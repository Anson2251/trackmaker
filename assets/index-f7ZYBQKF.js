var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a;
import { G as Vp, H as HC, I as XC, J as YC, d as nt, c as Ot, o as ut, a as xt, L as Ql, j as Ae, b as Ee, f as Fn, i as cr, M as Lh, q as Kt, k as Ei, p as Vr, h as B, m as ls, N as KC, O as Kb, t as zt, P as us, B as Wo, Q as eo, F as jr, w as Ao, R as za, S as JC, U as y0, V as QC, W as zn, X as e3, T as Jb, x as _r, Y as t3, Z as C_, $ as Fa, g as r3, a0 as cs, u as Gs, v as K, a1 as Dc, n as ha, A as Jt, _ as Ui, a2 as ns, a3 as i3, a4 as n3, a5 as Vi, a6 as zr, a7 as X0, a8 as Ng, C as fr, y as je, s as ze, z as vr, D as $c, a9 as o3, aa as tm, ab as un, ac as wh, ad as a3, ae as Qb, l as e1, af as s3, ag as l3, ah as Ea, ai as u3, aj as vc, ak as yc } from "./index-DL9s3iqV.js";
import { u as Gn } from "./vue-i18n-D73mg_te.js";
import { bq as c3, br as t1, bs as d3, b0 as vi, b3 as ql, bt as r1, bu as gh, bv as i1, bw as ln, bx as Qn, by as rm, bz as jg, aT as n1, a4 as he, a7 as Ue, ac as Cr, bA as Nc, b1 as Ch, bB as La, a3 as qe, a6 as Le, a8 as Sh, a9 as im, bC as to, aj as Nr, af as er, B as h3, ag as Ut, ah as ai, aa as Ul, bD as Y0, a_ as ci, bE as nm, bF as oi, ai as om, bG as Bh, ae as Ln, bH as f3, bI as p3, bJ as qo, bK as Wl, bL as m3, ab as am, bM as g3, bN as S_, b9 as jt, R as qn, bO as v3, b7 as k_, bi as K0, bP as y3, a5 as Up, ap as sm, bQ as _3, al as J0, am as lm, ao as Q0, an as ev, bR as o1, T as _0, bS as b3, bT as b0, bU as x3, bV as w3, b5 as Qi, bW as Ba, bX as Un, bY as co, bZ as um, b_ as C3, b$ as a1, c0 as s1, c1 as S3, $ as Kl, c2 as k3, c3 as T3, c4 as P3, c5 as I3, c6 as fa, r as ua, c7 as as, c8 as Zl, c9 as Fp, ca as ss, cb as Ls, cc as Ns, cd as Ec, ce as Hl, cf as l1, cg as x0, ch as w0, ci as C0, cj as vh, ck as S0, cl as k0, cm as T0, cn as Gp, co as u1, cp as c1, cq as d1, cr as Rc, cs as qp, ct as E3, cu as cm, cv as h1, bg as Or, cw as M3, b6 as Wp, b4 as D3, cx as R3, cy as Xl, cz as A3, a$ as f1, cA as p1, cB as z3, a0 as F3, aq as L3, cC as B3, cD as O3, cE as tv, cF as $3, cG as N3, cH as j3, cI as V3, c as Oh, cJ as Zp, cK as m1, cL as g1, cM as U3, cN as ca, cO as G3, cP as q3, cQ as W3, cR as v1, cS as Z3, cT as H3, cU as y1, cV as _1, cW as X3, cX as Y3, cY as K3, cZ as T_, c_ as J3, X as b1, c$ as Q3, d0 as eS, d1 as tS, d2 as rS, d3 as iS, d4 as nS, d5 as oS, d6 as Vg, d7 as aS, d8 as sS, d9 as x1, da as P_, db as lS, aV as I_, dc as w1, dd as Io, de as Eo, bh as xi, U as kh, b2 as C1, bd as jc, bc as uS, bm as rv, bo as yh, bp as S1, bf as is, bn as cS, df as Mo, bk as dS, be as k1, dg as hS, dh as fS, di as pS } from "./platform-DOaNk5vg.js";
var mS = /\s/;
function gS(r) {
  for (var n = r.length; n-- && mS.test(r.charAt(n)); ) ;
  return n;
}
var vS = /^\s+/;
function yS(r) {
  return r && r.slice(0, gS(r) + 1).replace(vS, "");
}
var E_ = NaN, _S = /^[-+]0x[0-9a-f]+$/i, bS = /^0b[01]+$/i, xS = /^0o[0-7]+$/i, wS = parseInt;
function _h(r) {
  if (typeof r == "number") return r;
  if (c3(r)) return E_;
  if (Vp(r)) {
    var n = typeof r.valueOf == "function" ? r.valueOf() : r;
    r = Vp(n) ? n + "" : n;
  }
  if (typeof r != "string") return r === 0 ? r : +r;
  r = yS(r);
  var l = bS.test(r);
  return l || xS.test(r) ? wS(r.slice(2), l ? 2 : 8) : _S.test(r) ? E_ : +r;
}
function CS(r, n, l, h) {
  for (var f = -1, y = r == null ? 0 : r.length; ++f < y; ) l = n(l, r[f], f, r);
  return l;
}
function SS(r) {
  return function(n) {
    return r == null ? void 0 : r[n];
  };
}
var kS = { \u00C0: "A", \u00C1: "A", \u00C2: "A", \u00C3: "A", \u00C4: "A", \u00C5: "A", \u00E0: "a", \u00E1: "a", \u00E2: "a", \u00E3: "a", \u00E4: "a", \u00E5: "a", \u00C7: "C", \u00E7: "c", \u00D0: "D", \u00F0: "d", \u00C8: "E", \u00C9: "E", \u00CA: "E", \u00CB: "E", \u00E8: "e", \u00E9: "e", \u00EA: "e", \u00EB: "e", \u00CC: "I", \u00CD: "I", \u00CE: "I", \u00CF: "I", \u00EC: "i", \u00ED: "i", \u00EE: "i", \u00EF: "i", \u00D1: "N", \u00F1: "n", \u00D2: "O", \u00D3: "O", \u00D4: "O", \u00D5: "O", \u00D6: "O", \u00D8: "O", \u00F2: "o", \u00F3: "o", \u00F4: "o", \u00F5: "o", \u00F6: "o", \u00F8: "o", \u00D9: "U", \u00DA: "U", \u00DB: "U", \u00DC: "U", \u00F9: "u", \u00FA: "u", \u00FB: "u", \u00FC: "u", \u00DD: "Y", \u00FD: "y", \u00FF: "y", \u00C6: "Ae", \u00E6: "ae", \u00DE: "Th", \u00FE: "th", \u00DF: "ss", \u0100: "A", \u0102: "A", \u0104: "A", \u0101: "a", \u0103: "a", \u0105: "a", \u0106: "C", \u0108: "C", \u010A: "C", \u010C: "C", \u0107: "c", \u0109: "c", \u010B: "c", \u010D: "c", \u010E: "D", \u0110: "D", \u010F: "d", \u0111: "d", \u0112: "E", \u0114: "E", \u0116: "E", \u0118: "E", \u011A: "E", \u0113: "e", \u0115: "e", \u0117: "e", \u0119: "e", \u011B: "e", \u011C: "G", \u011E: "G", \u0120: "G", \u0122: "G", \u011D: "g", \u011F: "g", \u0121: "g", \u0123: "g", \u0124: "H", \u0126: "H", \u0125: "h", \u0127: "h", \u0128: "I", \u012A: "I", \u012C: "I", \u012E: "I", \u0130: "I", \u0129: "i", \u012B: "i", \u012D: "i", \u012F: "i", \u0131: "i", \u0134: "J", \u0135: "j", \u0136: "K", \u0137: "k", \u0138: "k", \u0139: "L", \u013B: "L", \u013D: "L", \u013F: "L", \u0141: "L", \u013A: "l", \u013C: "l", \u013E: "l", \u0140: "l", \u0142: "l", \u0143: "N", \u0145: "N", \u0147: "N", \u014A: "N", \u0144: "n", \u0146: "n", \u0148: "n", \u014B: "n", \u014C: "O", \u014E: "O", \u0150: "O", \u014D: "o", \u014F: "o", \u0151: "o", \u0154: "R", \u0156: "R", \u0158: "R", \u0155: "r", \u0157: "r", \u0159: "r", \u015A: "S", \u015C: "S", \u015E: "S", \u0160: "S", \u015B: "s", \u015D: "s", \u015F: "s", \u0161: "s", \u0162: "T", \u0164: "T", \u0166: "T", \u0163: "t", \u0165: "t", \u0167: "t", \u0168: "U", \u016A: "U", \u016C: "U", \u016E: "U", \u0170: "U", \u0172: "U", \u0169: "u", \u016B: "u", \u016D: "u", \u016F: "u", \u0171: "u", \u0173: "u", \u0174: "W", \u0175: "w", \u0176: "Y", \u0177: "y", \u0178: "Y", \u0179: "Z", \u017B: "Z", \u017D: "Z", \u017A: "z", \u017C: "z", \u017E: "z", \u0132: "IJ", \u0133: "ij", \u0152: "Oe", \u0153: "oe", \u0149: "'n", \u017F: "s" }, TS = SS(kS), PS = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, IS = "\\u0300-\\u036f", ES = "\\ufe20-\\ufe2f", MS = "\\u20d0-\\u20ff", DS = IS + ES + MS, RS = "[" + DS + "]", AS = RegExp(RS, "g");
function zS(r) {
  return r = t1(r), r && r.replace(PS, TS).replace(AS, "");
}
var FS = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function LS(r) {
  return r.match(FS) || [];
}
var BS = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function OS(r) {
  return BS.test(r);
}
var T1 = "\\ud800-\\udfff", $S = "\\u0300-\\u036f", NS = "\\ufe20-\\ufe2f", jS = "\\u20d0-\\u20ff", VS = $S + NS + jS, P1 = "\\u2700-\\u27bf", I1 = "a-z\\xdf-\\xf6\\xf8-\\xff", US = "\\xac\\xb1\\xd7\\xf7", GS = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", qS = "\\u2000-\\u206f", WS = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", E1 = "A-Z\\xc0-\\xd6\\xd8-\\xde", ZS = "\\ufe0e\\ufe0f", M1 = US + GS + qS + WS, D1 = "['\u2019]", M_ = "[" + M1 + "]", HS = "[" + VS + "]", R1 = "\\d+", XS = "[" + P1 + "]", A1 = "[" + I1 + "]", z1 = "[^" + T1 + M1 + R1 + P1 + I1 + E1 + "]", YS = "\\ud83c[\\udffb-\\udfff]", KS = "(?:" + HS + "|" + YS + ")", JS = "[^" + T1 + "]", F1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", L1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", Pc = "[" + E1 + "]", QS = "\\u200d", D_ = "(?:" + A1 + "|" + z1 + ")", ek = "(?:" + Pc + "|" + z1 + ")", R_ = "(?:" + D1 + "(?:d|ll|m|re|s|t|ve))?", A_ = "(?:" + D1 + "(?:D|LL|M|RE|S|T|VE))?", B1 = KS + "?", O1 = "[" + ZS + "]?", tk = "(?:" + QS + "(?:" + [JS, F1, L1].join("|") + ")" + O1 + B1 + ")*", rk = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", ik = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", nk = O1 + B1 + tk, ok = "(?:" + [XS, F1, L1].join("|") + ")" + nk, ak = RegExp([Pc + "?" + A1 + "+" + R_ + "(?=" + [M_, Pc, "$"].join("|") + ")", ek + "+" + A_ + "(?=" + [M_, Pc + D_, "$"].join("|") + ")", Pc + "?" + D_ + "+" + R_, Pc + "+" + A_, ik, rk, R1, ok].join("|"), "g");
function sk(r) {
  return r.match(ak) || [];
}
function lk(r, n, l) {
  return r = t1(r), n = n, n === void 0 ? OS(r) ? sk(r) : LS(r) : r.match(n) || [];
}
var uk = "['\u2019]", ck = RegExp(uk, "g");
function dk(r) {
  return function(n) {
    return CS(lk(zS(n).replace(ck, "")), r, "");
  };
}
function hk(r, n, l) {
  return r === r && (l !== void 0 && (r = r <= l ? r : l), n !== void 0 && (r = r >= n ? r : n)), r;
}
function P0(r, n, l) {
  return l === void 0 && (l = n, n = void 0), l !== void 0 && (l = _h(l), l = l === l ? l : 0), n !== void 0 && (n = _h(n), n = n === n ? n : 0), hk(_h(r), n, l);
}
var Ug = function() {
  return HC.Date.now();
}, fk = "Expected a function", pk = Math.max, mk = Math.min;
function gk(r, n, l) {
  var h, f, y, p, s, S, P = 0, M = false, A = false, O = true;
  if (typeof r != "function") throw new TypeError(fk);
  n = _h(n) || 0, Vp(l) && (M = !!l.leading, A = "maxWait" in l, y = A ? pk(_h(l.maxWait) || 0, n) : y, O = "trailing" in l ? !!l.trailing : O);
  function j(ee) {
    var ke = h, ve = f;
    return h = f = void 0, P = ee, p = r.apply(ve, ke), p;
  }
  function L(ee) {
    return P = ee, s = setTimeout(J, n), M ? j(ee) : p;
  }
  function q(ee) {
    var ke = ee - S, ve = ee - P, le = n - ke;
    return A ? mk(le, y - ve) : le;
  }
  function N(ee) {
    var ke = ee - S, ve = ee - P;
    return S === void 0 || ke >= n || ke < 0 || A && ve >= y;
  }
  function J() {
    var ee = Ug();
    if (N(ee)) return te(ee);
    s = setTimeout(J, q(ee));
  }
  function te(ee) {
    return s = void 0, O && h ? j(ee) : (h = f = void 0, p);
  }
  function ne() {
    s !== void 0 && clearTimeout(s), P = 0, h = S = f = s = void 0;
  }
  function ae() {
    return s === void 0 ? p : te(Ug());
  }
  function oe() {
    var ee = Ug(), ke = N(ee);
    if (h = arguments, f = this, S = ee, ke) {
      if (s === void 0) return L(S);
      if (A) return clearTimeout(s), s = setTimeout(J, n), j(S);
    }
    return s === void 0 && (s = setTimeout(J, n)), p;
  }
  return oe.cancel = ne, oe.flush = ae, oe;
}
var vk = "[object Number]";
function yk(r) {
  return typeof r == "number" || XC(r) && YC(r) == vk;
}
var _k = dk(function(r, n, l) {
  return r + (l ? "-" : "") + n.toLowerCase();
}), bk = "Expected a function";
function xk(r, n, l) {
  var h = true, f = true;
  if (typeof r != "function") throw new TypeError(bk);
  return Vp(l) && (h = "leading" in l ? !!l.leading : h, f = "trailing" in l ? !!l.trailing : f), gk(r, n, { leading: h, maxWait: n, trailing: f });
}
const wk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Ck = nt({ name: "BrandGithub", render: function(n, l) {
  return ut(), Ot("svg", wk, l[0] || (l[0] = [xt("path", { d: "M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2c2.8-.3 5.5-1.4 5.5-6a4.6 4.6 0 0 0-1.3-3.2a4.2 4.2 0 0 0-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3 0 0 0-6.2 0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2 0 0 0-.1 3.2A4.6 4.6 0 0 0 4 9.5c0 4.6 2.7 5.7 5.5 6c-.6.6-.6 1.2-.5 2V21", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), Sk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, kk = nt({ name: "BuildingCommunity", render: function(n, l) {
  return ut(), Ot("svg", Sk, l[0] || (l[0] = [Ql('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 9l5 5v7H8v-4m0 4H3v-7l5-5m1 1V4a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v17h-8"></path><path d="M13 7v.01"></path><path d="M17 7v.01"></path><path d="M17 11v.01"></path><path d="M17 15v.01"></path></g>', 1)]));
} }), Tk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Pk = nt({ name: "Calendar", render: function(n, l) {
  return ut(), Ot("svg", Tk, l[0] || (l[0] = [Ql('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="5" width="16" height="16" rx="2"></rect><path d="M16 3v4"></path><path d="M8 3v4"></path><path d="M4 11h16"></path><path d="M11 15h1"></path><path d="M12 15v3"></path></g>', 1)]));
} }), Ik = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Ek = nt({ name: "CurrentLocation", render: function(n, l) {
  return ut(), Ot("svg", Ik, l[0] || (l[0] = [Ql('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><circle cx="12" cy="12" r="8"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="M20 12h2"></path><path d="M2 12h2"></path></g>', 1)]));
} }), Mk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Dk = nt({ name: "DeviceFloppy", render: function(n, l) {
  return ut(), Ot("svg", Mk, l[0] || (l[0] = [xt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [xt("path", { d: "M6 4h10l4 4v10a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2" }), xt("circle", { cx: "12", cy: "14", r: "2" }), xt("path", { d: "M14 4v4H8V4" })], -1)]));
} }), Rk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Ak = nt({ name: "Edit", render: function(n, l) {
  return ut(), Ot("svg", Rk, l[0] || (l[0] = [xt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [xt("path", { d: "M9 7H6a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h9a2 2 0 0 0 2-2v-3" }), xt("path", { d: "M9 15h3l8.5-8.5a1.5 1.5 0 0 0-3-3L9 12v3" }), xt("path", { d: "M16 5l3 3" })], -1)]));
} }), zk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, $1 = nt({ name: "FileText", render: function(n, l) {
  return ut(), Ot("svg", zk, l[0] || (l[0] = [Ql('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 3v4a1 1 0 0 0 1 1h4"></path><path d="M17 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7l5 5v11a2 2 0 0 1-2 2z"></path><path d="M9 9h1"></path><path d="M9 13h6"></path><path d="M9 17h6"></path></g>', 1)]));
} }), Fk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Lk = nt({ name: "Folder", render: function(n, l) {
  return ut(), Ot("svg", Fk, l[0] || (l[0] = [xt("path", { d: "M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), Bk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, N1 = nt({ name: "HandFinger", render: function(n, l) {
  return ut(), Ot("svg", Bk, l[0] || (l[0] = [Ql('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 13V4.5a1.5 1.5 0 0 1 3 0V12"></path><path d="M11 11.5v-2a1.5 1.5 0 1 1 3 0V12"></path><path d="M14 10.5a1.5 1.5 0 0 1 3 0V12"></path><path d="M17 11.5a1.5 1.5 0 0 1 3 0V16a6 6 0 0 1-6 6h-2h.208a6 6 0 0 1-5.012-2.7A69.74 69.74 0 0 1 7 19c-.312-.479-1.407-2.388-3.286-5.728a1.5 1.5 0 0 1 .536-2.022a1.867 1.867 0 0 1 2.28.28L8 13"></path></g>', 1)]));
} }), Ok = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, j1 = nt({ name: "Line", render: function(n, l) {
  return ut(), Ot("svg", Ok, l[0] || (l[0] = [xt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [xt("circle", { cx: "6", cy: "18", r: "2" }), xt("circle", { cx: "18", cy: "6", r: "2" }), xt("path", { d: "M7.5 16.5l9-9" })], -1)]));
} }), $k = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, z_ = nt({ name: "Link", render: function(n, l) {
  return ut(), Ot("svg", $k, l[0] || (l[0] = [xt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [xt("path", { d: "M10 14a3.5 3.5 0 0 0 5 0l4-4a3.5 3.5 0 0 0-5-5l-.5.5" }), xt("path", { d: "M14 10a3.5 3.5 0 0 0-5 0l-4 4a3.5 3.5 0 0 0 5 5l.5-.5" })], -1)]));
} }), Nk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, jk = nt({ name: "Minus", render: function(n, l) {
  return ut(), Ot("svg", Nk, l[0] || (l[0] = [xt("path", { d: "M5 12h14", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), Vk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Uk = nt({ name: "PlayerRecord", render: function(n, l) {
  return ut(), Ot("svg", Vk, l[0] || (l[0] = [xt("circle", { cx: "12", cy: "12", r: "7", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), Gk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Th = nt({ name: "Plus", render: function(n, l) {
  return ut(), Ot("svg", Gk, l[0] || (l[0] = [xt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [xt("path", { d: "M12 5v14" }), xt("path", { d: "M5 12h14" })], -1)]));
} }), qk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, iv = nt({ name: "Route", render: function(n, l) {
  return ut(), Ot("svg", qk, l[0] || (l[0] = [xt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [xt("circle", { cx: "6", cy: "19", r: "2" }), xt("circle", { cx: "18", cy: "5", r: "2" }), xt("path", { d: "M12 19h4.5a3.5 3.5 0 0 0 0-7h-8a3.5 3.5 0 0 1 0-7H12" })], -1)]));
} }), Wk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, V1 = nt({ name: "Shape", render: function(n, l) {
  return ut(), Ot("svg", Wk, l[0] || (l[0] = [Ql('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="5" cy="5" r="2"></circle><circle cx="19" cy="5" r="2"></circle><circle cx="5" cy="19" r="2"></circle><circle cx="19" cy="19" r="2"></circle><path d="M5 7v10"></path><path d="M7 5h10"></path><path d="M7 19h10"></path><path d="M19 7v10"></path></g>', 1)]));
} }), Zk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Hk = nt({ name: "Square", render: function(n, l) {
  return ut(), Ot("svg", Zk, l[0] || (l[0] = [xt("rect", { x: "4", y: "4", width: "16", height: "16", rx: "2", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), Xk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, dm = nt({ name: "Trash", render: function(n, l) {
  return ut(), Ot("svg", Xk, l[0] || (l[0] = [Ql('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 7h16"></path><path d="M10 11v6"></path><path d="M14 11v6"></path><path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2l1-12"></path><path d="M9 7V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3"></path></g>', 1)]));
} }), Yk = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, U1 = nt({ name: "Upload", render: function(n, l) {
  return ut(), Ot("svg", Yk, l[0] || (l[0] = [xt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [xt("path", { d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2" }), xt("path", { d: "M7 9l5-5l5 5" }), xt("path", { d: "M12 4v12" })], -1)]));
} });
function G1(r) {
  return typeof r == "string" ? document.querySelector(r) : typeof r == "function" ? r() : r;
}
function Kk(r) {
  if (typeof r == "number") return { "": r.toString() };
  const n = {};
  return r.split(/ +/).forEach((l) => {
    if (l === "") return;
    const [h, f] = l.split(":");
    f === void 0 ? n[""] = h : n[h] = f;
  }), n;
}
function _c(r, n) {
  var l;
  if (r == null) return;
  const h = Kk(r);
  if (n === void 0) return h[""];
  if (typeof n == "string") return (l = h[n]) !== null && l !== void 0 ? l : h[""];
  if (Array.isArray(n)) {
    for (let f = n.length - 1; f >= 0; --f) {
      const y = n[f];
      if (y in h) return h[y];
    }
    return h[""];
  } else {
    let f, y = -1;
    return Object.keys(h).forEach((p) => {
      const s = Number(p);
      !Number.isNaN(s) && n >= s && s >= y && (y = s, f = h[p]);
    }), f;
  }
}
const Jk = { xs: 0, s: 640, m: 1024, l: 1280, xl: 1536, "2xl": 1920 };
function Qk(r) {
  return `(min-width: ${r}px)`;
}
const ah = {};
function eT(r = Jk) {
  if (!d3) return Ae(() => []);
  if (typeof window.matchMedia != "function") return Ae(() => []);
  const n = Ee({}), l = Object.keys(r), h = (f, y) => {
    f.matches ? n.value[y] = true : n.value[y] = false;
  };
  return l.forEach((f) => {
    const y = r[f];
    let p, s;
    ah[y] === void 0 ? (p = window.matchMedia(Qk(y)), p.addEventListener ? p.addEventListener("change", (S) => {
      s.forEach((P) => {
        P(S, f);
      });
    }) : p.addListener && p.addListener((S) => {
      s.forEach((P) => {
        P(S, f);
      });
    }), s = /* @__PURE__ */ new Set(), ah[y] = { mql: p, cbs: s }) : (p = ah[y].mql, s = ah[y].cbs), s.add(h), p.matches && s.forEach((S) => {
      S(p, f);
    });
  }), Fn(() => {
    l.forEach((f) => {
      const { cbs: y } = ah[r[f]];
      y.has(h) && y.delete(h);
    });
  }), Ae(() => {
    const { value: f } = n;
    return l.filter((y) => f[y]);
  });
}
function tT(r, n, l) {
  var h;
  const f = cr(r, null);
  if (f === null) return;
  const y = (h = Lh()) === null || h === void 0 ? void 0 : h.proxy;
  Kt(l, p), p(l.value), Fn(() => {
    p(void 0, l.value);
  });
  function p(P, M) {
    if (!f) return;
    const A = f[n];
    M !== void 0 && s(A, M), P !== void 0 && S(A, P);
  }
  function s(P, M) {
    P[M] || (P[M] = []), P[M].splice(P[M].findIndex((A) => A === y), 1);
  }
  function S(P, M) {
    P[M] || (P[M] = []), ~P[M].findIndex((A) => A === y) || P[M].push(y);
  }
}
function rT(r, n, l) {
  const h = cr(r, null);
  h !== null && (n in h || (h[n] = []), h[n].push(l.value), Kt(l, (f, y) => {
    const p = h[n], s = p.findIndex((S) => S === y);
    ~s && p.splice(s, 1), p.push(f);
  }), Fn(() => {
    const f = h[n], y = f.findIndex((p) => p === l.value);
    ~y && f.splice(y, 1);
  }));
}
function iT(r, n, l) {
  const h = cr(r, null);
  h !== null && (n in h || (h[n] = []), Ei(() => {
    const f = l();
    f && h[n].push(f);
  }), Fn(() => {
    const f = h[n], y = l(), p = f.findIndex((s) => s === y);
    ~p && f.splice(p, 1);
  }));
}
function F_(r) {
  return r & -r;
}
class q1 {
  constructor(n, l) {
    this.l = n, this.min = l;
    const h = new Array(n + 1);
    for (let f = 0; f < n + 1; ++f) h[f] = 0;
    this.ft = h;
  }
  add(n, l) {
    if (l === 0) return;
    const { l: h, ft: f } = this;
    for (n += 1; n <= h; ) f[n] += l, n += F_(n);
  }
  get(n) {
    return this.sum(n + 1) - this.sum(n);
  }
  sum(n) {
    if (n === void 0 && (n = this.l), n <= 0) return 0;
    const { ft: l, min: h, l: f } = this;
    if (n > f) throw new Error("[FinweckTree.sum]: `i` is larger than length.");
    let y = n * h;
    for (; n > 0; ) y += l[n], n -= F_(n);
    return y;
  }
  getBound(n) {
    let l = 0, h = this.l;
    for (; h > l; ) {
      const f = Math.floor((l + h) / 2), y = this.sum(f);
      if (y > n) {
        h = f;
        continue;
      } else if (y < n) {
        if (l === f) return this.sum(l + 1) <= n ? l + 1 : f;
        l = f;
      } else return f;
    }
    return l;
  }
}
let _p;
function nT() {
  return typeof document > "u" ? false : (_p === void 0 && ("matchMedia" in window ? _p = window.matchMedia("(pointer:coarse)").matches : _p = false), _p);
}
let Gg;
function L_() {
  return typeof document > "u" ? 1 : (Gg === void 0 && (Gg = "chrome" in window ? window.devicePixelRatio : 1), Gg);
}
const W1 = "VVirtualListXScroll";
function oT({ columnsRef: r, renderColRef: n, renderItemWithColsRef: l }) {
  const h = Ee(0), f = Ee(0), y = Ae(() => {
    const P = r.value;
    if (P.length === 0) return null;
    const M = new q1(P.length, 0);
    return P.forEach((A, O) => {
      M.add(O, A.width);
    }), M;
  }), p = vi(() => {
    const P = y.value;
    return P !== null ? Math.max(P.getBound(f.value) - 1, 0) : 0;
  }), s = (P) => {
    const M = y.value;
    return M !== null ? M.sum(P) : 0;
  }, S = vi(() => {
    const P = y.value;
    return P !== null ? Math.min(P.getBound(f.value + h.value) + 1, r.value.length - 1) : 0;
  });
  return Vr(W1, { startIndexRef: p, endIndexRef: S, columnsRef: r, renderColRef: n, renderItemWithColsRef: l, getLeft: s }), { listWidthRef: h, scrollLeftRef: f };
}
const B_ = nt({ name: "VirtualListRow", props: { index: { type: Number, required: true }, item: { type: Object, required: true } }, setup() {
  const { startIndexRef: r, endIndexRef: n, columnsRef: l, getLeft: h, renderColRef: f, renderItemWithColsRef: y } = cr(W1);
  return { startIndex: r, endIndex: n, columns: l, renderCol: f, renderItemWithCols: y, getLeft: h };
}, render() {
  const { startIndex: r, endIndex: n, columns: l, renderCol: h, renderItemWithCols: f, getLeft: y, item: p } = this;
  if (f != null) return f({ itemIndex: this.index, startColIndex: r, endColIndex: n, allColumns: l, item: p, getLeft: y });
  if (h != null) {
    const s = [];
    for (let S = r; S <= n; ++S) {
      const P = l[S];
      s.push(h({ column: P, left: y(S), item: p }));
    }
    return s;
  }
  return null;
} }), aT = gh(".v-vl", { maxHeight: "inherit", height: "100%", overflow: "auto", minWidth: "1px" }, [gh("&:not(.v-vl--show-scrollbar)", { scrollbarWidth: "none" }, [gh("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", { width: 0, height: 0, display: "none" })])]), sT = nt({ name: "VirtualList", inheritAttrs: false, props: { showScrollbar: { type: Boolean, default: true }, columns: { type: Array, default: () => [] }, renderCol: Function, renderItemWithCols: Function, items: { type: Array, default: () => [] }, itemSize: { type: Number, required: true }, itemResizable: Boolean, itemsStyle: [String, Object], visibleItemsTag: { type: [String, Object], default: "div" }, visibleItemsProps: Object, ignoreItemResize: Boolean, onScroll: Function, onWheel: Function, onResize: Function, defaultScrollKey: [Number, String], defaultScrollIndex: Number, keyField: { type: String, default: "key" }, paddingTop: { type: [Number, String], default: 0 }, paddingBottom: { type: [Number, String], default: 0 } }, setup(r) {
  const n = r1();
  aT.mount({ id: "vueuc/virtual-list", head: true, anchorMetaName: i1, ssr: n }), Ei(() => {
    const { defaultScrollIndex: Ge, defaultScrollKey: et } = r;
    Ge != null ? N({ index: Ge }) : et != null && N({ key: et });
  });
  let l = false, h = false;
  KC(() => {
    if (l = false, !h) {
      h = true;
      return;
    }
    N({ top: j.value, left: p.value });
  }), Kb(() => {
    l = true, h || (h = true);
  });
  const f = vi(() => {
    if (r.renderCol == null && r.renderItemWithCols == null || r.columns.length === 0) return;
    let Ge = 0;
    return r.columns.forEach((et) => {
      Ge += et.width;
    }), Ge;
  }), y = Ae(() => {
    const Ge = /* @__PURE__ */ new Map(), { keyField: et } = r;
    return r.items.forEach((dt, Ct) => {
      Ge.set(dt[et], Ct);
    }), Ge;
  }), { scrollLeftRef: p, listWidthRef: s } = oT({ columnsRef: zt(r, "columns"), renderColRef: zt(r, "renderCol"), renderItemWithColsRef: zt(r, "renderItemWithCols") }), S = Ee(null), P = Ee(void 0), M = /* @__PURE__ */ new Map(), A = Ae(() => {
    const { items: Ge, itemSize: et, keyField: dt } = r, Ct = new q1(Ge.length, et);
    return Ge.forEach((kt, ct) => {
      const it = kt[dt], pt = M.get(it);
      pt !== void 0 && Ct.add(ct, pt);
    }), Ct;
  }), O = Ee(0), j = Ee(0), L = vi(() => Math.max(A.value.getBound(j.value - ln(r.paddingTop)) - 1, 0)), q = Ae(() => {
    const { value: Ge } = P;
    if (Ge === void 0) return [];
    const { items: et, itemSize: dt } = r, Ct = L.value, kt = Math.min(Ct + Math.ceil(Ge / dt + 1), et.length - 1), ct = [];
    for (let it = Ct; it <= kt; ++it) ct.push(et[it]);
    return ct;
  }), N = (Ge, et) => {
    if (typeof Ge == "number") {
      ae(Ge, et, "auto");
      return;
    }
    const { left: dt, top: Ct, index: kt, key: ct, position: it, behavior: pt, debounce: $t = true } = Ge;
    if (dt !== void 0 || Ct !== void 0) ae(dt, Ct, pt);
    else if (kt !== void 0) ne(kt, pt, $t);
    else if (ct !== void 0) {
      const vt = y.value.get(ct);
      vt !== void 0 && ne(vt, pt, $t);
    } else it === "bottom" ? ae(0, Number.MAX_SAFE_INTEGER, pt) : it === "top" && ae(0, 0, pt);
  };
  let J, te = null;
  function ne(Ge, et, dt) {
    const { value: Ct } = A, kt = Ct.sum(Ge) + ln(r.paddingTop);
    if (!dt) S.value.scrollTo({ left: 0, top: kt, behavior: et });
    else {
      J = Ge, te !== null && window.clearTimeout(te), te = window.setTimeout(() => {
        J = void 0, te = null;
      }, 16);
      const { scrollTop: ct, offsetHeight: it } = S.value;
      if (kt > ct) {
        const pt = Ct.get(Ge);
        kt + pt <= ct + it || S.value.scrollTo({ left: 0, top: kt + pt - it, behavior: et });
      } else S.value.scrollTo({ left: 0, top: kt, behavior: et });
    }
  }
  function ae(Ge, et, dt) {
    S.value.scrollTo({ left: Ge, top: et, behavior: dt });
  }
  function oe(Ge, et) {
    var dt, Ct, kt;
    if (l || r.ignoreItemResize || Ve(et.target)) return;
    const { value: ct } = A, it = y.value.get(Ge), pt = ct.get(it), $t = (kt = (Ct = (dt = et.borderBoxSize) === null || dt === void 0 ? void 0 : dt[0]) === null || Ct === void 0 ? void 0 : Ct.blockSize) !== null && kt !== void 0 ? kt : et.contentRect.height;
    if ($t === pt) return;
    $t - r.itemSize === 0 ? M.delete(Ge) : M.set(Ge, $t - r.itemSize);
    const Pt = $t - pt;
    if (Pt === 0) return;
    ct.add(it, Pt);
    const Nt = S.value;
    if (Nt != null) {
      if (J === void 0) {
        const ir = ct.sum(it);
        Nt.scrollTop > ir && Nt.scrollBy(0, Pt);
      } else if (it < J) Nt.scrollBy(0, Pt);
      else if (it === J) {
        const ir = ct.sum(it);
        $t + ir > Nt.scrollTop + Nt.offsetHeight && Nt.scrollBy(0, Pt);
      }
      be();
    }
    O.value++;
  }
  const ee = !nT();
  let ke = false;
  function ve(Ge) {
    var et;
    (et = r.onScroll) === null || et === void 0 || et.call(r, Ge), (!ee || !ke) && be();
  }
  function le(Ge) {
    var et;
    if ((et = r.onWheel) === null || et === void 0 || et.call(r, Ge), ee) {
      const dt = S.value;
      if (dt != null) {
        if (Ge.deltaX === 0 && (dt.scrollTop === 0 && Ge.deltaY <= 0 || dt.scrollTop + dt.offsetHeight >= dt.scrollHeight && Ge.deltaY >= 0)) return;
        Ge.preventDefault(), dt.scrollTop += Ge.deltaY / L_(), dt.scrollLeft += Ge.deltaX / L_(), be(), ke = true, rm(() => {
          ke = false;
        });
      }
    }
  }
  function ue(Ge) {
    if (l || Ve(Ge.target)) return;
    if (r.renderCol == null && r.renderItemWithCols == null) {
      if (Ge.contentRect.height === P.value) return;
    } else if (Ge.contentRect.height === P.value && Ge.contentRect.width === s.value) return;
    P.value = Ge.contentRect.height, s.value = Ge.contentRect.width;
    const { onResize: et } = r;
    et !== void 0 && et(Ge);
  }
  function be() {
    const { value: Ge } = S;
    Ge != null && (j.value = Ge.scrollTop, p.value = Ge.scrollLeft);
  }
  function Ve(Ge) {
    let et = Ge;
    for (; et !== null; ) {
      if (et.style.display === "none") return true;
      et = et.parentElement;
    }
    return false;
  }
  return { listHeight: P, listStyle: { overflow: "auto" }, keyToIndex: y, itemsStyle: Ae(() => {
    const { itemResizable: Ge } = r, et = Qn(A.value.sum());
    return O.value, [r.itemsStyle, { boxSizing: "content-box", width: Qn(f.value), height: Ge ? "" : et, minHeight: Ge ? et : "", paddingTop: Qn(r.paddingTop), paddingBottom: Qn(r.paddingBottom) }];
  }), visibleItemsStyle: Ae(() => (O.value, { transform: `translateY(${Qn(A.value.sum(L.value))})` })), viewportItems: q, listElRef: S, itemsElRef: Ee(null), scrollTo: N, handleListResize: ue, handleListScroll: ve, handleListWheel: le, handleItemResize: oe };
}, render() {
  const { itemResizable: r, keyField: n, keyToIndex: l, visibleItemsTag: h } = this;
  return B(ql, { onResize: this.handleListResize }, { default: () => {
    var f, y;
    return B("div", ls(this.$attrs, { class: ["v-vl", this.showScrollbar && "v-vl--show-scrollbar"], onScroll: this.handleListScroll, onWheel: this.handleListWheel, ref: "listElRef" }), [this.items.length !== 0 ? B("div", { ref: "itemsElRef", class: "v-vl-items", style: this.itemsStyle }, [B(h, Object.assign({ class: "v-vl-visible-items", style: this.visibleItemsStyle }, this.visibleItemsProps), { default: () => {
      const { renderCol: p, renderItemWithCols: s } = this;
      return this.viewportItems.map((S) => {
        const P = S[n], M = l.get(P), A = p != null ? B(B_, { index: M, item: S }) : void 0, O = s != null ? B(B_, { index: M, item: S }) : void 0, j = this.$slots.default({ item: S, renderedCols: A, renderedItemWithCols: O, index: M })[0];
        return r ? B(ql, { key: P, onResize: (L) => this.handleItemResize(P, L) }, { default: () => j }) : (j.key = P, j);
      });
    } })]) : (y = (f = this.$slots).empty) === null || y === void 0 ? void 0 : y.call(f)]);
  } });
} }), lT = gh(".v-x-scroll", { overflow: "auto", scrollbarWidth: "none" }, [gh("&::-webkit-scrollbar", { width: 0, height: 0 })]), uT = nt({ name: "XScroll", props: { disabled: Boolean, onScroll: Function }, setup() {
  const r = Ee(null);
  function n(f) {
    !(f.currentTarget.offsetWidth < f.currentTarget.scrollWidth) || f.deltaY === 0 || (f.currentTarget.scrollLeft += f.deltaY + f.deltaX, f.preventDefault());
  }
  const l = r1();
  return lT.mount({ id: "vueuc/x-scroll", head: true, anchorMetaName: i1, ssr: l }), Object.assign({ selfRef: r, handleWheel: n }, { scrollTo(...f) {
    var y;
    (y = r.value) === null || y === void 0 || y.scrollTo(...f);
  } });
}, render() {
  return B("div", { ref: "selfRef", onScroll: this.onScroll, onWheel: this.disabled ? void 0 : this.handleWheel, class: "v-x-scroll" }, this.$slots);
} });
function Z1(r, n) {
  n && (Ei(() => {
    const { value: l } = r;
    l && jg.registerHandler(l, n);
  }), Kt(r, (l, h) => {
    h && jg.unregisterHandler(h);
  }, { deep: false }), Fn(() => {
    const { value: l } = r;
    l && jg.unregisterHandler(l);
  }));
}
function H1(r, n) {
  if (!r) return;
  const l = document.createElement("a");
  l.href = r, n !== void 0 && (l.download = n), document.body.appendChild(l), l.click(), document.body.removeChild(l);
}
function I0(r) {
  switch (typeof r) {
    case "string":
      return r || void 0;
    case "number":
      return String(r);
    default:
      return;
  }
}
const cT = { tiny: "mini", small: "tiny", medium: "small", large: "medium", huge: "large" };
function dT(r) {
  const n = cT[r];
  if (n === void 0) throw new Error(`${r} has no smaller size.`);
  return n;
}
function hm(r, n = "default", l = []) {
  const f = r.$slots[n];
  return f === void 0 ? l : f();
}
function hT(r) {
  var n;
  const l = (n = r.dirs) === null || n === void 0 ? void 0 : n.find(({ dir: h }) => h === us);
  return !!(l && l.value === false);
}
function qg(r) {
  const n = r.filter((l) => l !== void 0);
  if (n.length !== 0) return n.length === 1 ? n[0] : (l) => {
    r.forEach((h) => {
      h && h(l);
    });
  };
}
const fT = { name: "en-US", global: { undo: "Undo", redo: "Redo", confirm: "Confirm", clear: "Clear" }, Popconfirm: { positiveText: "Confirm", negativeText: "Cancel" }, Cascader: { placeholder: "Please Select", loading: "Loading", loadingRequiredMessage: (r) => `Please load all ${r}'s descendants before checking it.` }, Time: { dateFormat: "yyyy-MM-dd", dateTimeFormat: "yyyy-MM-dd HH:mm:ss" }, DatePicker: { yearFormat: "yyyy", monthFormat: "MMM", dayFormat: "eeeeee", yearTypeFormat: "yyyy", monthTypeFormat: "yyyy-MM", dateFormat: "yyyy-MM-dd", dateTimeFormat: "yyyy-MM-dd HH:mm:ss", quarterFormat: "yyyy-qqq", weekFormat: "YYYY-w", clear: "Clear", now: "Now", confirm: "Confirm", selectTime: "Select Time", selectDate: "Select Date", datePlaceholder: "Select Date", datetimePlaceholder: "Select Date and Time", monthPlaceholder: "Select Month", yearPlaceholder: "Select Year", quarterPlaceholder: "Select Quarter", weekPlaceholder: "Select Week", startDatePlaceholder: "Start Date", endDatePlaceholder: "End Date", startDatetimePlaceholder: "Start Date and Time", endDatetimePlaceholder: "End Date and Time", startMonthPlaceholder: "Start Month", endMonthPlaceholder: "End Month", monthBeforeYear: true, firstDayOfWeek: 6, today: "Today" }, DataTable: { checkTableAll: "Select all in the table", uncheckTableAll: "Unselect all in the table", confirm: "Confirm", clear: "Clear" }, LegacyTransfer: { sourceTitle: "Source", targetTitle: "Target" }, Transfer: { selectAll: "Select all", unselectAll: "Unselect all", clearAll: "Clear", total: (r) => `Total ${r} items`, selected: (r) => `${r} items selected` }, Empty: { description: "No Data" }, Select: { placeholder: "Please Select" }, TimePicker: { placeholder: "Select Time", positiveText: "OK", negativeText: "Cancel", now: "Now", clear: "Clear" }, Pagination: { goto: "Goto", selectionSuffix: "page" }, DynamicTags: { add: "Add" }, Log: { loading: "Loading" }, Input: { placeholder: "Please Input" }, InputNumber: { placeholder: "Please Input" }, DynamicInput: { create: "Create" }, ThemeEditor: { title: "Theme Editor", clearAllVars: "Clear All Variables", clearSearch: "Clear Search", filterCompName: "Filter Component Name", filterVarName: "Filter Variable Name", import: "Import", export: "Export", restore: "Reset to Default" }, Image: { tipPrevious: "Previous picture (\u2190)", tipNext: "Next picture (\u2192)", tipCounterclockwise: "Counterclockwise", tipClockwise: "Clockwise", tipZoomOut: "Zoom out", tipZoomIn: "Zoom in", tipDownload: "Download", tipClose: "Close (Esc)", tipOriginalSize: "Zoom to original size" }, Heatmap: { less: "less", more: "more", monthFormat: "MMM", weekdayFormat: "eee" } };
function Wg(r) {
  return (n = {}) => {
    const l = n.width ? String(n.width) : r.defaultWidth;
    return r.formats[l] || r.formats[r.defaultWidth];
  };
}
function sh(r) {
  return (n, l) => {
    const h = (l == null ? void 0 : l.context) ? String(l.context) : "standalone";
    let f;
    if (h === "formatting" && r.formattingValues) {
      const p = r.defaultFormattingWidth || r.defaultWidth, s = (l == null ? void 0 : l.width) ? String(l.width) : p;
      f = r.formattingValues[s] || r.formattingValues[p];
    } else {
      const p = r.defaultWidth, s = (l == null ? void 0 : l.width) ? String(l.width) : r.defaultWidth;
      f = r.values[s] || r.values[p];
    }
    const y = r.argumentCallback ? r.argumentCallback(n) : n;
    return f[y];
  };
}
function lh(r) {
  return (n, l = {}) => {
    const h = l.width, f = h && r.matchPatterns[h] || r.matchPatterns[r.defaultMatchWidth], y = n.match(f);
    if (!y) return null;
    const p = y[0], s = h && r.parsePatterns[h] || r.parsePatterns[r.defaultParseWidth], S = Array.isArray(s) ? mT(s, (A) => A.test(p)) : pT(s, (A) => A.test(p));
    let P;
    P = r.valueCallback ? r.valueCallback(S) : S, P = l.valueCallback ? l.valueCallback(P) : P;
    const M = n.slice(p.length);
    return { value: P, rest: M };
  };
}
function pT(r, n) {
  for (const l in r) if (Object.prototype.hasOwnProperty.call(r, l) && n(r[l])) return l;
}
function mT(r, n) {
  for (let l = 0; l < r.length; l++) if (n(r[l])) return l;
}
function gT(r) {
  return (n, l = {}) => {
    const h = n.match(r.matchPattern);
    if (!h) return null;
    const f = h[0], y = n.match(r.parsePattern);
    if (!y) return null;
    let p = r.valueCallback ? r.valueCallback(y[0]) : y[0];
    p = l.valueCallback ? l.valueCallback(p) : p;
    const s = n.slice(f.length);
    return { value: p, rest: s };
  };
}
const vT = { lessThanXSeconds: { one: "less than a second", other: "less than {{count}} seconds" }, xSeconds: { one: "1 second", other: "{{count}} seconds" }, halfAMinute: "half a minute", lessThanXMinutes: { one: "less than a minute", other: "less than {{count}} minutes" }, xMinutes: { one: "1 minute", other: "{{count}} minutes" }, aboutXHours: { one: "about 1 hour", other: "about {{count}} hours" }, xHours: { one: "1 hour", other: "{{count}} hours" }, xDays: { one: "1 day", other: "{{count}} days" }, aboutXWeeks: { one: "about 1 week", other: "about {{count}} weeks" }, xWeeks: { one: "1 week", other: "{{count}} weeks" }, aboutXMonths: { one: "about 1 month", other: "about {{count}} months" }, xMonths: { one: "1 month", other: "{{count}} months" }, aboutXYears: { one: "about 1 year", other: "about {{count}} years" }, xYears: { one: "1 year", other: "{{count}} years" }, overXYears: { one: "over 1 year", other: "over {{count}} years" }, almostXYears: { one: "almost 1 year", other: "almost {{count}} years" } }, yT = (r, n, l) => {
  let h;
  const f = vT[r];
  return typeof f == "string" ? h = f : n === 1 ? h = f.one : h = f.other.replace("{{count}}", n.toString()), (l == null ? void 0 : l.addSuffix) ? l.comparison && l.comparison > 0 ? "in " + h : h + " ago" : h;
}, _T = { lastWeek: "'last' eeee 'at' p", yesterday: "'yesterday at' p", today: "'today at' p", tomorrow: "'tomorrow at' p", nextWeek: "eeee 'at' p", other: "P" }, bT = (r, n, l, h) => _T[r], xT = { narrow: ["B", "A"], abbreviated: ["BC", "AD"], wide: ["Before Christ", "Anno Domini"] }, wT = { narrow: ["1", "2", "3", "4"], abbreviated: ["Q1", "Q2", "Q3", "Q4"], wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"] }, CT = { narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, ST = { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, kT = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" } }, TT = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" } }, PT = (r, n) => {
  const l = Number(r), h = l % 100;
  if (h > 20 || h < 10) switch (h % 10) {
    case 1:
      return l + "st";
    case 2:
      return l + "nd";
    case 3:
      return l + "rd";
  }
  return l + "th";
}, IT = { ordinalNumber: PT, era: sh({ values: xT, defaultWidth: "wide" }), quarter: sh({ values: wT, defaultWidth: "wide", argumentCallback: (r) => r - 1 }), month: sh({ values: CT, defaultWidth: "wide" }), day: sh({ values: ST, defaultWidth: "wide" }), dayPeriod: sh({ values: kT, defaultWidth: "wide", formattingValues: TT, defaultFormattingWidth: "wide" }) }, ET = /^(\d+)(th|st|nd|rd)?/i, MT = /\d+/i, DT = { narrow: /^(b|a)/i, abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i, wide: /^(before christ|before common era|anno domini|common era)/i }, RT = { any: [/^b/i, /^(a|c)/i] }, AT = { narrow: /^[1234]/i, abbreviated: /^q[1234]/i, wide: /^[1234](th|st|nd|rd)? quarter/i }, zT = { any: [/1/i, /2/i, /3/i, /4/i] }, FT = { narrow: /^[jfmasond]/i, abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i, wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i }, LT = { narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i], any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i] }, BT = { narrow: /^[smtwf]/i, short: /^(su|mo|tu|we|th|fr|sa)/i, abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i, wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i }, OT = { narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i], any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i] }, $T = { narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i, any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i }, NT = { any: { am: /^a/i, pm: /^p/i, midnight: /^mi/i, noon: /^no/i, morning: /morning/i, afternoon: /afternoon/i, evening: /evening/i, night: /night/i } }, jT = { ordinalNumber: gT({ matchPattern: ET, parsePattern: MT, valueCallback: (r) => parseInt(r, 10) }), era: lh({ matchPatterns: DT, defaultMatchWidth: "wide", parsePatterns: RT, defaultParseWidth: "any" }), quarter: lh({ matchPatterns: AT, defaultMatchWidth: "wide", parsePatterns: zT, defaultParseWidth: "any", valueCallback: (r) => r + 1 }), month: lh({ matchPatterns: FT, defaultMatchWidth: "wide", parsePatterns: LT, defaultParseWidth: "any" }), day: lh({ matchPatterns: BT, defaultMatchWidth: "wide", parsePatterns: OT, defaultParseWidth: "any" }), dayPeriod: lh({ matchPatterns: $T, defaultMatchWidth: "any", parsePatterns: NT, defaultParseWidth: "any" }) }, VT = { full: "EEEE, MMMM do, y", long: "MMMM do, y", medium: "MMM d, y", short: "MM/dd/yyyy" }, UT = { full: "h:mm:ss a zzzz", long: "h:mm:ss a z", medium: "h:mm:ss a", short: "h:mm a" }, GT = { full: "{{date}} 'at' {{time}}", long: "{{date}} 'at' {{time}}", medium: "{{date}}, {{time}}", short: "{{date}}, {{time}}" }, qT = { date: Wg({ formats: VT, defaultWidth: "full" }), time: Wg({ formats: UT, defaultWidth: "full" }), dateTime: Wg({ formats: GT, defaultWidth: "full" }) }, WT = { code: "en-US", formatDistance: yT, formatLong: qT, formatRelative: bT, localize: IT, match: jT, options: { weekStartsOn: 0, firstWeekContainsDate: 1 } }, ZT = { name: "en-US", locale: WT };
function ds(r) {
  const { mergedLocaleRef: n, mergedDateLocaleRef: l } = cr(n1, null) || {}, h = Ae(() => {
    var y, p;
    return (p = (y = n == null ? void 0 : n.value) === null || y === void 0 ? void 0 : y[r]) !== null && p !== void 0 ? p : fT[r];
  });
  return { dateLocaleRef: Ae(() => {
    var y;
    return (y = l == null ? void 0 : l.value) !== null && y !== void 0 ? y : ZT;
  }), localeRef: h };
}
const HT = he("affix", [Ue("affixed", { position: "fixed" }, [Ue("absolute-positioned", { position: "absolute" })])]);
function XT(r) {
  return r instanceof HTMLElement ? r.scrollTop : window.scrollY;
}
function YT(r) {
  return r instanceof HTMLElement ? r.getBoundingClientRect() : { top: 0, bottom: window.innerHeight };
}
const nv = { listenTo: [String, Object, Function], top: Number, bottom: Number, triggerTop: Number, triggerBottom: Number, position: { type: String, default: "fixed" }, offsetTop: { type: Number, validator: () => true, default: void 0 }, offsetBottom: { type: Number, validator: () => true, default: void 0 }, target: { type: Function, validator: () => true, default: void 0 } }, KT = Ch(nv), JT = nt({ name: "Affix", props: nv, setup(r) {
  const { mergedClsPrefixRef: n } = Cr(r);
  Nc("-affix", HT, n);
  let l = null;
  const h = Ee(false), f = Ee(false), y = Ee(null), p = Ee(null), s = Ae(() => f.value || h.value), S = Ae(() => {
    var N, J;
    return (J = (N = r.triggerTop) !== null && N !== void 0 ? N : r.offsetTop) !== null && J !== void 0 ? J : r.top;
  }), P = Ae(() => {
    var N, J;
    return (J = (N = r.top) !== null && N !== void 0 ? N : r.triggerTop) !== null && J !== void 0 ? J : r.offsetTop;
  }), M = Ae(() => {
    var N, J;
    return (J = (N = r.bottom) !== null && N !== void 0 ? N : r.triggerBottom) !== null && J !== void 0 ? J : r.offsetBottom;
  }), A = Ae(() => {
    var N, J;
    return (J = (N = r.triggerBottom) !== null && N !== void 0 ? N : r.offsetBottom) !== null && J !== void 0 ? J : r.bottom;
  }), O = Ee(null), j = () => {
    const { target: N, listenTo: J } = r;
    N ? l = N() : J ? l = G1(J) : l = document, l && (l.addEventListener("scroll", L), L());
  };
  function L() {
    rm(q);
  }
  function q() {
    const { value: N } = O;
    if (!l || !N) return;
    const J = XT(l);
    if (s.value) {
      p.value !== null && J < p.value && (h.value = false, p.value = null), y.value !== null && J > y.value && (f.value = false, y.value = null);
      return;
    }
    const te = YT(l), ne = N.getBoundingClientRect(), ae = ne.top - te.top, oe = te.bottom - ne.bottom, ee = S.value, ke = A.value;
    ee !== void 0 && ae <= ee ? (h.value = true, p.value = J - (ee - ae)) : (h.value = false, p.value = null), ke !== void 0 && oe <= ke ? (f.value = true, y.value = J + ke - oe) : (f.value = false, y.value = null);
  }
  return Ei(() => {
    j();
  }), Fn(() => {
    l && l.removeEventListener("scroll", L);
  }), { selfRef: O, affixed: s, mergedClsPrefix: n, mergedstyle: Ae(() => {
    const N = {};
    return h.value && S.value !== void 0 && P.value !== void 0 && (N.top = `${P.value}px`), f.value && A.value !== void 0 && M.value !== void 0 && (N.bottom = `${M.value}px`), N;
  }) };
}, render() {
  const { mergedClsPrefix: r } = this;
  return B("div", { ref: "selfRef", class: [`${r}-affix`, { [`${r}-affix--affixed`]: this.affixed, [`${r}-affix--absolute-positioned`]: this.position === "absolute" }], style: this.mergedstyle }, this.$slots);
} }), fm = nt({ name: "Add", render() {
  return B("svg", { width: "512", height: "512", viewBox: "0 0 512 512", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M256 112V400M400 256H112", stroke: "currentColor", "stroke-width": "32", "stroke-linecap": "round", "stroke-linejoin": "round" }));
} }), QT = La("attach", () => B("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, B("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, B("g", { fill: "currentColor", "fill-rule": "nonzero" }, B("path", { d: "M3.25735931,8.70710678 L7.85355339,4.1109127 C8.82986412,3.13460197 10.4127766,3.13460197 11.3890873,4.1109127 C12.365398,5.08722343 12.365398,6.67013588 11.3890873,7.64644661 L6.08578644,12.9497475 C5.69526215,13.3402718 5.06209717,13.3402718 4.67157288,12.9497475 C4.28104858,12.5592232 4.28104858,11.9260582 4.67157288,11.5355339 L9.97487373,6.23223305 C10.1701359,6.0369709 10.1701359,5.72038841 9.97487373,5.52512627 C9.77961159,5.32986412 9.4630291,5.32986412 9.26776695,5.52512627 L3.96446609,10.8284271 C3.18341751,11.6094757 3.18341751,12.8758057 3.96446609,13.6568542 C4.74551468,14.4379028 6.01184464,14.4379028 6.79289322,13.6568542 L12.0961941,8.35355339 C13.4630291,6.98671837 13.4630291,4.77064094 12.0961941,3.40380592 C10.7293591,2.0369709 8.51328163,2.0369709 7.14644661,3.40380592 L2.55025253,8 C2.35499039,8.19526215 2.35499039,8.51184464 2.55025253,8.70710678 C2.74551468,8.90236893 3.06209717,8.90236893 3.25735931,8.70710678 Z" }))))), eP = La("cancel", () => B("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, B("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, B("g", { fill: "currentColor", "fill-rule": "nonzero" }, B("path", { d: "M2.58859116,2.7156945 L2.64644661,2.64644661 C2.82001296,2.47288026 3.08943736,2.45359511 3.2843055,2.58859116 L3.35355339,2.64644661 L8,7.293 L12.6464466,2.64644661 C12.8417088,2.45118446 13.1582912,2.45118446 13.3535534,2.64644661 C13.5488155,2.84170876 13.5488155,3.15829124 13.3535534,3.35355339 L8.707,8 L13.3535534,12.6464466 C13.5271197,12.820013 13.5464049,13.0894374 13.4114088,13.2843055 L13.3535534,13.3535534 C13.179987,13.5271197 12.9105626,13.5464049 12.7156945,13.4114088 L12.6464466,13.3535534 L8,8.707 L3.35355339,13.3535534 C3.15829124,13.5488155 2.84170876,13.5488155 2.64644661,13.3535534 C2.45118446,13.1582912 2.45118446,12.8417088 2.64644661,12.6464466 L7.293,8 L2.64644661,3.35355339 C2.47288026,3.17998704 2.45359511,2.91056264 2.58859116,2.7156945 L2.64644661,2.64644661 L2.58859116,2.7156945 Z" }))))), tP = nt({ name: "Checkmark", render() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16" }, B("g", { fill: "none" }, B("path", { d: "M14.046 3.486a.75.75 0 0 1-.032 1.06l-7.93 7.474a.85.85 0 0 1-1.188-.022l-2.68-2.72a.75.75 0 1 1 1.068-1.053l2.234 2.267l7.468-7.038a.75.75 0 0 1 1.06.032z", fill: "currentColor" })));
} }), rP = nt({ name: "ChevronDown", render() {
  return B("svg", { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M3.14645 5.64645C3.34171 5.45118 3.65829 5.45118 3.85355 5.64645L8 9.79289L12.1464 5.64645C12.3417 5.45118 12.6583 5.45118 12.8536 5.64645C13.0488 5.84171 13.0488 6.15829 12.8536 6.35355L8.35355 10.8536C8.15829 11.0488 7.84171 11.0488 7.64645 10.8536L3.14645 6.35355C2.95118 6.15829 2.95118 5.84171 3.14645 5.64645Z", fill: "currentColor" }));
} }), iP = nt({ name: "ChevronLeft", render() {
  return B("svg", { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M10.3536 3.14645C10.5488 3.34171 10.5488 3.65829 10.3536 3.85355L6.20711 8L10.3536 12.1464C10.5488 12.3417 10.5488 12.6583 10.3536 12.8536C10.1583 13.0488 9.84171 13.0488 9.64645 12.8536L5.14645 8.35355C4.95118 8.15829 4.95118 7.84171 5.14645 7.64645L9.64645 3.14645C9.84171 2.95118 10.1583 2.95118 10.3536 3.14645Z", fill: "currentColor" }));
} }), nP = La("clear", () => B("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, B("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, B("g", { fill: "currentColor", "fill-rule": "nonzero" }, B("path", { d: "M8,2 C11.3137085,2 14,4.6862915 14,8 C14,11.3137085 11.3137085,14 8,14 C4.6862915,14 2,11.3137085 2,8 C2,4.6862915 4.6862915,2 8,2 Z M6.5343055,5.83859116 C6.33943736,5.70359511 6.07001296,5.72288026 5.89644661,5.89644661 L5.89644661,5.89644661 L5.83859116,5.9656945 C5.70359511,6.16056264 5.72288026,6.42998704 5.89644661,6.60355339 L5.89644661,6.60355339 L7.293,8 L5.89644661,9.39644661 L5.83859116,9.4656945 C5.70359511,9.66056264 5.72288026,9.92998704 5.89644661,10.1035534 L5.89644661,10.1035534 L5.9656945,10.1614088 C6.16056264,10.2964049 6.42998704,10.2771197 6.60355339,10.1035534 L6.60355339,10.1035534 L8,8.707 L9.39644661,10.1035534 L9.4656945,10.1614088 C9.66056264,10.2964049 9.92998704,10.2771197 10.1035534,10.1035534 L10.1035534,10.1035534 L10.1614088,10.0343055 C10.2964049,9.83943736 10.2771197,9.57001296 10.1035534,9.39644661 L10.1035534,9.39644661 L8.707,8 L10.1035534,6.60355339 L10.1614088,6.5343055 C10.2964049,6.33943736 10.2771197,6.07001296 10.1035534,5.89644661 L10.1035534,5.89644661 L10.0343055,5.83859116 C9.83943736,5.70359511 9.57001296,5.72288026 9.39644661,5.89644661 L9.39644661,5.89644661 L8,7.293 L6.60355339,5.89644661 Z" }))))), X1 = La("download", () => B("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, B("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, B("g", { fill: "currentColor", "fill-rule": "nonzero" }, B("path", { d: "M3.5,13 L12.5,13 C12.7761424,13 13,13.2238576 13,13.5 C13,13.7454599 12.8231248,13.9496084 12.5898756,13.9919443 L12.5,14 L3.5,14 C3.22385763,14 3,13.7761424 3,13.5 C3,13.2545401 3.17687516,13.0503916 3.41012437,13.0080557 L3.5,13 L12.5,13 L3.5,13 Z M7.91012437,1.00805567 L8,1 C8.24545989,1 8.44960837,1.17687516 8.49194433,1.41012437 L8.5,1.5 L8.5,10.292 L11.1819805,7.6109127 C11.3555469,7.43734635 11.6249713,7.4180612 11.8198394,7.55305725 L11.8890873,7.6109127 C12.0626536,7.78447906 12.0819388,8.05390346 11.9469427,8.2487716 L11.8890873,8.31801948 L8.35355339,11.8535534 C8.17998704,12.0271197 7.91056264,12.0464049 7.7156945,11.9114088 L7.64644661,11.8535534 L4.1109127,8.31801948 C3.91565056,8.12275734 3.91565056,7.80617485 4.1109127,7.6109127 C4.28447906,7.43734635 4.55390346,7.4180612 4.7487716,7.55305725 L4.81801948,7.6109127 L7.5,10.292 L7.5,1.5 C7.5,1.25454011 7.67687516,1.05039163 7.91012437,1.00805567 L8,1 L7.91012437,1.00805567 Z" }))))), oP = nt({ name: "Empty", render() {
  return B("svg", { viewBox: "0 0 28 28", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M26 7.5C26 11.0899 23.0899 14 19.5 14C15.9101 14 13 11.0899 13 7.5C13 3.91015 15.9101 1 19.5 1C23.0899 1 26 3.91015 26 7.5ZM16.8536 4.14645C16.6583 3.95118 16.3417 3.95118 16.1464 4.14645C15.9512 4.34171 15.9512 4.65829 16.1464 4.85355L18.7929 7.5L16.1464 10.1464C15.9512 10.3417 15.9512 10.6583 16.1464 10.8536C16.3417 11.0488 16.6583 11.0488 16.8536 10.8536L19.5 8.20711L22.1464 10.8536C22.3417 11.0488 22.6583 11.0488 22.8536 10.8536C23.0488 10.6583 23.0488 10.3417 22.8536 10.1464L20.2071 7.5L22.8536 4.85355C23.0488 4.65829 23.0488 4.34171 22.8536 4.14645C22.6583 3.95118 22.3417 3.95118 22.1464 4.14645L19.5 6.79289L16.8536 4.14645Z", fill: "currentColor" }), B("path", { d: "M25 22.75V12.5991C24.5572 13.0765 24.053 13.4961 23.5 13.8454V16H17.5L17.3982 16.0068C17.0322 16.0565 16.75 16.3703 16.75 16.75C16.75 18.2688 15.5188 19.5 14 19.5C12.4812 19.5 11.25 18.2688 11.25 16.75L11.2432 16.6482C11.1935 16.2822 10.8797 16 10.5 16H4.5V7.25C4.5 6.2835 5.2835 5.5 6.25 5.5H12.2696C12.4146 4.97463 12.6153 4.47237 12.865 4H6.25C4.45507 4 3 5.45507 3 7.25V22.75C3 24.5449 4.45507 26 6.25 26H21.75C23.5449 26 25 24.5449 25 22.75ZM4.5 22.75V17.5H9.81597L9.85751 17.7041C10.2905 19.5919 11.9808 21 14 21L14.215 20.9947C16.2095 20.8953 17.842 19.4209 18.184 17.5H23.5V22.75C23.5 23.7165 22.7165 24.5 21.75 24.5H6.25C5.2835 24.5 4.5 23.7165 4.5 22.75Z", fill: "currentColor" }));
} }), Y1 = nt({ name: "Eye", render() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, B("path", { d: "M255.66 112c-77.94 0-157.89 45.11-220.83 135.33a16 16 0 0 0-.27 17.77C82.92 340.8 161.8 400 255.66 400c92.84 0 173.34-59.38 221.79-135.25a16.14 16.14 0 0 0 0-17.47C428.89 172.28 347.8 112 255.66 112z", fill: "none", stroke: "currentColor", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "32" }), B("circle", { cx: "256", cy: "256", r: "80", fill: "none", stroke: "currentColor", "stroke-miterlimit": "10", "stroke-width": "32" }));
} }), aP = nt({ name: "EyeOff", render() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, B("path", { d: "M432 448a15.92 15.92 0 0 1-11.31-4.69l-352-352a16 16 0 0 1 22.62-22.62l352 352A16 16 0 0 1 432 448z", fill: "currentColor" }), B("path", { d: "M255.66 384c-41.49 0-81.5-12.28-118.92-36.5c-34.07-22-64.74-53.51-88.7-91v-.08c19.94-28.57 41.78-52.73 65.24-72.21a2 2 0 0 0 .14-2.94L93.5 161.38a2 2 0 0 0-2.71-.12c-24.92 21-48.05 46.76-69.08 76.92a31.92 31.92 0 0 0-.64 35.54c26.41 41.33 60.4 76.14 98.28 100.65C162 402 207.9 416 255.66 416a239.13 239.13 0 0 0 75.8-12.58a2 2 0 0 0 .77-3.31l-21.58-21.58a4 4 0 0 0-3.83-1a204.8 204.8 0 0 1-51.16 6.47z", fill: "currentColor" }), B("path", { d: "M490.84 238.6c-26.46-40.92-60.79-75.68-99.27-100.53C349 110.55 302 96 255.66 96a227.34 227.34 0 0 0-74.89 12.83a2 2 0 0 0-.75 3.31l21.55 21.55a4 4 0 0 0 3.88 1a192.82 192.82 0 0 1 50.21-6.69c40.69 0 80.58 12.43 118.55 37c34.71 22.4 65.74 53.88 89.76 91a.13.13 0 0 1 0 .16a310.72 310.72 0 0 1-64.12 72.73a2 2 0 0 0-.15 2.95l19.9 19.89a2 2 0 0 0 2.7.13a343.49 343.49 0 0 0 68.64-78.48a32.2 32.2 0 0 0-.1-34.78z", fill: "currentColor" }), B("path", { d: "M256 160a95.88 95.88 0 0 0-21.37 2.4a2 2 0 0 0-1 3.38l112.59 112.56a2 2 0 0 0 3.38-1A96 96 0 0 0 256 160z", fill: "currentColor" }), B("path", { d: "M165.78 233.66a2 2 0 0 0-3.38 1a96 96 0 0 0 115 115a2 2 0 0 0 1-3.38z", fill: "currentColor" }));
} }), sP = nt({ name: "Remove", render() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, B("line", { x1: "400", y1: "256", x2: "112", y2: "256", style: `
        fill: none;
        stroke: currentColor;
        stroke-linecap: round;
        stroke-linejoin: round;
        stroke-width: 32px;
      ` }));
} }), lP = nt({ name: "ResizeSmall", render() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20" }, B("g", { fill: "none" }, B("path", { d: "M5.5 4A1.5 1.5 0 0 0 4 5.5v1a.5.5 0 0 1-1 0v-1A2.5 2.5 0 0 1 5.5 3h1a.5.5 0 0 1 0 1h-1zM16 5.5A1.5 1.5 0 0 0 14.5 4h-1a.5.5 0 0 1 0-1h1A2.5 2.5 0 0 1 17 5.5v1a.5.5 0 0 1-1 0v-1zm0 9a1.5 1.5 0 0 1-1.5 1.5h-1a.5.5 0 0 0 0 1h1a2.5 2.5 0 0 0 2.5-2.5v-1a.5.5 0 0 0-1 0v1zm-12 0A1.5 1.5 0 0 0 5.5 16h1.25a.5.5 0 0 1 0 1H5.5A2.5 2.5 0 0 1 3 14.5v-1.25a.5.5 0 0 1 1 0v1.25zM8.5 7A1.5 1.5 0 0 0 7 8.5v3A1.5 1.5 0 0 0 8.5 13h3a1.5 1.5 0 0 0 1.5-1.5v-3A1.5 1.5 0 0 0 11.5 7h-3zM8 8.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3z", fill: "currentColor" })));
} }), uP = La("retry", () => B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, B("path", { d: "M320,146s24.36-12-64-12A160,160,0,1,0,416,294", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-miterlimit: 10; stroke-width: 32px;" }), B("polyline", { points: "256 58 336 138 256 218", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }))), cP = La("rotateClockwise", () => B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M3 10C3 6.13401 6.13401 3 10 3C13.866 3 17 6.13401 17 10C17 12.7916 15.3658 15.2026 13 16.3265V14.5C13 14.2239 12.7761 14 12.5 14C12.2239 14 12 14.2239 12 14.5V17.5C12 17.7761 12.2239 18 12.5 18H15.5C15.7761 18 16 17.7761 16 17.5C16 17.2239 15.7761 17 15.5 17H13.8758C16.3346 15.6357 18 13.0128 18 10C18 5.58172 14.4183 2 10 2C5.58172 2 2 5.58172 2 10C2 10.2761 2.22386 10.5 2.5 10.5C2.77614 10.5 3 10.2761 3 10Z", fill: "currentColor" }), B("path", { d: "M10 12C11.1046 12 12 11.1046 12 10C12 8.89543 11.1046 8 10 8C8.89543 8 8 8.89543 8 10C8 11.1046 8.89543 12 10 12ZM10 11C9.44772 11 9 10.5523 9 10C9 9.44772 9.44772 9 10 9C10.5523 9 11 9.44772 11 10C11 10.5523 10.5523 11 10 11Z", fill: "currentColor" }))), dP = La("rotateClockwise", () => B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M17 10C17 6.13401 13.866 3 10 3C6.13401 3 3 6.13401 3 10C3 12.7916 4.63419 15.2026 7 16.3265V14.5C7 14.2239 7.22386 14 7.5 14C7.77614 14 8 14.2239 8 14.5V17.5C8 17.7761 7.77614 18 7.5 18H4.5C4.22386 18 4 17.7761 4 17.5C4 17.2239 4.22386 17 4.5 17H6.12422C3.66539 15.6357 2 13.0128 2 10C2 5.58172 5.58172 2 10 2C14.4183 2 18 5.58172 18 10C18 10.2761 17.7761 10.5 17.5 10.5C17.2239 10.5 17 10.2761 17 10Z", fill: "currentColor" }), B("path", { d: "M10 12C8.89543 12 8 11.1046 8 10C8 8.89543 8.89543 8 10 8C11.1046 8 12 8.89543 12 10C12 11.1046 11.1046 12 10 12ZM10 11C10.5523 11 11 10.5523 11 10C11 9.44772 10.5523 9 10 9C9.44772 9 9 9.44772 9 10C9 10.5523 9.44772 11 10 11Z", fill: "currentColor" }))), hP = La("trash", () => B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, B("path", { d: "M432,144,403.33,419.74A32,32,0,0,1,371.55,448H140.46a32,32,0,0,1-31.78-28.26L80,144", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), B("rect", { x: "32", y: "64", width: "448", height: "80", rx: "16", ry: "16", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), B("line", { x1: "312", y1: "240", x2: "200", y2: "352", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), B("line", { x1: "312", y1: "352", x2: "200", y2: "240", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }))), fP = La("zoomIn", () => B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M11.5 8.5C11.5 8.22386 11.2761 8 11 8H9V6C9 5.72386 8.77614 5.5 8.5 5.5C8.22386 5.5 8 5.72386 8 6V8H6C5.72386 8 5.5 8.22386 5.5 8.5C5.5 8.77614 5.72386 9 6 9H8V11C8 11.2761 8.22386 11.5 8.5 11.5C8.77614 11.5 9 11.2761 9 11V9H11C11.2761 9 11.5 8.77614 11.5 8.5Z", fill: "currentColor" }), B("path", { d: "M8.5 3C11.5376 3 14 5.46243 14 8.5C14 9.83879 13.5217 11.0659 12.7266 12.0196L16.8536 16.1464C17.0488 16.3417 17.0488 16.6583 16.8536 16.8536C16.68 17.0271 16.4106 17.0464 16.2157 16.9114L16.1464 16.8536L12.0196 12.7266C11.0659 13.5217 9.83879 14 8.5 14C5.46243 14 3 11.5376 3 8.5C3 5.46243 5.46243 3 8.5 3ZM8.5 4C6.01472 4 4 6.01472 4 8.5C4 10.9853 6.01472 13 8.5 13C10.9853 13 13 10.9853 13 8.5C13 6.01472 10.9853 4 8.5 4Z", fill: "currentColor" }))), pP = La("zoomOut", () => B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M11 8C11.2761 8 11.5 8.22386 11.5 8.5C11.5 8.77614 11.2761 9 11 9H6C5.72386 9 5.5 8.77614 5.5 8.5C5.5 8.22386 5.72386 8 6 8H11Z", fill: "currentColor" }), B("path", { d: "M14 8.5C14 5.46243 11.5376 3 8.5 3C5.46243 3 3 5.46243 3 8.5C3 11.5376 5.46243 14 8.5 14C9.83879 14 11.0659 13.5217 12.0196 12.7266L16.1464 16.8536L16.2157 16.9114C16.4106 17.0464 16.68 17.0271 16.8536 16.8536C17.0488 16.6583 17.0488 16.3417 16.8536 16.1464L12.7266 12.0196C13.5217 11.0659 14 9.83879 14 8.5ZM4 8.5C4 6.01472 6.01472 4 8.5 4C10.9853 4 13 6.01472 13 8.5C13 10.9853 10.9853 13 8.5 13C6.01472 13 4 10.9853 4 8.5Z", fill: "currentColor" }))), mP = he("base-clear", `
 flex-shrink: 0;
 height: 1em;
 width: 1em;
 position: relative;
`, [qe(">", [Le("clear", `
 font-size: var(--n-clear-size);
 height: 1em;
 width: 1em;
 cursor: pointer;
 color: var(--n-clear-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 `, [qe("&:hover", `
 color: var(--n-clear-color-hover)!important;
 `), qe("&:active", `
 color: var(--n-clear-color-pressed)!important;
 `)]), Le("placeholder", `
 display: flex;
 `), Le("clear, placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [Sh({ originalTransform: "translateX(-50%) translateY(-50%)", left: "50%", top: "50%" })])])]), E0 = nt({ name: "BaseClear", props: { clsPrefix: { type: String, required: true }, show: Boolean, onClear: Function }, setup(r) {
  return Nc("-base-clear", mP, zt(r, "clsPrefix")), { handleMouseDown(n) {
    n.preventDefault();
  } };
}, render() {
  const { clsPrefix: r } = this;
  return B("div", { class: `${r}-base-clear` }, B(im, null, { default: () => {
    var n, l;
    return this.show ? B("div", { key: "dismiss", class: `${r}-base-clear__clear`, onClick: this.onClear, onMousedown: this.handleMouseDown, "data-clear": true }, to(this.$slots.icon, () => [B(Nr, { clsPrefix: r }, { default: () => B(nP, null) })])) : B("div", { key: "icon", class: `${r}-base-clear__placeholder` }, (l = (n = this.$slots).placeholder) === null || l === void 0 ? void 0 : l.call(n));
  } }));
} }), gP = nt({ props: { onFocus: Function, onBlur: Function }, setup(r) {
  return () => B("div", { style: "width: 0; height: 0", tabindex: 0, onFocus: r.onFocus, onBlur: r.onBlur });
} }), vP = he("empty", `
 display: flex;
 flex-direction: column;
 align-items: center;
 font-size: var(--n-font-size);
`, [Le("icon", `
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 line-height: var(--n-icon-size);
 color: var(--n-icon-color);
 transition:
 color .3s var(--n-bezier);
 `, [qe("+", [Le("description", `
 margin-top: 8px;
 `)])]), Le("description", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), Le("extra", `
 text-align: center;
 transition: color .3s var(--n-bezier);
 margin-top: 12px;
 color: var(--n-extra-text-color);
 `)]), yP = Object.assign(Object.assign({}, er.props), { description: String, showDescription: { type: Boolean, default: true }, showIcon: { type: Boolean, default: true }, size: { type: String, default: "medium" }, renderIcon: Function }), Ph = nt({ name: "Empty", props: yP, slots: Object, setup(r) {
  const { mergedClsPrefixRef: n, inlineThemeDisabled: l, mergedComponentPropsRef: h } = Cr(r), f = er("Empty", "-empty", vP, h3, r, n), { localeRef: y } = ds("Empty"), p = Ae(() => {
    var M, A, O;
    return (M = r.description) !== null && M !== void 0 ? M : (O = (A = h == null ? void 0 : h.value) === null || A === void 0 ? void 0 : A.Empty) === null || O === void 0 ? void 0 : O.description;
  }), s = Ae(() => {
    var M, A;
    return ((A = (M = h == null ? void 0 : h.value) === null || M === void 0 ? void 0 : M.Empty) === null || A === void 0 ? void 0 : A.renderIcon) || (() => B(oP, null));
  }), S = Ae(() => {
    const { size: M } = r, { common: { cubicBezierEaseInOut: A }, self: { [Ut("iconSize", M)]: O, [Ut("fontSize", M)]: j, textColor: L, iconColor: q, extraTextColor: N } } = f.value;
    return { "--n-icon-size": O, "--n-font-size": j, "--n-bezier": A, "--n-text-color": L, "--n-icon-color": q, "--n-extra-text-color": N };
  }), P = l ? ai("empty", Ae(() => {
    let M = "";
    const { size: A } = r;
    return M += A[0], M;
  }), S, r) : void 0;
  return { mergedClsPrefix: n, mergedRenderIcon: s, localizedDescription: Ae(() => p.value || y.value.description), cssVars: l ? void 0 : S, themeClass: P == null ? void 0 : P.themeClass, onRender: P == null ? void 0 : P.onRender };
}, render() {
  const { $slots: r, mergedClsPrefix: n, onRender: l } = this;
  return l == null ? void 0 : l(), B("div", { class: [`${n}-empty`, this.themeClass], style: this.cssVars }, this.showIcon ? B("div", { class: `${n}-empty__icon` }, r.icon ? r.icon() : B(Nr, { clsPrefix: n }, { default: this.mergedRenderIcon })) : null, this.showDescription ? B("div", { class: `${n}-empty__description` }, r.default ? r.default() : this.localizedDescription) : null, r.extra ? B("div", { class: `${n}-empty__extra` }, r.extra()) : null);
} }), O_ = nt({ name: "NBaseSelectGroupHeader", props: { clsPrefix: { type: String, required: true }, tmNode: { type: Object, required: true } }, setup() {
  const { renderLabelRef: r, renderOptionRef: n, labelFieldRef: l, nodePropsRef: h } = cr(Y0);
  return { labelField: l, nodeProps: h, renderLabel: r, renderOption: n };
}, render() {
  const { clsPrefix: r, renderLabel: n, renderOption: l, nodeProps: h, tmNode: { rawNode: f } } = this, y = h == null ? void 0 : h(f), p = n ? n(f, false) : Ul(f[this.labelField], f, false), s = B("div", Object.assign({}, y, { class: [`${r}-base-select-group-header`, y == null ? void 0 : y.class] }), p);
  return f.render ? f.render({ node: s, option: f }) : l ? l({ node: s, option: f, selected: false }) : s;
} });
function _P(r, n) {
  return B(Wo, { name: "fade-in-scale-up-transition" }, { default: () => r ? B(Nr, { clsPrefix: n, class: `${n}-base-select-option__check` }, { default: () => B(tP) }) : null });
}
const $_ = nt({ name: "NBaseSelectOption", props: { clsPrefix: { type: String, required: true }, tmNode: { type: Object, required: true } }, setup(r) {
  const { valueRef: n, pendingTmNodeRef: l, multipleRef: h, valueSetRef: f, renderLabelRef: y, renderOptionRef: p, labelFieldRef: s, valueFieldRef: S, showCheckmarkRef: P, nodePropsRef: M, handleOptionClick: A, handleOptionMouseEnter: O } = cr(Y0), j = vi(() => {
    const { value: J } = l;
    return J ? r.tmNode.key === J.key : false;
  });
  function L(J) {
    const { tmNode: te } = r;
    te.disabled || A(J, te);
  }
  function q(J) {
    const { tmNode: te } = r;
    te.disabled || O(J, te);
  }
  function N(J) {
    const { tmNode: te } = r, { value: ne } = j;
    te.disabled || ne || O(J, te);
  }
  return { multiple: h, isGrouped: vi(() => {
    const { tmNode: J } = r, { parent: te } = J;
    return te && te.rawNode.type === "group";
  }), showCheckmark: P, nodeProps: M, isPending: j, isSelected: vi(() => {
    const { value: J } = n, { value: te } = h;
    if (J === null) return false;
    const ne = r.tmNode.rawNode[S.value];
    if (te) {
      const { value: ae } = f;
      return ae.has(ne);
    } else return J === ne;
  }), labelField: s, renderLabel: y, renderOption: p, handleMouseMove: N, handleMouseEnter: q, handleClick: L };
}, render() {
  const { clsPrefix: r, tmNode: { rawNode: n }, isSelected: l, isPending: h, isGrouped: f, showCheckmark: y, nodeProps: p, renderOption: s, renderLabel: S, handleClick: P, handleMouseEnter: M, handleMouseMove: A } = this, O = _P(l, r), j = S ? [S(n, l), y && O] : [Ul(n[this.labelField], n, l), y && O], L = p == null ? void 0 : p(n), q = B("div", Object.assign({}, L, { class: [`${r}-base-select-option`, n.class, L == null ? void 0 : L.class, { [`${r}-base-select-option--disabled`]: n.disabled, [`${r}-base-select-option--selected`]: l, [`${r}-base-select-option--grouped`]: f, [`${r}-base-select-option--pending`]: h, [`${r}-base-select-option--show-checkmark`]: y }], style: [(L == null ? void 0 : L.style) || "", n.style || ""], onClick: qg([P, L == null ? void 0 : L.onClick]), onMouseenter: qg([M, L == null ? void 0 : L.onMouseenter]), onMousemove: qg([A, L == null ? void 0 : L.onMousemove]) }), B("div", { class: `${r}-base-select-option__content` }, j));
  return n.render ? n.render({ node: q, option: n, selected: l }) : s ? s({ node: q, option: n, selected: l }) : q;
} }), bP = he("base-select-menu", `
 line-height: 1.5;
 outline: none;
 z-index: 0;
 position: relative;
 border-radius: var(--n-border-radius);
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-color);
`, [he("scrollbar", `
 max-height: var(--n-height);
 `), he("virtual-list", `
 max-height: var(--n-height);
 `), he("base-select-option", `
 min-height: var(--n-option-height);
 font-size: var(--n-option-font-size);
 display: flex;
 align-items: center;
 `, [Le("content", `
 z-index: 1;
 white-space: nowrap;
 text-overflow: ellipsis;
 overflow: hidden;
 `)]), he("base-select-group-header", `
 min-height: var(--n-option-height);
 font-size: .93em;
 display: flex;
 align-items: center;
 `), he("base-select-menu-option-wrapper", `
 position: relative;
 width: 100%;
 `), Le("loading, empty", `
 display: flex;
 padding: 12px 32px;
 flex: 1;
 justify-content: center;
 `), Le("loading", `
 color: var(--n-loading-color);
 font-size: var(--n-loading-size);
 `), Le("header", `
 padding: 8px var(--n-option-padding-left);
 font-size: var(--n-option-font-size);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), Le("action", `
 padding: 8px var(--n-option-padding-left);
 font-size: var(--n-option-font-size);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 border-top: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), he("base-select-group-header", `
 position: relative;
 cursor: default;
 padding: var(--n-option-padding);
 color: var(--n-group-header-text-color);
 `), he("base-select-option", `
 cursor: pointer;
 position: relative;
 padding: var(--n-option-padding);
 transition:
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 box-sizing: border-box;
 color: var(--n-option-text-color);
 opacity: 1;
 `, [Ue("show-checkmark", `
 padding-right: calc(var(--n-option-padding-right) + 20px);
 `), qe("&::before", `
 content: "";
 position: absolute;
 left: 4px;
 right: 4px;
 top: 0;
 bottom: 0;
 border-radius: var(--n-border-radius);
 transition: background-color .3s var(--n-bezier);
 `), qe("&:active", `
 color: var(--n-option-text-color-pressed);
 `), Ue("grouped", `
 padding-left: calc(var(--n-option-padding-left) * 1.5);
 `), Ue("pending", [qe("&::before", `
 background-color: var(--n-option-color-pending);
 `)]), Ue("selected", `
 color: var(--n-option-text-color-active);
 `, [qe("&::before", `
 background-color: var(--n-option-color-active);
 `), Ue("pending", [qe("&::before", `
 background-color: var(--n-option-color-active-pending);
 `)])]), Ue("disabled", `
 cursor: not-allowed;
 `, [ci("selected", `
 color: var(--n-option-text-color-disabled);
 `), Ue("selected", `
 opacity: var(--n-option-opacity-disabled);
 `)]), Le("check", `
 font-size: 16px;
 position: absolute;
 right: calc(var(--n-option-padding-right) - 4px);
 top: calc(50% - 7px);
 color: var(--n-option-check-color);
 transition: color .3s var(--n-bezier);
 `, [nm({ enterScale: "0.5" })])])]), xP = nt({ name: "InternalSelectMenu", props: Object.assign(Object.assign({}, er.props), { clsPrefix: { type: String, required: true }, scrollable: { type: Boolean, default: true }, treeMate: { type: Object, required: true }, multiple: Boolean, size: { type: String, default: "medium" }, value: { type: [String, Number, Array], default: null }, autoPending: Boolean, virtualScroll: { type: Boolean, default: true }, show: { type: Boolean, default: true }, labelField: { type: String, default: "label" }, valueField: { type: String, default: "value" }, loading: Boolean, focusable: Boolean, renderLabel: Function, renderOption: Function, nodeProps: Function, showCheckmark: { type: Boolean, default: true }, onMousedown: Function, onScroll: Function, onFocus: Function, onBlur: Function, onKeyup: Function, onKeydown: Function, onTabOut: Function, onMouseenter: Function, onMouseleave: Function, onResize: Function, resetMenuOnOptionsChange: { type: Boolean, default: true }, inlineThemeDisabled: Boolean, onToggle: Function }), setup(r) {
  const { mergedClsPrefixRef: n, mergedRtlRef: l } = Cr(r), h = Ln("InternalSelectMenu", l, n), f = er("InternalSelectMenu", "-internal-select-menu", bP, f3, r, zt(r, "clsPrefix")), y = Ee(null), p = Ee(null), s = Ee(null), S = Ae(() => r.treeMate.getFlattenedNodes()), P = Ae(() => p3(S.value)), M = Ee(null);
  function A() {
    const { treeMate: vt } = r;
    let Pt = null;
    const { value: Nt } = r;
    Nt === null ? Pt = vt.getFirstAvailableNode() : (r.multiple ? Pt = vt.getNode((Nt || [])[(Nt || []).length - 1]) : Pt = vt.getNode(Nt), (!Pt || Pt.disabled) && (Pt = vt.getFirstAvailableNode())), et(Pt || null);
  }
  function O() {
    const { value: vt } = M;
    vt && !r.treeMate.getNode(vt.key) && (M.value = null);
  }
  let j;
  Kt(() => r.show, (vt) => {
    vt ? j = Kt(() => r.treeMate, () => {
      r.resetMenuOnOptionsChange ? (r.autoPending ? A() : O(), eo(dt)) : O();
    }, { immediate: true }) : j == null ? void 0 : j();
  }, { immediate: true }), Fn(() => {
    j == null ? void 0 : j();
  });
  const L = Ae(() => ln(f.value.self[Ut("optionHeight", r.size)])), q = Ae(() => qo(f.value.self[Ut("padding", r.size)])), N = Ae(() => r.multiple && Array.isArray(r.value) ? new Set(r.value) : /* @__PURE__ */ new Set()), J = Ae(() => {
    const vt = S.value;
    return vt && vt.length === 0;
  });
  function te(vt) {
    const { onToggle: Pt } = r;
    Pt && Pt(vt);
  }
  function ne(vt) {
    const { onScroll: Pt } = r;
    Pt && Pt(vt);
  }
  function ae(vt) {
    var Pt;
    (Pt = s.value) === null || Pt === void 0 || Pt.sync(), ne(vt);
  }
  function oe() {
    var vt;
    (vt = s.value) === null || vt === void 0 || vt.sync();
  }
  function ee() {
    const { value: vt } = M;
    return vt || null;
  }
  function ke(vt, Pt) {
    Pt.disabled || et(Pt, false);
  }
  function ve(vt, Pt) {
    Pt.disabled || te(Pt);
  }
  function le(vt) {
    var Pt;
    Wl(vt, "action") || (Pt = r.onKeyup) === null || Pt === void 0 || Pt.call(r, vt);
  }
  function ue(vt) {
    var Pt;
    Wl(vt, "action") || (Pt = r.onKeydown) === null || Pt === void 0 || Pt.call(r, vt);
  }
  function be(vt) {
    var Pt;
    (Pt = r.onMousedown) === null || Pt === void 0 || Pt.call(r, vt), !r.focusable && vt.preventDefault();
  }
  function Ve() {
    const { value: vt } = M;
    vt && et(vt.getNext({ loop: true }), true);
  }
  function Ge() {
    const { value: vt } = M;
    vt && et(vt.getPrev({ loop: true }), true);
  }
  function et(vt, Pt = false) {
    M.value = vt, Pt && dt();
  }
  function dt() {
    var vt, Pt;
    const Nt = M.value;
    if (!Nt) return;
    const ir = P.value(Nt.key);
    ir !== null && (r.virtualScroll ? (vt = p.value) === null || vt === void 0 || vt.scrollTo({ index: ir }) : (Pt = s.value) === null || Pt === void 0 || Pt.scrollTo({ index: ir, elSize: L.value }));
  }
  function Ct(vt) {
    var Pt, Nt;
    !((Pt = y.value) === null || Pt === void 0) && Pt.contains(vt.target) && ((Nt = r.onFocus) === null || Nt === void 0 || Nt.call(r, vt));
  }
  function kt(vt) {
    var Pt, Nt;
    !((Pt = y.value) === null || Pt === void 0) && Pt.contains(vt.relatedTarget) || (Nt = r.onBlur) === null || Nt === void 0 || Nt.call(r, vt);
  }
  Vr(Y0, { handleOptionMouseEnter: ke, handleOptionClick: ve, valueSetRef: N, pendingTmNodeRef: M, nodePropsRef: zt(r, "nodeProps"), showCheckmarkRef: zt(r, "showCheckmark"), multipleRef: zt(r, "multiple"), valueRef: zt(r, "value"), renderLabelRef: zt(r, "renderLabel"), renderOptionRef: zt(r, "renderOption"), labelFieldRef: zt(r, "labelField"), valueFieldRef: zt(r, "valueField") }), Vr(m3, y), Ei(() => {
    const { value: vt } = s;
    vt && vt.sync();
  });
  const ct = Ae(() => {
    const { size: vt } = r, { common: { cubicBezierEaseInOut: Pt }, self: { height: Nt, borderRadius: ir, color: bt, groupHeaderTextColor: Dt, actionDividerColor: Zt, optionTextColorPressed: dr, optionTextColor: yr, optionTextColorDisabled: Pr, optionTextColorActive: lr, optionOpacityDisabled: Ir, optionCheckColor: Ht, actionTextColor: Rr, optionColorPending: xr, optionColorActive: gt, loadingColor: Be, loadingSize: ot, optionColorActivePending: $e, [Ut("optionFontSize", vt)]: Ye, [Ut("optionHeight", vt)]: ht, [Ut("optionPadding", vt)]: St } } = f.value;
    return { "--n-height": Nt, "--n-action-divider-color": Zt, "--n-action-text-color": Rr, "--n-bezier": Pt, "--n-border-radius": ir, "--n-color": bt, "--n-option-font-size": Ye, "--n-group-header-text-color": Dt, "--n-option-check-color": Ht, "--n-option-color-pending": xr, "--n-option-color-active": gt, "--n-option-color-active-pending": $e, "--n-option-height": ht, "--n-option-opacity-disabled": Ir, "--n-option-text-color": yr, "--n-option-text-color-active": lr, "--n-option-text-color-disabled": Pr, "--n-option-text-color-pressed": dr, "--n-option-padding": St, "--n-option-padding-left": qo(St, "left"), "--n-option-padding-right": qo(St, "right"), "--n-loading-color": Be, "--n-loading-size": ot };
  }), { inlineThemeDisabled: it } = r, pt = it ? ai("internal-select-menu", Ae(() => r.size[0]), ct, r) : void 0, $t = { selfRef: y, next: Ve, prev: Ge, getPendingTmNode: ee };
  return Z1(y, r.onResize), Object.assign({ mergedTheme: f, mergedClsPrefix: n, rtlEnabled: h, virtualListRef: p, scrollbarRef: s, itemSize: L, padding: q, flattenedNodes: S, empty: J, virtualListContainer() {
    const { value: vt } = p;
    return vt == null ? void 0 : vt.listElRef;
  }, virtualListContent() {
    const { value: vt } = p;
    return vt == null ? void 0 : vt.itemsElRef;
  }, doScroll: ne, handleFocusin: Ct, handleFocusout: kt, handleKeyUp: le, handleKeyDown: ue, handleMouseDown: be, handleVirtualListResize: oe, handleVirtualListScroll: ae, cssVars: it ? void 0 : ct, themeClass: pt == null ? void 0 : pt.themeClass, onRender: pt == null ? void 0 : pt.onRender }, $t);
}, render() {
  const { $slots: r, virtualScroll: n, clsPrefix: l, mergedTheme: h, themeClass: f, onRender: y } = this;
  return y == null ? void 0 : y(), B("div", { ref: "selfRef", tabindex: this.focusable ? 0 : -1, class: [`${l}-base-select-menu`, this.rtlEnabled && `${l}-base-select-menu--rtl`, f, this.multiple && `${l}-base-select-menu--multiple`], style: this.cssVars, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onKeyup: this.handleKeyUp, onKeydown: this.handleKeyDown, onMousedown: this.handleMouseDown, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave }, oi(r.header, (p) => p && B("div", { class: `${l}-base-select-menu__header`, "data-header": true, key: "header" }, p)), this.loading ? B("div", { class: `${l}-base-select-menu__loading` }, B(om, { clsPrefix: l, strokeWidth: 20 })) : this.empty ? B("div", { class: `${l}-base-select-menu__empty`, "data-empty": true }, to(r.empty, () => [B(Ph, { theme: h.peers.Empty, themeOverrides: h.peerOverrides.Empty, size: this.size })])) : B(Bh, { ref: "scrollbarRef", theme: h.peers.Scrollbar, themeOverrides: h.peerOverrides.Scrollbar, scrollable: this.scrollable, container: n ? this.virtualListContainer : void 0, content: n ? this.virtualListContent : void 0, onScroll: n ? void 0 : this.doScroll }, { default: () => n ? B(sT, { ref: "virtualListRef", class: `${l}-virtual-list`, items: this.flattenedNodes, itemSize: this.itemSize, showScrollbar: false, paddingTop: this.padding.top, paddingBottom: this.padding.bottom, onResize: this.handleVirtualListResize, onScroll: this.handleVirtualListScroll, itemResizable: true }, { default: ({ item: p }) => p.isGroup ? B(O_, { key: p.key, clsPrefix: l, tmNode: p }) : p.ignored ? null : B($_, { clsPrefix: l, key: p.key, tmNode: p }) }) : B("div", { class: `${l}-base-select-menu-option-wrapper`, style: { paddingTop: this.padding.top, paddingBottom: this.padding.bottom } }, this.flattenedNodes.map((p) => p.isGroup ? B(O_, { key: p.key, clsPrefix: l, tmNode: p }) : B($_, { clsPrefix: l, key: p.key, tmNode: p }))) }), oi(r.action, (p) => p && [B("div", { class: `${l}-base-select-menu__action`, "data-action": true, key: "action" }, p), B(gP, { onFocus: this.onTabOut, key: "focus-detector" })]));
} }), K1 = { color: Object, type: { type: String, default: "default" }, round: Boolean, size: { type: String, default: "medium" }, closable: Boolean, disabled: { type: Boolean, default: void 0 } }, wP = he("tag", `
 --n-close-margin: var(--n-close-margin-top) var(--n-close-margin-right) var(--n-close-margin-bottom) var(--n-close-margin-left);
 white-space: nowrap;
 position: relative;
 box-sizing: border-box;
 cursor: default;
 display: inline-flex;
 align-items: center;
 flex-wrap: nowrap;
 padding: var(--n-padding);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition: 
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 line-height: 1;
 height: var(--n-height);
 font-size: var(--n-font-size);
`, [Ue("strong", `
 font-weight: var(--n-font-weight-strong);
 `), Le("border", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 border: var(--n-border);
 transition: border-color .3s var(--n-bezier);
 `), Le("icon", `
 display: flex;
 margin: 0 4px 0 0;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 font-size: var(--n-avatar-size-override);
 `), Le("avatar", `
 display: flex;
 margin: 0 6px 0 0;
 `), Le("close", `
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), Ue("round", `
 padding: 0 calc(var(--n-height) / 3);
 border-radius: calc(var(--n-height) / 2);
 `, [Le("icon", `
 margin: 0 4px 0 calc((var(--n-height) - 8px) / -2);
 `), Le("avatar", `
 margin: 0 6px 0 calc((var(--n-height) - 8px) / -2);
 `), Ue("closable", `
 padding: 0 calc(var(--n-height) / 4) 0 calc(var(--n-height) / 3);
 `)]), Ue("icon, avatar", [Ue("round", `
 padding: 0 calc(var(--n-height) / 3) 0 calc(var(--n-height) / 2);
 `)]), Ue("disabled", `
 cursor: not-allowed !important;
 opacity: var(--n-opacity-disabled);
 `), Ue("checkable", `
 cursor: pointer;
 box-shadow: none;
 color: var(--n-text-color-checkable);
 background-color: var(--n-color-checkable);
 `, [ci("disabled", [qe("&:hover", "background-color: var(--n-color-hover-checkable);", [ci("checked", "color: var(--n-text-color-hover-checkable);")]), qe("&:active", "background-color: var(--n-color-pressed-checkable);", [ci("checked", "color: var(--n-text-color-pressed-checkable);")])]), Ue("checked", `
 color: var(--n-text-color-checked);
 background-color: var(--n-color-checked);
 `, [ci("disabled", [qe("&:hover", "background-color: var(--n-color-checked-hover);"), qe("&:active", "background-color: var(--n-color-checked-pressed);")])])])]), CP = Object.assign(Object.assign(Object.assign({}, er.props), K1), { bordered: { type: Boolean, default: void 0 }, checked: Boolean, checkable: Boolean, strong: Boolean, triggerClickOnClose: Boolean, onClose: [Array, Function], onMouseenter: Function, onMouseleave: Function, "onUpdate:checked": Function, onUpdateChecked: Function, internalCloseFocusable: { type: Boolean, default: true }, internalCloseIsButtonTag: { type: Boolean, default: true }, onCheckedChange: Function }), SP = qn("n-tag"), zo = nt({ name: "Tag", props: CP, slots: Object, setup(r) {
  const n = Ee(null), { mergedBorderedRef: l, mergedClsPrefixRef: h, inlineThemeDisabled: f, mergedRtlRef: y } = Cr(r), p = er("Tag", "-tag", wP, g3, r, h);
  Vr(SP, { roundRef: zt(r, "round") });
  function s() {
    if (!r.disabled && r.checkable) {
      const { checked: j, onCheckedChange: L, onUpdateChecked: q, "onUpdate:checked": N } = r;
      q && q(!j), N && N(!j), L && L(!j);
    }
  }
  function S(j) {
    if (r.triggerClickOnClose || j.stopPropagation(), !r.disabled) {
      const { onClose: L } = r;
      L && jt(L, j);
    }
  }
  const P = { setTextContent(j) {
    const { value: L } = n;
    L && (L.textContent = j);
  } }, M = Ln("Tag", y, h), A = Ae(() => {
    const { type: j, size: L, color: { color: q, textColor: N } = {} } = r, { common: { cubicBezierEaseInOut: J }, self: { padding: te, closeMargin: ne, borderRadius: ae, opacityDisabled: oe, textColorCheckable: ee, textColorHoverCheckable: ke, textColorPressedCheckable: ve, textColorChecked: le, colorCheckable: ue, colorHoverCheckable: be, colorPressedCheckable: Ve, colorChecked: Ge, colorCheckedHover: et, colorCheckedPressed: dt, closeBorderRadius: Ct, fontWeightStrong: kt, [Ut("colorBordered", j)]: ct, [Ut("closeSize", L)]: it, [Ut("closeIconSize", L)]: pt, [Ut("fontSize", L)]: $t, [Ut("height", L)]: vt, [Ut("color", j)]: Pt, [Ut("textColor", j)]: Nt, [Ut("border", j)]: ir, [Ut("closeIconColor", j)]: bt, [Ut("closeIconColorHover", j)]: Dt, [Ut("closeIconColorPressed", j)]: Zt, [Ut("closeColorHover", j)]: dr, [Ut("closeColorPressed", j)]: yr } } = p.value, Pr = qo(ne);
    return { "--n-font-weight-strong": kt, "--n-avatar-size-override": `calc(${vt} - 8px)`, "--n-bezier": J, "--n-border-radius": ae, "--n-border": ir, "--n-close-icon-size": pt, "--n-close-color-pressed": yr, "--n-close-color-hover": dr, "--n-close-border-radius": Ct, "--n-close-icon-color": bt, "--n-close-icon-color-hover": Dt, "--n-close-icon-color-pressed": Zt, "--n-close-icon-color-disabled": bt, "--n-close-margin-top": Pr.top, "--n-close-margin-right": Pr.right, "--n-close-margin-bottom": Pr.bottom, "--n-close-margin-left": Pr.left, "--n-close-size": it, "--n-color": q || (l.value ? ct : Pt), "--n-color-checkable": ue, "--n-color-checked": Ge, "--n-color-checked-hover": et, "--n-color-checked-pressed": dt, "--n-color-hover-checkable": be, "--n-color-pressed-checkable": Ve, "--n-font-size": $t, "--n-height": vt, "--n-opacity-disabled": oe, "--n-padding": te, "--n-text-color": N || Nt, "--n-text-color-checkable": ee, "--n-text-color-checked": le, "--n-text-color-hover-checkable": ke, "--n-text-color-pressed-checkable": ve };
  }), O = f ? ai("tag", Ae(() => {
    let j = "";
    const { type: L, size: q, color: { color: N, textColor: J } = {} } = r;
    return j += L[0], j += q[0], N && (j += `a${S_(N)}`), J && (j += `b${S_(J)}`), l.value && (j += "c"), j;
  }), A, r) : void 0;
  return Object.assign(Object.assign({}, P), { rtlEnabled: M, mergedClsPrefix: h, contentRef: n, mergedBordered: l, handleClick: s, handleCloseClick: S, cssVars: f ? void 0 : A, themeClass: O == null ? void 0 : O.themeClass, onRender: O == null ? void 0 : O.onRender });
}, render() {
  var r, n;
  const { mergedClsPrefix: l, rtlEnabled: h, closable: f, color: { borderColor: y } = {}, round: p, onRender: s, $slots: S } = this;
  s == null ? void 0 : s();
  const P = oi(S.avatar, (A) => A && B("div", { class: `${l}-tag__avatar` }, A)), M = oi(S.icon, (A) => A && B("div", { class: `${l}-tag__icon` }, A));
  return B("div", { class: [`${l}-tag`, this.themeClass, { [`${l}-tag--rtl`]: h, [`${l}-tag--strong`]: this.strong, [`${l}-tag--disabled`]: this.disabled, [`${l}-tag--checkable`]: this.checkable, [`${l}-tag--checked`]: this.checkable && this.checked, [`${l}-tag--round`]: p, [`${l}-tag--avatar`]: P, [`${l}-tag--icon`]: M, [`${l}-tag--closable`]: f }], style: this.cssVars, onClick: this.handleClick, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave }, M || P, B("span", { class: `${l}-tag__content`, ref: "contentRef" }, (n = (r = this.$slots).default) === null || n === void 0 ? void 0 : n.call(r)), !this.checkable && f ? B(am, { clsPrefix: l, class: `${l}-tag__close`, disabled: this.disabled, onClick: this.handleCloseClick, focusable: this.internalCloseFocusable, round: p, isButtonTag: this.internalCloseIsButtonTag, absolute: true }) : null, !this.checkable && this.mergedBordered ? B("div", { class: `${l}-tag__border`, style: { borderColor: y } }) : null);
} }), J1 = nt({ name: "InternalSelectionSuffix", props: { clsPrefix: { type: String, required: true }, showArrow: { type: Boolean, default: void 0 }, showClear: { type: Boolean, default: void 0 }, loading: { type: Boolean, default: false }, onClear: Function }, setup(r, { slots: n }) {
  return () => {
    const { clsPrefix: l } = r;
    return B(om, { clsPrefix: l, class: `${l}-base-suffix`, strokeWidth: 24, scale: 0.85, show: r.loading }, { default: () => r.showArrow ? B(E0, { clsPrefix: l, show: r.showClear, onClear: r.onClear }, { placeholder: () => B(Nr, { clsPrefix: l, class: `${l}-base-suffix__arrow` }, { default: () => to(n.default, () => [B(rP, null)]) }) }) : null });
  };
} }), kP = qe([he("base-selection", `
 --n-padding-single: var(--n-padding-single-top) var(--n-padding-single-right) var(--n-padding-single-bottom) var(--n-padding-single-left);
 --n-padding-multiple: var(--n-padding-multiple-top) var(--n-padding-multiple-right) var(--n-padding-multiple-bottom) var(--n-padding-multiple-left);
 position: relative;
 z-index: auto;
 box-shadow: none;
 width: 100%;
 max-width: 100%;
 display: inline-block;
 vertical-align: bottom;
 border-radius: var(--n-border-radius);
 min-height: var(--n-height);
 line-height: 1.5;
 font-size: var(--n-font-size);
 `, [he("base-loading", `
 color: var(--n-loading-color);
 `), he("base-selection-tags", "min-height: var(--n-height);"), Le("border, state-border", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border: var(--n-border);
 border-radius: inherit;
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), Le("state-border", `
 z-index: 1;
 border-color: #0000;
 `), he("base-suffix", `
 cursor: pointer;
 position: absolute;
 top: 50%;
 transform: translateY(-50%);
 right: 10px;
 `, [Le("arrow", `
 font-size: var(--n-arrow-size);
 color: var(--n-arrow-color);
 transition: color .3s var(--n-bezier);
 `)]), he("base-selection-overlay", `
 display: flex;
 align-items: center;
 white-space: nowrap;
 pointer-events: none;
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 padding: var(--n-padding-single);
 transition: color .3s var(--n-bezier);
 `, [Le("wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 overflow: hidden;
 text-overflow: ellipsis;
 `)]), he("base-selection-placeholder", `
 color: var(--n-placeholder-color);
 `, [Le("inner", `
 max-width: 100%;
 overflow: hidden;
 `)]), he("base-selection-tags", `
 cursor: pointer;
 outline: none;
 box-sizing: border-box;
 position: relative;
 z-index: auto;
 display: flex;
 padding: var(--n-padding-multiple);
 flex-wrap: wrap;
 align-items: center;
 width: 100%;
 vertical-align: bottom;
 background-color: var(--n-color);
 border-radius: inherit;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), he("base-selection-label", `
 height: var(--n-height);
 display: inline-flex;
 width: 100%;
 vertical-align: bottom;
 cursor: pointer;
 outline: none;
 z-index: auto;
 box-sizing: border-box;
 position: relative;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: inherit;
 background-color: var(--n-color);
 align-items: center;
 `, [he("base-selection-input", `
 font-size: inherit;
 line-height: inherit;
 outline: none;
 cursor: pointer;
 box-sizing: border-box;
 border:none;
 width: 100%;
 padding: var(--n-padding-single);
 background-color: #0000;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 caret-color: var(--n-caret-color);
 `, [Le("content", `
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap; 
 `)]), Le("render-label", `
 color: var(--n-text-color);
 `)]), ci("disabled", [qe("&:hover", [Le("state-border", `
 box-shadow: var(--n-box-shadow-hover);
 border: var(--n-border-hover);
 `)]), Ue("focus", [Le("state-border", `
 box-shadow: var(--n-box-shadow-focus);
 border: var(--n-border-focus);
 `)]), Ue("active", [Le("state-border", `
 box-shadow: var(--n-box-shadow-active);
 border: var(--n-border-active);
 `), he("base-selection-label", "background-color: var(--n-color-active);"), he("base-selection-tags", "background-color: var(--n-color-active);")])]), Ue("disabled", "cursor: not-allowed;", [Le("arrow", `
 color: var(--n-arrow-color-disabled);
 `), he("base-selection-label", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [he("base-selection-input", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 `), Le("render-label", `
 color: var(--n-text-color-disabled);
 `)]), he("base-selection-tags", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `), he("base-selection-placeholder", `
 cursor: not-allowed;
 color: var(--n-placeholder-color-disabled);
 `)]), he("base-selection-input-tag", `
 height: calc(var(--n-height) - 6px);
 line-height: calc(var(--n-height) - 6px);
 outline: none;
 display: none;
 position: relative;
 margin-bottom: 3px;
 max-width: 100%;
 vertical-align: bottom;
 `, [Le("input", `
 font-size: inherit;
 font-family: inherit;
 min-width: 1px;
 padding: 0;
 background-color: #0000;
 outline: none;
 border: none;
 max-width: 100%;
 overflow: hidden;
 width: 1em;
 line-height: inherit;
 cursor: pointer;
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 `), Le("mirror", `
 position: absolute;
 left: 0;
 top: 0;
 white-space: pre;
 visibility: hidden;
 user-select: none;
 -webkit-user-select: none;
 opacity: 0;
 `)]), ["warning", "error"].map((r) => Ue(`${r}-status`, [Le("state-border", `border: var(--n-border-${r});`), ci("disabled", [qe("&:hover", [Le("state-border", `
 box-shadow: var(--n-box-shadow-hover-${r});
 border: var(--n-border-hover-${r});
 `)]), Ue("active", [Le("state-border", `
 box-shadow: var(--n-box-shadow-active-${r});
 border: var(--n-border-active-${r});
 `), he("base-selection-label", `background-color: var(--n-color-active-${r});`), he("base-selection-tags", `background-color: var(--n-color-active-${r});`)]), Ue("focus", [Le("state-border", `
 box-shadow: var(--n-box-shadow-focus-${r});
 border: var(--n-border-focus-${r});
 `)])])]))]), he("base-selection-popover", `
 margin-bottom: -3px;
 display: flex;
 flex-wrap: wrap;
 margin-right: -8px;
 `), he("base-selection-tag-wrapper", `
 max-width: 100%;
 display: inline-flex;
 padding: 0 7px 3px 0;
 `, [qe("&:last-child", "padding-right: 0;"), he("tag", `
 font-size: 14px;
 max-width: 100%;
 `, [Le("content", `
 line-height: 1.25;
 text-overflow: ellipsis;
 overflow: hidden;
 `)])])]), TP = nt({ name: "InternalSelection", props: Object.assign(Object.assign({}, er.props), { clsPrefix: { type: String, required: true }, bordered: { type: Boolean, default: void 0 }, active: Boolean, pattern: { type: String, default: "" }, placeholder: String, selectedOption: { type: Object, default: null }, selectedOptions: { type: Array, default: null }, labelField: { type: String, default: "label" }, valueField: { type: String, default: "value" }, multiple: Boolean, filterable: Boolean, clearable: Boolean, disabled: Boolean, size: { type: String, default: "medium" }, loading: Boolean, autofocus: Boolean, showArrow: { type: Boolean, default: true }, inputProps: Object, focused: Boolean, renderTag: Function, onKeydown: Function, onClick: Function, onBlur: Function, onFocus: Function, onDeleteOption: Function, maxTagCount: [String, Number], ellipsisTagPopoverProps: Object, onClear: Function, onPatternInput: Function, onPatternFocus: Function, onPatternBlur: Function, renderLabel: Function, status: String, inlineThemeDisabled: Boolean, ignoreComposition: { type: Boolean, default: true }, onResize: Function }), setup(r) {
  const { mergedClsPrefixRef: n, mergedRtlRef: l } = Cr(r), h = Ln("InternalSelection", l, n), f = Ee(null), y = Ee(null), p = Ee(null), s = Ee(null), S = Ee(null), P = Ee(null), M = Ee(null), A = Ee(null), O = Ee(null), j = Ee(null), L = Ee(false), q = Ee(false), N = Ee(false), J = er("InternalSelection", "-internal-selection", kP, y3, r, zt(r, "clsPrefix")), te = Ae(() => r.clearable && !r.disabled && (N.value || r.active)), ne = Ae(() => r.selectedOption ? r.renderTag ? r.renderTag({ option: r.selectedOption, handleClose: () => {
  } }) : r.renderLabel ? r.renderLabel(r.selectedOption, true) : Ul(r.selectedOption[r.labelField], r.selectedOption, true) : r.placeholder), ae = Ae(() => {
    const rt = r.selectedOption;
    if (rt) return rt[r.labelField];
  }), oe = Ae(() => r.multiple ? !!(Array.isArray(r.selectedOptions) && r.selectedOptions.length) : r.selectedOption !== null);
  function ee() {
    var rt;
    const { value: mt } = f;
    if (mt) {
      const { value: nr } = y;
      nr && (nr.style.width = `${mt.offsetWidth}px`, r.maxTagCount !== "responsive" && ((rt = O.value) === null || rt === void 0 || rt.sync({ showAllItemsBeforeCalculate: false })));
    }
  }
  function ke() {
    const { value: rt } = j;
    rt && (rt.style.display = "none");
  }
  function ve() {
    const { value: rt } = j;
    rt && (rt.style.display = "inline-block");
  }
  Kt(zt(r, "active"), (rt) => {
    rt || ke();
  }), Kt(zt(r, "pattern"), () => {
    r.multiple && eo(ee);
  });
  function le(rt) {
    const { onFocus: mt } = r;
    mt && mt(rt);
  }
  function ue(rt) {
    const { onBlur: mt } = r;
    mt && mt(rt);
  }
  function be(rt) {
    const { onDeleteOption: mt } = r;
    mt && mt(rt);
  }
  function Ve(rt) {
    const { onClear: mt } = r;
    mt && mt(rt);
  }
  function Ge(rt) {
    const { onPatternInput: mt } = r;
    mt && mt(rt);
  }
  function et(rt) {
    var mt;
    (!rt.relatedTarget || !(!((mt = p.value) === null || mt === void 0) && mt.contains(rt.relatedTarget))) && le(rt);
  }
  function dt(rt) {
    var mt;
    !((mt = p.value) === null || mt === void 0) && mt.contains(rt.relatedTarget) || ue(rt);
  }
  function Ct(rt) {
    Ve(rt);
  }
  function kt() {
    N.value = true;
  }
  function ct() {
    N.value = false;
  }
  function it(rt) {
    !r.active || !r.filterable || rt.target !== y.value && rt.preventDefault();
  }
  function pt(rt) {
    be(rt);
  }
  const $t = Ee(false);
  function vt(rt) {
    if (rt.key === "Backspace" && !$t.value && !r.pattern.length) {
      const { selectedOptions: mt } = r;
      (mt == null ? void 0 : mt.length) && pt(mt[mt.length - 1]);
    }
  }
  let Pt = null;
  function Nt(rt) {
    const { value: mt } = f;
    if (mt) {
      const nr = rt.target.value;
      mt.textContent = nr, ee();
    }
    r.ignoreComposition && $t.value ? Pt = rt : Ge(rt);
  }
  function ir() {
    $t.value = true;
  }
  function bt() {
    $t.value = false, r.ignoreComposition && Ge(Pt), Pt = null;
  }
  function Dt(rt) {
    var mt;
    q.value = true, (mt = r.onPatternFocus) === null || mt === void 0 || mt.call(r, rt);
  }
  function Zt(rt) {
    var mt;
    q.value = false, (mt = r.onPatternBlur) === null || mt === void 0 || mt.call(r, rt);
  }
  function dr() {
    var rt, mt;
    if (r.filterable) q.value = false, (rt = P.value) === null || rt === void 0 || rt.blur(), (mt = y.value) === null || mt === void 0 || mt.blur();
    else if (r.multiple) {
      const { value: nr } = s;
      nr == null ? void 0 : nr.blur();
    } else {
      const { value: nr } = S;
      nr == null ? void 0 : nr.blur();
    }
  }
  function yr() {
    var rt, mt, nr;
    r.filterable ? (q.value = false, (rt = P.value) === null || rt === void 0 || rt.focus()) : r.multiple ? (mt = s.value) === null || mt === void 0 || mt.focus() : (nr = S.value) === null || nr === void 0 || nr.focus();
  }
  function Pr() {
    const { value: rt } = y;
    rt && (ve(), rt.focus());
  }
  function lr() {
    const { value: rt } = y;
    rt && rt.blur();
  }
  function Ir(rt) {
    const { value: mt } = M;
    mt && mt.setTextContent(`+${rt}`);
  }
  function Ht() {
    const { value: rt } = A;
    return rt;
  }
  function Rr() {
    return y.value;
  }
  let xr = null;
  function gt() {
    xr !== null && window.clearTimeout(xr);
  }
  function Be() {
    r.active || (gt(), xr = window.setTimeout(() => {
      oe.value && (L.value = true);
    }, 100));
  }
  function ot() {
    gt();
  }
  function $e(rt) {
    rt || (gt(), L.value = false);
  }
  Kt(oe, (rt) => {
    rt || (L.value = false);
  }), Ei(() => {
    Ao(() => {
      const rt = P.value;
      rt && (r.disabled ? rt.removeAttribute("tabindex") : rt.tabIndex = q.value ? -1 : 0);
    });
  }), Z1(p, r.onResize);
  const { inlineThemeDisabled: Ye } = r, ht = Ae(() => {
    const { size: rt } = r, { common: { cubicBezierEaseInOut: mt }, self: { fontWeight: nr, borderRadius: di, color: wi, placeholderColor: xn, textColor: en, paddingSingle: wn, paddingMultiple: Cn, caretColor: Bi, colorDisabled: Ci, textColorDisabled: Me, placeholderColorDisabled: $, colorActive: Z, boxShadowFocus: Q, boxShadowActive: ge, boxShadowHover: _e, border: Re, borderFocus: se, borderHover: Fe, borderActive: We, arrowColor: Qe, arrowColorDisabled: tt, loadingColor: At, colorActiveWarning: qt, boxShadowFocusWarning: sr, boxShadowActiveWarning: Ur, boxShadowHoverWarning: mr, borderWarning: Sr, borderFocusWarning: Dr, borderHoverWarning: ye, borderActiveWarning: at, colorActiveError: Ft, boxShadowFocusError: hr, boxShadowActiveError: ur, boxShadowHoverError: st, borderError: Bt, borderFocusError: Xt, borderHoverError: hi, borderActiveError: Sn, clearColor: Jr, clearColorHover: ar, clearColorPressed: Wn, clearSize: Lo, arrowSize: Bo, [Ut("height", rt)]: kn, [Ut("fontSize", rt)]: mo } } = J.value, Zn = qo(wn), Hn = qo(Cn);
    return { "--n-bezier": mt, "--n-border": Re, "--n-border-active": We, "--n-border-focus": se, "--n-border-hover": Fe, "--n-border-radius": di, "--n-box-shadow-active": ge, "--n-box-shadow-focus": Q, "--n-box-shadow-hover": _e, "--n-caret-color": Bi, "--n-color": wi, "--n-color-active": Z, "--n-color-disabled": Ci, "--n-font-size": mo, "--n-height": kn, "--n-padding-single-top": Zn.top, "--n-padding-multiple-top": Hn.top, "--n-padding-single-right": Zn.right, "--n-padding-multiple-right": Hn.right, "--n-padding-single-left": Zn.left, "--n-padding-multiple-left": Hn.left, "--n-padding-single-bottom": Zn.bottom, "--n-padding-multiple-bottom": Hn.bottom, "--n-placeholder-color": xn, "--n-placeholder-color-disabled": $, "--n-text-color": en, "--n-text-color-disabled": Me, "--n-arrow-color": Qe, "--n-arrow-color-disabled": tt, "--n-loading-color": At, "--n-color-active-warning": qt, "--n-box-shadow-focus-warning": sr, "--n-box-shadow-active-warning": Ur, "--n-box-shadow-hover-warning": mr, "--n-border-warning": Sr, "--n-border-focus-warning": Dr, "--n-border-hover-warning": ye, "--n-border-active-warning": at, "--n-color-active-error": Ft, "--n-box-shadow-focus-error": hr, "--n-box-shadow-active-error": ur, "--n-box-shadow-hover-error": st, "--n-border-error": Bt, "--n-border-focus-error": Xt, "--n-border-hover-error": hi, "--n-border-active-error": Sn, "--n-clear-size": Lo, "--n-clear-color": Jr, "--n-clear-color-hover": ar, "--n-clear-color-pressed": Wn, "--n-arrow-size": Bo, "--n-font-weight": nr };
  }), St = Ye ? ai("internal-selection", Ae(() => r.size[0]), ht, r) : void 0;
  return { mergedTheme: J, mergedClearable: te, mergedClsPrefix: n, rtlEnabled: h, patternInputFocused: q, filterablePlaceholder: ne, label: ae, selected: oe, showTagsPanel: L, isComposing: $t, counterRef: M, counterWrapperRef: A, patternInputMirrorRef: f, patternInputRef: y, selfRef: p, multipleElRef: s, singleElRef: S, patternInputWrapperRef: P, overflowRef: O, inputTagElRef: j, handleMouseDown: it, handleFocusin: et, handleClear: Ct, handleMouseEnter: kt, handleMouseLeave: ct, handleDeleteOption: pt, handlePatternKeyDown: vt, handlePatternInputInput: Nt, handlePatternInputBlur: Zt, handlePatternInputFocus: Dt, handleMouseEnterCounter: Be, handleMouseLeaveCounter: ot, handleFocusout: dt, handleCompositionEnd: bt, handleCompositionStart: ir, onPopoverUpdateShow: $e, focus: yr, focusInput: Pr, blur: dr, blurInput: lr, updateCounter: Ir, getCounter: Ht, getTail: Rr, renderLabel: r.renderLabel, cssVars: Ye ? void 0 : ht, themeClass: St == null ? void 0 : St.themeClass, onRender: St == null ? void 0 : St.onRender };
}, render() {
  const { status: r, multiple: n, size: l, disabled: h, filterable: f, maxTagCount: y, bordered: p, clsPrefix: s, ellipsisTagPopoverProps: S, onRender: P, renderTag: M, renderLabel: A } = this;
  P == null ? void 0 : P();
  const O = y === "responsive", j = typeof y == "number", L = O || j, q = B(v3, null, { default: () => B(J1, { clsPrefix: s, loading: this.loading, showArrow: this.showArrow, showClear: this.mergedClearable && this.selected, onClear: this.handleClear }, { default: () => {
    var J, te;
    return (te = (J = this.$slots).arrow) === null || te === void 0 ? void 0 : te.call(J);
  } }) });
  let N;
  if (n) {
    const { labelField: J } = this, te = (Ge) => B("div", { class: `${s}-base-selection-tag-wrapper`, key: Ge.value }, M ? M({ option: Ge, handleClose: () => {
      this.handleDeleteOption(Ge);
    } }) : B(zo, { size: l, closable: !Ge.disabled, disabled: h, onClose: () => {
      this.handleDeleteOption(Ge);
    }, internalCloseIsButtonTag: false, internalCloseFocusable: false }, { default: () => A ? A(Ge, true) : Ul(Ge[J], Ge, true) })), ne = () => (j ? this.selectedOptions.slice(0, y) : this.selectedOptions).map(te), ae = f ? B("div", { class: `${s}-base-selection-input-tag`, ref: "inputTagElRef", key: "__input-tag__" }, B("input", Object.assign({}, this.inputProps, { ref: "patternInputRef", tabindex: -1, disabled: h, value: this.pattern, autofocus: this.autofocus, class: `${s}-base-selection-input-tag__input`, onBlur: this.handlePatternInputBlur, onFocus: this.handlePatternInputFocus, onKeydown: this.handlePatternKeyDown, onInput: this.handlePatternInputInput, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd })), B("span", { ref: "patternInputMirrorRef", class: `${s}-base-selection-input-tag__mirror` }, this.pattern)) : null, oe = O ? () => B("div", { class: `${s}-base-selection-tag-wrapper`, ref: "counterWrapperRef" }, B(zo, { size: l, ref: "counterRef", onMouseenter: this.handleMouseEnterCounter, onMouseleave: this.handleMouseLeaveCounter, disabled: h })) : void 0;
    let ee;
    if (j) {
      const Ge = this.selectedOptions.length - y;
      Ge > 0 && (ee = B("div", { class: `${s}-base-selection-tag-wrapper`, key: "__counter__" }, B(zo, { size: l, ref: "counterRef", onMouseenter: this.handleMouseEnterCounter, disabled: h }, { default: () => `+${Ge}` })));
    }
    const ke = O ? f ? B(k_, { ref: "overflowRef", updateCounter: this.updateCounter, getCounter: this.getCounter, getTail: this.getTail, style: { width: "100%", display: "flex", overflow: "hidden" } }, { default: ne, counter: oe, tail: () => ae }) : B(k_, { ref: "overflowRef", updateCounter: this.updateCounter, getCounter: this.getCounter, style: { width: "100%", display: "flex", overflow: "hidden" } }, { default: ne, counter: oe }) : j && ee ? ne().concat(ee) : ne(), ve = L ? () => B("div", { class: `${s}-base-selection-popover` }, O ? ne() : this.selectedOptions.map(te)) : void 0, le = L ? Object.assign({ show: this.showTagsPanel, trigger: "hover", overlap: true, placement: "top", width: "trigger", onUpdateShow: this.onPopoverUpdateShow, theme: this.mergedTheme.peers.Popover, themeOverrides: this.mergedTheme.peerOverrides.Popover }, S) : null, be = (this.selected ? false : this.active ? !this.pattern && !this.isComposing : true) ? B("div", { class: `${s}-base-selection-placeholder ${s}-base-selection-overlay` }, B("div", { class: `${s}-base-selection-placeholder__inner` }, this.placeholder)) : null, Ve = f ? B("div", { ref: "patternInputWrapperRef", class: `${s}-base-selection-tags` }, ke, O ? null : ae, q) : B("div", { ref: "multipleElRef", class: `${s}-base-selection-tags`, tabindex: h ? void 0 : 0 }, ke, q);
    N = B(jr, null, L ? B(K0, Object.assign({}, le, { scrollable: true, style: "max-height: calc(var(--v-target-height) * 6.6);" }), { trigger: () => Ve, default: ve }) : Ve, be);
  } else if (f) {
    const J = this.pattern || this.isComposing, te = this.active ? !J : !this.selected, ne = this.active ? false : this.selected;
    N = B("div", { ref: "patternInputWrapperRef", class: `${s}-base-selection-label`, title: this.patternInputFocused ? void 0 : I0(this.label) }, B("input", Object.assign({}, this.inputProps, { ref: "patternInputRef", class: `${s}-base-selection-input`, value: this.active ? this.pattern : "", placeholder: "", readonly: h, disabled: h, tabindex: -1, autofocus: this.autofocus, onFocus: this.handlePatternInputFocus, onBlur: this.handlePatternInputBlur, onInput: this.handlePatternInputInput, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd })), ne ? B("div", { class: `${s}-base-selection-label__render-label ${s}-base-selection-overlay`, key: "input" }, B("div", { class: `${s}-base-selection-overlay__wrapper` }, M ? M({ option: this.selectedOption, handleClose: () => {
    } }) : A ? A(this.selectedOption, true) : Ul(this.label, this.selectedOption, true))) : null, te ? B("div", { class: `${s}-base-selection-placeholder ${s}-base-selection-overlay`, key: "placeholder" }, B("div", { class: `${s}-base-selection-overlay__wrapper` }, this.filterablePlaceholder)) : null, q);
  } else N = B("div", { ref: "singleElRef", class: `${s}-base-selection-label`, tabindex: this.disabled ? void 0 : 0 }, this.label !== void 0 ? B("div", { class: `${s}-base-selection-input`, title: I0(this.label), key: "input" }, B("div", { class: `${s}-base-selection-input__content` }, M ? M({ option: this.selectedOption, handleClose: () => {
  } }) : A ? A(this.selectedOption, true) : Ul(this.label, this.selectedOption, true))) : B("div", { class: `${s}-base-selection-placeholder ${s}-base-selection-overlay`, key: "placeholder" }, B("div", { class: `${s}-base-selection-placeholder__inner` }, this.placeholder)), q);
  return B("div", { ref: "selfRef", class: [`${s}-base-selection`, this.rtlEnabled && `${s}-base-selection--rtl`, this.themeClass, r && `${s}-base-selection--${r}-status`, { [`${s}-base-selection--active`]: this.active, [`${s}-base-selection--selected`]: this.selected || this.active && this.pattern, [`${s}-base-selection--disabled`]: this.disabled, [`${s}-base-selection--multiple`]: this.multiple, [`${s}-base-selection--focus`]: this.focused }], style: this.cssVars, onClick: this.onClick, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onKeydown: this.onKeydown, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onMousedown: this.handleMouseDown }, N, p ? B("div", { class: `${s}-base-selection__border` }) : null, p ? B("div", { class: `${s}-base-selection__state-border` }) : null);
} }), PP = he("alert", `
 line-height: var(--n-line-height);
 border-radius: var(--n-border-radius);
 position: relative;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-color);
 text-align: start;
 word-break: break-word;
`, [Le("border", `
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 transition: border-color .3s var(--n-bezier);
 border: var(--n-border);
 pointer-events: none;
 `), Ue("closable", [he("alert-body", [Le("title", `
 padding-right: 24px;
 `)])]), Le("icon", { color: "var(--n-icon-color)" }), he("alert-body", { padding: "var(--n-padding)" }, [Le("title", { color: "var(--n-title-text-color)" }), Le("content", { color: "var(--n-content-text-color)" })]), Up({ originalTransition: "transform .3s var(--n-bezier)", enterToProps: { transform: "scale(1)" }, leaveToProps: { transform: "scale(0.9)" } }), Le("icon", `
 position: absolute;
 left: 0;
 top: 0;
 align-items: center;
 justify-content: center;
 display: flex;
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 margin: var(--n-icon-margin);
 `), Le("close", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 position: absolute;
 right: 0;
 top: 0;
 margin: var(--n-close-margin);
 `), Ue("show-icon", [he("alert-body", { paddingLeft: "calc(var(--n-icon-margin-left) + var(--n-icon-size) + var(--n-icon-margin-right))" })]), Ue("right-adjust", [he("alert-body", { paddingRight: "calc(var(--n-close-size) + var(--n-padding) + 2px)" })]), he("alert-body", `
 border-radius: var(--n-border-radius);
 transition: border-color .3s var(--n-bezier);
 `, [Le("title", `
 transition: color .3s var(--n-bezier);
 font-size: 16px;
 line-height: 19px;
 font-weight: var(--n-title-font-weight);
 `, [qe("& +", [Le("content", { marginTop: "9px" })])]), Le("content", { transition: "color .3s var(--n-bezier)", fontSize: "var(--n-font-size)" })]), Le("icon", { transition: "color .3s var(--n-bezier)" })]), IP = Object.assign(Object.assign({}, er.props), { title: String, showIcon: { type: Boolean, default: true }, type: { type: String, default: "default" }, bordered: { type: Boolean, default: true }, closable: Boolean, onClose: Function, onAfterLeave: Function, onAfterHide: Function }), Lp = nt({ name: "Alert", inheritAttrs: false, props: IP, slots: Object, setup(r) {
  const { mergedClsPrefixRef: n, mergedBorderedRef: l, inlineThemeDisabled: h, mergedRtlRef: f } = Cr(r), y = er("Alert", "-alert", PP, _3, r, n), p = Ln("Alert", f, n), s = Ae(() => {
    const { common: { cubicBezierEaseInOut: j }, self: L } = y.value, { fontSize: q, borderRadius: N, titleFontWeight: J, lineHeight: te, iconSize: ne, iconMargin: ae, iconMarginRtl: oe, closeIconSize: ee, closeBorderRadius: ke, closeSize: ve, closeMargin: le, closeMarginRtl: ue, padding: be } = L, { type: Ve } = r, { left: Ge, right: et } = qo(ae);
    return { "--n-bezier": j, "--n-color": L[Ut("color", Ve)], "--n-close-icon-size": ee, "--n-close-border-radius": ke, "--n-close-color-hover": L[Ut("closeColorHover", Ve)], "--n-close-color-pressed": L[Ut("closeColorPressed", Ve)], "--n-close-icon-color": L[Ut("closeIconColor", Ve)], "--n-close-icon-color-hover": L[Ut("closeIconColorHover", Ve)], "--n-close-icon-color-pressed": L[Ut("closeIconColorPressed", Ve)], "--n-icon-color": L[Ut("iconColor", Ve)], "--n-border": L[Ut("border", Ve)], "--n-title-text-color": L[Ut("titleTextColor", Ve)], "--n-content-text-color": L[Ut("contentTextColor", Ve)], "--n-line-height": te, "--n-border-radius": N, "--n-font-size": q, "--n-title-font-weight": J, "--n-icon-size": ne, "--n-icon-margin": ae, "--n-icon-margin-rtl": oe, "--n-close-size": ve, "--n-close-margin": le, "--n-close-margin-rtl": ue, "--n-padding": be, "--n-icon-margin-left": Ge, "--n-icon-margin-right": et };
  }), S = h ? ai("alert", Ae(() => r.type[0]), s, r) : void 0, P = Ee(true), M = () => {
    const { onAfterLeave: j, onAfterHide: L } = r;
    j && j(), L && L();
  };
  return { rtlEnabled: p, mergedClsPrefix: n, mergedBordered: l, visible: P, handleCloseClick: () => {
    var j;
    Promise.resolve((j = r.onClose) === null || j === void 0 ? void 0 : j.call(r)).then((L) => {
      L !== false && (P.value = false);
    });
  }, handleAfterLeave: () => {
    M();
  }, mergedTheme: y, cssVars: h ? void 0 : s, themeClass: S == null ? void 0 : S.themeClass, onRender: S == null ? void 0 : S.onRender };
}, render() {
  var r;
  return (r = this.onRender) === null || r === void 0 || r.call(this), B(sm, { onAfterLeave: this.handleAfterLeave }, { default: () => {
    const { mergedClsPrefix: n, $slots: l } = this, h = { class: [`${n}-alert`, this.themeClass, this.closable && `${n}-alert--closable`, this.showIcon && `${n}-alert--show-icon`, !this.title && this.closable && `${n}-alert--right-adjust`, this.rtlEnabled && `${n}-alert--rtl`], style: this.cssVars, role: "alert" };
    return this.visible ? B("div", Object.assign({}, ls(this.$attrs, h)), this.closable && B(am, { clsPrefix: n, class: `${n}-alert__close`, onClick: this.handleCloseClick }), this.bordered && B("div", { class: `${n}-alert__border` }), this.showIcon && B("div", { class: `${n}-alert__icon`, "aria-hidden": "true" }, to(l.icon, () => [B(Nr, { clsPrefix: n }, { default: () => {
      switch (this.type) {
        case "success":
          return B(ev, null);
        case "info":
          return B(Q0, null);
        case "warning":
          return B(lm, null);
        case "error":
          return B(J0, null);
        default:
          return null;
      }
    } })])), B("div", { class: [`${n}-alert-body`, this.mergedBordered && `${n}-alert-body--bordered`] }, oi(l.header, (f) => {
      const y = f || this.title;
      return y ? B("div", { class: `${n}-alert-body__title` }, y) : null;
    }), l.default && B("div", { class: `${n}-alert-body__content` }, l))) : null;
  } });
} }), Bp = qn("n-anchor"), EP = { title: String, href: String }, Op = nt({ name: "AnchorLink", props: EP, slots: Object, setup(r, { slots: n }) {
  const l = Ee(null), h = cr(Bp), f = zt(r, "href"), y = vi(() => f.value && f.value === h.activeHref.value);
  rT(Bp, "collectedLinkHrefs", f), iT(Bp, "titleEls", () => l.value), Kt(y, (s) => {
    s && l.value && h.updateBarPosition(l.value);
  });
  function p() {
    r.href !== void 0 && h.setActiveHref(r.href);
  }
  return () => {
    var s;
    const { value: S } = h.mergedClsPrefix;
    return B("div", { class: [`${S}-anchor-link`, y.value && `${S}-anchor-link--active`] }, B("a", { ref: l, class: [`${S}-anchor-link__title`], href: r.href, title: I0(r.title), onClick: p }, { default: () => to(n.title, () => [r.title]) }), (s = n.default) === null || s === void 0 ? void 0 : s.call(n));
  };
} });
function MP(r, n) {
  const { top: l, height: h } = r.getBoundingClientRect(), f = n instanceof HTMLElement ? n.getBoundingClientRect().top : 0;
  return { top: l - f, height: h };
}
const ov = { type: { type: String, default: "rail" }, showRail: { type: Boolean, default: true }, showBackground: { type: Boolean, default: true }, bound: { type: Number, default: 12 }, internalScrollable: Boolean, ignoreGap: Boolean, offsetTarget: [String, Object, Function] }, DP = Ch(ov), RP = nt({ name: "BaseAnchor", props: Object.assign(Object.assign({}, ov), { mergedClsPrefix: { type: String, required: true } }), setup(r) {
  const n = [], l = [], h = Ee(null), f = Ee(null), y = Ee(null), p = Ee(null);
  let s = false;
  const S = Ae(() => r.type === "block"), P = Ae(() => !S.value && r.showRail);
  function M() {
    const { value: te } = y, { value: ne } = f;
    te && (te.style.transition = "none"), ne && (ne.style.transition = "none"), l && l.forEach((ae) => {
      ae.style.transition = "none";
    }), eo(() => {
      const { value: ae } = y, { value: oe } = f;
      ae && (ae.offsetWidth, ae.style.transition = ""), oe && (oe.offsetWidth, oe.style.transition = ""), l && l.forEach((ee) => {
        ee.offsetWidth, ee.style.transition = "";
      });
    });
  }
  function A(te, ne = true) {
    const { value: ae } = y, { value: oe } = f, { value: ee } = p;
    if (!ee || !ae) return;
    ne || (ae.style.transition = "none", oe && (oe.style.transition = "none"));
    const { offsetHeight: ke, offsetWidth: ve } = te, { top: le, left: ue } = te.getBoundingClientRect(), { top: be, left: Ve } = ee.getBoundingClientRect(), Ge = le - be, et = ue - Ve;
    ae.style.top = `${Ge}px`, ae.style.height = `${ke}px`, oe && (oe.style.top = `${Ge}px`, oe.style.height = `${ke}px`, oe.style.maxWidth = `${ve + et}px`), ae.offsetHeight, oe && oe.offsetHeight, ne || (ae.style.transition = "", oe && (oe.style.transition = ""));
  }
  let O, j = false, L = false;
  const q = () => {
    if (L) j = true;
    else {
      if (s) return;
      J(true), L = true, clearTimeout(O), O = setTimeout(() => {
        L = false, j && (j = false, q());
      }, 128);
    }
  };
  function N(te, ne = true) {
    const ae = /^#([^#]+)$/.exec(te);
    if (!ae) return;
    const oe = document.getElementById(ae[1]);
    oe && (s = true, h.value = te, oe.scrollIntoView(), ne || M(), j = false, setTimeout(() => {
      s = false;
    }, 0));
  }
  function J(te = true) {
    var ne;
    const ae = [], oe = G1((ne = r.offsetTarget) !== null && ne !== void 0 ? ne : document);
    n.forEach((ue) => {
      const be = /#([^#]+)$/.exec(ue);
      if (!be) return;
      const Ve = document.getElementById(be[1]);
      if (Ve && oe) {
        const { top: Ge, height: et } = MP(Ve, oe);
        ae.push({ top: Ge, height: et, href: ue });
      }
    }), ae.sort((ue, be) => ue.top > be.top ? 1 : (ue.top === be.top && ue.height < be.height, -1));
    const ee = h.value, { bound: ke, ignoreGap: ve } = r, le = ae.reduce((ue, be) => be.top + be.height < 0 ? ve ? be : ue : be.top <= ke ? ue === null ? be : be.top === ue.top ? be.href === ee ? be : ue : be.top > ue.top ? be : ue : ue, null);
    te || M(), le ? h.value = le.href : h.value = null;
  }
  return Vr(Bp, { activeHref: h, mergedClsPrefix: zt(r, "mergedClsPrefix"), updateBarPosition: A, setActiveHref: N, collectedLinkHrefs: n, titleEls: l }), Ei(() => {
    document.addEventListener("scroll", q, true), N(window.location.hash), J(false);
  }), o1(() => {
    N(window.location.hash), J(false);
  }), Fn(() => {
    clearTimeout(O), document.removeEventListener("scroll", q, true);
  }), Kt(h, (te) => {
    if (te === null) {
      const { value: ne } = f;
      ne && !S.value && (ne.style.maxWidth = "0");
    }
  }), { selfRef: p, barRef: y, slotRef: f, setActiveHref: N, activeHref: h, isBlockType: S, mergedShowRail: P };
}, render() {
  var r;
  const { mergedClsPrefix: n, mergedShowRail: l, isBlockType: h, $slots: f } = this, y = B("div", { class: [`${n}-anchor`, h && `${n}-anchor--block`, l && `${n}-anchor--show-rail`], ref: "selfRef" }, l && this.showBackground ? B("div", { ref: "slotRef", class: `${n}-anchor-link-background` }) : null, l ? B("div", { class: `${n}-anchor-rail` }, B("div", { ref: "barRef", class: [`${n}-anchor-rail__bar`, this.activeHref !== null && `${n}-anchor-rail__bar--active`] })) : null, (r = f.default) === null || r === void 0 ? void 0 : r.call(f));
  return this.internalScrollable ? B(Bh, null, { default: () => y }) : y;
} }), AP = he("anchor", `
 position: relative;
`, [ci("block", `
 padding-left: var(--n-rail-width);
 `, [he("anchor-link", [qe("+, >", [he("anchor-link", `
 margin-top: .5em;
 `)])]), he("anchor-link-background", `
 max-width: 0;
 border-top-right-radius: 10.5px;
 border-bottom-right-radius: 10.5px;
 `), ci("show-rail", [qe(">", [he("anchor-link", "padding-left: 0;")])])]), Ue("block", [he("anchor-link", `
 margin-bottom: 4px;
 padding: 2px 8px;
 transition: background-color .3s var(--n-bezier);
 background-color: transparent;
 border-radius: var(--n-link-border-radius);
 `, [Ue("active", `
 background-color: var(--n-link-color);
 `)])]), he("anchor-link-background", `
 position: absolute;
 left: calc(var(--n-rail-width) / 2);
 width: 100%;
 background-color: var(--n-link-color);
 transition:
 top .15s var(--n-bezier),
 max-width .15s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), he("anchor-rail", `
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 width: var(--n-rail-width);
 border-radius: calc(var(--n-rail-width) / 2);
 overflow: hidden;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [Le("bar", `
 position: absolute;
 left: 0;
 width: var(--n-rail-width);
 height: 21px;
 background-color: #0000;
 transition: 
 top .15s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [Ue("active", { backgroundColor: "var(--n-rail-color-active)" })])]), he("anchor-link", `
 padding: var(--n-link-padding);
 position: relative;
 line-height: 1.5;
 font-size: var(--n-link-font-size);
 min-height: 1.5em;
 display: flex;
 flex-direction: column;
 `, [Ue("active", [qe(">", [Le("title", `
 color: var(--n-link-text-color-active);
 `)])]), Le("title", `
 outline: none;
 max-width: 100%;
 text-decoration: none;
 white-space: nowrap;
 text-overflow: ellipsis;
 overflow: hidden;
 cursor: pointer;
 display: inline-block;
 padding-right: 16px;
 transition: color .3s var(--n-bezier);
 color: var(--n-link-text-color);
 `, [qe("&:hover, &:focus", `
 color: var(--n-link-text-color-hover);
 `), qe("&:active", `
 color: var(--n-link-text-color-pressed);
 `)])])]), zP = Object.assign(Object.assign(Object.assign(Object.assign({}, er.props), { affix: Boolean }), nv), ov), Q1 = nt({ name: "Anchor", props: zP, setup(r, { slots: n }) {
  const { mergedClsPrefixRef: l, inlineThemeDisabled: h } = Cr(r), f = er("Anchor", "-anchor", AP, b3, r, l), y = Ee(null), p = Ae(() => {
    const { self: { railColor: S, linkColor: P, railColorActive: M, linkTextColor: A, linkTextColorHover: O, linkTextColorPressed: j, linkTextColorActive: L, linkFontSize: q, railWidth: N, linkPadding: J, borderRadius: te }, common: { cubicBezierEaseInOut: ne } } = f.value;
    return { "--n-link-border-radius": te, "--n-link-color": P, "--n-link-font-size": q, "--n-link-text-color": A, "--n-link-text-color-hover": O, "--n-link-text-color-active": L, "--n-link-text-color-pressed": j, "--n-link-padding": J, "--n-bezier": ne, "--n-rail-color": S, "--n-rail-color-active": M, "--n-rail-width": N };
  }), s = h ? ai("anchor", void 0, p, r) : void 0;
  return { scrollTo(S) {
    var P;
    (P = y.value) === null || P === void 0 || P.setActiveHref(S);
  }, renderAnchor: () => (s == null ? void 0 : s.onRender(), B(RP, Object.assign({ ref: y, style: h ? void 0 : p.value, class: s == null ? void 0 : s.themeClass.value }, _0(r, DP), { mergedClsPrefix: l.value }), n)) };
}, render() {
  return this.affix ? B(JT, Object.assign({}, _0(this, KT)), { default: this.renderAnchor }) : this.renderAnchor();
} }), ex = qn("n-input"), FP = he("input", `
 max-width: 100%;
 cursor: text;
 line-height: 1.5;
 z-index: auto;
 outline: none;
 box-sizing: border-box;
 position: relative;
 display: inline-flex;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color .3s var(--n-bezier);
 font-size: var(--n-font-size);
 font-weight: var(--n-font-weight);
 --n-padding-vertical: calc((var(--n-height) - 1.5 * var(--n-font-size)) / 2);
`, [Le("input, textarea", `
 overflow: hidden;
 flex-grow: 1;
 position: relative;
 `), Le("input-el, textarea-el, input-mirror, textarea-mirror, separator, placeholder", `
 box-sizing: border-box;
 font-size: inherit;
 line-height: 1.5;
 font-family: inherit;
 border: none;
 outline: none;
 background-color: #0000;
 text-align: inherit;
 transition:
 -webkit-text-fill-color .3s var(--n-bezier),
 caret-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 `), Le("input-el, textarea-el", `
 -webkit-appearance: none;
 scrollbar-width: none;
 width: 100%;
 min-width: 0;
 text-decoration-color: var(--n-text-decoration-color);
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 background-color: transparent;
 `, [qe("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), qe("&::placeholder", `
 color: #0000;
 -webkit-text-fill-color: transparent !important;
 `), qe("&:-webkit-autofill ~", [Le("placeholder", "display: none;")])]), Ue("round", [ci("textarea", "border-radius: calc(var(--n-height) / 2);")]), Le("placeholder", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: hidden;
 color: var(--n-placeholder-color);
 `, [qe("span", `
 width: 100%;
 display: inline-block;
 `)]), Ue("textarea", [Le("placeholder", "overflow: visible;")]), ci("autosize", "width: 100%;"), Ue("autosize", [Le("textarea-el, input-el", `
 position: absolute;
 top: 0;
 left: 0;
 height: 100%;
 `)]), he("input-wrapper", `
 overflow: hidden;
 display: inline-flex;
 flex-grow: 1;
 position: relative;
 padding-left: var(--n-padding-left);
 padding-right: var(--n-padding-right);
 `), Le("input-mirror", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre;
 pointer-events: none;
 `), Le("input-el", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [qe("&[type=password]::-ms-reveal", "display: none;"), qe("+", [Le("placeholder", `
 display: flex;
 align-items: center; 
 `)])]), ci("textarea", [Le("placeholder", "white-space: nowrap;")]), Le("eye", `
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `), Ue("textarea", "width: 100%;", [he("input-word-count", `
 position: absolute;
 right: var(--n-padding-right);
 bottom: var(--n-padding-vertical);
 `), Ue("resizable", [he("input-wrapper", `
 resize: vertical;
 min-height: var(--n-height);
 `)]), Le("textarea-el, textarea-mirror, placeholder", `
 height: 100%;
 padding-left: 0;
 padding-right: 0;
 padding-top: var(--n-padding-vertical);
 padding-bottom: var(--n-padding-vertical);
 word-break: break-word;
 display: inline-block;
 vertical-align: bottom;
 box-sizing: border-box;
 line-height: var(--n-line-height-textarea);
 margin: 0;
 resize: none;
 white-space: pre-wrap;
 scroll-padding-block-end: var(--n-padding-vertical);
 `), Le("textarea-mirror", `
 width: 100%;
 pointer-events: none;
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre-wrap;
 overflow-wrap: break-word;
 `)]), Ue("pair", [Le("input-el, placeholder", "text-align: center;"), Le("separator", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 white-space: nowrap;
 `, [he("icon", `
 color: var(--n-icon-color);
 `), he("base-icon", `
 color: var(--n-icon-color);
 `)])]), Ue("disabled", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [Le("border", "border: var(--n-border-disabled);"), Le("input-el, textarea-el", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 text-decoration-color: var(--n-text-color-disabled);
 `), Le("placeholder", "color: var(--n-placeholder-color-disabled);"), Le("separator", "color: var(--n-text-color-disabled);", [he("icon", `
 color: var(--n-icon-color-disabled);
 `), he("base-icon", `
 color: var(--n-icon-color-disabled);
 `)]), he("input-word-count", `
 color: var(--n-count-text-color-disabled);
 `), Le("suffix, prefix", "color: var(--n-text-color-disabled);", [he("icon", `
 color: var(--n-icon-color-disabled);
 `), he("internal-icon", `
 color: var(--n-icon-color-disabled);
 `)])]), ci("disabled", [Le("eye", `
 color: var(--n-icon-color);
 cursor: pointer;
 `, [qe("&:hover", `
 color: var(--n-icon-color-hover);
 `), qe("&:active", `
 color: var(--n-icon-color-pressed);
 `)]), qe("&:hover", [Le("state-border", "border: var(--n-border-hover);")]), Ue("focus", "background-color: var(--n-color-focus);", [Le("state-border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), Le("border, state-border", `
 box-sizing: border-box;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border-radius: inherit;
 border: var(--n-border);
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), Le("state-border", `
 border-color: #0000;
 z-index: 1;
 `), Le("prefix", "margin-right: 4px;"), Le("suffix", `
 margin-left: 4px;
 `), Le("suffix, prefix", `
 transition: color .3s var(--n-bezier);
 flex-wrap: nowrap;
 flex-shrink: 0;
 line-height: var(--n-height);
 white-space: nowrap;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 color: var(--n-suffix-text-color);
 `, [he("base-loading", `
 font-size: var(--n-icon-size);
 margin: 0 2px;
 color: var(--n-loading-color);
 `), he("base-clear", `
 font-size: var(--n-icon-size);
 `, [Le("placeholder", [he("base-icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)])]), qe(">", [he("icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)]), he("base-icon", `
 font-size: var(--n-icon-size);
 `)]), he("input-word-count", `
 pointer-events: none;
 line-height: 1.5;
 font-size: .85em;
 color: var(--n-count-text-color);
 transition: color .3s var(--n-bezier);
 margin-left: 4px;
 font-variant: tabular-nums;
 `), ["warning", "error"].map((r) => Ue(`${r}-status`, [ci("disabled", [he("base-loading", `
 color: var(--n-loading-color-${r})
 `), Le("input-el, textarea-el", `
 caret-color: var(--n-caret-color-${r});
 `), Le("state-border", `
 border: var(--n-border-${r});
 `), qe("&:hover", [Le("state-border", `
 border: var(--n-border-hover-${r});
 `)]), qe("&:focus", `
 background-color: var(--n-color-focus-${r});
 `, [Le("state-border", `
 box-shadow: var(--n-box-shadow-focus-${r});
 border: var(--n-border-focus-${r});
 `)]), Ue("focus", `
 background-color: var(--n-color-focus-${r});
 `, [Le("state-border", `
 box-shadow: var(--n-box-shadow-focus-${r});
 border: var(--n-border-focus-${r});
 `)])])]))]), LP = he("input", [Ue("disabled", [Le("input-el, textarea-el", `
 -webkit-text-fill-color: var(--n-text-color-disabled);
 `)])]);
function BP(r) {
  let n = 0;
  for (const l of r) n++;
  return n;
}
function bp(r) {
  return r === "" || r == null;
}
function OP(r) {
  const n = Ee(null);
  function l() {
    const { value: y } = r;
    if (!(y == null ? void 0 : y.focus)) {
      f();
      return;
    }
    const { selectionStart: p, selectionEnd: s, value: S } = y;
    if (p == null || s == null) {
      f();
      return;
    }
    n.value = { start: p, end: s, beforeText: S.slice(0, p), afterText: S.slice(s) };
  }
  function h() {
    var y;
    const { value: p } = n, { value: s } = r;
    if (!p || !s) return;
    const { value: S } = s, { start: P, beforeText: M, afterText: A } = p;
    let O = S.length;
    if (S.endsWith(A)) O = S.length - A.length;
    else if (S.startsWith(M)) O = M.length;
    else {
      const j = M[P - 1], L = S.indexOf(j, P - 1);
      L !== -1 && (O = L + 1);
    }
    (y = s.setSelectionRange) === null || y === void 0 || y.call(s, O, O);
  }
  function f() {
    n.value = null;
  }
  return Kt(r, f), { recordCursor: l, restoreCursor: h };
}
const N_ = nt({ name: "InputWordCount", setup(r, { slots: n }) {
  const { mergedValueRef: l, maxlengthRef: h, mergedClsPrefixRef: f, countGraphemesRef: y } = cr(ex), p = Ae(() => {
    const { value: s } = l;
    return s === null || Array.isArray(s) ? 0 : (y.value || BP)(s);
  });
  return () => {
    const { value: s } = h, { value: S } = l;
    return B("span", { class: `${f.value}-input-word-count` }, b0(n.default, { value: S === null || Array.isArray(S) ? "" : S }, () => [s === void 0 ? p.value : `${p.value} / ${s}`]));
  };
} }), $P = Object.assign(Object.assign({}, er.props), { bordered: { type: Boolean, default: void 0 }, type: { type: String, default: "text" }, placeholder: [Array, String], defaultValue: { type: [String, Array], default: null }, value: [String, Array], disabled: { type: Boolean, default: void 0 }, size: String, rows: { type: [Number, String], default: 3 }, round: Boolean, minlength: [String, Number], maxlength: [String, Number], clearable: Boolean, autosize: { type: [Boolean, Object], default: false }, pair: Boolean, separator: String, readonly: { type: [String, Boolean], default: false }, passivelyActivated: Boolean, showPasswordOn: String, stateful: { type: Boolean, default: true }, autofocus: Boolean, inputProps: Object, resizable: { type: Boolean, default: true }, showCount: Boolean, loading: { type: Boolean, default: void 0 }, allowInput: Function, renderCount: Function, onMousedown: Function, onKeydown: Function, onKeyup: [Function, Array], onInput: [Function, Array], onFocus: [Function, Array], onBlur: [Function, Array], onClick: [Function, Array], onChange: [Function, Array], onClear: [Function, Array], countGraphemes: Function, status: String, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], textDecoration: [String, Array], attrSize: { type: Number, default: 20 }, onInputBlur: [Function, Array], onInputFocus: [Function, Array], onDeactivate: [Function, Array], onActivate: [Function, Array], onWrapperFocus: [Function, Array], onWrapperBlur: [Function, Array], internalDeactivateOnEnter: Boolean, internalForceFocus: Boolean, internalLoadingBeforeSuffix: { type: Boolean, default: true }, showPasswordToggle: Boolean }), Do = nt({ name: "Input", props: $P, slots: Object, setup(r) {
  const { mergedClsPrefixRef: n, mergedBorderedRef: l, inlineThemeDisabled: h, mergedRtlRef: f } = Cr(r), y = er("Input", "-input", FP, x3, r, n);
  w3 && Nc("-input-safari", LP, n);
  const p = Ee(null), s = Ee(null), S = Ee(null), P = Ee(null), M = Ee(null), A = Ee(null), O = Ee(null), j = OP(O), L = Ee(null), { localeRef: q } = ds("Input"), N = Ee(r.defaultValue), J = zt(r, "value"), te = Qi(J, N), ne = Ba(r), { mergedSizeRef: ae, mergedDisabledRef: oe, mergedStatusRef: ee } = ne, ke = Ee(false), ve = Ee(false), le = Ee(false), ue = Ee(false);
  let be = null;
  const Ve = Ae(() => {
    const { placeholder: ye, pair: at } = r;
    return at ? Array.isArray(ye) ? ye : ye === void 0 ? ["", ""] : [ye, ye] : ye === void 0 ? [q.value.placeholder] : [ye];
  }), Ge = Ae(() => {
    const { value: ye } = le, { value: at } = te, { value: Ft } = Ve;
    return !ye && (bp(at) || Array.isArray(at) && bp(at[0])) && Ft[0];
  }), et = Ae(() => {
    const { value: ye } = le, { value: at } = te, { value: Ft } = Ve;
    return !ye && Ft[1] && (bp(at) || Array.isArray(at) && bp(at[1]));
  }), dt = vi(() => r.internalForceFocus || ke.value), Ct = vi(() => {
    if (oe.value || r.readonly || !r.clearable || !dt.value && !ve.value) return false;
    const { value: ye } = te, { value: at } = dt;
    return r.pair ? !!(Array.isArray(ye) && (ye[0] || ye[1])) && (ve.value || at) : !!ye && (ve.value || at);
  }), kt = Ae(() => {
    const { showPasswordOn: ye } = r;
    if (ye) return ye;
    if (r.showPasswordToggle) return "click";
  }), ct = Ee(false), it = Ae(() => {
    const { textDecoration: ye } = r;
    return ye ? Array.isArray(ye) ? ye.map((at) => ({ textDecoration: at })) : [{ textDecoration: ye }] : ["", ""];
  }), pt = Ee(void 0), $t = () => {
    var ye, at;
    if (r.type === "textarea") {
      const { autosize: Ft } = r;
      if (Ft && (pt.value = (at = (ye = L.value) === null || ye === void 0 ? void 0 : ye.$el) === null || at === void 0 ? void 0 : at.offsetWidth), !s.value || typeof Ft == "boolean") return;
      const { paddingTop: hr, paddingBottom: ur, lineHeight: st } = window.getComputedStyle(s.value), Bt = Number(hr.slice(0, -2)), Xt = Number(ur.slice(0, -2)), hi = Number(st.slice(0, -2)), { value: Sn } = S;
      if (!Sn) return;
      if (Ft.minRows) {
        const Jr = Math.max(Ft.minRows, 1), ar = `${Bt + Xt + hi * Jr}px`;
        Sn.style.minHeight = ar;
      }
      if (Ft.maxRows) {
        const Jr = `${Bt + Xt + hi * Ft.maxRows}px`;
        Sn.style.maxHeight = Jr;
      }
    }
  }, vt = Ae(() => {
    const { maxlength: ye } = r;
    return ye === void 0 ? void 0 : Number(ye);
  });
  Ei(() => {
    const { value: ye } = te;
    Array.isArray(ye) || We(ye);
  });
  const Pt = Lh().proxy;
  function Nt(ye, at) {
    const { onUpdateValue: Ft, "onUpdate:value": hr, onInput: ur } = r, { nTriggerFormInput: st } = ne;
    Ft && jt(Ft, ye, at), hr && jt(hr, ye, at), ur && jt(ur, ye, at), N.value = ye, st();
  }
  function ir(ye, at) {
    const { onChange: Ft } = r, { nTriggerFormChange: hr } = ne;
    Ft && jt(Ft, ye, at), N.value = ye, hr();
  }
  function bt(ye) {
    const { onBlur: at } = r, { nTriggerFormBlur: Ft } = ne;
    at && jt(at, ye), Ft();
  }
  function Dt(ye) {
    const { onFocus: at } = r, { nTriggerFormFocus: Ft } = ne;
    at && jt(at, ye), Ft();
  }
  function Zt(ye) {
    const { onClear: at } = r;
    at && jt(at, ye);
  }
  function dr(ye) {
    const { onInputBlur: at } = r;
    at && jt(at, ye);
  }
  function yr(ye) {
    const { onInputFocus: at } = r;
    at && jt(at, ye);
  }
  function Pr() {
    const { onDeactivate: ye } = r;
    ye && jt(ye);
  }
  function lr() {
    const { onActivate: ye } = r;
    ye && jt(ye);
  }
  function Ir(ye) {
    const { onClick: at } = r;
    at && jt(at, ye);
  }
  function Ht(ye) {
    const { onWrapperFocus: at } = r;
    at && jt(at, ye);
  }
  function Rr(ye) {
    const { onWrapperBlur: at } = r;
    at && jt(at, ye);
  }
  function xr() {
    le.value = true;
  }
  function gt(ye) {
    le.value = false, ye.target === A.value ? Be(ye, 1) : Be(ye, 0);
  }
  function Be(ye, at = 0, Ft = "input") {
    const hr = ye.target.value;
    if (We(hr), ye instanceof InputEvent && !ye.isComposing && (le.value = false), r.type === "textarea") {
      const { value: st } = L;
      st && st.syncUnifiedContainer();
    }
    if (be = hr, le.value) return;
    j.recordCursor();
    const ur = ot(hr);
    if (ur) if (!r.pair) Ft === "input" ? Nt(hr, { source: at }) : ir(hr, { source: at });
    else {
      let { value: st } = te;
      Array.isArray(st) ? st = [st[0], st[1]] : st = ["", ""], st[at] = hr, Ft === "input" ? Nt(st, { source: at }) : ir(st, { source: at });
    }
    Pt.$forceUpdate(), ur || eo(j.restoreCursor);
  }
  function ot(ye) {
    const { countGraphemes: at, maxlength: Ft, minlength: hr } = r;
    if (at) {
      let st;
      if (Ft !== void 0 && (st === void 0 && (st = at(ye)), st > Number(Ft)) || hr !== void 0 && (st === void 0 && (st = at(ye)), st < Number(Ft))) return false;
    }
    const { allowInput: ur } = r;
    return typeof ur == "function" ? ur(ye) : true;
  }
  function $e(ye) {
    dr(ye), ye.relatedTarget === p.value && Pr(), ye.relatedTarget !== null && (ye.relatedTarget === M.value || ye.relatedTarget === A.value || ye.relatedTarget === s.value) || (ue.value = false), rt(ye, "blur"), O.value = null;
  }
  function Ye(ye, at) {
    yr(ye), ke.value = true, ue.value = true, lr(), rt(ye, "focus"), at === 0 ? O.value = M.value : at === 1 ? O.value = A.value : at === 2 && (O.value = s.value);
  }
  function ht(ye) {
    r.passivelyActivated && (Rr(ye), rt(ye, "blur"));
  }
  function St(ye) {
    r.passivelyActivated && (ke.value = true, Ht(ye), rt(ye, "focus"));
  }
  function rt(ye, at) {
    ye.relatedTarget !== null && (ye.relatedTarget === M.value || ye.relatedTarget === A.value || ye.relatedTarget === s.value || ye.relatedTarget === p.value) || (at === "focus" ? (Dt(ye), ke.value = true) : at === "blur" && (bt(ye), ke.value = false));
  }
  function mt(ye, at) {
    Be(ye, at, "change");
  }
  function nr(ye) {
    Ir(ye);
  }
  function di(ye) {
    Zt(ye), wi();
  }
  function wi() {
    r.pair ? (Nt(["", ""], { source: "clear" }), ir(["", ""], { source: "clear" })) : (Nt("", { source: "clear" }), ir("", { source: "clear" }));
  }
  function xn(ye) {
    const { onMousedown: at } = r;
    at && at(ye);
    const { tagName: Ft } = ye.target;
    if (Ft !== "INPUT" && Ft !== "TEXTAREA") {
      if (r.resizable) {
        const { value: hr } = p;
        if (hr) {
          const { left: ur, top: st, width: Bt, height: Xt } = hr.getBoundingClientRect(), hi = 14;
          if (ur + Bt - hi < ye.clientX && ye.clientX < ur + Bt && st + Xt - hi < ye.clientY && ye.clientY < st + Xt) return;
        }
      }
      ye.preventDefault(), ke.value || Q();
    }
  }
  function en() {
    var ye;
    ve.value = true, r.type === "textarea" && ((ye = L.value) === null || ye === void 0 || ye.handleMouseEnterWrapper());
  }
  function wn() {
    var ye;
    ve.value = false, r.type === "textarea" && ((ye = L.value) === null || ye === void 0 || ye.handleMouseLeaveWrapper());
  }
  function Cn() {
    oe.value || kt.value === "click" && (ct.value = !ct.value);
  }
  function Bi(ye) {
    if (oe.value) return;
    ye.preventDefault();
    const at = (hr) => {
      hr.preventDefault(), co("mouseup", document, at);
    };
    if (Un("mouseup", document, at), kt.value !== "mousedown") return;
    ct.value = true;
    const Ft = () => {
      ct.value = false, co("mouseup", document, Ft);
    };
    Un("mouseup", document, Ft);
  }
  function Ci(ye) {
    r.onKeyup && jt(r.onKeyup, ye);
  }
  function Me(ye) {
    switch (r.onKeydown && jt(r.onKeydown, ye), ye.key) {
      case "Escape":
        Z();
        break;
      case "Enter":
        $(ye);
        break;
    }
  }
  function $(ye) {
    var at, Ft;
    if (r.passivelyActivated) {
      const { value: hr } = ue;
      if (hr) {
        r.internalDeactivateOnEnter && Z();
        return;
      }
      ye.preventDefault(), r.type === "textarea" ? (at = s.value) === null || at === void 0 || at.focus() : (Ft = M.value) === null || Ft === void 0 || Ft.focus();
    }
  }
  function Z() {
    r.passivelyActivated && (ue.value = false, eo(() => {
      var ye;
      (ye = p.value) === null || ye === void 0 || ye.focus();
    }));
  }
  function Q() {
    var ye, at, Ft;
    oe.value || (r.passivelyActivated ? (ye = p.value) === null || ye === void 0 || ye.focus() : ((at = s.value) === null || at === void 0 || at.focus(), (Ft = M.value) === null || Ft === void 0 || Ft.focus()));
  }
  function ge() {
    var ye;
    !((ye = p.value) === null || ye === void 0) && ye.contains(document.activeElement) && document.activeElement.blur();
  }
  function _e() {
    var ye, at;
    (ye = s.value) === null || ye === void 0 || ye.select(), (at = M.value) === null || at === void 0 || at.select();
  }
  function Re() {
    oe.value || (s.value ? s.value.focus() : M.value && M.value.focus());
  }
  function se() {
    const { value: ye } = p;
    (ye == null ? void 0 : ye.contains(document.activeElement)) && ye !== document.activeElement && Z();
  }
  function Fe(ye) {
    if (r.type === "textarea") {
      const { value: at } = s;
      at == null ? void 0 : at.scrollTo(ye);
    } else {
      const { value: at } = M;
      at == null ? void 0 : at.scrollTo(ye);
    }
  }
  function We(ye) {
    const { type: at, pair: Ft, autosize: hr } = r;
    if (!Ft && hr) if (at === "textarea") {
      const { value: ur } = S;
      ur && (ur.textContent = `${ye ?? ""}\r
`);
    } else {
      const { value: ur } = P;
      ur && (ye ? ur.textContent = ye : ur.innerHTML = "&nbsp;");
    }
  }
  function Qe() {
    $t();
  }
  const tt = Ee({ top: "0" });
  function At(ye) {
    var at;
    const { scrollTop: Ft } = ye.target;
    tt.value.top = `${-Ft}px`, (at = L.value) === null || at === void 0 || at.syncUnifiedContainer();
  }
  let qt = null;
  Ao(() => {
    const { autosize: ye, type: at } = r;
    ye && at === "textarea" ? qt = Kt(te, (Ft) => {
      !Array.isArray(Ft) && Ft !== be && We(Ft);
    }) : qt == null ? void 0 : qt();
  });
  let sr = null;
  Ao(() => {
    r.type === "textarea" ? sr = Kt(te, (ye) => {
      var at;
      !Array.isArray(ye) && ye !== be && ((at = L.value) === null || at === void 0 || at.syncUnifiedContainer());
    }) : sr == null ? void 0 : sr();
  }), Vr(ex, { mergedValueRef: te, maxlengthRef: vt, mergedClsPrefixRef: n, countGraphemesRef: zt(r, "countGraphemes") });
  const Ur = { wrapperElRef: p, inputElRef: M, textareaElRef: s, isCompositing: le, clear: wi, focus: Q, blur: ge, select: _e, deactivate: se, activate: Re, scrollTo: Fe }, mr = Ln("Input", f, n), Sr = Ae(() => {
    const { value: ye } = ae, { common: { cubicBezierEaseInOut: at }, self: { color: Ft, borderRadius: hr, textColor: ur, caretColor: st, caretColorError: Bt, caretColorWarning: Xt, textDecorationColor: hi, border: Sn, borderDisabled: Jr, borderHover: ar, borderFocus: Wn, placeholderColor: Lo, placeholderColorDisabled: Bo, lineHeightTextarea: kn, colorDisabled: mo, colorFocus: Zn, textColorDisabled: Hn, boxShadowFocus: Tn, iconSize: Gr, colorFocusWarning: Gc, boxShadowFocusWarning: ro, borderWarning: Na, borderFocusWarning: Qr, borderHoverWarning: Oo, colorFocusError: Zs, boxShadowFocusError: ga, borderError: Hs, borderFocusError: va, borderHoverError: tu, clearSize: ru, clearColor: qc, clearColorHover: iu, clearColorPressed: nu, iconColor: ou, iconColorDisabled: Xs, suffixTextColor: Ys, countTextColor: au, countTextColorDisabled: Ks, iconColorHover: Js, iconColorPressed: su, loadingColor: go, loadingColorError: fs, loadingColorWarning: lu, fontWeight: io, [Ut("padding", ye)]: uu, [Ut("fontSize", ye)]: Wc, [Ut("height", ye)]: $o } } = y.value, { left: Ho, right: br } = qo(uu);
    return { "--n-bezier": at, "--n-count-text-color": au, "--n-count-text-color-disabled": Ks, "--n-color": Ft, "--n-font-size": Wc, "--n-font-weight": io, "--n-border-radius": hr, "--n-height": $o, "--n-padding-left": Ho, "--n-padding-right": br, "--n-text-color": ur, "--n-caret-color": st, "--n-text-decoration-color": hi, "--n-border": Sn, "--n-border-disabled": Jr, "--n-border-hover": ar, "--n-border-focus": Wn, "--n-placeholder-color": Lo, "--n-placeholder-color-disabled": Bo, "--n-icon-size": Gr, "--n-line-height-textarea": kn, "--n-color-disabled": mo, "--n-color-focus": Zn, "--n-text-color-disabled": Hn, "--n-box-shadow-focus": Tn, "--n-loading-color": go, "--n-caret-color-warning": Xt, "--n-color-focus-warning": Gc, "--n-box-shadow-focus-warning": ro, "--n-border-warning": Na, "--n-border-focus-warning": Qr, "--n-border-hover-warning": Oo, "--n-loading-color-warning": lu, "--n-caret-color-error": Bt, "--n-color-focus-error": Zs, "--n-box-shadow-focus-error": ga, "--n-border-error": Hs, "--n-border-focus-error": va, "--n-border-hover-error": tu, "--n-loading-color-error": fs, "--n-clear-color": qc, "--n-clear-size": ru, "--n-clear-color-hover": iu, "--n-clear-color-pressed": nu, "--n-icon-color": ou, "--n-icon-color-hover": Js, "--n-icon-color-pressed": su, "--n-icon-color-disabled": Xs, "--n-suffix-text-color": Ys };
  }), Dr = h ? ai("input", Ae(() => {
    const { value: ye } = ae;
    return ye[0];
  }), Sr, r) : void 0;
  return Object.assign(Object.assign({}, Ur), { wrapperElRef: p, inputElRef: M, inputMirrorElRef: P, inputEl2Ref: A, textareaElRef: s, textareaMirrorElRef: S, textareaScrollbarInstRef: L, rtlEnabled: mr, uncontrolledValue: N, mergedValue: te, passwordVisible: ct, mergedPlaceholder: Ve, showPlaceholder1: Ge, showPlaceholder2: et, mergedFocus: dt, isComposing: le, activated: ue, showClearButton: Ct, mergedSize: ae, mergedDisabled: oe, textDecorationStyle: it, mergedClsPrefix: n, mergedBordered: l, mergedShowPasswordOn: kt, placeholderStyle: tt, mergedStatus: ee, textAreaScrollContainerWidth: pt, handleTextAreaScroll: At, handleCompositionStart: xr, handleCompositionEnd: gt, handleInput: Be, handleInputBlur: $e, handleInputFocus: Ye, handleWrapperBlur: ht, handleWrapperFocus: St, handleMouseEnter: en, handleMouseLeave: wn, handleMouseDown: xn, handleChange: mt, handleClick: nr, handleClear: di, handlePasswordToggleClick: Cn, handlePasswordToggleMousedown: Bi, handleWrapperKeydown: Me, handleWrapperKeyup: Ci, handleTextAreaMirrorResize: Qe, getTextareaScrollContainer: () => s.value, mergedTheme: y, cssVars: h ? void 0 : Sr, themeClass: Dr == null ? void 0 : Dr.themeClass, onRender: Dr == null ? void 0 : Dr.onRender });
}, render() {
  var r, n, l, h, f, y, p;
  const { mergedClsPrefix: s, mergedStatus: S, themeClass: P, type: M, countGraphemes: A, onRender: O } = this, j = this.$slots;
  return O == null ? void 0 : O(), B("div", { ref: "wrapperElRef", class: [`${s}-input`, P, S && `${s}-input--${S}-status`, { [`${s}-input--rtl`]: this.rtlEnabled, [`${s}-input--disabled`]: this.mergedDisabled, [`${s}-input--textarea`]: M === "textarea", [`${s}-input--resizable`]: this.resizable && !this.autosize, [`${s}-input--autosize`]: this.autosize, [`${s}-input--round`]: this.round && M !== "textarea", [`${s}-input--pair`]: this.pair, [`${s}-input--focus`]: this.mergedFocus, [`${s}-input--stateful`]: this.stateful }], style: this.cssVars, tabindex: !this.mergedDisabled && this.passivelyActivated && !this.activated ? 0 : void 0, onFocus: this.handleWrapperFocus, onBlur: this.handleWrapperBlur, onClick: this.handleClick, onMousedown: this.handleMouseDown, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd, onKeyup: this.handleWrapperKeyup, onKeydown: this.handleWrapperKeydown }, B("div", { class: `${s}-input-wrapper` }, oi(j.prefix, (L) => L && B("div", { class: `${s}-input__prefix` }, L)), M === "textarea" ? B(Bh, { ref: "textareaScrollbarInstRef", class: `${s}-input__textarea`, container: this.getTextareaScrollContainer, theme: (n = (r = this.theme) === null || r === void 0 ? void 0 : r.peers) === null || n === void 0 ? void 0 : n.Scrollbar, themeOverrides: (h = (l = this.themeOverrides) === null || l === void 0 ? void 0 : l.peers) === null || h === void 0 ? void 0 : h.Scrollbar, triggerDisplayManually: true, useUnifiedContainer: true, internalHoistYRail: true }, { default: () => {
    var L, q;
    const { textAreaScrollContainerWidth: N } = this, J = { width: this.autosize && N && `${N}px` };
    return B(jr, null, B("textarea", Object.assign({}, this.inputProps, { ref: "textareaElRef", class: [`${s}-input__textarea-el`, (L = this.inputProps) === null || L === void 0 ? void 0 : L.class], autofocus: this.autofocus, rows: Number(this.rows), placeholder: this.placeholder, value: this.mergedValue, disabled: this.mergedDisabled, maxlength: A ? void 0 : this.maxlength, minlength: A ? void 0 : this.minlength, readonly: this.readonly, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, style: [this.textDecorationStyle[0], (q = this.inputProps) === null || q === void 0 ? void 0 : q.style, J], onBlur: this.handleInputBlur, onFocus: (te) => {
      this.handleInputFocus(te, 2);
    }, onInput: this.handleInput, onChange: this.handleChange, onScroll: this.handleTextAreaScroll })), this.showPlaceholder1 ? B("div", { class: `${s}-input__placeholder`, style: [this.placeholderStyle, J], key: "placeholder" }, this.mergedPlaceholder[0]) : null, this.autosize ? B(ql, { onResize: this.handleTextAreaMirrorResize }, { default: () => B("div", { ref: "textareaMirrorElRef", class: `${s}-input__textarea-mirror`, key: "mirror" }) }) : null);
  } }) : B("div", { class: `${s}-input__input` }, B("input", Object.assign({ type: M === "password" && this.mergedShowPasswordOn && this.passwordVisible ? "text" : M }, this.inputProps, { ref: "inputElRef", class: [`${s}-input__input-el`, (f = this.inputProps) === null || f === void 0 ? void 0 : f.class], style: [this.textDecorationStyle[0], (y = this.inputProps) === null || y === void 0 ? void 0 : y.style], tabindex: this.passivelyActivated && !this.activated ? -1 : (p = this.inputProps) === null || p === void 0 ? void 0 : p.tabindex, placeholder: this.mergedPlaceholder[0], disabled: this.mergedDisabled, maxlength: A ? void 0 : this.maxlength, minlength: A ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[0] : this.mergedValue, readonly: this.readonly, autofocus: this.autofocus, size: this.attrSize, onBlur: this.handleInputBlur, onFocus: (L) => {
    this.handleInputFocus(L, 0);
  }, onInput: (L) => {
    this.handleInput(L, 0);
  }, onChange: (L) => {
    this.handleChange(L, 0);
  } })), this.showPlaceholder1 ? B("div", { class: `${s}-input__placeholder` }, B("span", null, this.mergedPlaceholder[0])) : null, this.autosize ? B("div", { class: `${s}-input__input-mirror`, key: "mirror", ref: "inputMirrorElRef" }, "\xA0") : null), !this.pair && oi(j.suffix, (L) => L || this.clearable || this.showCount || this.mergedShowPasswordOn || this.loading !== void 0 ? B("div", { class: `${s}-input__suffix` }, [oi(j["clear-icon-placeholder"], (q) => (this.clearable || q) && B(E0, { clsPrefix: s, show: this.showClearButton, onClear: this.handleClear }, { placeholder: () => q, icon: () => {
    var N, J;
    return (J = (N = this.$slots)["clear-icon"]) === null || J === void 0 ? void 0 : J.call(N);
  } })), this.internalLoadingBeforeSuffix ? null : L, this.loading !== void 0 ? B(J1, { clsPrefix: s, loading: this.loading, showArrow: false, showClear: false, style: this.cssVars }) : null, this.internalLoadingBeforeSuffix ? L : null, this.showCount && this.type !== "textarea" ? B(N_, null, { default: (q) => {
    var N;
    const { renderCount: J } = this;
    return J ? J(q) : (N = j.count) === null || N === void 0 ? void 0 : N.call(j, q);
  } }) : null, this.mergedShowPasswordOn && this.type === "password" ? B("div", { class: `${s}-input__eye`, onMousedown: this.handlePasswordToggleMousedown, onClick: this.handlePasswordToggleClick }, this.passwordVisible ? to(j["password-visible-icon"], () => [B(Nr, { clsPrefix: s }, { default: () => B(Y1, null) })]) : to(j["password-invisible-icon"], () => [B(Nr, { clsPrefix: s }, { default: () => B(aP, null) })])) : null]) : null)), this.pair ? B("span", { class: `${s}-input__separator` }, to(j.separator, () => [this.separator])) : null, this.pair ? B("div", { class: `${s}-input-wrapper` }, B("div", { class: `${s}-input__input` }, B("input", { ref: "inputEl2Ref", type: this.type, class: `${s}-input__input-el`, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, placeholder: this.mergedPlaceholder[1], disabled: this.mergedDisabled, maxlength: A ? void 0 : this.maxlength, minlength: A ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[1] : void 0, readonly: this.readonly, style: this.textDecorationStyle[1], onBlur: this.handleInputBlur, onFocus: (L) => {
    this.handleInputFocus(L, 1);
  }, onInput: (L) => {
    this.handleInput(L, 1);
  }, onChange: (L) => {
    this.handleChange(L, 1);
  } }), this.showPlaceholder2 ? B("div", { class: `${s}-input__placeholder` }, B("span", null, this.mergedPlaceholder[1])) : null), oi(j.suffix, (L) => (this.clearable || L) && B("div", { class: `${s}-input__suffix` }, [this.clearable && B(E0, { clsPrefix: s, show: this.showClearButton, onClear: this.handleClear }, { icon: () => {
    var q;
    return (q = j["clear-icon"]) === null || q === void 0 ? void 0 : q.call(j);
  }, placeholder: () => {
    var q;
    return (q = j["clear-icon-placeholder"]) === null || q === void 0 ? void 0 : q.call(j);
  } }), L]))) : null, this.mergedBordered ? B("div", { class: `${s}-input__border` }) : null, this.mergedBordered ? B("div", { class: `${s}-input__state-border` }) : null, this.showCount && M === "textarea" ? B(N_, null, { default: (L) => {
    var q;
    const { renderCount: N } = this;
    return N ? N(L) : (q = j.count) === null || q === void 0 ? void 0 : q.call(j, L);
  } }) : null);
} }), NP = he("input-group", `
 display: inline-flex;
 width: 100%;
 flex-wrap: nowrap;
 vertical-align: bottom;
`, [qe(">", [he("input", [qe("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), qe("&:not(:first-child)", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 margin-left: -1px!important;
 `)]), he("button", [qe("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `, [Le("state-border, border", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `)]), qe("&:not(:first-child)", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `, [Le("state-border, border", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `)])]), qe("*", [qe("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `, [qe(">", [he("input", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), he("base-selection", [he("base-selection-label", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), he("base-selection-tags", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), Le("box-shadow, border, state-border", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `)])])]), qe("&:not(:first-child)", `
 margin-left: -1px!important;
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `, [qe(">", [he("input", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), he("base-selection", [he("base-selection-label", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), he("base-selection-tags", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), Le("box-shadow, border, state-border", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `)])])])])])]), jP = {}, VP = nt({ name: "InputGroup", props: jP, setup(r) {
  const { mergedClsPrefixRef: n } = Cr(r);
  return Nc("-input-group", NP, n), { mergedClsPrefix: n };
}, render() {
  const { mergedClsPrefix: r } = this;
  return B("div", { class: `${r}-input-group` }, this.$slots);
} });
function Hp(r) {
  return r.type === "group";
}
function tx(r) {
  return r.type === "ignored";
}
function Zg(r, n) {
  try {
    return !!(1 + n.toString().toLowerCase().indexOf(r.trim().toLowerCase()));
  } catch {
    return false;
  }
}
function UP(r, n) {
  return { getIsGroup: Hp, getIgnored: tx, getKey(h) {
    return Hp(h) ? h.name || h.key || "key-required" : h[r];
  }, getChildren(h) {
    return h[n];
  } };
}
function GP(r, n, l, h) {
  if (!n) return r;
  function f(y) {
    if (!Array.isArray(y)) return [];
    const p = [];
    for (const s of y) if (Hp(s)) {
      const S = f(s[h]);
      S.length && p.push(Object.assign({}, s, { [h]: S }));
    } else {
      if (tx(s)) continue;
      n(l, s) && p.push(s);
    }
    return p;
  }
  return f(r);
}
function qP(r, n, l) {
  const h = /* @__PURE__ */ new Map();
  return r.forEach((f) => {
    Hp(f) ? f[l].forEach((y) => {
      h.set(y[n], y);
    }) : h.set(f[n], f);
  }), h;
}
const WP = um && "loading" in document.createElement("img");
function ZP(r = {}) {
  var n;
  const { root: l = null } = r;
  return { hash: `${r.rootMargin || "0px 0px 0px 0px"}-${Array.isArray(r.threshold) ? r.threshold.join(",") : (n = r.threshold) !== null && n !== void 0 ? n : "0"}`, options: Object.assign(Object.assign({}, r), { root: (typeof l == "string" ? document.querySelector(l) : l) || document.documentElement }) };
}
const Hg = /* @__PURE__ */ new WeakMap(), Xg = /* @__PURE__ */ new WeakMap(), Yg = /* @__PURE__ */ new WeakMap(), HP = (r, n, l) => {
  if (!r) return () => {
  };
  const h = ZP(n), { root: f } = h.options;
  let y;
  const p = Hg.get(f);
  p ? y = p : (y = /* @__PURE__ */ new Map(), Hg.set(f, y));
  let s, S;
  y.has(h.hash) ? (S = y.get(h.hash), S[1].has(r) || (s = S[0], S[1].add(r), s.observe(r))) : (s = new IntersectionObserver((A) => {
    A.forEach((O) => {
      if (O.isIntersecting) {
        const j = Xg.get(O.target), L = Yg.get(O.target);
        j && j(), L && (L.value = true);
      }
    });
  }, h.options), s.observe(r), S = [s, /* @__PURE__ */ new Set([r])], y.set(h.hash, S));
  let P = false;
  const M = () => {
    P || (Xg.delete(r), Yg.delete(r), P = true, S[1].has(r) && (S[0].unobserve(r), S[1].delete(r)), S[1].size <= 0 && y.delete(h.hash), y.size || Hg.delete(f));
  };
  return Xg.set(r, M), Yg.set(r, l), M;
}, Ii = "0!important", rx = "-1px!important";
function bc(r) {
  return Ue(`${r}-type`, [qe("& +", [he("button", {}, [Ue(`${r}-type`, [Le("border", { borderLeftWidth: Ii }), Le("state-border", { left: rx })])])])]);
}
function xc(r) {
  return Ue(`${r}-type`, [qe("& +", [he("button", [Ue(`${r}-type`, [Le("border", { borderTopWidth: Ii }), Le("state-border", { top: rx })])])])]);
}
const XP = he("button-group", `
 flex-wrap: nowrap;
 display: inline-flex;
 position: relative;
`, [ci("vertical", { flexDirection: "row" }, [ci("rtl", [he("button", [qe("&:first-child:not(:last-child)", `
 margin-right: ${Ii};
 border-top-right-radius: ${Ii};
 border-bottom-right-radius: ${Ii};
 `), qe("&:last-child:not(:first-child)", `
 margin-left: ${Ii};
 border-top-left-radius: ${Ii};
 border-bottom-left-radius: ${Ii};
 `), qe("&:not(:first-child):not(:last-child)", `
 margin-left: ${Ii};
 margin-right: ${Ii};
 border-radius: ${Ii};
 `), bc("default"), Ue("ghost", [bc("primary"), bc("info"), bc("success"), bc("warning"), bc("error")])])])]), Ue("vertical", { flexDirection: "column" }, [he("button", [qe("&:first-child:not(:last-child)", `
 margin-bottom: ${Ii};
 margin-left: ${Ii};
 margin-right: ${Ii};
 border-bottom-left-radius: ${Ii};
 border-bottom-right-radius: ${Ii};
 `), qe("&:last-child:not(:first-child)", `
 margin-top: ${Ii};
 margin-left: ${Ii};
 margin-right: ${Ii};
 border-top-left-radius: ${Ii};
 border-top-right-radius: ${Ii};
 `), qe("&:not(:first-child):not(:last-child)", `
 margin: ${Ii};
 border-radius: ${Ii};
 `), xc("default"), Ue("ghost", [xc("primary"), xc("info"), xc("success"), xc("warning"), xc("error")])])])]), YP = { size: { type: String, default: void 0 }, vertical: Boolean }, KP = nt({ name: "ButtonGroup", props: YP, setup(r) {
  const { mergedClsPrefixRef: n, mergedRtlRef: l } = Cr(r);
  return Nc("-button-group", XP, n), Vr(C3, r), { rtlEnabled: Ln("ButtonGroup", l, n), mergedClsPrefix: n };
}, render() {
  const { mergedClsPrefix: r } = this;
  return B("div", { class: [`${r}-button-group`, this.rtlEnabled && `${r}-button-group--rtl`, this.vertical && `${r}-button-group--vertical`], role: "group" }, this.$slots);
} }), JP = qn("n-checkbox-group"), QP = () => B("svg", { viewBox: "0 0 64 64", class: "check-icon" }, B("path", { d: "M50.42,16.76L22.34,39.45l-8.1-11.46c-1.12-1.58-3.3-1.96-4.88-0.84c-1.58,1.12-1.95,3.3-0.84,4.88l10.26,14.51  c0.56,0.79,1.42,1.31,2.38,1.45c0.16,0.02,0.32,0.03,0.48,0.03c0.8,0,1.57-0.27,2.2-0.78l30.99-25.03c1.5-1.21,1.74-3.42,0.52-4.92  C54.13,15.78,51.93,15.55,50.42,16.76z" })), e5 = () => B("svg", { viewBox: "0 0 100 100", class: "line-icon" }, B("path", { d: "M80.2,55.5H21.4c-2.8,0-5.1-2.5-5.1-5.5l0,0c0-3,2.3-5.5,5.1-5.5h58.7c2.8,0,5.1,2.5,5.1,5.5l0,0C85.2,53.1,82.9,55.5,80.2,55.5z" })), t5 = qe([he("checkbox", `
 font-size: var(--n-font-size);
 outline: none;
 cursor: pointer;
 display: inline-flex;
 flex-wrap: nowrap;
 align-items: flex-start;
 word-break: break-word;
 line-height: var(--n-size);
 --n-merged-color-table: var(--n-color-table);
 `, [Ue("show-label", "line-height: var(--n-label-line-height);"), qe("&:hover", [he("checkbox-box", [Le("border", "border: var(--n-border-checked);")])]), qe("&:focus:not(:active)", [he("checkbox-box", [Le("border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), Ue("inside-table", [he("checkbox-box", `
 background-color: var(--n-merged-color-table);
 `)]), Ue("checked", [he("checkbox-box", `
 background-color: var(--n-color-checked);
 `, [he("checkbox-icon", [qe(".check-icon", `
 opacity: 1;
 transform: scale(1);
 `)])])]), Ue("indeterminate", [he("checkbox-box", [he("checkbox-icon", [qe(".check-icon", `
 opacity: 0;
 transform: scale(.5);
 `), qe(".line-icon", `
 opacity: 1;
 transform: scale(1);
 `)])])]), Ue("checked, indeterminate", [qe("&:focus:not(:active)", [he("checkbox-box", [Le("border", `
 border: var(--n-border-checked);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), he("checkbox-box", `
 background-color: var(--n-color-checked);
 border-left: 0;
 border-top: 0;
 `, [Le("border", { border: "var(--n-border-checked)" })])]), Ue("disabled", { cursor: "not-allowed" }, [Ue("checked", [he("checkbox-box", `
 background-color: var(--n-color-disabled-checked);
 `, [Le("border", { border: "var(--n-border-disabled-checked)" }), he("checkbox-icon", [qe(".check-icon, .line-icon", { fill: "var(--n-check-mark-color-disabled-checked)" })])])]), he("checkbox-box", `
 background-color: var(--n-color-disabled);
 `, [Le("border", `
 border: var(--n-border-disabled);
 `), he("checkbox-icon", [qe(".check-icon, .line-icon", `
 fill: var(--n-check-mark-color-disabled);
 `)])]), Le("label", `
 color: var(--n-text-color-disabled);
 `)]), he("checkbox-box-wrapper", `
 position: relative;
 width: var(--n-size);
 flex-shrink: 0;
 flex-grow: 0;
 user-select: none;
 -webkit-user-select: none;
 `), he("checkbox-box", `
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 height: var(--n-size);
 width: var(--n-size);
 display: inline-block;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color 0.3s var(--n-bezier);
 `, [Le("border", `
 transition:
 border-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border: var(--n-border);
 `), he("checkbox-icon", `
 display: flex;
 align-items: center;
 justify-content: center;
 position: absolute;
 left: 1px;
 right: 1px;
 top: 1px;
 bottom: 1px;
 `, [qe(".check-icon, .line-icon", `
 width: 100%;
 fill: var(--n-check-mark-color);
 opacity: 0;
 transform: scale(0.5);
 transform-origin: center;
 transition:
 fill 0.3s var(--n-bezier),
 transform 0.3s var(--n-bezier),
 opacity 0.3s var(--n-bezier),
 border-color 0.3s var(--n-bezier);
 `), Sh({ left: "1px", top: "1px" })])]), Le("label", `
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 user-select: none;
 -webkit-user-select: none;
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 `, [qe("&:empty", { display: "none" })])]), a1(he("checkbox", `
 --n-merged-color-table: var(--n-color-table-modal);
 `)), s1(he("checkbox", `
 --n-merged-color-table: var(--n-color-table-popover);
 `))]), r5 = Object.assign(Object.assign({}, er.props), { size: String, checked: { type: [Boolean, String, Number], default: void 0 }, defaultChecked: { type: [Boolean, String, Number], default: false }, value: [String, Number], disabled: { type: Boolean, default: void 0 }, indeterminate: Boolean, label: String, focusable: { type: Boolean, default: true }, checkedValue: { type: [Boolean, String, Number], default: true }, uncheckedValue: { type: [Boolean, String, Number], default: false }, "onUpdate:checked": [Function, Array], onUpdateChecked: [Function, Array], privateInsideTable: Boolean, onChange: [Function, Array] }), i5 = nt({ name: "Checkbox", props: r5, setup(r) {
  const n = cr(JP, null), l = Ee(null), { mergedClsPrefixRef: h, inlineThemeDisabled: f, mergedRtlRef: y } = Cr(r), p = Ee(r.defaultChecked), s = zt(r, "checked"), S = Qi(s, p), P = vi(() => {
    if (n) {
      const ee = n.valueSetRef.value;
      return ee && r.value !== void 0 ? ee.has(r.value) : false;
    } else return S.value === r.checkedValue;
  }), M = Ba(r, { mergedSize(ee) {
    const { size: ke } = r;
    if (ke !== void 0) return ke;
    if (n) {
      const { value: ve } = n.mergedSizeRef;
      if (ve !== void 0) return ve;
    }
    if (ee) {
      const { mergedSize: ve } = ee;
      if (ve !== void 0) return ve.value;
    }
    return "medium";
  }, mergedDisabled(ee) {
    const { disabled: ke } = r;
    if (ke !== void 0) return ke;
    if (n) {
      if (n.disabledRef.value) return true;
      const { maxRef: { value: ve }, checkedCountRef: le } = n;
      if (ve !== void 0 && le.value >= ve && !P.value) return true;
      const { minRef: { value: ue } } = n;
      if (ue !== void 0 && le.value <= ue && P.value) return true;
    }
    return ee ? ee.disabled.value : false;
  } }), { mergedDisabledRef: A, mergedSizeRef: O } = M, j = er("Checkbox", "-checkbox", t5, S3, r, h);
  function L(ee) {
    if (n && r.value !== void 0) n.toggleCheckbox(!P.value, r.value);
    else {
      const { onChange: ke, "onUpdate:checked": ve, onUpdateChecked: le } = r, { nTriggerFormInput: ue, nTriggerFormChange: be } = M, Ve = P.value ? r.uncheckedValue : r.checkedValue;
      ve && jt(ve, Ve, ee), le && jt(le, Ve, ee), ke && jt(ke, Ve, ee), ue(), be(), p.value = Ve;
    }
  }
  function q(ee) {
    A.value || L(ee);
  }
  function N(ee) {
    if (!A.value) switch (ee.key) {
      case " ":
      case "Enter":
        L(ee);
    }
  }
  function J(ee) {
    switch (ee.key) {
      case " ":
        ee.preventDefault();
    }
  }
  const te = { focus: () => {
    var ee;
    (ee = l.value) === null || ee === void 0 || ee.focus();
  }, blur: () => {
    var ee;
    (ee = l.value) === null || ee === void 0 || ee.blur();
  } }, ne = Ln("Checkbox", y, h), ae = Ae(() => {
    const { value: ee } = O, { common: { cubicBezierEaseInOut: ke }, self: { borderRadius: ve, color: le, colorChecked: ue, colorDisabled: be, colorTableHeader: Ve, colorTableHeaderModal: Ge, colorTableHeaderPopover: et, checkMarkColor: dt, checkMarkColorDisabled: Ct, border: kt, borderFocus: ct, borderDisabled: it, borderChecked: pt, boxShadowFocus: $t, textColor: vt, textColorDisabled: Pt, checkMarkColorDisabledChecked: Nt, colorDisabledChecked: ir, borderDisabledChecked: bt, labelPadding: Dt, labelLineHeight: Zt, labelFontWeight: dr, [Ut("fontSize", ee)]: yr, [Ut("size", ee)]: Pr } } = j.value;
    return { "--n-label-line-height": Zt, "--n-label-font-weight": dr, "--n-size": Pr, "--n-bezier": ke, "--n-border-radius": ve, "--n-border": kt, "--n-border-checked": pt, "--n-border-focus": ct, "--n-border-disabled": it, "--n-border-disabled-checked": bt, "--n-box-shadow-focus": $t, "--n-color": le, "--n-color-checked": ue, "--n-color-table": Ve, "--n-color-table-modal": Ge, "--n-color-table-popover": et, "--n-color-disabled": be, "--n-color-disabled-checked": ir, "--n-text-color": vt, "--n-text-color-disabled": Pt, "--n-check-mark-color": dt, "--n-check-mark-color-disabled": Ct, "--n-check-mark-color-disabled-checked": Nt, "--n-font-size": yr, "--n-label-padding": Dt };
  }), oe = f ? ai("checkbox", Ae(() => O.value[0]), ae, r) : void 0;
  return Object.assign(M, te, { rtlEnabled: ne, selfRef: l, mergedClsPrefix: h, mergedDisabled: A, renderedChecked: P, mergedTheme: j, labelId: Kl(), handleClick: q, handleKeyUp: N, handleKeyDown: J, cssVars: f ? void 0 : ae, themeClass: oe == null ? void 0 : oe.themeClass, onRender: oe == null ? void 0 : oe.onRender });
}, render() {
  var r;
  const { $slots: n, renderedChecked: l, mergedDisabled: h, indeterminate: f, privateInsideTable: y, cssVars: p, labelId: s, label: S, mergedClsPrefix: P, focusable: M, handleKeyUp: A, handleKeyDown: O, handleClick: j } = this;
  (r = this.onRender) === null || r === void 0 || r.call(this);
  const L = oi(n.default, (q) => S || q ? B("span", { class: `${P}-checkbox__label`, id: s }, S || q) : null);
  return B("div", { ref: "selfRef", class: [`${P}-checkbox`, this.themeClass, this.rtlEnabled && `${P}-checkbox--rtl`, l && `${P}-checkbox--checked`, h && `${P}-checkbox--disabled`, f && `${P}-checkbox--indeterminate`, y && `${P}-checkbox--inside-table`, L && `${P}-checkbox--show-label`], tabindex: h || !M ? void 0 : 0, role: "checkbox", "aria-checked": f ? "mixed" : l, "aria-labelledby": s, style: p, onKeyup: A, onKeydown: O, onClick: j, onMousedown: () => {
    Un("selectstart", window, (q) => {
      q.preventDefault();
    }, { once: true });
  } }, B("div", { class: `${P}-checkbox-box-wrapper` }, "\xA0", B("div", { class: `${P}-checkbox-box` }, B(im, null, { default: () => this.indeterminate ? B("div", { key: "indeterminate", class: `${P}-checkbox-icon` }, e5()) : B("div", { key: "check", class: `${P}-checkbox-icon` }, QP()) }), B("div", { class: `${P}-checkbox-box__border` }))), L);
} }), n5 = he("collapse", "width: 100%;", [he("collapse-item", `
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 margin: var(--n-item-margin);
 `, [Ue("disabled", [Le("header", "cursor: not-allowed;", [Le("header-main", `
 color: var(--n-title-text-color-disabled);
 `), he("collapse-item-arrow", `
 color: var(--n-arrow-color-disabled);
 `)])]), he("collapse-item", "margin-left: 32px;"), qe("&:first-child", "margin-top: 0;"), qe("&:first-child >", [Le("header", "padding-top: 0;")]), Ue("left-arrow-placement", [Le("header", [he("collapse-item-arrow", "margin-right: 4px;")])]), Ue("right-arrow-placement", [Le("header", [he("collapse-item-arrow", "margin-left: 4px;")])]), Le("content-wrapper", [Le("content-inner", "padding-top: 16px;"), Up({ duration: "0.15s" })]), Ue("active", [Le("header", [Ue("active", [he("collapse-item-arrow", "transform: rotate(90deg);")])])]), qe("&:not(:first-child)", "border-top: 1px solid var(--n-divider-color);"), ci("disabled", [Ue("trigger-area-main", [Le("header", [Le("header-main", "cursor: pointer;"), he("collapse-item-arrow", "cursor: default;")])]), Ue("trigger-area-arrow", [Le("header", [he("collapse-item-arrow", "cursor: pointer;")])]), Ue("trigger-area-extra", [Le("header", [Le("header-extra", "cursor: pointer;")])])]), Le("header", `
 font-size: var(--n-title-font-size);
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition: color .3s var(--n-bezier);
 position: relative;
 padding: var(--n-title-padding);
 color: var(--n-title-text-color);
 `, [Le("header-main", `
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 flex: 1;
 color: var(--n-title-text-color);
 `), Le("header-extra", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), he("collapse-item-arrow", `
 display: flex;
 transition:
 transform .15s var(--n-bezier),
 color .3s var(--n-bezier);
 font-size: 18px;
 color: var(--n-arrow-color);
 `)])])]), o5 = Object.assign(Object.assign({}, er.props), { defaultExpandedNames: { type: [Array, String], default: null }, expandedNames: [Array, String], arrowPlacement: { type: String, default: "left" }, accordion: { type: Boolean, default: false }, displayDirective: { type: String, default: "if" }, triggerAreas: { type: Array, default: () => ["main", "extra", "arrow"] }, onItemHeaderClick: [Function, Array], "onUpdate:expandedNames": [Function, Array], onUpdateExpandedNames: [Function, Array], onExpandedNamesChange: { type: [Function, Array], validator: () => true, default: void 0 } }), ix = qn("n-collapse"), j_ = nt({ name: "Collapse", props: o5, slots: Object, setup(r, { slots: n }) {
  const { mergedClsPrefixRef: l, inlineThemeDisabled: h, mergedRtlRef: f } = Cr(r), y = Ee(r.defaultExpandedNames), p = Ae(() => r.expandedNames), s = Qi(p, y), S = er("Collapse", "-collapse", n5, k3, r, l);
  function P(q) {
    const { "onUpdate:expandedNames": N, onUpdateExpandedNames: J, onExpandedNamesChange: te } = r;
    J && jt(J, q), N && jt(N, q), te && jt(te, q), y.value = q;
  }
  function M(q) {
    const { onItemHeaderClick: N } = r;
    N && jt(N, q);
  }
  function A(q, N, J) {
    const { accordion: te } = r, { value: ne } = s;
    if (te) q ? (P([N]), M({ name: N, expanded: true, event: J })) : (P([]), M({ name: N, expanded: false, event: J }));
    else if (!Array.isArray(ne)) P([N]), M({ name: N, expanded: true, event: J });
    else {
      const ae = ne.slice(), oe = ae.findIndex((ee) => N === ee);
      ~oe ? (ae.splice(oe, 1), P(ae), M({ name: N, expanded: false, event: J })) : (ae.push(N), P(ae), M({ name: N, expanded: true, event: J }));
    }
  }
  Vr(ix, { props: r, mergedClsPrefixRef: l, expandedNamesRef: s, slots: n, toggleItem: A });
  const O = Ln("Collapse", f, l), j = Ae(() => {
    const { common: { cubicBezierEaseInOut: q }, self: { titleFontWeight: N, dividerColor: J, titlePadding: te, titleTextColor: ne, titleTextColorDisabled: ae, textColor: oe, arrowColor: ee, fontSize: ke, titleFontSize: ve, arrowColorDisabled: le, itemMargin: ue } } = S.value;
    return { "--n-font-size": ke, "--n-bezier": q, "--n-text-color": oe, "--n-divider-color": J, "--n-title-padding": te, "--n-title-font-size": ve, "--n-title-text-color": ne, "--n-title-text-color-disabled": ae, "--n-title-font-weight": N, "--n-arrow-color": ee, "--n-arrow-color-disabled": le, "--n-item-margin": ue };
  }), L = h ? ai("collapse", void 0, j, r) : void 0;
  return { rtlEnabled: O, mergedTheme: S, mergedClsPrefix: l, cssVars: h ? void 0 : j, themeClass: L == null ? void 0 : L.themeClass, onRender: L == null ? void 0 : L.onRender };
}, render() {
  var r;
  return (r = this.onRender) === null || r === void 0 || r.call(this), B("div", { class: [`${this.mergedClsPrefix}-collapse`, this.rtlEnabled && `${this.mergedClsPrefix}-collapse--rtl`, this.themeClass], style: this.cssVars }, this.$slots);
} }), a5 = nt({ name: "CollapseItemContent", props: { displayDirective: { type: String, required: true }, show: Boolean, clsPrefix: { type: String, required: true } }, setup(r) {
  return { onceTrue: T3(zt(r, "show")) };
}, render() {
  return B(sm, null, { default: () => {
    const { show: r, displayDirective: n, onceTrue: l, clsPrefix: h } = this, f = n === "show" && l, y = B("div", { class: `${h}-collapse-item__content-wrapper` }, B("div", { class: `${h}-collapse-item__content-inner` }, this.$slots));
    return f ? za(y, [[us, r]]) : r ? y : null;
  } });
} }), s5 = { title: String, name: [String, Number], disabled: Boolean, displayDirective: String }, V_ = nt({ name: "CollapseItem", props: s5, setup(r) {
  const { mergedRtlRef: n } = Cr(r), l = Kl(), h = vi(() => {
    var A;
    return (A = r.name) !== null && A !== void 0 ? A : l;
  }), f = cr(ix);
  f || fa("collapse-item", "`n-collapse-item` must be placed inside `n-collapse`.");
  const { expandedNamesRef: y, props: p, mergedClsPrefixRef: s, slots: S } = f, P = Ae(() => {
    const { value: A } = y;
    if (Array.isArray(A)) {
      const { value: O } = h;
      return !~A.findIndex((j) => j === O);
    } else if (A) {
      const { value: O } = h;
      return O !== A;
    }
    return true;
  });
  return { rtlEnabled: Ln("Collapse", n, s), collapseSlots: S, randomName: l, mergedClsPrefix: s, collapsed: P, triggerAreas: zt(p, "triggerAreas"), mergedDisplayDirective: Ae(() => {
    const { displayDirective: A } = r;
    return A || p.displayDirective;
  }), arrowPlacement: Ae(() => p.arrowPlacement), handleClick(A) {
    let O = "main";
    Wl(A, "arrow") && (O = "arrow"), Wl(A, "extra") && (O = "extra"), p.triggerAreas.includes(O) && f && !r.disabled && f.toggleItem(P.value, h.value, A);
  } };
}, render() {
  const { collapseSlots: r, $slots: n, arrowPlacement: l, collapsed: h, mergedDisplayDirective: f, mergedClsPrefix: y, disabled: p, triggerAreas: s } = this, S = b0(n.header, { collapsed: h }, () => [this.title]), P = n["header-extra"] || r["header-extra"], M = n.arrow || r.arrow;
  return B("div", { class: [`${y}-collapse-item`, `${y}-collapse-item--${l}-arrow-placement`, p && `${y}-collapse-item--disabled`, !h && `${y}-collapse-item--active`, s.map((A) => `${y}-collapse-item--trigger-area-${A}`)] }, B("div", { class: [`${y}-collapse-item__header`, !h && `${y}-collapse-item__header--active`] }, B("div", { class: `${y}-collapse-item__header-main`, onClick: this.handleClick }, l === "right" && S, B("div", { class: `${y}-collapse-item-arrow`, key: this.rtlEnabled ? 0 : 1, "data-arrow": true }, b0(M, { collapsed: h }, () => [B(Nr, { clsPrefix: y }, { default: () => this.rtlEnabled ? B(iP, null) : B(P3, null) })])), l === "left" && S), I3(P, { collapsed: h }, (A) => B("div", { class: `${y}-collapse-item__header-extra`, onClick: this.handleClick, "data-extra": true }, A))), B(a5, { clsPrefix: y, displayDirective: f, show: !h }, n));
} });
function l5(r, n) {
  switch (r[0]) {
    case "hex":
      return n ? "#000000FF" : "#000000";
    case "rgb":
      return n ? "rgba(0, 0, 0, 1)" : "rgb(0, 0, 0)";
    case "hsl":
      return n ? "hsla(0, 0%, 0%, 1)" : "hsl(0, 0%, 0%)";
    case "hsv":
      return n ? "hsva(0, 0%, 0%, 1)" : "hsv(0, 0%, 0%)";
  }
  return "#000000";
}
function Ih(r) {
  return r === null ? null : /^ *#/.test(r) ? "hex" : r.includes("rgb") ? "rgb" : r.includes("hsl") ? "hsl" : r.includes("hsv") ? "hsv" : null;
}
function u5(r, n = [255, 255, 255], l = "AA") {
  const [h, f, y, p] = ua(as(r));
  if (p === 1) {
    const j = xp([h, f, y]), L = xp(n);
    return (Math.max(j, L) + 0.05) / (Math.min(j, L) + 0.05) >= (l === "AA" ? 4.5 : 7);
  }
  const s = Math.round(h * p + n[0] * (1 - p)), S = Math.round(f * p + n[1] * (1 - p)), P = Math.round(y * p + n[2] * (1 - p)), M = xp([s, S, P]), A = xp(n);
  return (Math.max(M, A) + 0.05) / (Math.min(M, A) + 0.05) >= (l === "AA" ? 4.5 : 7);
}
function xp(r) {
  const [n, l, h] = r.map((f) => (f /= 255, f <= 0.03928 ? f / 12.92 : Math.pow((f + 0.055) / 1.055, 2.4)));
  return 0.2126 * n + 0.7152 * l + 0.0722 * h;
}
function c5(r) {
  return r = Math.round(r), r >= 360 ? 359 : r < 0 ? 0 : r;
}
function d5(r) {
  return r = Math.round(r * 100) / 100, r > 1 ? 1 : r < 0 ? 0 : r;
}
const h5 = { rgb: { hex(r) {
  return Ns(ua(r));
}, hsl(r) {
  const [n, l, h, f] = ua(r);
  return as([...C0(n, l, h), f]);
}, hsv(r) {
  const [n, l, h, f] = ua(r);
  return Hl([...w0(n, l, h), f]);
} }, hex: { rgb(r) {
  return ss(ua(r));
}, hsl(r) {
  const [n, l, h, f] = ua(r);
  return as([...C0(n, l, h), f]);
}, hsv(r) {
  const [n, l, h, f] = ua(r);
  return Hl([...w0(n, l, h), f]);
} }, hsl: { hex(r) {
  const [n, l, h, f] = Ec(r);
  return Ns([...x0(n, l, h), f]);
}, rgb(r) {
  const [n, l, h, f] = Ec(r);
  return ss([...x0(n, l, h), f]);
}, hsv(r) {
  const [n, l, h, f] = Ec(r);
  return Hl([...l1(n, l, h), f]);
} }, hsv: { hex(r) {
  const [n, l, h, f] = Zl(r);
  return Ns([...Ls(n, l, h), f]);
}, rgb(r) {
  const [n, l, h, f] = Zl(r);
  return ss([...Ls(n, l, h), f]);
}, hsl(r) {
  const [n, l, h, f] = Zl(r);
  return as([...Fp(n, l, h), f]);
} } };
function nx(r, n, l) {
  return l = l || Ih(r), l ? l === n ? r : h5[l][n](r) : null;
}
const uh = "12px", f5 = 12, $l = "6px", p5 = nt({ name: "AlphaSlider", props: { clsPrefix: { type: String, required: true }, rgba: { type: Array, default: null }, alpha: { type: Number, default: 0 }, onUpdateAlpha: { type: Function, required: true }, onComplete: Function }, setup(r) {
  const n = Ee(null);
  function l(y) {
    !n.value || !r.rgba || (Un("mousemove", document, h), Un("mouseup", document, f), h(y));
  }
  function h(y) {
    const { value: p } = n;
    if (!p) return;
    const { width: s, left: S } = p.getBoundingClientRect(), P = (y.clientX - S) / (s - f5);
    r.onUpdateAlpha(d5(P));
  }
  function f() {
    var y;
    co("mousemove", document, h), co("mouseup", document, f), (y = r.onComplete) === null || y === void 0 || y.call(r);
  }
  return { railRef: n, railBackgroundImage: Ae(() => {
    const { rgba: y } = r;
    return y ? `linear-gradient(to right, rgba(${y[0]}, ${y[1]}, ${y[2]}, 0) 0%, rgba(${y[0]}, ${y[1]}, ${y[2]}, 1) 100%)` : "";
  }), handleMouseDown: l };
}, render() {
  const { clsPrefix: r } = this;
  return B("div", { class: `${r}-color-picker-slider`, ref: "railRef", style: { height: uh, borderRadius: $l }, onMousedown: this.handleMouseDown }, B("div", { style: { borderRadius: $l, position: "absolute", left: 0, right: 0, top: 0, bottom: 0, overflow: "hidden" } }, B("div", { class: `${r}-color-picker-checkboard` }), B("div", { class: `${r}-color-picker-slider__image`, style: { backgroundImage: this.railBackgroundImage } })), this.rgba && B("div", { style: { position: "absolute", left: $l, right: $l, top: 0, bottom: 0 } }, B("div", { class: `${r}-color-picker-handle`, style: { left: `calc(${this.alpha * 100}% - ${$l})`, borderRadius: $l, width: uh, height: uh } }, B("div", { class: `${r}-color-picker-handle__fill`, style: { backgroundColor: ss(this.rgba), borderRadius: $l, width: uh, height: uh } }))));
} }), av = qn("n-color-picker");
function m5(r) {
  return /^\d{1,3}\.?\d*$/.test(r.trim()) ? Math.max(0, Math.min(Number.parseInt(r), 255)) : false;
}
function g5(r) {
  return /^\d{1,3}\.?\d*$/.test(r.trim()) ? Math.max(0, Math.min(Number.parseInt(r), 360)) : false;
}
function v5(r) {
  return /^\d{1,3}\.?\d*$/.test(r.trim()) ? Math.max(0, Math.min(Number.parseInt(r), 100)) : false;
}
function y5(r) {
  const n = r.trim();
  return /^#[0-9a-fA-F]+$/.test(n) ? [4, 5, 7, 9].includes(n.length) : false;
}
function _5(r) {
  return /^\d{1,3}\.?\d*%$/.test(r.trim()) ? Math.max(0, Math.min(Number.parseInt(r) / 100, 100)) : false;
}
const b5 = { paddingSmall: "0 4px" }, U_ = nt({ name: "ColorInputUnit", props: { label: { type: String, required: true }, value: { type: [Number, String], default: null }, showAlpha: Boolean, onUpdateValue: { type: Function, required: true } }, setup(r) {
  const n = Ee(""), { themeRef: l } = cr(av, null);
  Ao(() => {
    n.value = h();
  });
  function h() {
    const { value: p } = r;
    if (p === null) return "";
    const { label: s } = r;
    return s === "HEX" ? p : s === "A" ? `${Math.floor(p * 100)}%` : String(Math.floor(p));
  }
  function f(p) {
    n.value = p;
  }
  function y(p) {
    let s, S;
    switch (r.label) {
      case "HEX":
        S = y5(p), S && r.onUpdateValue(p), n.value = h();
        break;
      case "H":
        s = g5(p), s === false ? n.value = h() : r.onUpdateValue(s);
        break;
      case "S":
      case "L":
      case "V":
        s = v5(p), s === false ? n.value = h() : r.onUpdateValue(s);
        break;
      case "A":
        s = _5(p), s === false ? n.value = h() : r.onUpdateValue(s);
        break;
      case "R":
      case "G":
      case "B":
        s = m5(p), s === false ? n.value = h() : r.onUpdateValue(s);
        break;
    }
  }
  return { mergedTheme: l, inputValue: n, handleInputChange: y, handleInputUpdateValue: f };
}, render() {
  const { mergedTheme: r } = this;
  return B(Do, { size: "small", placeholder: this.label, theme: r.peers.Input, themeOverrides: r.peerOverrides.Input, builtinThemeOverrides: b5, value: this.inputValue, onUpdateValue: this.handleInputUpdateValue, onChange: this.handleInputChange, style: this.label === "A" ? "flex-grow: 1.25;" : "" });
} }), x5 = nt({ name: "ColorInput", props: { clsPrefix: { type: String, required: true }, mode: { type: String, required: true }, modes: { type: Array, required: true }, showAlpha: { type: Boolean, required: true }, value: { type: String, default: null }, valueArr: { type: Array, default: null }, onUpdateValue: { type: Function, required: true }, onUpdateMode: { type: Function, required: true } }, setup(r) {
  return { handleUnitUpdateValue(n, l) {
    const { showAlpha: h } = r;
    if (r.mode === "hex") {
      r.onUpdateValue((h ? Ns : vh)(l));
      return;
    }
    let f;
    switch (r.valueArr === null ? f = [0, 0, 0, 0] : f = Array.from(r.valueArr), r.mode) {
      case "hsv":
        f[n] = l, r.onUpdateValue((h ? Hl : T0)(f));
        break;
      case "rgb":
        f[n] = l, r.onUpdateValue((h ? ss : k0)(f));
        break;
      case "hsl":
        f[n] = l, r.onUpdateValue((h ? as : S0)(f));
        break;
    }
  } };
}, render() {
  const { clsPrefix: r, modes: n } = this;
  return B("div", { class: `${r}-color-picker-input` }, B("div", { class: `${r}-color-picker-input__mode`, onClick: this.onUpdateMode, style: { cursor: n.length === 1 ? "" : "pointer" } }, this.mode.toUpperCase() + (this.showAlpha ? "A" : "")), B(VP, null, { default: () => {
    const { mode: l, valueArr: h, showAlpha: f } = this;
    if (l === "hex") {
      let y = null;
      try {
        y = h === null ? null : (f ? Ns : vh)(h);
      } catch {
      }
      return B(U_, { label: "HEX", showAlpha: f, value: y, onUpdateValue: (p) => {
        this.handleUnitUpdateValue(0, p);
      } });
    }
    return (l + (f ? "a" : "")).split("").map((y, p) => B(U_, { label: y.toUpperCase(), value: h === null ? null : h[p], onUpdateValue: (s) => {
      this.handleUnitUpdateValue(p, s);
    } }));
  } }));
} });
function w5(r, n) {
  if (n === "hsv") {
    const [l, h, f, y] = Zl(r);
    return ss([...Ls(l, h, f), y]);
  }
  return r;
}
function C5(r) {
  const n = document.createElement("canvas").getContext("2d");
  return n ? (n.fillStyle = r, n.fillStyle) : "#000000";
}
const S5 = nt({ name: "ColorPickerSwatches", props: { clsPrefix: { type: String, required: true }, mode: { type: String, required: true }, swatches: { type: Array, required: true }, onUpdateColor: { type: Function, required: true } }, setup(r) {
  const n = Ae(() => r.swatches.map((y) => {
    const p = Ih(y);
    return { value: y, mode: p, legalValue: w5(y, p) };
  }));
  function l(y) {
    const { mode: p } = r;
    let { value: s, mode: S } = y;
    return S || (S = "hex", /^[a-zA-Z]+$/.test(s) ? s = C5(s) : (Gp("color-picker", `color ${s} in swatches is invalid.`), s = "#000000")), S === p ? s : nx(s, p, S);
  }
  function h(y) {
    r.onUpdateColor(l(y));
  }
  function f(y, p) {
    y.key === "Enter" && h(p);
  }
  return { parsedSwatchesRef: n, handleSwatchSelect: h, handleSwatchKeyDown: f };
}, render() {
  const { clsPrefix: r } = this;
  return B("div", { class: `${r}-color-picker-swatches` }, this.parsedSwatchesRef.map((n) => B("div", { class: `${r}-color-picker-swatch`, tabindex: 0, onClick: () => {
    this.handleSwatchSelect(n);
  }, onKeydown: (l) => {
    this.handleSwatchKeyDown(l, n);
  } }, B("div", { class: `${r}-color-picker-swatch__fill`, style: { background: n.legalValue } }))));
} }), k5 = nt({ name: "ColorPickerTrigger", slots: Object, props: { clsPrefix: { type: String, required: true }, value: { type: String, default: null }, hsla: { type: Array, default: null }, disabled: Boolean, onClick: Function }, setup(r) {
  const { colorPickerSlots: n, renderLabelRef: l } = cr(av, null);
  return () => {
    const { hsla: h, value: f, clsPrefix: y, onClick: p, disabled: s } = r, S = n.label || l.value;
    return B("div", { class: [`${y}-color-picker-trigger`, s && `${y}-color-picker-trigger--disabled`], onClick: s ? void 0 : p }, B("div", { class: `${y}-color-picker-trigger__fill` }, B("div", { class: `${y}-color-picker-checkboard` }), B("div", { style: { position: "absolute", left: 0, right: 0, top: 0, bottom: 0, backgroundColor: h ? as(h) : "" } }), f && h ? B("div", { class: `${y}-color-picker-trigger__value`, style: { color: u5(h) ? "white" : "black" } }, S ? S(f) : f) : null));
  };
} }), T5 = nt({ name: "ColorPreview", props: { clsPrefix: { type: String, required: true }, mode: { type: String, required: true }, color: { type: String, default: null, validator: (r) => {
  const n = Ih(r);
  return !!(!r || n && n !== "hsv");
} }, onUpdateColor: { type: Function, required: true } }, setup(r) {
  function n(l) {
    var h;
    const f = l.target.value;
    (h = r.onUpdateColor) === null || h === void 0 || h.call(r, nx(f.toUpperCase(), r.mode, "hex")), l.stopPropagation();
  }
  return { handleChange: n };
}, render() {
  const { clsPrefix: r } = this;
  return B("div", { class: `${r}-color-picker-preview__preview` }, B("span", { class: `${r}-color-picker-preview__fill`, style: { background: this.color || "#000000" } }), B("input", { class: `${r}-color-picker-preview__input`, type: "color", value: this.color, onChange: this.handleChange }));
} }), wc = "12px", P5 = 12, Nl = "6px", I5 = 6, E5 = "linear-gradient(90deg,red,#ff0 16.66%,#0f0 33.33%,#0ff 50%,#00f 66.66%,#f0f 83.33%,red)", M5 = nt({ name: "HueSlider", props: { clsPrefix: { type: String, required: true }, hue: { type: Number, required: true }, onUpdateHue: { type: Function, required: true }, onComplete: Function }, setup(r) {
  const n = Ee(null);
  function l(y) {
    n.value && (Un("mousemove", document, h), Un("mouseup", document, f), h(y));
  }
  function h(y) {
    const { value: p } = n;
    if (!p) return;
    const { width: s, left: S } = p.getBoundingClientRect(), P = c5((y.clientX - S - I5) / (s - P5) * 360);
    r.onUpdateHue(P);
  }
  function f() {
    var y;
    co("mousemove", document, h), co("mouseup", document, f), (y = r.onComplete) === null || y === void 0 || y.call(r);
  }
  return { railRef: n, handleMouseDown: l };
}, render() {
  const { clsPrefix: r } = this;
  return B("div", { class: `${r}-color-picker-slider`, style: { height: wc, borderRadius: Nl } }, B("div", { ref: "railRef", style: { boxShadow: "inset 0 0 2px 0 rgba(0, 0, 0, .24)", boxSizing: "border-box", backgroundImage: E5, height: wc, borderRadius: Nl, position: "relative" }, onMousedown: this.handleMouseDown }, B("div", { style: { position: "absolute", left: Nl, right: Nl, top: 0, bottom: 0 } }, B("div", { class: `${r}-color-picker-handle`, style: { left: `calc((${this.hue}%) / 359 * 100 - ${Nl})`, borderRadius: Nl, width: wc, height: wc } }, B("div", { class: `${r}-color-picker-handle__fill`, style: { backgroundColor: `hsl(${this.hue}, 100%, 50%)`, borderRadius: Nl, width: wc, height: wc } })))));
} }), wp = "12px", Cp = "6px", D5 = nt({ name: "Pallete", props: { clsPrefix: { type: String, required: true }, rgba: { type: Array, default: null }, displayedHue: { type: Number, required: true }, displayedSv: { type: Array, required: true }, onUpdateSV: { type: Function, required: true }, onComplete: Function }, setup(r) {
  const n = Ee(null);
  function l(y) {
    n.value && (Un("mousemove", document, h), Un("mouseup", document, f), h(y));
  }
  function h(y) {
    const { value: p } = n;
    if (!p) return;
    const { width: s, height: S, left: P, bottom: M } = p.getBoundingClientRect(), A = (M - y.clientY) / S, O = (y.clientX - P) / s, j = 100 * (O > 1 ? 1 : O < 0 ? 0 : O), L = 100 * (A > 1 ? 1 : A < 0 ? 0 : A);
    r.onUpdateSV(j, L);
  }
  function f() {
    var y;
    co("mousemove", document, h), co("mouseup", document, f), (y = r.onComplete) === null || y === void 0 || y.call(r);
  }
  return { palleteRef: n, handleColor: Ae(() => {
    const { rgba: y } = r;
    return y ? `rgb(${y[0]}, ${y[1]}, ${y[2]})` : "";
  }), handleMouseDown: l };
}, render() {
  const { clsPrefix: r } = this;
  return B("div", { class: `${r}-color-picker-pallete`, onMousedown: this.handleMouseDown, ref: "palleteRef" }, B("div", { class: `${r}-color-picker-pallete__layer`, style: { backgroundImage: `linear-gradient(90deg, white, hsl(${this.displayedHue}, 100%, 50%))` } }), B("div", { class: `${r}-color-picker-pallete__layer ${r}-color-picker-pallete__layer--shadowed`, style: { backgroundImage: "linear-gradient(180deg, rgba(0, 0, 0, 0%), rgba(0, 0, 0, 100%))" } }), this.rgba && B("div", { class: `${r}-color-picker-handle`, style: { width: wp, height: wp, borderRadius: Cp, left: `calc(${this.displayedSv[0]}% - ${Cp})`, bottom: `calc(${this.displayedSv[1]}% - ${Cp})` } }, B("div", { class: `${r}-color-picker-handle__fill`, style: { backgroundColor: this.handleColor, borderRadius: Cp, width: wp, height: wp } })));
} }), R5 = qe([he("color-picker", `
 display: inline-block;
 box-sizing: border-box;
 height: var(--n-height);
 font-size: var(--n-font-size);
 width: 100%;
 position: relative;
 `), he("color-picker-panel", `
 margin: 4px 0;
 width: 240px;
 font-size: var(--n-panel-font-size);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 `, [nm(), he("input", `
 text-align: center;
 `)]), he("color-picker-checkboard", `
 background: white; 
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [qe("&::after", `
 background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
 background-size: 12px 12px;
 background-position: 0 0, 0 6px, 6px -6px, -6px 0px;
 background-repeat: repeat;
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), he("color-picker-slider", `
 margin-bottom: 8px;
 position: relative;
 box-sizing: border-box;
 `, [Le("image", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `), qe("&::after", `
 content: "";
 position: absolute;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
 pointer-events: none;
 `)]), he("color-picker-handle", `
 z-index: 1;
 box-shadow: 0 0 2px 0 rgba(0, 0, 0, .45);
 position: absolute;
 background-color: white;
 overflow: hidden;
 `, [Le("fill", `
 box-sizing: border-box;
 border: 2px solid white;
 `)]), he("color-picker-pallete", `
 height: 180px;
 position: relative;
 margin-bottom: 8px;
 cursor: crosshair;
 `, [Le("layer", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [Ue("shadowed", `
 box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
 `)])]), he("color-picker-preview", `
 display: flex;
 `, [Le("sliders", `
 flex: 1 0 auto;
 `), Le("preview", `
 position: relative;
 height: 30px;
 width: 30px;
 margin: 0 0 8px 6px;
 border-radius: 50%;
 box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
 overflow: hidden;
 `), Le("fill", `
 display: block;
 width: 30px;
 height: 30px;
 `), Le("input", `
 position: absolute;
 top: 0;
 left: 0;
 width: 30px;
 height: 30px;
 opacity: 0;
 z-index: 1;
 `)]), he("color-picker-input", `
 display: flex;
 align-items: center;
 `, [he("input", `
 flex-grow: 1;
 flex-basis: 0;
 `), Le("mode", `
 width: 72px;
 text-align: center;
 `)]), he("color-picker-control", `
 padding: 12px;
 `), he("color-picker-action", `
 display: flex;
 margin-top: -4px;
 border-top: 1px solid var(--n-divider-color);
 padding: 8px 12px;
 justify-content: flex-end;
 `, [he("button", "margin-left: 8px;")]), he("color-picker-trigger", `
 border: var(--n-border);
 height: 100%;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 transition: border-color .3s var(--n-bezier);
 cursor: pointer;
 `, [Le("value", `
 white-space: nowrap;
 position: relative;
 `), Le("fill", `
 border-radius: var(--n-border-radius);
 position: absolute;
 display: flex;
 align-items: center;
 justify-content: center;
 left: 4px;
 right: 4px;
 top: 4px;
 bottom: 4px;
 `), Ue("disabled", "cursor: not-allowed"), he("color-picker-checkboard", `
 border-radius: var(--n-border-radius);
 `, [qe("&::after", `
 --n-block-size: calc((var(--n-height) - 8px) / 3);
 background-size: calc(var(--n-block-size) * 2) calc(var(--n-block-size) * 2);
 background-position: 0 0, 0 var(--n-block-size), var(--n-block-size) calc(-1 * var(--n-block-size)), calc(-1 * var(--n-block-size)) 0px; 
 `)])]), he("color-picker-swatches", `
 display: grid;
 grid-gap: 8px;
 flex-wrap: wrap;
 position: relative;
 grid-template-columns: repeat(auto-fill, 18px);
 margin-top: 10px;
 `, [he("color-picker-swatch", `
 width: 18px;
 height: 18px;
 background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
 background-size: 8px 8px;
 background-position: 0px 0, 0px 4px, 4px -4px, -4px 0px;
 background-repeat: repeat;
 `, [Le("fill", `
 position: relative;
 width: 100%;
 height: 100%;
 border-radius: 3px;
 box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
 cursor: pointer;
 `), qe("&:focus", `
 outline: none;
 `, [Le("fill", [qe("&::after", `
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 background: inherit;
 filter: blur(2px);
 content: "";
 `)])])])])]), A5 = Object.assign(Object.assign({}, er.props), { value: String, show: { type: Boolean, default: void 0 }, defaultShow: Boolean, defaultValue: String, modes: { type: Array, default: () => ["rgb", "hex", "hsl"] }, placement: { type: String, default: "bottom-start" }, to: Rc.propTo, showAlpha: { type: Boolean, default: true }, showPreview: Boolean, swatches: Array, disabled: { type: Boolean, default: void 0 }, actions: { type: Array, default: null }, internalActions: Array, size: String, renderLabel: Function, onComplete: Function, onConfirm: Function, onClear: Function, "onUpdate:show": [Function, Array], onUpdateShow: [Function, Array], "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array] }), Kg = nt({ name: "ColorPicker", props: A5, slots: Object, setup(r, { slots: n }) {
  const l = Ee(null);
  let h = null;
  const f = Ba(r), { mergedSizeRef: y, mergedDisabledRef: p } = f, { localeRef: s } = ds("global"), { mergedClsPrefixRef: S, namespaceRef: P, inlineThemeDisabled: M } = Cr(r), A = er("ColorPicker", "-color-picker", R5, E3, r, S);
  Vr(av, { themeRef: A, renderLabelRef: zt(r, "renderLabel"), colorPickerSlots: n });
  const O = Ee(r.defaultShow), j = Qi(zt(r, "show"), O);
  function L(Be) {
    const { onUpdateShow: ot, "onUpdate:show": $e } = r;
    ot && jt(ot, Be), $e && jt($e, Be), O.value = Be;
  }
  const { defaultValue: q } = r, N = Ee(q === void 0 ? l5(r.modes, r.showAlpha) : q), J = Qi(zt(r, "value"), N), te = Ee([J.value]), ne = Ee(0), ae = Ae(() => Ih(J.value)), { modes: oe } = r, ee = Ee(Ih(J.value) || oe[0] || "rgb");
  function ke() {
    const { modes: Be } = r, { value: ot } = ee, $e = Be.findIndex((Ye) => Ye === ot);
    ~$e ? ee.value = Be[($e + 1) % Be.length] : ee.value = "rgb";
  }
  let ve, le, ue, be, Ve, Ge, et, dt;
  const Ct = Ae(() => {
    const { value: Be } = J;
    if (!Be) return null;
    switch (ae.value) {
      case "hsv":
        return Zl(Be);
      case "hsl":
        return [ve, le, ue, dt] = Ec(Be), [...l1(ve, le, ue), dt];
      case "rgb":
      case "hex":
        return [Ve, Ge, et, dt] = ua(Be), [...w0(Ve, Ge, et), dt];
    }
  }), kt = Ae(() => {
    const { value: Be } = J;
    if (!Be) return null;
    switch (ae.value) {
      case "rgb":
      case "hex":
        return ua(Be);
      case "hsv":
        return [ve, le, be, dt] = Zl(Be), [...Ls(ve, le, be), dt];
      case "hsl":
        return [ve, le, ue, dt] = Ec(Be), [...x0(ve, le, ue), dt];
    }
  }), ct = Ae(() => {
    const { value: Be } = J;
    if (!Be) return null;
    switch (ae.value) {
      case "hsl":
        return Ec(Be);
      case "hsv":
        return [ve, le, be, dt] = Zl(Be), [...Fp(ve, le, be), dt];
      case "rgb":
      case "hex":
        return [Ve, Ge, et, dt] = ua(Be), [...C0(Ve, Ge, et), dt];
    }
  }), it = Ae(() => {
    switch (ee.value) {
      case "rgb":
      case "hex":
        return kt.value;
      case "hsv":
        return Ct.value;
      case "hsl":
        return ct.value;
    }
  }), pt = Ee(0), $t = Ee(1), vt = Ee([0, 0]);
  function Pt(Be, ot) {
    const { value: $e } = Ct, Ye = pt.value, ht = $e ? $e[3] : 1;
    vt.value = [Be, ot];
    const { showAlpha: St } = r;
    switch (ee.value) {
      case "hsv":
        bt((St ? Hl : T0)([Ye, Be, ot, ht]), "cursor");
        break;
      case "hsl":
        bt((St ? as : S0)([...Fp(Ye, Be, ot), ht]), "cursor");
        break;
      case "rgb":
        bt((St ? ss : k0)([...Ls(Ye, Be, ot), ht]), "cursor");
        break;
      case "hex":
        bt((St ? Ns : vh)([...Ls(Ye, Be, ot), ht]), "cursor");
        break;
    }
  }
  function Nt(Be) {
    pt.value = Be;
    const { value: ot } = Ct;
    if (!ot) return;
    const [, $e, Ye, ht] = ot, { showAlpha: St } = r;
    switch (ee.value) {
      case "hsv":
        bt((St ? Hl : T0)([Be, $e, Ye, ht]), "cursor");
        break;
      case "rgb":
        bt((St ? ss : k0)([...Ls(Be, $e, Ye), ht]), "cursor");
        break;
      case "hex":
        bt((St ? Ns : vh)([...Ls(Be, $e, Ye), ht]), "cursor");
        break;
      case "hsl":
        bt((St ? as : S0)([...Fp(Be, $e, Ye), ht]), "cursor");
        break;
    }
  }
  function ir(Be) {
    switch (ee.value) {
      case "hsv":
        [ve, le, be] = Ct.value, bt(Hl([ve, le, be, Be]), "cursor");
        break;
      case "rgb":
        [Ve, Ge, et] = kt.value, bt(ss([Ve, Ge, et, Be]), "cursor");
        break;
      case "hex":
        [Ve, Ge, et] = kt.value, bt(Ns([Ve, Ge, et, Be]), "cursor");
        break;
      case "hsl":
        [ve, le, ue] = ct.value, bt(as([ve, le, ue, Be]), "cursor");
        break;
    }
    $t.value = Be;
  }
  function bt(Be, ot) {
    ot === "cursor" ? h = Be : h = null;
    const { nTriggerFormChange: $e, nTriggerFormInput: Ye } = f, { onUpdateValue: ht, "onUpdate:value": St } = r;
    ht && jt(ht, Be), St && jt(St, Be), $e(), Ye(), N.value = Be;
  }
  function Dt(Be) {
    bt(Be, "input"), eo(Zt);
  }
  function Zt(Be = true) {
    const { value: ot } = J;
    if (ot) {
      const { nTriggerFormChange: $e, nTriggerFormInput: Ye } = f, { onComplete: ht } = r;
      ht && ht(ot);
      const { value: St } = te, { value: rt } = ne;
      Be && (St.splice(rt + 1, St.length, ot), ne.value = rt + 1), $e(), Ye();
    }
  }
  function dr() {
    const { value: Be } = ne;
    Be - 1 < 0 || (bt(te.value[Be - 1], "input"), Zt(false), ne.value = Be - 1);
  }
  function yr() {
    const { value: Be } = ne;
    Be < 0 || Be + 1 >= te.value.length || (bt(te.value[Be + 1], "input"), Zt(false), ne.value = Be + 1);
  }
  function Pr() {
    bt(null, "input");
    const { onClear: Be } = r;
    Be && Be(), L(false);
  }
  function lr() {
    const { value: Be } = J, { onConfirm: ot } = r;
    ot && ot(Be), L(false);
  }
  const Ir = Ae(() => ne.value >= 1), Ht = Ae(() => {
    const { value: Be } = te;
    return Be.length > 1 && ne.value < Be.length - 1;
  });
  Kt(j, (Be) => {
    Be || (te.value = [J.value], ne.value = 0);
  }), Ao(() => {
    if (!(h && h === J.value)) {
      const { value: Be } = Ct;
      Be && (pt.value = Be[0], $t.value = Be[3], vt.value = [Be[1], Be[2]]);
    }
    h = null;
  });
  const Rr = Ae(() => {
    const { value: Be } = y, { common: { cubicBezierEaseInOut: ot }, self: { textColor: $e, color: Ye, panelFontSize: ht, boxShadow: St, border: rt, borderRadius: mt, dividerColor: nr, [Ut("height", Be)]: di, [Ut("fontSize", Be)]: wi } } = A.value;
    return { "--n-bezier": ot, "--n-text-color": $e, "--n-color": Ye, "--n-panel-font-size": ht, "--n-font-size": wi, "--n-box-shadow": St, "--n-border": rt, "--n-border-radius": mt, "--n-height": di, "--n-divider-color": nr };
  }), xr = M ? ai("color-picker", Ae(() => y.value[0]), Rr, r) : void 0;
  function gt() {
    var Be;
    const { value: ot } = kt, { value: $e } = pt, { internalActions: Ye, modes: ht, actions: St } = r, { value: rt } = A, { value: mt } = S;
    return B("div", { class: [`${mt}-color-picker-panel`, xr == null ? void 0 : xr.themeClass.value], onDragstart: (nr) => {
      nr.preventDefault();
    }, style: M ? void 0 : Rr.value }, B("div", { class: `${mt}-color-picker-control` }, B(D5, { clsPrefix: mt, rgba: ot, displayedHue: $e, displayedSv: vt.value, onUpdateSV: Pt, onComplete: Zt }), B("div", { class: `${mt}-color-picker-preview` }, B("div", { class: `${mt}-color-picker-preview__sliders` }, B(M5, { clsPrefix: mt, hue: $e, onUpdateHue: Nt, onComplete: Zt }), r.showAlpha ? B(p5, { clsPrefix: mt, rgba: ot, alpha: $t.value, onUpdateAlpha: ir, onComplete: Zt }) : null), r.showPreview ? B(T5, { clsPrefix: mt, mode: ee.value, color: kt.value && vh(kt.value), onUpdateColor: (nr) => {
      bt(nr, "input");
    } }) : null), B(x5, { clsPrefix: mt, showAlpha: r.showAlpha, mode: ee.value, modes: ht, onUpdateMode: ke, value: J.value, valueArr: it.value, onUpdateValue: Dt }), ((Be = r.swatches) === null || Be === void 0 ? void 0 : Be.length) && B(S5, { clsPrefix: mt, mode: ee.value, swatches: r.swatches, onUpdateColor: (nr) => {
      bt(nr, "input");
    } })), (St == null ? void 0 : St.length) ? B("div", { class: `${mt}-color-picker-action` }, St.includes("confirm") && B(Or, { size: "small", onClick: lr, theme: rt.peers.Button, themeOverrides: rt.peerOverrides.Button }, { default: () => s.value.confirm }), St.includes("clear") && B(Or, { size: "small", onClick: Pr, disabled: !J.value, theme: rt.peers.Button, themeOverrides: rt.peerOverrides.Button }, { default: () => s.value.clear })) : null, n.action ? B("div", { class: `${mt}-color-picker-action` }, { default: n.action }) : Ye ? B("div", { class: `${mt}-color-picker-action` }, Ye.includes("undo") && B(Or, { size: "small", onClick: dr, disabled: !Ir.value, theme: rt.peers.Button, themeOverrides: rt.peerOverrides.Button }, { default: () => s.value.undo }), Ye.includes("redo") && B(Or, { size: "small", onClick: yr, disabled: !Ht.value, theme: rt.peers.Button, themeOverrides: rt.peerOverrides.Button }, { default: () => s.value.redo })) : null);
  }
  return { mergedClsPrefix: S, namespace: P, selfRef: l, hsla: ct, rgba: kt, mergedShow: j, mergedDisabled: p, isMounted: cm(), adjustedTo: Rc(r), mergedValue: J, handleTriggerClick() {
    L(true);
  }, handleClickOutside(Be) {
    var ot;
    !((ot = l.value) === null || ot === void 0) && ot.contains(h1(Be)) || L(false);
  }, renderPanel: gt, cssVars: M ? void 0 : Rr, themeClass: xr == null ? void 0 : xr.themeClass, onRender: xr == null ? void 0 : xr.onRender };
}, render() {
  const { mergedClsPrefix: r, onRender: n } = this;
  return n == null ? void 0 : n(), B("div", { class: [this.themeClass, `${r}-color-picker`], ref: "selfRef", style: this.cssVars }, B(u1, null, { default: () => [B(c1, null, { default: () => B(k5, { clsPrefix: r, value: this.mergedValue, hsla: this.hsla, disabled: this.mergedDisabled, onClick: this.handleTriggerClick }) }), B(d1, { placement: this.placement, show: this.mergedShow, containerClass: this.namespace, teleportDisabled: this.adjustedTo === Rc.tdkey, to: this.adjustedTo }, { default: () => B(Wo, { name: "fade-in-scale-up-transition", appear: this.isMounted }, { default: () => this.mergedShow ? za(this.renderPanel(), [[qp, this.handleClickOutside, void 0, { capture: true }]]) : null }) })] }));
} }), z5 = qe([he("select", `
 z-index: auto;
 outline: none;
 width: 100%;
 position: relative;
 font-weight: var(--n-font-weight);
 `), he("select-menu", `
 margin: 4px 0;
 box-shadow: var(--n-menu-box-shadow);
 `, [nm({ originalTransition: "background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)" })])]), F5 = Object.assign(Object.assign({}, er.props), { to: Rc.propTo, bordered: { type: Boolean, default: void 0 }, clearable: Boolean, clearFilterAfterSelect: { type: Boolean, default: true }, options: { type: Array, default: () => [] }, defaultValue: { type: [String, Number, Array], default: null }, keyboard: { type: Boolean, default: true }, value: [String, Number, Array], placeholder: String, menuProps: Object, multiple: Boolean, size: String, menuSize: { type: String }, filterable: Boolean, disabled: { type: Boolean, default: void 0 }, remote: Boolean, loading: Boolean, filter: Function, placement: { type: String, default: "bottom-start" }, widthMode: { type: String, default: "trigger" }, tag: Boolean, onCreate: Function, fallbackOption: { type: [Function, Boolean], default: void 0 }, show: { type: Boolean, default: void 0 }, showArrow: { type: Boolean, default: true }, maxTagCount: [Number, String], ellipsisTagPopoverProps: Object, consistentMenuWidth: { type: Boolean, default: true }, virtualScroll: { type: Boolean, default: true }, labelField: { type: String, default: "label" }, valueField: { type: String, default: "value" }, childrenField: { type: String, default: "children" }, renderLabel: Function, renderOption: Function, renderTag: Function, "onUpdate:value": [Function, Array], inputProps: Object, nodeProps: Function, ignoreComposition: { type: Boolean, default: true }, showOnFocus: Boolean, onUpdateValue: [Function, Array], onBlur: [Function, Array], onClear: [Function, Array], onFocus: [Function, Array], onScroll: [Function, Array], onSearch: [Function, Array], onUpdateShow: [Function, Array], "onUpdate:show": [Function, Array], displayDirective: { type: String, default: "show" }, resetMenuOnOptionsChange: { type: Boolean, default: true }, status: String, showCheckmark: { type: Boolean, default: true }, onChange: [Function, Array], items: Array }), M0 = nt({ name: "Select", props: F5, slots: Object, setup(r) {
  const { mergedClsPrefixRef: n, mergedBorderedRef: l, namespaceRef: h, inlineThemeDisabled: f } = Cr(r), y = er("Select", "-select", z5, M3, r, n), p = Ee(r.defaultValue), s = zt(r, "value"), S = Qi(s, p), P = Ee(false), M = Ee(""), A = Wp(r, ["items", "options"]), O = Ee([]), j = Ee([]), L = Ae(() => j.value.concat(O.value).concat(A.value)), q = Ae(() => {
    const { filter: $ } = r;
    if ($) return $;
    const { labelField: Z, valueField: Q } = r;
    return (ge, _e) => {
      if (!_e) return false;
      const Re = _e[Z];
      if (typeof Re == "string") return Zg(ge, Re);
      const se = _e[Q];
      return typeof se == "string" ? Zg(ge, se) : typeof se == "number" ? Zg(ge, String(se)) : false;
    };
  }), N = Ae(() => {
    if (r.remote) return A.value;
    {
      const { value: $ } = L, { value: Z } = M;
      return !Z.length || !r.filterable ? $ : GP($, q.value, Z, r.childrenField);
    }
  }), J = Ae(() => {
    const { valueField: $, childrenField: Z } = r, Q = UP($, Z);
    return D3(N.value, Q);
  }), te = Ae(() => qP(L.value, r.valueField, r.childrenField)), ne = Ee(false), ae = Qi(zt(r, "show"), ne), oe = Ee(null), ee = Ee(null), ke = Ee(null), { localeRef: ve } = ds("Select"), le = Ae(() => {
    var $;
    return ($ = r.placeholder) !== null && $ !== void 0 ? $ : ve.value.placeholder;
  }), ue = [], be = Ee(/* @__PURE__ */ new Map()), Ve = Ae(() => {
    const { fallbackOption: $ } = r;
    if ($ === void 0) {
      const { labelField: Z, valueField: Q } = r;
      return (ge) => ({ [Z]: String(ge), [Q]: ge });
    }
    return $ === false ? false : (Z) => Object.assign($(Z), { value: Z });
  });
  function Ge($) {
    const Z = r.remote, { value: Q } = be, { value: ge } = te, { value: _e } = Ve, Re = [];
    return $.forEach((se) => {
      if (ge.has(se)) Re.push(ge.get(se));
      else if (Z && Q.has(se)) Re.push(Q.get(se));
      else if (_e) {
        const Fe = _e(se);
        Fe && Re.push(Fe);
      }
    }), Re;
  }
  const et = Ae(() => {
    if (r.multiple) {
      const { value: $ } = S;
      return Array.isArray($) ? Ge($) : [];
    }
    return null;
  }), dt = Ae(() => {
    const { value: $ } = S;
    return !r.multiple && !Array.isArray($) ? $ === null ? null : Ge([$])[0] || null : null;
  }), Ct = Ba(r), { mergedSizeRef: kt, mergedDisabledRef: ct, mergedStatusRef: it } = Ct;
  function pt($, Z) {
    const { onChange: Q, "onUpdate:value": ge, onUpdateValue: _e } = r, { nTriggerFormChange: Re, nTriggerFormInput: se } = Ct;
    Q && jt(Q, $, Z), _e && jt(_e, $, Z), ge && jt(ge, $, Z), p.value = $, Re(), se();
  }
  function $t($) {
    const { onBlur: Z } = r, { nTriggerFormBlur: Q } = Ct;
    Z && jt(Z, $), Q();
  }
  function vt() {
    const { onClear: $ } = r;
    $ && jt($);
  }
  function Pt($) {
    const { onFocus: Z, showOnFocus: Q } = r, { nTriggerFormFocus: ge } = Ct;
    Z && jt(Z, $), ge(), Q && Zt();
  }
  function Nt($) {
    const { onSearch: Z } = r;
    Z && jt(Z, $);
  }
  function ir($) {
    const { onScroll: Z } = r;
    Z && jt(Z, $);
  }
  function bt() {
    var $;
    const { remote: Z, multiple: Q } = r;
    if (Z) {
      const { value: ge } = be;
      if (Q) {
        const { valueField: _e } = r;
        ($ = et.value) === null || $ === void 0 || $.forEach((Re) => {
          ge.set(Re[_e], Re);
        });
      } else {
        const _e = dt.value;
        _e && ge.set(_e[r.valueField], _e);
      }
    }
  }
  function Dt($) {
    const { onUpdateShow: Z, "onUpdate:show": Q } = r;
    Z && jt(Z, $), Q && jt(Q, $), ne.value = $;
  }
  function Zt() {
    ct.value || (Dt(true), ne.value = true, r.filterable && wn());
  }
  function dr() {
    Dt(false);
  }
  function yr() {
    M.value = "", j.value = ue;
  }
  const Pr = Ee(false);
  function lr() {
    r.filterable && (Pr.value = true);
  }
  function Ir() {
    r.filterable && (Pr.value = false, ae.value || yr());
  }
  function Ht() {
    ct.value || (ae.value ? r.filterable ? wn() : dr() : Zt());
  }
  function Rr($) {
    var Z, Q;
    !((Q = (Z = ke.value) === null || Z === void 0 ? void 0 : Z.selfRef) === null || Q === void 0) && Q.contains($.relatedTarget) || (P.value = false, $t($), dr());
  }
  function xr($) {
    Pt($), P.value = true;
  }
  function gt() {
    P.value = true;
  }
  function Be($) {
    var Z;
    !((Z = oe.value) === null || Z === void 0) && Z.$el.contains($.relatedTarget) || (P.value = false, $t($), dr());
  }
  function ot() {
    var $;
    ($ = oe.value) === null || $ === void 0 || $.focus(), dr();
  }
  function $e($) {
    var Z;
    ae.value && (!((Z = oe.value) === null || Z === void 0) && Z.$el.contains(h1($)) || dr());
  }
  function Ye($) {
    if (!Array.isArray($)) return [];
    if (Ve.value) return Array.from($);
    {
      const { remote: Z } = r, { value: Q } = te;
      if (Z) {
        const { value: ge } = be;
        return $.filter((_e) => Q.has(_e) || ge.has(_e));
      } else return $.filter((ge) => Q.has(ge));
    }
  }
  function ht($) {
    St($.rawNode);
  }
  function St($) {
    if (ct.value) return;
    const { tag: Z, remote: Q, clearFilterAfterSelect: ge, valueField: _e } = r;
    if (Z && !Q) {
      const { value: Re } = j, se = Re[0] || null;
      if (se) {
        const Fe = O.value;
        Fe.length ? Fe.push(se) : O.value = [se], j.value = ue;
      }
    }
    if (Q && be.value.set($[_e], $), r.multiple) {
      const Re = Ye(S.value), se = Re.findIndex((Fe) => Fe === $[_e]);
      if (~se) {
        if (Re.splice(se, 1), Z && !Q) {
          const Fe = rt($[_e]);
          ~Fe && (O.value.splice(Fe, 1), ge && (M.value = ""));
        }
      } else Re.push($[_e]), ge && (M.value = "");
      pt(Re, Ge(Re));
    } else {
      if (Z && !Q) {
        const Re = rt($[_e]);
        ~Re ? O.value = [O.value[Re]] : O.value = ue;
      }
      en(), dr(), pt($[_e], $);
    }
  }
  function rt($) {
    return O.value.findIndex((Q) => Q[r.valueField] === $);
  }
  function mt($) {
    ae.value || Zt();
    const { value: Z } = $.target;
    M.value = Z;
    const { tag: Q, remote: ge } = r;
    if (Nt(Z), Q && !ge) {
      if (!Z) {
        j.value = ue;
        return;
      }
      const { onCreate: _e } = r, Re = _e ? _e(Z) : { [r.labelField]: Z, [r.valueField]: Z }, { valueField: se, labelField: Fe } = r;
      A.value.some((We) => We[se] === Re[se] || We[Fe] === Re[Fe]) || O.value.some((We) => We[se] === Re[se] || We[Fe] === Re[Fe]) ? j.value = ue : j.value = [Re];
    }
  }
  function nr($) {
    $.stopPropagation();
    const { multiple: Z } = r;
    !Z && r.filterable && dr(), vt(), Z ? pt([], []) : pt(null, null);
  }
  function di($) {
    !Wl($, "action") && !Wl($, "empty") && !Wl($, "header") && $.preventDefault();
  }
  function wi($) {
    ir($);
  }
  function xn($) {
    var Z, Q, ge, _e, Re;
    if (!r.keyboard) {
      $.preventDefault();
      return;
    }
    switch ($.key) {
      case " ":
        if (r.filterable) break;
        $.preventDefault();
      case "Enter":
        if (!(!((Z = oe.value) === null || Z === void 0) && Z.isComposing)) {
          if (ae.value) {
            const se = (Q = ke.value) === null || Q === void 0 ? void 0 : Q.getPendingTmNode();
            se ? ht(se) : r.filterable || (dr(), en());
          } else if (Zt(), r.tag && Pr.value) {
            const se = j.value[0];
            if (se) {
              const Fe = se[r.valueField], { value: We } = S;
              r.multiple && Array.isArray(We) && We.includes(Fe) || St(se);
            }
          }
        }
        $.preventDefault();
        break;
      case "ArrowUp":
        if ($.preventDefault(), r.loading) return;
        ae.value && ((ge = ke.value) === null || ge === void 0 || ge.prev());
        break;
      case "ArrowDown":
        if ($.preventDefault(), r.loading) return;
        ae.value ? (_e = ke.value) === null || _e === void 0 || _e.next() : Zt();
        break;
      case "Escape":
        ae.value && (R3($), dr()), (Re = oe.value) === null || Re === void 0 || Re.focus();
        break;
    }
  }
  function en() {
    var $;
    ($ = oe.value) === null || $ === void 0 || $.focus();
  }
  function wn() {
    var $;
    ($ = oe.value) === null || $ === void 0 || $.focusInput();
  }
  function Cn() {
    var $;
    ae.value && (($ = ee.value) === null || $ === void 0 || $.syncPosition());
  }
  bt(), Kt(zt(r, "options"), bt);
  const Bi = { focus: () => {
    var $;
    ($ = oe.value) === null || $ === void 0 || $.focus();
  }, focusInput: () => {
    var $;
    ($ = oe.value) === null || $ === void 0 || $.focusInput();
  }, blur: () => {
    var $;
    ($ = oe.value) === null || $ === void 0 || $.blur();
  }, blurInput: () => {
    var $;
    ($ = oe.value) === null || $ === void 0 || $.blurInput();
  } }, Ci = Ae(() => {
    const { self: { menuBoxShadow: $ } } = y.value;
    return { "--n-menu-box-shadow": $ };
  }), Me = f ? ai("select", void 0, Ci, r) : void 0;
  return Object.assign(Object.assign({}, Bi), { mergedStatus: it, mergedClsPrefix: n, mergedBordered: l, namespace: h, treeMate: J, isMounted: cm(), triggerRef: oe, menuRef: ke, pattern: M, uncontrolledShow: ne, mergedShow: ae, adjustedTo: Rc(r), uncontrolledValue: p, mergedValue: S, followerRef: ee, localizedPlaceholder: le, selectedOption: dt, selectedOptions: et, mergedSize: kt, mergedDisabled: ct, focused: P, activeWithoutMenuOpen: Pr, inlineThemeDisabled: f, onTriggerInputFocus: lr, onTriggerInputBlur: Ir, handleTriggerOrMenuResize: Cn, handleMenuFocus: gt, handleMenuBlur: Be, handleMenuTabOut: ot, handleTriggerClick: Ht, handleToggle: ht, handleDeleteOption: St, handlePatternInput: mt, handleClear: nr, handleTriggerBlur: Rr, handleTriggerFocus: xr, handleKeydown: xn, handleMenuAfterLeave: yr, handleMenuClickOutside: $e, handleMenuScroll: wi, handleMenuKeydown: xn, handleMenuMousedown: di, mergedTheme: y, cssVars: f ? void 0 : Ci, themeClass: Me == null ? void 0 : Me.themeClass, onRender: Me == null ? void 0 : Me.onRender });
}, render() {
  return B("div", { class: `${this.mergedClsPrefix}-select` }, B(u1, null, { default: () => [B(c1, null, { default: () => B(TP, { ref: "triggerRef", inlineThemeDisabled: this.inlineThemeDisabled, status: this.mergedStatus, inputProps: this.inputProps, clsPrefix: this.mergedClsPrefix, showArrow: this.showArrow, maxTagCount: this.maxTagCount, ellipsisTagPopoverProps: this.ellipsisTagPopoverProps, bordered: this.mergedBordered, active: this.activeWithoutMenuOpen || this.mergedShow, pattern: this.pattern, placeholder: this.localizedPlaceholder, selectedOption: this.selectedOption, selectedOptions: this.selectedOptions, multiple: this.multiple, renderTag: this.renderTag, renderLabel: this.renderLabel, filterable: this.filterable, clearable: this.clearable, disabled: this.mergedDisabled, size: this.mergedSize, theme: this.mergedTheme.peers.InternalSelection, labelField: this.labelField, valueField: this.valueField, themeOverrides: this.mergedTheme.peerOverrides.InternalSelection, loading: this.loading, focused: this.focused, onClick: this.handleTriggerClick, onDeleteOption: this.handleDeleteOption, onPatternInput: this.handlePatternInput, onClear: this.handleClear, onBlur: this.handleTriggerBlur, onFocus: this.handleTriggerFocus, onKeydown: this.handleKeydown, onPatternBlur: this.onTriggerInputBlur, onPatternFocus: this.onTriggerInputFocus, onResize: this.handleTriggerOrMenuResize, ignoreComposition: this.ignoreComposition }, { arrow: () => {
    var r, n;
    return [(n = (r = this.$slots).arrow) === null || n === void 0 ? void 0 : n.call(r)];
  } }) }), B(d1, { ref: "followerRef", show: this.mergedShow, to: this.adjustedTo, teleportDisabled: this.adjustedTo === Rc.tdkey, containerClass: this.namespace, width: this.consistentMenuWidth ? "target" : void 0, minWidth: "target", placement: this.placement }, { default: () => B(Wo, { name: "fade-in-scale-up-transition", appear: this.isMounted, onAfterLeave: this.handleMenuAfterLeave }, { default: () => {
    var r, n, l;
    return this.mergedShow || this.displayDirective === "show" ? ((r = this.onRender) === null || r === void 0 || r.call(this), za(B(xP, Object.assign({}, this.menuProps, { ref: "menuRef", onResize: this.handleTriggerOrMenuResize, inlineThemeDisabled: this.inlineThemeDisabled, virtualScroll: this.consistentMenuWidth && this.virtualScroll, class: [`${this.mergedClsPrefix}-select-menu`, this.themeClass, (n = this.menuProps) === null || n === void 0 ? void 0 : n.class], clsPrefix: this.mergedClsPrefix, focusable: true, labelField: this.labelField, valueField: this.valueField, autoPending: true, nodeProps: this.nodeProps, theme: this.mergedTheme.peers.InternalSelectMenu, themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu, treeMate: this.treeMate, multiple: this.multiple, size: this.menuSize, renderOption: this.renderOption, renderLabel: this.renderLabel, value: this.mergedValue, style: [(l = this.menuProps) === null || l === void 0 ? void 0 : l.style, this.cssVars], onToggle: this.handleToggle, onScroll: this.handleMenuScroll, onFocus: this.handleMenuFocus, onBlur: this.handleMenuBlur, onKeydown: this.handleMenuKeydown, onTabOut: this.handleMenuTabOut, onMousedown: this.handleMenuMousedown, show: this.mergedShow, showCheckmark: this.showCheckmark, resetMenuOnOptionsChange: this.resetMenuOnOptionsChange }), { empty: () => {
      var h, f;
      return [(f = (h = this.$slots).empty) === null || f === void 0 ? void 0 : f.call(h)];
    }, header: () => {
      var h, f;
      return [(f = (h = this.$slots).header) === null || f === void 0 ? void 0 : f.call(h)];
    }, action: () => {
      var h, f;
      return [(f = (h = this.$slots).action) === null || f === void 0 ? void 0 : f.call(h)];
    } }), this.displayDirective === "show" ? [[us, this.mergedShow], [qp, this.handleMenuClickOutside, void 0, { capture: true }]] : [[qp, this.handleMenuClickOutside, void 0, { capture: true }]])) : null;
  } }) })] }));
} }), L5 = { name: String, value: { type: [String, Number, Boolean], default: "on" }, checked: { type: Boolean, default: void 0 }, defaultChecked: Boolean, disabled: { type: Boolean, default: void 0 }, label: String, size: String, onUpdateChecked: [Function, Array], "onUpdate:checked": [Function, Array], checkedValue: { type: Boolean, default: void 0 } }, ox = qn("n-radio-group");
function B5(r) {
  const n = cr(ox, null), l = Ba(r, { mergedSize(te) {
    const { size: ne } = r;
    if (ne !== void 0) return ne;
    if (n) {
      const { mergedSizeRef: { value: ae } } = n;
      if (ae !== void 0) return ae;
    }
    return te ? te.mergedSize.value : "medium";
  }, mergedDisabled(te) {
    return !!(r.disabled || (n == null ? void 0 : n.disabledRef.value) || (te == null ? void 0 : te.disabled.value));
  } }), { mergedSizeRef: h, mergedDisabledRef: f } = l, y = Ee(null), p = Ee(null), s = Ee(r.defaultChecked), S = zt(r, "checked"), P = Qi(S, s), M = vi(() => n ? n.valueRef.value === r.value : P.value), A = vi(() => {
    const { name: te } = r;
    if (te !== void 0) return te;
    if (n) return n.nameRef.value;
  }), O = Ee(false);
  function j() {
    if (n) {
      const { doUpdateValue: te } = n, { value: ne } = r;
      jt(te, ne);
    } else {
      const { onUpdateChecked: te, "onUpdate:checked": ne } = r, { nTriggerFormInput: ae, nTriggerFormChange: oe } = l;
      te && jt(te, true), ne && jt(ne, true), ae(), oe(), s.value = true;
    }
  }
  function L() {
    f.value || M.value || j();
  }
  function q() {
    L(), y.value && (y.value.checked = M.value);
  }
  function N() {
    O.value = false;
  }
  function J() {
    O.value = true;
  }
  return { mergedClsPrefix: n ? n.mergedClsPrefixRef : Cr(r).mergedClsPrefixRef, inputRef: y, labelRef: p, mergedName: A, mergedDisabled: f, renderSafeChecked: M, focus: O, mergedSize: h, handleRadioInputChange: q, handleRadioInputBlur: N, handleRadioInputFocus: J };
}
const O5 = nt({ name: "RadioButton", props: L5, setup: B5, render() {
  const { mergedClsPrefix: r } = this;
  return B("label", { class: [`${r}-radio-button`, this.mergedDisabled && `${r}-radio-button--disabled`, this.renderSafeChecked && `${r}-radio-button--checked`, this.focus && [`${r}-radio-button--focus`]] }, B("input", { ref: "inputRef", type: "radio", class: `${r}-radio-input`, value: this.value, name: this.mergedName, checked: this.renderSafeChecked, disabled: this.mergedDisabled, onChange: this.handleRadioInputChange, onFocus: this.handleRadioInputFocus, onBlur: this.handleRadioInputBlur }), B("div", { class: `${r}-radio-button__state-border` }), oi(this.$slots.default, (n) => !n && !this.label ? null : B("div", { ref: "labelRef", class: `${r}-radio__label` }, n || this.label)));
} }), $5 = he("radio-group", `
 display: inline-block;
 font-size: var(--n-font-size);
`, [Le("splitor", `
 display: inline-block;
 vertical-align: bottom;
 width: 1px;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 background: var(--n-button-border-color);
 `, [Ue("checked", { backgroundColor: "var(--n-button-border-color-active)" }), Ue("disabled", { opacity: "var(--n-opacity-disabled)" })]), Ue("button-group", `
 white-space: nowrap;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [he("radio-button", { height: "var(--n-height)", lineHeight: "var(--n-height)" }), Le("splitor", { height: "var(--n-height)" })]), he("radio-button", `
 vertical-align: bottom;
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-block;
 box-sizing: border-box;
 padding-left: 14px;
 padding-right: 14px;
 white-space: nowrap;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background: var(--n-button-color);
 color: var(--n-button-text-color);
 border-top: 1px solid var(--n-button-border-color);
 border-bottom: 1px solid var(--n-button-border-color);
 `, [he("radio-input", `
 pointer-events: none;
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 `), Le("state-border", `
 z-index: 1;
 pointer-events: none;
 position: absolute;
 box-shadow: var(--n-button-box-shadow);
 transition: box-shadow .3s var(--n-bezier);
 left: -1px;
 bottom: -1px;
 right: -1px;
 top: -1px;
 `), qe("&:first-child", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 border-left: 1px solid var(--n-button-border-color);
 `, [Le("state-border", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 `)]), qe("&:last-child", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 border-right: 1px solid var(--n-button-border-color);
 `, [Le("state-border", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 `)]), ci("disabled", `
 cursor: pointer;
 `, [qe("&:hover", [Le("state-border", `
 transition: box-shadow .3s var(--n-bezier);
 box-shadow: var(--n-button-box-shadow-hover);
 `), ci("checked", { color: "var(--n-button-text-color-hover)" })]), Ue("focus", [qe("&:not(:active)", [Le("state-border", { boxShadow: "var(--n-button-box-shadow-focus)" })])])]), Ue("checked", `
 background: var(--n-button-color-active);
 color: var(--n-button-text-color-active);
 border-color: var(--n-button-border-color-active);
 `), Ue("disabled", `
 cursor: not-allowed;
 opacity: var(--n-opacity-disabled);
 `)])]);
function N5(r, n, l) {
  var h;
  const f = [];
  let y = false;
  for (let p = 0; p < r.length; ++p) {
    const s = r[p], S = (h = s.type) === null || h === void 0 ? void 0 : h.name;
    S === "RadioButton" && (y = true);
    const P = s.props;
    if (S !== "RadioButton") {
      f.push(s);
      continue;
    }
    if (p === 0) f.push(s);
    else {
      const M = f[f.length - 1].props, A = n === M.value, O = M.disabled, j = n === P.value, L = P.disabled, q = (A ? 2 : 0) + (O ? 0 : 1), N = (j ? 2 : 0) + (L ? 0 : 1), J = { [`${l}-radio-group__splitor--disabled`]: O, [`${l}-radio-group__splitor--checked`]: A }, te = { [`${l}-radio-group__splitor--disabled`]: L, [`${l}-radio-group__splitor--checked`]: j }, ne = q < N ? te : J;
      f.push(B("div", { class: [`${l}-radio-group__splitor`, ne] }), s);
    }
  }
  return { children: f, isButtonGroup: y };
}
const j5 = Object.assign(Object.assign({}, er.props), { name: String, value: [String, Number, Boolean], defaultValue: { type: [String, Number, Boolean], default: null }, size: String, disabled: { type: Boolean, default: void 0 }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array] }), V5 = nt({ name: "RadioGroup", props: j5, setup(r) {
  const n = Ee(null), { mergedSizeRef: l, mergedDisabledRef: h, nTriggerFormChange: f, nTriggerFormInput: y, nTriggerFormBlur: p, nTriggerFormFocus: s } = Ba(r), { mergedClsPrefixRef: S, inlineThemeDisabled: P, mergedRtlRef: M } = Cr(r), A = er("Radio", "-radio-group", $5, A3, r, S), O = Ee(r.defaultValue), j = zt(r, "value"), L = Qi(j, O);
  function q(oe) {
    const { onUpdateValue: ee, "onUpdate:value": ke } = r;
    ee && jt(ee, oe), ke && jt(ke, oe), O.value = oe, f(), y();
  }
  function N(oe) {
    const { value: ee } = n;
    ee && (ee.contains(oe.relatedTarget) || s());
  }
  function J(oe) {
    const { value: ee } = n;
    ee && (ee.contains(oe.relatedTarget) || p());
  }
  Vr(ox, { mergedClsPrefixRef: S, nameRef: zt(r, "name"), valueRef: L, disabledRef: h, mergedSizeRef: l, doUpdateValue: q });
  const te = Ln("Radio", M, S), ne = Ae(() => {
    const { value: oe } = l, { common: { cubicBezierEaseInOut: ee }, self: { buttonBorderColor: ke, buttonBorderColorActive: ve, buttonBorderRadius: le, buttonBoxShadow: ue, buttonBoxShadowFocus: be, buttonBoxShadowHover: Ve, buttonColor: Ge, buttonColorActive: et, buttonTextColor: dt, buttonTextColorActive: Ct, buttonTextColorHover: kt, opacityDisabled: ct, [Ut("buttonHeight", oe)]: it, [Ut("fontSize", oe)]: pt } } = A.value;
    return { "--n-font-size": pt, "--n-bezier": ee, "--n-button-border-color": ke, "--n-button-border-color-active": ve, "--n-button-border-radius": le, "--n-button-box-shadow": ue, "--n-button-box-shadow-focus": be, "--n-button-box-shadow-hover": Ve, "--n-button-color": Ge, "--n-button-color-active": et, "--n-button-text-color": dt, "--n-button-text-color-hover": kt, "--n-button-text-color-active": Ct, "--n-height": it, "--n-opacity-disabled": ct };
  }), ae = P ? ai("radio-group", Ae(() => l.value[0]), ne, r) : void 0;
  return { selfElRef: n, rtlEnabled: te, mergedClsPrefix: S, mergedValue: L, handleFocusout: J, handleFocusin: N, cssVars: P ? void 0 : ne, themeClass: ae == null ? void 0 : ae.themeClass, onRender: ae == null ? void 0 : ae.onRender };
}, render() {
  var r;
  const { mergedValue: n, mergedClsPrefix: l, handleFocusin: h, handleFocusout: f } = this, { children: y, isButtonGroup: p } = N5(Xl(hm(this)), n, l);
  return (r = this.onRender) === null || r === void 0 || r.call(this), B("div", { onFocusin: h, onFocusout: f, ref: "selfElRef", class: [`${l}-radio-group`, this.rtlEnabled && `${l}-radio-group--rtl`, this.themeClass, p && `${l}-radio-group--button-group`], style: this.cssVars }, y);
} }), ax = he("ellipsis", { overflow: "hidden" }, [ci("line-clamp", `
 white-space: nowrap;
 display: inline-block;
 vertical-align: bottom;
 max-width: 100%;
 `), Ue("line-clamp", `
 display: -webkit-inline-box;
 -webkit-box-orient: vertical;
 `), Ue("cursor-pointer", `
 cursor: pointer;
 `)]);
function D0(r) {
  return `${r}-ellipsis--line-clamp`;
}
function R0(r, n) {
  return `${r}-ellipsis--cursor-${n}`;
}
const sx = Object.assign(Object.assign({}, er.props), { expandTrigger: String, lineClamp: [Number, String], tooltip: { type: [Boolean, Object], default: true } }), U5 = nt({ name: "Ellipsis", inheritAttrs: false, props: sx, slots: Object, setup(r, { slots: n, attrs: l }) {
  const h = p1(), f = er("Ellipsis", "-ellipsis", ax, z3, r, h), y = Ee(null), p = Ee(null), s = Ee(null), S = Ee(false), P = Ae(() => {
    const { lineClamp: N } = r, { value: J } = S;
    return N !== void 0 ? { textOverflow: "", "-webkit-line-clamp": J ? "" : N } : { textOverflow: J ? "" : "ellipsis", "-webkit-line-clamp": "" };
  });
  function M() {
    let N = false;
    const { value: J } = S;
    if (J) return true;
    const { value: te } = y;
    if (te) {
      const { lineClamp: ne } = r;
      if (j(te), ne !== void 0) N = te.scrollHeight <= te.offsetHeight;
      else {
        const { value: ae } = p;
        ae && (N = ae.getBoundingClientRect().width <= te.getBoundingClientRect().width);
      }
      L(te, N);
    }
    return N;
  }
  const A = Ae(() => r.expandTrigger === "click" ? () => {
    var N;
    const { value: J } = S;
    J && ((N = s.value) === null || N === void 0 || N.setShow(false)), S.value = !J;
  } : void 0);
  Kb(() => {
    var N;
    r.tooltip && ((N = s.value) === null || N === void 0 || N.setShow(false));
  });
  const O = () => B("span", Object.assign({}, ls(l, { class: [`${h.value}-ellipsis`, r.lineClamp !== void 0 ? D0(h.value) : void 0, r.expandTrigger === "click" ? R0(h.value, "pointer") : void 0], style: P.value }), { ref: "triggerRef", onClick: A.value, onMouseenter: r.expandTrigger === "click" ? M : void 0 }), r.lineClamp ? n : B("span", { ref: "triggerInnerRef" }, n));
  function j(N) {
    if (!N) return;
    const J = P.value, te = D0(h.value);
    r.lineClamp !== void 0 ? q(N, te, "add") : q(N, te, "remove");
    for (const ne in J) N.style[ne] !== J[ne] && (N.style[ne] = J[ne]);
  }
  function L(N, J) {
    const te = R0(h.value, "pointer");
    r.expandTrigger === "click" && !J ? q(N, te, "add") : q(N, te, "remove");
  }
  function q(N, J, te) {
    te === "add" ? N.classList.contains(J) || N.classList.add(J) : N.classList.contains(J) && N.classList.remove(J);
  }
  return { mergedTheme: f, triggerRef: y, triggerInnerRef: p, tooltipRef: s, handleClick: A, renderTrigger: O, getTooltipDisabled: M };
}, render() {
  var r;
  const { tooltip: n, renderTrigger: l, $slots: h } = this;
  if (n) {
    const { mergedTheme: f } = this;
    return B(f1, Object.assign({ ref: "tooltipRef", placement: "top" }, n, { getDisabled: this.getTooltipDisabled, theme: f.peers.Tooltip, themeOverrides: f.peerOverrides.Tooltip }), { trigger: l, default: (r = h.tooltip) !== null && r !== void 0 ? r : h.default });
  } else return l();
} }), lx = nt({ name: "PerformantEllipsis", props: sx, inheritAttrs: false, setup(r, { attrs: n, slots: l }) {
  const h = Ee(false), f = p1();
  return Nc("-ellipsis", ax, f), { mouseEntered: h, renderTrigger: () => {
    const { lineClamp: p } = r, s = f.value;
    return B("span", Object.assign({}, ls(n, { class: [`${s}-ellipsis`, p !== void 0 ? D0(s) : void 0, r.expandTrigger === "click" ? R0(s, "pointer") : void 0], style: p === void 0 ? { textOverflow: "ellipsis" } : { "-webkit-line-clamp": p } }), { onMouseenter: () => {
      h.value = true;
    } }), p ? l : B("span", null, l));
  } };
}, render() {
  return this.mouseEntered ? B(U5, ls({}, this.$attrs, this.$props), this.$slots) : this.renderTrigger();
} });
function ux() {
  const r = cr(F3, null);
  return r === null && fa("use-dialog", "No outer <n-dialog-provider /> founded."), r;
}
function pm() {
  const r = cr(L3, null);
  return r === null && fa("use-message", "No outer <n-message-provider /> founded. See prerequisite in https://www.naiveui.com/en-US/os-theme/components/message for more details. If you want to use `useMessage` outside setup, please check https://www.naiveui.com/zh-CN/os-theme/components/message#Q-&-A."), r;
}
const G5 = he("divider", `
 position: relative;
 display: flex;
 width: 100%;
 box-sizing: border-box;
 font-size: 16px;
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
`, [ci("vertical", `
 margin-top: 24px;
 margin-bottom: 24px;
 `, [ci("no-title", `
 display: flex;
 align-items: center;
 `)]), Le("title", `
 display: flex;
 align-items: center;
 margin-left: 12px;
 margin-right: 12px;
 white-space: nowrap;
 font-weight: var(--n-font-weight);
 `), Ue("title-position-left", [Le("line", [Ue("left", { width: "28px" })])]), Ue("title-position-right", [Le("line", [Ue("right", { width: "28px" })])]), Ue("dashed", [Le("line", `
 background-color: #0000;
 height: 0px;
 width: 100%;
 border-style: dashed;
 border-width: 1px 0 0;
 `)]), Ue("vertical", `
 display: inline-block;
 height: 1em;
 margin: 0 8px;
 vertical-align: middle;
 width: 1px;
 `), Le("line", `
 border: none;
 transition: background-color .3s var(--n-bezier), border-color .3s var(--n-bezier);
 height: 1px;
 width: 100%;
 margin: 0;
 `), ci("dashed", [Le("line", { backgroundColor: "var(--n-color)" })]), Ue("dashed", [Le("line", { borderColor: "var(--n-color)" })]), Ue("vertical", { backgroundColor: "var(--n-color)" })]), q5 = Object.assign(Object.assign({}, er.props), { titlePlacement: { type: String, default: "center" }, dashed: Boolean, vertical: Boolean }), cx = nt({ name: "Divider", props: q5, setup(r) {
  const { mergedClsPrefixRef: n, inlineThemeDisabled: l } = Cr(r), h = er("Divider", "-divider", G5, B3, r, n), f = Ae(() => {
    const { common: { cubicBezierEaseInOut: p }, self: { color: s, textColor: S, fontWeight: P } } = h.value;
    return { "--n-bezier": p, "--n-color": s, "--n-text-color": S, "--n-font-weight": P };
  }), y = l ? ai("divider", void 0, f, r) : void 0;
  return { mergedClsPrefix: n, cssVars: l ? void 0 : f, themeClass: y == null ? void 0 : y.themeClass, onRender: y == null ? void 0 : y.onRender };
}, render() {
  var r;
  const { $slots: n, titlePlacement: l, vertical: h, dashed: f, cssVars: y, mergedClsPrefix: p } = this;
  return (r = this.onRender) === null || r === void 0 || r.call(this), B("div", { role: "separator", class: [`${p}-divider`, this.themeClass, { [`${p}-divider--vertical`]: h, [`${p}-divider--no-title`]: !n.default, [`${p}-divider--dashed`]: f, [`${p}-divider--title-position-${l}`]: n.default && l }], style: y }, h ? null : B("div", { class: `${p}-divider__line ${p}-divider__line--left` }), !h && n.default ? B(jr, null, B("div", { class: `${p}-divider__title` }, this.$slots), B("div", { class: `${p}-divider__line ${p}-divider__line--right` })) : null);
} }), W5 = nt({ name: "NDrawerContent", inheritAttrs: false, props: { blockScroll: Boolean, show: { type: Boolean, default: void 0 }, displayDirective: { type: String, required: true }, placement: { type: String, required: true }, contentClass: String, contentStyle: [Object, String], nativeScrollbar: { type: Boolean, required: true }, scrollbarProps: Object, trapFocus: { type: Boolean, default: true }, autoFocus: { type: Boolean, default: true }, showMask: { type: [Boolean, String], required: true }, maxWidth: Number, maxHeight: Number, minWidth: Number, minHeight: Number, resizable: Boolean, onClickoutside: Function, onAfterLeave: Function, onAfterEnter: Function, onEsc: Function }, setup(r) {
  const n = Ee(!!r.show), l = Ee(null), h = cr(tv);
  let f = 0, y = "", p = null;
  const s = Ee(false), S = Ee(false), P = Ae(() => r.placement === "top" || r.placement === "bottom"), { mergedClsPrefixRef: M, mergedRtlRef: A } = Cr(r), O = Ln("Drawer", A, M), j = ee, L = (le) => {
    S.value = true, f = P.value ? le.clientY : le.clientX, y = document.body.style.cursor, document.body.style.cursor = P.value ? "ns-resize" : "ew-resize", document.body.addEventListener("mousemove", oe), document.body.addEventListener("mouseleave", j), document.body.addEventListener("mouseup", ee);
  }, q = () => {
    p !== null && (window.clearTimeout(p), p = null), S.value ? s.value = true : p = window.setTimeout(() => {
      s.value = true;
    }, 300);
  }, N = () => {
    p !== null && (window.clearTimeout(p), p = null), s.value = false;
  }, { doUpdateHeight: J, doUpdateWidth: te } = h, ne = (le) => {
    const { maxWidth: ue } = r;
    if (ue && le > ue) return ue;
    const { minWidth: be } = r;
    return be && le < be ? be : le;
  }, ae = (le) => {
    const { maxHeight: ue } = r;
    if (ue && le > ue) return ue;
    const { minHeight: be } = r;
    return be && le < be ? be : le;
  };
  function oe(le) {
    var ue, be;
    if (S.value) if (P.value) {
      let Ve = ((ue = l.value) === null || ue === void 0 ? void 0 : ue.offsetHeight) || 0;
      const Ge = f - le.clientY;
      Ve += r.placement === "bottom" ? Ge : -Ge, Ve = ae(Ve), J(Ve), f = le.clientY;
    } else {
      let Ve = ((be = l.value) === null || be === void 0 ? void 0 : be.offsetWidth) || 0;
      const Ge = f - le.clientX;
      Ve += r.placement === "right" ? Ge : -Ge, Ve = ne(Ve), te(Ve), f = le.clientX;
    }
  }
  function ee() {
    S.value && (f = 0, S.value = false, document.body.style.cursor = y, document.body.removeEventListener("mousemove", oe), document.body.removeEventListener("mouseup", ee), document.body.removeEventListener("mouseleave", j));
  }
  Ao(() => {
    r.show && (n.value = true);
  }), Kt(() => r.show, (le) => {
    le || ee();
  }), Fn(() => {
    ee();
  });
  const ke = Ae(() => {
    const { show: le } = r, ue = [[us, le]];
    return r.showMask || ue.push([qp, r.onClickoutside, void 0, { capture: true }]), ue;
  });
  function ve() {
    var le;
    n.value = false, (le = r.onAfterLeave) === null || le === void 0 || le.call(r);
  }
  return $3(Ae(() => r.blockScroll && n.value)), Vr(N3, l), Vr(j3, null), Vr(V3, null), { bodyRef: l, rtlEnabled: O, mergedClsPrefix: h.mergedClsPrefixRef, isMounted: h.isMountedRef, mergedTheme: h.mergedThemeRef, displayed: n, transitionName: Ae(() => ({ right: "slide-in-from-right-transition", left: "slide-in-from-left-transition", top: "slide-in-from-top-transition", bottom: "slide-in-from-bottom-transition" })[r.placement]), handleAfterLeave: ve, bodyDirectives: ke, handleMousedownResizeTrigger: L, handleMouseenterResizeTrigger: q, handleMouseleaveResizeTrigger: N, isDragging: S, isHoverOnResizeTrigger: s };
}, render() {
  const { $slots: r, mergedClsPrefix: n } = this;
  return this.displayDirective === "show" || this.displayed || this.show ? za(B("div", { role: "none" }, B(O3, { disabled: !this.showMask || !this.trapFocus, active: this.show, autoFocus: this.autoFocus, onEsc: this.onEsc }, { default: () => B(Wo, { name: this.transitionName, appear: this.isMounted, onAfterEnter: this.onAfterEnter, onAfterLeave: this.handleAfterLeave }, { default: () => za(B("div", ls(this.$attrs, { role: "dialog", ref: "bodyRef", "aria-modal": "true", class: [`${n}-drawer`, this.rtlEnabled && `${n}-drawer--rtl`, `${n}-drawer--${this.placement}-placement`, this.isDragging && `${n}-drawer--unselectable`, this.nativeScrollbar && `${n}-drawer--native-scrollbar`] }), [this.resizable ? B("div", { class: [`${n}-drawer__resize-trigger`, (this.isDragging || this.isHoverOnResizeTrigger) && `${n}-drawer__resize-trigger--hover`], onMouseenter: this.handleMouseenterResizeTrigger, onMouseleave: this.handleMouseleaveResizeTrigger, onMousedown: this.handleMousedownResizeTrigger }) : null, this.nativeScrollbar ? B("div", { class: [`${n}-drawer-content-wrapper`, this.contentClass], style: this.contentStyle, role: "none" }, r) : B(Bh, Object.assign({}, this.scrollbarProps, { contentStyle: this.contentStyle, contentClass: [`${n}-drawer-content-wrapper`, this.contentClass], theme: this.mergedTheme.peers.Scrollbar, themeOverrides: this.mergedTheme.peerOverrides.Scrollbar }), r)]), this.bodyDirectives) }) })), [[us, this.displayDirective === "if" || this.displayed || this.show]]) : null;
} }), { cubicBezierEaseIn: Z5, cubicBezierEaseOut: H5 } = Oh;
function X5({ duration: r = "0.3s", leaveDuration: n = "0.2s", name: l = "slide-in-from-bottom" } = {}) {
  return [qe(`&.${l}-transition-leave-active`, { transition: `transform ${n} ${Z5}` }), qe(`&.${l}-transition-enter-active`, { transition: `transform ${r} ${H5}` }), qe(`&.${l}-transition-enter-to`, { transform: "translateY(0)" }), qe(`&.${l}-transition-enter-from`, { transform: "translateY(100%)" }), qe(`&.${l}-transition-leave-from`, { transform: "translateY(0)" }), qe(`&.${l}-transition-leave-to`, { transform: "translateY(100%)" })];
}
const { cubicBezierEaseIn: Y5, cubicBezierEaseOut: K5 } = Oh;
function J5({ duration: r = "0.3s", leaveDuration: n = "0.2s", name: l = "slide-in-from-left" } = {}) {
  return [qe(`&.${l}-transition-leave-active`, { transition: `transform ${n} ${Y5}` }), qe(`&.${l}-transition-enter-active`, { transition: `transform ${r} ${K5}` }), qe(`&.${l}-transition-enter-to`, { transform: "translateX(0)" }), qe(`&.${l}-transition-enter-from`, { transform: "translateX(-100%)" }), qe(`&.${l}-transition-leave-from`, { transform: "translateX(0)" }), qe(`&.${l}-transition-leave-to`, { transform: "translateX(-100%)" })];
}
const { cubicBezierEaseIn: Q5, cubicBezierEaseOut: e6 } = Oh;
function t6({ duration: r = "0.3s", leaveDuration: n = "0.2s", name: l = "slide-in-from-right" } = {}) {
  return [qe(`&.${l}-transition-leave-active`, { transition: `transform ${n} ${Q5}` }), qe(`&.${l}-transition-enter-active`, { transition: `transform ${r} ${e6}` }), qe(`&.${l}-transition-enter-to`, { transform: "translateX(0)" }), qe(`&.${l}-transition-enter-from`, { transform: "translateX(100%)" }), qe(`&.${l}-transition-leave-from`, { transform: "translateX(0)" }), qe(`&.${l}-transition-leave-to`, { transform: "translateX(100%)" })];
}
const { cubicBezierEaseIn: r6, cubicBezierEaseOut: i6 } = Oh;
function n6({ duration: r = "0.3s", leaveDuration: n = "0.2s", name: l = "slide-in-from-top" } = {}) {
  return [qe(`&.${l}-transition-leave-active`, { transition: `transform ${n} ${r6}` }), qe(`&.${l}-transition-enter-active`, { transition: `transform ${r} ${i6}` }), qe(`&.${l}-transition-enter-to`, { transform: "translateY(0)" }), qe(`&.${l}-transition-enter-from`, { transform: "translateY(-100%)" }), qe(`&.${l}-transition-leave-from`, { transform: "translateY(0)" }), qe(`&.${l}-transition-leave-to`, { transform: "translateY(-100%)" })];
}
const o6 = qe([he("drawer", `
 word-break: break-word;
 line-height: var(--n-line-height);
 position: absolute;
 pointer-events: all;
 box-shadow: var(--n-box-shadow);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background-color: var(--n-color);
 color: var(--n-text-color);
 box-sizing: border-box;
 `, [t6(), J5(), n6(), X5(), Ue("unselectable", `
 user-select: none; 
 -webkit-user-select: none;
 `), Ue("native-scrollbar", [he("drawer-content-wrapper", `
 overflow: auto;
 height: 100%;
 `)]), Le("resize-trigger", `
 position: absolute;
 background-color: #0000;
 transition: background-color .3s var(--n-bezier);
 `, [Ue("hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `)]), he("drawer-content-wrapper", `
 box-sizing: border-box;
 `), he("drawer-content", `
 height: 100%;
 display: flex;
 flex-direction: column;
 `, [Ue("native-scrollbar", [he("drawer-body-content-wrapper", `
 height: 100%;
 overflow: auto;
 `)]), he("drawer-body", `
 flex: 1 0 0;
 overflow: hidden;
 `), he("drawer-body-content-wrapper", `
 box-sizing: border-box;
 padding: var(--n-body-padding);
 `), he("drawer-header", `
 font-weight: var(--n-title-font-weight);
 line-height: 1;
 font-size: var(--n-title-font-size);
 color: var(--n-title-text-color);
 padding: var(--n-header-padding);
 transition: border .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-divider-color);
 border-bottom: var(--n-header-border-bottom);
 display: flex;
 justify-content: space-between;
 align-items: center;
 `, [Le("main", `
 flex: 1;
 `), Le("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), he("drawer-footer", `
 display: flex;
 justify-content: flex-end;
 border-top: var(--n-footer-border-top);
 transition: border .3s var(--n-bezier);
 padding: var(--n-footer-padding);
 `)]), Ue("right-placement", `
 top: 0;
 bottom: 0;
 right: 0;
 border-top-left-radius: var(--n-border-radius);
 border-bottom-left-radius: var(--n-border-radius);
 `, [Le("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 left: 0;
 transform: translateX(-1.5px);
 cursor: ew-resize;
 `)]), Ue("left-placement", `
 top: 0;
 bottom: 0;
 left: 0;
 border-top-right-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [Le("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 right: 0;
 transform: translateX(1.5px);
 cursor: ew-resize;
 `)]), Ue("top-placement", `
 top: 0;
 left: 0;
 right: 0;
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [Le("resize-trigger", `
 width: 100%;
 height: 3px;
 bottom: 0;
 left: 0;
 transform: translateY(1.5px);
 cursor: ns-resize;
 `)]), Ue("bottom-placement", `
 left: 0;
 bottom: 0;
 right: 0;
 border-top-left-radius: var(--n-border-radius);
 border-top-right-radius: var(--n-border-radius);
 `, [Le("resize-trigger", `
 width: 100%;
 height: 3px;
 top: 0;
 left: 0;
 transform: translateY(-1.5px);
 cursor: ns-resize;
 `)])]), qe("body", [qe(">", [he("drawer-container", `
 position: fixed;
 `)])]), he("drawer-container", `
 position: relative;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 `, [qe("> *", `
 pointer-events: all;
 `)]), he("drawer-mask", `
 background-color: rgba(0, 0, 0, .3);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [Ue("invisible", `
 background-color: rgba(0, 0, 0, 0)
 `), Zp({ enterDuration: "0.2s", leaveDuration: "0.2s", enterCubicBezier: "var(--n-bezier-in)", leaveCubicBezier: "var(--n-bezier-out)" })])]), a6 = Object.assign(Object.assign({}, er.props), { show: Boolean, width: [Number, String], height: [Number, String], placement: { type: String, default: "right" }, maskClosable: { type: Boolean, default: true }, showMask: { type: [Boolean, String], default: true }, to: [String, Object], displayDirective: { type: String, default: "if" }, nativeScrollbar: { type: Boolean, default: true }, zIndex: Number, onMaskClick: Function, scrollbarProps: Object, contentClass: String, contentStyle: [Object, String], trapFocus: { type: Boolean, default: true }, onEsc: Function, autoFocus: { type: Boolean, default: true }, closeOnEsc: { type: Boolean, default: true }, blockScroll: { type: Boolean, default: true }, maxWidth: Number, maxHeight: Number, minWidth: Number, minHeight: Number, resizable: Boolean, defaultWidth: { type: [Number, String], default: 251 }, defaultHeight: { type: [Number, String], default: 251 }, onUpdateWidth: [Function, Array], onUpdateHeight: [Function, Array], "onUpdate:width": [Function, Array], "onUpdate:height": [Function, Array], "onUpdate:show": [Function, Array], onUpdateShow: [Function, Array], onAfterEnter: Function, onAfterLeave: Function, drawerStyle: [String, Object], drawerClass: String, target: null, onShow: Function, onHide: Function }), dx = nt({ name: "Drawer", inheritAttrs: false, props: a6, setup(r) {
  const { mergedClsPrefixRef: n, namespaceRef: l, inlineThemeDisabled: h } = Cr(r), f = cm(), y = er("Drawer", "-drawer", o6, U3, r, n), p = Ee(r.defaultWidth), s = Ee(r.defaultHeight), S = Qi(zt(r, "width"), p), P = Qi(zt(r, "height"), s), M = Ae(() => {
    const { placement: ee } = r;
    return ee === "top" || ee === "bottom" ? "" : ca(S.value);
  }), A = Ae(() => {
    const { placement: ee } = r;
    return ee === "left" || ee === "right" ? "" : ca(P.value);
  }), O = (ee) => {
    const { onUpdateWidth: ke, "onUpdate:width": ve } = r;
    ke && jt(ke, ee), ve && jt(ve, ee), p.value = ee;
  }, j = (ee) => {
    const { onUpdateHeight: ke, "onUpdate:width": ve } = r;
    ke && jt(ke, ee), ve && jt(ve, ee), s.value = ee;
  }, L = Ae(() => [{ width: M.value, height: A.value }, r.drawerStyle || ""]);
  function q(ee) {
    const { onMaskClick: ke, maskClosable: ve } = r;
    ve && ne(false), ke && ke(ee);
  }
  function N(ee) {
    q(ee);
  }
  const J = G3();
  function te(ee) {
    var ke;
    (ke = r.onEsc) === null || ke === void 0 || ke.call(r), r.show && r.closeOnEsc && q3(ee) && (J.value || ne(false));
  }
  function ne(ee) {
    const { onHide: ke, onUpdateShow: ve, "onUpdate:show": le } = r;
    ve && jt(ve, ee), le && jt(le, ee), ke && !ee && jt(ke, ee);
  }
  Vr(tv, { isMountedRef: f, mergedThemeRef: y, mergedClsPrefixRef: n, doUpdateShow: ne, doUpdateHeight: j, doUpdateWidth: O });
  const ae = Ae(() => {
    const { common: { cubicBezierEaseInOut: ee, cubicBezierEaseIn: ke, cubicBezierEaseOut: ve }, self: { color: le, textColor: ue, boxShadow: be, lineHeight: Ve, headerPadding: Ge, footerPadding: et, borderRadius: dt, bodyPadding: Ct, titleFontSize: kt, titleTextColor: ct, titleFontWeight: it, headerBorderBottom: pt, footerBorderTop: $t, closeIconColor: vt, closeIconColorHover: Pt, closeIconColorPressed: Nt, closeColorHover: ir, closeColorPressed: bt, closeIconSize: Dt, closeSize: Zt, closeBorderRadius: dr, resizableTriggerColorHover: yr } } = y.value;
    return { "--n-line-height": Ve, "--n-color": le, "--n-border-radius": dt, "--n-text-color": ue, "--n-box-shadow": be, "--n-bezier": ee, "--n-bezier-out": ve, "--n-bezier-in": ke, "--n-header-padding": Ge, "--n-body-padding": Ct, "--n-footer-padding": et, "--n-title-text-color": ct, "--n-title-font-size": kt, "--n-title-font-weight": it, "--n-header-border-bottom": pt, "--n-footer-border-top": $t, "--n-close-icon-color": vt, "--n-close-icon-color-hover": Pt, "--n-close-icon-color-pressed": Nt, "--n-close-size": Zt, "--n-close-color-hover": ir, "--n-close-color-pressed": bt, "--n-close-icon-size": Dt, "--n-close-border-radius": dr, "--n-resize-trigger-color-hover": yr };
  }), oe = h ? ai("drawer", void 0, ae, r) : void 0;
  return { mergedClsPrefix: n, namespace: l, mergedBodyStyle: L, handleOutsideClick: N, handleMaskClick: q, handleEsc: te, mergedTheme: y, cssVars: h ? void 0 : ae, themeClass: oe == null ? void 0 : oe.themeClass, onRender: oe == null ? void 0 : oe.onRender, isMounted: f };
}, render() {
  const { mergedClsPrefix: r } = this;
  return B(g1, { to: this.to, show: this.show }, { default: () => {
    var n;
    return (n = this.onRender) === null || n === void 0 || n.call(this), za(B("div", { class: [`${r}-drawer-container`, this.namespace, this.themeClass], style: this.cssVars, role: "none" }, this.showMask ? B(Wo, { name: "fade-in-transition", appear: this.isMounted }, { default: () => this.show ? B("div", { "aria-hidden": true, class: [`${r}-drawer-mask`, this.showMask === "transparent" && `${r}-drawer-mask--invisible`], onClick: this.handleMaskClick }) : null }) : null, B(W5, Object.assign({}, this.$attrs, { class: [this.drawerClass, this.$attrs.class], style: [this.mergedBodyStyle, this.$attrs.style], blockScroll: this.blockScroll, contentStyle: this.contentStyle, contentClass: this.contentClass, placement: this.placement, scrollbarProps: this.scrollbarProps, show: this.show, displayDirective: this.displayDirective, nativeScrollbar: this.nativeScrollbar, onAfterEnter: this.onAfterEnter, onAfterLeave: this.onAfterLeave, trapFocus: this.trapFocus, autoFocus: this.autoFocus, resizable: this.resizable, maxHeight: this.maxHeight, minHeight: this.minHeight, maxWidth: this.maxWidth, minWidth: this.minWidth, showMask: this.showMask, onEsc: this.handleEsc, onClickoutside: this.handleOutsideClick }), this.$slots)), [[m1, { zIndex: this.zIndex, enabled: this.show }]]);
  } });
} }), s6 = { title: String, headerClass: String, headerStyle: [Object, String], footerClass: String, footerStyle: [Object, String], bodyClass: String, bodyStyle: [Object, String], bodyContentClass: String, bodyContentStyle: [Object, String], nativeScrollbar: { type: Boolean, default: true }, scrollbarProps: Object, closable: Boolean }, hx = nt({ name: "DrawerContent", props: s6, slots: Object, setup() {
  const r = cr(tv, null);
  r || fa("drawer-content", "`n-drawer-content` must be placed inside `n-drawer`.");
  const { doUpdateShow: n } = r;
  function l() {
    n(false);
  }
  return { handleCloseClick: l, mergedTheme: r.mergedThemeRef, mergedClsPrefix: r.mergedClsPrefixRef };
}, render() {
  const { title: r, mergedClsPrefix: n, nativeScrollbar: l, mergedTheme: h, bodyClass: f, bodyStyle: y, bodyContentClass: p, bodyContentStyle: s, headerClass: S, headerStyle: P, footerClass: M, footerStyle: A, scrollbarProps: O, closable: j, $slots: L } = this;
  return B("div", { role: "none", class: [`${n}-drawer-content`, l && `${n}-drawer-content--native-scrollbar`] }, L.header || r || j ? B("div", { class: [`${n}-drawer-header`, S], style: P, role: "none" }, B("div", { class: `${n}-drawer-header__main`, role: "heading", "aria-level": "1" }, L.header !== void 0 ? L.header() : r), j && B(am, { onClick: this.handleCloseClick, clsPrefix: n, class: `${n}-drawer-header__close`, absolute: true })) : null, l ? B("div", { class: [`${n}-drawer-body`, f], style: y, role: "none" }, B("div", { class: [`${n}-drawer-body-content-wrapper`, p], style: s, role: "none" }, L)) : B(Bh, Object.assign({ themeOverrides: h.peerOverrides.Scrollbar, theme: h.peers.Scrollbar }, O, { class: `${n}-drawer-body`, contentClass: [`${n}-drawer-body-content-wrapper`, p], contentStyle: s }), L), L.footer ? B("div", { class: [`${n}-drawer-footer`, M], style: A, role: "none" }, L.footer()) : null);
} });
let Jg;
function l6() {
  if (!um) return true;
  if (Jg === void 0) {
    const r = document.createElement("div");
    r.style.display = "flex", r.style.flexDirection = "column", r.style.rowGap = "1px", r.appendChild(document.createElement("div")), r.appendChild(document.createElement("div")), document.body.appendChild(r);
    const n = r.scrollHeight === 1;
    return document.body.removeChild(r), Jg = n;
  }
  return Jg;
}
const u6 = Object.assign(Object.assign({}, er.props), { align: String, justify: { type: String, default: "start" }, inline: Boolean, vertical: Boolean, reverse: Boolean, size: { type: [String, Number, Array], default: "medium" }, wrapItem: { type: Boolean, default: true }, itemClass: String, itemStyle: [String, Object], wrap: { type: Boolean, default: true }, internalUseGap: { type: Boolean, default: void 0 } }), Os = nt({ name: "Space", props: u6, setup(r) {
  const { mergedClsPrefixRef: n, mergedRtlRef: l } = Cr(r), h = er("Space", "-space", void 0, W3, r, n), f = Ln("Space", l, n);
  return { useGap: l6(), rtlEnabled: f, mergedClsPrefix: n, margin: Ae(() => {
    const { size: y } = r;
    if (Array.isArray(y)) return { horizontal: y[0], vertical: y[1] };
    if (typeof y == "number") return { horizontal: y, vertical: y };
    const { self: { [Ut("gap", y)]: p } } = h.value, { row: s, col: S } = v1(p);
    return { horizontal: ln(S), vertical: ln(s) };
  }) };
}, render() {
  const { vertical: r, reverse: n, align: l, inline: h, justify: f, itemClass: y, itemStyle: p, margin: s, wrap: S, mergedClsPrefix: P, rtlEnabled: M, useGap: A, wrapItem: O, internalUseGap: j } = this, L = Xl(hm(this), false);
  if (!L.length) return null;
  const q = `${s.horizontal}px`, N = `${s.horizontal / 2}px`, J = `${s.vertical}px`, te = `${s.vertical / 2}px`, ne = L.length - 1, ae = f.startsWith("space-");
  return B("div", { role: "none", class: [`${P}-space`, M && `${P}-space--rtl`], style: { display: h ? "inline-flex" : "flex", flexDirection: r && !n ? "column" : r && n ? "column-reverse" : !r && n ? "row-reverse" : "row", justifyContent: ["start", "end"].includes(f) ? `flex-${f}` : f, flexWrap: !S || r ? "nowrap" : "wrap", marginTop: A || r ? "" : `-${te}`, marginBottom: A || r ? "" : `-${te}`, alignItems: l, gap: A ? `${s.vertical}px ${s.horizontal}px` : "" } }, !O && (A || j) ? L : L.map((oe, ee) => oe.type === JC ? oe : B("div", { role: "none", class: y, style: [p, { maxWidth: "100%" }, A ? "" : r ? { marginBottom: ee !== ne ? J : "" } : M ? { marginLeft: ae ? f === "space-between" && ee === ne ? "" : N : ee !== ne ? q : "", marginRight: ae ? f === "space-between" && ee === 0 ? "" : N : "", paddingTop: te, paddingBottom: te } : { marginRight: ae ? f === "space-between" && ee === ne ? "" : N : ee !== ne ? q : "", marginLeft: ae ? f === "space-between" && ee === 0 ? "" : N : "", paddingTop: te, paddingBottom: te }] }, oe)));
} }), c6 = he("dynamic-tags", [he("input", { minWidth: "var(--n-input-width)" })]), d6 = Object.assign(Object.assign(Object.assign({}, er.props), K1), { size: { type: String, default: "medium" }, closable: { type: Boolean, default: true }, defaultValue: { type: Array, default: () => [] }, value: Array, inputClass: String, inputStyle: [String, Object], inputProps: Object, max: Number, tagClass: String, tagStyle: [String, Object], renderTag: Function, onCreate: { type: Function, default: (r) => r }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onChange: [Function, Array] }), h6 = nt({ name: "DynamicTags", props: d6, slots: Object, setup(r) {
  const { mergedClsPrefixRef: n, inlineThemeDisabled: l } = Cr(r), { localeRef: h } = ds("DynamicTags"), f = Ba(r), { mergedDisabledRef: y } = f, p = Ee(""), s = Ee(false), S = Ee(true), P = Ee(null), M = er("DynamicTags", "-dynamic-tags", c6, Z3, r, n), A = Ee(r.defaultValue), O = zt(r, "value"), j = Qi(O, A), L = Ae(() => h.value.add), q = Ae(() => dT(r.size)), N = Ae(() => y.value || !!r.max && j.value.length >= r.max);
  function J(le) {
    const { onChange: ue, "onUpdate:value": be, onUpdateValue: Ve } = r, { nTriggerFormInput: Ge, nTriggerFormChange: et } = f;
    ue && jt(ue, le), Ve && jt(Ve, le), be && jt(be, le), A.value = le, Ge(), et();
  }
  function te(le) {
    const ue = j.value.slice(0);
    ue.splice(le, 1), J(ue);
  }
  function ne(le) {
    switch (le.key) {
      case "Enter":
        ae();
    }
  }
  function ae(le) {
    const ue = le ?? p.value;
    if (ue) {
      const be = j.value.slice(0);
      be.push(r.onCreate(ue)), J(be);
    }
    s.value = false, S.value = true, p.value = "";
  }
  function oe() {
    ae();
  }
  function ee() {
    s.value = true, eo(() => {
      var le;
      (le = P.value) === null || le === void 0 || le.focus(), S.value = false;
    });
  }
  const ke = Ae(() => {
    const { self: { inputWidth: le } } = M.value;
    return { "--n-input-width": le };
  }), ve = l ? ai("dynamic-tags", void 0, ke, r) : void 0;
  return { mergedClsPrefix: n, inputInstRef: P, localizedAdd: L, inputSize: q, inputValue: p, showInput: s, inputForceFocused: S, mergedValue: j, mergedDisabled: y, triggerDisabled: N, handleInputKeyDown: ne, handleAddClick: ee, handleInputBlur: oe, handleCloseClick: te, handleInputConfirm: ae, mergedTheme: M, cssVars: l ? void 0 : ke, themeClass: ve == null ? void 0 : ve.themeClass, onRender: ve == null ? void 0 : ve.onRender };
}, render() {
  const { mergedTheme: r, cssVars: n, mergedClsPrefix: l, onRender: h, renderTag: f } = this;
  return h == null ? void 0 : h(), B(Os, { class: [`${l}-dynamic-tags`, this.themeClass], size: "small", style: n, theme: r.peers.Space, themeOverrides: r.peerOverrides.Space, itemStyle: "display: flex;" }, { default: () => {
    const { mergedTheme: y, tagClass: p, tagStyle: s, type: S, round: P, size: M, color: A, closable: O, mergedDisabled: j, showInput: L, inputValue: q, inputClass: N, inputStyle: J, inputSize: te, inputForceFocused: ne, triggerDisabled: ae, handleInputKeyDown: oe, handleInputBlur: ee, handleAddClick: ke, handleCloseClick: ve, handleInputConfirm: le, $slots: ue } = this;
    return this.mergedValue.map((be, Ve) => f ? f(be, Ve) : B(zo, { key: Ve, theme: y.peers.Tag, themeOverrides: y.peerOverrides.Tag, class: p, style: s, type: S, round: P, size: M, color: A, closable: O, disabled: j, onClose: () => {
      ve(Ve);
    } }, { default: () => typeof be == "string" ? be : be.label })).concat(L ? ue.input ? ue.input({ submit: le, deactivate: ee }) : B(Do, Object.assign({ placeholder: "", size: te, style: J, class: N, autosize: true }, this.inputProps, { ref: "inputInstRef", value: q, onUpdateValue: (be) => {
      this.inputValue = be;
    }, theme: y.peers.Input, themeOverrides: y.peerOverrides.Input, onKeydown: oe, onBlur: ee, internalForceFocus: ne })) : ue.trigger ? ue.trigger({ activate: ke, disabled: ae }) : B(Or, { dashed: true, disabled: ae, theme: y.peers.Button, themeOverrides: y.peerOverrides.Button, size: te, onClick: ke }, { icon: () => B(Nr, { clsPrefix: l }, { default: () => B(fm, null) }) }));
  } });
} }), f6 = Object.assign(Object.assign({}, er.props), { align: String, justify: { type: String, default: "start" }, inline: Boolean, vertical: Boolean, reverse: Boolean, size: { type: [String, Number, Array], default: "medium" }, wrap: { type: Boolean, default: true } }), G_ = nt({ name: "Flex", props: f6, setup(r) {
  const { mergedClsPrefixRef: n, mergedRtlRef: l } = Cr(r), h = er("Flex", "-flex", void 0, H3, r, n);
  return { rtlEnabled: Ln("Flex", l, n), mergedClsPrefix: n, margin: Ae(() => {
    const { size: y } = r;
    if (Array.isArray(y)) return { horizontal: y[0], vertical: y[1] };
    if (typeof y == "number") return { horizontal: y, vertical: y };
    const { self: { [Ut("gap", y)]: p } } = h.value, { row: s, col: S } = v1(p);
    return { horizontal: ln(S), vertical: ln(s) };
  }) };
}, render() {
  const { vertical: r, reverse: n, align: l, inline: h, justify: f, margin: y, wrap: p, mergedClsPrefix: s, rtlEnabled: S } = this, P = Xl(hm(this), false);
  return P.length ? B("div", { role: "none", class: [`${s}-flex`, S && `${s}-flex--rtl`], style: { display: h ? "inline-flex" : "flex", flexDirection: r && !n ? "column" : r && n ? "column-reverse" : !r && n ? "row-reverse" : "row", justifyContent: f, flexWrap: !p || r ? "nowrap" : "wrap", alignItems: l, gap: `${y.vertical}px ${y.horizontal}px` } }, P) : null;
} }), $h = qn("n-form"), fx = qn("n-form-item-insts"), p6 = he("form", [Ue("inline", `
 width: 100%;
 display: inline-flex;
 align-items: flex-start;
 align-content: space-around;
 `, [he("form-item", { width: "auto", marginRight: "18px" }, [qe("&:last-child", { marginRight: 0 })])])]);
var m6 = function(r, n, l, h) {
  function f(y) {
    return y instanceof l ? y : new l(function(p) {
      p(y);
    });
  }
  return new (l || (l = Promise))(function(y, p) {
    function s(M) {
      try {
        P(h.next(M));
      } catch (A) {
        p(A);
      }
    }
    function S(M) {
      try {
        P(h.throw(M));
      } catch (A) {
        p(A);
      }
    }
    function P(M) {
      M.done ? y(M.value) : f(M.value).then(s, S);
    }
    P((h = h.apply(r, n || [])).next());
  });
};
const g6 = Object.assign(Object.assign({}, er.props), { inline: Boolean, labelWidth: [Number, String], labelAlign: String, labelPlacement: { type: String, default: "top" }, model: { type: Object, default: () => {
} }, rules: Object, disabled: Boolean, size: String, showRequireMark: { type: Boolean, default: void 0 }, requireMarkPlacement: String, showFeedback: { type: Boolean, default: true }, onSubmit: { type: Function, default: (r) => {
  r.preventDefault();
} }, showLabel: { type: Boolean, default: void 0 }, validateMessages: Object }), Eh = nt({ name: "Form", props: g6, setup(r) {
  const { mergedClsPrefixRef: n } = Cr(r);
  er("Form", "-form", p6, y1, r, n);
  const l = {}, h = Ee(void 0), f = (S) => {
    const P = h.value;
    (P === void 0 || S >= P) && (h.value = S);
  };
  function y(S) {
    return m6(this, arguments, void 0, function* (P, M = () => true) {
      return yield new Promise((A, O) => {
        const j = [];
        for (const L of Ch(l)) {
          const q = l[L];
          for (const N of q) N.path && j.push(N.internalValidate(null, M));
        }
        Promise.all(j).then((L) => {
          const q = L.some((te) => !te.valid), N = [], J = [];
          L.forEach((te) => {
            var ne, ae;
            !((ne = te.errors) === null || ne === void 0) && ne.length && N.push(te.errors), !((ae = te.warnings) === null || ae === void 0) && ae.length && J.push(te.warnings);
          }), P && P(N.length ? N : void 0, { warnings: J.length ? J : void 0 }), q ? O(N.length ? N : void 0) : A({ warnings: J.length ? J : void 0 });
        });
      });
    });
  }
  function p() {
    for (const S of Ch(l)) {
      const P = l[S];
      for (const M of P) M.restoreValidation();
    }
  }
  return Vr($h, { props: r, maxChildLabelWidthRef: h, deriveMaxChildLabelWidth: f }), Vr(fx, { formItems: l }), Object.assign({ validate: y, restoreValidation: p }, { mergedClsPrefix: n });
}, render() {
  const { mergedClsPrefix: r } = this;
  return B("form", { class: [`${r}-form`, this.inline && `${r}-form--inline`], onSubmit: this.onSubmit }, this.$slots);
} });
function Gl() {
  return Gl = Object.assign ? Object.assign.bind() : function(r) {
    for (var n = 1; n < arguments.length; n++) {
      var l = arguments[n];
      for (var h in l) Object.prototype.hasOwnProperty.call(l, h) && (r[h] = l[h]);
    }
    return r;
  }, Gl.apply(this, arguments);
}
function v6(r, n) {
  r.prototype = Object.create(n.prototype), r.prototype.constructor = r, Mh(r, n);
}
function A0(r) {
  return A0 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
    return l.__proto__ || Object.getPrototypeOf(l);
  }, A0(r);
}
function Mh(r, n) {
  return Mh = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(h, f) {
    return h.__proto__ = f, h;
  }, Mh(r, n);
}
function y6() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return false;
  if (typeof Proxy == "function") return true;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), true;
  } catch {
    return false;
  }
}
function $p(r, n, l) {
  return y6() ? $p = Reflect.construct.bind() : $p = function(f, y, p) {
    var s = [null];
    s.push.apply(s, y);
    var S = Function.bind.apply(f, s), P = new S();
    return p && Mh(P, p.prototype), P;
  }, $p.apply(null, arguments);
}
function _6(r) {
  return Function.toString.call(r).indexOf("[native code]") !== -1;
}
function z0(r) {
  var n = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return z0 = function(h) {
    if (h === null || !_6(h)) return h;
    if (typeof h != "function") throw new TypeError("Super expression must either be null or a function");
    if (typeof n < "u") {
      if (n.has(h)) return n.get(h);
      n.set(h, f);
    }
    function f() {
      return $p(h, arguments, A0(this).constructor);
    }
    return f.prototype = Object.create(h.prototype, { constructor: { value: f, enumerable: false, writable: true, configurable: true } }), Mh(f, h);
  }, z0(r);
}
var b6 = /%[sdj%]/g, x6 = function() {
};
function F0(r) {
  if (!r || !r.length) return null;
  var n = {};
  return r.forEach(function(l) {
    var h = l.field;
    n[h] = n[h] || [], n[h].push(l);
  }), n;
}
function Ro(r) {
  for (var n = arguments.length, l = new Array(n > 1 ? n - 1 : 0), h = 1; h < n; h++) l[h - 1] = arguments[h];
  var f = 0, y = l.length;
  if (typeof r == "function") return r.apply(null, l);
  if (typeof r == "string") {
    var p = r.replace(b6, function(s) {
      if (s === "%%") return "%";
      if (f >= y) return s;
      switch (s) {
        case "%s":
          return String(l[f++]);
        case "%d":
          return Number(l[f++]);
        case "%j":
          try {
            return JSON.stringify(l[f++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return s;
      }
    });
    return p;
  }
  return r;
}
function w6(r) {
  return r === "string" || r === "url" || r === "hex" || r === "email" || r === "date" || r === "pattern";
}
function cn(r, n) {
  return !!(r == null || n === "array" && Array.isArray(r) && !r.length || w6(n) && typeof r == "string" && !r);
}
function C6(r, n, l) {
  var h = [], f = 0, y = r.length;
  function p(s) {
    h.push.apply(h, s || []), f++, f === y && l(h);
  }
  r.forEach(function(s) {
    n(s, p);
  });
}
function q_(r, n, l) {
  var h = 0, f = r.length;
  function y(p) {
    if (p && p.length) {
      l(p);
      return;
    }
    var s = h;
    h = h + 1, s < f ? n(r[s], y) : l([]);
  }
  y([]);
}
function S6(r) {
  var n = [];
  return Object.keys(r).forEach(function(l) {
    n.push.apply(n, r[l] || []);
  }), n;
}
var W_ = (function(r) {
  v6(n, r);
  function n(l, h) {
    var f;
    return f = r.call(this, "Async Validation Error") || this, f.errors = l, f.fields = h, f;
  }
  return n;
})(z0(Error));
function k6(r, n, l, h, f) {
  if (n.first) {
    var y = new Promise(function(O, j) {
      var L = function(J) {
        return h(J), J.length ? j(new W_(J, F0(J))) : O(f);
      }, q = S6(r);
      q_(q, l, L);
    });
    return y.catch(function(O) {
      return O;
    }), y;
  }
  var p = n.firstFields === true ? Object.keys(r) : n.firstFields || [], s = Object.keys(r), S = s.length, P = 0, M = [], A = new Promise(function(O, j) {
    var L = function(N) {
      if (M.push.apply(M, N), P++, P === S) return h(M), M.length ? j(new W_(M, F0(M))) : O(f);
    };
    s.length || (h(M), O(f)), s.forEach(function(q) {
      var N = r[q];
      p.indexOf(q) !== -1 ? q_(N, l, L) : C6(N, l, L);
    });
  });
  return A.catch(function(O) {
    return O;
  }), A;
}
function T6(r) {
  return !!(r && r.message !== void 0);
}
function P6(r, n) {
  for (var l = r, h = 0; h < n.length; h++) {
    if (l == null) return l;
    l = l[n[h]];
  }
  return l;
}
function Z_(r, n) {
  return function(l) {
    var h;
    return r.fullFields ? h = P6(n, r.fullFields) : h = n[l.field || r.fullField], T6(l) ? (l.field = l.field || r.fullField, l.fieldValue = h, l) : { message: typeof l == "function" ? l() : l, fieldValue: h, field: l.field || r.fullField };
  };
}
function H_(r, n) {
  if (n) {
    for (var l in n) if (n.hasOwnProperty(l)) {
      var h = n[l];
      typeof h == "object" && typeof r[l] == "object" ? r[l] = Gl({}, r[l], h) : r[l] = h;
    }
  }
  return r;
}
var px = function(n, l, h, f, y, p) {
  n.required && (!h.hasOwnProperty(n.field) || cn(l, p || n.type)) && f.push(Ro(y.messages.required, n.fullField));
}, I6 = function(n, l, h, f, y) {
  (/^\s+$/.test(l) || l === "") && f.push(Ro(y.messages.whitespace, n.fullField));
}, Sp, E6 = (function() {
  if (Sp) return Sp;
  var r = "[a-fA-F\\d:]", n = function(ae) {
    return ae && ae.includeBoundaries ? "(?:(?<=\\s|^)(?=" + r + ")|(?<=" + r + ")(?=\\s|$))" : "";
  }, l = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", h = "[a-fA-F\\d]{1,4}", f = (`
(?:
(?:` + h + ":){7}(?:" + h + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + h + ":){6}(?:" + l + "|:" + h + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + h + ":){5}(?::" + l + "|(?::" + h + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + h + ":){4}(?:(?::" + h + "){0,1}:" + l + "|(?::" + h + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + h + ":){3}(?:(?::" + h + "){0,2}:" + l + "|(?::" + h + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + h + ":){2}(?:(?::" + h + "){0,3}:" + l + "|(?::" + h + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + h + ":){1}(?:(?::" + h + "){0,4}:" + l + "|(?::" + h + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + h + "){0,5}:" + l + "|(?::" + h + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), y = new RegExp("(?:^" + l + "$)|(?:^" + f + "$)"), p = new RegExp("^" + l + "$"), s = new RegExp("^" + f + "$"), S = function(ae) {
    return ae && ae.exact ? y : new RegExp("(?:" + n(ae) + l + n(ae) + ")|(?:" + n(ae) + f + n(ae) + ")", "g");
  };
  S.v4 = function(ne) {
    return ne && ne.exact ? p : new RegExp("" + n(ne) + l + n(ne), "g");
  }, S.v6 = function(ne) {
    return ne && ne.exact ? s : new RegExp("" + n(ne) + f + n(ne), "g");
  };
  var P = "(?:(?:[a-z]+:)?//)", M = "(?:\\S+(?::\\S*)?@)?", A = S.v4().source, O = S.v6().source, j = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", L = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", q = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", N = "(?::\\d{2,5})?", J = '(?:[/?#][^\\s"]*)?', te = "(?:" + P + "|www\\.)" + M + "(?:localhost|" + A + "|" + O + "|" + j + L + q + ")" + N + J;
  return Sp = new RegExp("(?:^" + te + "$)", "i"), Sp;
}), X_ = { email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/, hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i }, fh = { integer: function(n) {
  return fh.number(n) && parseInt(n, 10) === n;
}, float: function(n) {
  return fh.number(n) && !fh.integer(n);
}, array: function(n) {
  return Array.isArray(n);
}, regexp: function(n) {
  if (n instanceof RegExp) return true;
  try {
    return !!new RegExp(n);
  } catch {
    return false;
  }
}, date: function(n) {
  return typeof n.getTime == "function" && typeof n.getMonth == "function" && typeof n.getYear == "function" && !isNaN(n.getTime());
}, number: function(n) {
  return isNaN(n) ? false : typeof n == "number";
}, object: function(n) {
  return typeof n == "object" && !fh.array(n);
}, method: function(n) {
  return typeof n == "function";
}, email: function(n) {
  return typeof n == "string" && n.length <= 320 && !!n.match(X_.email);
}, url: function(n) {
  return typeof n == "string" && n.length <= 2048 && !!n.match(E6());
}, hex: function(n) {
  return typeof n == "string" && !!n.match(X_.hex);
} }, M6 = function(n, l, h, f, y) {
  if (n.required && l === void 0) {
    px(n, l, h, f, y);
    return;
  }
  var p = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], s = n.type;
  p.indexOf(s) > -1 ? fh[s](l) || f.push(Ro(y.messages.types[s], n.fullField, n.type)) : s && typeof l !== n.type && f.push(Ro(y.messages.types[s], n.fullField, n.type));
}, D6 = function(n, l, h, f, y) {
  var p = typeof n.len == "number", s = typeof n.min == "number", S = typeof n.max == "number", P = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, M = l, A = null, O = typeof l == "number", j = typeof l == "string", L = Array.isArray(l);
  if (O ? A = "number" : j ? A = "string" : L && (A = "array"), !A) return false;
  L && (M = l.length), j && (M = l.replace(P, "_").length), p ? M !== n.len && f.push(Ro(y.messages[A].len, n.fullField, n.len)) : s && !S && M < n.min ? f.push(Ro(y.messages[A].min, n.fullField, n.min)) : S && !s && M > n.max ? f.push(Ro(y.messages[A].max, n.fullField, n.max)) : s && S && (M < n.min || M > n.max) && f.push(Ro(y.messages[A].range, n.fullField, n.min, n.max));
}, Cc = "enum", R6 = function(n, l, h, f, y) {
  n[Cc] = Array.isArray(n[Cc]) ? n[Cc] : [], n[Cc].indexOf(l) === -1 && f.push(Ro(y.messages[Cc], n.fullField, n[Cc].join(", ")));
}, A6 = function(n, l, h, f, y) {
  if (n.pattern) {
    if (n.pattern instanceof RegExp) n.pattern.lastIndex = 0, n.pattern.test(l) || f.push(Ro(y.messages.pattern.mismatch, n.fullField, l, n.pattern));
    else if (typeof n.pattern == "string") {
      var p = new RegExp(n.pattern);
      p.test(l) || f.push(Ro(y.messages.pattern.mismatch, n.fullField, l, n.pattern));
    }
  }
}, Fr = { required: px, whitespace: I6, type: M6, range: D6, enum: R6, pattern: A6 }, z6 = function(n, l, h, f, y) {
  var p = [], s = n.required || !n.required && f.hasOwnProperty(n.field);
  if (s) {
    if (cn(l, "string") && !n.required) return h();
    Fr.required(n, l, f, p, y, "string"), cn(l, "string") || (Fr.type(n, l, f, p, y), Fr.range(n, l, f, p, y), Fr.pattern(n, l, f, p, y), n.whitespace === true && Fr.whitespace(n, l, f, p, y));
  }
  h(p);
}, F6 = function(n, l, h, f, y) {
  var p = [], s = n.required || !n.required && f.hasOwnProperty(n.field);
  if (s) {
    if (cn(l) && !n.required) return h();
    Fr.required(n, l, f, p, y), l !== void 0 && Fr.type(n, l, f, p, y);
  }
  h(p);
}, L6 = function(n, l, h, f, y) {
  var p = [], s = n.required || !n.required && f.hasOwnProperty(n.field);
  if (s) {
    if (l === "" && (l = void 0), cn(l) && !n.required) return h();
    Fr.required(n, l, f, p, y), l !== void 0 && (Fr.type(n, l, f, p, y), Fr.range(n, l, f, p, y));
  }
  h(p);
}, B6 = function(n, l, h, f, y) {
  var p = [], s = n.required || !n.required && f.hasOwnProperty(n.field);
  if (s) {
    if (cn(l) && !n.required) return h();
    Fr.required(n, l, f, p, y), l !== void 0 && Fr.type(n, l, f, p, y);
  }
  h(p);
}, O6 = function(n, l, h, f, y) {
  var p = [], s = n.required || !n.required && f.hasOwnProperty(n.field);
  if (s) {
    if (cn(l) && !n.required) return h();
    Fr.required(n, l, f, p, y), cn(l) || Fr.type(n, l, f, p, y);
  }
  h(p);
}, $6 = function(n, l, h, f, y) {
  var p = [], s = n.required || !n.required && f.hasOwnProperty(n.field);
  if (s) {
    if (cn(l) && !n.required) return h();
    Fr.required(n, l, f, p, y), l !== void 0 && (Fr.type(n, l, f, p, y), Fr.range(n, l, f, p, y));
  }
  h(p);
}, N6 = function(n, l, h, f, y) {
  var p = [], s = n.required || !n.required && f.hasOwnProperty(n.field);
  if (s) {
    if (cn(l) && !n.required) return h();
    Fr.required(n, l, f, p, y), l !== void 0 && (Fr.type(n, l, f, p, y), Fr.range(n, l, f, p, y));
  }
  h(p);
}, j6 = function(n, l, h, f, y) {
  var p = [], s = n.required || !n.required && f.hasOwnProperty(n.field);
  if (s) {
    if (l == null && !n.required) return h();
    Fr.required(n, l, f, p, y, "array"), l != null && (Fr.type(n, l, f, p, y), Fr.range(n, l, f, p, y));
  }
  h(p);
}, V6 = function(n, l, h, f, y) {
  var p = [], s = n.required || !n.required && f.hasOwnProperty(n.field);
  if (s) {
    if (cn(l) && !n.required) return h();
    Fr.required(n, l, f, p, y), l !== void 0 && Fr.type(n, l, f, p, y);
  }
  h(p);
}, U6 = "enum", G6 = function(n, l, h, f, y) {
  var p = [], s = n.required || !n.required && f.hasOwnProperty(n.field);
  if (s) {
    if (cn(l) && !n.required) return h();
    Fr.required(n, l, f, p, y), l !== void 0 && Fr[U6](n, l, f, p, y);
  }
  h(p);
}, q6 = function(n, l, h, f, y) {
  var p = [], s = n.required || !n.required && f.hasOwnProperty(n.field);
  if (s) {
    if (cn(l, "string") && !n.required) return h();
    Fr.required(n, l, f, p, y), cn(l, "string") || Fr.pattern(n, l, f, p, y);
  }
  h(p);
}, W6 = function(n, l, h, f, y) {
  var p = [], s = n.required || !n.required && f.hasOwnProperty(n.field);
  if (s) {
    if (cn(l, "date") && !n.required) return h();
    if (Fr.required(n, l, f, p, y), !cn(l, "date")) {
      var S;
      l instanceof Date ? S = l : S = new Date(l), Fr.type(n, S, f, p, y), S && Fr.range(n, S.getTime(), f, p, y);
    }
  }
  h(p);
}, Z6 = function(n, l, h, f, y) {
  var p = [], s = Array.isArray(l) ? "array" : typeof l;
  Fr.required(n, l, f, p, y, s), h(p);
}, Qg = function(n, l, h, f, y) {
  var p = n.type, s = [], S = n.required || !n.required && f.hasOwnProperty(n.field);
  if (S) {
    if (cn(l, p) && !n.required) return h();
    Fr.required(n, l, f, s, y, p), cn(l, p) || Fr.type(n, l, f, s, y);
  }
  h(s);
}, H6 = function(n, l, h, f, y) {
  var p = [], s = n.required || !n.required && f.hasOwnProperty(n.field);
  if (s) {
    if (cn(l) && !n.required) return h();
    Fr.required(n, l, f, p, y);
  }
  h(p);
}, bh = { string: z6, method: F6, number: L6, boolean: B6, regexp: O6, integer: $6, float: N6, array: j6, object: V6, enum: G6, pattern: q6, date: W6, url: Qg, hex: Qg, email: Qg, required: Z6, any: H6 };
function L0() {
  return { default: "Validation error on field %s", required: "%s is required", enum: "%s must be one of %s", whitespace: "%s cannot be empty", date: { format: "%s date %s is invalid for format %s", parse: "%s date could not be parsed, %s is invalid ", invalid: "%s date %s is invalid" }, types: { string: "%s is not a %s", method: "%s is not a %s (function)", array: "%s is not an %s", object: "%s is not an %s", number: "%s is not a %s", date: "%s is not a %s", boolean: "%s is not a %s", integer: "%s is not an %s", float: "%s is not a %s", regexp: "%s is not a valid %s", email: "%s is not a valid %s", url: "%s is not a valid %s", hex: "%s is not a valid %s" }, string: { len: "%s must be exactly %s characters", min: "%s must be at least %s characters", max: "%s cannot be longer than %s characters", range: "%s must be between %s and %s characters" }, number: { len: "%s must equal %s", min: "%s cannot be less than %s", max: "%s cannot be greater than %s", range: "%s must be between %s and %s" }, array: { len: "%s must be exactly %s in length", min: "%s cannot be less than %s in length", max: "%s cannot be greater than %s in length", range: "%s must be between %s and %s in length" }, pattern: { mismatch: "%s value %s does not match pattern %s" }, clone: function() {
    var n = JSON.parse(JSON.stringify(this));
    return n.clone = this.clone, n;
  } };
}
var B0 = L0(), Ac = (function() {
  function r(l) {
    this.rules = null, this._messages = B0, this.define(l);
  }
  var n = r.prototype;
  return n.define = function(h) {
    var f = this;
    if (!h) throw new Error("Cannot configure a schema with no rules");
    if (typeof h != "object" || Array.isArray(h)) throw new Error("Rules must be an object");
    this.rules = {}, Object.keys(h).forEach(function(y) {
      var p = h[y];
      f.rules[y] = Array.isArray(p) ? p : [p];
    });
  }, n.messages = function(h) {
    return h && (this._messages = H_(L0(), h)), this._messages;
  }, n.validate = function(h, f, y) {
    var p = this;
    f === void 0 && (f = {}), y === void 0 && (y = function() {
    });
    var s = h, S = f, P = y;
    if (typeof S == "function" && (P = S, S = {}), !this.rules || Object.keys(this.rules).length === 0) return P && P(null, s), Promise.resolve(s);
    function M(q) {
      var N = [], J = {};
      function te(ae) {
        if (Array.isArray(ae)) {
          var oe;
          N = (oe = N).concat.apply(oe, ae);
        } else N.push(ae);
      }
      for (var ne = 0; ne < q.length; ne++) te(q[ne]);
      N.length ? (J = F0(N), P(N, J)) : P(null, s);
    }
    if (S.messages) {
      var A = this.messages();
      A === B0 && (A = L0()), H_(A, S.messages), S.messages = A;
    } else S.messages = this.messages();
    var O = {}, j = S.keys || Object.keys(this.rules);
    j.forEach(function(q) {
      var N = p.rules[q], J = s[q];
      N.forEach(function(te) {
        var ne = te;
        typeof ne.transform == "function" && (s === h && (s = Gl({}, s)), J = s[q] = ne.transform(J)), typeof ne == "function" ? ne = { validator: ne } : ne = Gl({}, ne), ne.validator = p.getValidationMethod(ne), ne.validator && (ne.field = q, ne.fullField = ne.fullField || q, ne.type = p.getType(ne), O[q] = O[q] || [], O[q].push({ rule: ne, value: J, source: s, field: q }));
      });
    });
    var L = {};
    return k6(O, S, function(q, N) {
      var _a2;
      var J = q.rule, te = (J.type === "object" || J.type === "array") && (typeof J.fields == "object" || typeof J.defaultField == "object");
      te = te && (J.required || !J.required && q.value), J.field = q.field;
      function ne(ee, ke) {
        return Gl({}, ke, { fullField: J.fullField + "." + ee, fullFields: J.fullFields ? [].concat(J.fullFields, [ee]) : [ee] });
      }
      function ae(ee) {
        ee === void 0 && (ee = []);
        var ke = Array.isArray(ee) ? ee : [ee];
        !S.suppressWarning && ke.length && r.warning("async-validator:", ke), ke.length && J.message !== void 0 && (ke = [].concat(J.message));
        var ve = ke.map(Z_(J, s));
        if (S.first && ve.length) return L[J.field] = 1, N(ve);
        if (!te) N(ve);
        else {
          if (J.required && !q.value) return J.message !== void 0 ? ve = [].concat(J.message).map(Z_(J, s)) : S.error && (ve = [S.error(J, Ro(S.messages.required, J.field))]), N(ve);
          var le = {};
          J.defaultField && Object.keys(q.value).map(function(Ve) {
            le[Ve] = J.defaultField;
          }), le = Gl({}, le, q.rule.fields);
          var ue = {};
          Object.keys(le).forEach(function(Ve) {
            var Ge = le[Ve], et = Array.isArray(Ge) ? Ge : [Ge];
            ue[Ve] = et.map(ne.bind(null, Ve));
          });
          var be = new r(ue);
          be.messages(S.messages), q.rule.options && (q.rule.options.messages = S.messages, q.rule.options.error = S.error), be.validate(q.value, q.rule.options || S, function(Ve) {
            var Ge = [];
            ve && ve.length && Ge.push.apply(Ge, ve), Ve && Ve.length && Ge.push.apply(Ge, Ve), N(Ge.length ? Ge : null);
          });
        }
      }
      var oe;
      if (J.asyncValidator) oe = J.asyncValidator(J, q.value, ae, q.source, S);
      else if (J.validator) {
        try {
          oe = J.validator(J, q.value, ae, q.source, S);
        } catch (ee) {
          (_a2 = console.error) == null ? void 0 : _a2.call(console, ee), S.suppressValidatorError || setTimeout(function() {
            throw ee;
          }, 0), ae(ee.message);
        }
        oe === true ? ae() : oe === false ? ae(typeof J.message == "function" ? J.message(J.fullField || J.field) : J.message || (J.fullField || J.field) + " fails") : oe instanceof Array ? ae(oe) : oe instanceof Error && ae(oe.message);
      }
      oe && oe.then && oe.then(function() {
        return ae();
      }, function(ee) {
        return ae(ee);
      });
    }, function(q) {
      M(q);
    }, s);
  }, n.getType = function(h) {
    if (h.type === void 0 && h.pattern instanceof RegExp && (h.type = "pattern"), typeof h.validator != "function" && h.type && !bh.hasOwnProperty(h.type)) throw new Error(Ro("Unknown rule type %s", h.type));
    return h.type || "string";
  }, n.getValidationMethod = function(h) {
    if (typeof h.validator == "function") return h.validator;
    var f = Object.keys(h), y = f.indexOf("message");
    return y !== -1 && f.splice(y, 1), f.length === 1 && f[0] === "required" ? bh.required : bh[this.getType(h)] || void 0;
  }, r;
})();
Ac.register = function(n, l) {
  if (typeof l != "function") throw new Error("Cannot register a validator by type, validator is not a function");
  bh[n] = l;
};
Ac.warning = x6;
Ac.messages = B0;
Ac.validators = bh;
const { cubicBezierEaseInOut: Y_ } = Oh;
function X6({ name: r = "fade-down", fromOffset: n = "-4px", enterDuration: l = ".3s", leaveDuration: h = ".3s", enterCubicBezier: f = Y_, leaveCubicBezier: y = Y_ } = {}) {
  return [qe(`&.${r}-transition-enter-from, &.${r}-transition-leave-to`, { opacity: 0, transform: `translateY(${n})` }), qe(`&.${r}-transition-enter-to, &.${r}-transition-leave-from`, { opacity: 1, transform: "translateY(0)" }), qe(`&.${r}-transition-leave-active`, { transition: `opacity ${h} ${y}, transform ${h} ${y}` }), qe(`&.${r}-transition-enter-active`, { transition: `opacity ${l} ${f}, transform ${l} ${f}` })];
}
const Y6 = he("form-item", `
 display: grid;
 line-height: var(--n-line-height);
`, [he("form-item-label", `
 grid-area: label;
 align-items: center;
 line-height: 1.25;
 text-align: var(--n-label-text-align);
 font-size: var(--n-label-font-size);
 min-height: var(--n-label-height);
 padding: var(--n-label-padding);
 color: var(--n-label-text-color);
 transition: color .3s var(--n-bezier);
 box-sizing: border-box;
 font-weight: var(--n-label-font-weight);
 `, [Le("asterisk", `
 white-space: nowrap;
 user-select: none;
 -webkit-user-select: none;
 color: var(--n-asterisk-color);
 transition: color .3s var(--n-bezier);
 `), Le("asterisk-placeholder", `
 grid-area: mark;
 user-select: none;
 -webkit-user-select: none;
 visibility: hidden; 
 `)]), he("form-item-blank", `
 grid-area: blank;
 min-height: var(--n-blank-height);
 `), Ue("auto-label-width", [he("form-item-label", "white-space: nowrap;")]), Ue("left-labelled", `
 grid-template-areas:
 "label blank"
 "label feedback";
 grid-template-columns: auto minmax(0, 1fr);
 grid-template-rows: auto 1fr;
 align-items: flex-start;
 `, [he("form-item-label", `
 display: grid;
 grid-template-columns: 1fr auto;
 min-height: var(--n-blank-height);
 height: auto;
 box-sizing: border-box;
 flex-shrink: 0;
 flex-grow: 0;
 `, [Ue("reverse-columns-space", `
 grid-template-columns: auto 1fr;
 `), Ue("left-mark", `
 grid-template-areas:
 "mark text"
 ". text";
 `), Ue("right-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), Ue("right-hanging-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), Le("text", `
 grid-area: text; 
 `), Le("asterisk", `
 grid-area: mark; 
 align-self: end;
 `)])]), Ue("top-labelled", `
 grid-template-areas:
 "label"
 "blank"
 "feedback";
 grid-template-rows: minmax(var(--n-label-height), auto) 1fr;
 grid-template-columns: minmax(0, 100%);
 `, [Ue("no-label", `
 grid-template-areas:
 "blank"
 "feedback";
 grid-template-rows: 1fr;
 `), he("form-item-label", `
 display: flex;
 align-items: flex-start;
 justify-content: var(--n-label-text-align);
 `)]), he("form-item-blank", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 position: relative;
 `), he("form-item-feedback-wrapper", `
 grid-area: feedback;
 box-sizing: border-box;
 min-height: var(--n-feedback-height);
 font-size: var(--n-feedback-font-size);
 line-height: 1.25;
 transform-origin: top left;
 `, [qe("&:not(:empty)", `
 padding: var(--n-feedback-padding);
 `), he("form-item-feedback", { transition: "color .3s var(--n-bezier)", color: "var(--n-feedback-text-color)" }, [Ue("warning", { color: "var(--n-feedback-text-color-warning)" }), Ue("error", { color: "var(--n-feedback-text-color-error)" }), X6({ fromOffset: "-3px", enterDuration: ".3s", leaveDuration: ".2s" })])])]);
function K6(r) {
  const n = cr($h, null);
  return { mergedSize: Ae(() => r.size !== void 0 ? r.size : (n == null ? void 0 : n.props.size) !== void 0 ? n.props.size : "medium") };
}
function J6(r) {
  const n = cr($h, null), l = Ae(() => {
    const { labelPlacement: L } = r;
    return L !== void 0 ? L : (n == null ? void 0 : n.props.labelPlacement) ? n.props.labelPlacement : "top";
  }), h = Ae(() => l.value === "left" && (r.labelWidth === "auto" || (n == null ? void 0 : n.props.labelWidth) === "auto")), f = Ae(() => {
    if (l.value === "top") return;
    const { labelWidth: L } = r;
    if (L !== void 0 && L !== "auto") return ca(L);
    if (h.value) {
      const q = n == null ? void 0 : n.maxChildLabelWidthRef.value;
      return q !== void 0 ? ca(q) : void 0;
    }
    if ((n == null ? void 0 : n.props.labelWidth) !== void 0) return ca(n.props.labelWidth);
  }), y = Ae(() => {
    const { labelAlign: L } = r;
    if (L) return L;
    if (n == null ? void 0 : n.props.labelAlign) return n.props.labelAlign;
  }), p = Ae(() => {
    var L;
    return [(L = r.labelProps) === null || L === void 0 ? void 0 : L.style, r.labelStyle, { width: f.value }];
  }), s = Ae(() => {
    const { showRequireMark: L } = r;
    return L !== void 0 ? L : n == null ? void 0 : n.props.showRequireMark;
  }), S = Ae(() => {
    const { requireMarkPlacement: L } = r;
    return L !== void 0 ? L : (n == null ? void 0 : n.props.requireMarkPlacement) || "right";
  }), P = Ee(false), M = Ee(false), A = Ae(() => {
    const { validationStatus: L } = r;
    if (L !== void 0) return L;
    if (P.value) return "error";
    if (M.value) return "warning";
  }), O = Ae(() => {
    const { showFeedback: L } = r;
    return L !== void 0 ? L : (n == null ? void 0 : n.props.showFeedback) !== void 0 ? n.props.showFeedback : true;
  }), j = Ae(() => {
    const { showLabel: L } = r;
    return L !== void 0 ? L : (n == null ? void 0 : n.props.showLabel) !== void 0 ? n.props.showLabel : true;
  });
  return { validationErrored: P, validationWarned: M, mergedLabelStyle: p, mergedLabelPlacement: l, mergedLabelAlign: y, mergedShowRequireMark: s, mergedRequireMarkPlacement: S, mergedValidationStatus: A, mergedShowFeedback: O, mergedShowLabel: j, isAutoLabelWidth: h };
}
function Q6(r) {
  const n = cr($h, null), l = Ae(() => {
    const { rulePath: p } = r;
    if (p !== void 0) return p;
    const { path: s } = r;
    if (s !== void 0) return s;
  }), h = Ae(() => {
    const p = [], { rule: s } = r;
    if (s !== void 0 && (Array.isArray(s) ? p.push(...s) : p.push(s)), n) {
      const { rules: S } = n.props, { value: P } = l;
      if (S !== void 0 && P !== void 0) {
        const M = _1(S, P);
        M !== void 0 && (Array.isArray(M) ? p.push(...M) : p.push(M));
      }
    }
    return p;
  }), f = Ae(() => h.value.some((p) => p.required)), y = Ae(() => f.value || r.required);
  return { mergedRules: h, mergedRequired: y };
}
var K_ = function(r, n, l, h) {
  function f(y) {
    return y instanceof l ? y : new l(function(p) {
      p(y);
    });
  }
  return new (l || (l = Promise))(function(y, p) {
    function s(M) {
      try {
        P(h.next(M));
      } catch (A) {
        p(A);
      }
    }
    function S(M) {
      try {
        P(h.throw(M));
      } catch (A) {
        p(A);
      }
    }
    function P(M) {
      M.done ? y(M.value) : f(M.value).then(s, S);
    }
    P((h = h.apply(r, n || [])).next());
  });
};
const e4 = Object.assign(Object.assign({}, er.props), { label: String, labelWidth: [Number, String], labelStyle: [String, Object], labelAlign: String, labelPlacement: String, path: String, first: Boolean, rulePath: String, required: Boolean, showRequireMark: { type: Boolean, default: void 0 }, requireMarkPlacement: String, showFeedback: { type: Boolean, default: void 0 }, rule: [Object, Array], size: String, ignorePathChange: Boolean, validationStatus: String, feedback: String, feedbackClass: String, feedbackStyle: [String, Object], showLabel: { type: Boolean, default: void 0 }, labelProps: Object, contentClass: String, contentStyle: [String, Object] });
function J_(r, n) {
  return (...l) => {
    try {
      const h = r(...l);
      return !n && (typeof h == "boolean" || h instanceof Error || Array.isArray(h)) || (h == null ? void 0 : h.then) ? h : (h === void 0 || Gp("form-item/validate", `You return a ${typeof h} typed value in the validator method, which is not recommended. Please use ${n ? "`Promise`" : "`boolean`, `Error` or `Promise`"} typed value instead.`), true);
    } catch (h) {
      Gp("form-item/validate", "An error is catched in the validation, so the validation won't be done. Your callback in `validate` method of `n-form` or `n-form-item` won't be called in this validation."), console.error(h);
      return;
    }
  };
}
const An = nt({ name: "FormItem", props: e4, setup(r) {
  tT(fx, "formItems", zt(r, "path"));
  const { mergedClsPrefixRef: n, inlineThemeDisabled: l } = Cr(r), h = cr($h, null), f = K6(r), y = J6(r), { validationErrored: p, validationWarned: s } = y, { mergedRequired: S, mergedRules: P } = Q6(r), { mergedSize: M } = f, { mergedLabelPlacement: A, mergedLabelAlign: O, mergedRequireMarkPlacement: j } = y, L = Ee([]), q = Ee(Kl()), N = h ? zt(h.props, "disabled") : Ee(false), J = er("Form", "-form-item", Y6, y1, r, n);
  Kt(zt(r, "path"), () => {
    r.ignorePathChange || te();
  });
  function te() {
    L.value = [], p.value = false, s.value = false, r.feedback && (q.value = Kl());
  }
  const ne = (...et) => K_(this, [...et], void 0, function* (dt = null, Ct = () => true, kt = { suppressWarning: true }) {
    const { path: ct } = r;
    kt ? kt.first || (kt.first = r.first) : kt = {};
    const { value: it } = P, pt = h ? _1(h.props.model, ct || "") : void 0, $t = {}, vt = {}, Pt = (dt ? it.filter((lr) => Array.isArray(lr.trigger) ? lr.trigger.includes(dt) : lr.trigger === dt) : it).filter(Ct).map((lr, Ir) => {
      const Ht = Object.assign({}, lr);
      if (Ht.validator && (Ht.validator = J_(Ht.validator, false)), Ht.asyncValidator && (Ht.asyncValidator = J_(Ht.asyncValidator, true)), Ht.renderMessage) {
        const Rr = `__renderMessage__${Ir}`;
        vt[Rr] = Ht.message, Ht.message = Rr, $t[Rr] = Ht.renderMessage;
      }
      return Ht;
    }), Nt = Pt.filter((lr) => lr.level !== "warning"), ir = Pt.filter((lr) => lr.level === "warning"), bt = { valid: true, errors: void 0, warnings: void 0 };
    if (!Pt.length) return bt;
    const Dt = ct ?? "__n_no_path__", Zt = new Ac({ [Dt]: Nt }), dr = new Ac({ [Dt]: ir }), { validateMessages: yr } = (h == null ? void 0 : h.props) || {};
    yr && (Zt.messages(yr), dr.messages(yr));
    const Pr = (lr) => {
      L.value = lr.map((Ir) => {
        const Ht = (Ir == null ? void 0 : Ir.message) || "";
        return { key: Ht, render: () => Ht.startsWith("__renderMessage__") ? $t[Ht]() : Ht };
      }), lr.forEach((Ir) => {
        var Ht;
        !((Ht = Ir.message) === null || Ht === void 0) && Ht.startsWith("__renderMessage__") && (Ir.message = vt[Ir.message]);
      });
    };
    if (Nt.length) {
      const lr = yield new Promise((Ir) => {
        Zt.validate({ [Dt]: pt }, kt, Ir);
      });
      (lr == null ? void 0 : lr.length) && (bt.valid = false, bt.errors = lr, Pr(lr));
    }
    if (ir.length && !bt.errors) {
      const lr = yield new Promise((Ir) => {
        dr.validate({ [Dt]: pt }, kt, Ir);
      });
      (lr == null ? void 0 : lr.length) && (Pr(lr), bt.warnings = lr);
    }
    return !bt.errors && !bt.warnings ? te() : (p.value = !!bt.errors, s.value = !!bt.warnings), bt;
  });
  function ae() {
    ne("blur");
  }
  function oe() {
    ne("change");
  }
  function ee() {
    ne("focus");
  }
  function ke() {
    ne("input");
  }
  function ve(et, dt) {
    return K_(this, void 0, void 0, function* () {
      let Ct, kt, ct, it;
      return typeof et == "string" ? (Ct = et, kt = dt) : et !== null && typeof et == "object" && (Ct = et.trigger, kt = et.callback, ct = et.shouldRuleBeApplied, it = et.options), yield new Promise((pt, $t) => {
        ne(Ct, ct, it).then(({ valid: vt, errors: Pt, warnings: Nt }) => {
          vt ? (kt && kt(void 0, { warnings: Nt }), pt({ warnings: Nt })) : (kt && kt(Pt, { warnings: Nt }), $t(Pt));
        });
      });
    });
  }
  Vr(X3, { path: zt(r, "path"), disabled: N, mergedSize: f.mergedSize, mergedValidationStatus: y.mergedValidationStatus, restoreValidation: te, handleContentBlur: ae, handleContentChange: oe, handleContentFocus: ee, handleContentInput: ke });
  const le = { validate: ve, restoreValidation: te, internalValidate: ne }, ue = Ee(null);
  Ei(() => {
    if (!y.isAutoLabelWidth.value) return;
    const et = ue.value;
    if (et !== null) {
      const dt = et.style.whiteSpace;
      et.style.whiteSpace = "nowrap", et.style.width = "", h == null ? void 0 : h.deriveMaxChildLabelWidth(Number(getComputedStyle(et).width.slice(0, -2))), et.style.whiteSpace = dt;
    }
  });
  const be = Ae(() => {
    var et;
    const { value: dt } = M, { value: Ct } = A, kt = Ct === "top" ? "vertical" : "horizontal", { common: { cubicBezierEaseInOut: ct }, self: { labelTextColor: it, asteriskColor: pt, lineHeight: $t, feedbackTextColor: vt, feedbackTextColorWarning: Pt, feedbackTextColorError: Nt, feedbackPadding: ir, labelFontWeight: bt, [Ut("labelHeight", dt)]: Dt, [Ut("blankHeight", dt)]: Zt, [Ut("feedbackFontSize", dt)]: dr, [Ut("feedbackHeight", dt)]: yr, [Ut("labelPadding", kt)]: Pr, [Ut("labelTextAlign", kt)]: lr, [Ut(Ut("labelFontSize", Ct), dt)]: Ir } } = J.value;
    let Ht = (et = O.value) !== null && et !== void 0 ? et : lr;
    return Ct === "top" && (Ht = Ht === "right" ? "flex-end" : "flex-start"), { "--n-bezier": ct, "--n-line-height": $t, "--n-blank-height": Zt, "--n-label-font-size": Ir, "--n-label-text-align": Ht, "--n-label-height": Dt, "--n-label-padding": Pr, "--n-label-font-weight": bt, "--n-asterisk-color": pt, "--n-label-text-color": it, "--n-feedback-padding": ir, "--n-feedback-font-size": dr, "--n-feedback-height": yr, "--n-feedback-text-color": vt, "--n-feedback-text-color-warning": Pt, "--n-feedback-text-color-error": Nt };
  }), Ve = l ? ai("form-item", Ae(() => {
    var et;
    return `${M.value[0]}${A.value[0]}${((et = O.value) === null || et === void 0 ? void 0 : et[0]) || ""}`;
  }), be, r) : void 0, Ge = Ae(() => A.value === "left" && j.value === "left" && O.value === "left");
  return Object.assign(Object.assign(Object.assign(Object.assign({ labelElementRef: ue, mergedClsPrefix: n, mergedRequired: S, feedbackId: q, renderExplains: L, reverseColSpace: Ge }, y), f), le), { cssVars: l ? void 0 : be, themeClass: Ve == null ? void 0 : Ve.themeClass, onRender: Ve == null ? void 0 : Ve.onRender });
}, render() {
  const { $slots: r, mergedClsPrefix: n, mergedShowLabel: l, mergedShowRequireMark: h, mergedRequireMarkPlacement: f, onRender: y } = this, p = h !== void 0 ? h : this.mergedRequired;
  y == null ? void 0 : y();
  const s = () => {
    const S = this.$slots.label ? this.$slots.label() : this.label;
    if (!S) return null;
    const P = B("span", { class: `${n}-form-item-label__text` }, S), M = p ? B("span", { class: `${n}-form-item-label__asterisk` }, f !== "left" ? "\xA0*" : "*\xA0") : f === "right-hanging" && B("span", { class: `${n}-form-item-label__asterisk-placeholder` }, "\xA0*"), { labelProps: A } = this;
    return B("label", Object.assign({}, A, { class: [A == null ? void 0 : A.class, `${n}-form-item-label`, `${n}-form-item-label--${f}-mark`, this.reverseColSpace && `${n}-form-item-label--reverse-columns-space`], style: this.mergedLabelStyle, ref: "labelElementRef" }), f === "left" ? [M, P] : [P, M]);
  };
  return B("div", { class: [`${n}-form-item`, this.themeClass, `${n}-form-item--${this.mergedSize}-size`, `${n}-form-item--${this.mergedLabelPlacement}-labelled`, this.isAutoLabelWidth && `${n}-form-item--auto-label-width`, !l && `${n}-form-item--no-label`], style: this.cssVars }, l && s(), B("div", { class: [`${n}-form-item-blank`, this.contentClass, this.mergedValidationStatus && `${n}-form-item-blank--${this.mergedValidationStatus}`], style: this.contentStyle }, r), this.mergedShowFeedback ? B("div", { key: this.feedbackId, style: this.feedbackStyle, class: [`${n}-form-item-feedback-wrapper`, this.feedbackClass] }, B(Wo, { name: "fade-down-transition", mode: "out-in" }, { default: () => {
    const { mergedValidationStatus: S } = this;
    return oi(r.feedback, (P) => {
      var M;
      const { feedback: A } = this, O = P || A ? B("div", { key: "__feedback__", class: `${n}-form-item-feedback__line` }, P || A) : this.renderExplains.length ? (M = this.renderExplains) === null || M === void 0 ? void 0 : M.map(({ key: j, render: L }) => B("div", { key: j, class: `${n}-form-item-feedback__line` }, L())) : null;
      return O ? S === "warning" ? B("div", { key: "controlled-warning", class: `${n}-form-item-feedback ${n}-form-item-feedback--warning` }, O) : S === "error" ? B("div", { key: "controlled-error", class: `${n}-form-item-feedback ${n}-form-item-feedback--error` }, O) : S === "success" ? B("div", { key: "controlled-success", class: `${n}-form-item-feedback ${n}-form-item-feedback--success` }, O) : B("div", { key: "controlled-default", class: `${n}-form-item-feedback` }, O) : null;
    });
  } })) : null);
} }), Q_ = 1, mx = qn("n-grid"), gx = 1, t4 = { span: { type: [Number, String], default: gx }, offset: { type: [Number, String], default: 0 }, suffix: Boolean, privateOffset: Number, privateSpan: Number, privateColStart: Number, privateShow: { type: Boolean, default: true } }, r4 = nt({ __GRID_ITEM__: true, name: "GridItem", alias: ["Gi"], props: t4, setup() {
  const { isSsrRef: r, xGapRef: n, itemStyleRef: l, overflowRef: h, layoutShiftDisabledRef: f } = cr(mx), y = Lh();
  return { overflow: h, itemStyle: l, layoutShiftDisabled: f, mergedXGap: Ae(() => Qn(n.value || 0)), deriveStyle: () => {
    r.value;
    const { privateSpan: p = gx, privateShow: s = true, privateColStart: S = void 0, privateOffset: P = 0 } = y.vnode.props, { value: M } = n, A = Qn(M || 0);
    return { display: s ? "" : "none", gridColumn: `${S ?? `span ${p}`} / span ${p}`, marginLeft: P ? `calc((100% - (${p} - 1) * ${A}) / ${p} * ${P} + ${A} * ${P})` : "" };
  } };
}, render() {
  var r, n;
  if (this.layoutShiftDisabled) {
    const { span: l, offset: h, mergedXGap: f } = this;
    return B("div", { style: { gridColumn: `span ${l} / span ${l}`, marginLeft: h ? `calc((100% - (${l} - 1) * ${f}) / ${l} * ${h} + ${f} * ${h})` : "" } }, this.$slots);
  }
  return B("div", { style: [this.itemStyle, this.deriveStyle()] }, (n = (r = this.$slots).default) === null || n === void 0 ? void 0 : n.call(r, { overflow: this.overflow }));
} }), i4 = { xs: 0, s: 640, m: 1024, l: 1280, xl: 1536, xxl: 1920 }, vx = 24, e0 = "__ssr__", n4 = { layoutShiftDisabled: Boolean, responsive: { type: [String, Boolean], default: "self" }, cols: { type: [Number, String], default: vx }, itemResponsive: Boolean, collapsed: Boolean, collapsedRows: { type: Number, default: 1 }, itemStyle: [Object, String], xGap: { type: [Number, String], default: 0 }, yGap: { type: [Number, String], default: 0 } }, o4 = nt({ name: "Grid", inheritAttrs: false, props: n4, setup(r) {
  const { mergedClsPrefixRef: n, mergedBreakpointsRef: l } = Cr(r), h = /^\d+$/, f = Ee(void 0), y = eT((l == null ? void 0 : l.value) || i4), p = vi(() => !!(r.itemResponsive || !h.test(r.cols.toString()) || !h.test(r.xGap.toString()) || !h.test(r.yGap.toString()))), s = Ae(() => {
    if (p.value) return r.responsive === "self" ? f.value : y.value;
  }), S = vi(() => {
    var J;
    return (J = Number(_c(r.cols.toString(), s.value))) !== null && J !== void 0 ? J : vx;
  }), P = vi(() => _c(r.xGap.toString(), s.value)), M = vi(() => _c(r.yGap.toString(), s.value)), A = (J) => {
    f.value = J.contentRect.width;
  }, O = (J) => {
    rm(A, J);
  }, j = Ee(false), L = Ae(() => {
    if (r.responsive === "self") return O;
  }), q = Ee(false), N = Ee();
  return Ei(() => {
    const { value: J } = N;
    J && J.hasAttribute(e0) && (J.removeAttribute(e0), q.value = true);
  }), Vr(mx, { layoutShiftDisabledRef: zt(r, "layoutShiftDisabled"), isSsrRef: q, itemStyleRef: zt(r, "itemStyle"), xGapRef: P, overflowRef: j }), { isSsr: !um, contentEl: N, mergedClsPrefix: n, style: Ae(() => r.layoutShiftDisabled ? { width: "100%", display: "grid", gridTemplateColumns: `repeat(${r.cols}, minmax(0, 1fr))`, columnGap: Qn(r.xGap), rowGap: Qn(r.yGap) } : { width: "100%", display: "grid", gridTemplateColumns: `repeat(${S.value}, minmax(0, 1fr))`, columnGap: Qn(P.value), rowGap: Qn(M.value) }), isResponsive: p, responsiveQuery: s, responsiveCols: S, handleResize: L, overflow: j };
}, render() {
  if (this.layoutShiftDisabled) return B("div", ls({ ref: "contentEl", class: `${this.mergedClsPrefix}-grid`, style: this.style }, this.$attrs), this.$slots);
  const r = () => {
    var n, l, h, f, y, p, s;
    this.overflow = false;
    const S = Xl(hm(this)), P = [], { collapsed: M, collapsedRows: A, responsiveCols: O, responsiveQuery: j } = this;
    S.forEach((te) => {
      var ne, ae, oe, ee, ke;
      if (((ne = te == null ? void 0 : te.type) === null || ne === void 0 ? void 0 : ne.__GRID_ITEM__) !== true) return;
      if (hT(te)) {
        const ue = y0(te);
        ue.props ? ue.props.privateShow = false : ue.props = { privateShow: false }, P.push({ child: ue, rawChildSpan: 0 });
        return;
      }
      te.dirs = ((ae = te.dirs) === null || ae === void 0 ? void 0 : ae.filter(({ dir: ue }) => ue !== us)) || null, ((oe = te.dirs) === null || oe === void 0 ? void 0 : oe.length) === 0 && (te.dirs = null);
      const ve = y0(te), le = Number((ke = _c((ee = ve.props) === null || ee === void 0 ? void 0 : ee.span, j)) !== null && ke !== void 0 ? ke : Q_);
      le !== 0 && P.push({ child: ve, rawChildSpan: le });
    });
    let L = 0;
    const q = (n = P[P.length - 1]) === null || n === void 0 ? void 0 : n.child;
    if (q == null ? void 0 : q.props) {
      const te = (l = q.props) === null || l === void 0 ? void 0 : l.suffix;
      te !== void 0 && te !== false && (L = Number((f = _c((h = q.props) === null || h === void 0 ? void 0 : h.span, j)) !== null && f !== void 0 ? f : Q_), q.props.privateSpan = L, q.props.privateColStart = O + 1 - L, q.props.privateShow = (y = q.props.privateShow) !== null && y !== void 0 ? y : true);
    }
    let N = 0, J = false;
    for (const { child: te, rawChildSpan: ne } of P) {
      if (J && (this.overflow = true), !J) {
        const ae = Number((s = _c((p = te.props) === null || p === void 0 ? void 0 : p.offset, j)) !== null && s !== void 0 ? s : 0), oe = Math.min(ne + ae, O);
        if (te.props ? (te.props.privateSpan = oe, te.props.privateOffset = ae) : te.props = { privateSpan: oe, privateOffset: ae }, M) {
          const ee = N % O;
          oe + ee > O && (N += O - ee), oe + N + L > A * O ? J = true : N += oe;
        }
      }
      J && (te.props ? te.props.privateShow !== true && (te.props.privateShow = false) : te.props = { privateShow: false });
    }
    return B("div", ls({ ref: "contentEl", class: `${this.mergedClsPrefix}-grid`, style: this.style, [e0]: this.isSsr || void 0 }, this.$attrs), P.map(({ child: te }) => te));
  };
  return this.isResponsive && this.responsive === "self" ? B(ql, { onResize: this.handleResize }, { default: r }) : r();
} });
function a4() {
  return B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M6 5C5.75454 5 5.55039 5.17688 5.50806 5.41012L5.5 5.5V14.5C5.5 14.7761 5.72386 15 6 15C6.24546 15 6.44961 14.8231 6.49194 14.5899L6.5 14.5V5.5C6.5 5.22386 6.27614 5 6 5ZM13.8536 5.14645C13.68 4.97288 13.4106 4.9536 13.2157 5.08859L13.1464 5.14645L8.64645 9.64645C8.47288 9.82001 8.4536 10.0894 8.58859 10.2843L8.64645 10.3536L13.1464 14.8536C13.3417 15.0488 13.6583 15.0488 13.8536 14.8536C14.0271 14.68 14.0464 14.4106 13.9114 14.2157L13.8536 14.1464L9.70711 10L13.8536 5.85355C14.0488 5.65829 14.0488 5.34171 13.8536 5.14645Z", fill: "currentColor" }));
}
function s4() {
  return B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M13.5 5C13.7455 5 13.9496 5.17688 13.9919 5.41012L14 5.5V14.5C14 14.7761 13.7761 15 13.5 15C13.2545 15 13.0504 14.8231 13.0081 14.5899L13 14.5V5.5C13 5.22386 13.2239 5 13.5 5ZM5.64645 5.14645C5.82001 4.97288 6.08944 4.9536 6.28431 5.08859L6.35355 5.14645L10.8536 9.64645C11.0271 9.82001 11.0464 10.0894 10.9114 10.2843L10.8536 10.3536L6.35355 14.8536C6.15829 15.0488 5.84171 15.0488 5.64645 14.8536C5.47288 14.68 5.4536 14.4106 5.58859 14.2157L5.64645 14.1464L9.79289 10L5.64645 5.85355C5.45118 5.65829 5.45118 5.34171 5.64645 5.14645Z", fill: "currentColor" }));
}
function l4() {
  return B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M4.089 4.216l.057-.07a.5.5 0 0 1 .638-.057l.07.057L10 9.293l5.146-5.147a.5.5 0 0 1 .638-.057l.07.057a.5.5 0 0 1 .057.638l-.057.07L10.707 10l5.147 5.146a.5.5 0 0 1 .057.638l-.057.07a.5.5 0 0 1-.638.057l-.07-.057L10 10.707l-5.146 5.147a.5.5 0 0 1-.638.057l-.07-.057a.5.5 0 0 1-.057-.638l.057-.07L9.293 10L4.146 4.854a.5.5 0 0 1-.057-.638l.057-.07l-.057.07z", fill: "currentColor" }));
}
const sv = Object.assign(Object.assign({}, er.props), { onPreviewPrev: Function, onPreviewNext: Function, showToolbar: { type: Boolean, default: true }, showToolbarTooltip: Boolean, renderToolbar: Function }), yx = qn("n-image"), u4 = qe([qe("body >", [he("image-container", "position: fixed;")]), he("image-preview-container", `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 `), he("image-preview-overlay", `
 z-index: -1;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 background: rgba(0, 0, 0, .3);
 `, [Zp()]), he("image-preview-toolbar", `
 z-index: 1;
 position: absolute;
 left: 50%;
 transform: translateX(-50%);
 border-radius: var(--n-toolbar-border-radius);
 height: 48px;
 bottom: 40px;
 padding: 0 12px;
 background: var(--n-toolbar-color);
 box-shadow: var(--n-toolbar-box-shadow);
 color: var(--n-toolbar-icon-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [he("base-icon", `
 padding: 0 8px;
 font-size: 28px;
 cursor: pointer;
 `), Zp()]), he("image-preview-wrapper", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 pointer-events: none;
 `, [nm()]), he("image-preview", `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: all;
 margin: auto;
 max-height: calc(100vh - 32px);
 max-width: calc(100vw - 32px);
 transition: transform .3s var(--n-bezier);
 `), he("image", `
 display: inline-flex;
 max-height: 100%;
 max-width: 100%;
 `, [ci("preview-disabled", `
 cursor: pointer;
 `), qe("img", `
 border-radius: inherit;
 `)])]), kp = 32, c4 = Object.assign(Object.assign({}, sv), { src: String, show: { type: Boolean, default: void 0 }, defaultShow: Boolean, "onUpdate:show": [Function, Array], onUpdateShow: [Function, Array], onNext: Function, onPrev: Function, onClose: [Function, Array] }), _x = nt({ name: "ImagePreview", props: c4, setup(r) {
  const { src: n } = QC(r), { mergedClsPrefixRef: l } = Cr(r), h = er("Image", "-image", u4, Y3, r, l);
  let f = null;
  const y = Ee(null), p = Ee(null), s = Ee(false), { localeRef: S } = ds("Image"), P = Ee(r.defaultShow), M = zt(r, "show"), A = Qi(M, P);
  function O() {
    const { value: Be } = p;
    if (!f || !Be) return;
    const { style: ot } = Be, $e = f.getBoundingClientRect(), Ye = $e.left + $e.width / 2, ht = $e.top + $e.height / 2;
    ot.transformOrigin = `${Ye}px ${ht}px`;
  }
  function j(Be) {
    var ot, $e;
    switch (Be.key) {
      case " ":
        Be.preventDefault();
        break;
      case "ArrowLeft":
        (ot = r.onPrev) === null || ot === void 0 || ot.call(r);
        break;
      case "ArrowRight":
        ($e = r.onNext) === null || $e === void 0 || $e.call(r);
        break;
      case "ArrowUp":
        Be.preventDefault(), bt();
        break;
      case "ArrowDown":
        Be.preventDefault(), Dt();
        break;
      case "Escape":
        yr();
        break;
    }
  }
  function L(Be) {
    const { onUpdateShow: ot, "onUpdate:show": $e } = r;
    ot && jt(ot, Be), $e && jt($e, Be), P.value = Be, s.value = true;
  }
  Kt(A, (Be) => {
    Be ? Un("keydown", document, j) : co("keydown", document, j);
  }), Fn(() => {
    co("keydown", document, j);
  });
  let q = 0, N = 0, J = 0, te = 0, ne = 0, ae = 0, oe = 0, ee = 0, ke = false;
  function ve(Be) {
    const { clientX: ot, clientY: $e } = Be;
    J = ot - q, te = $e - N, rm(dr);
  }
  function le(Be) {
    const { mouseUpClientX: ot, mouseUpClientY: $e, mouseDownClientX: Ye, mouseDownClientY: ht } = Be, St = Ye - ot, rt = ht - $e, mt = `vertical${rt > 0 ? "Top" : "Bottom"}`, nr = `horizontal${St > 0 ? "Left" : "Right"}`;
    return { moveVerticalDirection: mt, moveHorizontalDirection: nr, deltaHorizontal: St, deltaVertical: rt };
  }
  function ue(Be) {
    const { value: ot } = y;
    if (!ot) return { offsetX: 0, offsetY: 0 };
    const $e = ot.getBoundingClientRect(), { moveVerticalDirection: Ye, moveHorizontalDirection: ht, deltaHorizontal: St, deltaVertical: rt } = Be || {};
    let mt = 0, nr = 0;
    return $e.width <= window.innerWidth ? mt = 0 : $e.left > 0 ? mt = ($e.width - window.innerWidth) / 2 : $e.right < window.innerWidth ? mt = -($e.width - window.innerWidth) / 2 : ht === "horizontalRight" ? mt = Math.min(($e.width - window.innerWidth) / 2, ne - (St ?? 0)) : mt = Math.max(-(($e.width - window.innerWidth) / 2), ne - (St ?? 0)), $e.height <= window.innerHeight ? nr = 0 : $e.top > 0 ? nr = ($e.height - window.innerHeight) / 2 : $e.bottom < window.innerHeight ? nr = -($e.height - window.innerHeight) / 2 : Ye === "verticalBottom" ? nr = Math.min(($e.height - window.innerHeight) / 2, ae - (rt ?? 0)) : nr = Math.max(-(($e.height - window.innerHeight) / 2), ae - (rt ?? 0)), { offsetX: mt, offsetY: nr };
  }
  function be(Be) {
    co("mousemove", document, ve), co("mouseup", document, be);
    const { clientX: ot, clientY: $e } = Be;
    ke = false;
    const Ye = le({ mouseUpClientX: ot, mouseUpClientY: $e, mouseDownClientX: oe, mouseDownClientY: ee }), ht = ue(Ye);
    J = ht.offsetX, te = ht.offsetY, dr();
  }
  const Ve = cr(yx, null);
  function Ge(Be) {
    var ot, $e;
    if (($e = (ot = Ve == null ? void 0 : Ve.previewedImgPropsRef.value) === null || ot === void 0 ? void 0 : ot.onMousedown) === null || $e === void 0 || $e.call(ot, Be), Be.button !== 0) return;
    const { clientX: Ye, clientY: ht } = Be;
    ke = true, q = Ye - J, N = ht - te, ne = J, ae = te, oe = Ye, ee = ht, dr(), Un("mousemove", document, ve), Un("mouseup", document, be);
  }
  const et = 1.5;
  let dt = 0, Ct = 1, kt = 0;
  function ct(Be) {
    var ot, $e;
    ($e = (ot = Ve == null ? void 0 : Ve.previewedImgPropsRef.value) === null || ot === void 0 ? void 0 : ot.onDblclick) === null || $e === void 0 || $e.call(ot, Be);
    const Ye = ir();
    Ct = Ct === Ye ? 1 : Ye, dr();
  }
  function it() {
    Ct = 1, dt = 0;
  }
  function pt() {
    var Be;
    it(), kt = 0, (Be = r.onPrev) === null || Be === void 0 || Be.call(r);
  }
  function $t() {
    var Be;
    it(), kt = 0, (Be = r.onNext) === null || Be === void 0 || Be.call(r);
  }
  function vt() {
    kt -= 90, dr();
  }
  function Pt() {
    kt += 90, dr();
  }
  function Nt() {
    const { value: Be } = y;
    if (!Be) return 1;
    const { innerWidth: ot, innerHeight: $e } = window, Ye = Math.max(1, Be.naturalHeight / ($e - kp)), ht = Math.max(1, Be.naturalWidth / (ot - kp));
    return Math.max(3, Ye * 2, ht * 2);
  }
  function ir() {
    const { value: Be } = y;
    if (!Be) return 1;
    const { innerWidth: ot, innerHeight: $e } = window, Ye = Be.naturalHeight / ($e - kp), ht = Be.naturalWidth / (ot - kp);
    return Ye < 1 && ht < 1 ? 1 : Math.max(Ye, ht);
  }
  function bt() {
    const Be = Nt();
    Ct < Be && (dt += 1, Ct = Math.min(Be, Math.pow(et, dt)), dr());
  }
  function Dt() {
    if (Ct > 0.5) {
      const Be = Ct;
      dt -= 1, Ct = Math.max(0.5, Math.pow(et, dt));
      const ot = Be - Ct;
      dr(false);
      const $e = ue();
      Ct += ot, dr(false), Ct -= ot, J = $e.offsetX, te = $e.offsetY, dr();
    }
  }
  function Zt() {
    const Be = n.value;
    Be && H1(Be, void 0);
  }
  function dr(Be = true) {
    var ot;
    const { value: $e } = y;
    if (!$e) return;
    const { style: Ye } = $e, ht = zn((ot = Ve == null ? void 0 : Ve.previewedImgPropsRef.value) === null || ot === void 0 ? void 0 : ot.style);
    let St = "";
    if (typeof ht == "string") St = `${ht};`;
    else for (const mt in ht) St += `${_k(mt)}: ${ht[mt]};`;
    const rt = `transform-origin: center; transform: translateX(${J}px) translateY(${te}px) rotate(${kt}deg) scale(${Ct});`;
    ke ? Ye.cssText = `${St}cursor: grabbing; transition: none;${rt}` : Ye.cssText = `${St}cursor: grab;${rt}${Be ? "" : "transition: none;"}`, Be || $e.offsetHeight;
  }
  function yr() {
    if (A.value) {
      const { onClose: Be } = r;
      Be && jt(Be), L(false), P.value = false;
    }
  }
  function Pr() {
    Ct = ir(), dt = Math.ceil(Math.log(Ct) / Math.log(et)), J = 0, te = 0, dr();
  }
  const lr = { setThumbnailEl: (Be) => {
    f = Be;
  } };
  function Ir(Be, ot) {
    if (r.showToolbarTooltip) {
      const { value: $e } = h;
      return B(f1, { to: false, theme: $e.peers.Tooltip, themeOverrides: $e.peerOverrides.Tooltip, keepAliveOnHover: false }, { default: () => S.value[ot], trigger: () => Be });
    } else return Be;
  }
  const Ht = Ae(() => {
    const { common: { cubicBezierEaseInOut: Be }, self: { toolbarIconColor: ot, toolbarBorderRadius: $e, toolbarBoxShadow: Ye, toolbarColor: ht } } = h.value;
    return { "--n-bezier": Be, "--n-toolbar-icon-color": ot, "--n-toolbar-color": ht, "--n-toolbar-border-radius": $e, "--n-toolbar-box-shadow": Ye };
  }), { inlineThemeDisabled: Rr } = Cr(), xr = Rr ? ai("image-preview", void 0, Ht, r) : void 0;
  function gt(Be) {
    Be.preventDefault();
  }
  return Object.assign({ clsPrefix: l, previewRef: y, previewWrapperRef: p, previewSrc: n, mergedShow: A, appear: cm(), displayed: s, previewedImgProps: Ve == null ? void 0 : Ve.previewedImgPropsRef, handleWheel: gt, handlePreviewMousedown: Ge, handlePreviewDblclick: ct, syncTransformOrigin: O, handleAfterLeave: () => {
    it(), kt = 0, s.value = false;
  }, handleDragStart: (Be) => {
    var ot, $e;
    ($e = (ot = Ve == null ? void 0 : Ve.previewedImgPropsRef.value) === null || ot === void 0 ? void 0 : ot.onDragstart) === null || $e === void 0 || $e.call(ot, Be), Be.preventDefault();
  }, zoomIn: bt, zoomOut: Dt, handleDownloadClick: Zt, rotateCounterclockwise: vt, rotateClockwise: Pt, handleSwitchPrev: pt, handleSwitchNext: $t, withTooltip: Ir, resizeToOrignalImageSize: Pr, cssVars: Rr ? void 0 : Ht, themeClass: xr == null ? void 0 : xr.themeClass, onRender: xr == null ? void 0 : xr.onRender, doUpdateShow: L, close: yr }, lr);
}, render() {
  var r, n;
  const { clsPrefix: l, renderToolbar: h, withTooltip: f } = this, y = f(B(Nr, { clsPrefix: l, onClick: this.handleSwitchPrev }, { default: a4 }), "tipPrevious"), p = f(B(Nr, { clsPrefix: l, onClick: this.handleSwitchNext }, { default: s4 }), "tipNext"), s = f(B(Nr, { clsPrefix: l, onClick: this.rotateCounterclockwise }, { default: () => B(dP, null) }), "tipCounterclockwise"), S = f(B(Nr, { clsPrefix: l, onClick: this.rotateClockwise }, { default: () => B(cP, null) }), "tipClockwise"), P = f(B(Nr, { clsPrefix: l, onClick: this.resizeToOrignalImageSize }, { default: () => B(lP, null) }), "tipOriginalSize"), M = f(B(Nr, { clsPrefix: l, onClick: this.zoomOut }, { default: () => B(pP, null) }), "tipZoomOut"), A = f(B(Nr, { clsPrefix: l, onClick: this.handleDownloadClick }, { default: () => B(X1, null) }), "tipDownload"), O = f(B(Nr, { clsPrefix: l, onClick: () => this.close() }, { default: l4 }), "tipClose"), j = f(B(Nr, { clsPrefix: l, onClick: this.zoomIn }, { default: () => B(fP, null) }), "tipZoomIn");
  return B(jr, null, (n = (r = this.$slots).default) === null || n === void 0 ? void 0 : n.call(r), B(g1, { show: this.mergedShow }, { default: () => {
    var L;
    return this.mergedShow || this.displayed ? ((L = this.onRender) === null || L === void 0 || L.call(this), za(B("div", { ref: "containerRef", class: [`${l}-image-preview-container`, this.themeClass], style: this.cssVars, onWheel: this.handleWheel }, B(Wo, { name: "fade-in-transition", appear: this.appear }, { default: () => this.mergedShow ? B("div", { class: `${l}-image-preview-overlay`, onClick: () => this.close() }) : null }), this.showToolbar ? B(Wo, { name: "fade-in-transition", appear: this.appear }, { default: () => this.mergedShow ? B("div", { class: `${l}-image-preview-toolbar` }, h ? h({ nodes: { prev: y, next: p, rotateCounterclockwise: s, rotateClockwise: S, resizeToOriginalSize: P, zoomOut: M, zoomIn: j, download: A, close: O } }) : B(jr, null, this.onPrev ? B(jr, null, y, p) : null, s, S, P, M, j, A, O)) : null }) : null, B(Wo, { name: "fade-in-scale-up-transition", onAfterLeave: this.handleAfterLeave, appear: this.appear, onEnter: this.syncTransformOrigin, onBeforeLeave: this.syncTransformOrigin }, { default: () => {
      const { previewedImgProps: q = {} } = this;
      return za(B("div", { class: `${l}-image-preview-wrapper`, ref: "previewWrapperRef" }, B("img", Object.assign({}, q, { draggable: false, onMousedown: this.handlePreviewMousedown, onDblclick: this.handlePreviewDblclick, class: [`${l}-image-preview`, q.class], key: this.previewSrc, src: this.previewSrc, ref: "previewRef", onDragstart: this.handleDragStart }))), [[us, this.mergedShow]]);
    } })), [[m1, { enabled: this.mergedShow }]])) : null;
  } }));
} }), bx = qn("n-image-group"), d4 = Object.assign(Object.assign({}, sv), { srcList: Array, current: Number, defaultCurrent: { type: Number, default: 0 }, show: { type: Boolean, default: void 0 }, defaultShow: Boolean, onUpdateShow: [Function, Array], "onUpdate:show": [Function, Array], onUpdateCurrent: [Function, Array], "onUpdate:current": [Function, Array] }), h4 = nt({ name: "ImageGroup", props: d4, setup(r) {
  const { mergedClsPrefixRef: n } = Cr(r), l = `c${Kl()}`, h = Ee(null), f = Ee(r.defaultShow), y = zt(r, "show"), p = Qi(y, f), s = Ee(/* @__PURE__ */ new Map()), S = Ae(() => {
    if (r.srcList) {
      const ve = /* @__PURE__ */ new Map();
      return r.srcList.forEach((le, ue) => {
        ve.set(`p${ue}`, le);
      }), ve;
    }
    return s.value;
  }), P = Ae(() => Array.from(S.value.keys())), M = () => P.value.length;
  function A(ve, le) {
    r.srcList && fa("image-group", "`n-image` can't be placed inside `n-image-group` when image group's `src-list` prop is set.");
    const ue = `r${ve}`;
    return s.value.has(`r${ue}`) || s.value.set(ue, le), function() {
      s.value.has(ue) || s.value.delete(ue);
    };
  }
  const O = Ee(r.defaultCurrent), j = zt(r, "current"), L = Qi(j, O), q = (ve) => {
    if (ve !== L.value) {
      const { onUpdateCurrent: le, "onUpdate:current": ue } = r;
      le && jt(le, ve), ue && jt(ue, ve), O.value = ve;
    }
  }, N = Ae(() => P.value[L.value]), J = (ve) => {
    const le = P.value.indexOf(ve);
    le !== L.value && q(le);
  }, te = Ae(() => S.value.get(N.value));
  function ne(ve) {
    const { onUpdateShow: le, "onUpdate:show": ue } = r;
    le && jt(le, ve), ue && jt(ue, ve), f.value = ve;
  }
  function ae() {
    ne(false);
  }
  const oe = Ae(() => {
    const ve = (ue, be) => {
      for (let Ve = ue; Ve <= be; Ve++) {
        const Ge = P.value[Ve];
        if (S.value.get(Ge)) return Ve;
      }
    }, le = ve(L.value + 1, M() - 1);
    return le === void 0 ? ve(0, L.value - 1) : le;
  }), ee = Ae(() => {
    const ve = (ue, be) => {
      for (let Ve = ue; Ve >= be; Ve--) {
        const Ge = P.value[Ve];
        if (S.value.get(Ge)) return Ve;
      }
    }, le = ve(L.value - 1, 0);
    return le === void 0 ? ve(M() - 1, L.value + 1) : le;
  });
  function ke(ve) {
    var le, ue;
    ve === 1 ? (ee.value !== void 0 && q(oe.value), (le = r.onPreviewNext) === null || le === void 0 || le.call(r)) : (oe.value !== void 0 && q(ee.value), (ue = r.onPreviewPrev) === null || ue === void 0 || ue.call(r));
  }
  return Vr(bx, { mergedClsPrefixRef: n, registerImageUrl: A, setThumbnailEl: (ve) => {
    var le;
    (le = h.value) === null || le === void 0 || le.setThumbnailEl(ve);
  }, toggleShow: (ve) => {
    ne(true), J(ve);
  }, groupId: l, renderToolbarRef: zt(r, "renderToolbar") }), { mergedClsPrefix: n, previewInstRef: h, mergedShow: p, src: te, onClose: ae, next: () => {
    ke(1);
  }, prev: () => {
    ke(-1);
  } };
}, render() {
  return B(_x, { theme: this.theme, themeOverrides: this.themeOverrides, ref: "previewInstRef", onPrev: this.prev, onNext: this.next, src: this.src, show: this.mergedShow, showToolbar: this.showToolbar, showToolbarTooltip: this.showToolbarTooltip, renderToolbar: this.renderToolbar, onClose: this.onClose }, this.$slots);
} }), f4 = Object.assign({ alt: String, height: [String, Number], imgProps: Object, previewedImgProps: Object, lazy: Boolean, intersectionObserverOptions: Object, objectFit: { type: String, default: "fill" }, previewSrc: String, fallbackSrc: String, width: [String, Number], src: String, previewDisabled: Boolean, loadDescription: String, onError: Function, onLoad: Function }, sv);
let p4 = 0;
const xx = nt({ name: "Image", props: f4, slots: Object, inheritAttrs: false, setup(r) {
  const n = Ee(null), l = Ee(false), h = Ee(null), f = cr(bx, null), { mergedClsPrefixRef: y } = f || Cr(r), p = Ae(() => r.previewSrc || r.src), s = Ee(false), S = p4++, P = () => {
    if (r.previewDisabled || l.value) return;
    if (f) {
      f.setThumbnailEl(n.value), f.toggleShow(`r${S}`);
      return;
    }
    const { value: q } = h;
    q && (q.setThumbnailEl(n.value), s.value = true);
  }, M = { click: () => {
    P();
  }, showPreview: P }, A = Ee(!r.lazy);
  Ei(() => {
    var q;
    (q = n.value) === null || q === void 0 || q.setAttribute("data-group-id", (f == null ? void 0 : f.groupId) || "");
  }), Ei(() => {
    if (r.lazy && r.intersectionObserverOptions) {
      let q;
      const N = Ao(() => {
        q == null ? void 0 : q(), q = void 0, q = HP(n.value, r.intersectionObserverOptions, A);
      });
      Fn(() => {
        N(), q == null ? void 0 : q();
      });
    }
  }), Ao(() => {
    var q;
    r.src || ((q = r.imgProps) === null || q === void 0 || q.src), l.value = false;
  }), Ao((q) => {
    var N;
    const J = (N = f == null ? void 0 : f.registerImageUrl) === null || N === void 0 ? void 0 : N.call(f, S, p.value || "");
    q(() => {
      J == null ? void 0 : J();
    });
  });
  function O(q) {
    var N, J;
    M.showPreview(), (J = (N = r.imgProps) === null || N === void 0 ? void 0 : N.onClick) === null || J === void 0 || J.call(N, q);
  }
  function j() {
    s.value = false;
  }
  const L = Ee(false);
  return Vr(yx, { previewedImgPropsRef: zt(r, "previewedImgProps") }), Object.assign({ mergedClsPrefix: y, groupId: f == null ? void 0 : f.groupId, previewInstRef: h, imageRef: n, mergedPreviewSrc: p, showError: l, shouldStartLoading: A, loaded: L, mergedOnClick: (q) => {
    O(q);
  }, onPreviewClose: j, mergedOnError: (q) => {
    if (!A.value) return;
    l.value = true;
    const { onError: N, imgProps: { onError: J } = {} } = r;
    N == null ? void 0 : N(q), J == null ? void 0 : J(q);
  }, mergedOnLoad: (q) => {
    const { onLoad: N, imgProps: { onLoad: J } = {} } = r;
    N == null ? void 0 : N(q), J == null ? void 0 : J(q), L.value = true;
  }, previewShow: s }, M);
}, render() {
  var r, n;
  const { mergedClsPrefix: l, imgProps: h = {}, loaded: f, $attrs: y, lazy: p } = this, s = to(this.$slots.error, () => []), S = (n = (r = this.$slots).placeholder) === null || n === void 0 ? void 0 : n.call(r), P = this.src || h.src, M = this.showError && s.length ? s : B("img", Object.assign(Object.assign({}, h), { ref: "imageRef", width: this.width || h.width, height: this.height || h.height, src: this.showError ? this.fallbackSrc : p && this.intersectionObserverOptions ? this.shouldStartLoading ? P : void 0 : P, alt: this.alt || h.alt, "aria-label": this.alt || h.alt, onClick: this.mergedOnClick, onError: this.mergedOnError, onLoad: this.mergedOnLoad, loading: WP && p && !this.intersectionObserverOptions ? "lazy" : "eager", style: [h.style || "", S && !f ? { height: "0", width: "0", visibility: "hidden" } : "", { objectFit: this.objectFit }], "data-error": this.showError, "data-preview-src": this.previewSrc || this.src }));
  return B("div", Object.assign({}, y, { role: "none", class: [y.class, `${l}-image`, (this.previewDisabled || this.showError) && `${l}-image--preview-disabled`] }), this.groupId ? M : B(_x, { theme: this.theme, themeOverrides: this.themeOverrides, ref: "previewInstRef", showToolbar: this.showToolbar, showToolbarTooltip: this.showToolbarTooltip, renderToolbar: this.renderToolbar, src: this.mergedPreviewSrc, show: !this.previewDisabled && this.previewShow, onClose: this.onPreviewClose }, { default: () => M }), !f && S);
} }), m4 = qe([he("input-number-suffix", `
 display: inline-block;
 margin-right: 10px;
 `), he("input-number-prefix", `
 display: inline-block;
 margin-left: 10px;
 `)]);
function g4(r) {
  return r == null || typeof r == "string" && r.trim() === "" ? null : Number(r);
}
function v4(r) {
  return r.includes(".") && (/^(-)?\d+.*(\.|0)$/.test(r) || /^-?\d*$/.test(r)) || r === "-" || r === "-0";
}
function t0(r) {
  return r == null ? true : !Number.isNaN(r);
}
function eb(r, n) {
  return typeof r != "number" ? "" : n === void 0 ? String(r) : r.toFixed(n);
}
function r0(r) {
  if (r === null) return null;
  if (typeof r == "number") return r;
  {
    const n = Number(r);
    return Number.isNaN(n) ? null : n;
  }
}
const tb = 800, rb = 100, y4 = Object.assign(Object.assign({}, er.props), { autofocus: Boolean, loading: { type: Boolean, default: void 0 }, placeholder: String, defaultValue: { type: Number, default: null }, value: Number, step: { type: [Number, String], default: 1 }, min: [Number, String], max: [Number, String], size: String, disabled: { type: Boolean, default: void 0 }, validator: Function, bordered: { type: Boolean, default: void 0 }, showButton: { type: Boolean, default: true }, buttonPlacement: { type: String, default: "right" }, inputProps: Object, readonly: Boolean, clearable: Boolean, keyboard: { type: Object, default: {} }, updateValueOnInput: { type: Boolean, default: true }, round: { type: Boolean, default: void 0 }, parse: Function, format: Function, precision: Number, status: String, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onFocus: [Function, Array], onBlur: [Function, Array], onClear: [Function, Array], onChange: [Function, Array] }), ib = nt({ name: "InputNumber", props: y4, slots: Object, setup(r) {
  const { mergedBorderedRef: n, mergedClsPrefixRef: l, mergedRtlRef: h } = Cr(r), f = er("InputNumber", "-input-number", m4, K3, r, l), { localeRef: y } = ds("InputNumber"), p = Ba(r), { mergedSizeRef: s, mergedDisabledRef: S, mergedStatusRef: P } = p, M = Ee(null), A = Ee(null), O = Ee(null), j = Ee(r.defaultValue), L = zt(r, "value"), q = Qi(L, j), N = Ee(""), J = (gt) => {
    const Be = String(gt).split(".")[1];
    return Be ? Be.length : 0;
  }, te = (gt) => {
    const Be = [r.min, r.max, r.step, gt].map((ot) => ot === void 0 ? 0 : J(ot));
    return Math.max(...Be);
  }, ne = vi(() => {
    const { placeholder: gt } = r;
    return gt !== void 0 ? gt : y.value.placeholder;
  }), ae = vi(() => {
    const gt = r0(r.step);
    return gt !== null ? gt === 0 ? 1 : Math.abs(gt) : 1;
  }), oe = vi(() => {
    const gt = r0(r.min);
    return gt !== null ? gt : null;
  }), ee = vi(() => {
    const gt = r0(r.max);
    return gt !== null ? gt : null;
  }), ke = () => {
    const { value: gt } = q;
    if (t0(gt)) {
      const { format: Be, precision: ot } = r;
      Be ? N.value = Be(gt) : gt === null || ot === void 0 || J(gt) > ot ? N.value = eb(gt, void 0) : N.value = eb(gt, ot);
    } else N.value = String(gt);
  };
  ke();
  const ve = (gt) => {
    const { value: Be } = q;
    if (gt === Be) {
      ke();
      return;
    }
    const { "onUpdate:value": ot, onUpdateValue: $e, onChange: Ye } = r, { nTriggerFormInput: ht, nTriggerFormChange: St } = p;
    Ye && jt(Ye, gt), $e && jt($e, gt), ot && jt(ot, gt), j.value = gt, ht(), St();
  }, le = ({ offset: gt, doUpdateIfValid: Be, fixPrecision: ot, isInputing: $e }) => {
    const { value: Ye } = N;
    if ($e && v4(Ye)) return false;
    const ht = (r.parse || g4)(Ye);
    if (ht === null) return Be && ve(null), null;
    if (t0(ht)) {
      const St = J(ht), { precision: rt } = r;
      if (rt !== void 0 && rt < St && !ot) return false;
      let mt = Number.parseFloat((ht + gt).toFixed(rt ?? te(ht)));
      if (t0(mt)) {
        const { value: nr } = ee, { value: di } = oe;
        if (nr !== null && mt > nr) {
          if (!Be || $e) return false;
          mt = nr;
        }
        if (di !== null && mt < di) {
          if (!Be || $e) return false;
          mt = di;
        }
        return r.validator && !r.validator(mt) ? false : (Be && ve(mt), mt);
      }
    }
    return false;
  }, ue = vi(() => le({ offset: 0, doUpdateIfValid: false, isInputing: false, fixPrecision: false }) === false), be = vi(() => {
    const { value: gt } = q;
    if (r.validator && gt === null) return false;
    const { value: Be } = ae;
    return le({ offset: -Be, doUpdateIfValid: false, isInputing: false, fixPrecision: false }) !== false;
  }), Ve = vi(() => {
    const { value: gt } = q;
    if (r.validator && gt === null) return false;
    const { value: Be } = ae;
    return le({ offset: +Be, doUpdateIfValid: false, isInputing: false, fixPrecision: false }) !== false;
  });
  function Ge(gt) {
    const { onFocus: Be } = r, { nTriggerFormFocus: ot } = p;
    Be && jt(Be, gt), ot();
  }
  function et(gt) {
    var Be, ot;
    if (gt.target === ((Be = M.value) === null || Be === void 0 ? void 0 : Be.wrapperElRef)) return;
    const $e = le({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true });
    if ($e !== false) {
      const St = (ot = M.value) === null || ot === void 0 ? void 0 : ot.inputElRef;
      St && (St.value = String($e || "")), q.value === $e && ke();
    } else ke();
    const { onBlur: Ye } = r, { nTriggerFormBlur: ht } = p;
    Ye && jt(Ye, gt), ht(), eo(() => {
      ke();
    });
  }
  function dt(gt) {
    const { onClear: Be } = r;
    Be && jt(Be, gt);
  }
  function Ct() {
    const { value: gt } = Ve;
    if (!gt) {
      Zt();
      return;
    }
    const { value: Be } = q;
    if (Be === null) r.validator || ve(pt());
    else {
      const { value: ot } = ae;
      le({ offset: ot, doUpdateIfValid: true, isInputing: false, fixPrecision: true });
    }
  }
  function kt() {
    const { value: gt } = be;
    if (!gt) {
      bt();
      return;
    }
    const { value: Be } = q;
    if (Be === null) r.validator || ve(pt());
    else {
      const { value: ot } = ae;
      le({ offset: -ot, doUpdateIfValid: true, isInputing: false, fixPrecision: true });
    }
  }
  const ct = Ge, it = et;
  function pt() {
    if (r.validator) return null;
    const { value: gt } = oe, { value: Be } = ee;
    return gt !== null ? Math.max(0, gt) : Be !== null ? Math.min(0, Be) : 0;
  }
  function $t(gt) {
    dt(gt), ve(null);
  }
  function vt(gt) {
    var Be, ot, $e;
    !((Be = O.value) === null || Be === void 0) && Be.$el.contains(gt.target) && gt.preventDefault(), !((ot = A.value) === null || ot === void 0) && ot.$el.contains(gt.target) && gt.preventDefault(), ($e = M.value) === null || $e === void 0 || $e.activate();
  }
  let Pt = null, Nt = null, ir = null;
  function bt() {
    ir && (window.clearTimeout(ir), ir = null), Pt && (window.clearInterval(Pt), Pt = null);
  }
  let Dt = null;
  function Zt() {
    Dt && (window.clearTimeout(Dt), Dt = null), Nt && (window.clearInterval(Nt), Nt = null);
  }
  function dr() {
    bt(), ir = window.setTimeout(() => {
      Pt = window.setInterval(() => {
        kt();
      }, rb);
    }, tb), Un("mouseup", document, bt, { once: true });
  }
  function yr() {
    Zt(), Dt = window.setTimeout(() => {
      Nt = window.setInterval(() => {
        Ct();
      }, rb);
    }, tb), Un("mouseup", document, Zt, { once: true });
  }
  const Pr = () => {
    Nt || Ct();
  }, lr = () => {
    Pt || kt();
  };
  function Ir(gt) {
    var Be, ot;
    if (gt.key === "Enter") {
      if (gt.target === ((Be = M.value) === null || Be === void 0 ? void 0 : Be.wrapperElRef)) return;
      le({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true }) !== false && ((ot = M.value) === null || ot === void 0 || ot.deactivate());
    } else if (gt.key === "ArrowUp") {
      if (!Ve.value || r.keyboard.ArrowUp === false) return;
      gt.preventDefault(), le({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true }) !== false && Ct();
    } else if (gt.key === "ArrowDown") {
      if (!be.value || r.keyboard.ArrowDown === false) return;
      gt.preventDefault(), le({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true }) !== false && kt();
    }
  }
  function Ht(gt) {
    N.value = gt, r.updateValueOnInput && !r.format && !r.parse && r.precision === void 0 && le({ offset: 0, doUpdateIfValid: true, isInputing: true, fixPrecision: false });
  }
  Kt(q, () => {
    ke();
  });
  const Rr = { focus: () => {
    var gt;
    return (gt = M.value) === null || gt === void 0 ? void 0 : gt.focus();
  }, blur: () => {
    var gt;
    return (gt = M.value) === null || gt === void 0 ? void 0 : gt.blur();
  }, select: () => {
    var gt;
    return (gt = M.value) === null || gt === void 0 ? void 0 : gt.select();
  } }, xr = Ln("InputNumber", h, l);
  return Object.assign(Object.assign({}, Rr), { rtlEnabled: xr, inputInstRef: M, minusButtonInstRef: A, addButtonInstRef: O, mergedClsPrefix: l, mergedBordered: n, uncontrolledValue: j, mergedValue: q, mergedPlaceholder: ne, displayedValueInvalid: ue, mergedSize: s, mergedDisabled: S, displayedValue: N, addable: Ve, minusable: be, mergedStatus: P, handleFocus: ct, handleBlur: it, handleClear: $t, handleMouseDown: vt, handleAddClick: Pr, handleMinusClick: lr, handleAddMousedown: yr, handleMinusMousedown: dr, handleKeyDown: Ir, handleUpdateDisplayedValue: Ht, mergedTheme: f, inputThemeOverrides: { paddingSmall: "0 8px 0 10px", paddingMedium: "0 8px 0 12px", paddingLarge: "0 8px 0 14px" }, buttonThemeOverrides: Ae(() => {
    const { self: { iconColorDisabled: gt } } = f.value, [Be, ot, $e, Ye] = ua(gt);
    return { textColorTextDisabled: `rgb(${Be}, ${ot}, ${$e})`, opacityDisabled: `${Ye}` };
  }) });
}, render() {
  const { mergedClsPrefix: r, $slots: n } = this, l = () => B(T_, { text: true, disabled: !this.minusable || this.mergedDisabled || this.readonly, focusable: false, theme: this.mergedTheme.peers.Button, themeOverrides: this.mergedTheme.peerOverrides.Button, builtinThemeOverrides: this.buttonThemeOverrides, onClick: this.handleMinusClick, onMousedown: this.handleMinusMousedown, ref: "minusButtonInstRef" }, { icon: () => to(n["minus-icon"], () => [B(Nr, { clsPrefix: r }, { default: () => B(sP, null) })]) }), h = () => B(T_, { text: true, disabled: !this.addable || this.mergedDisabled || this.readonly, focusable: false, theme: this.mergedTheme.peers.Button, themeOverrides: this.mergedTheme.peerOverrides.Button, builtinThemeOverrides: this.buttonThemeOverrides, onClick: this.handleAddClick, onMousedown: this.handleAddMousedown, ref: "addButtonInstRef" }, { icon: () => to(n["add-icon"], () => [B(Nr, { clsPrefix: r }, { default: () => B(fm, null) })]) });
  return B("div", { class: [`${r}-input-number`, this.rtlEnabled && `${r}-input-number--rtl`] }, B(Do, { ref: "inputInstRef", autofocus: this.autofocus, status: this.mergedStatus, bordered: this.mergedBordered, loading: this.loading, value: this.displayedValue, onUpdateValue: this.handleUpdateDisplayedValue, theme: this.mergedTheme.peers.Input, themeOverrides: this.mergedTheme.peerOverrides.Input, builtinThemeOverrides: this.inputThemeOverrides, size: this.mergedSize, placeholder: this.mergedPlaceholder, disabled: this.mergedDisabled, readonly: this.readonly, round: this.round, textDecoration: this.displayedValueInvalid ? "line-through" : void 0, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeydown: this.handleKeyDown, onMousedown: this.handleMouseDown, onClear: this.handleClear, clearable: this.clearable, inputProps: this.inputProps, internalLoadingBeforeSuffix: true }, { prefix: () => {
    var f;
    return this.showButton && this.buttonPlacement === "both" ? [l(), oi(n.prefix, (y) => y ? B("span", { class: `${r}-input-number-prefix` }, y) : null)] : (f = n.prefix) === null || f === void 0 ? void 0 : f.call(n);
  }, suffix: () => {
    var f;
    return this.showButton ? [oi(n.suffix, (y) => y ? B("span", { class: `${r}-input-number-suffix` }, y) : null), this.buttonPlacement === "right" ? l() : null, h()] : (f = n.suffix) === null || f === void 0 ? void 0 : f.call(n);
  } }));
} }), _4 = qe([he("list", `
 --n-merged-border-color: var(--n-border-color);
 --n-merged-color: var(--n-color);
 --n-merged-color-hover: var(--n-color-hover);
 margin: 0;
 font-size: var(--n-font-size);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 padding: 0;
 list-style-type: none;
 color: var(--n-text-color);
 background-color: var(--n-merged-color);
 `, [Ue("show-divider", [he("list-item", [qe("&:not(:last-child)", [Le("divider", `
 background-color: var(--n-merged-border-color);
 `)])])]), Ue("clickable", [he("list-item", `
 cursor: pointer;
 `)]), Ue("bordered", `
 border: 1px solid var(--n-merged-border-color);
 border-radius: var(--n-border-radius);
 `), Ue("hoverable", [he("list-item", `
 border-radius: var(--n-border-radius);
 `, [qe("&:hover", `
 background-color: var(--n-merged-color-hover);
 `, [Le("divider", `
 background-color: transparent;
 `)])])]), Ue("bordered, hoverable", [he("list-item", `
 padding: 12px 20px;
 `), Le("header, footer", `
 padding: 12px 20px;
 `)]), Le("header, footer", `
 padding: 12px 0;
 box-sizing: border-box;
 transition: border-color .3s var(--n-bezier);
 `, [qe("&:not(:last-child)", `
 border-bottom: 1px solid var(--n-merged-border-color);
 `)]), he("list-item", `
 position: relative;
 padding: 12px 0; 
 box-sizing: border-box;
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [Le("prefix", `
 margin-right: 20px;
 flex: 0;
 `), Le("suffix", `
 margin-left: 20px;
 flex: 0;
 `), Le("main", `
 flex: 1;
 `), Le("divider", `
 height: 1px;
 position: absolute;
 bottom: 0;
 left: 0;
 right: 0;
 background-color: transparent;
 transition: background-color .3s var(--n-bezier);
 pointer-events: none;
 `)])]), a1(he("list", `
 --n-merged-color-hover: var(--n-color-hover-modal);
 --n-merged-color: var(--n-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 `)), s1(he("list", `
 --n-merged-color-hover: var(--n-color-hover-popover);
 --n-merged-color: var(--n-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 `))]), b4 = Object.assign(Object.assign({}, er.props), { size: { type: String, default: "medium" }, bordered: Boolean, clickable: Boolean, hoverable: Boolean, showDivider: { type: Boolean, default: true } }), wx = qn("n-list"), Nh = nt({ name: "List", props: b4, slots: Object, setup(r) {
  const { mergedClsPrefixRef: n, inlineThemeDisabled: l, mergedRtlRef: h } = Cr(r), f = Ln("List", h, n), y = er("List", "-list", _4, J3, r, n);
  Vr(wx, { showDividerRef: zt(r, "showDivider"), mergedClsPrefixRef: n });
  const p = Ae(() => {
    const { common: { cubicBezierEaseInOut: S }, self: { fontSize: P, textColor: M, color: A, colorModal: O, colorPopover: j, borderColor: L, borderColorModal: q, borderColorPopover: N, borderRadius: J, colorHover: te, colorHoverModal: ne, colorHoverPopover: ae } } = y.value;
    return { "--n-font-size": P, "--n-bezier": S, "--n-text-color": M, "--n-color": A, "--n-border-radius": J, "--n-border-color": L, "--n-border-color-modal": q, "--n-border-color-popover": N, "--n-color-modal": O, "--n-color-popover": j, "--n-color-hover": te, "--n-color-hover-modal": ne, "--n-color-hover-popover": ae };
  }), s = l ? ai("list", void 0, p, r) : void 0;
  return { mergedClsPrefix: n, rtlEnabled: f, cssVars: l ? void 0 : p, themeClass: s == null ? void 0 : s.themeClass, onRender: s == null ? void 0 : s.onRender };
}, render() {
  var r;
  const { $slots: n, mergedClsPrefix: l, onRender: h } = this;
  return h == null ? void 0 : h(), B("ul", { class: [`${l}-list`, this.rtlEnabled && `${l}-list--rtl`, this.bordered && `${l}-list--bordered`, this.showDivider && `${l}-list--show-divider`, this.hoverable && `${l}-list--hoverable`, this.clickable && `${l}-list--clickable`, this.themeClass], style: this.cssVars }, n.header ? B("div", { class: `${l}-list__header` }, n.header()) : null, (r = n.default) === null || r === void 0 ? void 0 : r.call(n), n.footer ? B("div", { class: `${l}-list__footer` }, n.footer()) : null);
} }), jh = nt({ name: "ListItem", slots: Object, setup() {
  const r = cr(wx, null);
  return r || fa("list-item", "`n-list-item` must be placed in `n-list`."), { showDivider: r.showDividerRef, mergedClsPrefix: r.mergedClsPrefixRef };
}, render() {
  const { $slots: r, mergedClsPrefix: n } = this;
  return B("li", { class: `${n}-list-item` }, r.prefix ? B("div", { class: `${n}-list-item__prefix` }, r.prefix()) : null, r.default ? B("div", { class: `${n}-list-item__main` }, r) : null, r.suffix ? B("div", { class: `${n}-list-item__suffix` }, r.suffix()) : null, this.showDivider && B("div", { class: `${n}-list-item__divider` }));
} }), Cx = qn("n-popconfirm"), Sx = { positiveText: String, negativeText: String, showIcon: { type: Boolean, default: true }, onPositiveClick: { type: Function, required: true }, onNegativeClick: { type: Function, required: true } }, nb = Ch(Sx), x4 = nt({ name: "NPopconfirmPanel", props: Sx, setup(r) {
  const { localeRef: n } = ds("Popconfirm"), { inlineThemeDisabled: l } = Cr(), { mergedClsPrefixRef: h, mergedThemeRef: f, props: y } = cr(Cx), p = Ae(() => {
    const { common: { cubicBezierEaseInOut: S }, self: { fontSize: P, iconSize: M, iconColor: A } } = f.value;
    return { "--n-bezier": S, "--n-font-size": P, "--n-icon-size": M, "--n-icon-color": A };
  }), s = l ? ai("popconfirm-panel", void 0, p, y) : void 0;
  return Object.assign(Object.assign({}, ds("Popconfirm")), { mergedClsPrefix: h, cssVars: l ? void 0 : p, localizedPositiveText: Ae(() => r.positiveText || n.value.positiveText), localizedNegativeText: Ae(() => r.negativeText || n.value.negativeText), positiveButtonProps: zt(y, "positiveButtonProps"), negativeButtonProps: zt(y, "negativeButtonProps"), handlePositiveClick(S) {
    r.onPositiveClick(S);
  }, handleNegativeClick(S) {
    r.onNegativeClick(S);
  }, themeClass: s == null ? void 0 : s.themeClass, onRender: s == null ? void 0 : s.onRender });
}, render() {
  var r;
  const { mergedClsPrefix: n, showIcon: l, $slots: h } = this, f = to(h.action, () => this.negativeText === null && this.positiveText === null ? [] : [this.negativeText !== null && B(Or, Object.assign({ size: "small", onClick: this.handleNegativeClick }, this.negativeButtonProps), { default: () => this.localizedNegativeText }), this.positiveText !== null && B(Or, Object.assign({ size: "small", type: "primary", onClick: this.handlePositiveClick }, this.positiveButtonProps), { default: () => this.localizedPositiveText })]);
  return (r = this.onRender) === null || r === void 0 || r.call(this), B("div", { class: [`${n}-popconfirm__panel`, this.themeClass], style: this.cssVars }, oi(h.default, (y) => l || y ? B("div", { class: `${n}-popconfirm__body` }, l ? B("div", { class: `${n}-popconfirm__icon` }, to(h.icon, () => [B(Nr, { clsPrefix: n }, { default: () => B(lm, null) })])) : null, y) : null), f ? B("div", { class: [`${n}-popconfirm__action`] }, f) : null);
} }), w4 = he("popconfirm", [Le("body", `
 font-size: var(--n-font-size);
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 position: relative;
 `, [Le("icon", `
 display: flex;
 font-size: var(--n-icon-size);
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 margin: 0 8px 0 0;
 `)]), Le("action", `
 display: flex;
 justify-content: flex-end;
 `, [qe("&:not(:first-child)", "margin-top: 8px"), he("button", [qe("&:not(:last-child)", "margin-right: 8px;")])])]), C4 = Object.assign(Object.assign(Object.assign({}, er.props), eS), { positiveText: String, negativeText: String, showIcon: { type: Boolean, default: true }, trigger: { type: String, default: "click" }, positiveButtonProps: Object, negativeButtonProps: Object, onPositiveClick: Function, onNegativeClick: Function }), S4 = nt({ name: "Popconfirm", props: C4, slots: Object, __popover__: true, setup(r) {
  const { mergedClsPrefixRef: n } = Cr(), l = er("Popconfirm", "-popconfirm", w4, Q3, r, n), h = Ee(null);
  function f(s) {
    var S;
    if (!(!((S = h.value) === null || S === void 0) && S.getMergedShow())) return;
    const { onPositiveClick: P, "onUpdate:show": M } = r;
    Promise.resolve(P ? P(s) : true).then((A) => {
      var O;
      A !== false && ((O = h.value) === null || O === void 0 || O.setShow(false), M && jt(M, false));
    });
  }
  function y(s) {
    var S;
    if (!(!((S = h.value) === null || S === void 0) && S.getMergedShow())) return;
    const { onNegativeClick: P, "onUpdate:show": M } = r;
    Promise.resolve(P ? P(s) : true).then((A) => {
      var O;
      A !== false && ((O = h.value) === null || O === void 0 || O.setShow(false), M && jt(M, false));
    });
  }
  return Vr(Cx, { mergedThemeRef: l, mergedClsPrefixRef: n, props: r }), { setShow(s) {
    var S;
    (S = h.value) === null || S === void 0 || S.setShow(s);
  }, syncPosition() {
    var s;
    (s = h.value) === null || s === void 0 || s.syncPosition();
  }, mergedTheme: l, popoverInstRef: h, handlePositiveClick: f, handleNegativeClick: y };
}, render() {
  const { $slots: r, $props: n, mergedTheme: l } = this;
  return B(K0, Object.assign({}, b1(n, nb), { theme: l.peers.Popover, themeOverrides: l.peerOverrides.Popover, internalExtraClass: ["popconfirm"], ref: "popoverInstRef" }), { trigger: r.trigger, default: () => {
    const h = _0(n, nb);
    return B(x4, Object.assign({}, h, { onPositiveClick: this.handlePositiveClick, onNegativeClick: this.handleNegativeClick }), r);
  } });
} }), k4 = { success: B(ev, null), error: B(J0, null), warning: B(lm, null), info: B(Q0, null) }, T4 = nt({ name: "ProgressCircle", props: { clsPrefix: { type: String, required: true }, status: { type: String, required: true }, strokeWidth: { type: Number, required: true }, fillColor: [String, Object], railColor: String, railStyle: [String, Object], percentage: { type: Number, default: 0 }, offsetDegree: { type: Number, default: 0 }, showIndicator: { type: Boolean, required: true }, indicatorTextColor: String, unit: String, viewBoxWidth: { type: Number, required: true }, gapDegree: { type: Number, required: true }, gapOffsetDegree: { type: Number, default: 0 } }, setup(r, { slots: n }) {
  const l = Ae(() => {
    const y = "gradient", { fillColor: p } = r;
    return typeof p == "object" ? `${y}-${tS(JSON.stringify(p))}` : y;
  });
  function h(y, p, s, S) {
    const { gapDegree: P, viewBoxWidth: M, strokeWidth: A } = r, O = 50, j = 0, L = O, q = 0, N = 2 * O, J = 50 + A / 2, te = `M ${J},${J} m ${j},${L}
      a ${O},${O} 0 1 1 ${q},${-N}
      a ${O},${O} 0 1 1 ${-q},${N}`, ne = Math.PI * 2 * O, ae = { stroke: S === "rail" ? s : typeof r.fillColor == "object" ? `url(#${l.value})` : s, strokeDasharray: `${y / 100 * (ne - P)}px ${M * 8}px`, strokeDashoffset: `-${P / 2}px`, transformOrigin: p ? "center" : void 0, transform: p ? `rotate(${p}deg)` : void 0 };
    return { pathString: te, pathStyle: ae };
  }
  const f = () => {
    const y = typeof r.fillColor == "object", p = y ? r.fillColor.stops[0] : "", s = y ? r.fillColor.stops[1] : "";
    return y && B("defs", null, B("linearGradient", { id: l.value, x1: "0%", y1: "100%", x2: "100%", y2: "0%" }, B("stop", { offset: "0%", "stop-color": p }), B("stop", { offset: "100%", "stop-color": s })));
  };
  return () => {
    const { fillColor: y, railColor: p, strokeWidth: s, offsetDegree: S, status: P, percentage: M, showIndicator: A, indicatorTextColor: O, unit: j, gapOffsetDegree: L, clsPrefix: q } = r, { pathString: N, pathStyle: J } = h(100, 0, p, "rail"), { pathString: te, pathStyle: ne } = h(M, S, y, "fill"), ae = 100 + s;
    return B("div", { class: `${q}-progress-content`, role: "none" }, B("div", { class: `${q}-progress-graph`, "aria-hidden": true }, B("div", { class: `${q}-progress-graph-circle`, style: { transform: L ? `rotate(${L}deg)` : void 0 } }, B("svg", { viewBox: `0 0 ${ae} ${ae}` }, f(), B("g", null, B("path", { class: `${q}-progress-graph-circle-rail`, d: N, "stroke-width": s, "stroke-linecap": "round", fill: "none", style: J })), B("g", null, B("path", { class: [`${q}-progress-graph-circle-fill`, M === 0 && `${q}-progress-graph-circle-fill--empty`], d: te, "stroke-width": s, "stroke-linecap": "round", fill: "none", style: ne }))))), A ? B("div", null, n.default ? B("div", { class: `${q}-progress-custom-content`, role: "none" }, n.default()) : P !== "default" ? B("div", { class: `${q}-progress-icon`, "aria-hidden": true }, B(Nr, { clsPrefix: q }, { default: () => k4[P] })) : B("div", { class: `${q}-progress-text`, style: { color: O }, role: "none" }, B("span", { class: `${q}-progress-text__percentage` }, M), B("span", { class: `${q}-progress-text__unit` }, j))) : null);
  };
} }), P4 = { success: B(ev, null), error: B(J0, null), warning: B(lm, null), info: B(Q0, null) }, I4 = nt({ name: "ProgressLine", props: { clsPrefix: { type: String, required: true }, percentage: { type: Number, default: 0 }, railColor: String, railStyle: [String, Object], fillColor: [String, Object], status: { type: String, required: true }, indicatorPlacement: { type: String, required: true }, indicatorTextColor: String, unit: { type: String, default: "%" }, processing: { type: Boolean, required: true }, showIndicator: { type: Boolean, required: true }, height: [String, Number], railBorderRadius: [String, Number], fillBorderRadius: [String, Number] }, setup(r, { slots: n }) {
  const l = Ae(() => ca(r.height)), h = Ae(() => {
    var p, s;
    return typeof r.fillColor == "object" ? `linear-gradient(to right, ${(p = r.fillColor) === null || p === void 0 ? void 0 : p.stops[0]} , ${(s = r.fillColor) === null || s === void 0 ? void 0 : s.stops[1]})` : r.fillColor;
  }), f = Ae(() => r.railBorderRadius !== void 0 ? ca(r.railBorderRadius) : r.height !== void 0 ? ca(r.height, { c: 0.5 }) : ""), y = Ae(() => r.fillBorderRadius !== void 0 ? ca(r.fillBorderRadius) : r.railBorderRadius !== void 0 ? ca(r.railBorderRadius) : r.height !== void 0 ? ca(r.height, { c: 0.5 }) : "");
  return () => {
    const { indicatorPlacement: p, railColor: s, railStyle: S, percentage: P, unit: M, indicatorTextColor: A, status: O, showIndicator: j, processing: L, clsPrefix: q } = r;
    return B("div", { class: `${q}-progress-content`, role: "none" }, B("div", { class: `${q}-progress-graph`, "aria-hidden": true }, B("div", { class: [`${q}-progress-graph-line`, { [`${q}-progress-graph-line--indicator-${p}`]: true }] }, B("div", { class: `${q}-progress-graph-line-rail`, style: [{ backgroundColor: s, height: l.value, borderRadius: f.value }, S] }, B("div", { class: [`${q}-progress-graph-line-fill`, L && `${q}-progress-graph-line-fill--processing`], style: { maxWidth: `${r.percentage}%`, background: h.value, height: l.value, lineHeight: l.value, borderRadius: y.value } }, p === "inside" ? B("div", { class: `${q}-progress-graph-line-indicator`, style: { color: A } }, n.default ? n.default() : `${P}${M}`) : null)))), j && p === "outside" ? B("div", null, n.default ? B("div", { class: `${q}-progress-custom-content`, style: { color: A }, role: "none" }, n.default()) : O === "default" ? B("div", { role: "none", class: `${q}-progress-icon ${q}-progress-icon--as-text`, style: { color: A } }, P, M) : B("div", { class: `${q}-progress-icon`, "aria-hidden": true }, B(Nr, { clsPrefix: q }, { default: () => P4[O] }))) : null);
  };
} });
function ob(r, n, l = 100) {
  return `m ${l / 2} ${l / 2 - r} a ${r} ${r} 0 1 1 0 ${2 * r} a ${r} ${r} 0 1 1 0 -${2 * r}`;
}
const E4 = nt({ name: "ProgressMultipleCircle", props: { clsPrefix: { type: String, required: true }, viewBoxWidth: { type: Number, required: true }, percentage: { type: Array, default: [0] }, strokeWidth: { type: Number, required: true }, circleGap: { type: Number, required: true }, showIndicator: { type: Boolean, required: true }, fillColor: { type: Array, default: () => [] }, railColor: { type: Array, default: () => [] }, railStyle: { type: Array, default: () => [] } }, setup(r, { slots: n }) {
  const l = Ae(() => r.percentage.map((y, p) => `${Math.PI * y / 100 * (r.viewBoxWidth / 2 - r.strokeWidth / 2 * (1 + 2 * p) - r.circleGap * p) * 2}, ${r.viewBoxWidth * 8}`)), h = (f, y) => {
    const p = r.fillColor[y], s = typeof p == "object" ? p.stops[0] : "", S = typeof p == "object" ? p.stops[1] : "";
    return typeof r.fillColor[y] == "object" && B("linearGradient", { id: `gradient-${y}`, x1: "100%", y1: "0%", x2: "0%", y2: "100%" }, B("stop", { offset: "0%", "stop-color": s }), B("stop", { offset: "100%", "stop-color": S }));
  };
  return () => {
    const { viewBoxWidth: f, strokeWidth: y, circleGap: p, showIndicator: s, fillColor: S, railColor: P, railStyle: M, percentage: A, clsPrefix: O } = r;
    return B("div", { class: `${O}-progress-content`, role: "none" }, B("div", { class: `${O}-progress-graph`, "aria-hidden": true }, B("div", { class: `${O}-progress-graph-circle` }, B("svg", { viewBox: `0 0 ${f} ${f}` }, B("defs", null, A.map((j, L) => h(j, L))), A.map((j, L) => B("g", { key: L }, B("path", { class: `${O}-progress-graph-circle-rail`, d: ob(f / 2 - y / 2 * (1 + 2 * L) - p * L, y, f), "stroke-width": y, "stroke-linecap": "round", fill: "none", style: [{ strokeDashoffset: 0, stroke: P[L] }, M[L]] }), B("path", { class: [`${O}-progress-graph-circle-fill`, j === 0 && `${O}-progress-graph-circle-fill--empty`], d: ob(f / 2 - y / 2 * (1 + 2 * L) - p * L, y, f), "stroke-width": y, "stroke-linecap": "round", fill: "none", style: { strokeDasharray: l.value[L], strokeDashoffset: 0, stroke: typeof S[L] == "object" ? `url(#gradient-${L})` : S[L] } })))))), s && n.default ? B("div", null, B("div", { class: `${O}-progress-text` }, n.default())) : null);
  };
} }), M4 = qe([he("progress", { display: "inline-block" }, [he("progress-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 `), Ue("line", `
 width: 100%;
 display: block;
 `, [he("progress-content", `
 display: flex;
 align-items: center;
 `, [he("progress-graph", { flex: 1 })]), he("progress-custom-content", { marginLeft: "14px" }), he("progress-icon", `
 width: 30px;
 padding-left: 14px;
 height: var(--n-icon-size-line);
 line-height: var(--n-icon-size-line);
 font-size: var(--n-icon-size-line);
 `, [Ue("as-text", `
 color: var(--n-text-color-line-outer);
 text-align: center;
 width: 40px;
 font-size: var(--n-font-size);
 padding-left: 4px;
 transition: color .3s var(--n-bezier);
 `)])]), Ue("circle, dashboard", { width: "120px" }, [he("progress-custom-content", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `), he("progress-text", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: inherit;
 font-size: var(--n-font-size-circle);
 color: var(--n-text-color-circle);
 font-weight: var(--n-font-weight-circle);
 transition: color .3s var(--n-bezier);
 white-space: nowrap;
 `), he("progress-icon", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: var(--n-icon-color);
 font-size: var(--n-icon-size-circle);
 `)]), Ue("multiple-circle", `
 width: 200px;
 color: inherit;
 `, [he("progress-text", `
 font-weight: var(--n-font-weight-circle);
 color: var(--n-text-color-circle);
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `)]), he("progress-content", { position: "relative" }), he("progress-graph", { position: "relative" }, [he("progress-graph-circle", [qe("svg", { verticalAlign: "bottom" }), he("progress-graph-circle-fill", `
 stroke: var(--n-fill-color);
 transition:
 opacity .3s var(--n-bezier),
 stroke .3s var(--n-bezier),
 stroke-dasharray .3s var(--n-bezier);
 `, [Ue("empty", { opacity: 0 })]), he("progress-graph-circle-rail", `
 transition: stroke .3s var(--n-bezier);
 overflow: hidden;
 stroke: var(--n-rail-color);
 `)]), he("progress-graph-line", [Ue("indicator-inside", [he("progress-graph-line-rail", `
 height: 16px;
 line-height: 16px;
 border-radius: 10px;
 `, [he("progress-graph-line-fill", `
 height: inherit;
 border-radius: 10px;
 `), he("progress-graph-line-indicator", `
 background: #0000;
 white-space: nowrap;
 text-align: right;
 margin-left: 14px;
 margin-right: 14px;
 height: inherit;
 font-size: 12px;
 color: var(--n-text-color-line-inner);
 transition: color .3s var(--n-bezier);
 `)])]), Ue("indicator-inside-label", `
 height: 16px;
 display: flex;
 align-items: center;
 `, [he("progress-graph-line-rail", `
 flex: 1;
 transition: background-color .3s var(--n-bezier);
 `), he("progress-graph-line-indicator", `
 background: var(--n-fill-color);
 font-size: 12px;
 transform: translateZ(0);
 display: flex;
 vertical-align: middle;
 height: 16px;
 line-height: 16px;
 padding: 0 10px;
 border-radius: 10px;
 position: absolute;
 white-space: nowrap;
 color: var(--n-text-color-line-inner);
 transition:
 right .2s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `)]), he("progress-graph-line-rail", `
 position: relative;
 overflow: hidden;
 height: var(--n-rail-height);
 border-radius: 5px;
 background-color: var(--n-rail-color);
 transition: background-color .3s var(--n-bezier);
 `, [he("progress-graph-line-fill", `
 background: var(--n-fill-color);
 position: relative;
 border-radius: 5px;
 height: inherit;
 width: 100%;
 max-width: 0%;
 transition:
 background-color .3s var(--n-bezier),
 max-width .2s var(--n-bezier);
 `, [Ue("processing", [qe("&::after", `
 content: "";
 background-image: var(--n-line-bg-processing);
 animation: progress-processing-animation 2s var(--n-bezier) infinite;
 `)])])])])])]), qe("@keyframes progress-processing-animation", `
 0% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 100%;
 opacity: 1;
 }
 66% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 100% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 `)]), D4 = Object.assign(Object.assign({}, er.props), { processing: Boolean, type: { type: String, default: "line" }, gapDegree: Number, gapOffsetDegree: Number, status: { type: String, default: "default" }, railColor: [String, Array], railStyle: [String, Array], color: [String, Array, Object], viewBoxWidth: { type: Number, default: 100 }, strokeWidth: { type: Number, default: 7 }, percentage: [Number, Array], unit: { type: String, default: "%" }, showIndicator: { type: Boolean, default: true }, indicatorPosition: { type: String, default: "outside" }, indicatorPlacement: { type: String, default: "outside" }, indicatorTextColor: String, circleGap: { type: Number, default: 1 }, height: Number, borderRadius: [String, Number], fillBorderRadius: [String, Number], offsetDegree: Number }), R4 = nt({ name: "Progress", props: D4, setup(r) {
  const n = Ae(() => r.indicatorPlacement || r.indicatorPosition), l = Ae(() => {
    if (r.gapDegree || r.gapDegree === 0) return r.gapDegree;
    if (r.type === "dashboard") return 75;
  }), { mergedClsPrefixRef: h, inlineThemeDisabled: f } = Cr(r), y = er("Progress", "-progress", M4, rS, r, h), p = Ae(() => {
    const { status: S } = r, { common: { cubicBezierEaseInOut: P }, self: { fontSize: M, fontSizeCircle: A, railColor: O, railHeight: j, iconSizeCircle: L, iconSizeLine: q, textColorCircle: N, textColorLineInner: J, textColorLineOuter: te, lineBgProcessing: ne, fontWeightCircle: ae, [Ut("iconColor", S)]: oe, [Ut("fillColor", S)]: ee } } = y.value;
    return { "--n-bezier": P, "--n-fill-color": ee, "--n-font-size": M, "--n-font-size-circle": A, "--n-font-weight-circle": ae, "--n-icon-color": oe, "--n-icon-size-circle": L, "--n-icon-size-line": q, "--n-line-bg-processing": ne, "--n-rail-color": O, "--n-rail-height": j, "--n-text-color-circle": N, "--n-text-color-line-inner": J, "--n-text-color-line-outer": te };
  }), s = f ? ai("progress", Ae(() => r.status[0]), p, r) : void 0;
  return { mergedClsPrefix: h, mergedIndicatorPlacement: n, gapDeg: l, cssVars: f ? void 0 : p, themeClass: s == null ? void 0 : s.themeClass, onRender: s == null ? void 0 : s.onRender };
}, render() {
  const { type: r, cssVars: n, indicatorTextColor: l, showIndicator: h, status: f, railColor: y, railStyle: p, color: s, percentage: S, viewBoxWidth: P, strokeWidth: M, mergedIndicatorPlacement: A, unit: O, borderRadius: j, fillBorderRadius: L, height: q, processing: N, circleGap: J, mergedClsPrefix: te, gapDeg: ne, gapOffsetDegree: ae, themeClass: oe, $slots: ee, onRender: ke } = this;
  return ke == null ? void 0 : ke(), B("div", { class: [oe, `${te}-progress`, `${te}-progress--${r}`, `${te}-progress--${f}`], style: n, "aria-valuemax": 100, "aria-valuemin": 0, "aria-valuenow": S, role: r === "circle" || r === "line" || r === "dashboard" ? "progressbar" : "none" }, r === "circle" || r === "dashboard" ? B(T4, { clsPrefix: te, status: f, showIndicator: h, indicatorTextColor: l, railColor: y, fillColor: s, railStyle: p, offsetDegree: this.offsetDegree, percentage: S, viewBoxWidth: P, strokeWidth: M, gapDegree: ne === void 0 ? r === "dashboard" ? 75 : 0 : ne, gapOffsetDegree: ae, unit: O }, ee) : r === "line" ? B(I4, { clsPrefix: te, status: f, showIndicator: h, indicatorTextColor: l, railColor: y, fillColor: s, railStyle: p, percentage: S, processing: N, indicatorPlacement: A, unit: O, fillBorderRadius: L, railBorderRadius: j, height: q }, ee) : r === "multiple-circle" ? B(E4, { clsPrefix: te, strokeWidth: M, railColor: y, fillColor: s, railStyle: p, viewBoxWidth: P, percentage: S, showIndicator: h, circleGap: J }, ee) : null);
} }), A4 = qe([qe("@keyframes spin-rotate", `
 from {
 transform: rotate(0);
 }
 to {
 transform: rotate(360deg);
 }
 `), he("spin-container", `
 position: relative;
 `, [he("spin-body", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [Zp()])]), he("spin-body", `
 display: inline-flex;
 align-items: center;
 justify-content: center;
 flex-direction: column;
 `), he("spin", `
 display: inline-flex;
 height: var(--n-size);
 width: var(--n-size);
 font-size: var(--n-size);
 color: var(--n-color);
 `, [Ue("rotate", `
 animation: spin-rotate 2s linear infinite;
 `)]), he("spin-description", `
 display: inline-block;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 margin-top: 8px;
 `), he("spin-content", `
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 pointer-events: all;
 `, [Ue("spinning", `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: none;
 opacity: var(--n-opacity-spinning);
 `)])]), z4 = { small: 20, medium: 18, large: 16 }, F4 = Object.assign(Object.assign({}, er.props), { contentClass: String, contentStyle: [Object, String], description: String, stroke: String, size: { type: [String, Number], default: "medium" }, show: { type: Boolean, default: true }, strokeWidth: Number, rotate: { type: Boolean, default: true }, spinning: { type: Boolean, validator: () => true, default: void 0 }, delay: Number }), L4 = nt({ name: "Spin", props: F4, slots: Object, setup(r) {
  const { mergedClsPrefixRef: n, inlineThemeDisabled: l } = Cr(r), h = er("Spin", "-spin", A4, iS, r, n), f = Ae(() => {
    const { size: S } = r, { common: { cubicBezierEaseInOut: P }, self: M } = h.value, { opacitySpinning: A, color: O, textColor: j } = M, L = typeof S == "number" ? Qn(S) : M[Ut("size", S)];
    return { "--n-bezier": P, "--n-opacity-spinning": A, "--n-size": L, "--n-color": O, "--n-text-color": j };
  }), y = l ? ai("spin", Ae(() => {
    const { size: S } = r;
    return typeof S == "number" ? String(S) : S[0];
  }), f, r) : void 0, p = Wp(r, ["spinning", "show"]), s = Ee(false);
  return Ao((S) => {
    let P;
    if (p.value) {
      const { delay: M } = r;
      if (M) {
        P = window.setTimeout(() => {
          s.value = true;
        }, M), S(() => {
          clearTimeout(P);
        });
        return;
      }
    }
    s.value = p.value;
  }), { mergedClsPrefix: n, active: s, mergedStrokeWidth: Ae(() => {
    const { strokeWidth: S } = r;
    if (S !== void 0) return S;
    const { size: P } = r;
    return z4[typeof P == "number" ? "medium" : P];
  }), cssVars: l ? void 0 : f, themeClass: y == null ? void 0 : y.themeClass, onRender: y == null ? void 0 : y.onRender };
}, render() {
  var r, n;
  const { $slots: l, mergedClsPrefix: h, description: f } = this, y = l.icon && this.rotate, p = (f || l.description) && B("div", { class: `${h}-spin-description` }, f || ((r = l.description) === null || r === void 0 ? void 0 : r.call(l))), s = l.icon ? B("div", { class: [`${h}-spin-body`, this.themeClass] }, B("div", { class: [`${h}-spin`, y && `${h}-spin--rotate`], style: l.default ? "" : this.cssVars }, l.icon()), p) : B("div", { class: [`${h}-spin-body`, this.themeClass] }, B(om, { clsPrefix: h, style: l.default ? "" : this.cssVars, stroke: this.stroke, "stroke-width": this.mergedStrokeWidth, class: `${h}-spin` }), p);
  return (n = this.onRender) === null || n === void 0 || n.call(this), l.default ? B("div", { class: [`${h}-spin-container`, this.themeClass], style: this.cssVars }, B("div", { class: [`${h}-spin-content`, this.active && `${h}-spin-content--spinning`, this.contentClass], style: this.contentStyle }, l), B(Wo, { name: "fade-in-transition" }, { default: () => this.active ? s : null })) : s;
} }), B4 = he("split", `
 display: flex;
 width: 100%;
 height: 100%;
`, [Ue("horizontal", `
 flex-direction: row;
 `), Ue("vertical", `
 flex-direction: column;
 `), he("split-pane-1", `
 overflow: hidden;
 `), he("split-pane-2", `
 overflow: hidden;
 flex: 1;
 `), Le("resize-trigger", `
 background-color: var(--n-resize-trigger-color);
 transition: background-color .3s var(--n-bezier);
 `, [Ue("hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `), qe("&:hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `)])]), O4 = Object.assign(Object.assign({}, er.props), { direction: { type: String, default: "horizontal" }, resizeTriggerSize: { type: Number, default: 3 }, disabled: Boolean, defaultSize: { type: [String, Number], default: 0.5 }, "onUpdate:size": [Function, Array], onUpdateSize: [Function, Array], size: [String, Number], min: { type: [String, Number], default: 0 }, max: { type: [String, Number], default: 1 }, pane1Class: String, pane1Style: [Object, String], pane2Class: String, pane2Style: [Object, String], onDragStart: Function, onDragMove: Function, onDragEnd: Function, watchProps: Array }), ab = nt({ name: "Split", props: O4, slots: Object, setup(r) {
  var n;
  const { mergedClsPrefixRef: l, inlineThemeDisabled: h } = Cr(r), f = er("Split", "-split", B4, nS, r, l), y = Ae(() => {
    const { common: { cubicBezierEaseInOut: ne }, self: { resizableTriggerColor: ae, resizableTriggerColorHover: oe } } = f.value;
    return { "--n-bezier": ne, "--n-resize-trigger-color": ae, "--n-resize-trigger-color-hover": oe };
  }), p = Ee(null), s = Ee(false), S = zt(r, "size"), P = Ee(r.defaultSize);
  !((n = r.watchProps) === null || n === void 0) && n.includes("defaultSize") && Ao(() => P.value = r.defaultSize);
  const M = (ne) => {
    const ae = r["onUpdate:size"];
    r.onUpdateSize && jt(r.onUpdateSize, ne), ae && jt(ae, ne), P.value = ne;
  }, A = Qi(S, P), O = Ae(() => {
    const ne = A.value;
    if (typeof ne == "string") return { flex: `0 0 ${ne}` };
    if (typeof ne == "number") {
      const ae = ne * 100;
      return { flex: `0 0 calc(${ae}% - ${r.resizeTriggerSize * ae / 100}px)` };
    }
  }), j = Ae(() => r.direction === "horizontal" ? { width: `${r.resizeTriggerSize}px`, height: "100%" } : { width: "100%", height: `${r.resizeTriggerSize}px` }), L = Ae(() => {
    const ne = r.direction === "horizontal";
    return { width: ne ? `${r.resizeTriggerSize}px` : "", height: ne ? "" : `${r.resizeTriggerSize}px`, cursor: r.direction === "horizontal" ? "col-resize" : "row-resize" };
  });
  let q = 0;
  const N = (ne) => {
    ne.preventDefault(), s.value = true, r.onDragStart && r.onDragStart(ne);
    const ae = "mousemove", oe = "mouseup", ee = (le) => {
      J(le), r.onDragMove && r.onDragMove(le);
    }, ke = () => {
      co(ae, document, ee), co(oe, document, ke), s.value = false, r.onDragEnd && r.onDragEnd(ne), document.body.style.cursor = "";
    };
    document.body.style.cursor = L.value.cursor, Un(ae, document, ee), Un(oe, document, ke);
    const ve = p.value;
    if (ve) {
      const le = ve.getBoundingClientRect();
      r.direction === "horizontal" ? q = ne.clientX - le.left : q = le.top - ne.clientY;
    }
    J(ne);
  };
  function J(ne) {
    var ae, oe;
    const ee = (oe = (ae = p.value) === null || ae === void 0 ? void 0 : ae.parentElement) === null || oe === void 0 ? void 0 : oe.getBoundingClientRect();
    if (!ee) return;
    const { direction: ke } = r, ve = ee.width - r.resizeTriggerSize, le = ee.height - r.resizeTriggerSize, ue = ke === "horizontal" ? ve : le, be = ke === "horizontal" ? ne.clientX - ee.left - q : ne.clientY - ee.top + q, { min: Ve, max: Ge } = r, et = typeof Ve == "string" ? ln(Ve) : Ve * ue, dt = typeof Ge == "string" ? ln(Ge) : Ge * ue;
    let Ct = be;
    Ct = Math.max(Ct, et), Ct = Math.min(Ct, dt, ue), typeof A.value == "string" ? M(`${Ct}px`) : M(Ct / ue);
  }
  const te = h ? ai("split", void 0, y, r) : void 0;
  return { themeClass: te == null ? void 0 : te.themeClass, onRender: te == null ? void 0 : te.onRender, cssVars: h ? void 0 : y, resizeTriggerElRef: p, isDragging: s, mergedClsPrefix: l, resizeTriggerWrapperStyle: L, resizeTriggerStyle: j, handleMouseDown: N, firstPaneStyle: O };
}, render() {
  var r, n, l, h, f;
  return (r = this.onRender) === null || r === void 0 || r.call(this), B("div", { class: [`${this.mergedClsPrefix}-split`, `${this.mergedClsPrefix}-split--${this.direction}`, this.themeClass], style: this.cssVars }, B("div", { class: [`${this.mergedClsPrefix}-split-pane-1`, this.pane1Class], style: [this.firstPaneStyle, this.pane1Style] }, (l = (n = this.$slots)[1]) === null || l === void 0 ? void 0 : l.call(n)), !this.disabled && B("div", { ref: "resizeTriggerElRef", class: `${this.mergedClsPrefix}-split__resize-trigger-wrapper`, style: this.resizeTriggerWrapperStyle, onMousedown: this.handleMouseDown }, to(this.$slots["resize-trigger"], () => [B("div", { style: this.resizeTriggerStyle, class: [`${this.mergedClsPrefix}-split__resize-trigger`, this.isDragging && `${this.mergedClsPrefix}-split__resize-trigger--hover`] })])), B("div", { class: [`${this.mergedClsPrefix}-split-pane-2`, this.pane2Class], style: this.pane2Style }, (f = (h = this.$slots)[2]) === null || f === void 0 ? void 0 : f.call(h)));
} }), $4 = he("statistic", [Le("label", `
 font-weight: var(--n-label-font-weight);
 transition: .3s color var(--n-bezier);
 font-size: var(--n-label-font-size);
 color: var(--n-label-text-color);
 `), he("statistic-value", `
 margin-top: 4px;
 font-weight: var(--n-value-font-weight);
 `, [Le("prefix", `
 margin: 0 4px 0 0;
 font-size: var(--n-value-font-size);
 transition: .3s color var(--n-bezier);
 color: var(--n-value-prefix-text-color);
 `, [he("icon", { verticalAlign: "-0.125em" })]), Le("content", `
 font-size: var(--n-value-font-size);
 transition: .3s color var(--n-bezier);
 color: var(--n-value-text-color);
 `), Le("suffix", `
 margin: 0 0 0 4px;
 font-size: var(--n-value-font-size);
 transition: .3s color var(--n-bezier);
 color: var(--n-value-suffix-text-color);
 `, [he("icon", { verticalAlign: "-0.125em" })])])]), N4 = Object.assign(Object.assign({}, er.props), { tabularNums: Boolean, label: String, value: [String, Number] }), sn = nt({ name: "Statistic", props: N4, slots: Object, setup(r) {
  const { mergedClsPrefixRef: n, inlineThemeDisabled: l, mergedRtlRef: h } = Cr(r), f = er("Statistic", "-statistic", $4, oS, r, n), y = Ln("Statistic", h, n), p = Ae(() => {
    const { self: { labelFontWeight: S, valueFontSize: P, valueFontWeight: M, valuePrefixTextColor: A, labelTextColor: O, valueSuffixTextColor: j, valueTextColor: L, labelFontSize: q }, common: { cubicBezierEaseInOut: N } } = f.value;
    return { "--n-bezier": N, "--n-label-font-size": q, "--n-label-font-weight": S, "--n-label-text-color": O, "--n-value-font-weight": M, "--n-value-font-size": P, "--n-value-prefix-text-color": A, "--n-value-suffix-text-color": j, "--n-value-text-color": L };
  }), s = l ? ai("statistic", void 0, p, r) : void 0;
  return { rtlEnabled: y, mergedClsPrefix: n, cssVars: l ? void 0 : p, themeClass: s == null ? void 0 : s.themeClass, onRender: s == null ? void 0 : s.onRender };
}, render() {
  var r;
  const { mergedClsPrefix: n, $slots: { default: l, label: h, prefix: f, suffix: y } } = this;
  return (r = this.onRender) === null || r === void 0 || r.call(this), B("div", { class: [`${n}-statistic`, this.themeClass, this.rtlEnabled && `${n}-statistic--rtl`], style: this.cssVars }, oi(h, (p) => B("div", { class: `${n}-statistic__label` }, this.label || p)), B("div", { class: `${n}-statistic-value`, style: { fontVariantNumeric: this.tabularNums ? "tabular-nums" : "" } }, oi(f, (p) => p && B("span", { class: `${n}-statistic-value__prefix` }, p)), this.value !== void 0 ? B("span", { class: `${n}-statistic-value__content` }, this.value) : oi(l, (p) => p && B("span", { class: `${n}-statistic-value__content` }, p)), oi(y, (p) => p && B("span", { class: `${n}-statistic-value__suffix` }, p))));
} }), j4 = he("switch", `
 height: var(--n-height);
 min-width: var(--n-width);
 vertical-align: middle;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 outline: none;
 justify-content: center;
 align-items: center;
`, [Le("children-placeholder", `
 height: var(--n-rail-height);
 display: flex;
 flex-direction: column;
 overflow: hidden;
 pointer-events: none;
 visibility: hidden;
 `), Le("rail-placeholder", `
 display: flex;
 flex-wrap: none;
 `), Le("button-placeholder", `
 width: calc(1.75 * var(--n-rail-height));
 height: var(--n-rail-height);
 `), he("base-loading", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 font-size: calc(var(--n-button-width) - 4px);
 color: var(--n-loading-color);
 transition: color .3s var(--n-bezier);
 `, [Sh({ left: "50%", top: "50%", originalTransform: "translateX(-50%) translateY(-50%)" })]), Le("checked, unchecked", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 box-sizing: border-box;
 position: absolute;
 white-space: nowrap;
 top: 0;
 bottom: 0;
 display: flex;
 align-items: center;
 line-height: 1;
 `), Le("checked", `
 right: 0;
 padding-right: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), Le("unchecked", `
 left: 0;
 justify-content: flex-end;
 padding-left: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), qe("&:focus", [Le("rail", `
 box-shadow: var(--n-box-shadow-focus);
 `)]), Ue("round", [Le("rail", "border-radius: calc(var(--n-rail-height) / 2);", [Le("button", "border-radius: calc(var(--n-button-height) / 2);")])]), ci("disabled", [ci("icon", [Ue("rubber-band", [Ue("pressed", [Le("rail", [Le("button", "max-width: var(--n-button-width-pressed);")])]), Le("rail", [qe("&:active", [Le("button", "max-width: var(--n-button-width-pressed);")])]), Ue("active", [Ue("pressed", [Le("rail", [Le("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])]), Le("rail", [qe("&:active", [Le("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])])])])])]), Ue("active", [Le("rail", [Le("button", "left: calc(100% - var(--n-button-width) - var(--n-offset))")])]), Le("rail", `
 overflow: hidden;
 height: var(--n-rail-height);
 min-width: var(--n-rail-width);
 border-radius: var(--n-rail-border-radius);
 cursor: pointer;
 position: relative;
 transition:
 opacity .3s var(--n-bezier),
 background .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [Le("button-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 font-size: calc(var(--n-button-height) - 4px);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 line-height: 1;
 `, [Sh()]), Le("button", `
 align-items: center; 
 top: var(--n-offset);
 left: var(--n-offset);
 height: var(--n-button-height);
 width: var(--n-button-width-pressed);
 max-width: var(--n-button-width);
 border-radius: var(--n-button-border-radius);
 background-color: var(--n-button-color);
 box-shadow: var(--n-button-box-shadow);
 box-sizing: border-box;
 cursor: inherit;
 content: "";
 position: absolute;
 transition:
 background-color .3s var(--n-bezier),
 left .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 max-width .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `)]), Ue("active", [Le("rail", "background-color: var(--n-rail-color-active);")]), Ue("loading", [Le("rail", `
 cursor: wait;
 `)]), Ue("disabled", [Le("rail", `
 cursor: not-allowed;
 opacity: .5;
 `)])]), V4 = Object.assign(Object.assign({}, er.props), { size: { type: String, default: "medium" }, value: { type: [String, Number, Boolean], default: void 0 }, loading: Boolean, defaultValue: { type: [String, Number, Boolean], default: false }, disabled: { type: Boolean, default: void 0 }, round: { type: Boolean, default: true }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], checkedValue: { type: [String, Number, Boolean], default: true }, uncheckedValue: { type: [String, Number, Boolean], default: false }, railStyle: Function, rubberBand: { type: Boolean, default: true }, onChange: [Function, Array] });
let ch;
const kx = nt({ name: "Switch", props: V4, slots: Object, setup(r) {
  ch === void 0 && (typeof CSS < "u" ? typeof CSS.supports < "u" ? ch = CSS.supports("width", "max(1px)") : ch = false : ch = true);
  const { mergedClsPrefixRef: n, inlineThemeDisabled: l } = Cr(r), h = er("Switch", "-switch", j4, aS, r, n), f = Ba(r), { mergedSizeRef: y, mergedDisabledRef: p } = f, s = Ee(r.defaultValue), S = zt(r, "value"), P = Qi(S, s), M = Ae(() => P.value === r.checkedValue), A = Ee(false), O = Ee(false), j = Ae(() => {
    const { railStyle: ve } = r;
    if (ve) return ve({ focused: O.value, checked: M.value });
  });
  function L(ve) {
    const { "onUpdate:value": le, onChange: ue, onUpdateValue: be } = r, { nTriggerFormInput: Ve, nTriggerFormChange: Ge } = f;
    le && jt(le, ve), be && jt(be, ve), ue && jt(ue, ve), s.value = ve, Ve(), Ge();
  }
  function q() {
    const { nTriggerFormFocus: ve } = f;
    ve();
  }
  function N() {
    const { nTriggerFormBlur: ve } = f;
    ve();
  }
  function J() {
    r.loading || p.value || (P.value !== r.checkedValue ? L(r.checkedValue) : L(r.uncheckedValue));
  }
  function te() {
    O.value = true, q();
  }
  function ne() {
    O.value = false, N(), A.value = false;
  }
  function ae(ve) {
    r.loading || p.value || ve.key === " " && (P.value !== r.checkedValue ? L(r.checkedValue) : L(r.uncheckedValue), A.value = false);
  }
  function oe(ve) {
    r.loading || p.value || ve.key === " " && (ve.preventDefault(), A.value = true);
  }
  const ee = Ae(() => {
    const { value: ve } = y, { self: { opacityDisabled: le, railColor: ue, railColorActive: be, buttonBoxShadow: Ve, buttonColor: Ge, boxShadowFocus: et, loadingColor: dt, textColor: Ct, iconColor: kt, [Ut("buttonHeight", ve)]: ct, [Ut("buttonWidth", ve)]: it, [Ut("buttonWidthPressed", ve)]: pt, [Ut("railHeight", ve)]: $t, [Ut("railWidth", ve)]: vt, [Ut("railBorderRadius", ve)]: Pt, [Ut("buttonBorderRadius", ve)]: Nt }, common: { cubicBezierEaseInOut: ir } } = h.value;
    let bt, Dt, Zt;
    return ch ? (bt = `calc((${$t} - ${ct}) / 2)`, Dt = `max(${$t}, ${ct})`, Zt = `max(${vt}, calc(${vt} + ${ct} - ${$t}))`) : (bt = Qn((ln($t) - ln(ct)) / 2), Dt = Qn(Math.max(ln($t), ln(ct))), Zt = ln($t) > ln(ct) ? vt : Qn(ln(vt) + ln(ct) - ln($t))), { "--n-bezier": ir, "--n-button-border-radius": Nt, "--n-button-box-shadow": Ve, "--n-button-color": Ge, "--n-button-width": it, "--n-button-width-pressed": pt, "--n-button-height": ct, "--n-height": Dt, "--n-offset": bt, "--n-opacity-disabled": le, "--n-rail-border-radius": Pt, "--n-rail-color": ue, "--n-rail-color-active": be, "--n-rail-height": $t, "--n-rail-width": vt, "--n-width": Zt, "--n-box-shadow-focus": et, "--n-loading-color": dt, "--n-text-color": Ct, "--n-icon-color": kt };
  }), ke = l ? ai("switch", Ae(() => y.value[0]), ee, r) : void 0;
  return { handleClick: J, handleBlur: ne, handleFocus: te, handleKeyup: ae, handleKeydown: oe, mergedRailStyle: j, pressed: A, mergedClsPrefix: n, mergedValue: P, checked: M, mergedDisabled: p, cssVars: l ? void 0 : ee, themeClass: ke == null ? void 0 : ke.themeClass, onRender: ke == null ? void 0 : ke.onRender };
}, render() {
  const { mergedClsPrefix: r, mergedDisabled: n, checked: l, mergedRailStyle: h, onRender: f, $slots: y } = this;
  f == null ? void 0 : f();
  const { checked: p, unchecked: s, icon: S, "checked-icon": P, "unchecked-icon": M } = y, A = !(Vg(S) && Vg(P) && Vg(M));
  return B("div", { role: "switch", "aria-checked": l, class: [`${r}-switch`, this.themeClass, A && `${r}-switch--icon`, l && `${r}-switch--active`, n && `${r}-switch--disabled`, this.round && `${r}-switch--round`, this.loading && `${r}-switch--loading`, this.pressed && `${r}-switch--pressed`, this.rubberBand && `${r}-switch--rubber-band`], tabindex: this.mergedDisabled ? void 0 : 0, style: this.cssVars, onClick: this.handleClick, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyup: this.handleKeyup, onKeydown: this.handleKeydown }, B("div", { class: `${r}-switch__rail`, "aria-hidden": "true", style: h }, oi(p, (O) => oi(s, (j) => O || j ? B("div", { "aria-hidden": true, class: `${r}-switch__children-placeholder` }, B("div", { class: `${r}-switch__rail-placeholder` }, B("div", { class: `${r}-switch__button-placeholder` }), O), B("div", { class: `${r}-switch__rail-placeholder` }, B("div", { class: `${r}-switch__button-placeholder` }), j)) : null)), B("div", { class: `${r}-switch__button` }, oi(S, (O) => oi(P, (j) => oi(M, (L) => B(im, null, { default: () => this.loading ? B(om, { key: "loading", clsPrefix: r, strokeWidth: 20 }) : this.checked && (j || O) ? B("div", { class: `${r}-switch__button-icon`, key: j ? "checked-icon" : "icon" }, j || O) : !this.checked && (L || O) ? B("div", { class: `${r}-switch__button-icon`, key: L ? "unchecked-icon" : "icon" }, L || O) : null })))), oi(p, (O) => O && B("div", { key: "checked", class: `${r}-switch__checked` }, O)), oi(s, (O) => O && B("div", { key: "unchecked", class: `${r}-switch__unchecked` }, O)))));
} }), lv = qn("n-tabs"), Tx = { tab: [String, Number, Object, Function], name: { type: [String, Number], required: true }, disabled: Boolean, displayDirective: { type: String, default: "if" }, closable: { type: Boolean, default: void 0 }, tabProps: Object, label: [String, Number, Object, Function] }, sb = nt({ __TAB_PANE__: true, name: "TabPane", alias: ["TabPanel"], props: Tx, slots: Object, setup(r) {
  const n = cr(lv, null);
  return n || fa("tab-pane", "`n-tab-pane` must be placed inside `n-tabs`."), { style: n.paneStyleRef, class: n.paneClassRef, mergedClsPrefix: n.mergedClsPrefixRef };
}, render() {
  return B("div", { class: [`${this.mergedClsPrefix}-tab-pane`, this.class], style: this.style }, this.$slots);
} }), U4 = Object.assign({ internalLeftPadded: Boolean, internalAddable: Boolean, internalCreatedByPane: Boolean }, b1(Tx, ["displayDirective"])), O0 = nt({ __TAB__: true, inheritAttrs: false, name: "Tab", props: U4, setup(r) {
  const { mergedClsPrefixRef: n, valueRef: l, typeRef: h, closableRef: f, tabStyleRef: y, addTabStyleRef: p, tabClassRef: s, addTabClassRef: S, tabChangeIdRef: P, onBeforeLeaveRef: M, triggerRef: A, handleAdd: O, activateTab: j, handleClose: L } = cr(lv);
  return { trigger: A, mergedClosable: Ae(() => {
    if (r.internalAddable) return false;
    const { closable: q } = r;
    return q === void 0 ? f.value : q;
  }), style: y, addStyle: p, tabClass: s, addTabClass: S, clsPrefix: n, value: l, type: h, handleClose(q) {
    q.stopPropagation(), !r.disabled && L(r.name);
  }, activateTab() {
    if (r.disabled) return;
    if (r.internalAddable) {
      O();
      return;
    }
    const { name: q } = r, N = ++P.id;
    if (q !== l.value) {
      const { value: J } = M;
      J ? Promise.resolve(J(r.name, l.value)).then((te) => {
        te && P.id === N && j(q);
      }) : j(q);
    }
  } };
}, render() {
  const { internalAddable: r, clsPrefix: n, name: l, disabled: h, label: f, tab: y, value: p, mergedClosable: s, trigger: S, $slots: { default: P } } = this, M = f ?? y;
  return B("div", { class: `${n}-tabs-tab-wrapper` }, this.internalLeftPadded ? B("div", { class: `${n}-tabs-tab-pad` }) : null, B("div", Object.assign({ key: l, "data-name": l, "data-disabled": h ? true : void 0 }, ls({ class: [`${n}-tabs-tab`, p === l && `${n}-tabs-tab--active`, h && `${n}-tabs-tab--disabled`, s && `${n}-tabs-tab--closable`, r && `${n}-tabs-tab--addable`, r ? this.addTabClass : this.tabClass], onClick: S === "click" ? this.activateTab : void 0, onMouseenter: S === "hover" ? this.activateTab : void 0, style: r ? this.addStyle : this.style }, this.internalCreatedByPane ? this.tabProps || {} : this.$attrs)), B("span", { class: `${n}-tabs-tab__label` }, r ? B(jr, null, B("div", { class: `${n}-tabs-tab__height-placeholder` }, "\xA0"), B(Nr, { clsPrefix: n }, { default: () => B(fm, null) })) : P ? P() : typeof M == "object" ? M : Ul(M ?? l)), s && this.type === "card" ? B(am, { clsPrefix: n, class: `${n}-tabs-tab__close`, onClick: this.handleClose, disabled: h }) : null));
} }), G4 = he("tabs", `
 box-sizing: border-box;
 width: 100%;
 display: flex;
 flex-direction: column;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
`, [Ue("segment-type", [he("tabs-rail", [qe("&.transition-disabled", [he("tabs-capsule", `
 transition: none;
 `)])])]), Ue("top", [he("tab-pane", `
 padding: var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left);
 `)]), Ue("left", [he("tab-pane", `
 padding: var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left) var(--n-pane-padding-top);
 `)]), Ue("left, right", `
 flex-direction: row;
 `, [he("tabs-bar", `
 width: 2px;
 right: 0;
 transition:
 top .2s var(--n-bezier),
 max-height .2s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), he("tabs-tab", `
 padding: var(--n-tab-padding-vertical); 
 `)]), Ue("right", `
 flex-direction: row-reverse;
 `, [he("tab-pane", `
 padding: var(--n-pane-padding-left) var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom);
 `), he("tabs-bar", `
 left: 0;
 `)]), Ue("bottom", `
 flex-direction: column-reverse;
 justify-content: flex-end;
 `, [he("tab-pane", `
 padding: var(--n-pane-padding-bottom) var(--n-pane-padding-right) var(--n-pane-padding-top) var(--n-pane-padding-left);
 `), he("tabs-bar", `
 top: 0;
 `)]), he("tabs-rail", `
 position: relative;
 padding: 3px;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 background-color: var(--n-color-segment);
 transition: background-color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [he("tabs-capsule", `
 border-radius: var(--n-tab-border-radius);
 position: absolute;
 pointer-events: none;
 background-color: var(--n-tab-color-segment);
 box-shadow: 0 1px 3px 0 rgba(0, 0, 0, .08);
 transition: transform 0.3s var(--n-bezier);
 `), he("tabs-tab-wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [he("tabs-tab", `
 overflow: hidden;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [Ue("active", `
 font-weight: var(--n-font-weight-strong);
 color: var(--n-tab-text-color-active);
 `), qe("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])])]), Ue("flex", [he("tabs-nav", `
 width: 100%;
 position: relative;
 `, [he("tabs-wrapper", `
 width: 100%;
 `, [he("tabs-tab", `
 margin-right: 0;
 `)])])]), he("tabs-nav", `
 box-sizing: border-box;
 line-height: 1.5;
 display: flex;
 transition: border-color .3s var(--n-bezier);
 `, [Le("prefix, suffix", `
 display: flex;
 align-items: center;
 `), Le("prefix", "padding-right: 16px;"), Le("suffix", "padding-left: 16px;")]), Ue("top, bottom", [qe(">", [he("tabs-nav", [he("tabs-nav-scroll-wrapper", [qe("&::before", `
 top: 0;
 bottom: 0;
 left: 0;
 width: 20px;
 `), qe("&::after", `
 top: 0;
 bottom: 0;
 right: 0;
 width: 20px;
 `), Ue("shadow-start", [qe("&::before", `
 box-shadow: inset 10px 0 8px -8px rgba(0, 0, 0, .12);
 `)]), Ue("shadow-end", [qe("&::after", `
 box-shadow: inset -10px 0 8px -8px rgba(0, 0, 0, .12);
 `)])])])])]), Ue("left, right", [he("tabs-nav-scroll-content", `
 flex-direction: column;
 `), qe(">", [he("tabs-nav", [he("tabs-nav-scroll-wrapper", [qe("&::before", `
 top: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), qe("&::after", `
 bottom: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), Ue("shadow-start", [qe("&::before", `
 box-shadow: inset 0 10px 8px -8px rgba(0, 0, 0, .12);
 `)]), Ue("shadow-end", [qe("&::after", `
 box-shadow: inset 0 -10px 8px -8px rgba(0, 0, 0, .12);
 `)])])])])]), he("tabs-nav-scroll-wrapper", `
 flex: 1;
 position: relative;
 overflow: hidden;
 `, [he("tabs-nav-y-scroll", `
 height: 100%;
 width: 100%;
 overflow-y: auto; 
 scrollbar-width: none;
 `, [qe("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `)]), qe("&::before, &::after", `
 transition: box-shadow .3s var(--n-bezier);
 pointer-events: none;
 content: "";
 position: absolute;
 z-index: 1;
 `)]), he("tabs-nav-scroll-content", `
 display: flex;
 position: relative;
 min-width: 100%;
 min-height: 100%;
 width: fit-content;
 box-sizing: border-box;
 `), he("tabs-wrapper", `
 display: inline-flex;
 flex-wrap: nowrap;
 position: relative;
 `), he("tabs-tab-wrapper", `
 display: flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 flex-grow: 0;
 `), he("tabs-tab", `
 cursor: pointer;
 white-space: nowrap;
 flex-wrap: nowrap;
 display: inline-flex;
 align-items: center;
 color: var(--n-tab-text-color);
 font-size: var(--n-tab-font-size);
 background-clip: padding-box;
 padding: var(--n-tab-padding);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [Ue("disabled", { cursor: "not-allowed" }), Le("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), Le("label", `
 display: flex;
 align-items: center;
 z-index: 1;
 `)]), he("tabs-bar", `
 position: absolute;
 bottom: 0;
 height: 2px;
 border-radius: 1px;
 background-color: var(--n-bar-color);
 transition:
 left .2s var(--n-bezier),
 max-width .2s var(--n-bezier),
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [qe("&.transition-disabled", `
 transition: none;
 `), Ue("disabled", `
 background-color: var(--n-tab-text-color-disabled)
 `)]), he("tabs-pane-wrapper", `
 position: relative;
 overflow: hidden;
 transition: max-height .2s var(--n-bezier);
 `), he("tab-pane", `
 color: var(--n-pane-text-color);
 width: 100%;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .2s var(--n-bezier);
 left: 0;
 right: 0;
 top: 0;
 `, [qe("&.next-transition-leave-active, &.prev-transition-leave-active, &.next-transition-enter-active, &.prev-transition-enter-active", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .2s var(--n-bezier),
 opacity .2s var(--n-bezier);
 `), qe("&.next-transition-leave-active, &.prev-transition-leave-active", `
 position: absolute;
 `), qe("&.next-transition-enter-from, &.prev-transition-leave-to", `
 transform: translateX(32px);
 opacity: 0;
 `), qe("&.next-transition-leave-to, &.prev-transition-enter-from", `
 transform: translateX(-32px);
 opacity: 0;
 `), qe("&.next-transition-leave-from, &.next-transition-enter-to, &.prev-transition-leave-from, &.prev-transition-enter-to", `
 transform: translateX(0);
 opacity: 1;
 `)]), he("tabs-tab-pad", `
 box-sizing: border-box;
 width: var(--n-tab-gap);
 flex-grow: 0;
 flex-shrink: 0;
 `), Ue("line-type, bar-type", [he("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 box-sizing: border-box;
 vertical-align: bottom;
 `, [qe("&:hover", { color: "var(--n-tab-text-color-hover)" }), Ue("active", `
 color: var(--n-tab-text-color-active);
 font-weight: var(--n-tab-font-weight-active);
 `), Ue("disabled", { color: "var(--n-tab-text-color-disabled)" })])]), he("tabs-nav", [Ue("line-type", [Ue("top", [Le("prefix, suffix", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), he("tabs-nav-scroll-content", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), he("tabs-bar", `
 bottom: -1px;
 `)]), Ue("left", [Le("prefix, suffix", `
 border-right: 1px solid var(--n-tab-border-color);
 `), he("tabs-nav-scroll-content", `
 border-right: 1px solid var(--n-tab-border-color);
 `), he("tabs-bar", `
 right: -1px;
 `)]), Ue("right", [Le("prefix, suffix", `
 border-left: 1px solid var(--n-tab-border-color);
 `), he("tabs-nav-scroll-content", `
 border-left: 1px solid var(--n-tab-border-color);
 `), he("tabs-bar", `
 left: -1px;
 `)]), Ue("bottom", [Le("prefix, suffix", `
 border-top: 1px solid var(--n-tab-border-color);
 `), he("tabs-nav-scroll-content", `
 border-top: 1px solid var(--n-tab-border-color);
 `), he("tabs-bar", `
 top: -1px;
 `)]), Le("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 `), he("tabs-nav-scroll-content", `
 transition: border-color .3s var(--n-bezier);
 `), he("tabs-bar", `
 border-radius: 0;
 `)]), Ue("card-type", [Le("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 `), he("tabs-pad", `
 flex-grow: 1;
 transition: border-color .3s var(--n-bezier);
 `), he("tabs-tab-pad", `
 transition: border-color .3s var(--n-bezier);
 `), he("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 border: 1px solid var(--n-tab-border-color);
 background-color: var(--n-tab-color);
 box-sizing: border-box;
 position: relative;
 vertical-align: bottom;
 display: flex;
 justify-content: space-between;
 font-size: var(--n-tab-font-size);
 color: var(--n-tab-text-color);
 `, [Ue("addable", `
 padding-left: 8px;
 padding-right: 8px;
 font-size: 16px;
 justify-content: center;
 `, [Le("height-placeholder", `
 width: 0;
 font-size: var(--n-tab-font-size);
 `), ci("disabled", [qe("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])]), Ue("closable", "padding-right: 8px;"), Ue("active", `
 background-color: #0000;
 font-weight: var(--n-tab-font-weight-active);
 color: var(--n-tab-text-color-active);
 `), Ue("disabled", "color: var(--n-tab-text-color-disabled);")])]), Ue("left, right", `
 flex-direction: column; 
 `, [Le("prefix, suffix", `
 padding: var(--n-tab-padding-vertical);
 `), he("tabs-wrapper", `
 flex-direction: column;
 `), he("tabs-tab-wrapper", `
 flex-direction: column;
 `, [he("tabs-tab-pad", `
 height: var(--n-tab-gap-vertical);
 width: 100%;
 `)])]), Ue("top", [Ue("card-type", [he("tabs-scroll-padding", "border-bottom: 1px solid var(--n-tab-border-color);"), Le("prefix, suffix", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), he("tabs-tab", `
 border-top-left-radius: var(--n-tab-border-radius);
 border-top-right-radius: var(--n-tab-border-radius);
 `, [Ue("active", `
 border-bottom: 1px solid #0000;
 `)]), he("tabs-tab-pad", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), he("tabs-pad", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `)])]), Ue("left", [Ue("card-type", [he("tabs-scroll-padding", "border-right: 1px solid var(--n-tab-border-color);"), Le("prefix, suffix", `
 border-right: 1px solid var(--n-tab-border-color);
 `), he("tabs-tab", `
 border-top-left-radius: var(--n-tab-border-radius);
 border-bottom-left-radius: var(--n-tab-border-radius);
 `, [Ue("active", `
 border-right: 1px solid #0000;
 `)]), he("tabs-tab-pad", `
 border-right: 1px solid var(--n-tab-border-color);
 `), he("tabs-pad", `
 border-right: 1px solid var(--n-tab-border-color);
 `)])]), Ue("right", [Ue("card-type", [he("tabs-scroll-padding", "border-left: 1px solid var(--n-tab-border-color);"), Le("prefix, suffix", `
 border-left: 1px solid var(--n-tab-border-color);
 `), he("tabs-tab", `
 border-top-right-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [Ue("active", `
 border-left: 1px solid #0000;
 `)]), he("tabs-tab-pad", `
 border-left: 1px solid var(--n-tab-border-color);
 `), he("tabs-pad", `
 border-left: 1px solid var(--n-tab-border-color);
 `)])]), Ue("bottom", [Ue("card-type", [he("tabs-scroll-padding", "border-top: 1px solid var(--n-tab-border-color);"), Le("prefix, suffix", `
 border-top: 1px solid var(--n-tab-border-color);
 `), he("tabs-tab", `
 border-bottom-left-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [Ue("active", `
 border-top: 1px solid #0000;
 `)]), he("tabs-tab-pad", `
 border-top: 1px solid var(--n-tab-border-color);
 `), he("tabs-pad", `
 border-top: 1px solid var(--n-tab-border-color);
 `)])])])]), i0 = xk, q4 = Object.assign(Object.assign({}, er.props), { value: [String, Number], defaultValue: [String, Number], trigger: { type: String, default: "click" }, type: { type: String, default: "bar" }, closable: Boolean, justifyContent: String, size: { type: String, default: "medium" }, placement: { type: String, default: "top" }, tabStyle: [String, Object], tabClass: String, addTabStyle: [String, Object], addTabClass: String, barWidth: Number, paneClass: String, paneStyle: [String, Object], paneWrapperClass: String, paneWrapperStyle: [String, Object], addable: [Boolean, Object], tabsPadding: { type: Number, default: 0 }, animated: Boolean, onBeforeLeave: Function, onAdd: Function, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onClose: [Function, Array], labelSize: String, activeName: [String, Number], onActiveNameChange: [Function, Array] }), W4 = nt({ name: "Tabs", props: q4, slots: Object, setup(r, { slots: n }) {
  var l, h, f, y;
  const { mergedClsPrefixRef: p, inlineThemeDisabled: s } = Cr(r), S = er("Tabs", "-tabs", G4, sS, r, p), P = Ee(null), M = Ee(null), A = Ee(null), O = Ee(null), j = Ee(null), L = Ee(null), q = Ee(true), N = Ee(true), J = Wp(r, ["labelSize", "size"]), te = Wp(r, ["activeName", "value"]), ne = Ee((h = (l = te.value) !== null && l !== void 0 ? l : r.defaultValue) !== null && h !== void 0 ? h : n.default ? (y = (f = Xl(n.default())[0]) === null || f === void 0 ? void 0 : f.props) === null || y === void 0 ? void 0 : y.name : null), ae = Qi(te, ne), oe = { id: 0 }, ee = Ae(() => {
    if (!(!r.justifyContent || r.type === "card")) return { display: "flex", justifyContent: r.justifyContent };
  });
  Kt(ae, () => {
    oe.id = 0, be(), Ve();
  });
  function ke() {
    var $e;
    const { value: Ye } = ae;
    return Ye === null ? null : ($e = P.value) === null || $e === void 0 ? void 0 : $e.querySelector(`[data-name="${Ye}"]`);
  }
  function ve($e) {
    if (r.type === "card") return;
    const { value: Ye } = M;
    if (!Ye) return;
    const ht = Ye.style.opacity === "0";
    if ($e) {
      const St = `${p.value}-tabs-bar--disabled`, { barWidth: rt, placement: mt } = r;
      if ($e.dataset.disabled === "true" ? Ye.classList.add(St) : Ye.classList.remove(St), ["top", "bottom"].includes(mt)) {
        if (ue(["top", "maxHeight", "height"]), typeof rt == "number" && $e.offsetWidth >= rt) {
          const nr = Math.floor(($e.offsetWidth - rt) / 2) + $e.offsetLeft;
          Ye.style.left = `${nr}px`, Ye.style.maxWidth = `${rt}px`;
        } else Ye.style.left = `${$e.offsetLeft}px`, Ye.style.maxWidth = `${$e.offsetWidth}px`;
        Ye.style.width = "8192px", ht && (Ye.style.transition = "none"), Ye.offsetWidth, ht && (Ye.style.transition = "", Ye.style.opacity = "1");
      } else {
        if (ue(["left", "maxWidth", "width"]), typeof rt == "number" && $e.offsetHeight >= rt) {
          const nr = Math.floor(($e.offsetHeight - rt) / 2) + $e.offsetTop;
          Ye.style.top = `${nr}px`, Ye.style.maxHeight = `${rt}px`;
        } else Ye.style.top = `${$e.offsetTop}px`, Ye.style.maxHeight = `${$e.offsetHeight}px`;
        Ye.style.height = "8192px", ht && (Ye.style.transition = "none"), Ye.offsetHeight, ht && (Ye.style.transition = "", Ye.style.opacity = "1");
      }
    }
  }
  function le() {
    if (r.type === "card") return;
    const { value: $e } = M;
    $e && ($e.style.opacity = "0");
  }
  function ue($e) {
    const { value: Ye } = M;
    if (Ye) for (const ht of $e) Ye.style[ht] = "";
  }
  function be() {
    if (r.type === "card") return;
    const $e = ke();
    $e ? ve($e) : le();
  }
  function Ve() {
    var $e;
    const Ye = ($e = j.value) === null || $e === void 0 ? void 0 : $e.$el;
    if (!Ye) return;
    const ht = ke();
    if (!ht) return;
    const { scrollLeft: St, offsetWidth: rt } = Ye, { offsetLeft: mt, offsetWidth: nr } = ht;
    St > mt ? Ye.scrollTo({ top: 0, left: mt, behavior: "smooth" }) : mt + nr > St + rt && Ye.scrollTo({ top: 0, left: mt + nr - rt, behavior: "smooth" });
  }
  const Ge = Ee(null);
  let et = 0, dt = null;
  function Ct($e) {
    const Ye = Ge.value;
    if (Ye) {
      et = $e.getBoundingClientRect().height;
      const ht = `${et}px`, St = () => {
        Ye.style.height = ht, Ye.style.maxHeight = ht;
      };
      dt ? (St(), dt(), dt = null) : dt = St;
    }
  }
  function kt($e) {
    const Ye = Ge.value;
    if (Ye) {
      const ht = $e.getBoundingClientRect().height, St = () => {
        document.body.offsetHeight, Ye.style.maxHeight = `${ht}px`, Ye.style.height = `${Math.max(et, ht)}px`;
      };
      dt ? (dt(), dt = null, St()) : dt = St;
    }
  }
  function ct() {
    const $e = Ge.value;
    if ($e) {
      $e.style.maxHeight = "", $e.style.height = "";
      const { paneWrapperStyle: Ye } = r;
      if (typeof Ye == "string") $e.style.cssText = Ye;
      else if (Ye) {
        const { maxHeight: ht, height: St } = Ye;
        ht !== void 0 && ($e.style.maxHeight = ht), St !== void 0 && ($e.style.height = St);
      }
    }
  }
  const it = { value: [] }, pt = Ee("next");
  function $t($e) {
    const Ye = ae.value;
    let ht = "next";
    for (const St of it.value) {
      if (St === Ye) break;
      if (St === $e) {
        ht = "prev";
        break;
      }
    }
    pt.value = ht, vt($e);
  }
  function vt($e) {
    const { onActiveNameChange: Ye, onUpdateValue: ht, "onUpdate:value": St } = r;
    Ye && jt(Ye, $e), ht && jt(ht, $e), St && jt(St, $e), ne.value = $e;
  }
  function Pt($e) {
    const { onClose: Ye } = r;
    Ye && jt(Ye, $e);
  }
  function Nt() {
    const { value: $e } = M;
    if (!$e) return;
    const Ye = "transition-disabled";
    $e.classList.add(Ye), be(), $e.classList.remove(Ye);
  }
  const ir = Ee(null);
  function bt({ transitionDisabled: $e }) {
    const Ye = P.value;
    if (!Ye) return;
    $e && Ye.classList.add("transition-disabled");
    const ht = ke();
    ht && ir.value && (ir.value.style.width = `${ht.offsetWidth}px`, ir.value.style.height = `${ht.offsetHeight}px`, ir.value.style.transform = `translateX(${ht.offsetLeft - ln(getComputedStyle(Ye).paddingLeft)}px)`, $e && ir.value.offsetWidth), $e && Ye.classList.remove("transition-disabled");
  }
  Kt([ae], () => {
    r.type === "segment" && eo(() => {
      bt({ transitionDisabled: false });
    });
  }), Ei(() => {
    r.type === "segment" && bt({ transitionDisabled: true });
  });
  let Dt = 0;
  function Zt($e) {
    var Ye;
    if ($e.contentRect.width === 0 && $e.contentRect.height === 0 || Dt === $e.contentRect.width) return;
    Dt = $e.contentRect.width;
    const { type: ht } = r;
    if ((ht === "line" || ht === "bar") && Nt(), ht !== "segment") {
      const { placement: St } = r;
      Ht((St === "top" || St === "bottom" ? (Ye = j.value) === null || Ye === void 0 ? void 0 : Ye.$el : L.value) || null);
    }
  }
  const dr = i0(Zt, 64);
  Kt([() => r.justifyContent, () => r.size], () => {
    eo(() => {
      const { type: $e } = r;
      ($e === "line" || $e === "bar") && Nt();
    });
  });
  const yr = Ee(false);
  function Pr($e) {
    var Ye;
    const { target: ht, contentRect: { width: St, height: rt } } = $e, mt = ht.parentElement.parentElement.offsetWidth, nr = ht.parentElement.parentElement.offsetHeight, { placement: di } = r;
    if (!yr.value) di === "top" || di === "bottom" ? mt < St && (yr.value = true) : nr < rt && (yr.value = true);
    else {
      const { value: wi } = O;
      if (!wi) return;
      di === "top" || di === "bottom" ? mt - St > wi.$el.offsetWidth && (yr.value = false) : nr - rt > wi.$el.offsetHeight && (yr.value = false);
    }
    Ht(((Ye = j.value) === null || Ye === void 0 ? void 0 : Ye.$el) || null);
  }
  const lr = i0(Pr, 64);
  function Ir() {
    const { onAdd: $e } = r;
    $e && $e(), eo(() => {
      const Ye = ke(), { value: ht } = j;
      !Ye || !ht || ht.scrollTo({ left: Ye.offsetLeft, top: 0, behavior: "smooth" });
    });
  }
  function Ht($e) {
    if (!$e) return;
    const { placement: Ye } = r;
    if (Ye === "top" || Ye === "bottom") {
      const { scrollLeft: ht, scrollWidth: St, offsetWidth: rt } = $e;
      q.value = ht <= 0, N.value = ht + rt >= St;
    } else {
      const { scrollTop: ht, scrollHeight: St, offsetHeight: rt } = $e;
      q.value = ht <= 0, N.value = ht + rt >= St;
    }
  }
  const Rr = i0(($e) => {
    Ht($e.target);
  }, 64);
  Vr(lv, { triggerRef: zt(r, "trigger"), tabStyleRef: zt(r, "tabStyle"), tabClassRef: zt(r, "tabClass"), addTabStyleRef: zt(r, "addTabStyle"), addTabClassRef: zt(r, "addTabClass"), paneClassRef: zt(r, "paneClass"), paneStyleRef: zt(r, "paneStyle"), mergedClsPrefixRef: p, typeRef: zt(r, "type"), closableRef: zt(r, "closable"), valueRef: ae, tabChangeIdRef: oe, onBeforeLeaveRef: zt(r, "onBeforeLeave"), activateTab: $t, handleClose: Pt, handleAdd: Ir }), o1(() => {
    be(), Ve();
  }), Ao(() => {
    const { value: $e } = A;
    if (!$e) return;
    const { value: Ye } = p, ht = `${Ye}-tabs-nav-scroll-wrapper--shadow-start`, St = `${Ye}-tabs-nav-scroll-wrapper--shadow-end`;
    q.value ? $e.classList.remove(ht) : $e.classList.add(ht), N.value ? $e.classList.remove(St) : $e.classList.add(St);
  });
  const xr = { syncBarPosition: () => {
    be();
  } }, gt = () => {
    bt({ transitionDisabled: true });
  }, Be = Ae(() => {
    const { value: $e } = J, { type: Ye } = r, ht = { card: "Card", bar: "Bar", line: "Line", segment: "Segment" }[Ye], St = `${$e}${ht}`, { self: { barColor: rt, closeIconColor: mt, closeIconColorHover: nr, closeIconColorPressed: di, tabColor: wi, tabBorderColor: xn, paneTextColor: en, tabFontWeight: wn, tabBorderRadius: Cn, tabFontWeightActive: Bi, colorSegment: Ci, fontWeightStrong: Me, tabColorSegment: $, closeSize: Z, closeIconSize: Q, closeColorHover: ge, closeColorPressed: _e, closeBorderRadius: Re, [Ut("panePadding", $e)]: se, [Ut("tabPadding", St)]: Fe, [Ut("tabPaddingVertical", St)]: We, [Ut("tabGap", St)]: Qe, [Ut("tabGap", `${St}Vertical`)]: tt, [Ut("tabTextColor", Ye)]: At, [Ut("tabTextColorActive", Ye)]: qt, [Ut("tabTextColorHover", Ye)]: sr, [Ut("tabTextColorDisabled", Ye)]: Ur, [Ut("tabFontSize", $e)]: mr }, common: { cubicBezierEaseInOut: Sr } } = S.value;
    return { "--n-bezier": Sr, "--n-color-segment": Ci, "--n-bar-color": rt, "--n-tab-font-size": mr, "--n-tab-text-color": At, "--n-tab-text-color-active": qt, "--n-tab-text-color-disabled": Ur, "--n-tab-text-color-hover": sr, "--n-pane-text-color": en, "--n-tab-border-color": xn, "--n-tab-border-radius": Cn, "--n-close-size": Z, "--n-close-icon-size": Q, "--n-close-color-hover": ge, "--n-close-color-pressed": _e, "--n-close-border-radius": Re, "--n-close-icon-color": mt, "--n-close-icon-color-hover": nr, "--n-close-icon-color-pressed": di, "--n-tab-color": wi, "--n-tab-font-weight": wn, "--n-tab-font-weight-active": Bi, "--n-tab-padding": Fe, "--n-tab-padding-vertical": We, "--n-tab-gap": Qe, "--n-tab-gap-vertical": tt, "--n-pane-padding-left": qo(se, "left"), "--n-pane-padding-right": qo(se, "right"), "--n-pane-padding-top": qo(se, "top"), "--n-pane-padding-bottom": qo(se, "bottom"), "--n-font-weight-strong": Me, "--n-tab-color-segment": $ };
  }), ot = s ? ai("tabs", Ae(() => `${J.value[0]}${r.type[0]}`), Be, r) : void 0;
  return Object.assign({ mergedClsPrefix: p, mergedValue: ae, renderedNames: /* @__PURE__ */ new Set(), segmentCapsuleElRef: ir, tabsPaneWrapperRef: Ge, tabsElRef: P, barElRef: M, addTabInstRef: O, xScrollInstRef: j, scrollWrapperElRef: A, addTabFixed: yr, tabWrapperStyle: ee, handleNavResize: dr, mergedSize: J, handleScroll: Rr, handleTabsResize: lr, cssVars: s ? void 0 : Be, themeClass: ot == null ? void 0 : ot.themeClass, animationDirection: pt, renderNameListRef: it, yScrollElRef: L, handleSegmentResize: gt, onAnimationBeforeLeave: Ct, onAnimationEnter: kt, onAnimationAfterEnter: ct, onRender: ot == null ? void 0 : ot.onRender }, xr);
}, render() {
  const { mergedClsPrefix: r, type: n, placement: l, addTabFixed: h, addable: f, mergedSize: y, renderNameListRef: p, onRender: s, paneWrapperClass: S, paneWrapperStyle: P, $slots: { default: M, prefix: A, suffix: O } } = this;
  s == null ? void 0 : s();
  const j = M ? Xl(M()).filter((oe) => oe.type.__TAB_PANE__ === true) : [], L = M ? Xl(M()).filter((oe) => oe.type.__TAB__ === true) : [], q = !L.length, N = n === "card", J = n === "segment", te = !N && !J && this.justifyContent;
  p.value = [];
  const ne = () => {
    const oe = B("div", { style: this.tabWrapperStyle, class: `${r}-tabs-wrapper` }, te ? null : B("div", { class: `${r}-tabs-scroll-padding`, style: l === "top" || l === "bottom" ? { width: `${this.tabsPadding}px` } : { height: `${this.tabsPadding}px` } }), q ? j.map((ee, ke) => (p.value.push(ee.props.name), n0(B(O0, Object.assign({}, ee.props, { internalCreatedByPane: true, internalLeftPadded: ke !== 0 && (!te || te === "center" || te === "start" || te === "end") }), ee.children ? { default: ee.children.tab } : void 0)))) : L.map((ee, ke) => (p.value.push(ee.props.name), n0(ke !== 0 && !te ? cb(ee) : ee))), !h && f && N ? ub(f, (q ? j.length : L.length) !== 0) : null, te ? null : B("div", { class: `${r}-tabs-scroll-padding`, style: { width: `${this.tabsPadding}px` } }));
    return B("div", { ref: "tabsElRef", class: `${r}-tabs-nav-scroll-content` }, N && f ? B(ql, { onResize: this.handleTabsResize }, { default: () => oe }) : oe, N ? B("div", { class: `${r}-tabs-pad` }) : null, N ? null : B("div", { ref: "barElRef", class: `${r}-tabs-bar` }));
  }, ae = J ? "top" : l;
  return B("div", { class: [`${r}-tabs`, this.themeClass, `${r}-tabs--${n}-type`, `${r}-tabs--${y}-size`, te && `${r}-tabs--flex`, `${r}-tabs--${ae}`], style: this.cssVars }, B("div", { class: [`${r}-tabs-nav--${n}-type`, `${r}-tabs-nav--${ae}`, `${r}-tabs-nav`] }, oi(A, (oe) => oe && B("div", { class: `${r}-tabs-nav__prefix` }, oe)), J ? B(ql, { onResize: this.handleSegmentResize }, { default: () => B("div", { class: `${r}-tabs-rail`, ref: "tabsElRef" }, B("div", { class: `${r}-tabs-capsule`, ref: "segmentCapsuleElRef" }, B("div", { class: `${r}-tabs-wrapper` }, B("div", { class: `${r}-tabs-tab` }))), q ? j.map((oe, ee) => (p.value.push(oe.props.name), B(O0, Object.assign({}, oe.props, { internalCreatedByPane: true, internalLeftPadded: ee !== 0 }), oe.children ? { default: oe.children.tab } : void 0))) : L.map((oe, ee) => (p.value.push(oe.props.name), ee === 0 ? oe : cb(oe)))) }) : B(ql, { onResize: this.handleNavResize }, { default: () => B("div", { class: `${r}-tabs-nav-scroll-wrapper`, ref: "scrollWrapperElRef" }, ["top", "bottom"].includes(ae) ? B(uT, { ref: "xScrollInstRef", onScroll: this.handleScroll }, { default: ne }) : B("div", { class: `${r}-tabs-nav-y-scroll`, onScroll: this.handleScroll, ref: "yScrollElRef" }, ne())) }), h && f && N ? ub(f, true) : null, oi(O, (oe) => oe && B("div", { class: `${r}-tabs-nav__suffix` }, oe))), q && (this.animated && (ae === "top" || ae === "bottom") ? B("div", { ref: "tabsPaneWrapperRef", style: P, class: [`${r}-tabs-pane-wrapper`, S] }, lb(j, this.mergedValue, this.renderedNames, this.onAnimationBeforeLeave, this.onAnimationEnter, this.onAnimationAfterEnter, this.animationDirection)) : lb(j, this.mergedValue, this.renderedNames)));
} });
function lb(r, n, l, h, f, y, p) {
  const s = [];
  return r.forEach((S) => {
    const { name: P, displayDirective: M, "display-directive": A } = S.props, O = (L) => M === L || A === L, j = n === P;
    if (S.key !== void 0 && (S.key = P), j || O("show") || O("show:lazy") && l.has(P)) {
      l.has(P) || l.add(P);
      const L = !O("if");
      s.push(L ? za(S, [[us, j]]) : S);
    }
  }), p ? B(e3, { name: `${p}-transition`, onBeforeLeave: h, onEnter: f, onAfterEnter: y }, { default: () => s }) : s;
}
function ub(r, n) {
  return B(O0, { ref: "addTabInstRef", key: "__addable", name: "__addable", internalCreatedByPane: true, internalAddable: true, internalLeftPadded: n, disabled: typeof r == "object" && r.disabled });
}
function cb(r) {
  const n = y0(r);
  return n.props ? n.props.internalLeftPadded = true : n.props = { internalLeftPadded: true }, n;
}
function n0(r) {
  return Array.isArray(r.dynamicProps) ? r.dynamicProps.includes("internalLeftPadded") || r.dynamicProps.push("internalLeftPadded") : r.dynamicProps = ["internalLeftPadded"], r;
}
const Z4 = he("h", `
 font-size: var(--n-font-size);
 font-weight: var(--n-font-weight);
 margin: var(--n-margin);
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
`, [qe("&:first-child", { marginTop: 0 }), Ue("prefix-bar", { position: "relative", paddingLeft: "var(--n-prefix-width)" }, [Ue("align-text", { paddingLeft: 0 }, [qe("&::before", { left: "calc(-1 * var(--n-prefix-width))" })]), qe("&::before", `
 content: "";
 width: var(--n-bar-width);
 border-radius: calc(var(--n-bar-width) / 2);
 transition: background-color .3s var(--n-bezier);
 left: 0;
 top: 0;
 bottom: 0;
 position: absolute;
 `), qe("&::before", { backgroundColor: "var(--n-bar-color)" })])]), H4 = Object.assign(Object.assign({}, er.props), { type: { type: String, default: "default" }, prefix: String, alignText: Boolean }), X4 = (r) => nt({ name: `H${r}`, props: H4, setup(n) {
  const { mergedClsPrefixRef: l, inlineThemeDisabled: h } = Cr(n), f = er("Typography", "-h", Z4, x1, n, l), y = Ae(() => {
    const { type: s } = n, { common: { cubicBezierEaseInOut: S }, self: { headerFontWeight: P, headerTextColor: M, [Ut("headerPrefixWidth", r)]: A, [Ut("headerFontSize", r)]: O, [Ut("headerMargin", r)]: j, [Ut("headerBarWidth", r)]: L, [Ut("headerBarColor", s)]: q } } = f.value;
    return { "--n-bezier": S, "--n-font-size": O, "--n-margin": j, "--n-bar-color": q, "--n-bar-width": L, "--n-font-weight": P, "--n-text-color": M, "--n-prefix-width": A };
  }), p = h ? ai(`h${r}`, Ae(() => n.type[0]), y, n) : void 0;
  return { mergedClsPrefix: l, cssVars: h ? void 0 : y, themeClass: p == null ? void 0 : p.themeClass, onRender: p == null ? void 0 : p.onRender };
}, render() {
  var n;
  const { prefix: l, alignText: h, mergedClsPrefix: f, cssVars: y, $slots: p } = this;
  return (n = this.onRender) === null || n === void 0 || n.call(this), B(`h${r}`, { class: [`${f}-h`, `${f}-h${r}`, this.themeClass, { [`${f}-h--prefix-bar`]: l, [`${f}-h--align-text`]: h }], style: y }, p);
} }), Y4 = X4("1"), K4 = he("p", `
 box-sizing: border-box;
 transition: color .3s var(--n-bezier);
 margin: var(--n-margin);
 font-size: var(--n-font-size);
 line-height: var(--n-line-height);
 color: var(--n-text-color);
`, [qe("&:first-child", "margin-top: 0;"), qe("&:last-child", "margin-bottom: 0;")]), J4 = Object.assign(Object.assign({}, er.props), { depth: [String, Number] }), Tp = nt({ name: "P", props: J4, setup(r) {
  const { mergedClsPrefixRef: n, inlineThemeDisabled: l } = Cr(r), h = er("Typography", "-p", K4, x1, r, n), f = Ae(() => {
    const { depth: p } = r, s = p || "1", { common: { cubicBezierEaseInOut: S }, self: { pFontSize: P, pLineHeight: M, pMargin: A, pTextColor: O, [`pTextColor${s}Depth`]: j } } = h.value;
    return { "--n-bezier": S, "--n-font-size": P, "--n-line-height": M, "--n-margin": A, "--n-text-color": p === void 0 ? O : j };
  }), y = l ? ai("p", Ae(() => `${r.depth || ""}`), f, r) : void 0;
  return { mergedClsPrefix: n, cssVars: l ? void 0 : f, themeClass: y == null ? void 0 : y.themeClass, onRender: y == null ? void 0 : y.onRender };
}, render() {
  var r;
  return (r = this.onRender) === null || r === void 0 || r.call(this), B("p", { class: [`${this.mergedClsPrefix}-p`, this.themeClass], style: this.cssVars }, this.$slots);
} }), Vc = qn("n-upload"), Q4 = qe([he("upload", "width: 100%;", [Ue("dragger-inside", [he("upload-trigger", `
 display: block;
 `)]), Ue("drag-over", [he("upload-dragger", `
 border: var(--n-dragger-border-hover);
 `)])]), he("upload-dragger", `
 cursor: pointer;
 box-sizing: border-box;
 width: 100%;
 text-align: center;
 border-radius: var(--n-border-radius);
 padding: 24px;
 opacity: 1;
 transition:
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 background-color: var(--n-dragger-color);
 border: var(--n-dragger-border);
 `, [qe("&:hover", `
 border: var(--n-dragger-border-hover);
 `), Ue("disabled", `
 cursor: not-allowed;
 `)]), he("upload-trigger", `
 display: inline-block;
 box-sizing: border-box;
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [qe("+", [he("upload-file-list", "margin-top: 8px;")]), Ue("disabled", `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `), Ue("image-card", `
 width: 96px;
 height: 96px;
 `, [he("base-icon", `
 font-size: 24px;
 `), he("upload-dragger", `
 padding: 0;
 height: 100%;
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `)])]), he("upload-file-list", `
 line-height: var(--n-line-height);
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [qe("a, img", "outline: none;"), Ue("disabled", `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `, [he("upload-file", "cursor: not-allowed;")]), Ue("grid", `
 display: grid;
 grid-template-columns: repeat(auto-fill, 96px);
 grid-gap: 8px;
 margin-top: 0;
 `), he("upload-file", `
 display: block;
 box-sizing: border-box;
 cursor: default;
 padding: 0px 12px 0 6px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `, [Up(), he("progress", [Up({ foldPadding: true })]), qe("&:hover", `
 background-color: var(--n-item-color-hover);
 `, [he("upload-file-info", [Le("action", `
 opacity: 1;
 `)])]), Ue("image-type", `
 border-radius: var(--n-border-radius);
 text-decoration: underline;
 text-decoration-color: #0000;
 `, [he("upload-file-info", `
 padding-top: 0px;
 padding-bottom: 0px;
 width: 100%;
 height: 100%;
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 6px 0;
 `, [he("progress", `
 padding: 2px 0;
 margin-bottom: 0;
 `), Le("name", `
 padding: 0 8px;
 `), Le("thumbnail", `
 width: 32px;
 height: 32px;
 font-size: 28px;
 display: flex;
 justify-content: center;
 align-items: center;
 `, [qe("img", `
 width: 100%;
 `)])])]), Ue("text-type", [he("progress", `
 box-sizing: border-box;
 padding-bottom: 6px;
 margin-bottom: 6px;
 `)]), Ue("image-card-type", `
 position: relative;
 width: 96px;
 height: 96px;
 border: var(--n-item-border-image-card);
 border-radius: var(--n-border-radius);
 padding: 0;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: border-color .3s var(--n-bezier), background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 overflow: hidden;
 `, [he("progress", `
 position: absolute;
 left: 8px;
 bottom: 8px;
 right: 8px;
 width: unset;
 `), he("upload-file-info", `
 padding: 0;
 width: 100%;
 height: 100%;
 `, [Le("thumbnail", `
 width: 100%;
 height: 100%;
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 font-size: 36px;
 `, [qe("img", `
 width: 100%;
 `)])]), qe("&::before", `
 position: absolute;
 z-index: 1;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 opacity: 0;
 transition: opacity .2s var(--n-bezier);
 content: "";
 `), qe("&:hover", [qe("&::before", "opacity: 1;"), he("upload-file-info", [Le("thumbnail", "opacity: .12;")])])]), Ue("error-status", [qe("&:hover", `
 background-color: var(--n-item-color-hover-error);
 `), he("upload-file-info", [Le("name", "color: var(--n-item-text-color-error);"), Le("thumbnail", "color: var(--n-item-text-color-error);")]), Ue("image-card-type", `
 border: var(--n-item-border-image-card-error);
 `)]), Ue("with-url", `
 cursor: pointer;
 `, [he("upload-file-info", [Le("name", `
 color: var(--n-item-text-color-success);
 text-decoration-color: var(--n-item-text-color-success);
 `, [qe("a", `
 text-decoration: underline;
 `)])])]), he("upload-file-info", `
 position: relative;
 padding-top: 6px;
 padding-bottom: 6px;
 display: flex;
 flex-wrap: nowrap;
 `, [Le("thumbnail", `
 font-size: 18px;
 opacity: 1;
 transition: opacity .2s var(--n-bezier);
 color: var(--n-item-icon-color);
 `, [he("base-icon", `
 margin-right: 2px;
 vertical-align: middle;
 transition: color .3s var(--n-bezier);
 `)]), Le("action", `
 padding-top: inherit;
 padding-bottom: inherit;
 position: absolute;
 right: 0;
 top: 0;
 bottom: 0;
 width: 80px;
 display: flex;
 align-items: center;
 transition: opacity .2s var(--n-bezier);
 justify-content: flex-end;
 opacity: 0;
 `, [he("button", [qe("&:not(:last-child)", { marginRight: "4px" }), he("base-icon", [qe("svg", [Sh()])])]), Ue("image-type", `
 position: relative;
 max-width: 80px;
 width: auto;
 `), Ue("image-card-type", `
 z-index: 2;
 position: absolute;
 width: 100%;
 height: 100%;
 left: 0;
 right: 0;
 bottom: 0;
 top: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 `)]), Le("name", `
 color: var(--n-item-text-color);
 flex: 1;
 display: flex;
 justify-content: center;
 text-overflow: ellipsis;
 overflow: hidden;
 flex-direction: column;
 text-decoration-color: #0000;
 font-size: var(--n-font-size);
 transition:
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier); 
 `, [qe("a", `
 color: inherit;
 text-decoration: underline;
 `)])])])]), he("upload-file-input", `
 display: none;
 width: 0;
 height: 0;
 opacity: 0;
 `)]), Px = "__UPLOAD_DRAGGER__", Ix = nt({ name: "UploadDragger", [Px]: true, setup(r, { slots: n }) {
  const l = cr(Vc, null);
  return l || fa("upload-dragger", "`n-upload-dragger` must be placed inside `n-upload`."), () => {
    const { mergedClsPrefixRef: { value: h }, mergedDisabledRef: { value: f }, maxReachedRef: { value: y } } = l;
    return B("div", { class: [`${h}-upload-dragger`, (f || y) && `${h}-upload-dragger--disabled`] }, n);
  };
} });
function eI() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 28 28" }, B("g", { fill: "none" }, B("path", { d: "M21.75 3A3.25 3.25 0 0 1 25 6.25v15.5A3.25 3.25 0 0 1 21.75 25H6.25A3.25 3.25 0 0 1 3 21.75V6.25A3.25 3.25 0 0 1 6.25 3h15.5zm.583 20.4l-7.807-7.68a.75.75 0 0 0-.968-.07l-.084.07l-7.808 7.68c.183.065.38.1.584.1h15.5c.204 0 .4-.035.583-.1l-7.807-7.68l7.807 7.68zM21.75 4.5H6.25A1.75 1.75 0 0 0 4.5 6.25v15.5c0 .208.036.408.103.593l7.82-7.692a2.25 2.25 0 0 1 3.026-.117l.129.117l7.82 7.692c.066-.185.102-.385.102-.593V6.25a1.75 1.75 0 0 0-1.75-1.75zm-3.25 3a2.5 2.5 0 1 1 0 5a2.5 2.5 0 0 1 0-5zm0 1.5a1 1 0 1 0 0 2a1 1 0 0 0 0-2z", fill: "currentColor" })));
}
function tI() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 28 28" }, B("g", { fill: "none" }, B("path", { d: "M6.4 2A2.4 2.4 0 0 0 4 4.4v19.2A2.4 2.4 0 0 0 6.4 26h15.2a2.4 2.4 0 0 0 2.4-2.4V11.578c0-.729-.29-1.428-.805-1.944l-6.931-6.931A2.4 2.4 0 0 0 14.567 2H6.4zm-.9 2.4a.9.9 0 0 1 .9-.9H14V10a2 2 0 0 0 2 2h6.5v11.6a.9.9 0 0 1-.9.9H6.4a.9.9 0 0 1-.9-.9V4.4zm16.44 6.1H16a.5.5 0 0 1-.5-.5V4.06l6.44 6.44z", fill: "currentColor" })));
}
const rI = nt({ name: "UploadProgress", props: { show: Boolean, percentage: { type: Number, required: true }, status: { type: String, required: true } }, setup() {
  return { mergedTheme: cr(Vc).mergedThemeRef };
}, render() {
  return B(sm, null, { default: () => this.show ? B(R4, { type: "line", showIndicator: false, percentage: this.percentage, status: this.status, height: 2, theme: this.mergedTheme.peers.Progress, themeOverrides: this.mergedTheme.peerOverrides.Progress }) : null });
} });
var $0 = function(r, n, l, h) {
  function f(y) {
    return y instanceof l ? y : new l(function(p) {
      p(y);
    });
  }
  return new (l || (l = Promise))(function(y, p) {
    function s(M) {
      try {
        P(h.next(M));
      } catch (A) {
        p(A);
      }
    }
    function S(M) {
      try {
        P(h.throw(M));
      } catch (A) {
        p(A);
      }
    }
    function P(M) {
      M.done ? y(M.value) : f(M.value).then(s, S);
    }
    P((h = h.apply(r, n || [])).next());
  });
};
function Ex(r) {
  return r.includes("image/");
}
function db(r = "") {
  const n = r.split("/"), h = n[n.length - 1].split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(h) || [""])[0];
}
const hb = /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i, Mx = (r) => {
  if (r.type) return Ex(r.type);
  const n = db(r.name || "");
  if (hb.test(n)) return true;
  const l = r.thumbnailUrl || r.url || "", h = db(l);
  return !!(/^data:image\//.test(l) || hb.test(h));
};
function iI(r) {
  return $0(this, void 0, void 0, function* () {
    return yield new Promise((n) => {
      if (!r.type || !Ex(r.type)) {
        n("");
        return;
      }
      n(window.URL.createObjectURL(r));
    });
  });
}
const nI = um && window.FileReader && window.File;
function oI(r) {
  return r.isDirectory;
}
function aI(r) {
  return r.isFile;
}
function sI(r, n) {
  return $0(this, void 0, void 0, function* () {
    const l = [];
    function h(f) {
      return $0(this, void 0, void 0, function* () {
        for (const y of f) if (y) {
          if (n && oI(y)) {
            const p = y.createReader();
            let s = [], S;
            try {
              do
                S = yield new Promise((P, M) => {
                  p.readEntries(P, M);
                }), s = s.concat(S);
              while (S.length > 0);
            } catch (P) {
              P_("upload", "error happens when handling directory upload", P);
            }
            yield h(s);
          } else if (aI(y)) try {
            const p = yield new Promise((s, S) => {
              y.file(s, S);
            });
            l.push({ file: p, entry: y, source: "dnd" });
          } catch (p) {
            P_("upload", "error happens when handling file upload", p);
          }
        }
      });
    }
    return yield h(r), l;
  });
}
function Dh(r) {
  const { id: n, name: l, percentage: h, status: f, url: y, file: p, thumbnailUrl: s, type: S, fullPath: P, batchId: M } = r;
  return { id: n, name: l, percentage: h ?? null, status: f, url: y ?? null, file: p ?? null, thumbnailUrl: s ?? null, type: S ?? null, fullPath: P ?? null, batchId: M ?? null };
}
function lI(r, n, l) {
  return r = r.toLowerCase(), n = n.toLocaleLowerCase(), l = l.toLocaleLowerCase(), l.split(",").map((f) => f.trim()).filter(Boolean).some((f) => {
    if (f.startsWith(".")) {
      if (r.endsWith(f)) return true;
    } else if (f.includes("/")) {
      const [y, p] = n.split("/"), [s, S] = f.split("/");
      if ((s === "*" || y && s && s === y) && (S === "*" || p && S && S === p)) return true;
    } else return true;
    return false;
  });
}
var fb = function(r, n, l, h) {
  function f(y) {
    return y instanceof l ? y : new l(function(p) {
      p(y);
    });
  }
  return new (l || (l = Promise))(function(y, p) {
    function s(M) {
      try {
        P(h.next(M));
      } catch (A) {
        p(A);
      }
    }
    function S(M) {
      try {
        P(h.throw(M));
      } catch (A) {
        p(A);
      }
    }
    function P(M) {
      M.done ? y(M.value) : f(M.value).then(s, S);
    }
    P((h = h.apply(r, n || [])).next());
  });
};
const Pp = { paddingMedium: "0 3px", heightMedium: "24px", iconSizeMedium: "18px" }, uI = nt({ name: "UploadFile", props: { clsPrefix: { type: String, required: true }, file: { type: Object, required: true }, listType: { type: String, required: true }, index: { type: Number, required: true } }, setup(r) {
  const n = cr(Vc), l = Ee(null), h = Ee(""), f = Ae(() => {
    const { file: oe } = r;
    return oe.status === "finished" ? "success" : oe.status === "error" ? "error" : "info";
  }), y = Ae(() => {
    const { file: oe } = r;
    if (oe.status === "error") return "error";
  }), p = Ae(() => {
    const { file: oe } = r;
    return oe.status === "uploading";
  }), s = Ae(() => {
    if (!n.showCancelButtonRef.value) return false;
    const { file: oe } = r;
    return ["uploading", "pending", "error"].includes(oe.status);
  }), S = Ae(() => {
    if (!n.showRemoveButtonRef.value) return false;
    const { file: oe } = r;
    return ["finished"].includes(oe.status);
  }), P = Ae(() => {
    if (!n.showDownloadButtonRef.value) return false;
    const { file: oe } = r;
    return ["finished"].includes(oe.status);
  }), M = Ae(() => {
    if (!n.showRetryButtonRef.value) return false;
    const { file: oe } = r;
    return ["error"].includes(oe.status);
  }), A = vi(() => h.value || r.file.thumbnailUrl || r.file.url), O = Ae(() => {
    if (!n.showPreviewButtonRef.value) return false;
    const { file: { status: oe }, listType: ee } = r;
    return ["finished"].includes(oe) && A.value && ee === "image-card";
  });
  function j() {
    return fb(this, void 0, void 0, function* () {
      const oe = n.onRetryRef.value;
      oe && (yield oe({ file: r.file })) === false || n.submit(r.file.id);
    });
  }
  function L(oe) {
    oe.preventDefault();
    const { file: ee } = r;
    ["finished", "pending", "error"].includes(ee.status) ? N(ee) : ["uploading"].includes(ee.status) ? te(ee) : Gp("upload", "The button clicked type is unknown.");
  }
  function q(oe) {
    oe.preventDefault(), J(r.file);
  }
  function N(oe) {
    const { xhrMap: ee, doChange: ke, onRemoveRef: { value: ve }, mergedFileListRef: { value: le } } = n;
    Promise.resolve(ve ? ve({ file: Object.assign({}, oe), fileList: le, index: r.index }) : true).then((ue) => {
      if (ue === false) return;
      const be = Object.assign({}, oe, { status: "removed" });
      ee.delete(oe.id), ke(be, void 0, { remove: true });
    });
  }
  function J(oe) {
    const { onDownloadRef: { value: ee }, customDownloadRef: { value: ke } } = n;
    Promise.resolve(ee ? ee(Object.assign({}, oe)) : true).then((ve) => {
      ve !== false && (ke ? ke(Object.assign({}, oe)) : H1(oe.url, oe.name));
    });
  }
  function te(oe) {
    const { xhrMap: ee } = n, ke = ee.get(oe.id);
    ke == null ? void 0 : ke.abort(), N(Object.assign({}, oe));
  }
  function ne(oe) {
    const { onPreviewRef: { value: ee } } = n;
    if (ee) ee(r.file, { event: oe });
    else if (r.listType === "image-card") {
      const { value: ke } = l;
      if (!ke) return;
      ke.showPreview();
    }
  }
  const ae = () => fb(this, void 0, void 0, function* () {
    const { listType: oe } = r;
    oe !== "image" && oe !== "image-card" || n.shouldUseThumbnailUrlRef.value(r.file) && (h.value = yield n.getFileThumbnailUrlResolver(r.file));
  });
  return Ao(() => {
    ae();
  }), { mergedTheme: n.mergedThemeRef, progressStatus: f, buttonType: y, showProgress: p, disabled: n.mergedDisabledRef, showCancelButton: s, showRemoveButton: S, showDownloadButton: P, showRetryButton: M, showPreviewButton: O, mergedThumbnailUrl: A, shouldUseThumbnailUrl: n.shouldUseThumbnailUrlRef, renderIcon: n.renderIconRef, imageRef: l, handleRemoveOrCancelClick: L, handleDownloadClick: q, handleRetryClick: j, handlePreviewClick: ne };
}, render() {
  const { clsPrefix: r, mergedTheme: n, listType: l, file: h, renderIcon: f } = this;
  let y;
  const p = l === "image";
  p || l === "image-card" ? y = !this.shouldUseThumbnailUrl(h) || !this.mergedThumbnailUrl ? B("span", { class: `${r}-upload-file-info__thumbnail` }, f ? f(h) : Mx(h) ? B(Nr, { clsPrefix: r }, { default: eI }) : B(Nr, { clsPrefix: r }, { default: tI })) : B("a", { rel: "noopener noreferer", target: "_blank", href: h.url || void 0, class: `${r}-upload-file-info__thumbnail`, onClick: this.handlePreviewClick }, l === "image-card" ? B(xx, { src: this.mergedThumbnailUrl || void 0, previewSrc: h.url || void 0, alt: h.name, ref: "imageRef" }) : B("img", { src: this.mergedThumbnailUrl || void 0, alt: h.name })) : y = B("span", { class: `${r}-upload-file-info__thumbnail` }, f ? f(h) : B(Nr, { clsPrefix: r }, { default: () => B(QT, null) }));
  const S = B(rI, { show: this.showProgress, percentage: h.percentage || 0, status: this.progressStatus }), P = l === "text" || l === "image";
  return B("div", { class: [`${r}-upload-file`, `${r}-upload-file--${this.progressStatus}-status`, h.url && h.status !== "error" && l !== "image-card" && `${r}-upload-file--with-url`, `${r}-upload-file--${l}-type`] }, B("div", { class: `${r}-upload-file-info` }, y, B("div", { class: `${r}-upload-file-info__name` }, P && (h.url && h.status !== "error" ? B("a", { rel: "noopener noreferer", target: "_blank", href: h.url || void 0, onClick: this.handlePreviewClick }, h.name) : B("span", { onClick: this.handlePreviewClick }, h.name)), p && S), B("div", { class: [`${r}-upload-file-info__action`, `${r}-upload-file-info__action--${l}-type`] }, this.showPreviewButton ? B(Or, { key: "preview", quaternary: true, type: this.buttonType, onClick: this.handlePreviewClick, theme: n.peers.Button, themeOverrides: n.peerOverrides.Button, builtinThemeOverrides: Pp }, { icon: () => B(Nr, { clsPrefix: r }, { default: () => B(Y1, null) }) }) : null, (this.showRemoveButton || this.showCancelButton) && !this.disabled && B(Or, { key: "cancelOrTrash", theme: n.peers.Button, themeOverrides: n.peerOverrides.Button, quaternary: true, builtinThemeOverrides: Pp, type: this.buttonType, onClick: this.handleRemoveOrCancelClick }, { icon: () => B(im, null, { default: () => this.showRemoveButton ? B(Nr, { clsPrefix: r, key: "trash" }, { default: () => B(hP, null) }) : B(Nr, { clsPrefix: r, key: "cancel" }, { default: () => B(eP, null) }) }) }), this.showRetryButton && !this.disabled && B(Or, { key: "retry", quaternary: true, type: this.buttonType, onClick: this.handleRetryClick, theme: n.peers.Button, themeOverrides: n.peerOverrides.Button, builtinThemeOverrides: Pp }, { icon: () => B(Nr, { clsPrefix: r }, { default: () => B(uP, null) }) }), this.showDownloadButton ? B(Or, { key: "download", quaternary: true, type: this.buttonType, onClick: this.handleDownloadClick, theme: n.peers.Button, themeOverrides: n.peerOverrides.Button, builtinThemeOverrides: Pp }, { icon: () => B(Nr, { clsPrefix: r }, { default: () => B(X1, null) }) }) : null)), !p && S);
} }), Dx = nt({ name: "UploadTrigger", props: { abstract: Boolean }, slots: Object, setup(r, { slots: n }) {
  const l = cr(Vc, null);
  l || fa("upload-trigger", "`n-upload-trigger` must be placed inside `n-upload`.");
  const { mergedClsPrefixRef: h, mergedDisabledRef: f, maxReachedRef: y, listTypeRef: p, dragOverRef: s, openOpenFileDialog: S, draggerInsideRef: P, handleFileAddition: M, mergedDirectoryDndRef: A, triggerClassRef: O, triggerStyleRef: j } = l, L = Ae(() => p.value === "image-card");
  function q() {
    f.value || y.value || S();
  }
  function N(ae) {
    ae.preventDefault(), s.value = true;
  }
  function J(ae) {
    ae.preventDefault(), s.value = true;
  }
  function te(ae) {
    ae.preventDefault(), s.value = false;
  }
  function ne(ae) {
    var oe;
    if (ae.preventDefault(), !P.value || f.value || y.value) {
      s.value = false;
      return;
    }
    const ee = (oe = ae.dataTransfer) === null || oe === void 0 ? void 0 : oe.items;
    (ee == null ? void 0 : ee.length) ? sI(Array.from(ee).map((ke) => ke.webkitGetAsEntry()), A.value).then((ke) => {
      M(ke);
    }).finally(() => {
      s.value = false;
    }) : s.value = false;
  }
  return () => {
    var ae;
    const { value: oe } = h;
    return r.abstract ? (ae = n.default) === null || ae === void 0 ? void 0 : ae.call(n, { handleClick: q, handleDrop: ne, handleDragOver: N, handleDragEnter: J, handleDragLeave: te }) : B("div", { class: [`${oe}-upload-trigger`, (f.value || y.value) && `${oe}-upload-trigger--disabled`, L.value && `${oe}-upload-trigger--image-card`, O.value], style: j.value, onClick: q, onDrop: ne, onDragover: N, onDragenter: J, onDragleave: te }, L.value ? B(Ix, null, { default: () => to(n.default, () => [B(Nr, { clsPrefix: oe }, { default: () => B(fm, null) })]) }) : n);
  };
} }), cI = nt({ name: "UploadFileList", setup(r, { slots: n }) {
  const l = cr(Vc, null);
  l || fa("upload-file-list", "`n-upload-file-list` must be placed inside `n-upload`.");
  const { abstractRef: h, mergedClsPrefixRef: f, listTypeRef: y, mergedFileListRef: p, fileListClassRef: s, fileListStyleRef: S, cssVarsRef: P, themeClassRef: M, maxReachedRef: A, showTriggerRef: O, imageGroupPropsRef: j } = l, L = Ae(() => y.value === "image-card"), q = () => p.value.map((J, te) => B(uI, { clsPrefix: f.value, key: J.id, file: J, index: te, listType: y.value })), N = () => L.value ? B(h4, Object.assign({}, j.value), { default: q }) : B(sm, { group: true }, { default: q });
  return () => {
    const { value: J } = f, { value: te } = h;
    return B("div", { class: [`${J}-upload-file-list`, L.value && `${J}-upload-file-list--grid`, te ? M == null ? void 0 : M.value : void 0, s.value], style: [te && P ? P.value : "", S.value] }, N(), O.value && !A.value && L.value && B(Dx, null, n));
  };
} });
var pb = function(r, n, l, h) {
  function f(y) {
    return y instanceof l ? y : new l(function(p) {
      p(y);
    });
  }
  return new (l || (l = Promise))(function(y, p) {
    function s(M) {
      try {
        P(h.next(M));
      } catch (A) {
        p(A);
      }
    }
    function S(M) {
      try {
        P(h.throw(M));
      } catch (A) {
        p(A);
      }
    }
    function P(M) {
      M.done ? y(M.value) : f(M.value).then(s, S);
    }
    P((h = h.apply(r, n || [])).next());
  });
};
function dI(r, n, l) {
  const { doChange: h, xhrMap: f } = r;
  let y = 0;
  function p(S) {
    var P;
    let M = Object.assign({}, n, { status: "error", percentage: y });
    f.delete(n.id), M = Dh(((P = r.onError) === null || P === void 0 ? void 0 : P.call(r, { file: M, event: S })) || M), h(M, S);
  }
  function s(S) {
    var P;
    if (r.isErrorState) {
      if (r.isErrorState(l)) {
        p(S);
        return;
      }
    } else if (l.status < 200 || l.status >= 300) {
      p(S);
      return;
    }
    let M = Object.assign({}, n, { status: "finished", percentage: y });
    f.delete(n.id), M = Dh(((P = r.onFinish) === null || P === void 0 ? void 0 : P.call(r, { file: M, event: S })) || M), h(M, S);
  }
  return { handleXHRLoad: s, handleXHRError: p, handleXHRAbort(S) {
    const P = Object.assign({}, n, { status: "removed", file: null, percentage: y });
    f.delete(n.id), h(P, S);
  }, handleXHRProgress(S) {
    const P = Object.assign({}, n, { status: "uploading" });
    if (S.lengthComputable) {
      const M = Math.ceil(S.loaded / S.total * 100);
      P.percentage = M, y = M;
    }
    h(P, S);
  } };
}
function hI(r) {
  const { inst: n, file: l, data: h, headers: f, withCredentials: y, action: p, customRequest: s } = r, { doChange: S } = r.inst;
  let P = 0;
  s({ file: l, data: h, headers: f, withCredentials: y, action: p, onProgress(M) {
    const A = Object.assign({}, l, { status: "uploading" }), O = M.percent;
    A.percentage = O, P = O, S(A);
  }, onFinish() {
    var M;
    let A = Object.assign({}, l, { status: "finished", percentage: P });
    A = Dh(((M = n.onFinish) === null || M === void 0 ? void 0 : M.call(n, { file: A })) || A), S(A);
  }, onError() {
    var M;
    let A = Object.assign({}, l, { status: "error", percentage: P });
    A = Dh(((M = n.onError) === null || M === void 0 ? void 0 : M.call(n, { file: A })) || A), S(A);
  } });
}
function fI(r, n, l) {
  const h = dI(r, n, l);
  l.onabort = h.handleXHRAbort, l.onerror = h.handleXHRError, l.onload = h.handleXHRLoad, l.upload && (l.upload.onprogress = h.handleXHRProgress);
}
function Rx(r, n) {
  return typeof r == "function" ? r({ file: n }) : r || {};
}
function pI(r, n, l) {
  const h = Rx(n, l);
  h && Object.keys(h).forEach((f) => {
    r.setRequestHeader(f, h[f]);
  });
}
function mI(r, n, l) {
  const h = Rx(n, l);
  h && Object.keys(h).forEach((f) => {
    r.append(f, h[f]);
  });
}
function gI(r, n, l, { method: h, action: f, withCredentials: y, responseType: p, headers: s, data: S }) {
  const P = new XMLHttpRequest();
  P.responseType = p, r.xhrMap.set(l.id, P), P.withCredentials = y;
  const M = new FormData();
  if (mI(M, S, l), l.file !== null && M.append(n, l.file), fI(r, l, P), f !== void 0) {
    P.open(h.toUpperCase(), f), pI(P, s, l), P.send(M);
    const A = Object.assign({}, l, { status: "uploading" });
    r.doChange(A);
  }
}
const vI = Object.assign(Object.assign({}, er.props), { name: { type: String, default: "file" }, accept: String, action: String, customRequest: Function, directory: Boolean, directoryDnd: { type: Boolean, default: void 0 }, method: { type: String, default: "POST" }, multiple: Boolean, showFileList: { type: Boolean, default: true }, data: [Object, Function], headers: [Object, Function], withCredentials: Boolean, responseType: { type: String, default: "" }, disabled: { type: Boolean, default: void 0 }, onChange: Function, onRemove: Function, onFinish: Function, onError: Function, onRetry: Function, onBeforeUpload: Function, isErrorState: Function, onDownload: Function, customDownload: Function, defaultUpload: { type: Boolean, default: true }, fileList: Array, "onUpdate:fileList": [Function, Array], onUpdateFileList: [Function, Array], fileListClass: String, fileListStyle: [String, Object], defaultFileList: { type: Array, default: () => [] }, showCancelButton: { type: Boolean, default: true }, showRemoveButton: { type: Boolean, default: true }, showDownloadButton: Boolean, showRetryButton: { type: Boolean, default: true }, showPreviewButton: { type: Boolean, default: true }, listType: { type: String, default: "text" }, onPreview: Function, shouldUseThumbnailUrl: { type: Function, default: (r) => nI ? Mx(r) : false }, createThumbnailUrl: Function, abstract: Boolean, max: Number, showTrigger: { type: Boolean, default: true }, imageGroupProps: Object, inputProps: Object, triggerClass: String, triggerStyle: [String, Object], renderIcon: Function }), yI = nt({ name: "Upload", props: vI, setup(r) {
  r.abstract && r.listType === "image-card" && fa("upload", "when the list-type is image-card, abstract is not supported.");
  const { mergedClsPrefixRef: n, inlineThemeDisabled: l, mergedRtlRef: h } = Cr(r), f = er("Upload", "-upload", Q4, lS, r, n), y = Ln("Upload", h, n), p = Ba(r), s = Ee(r.defaultFileList), S = zt(r, "fileList"), P = Ee(null), M = { value: false }, A = Ee(false), O = /* @__PURE__ */ new Map(), j = Qi(S, s), L = Ae(() => j.value.map(Dh)), q = Ae(() => {
    const { max: be } = r;
    return be !== void 0 ? L.value.length >= be : false;
  });
  function N() {
    var be;
    (be = P.value) === null || be === void 0 || be.click();
  }
  function J(be) {
    const Ve = be.target;
    oe(Ve.files ? Array.from(Ve.files).map((Ge) => ({ file: Ge, entry: null, source: "input" })) : null, be), Ve.value = "";
  }
  function te(be) {
    const { "onUpdate:fileList": Ve, onUpdateFileList: Ge } = r;
    Ve && jt(Ve, be), Ge && jt(Ge, be), s.value = be;
  }
  const ne = Ae(() => r.multiple || r.directory), ae = (be, Ve, Ge = { append: false, remove: false }) => {
    const { append: et, remove: dt } = Ge, Ct = Array.from(L.value), kt = Ct.findIndex((ct) => ct.id === be.id);
    if (et || dt || ~kt) {
      et ? Ct.push(be) : dt ? Ct.splice(kt, 1) : Ct.splice(kt, 1, be);
      const { onChange: ct } = r;
      ct && ct({ file: be, fileList: Ct, event: Ve }), te(Ct);
    }
  };
  function oe(be, Ve) {
    if (!be || be.length === 0) return;
    const { onBeforeUpload: Ge } = r;
    be = ne.value ? be : [be[0]];
    const { max: et, accept: dt } = r;
    be = be.filter(({ file: kt, source: ct }) => ct === "dnd" && (dt == null ? void 0 : dt.trim()) ? lI(kt.name, kt.type, dt) : true), et && (be = be.slice(0, et - L.value.length));
    const Ct = Kl();
    Promise.all(be.map((kt) => pb(this, [kt], void 0, function* ({ file: ct, entry: it }) {
      var pt;
      const $t = { id: Kl(), batchId: Ct, name: ct.name, status: "pending", percentage: 0, file: ct, url: null, type: ct.type, thumbnailUrl: null, fullPath: (pt = it == null ? void 0 : it.fullPath) !== null && pt !== void 0 ? pt : `/${ct.webkitRelativePath || ct.name}` };
      return !Ge || (yield Ge({ file: $t, fileList: L.value })) !== false ? $t : null;
    }))).then((kt) => pb(this, void 0, void 0, function* () {
      let ct = Promise.resolve();
      kt.forEach((it) => {
        ct = ct.then(eo).then(() => {
          it && ae(it, Ve, { append: true });
        });
      }), yield ct;
    })).then(() => {
      r.defaultUpload && ee();
    });
  }
  function ee(be) {
    const { method: Ve, action: Ge, withCredentials: et, headers: dt, data: Ct, name: kt } = r, ct = be !== void 0 ? L.value.filter((pt) => pt.id === be) : L.value, it = be !== void 0;
    ct.forEach((pt) => {
      const { status: $t } = pt;
      ($t === "pending" || $t === "error" && it) && (r.customRequest ? hI({ inst: { doChange: ae, xhrMap: O, onFinish: r.onFinish, onError: r.onError }, file: pt, action: Ge, withCredentials: et, headers: dt, data: Ct, customRequest: r.customRequest }) : gI({ doChange: ae, xhrMap: O, onFinish: r.onFinish, onError: r.onError, isErrorState: r.isErrorState }, kt, pt, { method: Ve, action: Ge, withCredentials: et, responseType: r.responseType, headers: dt, data: Ct }));
    });
  }
  function ke(be) {
    var Ve;
    if (be.thumbnailUrl) return be.thumbnailUrl;
    const { createThumbnailUrl: Ge } = r;
    return Ge ? (Ve = Ge(be.file, be)) !== null && Ve !== void 0 ? Ve : be.url || "" : be.url ? be.url : be.file ? iI(be.file) : "";
  }
  const ve = Ae(() => {
    const { common: { cubicBezierEaseInOut: be }, self: { draggerColor: Ve, draggerBorder: Ge, draggerBorderHover: et, itemColorHover: dt, itemColorHoverError: Ct, itemTextColorError: kt, itemTextColorSuccess: ct, itemTextColor: it, itemIconColor: pt, itemDisabledOpacity: $t, lineHeight: vt, borderRadius: Pt, fontSize: Nt, itemBorderImageCardError: ir, itemBorderImageCard: bt } } = f.value;
    return { "--n-bezier": be, "--n-border-radius": Pt, "--n-dragger-border": Ge, "--n-dragger-border-hover": et, "--n-dragger-color": Ve, "--n-font-size": Nt, "--n-item-color-hover": dt, "--n-item-color-hover-error": Ct, "--n-item-disabled-opacity": $t, "--n-item-icon-color": pt, "--n-item-text-color": it, "--n-item-text-color-error": kt, "--n-item-text-color-success": ct, "--n-line-height": vt, "--n-item-border-image-card-error": ir, "--n-item-border-image-card": bt };
  }), le = l ? ai("upload", void 0, ve, r) : void 0;
  Vr(Vc, { mergedClsPrefixRef: n, mergedThemeRef: f, showCancelButtonRef: zt(r, "showCancelButton"), showDownloadButtonRef: zt(r, "showDownloadButton"), showRemoveButtonRef: zt(r, "showRemoveButton"), showRetryButtonRef: zt(r, "showRetryButton"), onRemoveRef: zt(r, "onRemove"), onDownloadRef: zt(r, "onDownload"), customDownloadRef: zt(r, "customDownload"), mergedFileListRef: L, triggerClassRef: zt(r, "triggerClass"), triggerStyleRef: zt(r, "triggerStyle"), shouldUseThumbnailUrlRef: zt(r, "shouldUseThumbnailUrl"), renderIconRef: zt(r, "renderIcon"), xhrMap: O, submit: ee, doChange: ae, showPreviewButtonRef: zt(r, "showPreviewButton"), onPreviewRef: zt(r, "onPreview"), getFileThumbnailUrlResolver: ke, listTypeRef: zt(r, "listType"), dragOverRef: A, openOpenFileDialog: N, draggerInsideRef: M, handleFileAddition: oe, mergedDisabledRef: p.mergedDisabledRef, maxReachedRef: q, fileListClassRef: zt(r, "fileListClass"), fileListStyleRef: zt(r, "fileListStyle"), abstractRef: zt(r, "abstract"), acceptRef: zt(r, "accept"), cssVarsRef: l ? void 0 : ve, themeClassRef: le == null ? void 0 : le.themeClass, onRender: le == null ? void 0 : le.onRender, showTriggerRef: zt(r, "showTrigger"), imageGroupPropsRef: zt(r, "imageGroupProps"), mergedDirectoryDndRef: Ae(() => {
    var be;
    return (be = r.directoryDnd) !== null && be !== void 0 ? be : r.directory;
  }), onRetryRef: zt(r, "onRetry") });
  const ue = { clear: () => {
    s.value = [];
  }, submit: ee, openOpenFileDialog: N };
  return Object.assign({ mergedClsPrefix: n, draggerInsideRef: M, rtlEnabled: y, inputElRef: P, mergedTheme: f, dragOver: A, mergedMultiple: ne, cssVars: l ? void 0 : ve, themeClass: le == null ? void 0 : le.themeClass, onRender: le == null ? void 0 : le.onRender, handleFileInputChange: J }, ue);
}, render() {
  var r, n;
  const { draggerInsideRef: l, mergedClsPrefix: h, $slots: f, directory: y, onRender: p } = this;
  if (f.default && !this.abstract) {
    const S = f.default()[0];
    !((r = S == null ? void 0 : S.type) === null || r === void 0) && r[Px] && (l.value = true);
  }
  const s = B("input", Object.assign({}, this.inputProps, { ref: "inputElRef", type: "file", class: `${h}-upload-file-input`, accept: this.accept, multiple: this.mergedMultiple, onChange: this.handleFileInputChange, webkitdirectory: y || void 0, directory: y || void 0 }));
  return this.abstract ? B(jr, null, (n = f.default) === null || n === void 0 ? void 0 : n.call(f), B(Jb, { to: "body" }, s)) : (p == null ? void 0 : p(), B("div", { class: [`${h}-upload`, this.rtlEnabled && `${h}-upload--rtl`, l.value && `${h}-upload--dragger-inside`, this.dragOver && `${h}-upload--drag-over`, this.themeClass], style: this.cssVars }, s, this.showTrigger && this.listType !== "image-card" && B(Dx, null, f), this.showFileList && B(cI, null, f)));
} });
function Vs() {
  const r = cr(n1, null);
  return Ae(() => {
    if (r === null) return I_;
    const { mergedThemeRef: { value: n }, mergedThemeOverridesRef: { value: l } } = r, h = (n == null ? void 0 : n.common) || I_;
    return (l == null ? void 0 : l.common) ? Object.assign({}, h, l.common) : h;
  });
}
var Np = { exports: {} };
/**
* MapLibre GL JS
* @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.12.0/LICENSE.txt
*/
var _I = Np.exports, mb;
function bI() {
  return mb || (mb = 1, (function(r, n) {
    (function(l, h) {
      r.exports = h();
    })(_I, (function() {
      var l = {}, h = {};
      function f(p, s, S) {
        if (h[p] = S, p === "index") {
          var P = "var sharedModule = {}; (" + h.shared + ")(sharedModule); (" + h.worker + ")(sharedModule);", M = {};
          return h.shared(M), h.index(l, M), typeof window < "u" && l.setWorkerUrl(window.URL.createObjectURL(new Blob([P], { type: "text/javascript" }))), l;
        }
      }
      f("shared", ["exports"], (function(p) {
        function s(o, e, i, u) {
          return new (i || (i = Promise))((function(c, m) {
            function v(k) {
              try {
                C(u.next(k));
              } catch (E) {
                m(E);
              }
            }
            function x(k) {
              try {
                C(u.throw(k));
              } catch (E) {
                m(E);
              }
            }
            function C(k) {
              var E;
              k.done ? c(k.value) : (E = k.value, E instanceof i ? E : new i((function(D) {
                D(E);
              }))).then(v, x);
            }
            C((u = u.apply(o, e || [])).next());
          }));
        }
        function S(o, e) {
          this.x = o, this.y = e;
        }
        function P(o) {
          return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
        }
        var M, A;
        typeof SuppressedError == "function" && SuppressedError, S.prototype = { clone() {
          return new S(this.x, this.y);
        }, add(o) {
          return this.clone()._add(o);
        }, sub(o) {
          return this.clone()._sub(o);
        }, multByPoint(o) {
          return this.clone()._multByPoint(o);
        }, divByPoint(o) {
          return this.clone()._divByPoint(o);
        }, mult(o) {
          return this.clone()._mult(o);
        }, div(o) {
          return this.clone()._div(o);
        }, rotate(o) {
          return this.clone()._rotate(o);
        }, rotateAround(o, e) {
          return this.clone()._rotateAround(o, e);
        }, matMult(o) {
          return this.clone()._matMult(o);
        }, unit() {
          return this.clone()._unit();
        }, perp() {
          return this.clone()._perp();
        }, round() {
          return this.clone()._round();
        }, mag() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals(o) {
          return this.x === o.x && this.y === o.y;
        }, dist(o) {
          return Math.sqrt(this.distSqr(o));
        }, distSqr(o) {
          const e = o.x - this.x, i = o.y - this.y;
          return e * e + i * i;
        }, angle() {
          return Math.atan2(this.y, this.x);
        }, angleTo(o) {
          return Math.atan2(this.y - o.y, this.x - o.x);
        }, angleWith(o) {
          return this.angleWithSep(o.x, o.y);
        }, angleWithSep(o, e) {
          return Math.atan2(this.x * e - this.y * o, this.x * o + this.y * e);
        }, _matMult(o) {
          const e = o[2] * this.x + o[3] * this.y;
          return this.x = o[0] * this.x + o[1] * this.y, this.y = e, this;
        }, _add(o) {
          return this.x += o.x, this.y += o.y, this;
        }, _sub(o) {
          return this.x -= o.x, this.y -= o.y, this;
        }, _mult(o) {
          return this.x *= o, this.y *= o, this;
        }, _div(o) {
          return this.x /= o, this.y /= o, this;
        }, _multByPoint(o) {
          return this.x *= o.x, this.y *= o.y, this;
        }, _divByPoint(o) {
          return this.x /= o.x, this.y /= o.y, this;
        }, _unit() {
          return this._div(this.mag()), this;
        }, _perp() {
          const o = this.y;
          return this.y = this.x, this.x = -o, this;
        }, _rotate(o) {
          const e = Math.cos(o), i = Math.sin(o), u = i * this.x + e * this.y;
          return this.x = e * this.x - i * this.y, this.y = u, this;
        }, _rotateAround(o, e) {
          const i = Math.cos(o), u = Math.sin(o), c = e.y + u * (this.x - e.x) + i * (this.y - e.y);
          return this.x = e.x + i * (this.x - e.x) - u * (this.y - e.y), this.y = c, this;
        }, _round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }, constructor: S }, S.convert = function(o) {
          if (o instanceof S) return o;
          if (Array.isArray(o)) return new S(+o[0], +o[1]);
          if (o.x !== void 0 && o.y !== void 0) return new S(+o.x, +o.y);
          throw new Error("Expected [x, y] or {x, y} point format");
        };
        var O = (function() {
          if (A) return M;
          function o(e, i, u, c) {
            this.cx = 3 * e, this.bx = 3 * (u - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * i, this.by = 3 * (c - i) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = i, this.p2x = u, this.p2y = c;
          }
          return A = 1, M = o, o.prototype = { sampleCurveX: function(e) {
            return ((this.ax * e + this.bx) * e + this.cx) * e;
          }, sampleCurveY: function(e) {
            return ((this.ay * e + this.by) * e + this.cy) * e;
          }, sampleCurveDerivativeX: function(e) {
            return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
          }, solveCurveX: function(e, i) {
            if (i === void 0 && (i = 1e-6), e < 0) return 0;
            if (e > 1) return 1;
            for (var u = e, c = 0; c < 8; c++) {
              var m = this.sampleCurveX(u) - e;
              if (Math.abs(m) < i) return u;
              var v = this.sampleCurveDerivativeX(u);
              if (Math.abs(v) < 1e-6) break;
              u -= m / v;
            }
            var x = 0, C = 1;
            for (u = e, c = 0; c < 20 && (m = this.sampleCurveX(u), !(Math.abs(m - e) < i)); c++) e > m ? x = u : C = u, u = 0.5 * (C - x) + x;
            return u;
          }, solve: function(e, i) {
            return this.sampleCurveY(this.solveCurveX(e, i));
          } }, M;
        })(), j = P(O);
        let L, q;
        function N() {
          return L == null && (L = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), L;
        }
        function J() {
          if (q == null && (q = false, N())) {
            const e = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: true });
            if (e) {
              for (let u = 0; u < 25; u++) {
                const c = 4 * u;
                e.fillStyle = `rgb(${c},${c + 1},${c + 2})`, e.fillRect(u % 5, Math.floor(u / 5), 1, 1);
              }
              const i = e.getImageData(0, 0, 5, 5).data;
              for (let u = 0; u < 100; u++) if (u % 4 != 3 && i[u] !== u) {
                q = true;
                break;
              }
            }
          }
          return q || false;
        }
        var te = 1e-6, ne = typeof Float32Array < "u" ? Float32Array : Array;
        function ae() {
          var o = new ne(9);
          return ne != Float32Array && (o[1] = 0, o[2] = 0, o[3] = 0, o[5] = 0, o[6] = 0, o[7] = 0), o[0] = 1, o[4] = 1, o[8] = 1, o;
        }
        function oe(o) {
          return o[0] = 1, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = 1, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 1, o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, o;
        }
        function ee() {
          var o = new ne(3);
          return ne != Float32Array && (o[0] = 0, o[1] = 0, o[2] = 0), o;
        }
        function ke(o) {
          var e = o[0], i = o[1], u = o[2];
          return Math.sqrt(e * e + i * i + u * u);
        }
        function ve(o, e, i) {
          var u = new ne(3);
          return u[0] = o, u[1] = e, u[2] = i, u;
        }
        function le(o, e, i) {
          return o[0] = e[0] + i[0], o[1] = e[1] + i[1], o[2] = e[2] + i[2], o;
        }
        function ue(o, e, i) {
          return o[0] = e[0] * i, o[1] = e[1] * i, o[2] = e[2] * i, o;
        }
        function be(o, e, i) {
          var u = e[0], c = e[1], m = e[2], v = i[0], x = i[1], C = i[2];
          return o[0] = c * C - m * x, o[1] = m * v - u * C, o[2] = u * x - c * v, o;
        }
        var Ve, Ge = ke;
        function et(o, e, i) {
          var u = e[0], c = e[1], m = e[2], v = e[3];
          return o[0] = i[0] * u + i[4] * c + i[8] * m + i[12] * v, o[1] = i[1] * u + i[5] * c + i[9] * m + i[13] * v, o[2] = i[2] * u + i[6] * c + i[10] * m + i[14] * v, o[3] = i[3] * u + i[7] * c + i[11] * m + i[15] * v, o;
        }
        function dt() {
          var o = new ne(4);
          return ne != Float32Array && (o[0] = 0, o[1] = 0, o[2] = 0), o[3] = 1, o;
        }
        function Ct(o, e, i, u) {
          var c = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "zyx", m = Math.PI / 360;
          e *= m, u *= m, i *= m;
          var v = Math.sin(e), x = Math.cos(e), C = Math.sin(i), k = Math.cos(i), E = Math.sin(u), D = Math.cos(u);
          switch (c) {
            case "xyz":
              o[0] = v * k * D + x * C * E, o[1] = x * C * D - v * k * E, o[2] = x * k * E + v * C * D, o[3] = x * k * D - v * C * E;
              break;
            case "xzy":
              o[0] = v * k * D - x * C * E, o[1] = x * C * D - v * k * E, o[2] = x * k * E + v * C * D, o[3] = x * k * D + v * C * E;
              break;
            case "yxz":
              o[0] = v * k * D + x * C * E, o[1] = x * C * D - v * k * E, o[2] = x * k * E - v * C * D, o[3] = x * k * D + v * C * E;
              break;
            case "yzx":
              o[0] = v * k * D + x * C * E, o[1] = x * C * D + v * k * E, o[2] = x * k * E - v * C * D, o[3] = x * k * D - v * C * E;
              break;
            case "zxy":
              o[0] = v * k * D - x * C * E, o[1] = x * C * D + v * k * E, o[2] = x * k * E + v * C * D, o[3] = x * k * D - v * C * E;
              break;
            case "zyx":
              o[0] = v * k * D - x * C * E, o[1] = x * C * D + v * k * E, o[2] = x * k * E - v * C * D, o[3] = x * k * D + v * C * E;
              break;
            default:
              throw new Error("Unknown angle order " + c);
          }
          return o;
        }
        function kt() {
          var o = new ne(2);
          return ne != Float32Array && (o[0] = 0, o[1] = 0), o;
        }
        function ct(o, e) {
          var i = new ne(2);
          return i[0] = o, i[1] = e, i;
        }
        ee(), Ve = new ne(4), ne != Float32Array && (Ve[0] = 0, Ve[1] = 0, Ve[2] = 0, Ve[3] = 0), ee(), ve(1, 0, 0), ve(0, 1, 0), dt(), dt(), ae(), kt();
        const it = 8192;
        function pt(o, e, i) {
          return e * (it / (o.tileSize * Math.pow(2, i - o.tileID.overscaledZ)));
        }
        function $t(o, e) {
          return (o % e + e) % e;
        }
        function vt(o, e, i) {
          return o * (1 - i) + e * i;
        }
        function Pt(o) {
          if (o <= 0) return 0;
          if (o >= 1) return 1;
          const e = o * o, i = e * o;
          return 4 * (o < 0.5 ? i : 3 * (o - e) + i - 0.75);
        }
        function Nt(o, e, i, u) {
          const c = new j(o, e, i, u);
          return (m) => c.solve(m);
        }
        const ir = Nt(0.25, 0.1, 0.25, 1);
        function bt(o, e, i) {
          return Math.min(i, Math.max(e, o));
        }
        function Dt(o, e, i) {
          const u = i - e, c = ((o - e) % u + u) % u + e;
          return c === e ? i : c;
        }
        function Zt(o, ...e) {
          for (const i of e) for (const u in i) o[u] = i[u];
          return o;
        }
        let dr = 1;
        function yr(o, e, i) {
          const u = {};
          for (const c in o) u[c] = e.call(this, o[c], c, o);
          return u;
        }
        function Pr(o, e, i) {
          const u = {};
          for (const c in o) e.call(this, o[c], c, o) && (u[c] = o[c]);
          return u;
        }
        function lr(o) {
          return Array.isArray(o) ? o.map(lr) : typeof o == "object" && o ? yr(o, lr) : o;
        }
        const Ir = {};
        function Ht(o) {
          Ir[o] || (typeof console < "u" && console.warn(o), Ir[o] = true);
        }
        function Rr(o, e, i) {
          return (i.y - o.y) * (e.x - o.x) > (e.y - o.y) * (i.x - o.x);
        }
        function xr(o) {
          return typeof WorkerGlobalScope < "u" && o !== void 0 && o instanceof WorkerGlobalScope;
        }
        let gt = null;
        function Be(o) {
          return typeof ImageBitmap < "u" && o instanceof ImageBitmap;
        }
        const ot = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function $e(o, e, i, u, c) {
          return s(this, void 0, void 0, (function* () {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const m = new VideoFrame(o, { timestamp: 0 });
            try {
              const v = m == null ? void 0 : m.format;
              if (!v || !v.startsWith("BGR") && !v.startsWith("RGB")) throw new Error(`Unrecognized format ${v}`);
              const x = v.startsWith("BGR"), C = new Uint8ClampedArray(u * c * 4);
              if (yield m.copyTo(C, (function(k, E, D, F, V) {
                const G = 4 * Math.max(-E, 0), H = (Math.max(0, D) - D) * F * 4 + G, Y = 4 * F, ie = Math.max(0, E), we = Math.max(0, D);
                return { rect: { x: ie, y: we, width: Math.min(k.width, E + F) - ie, height: Math.min(k.height, D + V) - we }, layout: [{ offset: H, stride: Y }] };
              })(o, e, i, u, c)), x) for (let k = 0; k < C.length; k += 4) {
                const E = C[k];
                C[k] = C[k + 2], C[k + 2] = E;
              }
              return C;
            } finally {
              m.close();
            }
          }));
        }
        let Ye, ht;
        function St(o, e, i, u) {
          return o.addEventListener(e, i, u), { unsubscribe: () => {
            o.removeEventListener(e, i, u);
          } };
        }
        function rt(o) {
          return o * Math.PI / 180;
        }
        function mt(o) {
          return o / Math.PI * 180;
        }
        const nr = { touchstart: true, touchmove: true, touchmoveWindow: true, touchend: true, touchcancel: true }, di = { dblclick: true, click: true, mouseover: true, mouseout: true, mousedown: true, mousemove: true, mousemoveWindow: true, mouseup: true, mouseupWindow: true, contextmenu: true, wheel: true }, wi = "AbortError";
        function xn() {
          return new Error(wi);
        }
        const en = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function wn(o) {
          return en.REGISTERED_PROTOCOLS[o.substring(0, o.indexOf("://"))];
        }
        const Cn = "global-dispatcher";
        class Bi extends Error {
          constructor(e, i, u, c) {
            super(`AJAXError: ${i} (${e}): ${u}`), this.status = e, this.statusText = i, this.url = u, this.body = c;
          }
        }
        const Ci = () => xr(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, Me = function(o, e) {
          if (/:\/\//.test(o.url) && !/^https?:|^file:/.test(o.url)) {
            const u = wn(o.url);
            if (u) return u(o, e);
            if (xr(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: o, targetMapId: Cn }, e);
          }
          if (!(/^file:/.test(i = o.url) || /^file:/.test(Ci()) && !/^\w+:/.test(i))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(u, c) {
              return s(this, void 0, void 0, (function* () {
                const m = new Request(u.url, { method: u.method || "GET", body: u.body, credentials: u.credentials, headers: u.headers, cache: u.cache, referrer: Ci(), signal: c.signal });
                let v, x;
                u.type !== "json" || m.headers.has("Accept") || m.headers.set("Accept", "application/json");
                try {
                  v = yield fetch(m);
                } catch (k) {
                  throw new Bi(0, k.message, u.url, new Blob());
                }
                if (!v.ok) {
                  const k = yield v.blob();
                  throw new Bi(v.status, v.statusText, u.url, k);
                }
                x = u.type === "arrayBuffer" || u.type === "image" ? v.arrayBuffer() : u.type === "json" ? v.json() : v.text();
                const C = yield x;
                if (c.signal.aborted) throw xn();
                return { data: C, cacheControl: v.headers.get("Cache-Control"), expires: v.headers.get("Expires") };
              }));
            })(o, e);
            if (xr(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: o, mustQueue: true, targetMapId: Cn }, e);
          }
          var i;
          return (function(u, c) {
            return new Promise(((m, v) => {
              var x;
              const C = new XMLHttpRequest();
              C.open(u.method || "GET", u.url, true), u.type !== "arrayBuffer" && u.type !== "image" || (C.responseType = "arraybuffer");
              for (const k in u.headers) C.setRequestHeader(k, u.headers[k]);
              u.type === "json" && (C.responseType = "text", !((x = u.headers) === null || x === void 0) && x.Accept || C.setRequestHeader("Accept", "application/json")), C.withCredentials = u.credentials === "include", C.onerror = () => {
                v(new Error(C.statusText));
              }, C.onload = () => {
                if (!c.signal.aborted) if ((C.status >= 200 && C.status < 300 || C.status === 0) && C.response !== null) {
                  let k = C.response;
                  if (u.type === "json") try {
                    k = JSON.parse(C.response);
                  } catch (E) {
                    return void v(E);
                  }
                  m({ data: k, cacheControl: C.getResponseHeader("Cache-Control"), expires: C.getResponseHeader("Expires") });
                } else {
                  const k = new Blob([C.response], { type: C.getResponseHeader("Content-Type") });
                  v(new Bi(C.status, C.statusText, u.url, k));
                }
              }, c.signal.addEventListener("abort", (() => {
                C.abort(), v(xn());
              })), C.send(u.body);
            }));
          })(o, e);
        };
        function $(o) {
          if (!o || o.indexOf("://") <= 0 || o.indexOf("data:image/") === 0 || o.indexOf("blob:") === 0) return true;
          const e = new URL(o), i = window.location;
          return e.protocol === i.protocol && e.host === i.host;
        }
        function Z(o, e, i) {
          i[o] && i[o].indexOf(e) !== -1 || (i[o] = i[o] || [], i[o].push(e));
        }
        function Q(o, e, i) {
          if (i && i[o]) {
            const u = i[o].indexOf(e);
            u !== -1 && i[o].splice(u, 1);
          }
        }
        class ge {
          constructor(e, i = {}) {
            Zt(this, i), this.type = e;
          }
        }
        class _e extends ge {
          constructor(e, i = {}) {
            super("error", Zt({ error: e }, i));
          }
        }
        class Re {
          on(e, i) {
            return this._listeners = this._listeners || {}, Z(e, i, this._listeners), { unsubscribe: () => {
              this.off(e, i);
            } };
          }
          off(e, i) {
            return Q(e, i, this._listeners), Q(e, i, this._oneTimeListeners), this;
          }
          once(e, i) {
            return i ? (this._oneTimeListeners = this._oneTimeListeners || {}, Z(e, i, this._oneTimeListeners), this) : new Promise(((u) => this.once(e, u)));
          }
          fire(e, i) {
            typeof e == "string" && (e = new ge(e, i || {}));
            const u = e.type;
            if (this.listens(u)) {
              e.target = this;
              const c = this._listeners && this._listeners[u] ? this._listeners[u].slice() : [];
              for (const x of c) x.call(this, e);
              const m = this._oneTimeListeners && this._oneTimeListeners[u] ? this._oneTimeListeners[u].slice() : [];
              for (const x of m) Q(u, x, this._oneTimeListeners), x.call(this, e);
              const v = this._eventedParent;
              v && (Zt(e, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), v.fire(e));
            } else e instanceof _e && console.error(e.error);
            return this;
          }
          listens(e) {
            return this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e);
          }
          setEventedParent(e, i) {
            return this._eventedParent = e, this._eventedParentData = i, this;
          }
        }
        var se = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, "font-faces": { type: "array", value: "fontFaces" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, encoding: { type: "enum", values: { mvt: {}, mlt: {} }, default: "mvt" }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, "color-relief": {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_color-relief": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: false, expression: { interpolated: true, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, "paint_color-relief": { "color-relief-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "color-relief-color": { type: "color", transition: false, expression: { interpolated: true, parameters: ["elevation"] }, "property-type": "color-ramp" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        const Fe = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function We(o, e) {
          const i = {};
          for (const u in o) u !== "ref" && (i[u] = o[u]);
          return Fe.forEach(((u) => {
            u in e && (i[u] = e[u]);
          })), i;
        }
        function Qe(o, e) {
          if (Array.isArray(o)) {
            if (!Array.isArray(e) || o.length !== e.length) return false;
            for (let i = 0; i < o.length; i++) if (!Qe(o[i], e[i])) return false;
            return true;
          }
          if (typeof o == "object" && o !== null && e !== null) {
            if (typeof e != "object" || Object.keys(o).length !== Object.keys(e).length) return false;
            for (const i in o) if (!Qe(o[i], e[i])) return false;
            return true;
          }
          return o === e;
        }
        function tt(o, e) {
          o.push(e);
        }
        function At(o, e, i) {
          tt(i, { command: "addSource", args: [o, e[o]] });
        }
        function qt(o, e, i) {
          tt(e, { command: "removeSource", args: [o] }), i[o] = true;
        }
        function sr(o, e, i, u) {
          qt(o, i, u), At(o, e, i);
        }
        function Ur(o, e, i) {
          let u;
          for (u in o[i]) if (Object.prototype.hasOwnProperty.call(o[i], u) && u !== "data" && !Qe(o[i][u], e[i][u])) return false;
          for (u in e[i]) if (Object.prototype.hasOwnProperty.call(e[i], u) && u !== "data" && !Qe(o[i][u], e[i][u])) return false;
          return true;
        }
        function mr(o, e, i, u, c, m) {
          o = o || {}, e = e || {};
          for (const v in o) Object.prototype.hasOwnProperty.call(o, v) && (Qe(o[v], e[v]) || i.push({ command: m, args: [u, v, e[v], c] }));
          for (const v in e) Object.prototype.hasOwnProperty.call(e, v) && !Object.prototype.hasOwnProperty.call(o, v) && (Qe(o[v], e[v]) || i.push({ command: m, args: [u, v, e[v], c] }));
        }
        function Sr(o) {
          return o.id;
        }
        function Dr(o, e) {
          return o[e.id] = e, o;
        }
        class ye {
          constructor(e, i, u, c) {
            this.message = (e ? `${e}: ` : "") + u, c && (this.identifier = c), i != null && i.__line__ && (this.line = i.__line__);
          }
        }
        function at(o, ...e) {
          for (const i of e) for (const u in i) o[u] = i[u];
          return o;
        }
        class Ft extends Error {
          constructor(e, i) {
            super(i), this.message = i, this.key = e;
          }
        }
        class hr {
          constructor(e, i = []) {
            this.parent = e, this.bindings = {};
            for (const [u, c] of i) this.bindings[u] = c;
          }
          concat(e) {
            return new hr(this, e);
          }
          get(e) {
            if (this.bindings[e]) return this.bindings[e];
            if (this.parent) return this.parent.get(e);
            throw new Error(`${e} not found in scope.`);
          }
          has(e) {
            return !!this.bindings[e] || !!this.parent && this.parent.has(e);
          }
        }
        const ur = { kind: "null" }, st = { kind: "number" }, Bt = { kind: "string" }, Xt = { kind: "boolean" }, hi = { kind: "color" }, Sn = { kind: "projectionDefinition" }, Jr = { kind: "object" }, ar = { kind: "value" }, Wn = { kind: "collator" }, Lo = { kind: "formatted" }, Bo = { kind: "padding" }, kn = { kind: "colorArray" }, mo = { kind: "numberArray" }, Zn = { kind: "resolvedImage" }, Hn = { kind: "variableAnchorOffsetCollection" };
        function Tn(o, e) {
          return { kind: "array", itemType: o, N: e };
        }
        function Gr(o) {
          if (o.kind === "array") {
            const e = Gr(o.itemType);
            return typeof o.N == "number" ? `array<${e}, ${o.N}>` : o.itemType.kind === "value" ? "array" : `array<${e}>`;
          }
          return o.kind;
        }
        const Gc = [ur, st, Bt, Xt, hi, Sn, Lo, Jr, Tn(ar), Bo, mo, kn, Zn, Hn];
        function ro(o, e) {
          if (e.kind === "error") return null;
          if (o.kind === "array") {
            if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !ro(o.itemType, e.itemType)) && (typeof o.N != "number" || o.N === e.N)) return null;
          } else {
            if (o.kind === e.kind) return null;
            if (o.kind === "value") {
              for (const i of Gc) if (!ro(i, e)) return null;
            }
          }
          return `Expected ${Gr(o)} but found ${Gr(e)} instead.`;
        }
        function Na(o, e) {
          return e.some(((i) => i.kind === o.kind));
        }
        function Qr(o, e) {
          return e.some(((i) => i === "null" ? o === null : i === "array" ? Array.isArray(o) : i === "object" ? o && !Array.isArray(o) && typeof o == "object" : i === typeof o));
        }
        function Oo(o, e) {
          return o.kind === "array" && e.kind === "array" ? o.itemType.kind === e.itemType.kind && typeof o.N == "number" : o.kind === e.kind;
        }
        const Zs = 0.96422, ga = 0.82521, Hs = 4 / 29, va = 6 / 29, tu = 3 * va * va, ru = va * va * va, qc = Math.PI / 180, iu = 180 / Math.PI;
        function nu(o) {
          return (o %= 360) < 0 && (o += 360), o;
        }
        function ou([o, e, i, u]) {
          let c, m;
          const v = Ys((0.2225045 * (o = Xs(o)) + 0.7168786 * (e = Xs(e)) + 0.0606169 * (i = Xs(i))) / 1);
          o === e && e === i ? c = m = v : (c = Ys((0.4360747 * o + 0.3850649 * e + 0.1430804 * i) / Zs), m = Ys((0.0139322 * o + 0.0971045 * e + 0.7141733 * i) / ga));
          const x = 116 * v - 16;
          return [x < 0 ? 0 : x, 500 * (c - v), 200 * (v - m), u];
        }
        function Xs(o) {
          return o <= 0.04045 ? o / 12.92 : Math.pow((o + 0.055) / 1.055, 2.4);
        }
        function Ys(o) {
          return o > ru ? Math.pow(o, 1 / 3) : o / tu + Hs;
        }
        function au([o, e, i, u]) {
          let c = (o + 16) / 116, m = isNaN(e) ? c : c + e / 500, v = isNaN(i) ? c : c - i / 200;
          return c = 1 * Js(c), m = Zs * Js(m), v = ga * Js(v), [Ks(3.1338561 * m - 1.6168667 * c - 0.4906146 * v), Ks(-0.9787684 * m + 1.9161415 * c + 0.033454 * v), Ks(0.0719453 * m - 0.2289914 * c + 1.4052427 * v), u];
        }
        function Ks(o) {
          return (o = o <= 304e-5 ? 12.92 * o : 1.055 * Math.pow(o, 1 / 2.4) - 0.055) < 0 ? 0 : o > 1 ? 1 : o;
        }
        function Js(o) {
          return o > va ? o * o * o : tu * (o - Hs);
        }
        const su = Object.hasOwn || function(o, e) {
          return Object.prototype.hasOwnProperty.call(o, e);
        };
        function go(o, e) {
          return su(o, e) ? o[e] : void 0;
        }
        function fs(o) {
          return parseInt(o.padEnd(2, o), 16) / 255;
        }
        function lu(o, e) {
          return io(e ? o / 100 : o, 0, 1);
        }
        function io(o, e, i) {
          return Math.min(Math.max(e, o), i);
        }
        function uu(o) {
          return !o.some(Number.isNaN);
        }
        const Wc = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        function $o(o, e, i) {
          return o + i * (e - o);
        }
        function Ho(o, e, i) {
          return o.map(((u, c) => $o(u, e[c], i)));
        }
        class br {
          constructor(e, i, u, c = 1, m = true) {
            this.r = e, this.g = i, this.b = u, this.a = c, m || (this.r *= c, this.g *= c, this.b *= c, c || this.overwriteGetter("rgb", [e, i, u, c]));
          }
          static parse(e) {
            if (e instanceof br) return e;
            if (typeof e != "string") return;
            const i = (function(u) {
              if ((u = u.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const c = go(Wc, u);
              if (c) {
                const [v, x, C] = c;
                return [v / 255, x / 255, C / 255, 1];
              }
              if (u.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(u)) {
                const v = u.length < 6 ? 1 : 2;
                let x = 1;
                return [fs(u.slice(x, x += v)), fs(u.slice(x, x += v)), fs(u.slice(x, x += v)), fs(u.slice(x, x + v) || "ff")];
              }
              if (u.startsWith("rgb")) {
                const v = u.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (v) {
                  const [x, C, k, E, D, F, V, G, H, Y, ie, we] = v, ce = [E || " ", V || " ", Y].join("");
                  if (ce === "  " || ce === "  /" || ce === ",," || ce === ",,,") {
                    const pe = [k, F, H].join(""), Te = pe === "%%%" ? 100 : pe === "" ? 255 : 0;
                    if (Te) {
                      const Oe = [io(+C / Te, 0, 1), io(+D / Te, 0, 1), io(+G / Te, 0, 1), ie ? lu(+ie, we) : 1];
                      if (uu(Oe)) return Oe;
                    }
                  }
                  return;
                }
              }
              const m = u.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (m) {
                const [v, x, C, k, E, D, F, V, G] = m, H = [C || " ", E || " ", F].join("");
                if (H === "  " || H === "  /" || H === ",," || H === ",,,") {
                  const Y = [+x, io(+k, 0, 100), io(+D, 0, 100), V ? lu(+V, G) : 1];
                  if (uu(Y)) return (function([ie, we, ce, pe]) {
                    function Te(Oe) {
                      const Xe = (Oe + ie / 30) % 12, yt = we * Math.min(ce, 1 - ce);
                      return ce - yt * Math.max(-1, Math.min(Xe - 3, 9 - Xe, 1));
                    }
                    return ie = nu(ie), we /= 100, ce /= 100, [Te(0), Te(8), Te(4), pe];
                  })(Y);
                }
              }
            })(e);
            return i ? new br(...i, false) : void 0;
          }
          get rgb() {
            const { r: e, g: i, b: u, a: c } = this, m = c || 1 / 0;
            return this.overwriteGetter("rgb", [e / m, i / m, u / m, c]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(e) {
              const [i, u, c, m] = ou(e), v = Math.sqrt(u * u + c * c);
              return [Math.round(1e4 * v) ? nu(Math.atan2(c, u) * iu) : NaN, v, i, m];
            })(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", ou(this.rgb));
          }
          overwriteGetter(e, i) {
            return Object.defineProperty(this, e, { value: i }), i;
          }
          toString() {
            const [e, i, u, c] = this.rgb;
            return `rgba(${[e, i, u].map(((m) => Math.round(255 * m))).join(",")},${c})`;
          }
          static interpolate(e, i, u, c = "rgb") {
            switch (c) {
              case "rgb": {
                const [m, v, x, C] = Ho(e.rgb, i.rgb, u);
                return new br(m, v, x, C, false);
              }
              case "hcl": {
                const [m, v, x, C] = e.hcl, [k, E, D, F] = i.hcl;
                let V, G;
                if (isNaN(m) || isNaN(k)) isNaN(m) ? isNaN(k) ? V = NaN : (V = k, x !== 1 && x !== 0 || (G = E)) : (V = m, D !== 1 && D !== 0 || (G = v));
                else {
                  let ce = k - m;
                  k > m && ce > 180 ? ce -= 360 : k < m && m - k > 180 && (ce += 360), V = m + u * ce;
                }
                const [H, Y, ie, we] = (function([ce, pe, Te, Oe]) {
                  return ce = isNaN(ce) ? 0 : ce * qc, au([Te, Math.cos(ce) * pe, Math.sin(ce) * pe, Oe]);
                })([V, G ?? $o(v, E, u), $o(x, D, u), $o(C, F, u)]);
                return new br(H, Y, ie, we, false);
              }
              case "lab": {
                const [m, v, x, C] = au(Ho(e.lab, i.lab, u));
                return new br(m, v, x, C, false);
              }
            }
          }
        }
        br.black = new br(0, 0, 0, 1), br.white = new br(1, 1, 1, 1), br.transparent = new br(0, 0, 0, 0), br.red = new br(1, 0, 0, 1);
        class no {
          constructor(e, i, u) {
            this.sensitivity = e ? i ? "variant" : "case" : i ? "accent" : "base", this.locale = u, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(e, i) {
            return this.collator.compare(e, i);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        const Er = ["bottom", "center", "top"];
        class ya {
          constructor(e, i, u, c, m, v) {
            this.text = e, this.image = i, this.scale = u, this.fontStack = c, this.textColor = m, this.verticalAlign = v;
          }
        }
        class Mi {
          constructor(e) {
            this.sections = e;
          }
          static fromString(e) {
            return new Mi([new ya(e, null, null, null, null, null)]);
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some(((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0));
          }
          static factory(e) {
            return e instanceof Mi ? e : Mi.fromString(e);
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map(((e) => e.text)).join("");
          }
        }
        class dn {
          constructor(e) {
            this.values = e.slice();
          }
          static parse(e) {
            if (e instanceof dn) return e;
            if (typeof e == "number") return new dn([e, e, e, e]);
            if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {
              for (const i of e) if (typeof i != "number") return;
              switch (e.length) {
                case 1:
                  e = [e[0], e[0], e[0], e[0]];
                  break;
                case 2:
                  e = [e[0], e[1], e[0], e[1]];
                  break;
                case 3:
                  e = [e[0], e[1], e[2], e[1]];
              }
              return new dn(e);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(e, i, u) {
            return new dn(Ho(e.values, i.values, u));
          }
        }
        class hn {
          constructor(e) {
            this.values = e.slice();
          }
          static parse(e) {
            if (e instanceof hn) return e;
            if (typeof e == "number") return new hn([e]);
            if (Array.isArray(e)) {
              for (const i of e) if (typeof i != "number") return;
              return new hn(e);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(e, i, u) {
            return new hn(Ho(e.values, i.values, u));
          }
        }
        class Oi {
          constructor(e) {
            this.values = e.slice();
          }
          static parse(e) {
            if (e instanceof Oi) return e;
            if (typeof e == "string") {
              const u = br.parse(e);
              return u ? new Oi([u]) : void 0;
            }
            if (!Array.isArray(e)) return;
            const i = [];
            for (const u of e) {
              if (typeof u != "string") return;
              const c = br.parse(u);
              if (!c) return;
              i.push(c);
            }
            return new Oi(i);
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(e, i, u, c = "rgb") {
            const m = [];
            if (e.values.length != i.values.length) throw new Error(`colorArray: Arrays have mismatched length (${e.values.length} vs. ${i.values.length}), cannot interpolate.`);
            for (let v = 0; v < e.values.length; v++) m.push(br.interpolate(e.values[v], i.values[v], u, c));
            return new Oi(m);
          }
        }
        class Hr extends Error {
          constructor(e) {
            super(e), this.name = "RuntimeError";
          }
          toJSON() {
            return this.message;
          }
        }
        const cu = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class Pn {
          constructor(e) {
            this.values = e.slice();
          }
          static parse(e) {
            if (e instanceof Pn) return e;
            if (Array.isArray(e) && !(e.length < 1) && e.length % 2 == 0) {
              for (let i = 0; i < e.length; i += 2) {
                const u = e[i], c = e[i + 1];
                if (typeof u != "string" || !cu.has(u) || !Array.isArray(c) || c.length !== 2 || typeof c[0] != "number" || typeof c[1] != "number") return;
              }
              return new Pn(e);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(e, i, u) {
            const c = e.values, m = i.values;
            if (c.length !== m.length) throw new Hr(`Cannot interpolate values of different length. from: ${e.toString()}, to: ${i.toString()}`);
            const v = [];
            for (let x = 0; x < c.length; x += 2) {
              if (c[x] !== m[x]) throw new Hr(`Cannot interpolate values containing mismatched anchors. from[${x}]: ${c[x]}, to[${x}]: ${m[x]}`);
              v.push(c[x]);
              const [C, k] = c[x + 1], [E, D] = m[x + 1];
              v.push([$o(C, E, u), $o(k, D, u)]);
            }
            return new Pn(v);
          }
        }
        class Bn {
          constructor(e) {
            this.name = e.name, this.available = e.available;
          }
          toString() {
            return this.name;
          }
          static fromString(e) {
            return e ? new Bn({ name: e, available: false }) : null;
          }
        }
        class fn {
          constructor(e, i, u) {
            this.from = e, this.to = i, this.transition = u;
          }
          static interpolate(e, i, u) {
            return new fn(e, i, u);
          }
          static parse(e) {
            return e instanceof fn ? e : Array.isArray(e) && e.length === 3 && typeof e[0] == "string" && typeof e[1] == "string" && typeof e[2] == "number" ? new fn(e[0], e[1], e[2]) : typeof e == "object" && typeof e.from == "string" && typeof e.to == "string" && typeof e.transition == "number" ? new fn(e.from, e.to, e.transition) : typeof e == "string" ? new fn(e, e, 1) : void 0;
          }
        }
        function Zh(o, e, i, u) {
          return typeof o == "number" && o >= 0 && o <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof i == "number" && i >= 0 && i <= 255 ? u === void 0 || typeof u == "number" && u >= 0 && u <= 1 ? null : `Invalid rgba value [${[o, e, i, u].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof u == "number" ? [o, e, i, u] : [o, e, i]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function _a2(o) {
          if (o === null || typeof o == "string" || typeof o == "boolean" || typeof o == "number" || o instanceof fn || o instanceof br || o instanceof no || o instanceof Mi || o instanceof dn || o instanceof hn || o instanceof Oi || o instanceof Pn || o instanceof Bn) return true;
          if (Array.isArray(o)) {
            for (const e of o) if (!_a2(e)) return false;
            return true;
          }
          if (typeof o == "object") {
            for (const e in o) if (!_a2(o[e])) return false;
            return true;
          }
          return false;
        }
        function ei(o) {
          if (o === null) return ur;
          if (typeof o == "string") return Bt;
          if (typeof o == "boolean") return Xt;
          if (typeof o == "number") return st;
          if (o instanceof br) return hi;
          if (o instanceof fn) return Sn;
          if (o instanceof no) return Wn;
          if (o instanceof Mi) return Lo;
          if (o instanceof dn) return Bo;
          if (o instanceof hn) return mo;
          if (o instanceof Oi) return kn;
          if (o instanceof Pn) return Hn;
          if (o instanceof Bn) return Zn;
          if (Array.isArray(o)) {
            const e = o.length;
            let i;
            for (const u of o) {
              const c = ei(u);
              if (i) {
                if (i === c) continue;
                i = ar;
                break;
              }
              i = c;
            }
            return Tn(i || ar, e);
          }
          return Jr;
        }
        function ps(o) {
          const e = typeof o;
          return o === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(o) : o instanceof br || o instanceof fn || o instanceof Mi || o instanceof dn || o instanceof hn || o instanceof Oi || o instanceof Pn || o instanceof Bn ? o.toString() : JSON.stringify(o);
        }
        class ba {
          constructor(e, i) {
            this.type = e, this.value = i;
          }
          static parse(e, i) {
            if (e.length !== 2) return i.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
            if (!_a2(e[1])) return i.error("invalid value");
            const u = e[1];
            let c = ei(u);
            const m = i.expectedType;
            return c.kind !== "array" || c.N !== 0 || !m || m.kind !== "array" || typeof m.N == "number" && m.N !== 0 || (c = m), new ba(c, u);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        const Qs = { string: Bt, number: st, boolean: Xt, object: Jr };
        class On {
          constructor(e, i) {
            this.type = e, this.args = i;
          }
          static parse(e, i) {
            if (e.length < 2) return i.error("Expected at least one argument.");
            let u, c = 1;
            const m = e[0];
            if (m === "array") {
              let x, C;
              if (e.length > 2) {
                const k = e[1];
                if (typeof k != "string" || !(k in Qs) || k === "object") return i.error('The item type argument of "array" must be one of string, number, boolean', 1);
                x = Qs[k], c++;
              } else x = ar;
              if (e.length > 3) {
                if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2]))) return i.error('The length argument to "array" must be a positive integer literal', 2);
                C = e[2], c++;
              }
              u = Tn(x, C);
            } else {
              if (!Qs[m]) throw new Error(`Types doesn't contain name = ${m}`);
              u = Qs[m];
            }
            const v = [];
            for (; c < e.length; c++) {
              const x = i.parse(e[c], c, ar);
              if (!x) return null;
              v.push(x);
            }
            return new On(u, v);
          }
          evaluate(e) {
            for (let i = 0; i < this.args.length; i++) {
              const u = this.args[i].evaluate(e);
              if (!ro(this.type, ei(u))) return u;
              if (i === this.args.length - 1) throw new Hr(`Expected value to be of type ${Gr(this.type)}, but found ${Gr(ei(u))} instead.`);
            }
            throw new Error();
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return this.args.every(((e) => e.outputDefined()));
          }
        }
        const ti = { "to-boolean": Xt, "to-color": hi, "to-number": st, "to-string": Bt };
        class No {
          constructor(e, i) {
            this.type = e, this.args = i;
          }
          static parse(e, i) {
            if (e.length < 2) return i.error("Expected at least one argument.");
            const u = e[0];
            if (!ti[u]) throw new Error(`Can't parse ${u} as it is not part of the known types`);
            if ((u === "to-boolean" || u === "to-string") && e.length !== 2) return i.error("Expected one argument.");
            const c = ti[u], m = [];
            for (let v = 1; v < e.length; v++) {
              const x = i.parse(e[v], v, ar);
              if (!x) return null;
              m.push(x);
            }
            return new No(c, m);
          }
          evaluate(e) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(e);
              case "color": {
                let i, u;
                for (const c of this.args) {
                  if (i = c.evaluate(e), u = null, i instanceof br) return i;
                  if (typeof i == "string") {
                    const m = e.parseColor(i);
                    if (m) return m;
                  } else if (Array.isArray(i) && (u = i.length < 3 || i.length > 4 ? `Invalid rgba value ${JSON.stringify(i)}: expected an array containing either three or four numeric values.` : Zh(i[0], i[1], i[2], i[3]), !u)) return new br(i[0] / 255, i[1] / 255, i[2] / 255, i[3]);
                }
                throw new Hr(u || `Could not parse color from value '${typeof i == "string" ? i : JSON.stringify(i)}'`);
              }
              case "padding": {
                let i;
                for (const u of this.args) {
                  i = u.evaluate(e);
                  const c = dn.parse(i);
                  if (c) return c;
                }
                throw new Hr(`Could not parse padding from value '${typeof i == "string" ? i : JSON.stringify(i)}'`);
              }
              case "numberArray": {
                let i;
                for (const u of this.args) {
                  i = u.evaluate(e);
                  const c = hn.parse(i);
                  if (c) return c;
                }
                throw new Hr(`Could not parse numberArray from value '${typeof i == "string" ? i : JSON.stringify(i)}'`);
              }
              case "colorArray": {
                let i;
                for (const u of this.args) {
                  i = u.evaluate(e);
                  const c = Oi.parse(i);
                  if (c) return c;
                }
                throw new Hr(`Could not parse colorArray from value '${typeof i == "string" ? i : JSON.stringify(i)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let i;
                for (const u of this.args) {
                  i = u.evaluate(e);
                  const c = Pn.parse(i);
                  if (c) return c;
                }
                throw new Hr(`Could not parse variableAnchorOffsetCollection from value '${typeof i == "string" ? i : JSON.stringify(i)}'`);
              }
              case "number": {
                let i = null;
                for (const u of this.args) {
                  if (i = u.evaluate(e), i === null) return 0;
                  const c = Number(i);
                  if (!isNaN(c)) return c;
                }
                throw new Hr(`Could not convert ${JSON.stringify(i)} to number.`);
              }
              case "formatted":
                return Mi.fromString(ps(this.args[0].evaluate(e)));
              case "resolvedImage":
                return Bn.fromString(ps(this.args[0].evaluate(e)));
              case "projectionDefinition":
                return this.args[0].evaluate(e);
              default:
                return ps(this.args[0].evaluate(e));
            }
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return this.args.every(((e) => e.outputDefined()));
          }
        }
        const Ar = ["Unknown", "Point", "LineString", "Polygon"];
        class gr {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? Ar[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(e) {
            let i = this._parseColorCache.get(e);
            return i || (i = br.parse(e), this._parseColorCache.set(e, i)), i;
          }
        }
        class ms {
          constructor(e, i, u = [], c, m = new hr(), v = []) {
            this.registry = e, this.path = u, this.key = u.map(((x) => `[${x}]`)).join(""), this.scope = m, this.errors = v, this.expectedType = c, this._isConstant = i;
          }
          parse(e, i, u, c, m = {}) {
            return i ? this.concat(i, u, c)._parse(e, m) : this._parse(e, m);
          }
          _parse(e, i) {
            function u(c, m, v) {
              return v === "assert" ? new On(m, [c]) : v === "coerce" ? new No(m, [c]) : c;
            }
            if (e !== null && typeof e != "string" && typeof e != "boolean" && typeof e != "number" || (e = ["literal", e]), Array.isArray(e)) {
              if (e.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const c = e[0];
              if (typeof c != "string") return this.error(`Expression name must be a string, but found ${typeof c} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const m = this.registry[c];
              if (m) {
                let v = m.parse(e, this);
                if (!v) return null;
                if (this.expectedType) {
                  const x = this.expectedType, C = v.type;
                  if (x.kind !== "string" && x.kind !== "number" && x.kind !== "boolean" && x.kind !== "object" && x.kind !== "array" || C.kind !== "value") {
                    if (x.kind === "projectionDefinition" && ["string", "array"].includes(C.kind) || ["color", "formatted", "resolvedImage"].includes(x.kind) && ["value", "string"].includes(C.kind) || ["padding", "numberArray"].includes(x.kind) && ["value", "number", "array"].includes(C.kind) || x.kind === "colorArray" && ["value", "string", "array"].includes(C.kind) || x.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(C.kind)) v = u(v, x, i.typeAnnotation || "coerce");
                    else if (this.checkSubtype(x, C)) return null;
                  } else v = u(v, x, i.typeAnnotation || "assert");
                }
                if (!(v instanceof ba) && v.type.kind !== "resolvedImage" && this._isConstant(v)) {
                  const x = new gr();
                  try {
                    v = new ba(v.type, v.evaluate(x));
                  } catch (C) {
                    return this.error(C.message), null;
                  }
                }
                return v;
              }
              return this.error(`Unknown expression "${c}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(e === void 0 ? "'undefined' value invalid. Use null instead." : typeof e == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof e} instead.`);
          }
          concat(e, i, u) {
            const c = typeof e == "number" ? this.path.concat(e) : this.path, m = u ? this.scope.concat(u) : this.scope;
            return new ms(this.registry, this._isConstant, c, i || null, m, this.errors);
          }
          error(e, ...i) {
            const u = `${this.key}${i.map(((c) => `[${c}]`)).join("")}`;
            this.errors.push(new Ft(u, e));
          }
          checkSubtype(e, i) {
            const u = ro(e, i);
            return u && this.error(u), u;
          }
        }
        class Mr {
          constructor(e, i) {
            this.type = i.type, this.bindings = [].concat(e), this.result = i;
          }
          evaluate(e) {
            return this.result.evaluate(e);
          }
          eachChild(e) {
            for (const i of this.bindings) e(i[1]);
            e(this.result);
          }
          static parse(e, i) {
            if (e.length < 4) return i.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
            const u = [];
            for (let m = 1; m < e.length - 1; m += 2) {
              const v = e[m];
              if (typeof v != "string") return i.error(`Expected string, but found ${typeof v} instead.`, m);
              if (/[^a-zA-Z0-9_]/.test(v)) return i.error("Variable names must contain only alphanumeric characters or '_'.", m);
              const x = i.parse(e[m + 1], m + 1);
              if (!x) return null;
              u.push([v, x]);
            }
            const c = i.parse(e[e.length - 1], e.length - 1, i.expectedType, u);
            return c ? new Mr(u, c) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class gs {
          constructor(e, i) {
            this.type = i.type, this.name = e, this.boundExpression = i;
          }
          static parse(e, i) {
            if (e.length !== 2 || typeof e[1] != "string") return i.error("'var' expression requires exactly one string literal argument.");
            const u = e[1];
            return i.scope.has(u) ? new gs(u, i.scope.get(u)) : i.error(`Unknown variable "${u}". Make sure "${u}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(e) {
            return this.boundExpression.evaluate(e);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
        }
        class vo {
          constructor(e, i, u) {
            this.type = e, this.index = i, this.input = u;
          }
          static parse(e, i) {
            if (e.length !== 3) return i.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
            const u = i.parse(e[1], 1, st), c = i.parse(e[2], 2, Tn(i.expectedType || ar));
            return u && c ? new vo(c.type.itemType, u, c) : null;
          }
          evaluate(e) {
            const i = this.index.evaluate(e), u = this.input.evaluate(e);
            if (i < 0) throw new Hr(`Array index out of bounds: ${i} < 0.`);
            if (i >= u.length) throw new Hr(`Array index out of bounds: ${i} > ${u.length - 1}.`);
            if (i !== Math.floor(i)) throw new Hr(`Array index must be an integer, but found ${i} instead.`);
            return u[i];
          }
          eachChild(e) {
            e(this.index), e(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class el {
          constructor(e, i) {
            this.type = Xt, this.needle = e, this.haystack = i;
          }
          static parse(e, i) {
            if (e.length !== 3) return i.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
            const u = i.parse(e[1], 1, ar), c = i.parse(e[2], 2, ar);
            return u && c ? Na(u.type, [Xt, Bt, st, ur, ar]) ? new el(u, c) : i.error(`Expected first argument to be of type boolean, string, number or null, but found ${Gr(u.type)} instead`) : null;
          }
          evaluate(e) {
            const i = this.needle.evaluate(e), u = this.haystack.evaluate(e);
            if (!u) return false;
            if (!Qr(i, ["boolean", "string", "number", "null"])) throw new Hr(`Expected first argument to be of type boolean, string, number or null, but found ${Gr(ei(i))} instead.`);
            if (!Qr(u, ["string", "array"])) throw new Hr(`Expected second argument to be of type array or string, but found ${Gr(ei(u))} instead.`);
            return u.indexOf(i) >= 0;
          }
          eachChild(e) {
            e(this.needle), e(this.haystack);
          }
          outputDefined() {
            return true;
          }
        }
        class ja {
          constructor(e, i, u) {
            this.type = st, this.needle = e, this.haystack = i, this.fromIndex = u;
          }
          static parse(e, i) {
            if (e.length <= 2 || e.length >= 5) return i.error(`Expected 2 or 3 arguments, but found ${e.length - 1} instead.`);
            const u = i.parse(e[1], 1, ar), c = i.parse(e[2], 2, ar);
            if (!u || !c) return null;
            if (!Na(u.type, [Xt, Bt, st, ur, ar])) return i.error(`Expected first argument to be of type boolean, string, number or null, but found ${Gr(u.type)} instead`);
            if (e.length === 4) {
              const m = i.parse(e[3], 3, st);
              return m ? new ja(u, c, m) : null;
            }
            return new ja(u, c);
          }
          evaluate(e) {
            const i = this.needle.evaluate(e), u = this.haystack.evaluate(e);
            if (!Qr(i, ["boolean", "string", "number", "null"])) throw new Hr(`Expected first argument to be of type boolean, string, number or null, but found ${Gr(ei(i))} instead.`);
            let c;
            if (this.fromIndex && (c = this.fromIndex.evaluate(e)), Qr(u, ["string"])) {
              const m = u.indexOf(i, c);
              return m === -1 ? -1 : [...u.slice(0, m)].length;
            }
            if (Qr(u, ["array"])) return u.indexOf(i, c);
            throw new Hr(`Expected second argument to be of type array or string, but found ${Gr(ei(u))} instead.`);
          }
          eachChild(e) {
            e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
        }
        class du {
          constructor(e, i, u, c, m, v) {
            this.inputType = e, this.type = i, this.input = u, this.cases = c, this.outputs = m, this.otherwise = v;
          }
          static parse(e, i) {
            if (e.length < 5) return i.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
            if (e.length % 2 != 1) return i.error("Expected an even number of arguments.");
            let u, c;
            i.expectedType && i.expectedType.kind !== "value" && (c = i.expectedType);
            const m = {}, v = [];
            for (let k = 2; k < e.length - 1; k += 2) {
              let E = e[k];
              const D = e[k + 1];
              Array.isArray(E) || (E = [E]);
              const F = i.concat(k);
              if (E.length === 0) return F.error("Expected at least one branch label.");
              for (const G of E) {
                if (typeof G != "number" && typeof G != "string") return F.error("Branch labels must be numbers or strings.");
                if (typeof G == "number" && Math.abs(G) > Number.MAX_SAFE_INTEGER) return F.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof G == "number" && Math.floor(G) !== G) return F.error("Numeric branch labels must be integer values.");
                if (u) {
                  if (F.checkSubtype(u, ei(G))) return null;
                } else u = ei(G);
                if (m[String(G)] !== void 0) return F.error("Branch labels must be unique.");
                m[String(G)] = v.length;
              }
              const V = i.parse(D, k, c);
              if (!V) return null;
              c = c || V.type, v.push(V);
            }
            const x = i.parse(e[1], 1, ar);
            if (!x) return null;
            const C = i.parse(e[e.length - 1], e.length - 1, c);
            return C ? x.type.kind !== "value" && i.concat(1).checkSubtype(u, x.type) ? null : new du(u, c, x, m, v, C) : null;
          }
          evaluate(e) {
            const i = this.input.evaluate(e);
            return (ei(i) === this.inputType && this.outputs[this.cases[i]] || this.otherwise).evaluate(e);
          }
          eachChild(e) {
            e(this.input), this.outputs.forEach(e), e(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every(((e) => e.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class tl {
          constructor(e, i, u) {
            this.type = e, this.branches = i, this.otherwise = u;
          }
          static parse(e, i) {
            if (e.length < 4) return i.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
            if (e.length % 2 != 0) return i.error("Expected an odd number of arguments.");
            let u;
            i.expectedType && i.expectedType.kind !== "value" && (u = i.expectedType);
            const c = [];
            for (let v = 1; v < e.length - 1; v += 2) {
              const x = i.parse(e[v], v, Xt);
              if (!x) return null;
              const C = i.parse(e[v + 1], v + 1, u);
              if (!C) return null;
              c.push([x, C]), u = u || C.type;
            }
            const m = i.parse(e[e.length - 1], e.length - 1, u);
            if (!m) return null;
            if (!u) throw new Error("Can't infer output type");
            return new tl(u, c, m);
          }
          evaluate(e) {
            for (const [i, u] of this.branches) if (i.evaluate(e)) return u.evaluate(e);
            return this.otherwise.evaluate(e);
          }
          eachChild(e) {
            for (const [i, u] of this.branches) e(i), e(u);
            e(this.otherwise);
          }
          outputDefined() {
            return this.branches.every((([e, i]) => i.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class rl {
          constructor(e, i, u, c) {
            this.type = e, this.input = i, this.beginIndex = u, this.endIndex = c;
          }
          static parse(e, i) {
            if (e.length <= 2 || e.length >= 5) return i.error(`Expected 2 or 3 arguments, but found ${e.length - 1} instead.`);
            const u = i.parse(e[1], 1, ar), c = i.parse(e[2], 2, st);
            if (!u || !c) return null;
            if (!Na(u.type, [Tn(ar), Bt, ar])) return i.error(`Expected first argument to be of type array or string, but found ${Gr(u.type)} instead`);
            if (e.length === 4) {
              const m = i.parse(e[3], 3, st);
              return m ? new rl(u.type, u, c, m) : null;
            }
            return new rl(u.type, u, c);
          }
          evaluate(e) {
            const i = this.input.evaluate(e), u = this.beginIndex.evaluate(e);
            let c;
            if (this.endIndex && (c = this.endIndex.evaluate(e)), Qr(i, ["string"])) return [...i].slice(u, c).join("");
            if (Qr(i, ["array"])) return i.slice(u, c);
            throw new Hr(`Expected first argument to be of type array or string, but found ${Gr(ei(i))} instead.`);
          }
          eachChild(e) {
            e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
          }
          outputDefined() {
            return false;
          }
        }
        function hu(o, e) {
          const i = o.length - 1;
          let u, c, m = 0, v = i, x = 0;
          for (; m <= v; ) if (x = Math.floor((m + v) / 2), u = o[x], c = o[x + 1], u <= e) {
            if (x === i || e < c) return x;
            m = x + 1;
          } else {
            if (!(u > e)) throw new Hr("Input is not a number.");
            v = x - 1;
          }
          return 0;
        }
        class vs {
          constructor(e, i, u) {
            this.type = e, this.input = i, this.labels = [], this.outputs = [];
            for (const [c, m] of u) this.labels.push(c), this.outputs.push(m);
          }
          static parse(e, i) {
            if (e.length - 1 < 4) return i.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
            if ((e.length - 1) % 2 != 0) return i.error("Expected an even number of arguments.");
            const u = i.parse(e[1], 1, st);
            if (!u) return null;
            const c = [];
            let m = null;
            i.expectedType && i.expectedType.kind !== "value" && (m = i.expectedType);
            for (let v = 1; v < e.length; v += 2) {
              const x = v === 1 ? -1 / 0 : e[v], C = e[v + 1], k = v, E = v + 1;
              if (typeof x != "number") return i.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', k);
              if (c.length && c[c.length - 1][0] >= x) return i.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', k);
              const D = i.parse(C, E, m);
              if (!D) return null;
              m = m || D.type, c.push([x, D]);
            }
            return new vs(m, u, c);
          }
          evaluate(e) {
            const i = this.labels, u = this.outputs;
            if (i.length === 1) return u[0].evaluate(e);
            const c = this.input.evaluate(e);
            if (c <= i[0]) return u[0].evaluate(e);
            const m = i.length;
            return c >= i[m - 1] ? u[m - 1].evaluate(e) : u[hu(i, c)].evaluate(e);
          }
          eachChild(e) {
            e(this.input);
            for (const i of this.outputs) e(i);
          }
          outputDefined() {
            return this.outputs.every(((e) => e.outputDefined()));
          }
        }
        function Hh(o) {
          return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
        }
        var jo, tn, fu = (function() {
          if (tn) return jo;
          function o(e, i, u, c) {
            this.cx = 3 * e, this.bx = 3 * (u - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * i, this.by = 3 * (c - i) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = i, this.p2x = u, this.p2y = c;
          }
          return tn = 1, jo = o, o.prototype = { sampleCurveX: function(e) {
            return ((this.ax * e + this.bx) * e + this.cx) * e;
          }, sampleCurveY: function(e) {
            return ((this.ay * e + this.by) * e + this.cy) * e;
          }, sampleCurveDerivativeX: function(e) {
            return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
          }, solveCurveX: function(e, i) {
            if (i === void 0 && (i = 1e-6), e < 0) return 0;
            if (e > 1) return 1;
            for (var u = e, c = 0; c < 8; c++) {
              var m = this.sampleCurveX(u) - e;
              if (Math.abs(m) < i) return u;
              var v = this.sampleCurveDerivativeX(u);
              if (Math.abs(v) < 1e-6) break;
              u -= m / v;
            }
            var x = 0, C = 1;
            for (u = e, c = 0; c < 20 && (m = this.sampleCurveX(u), !(Math.abs(m - e) < i)); c++) e > m ? x = u : C = u, u = 0.5 * (C - x) + x;
            return u;
          }, solve: function(e, i) {
            return this.sampleCurveY(this.solveCurveX(e, i));
          } }, jo;
        })(), Xh = Hh(fu);
        class rn {
          constructor(e, i, u, c, m) {
            this.type = e, this.operator = i, this.interpolation = u, this.input = c, this.labels = [], this.outputs = [];
            for (const [v, x] of m) this.labels.push(v), this.outputs.push(x);
          }
          static interpolationFactor(e, i, u, c) {
            let m = 0;
            if (e.name === "exponential") m = Di(i, e.base, u, c);
            else if (e.name === "linear") m = Di(i, 1, u, c);
            else if (e.name === "cubic-bezier") {
              const v = e.controlPoints;
              m = new Xh(v[0], v[1], v[2], v[3]).solve(Di(i, 1, u, c));
            }
            return m;
          }
          static parse(e, i) {
            let [u, c, m, ...v] = e;
            if (!Array.isArray(c) || c.length === 0) return i.error("Expected an interpolation type expression.", 1);
            if (c[0] === "linear") c = { name: "linear" };
            else if (c[0] === "exponential") {
              const k = c[1];
              if (typeof k != "number") return i.error("Exponential interpolation requires a numeric base.", 1, 1);
              c = { name: "exponential", base: k };
            } else {
              if (c[0] !== "cubic-bezier") return i.error(`Unknown interpolation type ${String(c[0])}`, 1, 0);
              {
                const k = c.slice(1);
                if (k.length !== 4 || k.some(((E) => typeof E != "number" || E < 0 || E > 1))) return i.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                c = { name: "cubic-bezier", controlPoints: k };
              }
            }
            if (e.length - 1 < 4) return i.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
            if ((e.length - 1) % 2 != 0) return i.error("Expected an even number of arguments.");
            if (m = i.parse(m, 2, st), !m) return null;
            const x = [];
            let C = null;
            u !== "interpolate-hcl" && u !== "interpolate-lab" || i.expectedType == kn ? i.expectedType && i.expectedType.kind !== "value" && (C = i.expectedType) : C = hi;
            for (let k = 0; k < v.length; k += 2) {
              const E = v[k], D = v[k + 1], F = k + 3, V = k + 4;
              if (typeof E != "number") return i.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', F);
              if (x.length && x[x.length - 1][0] >= E) return i.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', F);
              const G = i.parse(D, V, C);
              if (!G) return null;
              C = C || G.type, x.push([E, G]);
            }
            return Oo(C, st) || Oo(C, Sn) || Oo(C, hi) || Oo(C, Bo) || Oo(C, mo) || Oo(C, kn) || Oo(C, Hn) || Oo(C, Tn(st)) ? new rn(C, u, c, m, x) : i.error(`Type ${Gr(C)} is not interpolatable.`);
          }
          evaluate(e) {
            const i = this.labels, u = this.outputs;
            if (i.length === 1) return u[0].evaluate(e);
            const c = this.input.evaluate(e);
            if (c <= i[0]) return u[0].evaluate(e);
            const m = i.length;
            if (c >= i[m - 1]) return u[m - 1].evaluate(e);
            const v = hu(i, c), x = rn.interpolationFactor(this.interpolation, c, i[v], i[v + 1]), C = u[v].evaluate(e), k = u[v + 1].evaluate(e);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return $o(C, k, x);
                  case "color":
                    return br.interpolate(C, k, x);
                  case "padding":
                    return dn.interpolate(C, k, x);
                  case "colorArray":
                    return Oi.interpolate(C, k, x);
                  case "numberArray":
                    return hn.interpolate(C, k, x);
                  case "variableAnchorOffsetCollection":
                    return Pn.interpolate(C, k, x);
                  case "array":
                    return Ho(C, k, x);
                  case "projectionDefinition":
                    return fn.interpolate(C, k, x);
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return br.interpolate(C, k, x, "hcl");
                  case "colorArray":
                    return Oi.interpolate(C, k, x, "hcl");
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return br.interpolate(C, k, x, "lab");
                  case "colorArray":
                    return Oi.interpolate(C, k, x, "lab");
                }
            }
          }
          eachChild(e) {
            e(this.input);
            for (const i of this.outputs) e(i);
          }
          outputDefined() {
            return this.outputs.every(((e) => e.outputDefined()));
          }
        }
        function Di(o, e, i, u) {
          const c = u - i, m = o - i;
          return c === 0 ? 0 : e === 1 ? m / c : (Math.pow(e, m) - 1) / (Math.pow(e, c) - 1);
        }
        const yo = { color: br.interpolate, number: $o, padding: dn.interpolate, numberArray: hn.interpolate, colorArray: Oi.interpolate, variableAnchorOffsetCollection: Pn.interpolate, array: Ho };
        class ys {
          constructor(e, i) {
            this.type = e, this.args = i;
          }
          static parse(e, i) {
            if (e.length < 2) return i.error("Expected at least one argument.");
            let u = null;
            const c = i.expectedType;
            c && c.kind !== "value" && (u = c);
            const m = [];
            for (const x of e.slice(1)) {
              const C = i.parse(x, 1 + m.length, u, void 0, { typeAnnotation: "omit" });
              if (!C) return null;
              u = u || C.type, m.push(C);
            }
            if (!u) throw new Error("No output type");
            const v = c && m.some(((x) => ro(c, x.type)));
            return new ys(v ? ar : u, m);
          }
          evaluate(e) {
            let i, u = null, c = 0;
            for (const m of this.args) if (c++, u = m.evaluate(e), u && u instanceof Bn && !u.available && (i || (i = u.name), u = null, c === this.args.length && (u = i)), u !== null) break;
            return u;
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return this.args.every(((e) => e.outputDefined()));
          }
        }
        function Zc(o, e) {
          return o === "==" || o === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
        }
        function Yh(o, e, i, u) {
          return u.compare(e, i) === 0;
        }
        function _o(o, e, i) {
          const u = o !== "==" && o !== "!=";
          return class Ax {
            constructor(m, v, x) {
              this.type = Xt, this.lhs = m, this.rhs = v, this.collator = x, this.hasUntypedArgument = m.type.kind === "value" || v.type.kind === "value";
            }
            static parse(m, v) {
              if (m.length !== 3 && m.length !== 4) return v.error("Expected two or three arguments.");
              const x = m[0];
              let C = v.parse(m[1], 1, ar);
              if (!C) return null;
              if (!Zc(x, C.type)) return v.concat(1).error(`"${x}" comparisons are not supported for type '${Gr(C.type)}'.`);
              let k = v.parse(m[2], 2, ar);
              if (!k) return null;
              if (!Zc(x, k.type)) return v.concat(2).error(`"${x}" comparisons are not supported for type '${Gr(k.type)}'.`);
              if (C.type.kind !== k.type.kind && C.type.kind !== "value" && k.type.kind !== "value") return v.error(`Cannot compare types '${Gr(C.type)}' and '${Gr(k.type)}'.`);
              u && (C.type.kind === "value" && k.type.kind !== "value" ? C = new On(k.type, [C]) : C.type.kind !== "value" && k.type.kind === "value" && (k = new On(C.type, [k])));
              let E = null;
              if (m.length === 4) {
                if (C.type.kind !== "string" && k.type.kind !== "string" && C.type.kind !== "value" && k.type.kind !== "value") return v.error("Cannot use collator to compare non-string types.");
                if (E = v.parse(m[3], 3, Wn), !E) return null;
              }
              return new Ax(C, k, E);
            }
            evaluate(m) {
              const v = this.lhs.evaluate(m), x = this.rhs.evaluate(m);
              if (u && this.hasUntypedArgument) {
                const C = ei(v), k = ei(x);
                if (C.kind !== k.kind || C.kind !== "string" && C.kind !== "number") throw new Hr(`Expected arguments for "${o}" to be (string, string) or (number, number), but found (${C.kind}, ${k.kind}) instead.`);
              }
              if (this.collator && !u && this.hasUntypedArgument) {
                const C = ei(v), k = ei(x);
                if (C.kind !== "string" || k.kind !== "string") return e(m, v, x);
              }
              return this.collator ? i(m, v, x, this.collator.evaluate(m)) : e(m, v, x);
            }
            eachChild(m) {
              m(this.lhs), m(this.rhs), this.collator && m(this.collator);
            }
            outputDefined() {
              return true;
            }
          };
        }
        const pu = _o("==", (function(o, e, i) {
          return e === i;
        }), Yh), Hc = _o("!=", (function(o, e, i) {
          return e !== i;
        }), (function(o, e, i, u) {
          return !Yh(0, e, i, u);
        })), Cm = _o("<", (function(o, e, i) {
          return e < i;
        }), (function(o, e, i, u) {
          return u.compare(e, i) < 0;
        })), Kh = _o(">", (function(o, e, i) {
          return e > i;
        }), (function(o, e, i, u) {
          return u.compare(e, i) > 0;
        })), mu = _o("<=", (function(o, e, i) {
          return e <= i;
        }), (function(o, e, i, u) {
          return u.compare(e, i) <= 0;
        })), gu = _o(">=", (function(o, e, i) {
          return e >= i;
        }), (function(o, e, i, u) {
          return u.compare(e, i) >= 0;
        }));
        class $n {
          constructor(e, i, u) {
            this.type = Wn, this.locale = u, this.caseSensitive = e, this.diacriticSensitive = i;
          }
          static parse(e, i) {
            if (e.length !== 2) return i.error("Expected one argument.");
            const u = e[1];
            if (typeof u != "object" || Array.isArray(u)) return i.error("Collator options argument must be an object.");
            const c = i.parse(u["case-sensitive"] !== void 0 && u["case-sensitive"], 1, Xt);
            if (!c) return null;
            const m = i.parse(u["diacritic-sensitive"] !== void 0 && u["diacritic-sensitive"], 1, Xt);
            if (!m) return null;
            let v = null;
            return u.locale && (v = i.parse(u.locale, 1, Bt), !v) ? null : new $n(c, m, v);
          }
          evaluate(e) {
            return new no(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
          }
          eachChild(e) {
            e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
          }
          outputDefined() {
            return false;
          }
        }
        class vu {
          constructor(e, i, u, c, m) {
            this.type = Bt, this.number = e, this.locale = i, this.currency = u, this.minFractionDigits = c, this.maxFractionDigits = m;
          }
          static parse(e, i) {
            if (e.length !== 3) return i.error("Expected two arguments.");
            const u = i.parse(e[1], 1, st);
            if (!u) return null;
            const c = e[2];
            if (typeof c != "object" || Array.isArray(c)) return i.error("NumberFormat options argument must be an object.");
            let m = null;
            if (c.locale && (m = i.parse(c.locale, 1, Bt), !m)) return null;
            let v = null;
            if (c.currency && (v = i.parse(c.currency, 1, Bt), !v)) return null;
            let x = null;
            if (c["min-fraction-digits"] && (x = i.parse(c["min-fraction-digits"], 1, st), !x)) return null;
            let C = null;
            return c["max-fraction-digits"] && (C = i.parse(c["max-fraction-digits"], 1, st), !C) ? null : new vu(u, m, v, x, C);
          }
          evaluate(e) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(e) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0 }).format(this.number.evaluate(e));
          }
          eachChild(e) {
            e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
        }
        class Va {
          constructor(e) {
            this.type = Lo, this.sections = e;
          }
          static parse(e, i) {
            if (e.length < 2) return i.error("Expected at least one argument.");
            const u = e[1];
            if (!Array.isArray(u) && typeof u == "object") return i.error("First argument must be an image or text section.");
            const c = [];
            let m = false;
            for (let v = 1; v <= e.length - 1; ++v) {
              const x = e[v];
              if (m && typeof x == "object" && !Array.isArray(x)) {
                m = false;
                let C = null;
                if (x["font-scale"] && (C = i.parse(x["font-scale"], 1, st), !C)) return null;
                let k = null;
                if (x["text-font"] && (k = i.parse(x["text-font"], 1, Tn(Bt)), !k)) return null;
                let E = null;
                if (x["text-color"] && (E = i.parse(x["text-color"], 1, hi), !E)) return null;
                let D = null;
                if (x["vertical-align"]) {
                  if (typeof x["vertical-align"] == "string" && !Er.includes(x["vertical-align"])) return i.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${x["vertical-align"]}' instead.`);
                  if (D = i.parse(x["vertical-align"], 1, Bt), !D) return null;
                }
                const F = c[c.length - 1];
                F.scale = C, F.font = k, F.textColor = E, F.verticalAlign = D;
              } else {
                const C = i.parse(e[v], 1, ar);
                if (!C) return null;
                const k = C.type.kind;
                if (k !== "string" && k !== "value" && k !== "null" && k !== "resolvedImage") return i.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                m = true, c.push({ content: C, scale: null, font: null, textColor: null, verticalAlign: null });
              }
            }
            return new Va(c);
          }
          evaluate(e) {
            return new Mi(this.sections.map(((i) => {
              const u = i.content.evaluate(e);
              return ei(u) === Zn ? new ya("", u, null, null, null, i.verticalAlign ? i.verticalAlign.evaluate(e) : null) : new ya(ps(u), null, i.scale ? i.scale.evaluate(e) : null, i.font ? i.font.evaluate(e).join(",") : null, i.textColor ? i.textColor.evaluate(e) : null, i.verticalAlign ? i.verticalAlign.evaluate(e) : null);
            })));
          }
          eachChild(e) {
            for (const i of this.sections) e(i.content), i.scale && e(i.scale), i.font && e(i.font), i.textColor && e(i.textColor), i.verticalAlign && e(i.verticalAlign);
          }
          outputDefined() {
            return false;
          }
        }
        class Xc {
          constructor(e) {
            this.type = Zn, this.input = e;
          }
          static parse(e, i) {
            if (e.length !== 2) return i.error("Expected two arguments.");
            const u = i.parse(e[1], 1, Bt);
            return u ? new Xc(u) : i.error("No image name provided.");
          }
          evaluate(e) {
            const i = this.input.evaluate(e), u = Bn.fromString(i);
            return u && e.availableImages && (u.available = e.availableImages.indexOf(i) > -1), u;
          }
          eachChild(e) {
            e(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class il {
          constructor(e) {
            this.type = st, this.input = e;
          }
          static parse(e, i) {
            if (e.length !== 2) return i.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
            const u = i.parse(e[1], 1);
            return u ? u.type.kind !== "array" && u.type.kind !== "string" && u.type.kind !== "value" ? i.error(`Expected argument of type string or array, but found ${Gr(u.type)} instead.`) : new il(u) : null;
          }
          evaluate(e) {
            const i = this.input.evaluate(e);
            if (typeof i == "string") return [...i].length;
            if (Array.isArray(i)) return i.length;
            throw new Hr(`Expected value to be of type string or array, but found ${Gr(ei(i))} instead.`);
          }
          eachChild(e) {
            e(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        const Vo = 8192;
        function Sm(o, e) {
          const i = (180 + o[0]) / 360, u = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + o[1] * Math.PI / 360))) / 360, c = Math.pow(2, e.z);
          return [Math.round(i * c * Vo), Math.round(u * c * Vo)];
        }
        function Yc(o, e) {
          const i = Math.pow(2, e.z);
          return [(c = (o[0] / Vo + e.x) / i, 360 * c - 180), (u = (o[1] / Vo + e.y) / i, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * u) * Math.PI / 180)) - 90)];
          var u, c;
        }
        function nl(o, e) {
          o[0] = Math.min(o[0], e[0]), o[1] = Math.min(o[1], e[1]), o[2] = Math.max(o[2], e[0]), o[3] = Math.max(o[3], e[1]);
        }
        function xa(o, e) {
          return !(o[0] <= e[0] || o[2] >= e[2] || o[1] <= e[1] || o[3] >= e[3]);
        }
        function km(o, e, i) {
          const u = o[0] - e[0], c = o[1] - e[1], m = o[0] - i[0], v = o[1] - i[1];
          return u * v - m * c == 0 && u * m <= 0 && c * v <= 0;
        }
        function ol(o, e, i, u) {
          return (c = [u[0] - i[0], u[1] - i[1]])[0] * (m = [e[0] - o[0], e[1] - o[1]])[1] - c[1] * m[0] != 0 && !(!tf(o, e, i, u) || !tf(i, u, o, e));
          var c, m;
        }
        function Jh(o, e, i) {
          for (const u of i) for (let c = 0; c < u.length - 1; ++c) if (ol(o, e, u[c], u[c + 1])) return true;
          return false;
        }
        function _s(o, e, i = false) {
          let u = false;
          for (const x of e) for (let C = 0; C < x.length - 1; C++) {
            if (km(o, x[C], x[C + 1])) return i;
            (m = x[C])[1] > (c = o)[1] != (v = x[C + 1])[1] > c[1] && c[0] < (v[0] - m[0]) * (c[1] - m[1]) / (v[1] - m[1]) + m[0] && (u = !u);
          }
          var c, m, v;
          return u;
        }
        function Qh(o, e) {
          for (const i of e) if (_s(o, i)) return true;
          return false;
        }
        function ef(o, e) {
          for (const i of o) if (!_s(i, e)) return false;
          for (let i = 0; i < o.length - 1; ++i) if (Jh(o[i], o[i + 1], e)) return false;
          return true;
        }
        function Tm(o, e) {
          for (const i of e) if (ef(o, i)) return true;
          return false;
        }
        function tf(o, e, i, u) {
          const c = u[0] - i[0], m = u[1] - i[1], v = (o[0] - i[0]) * m - c * (o[1] - i[1]), x = (e[0] - i[0]) * m - c * (e[1] - i[1]);
          return v > 0 && x < 0 || v < 0 && x > 0;
        }
        function Kc(o, e, i) {
          const u = [];
          for (let c = 0; c < o.length; c++) {
            const m = [];
            for (let v = 0; v < o[c].length; v++) {
              const x = Sm(o[c][v], i);
              nl(e, x), m.push(x);
            }
            u.push(m);
          }
          return u;
        }
        function rf(o, e, i) {
          const u = [];
          for (let c = 0; c < o.length; c++) {
            const m = Kc(o[c], e, i);
            u.push(m);
          }
          return u;
        }
        function Jc(o, e, i, u) {
          if (o[0] < i[0] || o[0] > i[2]) {
            const c = 0.5 * u;
            let m = o[0] - i[0] > c ? -u : i[0] - o[0] > c ? u : 0;
            m === 0 && (m = o[0] - i[2] > c ? -u : i[2] - o[0] > c ? u : 0), o[0] += m;
          }
          nl(e, o);
        }
        function Qc(o, e, i, u) {
          const c = Math.pow(2, u.z) * Vo, m = [u.x * Vo, u.y * Vo], v = [];
          for (const x of o) for (const C of x) {
            const k = [C.x + m[0], C.y + m[1]];
            Jc(k, e, i, c), v.push(k);
          }
          return v;
        }
        function ed(o, e, i, u) {
          const c = Math.pow(2, u.z) * Vo, m = [u.x * Vo, u.y * Vo], v = [];
          for (const C of o) {
            const k = [];
            for (const E of C) {
              const D = [E.x + m[0], E.y + m[1]];
              nl(e, D), k.push(D);
            }
            v.push(k);
          }
          if (e[2] - e[0] <= c / 2) {
            (x = e)[0] = x[1] = 1 / 0, x[2] = x[3] = -1 / 0;
            for (const C of v) for (const k of C) Jc(k, e, i, c);
          }
          var x;
          return v;
        }
        class Ua {
          constructor(e, i) {
            this.type = Xt, this.geojson = e, this.geometries = i;
          }
          static parse(e, i) {
            if (e.length !== 2) return i.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
            if (_a2(e[1])) {
              const u = e[1];
              if (u.type === "FeatureCollection") {
                const c = [];
                for (const m of u.features) {
                  const { type: v, coordinates: x } = m.geometry;
                  v === "Polygon" && c.push(x), v === "MultiPolygon" && c.push(...x);
                }
                if (c.length) return new Ua(u, { type: "MultiPolygon", coordinates: c });
              } else if (u.type === "Feature") {
                const c = u.geometry.type;
                if (c === "Polygon" || c === "MultiPolygon") return new Ua(u, u.geometry);
              } else if (u.type === "Polygon" || u.type === "MultiPolygon") return new Ua(u, u);
            }
            return i.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(e) {
            if (e.geometry() != null && e.canonicalID() != null) {
              if (e.geometryType() === "Point") return (function(i, u) {
                const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0], m = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = i.canonicalID();
                if (u.type === "Polygon") {
                  const x = Kc(u.coordinates, m, v), C = Qc(i.geometry(), c, m, v);
                  if (!xa(c, m)) return false;
                  for (const k of C) if (!_s(k, x)) return false;
                }
                if (u.type === "MultiPolygon") {
                  const x = rf(u.coordinates, m, v), C = Qc(i.geometry(), c, m, v);
                  if (!xa(c, m)) return false;
                  for (const k of C) if (!Qh(k, x)) return false;
                }
                return true;
              })(e, this.geometries);
              if (e.geometryType() === "LineString") return (function(i, u) {
                const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0], m = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = i.canonicalID();
                if (u.type === "Polygon") {
                  const x = Kc(u.coordinates, m, v), C = ed(i.geometry(), c, m, v);
                  if (!xa(c, m)) return false;
                  for (const k of C) if (!ef(k, x)) return false;
                }
                if (u.type === "MultiPolygon") {
                  const x = rf(u.coordinates, m, v), C = ed(i.geometry(), c, m, v);
                  if (!xa(c, m)) return false;
                  for (const k of C) if (!Tm(k, x)) return false;
                }
                return true;
              })(e, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        let nf = class {
          constructor(o = [], e = (i, u) => i < u ? -1 : i > u ? 1 : 0) {
            if (this.data = o, this.length = this.data.length, this.compare = e, this.length > 0) for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
          }
          push(o) {
            this.data.push(o), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const o = this.data[0], e = this.data.pop();
            return --this.length > 0 && (this.data[0] = e, this._down(0)), o;
          }
          peek() {
            return this.data[0];
          }
          _up(o) {
            const { data: e, compare: i } = this, u = e[o];
            for (; o > 0; ) {
              const c = o - 1 >> 1, m = e[c];
              if (i(u, m) >= 0) break;
              e[o] = m, o = c;
            }
            e[o] = u;
          }
          _down(o) {
            const { data: e, compare: i } = this, u = this.length >> 1, c = e[o];
            for (; o < u; ) {
              let m = 1 + (o << 1);
              const v = m + 1;
              if (v < this.length && i(e[v], e[m]) < 0 && (m = v), i(e[m], c) >= 0) break;
              e[o] = e[m], o = m;
            }
            e[o] = c;
          }
        };
        function of(o, e, i = 0, u = o.length - 1, c = yu) {
          for (; u > i; ) {
            if (u - i > 600) {
              const C = u - i + 1, k = e - i + 1, E = Math.log(C), D = 0.5 * Math.exp(2 * E / 3), F = 0.5 * Math.sqrt(E * D * (C - D) / C) * (k - C / 2 < 0 ? -1 : 1);
              of(o, e, Math.max(i, Math.floor(e - k * D / C + F)), Math.min(u, Math.floor(e + (C - k) * D / C + F)), c);
            }
            const m = o[e];
            let v = i, x = u;
            for (al(o, i, e), c(o[u], m) > 0 && al(o, i, u); v < x; ) {
              for (al(o, v, x), v++, x--; c(o[v], m) < 0; ) v++;
              for (; c(o[x], m) > 0; ) x--;
            }
            c(o[i], m) === 0 ? al(o, i, x) : (x++, al(o, x, u)), x <= e && (i = x + 1), e <= x && (u = x - 1);
          }
        }
        function al(o, e, i) {
          const u = o[e];
          o[e] = o[i], o[i] = u;
        }
        function yu(o, e) {
          return o < e ? -1 : o > e ? 1 : 0;
        }
        function sl(o, e) {
          if (o.length <= 1) return [o];
          const i = [];
          let u, c;
          for (const m of o) {
            const v = Im(m);
            v !== 0 && (m.area = Math.abs(v), c === void 0 && (c = v < 0), c === v < 0 ? (u && i.push(u), u = [m]) : u.push(m));
          }
          if (u && i.push(u), e > 1) for (let m = 0; m < i.length; m++) i[m].length <= e || (of(i[m], e, 1, i[m].length - 1, Pm), i[m] = i[m].slice(0, e));
          return i;
        }
        function Pm(o, e) {
          return e.area - o.area;
        }
        function Im(o) {
          let e = 0;
          for (let i, u, c = 0, m = o.length, v = m - 1; c < m; v = c++) i = o[c], u = o[v], e += (u.x - i.x) * (i.y + u.y);
          return e;
        }
        const af = 1 / 298.257223563, _u = af * (2 - af), td = Math.PI / 180;
        class rd {
          constructor(e) {
            const i = 6378.137 * td * 1e3, u = Math.cos(e * td), c = 1 / (1 - _u * (1 - u * u)), m = Math.sqrt(c);
            this.kx = i * m * u, this.ky = i * m * c * (1 - _u);
          }
          distance(e, i) {
            const u = this.wrap(e[0] - i[0]) * this.kx, c = (e[1] - i[1]) * this.ky;
            return Math.sqrt(u * u + c * c);
          }
          pointOnLine(e, i) {
            let u, c, m, v, x = 1 / 0;
            for (let C = 0; C < e.length - 1; C++) {
              let k = e[C][0], E = e[C][1], D = this.wrap(e[C + 1][0] - k) * this.kx, F = (e[C + 1][1] - E) * this.ky, V = 0;
              D === 0 && F === 0 || (V = (this.wrap(i[0] - k) * this.kx * D + (i[1] - E) * this.ky * F) / (D * D + F * F), V > 1 ? (k = e[C + 1][0], E = e[C + 1][1]) : V > 0 && (k += D / this.kx * V, E += F / this.ky * V)), D = this.wrap(i[0] - k) * this.kx, F = (i[1] - E) * this.ky;
              const G = D * D + F * F;
              G < x && (x = G, u = k, c = E, m = C, v = V);
            }
            return { point: [u, c], index: m, t: Math.max(0, Math.min(1, v)) };
          }
          wrap(e) {
            for (; e < -180; ) e += 360;
            for (; e > 180; ) e -= 360;
            return e;
          }
        }
        function sf(o, e) {
          return e[0] - o[0];
        }
        function ll(o) {
          return o[1] - o[0] + 1;
        }
        function Uo(o, e) {
          return o[1] >= o[0] && o[1] < e;
        }
        function id(o, e) {
          if (o[0] > o[1]) return [null, null];
          const i = ll(o);
          if (e) {
            if (i === 2) return [o, null];
            const c = Math.floor(i / 2);
            return [[o[0], o[0] + c], [o[0] + c, o[1]]];
          }
          if (i === 1) return [o, null];
          const u = Math.floor(i / 2) - 1;
          return [[o[0], o[0] + u], [o[0] + u + 1, o[1]]];
        }
        function nd(o, e) {
          if (!Uo(e, o.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let u = e[0]; u <= e[1]; ++u) nl(i, o[u]);
          return i;
        }
        function od(o) {
          const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const i of o) for (const u of i) nl(e, u);
          return e;
        }
        function ad(o) {
          return o[0] !== -1 / 0 && o[1] !== -1 / 0 && o[2] !== 1 / 0 && o[3] !== 1 / 0;
        }
        function sd(o, e, i) {
          if (!ad(o) || !ad(e)) return NaN;
          let u = 0, c = 0;
          return o[2] < e[0] && (u = e[0] - o[2]), o[0] > e[2] && (u = o[0] - e[2]), o[1] > e[3] && (c = o[1] - e[3]), o[3] < e[1] && (c = e[1] - o[3]), i.distance([0, 0], [u, c]);
        }
        function Ga(o, e, i) {
          const u = i.pointOnLine(e, o);
          return i.distance(o, u.point);
        }
        function ld(o, e, i, u, c) {
          const m = Math.min(Ga(o, [i, u], c), Ga(e, [i, u], c)), v = Math.min(Ga(i, [o, e], c), Ga(u, [o, e], c));
          return Math.min(m, v);
        }
        function Em(o, e, i, u, c) {
          if (!Uo(e, o.length) || !Uo(u, i.length)) return 1 / 0;
          let m = 1 / 0;
          for (let v = e[0]; v < e[1]; ++v) {
            const x = o[v], C = o[v + 1];
            for (let k = u[0]; k < u[1]; ++k) {
              const E = i[k], D = i[k + 1];
              if (ol(x, C, E, D)) return 0;
              m = Math.min(m, ld(x, C, E, D, c));
            }
          }
          return m;
        }
        function Lr(o, e, i, u, c) {
          if (!Uo(e, o.length) || !Uo(u, i.length)) return NaN;
          let m = 1 / 0;
          for (let v = e[0]; v <= e[1]; ++v) for (let x = u[0]; x <= u[1]; ++x) if (m = Math.min(m, c.distance(o[v], i[x])), m === 0) return m;
          return m;
        }
        function Mm(o, e, i) {
          if (_s(o, e, true)) return 0;
          let u = 1 / 0;
          for (const c of e) {
            const m = c[0], v = c[c.length - 1];
            if (m !== v && (u = Math.min(u, Ga(o, [v, m], i)), u === 0)) return u;
            const x = i.pointOnLine(c, o);
            if (u = Math.min(u, i.distance(o, x.point)), u === 0) return u;
          }
          return u;
        }
        function Dm(o, e, i, u) {
          if (!Uo(e, o.length)) return NaN;
          for (let m = e[0]; m <= e[1]; ++m) if (_s(o[m], i, true)) return 0;
          let c = 1 / 0;
          for (let m = e[0]; m < e[1]; ++m) {
            const v = o[m], x = o[m + 1];
            for (const C of i) for (let k = 0, E = C.length, D = E - 1; k < E; D = k++) {
              const F = C[D], V = C[k];
              if (ol(v, x, F, V)) return 0;
              c = Math.min(c, ld(v, x, F, V, u));
            }
          }
          return c;
        }
        function lf(o, e) {
          for (const i of o) for (const u of i) if (_s(u, e, true)) return true;
          return false;
        }
        function Rm(o, e, i, u = 1 / 0) {
          const c = od(o), m = od(e);
          if (u !== 1 / 0 && sd(c, m, i) >= u) return u;
          if (xa(c, m)) {
            if (lf(o, e)) return 0;
          } else if (lf(e, o)) return 0;
          let v = 1 / 0;
          for (const x of o) for (let C = 0, k = x.length, E = k - 1; C < k; E = C++) {
            const D = x[E], F = x[C];
            for (const V of e) for (let G = 0, H = V.length, Y = H - 1; G < H; Y = G++) {
              const ie = V[Y], we = V[G];
              if (ol(D, F, ie, we)) return 0;
              v = Math.min(v, ld(D, F, ie, we, i));
            }
          }
          return v;
        }
        function uf(o, e, i, u, c, m) {
          if (!m) return;
          const v = sd(nd(u, m), c, i);
          v < e && o.push([v, m, [0, 0]]);
        }
        function bu(o, e, i, u, c, m, v) {
          if (!m || !v) return;
          const x = sd(nd(u, m), nd(c, v), i);
          x < e && o.push([x, m, v]);
        }
        function xu(o, e, i, u, c = 1 / 0) {
          let m = Math.min(u.distance(o[0], i[0][0]), c);
          if (m === 0) return m;
          const v = new nf([[0, [0, o.length - 1], [0, 0]]], sf), x = od(i);
          for (; v.length > 0; ) {
            const C = v.pop();
            if (C[0] >= m) continue;
            const k = C[1], E = e ? 50 : 100;
            if (ll(k) <= E) {
              if (!Uo(k, o.length)) return NaN;
              if (e) {
                const D = Dm(o, k, i, u);
                if (isNaN(D) || D === 0) return D;
                m = Math.min(m, D);
              } else for (let D = k[0]; D <= k[1]; ++D) {
                const F = Mm(o[D], i, u);
                if (m = Math.min(m, F), m === 0) return 0;
              }
            } else {
              const D = id(k, e);
              uf(v, m, u, o, x, D[0]), uf(v, m, u, o, x, D[1]);
            }
          }
          return m;
        }
        function wu(o, e, i, u, c, m = 1 / 0) {
          let v = Math.min(m, c.distance(o[0], i[0]));
          if (v === 0) return v;
          const x = new nf([[0, [0, o.length - 1], [0, i.length - 1]]], sf);
          for (; x.length > 0; ) {
            const C = x.pop();
            if (C[0] >= v) continue;
            const k = C[1], E = C[2], D = e ? 50 : 100, F = u ? 50 : 100;
            if (ll(k) <= D && ll(E) <= F) {
              if (!Uo(k, o.length) && Uo(E, i.length)) return NaN;
              let V;
              if (e && u) V = Em(o, k, i, E, c), v = Math.min(v, V);
              else if (e && !u) {
                const G = o.slice(k[0], k[1] + 1);
                for (let H = E[0]; H <= E[1]; ++H) if (V = Ga(i[H], G, c), v = Math.min(v, V), v === 0) return v;
              } else if (!e && u) {
                const G = i.slice(E[0], E[1] + 1);
                for (let H = k[0]; H <= k[1]; ++H) if (V = Ga(o[H], G, c), v = Math.min(v, V), v === 0) return v;
              } else V = Lr(o, k, i, E, c), v = Math.min(v, V);
            } else {
              const V = id(k, e), G = id(E, u);
              bu(x, v, c, o, i, V[0], G[0]), bu(x, v, c, o, i, V[0], G[1]), bu(x, v, c, o, i, V[1], G[0]), bu(x, v, c, o, i, V[1], G[1]);
            }
          }
          return v;
        }
        function ud(o) {
          return o.type === "MultiPolygon" ? o.coordinates.map(((e) => ({ type: "Polygon", coordinates: e }))) : o.type === "MultiLineString" ? o.coordinates.map(((e) => ({ type: "LineString", coordinates: e }))) : o.type === "MultiPoint" ? o.coordinates.map(((e) => ({ type: "Point", coordinates: e }))) : [o];
        }
        class qa {
          constructor(e, i) {
            this.type = st, this.geojson = e, this.geometries = i;
          }
          static parse(e, i) {
            if (e.length !== 2) return i.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`);
            if (_a2(e[1])) {
              const u = e[1];
              if (u.type === "FeatureCollection") return new qa(u, u.features.map(((c) => ud(c.geometry))).flat());
              if (u.type === "Feature") return new qa(u, ud(u.geometry));
              if ("type" in u && "coordinates" in u) return new qa(u, ud(u));
            }
            return i.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(e) {
            if (e.geometry() != null && e.canonicalID() != null) {
              if (e.geometryType() === "Point") return (function(i, u) {
                const c = i.geometry(), m = c.flat().map(((C) => Yc([C.x, C.y], i.canonical)));
                if (c.length === 0) return NaN;
                const v = new rd(m[0][1]);
                let x = 1 / 0;
                for (const C of u) {
                  switch (C.type) {
                    case "Point":
                      x = Math.min(x, wu(m, false, [C.coordinates], false, v, x));
                      break;
                    case "LineString":
                      x = Math.min(x, wu(m, false, C.coordinates, true, v, x));
                      break;
                    case "Polygon":
                      x = Math.min(x, xu(m, false, C.coordinates, v, x));
                  }
                  if (x === 0) return x;
                }
                return x;
              })(e, this.geometries);
              if (e.geometryType() === "LineString") return (function(i, u) {
                const c = i.geometry(), m = c.flat().map(((C) => Yc([C.x, C.y], i.canonical)));
                if (c.length === 0) return NaN;
                const v = new rd(m[0][1]);
                let x = 1 / 0;
                for (const C of u) {
                  switch (C.type) {
                    case "Point":
                      x = Math.min(x, wu(m, true, [C.coordinates], false, v, x));
                      break;
                    case "LineString":
                      x = Math.min(x, wu(m, true, C.coordinates, true, v, x));
                      break;
                    case "Polygon":
                      x = Math.min(x, xu(m, true, C.coordinates, v, x));
                  }
                  if (x === 0) return x;
                }
                return x;
              })(e, this.geometries);
              if (e.geometryType() === "Polygon") return (function(i, u) {
                const c = i.geometry();
                if (c.length === 0 || c[0].length === 0) return NaN;
                const m = sl(c, 0).map(((C) => C.map(((k) => k.map(((E) => Yc([E.x, E.y], i.canonical))))))), v = new rd(m[0][0][0][1]);
                let x = 1 / 0;
                for (const C of u) for (const k of m) {
                  switch (C.type) {
                    case "Point":
                      x = Math.min(x, xu([C.coordinates], false, k, v, x));
                      break;
                    case "LineString":
                      x = Math.min(x, xu(C.coordinates, true, k, v, x));
                      break;
                    case "Polygon":
                      x = Math.min(x, Rm(k, C.coordinates, v, x));
                  }
                  if (x === 0) return x;
                }
                return x;
              })(e, this.geometries);
            }
            return NaN;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        class ul {
          constructor(e) {
            this.type = ar, this.key = e;
          }
          static parse(e, i) {
            if (e.length !== 2) return i.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
            const u = e[1];
            return u == null ? i.error("Global state property must be defined.") : typeof u != "string" ? i.error(`Global state property must be string, but found ${typeof e[1]} instead.`) : new ul(u);
          }
          evaluate(e) {
            var i;
            const u = (i = e.globals) === null || i === void 0 ? void 0 : i.globalState;
            return u && Object.keys(u).length !== 0 ? go(u, this.key) : null;
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
        }
        const bs = { "==": pu, "!=": Hc, ">": Kh, "<": Cm, ">=": gu, "<=": mu, array: On, at: vo, boolean: On, case: tl, coalesce: ys, collator: $n, format: Va, image: Xc, in: el, "index-of": ja, interpolate: rn, "interpolate-hcl": rn, "interpolate-lab": rn, length: il, let: Mr, literal: ba, match: du, number: On, "number-format": vu, object: On, slice: rl, step: vs, string: On, "to-boolean": No, "to-color": No, "to-number": No, "to-string": No, var: gs, within: Ua, distance: qa, "global-state": ul };
        class oo {
          constructor(e, i, u, c) {
            this.name = e, this.type = i, this._evaluate = u, this.args = c;
          }
          evaluate(e) {
            return this._evaluate(e, this.args);
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return false;
          }
          static parse(e, i) {
            const u = e[0], c = oo.definitions[u];
            if (!c) return i.error(`Unknown expression "${u}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const m = Array.isArray(c) ? c[0] : c.type, v = Array.isArray(c) ? [[c[1], c[2]]] : c.overloads, x = v.filter((([k]) => !Array.isArray(k) || k.length === e.length - 1));
            let C = null;
            for (const [k, E] of x) {
              C = new ms(i.registry, Cu, i.path, null, i.scope);
              const D = [];
              let F = false;
              for (let V = 1; V < e.length; V++) {
                const G = e[V], H = Array.isArray(k) ? k[V - 1] : k.type, Y = C.parse(G, 1 + D.length, H);
                if (!Y) {
                  F = true;
                  break;
                }
                D.push(Y);
              }
              if (!F) if (Array.isArray(k) && k.length !== D.length) C.error(`Expected ${k.length} arguments, but found ${D.length} instead.`);
              else {
                for (let V = 0; V < D.length; V++) {
                  const G = Array.isArray(k) ? k[V] : k.type, H = D[V];
                  C.concat(V + 1).checkSubtype(G, H.type);
                }
                if (C.errors.length === 0) return new oo(u, m, E, D);
              }
            }
            if (x.length === 1) i.errors.push(...C.errors);
            else {
              const k = (x.length ? x : v).map((([D]) => {
                return F = D, Array.isArray(F) ? `(${F.map(Gr).join(", ")})` : `(${Gr(F.type)}...)`;
                var F;
              })).join(" | "), E = [];
              for (let D = 1; D < e.length; D++) {
                const F = i.parse(e[D], 1 + E.length);
                if (!F) return null;
                E.push(Gr(F.type));
              }
              i.error(`Expected arguments of type ${k}, but found (${E.join(", ")}) instead.`);
            }
            return null;
          }
          static register(e, i) {
            oo.definitions = i;
            for (const u in i) e[u] = oo;
          }
        }
        function cf(o, [e, i, u, c]) {
          e = e.evaluate(o), i = i.evaluate(o), u = u.evaluate(o);
          const m = c ? c.evaluate(o) : 1, v = Zh(e, i, u, m);
          if (v) throw new Hr(v);
          return new br(e / 255, i / 255, u / 255, m, false);
        }
        function df(o, e) {
          return o in e;
        }
        function cd(o, e) {
          const i = e[o];
          return i === void 0 ? null : i;
        }
        function Wa(o) {
          return { type: o };
        }
        function Cu(o) {
          if (o instanceof gs) return Cu(o.boundExpression);
          if (o instanceof oo && o.name === "error" || o instanceof $n || o instanceof Ua || o instanceof qa || o instanceof ul) return false;
          const e = o instanceof No || o instanceof On;
          let i = true;
          return o.eachChild(((u) => {
            i = e ? i && Cu(u) : i && u instanceof ba;
          })), !!i && Su(o) && ku(o, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]);
        }
        function Su(o) {
          if (o instanceof oo && (o.name === "get" && o.args.length === 1 || o.name === "feature-state" || o.name === "has" && o.args.length === 1 || o.name === "properties" || o.name === "geometry-type" || o.name === "id" || /^filter-/.test(o.name)) || o instanceof Ua || o instanceof qa) return false;
          let e = true;
          return o.eachChild(((i) => {
            e && !Su(i) && (e = false);
          })), e;
        }
        function cl(o) {
          if (o instanceof oo && o.name === "feature-state") return false;
          let e = true;
          return o.eachChild(((i) => {
            e && !cl(i) && (e = false);
          })), e;
        }
        function ku(o, e) {
          if (o instanceof oo && e.indexOf(o.name) >= 0) return false;
          let i = true;
          return o.eachChild(((u) => {
            i && !ku(u, e) && (i = false);
          })), i;
        }
        function hf(o) {
          return { result: "success", value: o };
        }
        function xs(o) {
          return { result: "error", value: o };
        }
        function ws(o) {
          return o["property-type"] === "data-driven" || o["property-type"] === "cross-faded-data-driven";
        }
        function ff(o) {
          return !!o.expression && o.expression.parameters.indexOf("zoom") > -1;
        }
        function dd(o) {
          return !!o.expression && o.expression.interpolated;
        }
        function kr(o) {
          return o instanceof Number ? "number" : o instanceof String ? "string" : o instanceof Boolean ? "boolean" : Array.isArray(o) ? "array" : o === null ? "null" : typeof o;
        }
        function Tu(o) {
          return typeof o == "object" && o !== null && !Array.isArray(o) && ei(o) === Jr;
        }
        function Am(o) {
          return o;
        }
        function pf(o, e) {
          const i = o.stops && typeof o.stops[0][0] == "object", u = i || !(i || o.property !== void 0), c = o.type || (dd(e) ? "exponential" : "interval"), m = (function(E) {
            switch (E.type) {
              case "color":
                return br.parse;
              case "padding":
                return dn.parse;
              case "numberArray":
                return hn.parse;
              case "colorArray":
                return Oi.parse;
              default:
                return null;
            }
          })(e);
          if (m && ((o = at({}, o)).stops && (o.stops = o.stops.map(((E) => [E[0], m(E[1])]))), o.default = m(o.default ? o.default : e.default)), o.colorSpace && (v = o.colorSpace) !== "rgb" && v !== "hcl" && v !== "lab") throw new Error(`Unknown color space: "${o.colorSpace}"`);
          var v;
          const x = (function(E) {
            switch (E) {
              case "exponential":
                return mf;
              case "interval":
                return zm;
              case "categorical":
                return hd;
              case "identity":
                return Fm;
              default:
                throw new Error(`Unknown function type "${E}"`);
            }
          })(c);
          let C, k;
          if (c === "categorical") {
            C = /* @__PURE__ */ Object.create(null);
            for (const E of o.stops) C[E[0]] = E[1];
            k = typeof o.stops[0][0];
          }
          if (i) {
            const E = {}, D = [];
            for (let G = 0; G < o.stops.length; G++) {
              const H = o.stops[G], Y = H[0].zoom;
              E[Y] === void 0 && (E[Y] = { zoom: Y, type: o.type, property: o.property, default: o.default, stops: [] }, D.push(Y)), E[Y].stops.push([H[0].value, H[1]]);
            }
            const F = [];
            for (const G of D) F.push([E[G].zoom, pf(E[G], e)]);
            const V = { name: "linear" };
            return { kind: "composite", interpolationType: V, interpolationFactor: rn.interpolationFactor.bind(void 0, V), zoomStops: F.map(((G) => G[0])), evaluate: ({ zoom: G }, H) => mf({ stops: F, base: o.base }, e, G).evaluate(G, H) };
          }
          if (u) {
            const E = c === "exponential" ? { name: "exponential", base: o.base !== void 0 ? o.base : 1 } : null;
            return { kind: "camera", interpolationType: E, interpolationFactor: rn.interpolationFactor.bind(void 0, E), zoomStops: o.stops.map(((D) => D[0])), evaluate: ({ zoom: D }) => x(o, e, D, C, k) };
          }
          return { kind: "source", evaluate(E, D) {
            const F = D && D.properties ? D.properties[o.property] : void 0;
            return F === void 0 ? dl(o.default, e.default) : x(o, e, F, C, k);
          } };
        }
        function dl(o, e, i) {
          return o !== void 0 ? o : e !== void 0 ? e : i !== void 0 ? i : void 0;
        }
        function hd(o, e, i, u, c) {
          return dl(typeof i === c ? u[i] : void 0, o.default, e.default);
        }
        function zm(o, e, i) {
          if (kr(i) !== "number") return dl(o.default, e.default);
          const u = o.stops.length;
          if (u === 1 || i <= o.stops[0][0]) return o.stops[0][1];
          if (i >= o.stops[u - 1][0]) return o.stops[u - 1][1];
          const c = hu(o.stops.map(((m) => m[0])), i);
          return o.stops[c][1];
        }
        function mf(o, e, i) {
          const u = o.base !== void 0 ? o.base : 1;
          if (kr(i) !== "number") return dl(o.default, e.default);
          const c = o.stops.length;
          if (c === 1 || i <= o.stops[0][0]) return o.stops[0][1];
          if (i >= o.stops[c - 1][0]) return o.stops[c - 1][1];
          const m = hu(o.stops.map(((E) => E[0])), i), v = (function(E, D, F, V) {
            const G = V - F, H = E - F;
            return G === 0 ? 0 : D === 1 ? H / G : (Math.pow(D, H) - 1) / (Math.pow(D, G) - 1);
          })(i, u, o.stops[m][0], o.stops[m + 1][0]), x = o.stops[m][1], C = o.stops[m + 1][1], k = yo[e.type] || Am;
          return typeof x.evaluate == "function" ? { evaluate(...E) {
            const D = x.evaluate.apply(void 0, E), F = C.evaluate.apply(void 0, E);
            if (D !== void 0 && F !== void 0) return k(D, F, v, o.colorSpace);
          } } : k(x, C, v, o.colorSpace);
        }
        function Fm(o, e, i) {
          switch (e.type) {
            case "color":
              i = br.parse(i);
              break;
            case "formatted":
              i = Mi.fromString(i.toString());
              break;
            case "resolvedImage":
              i = Bn.fromString(i.toString());
              break;
            case "padding":
              i = dn.parse(i);
              break;
            case "colorArray":
              i = Oi.parse(i);
              break;
            case "numberArray":
              i = hn.parse(i);
              break;
            default:
              kr(i) === e.type || e.type === "enum" && e.values[i] || (i = void 0);
          }
          return dl(i, o.default, e.default);
        }
        oo.register(bs, { error: [{ kind: "error" }, [Bt], (o, [e]) => {
          throw new Hr(e.evaluate(o));
        }], typeof: [Bt, [ar], (o, [e]) => Gr(ei(e.evaluate(o)))], "to-rgba": [Tn(st, 4), [hi], (o, [e]) => {
          const [i, u, c, m] = e.evaluate(o).rgb;
          return [255 * i, 255 * u, 255 * c, m];
        }], rgb: [hi, [st, st, st], cf], rgba: [hi, [st, st, st, st], cf], has: { type: Xt, overloads: [[[Bt], (o, [e]) => df(e.evaluate(o), o.properties())], [[Bt, Jr], (o, [e, i]) => df(e.evaluate(o), i.evaluate(o))]] }, get: { type: ar, overloads: [[[Bt], (o, [e]) => cd(e.evaluate(o), o.properties())], [[Bt, Jr], (o, [e, i]) => cd(e.evaluate(o), i.evaluate(o))]] }, "feature-state": [ar, [Bt], (o, [e]) => cd(e.evaluate(o), o.featureState || {})], properties: [Jr, [], (o) => o.properties()], "geometry-type": [Bt, [], (o) => o.geometryType()], id: [ar, [], (o) => o.id()], zoom: [st, [], (o) => o.globals.zoom], "heatmap-density": [st, [], (o) => o.globals.heatmapDensity || 0], elevation: [st, [], (o) => o.globals.elevation || 0], "line-progress": [st, [], (o) => o.globals.lineProgress || 0], accumulated: [ar, [], (o) => o.globals.accumulated === void 0 ? null : o.globals.accumulated], "+": [st, Wa(st), (o, e) => {
          let i = 0;
          for (const u of e) i += u.evaluate(o);
          return i;
        }], "*": [st, Wa(st), (o, e) => {
          let i = 1;
          for (const u of e) i *= u.evaluate(o);
          return i;
        }], "-": { type: st, overloads: [[[st, st], (o, [e, i]) => e.evaluate(o) - i.evaluate(o)], [[st], (o, [e]) => -e.evaluate(o)]] }, "/": [st, [st, st], (o, [e, i]) => e.evaluate(o) / i.evaluate(o)], "%": [st, [st, st], (o, [e, i]) => e.evaluate(o) % i.evaluate(o)], ln2: [st, [], () => Math.LN2], pi: [st, [], () => Math.PI], e: [st, [], () => Math.E], "^": [st, [st, st], (o, [e, i]) => Math.pow(e.evaluate(o), i.evaluate(o))], sqrt: [st, [st], (o, [e]) => Math.sqrt(e.evaluate(o))], log10: [st, [st], (o, [e]) => Math.log(e.evaluate(o)) / Math.LN10], ln: [st, [st], (o, [e]) => Math.log(e.evaluate(o))], log2: [st, [st], (o, [e]) => Math.log(e.evaluate(o)) / Math.LN2], sin: [st, [st], (o, [e]) => Math.sin(e.evaluate(o))], cos: [st, [st], (o, [e]) => Math.cos(e.evaluate(o))], tan: [st, [st], (o, [e]) => Math.tan(e.evaluate(o))], asin: [st, [st], (o, [e]) => Math.asin(e.evaluate(o))], acos: [st, [st], (o, [e]) => Math.acos(e.evaluate(o))], atan: [st, [st], (o, [e]) => Math.atan(e.evaluate(o))], min: [st, Wa(st), (o, e) => Math.min(...e.map(((i) => i.evaluate(o))))], max: [st, Wa(st), (o, e) => Math.max(...e.map(((i) => i.evaluate(o))))], abs: [st, [st], (o, [e]) => Math.abs(e.evaluate(o))], round: [st, [st], (o, [e]) => {
          const i = e.evaluate(o);
          return i < 0 ? -Math.round(-i) : Math.round(i);
        }], floor: [st, [st], (o, [e]) => Math.floor(e.evaluate(o))], ceil: [st, [st], (o, [e]) => Math.ceil(e.evaluate(o))], "filter-==": [Xt, [Bt, ar], (o, [e, i]) => o.properties()[e.value] === i.value], "filter-id-==": [Xt, [ar], (o, [e]) => o.id() === e.value], "filter-type-==": [Xt, [Bt], (o, [e]) => o.geometryType() === e.value], "filter-<": [Xt, [Bt, ar], (o, [e, i]) => {
          const u = o.properties()[e.value], c = i.value;
          return typeof u == typeof c && u < c;
        }], "filter-id-<": [Xt, [ar], (o, [e]) => {
          const i = o.id(), u = e.value;
          return typeof i == typeof u && i < u;
        }], "filter->": [Xt, [Bt, ar], (o, [e, i]) => {
          const u = o.properties()[e.value], c = i.value;
          return typeof u == typeof c && u > c;
        }], "filter-id->": [Xt, [ar], (o, [e]) => {
          const i = o.id(), u = e.value;
          return typeof i == typeof u && i > u;
        }], "filter-<=": [Xt, [Bt, ar], (o, [e, i]) => {
          const u = o.properties()[e.value], c = i.value;
          return typeof u == typeof c && u <= c;
        }], "filter-id-<=": [Xt, [ar], (o, [e]) => {
          const i = o.id(), u = e.value;
          return typeof i == typeof u && i <= u;
        }], "filter->=": [Xt, [Bt, ar], (o, [e, i]) => {
          const u = o.properties()[e.value], c = i.value;
          return typeof u == typeof c && u >= c;
        }], "filter-id->=": [Xt, [ar], (o, [e]) => {
          const i = o.id(), u = e.value;
          return typeof i == typeof u && i >= u;
        }], "filter-has": [Xt, [ar], (o, [e]) => e.value in o.properties()], "filter-has-id": [Xt, [], (o) => o.id() !== null && o.id() !== void 0], "filter-type-in": [Xt, [Tn(Bt)], (o, [e]) => e.value.indexOf(o.geometryType()) >= 0], "filter-id-in": [Xt, [Tn(ar)], (o, [e]) => e.value.indexOf(o.id()) >= 0], "filter-in-small": [Xt, [Bt, Tn(ar)], (o, [e, i]) => i.value.indexOf(o.properties()[e.value]) >= 0], "filter-in-large": [Xt, [Bt, Tn(ar)], (o, [e, i]) => (function(u, c, m, v) {
          for (; m <= v; ) {
            const x = m + v >> 1;
            if (c[x] === u) return true;
            c[x] > u ? v = x - 1 : m = x + 1;
          }
          return false;
        })(o.properties()[e.value], i.value, 0, i.value.length - 1)], all: { type: Xt, overloads: [[[Xt, Xt], (o, [e, i]) => e.evaluate(o) && i.evaluate(o)], [Wa(Xt), (o, e) => {
          for (const i of e) if (!i.evaluate(o)) return false;
          return true;
        }]] }, any: { type: Xt, overloads: [[[Xt, Xt], (o, [e, i]) => e.evaluate(o) || i.evaluate(o)], [Wa(Xt), (o, e) => {
          for (const i of e) if (i.evaluate(o)) return true;
          return false;
        }]] }, "!": [Xt, [Xt], (o, [e]) => !e.evaluate(o)], "is-supported-script": [Xt, [Bt], (o, [e]) => {
          const i = o.globals && o.globals.isSupportedScript;
          return !i || i(e.evaluate(o));
        }], upcase: [Bt, [Bt], (o, [e]) => e.evaluate(o).toUpperCase()], downcase: [Bt, [Bt], (o, [e]) => e.evaluate(o).toLowerCase()], concat: [Bt, Wa(ar), (o, e) => e.map(((i) => ps(i.evaluate(o)))).join("")], "resolved-locale": [Bt, [Wn], (o, [e]) => e.evaluate(o).resolvedLocale()] });
        class Pu {
          constructor(e, i, u) {
            this.expression = e, this._warningHistory = {}, this._evaluator = new gr(), this._defaultValue = i ? (function(c) {
              if (c.type === "color" && Tu(c.default)) return new br(0, 0, 0, 0);
              switch (c.type) {
                case "color":
                  return br.parse(c.default) || null;
                case "padding":
                  return dn.parse(c.default) || null;
                case "numberArray":
                  return hn.parse(c.default) || null;
                case "colorArray":
                  return Oi.parse(c.default) || null;
                case "variableAnchorOffsetCollection":
                  return Pn.parse(c.default) || null;
                case "projectionDefinition":
                  return fn.parse(c.default) || null;
                default:
                  return c.default === void 0 ? null : c.default;
              }
            })(i) : null, this._enumValues = i && i.type === "enum" ? i.values : null, this._globalState = u;
          }
          evaluateWithoutErrorHandling(e, i, u, c, m, v) {
            return this._globalState && (e = Cs(e, this._globalState)), this._evaluator.globals = e, this._evaluator.feature = i, this._evaluator.featureState = u, this._evaluator.canonical = c, this._evaluator.availableImages = m || null, this._evaluator.formattedSection = v, this.expression.evaluate(this._evaluator);
          }
          evaluate(e, i, u, c, m, v) {
            this._globalState && (e = Cs(e, this._globalState)), this._evaluator.globals = e, this._evaluator.feature = i || null, this._evaluator.featureState = u || null, this._evaluator.canonical = c, this._evaluator.availableImages = m || null, this._evaluator.formattedSection = v || null;
            try {
              const x = this.expression.evaluate(this._evaluator);
              if (x == null || typeof x == "number" && x != x) return this._defaultValue;
              if (this._enumValues && !(x in this._enumValues)) throw new Hr(`Expected value to be one of ${Object.keys(this._enumValues).map(((C) => JSON.stringify(C))).join(", ")}, but found ${JSON.stringify(x)} instead.`);
              return x;
            } catch (x) {
              return this._warningHistory[x.message] || (this._warningHistory[x.message] = true, typeof console < "u" && console.warn(x.message)), this._defaultValue;
            }
          }
        }
        function Iu(o) {
          return Array.isArray(o) && o.length > 0 && typeof o[0] == "string" && o[0] in bs;
        }
        function Eu(o, e, i) {
          const u = new ms(bs, Cu, [], e ? (function(m) {
            const v = { color: hi, string: Bt, number: st, enum: Bt, boolean: Xt, formatted: Lo, padding: Bo, numberArray: mo, colorArray: kn, projectionDefinition: Sn, resolvedImage: Zn, variableAnchorOffsetCollection: Hn };
            return m.type === "array" ? Tn(v[m.value] || ar, m.length) : v[m.type];
          })(e) : void 0), c = u.parse(o, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return c ? hf(new Pu(c, e, i)) : xs(u.errors);
        }
        class Za {
          constructor(e, i, u) {
            this.kind = e, this._styleExpression = i, this.isStateDependent = e !== "constant" && !cl(i.expression), this.globalStateRefs = Au(i.expression), this._globalState = u;
          }
          evaluateWithoutErrorHandling(e, i, u, c, m, v) {
            return this._globalState && (e = Cs(e, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(e, i, u, c, m, v);
          }
          evaluate(e, i, u, c, m, v) {
            return this._globalState && (e = Cs(e, this._globalState)), this._styleExpression.evaluate(e, i, u, c, m, v);
          }
        }
        class Mu {
          constructor(e, i, u, c, m) {
            this.kind = e, this.zoomStops = u, this._styleExpression = i, this.isStateDependent = e !== "camera" && !cl(i.expression), this.globalStateRefs = Au(i.expression), this.interpolationType = c, this._globalState = m;
          }
          evaluateWithoutErrorHandling(e, i, u, c, m, v) {
            return this._globalState && (e = Cs(e, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(e, i, u, c, m, v);
          }
          evaluate(e, i, u, c, m, v) {
            return this._globalState && (e = Cs(e, this._globalState)), this._styleExpression.evaluate(e, i, u, c, m, v);
          }
          interpolationFactor(e, i, u) {
            return this.interpolationType ? rn.interpolationFactor(this.interpolationType, e, i, u) : 0;
          }
        }
        function gf(o, e, i) {
          const u = Eu(o, e, i);
          if (u.result === "error") return u;
          const c = u.value.expression, m = Su(c);
          if (!m && !ws(e)) return xs([new Ft("", "data expressions not supported")]);
          const v = ku(c, ["zoom"]);
          if (!v && !ff(e)) return xs([new Ft("", "zoom expressions not supported")]);
          const x = Ru(c);
          return x || v ? x instanceof Ft ? xs([x]) : x instanceof rn && !dd(e) ? xs([new Ft("", '"interpolate" expressions cannot be used with this property')]) : hf(x ? new Mu(m ? "camera" : "composite", u.value, x.labels, x instanceof rn ? x.interpolation : void 0, i) : new Za(m ? "constant" : "source", u.value, i)) : xs([new Ft("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class Du {
          constructor(e, i) {
            this._parameters = e, this._specification = i, at(this, pf(this._parameters, this._specification));
          }
          static deserialize(e) {
            return new Du(e._parameters, e._specification);
          }
          static serialize(e) {
            return { _parameters: e._parameters, _specification: e._specification };
          }
        }
        function Ru(o) {
          let e = null;
          if (o instanceof Mr) e = Ru(o.result);
          else if (o instanceof ys) {
            for (const i of o.args) if (e = Ru(i), e) break;
          } else (o instanceof vs || o instanceof rn) && o.input instanceof oo && o.input.name === "zoom" && (e = o);
          return e instanceof Ft || o.eachChild(((i) => {
            const u = Ru(i);
            u instanceof Ft ? e = u : !e && u ? e = new Ft("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && u && e !== u && (e = new Ft("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          })), e;
        }
        function Au(o, e = /* @__PURE__ */ new Set()) {
          return o instanceof ul && e.add(o.key), o.eachChild(((i) => {
            Au(i, e);
          })), e;
        }
        function Cs(o, e) {
          const { zoom: i, heatmapDensity: u, elevation: c, lineProgress: m, isSupportedScript: v, accumulated: x } = o ?? {};
          return { zoom: i, heatmapDensity: u, elevation: c, lineProgress: m, isSupportedScript: v, accumulated: x, globalState: e };
        }
        function zu(o) {
          if (o === true || o === false) return true;
          if (!Array.isArray(o) || o.length === 0) return false;
          switch (o[0]) {
            case "has":
              return o.length >= 2 && o[1] !== "$id" && o[1] !== "$type";
            case "in":
              return o.length >= 3 && (typeof o[1] != "string" || Array.isArray(o[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return o.length !== 3 || Array.isArray(o[1]) || Array.isArray(o[2]);
            case "any":
            case "all":
              for (const e of o.slice(1)) if (!zu(e) && typeof e != "boolean") return false;
              return true;
            default:
              return true;
          }
        }
        const vf = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
        function hl(o, e) {
          if (o == null) return { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() };
          zu(o) || (o = fl(o));
          const i = Eu(o, vf, e);
          if (i.result === "error") throw new Error(i.value.map(((u) => `${u.key}: ${u.message}`)).join(", "));
          return { filter: (u, c, m) => i.value.evaluate(u, c, {}, m), needGeometry: fd(o), getGlobalStateRefs: () => Au(i.value.expression) };
        }
        function Lm(o, e) {
          return o < e ? -1 : o > e ? 1 : 0;
        }
        function fd(o) {
          if (!Array.isArray(o)) return false;
          if (o[0] === "within" || o[0] === "distance") return true;
          for (let e = 1; e < o.length; e++) if (fd(o[e])) return true;
          return false;
        }
        function fl(o) {
          if (!o) return true;
          const e = o[0];
          return o.length <= 1 ? e !== "any" : e === "==" ? Fu(o[1], o[2], "==") : e === "!=" ? Lu(Fu(o[1], o[2], "==")) : e === "<" || e === ">" || e === "<=" || e === ">=" ? Fu(o[1], o[2], e) : e === "any" ? (i = o.slice(1), ["any"].concat(i.map(fl))) : e === "all" ? ["all"].concat(o.slice(1).map(fl)) : e === "none" ? ["all"].concat(o.slice(1).map(fl).map(Lu)) : e === "in" ? yf(o[1], o.slice(2)) : e === "!in" ? Lu(yf(o[1], o.slice(2))) : e === "has" ? _f(o[1]) : e !== "!has" || Lu(_f(o[1]));
          var i;
        }
        function Fu(o, e, i) {
          switch (o) {
            case "$type":
              return [`filter-type-${i}`, e];
            case "$id":
              return [`filter-id-${i}`, e];
            default:
              return [`filter-${i}`, o, e];
          }
        }
        function yf(o, e) {
          if (e.length === 0) return false;
          switch (o) {
            case "$type":
              return ["filter-type-in", ["literal", e]];
            case "$id":
              return ["filter-id-in", ["literal", e]];
            default:
              return e.length > 200 && !e.some(((i) => typeof i != typeof e[0])) ? ["filter-in-large", o, ["literal", e.sort(Lm)]] : ["filter-in-small", o, ["literal", e]];
          }
        }
        function _f(o) {
          switch (o) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", o];
          }
        }
        function Lu(o) {
          return ["!", o];
        }
        function pd(o) {
          const e = typeof o;
          if (e === "number" || e === "boolean" || e === "string" || o == null) return JSON.stringify(o);
          if (Array.isArray(o)) {
            let c = "[";
            for (const m of o) c += `${pd(m)},`;
            return `${c}]`;
          }
          const i = Object.keys(o).sort();
          let u = "{";
          for (let c = 0; c < i.length; c++) u += `${JSON.stringify(i[c])}:${pd(o[i[c]])},`;
          return `${u}}`;
        }
        function bf(o) {
          let e = "";
          for (const i of Fe) e += `/${pd(o[i])}`;
          return e;
        }
        function md(o) {
          const e = o.value;
          return e ? [new ye(o.key, e, "constants have been deprecated as of v8")] : [];
        }
        function fi(o) {
          return o instanceof Number || o instanceof String || o instanceof Boolean ? o.valueOf() : o;
        }
        function Xo(o) {
          if (Array.isArray(o)) return o.map(Xo);
          if (o instanceof Object && !(o instanceof Number || o instanceof String || o instanceof Boolean)) {
            const e = {};
            for (const i in o) e[i] = Xo(o[i]);
            return e;
          }
          return fi(o);
        }
        function Nn(o) {
          const e = o.key, i = o.value, u = o.valueSpec || {}, c = o.objectElementValidators || {}, m = o.style, v = o.styleSpec, x = o.validateSpec;
          let C = [];
          const k = kr(i);
          if (k !== "object") return [new ye(e, i, `object expected, ${k} found`)];
          for (const E in i) {
            const D = E.split(".")[0], F = go(u, D) || u["*"];
            let V;
            if (go(c, D)) V = c[D];
            else if (go(u, D)) V = x;
            else if (c["*"]) V = c["*"];
            else {
              if (!u["*"]) {
                C.push(new ye(e, i[E], `unknown property "${E}"`));
                continue;
              }
              V = x;
            }
            C = C.concat(V({ key: (e && `${e}.`) + E, value: i[E], valueSpec: F, style: m, styleSpec: v, object: i, objectKey: E, validateSpec: x }, i));
          }
          for (const E in u) c[E] || u[E].required && u[E].default === void 0 && i[E] === void 0 && C.push(new ye(e, i, `missing required property "${E}"`));
          return C;
        }
        function pl(o) {
          const e = o.value, i = o.valueSpec, u = o.style, c = o.styleSpec, m = o.key, v = o.arrayElementValidator || o.validateSpec;
          if (kr(e) !== "array") return [new ye(m, e, `array expected, ${kr(e)} found`)];
          if (i.length && e.length !== i.length) return [new ye(m, e, `array length ${i.length} expected, length ${e.length} found`)];
          if (i["min-length"] && e.length < i["min-length"]) return [new ye(m, e, `array length at least ${i["min-length"]} expected, length ${e.length} found`)];
          let x = { type: i.value, values: i.values };
          c.$version < 7 && (x.function = i.function), kr(i.value) === "object" && (x = i.value);
          let C = [];
          for (let k = 0; k < e.length; k++) C = C.concat(v({ array: e, arrayIndex: k, value: e[k], valueSpec: x, validateSpec: o.validateSpec, style: u, styleSpec: c, key: `${m}[${k}]` }));
          return C;
        }
        function Ha(o) {
          const e = o.key, i = o.value, u = o.valueSpec;
          let c = kr(i);
          return c === "number" && i != i && (c = "NaN"), c !== "number" ? [new ye(e, i, `number expected, ${c} found`)] : "minimum" in u && i < u.minimum ? [new ye(e, i, `${i} is less than the minimum value ${u.minimum}`)] : "maximum" in u && i > u.maximum ? [new ye(e, i, `${i} is greater than the maximum value ${u.maximum}`)] : [];
        }
        function xf(o) {
          const e = o.valueSpec, i = fi(o.value.type);
          let u, c, m, v = {};
          const x = i !== "categorical" && o.value.property === void 0, C = !x, k = kr(o.value.stops) === "array" && kr(o.value.stops[0]) === "array" && kr(o.value.stops[0][0]) === "object", E = Nn({ key: o.key, value: o.value, valueSpec: o.styleSpec.function, validateSpec: o.validateSpec, style: o.style, styleSpec: o.styleSpec, objectElementValidators: { stops: function(V) {
            if (i === "identity") return [new ye(V.key, V.value, 'identity function may not have a "stops" property')];
            let G = [];
            const H = V.value;
            return G = G.concat(pl({ key: V.key, value: H, valueSpec: V.valueSpec, validateSpec: V.validateSpec, style: V.style, styleSpec: V.styleSpec, arrayElementValidator: D })), kr(H) === "array" && H.length === 0 && G.push(new ye(V.key, H, "array must have at least one stop")), G;
          }, default: function(V) {
            return V.validateSpec({ key: V.key, value: V.value, valueSpec: e, validateSpec: V.validateSpec, style: V.style, styleSpec: V.styleSpec });
          } } });
          return i === "identity" && x && E.push(new ye(o.key, o.value, 'missing required property "property"')), i === "identity" || o.value.stops || E.push(new ye(o.key, o.value, 'missing required property "stops"')), i === "exponential" && o.valueSpec.expression && !dd(o.valueSpec) && E.push(new ye(o.key, o.value, "exponential functions not supported")), o.styleSpec.$version >= 8 && (C && !ws(o.valueSpec) ? E.push(new ye(o.key, o.value, "property functions not supported")) : x && !ff(o.valueSpec) && E.push(new ye(o.key, o.value, "zoom functions not supported"))), i !== "categorical" && !k || o.value.property !== void 0 || E.push(new ye(o.key, o.value, '"property" property is required')), E;
          function D(V) {
            let G = [];
            const H = V.value, Y = V.key;
            if (kr(H) !== "array") return [new ye(Y, H, `array expected, ${kr(H)} found`)];
            if (H.length !== 2) return [new ye(Y, H, `array length 2 expected, length ${H.length} found`)];
            if (k) {
              if (kr(H[0]) !== "object") return [new ye(Y, H, `object expected, ${kr(H[0])} found`)];
              if (H[0].zoom === void 0) return [new ye(Y, H, "object stop key must have zoom")];
              if (H[0].value === void 0) return [new ye(Y, H, "object stop key must have value")];
              if (m && m > fi(H[0].zoom)) return [new ye(Y, H[0].zoom, "stop zoom values must appear in ascending order")];
              fi(H[0].zoom) !== m && (m = fi(H[0].zoom), c = void 0, v = {}), G = G.concat(Nn({ key: `${Y}[0]`, value: H[0], valueSpec: { zoom: {} }, validateSpec: V.validateSpec, style: V.style, styleSpec: V.styleSpec, objectElementValidators: { zoom: Ha, value: F } }));
            } else G = G.concat(F({ key: `${Y}[0]`, value: H[0], validateSpec: V.validateSpec, style: V.style, styleSpec: V.styleSpec }, H));
            return Iu(Xo(H[1])) ? G.concat([new ye(`${Y}[1]`, H[1], "expressions are not allowed in function stops.")]) : G.concat(V.validateSpec({ key: `${Y}[1]`, value: H[1], valueSpec: e, validateSpec: V.validateSpec, style: V.style, styleSpec: V.styleSpec }));
          }
          function F(V, G) {
            const H = kr(V.value), Y = fi(V.value), ie = V.value !== null ? V.value : G;
            if (u) {
              if (H !== u) return [new ye(V.key, ie, `${H} stop domain type must match previous stop domain type ${u}`)];
            } else u = H;
            if (H !== "number" && H !== "string" && H !== "boolean") return [new ye(V.key, ie, "stop domain value must be a number, string, or boolean")];
            if (H !== "number" && i !== "categorical") {
              let we = `number expected, ${H} found`;
              return ws(e) && i === void 0 && (we += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ye(V.key, ie, we)];
            }
            return i !== "categorical" || H !== "number" || isFinite(Y) && Math.floor(Y) === Y ? i !== "categorical" && H === "number" && c !== void 0 && Y < c ? [new ye(V.key, ie, "stop domain values must appear in ascending order")] : (c = Y, i === "categorical" && Y in v ? [new ye(V.key, ie, "stop domain values must be unique")] : (v[Y] = true, [])) : [new ye(V.key, ie, `integer expected, found ${Y}`)];
          }
        }
        function Ss(o) {
          const e = (o.expressionContext === "property" ? gf : Eu)(Xo(o.value), o.valueSpec);
          if (e.result === "error") return e.value.map(((u) => new ye(`${o.key}${u.key}`, o.value, u.message)));
          const i = e.value.expression || e.value._styleExpression.expression;
          if (o.expressionContext === "property" && o.propertyKey === "text-font" && !i.outputDefined()) return [new ye(o.key, o.value, `Invalid data expression for "${o.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (o.expressionContext === "property" && o.propertyType === "layout" && !cl(i)) return [new ye(o.key, o.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (o.expressionContext === "filter" && !cl(i)) return [new ye(o.key, o.value, '"feature-state" data expressions are not supported with filters.')];
          if (o.expressionContext && o.expressionContext.indexOf("cluster") === 0) {
            if (!ku(i, ["zoom", "feature-state"])) return [new ye(o.key, o.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (o.expressionContext === "cluster-initial" && !Su(i)) return [new ye(o.key, o.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function gd(o) {
          const e = o.key, i = o.value, u = kr(i);
          return u !== "string" ? [new ye(e, i, `color expected, ${u} found`)] : br.parse(String(i)) ? [] : [new ye(e, i, `color expected, "${i}" found`)];
        }
        function ml(o) {
          const e = o.key, i = o.value, u = o.valueSpec, c = [];
          return Array.isArray(u.values) ? u.values.indexOf(fi(i)) === -1 && c.push(new ye(e, i, `expected one of [${u.values.join(", ")}], ${JSON.stringify(i)} found`)) : Object.keys(u.values).indexOf(fi(i)) === -1 && c.push(new ye(e, i, `expected one of [${Object.keys(u.values).join(", ")}], ${JSON.stringify(i)} found`)), c;
        }
        function vd(o) {
          return zu(Xo(o.value)) ? Ss(at({}, o, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : wf(o);
        }
        function wf(o) {
          const e = o.value, i = o.key;
          if (kr(e) !== "array") return [new ye(i, e, `array expected, ${kr(e)} found`)];
          const u = o.styleSpec;
          let c, m = [];
          if (e.length < 1) return [new ye(i, e, "filter array must have at least 1 element")];
          switch (m = m.concat(ml({ key: `${i}[0]`, value: e[0], valueSpec: u.filter_operator, style: o.style, styleSpec: o.styleSpec })), fi(e[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              e.length >= 2 && fi(e[1]) === "$type" && m.push(new ye(i, e, `"$type" cannot be use with operator "${e[0]}"`));
            case "==":
            case "!=":
              e.length !== 3 && m.push(new ye(i, e, `filter array for operator "${e[0]}" must have 3 elements`));
            case "in":
            case "!in":
              e.length >= 2 && (c = kr(e[1]), c !== "string" && m.push(new ye(`${i}[1]`, e[1], `string expected, ${c} found`)));
              for (let v = 2; v < e.length; v++) c = kr(e[v]), fi(e[1]) === "$type" ? m = m.concat(ml({ key: `${i}[${v}]`, value: e[v], valueSpec: u.geometry_type, style: o.style, styleSpec: o.styleSpec })) : c !== "string" && c !== "number" && c !== "boolean" && m.push(new ye(`${i}[${v}]`, e[v], `string, number, or boolean expected, ${c} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let v = 1; v < e.length; v++) m = m.concat(wf({ key: `${i}[${v}]`, value: e[v], style: o.style, styleSpec: o.styleSpec }));
              break;
            case "has":
            case "!has":
              c = kr(e[1]), e.length !== 2 ? m.push(new ye(i, e, `filter array for "${e[0]}" operator must have 2 elements`)) : c !== "string" && m.push(new ye(`${i}[1]`, e[1], `string expected, ${c} found`));
          }
          return m;
        }
        function yd(o, e) {
          const i = o.key, u = o.validateSpec, c = o.style, m = o.styleSpec, v = o.value, x = o.objectKey, C = m[`${e}_${o.layerType}`];
          if (!C) return [];
          const k = x.match(/^(.*)-transition$/);
          if (e === "paint" && k && C[k[1]] && C[k[1]].transition) return u({ key: i, value: v, valueSpec: m.transition, style: c, styleSpec: m });
          const E = o.valueSpec || C[x];
          if (!E) return [new ye(i, v, `unknown property "${x}"`)];
          let D;
          if (kr(v) === "string" && ws(E) && !E.tokens && (D = /^{([^}]+)}$/.exec(v))) return [new ye(i, v, `"${x}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(D[1])} }\`.`)];
          const F = [];
          return o.layerType === "symbol" && x === "text-font" && Tu(Xo(v)) && fi(v.type) === "identity" && F.push(new ye(i, v, '"text-font" does not support identity functions')), F.concat(u({ key: o.key, value: v, valueSpec: E, style: c, styleSpec: m, expressionContext: "property", propertyType: e, propertyKey: x }));
        }
        function _d(o) {
          return yd(o, "paint");
        }
        function gl(o) {
          return yd(o, "layout");
        }
        function Cf(o) {
          let e = [];
          const i = o.value, u = o.key, c = o.style, m = o.styleSpec;
          if (kr(i) !== "object") return [new ye(u, i, `object expected, ${kr(i)} found`)];
          i.type || i.ref || e.push(new ye(u, i, 'either "type" or "ref" is required'));
          let v = fi(i.type);
          const x = fi(i.ref);
          if (i.id) {
            const C = fi(i.id);
            for (let k = 0; k < o.arrayIndex; k++) {
              const E = c.layers[k];
              fi(E.id) === C && e.push(new ye(u, i.id, `duplicate layer id "${i.id}", previously used at line ${E.id.__line__}`));
            }
          }
          if ("ref" in i) {
            let C;
            ["type", "source", "source-layer", "filter", "layout"].forEach(((k) => {
              k in i && e.push(new ye(u, i[k], `"${k}" is prohibited for ref layers`));
            })), c.layers.forEach(((k) => {
              fi(k.id) === x && (C = k);
            })), C ? C.ref ? e.push(new ye(u, i.ref, "ref cannot reference another ref layer")) : v = fi(C.type) : e.push(new ye(u, i.ref, `ref layer "${x}" not found`));
          } else if (v !== "background") if (i.source) {
            const C = c.sources && c.sources[i.source], k = C && fi(C.type);
            C ? k === "vector" && v === "raster" ? e.push(new ye(u, i.source, `layer "${i.id}" requires a raster source`)) : k !== "raster-dem" && v === "hillshade" || k !== "raster-dem" && v === "color-relief" ? e.push(new ye(u, i.source, `layer "${i.id}" requires a raster-dem source`)) : k === "raster" && v !== "raster" ? e.push(new ye(u, i.source, `layer "${i.id}" requires a vector source`)) : k !== "vector" || i["source-layer"] ? k === "raster-dem" && v !== "hillshade" && v !== "color-relief" ? e.push(new ye(u, i.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : v !== "line" || !i.paint || !i.paint["line-gradient"] || k === "geojson" && C.lineMetrics || e.push(new ye(u, i, `layer "${i.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new ye(u, i, `layer "${i.id}" must specify a "source-layer"`)) : e.push(new ye(u, i.source, `source "${i.source}" not found`));
          } else e.push(new ye(u, i, 'missing required property "source"'));
          return e = e.concat(Nn({ key: u, value: i, valueSpec: m.layer, style: o.style, styleSpec: o.styleSpec, validateSpec: o.validateSpec, objectElementValidators: { "*": () => [], type: () => o.validateSpec({ key: `${u}.type`, value: i.type, valueSpec: m.layer.type, style: o.style, styleSpec: o.styleSpec, validateSpec: o.validateSpec, object: i, objectKey: "type" }), filter: vd, layout: (C) => Nn({ layer: i, key: C.key, value: C.value, style: C.style, styleSpec: C.styleSpec, validateSpec: C.validateSpec, objectElementValidators: { "*": (k) => gl(at({ layerType: v }, k)) } }), paint: (C) => Nn({ layer: i, key: C.key, value: C.value, style: C.style, styleSpec: C.styleSpec, validateSpec: C.validateSpec, objectElementValidators: { "*": (k) => _d(at({ layerType: v }, k)) } }) } })), e;
        }
        function wa(o) {
          const e = o.value, i = o.key, u = kr(e);
          return u !== "string" ? [new ye(i, e, `string expected, ${u} found`)] : [];
        }
        const bd = { promoteId: function({ key: o, value: e }) {
          if (kr(e) === "string") return wa({ key: o, value: e });
          {
            const i = [];
            for (const u in e) i.push(...wa({ key: `${o}.${u}`, value: e[u] }));
            return i;
          }
        } };
        function Sf(o) {
          const e = o.value, i = o.key, u = o.styleSpec, c = o.style, m = o.validateSpec;
          if (!e.type) return [new ye(i, e, '"type" is required')];
          const v = fi(e.type);
          let x;
          switch (v) {
            case "vector":
            case "raster":
              return x = Nn({ key: i, value: e, valueSpec: u[`source_${v.replace("-", "_")}`], style: o.style, styleSpec: u, objectElementValidators: bd, validateSpec: m }), x;
            case "raster-dem":
              return x = (function(C) {
                var k;
                const E = (k = C.sourceName) !== null && k !== void 0 ? k : "", D = C.value, F = C.styleSpec, V = F.source_raster_dem, G = C.style;
                let H = [];
                const Y = kr(D);
                if (D === void 0) return H;
                if (Y !== "object") return H.push(new ye("source_raster_dem", D, `object expected, ${Y} found`)), H;
                const ie = fi(D.encoding) === "custom", we = ["redFactor", "greenFactor", "blueFactor", "baseShift"], ce = C.value.encoding ? `"${C.value.encoding}"` : "Default";
                for (const pe in D) !ie && we.includes(pe) ? H.push(new ye(pe, D[pe], `In "${E}": "${pe}" is only valid when "encoding" is set to "custom". ${ce} encoding found`)) : V[pe] ? H = H.concat(C.validateSpec({ key: pe, value: D[pe], valueSpec: V[pe], validateSpec: C.validateSpec, style: G, styleSpec: F })) : H.push(new ye(pe, D[pe], `unknown property "${pe}"`));
                return H;
              })({ sourceName: i, value: e, style: o.style, styleSpec: u, validateSpec: m }), x;
            case "geojson":
              if (x = Nn({ key: i, value: e, valueSpec: u.source_geojson, style: c, styleSpec: u, validateSpec: m, objectElementValidators: bd }), e.cluster) for (const C in e.clusterProperties) {
                const [k, E] = e.clusterProperties[C], D = typeof k == "string" ? [k, ["accumulated"], ["get", C]] : k;
                x.push(...Ss({ key: `${i}.${C}.map`, value: E, expressionContext: "cluster-map" })), x.push(...Ss({ key: `${i}.${C}.reduce`, value: D, expressionContext: "cluster-reduce" }));
              }
              return x;
            case "video":
              return Nn({ key: i, value: e, valueSpec: u.source_video, style: c, validateSpec: m, styleSpec: u });
            case "image":
              return Nn({ key: i, value: e, valueSpec: u.source_image, style: c, validateSpec: m, styleSpec: u });
            case "canvas":
              return [new ye(i, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return ml({ key: `${i}.type`, value: e.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
          }
        }
        function xd(o) {
          const e = o.value, i = o.styleSpec, u = i.light, c = o.style;
          let m = [];
          const v = kr(e);
          if (e === void 0) return m;
          if (v !== "object") return m = m.concat([new ye("light", e, `object expected, ${v} found`)]), m;
          for (const x in e) {
            const C = x.match(/^(.*)-transition$/);
            m = m.concat(C && u[C[1]] && u[C[1]].transition ? o.validateSpec({ key: x, value: e[x], valueSpec: i.transition, validateSpec: o.validateSpec, style: c, styleSpec: i }) : u[x] ? o.validateSpec({ key: x, value: e[x], valueSpec: u[x], validateSpec: o.validateSpec, style: c, styleSpec: i }) : [new ye(x, e[x], `unknown property "${x}"`)]);
          }
          return m;
        }
        function wd(o) {
          const e = o.value, i = o.styleSpec, u = i.sky, c = o.style, m = kr(e);
          if (e === void 0) return [];
          if (m !== "object") return [new ye("sky", e, `object expected, ${m} found`)];
          let v = [];
          for (const x in e) v = v.concat(u[x] ? o.validateSpec({ key: x, value: e[x], valueSpec: u[x], style: c, styleSpec: i }) : [new ye(x, e[x], `unknown property "${x}"`)]);
          return v;
        }
        function ks(o) {
          const e = o.value, i = o.styleSpec, u = i.terrain, c = o.style;
          let m = [];
          const v = kr(e);
          if (e === void 0) return m;
          if (v !== "object") return m = m.concat([new ye("terrain", e, `object expected, ${v} found`)]), m;
          for (const x in e) m = m.concat(u[x] ? o.validateSpec({ key: x, value: e[x], valueSpec: u[x], validateSpec: o.validateSpec, style: c, styleSpec: i }) : [new ye(x, e[x], `unknown property "${x}"`)]);
          return m;
        }
        function kf(o) {
          let e = [];
          const i = o.value, u = o.key;
          if (Array.isArray(i)) {
            const c = [], m = [];
            for (const v in i) i[v].id && c.includes(i[v].id) && e.push(new ye(u, i, `all the sprites' ids must be unique, but ${i[v].id} is duplicated`)), c.push(i[v].id), i[v].url && m.includes(i[v].url) && e.push(new ye(u, i, `all the sprites' URLs must be unique, but ${i[v].url} is duplicated`)), m.push(i[v].url), e = e.concat(Nn({ key: `${u}[${v}]`, value: i[v], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: o.validateSpec }));
            return e;
          }
          return wa({ key: u, value: i });
        }
        function Tf(o) {
          return e = o.value, e && e.constructor === Object ? [] : [new ye(o.key, o.value, `object expected, ${kr(o.value)} found`)];
          var e;
        }
        const Pf = { "*": () => [], array: pl, boolean: function(o) {
          const e = o.value, i = o.key, u = kr(e);
          return u !== "boolean" ? [new ye(i, e, `boolean expected, ${u} found`)] : [];
        }, number: Ha, color: gd, constants: md, enum: ml, filter: vd, function: xf, layer: Cf, object: Nn, source: Sf, light: xd, sky: wd, terrain: ks, projection: function(o) {
          const e = o.value, i = o.styleSpec, u = i.projection, c = o.style, m = kr(e);
          if (e === void 0) return [];
          if (m !== "object") return [new ye("projection", e, `object expected, ${m} found`)];
          let v = [];
          for (const x in e) v = v.concat(u[x] ? o.validateSpec({ key: x, value: e[x], valueSpec: u[x], style: c, styleSpec: i }) : [new ye(x, e[x], `unknown property "${x}"`)]);
          return v;
        }, projectionDefinition: function(o) {
          const e = o.key;
          let i = o.value;
          i = i instanceof String ? i.valueOf() : i;
          const u = kr(i);
          return u !== "array" || (function(c) {
            return Array.isArray(c) && c.length === 3 && typeof c[0] == "string" && typeof c[1] == "string" && typeof c[2] == "number";
          })(i) || (function(c) {
            return !!["interpolate", "step", "literal"].includes(c[0]);
          })(i) ? ["array", "string"].includes(u) ? [] : [new ye(e, i, `projection expected, invalid type "${u}" found`)] : [new ye(e, i, `projection expected, invalid array ${JSON.stringify(i)} found`)];
        }, string: wa, formatted: function(o) {
          return wa(o).length === 0 ? [] : Ss(o);
        }, resolvedImage: function(o) {
          return wa(o).length === 0 ? [] : Ss(o);
        }, padding: function(o) {
          const e = o.key, i = o.value;
          if (kr(i) === "array") {
            if (i.length < 1 || i.length > 4) return [new ye(e, i, `padding requires 1 to 4 values; ${i.length} values found`)];
            const u = { type: "number" };
            let c = [];
            for (let m = 0; m < i.length; m++) c = c.concat(o.validateSpec({ key: `${e}[${m}]`, value: i[m], validateSpec: o.validateSpec, valueSpec: u }));
            return c;
          }
          return Ha({ key: e, value: i, valueSpec: {} });
        }, numberArray: function(o) {
          const e = o.key, i = o.value;
          if (kr(i) === "array") {
            const u = { type: "number" };
            if (i.length < 1) return [new ye(e, i, "array length at least 1 expected, length 0 found")];
            let c = [];
            for (let m = 0; m < i.length; m++) c = c.concat(o.validateSpec({ key: `${e}[${m}]`, value: i[m], validateSpec: o.validateSpec, valueSpec: u }));
            return c;
          }
          return Ha({ key: e, value: i, valueSpec: {} });
        }, colorArray: function(o) {
          const e = o.key, i = o.value;
          if (kr(i) === "array") {
            if (i.length < 1) return [new ye(e, i, "array length at least 1 expected, length 0 found")];
            let u = [];
            for (let c = 0; c < i.length; c++) u = u.concat(gd({ key: `${e}[${c}]`, value: i[c] }));
            return u;
          }
          return gd({ key: e, value: i });
        }, variableAnchorOffsetCollection: function(o) {
          const e = o.key, i = o.value, u = kr(i), c = o.styleSpec;
          if (u !== "array" || i.length < 1 || i.length % 2 != 0) return [new ye(e, i, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let m = [];
          for (let v = 0; v < i.length; v += 2) m = m.concat(ml({ key: `${e}[${v}]`, value: i[v], valueSpec: c.layout_symbol["text-anchor"] })), m = m.concat(pl({ key: `${e}[${v + 1}]`, value: i[v + 1], valueSpec: { length: 2, value: "number" }, validateSpec: o.validateSpec, style: o.style, styleSpec: c }));
          return m;
        }, sprite: kf, state: Tf };
        function Bu(o) {
          const e = o.value, i = o.valueSpec, u = o.styleSpec;
          return o.validateSpec = Bu, i.expression && Tu(fi(e)) ? xf(o) : i.expression && Iu(Xo(e)) ? Ss(o) : i.type && Pf[i.type] ? Pf[i.type](o) : Nn(at({}, o, { valueSpec: i.type ? u[i.type] : i }));
        }
        function If(o) {
          const e = o.value, i = o.key, u = wa(o);
          return u.length || (e.indexOf("{fontstack}") === -1 && u.push(new ye(i, e, '"glyphs" url must include a "{fontstack}" token')), e.indexOf("{range}") === -1 && u.push(new ye(i, e, '"glyphs" url must include a "{range}" token'))), u;
        }
        function ao(o, e = se) {
          let i = [];
          return i = i.concat(Bu({ key: "", value: o, valueSpec: e.$root, styleSpec: e, style: o, validateSpec: Bu, objectElementValidators: { glyphs: If, "*": () => [] } })), o.constants && (i = i.concat(md({ key: "constants", value: o.constants }))), Ts(i);
        }
        function In(o) {
          return function(e) {
            return o(Object.assign({}, e, { validateSpec: Bu }));
          };
        }
        function Ts(o) {
          return [].concat(o).sort(((e, i) => e.line - i.line));
        }
        function _i(o) {
          return function(...e) {
            return Ts(o.apply(this, e));
          };
        }
        ao.source = _i(In(Sf)), ao.sprite = _i(In(kf)), ao.glyphs = _i(In(If)), ao.light = _i(In(xd)), ao.sky = _i(In(wd)), ao.terrain = _i(In(ks)), ao.state = _i(In(Tf)), ao.layer = _i(In(Cf)), ao.filter = _i(In(vd)), ao.paintProperty = _i(In(_d)), ao.layoutProperty = _i(In(gl));
        const vl = se, Xa = ao, Bm = Xa.light, Om = Xa.sky, yl = Xa.paintProperty, Ef = Xa.layoutProperty;
        function Ou(o, e) {
          let i = false;
          if (e && e.length) for (const u of e) o.fire(new _e(new Error(u.message))), i = true;
          return i;
        }
        class _l {
          constructor(e, i, u) {
            const c = this.cells = [];
            if (e instanceof ArrayBuffer) {
              this.arrayBuffer = e;
              const v = new Int32Array(this.arrayBuffer);
              e = v[0], this.d = (i = v[1]) + 2 * (u = v[2]);
              for (let C = 0; C < this.d * this.d; C++) {
                const k = v[3 + C], E = v[3 + C + 1];
                c.push(k === E ? null : v.subarray(k, E));
              }
              const x = v[3 + c.length + 1];
              this.keys = v.subarray(v[3 + c.length], x), this.bboxes = v.subarray(x), this.insert = this._insertReadonly;
            } else {
              this.d = i + 2 * u;
              for (let v = 0; v < this.d * this.d; v++) c.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = i, this.extent = e, this.padding = u, this.scale = i / e, this.uid = 0;
            const m = u / i * e;
            this.min = -m, this.max = e + m;
          }
          insert(e, i, u, c, m) {
            this._forEachCell(i, u, c, m, this._insertCell, this.uid++, void 0, void 0), this.keys.push(e), this.bboxes.push(i), this.bboxes.push(u), this.bboxes.push(c), this.bboxes.push(m);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(e, i, u, c, m, v) {
            this.cells[m].push(v);
          }
          query(e, i, u, c, m) {
            const v = this.min, x = this.max;
            if (e <= v && i <= v && x <= u && x <= c && !m) return Array.prototype.slice.call(this.keys);
            {
              const C = [];
              return this._forEachCell(e, i, u, c, this._queryCell, C, {}, m), C;
            }
          }
          _queryCell(e, i, u, c, m, v, x, C) {
            const k = this.cells[m];
            if (k !== null) {
              const E = this.keys, D = this.bboxes;
              for (let F = 0; F < k.length; F++) {
                const V = k[F];
                if (x[V] === void 0) {
                  const G = 4 * V;
                  (C ? C(D[G + 0], D[G + 1], D[G + 2], D[G + 3]) : e <= D[G + 2] && i <= D[G + 3] && u >= D[G + 0] && c >= D[G + 1]) ? (x[V] = true, v.push(E[V])) : x[V] = false;
                }
              }
            }
          }
          _forEachCell(e, i, u, c, m, v, x, C) {
            const k = this._convertToCellCoord(e), E = this._convertToCellCoord(i), D = this._convertToCellCoord(u), F = this._convertToCellCoord(c);
            for (let V = k; V <= D; V++) for (let G = E; G <= F; G++) {
              const H = this.d * G + V;
              if ((!C || C(this._convertFromCellCoord(V), this._convertFromCellCoord(G), this._convertFromCellCoord(V + 1), this._convertFromCellCoord(G + 1))) && m.call(this, e, i, u, c, H, v, x, C)) return;
            }
          }
          _convertFromCellCoord(e) {
            return (e - this.padding) / this.scale;
          }
          _convertToCellCoord(e) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(e * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const e = this.cells, i = 3 + this.cells.length + 1 + 1;
            let u = 0;
            for (let v = 0; v < this.cells.length; v++) u += this.cells[v].length;
            const c = new Int32Array(i + u + this.keys.length + this.bboxes.length);
            c[0] = this.extent, c[1] = this.n, c[2] = this.padding;
            let m = i;
            for (let v = 0; v < e.length; v++) {
              const x = e[v];
              c[3 + v] = m, c.set(x, m), m += x.length;
            }
            return c[3 + e.length] = m, c.set(this.keys, m), m += this.keys.length, c[3 + e.length + 1] = m, c.set(this.bboxes, m), m += this.bboxes.length, c.buffer;
          }
          static serialize(e, i) {
            const u = e.toArrayBuffer();
            return i && i.push(u), { buffer: u };
          }
          static deserialize(e) {
            return new _l(e.buffer);
          }
        }
        const bo = {};
        function Lt(o, e, i = {}) {
          if (bo[o]) throw new Error(`${o} is already registered.`);
          Object.defineProperty(e, "_classRegistryKey", { value: o, writeable: false }), bo[o] = { klass: e, omit: i.omit || [], shallow: i.shallow || [] };
        }
        Lt("Object", Object), Lt("Set", Set), Lt("TransferableGridIndex", _l), Lt("Color", br), Lt("Error", Error), Lt("AJAXError", Bi), Lt("ResolvedImage", Bn), Lt("StylePropertyFunction", Du), Lt("StyleExpression", Pu, { omit: ["_evaluator"] }), Lt("ZoomDependentExpression", Mu), Lt("ZoomConstantExpression", Za), Lt("CompoundExpression", oo, { omit: ["_evaluate"] });
        for (const o in bs) bs[o]._classRegistryKey || Lt(`Expression_${o}`, bs[o]);
        function Ps(o) {
          return o && typeof ArrayBuffer < "u" && (o instanceof ArrayBuffer || o.constructor && o.constructor.name === "ArrayBuffer");
        }
        function Cd(o) {
          return o.$name || o.constructor._classRegistryKey;
        }
        function Mf(o) {
          return !(function(e) {
            if (e === null || typeof e != "object") return false;
            const i = Cd(e);
            return !(!i || i === "Object");
          })(o) && (o == null || typeof o == "boolean" || typeof o == "number" || typeof o == "string" || o instanceof Boolean || o instanceof Number || o instanceof String || o instanceof Date || o instanceof RegExp || o instanceof Blob || o instanceof Error || Ps(o) || Be(o) || ArrayBuffer.isView(o) || o instanceof ImageData);
        }
        function bl(o, e) {
          if (Mf(o)) return (Ps(o) || Be(o)) && e && e.push(o), ArrayBuffer.isView(o) && e && e.push(o.buffer), o instanceof ImageData && e && e.push(o.data.buffer), o;
          if (Array.isArray(o)) {
            const m = [];
            for (const v of o) m.push(bl(v, e));
            return m;
          }
          if (typeof o != "object") throw new Error("can't serialize object of type " + typeof o);
          const i = Cd(o);
          if (!i) throw new Error(`can't serialize object of unregistered class ${o.constructor.name}`);
          if (!bo[i]) throw new Error(`${i} is not registered.`);
          const { klass: u } = bo[i], c = u.serialize ? u.serialize(o, e) : {};
          if (u.serialize) {
            if (e && c === e[e.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const m in o) {
              if (!o.hasOwnProperty(m) || bo[i].omit.indexOf(m) >= 0) continue;
              const v = o[m];
              c[m] = bo[i].shallow.indexOf(m) >= 0 ? v : bl(v, e);
            }
            o instanceof Error && (c.message = o.message);
          }
          if (c.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return i !== "Object" && (c.$name = i), c;
        }
        function Yo(o) {
          if (Mf(o)) return o;
          if (Array.isArray(o)) return o.map(Yo);
          if (typeof o != "object") throw new Error("can't deserialize object of type " + typeof o);
          const e = Cd(o) || "Object";
          if (!bo[e]) throw new Error(`can't deserialize unregistered class ${e}`);
          const { klass: i } = bo[e];
          if (!i) throw new Error(`can't deserialize unregistered class ${e}`);
          if (i.deserialize) return i.deserialize(o);
          const u = Object.create(i.prototype);
          for (const c of Object.keys(o)) {
            if (c === "$name") continue;
            const m = o[c];
            u[c] = bo[e].shallow.indexOf(c) >= 0 ? m : Yo(m);
          }
          return u;
        }
        class Sd {
          constructor() {
            this.first = true;
          }
          update(e, i) {
            const u = Math.floor(e);
            return this.first ? (this.first = false, this.lastIntegerZoom = u, this.lastIntegerZoomTime = 0, this.lastZoom = e, this.lastFloorZoom = u, true) : (this.lastFloorZoom > u ? (this.lastIntegerZoom = u + 1, this.lastIntegerZoomTime = i) : this.lastFloorZoom < u && (this.lastIntegerZoom = u, this.lastIntegerZoomTime = i), e !== this.lastZoom && (this.lastZoom = e, this.lastFloorZoom = u, true));
          }
        }
        function $m(o) {
          return /[\u02EA\u02EB\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u303F\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FD-\u30FF\u3105-\u312F\u31A0-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE4F\uFF00-\uFFEF]|\uD81B[\uDFE0-\uDFE4\uDFF0-\uDFF6]|[\uD81C-\uD822\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD83C\uDE00|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(o));
        }
        function Is(o) {
          return /[\u02EA\u02EB\u1100-\u11FF\u1400-\u167F\u18B0-\u18F5\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u3007\u3012\u3013\u3020-\u302F\u3031-\u303F\u3041-\u3096\u309D-\u30FB\u30FD-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFE10-\uFE1F\uFE30-\uFE48\uFE50-\uFE57\uFE5F-\uFE62\uFE67-\uFE6F\uFF00-\uFF07\uFF0A-\uFF0C\uFF0E-\uFF19\uFF1F-\uFF3A\uFF3C\uFF3E\uFF40-\uFF5A\uFFE0-\uFFE2\uFFE4-\uFFE7]|\uD806[\uDEB0-\uDEBF]|\uD81B[\uDFE0-\uDFE4\uDFF0-\uDFF6]|[\uD81C-\uD822\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD83C\uDE00|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(o));
        }
        function kd(o) {
          for (const e of o) if (Is(e.charCodeAt(0))) return true;
          return false;
        }
        function Td(o) {
          for (const e of o) if (!Rf(e.charCodeAt(0))) return false;
          return true;
        }
        function xl(o) {
          const e = o.map(((i) => {
            try {
              return new RegExp(`\\p{sc=${i}}`, "u").source;
            } catch {
              return null;
            }
          })).filter(((i) => i));
          return new RegExp(e.join("|"), "u");
        }
        const Df = xl(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
        function Rf(o) {
          return !Df.test(String.fromCodePoint(o));
        }
        function Pd(o) {
          return !(Is(o) || (e = o, /[\xA7\xA9\xAE\xB1\xBC-\xBE\xD7\xF7\u2016\u2020\u2021\u2030\u2031\u203B\u203C\u2042\u2047-\u2049\u2051\u2100-\u218F\u221E\u2234\u2235\u2300-\u2307\u230C-\u231F\u2324-\u2328\u232B\u237D-\u239A\u23BE-\u23CD\u23CF\u23D1-\u23DB\u23E2-\u2422\u2424-\u24FF\u25A0-\u2619\u2620-\u2767\u2776-\u2793\u2B12-\u2B2F\u2B50-\u2B59\u2BB8-\u2BEB\u3000-\u303F\u30A0-\u30FF\uE000-\uF8FF\uFE30-\uFE6F\uFF00-\uFFEF\uFFFC\uFFFD]/gim.test(String.fromCodePoint(e))));
          var e;
        }
        const Af = xl(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
        function $u(o) {
          return Af.test(String.fromCodePoint(o));
        }
        function zf(o, e) {
          return !(!e && $u(o) || /[\u0900-\u0DFF\u0F00-\u109F\u1780-\u17FF]/gim.test(String.fromCodePoint(o)));
        }
        function Nm(o) {
          for (const e of o) if ($u(e.charCodeAt(0))) return true;
          return false;
        }
        const Ko = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
            };
          }
          setState(o) {
            this.pluginStatus = o.pluginStatus, this.pluginURL = o.pluginURL;
          }
          getState() {
            return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
          }
          setMethods(o) {
            if (Ko.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = o.applyArabicShaping, this.processBidirectionalText = o.processBidirectionalText, this.processStyledBidirectionalText = o.processStyledBidirectionalText, this.loadScriptResolve();
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
          syncState(o, e) {
            return s(this, void 0, void 0, (function* () {
              if (this.isParsed()) return this.getState();
              if (o.pluginStatus !== "loading") return this.setState(o), o;
              const i = o.pluginURL, u = new Promise(((m) => {
                this.loadScriptResolve = m;
              }));
              e(i);
              const c = new Promise(((m) => setTimeout((() => m()), this.TIMEOUT)));
              if (yield Promise.race([u, c]), this.isParsed()) {
                const m = { pluginStatus: "loaded", pluginURL: i };
                return this.setState(m), m;
              }
              throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${i}`);
            }));
          }
        }();
        class qr {
          constructor(e, i) {
            this.isSupportedScript = Ff, this.zoom = e, i ? (this.now = i.now || 0, this.fadeDuration = i.fadeDuration || 0, this.zoomHistory = i.zoomHistory || new Sd(), this.transition = i.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Sd(), this.transition = {});
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const e = this.zoom, i = e - Math.floor(e), u = this.crossFadingFactor();
            return e > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: i + (1 - i) * u } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - u) * i };
          }
        }
        function Ff(o) {
          return (function(e, i) {
            for (const u of e) if (!zf(u.charCodeAt(0), i)) return false;
            return true;
          })(o, Ko.getRTLTextPluginStatus() === "loaded");
        }
        class Nu {
          constructor(e, i, u) {
            this.property = e, this.value = i, this.expression = (function(c, m, v) {
              if (Tu(c)) return new Du(c, m);
              if (Iu(c)) {
                const x = gf(c, m, v);
                if (x.result === "error") throw new Error(x.value.map(((C) => `${C.key}: ${C.message}`)).join(", "));
                return x.value;
              }
              {
                let x = c;
                return m.type === "color" && typeof c == "string" ? x = br.parse(c) : m.type !== "padding" || typeof c != "number" && !Array.isArray(c) ? m.type !== "numberArray" || typeof c != "number" && !Array.isArray(c) ? m.type !== "colorArray" || typeof c != "string" && !Array.isArray(c) ? m.type === "variableAnchorOffsetCollection" && Array.isArray(c) ? x = Pn.parse(c) : m.type === "projectionDefinition" && typeof c == "string" && (x = fn.parse(c)) : x = Oi.parse(c) : x = hn.parse(c) : x = dn.parse(c), { globalStateRefs: /* @__PURE__ */ new Set(), _globalState: null, kind: "constant", evaluate: () => x };
              }
            })(i === void 0 ? e.specification.default : i, e.specification, u);
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite";
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
          }
          possiblyEvaluate(e, i, u) {
            return this.property.possiblyEvaluate(this, e, i, u);
          }
        }
        class ju {
          constructor(e, i) {
            this.property = e, this.value = new Nu(e, void 0, i);
          }
          transitioned(e, i) {
            return new Lf(this.property, this.value, i, Zt({}, e.transition, this.transition), e.now);
          }
          untransitioned() {
            return new Lf(this.property, this.value, null, {}, 0);
          }
        }
        class Id {
          constructor(e, i) {
            this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues), this._globalState = i;
          }
          getValue(e) {
            return lr(this._values[e].value.value);
          }
          setValue(e, i) {
            Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new ju(this._values[e].property, this._globalState)), this._values[e].value = new Nu(this._values[e].property, i === null ? void 0 : lr(i), this._globalState);
          }
          getTransition(e) {
            return lr(this._values[e].transition);
          }
          setTransition(e, i) {
            Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new ju(this._values[e].property, this._globalState)), this._values[e].transition = lr(i) || void 0;
          }
          serialize() {
            const e = {};
            for (const i of Object.keys(this._values)) {
              const u = this.getValue(i);
              u !== void 0 && (e[i] = u);
              const c = this.getTransition(i);
              c !== void 0 && (e[`${i}-transition`] = c);
            }
            return e;
          }
          transitioned(e, i) {
            const u = new Bf(this._properties);
            for (const c of Object.keys(this._values)) u._values[c] = this._values[c].transitioned(e, i._values[c]);
            return u;
          }
          untransitioned() {
            const e = new Bf(this._properties);
            for (const i of Object.keys(this._values)) e._values[i] = this._values[i].untransitioned();
            return e;
          }
        }
        class Lf {
          constructor(e, i, u, c, m) {
            this.property = e, this.value = i, this.begin = m + c.delay || 0, this.end = this.begin + c.duration || 0, e.specification.transition && (c.delay || c.duration) && (this.prior = u);
          }
          possiblyEvaluate(e, i, u) {
            const c = e.now || 0, m = this.value.possiblyEvaluate(e, i, u), v = this.prior;
            if (v) {
              if (c > this.end) return this.prior = null, m;
              if (this.value.isDataDriven()) return this.prior = null, m;
              if (c < this.begin) return v.possiblyEvaluate(e, i, u);
              {
                const x = (c - this.begin) / (this.end - this.begin);
                return this.property.interpolate(v.possiblyEvaluate(e, i, u), m, Pt(x));
              }
            }
            return m;
          }
        }
        class Bf {
          constructor(e) {
            this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(e, i, u) {
            const c = new wl(this._properties);
            for (const m of Object.keys(this._values)) c._values[m] = this._values[m].possiblyEvaluate(e, i, u);
            return c;
          }
          hasTransition() {
            for (const e of Object.keys(this._values)) if (this._values[e].prior) return true;
            return false;
          }
        }
        class Of {
          constructor(e, i) {
            this._properties = e, this._values = Object.create(e.defaultPropertyValues), this._globalState = i;
          }
          hasValue(e) {
            return this._values[e].value !== void 0;
          }
          getValue(e) {
            return lr(this._values[e].value);
          }
          setValue(e, i) {
            this._values[e] = new Nu(this._values[e].property, i === null ? void 0 : lr(i), this._globalState);
          }
          serialize() {
            const e = {};
            for (const i of Object.keys(this._values)) {
              const u = this.getValue(i);
              u !== void 0 && (e[i] = u);
            }
            return e;
          }
          possiblyEvaluate(e, i, u) {
            const c = new wl(this._properties);
            for (const m of Object.keys(this._values)) c._values[m] = this._values[m].possiblyEvaluate(e, i, u);
            return c;
          }
        }
        class xo {
          constructor(e, i, u) {
            this.property = e, this.value = i, this.parameters = u;
          }
          isConstant() {
            return this.value.kind === "constant";
          }
          constantOr(e) {
            return this.value.kind === "constant" ? this.value.value : e;
          }
          evaluate(e, i, u, c) {
            return this.property.evaluate(this.value, this.parameters, e, i, u, c);
          }
        }
        class wl {
          constructor(e) {
            this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues);
          }
          get(e) {
            return this._values[e];
          }
        }
        class Wt {
          constructor(e) {
            this.specification = e;
          }
          possiblyEvaluate(e, i) {
            if (e.isDataDriven()) throw new Error("Value should not be data driven");
            return e.expression.evaluate(i);
          }
          interpolate(e, i, u) {
            const c = yo[this.specification.type];
            return c ? c(e, i, u) : e;
          }
        }
        class or {
          constructor(e, i) {
            this.specification = e, this.overrides = i;
          }
          possiblyEvaluate(e, i, u, c) {
            return new xo(this, e.expression.kind === "constant" || e.expression.kind === "camera" ? { kind: "constant", value: e.expression.evaluate(i, null, {}, u, c) } : e.expression, i);
          }
          interpolate(e, i, u) {
            if (e.value.kind !== "constant" || i.value.kind !== "constant") return e;
            if (e.value.value === void 0 || i.value.value === void 0) return new xo(this, { kind: "constant", value: void 0 }, e.parameters);
            const c = yo[this.specification.type];
            if (c) {
              const m = c(e.value.value, i.value.value, u);
              return new xo(this, { kind: "constant", value: m }, e.parameters);
            }
            return e;
          }
          evaluate(e, i, u, c, m, v) {
            return e.kind === "constant" ? e.value : e.evaluate(i, u, c, m, v);
          }
        }
        class Cl extends or {
          possiblyEvaluate(e, i, u, c) {
            if (e.value === void 0) return new xo(this, { kind: "constant", value: void 0 }, i);
            if (e.expression.kind === "constant") {
              const m = e.expression.evaluate(i, null, {}, u, c), v = e.property.specification.type === "resolvedImage" && typeof m != "string" ? m.name : m, x = this._calculate(v, v, v, i);
              return new xo(this, { kind: "constant", value: x }, i);
            }
            if (e.expression.kind === "camera") {
              const m = this._calculate(e.expression.evaluate({ zoom: i.zoom - 1 }), e.expression.evaluate({ zoom: i.zoom }), e.expression.evaluate({ zoom: i.zoom + 1 }), i);
              return new xo(this, { kind: "constant", value: m }, i);
            }
            return new xo(this, e.expression, i);
          }
          evaluate(e, i, u, c, m, v) {
            if (e.kind === "source") {
              const x = e.evaluate(i, u, c, m, v);
              return this._calculate(x, x, x, i);
            }
            return e.kind === "composite" ? this._calculate(e.evaluate({ zoom: Math.floor(i.zoom) - 1 }, u, c), e.evaluate({ zoom: Math.floor(i.zoom) }, u, c), e.evaluate({ zoom: Math.floor(i.zoom) + 1 }, u, c), i) : e.value;
          }
          _calculate(e, i, u, c) {
            return c.zoom > c.zoomHistory.lastIntegerZoom ? { from: e, to: i } : { from: u, to: i };
          }
          interpolate(e) {
            return e;
          }
        }
        class Vu {
          constructor(e) {
            this.specification = e;
          }
          possiblyEvaluate(e, i, u, c) {
            if (e.value !== void 0) {
              if (e.expression.kind === "constant") {
                const m = e.expression.evaluate(i, null, {}, u, c);
                return this._calculate(m, m, m, i);
              }
              return this._calculate(e.expression.evaluate(new qr(Math.floor(i.zoom - 1), i)), e.expression.evaluate(new qr(Math.floor(i.zoom), i)), e.expression.evaluate(new qr(Math.floor(i.zoom + 1), i)), i);
            }
          }
          _calculate(e, i, u, c) {
            return c.zoom > c.zoomHistory.lastIntegerZoom ? { from: e, to: i } : { from: u, to: i };
          }
          interpolate(e) {
            return e;
          }
        }
        class Uu {
          constructor(e) {
            this.specification = e;
          }
          possiblyEvaluate(e, i, u, c) {
            return !!e.expression.evaluate(i, null, {}, u, c);
          }
          interpolate() {
            return false;
          }
        }
        class En {
          constructor(e) {
            this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const i in e) {
              const u = e[i];
              u.specification.overridable && this.overridableProperties.push(i);
              const c = this.defaultPropertyValues[i] = new Nu(u, void 0, void 0), m = this.defaultTransitionablePropertyValues[i] = new ju(u, void 0);
              this.defaultTransitioningPropertyValues[i] = m.untransitioned(), this.defaultPossiblyEvaluatedValues[i] = c.possiblyEvaluate({});
            }
          }
        }
        Lt("DataDrivenProperty", or), Lt("DataConstantProperty", Wt), Lt("CrossFadedDataDrivenProperty", Cl), Lt("CrossFadedProperty", Vu), Lt("ColorRampProperty", Uu);
        const Ed = "-transition";
        class so extends Re {
          constructor(e, i, u) {
            if (super(), this.id = e.id, this.type = e.type, this._globalState = u, this._featureFilter = { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() }, e.type !== "custom" && (this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, e.type !== "background" && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter, this._featureFilter = hl(e.filter, u)), i.layout && (this._unevaluatedLayout = new Of(i.layout, u)), i.paint)) {
              this._transitionablePaint = new Id(i.paint, u);
              for (const c in e.paint) this.setPaintProperty(c, e.paint[c], { validate: false });
              for (const c in e.layout) this.setLayoutProperty(c, e.layout[c], { validate: false });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new wl(i.paint);
            }
          }
          setFilter(e) {
            this.filter = e, this._featureFilter = hl(e, this._globalState);
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(e) {
            return e === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(e);
          }
          getLayoutAffectingGlobalStateRefs() {
            const e = /* @__PURE__ */ new Set();
            if (this._unevaluatedLayout) for (const i in this._unevaluatedLayout._values) {
              const u = this._unevaluatedLayout._values[i];
              for (const c of u.getGlobalStateRefs()) e.add(c);
            }
            for (const i of this._featureFilter.getGlobalStateRefs()) e.add(i);
            return e;
          }
          getPaintAffectingGlobalStateRefs() {
            var e;
            const i = new globalThis.Map();
            if (this._transitionablePaint) for (const u in this._transitionablePaint._values) {
              const c = this._transitionablePaint._values[u].value;
              for (const m of c.getGlobalStateRefs()) {
                const v = (e = i.get(m)) !== null && e !== void 0 ? e : [];
                v.push({ name: u, value: c.value }), i.set(m, v);
              }
            }
            return i;
          }
          setLayoutProperty(e, i, u = {}) {
            i != null && this._validate(Ef, `layers.${this.id}.layout.${e}`, e, i, u) || (e !== "visibility" ? this._unevaluatedLayout.setValue(e, i) : this.visibility = i);
          }
          getPaintProperty(e) {
            return e.endsWith(Ed) ? this._transitionablePaint.getTransition(e.slice(0, -11)) : this._transitionablePaint.getValue(e);
          }
          setPaintProperty(e, i, u = {}) {
            if (i != null && this._validate(yl, `layers.${this.id}.paint.${e}`, e, i, u)) return false;
            if (e.endsWith(Ed)) return this._transitionablePaint.setTransition(e.slice(0, -11), i || void 0), false;
            {
              const c = this._transitionablePaint._values[e], m = c.property.specification["property-type"] === "cross-faded-data-driven", v = c.value.isDataDriven(), x = c.value;
              this._transitionablePaint.setValue(e, i), this._handleSpecialPaintPropertyUpdate(e);
              const C = this._transitionablePaint._values[e].value;
              return C.isDataDriven() || v || m || this._handleOverridablePaintPropertyUpdate(e, x, C);
            }
          }
          _handleSpecialPaintPropertyUpdate(e) {
          }
          _handleOverridablePaintPropertyUpdate(e, i, u) {
            return false;
          }
          isHidden(e, i = false) {
            return !!(this.minzoom && e < (i ? Math.floor(this.minzoom) : this.minzoom)) || !!(this.maxzoom && e >= this.maxzoom) || this.visibility === "none";
          }
          updateTransitions(e) {
            this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(e, i) {
            e.getCrossfadeParameters && (this._crossfadeParameters = e.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, i)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, i);
          }
          serialize() {
            const e = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (e.layout = e.layout || {}, e.layout.visibility = this.visibility), Pr(e, ((i, u) => !(i === void 0 || u === "layout" && !Object.keys(i).length || u === "paint" && !Object.keys(i).length)));
          }
          _validate(e, i, u, c, m = {}) {
            return (!m || m.validate !== false) && Ou(this, e.call(Xa, { key: i, layerType: this.type, objectKey: u, value: c, styleSpec: se, style: { glyphs: true, sprite: true } }));
          }
          is3D() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          resize() {
          }
          isStateDependent() {
            for (const e in this.paint._values) {
              const i = this.paint.get(e);
              if (i instanceof xo && ws(i.property.specification) && (i.value.kind === "source" || i.value.kind === "composite") && i.value.isStateDependent) return true;
            }
            return false;
          }
        }
        let Md;
        var jm = { get paint() {
          return Md = Md || new En({ "raster-opacity": new Wt(se.paint_raster["raster-opacity"]), "raster-hue-rotate": new Wt(se.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Wt(se.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Wt(se.paint_raster["raster-brightness-max"]), "raster-saturation": new Wt(se.paint_raster["raster-saturation"]), "raster-contrast": new Wt(se.paint_raster["raster-contrast"]), "raster-resampling": new Wt(se.paint_raster["raster-resampling"]), "raster-fade-duration": new Wt(se.paint_raster["raster-fade-duration"]) });
        } };
        class Vm extends so {
          constructor(e, i) {
            super(e, jm, i);
          }
        }
        const Um = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class Sl {
          constructor(e, i) {
            this._structArray = e, this._pos1 = i * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class pi {
          constructor() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          }
          static serialize(e, i) {
            return e._trim(), i && (e.isTransferred = true, i.push(e.arrayBuffer)), { length: e.length, arrayBuffer: e.arrayBuffer };
          }
          static deserialize(e) {
            const i = Object.create(this.prototype);
            return i.arrayBuffer = e.arrayBuffer, i.length = e.length, i.capacity = e.arrayBuffer.byteLength / i.bytesPerElement, i._refreshViews(), i;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(e) {
            this.reserve(e), this.length = e;
          }
          reserve(e) {
            if (e > this.capacity) {
              this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const i = this.uint8;
              this._refreshViews(), i && this.uint8.set(i);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function Xr(o, e = 1) {
          let i = 0, u = 0;
          return { members: o.map(((c) => {
            const m = Um[c.type].BYTES_PER_ELEMENT, v = i = $f(i, Math.max(e, m)), x = c.components || 1;
            return u = Math.max(u, m), i += m * x, { name: c.name, type: c.type, components: x, offset: v };
          })), size: $f(i, Math.max(u, e)), alignment: e };
        }
        function $f(o, e) {
          return Math.ceil(o / e) * e;
        }
        class kl extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, i) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, e, i);
          }
          emplace(e, i, u) {
            const c = 2 * e;
            return this.int16[c + 0] = i, this.int16[c + 1] = u, e;
          }
        }
        kl.prototype.bytesPerElement = 4, Lt("StructArrayLayout2i4", kl);
        class Gu extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, u) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, e, i, u);
          }
          emplace(e, i, u, c) {
            const m = 3 * e;
            return this.int16[m + 0] = i, this.int16[m + 1] = u, this.int16[m + 2] = c, e;
          }
        }
        Gu.prototype.bytesPerElement = 6, Lt("StructArrayLayout3i6", Gu);
        class qu extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, u, c) {
            const m = this.length;
            return this.resize(m + 1), this.emplace(m, e, i, u, c);
          }
          emplace(e, i, u, c, m) {
            const v = 4 * e;
            return this.int16[v + 0] = i, this.int16[v + 1] = u, this.int16[v + 2] = c, this.int16[v + 3] = m, e;
          }
        }
        qu.prototype.bytesPerElement = 8, Lt("StructArrayLayout4i8", qu);
        class Dd extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, u, c, m, v) {
            const x = this.length;
            return this.resize(x + 1), this.emplace(x, e, i, u, c, m, v);
          }
          emplace(e, i, u, c, m, v, x) {
            const C = 6 * e;
            return this.int16[C + 0] = i, this.int16[C + 1] = u, this.int16[C + 2] = c, this.int16[C + 3] = m, this.int16[C + 4] = v, this.int16[C + 5] = x, e;
          }
        }
        Dd.prototype.bytesPerElement = 12, Lt("StructArrayLayout2i4i12", Dd);
        class Rd extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, u, c, m, v) {
            const x = this.length;
            return this.resize(x + 1), this.emplace(x, e, i, u, c, m, v);
          }
          emplace(e, i, u, c, m, v, x) {
            const C = 4 * e, k = 8 * e;
            return this.int16[C + 0] = i, this.int16[C + 1] = u, this.uint8[k + 4] = c, this.uint8[k + 5] = m, this.uint8[k + 6] = v, this.uint8[k + 7] = x, e;
          }
        }
        Rd.prototype.bytesPerElement = 8, Lt("StructArrayLayout2i4ub8", Rd);
        class wo extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, i) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, e, i);
          }
          emplace(e, i, u) {
            const c = 2 * e;
            return this.float32[c + 0] = i, this.float32[c + 1] = u, e;
          }
        }
        wo.prototype.bytesPerElement = 8, Lt("StructArrayLayout2f8", wo);
        class Wu extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, u, c, m, v, x, C, k, E) {
            const D = this.length;
            return this.resize(D + 1), this.emplace(D, e, i, u, c, m, v, x, C, k, E);
          }
          emplace(e, i, u, c, m, v, x, C, k, E, D) {
            const F = 10 * e;
            return this.uint16[F + 0] = i, this.uint16[F + 1] = u, this.uint16[F + 2] = c, this.uint16[F + 3] = m, this.uint16[F + 4] = v, this.uint16[F + 5] = x, this.uint16[F + 6] = C, this.uint16[F + 7] = k, this.uint16[F + 8] = E, this.uint16[F + 9] = D, e;
          }
        }
        Wu.prototype.bytesPerElement = 20, Lt("StructArrayLayout10ui20", Wu);
        class Tl extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, u, c, m, v, x, C) {
            const k = this.length;
            return this.resize(k + 1), this.emplace(k, e, i, u, c, m, v, x, C);
          }
          emplace(e, i, u, c, m, v, x, C, k) {
            const E = 8 * e;
            return this.uint16[E + 0] = i, this.uint16[E + 1] = u, this.uint16[E + 2] = c, this.uint16[E + 3] = m, this.uint16[E + 4] = v, this.uint16[E + 5] = x, this.uint16[E + 6] = C, this.uint16[E + 7] = k, e;
          }
        }
        Tl.prototype.bytesPerElement = 16, Lt("StructArrayLayout8ui16", Tl);
        class Zu extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, u, c, m, v, x, C, k, E, D, F) {
            const V = this.length;
            return this.resize(V + 1), this.emplace(V, e, i, u, c, m, v, x, C, k, E, D, F);
          }
          emplace(e, i, u, c, m, v, x, C, k, E, D, F, V) {
            const G = 12 * e;
            return this.int16[G + 0] = i, this.int16[G + 1] = u, this.int16[G + 2] = c, this.int16[G + 3] = m, this.uint16[G + 4] = v, this.uint16[G + 5] = x, this.uint16[G + 6] = C, this.uint16[G + 7] = k, this.int16[G + 8] = E, this.int16[G + 9] = D, this.int16[G + 10] = F, this.int16[G + 11] = V, e;
          }
        }
        Zu.prototype.bytesPerElement = 24, Lt("StructArrayLayout4i4ui4i24", Zu);
        class Pl extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, i, u) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, e, i, u);
          }
          emplace(e, i, u, c) {
            const m = 3 * e;
            return this.float32[m + 0] = i, this.float32[m + 1] = u, this.float32[m + 2] = c, e;
          }
        }
        Pl.prototype.bytesPerElement = 12, Lt("StructArrayLayout3f12", Pl);
        class Ad extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            const i = this.length;
            return this.resize(i + 1), this.emplace(i, e);
          }
          emplace(e, i) {
            return this.uint32[1 * e + 0] = i, e;
          }
        }
        Ad.prototype.bytesPerElement = 4, Lt("StructArrayLayout1ul4", Ad);
        class Es extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, u, c, m, v, x, C, k) {
            const E = this.length;
            return this.resize(E + 1), this.emplace(E, e, i, u, c, m, v, x, C, k);
          }
          emplace(e, i, u, c, m, v, x, C, k, E) {
            const D = 10 * e, F = 5 * e;
            return this.int16[D + 0] = i, this.int16[D + 1] = u, this.int16[D + 2] = c, this.int16[D + 3] = m, this.int16[D + 4] = v, this.int16[D + 5] = x, this.uint32[F + 3] = C, this.uint16[D + 8] = k, this.uint16[D + 9] = E, e;
          }
        }
        Es.prototype.bytesPerElement = 20, Lt("StructArrayLayout6i1ul2ui20", Es);
        class Ya extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, u, c, m, v) {
            const x = this.length;
            return this.resize(x + 1), this.emplace(x, e, i, u, c, m, v);
          }
          emplace(e, i, u, c, m, v, x) {
            const C = 6 * e;
            return this.int16[C + 0] = i, this.int16[C + 1] = u, this.int16[C + 2] = c, this.int16[C + 3] = m, this.int16[C + 4] = v, this.int16[C + 5] = x, e;
          }
        }
        Ya.prototype.bytesPerElement = 12, Lt("StructArrayLayout2i2i2i12", Ya);
        class zd extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, u, c, m) {
            const v = this.length;
            return this.resize(v + 1), this.emplace(v, e, i, u, c, m);
          }
          emplace(e, i, u, c, m, v) {
            const x = 4 * e, C = 8 * e;
            return this.float32[x + 0] = i, this.float32[x + 1] = u, this.float32[x + 2] = c, this.int16[C + 6] = m, this.int16[C + 7] = v, e;
          }
        }
        zd.prototype.bytesPerElement = 16, Lt("StructArrayLayout2f1f2i16", zd);
        class Hu extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, u, c, m, v) {
            const x = this.length;
            return this.resize(x + 1), this.emplace(x, e, i, u, c, m, v);
          }
          emplace(e, i, u, c, m, v, x) {
            const C = 16 * e, k = 4 * e, E = 8 * e;
            return this.uint8[C + 0] = i, this.uint8[C + 1] = u, this.float32[k + 1] = c, this.float32[k + 2] = m, this.int16[E + 6] = v, this.int16[E + 7] = x, e;
          }
        }
        Hu.prototype.bytesPerElement = 16, Lt("StructArrayLayout2ub2f2i16", Hu);
        class Ca extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, u) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, e, i, u);
          }
          emplace(e, i, u, c) {
            const m = 3 * e;
            return this.uint16[m + 0] = i, this.uint16[m + 1] = u, this.uint16[m + 2] = c, e;
          }
        }
        Ca.prototype.bytesPerElement = 6, Lt("StructArrayLayout3ui6", Ca);
        class Fd extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, i, u, c, m, v, x, C, k, E, D, F, V, G, H, Y, ie) {
            const we = this.length;
            return this.resize(we + 1), this.emplace(we, e, i, u, c, m, v, x, C, k, E, D, F, V, G, H, Y, ie);
          }
          emplace(e, i, u, c, m, v, x, C, k, E, D, F, V, G, H, Y, ie, we) {
            const ce = 24 * e, pe = 12 * e, Te = 48 * e;
            return this.int16[ce + 0] = i, this.int16[ce + 1] = u, this.uint16[ce + 2] = c, this.uint16[ce + 3] = m, this.uint32[pe + 2] = v, this.uint32[pe + 3] = x, this.uint32[pe + 4] = C, this.uint16[ce + 10] = k, this.uint16[ce + 11] = E, this.uint16[ce + 12] = D, this.float32[pe + 7] = F, this.float32[pe + 8] = V, this.uint8[Te + 36] = G, this.uint8[Te + 37] = H, this.uint8[Te + 38] = Y, this.uint32[pe + 10] = ie, this.int16[ce + 22] = we, e;
          }
        }
        Fd.prototype.bytesPerElement = 48, Lt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Fd);
        class Ld extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, i, u, c, m, v, x, C, k, E, D, F, V, G, H, Y, ie, we, ce, pe, Te, Oe, Xe, yt, ft, wt, Rt, Et) {
            const Mt = this.length;
            return this.resize(Mt + 1), this.emplace(Mt, e, i, u, c, m, v, x, C, k, E, D, F, V, G, H, Y, ie, we, ce, pe, Te, Oe, Xe, yt, ft, wt, Rt, Et);
          }
          emplace(e, i, u, c, m, v, x, C, k, E, D, F, V, G, H, Y, ie, we, ce, pe, Te, Oe, Xe, yt, ft, wt, Rt, Et, Mt) {
            const lt = 32 * e, rr = 16 * e;
            return this.int16[lt + 0] = i, this.int16[lt + 1] = u, this.int16[lt + 2] = c, this.int16[lt + 3] = m, this.int16[lt + 4] = v, this.int16[lt + 5] = x, this.int16[lt + 6] = C, this.int16[lt + 7] = k, this.uint16[lt + 8] = E, this.uint16[lt + 9] = D, this.uint16[lt + 10] = F, this.uint16[lt + 11] = V, this.uint16[lt + 12] = G, this.uint16[lt + 13] = H, this.uint16[lt + 14] = Y, this.uint16[lt + 15] = ie, this.uint16[lt + 16] = we, this.uint16[lt + 17] = ce, this.uint16[lt + 18] = pe, this.uint16[lt + 19] = Te, this.uint16[lt + 20] = Oe, this.uint16[lt + 21] = Xe, this.uint16[lt + 22] = yt, this.uint32[rr + 12] = ft, this.float32[rr + 13] = wt, this.float32[rr + 14] = Rt, this.uint16[lt + 30] = Et, this.uint16[lt + 31] = Mt, e;
          }
        }
        Ld.prototype.bytesPerElement = 64, Lt("StructArrayLayout8i15ui1ul2f2ui64", Ld);
        class Il extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            const i = this.length;
            return this.resize(i + 1), this.emplace(i, e);
          }
          emplace(e, i) {
            return this.float32[1 * e + 0] = i, e;
          }
        }
        Il.prototype.bytesPerElement = 4, Lt("StructArrayLayout1f4", Il);
        class Bd extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, i, u) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, e, i, u);
          }
          emplace(e, i, u, c) {
            const m = 3 * e;
            return this.uint16[6 * e + 0] = i, this.float32[m + 1] = u, this.float32[m + 2] = c, e;
          }
        }
        Bd.prototype.bytesPerElement = 12, Lt("StructArrayLayout1ui2f12", Bd);
        class _ extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, u) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, e, i, u);
          }
          emplace(e, i, u, c) {
            const m = 4 * e;
            return this.uint32[2 * e + 0] = i, this.uint16[m + 2] = u, this.uint16[m + 3] = c, e;
          }
        }
        _.prototype.bytesPerElement = 8, Lt("StructArrayLayout1ul2ui8", _);
        class t extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, i) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, e, i);
          }
          emplace(e, i, u) {
            const c = 2 * e;
            return this.uint16[c + 0] = i, this.uint16[c + 1] = u, e;
          }
        }
        t.prototype.bytesPerElement = 4, Lt("StructArrayLayout2ui4", t);
        class a extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            const i = this.length;
            return this.resize(i + 1), this.emplace(i, e);
          }
          emplace(e, i) {
            return this.uint16[1 * e + 0] = i, e;
          }
        }
        a.prototype.bytesPerElement = 2, Lt("StructArrayLayout1ui2", a);
        class d extends pi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, i, u, c) {
            const m = this.length;
            return this.resize(m + 1), this.emplace(m, e, i, u, c);
          }
          emplace(e, i, u, c, m) {
            const v = 4 * e;
            return this.float32[v + 0] = i, this.float32[v + 1] = u, this.float32[v + 2] = c, this.float32[v + 3] = m, e;
          }
        }
        d.prototype.bytesPerElement = 16, Lt("StructArrayLayout4f16", d);
        class g extends Sl {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new S(this.anchorPointX, this.anchorPointY);
          }
        }
        g.prototype.size = 20;
        class b extends Es {
          get(e) {
            return new g(this, e);
          }
        }
        Lt("CollisionBoxArray", b);
        class w extends Sl {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(e) {
            this._structArray.uint8[this._pos1 + 37] = e;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(e) {
            this._structArray.uint8[this._pos1 + 38] = e;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(e) {
            this._structArray.uint32[this._pos4 + 10] = e;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        w.prototype.size = 48;
        class T extends Fd {
          get(e) {
            return new w(this, e);
          }
        }
        Lt("PlacedSymbolArray", T);
        class I extends Sl {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(e) {
            this._structArray.uint32[this._pos4 + 12] = e;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        I.prototype.size = 64;
        class R extends Ld {
          get(e) {
            return new I(this, e);
          }
        }
        Lt("SymbolInstanceArray", R);
        class z extends Il {
          getoffsetX(e) {
            return this.float32[1 * e + 0];
          }
        }
        Lt("GlyphOffsetArray", z);
        class W extends Gu {
          getx(e) {
            return this.int16[3 * e + 0];
          }
          gety(e) {
            return this.int16[3 * e + 1];
          }
          gettileUnitDistanceFromAnchor(e) {
            return this.int16[3 * e + 2];
          }
        }
        Lt("SymbolLineVertexArray", W);
        class U extends Sl {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        U.prototype.size = 12;
        class X extends Bd {
          get(e) {
            return new U(this, e);
          }
        }
        Lt("TextAnchorOffsetArray", X);
        class re extends Sl {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        re.prototype.size = 8;
        class de extends _ {
          get(e) {
            return new re(this, e);
          }
        }
        Lt("FeatureIndexArray", de);
        class fe extends kl {
        }
        class me extends kl {
        }
        class Ce extends kl {
        }
        class Pe extends Dd {
        }
        class xe extends Rd {
        }
        class Ie extends wo {
        }
        class De extends Wu {
        }
        class Se extends Tl {
        }
        class Ne extends Zu {
        }
        class Ke extends Pl {
        }
        class Ze extends Ad {
        }
        class He extends Ya {
        }
        class Je extends Hu {
        }
        class Tt extends Ca {
        }
        class It extends t {
        }
        const _t = Xr([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Gt } = _t;
        class Yt {
          constructor(e = []) {
            this._forceNewSegmentOnNextPrepare = false, this.segments = e;
          }
          prepareSegment(e, i, u, c) {
            const m = this.segments[this.segments.length - 1];
            return e > Yt.MAX_VERTEX_ARRAY_LENGTH && Ht(`Max vertices per segment is ${Yt.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Yt.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !m || m.vertexLength + e > Yt.MAX_VERTEX_ARRAY_LENGTH || m.sortKey !== c ? this.createNewSegment(i, u, c) : m;
          }
          createNewSegment(e, i, u) {
            const c = { vertexOffset: e.length, primitiveOffset: i.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
            return u !== void 0 && (c.sortKey = u), this._forceNewSegmentOnNextPrepare = false, this.segments.push(c), c;
          }
          getOrCreateLatestSegment(e, i, u) {
            return this.prepareSegment(0, e, i, u);
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = true;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const e of this.segments) for (const i in e.vaos) e.vaos[i].destroy();
          }
          static simpleSegment(e, i, u, c) {
            return new Yt([{ vertexOffset: e, primitiveOffset: i, vertexLength: u, primitiveLength: c, vaos: {}, sortKey: 0 }]);
          }
        }
        function Br(o, e) {
          return 256 * (o = bt(Math.floor(o), 0, 255)) + bt(Math.floor(e), 0, 255);
        }
        Yt.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Lt("SegmentVector", Yt);
        const ri = Xr([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]), Yr = Xr([{ name: "a_dasharray_from", components: 4, type: "Uint16" }, { name: "a_dasharray_to", components: 4, type: "Uint16" }]);
        var si, Wr, Ri, Zr = { exports: {} }, Gi = { exports: {} }, Si = { exports: {} }, Ai = (function() {
          if (Ri) return Zr.exports;
          Ri = 1;
          var o = (si || (si = 1, Gi.exports = function(i, u) {
            var c, m, v, x, C, k, E, D;
            for (m = i.length - (c = 3 & i.length), v = u, C = 3432918353, k = 461845907, D = 0; D < m; ) E = 255 & i.charCodeAt(D) | (255 & i.charCodeAt(++D)) << 8 | (255 & i.charCodeAt(++D)) << 16 | (255 & i.charCodeAt(++D)) << 24, ++D, v = 27492 + (65535 & (x = 5 * (65535 & (v = (v ^= E = (65535 & (E = (E = (65535 & E) * C + (((E >>> 16) * C & 65535) << 16) & 4294967295) << 15 | E >>> 17)) * k + (((E >>> 16) * k & 65535) << 16) & 4294967295) << 13 | v >>> 19)) + ((5 * (v >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (x >>> 16) & 65535) << 16);
            switch (E = 0, c) {
              case 3:
                E ^= (255 & i.charCodeAt(D + 2)) << 16;
              case 2:
                E ^= (255 & i.charCodeAt(D + 1)) << 8;
              case 1:
                v ^= E = (65535 & (E = (E = (65535 & (E ^= 255 & i.charCodeAt(D))) * C + (((E >>> 16) * C & 65535) << 16) & 4294967295) << 15 | E >>> 17)) * k + (((E >>> 16) * k & 65535) << 16) & 4294967295;
            }
            return v ^= i.length, v = 2246822507 * (65535 & (v ^= v >>> 16)) + ((2246822507 * (v >>> 16) & 65535) << 16) & 4294967295, v = 3266489909 * (65535 & (v ^= v >>> 13)) + ((3266489909 * (v >>> 16) & 65535) << 16) & 4294967295, (v ^= v >>> 16) >>> 0;
          }), Gi.exports), e = (Wr || (Wr = 1, Si.exports = function(i, u) {
            for (var c, m = i.length, v = u ^ m, x = 0; m >= 4; ) c = 1540483477 * (65535 & (c = 255 & i.charCodeAt(x) | (255 & i.charCodeAt(++x)) << 8 | (255 & i.charCodeAt(++x)) << 16 | (255 & i.charCodeAt(++x)) << 24)) + ((1540483477 * (c >>> 16) & 65535) << 16), v = 1540483477 * (65535 & v) + ((1540483477 * (v >>> 16) & 65535) << 16) ^ (c = 1540483477 * (65535 & (c ^= c >>> 24)) + ((1540483477 * (c >>> 16) & 65535) << 16)), m -= 4, ++x;
            switch (m) {
              case 3:
                v ^= (255 & i.charCodeAt(x + 2)) << 16;
              case 2:
                v ^= (255 & i.charCodeAt(x + 1)) << 8;
              case 1:
                v = 1540483477 * (65535 & (v ^= 255 & i.charCodeAt(x))) + ((1540483477 * (v >>> 16) & 65535) << 16);
            }
            return v = 1540483477 * (65535 & (v ^= v >>> 13)) + ((1540483477 * (v >>> 16) & 65535) << 16), (v ^= v >>> 15) >>> 0;
          }), Si.exports);
          return Zr.exports = o, Zr.exports.murmur3 = o, Zr.exports.murmur2 = e, Zr.exports;
        })(), pn = P(Ai);
        class Go {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = false;
          }
          add(e, i, u, c) {
            this.ids.push(Sa(e)), this.positions.push(i, u, c);
          }
          getPositions(e) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const i = Sa(e);
            let u = 0, c = this.ids.length - 1;
            for (; u < c; ) {
              const v = u + c >> 1;
              this.ids[v] >= i ? c = v : u = v + 1;
            }
            const m = [];
            for (; this.ids[u] === i; ) m.push({ index: this.positions[3 * u], start: this.positions[3 * u + 1], end: this.positions[3 * u + 2] }), u++;
            return m;
          }
          static serialize(e, i) {
            const u = new Float64Array(e.ids), c = new Uint32Array(e.positions);
            return Jo(u, c, 0, u.length - 1), i && i.push(u.buffer, c.buffer), { ids: u, positions: c };
          }
          static deserialize(e) {
            const i = new Go();
            return i.ids = e.ids, i.positions = e.positions, i.indexed = true, i;
          }
        }
        function Sa(o) {
          const e = +o;
          return !isNaN(e) && e <= Number.MAX_SAFE_INTEGER ? e : pn(String(o));
        }
        function Jo(o, e, i, u) {
          for (; i < u; ) {
            const c = o[i + u >> 1];
            let m = i - 1, v = u + 1;
            for (; ; ) {
              do
                m++;
              while (o[m] < c);
              do
                v--;
              while (o[v] > c);
              if (m >= v) break;
              Qo(o, m, v), Qo(e, 3 * m, 3 * v), Qo(e, 3 * m + 1, 3 * v + 1), Qo(e, 3 * m + 2, 3 * v + 2);
            }
            v - i < u - v ? (Jo(o, e, i, v), i = v + 1) : (Jo(o, e, v + 1, u), u = v);
          }
        }
        function Qo(o, e, i) {
          const u = o[e];
          o[e] = o[i], o[i] = u;
        }
        Lt("FeaturePositionMap", Go);
        class lo {
          constructor(e, i) {
            this.gl = e.gl, this.location = i;
          }
        }
        class Ka extends lo {
          constructor(e, i) {
            super(e, i), this.current = 0;
          }
          set(e) {
            this.current !== e && (this.current = e, this.gl.uniform1f(this.location, e));
          }
        }
        class Ja extends lo {
          constructor(e, i) {
            super(e, i), this.current = [0, 0, 0, 0];
          }
          set(e) {
            e[0] === this.current[0] && e[1] === this.current[1] && e[2] === this.current[2] && e[3] === this.current[3] || (this.current = e, this.gl.uniform4f(this.location, e[0], e[1], e[2], e[3]));
          }
        }
        class Xn extends lo {
          constructor(e, i) {
            super(e, i), this.current = br.transparent;
          }
          set(e) {
            e.r === this.current.r && e.g === this.current.g && e.b === this.current.b && e.a === this.current.a || (this.current = e, this.gl.uniform4f(this.location, e.r, e.g, e.b, e.a));
          }
        }
        const ka = new Float32Array(16);
        function ea(o) {
          return [Br(255 * o.r, 255 * o.g), Br(255 * o.b, 255 * o.a)];
        }
        class ta {
          constructor(e, i, u) {
            this.value = e, this.uniformNames = i.map(((c) => `u_${c}`)), this.type = u;
          }
          setUniform(e, i, u) {
            e.set(u.constantOr(this.value));
          }
          getBinding(e, i, u) {
            return this.type === "color" ? new Xn(e, i) : new Ka(e, i);
          }
        }
        class li {
          constructor(e, i) {
            this.uniformNames = i.map(((u) => `u_${u}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(e, i) {
            this.pixelRatioFrom = i.pixelRatio, this.pixelRatioTo = e.pixelRatio, this.patternFrom = i.tlbr, this.patternTo = e.tlbr;
          }
          setConstantDashPositions(e, i) {
            this.dashTo = [0, e.y, e.height, e.width], this.dashFrom = [0, i.y, i.height, i.width];
          }
          setUniform(e, i, u, c) {
            let m = null;
            c === "u_pattern_to" ? m = this.patternTo : c === "u_pattern_from" ? m = this.patternFrom : c === "u_dasharray_to" ? m = this.dashTo : c === "u_dasharray_from" ? m = this.dashFrom : c === "u_pixel_ratio_to" ? m = this.pixelRatioTo : c === "u_pixel_ratio_from" && (m = this.pixelRatioFrom), m !== null && e.set(m);
          }
          getBinding(e, i, u) {
            return u.substr(0, 9) === "u_pattern" || u.substr(0, 12) === "u_dasharray_" ? new Ja(e, i) : new Ka(e, i);
          }
        }
        class ii {
          constructor(e, i, u, c) {
            this.expression = e, this.type = u, this.maxValue = 0, this.paintVertexAttributes = i.map(((m) => ({ name: `a_${m}`, type: "Float32", components: u === "color" ? 2 : 1, offset: 0 }))), this.paintVertexArray = new c();
          }
          populatePaintArray(e, i, u) {
            const c = this.paintVertexArray.length, m = this.expression.evaluate(new qr(0, u), i, {}, u.canonical, [], u.formattedSection);
            this.paintVertexArray.resize(e), this._setPaintValue(c, e, m);
          }
          updatePaintArray(e, i, u, c, m) {
            const v = this.expression.evaluate(new qr(0, m), u, c);
            this._setPaintValue(e, i, v);
          }
          _setPaintValue(e, i, u) {
            if (this.type === "color") {
              const c = ea(u);
              for (let m = e; m < i; m++) this.paintVertexArray.emplace(m, c[0], c[1]);
            } else {
              for (let c = e; c < i; c++) this.paintVertexArray.emplace(c, u);
              this.maxValue = Math.max(this.maxValue, Math.abs(u));
            }
          }
          upload(e) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class ki {
          constructor(e, i, u, c, m, v) {
            this.expression = e, this.uniformNames = i.map(((x) => `u_${x}_t`)), this.type = u, this.useIntegerZoom = c, this.zoom = m, this.maxValue = 0, this.paintVertexAttributes = i.map(((x) => ({ name: `a_${x}`, type: "Float32", components: u === "color" ? 4 : 2, offset: 0 }))), this.paintVertexArray = new v();
          }
          populatePaintArray(e, i, u) {
            const c = this.expression.evaluate(new qr(this.zoom, u), i, {}, u.canonical, [], u.formattedSection), m = this.expression.evaluate(new qr(this.zoom + 1, u), i, {}, u.canonical, [], u.formattedSection), v = this.paintVertexArray.length;
            this.paintVertexArray.resize(e), this._setPaintValue(v, e, c, m);
          }
          updatePaintArray(e, i, u, c, m) {
            const v = this.expression.evaluate(new qr(this.zoom, m), u, c), x = this.expression.evaluate(new qr(this.zoom + 1, m), u, c);
            this._setPaintValue(e, i, v, x);
          }
          _setPaintValue(e, i, u, c) {
            if (this.type === "color") {
              const m = ea(u), v = ea(c);
              for (let x = e; x < i; x++) this.paintVertexArray.emplace(x, m[0], m[1], v[0], v[1]);
            } else {
              for (let m = e; m < i; m++) this.paintVertexArray.emplace(m, u, c);
              this.maxValue = Math.max(this.maxValue, Math.abs(u), Math.abs(c));
            }
          }
          upload(e) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(e, i) {
            const u = this.useIntegerZoom ? Math.floor(i.zoom) : i.zoom, c = bt(this.expression.interpolationFactor(u, this.zoom, this.zoom + 1), 0, 1);
            e.set(c);
          }
          getBinding(e, i, u) {
            return new Ka(e, i);
          }
        }
        class ui {
          constructor(e, i, u, c, m, v) {
            this.expression = e, this.type = i, this.useIntegerZoom = u, this.zoom = c, this.layerId = v, this.zoomInPaintVertexArray = new m(), this.zoomOutPaintVertexArray = new m();
          }
          populatePaintArray(e, i, u) {
            const c = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(e), this.zoomOutPaintVertexArray.resize(e), this._setPaintValues(c, e, this.getPositionIds(i), u);
          }
          updatePaintArray(e, i, u, c, m) {
            this._setPaintValues(e, i, this.getPositionIds(u), m);
          }
          _setPaintValues(e, i, u, c) {
            const m = this.getPositions(c);
            if (!m || !u) return;
            const v = m[u.min], x = m[u.mid], C = m[u.max];
            if (v && x && C) for (let k = e; k < i; k++) this.emplace(this.zoomInPaintVertexArray, k, x, v), this.emplace(this.zoomOutPaintVertexArray, k, x, C);
          }
          upload(e) {
            if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
              const i = this.getVertexAttributes();
              this.zoomInPaintVertexBuffer = e.createVertexBuffer(this.zoomInPaintVertexArray, i, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = e.createVertexBuffer(this.zoomOutPaintVertexArray, i, this.expression.isStateDependent);
            }
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class Nf extends ui {
          getPositions(e) {
            return e.imagePositions;
          }
          getPositionIds(e) {
            return e.patterns && e.patterns[this.layerId];
          }
          getVertexAttributes() {
            return ri.members;
          }
          emplace(e, i, u, c) {
            e.emplace(i, u.tlbr[0], u.tlbr[1], u.tlbr[2], u.tlbr[3], c.tlbr[0], c.tlbr[1], c.tlbr[2], c.tlbr[3], u.pixelRatio, c.pixelRatio);
          }
        }
        class jf extends ui {
          getPositions(e) {
            return e.dashPositions;
          }
          getPositionIds(e) {
            return e.dashes && e.dashes[this.layerId];
          }
          getVertexAttributes() {
            return Yr.members;
          }
          emplace(e, i, u, c) {
            e.emplace(i, 0, u.y, u.height, u.width, 0, c.y, c.height, c.width);
          }
        }
        class Vf {
          constructor(e, i, u) {
            this.binders = {}, this._buffers = [];
            const c = [];
            for (const m in e.paint._values) {
              if (!u(m)) continue;
              const v = e.paint.get(m);
              if (!(v instanceof xo && ws(v.property.specification))) continue;
              const x = Gm(m, e.type), C = v.value, k = v.property.specification.type, E = v.property.useIntegerZoom, D = v.property.specification["property-type"], F = D === "cross-faded" || D === "cross-faded-data-driven";
              if (C.kind === "constant") this.binders[m] = F ? new li(C.value, x) : new ta(C.value, x, k), c.push(`/u_${m}`);
              else if (C.kind === "source" || F) {
                const V = Uf(m, k, "source");
                this.binders[m] = F ? m === "line-dasharray" ? new jf(C, k, E, i, V, e.id) : new Nf(C, k, E, i, V, e.id) : new ii(C, x, k, V), c.push(`/a_${m}`);
              } else {
                const V = Uf(m, k, "composite");
                this.binders[m] = new ki(C, x, k, E, i, V), c.push(`/z_${m}`);
              }
            }
            this.cacheKey = c.sort().join("");
          }
          getMaxValue(e) {
            const i = this.binders[e];
            return i instanceof ii || i instanceof ki ? i.maxValue : 0;
          }
          populatePaintArrays(e, i, u) {
            for (const c in this.binders) {
              const m = this.binders[c];
              (m instanceof ii || m instanceof ki || m instanceof ui) && m.populatePaintArray(e, i, u);
            }
          }
          setConstantPatternPositions(e, i) {
            for (const u in this.binders) {
              const c = this.binders[u];
              c instanceof li && c.setConstantPatternPositions(e, i);
            }
          }
          setConstantDashPositions(e, i) {
            for (const u in this.binders) {
              const c = this.binders[u];
              c instanceof li && c.setConstantDashPositions(e, i);
            }
          }
          updatePaintArrays(e, i, u, c, m) {
            let v = false;
            for (const x in e) {
              const C = i.getPositions(x);
              for (const k of C) {
                const E = u.feature(k.index);
                for (const D in this.binders) {
                  const F = this.binders[D];
                  if ((F instanceof ii || F instanceof ki || F instanceof ui) && F.expression.isStateDependent === true) {
                    const V = c.paint.get(D);
                    F.expression = V.value, F.updatePaintArray(k.start, k.end, E, e[x], m), v = true;
                  }
                }
              }
            }
            return v;
          }
          defines() {
            const e = [];
            for (const i in this.binders) {
              const u = this.binders[i];
              (u instanceof ta || u instanceof li) && e.push(...u.uniformNames.map(((c) => `#define HAS_UNIFORM_${c}`)));
            }
            return e;
          }
          getBinderAttributes() {
            const e = [];
            for (const i in this.binders) {
              const u = this.binders[i];
              if (u instanceof ii || u instanceof ki) for (let c = 0; c < u.paintVertexAttributes.length; c++) e.push(u.paintVertexAttributes[c].name);
              else if (u instanceof ui) {
                const c = u.getVertexAttributes();
                for (const m of c) e.push(m.name);
              }
            }
            return e;
          }
          getBinderUniforms() {
            const e = [];
            for (const i in this.binders) {
              const u = this.binders[i];
              if (u instanceof ta || u instanceof li || u instanceof ki) for (const c of u.uniformNames) e.push(c);
            }
            return e;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(e, i) {
            const u = [];
            for (const c in this.binders) {
              const m = this.binders[c];
              if (m instanceof ta || m instanceof li || m instanceof ki) {
                for (const v of m.uniformNames) if (i[v]) {
                  const x = m.getBinding(e, i[v], v);
                  u.push({ name: v, property: c, binding: x });
                }
              }
            }
            return u;
          }
          setUniforms(e, i, u, c) {
            for (const { name: m, property: v, binding: x } of i) this.binders[v].setUniform(x, c, u.get(v), m);
          }
          updatePaintBuffers(e) {
            this._buffers = [];
            for (const i in this.binders) {
              const u = this.binders[i];
              if (e && u instanceof ui) {
                const c = e.fromScale === 2 ? u.zoomInPaintVertexBuffer : u.zoomOutPaintVertexBuffer;
                c && this._buffers.push(c);
              } else (u instanceof ii || u instanceof ki) && u.paintVertexBuffer && this._buffers.push(u.paintVertexBuffer);
            }
          }
          upload(e) {
            for (const i in this.binders) {
              const u = this.binders[i];
              (u instanceof ii || u instanceof ki || u instanceof ui) && u.upload(e);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const e in this.binders) {
              const i = this.binders[e];
              (i instanceof ii || i instanceof ki || i instanceof ui) && i.destroy();
            }
          }
        }
        class Qa {
          constructor(e, i, u = () => true) {
            this.programConfigurations = {};
            for (const c of e) this.programConfigurations[c.id] = new Vf(c, i, u);
            this.needsUpload = false, this._featureMap = new Go(), this._bufferOffset = 0;
          }
          populatePaintArrays(e, i, u, c) {
            for (const m in this.programConfigurations) this.programConfigurations[m].populatePaintArrays(e, i, c);
            i.id !== void 0 && this._featureMap.add(i.id, u, this._bufferOffset, e), this._bufferOffset = e, this.needsUpload = true;
          }
          updatePaintArrays(e, i, u, c) {
            for (const m of u) this.needsUpload = this.programConfigurations[m.id].updatePaintArrays(e, this._featureMap, i, m, c) || this.needsUpload;
          }
          get(e) {
            return this.programConfigurations[e];
          }
          upload(e) {
            if (this.needsUpload) {
              for (const i in this.programConfigurations) this.programConfigurations[i].upload(e);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const e in this.programConfigurations) this.programConfigurations[e].destroy();
          }
        }
        function Gm(o, e) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-dasharray": ["dasharray_to", "dasharray_from"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[o] || [o.replace(`${e}-`, "").replace(/-/g, "_")];
        }
        function Uf(o, e, i) {
          const u = { color: { source: wo, composite: d }, number: { source: Il, composite: wo } }, c = (function(m) {
            return { "line-pattern": { source: De, composite: De }, "fill-pattern": { source: De, composite: De }, "fill-extrusion-pattern": { source: De, composite: De }, "line-dasharray": { source: Se, composite: Se } }[m];
          })(o);
          return c && c[i] || u[e][i];
        }
        Lt("ConstantBinder", ta), Lt("CrossFadedConstantBinder", li), Lt("SourceExpressionBinder", ii), Lt("CrossFadedPatternBinder", Nf), Lt("CrossFadedDasharrayBinder", jf), Lt("CompositeExpressionBinder", ki), Lt("ProgramConfiguration", Vf, { omit: ["_buffers"] }), Lt("ProgramConfigurationSet", Qa);
        const ra = Math.pow(2, 14) - 1, Od = -ra - 1;
        function Ta(o) {
          const e = it / o.extent, i = o.loadGeometry();
          for (let u = 0; u < i.length; u++) {
            const c = i[u];
            for (let m = 0; m < c.length; m++) {
              const v = c[m], x = Math.round(v.x * e), C = Math.round(v.y * e);
              v.x = bt(x, Od, ra), v.y = bt(C, Od, ra), (x < v.x || x > v.x + 1 || C < v.y || C > v.y + 1) && Ht("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return i;
        }
        function Pa(o, e) {
          return { type: o.type, id: o.id, properties: o.properties, geometry: e ? Ta(o) : [] };
        }
        const Xu = -32768;
        function Gf(o, e, i, u, c) {
          o.emplaceBack(Xu + 8 * e + u, Xu + 8 * i + c);
        }
        class El {
          constructor(e) {
            this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(((i) => i.id)), this.index = e.index, this.hasDependencies = false, this.layoutVertexArray = new me(), this.indexArray = new Tt(), this.segments = new Yt(), this.programConfigurations = new Qa(e.layers, e.zoom), this.stateDependentLayerIds = this.layers.filter(((i) => i.isStateDependent())).map(((i) => i.id));
          }
          populate(e, i, u) {
            const c = this.layers[0], m = [];
            let v = null, x = false, C = c.type === "heatmap";
            if (c.type === "circle") {
              const E = c;
              v = E.layout.get("circle-sort-key"), x = !v.isConstant(), C = C || E.paint.get("circle-pitch-alignment") === "map";
            }
            const k = C ? i.subdivisionGranularity.circle : 1;
            for (const { feature: E, id: D, index: F, sourceLayerIndex: V } of e) {
              const G = this.layers[0]._featureFilter.needGeometry, H = Pa(E, G);
              if (!this.layers[0]._featureFilter.filter(new qr(this.zoom), H, u)) continue;
              const Y = x ? v.evaluate(H, {}, u) : void 0, ie = { id: D, properties: E.properties, type: E.type, sourceLayerIndex: V, index: F, geometry: G ? H.geometry : Ta(E), patterns: {}, sortKey: Y };
              m.push(ie);
            }
            x && m.sort(((E, D) => E.sortKey - D.sortKey));
            for (const E of m) {
              const { geometry: D, index: F, sourceLayerIndex: V } = E, G = e[F].feature;
              this.addFeature(E, D, F, u, k), i.featureIndex.insert(G, D, F, V, this.index);
            }
          }
          update(e, i, u) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, i, this.stateDependentLayers, { imagePositions: u });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Gt), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(e, i, u, c, m = 1) {
            let v;
            switch (m) {
              case 1:
                v = [0, 7];
                break;
              case 3:
                v = [0, 2, 5, 7];
                break;
              case 5:
                v = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                v = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${m}; valid values are 1, 3, 5, 7.`);
            }
            const x = v.length;
            for (const C of i) for (const k of C) {
              const E = k.x, D = k.y;
              if (E < 0 || E >= it || D < 0 || D >= it) continue;
              const F = this.segments.prepareSegment(x * x, this.layoutVertexArray, this.indexArray, e.sortKey), V = F.vertexLength;
              for (let G = 0; G < x; G++) for (let H = 0; H < x; H++) Gf(this.layoutVertexArray, E, D, v[H], v[G]);
              for (let G = 0; G < x - 1; G++) for (let H = 0; H < x - 1; H++) {
                const Y = V + G * x + H, ie = V + (G + 1) * x + H;
                this.indexArray.emplaceBack(Y, ie + 1, Y + 1), this.indexArray.emplaceBack(Y, ie, ie + 1);
              }
              F.vertexLength += x * x, F.primitiveLength += (x - 1) * (x - 1) * 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, u, { imagePositions: {}, canonical: c });
          }
        }
        function wv(o, e) {
          for (let i = 0; i < o.length; i++) if (Yu(e, o[i])) return true;
          for (let i = 0; i < e.length; i++) if (Yu(o, e[i])) return true;
          return !!qm(o, e);
        }
        function qf(o, e, i) {
          return !!Yu(o, e) || !!Wm(e, o, i);
        }
        function Cv(o, e) {
          if (o.length === 1) return kv(e, o[0]);
          for (let i = 0; i < e.length; i++) {
            const u = e[i];
            for (let c = 0; c < u.length; c++) if (Yu(o, u[c])) return true;
          }
          for (let i = 0; i < o.length; i++) if (kv(e, o[i])) return true;
          for (let i = 0; i < e.length; i++) if (qm(o, e[i])) return true;
          return false;
        }
        function A2(o, e, i) {
          if (o.length > 1) {
            if (qm(o, e)) return true;
            for (let u = 0; u < e.length; u++) if (Wm(e[u], o, i)) return true;
          }
          for (let u = 0; u < o.length; u++) if (Wm(o[u], e, i)) return true;
          return false;
        }
        function qm(o, e) {
          if (o.length === 0 || e.length === 0) return false;
          for (let i = 0; i < o.length - 1; i++) {
            const u = o[i], c = o[i + 1];
            for (let m = 0; m < e.length - 1; m++) if (z2(u, c, e[m], e[m + 1])) return true;
          }
          return false;
        }
        function z2(o, e, i, u) {
          return Rr(o, i, u) !== Rr(e, i, u) && Rr(o, e, i) !== Rr(o, e, u);
        }
        function Wm(o, e, i) {
          const u = i * i;
          if (e.length === 1) return o.distSqr(e[0]) < u;
          for (let c = 1; c < e.length; c++) if (Sv(o, e[c - 1], e[c]) < u) return true;
          return false;
        }
        function Sv(o, e, i) {
          const u = e.distSqr(i);
          if (u === 0) return o.distSqr(e);
          const c = ((o.x - e.x) * (i.x - e.x) + (o.y - e.y) * (i.y - e.y)) / u;
          return o.distSqr(c < 0 ? e : c > 1 ? i : i.sub(e)._mult(c)._add(e));
        }
        function kv(o, e) {
          let i, u, c, m = false;
          for (let v = 0; v < o.length; v++) {
            i = o[v];
            for (let x = 0, C = i.length - 1; x < i.length; C = x++) u = i[x], c = i[C], u.y > e.y != c.y > e.y && e.x < (c.x - u.x) * (e.y - u.y) / (c.y - u.y) + u.x && (m = !m);
          }
          return m;
        }
        function Yu(o, e) {
          let i = false;
          for (let u = 0, c = o.length - 1; u < o.length; c = u++) {
            const m = o[u], v = o[c];
            m.y > e.y != v.y > e.y && e.x < (v.x - m.x) * (e.y - m.y) / (v.y - m.y) + m.x && (i = !i);
          }
          return i;
        }
        function F2(o, e, i) {
          const u = i[0], c = i[2];
          if (o.x < u.x && e.x < u.x || o.x > c.x && e.x > c.x || o.y < u.y && e.y < u.y || o.y > c.y && e.y > c.y) return false;
          const m = Rr(o, e, i[0]);
          return m !== Rr(o, e, i[1]) || m !== Rr(o, e, i[2]) || m !== Rr(o, e, i[3]);
        }
        function Ku(o, e, i) {
          const u = e.paint.get(o).value;
          return u.kind === "constant" ? u.value : i.programConfigurations.get(e.id).getMaxValue(o);
        }
        function Wf(o) {
          return Math.sqrt(o[0] * o[0] + o[1] * o[1]);
        }
        function Zf(o, e, i, u, c) {
          if (!e[0] && !e[1]) return o;
          const m = S.convert(e)._mult(c);
          i === "viewport" && m._rotate(-u);
          const v = [];
          for (let x = 0; x < o.length; x++) v.push(o[x].sub(m));
          return v;
        }
        function L2({ queryGeometry: o, size: e }, i) {
          return qf(o, i, e);
        }
        function B2({ queryGeometry: o, size: e, transform: i, unwrappedTileID: u, getElevation: c }, m) {
          return qf(o, m, e * (i.projectTileCoordinates(m.x, m.y, u, c).signedDistanceFromCamera / i.cameraToCenterDistance));
        }
        function O2({ queryGeometry: o, size: e, transform: i, unwrappedTileID: u, getElevation: c }, m) {
          const v = i.projectTileCoordinates(m.x, m.y, u, c).signedDistanceFromCamera, x = e * (i.cameraToCenterDistance / v);
          return qf(o, Zm(m, i, u, c), x);
        }
        function $2({ queryGeometry: o, size: e, transform: i, unwrappedTileID: u, getElevation: c }, m) {
          return qf(o, Zm(m, i, u, c), e);
        }
        function Tv({ queryGeometry: o, size: e, transform: i, unwrappedTileID: u, getElevation: c, pitchAlignment: m = "map", pitchScale: v = "map" }, x) {
          const C = m === "map" ? v === "map" ? L2 : B2 : v === "map" ? O2 : $2, k = { queryGeometry: o, size: e, transform: i, unwrappedTileID: u, getElevation: c };
          for (const E of x) for (const D of E) if (C(k, D)) return true;
          return false;
        }
        function Zm(o, e, i, u) {
          const c = e.projectTileCoordinates(o.x, o.y, i, u).point;
          return new S((0.5 * c.x + 0.5) * e.width, (0.5 * -c.y + 0.5) * e.height);
        }
        let Pv, Iv;
        Lt("CircleBucket", El, { omit: ["layers"] });
        var N2 = { get paint() {
          return Iv = Iv || new En({ "circle-radius": new or(se.paint_circle["circle-radius"]), "circle-color": new or(se.paint_circle["circle-color"]), "circle-blur": new or(se.paint_circle["circle-blur"]), "circle-opacity": new or(se.paint_circle["circle-opacity"]), "circle-translate": new Wt(se.paint_circle["circle-translate"]), "circle-translate-anchor": new Wt(se.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Wt(se.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Wt(se.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new or(se.paint_circle["circle-stroke-width"]), "circle-stroke-color": new or(se.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new or(se.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return Pv = Pv || new En({ "circle-sort-key": new or(se.layout_circle["circle-sort-key"]) });
        } };
        class j2 extends so {
          constructor(e, i) {
            super(e, N2, i);
          }
          createBucket(e) {
            return new El(e);
          }
          queryRadius(e) {
            const i = e;
            return Ku("circle-radius", this, i) + Ku("circle-stroke-width", this, i) + Wf(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature({ queryGeometry: e, feature: i, featureState: u, geometry: c, transform: m, pixelsToTileUnits: v, unwrappedTileID: x, getElevation: C }) {
            const k = Zf(e, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -m.bearingInRadians, v), E = this.paint.get("circle-radius").evaluate(i, u) + this.paint.get("circle-stroke-width").evaluate(i, u), D = this.paint.get("circle-pitch-scale"), F = this.paint.get("circle-pitch-alignment");
            let V, G;
            return F === "map" ? (V = k, G = E * v) : (V = (function(H, Y, ie, we) {
              return H.map(((ce) => Zm(ce, Y, ie, we)));
            })(k, m, x, C), G = E), Tv({ queryGeometry: V, size: G, transform: m, unwrappedTileID: x, getElevation: C, pitchAlignment: F, pitchScale: D }, c);
          }
        }
        class Ev extends El {
        }
        let Mv;
        Lt("HeatmapBucket", Ev, { omit: ["layers"] });
        var V2 = { get paint() {
          return Mv = Mv || new En({ "heatmap-radius": new or(se.paint_heatmap["heatmap-radius"]), "heatmap-weight": new or(se.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Wt(se.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Uu(se.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Wt(se.paint_heatmap["heatmap-opacity"]) });
        } };
        function Hm(o, { width: e, height: i }, u, c) {
          if (c) {
            if (c instanceof Uint8ClampedArray) c = new Uint8Array(c.buffer);
            else if (c.length !== e * i * u) throw new RangeError(`mismatched image size. expected: ${c.length} but got: ${e * i * u}`);
          } else c = new Uint8Array(e * i * u);
          return o.width = e, o.height = i, o.data = c, o;
        }
        function Dv(o, { width: e, height: i }, u) {
          if (e === o.width && i === o.height) return;
          const c = Hm({}, { width: e, height: i }, u);
          Xm(o, c, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(o.width, e), height: Math.min(o.height, i) }, u), o.width = e, o.height = i, o.data = c.data;
        }
        function Xm(o, e, i, u, c, m) {
          if (c.width === 0 || c.height === 0) return e;
          if (c.width > o.width || c.height > o.height || i.x > o.width - c.width || i.y > o.height - c.height) throw new RangeError("out of range source coordinates for image copy");
          if (c.width > e.width || c.height > e.height || u.x > e.width - c.width || u.y > e.height - c.height) throw new RangeError("out of range destination coordinates for image copy");
          const v = o.data, x = e.data;
          if (v === x) throw new Error("srcData equals dstData, so image is already copied");
          for (let C = 0; C < c.height; C++) {
            const k = ((i.y + C) * o.width + i.x) * m, E = ((u.y + C) * e.width + u.x) * m;
            for (let D = 0; D < c.width * m; D++) x[E + D] = v[k + D];
          }
          return e;
        }
        class $d {
          constructor(e, i) {
            Hm(this, e, 1, i);
          }
          resize(e) {
            Dv(this, e, 1);
          }
          clone() {
            return new $d({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(e, i, u, c, m) {
            Xm(e, i, u, c, m, 1);
          }
        }
        class Yn {
          constructor(e, i) {
            Hm(this, e, 4, i);
          }
          resize(e) {
            Dv(this, e, 4);
          }
          replace(e, i) {
            i ? this.data.set(e) : this.data = e instanceof Uint8ClampedArray ? new Uint8Array(e.buffer) : e;
          }
          clone() {
            return new Yn({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(e, i, u, c, m) {
            Xm(e, i, u, c, m, 4);
          }
          setPixel(e, i, u) {
            const c = 4 * (e * this.width + i);
            this.data[c + 0] = Math.round(255 * u.r / u.a), this.data[c + 1] = Math.round(255 * u.g / u.a), this.data[c + 2] = Math.round(255 * u.b / u.a), this.data[c + 3] = Math.round(255 * u.a);
          }
        }
        function Rv(o) {
          const e = {}, i = o.resolution || 256, u = o.clips ? o.clips.length : 1, c = o.image || new Yn({ width: i, height: u });
          if (Math.log(i) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${i}`);
          const m = (v, x, C) => {
            e[o.evaluationKey] = C;
            const k = o.expression.evaluate(e);
            c.setPixel(v / 4 / i, x / 4, k);
          };
          if (o.clips) for (let v = 0, x = 0; v < u; ++v, x += 4 * i) for (let C = 0, k = 0; C < i; C++, k += 4) {
            const E = C / (i - 1), { start: D, end: F } = o.clips[v];
            m(x, k, D * (1 - E) + F * E);
          }
          else for (let v = 0, x = 0; v < i; v++, x += 4) m(0, x, v / (i - 1));
          return c;
        }
        Lt("AlphaImage", $d), Lt("RGBAImage", Yn);
        const Ym = "big-fb";
        class U2 extends so {
          createBucket(e) {
            return new Ev(e);
          }
          constructor(e, i) {
            super(e, V2, i), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(e) {
            e === "heatmap-color" && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = Rv({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbos.has(Ym) && this.heatmapFbos.delete(Ym);
          }
          queryRadius(e) {
            return Ku("heatmap-radius", this, e);
          }
          queryIntersectsFeature({ queryGeometry: e, feature: i, featureState: u, geometry: c, transform: m, pixelsToTileUnits: v, unwrappedTileID: x, getElevation: C }) {
            return Tv({ queryGeometry: e, size: this.paint.get("heatmap-radius").evaluate(i, u) * v, transform: m, unwrappedTileID: x, getElevation: C }, c);
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
          }
        }
        let Av;
        var G2 = { get paint() {
          return Av = Av || new En({ "hillshade-illumination-direction": new Wt(se.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new Wt(se.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new Wt(se.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Wt(se.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Wt(se.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Wt(se.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Wt(se.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new Wt(se.paint_hillshade["hillshade-method"]) });
        } };
        class q2 extends so {
          constructor(e, i) {
            super(e, G2, i), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
          }
          getIlluminationProperties() {
            let e = this.paint.get("hillshade-illumination-direction").values, i = this.paint.get("hillshade-illumination-altitude").values, u = this.paint.get("hillshade-highlight-color").values, c = this.paint.get("hillshade-shadow-color").values;
            const m = Math.max(e.length, i.length, u.length, c.length);
            e = e.concat(Array(m - e.length).fill(e.at(-1))), i = i.concat(Array(m - i.length).fill(i.at(-1))), u = u.concat(Array(m - u.length).fill(u.at(-1))), c = c.concat(Array(m - c.length).fill(c.at(-1)));
            const v = i.map(rt);
            return { directionRadians: e.map(rt), altitudeRadians: v, shadowColor: c, highlightColor: u };
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
          }
        }
        let zv;
        var W2 = { get paint() {
          return zv = zv || new En({ "color-relief-opacity": new Wt(se["paint_color-relief"]["color-relief-opacity"]), "color-relief-color": new Uu(se["paint_color-relief"]["color-relief-color"]) });
        } };
        class Km {
          constructor(e, i, u, c) {
            this.context = e, this.format = u, this.texture = e.gl.createTexture(), this.update(i, c);
          }
          update(e, i, u) {
            const { width: c, height: m } = e, v = !(this.size && this.size[0] === c && this.size[1] === m || u), { context: x } = this, { gl: C } = x;
            if (this.useMipmap = !!(i && i.useMipmap), C.bindTexture(C.TEXTURE_2D, this.texture), x.pixelStoreUnpackFlipY.set(false), x.pixelStoreUnpack.set(1), x.pixelStoreUnpackPremultiplyAlpha.set(this.format === C.RGBA && (!i || i.premultiply !== false)), v) this.size = [c, m], e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || Be(e) ? C.texImage2D(C.TEXTURE_2D, 0, this.format, this.format, C.UNSIGNED_BYTE, e) : C.texImage2D(C.TEXTURE_2D, 0, this.format, c, m, 0, this.format, C.UNSIGNED_BYTE, e.data);
            else {
              const { x: k, y: E } = u || { x: 0, y: 0 };
              e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || Be(e) ? C.texSubImage2D(C.TEXTURE_2D, 0, k, E, C.RGBA, C.UNSIGNED_BYTE, e) : C.texSubImage2D(C.TEXTURE_2D, 0, k, E, c, m, C.RGBA, C.UNSIGNED_BYTE, e.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && C.generateMipmap(C.TEXTURE_2D), x.pixelStoreUnpackFlipY.setDefault(), x.pixelStoreUnpack.setDefault(), x.pixelStoreUnpackPremultiplyAlpha.setDefault();
          }
          bind(e, i, u) {
            const { context: c } = this, { gl: m } = c;
            m.bindTexture(m.TEXTURE_2D, this.texture), u !== m.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (u = m.LINEAR), e !== this.filter && (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, e), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, u || e), this.filter = e), i !== this.wrap && (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, i), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, i), this.wrap = i);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: e } = this.context;
            e.deleteTexture(this.texture), this.texture = null;
          }
        }
        class Fv {
          constructor(e, i, u, c = 1, m = 1, v = 1, x = 0) {
            if (this.uid = e, i.height !== i.width) throw new RangeError("DEM tiles must be square");
            if (u && !["mapbox", "terrarium", "custom"].includes(u)) return void Ht(`"${u}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = i.height;
            const C = this.dim = i.height - 2;
            switch (this.data = new Uint32Array(i.data.buffer), u) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = c, this.greenFactor = m, this.blueFactor = v, this.baseShift = x;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let k = 0; k < C; k++) this.data[this._idx(-1, k)] = this.data[this._idx(0, k)], this.data[this._idx(C, k)] = this.data[this._idx(C - 1, k)], this.data[this._idx(k, -1)] = this.data[this._idx(k, 0)], this.data[this._idx(k, C)] = this.data[this._idx(k, C - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(C, -1)] = this.data[this._idx(C - 1, 0)], this.data[this._idx(-1, C)] = this.data[this._idx(0, C - 1)], this.data[this._idx(C, C)] = this.data[this._idx(C - 1, C - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let k = 0; k < C; k++) for (let E = 0; E < C; E++) {
              const D = this.get(k, E);
              D > this.max && (this.max = D), D < this.min && (this.min = D);
            }
          }
          get(e, i) {
            const u = new Uint8Array(this.data.buffer), c = 4 * this._idx(e, i);
            return this.unpack(u[c], u[c + 1], u[c + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(e, i) {
            if (e < -1 || e >= this.dim + 1 || i < -1 || i >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (i + 1) * this.stride + (e + 1);
          }
          unpack(e, i, u) {
            return e * this.redFactor + i * this.greenFactor + u * this.blueFactor - this.baseShift;
          }
          pack(e) {
            return Lv(e, this.getUnpackVector());
          }
          getPixels() {
            return new Yn({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(e, i, u) {
            if (this.dim !== e.dim) throw new Error("dem dimension mismatch");
            let c = i * this.dim, m = i * this.dim + this.dim, v = u * this.dim, x = u * this.dim + this.dim;
            switch (i) {
              case -1:
                c = m - 1;
                break;
              case 1:
                m = c + 1;
            }
            switch (u) {
              case -1:
                v = x - 1;
                break;
              case 1:
                x = v + 1;
            }
            const C = -i * this.dim, k = -u * this.dim;
            for (let E = v; E < x; E++) for (let D = c; D < m; D++) this.data[this._idx(D, E)] = e.data[this._idx(D + C, E + k)];
          }
        }
        function Lv(o, e) {
          const i = e[0], u = e[1], c = e[2], m = e[3], v = Math.min(i, u, c), x = Math.round((o + m) / v);
          return { r: Math.floor(x * v / i) % 256, g: Math.floor(x * v / u) % 256, b: Math.floor(x * v / c) % 256 };
        }
        Lt("DEMData", Fv);
        class Z2 extends so {
          constructor(e, i) {
            super(e, W2, i);
          }
          _createColorRamp(e) {
            const i = { elevationStops: [], colorStops: [] }, u = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (u instanceof Za && u._styleExpression.expression instanceof rn) {
              this.colorRampExpression = u;
              const v = u._styleExpression.expression;
              i.elevationStops = v.labels, i.colorStops = [];
              for (const x of i.elevationStops) i.colorStops.push(v.evaluate({ globals: { elevation: x } }));
            }
            if (i.elevationStops.length < 1 && (i.elevationStops = [0], i.colorStops = [br.transparent]), i.elevationStops.length < 2 && (i.elevationStops.push(i.elevationStops[0] + 1), i.colorStops.push(i.colorStops[0])), i.elevationStops.length <= e) return i;
            const c = { elevationStops: [], colorStops: [] }, m = (i.elevationStops.length - 1) / (e - 1);
            for (let v = 0; v < i.elevationStops.length - 0.5; v += m) c.elevationStops.push(i.elevationStops[Math.round(v)]), c.colorStops.push(i.colorStops[Math.round(v)]);
            return Ht(`Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${e}, provided: ${i.elevationStops.length}`), c;
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
          }
          getColorRampTextures(e, i, u) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const c = this._createColorRamp(i), m = new Yn({ width: c.colorStops.length, height: 1 }), v = new Yn({ width: c.colorStops.length, height: 1 });
            for (let x = 0; x < c.elevationStops.length; x++) {
              const C = Lv(c.elevationStops[x], u);
              v.setPixel(0, x, new br(C.r / 255, C.g / 255, C.b / 255, 1)), m.setPixel(0, x, c.colorStops[x]);
            }
            return this.colorRampTextures = { elevationTexture: new Km(e, v, e.gl.RGBA), colorTexture: new Km(e, m, e.gl.RGBA) }, this.colorRampTextures;
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures;
          }
        }
        const H2 = Xr([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: X2 } = H2;
        function Hf(o, e, i) {
          const u = i.patternDependencies;
          let c = false;
          for (const m of e) {
            const v = m.paint.get(`${o}-pattern`);
            v.isConstant() || (c = true);
            const x = v.constantOr(null);
            x && (c = true, u[x.to] = true, u[x.from] = true);
          }
          return c;
        }
        function Jm(o, e, i, u, c) {
          const { zoom: m } = u, v = c.patternDependencies;
          for (const x of e) {
            const C = x.paint.get(`${o}-pattern`).value;
            if (C.kind !== "constant") {
              let k = C.evaluate({ zoom: m - 1 }, i, {}, c.availableImages), E = C.evaluate({ zoom: m }, i, {}, c.availableImages), D = C.evaluate({ zoom: m + 1 }, i, {}, c.availableImages);
              k = k && k.name ? k.name : k, E = E && E.name ? E.name : E, D = D && D.name ? D.name : D, v[k] = true, v[E] = true, v[D] = true, i.patterns[x.id] = { min: k, mid: E, max: D };
            }
          }
          return i;
        }
        function Bv(o, e, i, u, c) {
          let m;
          if (c === (function(v, x, C, k) {
            let E = 0;
            for (let D = x, F = C - k; D < C; D += k) E += (v[F] - v[D]) * (v[D + 1] + v[F + 1]), F = D;
            return E;
          })(o, e, i, u) > 0) for (let v = e; v < i; v += u) m = jv(v / u | 0, o[v], o[v + 1], m);
          else for (let v = i - u; v >= e; v -= u) m = jv(v / u | 0, o[v], o[v + 1], m);
          return m && Ju(m, m.next) && (Ud(m), m = m.next), m;
        }
        function Ml(o, e) {
          if (!o) return o;
          e || (e = o);
          let i, u = o;
          do
            if (i = false, u.steiner || !Ju(u, u.next) && Pi(u.prev, u, u.next) !== 0) u = u.next;
            else {
              if (Ud(u), u = e = u.prev, u === u.next) break;
              i = true;
            }
          while (i || u !== e);
          return e;
        }
        function Nd(o, e, i, u, c, m, v) {
          if (!o) return;
          !v && m && (function(C, k, E, D) {
            let F = C;
            do
              F.z === 0 && (F.z = Qm(F.x, F.y, k, E, D)), F.prevZ = F.prev, F.nextZ = F.next, F = F.next;
            while (F !== C);
            F.prevZ.nextZ = null, F.prevZ = null, (function(V) {
              let G, H = 1;
              do {
                let Y, ie = V;
                V = null;
                let we = null;
                for (G = 0; ie; ) {
                  G++;
                  let ce = ie, pe = 0;
                  for (let Oe = 0; Oe < H && (pe++, ce = ce.nextZ, ce); Oe++) ;
                  let Te = H;
                  for (; pe > 0 || Te > 0 && ce; ) pe !== 0 && (Te === 0 || !ce || ie.z <= ce.z) ? (Y = ie, ie = ie.nextZ, pe--) : (Y = ce, ce = ce.nextZ, Te--), we ? we.nextZ = Y : V = Y, Y.prevZ = we, we = Y;
                  ie = ce;
                }
                we.nextZ = null, H *= 2;
              } while (G > 1);
            })(F);
          })(o, u, c, m);
          let x = o;
          for (; o.prev !== o.next; ) {
            const C = o.prev, k = o.next;
            if (m ? K2(o, u, c, m) : Y2(o)) e.push(C.i, o.i, k.i), Ud(o), o = k.next, x = k.next;
            else if ((o = k) === x) {
              v ? v === 1 ? Nd(o = J2(Ml(o), e), e, i, u, c, m, 2) : v === 2 && Q2(o, e, i, u, c, m) : Nd(Ml(o), e, i, u, c, m, 1);
              break;
            }
          }
        }
        function Y2(o) {
          const e = o.prev, i = o, u = o.next;
          if (Pi(e, i, u) >= 0) return false;
          const c = e.x, m = i.x, v = u.x, x = e.y, C = i.y, k = u.y, E = Math.min(c, m, v), D = Math.min(x, C, k), F = Math.max(c, m, v), V = Math.max(x, C, k);
          let G = u.next;
          for (; G !== e; ) {
            if (G.x >= E && G.x <= F && G.y >= D && G.y <= V && jd(c, x, m, C, v, k, G.x, G.y) && Pi(G.prev, G, G.next) >= 0) return false;
            G = G.next;
          }
          return true;
        }
        function K2(o, e, i, u) {
          const c = o.prev, m = o, v = o.next;
          if (Pi(c, m, v) >= 0) return false;
          const x = c.x, C = m.x, k = v.x, E = c.y, D = m.y, F = v.y, V = Math.min(x, C, k), G = Math.min(E, D, F), H = Math.max(x, C, k), Y = Math.max(E, D, F), ie = Qm(V, G, e, i, u), we = Qm(H, Y, e, i, u);
          let ce = o.prevZ, pe = o.nextZ;
          for (; ce && ce.z >= ie && pe && pe.z <= we; ) {
            if (ce.x >= V && ce.x <= H && ce.y >= G && ce.y <= Y && ce !== c && ce !== v && jd(x, E, C, D, k, F, ce.x, ce.y) && Pi(ce.prev, ce, ce.next) >= 0 || (ce = ce.prevZ, pe.x >= V && pe.x <= H && pe.y >= G && pe.y <= Y && pe !== c && pe !== v && jd(x, E, C, D, k, F, pe.x, pe.y) && Pi(pe.prev, pe, pe.next) >= 0)) return false;
            pe = pe.nextZ;
          }
          for (; ce && ce.z >= ie; ) {
            if (ce.x >= V && ce.x <= H && ce.y >= G && ce.y <= Y && ce !== c && ce !== v && jd(x, E, C, D, k, F, ce.x, ce.y) && Pi(ce.prev, ce, ce.next) >= 0) return false;
            ce = ce.prevZ;
          }
          for (; pe && pe.z <= we; ) {
            if (pe.x >= V && pe.x <= H && pe.y >= G && pe.y <= Y && pe !== c && pe !== v && jd(x, E, C, D, k, F, pe.x, pe.y) && Pi(pe.prev, pe, pe.next) >= 0) return false;
            pe = pe.nextZ;
          }
          return true;
        }
        function J2(o, e) {
          let i = o;
          do {
            const u = i.prev, c = i.next.next;
            !Ju(u, c) && $v(u, i, i.next, c) && Vd(u, c) && Vd(c, u) && (e.push(u.i, i.i, c.i), Ud(i), Ud(i.next), i = o = c), i = i.next;
          } while (i !== o);
          return Ml(i);
        }
        function Q2(o, e, i, u, c, m) {
          let v = o;
          do {
            let x = v.next.next;
            for (; x !== v.prev; ) {
              if (v.i !== x.i && nw(v, x)) {
                let C = Nv(v, x);
                return v = Ml(v, v.next), C = Ml(C, C.next), Nd(v, e, i, u, c, m, 0), void Nd(C, e, i, u, c, m, 0);
              }
              x = x.next;
            }
            v = v.next;
          } while (v !== o);
        }
        function ew(o, e) {
          let i = o.x - e.x;
          return i === 0 && (i = o.y - e.y, i === 0) && (i = (o.next.y - o.y) / (o.next.x - o.x) - (e.next.y - e.y) / (e.next.x - e.x)), i;
        }
        function tw(o, e) {
          const i = (function(c, m) {
            let v = m;
            const x = c.x, C = c.y;
            let k, E = -1 / 0;
            if (Ju(c, v)) return v;
            do {
              if (Ju(c, v.next)) return v.next;
              if (C <= v.y && C >= v.next.y && v.next.y !== v.y) {
                const H = v.x + (C - v.y) * (v.next.x - v.x) / (v.next.y - v.y);
                if (H <= x && H > E && (E = H, k = v.x < v.next.x ? v : v.next, H === x)) return k;
              }
              v = v.next;
            } while (v !== m);
            if (!k) return null;
            const D = k, F = k.x, V = k.y;
            let G = 1 / 0;
            v = k;
            do {
              if (x >= v.x && v.x >= F && x !== v.x && Ov(C < V ? x : E, C, F, V, C < V ? E : x, C, v.x, v.y)) {
                const H = Math.abs(C - v.y) / (x - v.x);
                Vd(v, c) && (H < G || H === G && (v.x > k.x || v.x === k.x && rw(k, v))) && (k = v, G = H);
              }
              v = v.next;
            } while (v !== D);
            return k;
          })(o, e);
          if (!i) return e;
          const u = Nv(i, o);
          return Ml(u, u.next), Ml(i, i.next);
        }
        function rw(o, e) {
          return Pi(o.prev, o, e.prev) < 0 && Pi(e.next, o, o.next) < 0;
        }
        function Qm(o, e, i, u, c) {
          return (o = 1431655765 & ((o = 858993459 & ((o = 252645135 & ((o = 16711935 & ((o = (o - i) * c | 0) | o << 8)) | o << 4)) | o << 2)) | o << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - u) * c | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
        }
        function iw(o) {
          let e = o, i = o;
          do
            (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next;
          while (e !== o);
          return i;
        }
        function Ov(o, e, i, u, c, m, v, x) {
          return (c - v) * (e - x) >= (o - v) * (m - x) && (o - v) * (u - x) >= (i - v) * (e - x) && (i - v) * (m - x) >= (c - v) * (u - x);
        }
        function jd(o, e, i, u, c, m, v, x) {
          return !(o === v && e === x) && Ov(o, e, i, u, c, m, v, x);
        }
        function nw(o, e) {
          return o.next.i !== e.i && o.prev.i !== e.i && !(function(i, u) {
            let c = i;
            do {
              if (c.i !== i.i && c.next.i !== i.i && c.i !== u.i && c.next.i !== u.i && $v(c, c.next, i, u)) return true;
              c = c.next;
            } while (c !== i);
            return false;
          })(o, e) && (Vd(o, e) && Vd(e, o) && (function(i, u) {
            let c = i, m = false;
            const v = (i.x + u.x) / 2, x = (i.y + u.y) / 2;
            do
              c.y > x != c.next.y > x && c.next.y !== c.y && v < (c.next.x - c.x) * (x - c.y) / (c.next.y - c.y) + c.x && (m = !m), c = c.next;
            while (c !== i);
            return m;
          })(o, e) && (Pi(o.prev, o, e.prev) || Pi(o, e.prev, e)) || Ju(o, e) && Pi(o.prev, o, o.next) > 0 && Pi(e.prev, e, e.next) > 0);
        }
        function Pi(o, e, i) {
          return (e.y - o.y) * (i.x - e.x) - (e.x - o.x) * (i.y - e.y);
        }
        function Ju(o, e) {
          return o.x === e.x && o.y === e.y;
        }
        function $v(o, e, i, u) {
          const c = Yf(Pi(o, e, i)), m = Yf(Pi(o, e, u)), v = Yf(Pi(i, u, o)), x = Yf(Pi(i, u, e));
          return c !== m && v !== x || !(c !== 0 || !Xf(o, i, e)) || !(m !== 0 || !Xf(o, u, e)) || !(v !== 0 || !Xf(i, o, u)) || !(x !== 0 || !Xf(i, e, u));
        }
        function Xf(o, e, i) {
          return e.x <= Math.max(o.x, i.x) && e.x >= Math.min(o.x, i.x) && e.y <= Math.max(o.y, i.y) && e.y >= Math.min(o.y, i.y);
        }
        function Yf(o) {
          return o > 0 ? 1 : o < 0 ? -1 : 0;
        }
        function Vd(o, e) {
          return Pi(o.prev, o, o.next) < 0 ? Pi(o, e, o.next) >= 0 && Pi(o, o.prev, e) >= 0 : Pi(o, e, o.prev) < 0 || Pi(o, o.next, e) < 0;
        }
        function Nv(o, e) {
          const i = eg(o.i, o.x, o.y), u = eg(e.i, e.x, e.y), c = o.next, m = e.prev;
          return o.next = e, e.prev = o, i.next = c, c.prev = i, u.next = i, i.prev = u, m.next = u, u.prev = m, u;
        }
        function jv(o, e, i, u) {
          const c = eg(o, e, i);
          return u ? (c.next = u.next, c.prev = u, u.next.prev = c, u.next = c) : (c.prev = c, c.next = c), c;
        }
        function Ud(o) {
          o.next.prev = o.prev, o.prev.next = o.next, o.prevZ && (o.prevZ.nextZ = o.nextZ), o.nextZ && (o.nextZ.prevZ = o.prevZ);
        }
        function eg(o, e, i) {
          return { i: o, x: e, y: i, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
        }
        class Qu {
          constructor(e, i) {
            if (i > e) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = e, this._minGranularity = i;
          }
          getGranularityForZoomLevel(e) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << e)), this._minGranularity, 1);
          }
        }
        class Kf {
          constructor(e) {
            this.fill = e.fill, this.line = e.line, this.tile = e.tile, this.stencil = e.stencil, this.circle = e.circle;
          }
        }
        Kf.noSubdivision = new Kf({ fill: new Qu(0, 0), line: new Qu(0, 0), tile: new Qu(0, 0), stencil: new Qu(0, 0), circle: 1 }), Lt("SubdivisionGranularityExpression", Qu), Lt("SubdivisionGranularitySetting", Kf);
        const ec = -32768, Gd = 32767;
        class ow {
          constructor(e, i) {
            this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = false, this._granularity = e, this._granularityCellSize = it / e, this._canonical = i;
          }
          _getKey(e, i) {
            return (e += 32768) << 16 | i + 32768;
          }
          _vertexToIndex(e, i) {
            if (e < -32768 || i < -32768 || e > 32767 || i > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const u = 0 | Math.round(e), c = 0 | Math.round(i), m = this._getKey(u, c);
            if (this._vertexDictionary.has(m)) return this._vertexDictionary.get(m);
            const v = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(m, v), this._vertexBuffer.push(u, c), v;
          }
          _subdivideTrianglesScanline(e) {
            if (this._granularity < 2) return (function(c, m) {
              const v = [];
              for (let x = 0; x < m.length; x += 3) {
                const C = m[x], k = m[x + 1], E = m[x + 2], D = c[2 * C], F = c[2 * C + 1];
                (c[2 * k] - D) * (c[2 * E + 1] - F) - (c[2 * k + 1] - F) * (c[2 * E] - D) > 0 ? (v.push(C), v.push(E), v.push(k)) : (v.push(C), v.push(k), v.push(E));
              }
              return v;
            })(this._vertexBuffer, e);
            const i = [], u = e.length;
            for (let c = 0; c < u; c += 3) {
              const m = [e[c + 0], e[c + 1], e[c + 2]], v = [this._vertexBuffer[2 * e[c + 0] + 0], this._vertexBuffer[2 * e[c + 0] + 1], this._vertexBuffer[2 * e[c + 1] + 0], this._vertexBuffer[2 * e[c + 1] + 1], this._vertexBuffer[2 * e[c + 2] + 0], this._vertexBuffer[2 * e[c + 2] + 1]];
              let x = 1 / 0, C = 1 / 0, k = -1 / 0, E = -1 / 0;
              for (let H = 0; H < 3; H++) {
                const Y = v[2 * H], ie = v[2 * H + 1];
                x = Math.min(x, Y), k = Math.max(k, Y), C = Math.min(C, ie), E = Math.max(E, ie);
              }
              if (x === k || C === E) continue;
              const D = Math.floor(x / this._granularityCellSize), F = Math.ceil(k / this._granularityCellSize), V = Math.floor(C / this._granularityCellSize), G = Math.ceil(E / this._granularityCellSize);
              if (D !== F || V !== G) for (let H = V; H < G; H++) {
                const Y = this._scanlineGenerateVertexRingForCellRow(H, v, m);
                aw(this._vertexBuffer, Y, i);
              }
              else i.push(...m);
            }
            return i;
          }
          _scanlineGenerateVertexRingForCellRow(e, i, u) {
            const c = e * this._granularityCellSize, m = c + this._granularityCellSize, v = [];
            for (let x = 0; x < 3; x++) {
              const C = i[2 * x], k = i[2 * x + 1], E = i[2 * (x + 1) % 6], D = i[(2 * (x + 1) + 1) % 6], F = i[2 * (x + 2) % 6], V = i[(2 * (x + 2) + 1) % 6], G = E - C, H = D - k, Y = G === 0, ie = H === 0, we = (c - k) / H, ce = (m - k) / H, pe = Math.min(we, ce), Te = Math.max(we, ce);
              if (!ie && (pe >= 1 || Te <= 0) || ie && (k < c || k > m)) {
                D >= c && D <= m && v.push(u[(x + 1) % 3]);
                continue;
              }
              !ie && pe > 0 && v.push(this._vertexToIndex(C + G * pe, k + H * pe));
              const Oe = C + G * Math.max(pe, 0), Xe = C + G * Math.min(Te, 1);
              Y || this._generateIntraEdgeVertices(v, C, k, E, D, Oe, Xe), !ie && Te < 1 && v.push(this._vertexToIndex(C + G * Te, k + H * Te)), (ie || D >= c && D <= m) && v.push(u[(x + 1) % 3]), !ie && (D <= c || D >= m) && this._generateInterEdgeVertices(v, C, k, E, D, F, V, Xe, c, m);
            }
            return v;
          }
          _generateIntraEdgeVertices(e, i, u, c, m, v, x) {
            const C = c - i, k = m - u, E = k === 0, D = E ? Math.min(i, c) : Math.min(v, x), F = E ? Math.max(i, c) : Math.max(v, x), V = Math.floor(D / this._granularityCellSize) + 1, G = Math.ceil(F / this._granularityCellSize) - 1;
            if (E ? i < c : v < x) for (let H = V; H <= G; H++) {
              const Y = H * this._granularityCellSize;
              e.push(this._vertexToIndex(Y, u + k * (Y - i) / C));
            }
            else for (let H = G; H >= V; H--) {
              const Y = H * this._granularityCellSize;
              e.push(this._vertexToIndex(Y, u + k * (Y - i) / C));
            }
          }
          _generateInterEdgeVertices(e, i, u, c, m, v, x, C, k, E) {
            const D = m - u, F = v - c, V = x - m, G = (k - m) / V, H = (E - m) / V, Y = Math.min(G, H), ie = Math.max(G, H), we = c + F * Y;
            let ce = Math.floor(Math.min(we, C) / this._granularityCellSize) + 1, pe = Math.ceil(Math.max(we, C) / this._granularityCellSize) - 1, Te = C < we;
            const Oe = V === 0;
            if (Oe && (x === k || x === E)) return;
            if (Oe || Y >= 1 || ie <= 0) {
              const yt = u - x, ft = v + (i - v) * Math.min((k - x) / yt, (E - x) / yt);
              ce = Math.floor(Math.min(ft, C) / this._granularityCellSize) + 1, pe = Math.ceil(Math.max(ft, C) / this._granularityCellSize) - 1, Te = C < ft;
            }
            const Xe = D > 0 ? E : k;
            if (Te) for (let yt = ce; yt <= pe; yt++) e.push(this._vertexToIndex(yt * this._granularityCellSize, Xe));
            else for (let yt = pe; yt >= ce; yt--) e.push(this._vertexToIndex(yt * this._granularityCellSize, Xe));
          }
          _generateOutline(e) {
            const i = [];
            for (const u of e) {
              const c = Dl(u, this._granularity, true), m = this._pointArrayToIndices(c), v = [];
              for (let x = 1; x < m.length; x++) v.push(m[x - 1]), v.push(m[x]);
              i.push(v);
            }
            return i;
          }
          _handlePoles(e) {
            let i = false, u = false;
            this._canonical && (this._canonical.y === 0 && (i = true), this._canonical.y === (1 << this._canonical.z) - 1 && (u = true)), (i || u) && this._fillPoles(e, i, u);
          }
          _ensureNoPoleVertices() {
            const e = this._vertexBuffer;
            for (let i = 0; i < e.length; i += 2) {
              const u = e[i + 1];
              u === ec && (e[i + 1] = -32767), u === Gd && (e[i + 1] = 32766);
            }
          }
          _generatePoleQuad(e, i, u, c, m, v) {
            c > m != (v === ec) ? (e.push(i), e.push(u), e.push(this._vertexToIndex(c, v)), e.push(u), e.push(this._vertexToIndex(m, v)), e.push(this._vertexToIndex(c, v))) : (e.push(u), e.push(i), e.push(this._vertexToIndex(c, v)), e.push(this._vertexToIndex(m, v)), e.push(u), e.push(this._vertexToIndex(c, v)));
          }
          _fillPoles(e, i, u) {
            const c = this._vertexBuffer, m = it, v = e.length;
            for (let x = 2; x < v; x += 3) {
              const C = e[x - 2], k = e[x - 1], E = e[x], D = c[2 * C], F = c[2 * C + 1], V = c[2 * k], G = c[2 * k + 1], H = c[2 * E], Y = c[2 * E + 1];
              i && (F === 0 && G === 0 && this._generatePoleQuad(e, C, k, D, V, ec), G === 0 && Y === 0 && this._generatePoleQuad(e, k, E, V, H, ec), Y === 0 && F === 0 && this._generatePoleQuad(e, E, C, H, D, ec)), u && (F === m && G === m && this._generatePoleQuad(e, C, k, D, V, Gd), G === m && Y === m && this._generatePoleQuad(e, k, E, V, H, Gd), Y === m && F === m && this._generatePoleQuad(e, E, C, H, D, Gd));
            }
          }
          _initializeVertices(e) {
            for (let i = 0; i < e.length; i += 2) this._vertexToIndex(e[i], e[i + 1]);
          }
          subdividePolygonInternal(e, i) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = true;
            const { flattened: u, holeIndices: c } = (function(x) {
              const C = [], k = [];
              for (const E of x) if (E.length !== 0) {
                E !== x[0] && C.push(k.length / 2);
                for (let D = 0; D < E.length; D++) k.push(E[D].x), k.push(E[D].y);
              }
              return { flattened: k, holeIndices: C };
            })(e);
            let m;
            this._initializeVertices(u);
            try {
              const x = (function(k, E, D = 2) {
                const F = E && E.length, V = F ? E[0] * D : k.length;
                let G = Bv(k, 0, V, D, true);
                const H = [];
                if (!G || G.next === G.prev) return H;
                let Y, ie, we;
                if (F && (G = (function(ce, pe, Te, Oe) {
                  const Xe = [];
                  for (let yt = 0, ft = pe.length; yt < ft; yt++) {
                    const wt = Bv(ce, pe[yt] * Oe, yt < ft - 1 ? pe[yt + 1] * Oe : ce.length, Oe, false);
                    wt === wt.next && (wt.steiner = true), Xe.push(iw(wt));
                  }
                  Xe.sort(ew);
                  for (let yt = 0; yt < Xe.length; yt++) Te = tw(Xe[yt], Te);
                  return Te;
                })(k, E, G, D)), k.length > 80 * D) {
                  Y = k[0], ie = k[1];
                  let ce = Y, pe = ie;
                  for (let Te = D; Te < V; Te += D) {
                    const Oe = k[Te], Xe = k[Te + 1];
                    Oe < Y && (Y = Oe), Xe < ie && (ie = Xe), Oe > ce && (ce = Oe), Xe > pe && (pe = Xe);
                  }
                  we = Math.max(ce - Y, pe - ie), we = we !== 0 ? 32767 / we : 0;
                }
                return Nd(G, H, D, Y, ie, we, 0), H;
              })(u, c), C = this._convertIndices(u, x);
              m = this._subdivideTrianglesScanline(C);
            } catch (x) {
              console.error(x);
            }
            let v = [];
            return i && (v = this._generateOutline(e)), this._ensureNoPoleVertices(), this._handlePoles(m), { verticesFlattened: this._vertexBuffer, indicesTriangles: m, indicesLineList: v };
          }
          _convertIndices(e, i) {
            const u = [];
            for (let c = 0; c < i.length; c++) u.push(this._vertexToIndex(e[2 * i[c]], e[2 * i[c] + 1]));
            return u;
          }
          _pointArrayToIndices(e) {
            const i = [];
            for (let u = 0; u < e.length; u++) {
              const c = e[u];
              i.push(this._vertexToIndex(c.x, c.y));
            }
            return i;
          }
        }
        function Vv(o, e, i, u = true) {
          return new ow(i, e).subdividePolygonInternal(o, u);
        }
        function Dl(o, e, i = false) {
          if (!o || o.length < 1) return [];
          if (o.length < 2) return [];
          const u = o[0], c = o[o.length - 1], m = i && (u.x !== c.x || u.y !== c.y);
          if (e < 2) return m ? [...o, o[0]] : [...o];
          const v = Math.floor(it / e), x = [];
          x.push(new S(o[0].x, o[0].y));
          const C = o.length, k = m ? C : C - 1;
          for (let E = 0; E < k; E++) {
            const D = o[E], F = E < C - 1 ? o[E + 1] : o[0], V = D.x, G = D.y, H = F.x, Y = F.y, ie = V !== H, we = G !== Y;
            if (!ie && !we) continue;
            const ce = H - V, pe = Y - G, Te = Math.abs(ce), Oe = Math.abs(pe);
            let Xe = V, yt = G;
            for (; ; ) {
              const wt = ce > 0 ? (Math.floor(Xe / v) + 1) * v : (Math.ceil(Xe / v) - 1) * v, Rt = pe > 0 ? (Math.floor(yt / v) + 1) * v : (Math.ceil(yt / v) - 1) * v, Et = Math.abs(Xe - wt), Mt = Math.abs(yt - Rt), lt = Math.abs(Xe - H), rr = Math.abs(yt - Y), Qt = ie ? Et / Te : Number.POSITIVE_INFINITY, tr = we ? Mt / Oe : Number.POSITIVE_INFINITY;
              if ((lt <= Et || !ie) && (rr <= Mt || !we)) break;
              if (Qt < tr && ie || !we) {
                Xe = wt, yt += pe * Qt;
                const Vt = new S(Xe, Math.round(yt));
                x[x.length - 1].x === Vt.x && x[x.length - 1].y === Vt.y || x.push(Vt);
              } else {
                Xe += ce * tr, yt = Rt;
                const Vt = new S(Math.round(Xe), yt);
                x[x.length - 1].x === Vt.x && x[x.length - 1].y === Vt.y || x.push(Vt);
              }
            }
            const ft = new S(H, Y);
            x[x.length - 1].x === ft.x && x[x.length - 1].y === ft.y || x.push(ft);
          }
          return x;
        }
        function aw(o, e, i) {
          if (e.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let u = 0, c = o[2 * e[0]];
          for (let C = 1; C < e.length; C++) {
            const k = o[2 * e[C]];
            k < c && (c = k, u = C);
          }
          const m = e.length;
          let v = u, x = (v + 1) % m;
          for (; ; ) {
            const C = v - 1 >= 0 ? v - 1 : m - 1, k = (x + 1) % m, E = o[2 * e[C]], D = o[2 * e[k]], F = o[2 * e[v]], V = o[2 * e[v] + 1], G = o[2 * e[x] + 1];
            let H = false;
            if (E < D) H = true;
            else if (E > D) H = false;
            else {
              const Y = G - V, ie = -(o[2 * e[x]] - F), we = V < G ? 1 : -1;
              ((E - F) * Y + (o[2 * e[C] + 1] - V) * ie) * we > ((D - F) * Y + (o[2 * e[k] + 1] - V) * ie) * we && (H = true);
            }
            if (H) {
              const Y = e[C], ie = e[v], we = e[x];
              Y !== ie && Y !== we && ie !== we && i.push(we, ie, Y), v--, v < 0 && (v = m - 1);
            } else {
              const Y = e[k], ie = e[v], we = e[x];
              Y !== ie && Y !== we && ie !== we && i.push(we, ie, Y), x++, x >= m && (x = 0);
            }
            if (C === k) break;
          }
        }
        function Uv(o, e, i, u, c, m, v, x, C) {
          const k = c.length / 2, E = v && x && C;
          if (k < Yt.MAX_VERTEX_ARRAY_LENGTH) {
            const D = e.prepareSegment(k, i, u), F = D.vertexLength;
            for (let H = 0; H < m.length; H += 3) u.emplaceBack(F + m[H], F + m[H + 1], F + m[H + 2]);
            let V, G;
            D.vertexLength += k, D.primitiveLength += m.length / 3, E && (G = v.prepareSegment(k, i, x), V = G.vertexLength, G.vertexLength += k);
            for (let H = 0; H < c.length; H += 2) o(c[H], c[H + 1]);
            if (E) for (let H = 0; H < C.length; H++) {
              const Y = C[H];
              for (let ie = 1; ie < Y.length; ie += 2) x.emplaceBack(V + Y[ie - 1], V + Y[ie]);
              G.primitiveLength += Y.length / 2;
            }
          } else (function(D, F, V, G, H, Y) {
            const ie = [];
            for (let Oe = 0; Oe < G.length / 2; Oe++) ie.push(-1);
            const we = { count: 0 };
            let ce = 0, pe = D.getOrCreateLatestSegment(F, V), Te = pe.vertexLength;
            for (let Oe = 2; Oe < H.length; Oe += 3) {
              const Xe = H[Oe - 2], yt = H[Oe - 1], ft = H[Oe];
              let wt = ie[Xe] < ce, Rt = ie[yt] < ce, Et = ie[ft] < ce;
              pe.vertexLength + ((wt ? 1 : 0) + (Rt ? 1 : 0) + (Et ? 1 : 0)) > Yt.MAX_VERTEX_ARRAY_LENGTH && (pe = D.createNewSegment(F, V), ce = we.count, wt = true, Rt = true, Et = true, Te = 0);
              const Mt = qd(ie, G, Y, we, Xe, wt, pe), lt = qd(ie, G, Y, we, yt, Rt, pe), rr = qd(ie, G, Y, we, ft, Et, pe);
              V.emplaceBack(Te + Mt - ce, Te + lt - ce, Te + rr - ce), pe.primitiveLength++;
            }
          })(e, i, u, c, m, o), E && (function(D, F, V, G, H, Y) {
            const ie = [];
            for (let Oe = 0; Oe < G.length / 2; Oe++) ie.push(-1);
            const we = { count: 0 };
            let ce = 0, pe = D.getOrCreateLatestSegment(F, V), Te = pe.vertexLength;
            for (let Oe = 0; Oe < H.length; Oe++) {
              const Xe = H[Oe];
              for (let yt = 1; yt < H[Oe].length; yt += 2) {
                const ft = Xe[yt - 1], wt = Xe[yt];
                let Rt = ie[ft] < ce, Et = ie[wt] < ce;
                pe.vertexLength + ((Rt ? 1 : 0) + (Et ? 1 : 0)) > Yt.MAX_VERTEX_ARRAY_LENGTH && (pe = D.createNewSegment(F, V), ce = we.count, Rt = true, Et = true, Te = 0);
                const Mt = qd(ie, G, Y, we, ft, Rt, pe), lt = qd(ie, G, Y, we, wt, Et, pe);
                V.emplaceBack(Te + Mt - ce, Te + lt - ce), pe.primitiveLength++;
              }
            }
          })(v, i, x, c, C, o), e.forceNewSegmentOnNextPrepare(), v == null ? void 0 : v.forceNewSegmentOnNextPrepare();
        }
        function qd(o, e, i, u, c, m, v) {
          if (m) {
            const x = u.count;
            return i(e[2 * c], e[2 * c + 1]), o[c] = u.count, u.count++, v.vertexLength++, x;
          }
          return o[c];
        }
        class tg {
          constructor(e) {
            this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(((i) => i.id)), this.index = e.index, this.hasDependencies = false, this.patternFeatures = [], this.layoutVertexArray = new Ce(), this.indexArray = new Tt(), this.indexArray2 = new It(), this.programConfigurations = new Qa(e.layers, e.zoom), this.segments = new Yt(), this.segments2 = new Yt(), this.stateDependentLayerIds = this.layers.filter(((i) => i.isStateDependent())).map(((i) => i.id));
          }
          populate(e, i, u) {
            this.hasDependencies = Hf("fill", this.layers, i);
            const c = this.layers[0].layout.get("fill-sort-key"), m = !c.isConstant(), v = [];
            for (const { feature: x, id: C, index: k, sourceLayerIndex: E } of e) {
              const D = this.layers[0]._featureFilter.needGeometry, F = Pa(x, D);
              if (!this.layers[0]._featureFilter.filter(new qr(this.zoom), F, u)) continue;
              const V = m ? c.evaluate(F, {}, u, i.availableImages) : void 0, G = { id: C, properties: x.properties, type: x.type, sourceLayerIndex: E, index: k, geometry: D ? F.geometry : Ta(x), patterns: {}, sortKey: V };
              v.push(G);
            }
            m && v.sort(((x, C) => x.sortKey - C.sortKey));
            for (const x of v) {
              const { geometry: C, index: k, sourceLayerIndex: E } = x;
              if (this.hasDependencies) {
                const D = Jm("fill", this.layers, x, { zoom: this.zoom }, i);
                this.patternFeatures.push(D);
              } else this.addFeature(x, C, k, u, {}, i.subdivisionGranularity);
              i.featureIndex.insert(e[k].feature, C, k, E, this.index);
            }
          }
          update(e, i, u) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, i, this.stateDependentLayers, { imagePositions: u });
          }
          addFeatures(e, i, u) {
            for (const c of this.patternFeatures) this.addFeature(c, c.geometry, c.index, i, u, e.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, X2), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(e, i, u, c, m, v) {
            for (const x of sl(i, 500)) {
              const C = Vv(x, c, v.fill.getGranularityForZoomLevel(c.z)), k = this.layoutVertexArray;
              Uv(((E, D) => {
                k.emplaceBack(E, D);
              }), this.segments, this.layoutVertexArray, this.indexArray, C.verticesFlattened, C.indicesTriangles, this.segments2, this.indexArray2, C.indicesLineList);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, u, { imagePositions: m, canonical: c });
          }
        }
        let Gv, qv;
        Lt("FillBucket", tg, { omit: ["layers", "patternFeatures"] });
        var sw = { get paint() {
          return qv = qv || new En({ "fill-antialias": new Wt(se.paint_fill["fill-antialias"]), "fill-opacity": new or(se.paint_fill["fill-opacity"]), "fill-color": new or(se.paint_fill["fill-color"]), "fill-outline-color": new or(se.paint_fill["fill-outline-color"]), "fill-translate": new Wt(se.paint_fill["fill-translate"]), "fill-translate-anchor": new Wt(se.paint_fill["fill-translate-anchor"]), "fill-pattern": new Cl(se.paint_fill["fill-pattern"]) });
        }, get layout() {
          return Gv = Gv || new En({ "fill-sort-key": new or(se.layout_fill["fill-sort-key"]) });
        } };
        class lw extends so {
          constructor(e, i) {
            super(e, sw, i);
          }
          recalculate(e, i) {
            super.recalculate(e, i);
            const u = this.paint._values["fill-outline-color"];
            u.value.kind === "constant" && u.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(e) {
            return new tg(e);
          }
          queryRadius() {
            return Wf(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature({ queryGeometry: e, geometry: i, transform: u, pixelsToTileUnits: c }) {
            return Cv(Zf(e, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -u.bearingInRadians, c), i);
          }
          isTileClipped() {
            return true;
          }
        }
        const uw = Xr([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), cw = Xr([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: dw } = uw;
        class tc {
          constructor(e, i, u, c, m) {
            this.properties = {}, this.extent = u, this.type = 0, this.id = void 0, this._pbf = e, this._geometry = -1, this._keys = c, this._values = m, e.readFields(hw, this, i);
          }
          loadGeometry() {
            const e = this._pbf;
            e.pos = this._geometry;
            const i = e.readVarint() + e.pos, u = [];
            let c, m = 1, v = 0, x = 0, C = 0;
            for (; e.pos < i; ) {
              if (v <= 0) {
                const k = e.readVarint();
                m = 7 & k, v = k >> 3;
              }
              if (v--, m === 1 || m === 2) x += e.readSVarint(), C += e.readSVarint(), m === 1 && (c && u.push(c), c = []), c && c.push(new S(x, C));
              else {
                if (m !== 7) throw new Error(`unknown command ${m}`);
                c && c.push(c[0].clone());
              }
            }
            return c && u.push(c), u;
          }
          bbox() {
            const e = this._pbf;
            e.pos = this._geometry;
            const i = e.readVarint() + e.pos;
            let u = 1, c = 0, m = 0, v = 0, x = 1 / 0, C = -1 / 0, k = 1 / 0, E = -1 / 0;
            for (; e.pos < i; ) {
              if (c <= 0) {
                const D = e.readVarint();
                u = 7 & D, c = D >> 3;
              }
              if (c--, u === 1 || u === 2) m += e.readSVarint(), v += e.readSVarint(), m < x && (x = m), m > C && (C = m), v < k && (k = v), v > E && (E = v);
              else if (u !== 7) throw new Error(`unknown command ${u}`);
            }
            return [x, k, C, E];
          }
          toGeoJSON(e, i, u) {
            const c = this.extent * Math.pow(2, u), m = this.extent * e, v = this.extent * i, x = this.loadGeometry();
            function C(F) {
              return [360 * (F.x + m) / c - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (F.y + v) / c) * Math.PI)) - 90];
            }
            function k(F) {
              return F.map(C);
            }
            let E;
            if (this.type === 1) {
              const F = [];
              for (const G of x) F.push(G[0]);
              const V = k(F);
              E = F.length === 1 ? { type: "Point", coordinates: V[0] } : { type: "MultiPoint", coordinates: V };
            } else if (this.type === 2) {
              const F = x.map(k);
              E = F.length === 1 ? { type: "LineString", coordinates: F[0] } : { type: "MultiLineString", coordinates: F };
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const F = (function(G) {
                  const H = G.length;
                  if (H <= 1) return [G];
                  const Y = [];
                  let ie, we;
                  for (let ce = 0; ce < H; ce++) {
                    const pe = fw(G[ce]);
                    pe !== 0 && (we === void 0 && (we = pe < 0), we === pe < 0 ? (ie && Y.push(ie), ie = [G[ce]]) : ie && ie.push(G[ce]));
                  }
                  return ie && Y.push(ie), Y;
                })(x), V = [];
                for (const G of F) V.push(G.map(k));
                E = V.length === 1 ? { type: "Polygon", coordinates: V[0] } : { type: "MultiPolygon", coordinates: V };
              }
            }
            const D = { type: "Feature", geometry: E, properties: this.properties };
            return this.id != null && (D.id = this.id), D;
          }
        }
        function hw(o, e, i) {
          o === 1 ? e.id = i.readVarint() : o === 2 ? (function(u, c) {
            const m = u.readVarint() + u.pos;
            for (; u.pos < m; ) {
              const v = c._keys[u.readVarint()], x = c._values[u.readVarint()];
              c.properties[v] = x;
            }
          })(i, e) : o === 3 ? e.type = i.readVarint() : o === 4 && (e._geometry = i.pos);
        }
        function fw(o) {
          let e = 0;
          for (let i, u, c = 0, m = o.length, v = m - 1; c < m; v = c++) i = o[c], u = o[v], e += (u.x - i.x) * (i.y + u.y);
          return e;
        }
        tc.types = ["Unknown", "Point", "LineString", "Polygon"];
        class Wv {
          constructor(e, i) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = e, this._keys = [], this._values = [], this._features = [], e.readFields(pw, this, i), this.length = this._features.length;
          }
          feature(e) {
            if (e < 0 || e >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[e];
            const i = this._pbf.readVarint() + this._pbf.pos;
            return new tc(this._pbf, i, this.extent, this._keys, this._values);
          }
        }
        function pw(o, e, i) {
          o === 15 ? e.version = i.readVarint() : o === 1 ? e.name = i.readString() : o === 5 ? e.extent = i.readVarint() : o === 2 ? e._features.push(i.pos) : o === 3 ? e._keys.push(i.readString()) : o === 4 && e._values.push((function(u) {
            let c = null;
            const m = u.readVarint() + u.pos;
            for (; u.pos < m; ) {
              const v = u.readVarint() >> 3;
              c = v === 1 ? u.readString() : v === 2 ? u.readFloat() : v === 3 ? u.readDouble() : v === 4 ? u.readVarint64() : v === 5 ? u.readVarint() : v === 6 ? u.readSVarint() : v === 7 ? u.readBoolean() : null;
            }
            if (c == null) throw new Error("unknown feature value");
            return c;
          })(i));
        }
        class Zv {
          constructor(e, i) {
            this.layers = e.readFields(mw, {}, i);
          }
        }
        function mw(o, e, i) {
          if (o === 3) {
            const u = new Wv(i, i.readVarint() + i.pos);
            u.length && (e[u.name] = u);
          }
        }
        const rg = Math.pow(2, 13);
        function Wd(o, e, i, u, c, m, v, x) {
          o.emplaceBack(e, i, 2 * Math.floor(u * rg) + v, c * rg * 2, m * rg * 2, Math.round(x));
        }
        class ig {
          constructor(e) {
            this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(((i) => i.id)), this.index = e.index, this.hasDependencies = false, this.layoutVertexArray = new Pe(), this.centroidVertexArray = new fe(), this.indexArray = new Tt(), this.programConfigurations = new Qa(e.layers, e.zoom), this.segments = new Yt(), this.stateDependentLayerIds = this.layers.filter(((i) => i.isStateDependent())).map(((i) => i.id));
          }
          populate(e, i, u) {
            this.features = [], this.hasDependencies = Hf("fill-extrusion", this.layers, i);
            for (const { feature: c, id: m, index: v, sourceLayerIndex: x } of e) {
              const C = this.layers[0]._featureFilter.needGeometry, k = Pa(c, C);
              if (!this.layers[0]._featureFilter.filter(new qr(this.zoom), k, u)) continue;
              const E = { id: m, sourceLayerIndex: x, index: v, geometry: C ? k.geometry : Ta(c), properties: c.properties, type: c.type, patterns: {} };
              this.hasDependencies ? this.features.push(Jm("fill-extrusion", this.layers, E, { zoom: this.zoom }, i)) : this.addFeature(E, E.geometry, v, u, {}, i.subdivisionGranularity), i.featureIndex.insert(c, E.geometry, v, x, this.index, true);
            }
          }
          addFeatures(e, i, u) {
            for (const c of this.features) {
              const { geometry: m } = c;
              this.addFeature(c, m, c.index, i, u, e.subdivisionGranularity);
            }
          }
          update(e, i, u) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, i, this.stateDependentLayers, { imagePositions: u });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, dw), this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, cw.members, true), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(e, i, u, c, m, v) {
            for (const x of sl(i, 500)) {
              const C = { x: 0, y: 0, sampleCount: 0 }, k = this.layoutVertexArray.length;
              this.processPolygon(C, c, e, x, v);
              const E = this.layoutVertexArray.length - k, D = Math.floor(C.x / C.sampleCount), F = Math.floor(C.y / C.sampleCount);
              for (let V = 0; V < E; V++) this.centroidVertexArray.emplaceBack(D, F);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, u, { imagePositions: m, canonical: c });
          }
          processPolygon(e, i, u, c, m) {
            if (c.length < 1 || Hv(c[0])) return;
            for (const D of c) D.length !== 0 && gw(e, D);
            const v = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, x = m.fill.getGranularityForZoomLevel(i.z), C = tc.types[u.type] === "Polygon";
            for (const D of c) {
              if (D.length === 0 || Hv(D)) continue;
              const F = Dl(D, x, C);
              this._generateSideFaces(F, v);
            }
            if (!C) return;
            const k = Vv(c, i, x, false), E = this.layoutVertexArray;
            Uv(((D, F) => {
              Wd(E, D, F, 0, 0, 1, 1, 0);
            }), this.segments, this.layoutVertexArray, this.indexArray, k.verticesFlattened, k.indicesTriangles);
          }
          _generateSideFaces(e, i) {
            let u = 0;
            for (let c = 1; c < e.length; c++) {
              const m = e[c], v = e[c - 1];
              if (vw(m, v)) continue;
              i.segment.vertexLength + 4 > Yt.MAX_VERTEX_ARRAY_LENGTH && (i.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const x = m.sub(v)._perp()._unit(), C = v.dist(m);
              u + C > 32768 && (u = 0), Wd(this.layoutVertexArray, m.x, m.y, x.x, x.y, 0, 0, u), Wd(this.layoutVertexArray, m.x, m.y, x.x, x.y, 0, 1, u), u += C, Wd(this.layoutVertexArray, v.x, v.y, x.x, x.y, 0, 0, u), Wd(this.layoutVertexArray, v.x, v.y, x.x, x.y, 0, 1, u);
              const k = i.segment.vertexLength;
              this.indexArray.emplaceBack(k, k + 2, k + 1), this.indexArray.emplaceBack(k + 1, k + 2, k + 3), i.segment.vertexLength += 4, i.segment.primitiveLength += 2;
            }
          }
        }
        function gw(o, e) {
          for (let i = 0; i < e.length; i++) {
            const u = e[i];
            i === e.length - 1 && e[0].x === u.x && e[0].y === u.y || (o.x += u.x, o.y += u.y, o.sampleCount++);
          }
        }
        function vw(o, e) {
          return o.x === e.x && (o.x < 0 || o.x > it) || o.y === e.y && (o.y < 0 || o.y > it);
        }
        function Hv(o) {
          return o.every(((e) => e.x < 0)) || o.every(((e) => e.x > it)) || o.every(((e) => e.y < 0)) || o.every(((e) => e.y > it));
        }
        let Xv;
        Lt("FillExtrusionBucket", ig, { omit: ["layers", "features"] });
        var yw = { get paint() {
          return Xv = Xv || new En({ "fill-extrusion-opacity": new Wt(se["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new or(se["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Wt(se["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Wt(se["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Cl(se["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new or(se["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new or(se["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Wt(se["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class _w extends so {
          constructor(e, i) {
            super(e, yw, i);
          }
          createBucket(e) {
            return new ig(e);
          }
          queryRadius() {
            return Wf(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return true;
          }
          queryIntersectsFeature({ queryGeometry: e, feature: i, featureState: u, geometry: c, transform: m, pixelsToTileUnits: v, pixelPosMatrix: x }) {
            const C = Zf(e, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -m.bearingInRadians, v), k = this.paint.get("fill-extrusion-height").evaluate(i, u), E = this.paint.get("fill-extrusion-base").evaluate(i, u), D = (function(V, G) {
              const H = [];
              for (const Y of V) {
                const ie = [Y.x, Y.y, 0, 1];
                et(ie, ie, G), H.push(new S(ie[0] / ie[3], ie[1] / ie[3]));
              }
              return H;
            })(C, x), F = (function(V, G, H, Y) {
              const ie = [], we = [], ce = Y[8] * G, pe = Y[9] * G, Te = Y[10] * G, Oe = Y[11] * G, Xe = Y[8] * H, yt = Y[9] * H, ft = Y[10] * H, wt = Y[11] * H;
              for (const Rt of V) {
                const Et = [], Mt = [];
                for (const lt of Rt) {
                  const rr = lt.x, Qt = lt.y, tr = Y[0] * rr + Y[4] * Qt + Y[12], Vt = Y[1] * rr + Y[5] * Qt + Y[13], wr = Y[2] * rr + Y[6] * Qt + Y[14], bi = Y[3] * rr + Y[7] * Qt + Y[15], Ni = wr + Te, vn = bi + Oe, ko = tr + Xe, Kn = Vt + yt, nn = wr + ft, mi = bi + wt, Hi = new S((tr + ce) / vn, (Vt + pe) / vn);
                  Hi.z = Ni / vn, Et.push(Hi);
                  const on = new S(ko / mi, Kn / mi);
                  on.z = nn / mi, Mt.push(on);
                }
                ie.push(Et), we.push(Mt);
              }
              return [ie, we];
            })(c, E, k, x);
            return (function(V, G, H) {
              let Y = 1 / 0;
              Cv(H, G) && (Y = Yv(H, G[0]));
              for (let ie = 0; ie < G.length; ie++) {
                const we = G[ie], ce = V[ie];
                for (let pe = 0; pe < we.length - 1; pe++) {
                  const Te = we[pe], Oe = [Te, we[pe + 1], ce[pe + 1], ce[pe], Te];
                  wv(H, Oe) && (Y = Math.min(Y, Yv(H, Oe)));
                }
              }
              return Y !== 1 / 0 && Y;
            })(F[0], F[1], D);
          }
        }
        function Zd(o, e) {
          return o.x * e.x + o.y * e.y;
        }
        function Yv(o, e) {
          if (o.length === 1) {
            let i = 0;
            const u = e[i++];
            let c;
            for (; !c || u.equals(c); ) if (c = e[i++], !c) return 1 / 0;
            for (; i < e.length; i++) {
              const m = e[i], v = o[0], x = c.sub(u), C = m.sub(u), k = v.sub(u), E = Zd(x, x), D = Zd(x, C), F = Zd(C, C), V = Zd(k, x), G = Zd(k, C), H = E * F - D * D, Y = (F * V - D * G) / H, ie = (E * G - D * V) / H, we = u.z * (1 - Y - ie) + c.z * Y + m.z * ie;
              if (isFinite(we)) return we;
            }
            return 1 / 0;
          }
          {
            let i = 1 / 0;
            for (const u of e) i = Math.min(i, u.z);
            return i;
          }
        }
        const bw = Xr([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: xw } = bw, ww = Xr([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: Cw } = ww, Sw = Math.cos(Math.PI / 180 * 37.5), Kv = Math.pow(2, 14) / 0.5;
        class ng {
          constructor(e) {
            this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(((i) => i.id)), this.index = e.index, this.hasDependencies = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(((i) => {
              this.gradients[i.id] = {};
            })), this.layoutVertexArray = new xe(), this.layoutVertexArray2 = new Ie(), this.indexArray = new Tt(), this.programConfigurations = new Qa(e.layers, e.zoom), this.segments = new Yt(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(((i) => i.isStateDependent())).map(((i) => i.id));
          }
          populate(e, i, u) {
            this.hasDependencies = Hf("line", this.layers, i) || this.hasLineDasharray(this.layers);
            const c = this.layers[0].layout.get("line-sort-key"), m = !c.isConstant(), v = [];
            for (const { feature: x, id: C, index: k, sourceLayerIndex: E } of e) {
              const D = this.layers[0]._featureFilter.needGeometry, F = Pa(x, D);
              if (!this.layers[0]._featureFilter.filter(new qr(this.zoom), F, u)) continue;
              const V = m ? c.evaluate(F, {}, u) : void 0, G = { id: C, properties: x.properties, type: x.type, sourceLayerIndex: E, index: k, geometry: D ? F.geometry : Ta(x), patterns: {}, dashes: {}, sortKey: V };
              v.push(G);
            }
            m && v.sort(((x, C) => x.sortKey - C.sortKey));
            for (const x of v) {
              const { geometry: C, index: k, sourceLayerIndex: E } = x;
              this.hasDependencies ? (Hf("line", this.layers, i) ? Jm("line", this.layers, x, { zoom: this.zoom }, i) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, x, this.zoom, i), this.patternFeatures.push(x)) : this.addFeature(x, C, k, u, {}, {}, i.subdivisionGranularity), i.featureIndex.insert(e[k].feature, C, k, E, this.index);
            }
          }
          update(e, i, u, c) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, i, this.stateDependentLayers, { imagePositions: u, dashPositions: c });
          }
          addFeatures(e, i, u, c) {
            for (const m of this.patternFeatures) this.addFeature(m, m.geometry, m.index, i, u, c, e.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, Cw)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, xw), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(e) {
            if (e.properties && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_end")) return { start: +e.properties.mapbox_clip_start, end: +e.properties.mapbox_clip_end };
          }
          addFeature(e, i, u, c, m, v, x) {
            const C = this.layers[0].layout, k = C.get("line-join").evaluate(e, {}), E = C.get("line-cap"), D = C.get("line-miter-limit"), F = C.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(e);
            for (const V of i) this.addLine(V, e, k, E, D, F, c, x);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, u, { imagePositions: m, dashPositions: v, canonical: c });
          }
          addLine(e, i, u, c, m, v, x, C) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, e = Dl(e, x ? C.line.getGranularityForZoomLevel(x.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let ce = 0; ce < e.length - 1; ce++) this.totalDistance += e[ce].dist(e[ce + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const k = tc.types[i.type] === "Polygon";
            let E = e.length;
            for (; E >= 2 && e[E - 1].equals(e[E - 2]); ) E--;
            let D = 0;
            for (; D < E - 1 && e[D].equals(e[D + 1]); ) D++;
            if (E < (k ? 3 : 2)) return;
            u === "bevel" && (m = 1.05);
            const F = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, V = this.segments.prepareSegment(10 * E, this.layoutVertexArray, this.indexArray);
            let G, H, Y, ie, we;
            this.e1 = this.e2 = -1, k && (G = e[E - 2], we = e[D].sub(G)._unit()._perp());
            for (let ce = D; ce < E; ce++) {
              if (Y = ce === E - 1 ? k ? e[D + 1] : void 0 : e[ce + 1], Y && e[ce].equals(Y)) continue;
              we && (ie = we), G && (H = G), G = e[ce], we = Y ? Y.sub(G)._unit()._perp() : ie, ie = ie || we;
              let pe = ie.add(we);
              pe.x === 0 && pe.y === 0 || pe._unit();
              const Te = ie.x * we.x + ie.y * we.y, Oe = pe.x * we.x + pe.y * we.y, Xe = Oe !== 0 ? 1 / Oe : 1 / 0, yt = 2 * Math.sqrt(2 - 2 * Oe), ft = Oe < Sw && H && Y, wt = ie.x * we.y - ie.y * we.x > 0;
              if (ft && ce > D) {
                const Mt = G.dist(H);
                if (Mt > 2 * F) {
                  const lt = G.sub(G.sub(H)._mult(F / Mt)._round());
                  this.updateDistance(H, lt), this.addCurrentVertex(lt, ie, 0, 0, V), H = lt;
                }
              }
              const Rt = H && Y;
              let Et = Rt ? u : k ? "butt" : c;
              if (Rt && Et === "round" && (Xe < v ? Et = "miter" : Xe <= 2 && (Et = "fakeround")), Et === "miter" && Xe > m && (Et = "bevel"), Et === "bevel" && (Xe > 2 && (Et = "flipbevel"), Xe < m && (Et = "miter")), H && this.updateDistance(H, G), Et === "miter") pe._mult(Xe), this.addCurrentVertex(G, pe, 0, 0, V);
              else if (Et === "flipbevel") {
                if (Xe > 100) pe = we.mult(-1);
                else {
                  const Mt = Xe * ie.add(we).mag() / ie.sub(we).mag();
                  pe._perp()._mult(Mt * (wt ? -1 : 1));
                }
                this.addCurrentVertex(G, pe, 0, 0, V), this.addCurrentVertex(G, pe.mult(-1), 0, 0, V);
              } else if (Et === "bevel" || Et === "fakeround") {
                const Mt = -Math.sqrt(Xe * Xe - 1), lt = wt ? Mt : 0, rr = wt ? 0 : Mt;
                if (H && this.addCurrentVertex(G, ie, lt, rr, V), Et === "fakeround") {
                  const Qt = Math.round(180 * yt / Math.PI / 20);
                  for (let tr = 1; tr < Qt; tr++) {
                    let Vt = tr / Qt;
                    if (Vt !== 0.5) {
                      const bi = Vt - 0.5;
                      Vt += Vt * bi * (Vt - 1) * ((1.0904 + Te * (Te * (3.55645 - 1.43519 * Te) - 3.2452)) * bi * bi + (0.848013 + Te * (0.215638 * Te - 1.06021)));
                    }
                    const wr = we.sub(ie)._mult(Vt)._add(ie)._unit()._mult(wt ? -1 : 1);
                    this.addHalfVertex(G, wr.x, wr.y, false, wt, 0, V);
                  }
                }
                Y && this.addCurrentVertex(G, we, -lt, -rr, V);
              } else if (Et === "butt") this.addCurrentVertex(G, pe, 0, 0, V);
              else if (Et === "square") {
                const Mt = H ? 1 : -1;
                this.addCurrentVertex(G, pe, Mt, Mt, V);
              } else Et === "round" && (H && (this.addCurrentVertex(G, ie, 0, 0, V), this.addCurrentVertex(G, ie, 1, 1, V, true)), Y && (this.addCurrentVertex(G, we, -1, -1, V, true), this.addCurrentVertex(G, we, 0, 0, V)));
              if (ft && ce < E - 1) {
                const Mt = G.dist(Y);
                if (Mt > 2 * F) {
                  const lt = G.add(Y.sub(G)._mult(F / Mt)._round());
                  this.updateDistance(G, lt), this.addCurrentVertex(lt, we, 0, 0, V), G = lt;
                }
              }
            }
          }
          addCurrentVertex(e, i, u, c, m, v = false) {
            const x = i.y * c - i.x, C = -i.y - i.x * c;
            this.addHalfVertex(e, i.x + i.y * u, i.y - i.x * u, v, false, u, m), this.addHalfVertex(e, x, C, v, true, -c, m), this.distance > Kv / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(e, i, u, c, m, v));
          }
          addHalfVertex({ x: e, y: i }, u, c, m, v, x, C) {
            const k = 0.5 * (this.lineClips ? this.scaledDistance * (Kv - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((e << 1) + (m ? 1 : 0), (i << 1) + (v ? 1 : 0), Math.round(63 * u) + 128, Math.round(63 * c) + 128, 1 + (x === 0 ? 0 : x < 0 ? -1 : 1) | (63 & k) << 2, k >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const E = C.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, E, this.e2), C.primitiveLength++), v ? this.e2 = E : this.e1 = E;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(e, i) {
            this.distance += e.dist(i), this.updateScaledDistance();
          }
          hasLineDasharray(e) {
            for (const i of e) {
              const u = i.paint.get("line-dasharray");
              if (u && !u.isConstant()) return true;
            }
            return false;
          }
          addLineDashDependencies(e, i, u, c) {
            for (const m of e) {
              const v = m.paint.get("line-dasharray");
              if (!v || v.value.kind === "constant") continue;
              const x = m.layout.get("line-cap") === "round", C = { dasharray: v.value.evaluate({ zoom: u - 1 }, i, {}), round: x }, k = { dasharray: v.value.evaluate({ zoom: u }, i, {}), round: x }, E = { dasharray: v.value.evaluate({ zoom: u + 1 }, i, {}), round: x }, D = `${C.dasharray.join(",")},${C.round}`, F = `${k.dasharray.join(",")},${k.round}`, V = `${E.dasharray.join(",")},${E.round}`;
              c.dashDependencies[D] = C, c.dashDependencies[F] = k, c.dashDependencies[V] = E, i.dashes[m.id] = { min: D, mid: F, max: V };
            }
          }
        }
        let Jv, Qv;
        Lt("LineBucket", ng, { omit: ["layers", "patternFeatures"] });
        var ey = { get paint() {
          return Qv = Qv || new En({ "line-opacity": new or(se.paint_line["line-opacity"]), "line-color": new or(se.paint_line["line-color"]), "line-translate": new Wt(se.paint_line["line-translate"]), "line-translate-anchor": new Wt(se.paint_line["line-translate-anchor"]), "line-width": new or(se.paint_line["line-width"]), "line-gap-width": new or(se.paint_line["line-gap-width"]), "line-offset": new or(se.paint_line["line-offset"]), "line-blur": new or(se.paint_line["line-blur"]), "line-dasharray": new Cl(se.paint_line["line-dasharray"]), "line-pattern": new Cl(se.paint_line["line-pattern"]), "line-gradient": new Uu(se.paint_line["line-gradient"]) });
        }, get layout() {
          return Jv = Jv || new En({ "line-cap": new Wt(se.layout_line["line-cap"]), "line-join": new or(se.layout_line["line-join"]), "line-miter-limit": new Wt(se.layout_line["line-miter-limit"]), "line-round-limit": new Wt(se.layout_line["line-round-limit"]), "line-sort-key": new or(se.layout_line["line-sort-key"]) });
        } };
        class kw extends or {
          possiblyEvaluate(e, i) {
            return i = new qr(Math.floor(i.zoom), { now: i.now, fadeDuration: i.fadeDuration, zoomHistory: i.zoomHistory, transition: i.transition }), super.possiblyEvaluate(e, i);
          }
          evaluate(e, i, u, c) {
            return i = Zt({}, i, { zoom: Math.floor(i.zoom) }), super.evaluate(e, i, u, c);
          }
        }
        let Jf;
        class Tw extends so {
          constructor(e, i) {
            super(e, ey, i), this.gradientVersion = 0, Jf || (Jf = new kw(ey.paint.properties["line-width"].specification), Jf.useIntegerZoom = true);
          }
          _handleSpecialPaintPropertyUpdate(e) {
            if (e === "line-gradient") {
              const i = this.gradientExpression();
              this.stepInterpolant = !!(function(u) {
                return u._styleExpression !== void 0;
              })(i) && i._styleExpression.expression instanceof vs, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(e, i) {
            super.recalculate(e, i), this.paint._values["line-floorwidth"] = Jf.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e);
          }
          createBucket(e) {
            return new ng(e);
          }
          queryRadius(e) {
            const i = e, u = ty(Ku("line-width", this, i), Ku("line-gap-width", this, i)), c = Ku("line-offset", this, i);
            return u / 2 + Math.abs(c) + Wf(this.paint.get("line-translate"));
          }
          queryIntersectsFeature({ queryGeometry: e, feature: i, featureState: u, geometry: c, transform: m, pixelsToTileUnits: v }) {
            const x = Zf(e, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -m.bearingInRadians, v), C = v / 2 * ty(this.paint.get("line-width").evaluate(i, u), this.paint.get("line-gap-width").evaluate(i, u)), k = this.paint.get("line-offset").evaluate(i, u);
            return k && (c = (function(E, D) {
              const F = [];
              for (let V = 0; V < E.length; V++) {
                const G = E[V], H = [];
                for (let Y = 0; Y < G.length; Y++) {
                  const ie = G[Y - 1], we = G[Y], ce = G[Y + 1], pe = Y === 0 ? new S(0, 0) : we.sub(ie)._unit()._perp(), Te = Y === G.length - 1 ? new S(0, 0) : ce.sub(we)._unit()._perp(), Oe = pe._add(Te)._unit(), Xe = Oe.x * Te.x + Oe.y * Te.y;
                  Xe !== 0 && Oe._mult(1 / Xe), H.push(Oe._mult(D)._add(we));
                }
                F.push(H);
              }
              return F;
            })(c, k * v)), (function(E, D, F) {
              for (let V = 0; V < D.length; V++) {
                const G = D[V];
                if (E.length >= 3) {
                  for (let H = 0; H < G.length; H++) if (Yu(E, G[H])) return true;
                }
                if (A2(E, G, F)) return true;
              }
              return false;
            })(x, c, C);
          }
          isTileClipped() {
            return true;
          }
        }
        function ty(o, e) {
          return e > 0 ? e + 2 * o : o;
        }
        const Pw = Xr([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Iw = Xr([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        Xr([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const Ew = Xr([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
        Xr([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const ry = Xr([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Mw = Xr([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function Dw(o, e, i) {
          return o.sections.forEach(((u) => {
            u.text = (function(c, m, v) {
              const x = m.layout.get("text-transform").evaluate(v, {});
              return x === "uppercase" ? c = c.toLocaleUpperCase() : x === "lowercase" && (c = c.toLocaleLowerCase()), Ko.applyArabicShaping && (c = Ko.applyArabicShaping(c)), c;
            })(u.text, e, i);
          })), o;
        }
        Xr([{ name: "triangle", components: 3, type: "Uint16" }]), Xr([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Xr([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Xr([{ type: "Float32", name: "offsetX" }]), Xr([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Xr([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        const Hd = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
        var qi = 24;
        const og = 4294967296, iy = 1 / og, ny = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class ag {
          constructor(e = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(e) ? e : new Uint8Array(e), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          readFields(e, i, u = this.length) {
            for (; this.pos < u; ) {
              const c = this.readVarint(), m = c >> 3, v = this.pos;
              this.type = 7 & c, e(m, i, this), this.pos === v && this.skip(c);
            }
            return i;
          }
          readMessage(e, i) {
            return this.readFields(e, i, this.readVarint() + this.pos);
          }
          readFixed32() {
            const e = this.dataView.getUint32(this.pos, true);
            return this.pos += 4, e;
          }
          readSFixed32() {
            const e = this.dataView.getInt32(this.pos, true);
            return this.pos += 4, e;
          }
          readFixed64() {
            const e = this.dataView.getUint32(this.pos, true) + this.dataView.getUint32(this.pos + 4, true) * og;
            return this.pos += 8, e;
          }
          readSFixed64() {
            const e = this.dataView.getUint32(this.pos, true) + this.dataView.getInt32(this.pos + 4, true) * og;
            return this.pos += 8, e;
          }
          readFloat() {
            const e = this.dataView.getFloat32(this.pos, true);
            return this.pos += 4, e;
          }
          readDouble() {
            const e = this.dataView.getFloat64(this.pos, true);
            return this.pos += 8, e;
          }
          readVarint(e) {
            const i = this.buf;
            let u, c;
            return c = i[this.pos++], u = 127 & c, c < 128 ? u : (c = i[this.pos++], u |= (127 & c) << 7, c < 128 ? u : (c = i[this.pos++], u |= (127 & c) << 14, c < 128 ? u : (c = i[this.pos++], u |= (127 & c) << 21, c < 128 ? u : (c = i[this.pos], u |= (15 & c) << 28, (function(m, v, x) {
              const C = x.buf;
              let k, E;
              if (E = C[x.pos++], k = (112 & E) >> 4, E < 128 || (E = C[x.pos++], k |= (127 & E) << 3, E < 128) || (E = C[x.pos++], k |= (127 & E) << 10, E < 128) || (E = C[x.pos++], k |= (127 & E) << 17, E < 128) || (E = C[x.pos++], k |= (127 & E) << 24, E < 128) || (E = C[x.pos++], k |= (1 & E) << 31, E < 128)) return rc(m, k, v);
              throw new Error("Expected varint not more than 10 bytes");
            })(u, e, this)))));
          }
          readVarint64() {
            return this.readVarint(true);
          }
          readSVarint() {
            const e = this.readVarint();
            return e % 2 == 1 ? (e + 1) / -2 : e / 2;
          }
          readBoolean() {
            return !!this.readVarint();
          }
          readString() {
            const e = this.readVarint() + this.pos, i = this.pos;
            return this.pos = e, e - i >= 12 && ny ? ny.decode(this.buf.subarray(i, e)) : (function(u, c, m) {
              let v = "", x = c;
              for (; x < m; ) {
                const C = u[x];
                let k, E, D, F = null, V = C > 239 ? 4 : C > 223 ? 3 : C > 191 ? 2 : 1;
                if (x + V > m) break;
                V === 1 ? C < 128 && (F = C) : V === 2 ? (k = u[x + 1], (192 & k) == 128 && (F = (31 & C) << 6 | 63 & k, F <= 127 && (F = null))) : V === 3 ? (k = u[x + 1], E = u[x + 2], (192 & k) == 128 && (192 & E) == 128 && (F = (15 & C) << 12 | (63 & k) << 6 | 63 & E, (F <= 2047 || F >= 55296 && F <= 57343) && (F = null))) : V === 4 && (k = u[x + 1], E = u[x + 2], D = u[x + 3], (192 & k) == 128 && (192 & E) == 128 && (192 & D) == 128 && (F = (15 & C) << 18 | (63 & k) << 12 | (63 & E) << 6 | 63 & D, (F <= 65535 || F >= 1114112) && (F = null))), F === null ? (F = 65533, V = 1) : F > 65535 && (F -= 65536, v += String.fromCharCode(F >>> 10 & 1023 | 55296), F = 56320 | 1023 & F), v += String.fromCharCode(F), x += V;
              }
              return v;
            })(this.buf, i, e);
          }
          readBytes() {
            const e = this.readVarint() + this.pos, i = this.buf.subarray(this.pos, e);
            return this.pos = e, i;
          }
          readPackedVarint(e = [], i) {
            const u = this.readPackedEnd();
            for (; this.pos < u; ) e.push(this.readVarint(i));
            return e;
          }
          readPackedSVarint(e = []) {
            const i = this.readPackedEnd();
            for (; this.pos < i; ) e.push(this.readSVarint());
            return e;
          }
          readPackedBoolean(e = []) {
            const i = this.readPackedEnd();
            for (; this.pos < i; ) e.push(this.readBoolean());
            return e;
          }
          readPackedFloat(e = []) {
            const i = this.readPackedEnd();
            for (; this.pos < i; ) e.push(this.readFloat());
            return e;
          }
          readPackedDouble(e = []) {
            const i = this.readPackedEnd();
            for (; this.pos < i; ) e.push(this.readDouble());
            return e;
          }
          readPackedFixed32(e = []) {
            const i = this.readPackedEnd();
            for (; this.pos < i; ) e.push(this.readFixed32());
            return e;
          }
          readPackedSFixed32(e = []) {
            const i = this.readPackedEnd();
            for (; this.pos < i; ) e.push(this.readSFixed32());
            return e;
          }
          readPackedFixed64(e = []) {
            const i = this.readPackedEnd();
            for (; this.pos < i; ) e.push(this.readFixed64());
            return e;
          }
          readPackedSFixed64(e = []) {
            const i = this.readPackedEnd();
            for (; this.pos < i; ) e.push(this.readSFixed64());
            return e;
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1;
          }
          skip(e) {
            const i = 7 & e;
            if (i === 0) for (; this.buf[this.pos++] > 127; ) ;
            else if (i === 2) this.pos = this.readVarint() + this.pos;
            else if (i === 5) this.pos += 4;
            else {
              if (i !== 1) throw new Error(`Unimplemented type: ${i}`);
              this.pos += 8;
            }
          }
          writeTag(e, i) {
            this.writeVarint(e << 3 | i);
          }
          realloc(e) {
            let i = this.length || 16;
            for (; i < this.pos + e; ) i *= 2;
            if (i !== this.length) {
              const u = new Uint8Array(i);
              u.set(this.buf), this.buf = u, this.dataView = new DataView(u.buffer), this.length = i;
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }
          writeFixed32(e) {
            this.realloc(4), this.dataView.setInt32(this.pos, e, true), this.pos += 4;
          }
          writeSFixed32(e) {
            this.realloc(4), this.dataView.setInt32(this.pos, e, true), this.pos += 4;
          }
          writeFixed64(e) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & e, true), this.dataView.setInt32(this.pos + 4, Math.floor(e * iy), true), this.pos += 8;
          }
          writeSFixed64(e) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & e, true), this.dataView.setInt32(this.pos + 4, Math.floor(e * iy), true), this.pos += 8;
          }
          writeVarint(e) {
            (e = +e || 0) > 268435455 || e < 0 ? (function(i, u) {
              let c, m;
              if (i >= 0 ? (c = i % 4294967296 | 0, m = i / 4294967296 | 0) : (c = ~(-i % 4294967296), m = ~(-i / 4294967296), 4294967295 ^ c ? c = c + 1 | 0 : (c = 0, m = m + 1 | 0)), i >= 18446744073709552e3 || i < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              u.realloc(10), (function(v, x, C) {
                C.buf[C.pos++] = 127 & v | 128, v >>>= 7, C.buf[C.pos++] = 127 & v | 128, v >>>= 7, C.buf[C.pos++] = 127 & v | 128, v >>>= 7, C.buf[C.pos++] = 127 & v | 128, C.buf[C.pos] = 127 & (v >>>= 7);
              })(c, 0, u), (function(v, x) {
                const C = (7 & v) << 4;
                x.buf[x.pos++] |= C | ((v >>>= 3) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v | ((v >>>= 7) ? 128 : 0), v && (x.buf[x.pos++] = 127 & v)))));
              })(m, u);
            })(e, this) : (this.realloc(4), this.buf[this.pos++] = 127 & e | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = 127 & (e >>>= 7) | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = 127 & (e >>>= 7) | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = e >>> 7 & 127))));
          }
          writeSVarint(e) {
            this.writeVarint(e < 0 ? 2 * -e - 1 : 2 * e);
          }
          writeBoolean(e) {
            this.writeVarint(+e);
          }
          writeString(e) {
            e = String(e), this.realloc(4 * e.length), this.pos++;
            const i = this.pos;
            this.pos = (function(c, m, v) {
              for (let x, C, k = 0; k < m.length; k++) {
                if (x = m.charCodeAt(k), x > 55295 && x < 57344) {
                  if (!C) {
                    x > 56319 || k + 1 === m.length ? (c[v++] = 239, c[v++] = 191, c[v++] = 189) : C = x;
                    continue;
                  }
                  if (x < 56320) {
                    c[v++] = 239, c[v++] = 191, c[v++] = 189, C = x;
                    continue;
                  }
                  x = C - 55296 << 10 | x - 56320 | 65536, C = null;
                } else C && (c[v++] = 239, c[v++] = 191, c[v++] = 189, C = null);
                x < 128 ? c[v++] = x : (x < 2048 ? c[v++] = x >> 6 | 192 : (x < 65536 ? c[v++] = x >> 12 | 224 : (c[v++] = x >> 18 | 240, c[v++] = x >> 12 & 63 | 128), c[v++] = x >> 6 & 63 | 128), c[v++] = 63 & x | 128);
              }
              return v;
            })(this.buf, e, this.pos);
            const u = this.pos - i;
            u >= 128 && oy(i, u, this), this.pos = i - 1, this.writeVarint(u), this.pos += u;
          }
          writeFloat(e) {
            this.realloc(4), this.dataView.setFloat32(this.pos, e, true), this.pos += 4;
          }
          writeDouble(e) {
            this.realloc(8), this.dataView.setFloat64(this.pos, e, true), this.pos += 8;
          }
          writeBytes(e) {
            const i = e.length;
            this.writeVarint(i), this.realloc(i);
            for (let u = 0; u < i; u++) this.buf[this.pos++] = e[u];
          }
          writeRawMessage(e, i) {
            this.pos++;
            const u = this.pos;
            e(i, this);
            const c = this.pos - u;
            c >= 128 && oy(u, c, this), this.pos = u - 1, this.writeVarint(c), this.pos += c;
          }
          writeMessage(e, i, u) {
            this.writeTag(e, 2), this.writeRawMessage(i, u);
          }
          writePackedVarint(e, i) {
            i.length && this.writeMessage(e, Rw, i);
          }
          writePackedSVarint(e, i) {
            i.length && this.writeMessage(e, Aw, i);
          }
          writePackedBoolean(e, i) {
            i.length && this.writeMessage(e, Lw, i);
          }
          writePackedFloat(e, i) {
            i.length && this.writeMessage(e, zw, i);
          }
          writePackedDouble(e, i) {
            i.length && this.writeMessage(e, Fw, i);
          }
          writePackedFixed32(e, i) {
            i.length && this.writeMessage(e, Bw, i);
          }
          writePackedSFixed32(e, i) {
            i.length && this.writeMessage(e, Ow, i);
          }
          writePackedFixed64(e, i) {
            i.length && this.writeMessage(e, $w, i);
          }
          writePackedSFixed64(e, i) {
            i.length && this.writeMessage(e, Nw, i);
          }
          writeBytesField(e, i) {
            this.writeTag(e, 2), this.writeBytes(i);
          }
          writeFixed32Field(e, i) {
            this.writeTag(e, 5), this.writeFixed32(i);
          }
          writeSFixed32Field(e, i) {
            this.writeTag(e, 5), this.writeSFixed32(i);
          }
          writeFixed64Field(e, i) {
            this.writeTag(e, 1), this.writeFixed64(i);
          }
          writeSFixed64Field(e, i) {
            this.writeTag(e, 1), this.writeSFixed64(i);
          }
          writeVarintField(e, i) {
            this.writeTag(e, 0), this.writeVarint(i);
          }
          writeSVarintField(e, i) {
            this.writeTag(e, 0), this.writeSVarint(i);
          }
          writeStringField(e, i) {
            this.writeTag(e, 2), this.writeString(i);
          }
          writeFloatField(e, i) {
            this.writeTag(e, 5), this.writeFloat(i);
          }
          writeDoubleField(e, i) {
            this.writeTag(e, 1), this.writeDouble(i);
          }
          writeBooleanField(e, i) {
            this.writeVarintField(e, +i);
          }
        }
        function rc(o, e, i) {
          return i ? 4294967296 * e + (o >>> 0) : 4294967296 * (e >>> 0) + (o >>> 0);
        }
        function oy(o, e, i) {
          const u = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));
          i.realloc(u);
          for (let c = i.pos - 1; c >= o; c--) i.buf[c + u] = i.buf[c];
        }
        function Rw(o, e) {
          for (let i = 0; i < o.length; i++) e.writeVarint(o[i]);
        }
        function Aw(o, e) {
          for (let i = 0; i < o.length; i++) e.writeSVarint(o[i]);
        }
        function zw(o, e) {
          for (let i = 0; i < o.length; i++) e.writeFloat(o[i]);
        }
        function Fw(o, e) {
          for (let i = 0; i < o.length; i++) e.writeDouble(o[i]);
        }
        function Lw(o, e) {
          for (let i = 0; i < o.length; i++) e.writeBoolean(o[i]);
        }
        function Bw(o, e) {
          for (let i = 0; i < o.length; i++) e.writeFixed32(o[i]);
        }
        function Ow(o, e) {
          for (let i = 0; i < o.length; i++) e.writeSFixed32(o[i]);
        }
        function $w(o, e) {
          for (let i = 0; i < o.length; i++) e.writeFixed64(o[i]);
        }
        function Nw(o, e) {
          for (let i = 0; i < o.length; i++) e.writeSFixed64(o[i]);
        }
        function jw(o, e, i) {
          o === 1 && i.readMessage(Vw, e);
        }
        function Vw(o, e, i) {
          if (o === 3) {
            const { id: u, bitmap: c, width: m, height: v, left: x, top: C, advance: k } = i.readMessage(Uw, {});
            e.push({ id: u, bitmap: new $d({ width: m + 6, height: v + 6 }, c), metrics: { width: m, height: v, left: x, top: C, advance: k } });
          }
        }
        function Uw(o, e, i) {
          o === 1 ? e.id = i.readVarint() : o === 2 ? e.bitmap = i.readBytes() : o === 3 ? e.width = i.readVarint() : o === 4 ? e.height = i.readVarint() : o === 5 ? e.left = i.readSVarint() : o === 6 ? e.top = i.readSVarint() : o === 7 && (e.advance = i.readVarint());
        }
        function ay(o) {
          let e = 0, i = 0;
          for (const v of o) e += v.w * v.h, i = Math.max(i, v.w);
          o.sort(((v, x) => x.h - v.h));
          const u = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / 0.95)), i), h: 1 / 0 }];
          let c = 0, m = 0;
          for (const v of o) for (let x = u.length - 1; x >= 0; x--) {
            const C = u[x];
            if (!(v.w > C.w || v.h > C.h)) {
              if (v.x = C.x, v.y = C.y, m = Math.max(m, v.y + v.h), c = Math.max(c, v.x + v.w), v.w === C.w && v.h === C.h) {
                const k = u.pop();
                k && x < u.length && (u[x] = k);
              } else v.h === C.h ? (C.x += v.w, C.w -= v.w) : v.w === C.w ? (C.y += v.h, C.h -= v.h) : (u.push({ x: C.x + v.w, y: C.y, w: C.w - v.w, h: v.h }), C.y += v.h, C.h -= v.h);
              break;
            }
          }
          return { w: c, h: m, fill: e / (c * m) || 0 };
        }
        class sg {
          constructor(e, { pixelRatio: i, version: u, stretchX: c, stretchY: m, content: v, textFitWidth: x, textFitHeight: C }) {
            this.paddedRect = e, this.pixelRatio = i, this.stretchX = c, this.stretchY = m, this.content = v, this.version = u, this.textFitWidth = x, this.textFitHeight = C;
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
          }
        }
        class sy {
          constructor(e, i) {
            const u = {}, c = {};
            this.haveRenderCallbacks = [];
            const m = [];
            this.addImages(e, u, m), this.addImages(i, c, m);
            const { w: v, h: x } = ay(m), C = new Yn({ width: v || 1, height: x || 1 });
            for (const k in e) {
              const E = e[k], D = u[k].paddedRect;
              Yn.copy(E.data, C, { x: 0, y: 0 }, { x: D.x + 1, y: D.y + 1 }, E.data);
            }
            for (const k in i) {
              const E = i[k], D = c[k].paddedRect, F = D.x + 1, V = D.y + 1, G = E.data.width, H = E.data.height;
              Yn.copy(E.data, C, { x: 0, y: 0 }, { x: F, y: V }, E.data), Yn.copy(E.data, C, { x: 0, y: H - 1 }, { x: F, y: V - 1 }, { width: G, height: 1 }), Yn.copy(E.data, C, { x: 0, y: 0 }, { x: F, y: V + H }, { width: G, height: 1 }), Yn.copy(E.data, C, { x: G - 1, y: 0 }, { x: F - 1, y: V }, { width: 1, height: H }), Yn.copy(E.data, C, { x: 0, y: 0 }, { x: F + G, y: V }, { width: 1, height: H });
            }
            this.image = C, this.iconPositions = u, this.patternPositions = c;
          }
          addImages(e, i, u) {
            for (const c in e) {
              const m = e[c], v = { x: 0, y: 0, w: m.data.width + 2, h: m.data.height + 2 };
              u.push(v), i[c] = new sg(v, m), m.hasRenderCallback && this.haveRenderCallbacks.push(c);
            }
          }
          patchUpdatedImages(e, i) {
            e.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const u in e.updatedImages) this.patchUpdatedImage(this.iconPositions[u], e.getImage(u), i), this.patchUpdatedImage(this.patternPositions[u], e.getImage(u), i);
          }
          patchUpdatedImage(e, i, u) {
            if (!e || !i || e.version === i.version) return;
            e.version = i.version;
            const [c, m] = e.tl;
            u.update(i.data, void 0, { x: c, y: m });
          }
        }
        var Ms;
        Lt("ImagePosition", sg), Lt("ImageAtlas", sy), p.at = void 0, (Ms = p.at || (p.at = {}))[Ms.none = 0] = "none", Ms[Ms.horizontal = 1] = "horizontal", Ms[Ms.vertical = 2] = "vertical", Ms[Ms.horizontalOnly = 3] = "horizontalOnly";
        class Xd {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
          }
          static forText(e, i, u) {
            const c = new Xd();
            return c.scale = e || 1, c.fontStack = i, c.verticalAlign = u || "bottom", c;
          }
          static forImage(e, i) {
            const u = new Xd();
            return u.imageName = e, u.verticalAlign = i || "bottom", u;
          }
        }
        class ic {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(e, i) {
            const u = new ic();
            for (let c = 0; c < e.sections.length; c++) {
              const m = e.sections[c];
              m.image ? u.addImageSection(m) : u.addTextSection(m, i);
            }
            return u;
          }
          length() {
            return this.text.length;
          }
          getSection(e) {
            return this.sections[this.sectionIndex[e]];
          }
          getSectionIndex(e) {
            return this.sectionIndex[e];
          }
          getCharCode(e) {
            return this.text.charCodeAt(e);
          }
          verticalizePunctuation() {
            this.text = (function(e) {
              let i = "";
              for (let u = 0; u < e.length; u++) {
                const c = e.charCodeAt(u + 1) || null, m = e.charCodeAt(u - 1) || null;
                i += c && Pd(c) && !Hd[e[u + 1]] || m && Pd(m) && !Hd[e[u - 1]] || !Hd[e[u]] ? e[u] : Hd[e[u]];
              }
              return i;
            })(this.text);
          }
          trim() {
            let e = 0;
            for (let u = 0; u < this.text.length && ep[this.text.charCodeAt(u)]; u++) e++;
            let i = this.text.length;
            for (let u = this.text.length - 1; u >= 0 && u >= e && ep[this.text.charCodeAt(u)]; u--) i--;
            this.text = this.text.substring(e, i), this.sectionIndex = this.sectionIndex.slice(e, i);
          }
          substring(e, i) {
            const u = new ic();
            return u.text = this.text.substring(e, i), u.sectionIndex = this.sectionIndex.slice(e, i), u.sections = this.sections, u;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((e, i) => Math.max(e, this.sections[i].scale)), 0);
          }
          getMaxImageSize(e) {
            let i = 0, u = 0;
            for (let c = 0; c < this.length(); c++) {
              const m = this.getSection(c);
              if (m.imageName) {
                const v = e[m.imageName];
                if (!v) continue;
                const x = v.displaySize;
                i = Math.max(i, x[0]), u = Math.max(u, x[1]);
              }
            }
            return { maxImageWidth: i, maxImageHeight: u };
          }
          addTextSection(e, i) {
            this.text += e.text, this.sections.push(Xd.forText(e.scale, e.fontStack || i, e.verticalAlign));
            const u = this.sections.length - 1;
            for (let c = 0; c < e.text.length; ++c) this.sectionIndex.push(u);
          }
          addImageSection(e) {
            const i = e.image ? e.image.name : "";
            if (i.length === 0) return void Ht("Can't add FormattedSection with an empty image.");
            const u = this.getNextImageSectionCharCode();
            u ? (this.text += String.fromCharCode(u), this.sections.push(Xd.forImage(i, e.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : Ht("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function Qf(o, e, i, u, c, m, v, x, C, k, E, D, F, V, G) {
          const H = ic.fromFeature(o, c);
          let Y;
          D === p.at.vertical && H.verticalizePunctuation();
          const { processBidirectionalText: ie, processStyledBidirectionalText: we } = Ko;
          if (ie && H.sections.length === 1) {
            Y = [];
            const Te = ie(H.toString(), lg(H, k, m, e, u, V));
            for (const Oe of Te) {
              const Xe = new ic();
              Xe.text = Oe, Xe.sections = H.sections;
              for (let yt = 0; yt < Oe.length; yt++) Xe.sectionIndex.push(0);
              Y.push(Xe);
            }
          } else if (we) {
            Y = [];
            const Te = we(H.text, H.sectionIndex, lg(H, k, m, e, u, V));
            for (const Oe of Te) {
              const Xe = new ic();
              Xe.text = Oe[0], Xe.sectionIndex = Oe[1], Xe.sections = H.sections, Y.push(Xe);
            }
          } else Y = (function(Te, Oe) {
            const Xe = [], yt = Te.text;
            let ft = 0;
            for (const wt of Oe) Xe.push(Te.substring(ft, wt)), ft = wt;
            return ft < yt.length && Xe.push(Te.substring(ft, yt.length)), Xe;
          })(H, lg(H, k, m, e, u, V));
          const ce = [], pe = { positionedLines: ce, text: H.toString(), top: E[1], bottom: E[1], left: E[0], right: E[0], writingMode: D, iconsInText: false, verticalizable: false };
          return (function(Te, Oe, Xe, yt, ft, wt, Rt, Et, Mt, lt, rr, Qt) {
            let tr = 0, Vt = 0, wr = 0, bi = 0;
            const Ni = Et === "right" ? 1 : Et === "left" ? 0 : 0.5, vn = qi / Qt;
            let ko = 0;
            for (const mi of ft) {
              mi.trim();
              const Hi = mi.getMaxScale(), on = { positionedGlyphs: [], lineOffset: 0 };
              Te.positionedLines[ko] = on;
              const an = on.positionedGlyphs;
              let jn = 0;
              if (!mi.length()) {
                Vt += wt, ++ko;
                continue;
              }
              const To = Zw(yt, mi, vn);
              for (let Jn = 0; Jn < mi.length(); Jn++) {
                const ji = mi.getSection(Jn), Yi = mi.getSectionIndex(Jn), Ki = mi.getCharCode(Jn), zi = Hw(Mt, rr, Ki);
                let ni;
                if (ji.imageName) {
                  if (Te.iconsInText = true, ji.scale = ji.scale * vn, ni = Yw(ji, zi, Hi, To, yt), !ni) continue;
                  jn = Math.max(jn, ni.imageOffset);
                } else if (ni = Xw(ji, Ki, zi, To, Oe, Xe), !ni) continue;
                const { rect: oa, metrics: hc, baselineOffset: aa } = ni;
                an.push({ glyph: Ki, imageName: ji.imageName, x: tr, y: Vt + aa + -17, vertical: zi, scale: ji.scale, fontStack: ji.fontStack, sectionIndex: Yi, metrics: hc, rect: oa }), zi ? (Te.verticalizable = true, tr += (ji.imageName ? hc.advance : qi) * ji.scale + lt) : tr += hc.advance * ji.scale + lt;
              }
              an.length !== 0 && (wr = Math.max(tr - lt, wr), Kw(an, 0, an.length - 1, Ni)), tr = 0, on.lineOffset = Math.max(jn, (Hi - 1) * qi);
              const Xi = wt * Hi + jn;
              Vt += Xi, bi = Math.max(Xi, bi), ++ko;
            }
            const { horizontalAlign: Kn, verticalAlign: nn } = ug(Rt);
            (function(mi, Hi, on, an, jn, To, Xi, Jn, ji) {
              const Yi = (Hi - on) * jn;
              let Ki = 0;
              Ki = To !== Xi ? -Jn * an - -17 : -an * ji * Xi + 0.5 * Xi;
              for (const zi of mi) for (const ni of zi.positionedGlyphs) ni.x += Yi, ni.y += Ki;
            })(Te.positionedLines, Ni, Kn, nn, wr, bi, wt, Vt, ft.length), Te.top += -nn * Vt, Te.bottom = Te.top + Vt, Te.left += -Kn * wr, Te.right = Te.left + wr;
          })(pe, e, i, u, Y, v, x, C, D, k, F, G), !(function(Te) {
            for (const Oe of Te) if (Oe.positionedGlyphs.length !== 0) return false;
            return true;
          })(ce) && pe;
        }
        const ep = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, Gw = { 10: true, 32: true, 38: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true }, qw = { 40: true };
        function ly(o, e, i, u, c, m) {
          if (e.imageName) {
            const v = u[e.imageName];
            return v ? v.displaySize[0] * e.scale * qi / m + c : 0;
          }
          {
            const v = i[e.fontStack], x = v && v[o];
            return x ? x.metrics.advance * e.scale + c : 0;
          }
        }
        function uy(o, e, i, u) {
          const c = Math.pow(o - e, 2);
          return u ? o < e ? c / 2 : 2 * c : c + Math.abs(i) * i;
        }
        function Ww(o, e, i) {
          let u = 0;
          return o === 10 && (u -= 1e4), i && (u += 150), o !== 40 && o !== 65288 || (u += 50), e !== 41 && e !== 65289 || (u += 50), u;
        }
        function cy(o, e, i, u, c, m) {
          let v = null, x = uy(e, i, c, m);
          for (const C of u) {
            const k = uy(e - C.x, i, c, m) + C.badness;
            k <= x && (v = C, x = k);
          }
          return { index: o, x: e, priorBreak: v, badness: x };
        }
        function dy(o) {
          return o ? dy(o.priorBreak).concat(o.index) : [];
        }
        function lg(o, e, i, u, c, m) {
          if (!o) return [];
          const v = [], x = (function(E, D, F, V, G, H) {
            let Y = 0;
            for (let ie = 0; ie < E.length(); ie++) {
              const we = E.getSection(ie);
              Y += ly(E.getCharCode(ie), we, V, G, D, H);
            }
            return Y / Math.max(1, Math.ceil(Y / F));
          })(o, e, i, u, c, m), C = o.text.indexOf("\u200B") >= 0;
          let k = 0;
          for (let E = 0; E < o.length(); E++) {
            const D = o.getSection(E), F = o.getCharCode(E);
            if (ep[F] || (k += ly(F, D, u, c, e, m)), E < o.length() - 1) {
              const V = $m(F);
              (Gw[F] || V || D.imageName || E !== o.length() - 2 && qw[o.getCharCode(E + 1)]) && v.push(cy(E + 1, k, x, v, Ww(F, o.getCharCode(E + 1), V && C), false));
            }
          }
          return dy(cy(o.length(), k, x, v, 0, true));
        }
        function ug(o) {
          let e = 0.5, i = 0.5;
          switch (o) {
            case "right":
            case "top-right":
            case "bottom-right":
              e = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e = 0;
          }
          switch (o) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              i = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              i = 0;
          }
          return { horizontalAlign: e, verticalAlign: i };
        }
        function Zw(o, e, i) {
          const u = e.getMaxScale() * qi, { maxImageWidth: c, maxImageHeight: m } = e.getMaxImageSize(o), v = Math.max(u, m * i);
          return { verticalLineContentWidth: Math.max(u, c * i), horizontalLineContentHeight: v };
        }
        function hy(o) {
          switch (o) {
            case "top":
              return 0;
            case "center":
              return 0.5;
            default:
              return 1;
          }
        }
        function Hw(o, e, i) {
          return !(o === p.at.horizontal || !e && !Is(i) || e && (ep[i] || (u = i, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(u)))));
          var u;
        }
        function Xw(o, e, i, u, c, m) {
          const v = m[o.fontStack], x = (function(k, E, D, F) {
            if (k && k.rect) return k;
            const V = E[D.fontStack], G = V && V[F];
            return G ? { rect: null, metrics: G.metrics } : null;
          })(v && v[e], c, o, e);
          if (x === null) return null;
          let C;
          if (i) C = u.verticalLineContentWidth - o.scale * qi;
          else {
            const k = hy(o.verticalAlign);
            C = (u.horizontalLineContentHeight - o.scale * qi) * k;
          }
          return { rect: x.rect, metrics: x.metrics, baselineOffset: C };
        }
        function Yw(o, e, i, u, c) {
          const m = c[o.imageName];
          if (!m) return null;
          const v = m.paddedRect, x = m.displaySize, C = { width: x[0], height: x[1], left: 1, top: -3, advance: e ? x[1] : x[0] };
          let k;
          if (e) k = u.verticalLineContentWidth - x[1] * o.scale;
          else {
            const E = hy(o.verticalAlign);
            k = (u.horizontalLineContentHeight - x[1] * o.scale) * E;
          }
          return { rect: v, metrics: C, baselineOffset: k, imageOffset: (e ? x[0] : x[1]) * o.scale - qi * i };
        }
        function Kw(o, e, i, u) {
          if (u === 0) return;
          const c = o[i], m = (o[i].x + c.metrics.advance * c.scale) * u;
          for (let v = e; v <= i; v++) o[v].x -= m;
        }
        function Jw(o, e, i) {
          const { horizontalAlign: u, verticalAlign: c } = ug(i), m = e[0] - o.displaySize[0] * u, v = e[1] - o.displaySize[1] * c;
          return { image: o, top: v, bottom: v + o.displaySize[1], left: m, right: m + o.displaySize[0] };
        }
        function fy(o) {
          var e, i;
          let u = o.left, c = o.top, m = o.right - u, v = o.bottom - c;
          const x = (e = o.image.textFitWidth) !== null && e !== void 0 ? e : "stretchOrShrink", C = (i = o.image.textFitHeight) !== null && i !== void 0 ? i : "stretchOrShrink", k = (o.image.content[2] - o.image.content[0]) / (o.image.content[3] - o.image.content[1]);
          if (C === "proportional") {
            if (x === "stretchOnly" && m / v < k || x === "proportional") {
              const E = Math.ceil(v * k);
              u *= E / m, m = E;
            }
          } else if (x === "proportional" && C === "stretchOnly" && k !== 0 && m / v > k) {
            const E = Math.ceil(m / k);
            c *= E / v, v = E;
          }
          return { x1: u, y1: c, x2: u + m, y2: c + v };
        }
        function py(o, e, i, u, c, m) {
          const v = o.image;
          let x;
          if (v.content) {
            const Y = v.content, ie = v.pixelRatio || 1;
            x = [Y[0] / ie, Y[1] / ie, v.displaySize[0] - Y[2] / ie, v.displaySize[1] - Y[3] / ie];
          }
          const C = e.left * m, k = e.right * m;
          let E, D, F, V;
          i === "width" || i === "both" ? (V = c[0] + C - u[3], D = c[0] + k + u[1]) : (V = c[0] + (C + k - v.displaySize[0]) / 2, D = V + v.displaySize[0]);
          const G = e.top * m, H = e.bottom * m;
          return i === "height" || i === "both" ? (E = c[1] + G - u[0], F = c[1] + H + u[2]) : (E = c[1] + (G + H - v.displaySize[1]) / 2, F = E + v.displaySize[1]), { image: v, top: E, right: D, bottom: F, left: V, collisionPadding: x };
        }
        const es = 128, Ds = 32640;
        function my(o, e) {
          const { expression: i } = e;
          if (i.kind === "constant") return { kind: "constant", layoutSize: i.evaluate(new qr(o + 1)) };
          if (i.kind === "source") return { kind: "source" };
          {
            const { zoomStops: u, interpolationType: c } = i;
            let m = 0;
            for (; m < u.length && u[m] <= o; ) m++;
            m = Math.max(0, m - 1);
            let v = m;
            for (; v < u.length && u[v] < o + 1; ) v++;
            v = Math.min(u.length - 1, v);
            const x = u[m], C = u[v];
            return i.kind === "composite" ? { kind: "composite", minZoom: x, maxZoom: C, interpolationType: c } : { kind: "camera", minZoom: x, maxZoom: C, minSize: i.evaluate(new qr(x)), maxSize: i.evaluate(new qr(C)), interpolationType: c };
          }
        }
        function cg(o, e, i) {
          let u = "never";
          const c = o.get(e);
          return c ? u = c : o.get(i) && (u = "always"), u;
        }
        const Qw = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function tp(o, e, i, u, c, m, v, x, C, k, E, D, F) {
          const V = x ? Math.min(Ds, Math.round(x[0])) : 0, G = x ? Math.min(Ds, Math.round(x[1])) : 0;
          o.emplaceBack(e, i, Math.round(32 * u), Math.round(32 * c), m, v, (V << 1) + (C ? 1 : 0), G, 16 * k, 16 * E, 256 * D, 256 * F);
        }
        function dg(o, e, i) {
          o.emplaceBack(e.x, e.y, i), o.emplaceBack(e.x, e.y, i), o.emplaceBack(e.x, e.y, i), o.emplaceBack(e.x, e.y, i);
        }
        function eC(o) {
          for (const e of o.sections) if (Nm(e.text)) return true;
          return false;
        }
        class hg {
          constructor(e) {
            this.layoutVertexArray = new Ne(), this.indexArray = new Tt(), this.programConfigurations = e, this.segments = new Yt(), this.dynamicLayoutVertexArray = new Ke(), this.opacityVertexArray = new Ze(), this.hasVisibleVertices = false, this.placedSymbolArray = new T();
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
          }
          upload(e, i, u, c) {
            this.isEmpty() || (u && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Pw.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, i), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, Iw.members, true), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, Qw, true), this.opacityVertexBuffer.itemSize = 1), (u || c) && this.programConfigurations.upload(e));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        Lt("SymbolBuffers", hg);
        class fg {
          constructor(e, i, u) {
            this.layoutVertexArray = new e(), this.layoutAttributes = i, this.indexArray = new u(), this.segments = new Yt(), this.collisionVertexArray = new Je();
          }
          upload(e) {
            this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, Ew.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        Lt("CollisionBuffers", fg);
        class nc {
          constructor(e) {
            this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(((v) => v.id)), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasDependencies = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const i = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = my(this.zoom, i["text-size"]), this.iconSizeData = my(this.zoom, i["icon-size"]);
            const u = this.layers[0].layout, c = u.get("symbol-sort-key"), m = u.get("symbol-z-order");
            this.canOverlap = cg(u, "text-overlap", "text-allow-overlap") !== "never" || cg(u, "icon-overlap", "icon-allow-overlap") !== "never" || u.get("text-ignore-placement") || u.get("icon-ignore-placement"), this.sortFeaturesByKey = m !== "viewport-y" && !c.isConstant(), this.sortFeaturesByY = (m === "viewport-y" || m === "auto" && !this.sortFeaturesByKey) && this.canOverlap, u.get("symbol-placement") === "point" && (this.writingModes = u.get("text-writing-mode").map(((v) => p.at[v]))), this.stateDependentLayerIds = this.layers.filter(((v) => v.isStateDependent())).map(((v) => v.id)), this.sourceID = e.sourceID;
          }
          createArrays() {
            this.text = new hg(new Qa(this.layers, this.zoom, ((e) => /^text/.test(e)))), this.icon = new hg(new Qa(this.layers, this.zoom, ((e) => /^icon/.test(e)))), this.glyphOffsetArray = new z(), this.lineVertexArray = new W(), this.symbolInstances = new R(), this.textAnchorOffsets = new X();
          }
          calculateGlyphDependencies(e, i, u, c, m) {
            for (let v = 0; v < e.length; v++) if (i[e.charCodeAt(v)] = true, (u || c) && m) {
              const x = Hd[e.charAt(v)];
              x && (i[x.charCodeAt(0)] = true);
            }
          }
          populate(e, i, u) {
            const c = this.layers[0], m = c.layout, v = m.get("text-font"), x = m.get("text-field"), C = m.get("icon-image"), k = (x.value.kind !== "constant" || x.value.value instanceof Mi && !x.value.value.isEmpty() || x.value.value.toString().length > 0) && (v.value.kind !== "constant" || v.value.value.length > 0), E = C.value.kind !== "constant" || !!C.value.value || Object.keys(C.parameters).length > 0, D = m.get("symbol-sort-key");
            if (this.features = [], !k && !E) return;
            const F = i.iconDependencies, V = i.glyphDependencies, G = i.availableImages, H = new qr(this.zoom);
            for (const { feature: Y, id: ie, index: we, sourceLayerIndex: ce } of e) {
              const pe = c._featureFilter.needGeometry, Te = Pa(Y, pe);
              if (!c._featureFilter.filter(H, Te, u)) continue;
              let Oe, Xe;
              if (pe || (Te.geometry = Ta(Y)), k) {
                const ft = c.getValueAndResolveTokens("text-field", Te, u, G), wt = Mi.factory(ft), Rt = this.hasRTLText = this.hasRTLText || eC(wt);
                (!Rt || Ko.getRTLTextPluginStatus() === "unavailable" || Rt && Ko.isParsed()) && (Oe = Dw(wt, c, Te));
              }
              if (E) {
                const ft = c.getValueAndResolveTokens("icon-image", Te, u, G);
                Xe = ft instanceof Bn ? ft : Bn.fromString(ft);
              }
              if (!Oe && !Xe) continue;
              const yt = this.sortFeaturesByKey ? D.evaluate(Te, {}, u) : void 0;
              if (this.features.push({ id: ie, text: Oe, icon: Xe, index: we, sourceLayerIndex: ce, geometry: Te.geometry, properties: Y.properties, type: tc.types[Y.type], sortKey: yt }), Xe && (F[Xe.name] = true), Oe) {
                const ft = v.evaluate(Te, {}, u).join(","), wt = m.get("text-rotation-alignment") !== "viewport" && m.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(p.at.vertical) >= 0;
                for (const Rt of Oe.sections) if (Rt.image) F[Rt.image.name] = true;
                else {
                  const Et = kd(Oe.toString()), Mt = Rt.fontStack || ft, lt = V[Mt] = V[Mt] || {};
                  this.calculateGlyphDependencies(Rt.text, lt, wt, this.allowVerticalPlacement, Et);
                }
              }
            }
            m.get("symbol-placement") === "line" && (this.features = (function(Y) {
              const ie = {}, we = {}, ce = [];
              let pe = 0;
              function Te(ft) {
                ce.push(Y[ft]), pe++;
              }
              function Oe(ft, wt, Rt) {
                const Et = we[ft];
                return delete we[ft], we[wt] = Et, ce[Et].geometry[0].pop(), ce[Et].geometry[0] = ce[Et].geometry[0].concat(Rt[0]), Et;
              }
              function Xe(ft, wt, Rt) {
                const Et = ie[wt];
                return delete ie[wt], ie[ft] = Et, ce[Et].geometry[0].shift(), ce[Et].geometry[0] = Rt[0].concat(ce[Et].geometry[0]), Et;
              }
              function yt(ft, wt, Rt) {
                const Et = Rt ? wt[0][wt[0].length - 1] : wt[0][0];
                return `${ft}:${Et.x}:${Et.y}`;
              }
              for (let ft = 0; ft < Y.length; ft++) {
                const wt = Y[ft], Rt = wt.geometry, Et = wt.text ? wt.text.toString() : null;
                if (!Et) {
                  Te(ft);
                  continue;
                }
                const Mt = yt(Et, Rt), lt = yt(Et, Rt, true);
                if (Mt in we && lt in ie && we[Mt] !== ie[lt]) {
                  const rr = Xe(Mt, lt, Rt), Qt = Oe(Mt, lt, ce[rr].geometry);
                  delete ie[Mt], delete we[lt], we[yt(Et, ce[Qt].geometry, true)] = Qt, ce[rr].geometry = null;
                } else Mt in we ? Oe(Mt, lt, Rt) : lt in ie ? Xe(Mt, lt, Rt) : (Te(ft), ie[Mt] = pe - 1, we[lt] = pe - 1);
              }
              return ce.filter(((ft) => ft.geometry));
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((Y, ie) => Y.sortKey - ie.sortKey));
          }
          update(e, i, u) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(e, i, this.layers, { imagePositions: u }), this.icon.programConfigurations.updatePaintArrays(e, i, this.layers, { imagePositions: u }));
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(e) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(e, i) {
            const u = this.lineVertexArray.length;
            if (e.segment !== void 0) {
              let c = e.dist(i[e.segment + 1]), m = e.dist(i[e.segment]);
              const v = {};
              for (let x = e.segment + 1; x < i.length; x++) v[x] = { x: i[x].x, y: i[x].y, tileUnitDistanceFromAnchor: c }, x < i.length - 1 && (c += i[x + 1].dist(i[x]));
              for (let x = e.segment || 0; x >= 0; x--) v[x] = { x: i[x].x, y: i[x].y, tileUnitDistanceFromAnchor: m }, x > 0 && (m += i[x - 1].dist(i[x]));
              for (let x = 0; x < i.length; x++) {
                const C = v[x];
                this.lineVertexArray.emplaceBack(C.x, C.y, C.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: u, lineLength: this.lineVertexArray.length - u };
          }
          addSymbols(e, i, u, c, m, v, x, C, k, E, D, F) {
            const V = e.indexArray, G = e.layoutVertexArray, H = e.segments.prepareSegment(4 * i.length, G, V, this.canOverlap ? v.sortKey : void 0), Y = this.glyphOffsetArray.length, ie = H.vertexLength, we = this.allowVerticalPlacement && x === p.at.vertical ? Math.PI / 2 : 0, ce = v.text && v.text.sections;
            for (let pe = 0; pe < i.length; pe++) {
              const { tl: Te, tr: Oe, bl: Xe, br: yt, tex: ft, pixelOffsetTL: wt, pixelOffsetBR: Rt, minFontScaleX: Et, minFontScaleY: Mt, glyphOffset: lt, isSDF: rr, sectionIndex: Qt } = i[pe], tr = H.vertexLength, Vt = lt[1];
              tp(G, C.x, C.y, Te.x, Vt + Te.y, ft.x, ft.y, u, rr, wt.x, wt.y, Et, Mt), tp(G, C.x, C.y, Oe.x, Vt + Oe.y, ft.x + ft.w, ft.y, u, rr, Rt.x, wt.y, Et, Mt), tp(G, C.x, C.y, Xe.x, Vt + Xe.y, ft.x, ft.y + ft.h, u, rr, wt.x, Rt.y, Et, Mt), tp(G, C.x, C.y, yt.x, Vt + yt.y, ft.x + ft.w, ft.y + ft.h, u, rr, Rt.x, Rt.y, Et, Mt), dg(e.dynamicLayoutVertexArray, C, we), V.emplaceBack(tr, tr + 2, tr + 1), V.emplaceBack(tr + 1, tr + 2, tr + 3), H.vertexLength += 4, H.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(lt[0]), pe !== i.length - 1 && Qt === i[pe + 1].sectionIndex || e.programConfigurations.populatePaintArrays(G.length, v, v.index, { imagePositions: {}, canonical: F, formattedSection: ce && ce[Qt] });
            }
            e.placedSymbolArray.emplaceBack(C.x, C.y, Y, this.glyphOffsetArray.length - Y, ie, k, E, C.segment, u ? u[0] : 0, u ? u[1] : 0, c[0], c[1], x, 0, false, 0, D);
          }
          _addCollisionDebugVertex(e, i, u, c, m, v) {
            return i.emplaceBack(0, 0), e.emplaceBack(u.x, u.y, c, m, Math.round(v.x), Math.round(v.y));
          }
          addCollisionDebugVertices(e, i, u, c, m, v, x) {
            const C = m.segments.prepareSegment(4, m.layoutVertexArray, m.indexArray), k = C.vertexLength, E = m.layoutVertexArray, D = m.collisionVertexArray, F = x.anchorX, V = x.anchorY;
            this._addCollisionDebugVertex(E, D, v, F, V, new S(e, i)), this._addCollisionDebugVertex(E, D, v, F, V, new S(u, i)), this._addCollisionDebugVertex(E, D, v, F, V, new S(u, c)), this._addCollisionDebugVertex(E, D, v, F, V, new S(e, c)), C.vertexLength += 4;
            const G = m.indexArray;
            G.emplaceBack(k, k + 1), G.emplaceBack(k + 1, k + 2), G.emplaceBack(k + 2, k + 3), G.emplaceBack(k + 3, k), C.primitiveLength += 4;
          }
          addDebugCollisionBoxes(e, i, u, c) {
            for (let m = e; m < i; m++) {
              const v = this.collisionBoxArray.get(m);
              this.addCollisionDebugVertices(v.x1, v.y1, v.x2, v.y2, c ? this.textCollisionBox : this.iconCollisionBox, v.anchorPoint, u);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new fg(He, ry.members, It), this.iconCollisionBox = new fg(He, ry.members, It);
            for (let e = 0; e < this.symbolInstances.length; e++) {
              const i = this.symbolInstances.get(e);
              this.addDebugCollisionBoxes(i.textBoxStartIndex, i.textBoxEndIndex, i, true), this.addDebugCollisionBoxes(i.verticalTextBoxStartIndex, i.verticalTextBoxEndIndex, i, true), this.addDebugCollisionBoxes(i.iconBoxStartIndex, i.iconBoxEndIndex, i, false), this.addDebugCollisionBoxes(i.verticalIconBoxStartIndex, i.verticalIconBoxEndIndex, i, false);
            }
          }
          _deserializeCollisionBoxesForSymbol(e, i, u, c, m, v, x, C, k) {
            const E = {};
            for (let D = i; D < u; D++) {
              const F = e.get(D);
              E.textBox = { x1: F.x1, y1: F.y1, x2: F.x2, y2: F.y2, anchorPointX: F.anchorPointX, anchorPointY: F.anchorPointY }, E.textFeatureIndex = F.featureIndex;
              break;
            }
            for (let D = c; D < m; D++) {
              const F = e.get(D);
              E.verticalTextBox = { x1: F.x1, y1: F.y1, x2: F.x2, y2: F.y2, anchorPointX: F.anchorPointX, anchorPointY: F.anchorPointY }, E.verticalTextFeatureIndex = F.featureIndex;
              break;
            }
            for (let D = v; D < x; D++) {
              const F = e.get(D);
              E.iconBox = { x1: F.x1, y1: F.y1, x2: F.x2, y2: F.y2, anchorPointX: F.anchorPointX, anchorPointY: F.anchorPointY }, E.iconFeatureIndex = F.featureIndex;
              break;
            }
            for (let D = C; D < k; D++) {
              const F = e.get(D);
              E.verticalIconBox = { x1: F.x1, y1: F.y1, x2: F.x2, y2: F.y2, anchorPointX: F.anchorPointX, anchorPointY: F.anchorPointY }, E.verticalIconFeatureIndex = F.featureIndex;
              break;
            }
            return E;
          }
          deserializeCollisionBoxes(e) {
            this.collisionArrays = [];
            for (let i = 0; i < this.symbolInstances.length; i++) {
              const u = this.symbolInstances.get(i);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, u.textBoxStartIndex, u.textBoxEndIndex, u.verticalTextBoxStartIndex, u.verticalTextBoxEndIndex, u.iconBoxStartIndex, u.iconBoxEndIndex, u.verticalIconBoxStartIndex, u.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(e, i) {
            const u = e.placedSymbolArray.get(i), c = u.vertexStartIndex + 4 * u.numGlyphs;
            for (let m = u.vertexStartIndex; m < c; m += 4) e.indexArray.emplaceBack(m, m + 2, m + 1), e.indexArray.emplaceBack(m + 1, m + 2, m + 3);
          }
          getSortedSymbolIndexes(e) {
            if (this.sortedAngle === e && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const i = Math.sin(e), u = Math.cos(e), c = [], m = [], v = [];
            for (let x = 0; x < this.symbolInstances.length; ++x) {
              v.push(x);
              const C = this.symbolInstances.get(x);
              c.push(0 | Math.round(i * C.anchorX + u * C.anchorY)), m.push(C.featureIndex);
            }
            return v.sort(((x, C) => c[x] - c[C] || m[C] - m[x])), v;
          }
          addToSortKeyRanges(e, i) {
            const u = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            u && u.sortKey === i ? u.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({ sortKey: i, symbolInstanceStart: e, symbolInstanceEnd: e + 1 });
          }
          sortFeatures(e) {
            if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const i of this.symbolInstanceIndexes) {
                const u = this.symbolInstances.get(i);
                this.featureSortOrder.push(u.featureIndex), [u.rightJustifiedTextSymbolIndex, u.centerJustifiedTextSymbolIndex, u.leftJustifiedTextSymbolIndex].forEach(((c, m, v) => {
                  c >= 0 && v.indexOf(c) === m && this.addIndicesForPlacedSymbol(this.text, c);
                })), u.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, u.verticalPlacedTextSymbolIndex), u.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, u.placedIconSymbolIndex), u.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, u.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let gy, vy;
        Lt("SymbolBucket", nc, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), nc.MAX_GLYPHS = 65535, nc.addDynamicAttributes = dg;
        var pg = { get paint() {
          return vy = vy || new En({ "icon-opacity": new or(se.paint_symbol["icon-opacity"]), "icon-color": new or(se.paint_symbol["icon-color"]), "icon-halo-color": new or(se.paint_symbol["icon-halo-color"]), "icon-halo-width": new or(se.paint_symbol["icon-halo-width"]), "icon-halo-blur": new or(se.paint_symbol["icon-halo-blur"]), "icon-translate": new Wt(se.paint_symbol["icon-translate"]), "icon-translate-anchor": new Wt(se.paint_symbol["icon-translate-anchor"]), "text-opacity": new or(se.paint_symbol["text-opacity"]), "text-color": new or(se.paint_symbol["text-color"], { runtimeType: hi, getOverride: (o) => o.textColor, hasOverride: (o) => !!o.textColor }), "text-halo-color": new or(se.paint_symbol["text-halo-color"]), "text-halo-width": new or(se.paint_symbol["text-halo-width"]), "text-halo-blur": new or(se.paint_symbol["text-halo-blur"]), "text-translate": new Wt(se.paint_symbol["text-translate"]), "text-translate-anchor": new Wt(se.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return gy = gy || new En({ "symbol-placement": new Wt(se.layout_symbol["symbol-placement"]), "symbol-spacing": new Wt(se.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Wt(se.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new or(se.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Wt(se.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Wt(se.layout_symbol["icon-allow-overlap"]), "icon-overlap": new Wt(se.layout_symbol["icon-overlap"]), "icon-ignore-placement": new Wt(se.layout_symbol["icon-ignore-placement"]), "icon-optional": new Wt(se.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Wt(se.layout_symbol["icon-rotation-alignment"]), "icon-size": new or(se.layout_symbol["icon-size"]), "icon-text-fit": new Wt(se.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Wt(se.layout_symbol["icon-text-fit-padding"]), "icon-image": new or(se.layout_symbol["icon-image"]), "icon-rotate": new or(se.layout_symbol["icon-rotate"]), "icon-padding": new or(se.layout_symbol["icon-padding"]), "icon-keep-upright": new Wt(se.layout_symbol["icon-keep-upright"]), "icon-offset": new or(se.layout_symbol["icon-offset"]), "icon-anchor": new or(se.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Wt(se.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Wt(se.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Wt(se.layout_symbol["text-rotation-alignment"]), "text-field": new or(se.layout_symbol["text-field"]), "text-font": new or(se.layout_symbol["text-font"]), "text-size": new or(se.layout_symbol["text-size"]), "text-max-width": new or(se.layout_symbol["text-max-width"]), "text-line-height": new Wt(se.layout_symbol["text-line-height"]), "text-letter-spacing": new or(se.layout_symbol["text-letter-spacing"]), "text-justify": new or(se.layout_symbol["text-justify"]), "text-radial-offset": new or(se.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Wt(se.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new or(se.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new or(se.layout_symbol["text-anchor"]), "text-max-angle": new Wt(se.layout_symbol["text-max-angle"]), "text-writing-mode": new Wt(se.layout_symbol["text-writing-mode"]), "text-rotate": new or(se.layout_symbol["text-rotate"]), "text-padding": new Wt(se.layout_symbol["text-padding"]), "text-keep-upright": new Wt(se.layout_symbol["text-keep-upright"]), "text-transform": new or(se.layout_symbol["text-transform"]), "text-offset": new or(se.layout_symbol["text-offset"]), "text-allow-overlap": new Wt(se.layout_symbol["text-allow-overlap"]), "text-overlap": new Wt(se.layout_symbol["text-overlap"]), "text-ignore-placement": new Wt(se.layout_symbol["text-ignore-placement"]), "text-optional": new Wt(se.layout_symbol["text-optional"]) });
        } };
        class yy {
          constructor(e) {
            if (e.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = e.property.overrides ? e.property.overrides.runtimeType : ur, this.defaultValue = e;
          }
          evaluate(e) {
            if (e.formattedSection) {
              const i = this.defaultValue.property.overrides;
              if (i && i.hasOverride(e.formattedSection)) return i.getOverride(e.formattedSection);
            }
            return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(e) {
            this.defaultValue.isConstant() || e(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        Lt("FormatSectionOverride", yy, { omit: ["defaultValue"] });
        class rp extends so {
          constructor(e, i) {
            super(e, pg, i);
          }
          recalculate(e, i) {
            if (super.recalculate(e, i), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const u = this.layout.get("text-writing-mode");
              if (u) {
                const c = [];
                for (const m of u) c.indexOf(m) < 0 && c.push(m);
                this.layout._values["text-writing-mode"] = c;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(e, i, u, c) {
            const m = this.layout.get(e).evaluate(i, {}, u, c), v = this._unevaluatedLayout._values[e];
            return v.isDataDriven() || Iu(v.value) || !m ? m : (function(x, C) {
              return C.replace(/{([^{}]+)}/g, ((k, E) => x && E in x ? String(x[E]) : ""));
            })(i.properties, m);
          }
          createBucket(e) {
            return new nc(e);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const e of pg.paint.overridableProperties) {
              if (!rp.hasPaintOverride(this.layout, e)) continue;
              const i = this.paint.get(e), u = new yy(i), c = new Pu(u, i.property.specification);
              let m = null;
              m = i.value.kind === "constant" || i.value.kind === "source" ? new Za("source", c) : new Mu("composite", c, i.value.zoomStops), this.paint._values[e] = new xo(i.property, m, i.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(e, i, u) {
            return !(!this.layout || i.isDataDriven() || u.isDataDriven()) && rp.hasPaintOverride(this.layout, e);
          }
          static hasPaintOverride(e, i) {
            const u = e.get("text-field"), c = pg.paint.properties[i];
            let m = false;
            const v = (x) => {
              for (const C of x) if (c.overrides && c.overrides.hasOverride(C)) return void (m = true);
            };
            if (u.value.kind === "constant" && u.value.value instanceof Mi) v(u.value.value.sections);
            else if (u.value.kind === "source" || u.value.kind === "composite") {
              const x = (k) => {
                m || (k instanceof ba && ei(k.value) === Lo ? v(k.value.sections) : k instanceof Va ? v(k.sections) : k.eachChild(x));
              }, C = u.value;
              C._styleExpression && x(C._styleExpression.expression);
            }
            return m;
          }
        }
        let _y;
        var tC = { get paint() {
          return _y = _y || new En({ "background-color": new Wt(se.paint_background["background-color"]), "background-pattern": new Vu(se.paint_background["background-pattern"]), "background-opacity": new Wt(se.paint_background["background-opacity"]) });
        } };
        class rC extends so {
          constructor(e, i) {
            super(e, tC, i);
          }
        }
        class iC extends so {
          constructor(e, i) {
            super(e, {}, i), this.onAdd = (u) => {
              this.implementation.onAdd && this.implementation.onAdd(u, u.painter.context.gl);
            }, this.onRemove = (u) => {
              this.implementation.onRemove && this.implementation.onRemove(u, u.painter.context.gl);
            }, this.implementation = e;
          }
          is3D() {
            return this.implementation.renderingMode === "3d";
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return false;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class nC {
          constructor(e) {
            this._methodToThrottle = e, this._triggered = false, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout((() => {
              this._triggered = false, this._methodToThrottle();
            }), 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const oC = { once: true }, mg = 63710088e-1;
        class Rs {
          constructor(e, i) {
            if (isNaN(e) || isNaN(i)) throw new Error(`Invalid LngLat object: (${e}, ${i})`);
            if (this.lng = +e, this.lat = +i, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new Rs(Dt(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(e) {
            const i = Math.PI / 180, u = this.lat * i, c = e.lat * i, m = Math.sin(u) * Math.sin(c) + Math.cos(u) * Math.cos(c) * Math.cos((e.lng - this.lng) * i);
            return mg * Math.acos(Math.min(m, 1));
          }
          static convert(e) {
            if (e instanceof Rs) return e;
            if (Array.isArray(e) && (e.length === 2 || e.length === 3)) return new Rs(Number(e[0]), Number(e[1]));
            if (!Array.isArray(e) && typeof e == "object" && e !== null) return new Rs(Number("lng" in e ? e.lng : e.lon), Number(e.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const by = 2 * Math.PI * mg;
        function xy(o) {
          return by * Math.cos(o * Math.PI / 180);
        }
        function wy(o) {
          return (180 + o) / 360;
        }
        function Cy(o) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + o * Math.PI / 360))) / 360;
        }
        function Sy(o, e) {
          return o / xy(e);
        }
        function ky(o) {
          return 360 * o - 180;
        }
        function ip(o) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * o) * Math.PI / 180)) - 90;
        }
        function Ty(o, e) {
          return o * xy(ip(e));
        }
        class Yd {
          constructor(e, i, u = 0) {
            this.x = +e, this.y = +i, this.z = +u;
          }
          static fromLngLat(e, i = 0) {
            const u = Rs.convert(e);
            return new Yd(wy(u.lng), Cy(u.lat), Sy(i, u.lat));
          }
          toLngLat() {
            return new Rs(ky(this.x), ip(this.y));
          }
          toAltitude() {
            return Ty(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / by * (e = ip(this.y), 1 / Math.cos(e * Math.PI / 180));
            var e;
          }
        }
        function Py(o, e, i) {
          var u = 2 * Math.PI * 6378137 / 256 / Math.pow(2, i);
          return [o * u - 2 * Math.PI * 6378137 / 2, e * u - 2 * Math.PI * 6378137 / 2];
        }
        class gg {
          constructor(e, i, u) {
            if (!(function(c, m, v) {
              return !(c < 0 || c > 25 || v < 0 || v >= Math.pow(2, c) || m < 0 || m >= Math.pow(2, c));
            })(e, i, u)) throw new Error(`x=${i}, y=${u}, z=${e} outside of bounds. 0<=x<${Math.pow(2, e)}, 0<=y<${Math.pow(2, e)} 0<=z<=25 `);
            this.z = e, this.x = i, this.y = u, this.key = oc(0, e, e, i, u);
          }
          equals(e) {
            return this.z === e.z && this.x === e.x && this.y === e.y;
          }
          url(e, i, u) {
            const c = (v = this.y, x = this.z, C = Py(256 * (m = this.x), 256 * (v = Math.pow(2, x) - v - 1), x), k = Py(256 * (m + 1), 256 * (v + 1), x), C[0] + "," + C[1] + "," + k[0] + "," + k[1]);
            var m, v, x, C, k;
            const E = (function(D, F, V) {
              let G, H = "";
              for (let Y = D; Y > 0; Y--) G = 1 << Y - 1, H += (F & G ? 1 : 0) + (V & G ? 2 : 0);
              return H;
            })(this.z, this.x, this.y);
            return e[(this.x + this.y) % e.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(u === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, i > 1 ? "@2x" : "").replace(/{quadkey}/g, E).replace(/{bbox-epsg-3857}/g, c);
          }
          isChildOf(e) {
            const i = this.z - e.z;
            return i > 0 && e.x === this.x >> i && e.y === this.y >> i;
          }
          getTilePoint(e) {
            const i = Math.pow(2, this.z);
            return new S((e.x * i - this.x) * it, (e.y * i - this.y) * it);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class Iy {
          constructor(e, i) {
            this.wrap = e, this.canonical = i, this.key = oc(e, i.z, i.z, i.x, i.y);
          }
        }
        class Co {
          constructor(e, i, u, c, m) {
            if (this.terrainRttPosMatrix32f = null, e < u) throw new Error(`overscaledZ should be >= z; overscaledZ = ${e}; z = ${u}`);
            this.overscaledZ = e, this.wrap = i, this.canonical = new gg(u, +c, +m), this.key = oc(i, e, u, c, m);
          }
          clone() {
            return new Co(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(e) {
            return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical);
          }
          scaledTo(e) {
            if (e > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`);
            const i = this.canonical.z - e;
            return e > this.canonical.z ? new Co(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Co(e, this.wrap, e, this.canonical.x >> i, this.canonical.y >> i);
          }
          isOverscaled() {
            return this.overscaledZ > this.canonical.z;
          }
          calculateScaledKey(e, i) {
            if (e > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`);
            const u = this.canonical.z - e;
            return e > this.canonical.z ? oc(this.wrap * +i, e, this.canonical.z, this.canonical.x, this.canonical.y) : oc(this.wrap * +i, e, e, this.canonical.x >> u, this.canonical.y >> u);
          }
          isChildOf(e) {
            if (e.wrap !== this.wrap || this.overscaledZ - e.overscaledZ <= 0) return false;
            if (e.overscaledZ === 0) return this.overscaledZ > 0;
            const i = this.canonical.z - e.canonical.z;
            return !(i < 0) && e.canonical.x === this.canonical.x >> i && e.canonical.y === this.canonical.y >> i;
          }
          children(e) {
            if (this.overscaledZ >= e) return [new Co(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const i = this.canonical.z + 1, u = 2 * this.canonical.x, c = 2 * this.canonical.y;
            return [new Co(i, this.wrap, i, u, c), new Co(i, this.wrap, i, u + 1, c), new Co(i, this.wrap, i, u, c + 1), new Co(i, this.wrap, i, u + 1, c + 1)];
          }
          isLessThan(e) {
            return this.wrap < e.wrap || !(this.wrap > e.wrap) && (this.overscaledZ < e.overscaledZ || !(this.overscaledZ > e.overscaledZ) && (this.canonical.x < e.canonical.x || !(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y));
          }
          wrapped() {
            return new Co(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(e) {
            return new Co(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new Iy(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(e) {
            return this.canonical.getTilePoint(new Yd(e.x - this.wrap, e.y));
          }
        }
        function oc(o, e, i, u, c) {
          (o *= 2) < 0 && (o = -1 * o - 1);
          const m = 1 << i;
          return (m * m * o + m * c + u).toString(36) + i.toString(36) + e.toString(36);
        }
        function Kd(o, e) {
          return e ? o.properties[e] : o.id;
        }
        Lt("CanonicalTileID", gg), Lt("OverscaledTileID", Co, { omit: ["terrainRttPosMatrix32f"] });
        class Rl {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0;
          }
          extend(e) {
            return this.minX = Math.min(this.minX, e.x), this.minY = Math.min(this.minY, e.y), this.maxX = Math.max(this.maxX, e.x), this.maxY = Math.max(this.maxY, e.y), this;
          }
          expandBy(e) {
            return this.minX -= e, this.minY -= e, this.maxX += e, this.maxY += e, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this;
          }
          shrinkBy(e) {
            return this.expandBy(-e);
          }
          map(e) {
            const i = new Rl();
            return i.extend(e(new S(this.minX, this.minY))), i.extend(e(new S(this.maxX, this.minY))), i.extend(e(new S(this.minX, this.maxY))), i.extend(e(new S(this.maxX, this.maxY))), i;
          }
          static fromPoints(e) {
            const i = new Rl();
            for (const u of e) i.extend(u);
            return i;
          }
          contains(e) {
            return e.x >= this.minX && e.x <= this.maxX && e.y >= this.minY && e.y <= this.maxY;
          }
          empty() {
            return this.minX > this.maxX;
          }
          width() {
            return this.maxX - this.minX;
          }
          height() {
            return this.maxY - this.minY;
          }
          covers(e) {
            return !this.empty() && !e.empty() && e.minX >= this.minX && e.maxX <= this.maxX && e.minY >= this.minY && e.maxY <= this.maxY;
          }
          intersects(e) {
            return !this.empty() && !e.empty() && e.minX <= this.maxX && e.maxX >= this.minX && e.minY <= this.maxY && e.maxY >= this.minY;
          }
        }
        class Ey {
          constructor(e) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let i = 0; i < e.length; i++) {
              const u = e[i];
              this._stringToNumber[u] = i, this._numberToString[i] = u;
            }
          }
          encode(e) {
            return this._stringToNumber[e];
          }
          decode(e) {
            if (e >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${e} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[e];
          }
        }
        class My {
          constructor(e, i, u, c, m) {
            this.type = "Feature", this._vectorTileFeature = e, e._z = i, e._x = u, e._y = c, this.properties = e.properties, this.id = m;
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(e) {
            this._geometry = e;
          }
          toJSON() {
            const e = { geometry: this.geometry };
            for (const i in this) i !== "_geometry" && i !== "_vectorTileFeature" && (e[i] = this[i]);
            return e;
          }
        }
        class ac {
          constructor(e, i, u) {
            __publicField(this, "_name");
            __publicField(this, "dataBuffer");
            __publicField(this, "nullabilityBuffer");
            __publicField(this, "_size");
            this._name = e, this.dataBuffer = i, typeof u == "number" ? this._size = u : (this.nullabilityBuffer = u, this._size = u.size());
          }
          getValue(e) {
            return this.nullabilityBuffer && !this.nullabilityBuffer.get(e) ? null : this.getValueFromBuffer(e);
          }
          has(e) {
            return this.nullabilityBuffer && this.nullabilityBuffer.get(e) || !this.nullabilityBuffer;
          }
          get name() {
            return this._name;
          }
          get size() {
            return this._size;
          }
        }
        class np extends ac {
        }
        class vg extends np {
          getValueFromBuffer(e) {
            return this.dataBuffer[e];
          }
        }
        class yg extends np {
          getValueFromBuffer(e) {
            return this.dataBuffer[e];
          }
        }
        class Dy extends ac {
          constructor(e, i, u, c) {
            super(e, i, c);
            __publicField(this, "delta");
            this.delta = u;
          }
        }
        class _g extends Dy {
          constructor(e, i, u, c) {
            super(e, Int32Array.of(i), u, c);
          }
          getValueFromBuffer(e) {
            return this.dataBuffer[0] + e * this.delta;
          }
        }
        class bg extends ac {
          constructor(e, i, u) {
            super(e, Int32Array.of(i), u);
          }
          getValueFromBuffer(e) {
            return this.dataBuffer[0];
          }
        }
        class aC {
          constructor(e, i, u, c, m = 4096) {
            __publicField(this, "_name");
            __publicField(this, "_geometryVector");
            __publicField(this, "_idVector");
            __publicField(this, "_propertyVectors");
            __publicField(this, "_extent");
            __publicField(this, "propertyVectorsMap");
            this._name = e, this._geometryVector = i, this._idVector = u, this._propertyVectors = c, this._extent = m;
          }
          get name() {
            return this._name;
          }
          get idVector() {
            return this._idVector;
          }
          get geometryVector() {
            return this._geometryVector;
          }
          get propertyVectors() {
            return this._propertyVectors;
          }
          getPropertyVector(e) {
            return this.propertyVectorsMap || (this.propertyVectorsMap = new Map(this._propertyVectors.map(((i) => [i.name, i])))), this.propertyVectorsMap.get(e);
          }
          *[Symbol.iterator]() {
            const e = this.geometryVector[Symbol.iterator]();
            let i = 0;
            for (; i < this.numFeatures; ) {
              let u;
              this.idVector && (u = this.containsMaxSaveIntegerValues(this.idVector) ? Number(this.idVector.getValue(i)) : this.idVector.getValue(i));
              const c = e == null ? void 0 : e.next().value, m = {};
              for (const v of this.propertyVectors) {
                if (!v) continue;
                const x = v.name, C = v.getValue(i);
                C !== null && (m[x] = C);
              }
              i++, yield { id: u, geometry: c, properties: m };
            }
          }
          get numFeatures() {
            return this.geometryVector.numGeometries;
          }
          get extent() {
            return this._extent;
          }
          getFeatures() {
            const e = [], i = this.geometryVector.getGeometries();
            for (let u = 0; u < this.numFeatures; u++) {
              let c;
              this.idVector && (c = this.containsMaxSaveIntegerValues(this.idVector) ? Number(this.idVector.getValue(u)) : this.idVector.getValue(u));
              const m = { coordinates: i[u], type: this.geometryVector.geometryType(u) }, v = {};
              for (const x of this.propertyVectors) {
                if (!x) continue;
                const C = x.name, k = x.getValue(u);
                k !== null && (v[C] = k);
              }
              e.push({ id: c, geometry: m, properties: v });
            }
            return e;
          }
          containsMaxSaveIntegerValues(e) {
            return e instanceof vg || e instanceof bg && e instanceof _g || e instanceof yg;
          }
        }
        class sC {
          constructor(e) {
            __publicField(this, "value");
            this.value = e;
          }
          get() {
            return this.value;
          }
          set(e) {
            this.value = e;
          }
          increment() {
            return this.value++;
          }
          add(e) {
            this.value += e;
          }
        }
        var mn, Tr, ts, ia, Al, uo, Wi, Zi, Ry, So;
        (function(o) {
          o.PRESENT = "PRESENT", o.DATA = "DATA", o.OFFSET = "OFFSET", o.LENGTH = "LENGTH";
        })(mn || (mn = {}));
        class xg {
          constructor(e, i, u) {
            __publicField(this, "_dictionaryType");
            __publicField(this, "_offsetType");
            __publicField(this, "_lengthType");
            this._dictionaryType = e, this._offsetType = i, this._lengthType = u;
          }
          get dictionaryType() {
            return this._dictionaryType;
          }
          get offsetType() {
            return this._offsetType;
          }
          get lengthType() {
            return this._lengthType;
          }
        }
        function $i(o, e, i) {
          const u = new Int32Array(i);
          let c = 0, m = e.get();
          for (let v = 0; v < u.length; v++) {
            let x = o[m++], C = 127 & x;
            x < 128 || (x = o[m++], C |= (127 & x) << 7, x < 128 || (x = o[m++], C |= (127 & x) << 14, x < 128 || (x = o[m++], C |= (127 & x) << 21, x < 128 || (x = o[m++], C |= (15 & x) << 28)))), u[c++] = C;
          }
          return e.set(m), u;
        }
        function op(o, e, i) {
          const u = new BigInt64Array(i);
          for (let c = 0; c < u.length; c++) u[c] = uC(o, e);
          return u;
        }
        function lC(o, e) {
          let i, u;
          return u = o[e.get()], e.increment(), i = 127 & u, u < 128 ? i : (u = o[e.get()], e.increment(), i |= (127 & u) << 7, u < 128 ? i : (u = o[e.get()], e.increment(), i |= (127 & u) << 14, u < 128 ? i : (u = o[e.get()], e.increment(), i |= (127 & u) << 21, u < 128 ? i : (u = o[e.get()], i |= (15 & u) << 28, (function(c, m, v) {
            let x, C;
            if (C = m[v.get()], v.increment(), x = (112 & C) >> 4, C < 128 || (C = m[v.get()], v.increment(), x |= (127 & C) << 3, C < 128) || (C = m[v.get()], v.increment(), x |= (127 & C) << 10, C < 128) || (C = m[v.get()], v.increment(), x |= (127 & C) << 17, C < 128) || (C = m[v.get()], v.increment(), x |= (127 & C) << 24, C < 128) || (C = m[v.get()], v.increment(), x |= (1 & C) << 31, C < 128)) return 4294967296 * x + (c >>> 0);
            throw new Error("Expected varint not more than 10 bytes");
          })(i, o, e)))));
        }
        function Ay(o, e, i, u) {
          throw new Error("FastPFor is not implemented yet.");
        }
        function zl(o) {
          return o >>> 1 ^ -(1 & o);
        }
        function sc(o) {
          return o >> 1n ^ -(1n & o);
        }
        function uC(o, e) {
          let i = 0n, u = 0, c = e.get();
          for (; c < o.length; ) {
            const m = o[c++];
            if (i |= BigInt(127 & m) << BigInt(u), !(128 & m)) break;
            if (u += 7, u >= 64) throw new Error("Varint too long");
          }
          return e.set(c), i;
        }
        function zy(o, e, i) {
          const u = new Int32Array(i);
          let c = 0;
          for (let m = 0; m < e; m++) {
            const v = o[m];
            u.fill(o[m + e], c, c + v), c += v;
          }
          return u;
        }
        function Fy(o, e, i) {
          const u = new BigInt64Array(i);
          let c = 0;
          for (let m = 0; m < e; m++) {
            const v = Number(o[m]);
            u.fill(o[m + e], c, c + v), c += v;
          }
          return u;
        }
        function Ly(o, e, i) {
          const u = new Float64Array(i);
          let c = 0;
          for (let m = 0; m < e; m++) {
            const v = o[m];
            u.fill(o[m + e], c, c + v), c += v;
          }
          return u;
        }
        function wg(o) {
          const e = o.length / 4 * 4;
          let i = 1;
          if (e >= 4) for (let u = o[0]; i < e - 4; i += 4) u = o[i] += u, u = o[i + 1] += u, u = o[i + 2] += u, u = o[i + 3] += u;
          for (; i != o.length; ) o[i] += o[i - 1], ++i;
        }
        function By(o) {
          o[0] = o[0] >>> 1 ^ -(1 & o[0]), o[1] = o[1] >>> 1 ^ -(1 & o[1]);
          const e = o.length / 4 * 4;
          let i = 2;
          if (e >= 4) for (; i < e - 4; i += 4) {
            const u = o[i], c = o[i + 1], m = o[i + 2], v = o[i + 3];
            o[i] = (u >>> 1 ^ -(1 & u)) + o[i - 2], o[i + 1] = (c >>> 1 ^ -(1 & c)) + o[i - 1], o[i + 2] = (m >>> 1 ^ -(1 & m)) + o[i], o[i + 3] = (v >>> 1 ^ -(1 & v)) + o[i + 1];
          }
          for (; i != o.length; i += 2) o[i] = (o[i] >>> 1 ^ -(1 & o[i])) + o[i - 2], o[i + 1] = (o[i + 1] >>> 1 ^ -(1 & o[i + 1])) + o[i - 1];
        }
        function As(o, e, i) {
          return Math.min(i, Math.max(e, o));
        }
        (function(o) {
          o.NONE = "NONE", o.DELTA = "DELTA", o.COMPONENTWISE_DELTA = "COMPONENTWISE_DELTA", o.RLE = "RLE", o.MORTON = "MORTON", o.PDE = "PDE";
        })(Tr || (Tr = {})), (function(o) {
          o.NONE = "NONE", o.FAST_PFOR = "FAST_PFOR", o.VARINT = "VARINT", o.ALP = "ALP";
        })(ts || (ts = {})), (function(o) {
          o.NONE = "NONE", o.SINGLE = "SINGLE", o.SHARED = "SHARED", o.VERTEX = "VERTEX", o.MORTON = "MORTON", o.FSST = "FSST";
        })(ia || (ia = {})), (function(o) {
          o.VERTEX = "VERTEX", o.INDEX = "INDEX", o.STRING = "STRING", o.KEY = "KEY";
        })(Al || (Al = {})), (function(o) {
          o.VAR_BINARY = "VAR_BINARY", o.GEOMETRIES = "GEOMETRIES", o.PARTS = "PARTS", o.RINGS = "RINGS", o.TRIANGLES = "TRIANGLES", o.SYMBOL = "SYMBOL", o.DICTIONARY = "DICTIONARY";
        })(uo || (uo = {}));
        class Fl {
          constructor(e, i, u, c, m, v, x) {
            __publicField(this, "_physicalStreamType");
            __publicField(this, "_logicalStreamType");
            __publicField(this, "_logicalLevelTechnique1");
            __publicField(this, "_logicalLevelTechnique2");
            __publicField(this, "_physicalLevelTechnique");
            __publicField(this, "_numValues");
            __publicField(this, "_byteLength");
            this._physicalStreamType = e, this._logicalStreamType = i, this._logicalLevelTechnique1 = u, this._logicalLevelTechnique2 = c, this._physicalLevelTechnique = m, this._numValues = v, this._byteLength = x;
          }
          static decode(e, i) {
            const u = e[i.get()], c = Object.values(mn)[u >> 4];
            let m = null;
            switch (c) {
              case mn.DATA:
                m = new xg(Object.values(ia)[15 & u]);
                break;
              case mn.OFFSET:
                m = new xg(null, Object.values(Al)[15 & u]);
                break;
              case mn.LENGTH:
                m = new xg(null, null, Object.values(uo)[15 & u]);
            }
            i.increment();
            const v = e[i.get()], x = Object.values(Tr)[v >> 5], C = Object.values(Tr)[v >> 2 & 7], k = Object.values(ts)[3 & v];
            i.increment();
            const E = $i(e, i, 2);
            return new Fl(c, m, x, C, k, E[0], E[1]);
          }
          get physicalStreamType() {
            return this._physicalStreamType;
          }
          get logicalStreamType() {
            return this._logicalStreamType;
          }
          get logicalLevelTechnique1() {
            return this._logicalLevelTechnique1;
          }
          get logicalLevelTechnique2() {
            return this._logicalLevelTechnique2;
          }
          get physicalLevelTechnique() {
            return this._physicalLevelTechnique;
          }
          get numValues() {
            return this._numValues;
          }
          get byteLength() {
            return this._byteLength;
          }
          getDecompressedCount() {
            return this._numValues;
          }
        }
        class ap extends Fl {
          constructor(e, i, u, c, m, v, x, C, k) {
            super(e, i, u, c, m, v, x);
            __publicField(this, "num_bits");
            __publicField(this, "coordinate_shift");
            this.num_bits = C, this.coordinate_shift = k;
          }
          static decode(e, i) {
            const u = Fl.decode(e, i), c = $i(e, i, 2);
            return new ap(u.physicalStreamType, u.logicalStreamType, u.logicalLevelTechnique1, u.logicalLevelTechnique2, u.physicalLevelTechnique, u.numValues, u.byteLength, c[0], c[1]);
          }
          static decodePartial(e, i, u) {
            const c = $i(i, u, 2);
            return new ap(e.physicalStreamType, e.logicalStreamType, e.logicalLevelTechnique1, e.logicalLevelTechnique2, e.physicalLevelTechnique, e.numValues, e.byteLength, c[0], c[1]);
          }
          numBits() {
            return this.num_bits;
          }
          coordinateShift() {
            return this.coordinate_shift;
          }
        }
        class Jd extends Fl {
          constructor(e, i, u, c, m, v, x, C, k) {
            super(e, i, u, c, m, v, x);
            __publicField(this, "_runs");
            __publicField(this, "_numRleValues");
            this._runs = C, this._numRleValues = k;
          }
          static decode(e, i) {
            const u = Fl.decode(e, i), c = $i(e, i, 2);
            return new Jd(u.physicalStreamType, u.logicalStreamType, u.logicalLevelTechnique1, u.logicalLevelTechnique2, u.physicalLevelTechnique, u.numValues, u.byteLength, c[0], c[1]);
          }
          static decodePartial(e, i, u) {
            const c = $i(i, u, 2);
            return new Jd(e.physicalStreamType, e.logicalStreamType, e.logicalLevelTechnique1, e.logicalLevelTechnique2, e.physicalLevelTechnique, e.numValues, e.byteLength, c[0], c[1]);
          }
          get runs() {
            return this._runs;
          }
          get numRleValues() {
            return this._numRleValues;
          }
          getDecompressedCount() {
            return this._numRleValues;
          }
        }
        class Mn {
          static decode(e, i) {
            const u = Fl.decode(e, i);
            return u.logicalLevelTechnique1 === Tr.MORTON ? ap.decodePartial(u, e, i) : Tr.RLE !== u.logicalLevelTechnique1 && Tr.RLE !== u.logicalLevelTechnique2 || ts.NONE === u.physicalLevelTechnique ? u : Jd.decodePartial(u, e, i);
          }
        }
        (function(o) {
          o[o.FLAT = 0] = "FLAT", o[o.CONST = 1] = "CONST", o[o.SEQUENCE = 2] = "SEQUENCE", o[o.DICTIONARY = 3] = "DICTIONARY", o[o.FSST_DICTIONARY = 4] = "FSST_DICTIONARY";
        })(Wi || (Wi = {}));
        class na {
          constructor(e, i) {
            __publicField(this, "values");
            __publicField(this, "_size");
            this.values = e, this._size = i;
          }
          get(e) {
            const i = Math.floor(e / 8);
            return (this.values[i] >> e % 8 & 1) == 1;
          }
          set(e, i) {
            const u = Math.floor(e / 8);
            this.values[u] = this.values[u] | (i ? 1 : 0) << e % 8;
          }
          getInt(e) {
            const i = Math.floor(e / 8);
            return this.values[i] >> e % 8 & 1;
          }
          size() {
            return this._size;
          }
          getBuffer() {
            return this.values;
          }
        }
        class pr {
          constructor() {
          }
          static decodeIntStream(e, i, u, c, m) {
            const v = pr.decodePhysicalLevelTechnique(e, i, u);
            return this.decodeIntBuffer(v, u, c, m);
          }
          static decodeLengthStreamToOffsetBuffer(e, i, u) {
            const c = pr.decodePhysicalLevelTechnique(e, i, u);
            return this.decodeLengthToOffsetBuffer(c, u);
          }
          static decodePhysicalLevelTechnique(e, i, u) {
            const c = u.physicalLevelTechnique;
            if (c === ts.FAST_PFOR) return Ay();
            if (c === ts.VARINT) return $i(e, i, u.numValues);
            if (c === ts.NONE) {
              const m = i.get();
              i.add(u.byteLength);
              const v = e.subarray(m, i.get());
              return new Int32Array(v);
            }
            throw new Error("Specified physicalLevelTechnique is not supported (yet).");
          }
          static decodeConstIntStream(e, i, u, c) {
            const m = pr.decodePhysicalLevelTechnique(e, i, u);
            if (m.length === 1) {
              const v = m[0];
              return c ? zl(v) : v;
            }
            return c ? (function(v) {
              return zl(v[1]);
            })(m) : (function(v) {
              return v[1];
            })(m);
          }
          static decodeSequenceIntStream(e, i, u) {
            return (function(c) {
              if (c.length == 2) {
                const m = zl(c[1]);
                return [m, m];
              }
              return [zl(c[2]), zl(c[3])];
            })(pr.decodePhysicalLevelTechnique(e, i, u));
          }
          static decodeSequenceLongStream(e, i, u) {
            return (function(c) {
              if (c.length == 2) {
                const m = sc(c[1]);
                return [m, m];
              }
              return [sc(c[2]), sc(c[3])];
            })(op(e, i, u.numValues));
          }
          static decodeLongStream(e, i, u, c) {
            const m = op(e, i, u.numValues);
            return this.decodeLongBuffer(m, u, c);
          }
          static decodeLongFloat64Stream(e, i, u, c) {
            const m = (function(v, x, C) {
              const k = new Float64Array(x);
              for (let E = 0; E < x; E++) k[E] = lC(v, C);
              return k;
            })(e, u.numValues, i);
            return this.decodeFloat64Buffer(m, u, c);
          }
          static decodeConstLongStream(e, i, u, c) {
            const m = op(e, i, u.numValues);
            if (m.length === 1) {
              const v = m[0];
              return c ? sc(v) : v;
            }
            return c ? (function(v) {
              return sc(v[1]);
            })(m) : (function(v) {
              return v[1];
            })(m);
          }
          static decodeIntBuffer(e, i, u, c) {
            switch (i.logicalLevelTechnique1) {
              case Tr.DELTA:
                return i.logicalLevelTechnique2 === Tr.RLE ? (function(m, v, x) {
                  const C = new Int32Array(x);
                  let k = 0, E = 0;
                  for (let D = 0; D < v; D++) {
                    const F = m[D], V = zl(m[D + v]);
                    for (let G = 0; G < F; G++) E += V, C[k++] = E;
                  }
                  return C;
                })(e, i.runs, i.numRleValues) : ((function(m) {
                  m[0] = m[0] >>> 1 ^ -(1 & m[0]);
                  const v = m.length / 4 * 4;
                  let x = 1;
                  if (v >= 4) for (; x < v - 4; x += 4) {
                    const C = m[x], k = m[x + 1], E = m[x + 2], D = m[x + 3];
                    m[x] = (C >>> 1 ^ -(1 & C)) + m[x - 1], m[x + 1] = (k >>> 1 ^ -(1 & k)) + m[x], m[x + 2] = (E >>> 1 ^ -(1 & E)) + m[x + 1], m[x + 3] = (D >>> 1 ^ -(1 & D)) + m[x + 2];
                  }
                  for (; x != m.length; ++x) m[x] = (m[x] >>> 1 ^ -(1 & m[x])) + m[x - 1];
                })(e), e);
              case Tr.RLE:
                return (function(m, v, x) {
                  return x ? (function(C, k, E) {
                    const D = new Int32Array(E);
                    let F = 0;
                    for (let V = 0; V < k; V++) {
                      const G = C[V];
                      let H = C[V + k];
                      H = H >>> 1 ^ -(1 & H), D.fill(H, F, F + G), F += G;
                    }
                    return D;
                  })(m, v.runs, v.numRleValues) : zy(m, v.runs, v.numRleValues);
                })(e, i, u);
              case Tr.MORTON:
                return wg(e), e;
              case Tr.COMPONENTWISE_DELTA:
                return c ? ((function(m, v, x, C) {
                  let k = m[0] >>> 1 ^ -(1 & m[0]), E = m[1] >>> 1 ^ -(1 & m[1]);
                  m[0] = As(Math.round(k * v), x, C), m[1] = As(Math.round(E * v), x, C);
                  const D = m.length / 16;
                  let F = 2;
                  if (D >= 4) for (; F < D - 4; F += 4) {
                    const V = m[F], G = m[F + 1], H = (V >>> 1 ^ -(1 & V)) + k, Y = (G >>> 1 ^ -(1 & G)) + E;
                    m[F] = As(Math.round(H * v), x, C), m[F + 1] = As(Math.round(Y * v), x, C);
                    const ie = m[F + 2], we = m[F + 3];
                    k = (ie >>> 1 ^ -(1 & ie)) + H, E = (we >>> 1 ^ -(1 & we)) + Y, m[F + 2] = As(Math.round(k * v), x, C), m[F + 3] = As(Math.round(E * v), x, C);
                  }
                  for (; F != m.length; F += 2) k += m[F] >>> 1 ^ -(1 & m[F]), E += m[F + 1] >>> 1 ^ -(1 & m[F + 1]), m[F] = As(Math.round(k * v), x, C), m[F + 1] = As(Math.round(E * v), x, C);
                })(e, c.scale, c.min, c.max), e) : (By(e), e);
              case Tr.NONE:
                return u && (function(m) {
                  for (let v = 0; v < m.length; v++) {
                    const x = m[v];
                    m[v] = x >>> 1 ^ -(1 & x);
                  }
                })(e), e;
              default:
                throw new Error(`The specified Logical level technique is not supported: ${i.logicalLevelTechnique1}`);
            }
          }
          static decodeLongBuffer(e, i, u) {
            switch (i.logicalLevelTechnique1) {
              case Tr.DELTA:
                return i.logicalLevelTechnique2 === Tr.RLE ? (function(c, m, v) {
                  const x = new BigInt64Array(v);
                  let C = 0, k = 0n;
                  for (let E = 0; E < m; E++) {
                    const D = Number(c[E]), F = sc(c[E + m]);
                    for (let V = 0; V < D; V++) k += F, x[C++] = k;
                  }
                  return x;
                })(e, i.runs, i.numRleValues) : ((function(c) {
                  c[0] = c[0] >> 1n ^ -(1n & c[0]);
                  const m = c.length / 4 * 4;
                  let v = 1;
                  if (m >= 4) for (; v < m - 4; v += 4) {
                    const x = c[v], C = c[v + 1], k = c[v + 2], E = c[v + 3];
                    c[v] = (x >> 1n ^ -(1n & x)) + c[v - 1], c[v + 1] = (C >> 1n ^ -(1n & C)) + c[v], c[v + 2] = (k >> 1n ^ -(1n & k)) + c[v + 1], c[v + 3] = (E >> 1n ^ -(1n & E)) + c[v + 2];
                  }
                  for (; v != c.length; ++v) c[v] = (c[v] >> 1n ^ -(1n & c[v])) + c[v - 1];
                })(e), e);
              case Tr.RLE:
                return (function(c, m, v) {
                  return v ? (function(x, C, k) {
                    const E = new BigInt64Array(k);
                    let D = 0;
                    for (let F = 0; F < C; F++) {
                      const V = Number(x[F]);
                      let G = x[F + C];
                      G = G >> 1n ^ -(1n & G), E.fill(G, D, D + V), D += V;
                    }
                    return E;
                  })(c, m.runs, m.numRleValues) : Fy(c, m.runs, m.numRleValues);
                })(e, i, u);
              case Tr.NONE:
                return u && (function(c) {
                  for (let m = 0; m < c.length; m++) {
                    const v = c[m];
                    c[m] = v >> 1n ^ -(1n & v);
                  }
                })(e), e;
              default:
                throw new Error(`The specified Logical level technique is not supported: ${i.logicalLevelTechnique1}`);
            }
          }
          static decodeFloat64Buffer(e, i, u) {
            switch (i.logicalLevelTechnique1) {
              case Tr.DELTA:
                return i.logicalLevelTechnique2 === Tr.RLE && (e = Ly(e, i.runs, i.numRleValues)), (function(c) {
                  c[0] = c[0] % 2 == 1 ? (c[0] + 1) / -2 : c[0] / 2;
                  const m = c.length / 4 * 4;
                  let v = 1;
                  if (m >= 4) for (; v < m - 4; v += 4) {
                    const x = c[v], C = c[v + 1], k = c[v + 2], E = c[v + 3];
                    c[v] = (x % 2 == 1 ? (x + 1) / -2 : x / 2) + c[v - 1], c[v + 1] = (C % 2 == 1 ? (C + 1) / -2 : C / 2) + c[v], c[v + 2] = (k % 2 == 1 ? (k + 1) / -2 : k / 2) + c[v + 1], c[v + 3] = (E % 2 == 1 ? (E + 1) / -2 : E / 2) + c[v + 2];
                  }
                  for (; v != c.length; ++v) c[v] = (c[v] % 2 == 1 ? (c[v] + 1) / -2 : c[v] / 2) + c[v - 1];
                })(e), e;
              case Tr.RLE:
                return (function(c, m, v) {
                  return v ? (function(x, C, k) {
                    const E = new Float64Array(k);
                    let D = 0;
                    for (let F = 0; F < C; F++) {
                      const V = x[F];
                      let G = x[F + C];
                      G = G % 2 == 1 ? (G + 1) / -2 : G / 2, E.fill(G, D, D + V), D += V;
                    }
                    return E;
                  })(c, m.runs, m.numRleValues) : Ly(c, m.runs, m.numRleValues);
                })(e, i, u);
              case Tr.NONE:
                return u && (function(c) {
                  for (let m = 0; m < c.length; m++) {
                    const v = c[m];
                    c[m] = v % 2 == 1 ? (v + 1) / -2 : v / 2;
                  }
                })(e), e;
              default:
                throw new Error(`The specified Logical level technique is not supported: ${i.logicalLevelTechnique1}`);
            }
          }
          static decodeLengthToOffsetBuffer(e, i) {
            if (i.logicalLevelTechnique1 === Tr.DELTA && i.logicalLevelTechnique2 === Tr.NONE) return (function(u) {
              const c = new Int32Array(u.length + 1);
              c[0] = 0, c[1] = zl(u[0]);
              let m = c[1], v = 2;
              for (; v != c.length; ++v) {
                const x = u[v - 1];
                m += x >>> 1 ^ -(1 & x), c[v] = c[v - 1] + m;
              }
              return c;
            })(e);
            if (i.logicalLevelTechnique1 === Tr.RLE && i.logicalLevelTechnique2 === Tr.NONE) return (function(u, c, m) {
              const v = new Int32Array(m + 1);
              v[0] = 0;
              let x = 1, C = v[0];
              for (let k = 0; k < c; k++) {
                const E = u[k], D = u[k + c];
                for (let F = x; F < x + E; F++) v[F] = D + C, C = v[F];
                x += E;
              }
              return v;
            })(e, i.runs, i.numRleValues);
            if (i.logicalLevelTechnique1 === Tr.NONE && i.logicalLevelTechnique2 === Tr.NONE) {
              (function(c) {
                let m = 0;
                for (let v = 0; v < c.length; v++) c[v] += m, m = c[v];
              })(e);
              const u = new Int32Array(i.numValues + 1);
              return u[0] = 0, u.set(e, 1), u;
            }
            if (i.logicalLevelTechnique1 === Tr.DELTA && i.logicalLevelTechnique2 === Tr.RLE) {
              const u = (function(c, m, v) {
                const x = new Int32Array(v + 1);
                x[0] = 0;
                let C = 1, k = x[0];
                for (let E = 0; E < m; E++) {
                  const D = c[E];
                  let F = c[E + m];
                  F = F >>> 1 ^ -(1 & F);
                  for (let V = C; V < C + D; V++) x[V] = F + k, k = x[V];
                  C += D;
                }
                return x;
              })(e, i.runs, i.numRleValues);
              return wg(u), u;
            }
            throw new Error("Only delta encoding is supported for transforming length to offset streams yet.");
          }
          static decodeNullableIntStream(e, i, u, c, m) {
            const v = u.physicalLevelTechnique === ts.FAST_PFOR ? Ay() : $i(e, i, u.numValues);
            return this.decodeNullableIntBuffer(v, u, c, m);
          }
          static decodeNullableLongStream(e, i, u, c, m) {
            const v = op(e, i, u.numValues);
            return this.decodeNullableLongBuffer(v, u, c, m);
          }
          static decodeNullableIntBuffer(e, i, u, c) {
            switch (i.logicalLevelTechnique1) {
              case Tr.DELTA:
                return i.logicalLevelTechnique2 === Tr.RLE && (e = zy(e, i.runs, i.numRleValues)), (function(m, v) {
                  const x = new Int32Array(m.size());
                  let C = 0;
                  m.get(0) ? (x[0] = m.get(0) ? v[0] >>> 1 ^ -(1 & v[0]) : 0, C = 1) : x[0] = 0;
                  let k = 1;
                  for (; k != x.length; ++k) x[k] = m.get(k) ? x[k - 1] + (v[C] >>> 1 ^ -(1 & v[C++])) : x[k - 1];
                  return x;
                })(c, e);
              case Tr.RLE:
                return (function(m, v, x, C) {
                  const k = v;
                  return x ? (function(E, D, F) {
                    const V = new Int32Array(E.size());
                    let G = 0;
                    for (let H = 0; H < F; H++) {
                      const Y = D[H];
                      let ie = D[H + F];
                      ie = ie >>> 1 ^ -(1 & ie);
                      for (let we = G; we < G + Y; we++) E.get(we) ? V[we] = ie : (V[we] = 0, G++);
                      G += Y;
                    }
                    return V;
                  })(C, m, k.runs) : (function(E, D, F) {
                    const V = new Int32Array(E.size());
                    let G = 0;
                    for (let H = 0; H < F; H++) {
                      const Y = D[H], ie = D[H + F];
                      for (let we = G; we < G + Y; we++) E.get(we) ? V[we] = ie : (V[we] = 0, G++);
                      G += Y;
                    }
                    return V;
                  })(C, m, k.runs);
                })(e, i, u, c);
              case Tr.MORTON:
                return wg(e), e;
              case Tr.COMPONENTWISE_DELTA:
                return By(e), e;
              case Tr.NONE:
                return e = u ? (function(m, v) {
                  const x = new Int32Array(m.size());
                  let C = 0, k = 0;
                  for (; k != x.length; ++k) if (m.get(k)) {
                    const E = v[C++];
                    x[k] = E >>> 1 ^ -(1 & E);
                  } else x[k] = 0;
                  return x;
                })(c, e) : (function(m, v) {
                  const x = new Int32Array(m.size());
                  let C = 0, k = 0;
                  for (; k != x.length; ++k) x[k] = m.get(k) ? v[C++] : 0;
                  return x;
                })(c, e), e;
              default:
                throw new Error("The specified Logical level technique is not supported");
            }
          }
          static decodeNullableLongBuffer(e, i, u, c) {
            switch (i.logicalLevelTechnique1) {
              case Tr.DELTA:
                return i.logicalLevelTechnique2 === Tr.RLE && (e = Fy(e, i.runs, i.numRleValues)), (function(m, v) {
                  const x = new BigInt64Array(m.size());
                  let C = 0;
                  m.get(0) ? (x[0] = m.get(0) ? v[0] >> 1n ^ -(1n & v[0]) : 0n, C = 1) : x[0] = 0n;
                  let k = 1;
                  for (; k != x.length; ++k) x[k] = m.get(k) ? x[k - 1] + (v[C] >> 1n ^ -(1n & v[C++])) : x[k - 1];
                  return x;
                })(c, e);
              case Tr.RLE:
                return (function(m, v, x, C) {
                  const k = v;
                  return x ? (function(E, D, F) {
                    const V = new BigInt64Array(E.size());
                    let G = 0;
                    for (let H = 0; H < F; H++) {
                      const Y = Number(D[H]);
                      let ie = D[H + F];
                      ie = ie >> 1n ^ -(1n & ie);
                      for (let we = G; we < G + Y; we++) E.get(we) ? V[we] = ie : (V[we] = 0n, G++);
                      G += Y;
                    }
                    return V;
                  })(C, m, k.runs) : (function(E, D, F) {
                    const V = new BigInt64Array(E.size());
                    let G = 0;
                    for (let H = 0; H < F; H++) {
                      const Y = Number(D[H]), ie = D[H + F];
                      for (let we = G; we < G + Y; we++) E.get(we) ? V[we] = ie : (V[we] = 0n, G++);
                      G += Y;
                    }
                    return V;
                  })(C, m, k.runs);
                })(e, i, u, c);
              case Tr.NONE:
                return e = u ? (function(m, v) {
                  const x = new BigInt64Array(m.size());
                  let C = 0, k = 0;
                  for (; k != x.length; ++k) if (m.get(k)) {
                    const E = v[C++];
                    x[k] = E >> 1n ^ -(1n & E);
                  } else x[k] = 0n;
                  return x;
                })(c, e) : (function(m, v) {
                  const x = new BigInt64Array(m.size());
                  let C = 0, k = 0;
                  for (; k != x.length; ++k) x[k] = m.get(k) ? v[C++] : 0n;
                  return x;
                })(c, e), e;
              default:
                throw new Error("The specified Logical level technique is not supported");
            }
          }
          static getVectorType(e, i, u, c) {
            const m = e.logicalLevelTechnique1;
            if (m === Tr.RLE) return e.runs === 1 ? Wi.CONST : Wi.FLAT;
            const v = i instanceof na ? i.size() : i;
            if (m === Tr.DELTA && e.logicalLevelTechnique2 === Tr.RLE) {
              const x = e.runs, C = 2;
              if (e.numRleValues !== v) return Wi.FLAT;
              if (x === 1) return Wi.SEQUENCE;
              if (x === 2) {
                const k = c.get();
                let E;
                if (e.physicalLevelTechnique === ts.VARINT) E = $i(u, c, 4);
                else {
                  const D = c.get();
                  E = new Int32Array(u.buffer, u.byteOffset + D, 4);
                }
                if (c.set(k), E[2] === C && E[3] === C) return Wi.SEQUENCE;
              }
            }
            return e.numValues === 1 ? Wi.CONST : Wi.FLAT;
          }
        }
        class Oy extends np {
          getValueFromBuffer(e) {
            return this.dataBuffer[e];
          }
        }
        class $y extends Dy {
          constructor(e, i, u, c) {
            super(e, BigInt64Array.of(i), u, c);
          }
          getValueFromBuffer(e) {
            return this.dataBuffer[0] + BigInt(e) * this.delta;
          }
        }
        class lc {
          constructor(e, i, u) {
            __publicField(this, "_geometryOffsets");
            __publicField(this, "_partOffsets");
            __publicField(this, "_ringOffsets");
            this._geometryOffsets = e, this._partOffsets = i, this._ringOffsets = u;
          }
          get geometryOffsets() {
            return this._geometryOffsets;
          }
          get partOffsets() {
            return this._partOffsets;
          }
          get ringOffsets() {
            return this._ringOffsets;
          }
        }
        class cC {
          constructor(e, i) {
            __publicField(this, "tileExtent");
            __publicField(this, "_numBits");
            __publicField(this, "_coordinateShift");
            __publicField(this, "minBound");
            __publicField(this, "maxBound");
            this._coordinateShift = e < 0 ? Math.abs(e) : 0, this.tileExtent = i + this._coordinateShift, this._numBits = Math.ceil(Math.log2(this.tileExtent)), this.minBound = e, this.maxBound = i;
          }
          validateCoordinates(e) {
            if (e.x < this.minBound || e.y < this.minBound || e.x > this.maxBound || e.y > this.maxBound) throw new Error("The specified tile buffer size is currently not supported.");
          }
          numBits() {
            return this._numBits;
          }
          coordinateShift() {
            return this._coordinateShift;
          }
        }
        class uc extends cC {
          encode(e) {
            this.validateCoordinates(e);
            const i = e.x + this._coordinateShift, u = e.y + this._coordinateShift;
            let c = 0;
            for (let m = 0; m < this._numBits; m++) c |= (i & 1 << m) << m | (u & 1 << m) << m + 1;
            return c;
          }
          decode(e) {
            return { x: this.decodeMorton(e) - this._coordinateShift, y: this.decodeMorton(e >> 1) - this._coordinateShift };
          }
          decodeMorton(e) {
            let i = 0;
            for (let u = 0; u < this._numBits; u++) i |= (e & 1 << 2 * u) >> u;
            return i;
          }
          static decode(e, i, u) {
            return { x: uc.decodeMorton(e, i) - u, y: uc.decodeMorton(e >> 1, i) - u };
          }
          static decodeMorton(e, i) {
            let u = 0;
            for (let c = 0; c < i; c++) u |= (e & 1 << 2 * c) >> c;
            return u;
          }
        }
        (function(o) {
          o[o.POINT = 0] = "POINT", o[o.LINESTRING = 1] = "LINESTRING", o[o.POLYGON = 2] = "POLYGON", o[o.MULTIPOINT = 3] = "MULTIPOINT", o[o.MULTILINESTRING = 4] = "MULTILINESTRING", o[o.MULTIPOLYGON = 5] = "MULTIPOLYGON";
        })(Zi || (Zi = {})), (function(o) {
          o[o.POINT = 0] = "POINT", o[o.LINESTRING = 1] = "LINESTRING", o[o.POLYGON = 2] = "POLYGON";
        })(Ry || (Ry = {})), (function(o) {
          o[o.MORTON = 0] = "MORTON", o[o.VEC_2 = 1] = "VEC_2", o[o.VEC_3 = 2] = "VEC_3";
        })(So || (So = {}));
        class dC {
          createPoint(e) {
            return [[e]];
          }
          createMultiPoint(e) {
            return e.map(((i) => [i]));
          }
          createLineString(e) {
            return [e];
          }
          createMultiLineString(e) {
            return e;
          }
          createPolygon(e, i) {
            return [e, ...i];
          }
          createMultiPolygon(e) {
            return e.flat();
          }
        }
        function Ny(o) {
          const e = new Array(o.numGeometries);
          let i = 1, u = 1, c = 1, m = 0;
          const v = new dC();
          let x = 0, C = 0;
          const k = o.mortonSettings, E = o.topologyVector, D = E.geometryOffsets, F = E.partOffsets, V = E.ringOffsets, G = o.vertexOffsets, H = o.containsPolygonGeometry(), Y = o.vertexBuffer;
          for (let ie = 0; ie < o.numGeometries; ie++) {
            const we = o.geometryType(ie);
            if (we === Zi.POINT) {
              if (G && G.length !== 0) if (o.vertexBufferType === So.VEC_2) {
                const ce = 2 * G[C++], pe = new S(Y[ce], Y[ce + 1]);
                e[m++] = v.createPoint(pe);
              } else {
                const ce = G[C++], pe = uc.decode(Y[ce], k.numBits, k.coordinateShift), Te = new S(pe.x, pe.y);
                e[m++] = v.createPoint(Te);
              }
              else {
                const ce = new S(Y[x++], Y[x++]);
                e[m++] = v.createPoint(ce);
              }
              D && c++, F && i++, V && u++;
            } else if (we === Zi.MULTIPOINT) {
              const ce = D[c] - D[c - 1];
              c++;
              const pe = new Array(ce);
              if (G && G.length !== 0) {
                for (let Te = 0; Te < ce; Te++) {
                  const Oe = 2 * G[C++];
                  pe[Te] = new S(Y[Oe], Y[Oe + 1]);
                }
                e[m++] = v.createMultiPoint(pe);
              } else {
                for (let Te = 0; Te < ce; Te++) {
                  const Oe = Y[x++], Xe = Y[x++];
                  pe[Te] = new S(Oe, Xe);
                }
                e[m++] = v.createMultiPoint(pe);
              }
            } else if (we === Zi.LINESTRING) {
              let ce, pe = 0;
              H ? (pe = V[u] - V[u - 1], u++) : pe = F[i] - F[i - 1], i++, G && G.length !== 0 ? (ce = o.vertexBufferType === So.VEC_2 ? Sg(Y, G, C, pe, false) : kg(Y, G, C, pe, false, k), C += pe) : (ce = Cg(Y, x, pe, false), x += 2 * pe), e[m++] = v.createLineString(ce), D && c++;
            } else if (we === Zi.POLYGON) {
              const ce = F[i] - F[i - 1];
              i++;
              const pe = new Array(ce - 1);
              let Te = V[u] - V[u - 1];
              if (u++, G && G.length !== 0) {
                const Oe = o.vertexBufferType === So.VEC_2 ? lp(Y, G, C, Te) : up(Y, G, C, Te, 0, k);
                C += Te;
                for (let Xe = 0; Xe < pe.length; Xe++) Te = V[u] - V[u - 1], u++, pe[Xe] = o.vertexBufferType === So.VEC_2 ? lp(Y, G, C, Te) : up(Y, G, C, Te, 0, k), C += Te;
                e[m++] = v.createPolygon(Oe, pe);
              } else {
                const Oe = sp(Y, x, Te);
                x += 2 * Te;
                for (let Xe = 0; Xe < pe.length; Xe++) Te = V[u] - V[u - 1], u++, pe[Xe] = sp(Y, x, Te), x += 2 * Te;
                e[m++] = v.createPolygon(Oe, pe);
              }
              D && c++;
            } else if (we === Zi.MULTILINESTRING) {
              const ce = D[c] - D[c - 1];
              c++;
              const pe = new Array(ce);
              if (G && G.length !== 0) {
                for (let Te = 0; Te < ce; Te++) {
                  let Oe = 0;
                  H ? (Oe = V[u] - V[u - 1], u++) : Oe = F[i] - F[i - 1], i++;
                  const Xe = o.vertexBufferType === So.VEC_2 ? Sg(Y, G, C, Oe, false) : kg(Y, G, C, Oe, false, k);
                  pe[Te] = Xe, C += Oe;
                }
                e[m++] = v.createMultiLineString(pe);
              } else {
                for (let Te = 0; Te < ce; Te++) {
                  let Oe = 0;
                  H ? (Oe = V[u] - V[u - 1], u++) : Oe = F[i] - F[i - 1], i++, pe[Te] = Cg(Y, x, Oe, false), x += 2 * Oe;
                }
                e[m++] = v.createMultiLineString(pe);
              }
            } else {
              if (we !== Zi.MULTIPOLYGON) throw new Error("The specified geometry type is currently not supported.");
              {
                const ce = D[c] - D[c - 1];
                c++;
                const pe = new Array(ce);
                let Te = 0;
                if (G && G.length !== 0) {
                  for (let Oe = 0; Oe < ce; Oe++) {
                    const Xe = F[i] - F[i - 1];
                    i++;
                    const yt = new Array(Xe - 1);
                    Te = V[u] - V[u - 1], u++;
                    const ft = o.vertexBufferType === So.VEC_2 ? lp(Y, G, C, Te) : up(Y, G, C, Te, 0, k);
                    C += Te;
                    for (let wt = 0; wt < yt.length; wt++) Te = V[u] - V[u - 1], u++, yt[wt] = o.vertexBufferType === So.VEC_2 ? lp(Y, G, C, Te) : up(Y, G, C, Te, 0, k), C += Te;
                    pe[Oe] = v.createPolygon(ft, yt);
                  }
                  e[m++] = v.createMultiPolygon(pe);
                } else {
                  for (let Oe = 0; Oe < ce; Oe++) {
                    const Xe = F[i] - F[i - 1];
                    i++;
                    const yt = new Array(Xe - 1);
                    Te = V[u] - V[u - 1], u++;
                    const ft = sp(Y, x, Te);
                    x += 2 * Te;
                    for (let wt = 0; wt < yt.length; wt++) {
                      const Rt = V[u] - V[u - 1];
                      u++, yt[wt] = sp(Y, x, Rt), x += 2 * Rt;
                    }
                    pe[Oe] = v.createPolygon(ft, yt);
                  }
                  e[m++] = v.createMultiPolygon(pe);
                }
              }
            }
          }
          return e;
        }
        function sp(o, e, i) {
          return Cg(o, e, i, true);
        }
        function lp(o, e, i, u) {
          return Sg(o, e, i, u, true);
        }
        function up(o, e, i, u, c, m) {
          return kg(o, e, i, u, true, m);
        }
        function Cg(o, e, i, u) {
          const c = new Array(u ? i + 1 : i);
          for (let m = 0; m < 2 * i; m += 2) c[m / 2] = new S(o[e + m], o[e + m + 1]);
          return u && (c[c.length - 1] = c[0]), c;
        }
        function Sg(o, e, i, u, c) {
          const m = new Array(c ? u + 1 : u);
          for (let v = 0; v < 2 * u; v += 2) {
            const x = 2 * e[i + v / 2];
            m[v / 2] = new S(o[x], o[x + 1]);
          }
          return c && (m[m.length - 1] = m[0]), m;
        }
        function kg(o, e, i, u, c, m) {
          const v = new Array(c ? u + 1 : u);
          for (let x = 0; x < u; x++) {
            const C = uc.decode(o[e[i + x]], m.numBits, m.coordinateShift);
            v[x] = new S(C.x, C.y);
          }
          return c && (v[v.length - 1] = v[0]), v;
        }
        class jy {
          constructor(e, i, u, c, m) {
            __publicField(this, "_vertexBufferType");
            __publicField(this, "_topologyVector");
            __publicField(this, "_vertexOffsets");
            __publicField(this, "_vertexBuffer");
            __publicField(this, "_mortonSettings");
            this._vertexBufferType = e, this._topologyVector = i, this._vertexOffsets = u, this._vertexBuffer = c, this._mortonSettings = m;
          }
          get vertexBufferType() {
            return this._vertexBufferType;
          }
          get topologyVector() {
            return this._topologyVector;
          }
          get vertexOffsets() {
            return this._vertexOffsets;
          }
          get vertexBuffer() {
            return this._vertexBuffer;
          }
          *[Symbol.iterator]() {
            const e = Ny(this);
            let i = 0;
            for (; i < this.numGeometries; ) yield { coordinates: e[i], type: this.geometryType(i) }, i++;
          }
          getSimpleEncodedVertex(e) {
            const i = this.vertexOffsets ? 2 * this.vertexOffsets[e] : 2 * e;
            return [this.vertexBuffer[i], this.vertexBuffer[i + 1]];
          }
          getVertex(e) {
            if (this.vertexOffsets && this.mortonSettings) {
              const u = uc.decode(this.vertexBuffer[this.vertexOffsets[e]], this.mortonSettings.numBits, this.mortonSettings.coordinateShift);
              return [u.x, u.y];
            }
            const i = this.vertexOffsets ? 2 * this.vertexOffsets[e] : 2 * e;
            return [this.vertexBuffer[i], this.vertexBuffer[i + 1]];
          }
          getGeometries() {
            return Ny(this);
          }
          get mortonSettings() {
            return this._mortonSettings;
          }
        }
        class Qd extends jy {
          constructor(e, i, u, c, m, v, x) {
            super(u, c, m, v, x);
            __publicField(this, "_numGeometries");
            __publicField(this, "_geometryType");
            this._numGeometries = e, this._geometryType = i;
          }
          static createMortonEncoded(e, i, u, c, m, v) {
            return new Qd(e, i, So.MORTON, u, c, m, v);
          }
          static create(e, i, u, c, m) {
            return new Qd(e, i, So.VEC_2, u, c, m);
          }
          geometryType(e) {
            return this._geometryType;
          }
          get numGeometries() {
            return this._numGeometries;
          }
          containsPolygonGeometry() {
            return this._geometryType === Zi.POLYGON || this._geometryType === Zi.MULTIPOLYGON;
          }
          containsSingleGeometryType() {
            return true;
          }
        }
        class eh extends jy {
          constructor(e, i, u, c, m, v) {
            super(e, u, c, m, v);
            __publicField(this, "_geometryTypes");
            this._geometryTypes = i;
          }
          static createMortonEncoded(e, i, u, c, m) {
            return new eh(So.MORTON, e, i, u, c, m);
          }
          static create(e, i, u, c) {
            return new eh(So.VEC_2, e, i, u, c);
          }
          geometryType(e) {
            return this._geometryTypes[e];
          }
          get numGeometries() {
            return this._geometryTypes.length;
          }
          containsPolygonGeometry() {
            for (let e = 0; e < this.numGeometries; e++) if (this.geometryType(e) === Zi.POLYGON || this.geometryType(e) === Zi.MULTIPOLYGON) return true;
            return false;
          }
          containsSingleGeometryType() {
            return false;
          }
        }
        class Vy {
          constructor(e, i, u, c) {
            __publicField(this, "_triangleOffsets");
            __publicField(this, "_indexBuffer");
            __publicField(this, "_vertexBuffer");
            __publicField(this, "_topologyVector");
            this._triangleOffsets = e, this._indexBuffer = i, this._vertexBuffer = u, this._topologyVector = c;
          }
          get triangleOffsets() {
            return this._triangleOffsets;
          }
          get indexBuffer() {
            return this._indexBuffer;
          }
          get vertexBuffer() {
            return this._vertexBuffer;
          }
          get topologyVector() {
            return this._topologyVector;
          }
          getGeometries() {
            if (!this._topologyVector) throw new Error("Cannot convert GpuVector to coordinates without topology information");
            const e = new Array(this.numGeometries), i = this._topologyVector, u = i.partOffsets, c = i.ringOffsets, m = i.geometryOffsets;
            let v = 0, x = 1, C = 1, k = 1;
            for (let E = 0; E < this.numGeometries; E++) switch (this.geometryType(E)) {
              case Zi.POLYGON:
                {
                  const D = u[x] - u[x - 1];
                  x++;
                  const F = [];
                  for (let V = 0; V < D; V++) {
                    const G = c[C] - c[C - 1];
                    C++;
                    const H = [];
                    for (let Y = 0; Y < G; Y++) {
                      const ie = this._vertexBuffer[v++], we = this._vertexBuffer[v++];
                      H.push(new S(ie, we));
                    }
                    H.length > 0 && H.push(H[0]), F.push(H);
                  }
                  e[E] = F, m && k++;
                }
                break;
              case Zi.MULTIPOLYGON: {
                const D = m[k] - m[k - 1];
                k++;
                const F = [];
                for (let V = 0; V < D; V++) {
                  const G = u[x] - u[x - 1];
                  x++;
                  for (let H = 0; H < G; H++) {
                    const Y = c[C] - c[C - 1];
                    C++;
                    const ie = [];
                    for (let we = 0; we < Y; we++) {
                      const ce = this._vertexBuffer[v++], pe = this._vertexBuffer[v++];
                      ie.push(new S(ce, pe));
                    }
                    ie.length > 0 && ie.push(ie[0]), F.push(ie);
                  }
                }
                e[E] = F;
              }
            }
            return e;
          }
          [Symbol.iterator]() {
            return null;
          }
        }
        class cp extends Vy {
          constructor(e, i, u, c, m, v) {
            super(u, c, m, v);
            __publicField(this, "_numGeometries");
            __publicField(this, "_geometryType");
            this._numGeometries = e, this._geometryType = i;
          }
          static create(e, i, u, c, m, v) {
            return new cp(e, i, u, c, m, v);
          }
          geometryType(e) {
            return this._geometryType;
          }
          get numGeometries() {
            return this._numGeometries;
          }
          containsSingleGeometryType() {
            return true;
          }
        }
        class dp extends Vy {
          constructor(e, i, u, c, m) {
            super(i, u, c, m);
            __publicField(this, "_geometryTypes");
            this._geometryTypes = e;
          }
          static create(e, i, u, c, m) {
            return new dp(e, i, u, c, m);
          }
          geometryType(e) {
            return this._geometryTypes[e];
          }
          get numGeometries() {
            return this._geometryTypes.length;
          }
          containsSingleGeometryType() {
            return false;
          }
        }
        function hC(o, e, i, u, c) {
          const m = Mn.decode(o, i);
          let v = null, x = null, C = null, k = null, E = null, D = null, F = null, V = null;
          if (pr.getVectorType(m, u, o, i) === Wi.CONST) {
            const H = pr.decodeConstIntStream(o, i, m, false);
            for (let Y = 0; Y < e - 1; Y++) {
              const ie = Mn.decode(o, i);
              switch (ie.physicalStreamType) {
                case mn.LENGTH:
                  switch (ie.logicalStreamType.lengthType) {
                    case uo.GEOMETRIES:
                      v = pr.decodeLengthStreamToOffsetBuffer(o, i, ie);
                      break;
                    case uo.PARTS:
                      x = pr.decodeLengthStreamToOffsetBuffer(o, i, ie);
                      break;
                    case uo.RINGS:
                      C = pr.decodeLengthStreamToOffsetBuffer(o, i, ie);
                      break;
                    case uo.TRIANGLES:
                      F = pr.decodeLengthStreamToOffsetBuffer(o, i, ie);
                  }
                  break;
                case mn.OFFSET:
                  switch (ie.logicalStreamType.offsetType) {
                    case Al.VERTEX:
                      k = pr.decodeIntStream(o, i, ie, false);
                      break;
                    case Al.INDEX:
                      V = pr.decodeIntStream(o, i, ie, false);
                  }
                  break;
                case mn.DATA:
                  if (ia.VERTEX === ie.logicalStreamType.dictionaryType) E = pr.decodeIntStream(o, i, ie, true, c);
                  else {
                    const we = ie;
                    D = { numBits: we.numBits(), coordinateShift: we.coordinateShift() }, E = pr.decodeIntStream(o, i, ie, false, c);
                  }
              }
            }
            if (V !== null) {
              if (v != null || x != null) {
                const Y = new lc(v, x, C);
                return cp.create(u, H, F, V, E, Y);
              }
              return cp.create(u, H, F, V, E);
            }
            return D === null ? Qd.create(u, H, new lc(v, x, C), k, E) : Qd.createMortonEncoded(u, H, new lc(v, x, C), k, E, D);
          }
          const G = pr.decodeIntStream(o, i, m, false);
          for (let H = 0; H < e - 1; H++) {
            const Y = Mn.decode(o, i);
            switch (Y.physicalStreamType) {
              case mn.LENGTH:
                switch (Y.logicalStreamType.lengthType) {
                  case uo.GEOMETRIES:
                    v = pr.decodeIntStream(o, i, Y, false);
                    break;
                  case uo.PARTS:
                    x = pr.decodeIntStream(o, i, Y, false);
                    break;
                  case uo.RINGS:
                    C = pr.decodeIntStream(o, i, Y, false);
                    break;
                  case uo.TRIANGLES:
                    F = pr.decodeLengthStreamToOffsetBuffer(o, i, Y);
                }
                break;
              case mn.OFFSET:
                switch (Y.logicalStreamType.offsetType) {
                  case Al.VERTEX:
                    k = pr.decodeIntStream(o, i, Y, false);
                    break;
                  case Al.INDEX:
                    V = pr.decodeIntStream(o, i, Y, false);
                }
                break;
              case mn.DATA:
                if (ia.VERTEX === Y.logicalStreamType.dictionaryType) E = pr.decodeIntStream(o, i, Y, true, c);
                else {
                  const ie = Y;
                  D = { numBits: ie.numBits(), coordinateShift: ie.coordinateShift() }, E = pr.decodeIntStream(o, i, Y, false, c);
                }
            }
          }
          return V !== null && x === null ? dp.create(G, F, V, E) : (v !== null ? (v = Tg(G, v, 2), x !== null && C !== null ? (x = Uy(G, v, x, false), C = (function(H, Y, ie, we) {
            const ce = new Int32Array(ie[ie.length - 1] + 1);
            let pe = 0;
            ce[0] = pe;
            let Te = 1, Oe = 1, Xe = 0;
            for (let yt = 0; yt < H.length; yt++) {
              const ft = H[yt], wt = Y[yt + 1] - Y[yt];
              if (ft !== 0 && ft !== 3) for (let Rt = 0; Rt < wt; Rt++) {
                const Et = ie[Te] - ie[Te - 1];
                Te++;
                for (let Mt = 0; Mt < Et; Mt++) pe = ce[Oe++] = pe + we[Xe++];
              }
              else for (let Rt = 0; Rt < wt; Rt++) ce[Oe++] = ++pe, Te++;
            }
            return ce;
          })(G, v, x, C)) : x !== null && (x = (function(H, Y, ie) {
            const we = new Int32Array(Y[Y.length - 1] + 1);
            let ce = 0;
            we[0] = ce;
            let pe = 1, Te = 0;
            for (let Oe = 0; Oe < H.length; Oe++) {
              const Xe = H[Oe], yt = Y[Oe + 1] - Y[Oe];
              if (Xe === 4 || Xe === 1) for (let ft = 0; ft < yt; ft++) ce = we[pe++] = ce + ie[Te++];
              else for (let ft = 0; ft < yt; ft++) we[pe++] = ++ce;
            }
            return we;
          })(G, v, x))) : x !== null && C !== null ? (x = Tg(G, x, 1), C = Uy(G, x, C, true)) : x !== null && (x = Tg(G, x, 0)), V !== null ? dp.create(G, F, V, E, new lc(v, x, C)) : D === null ? eh.create(G, new lc(v, x, C), k, E) : eh.createMortonEncoded(G, new lc(v, x, C), k, E, D));
        }
        function Tg(o, e, i) {
          const u = new Int32Array(o.length + 1);
          let c = 0;
          u[0] = c;
          let m = 0;
          for (let v = 0; v < o.length; v++) c = u[v + 1] = c + (o[v] > i ? e[m++] : 1);
          return u;
        }
        function Uy(o, e, i, u) {
          const c = new Int32Array(e[e.length - 1] + 1);
          let m = 0;
          c[0] = m;
          let v = 1, x = 0;
          for (let C = 0; C < o.length; C++) {
            const k = o[C], E = e[C + 1] - e[C];
            if (k === 5 || k === 2 || u && (k === 4 || k === 1)) for (let D = 0; D < E; D++) m = c[v++] = m + i[x++];
            else for (let D = 0; D < E; D++) c[v++] = ++m;
          }
          return c;
        }
        class fC extends ac {
          constructor(e, i, u) {
            super(e, i.getBuffer(), u);
            __publicField(this, "dataVector");
            this.dataVector = i;
          }
          getValueFromBuffer(e) {
            return this.dataVector.get(e);
          }
        }
        class pC extends np {
          getValueFromBuffer(e) {
            return this.dataBuffer[e];
          }
        }
        class Gy extends ac {
          constructor(e, i, u) {
            super(e, BigInt64Array.of(i), u);
          }
          getValueFromBuffer(e) {
            return this.dataBuffer[0];
          }
        }
        function mC(o, e, i) {
          for (let u = 0; u < o; u++) {
            const c = Mn.decode(e, i);
            i.add(c.byteLength);
          }
        }
        function th(o, e, i) {
          return qy(o, Math.ceil(e / 8), i);
        }
        function qy(o, e, i) {
          const u = new Uint8Array(e);
          let c = 0;
          for (; c < e; ) {
            const m = o[i.increment()];
            if (m <= 127) {
              const v = m + 3, x = o[i.increment()], C = c + v;
              u.fill(x, c, C), c = C;
            } else {
              const v = 256 - m;
              for (let x = 0; x < v; x++) u[c++] = o[i.increment()];
            }
          }
          return u;
        }
        const gC = new TextDecoder();
        function Pg(o, e, i) {
          return i - e >= 12 ? gC.decode(o.subarray(e, i)) : (function(u, c, m) {
            let v = "", x = c;
            for (; x < m; ) {
              const C = u[x];
              let k, E, D, F = null, V = C > 239 ? 4 : C > 223 ? 3 : C > 191 ? 2 : 1;
              if (x + V > m) break;
              V === 1 ? C < 128 && (F = C) : V === 2 ? (k = u[x + 1], (192 & k) == 128 && (F = (31 & C) << 6 | 63 & k, F <= 127 && (F = null))) : V === 3 ? (k = u[x + 1], E = u[x + 2], (192 & k) == 128 && (192 & E) == 128 && (F = (15 & C) << 12 | (63 & k) << 6 | 63 & E, (F <= 2047 || F >= 55296 && F <= 57343) && (F = null))) : V === 4 && (k = u[x + 1], E = u[x + 2], D = u[x + 3], (192 & k) == 128 && (192 & E) == 128 && (192 & D) == 128 && (F = (15 & C) << 18 | (63 & k) << 12 | (63 & E) << 6 | 63 & D, (F <= 65535 || F >= 1114112) && (F = null))), F === null ? (F = 65533, V = 1) : F > 65535 && (F -= 65536, v += String.fromCharCode(F >>> 10 & 1023 | 55296), F = 56320 | 1023 & F), v += String.fromCharCode(F), x += V;
            }
            return v;
          })(o, e, i);
        }
        class Ig extends ac {
          constructor(e, i, u, c) {
            super(e, u, c);
            __publicField(this, "offsetBuffer");
            this.offsetBuffer = i;
          }
        }
        class Wy extends Ig {
          constructor(e, i, u, c) {
            super(e, i, u, c ?? i.length - 1);
            __publicField(this, "textEncoder");
            this.textEncoder = new TextEncoder();
          }
          getValueFromBuffer(e) {
            return Pg(this.dataBuffer, this.offsetBuffer[e], this.offsetBuffer[e + 1]);
          }
        }
        class cc extends Ig {
          constructor(e, i, u, c, m) {
            super(e, u, c, m ?? i.length);
            __publicField(this, "indexBuffer");
            __publicField(this, "textEncoder");
            this.indexBuffer = i, this.indexBuffer = i, this.textEncoder = new TextEncoder();
          }
          getValueFromBuffer(e) {
            const i = this.indexBuffer[e];
            return Pg(this.dataBuffer, this.offsetBuffer[i], this.offsetBuffer[i + 1]);
          }
        }
        class Zy extends Ig {
          constructor(e, i, u, c, m, v, x) {
            super(e, u, c, x);
            __publicField(this, "indexBuffer");
            __publicField(this, "symbolOffsetBuffer");
            __publicField(this, "symbolTableBuffer");
            __publicField(this, "textEncoder");
            __publicField(this, "symbolLengthBuffer");
            __publicField(this, "lengthBuffer");
            __publicField(this, "decodedDictionary");
            this.indexBuffer = i, this.symbolOffsetBuffer = m, this.symbolTableBuffer = v, this.textEncoder = new TextEncoder();
          }
          getValueFromBuffer(e) {
            this.decodedDictionary == null && (this.symbolLengthBuffer == null && (this.symbolLengthBuffer = this.offsetToLengthBuffer(this.symbolOffsetBuffer), this.lengthBuffer = this.offsetToLengthBuffer(this.offsetBuffer)), this.decodedDictionary = (function(u, c, m) {
              const v = [], x = new Array(c.length).fill(0);
              for (let C = 1; C < c.length; C++) x[C] = x[C - 1] + c[C - 1];
              for (let C = 0; C < m.length; C++) if (m[C] === 255) v.push(m[++C]);
              else {
                const k = c[m[C]], E = x[m[C]];
                for (let D = 0; D < k; D++) v.push(u[E + D]);
              }
              return new Uint8Array(v);
            })(this.symbolTableBuffer, this.symbolLengthBuffer, this.dataBuffer));
            const i = this.indexBuffer[e];
            return Pg(this.decodedDictionary, this.offsetBuffer[i], this.offsetBuffer[i + 1]);
          }
          offsetToLengthBuffer(e) {
            const i = new Uint32Array(e.length - 1);
            let u = e[0];
            for (let c = 1; c < e.length; c++) {
              const m = e[c];
              i[c - 1] = m - u, u = m;
            }
            return i;
          }
        }
        const _rh = class _rh {
          constructor() {
          }
          static decode(e, i, u, c, m) {
            let v = null, x = null, C = null, k = null, E = null, D = null, F = null, V = null;
            for (let G = 0; G < c; G++) {
              const H = Mn.decode(i, u);
              if (H.byteLength !== 0) switch (H.physicalStreamType) {
                case mn.PRESENT: {
                  const Y = th(i, H.numValues, u);
                  D = new na(Y, H.numValues);
                  break;
                }
                case mn.OFFSET:
                  x = m != null || D != null ? pr.decodeNullableIntStream(i, u, H, false, m ?? D) : pr.decodeIntStream(i, u, H, false);
                  break;
                case mn.LENGTH: {
                  const Y = pr.decodeLengthStreamToOffsetBuffer(i, u, H);
                  uo.DICTIONARY === H.logicalStreamType.lengthType ? v = Y : uo.SYMBOL === H.logicalStreamType.lengthType ? k = Y : F = Y;
                  break;
                }
                case mn.DATA: {
                  const Y = i.subarray(u.get(), u.get() + H.byteLength);
                  u.add(H.byteLength);
                  const ie = H.logicalStreamType.dictionaryType;
                  ia.FSST === ie ? E = Y : ia.SINGLE === ie || ia.SHARED === ie ? C = Y : ia.NONE === ie && (V = Y);
                  break;
                }
              }
            }
            return this.decodeFsstDictionaryVector(e, E, x, v, C, k, m ?? D) ?? this.decodeDictionaryVector(e, C, x, v, m ?? D) ?? this.decodePlainStringVector(e, F, V, x, m ?? D);
          }
          static decodeFsstDictionaryVector(e, i, u, c, m, v, x) {
            return i ? new Zy(e, u, c, m, v, i, x) : null;
          }
          static decodeDictionaryVector(e, i, u, c, m) {
            return i ? m ? new cc(e, u, c, i, m) : new cc(e, u, c, i) : null;
          }
          static decodePlainStringVector(e, i, u, c, m) {
            if (!i || !u) return null;
            if (c) return m ? new cc(e, c, i, u, m) : new cc(e, c, i, u);
            if (m && m.size() !== i.length - 1) {
              const v = new Int32Array(m.size());
              let x = 0;
              for (let C = 0; C < m.size(); C++) v[C] = m.get(C) ? x++ : 0;
              return new cc(e, v, i, u, m);
            }
            return m ? new Wy(e, i, u, m) : new Wy(e, i, u);
          }
          static decodeSharedDictionary(e, i, u, c, m) {
            let v = null, x = null, C = null, k = null, E = false;
            for (; !E; ) {
              const G = Mn.decode(e, i);
              switch (G.physicalStreamType) {
                case mn.LENGTH:
                  uo.DICTIONARY === G.logicalStreamType.lengthType ? v = pr.decodeLengthStreamToOffsetBuffer(e, i, G) : C = pr.decodeLengthStreamToOffsetBuffer(e, i, G);
                  break;
                case mn.DATA:
                  ia.SINGLE === G.logicalStreamType.dictionaryType || ia.SHARED === G.logicalStreamType.dictionaryType ? (x = e.subarray(i.get(), i.get() + G.byteLength), E = true) : k = e.subarray(i.get(), i.get() + G.byteLength), i.add(G.byteLength);
              }
            }
            const D = u.complexType.children, F = [];
            let V = 0;
            for (const G of D) {
              const H = $i(e, i, 1)[0];
              if (H == 0) continue;
              const Y = `${u.name}${G.name === _rh.ROOT_COLUMN_NAME ? "" : _rh.NESTED_COLUMN_SEPARATOR + G.name}`;
              if (m && !m.has(Y)) {
                mC(H, e, i);
                continue;
              }
              if (H !== 2 || G.type !== "scalarField" || G.scalarField.physicalType !== 9) throw new Error("Currently only optional string fields are implemented for a struct.");
              const ie = Mn.decode(e, i), we = th(e, ie.numValues, i), ce = Mn.decode(e, i), pe = (ce instanceof Jd ? ce.numRleValues : ce.numValues) !== c ? pr.decodeNullableIntStream(e, i, ce, false, new na(we, ie.numValues)) : pr.decodeIntStream(e, i, ce, false);
              F[V++] = k ? new Zy(Y, pe, v, x, C, k, new na(we, ie.numValues)) : new cc(Y, pe, v, x, new na(we, ie.numValues));
            }
            return F;
          }
        };
        __publicField(_rh, "ROOT_COLUMN_NAME", "default");
        __publicField(_rh, "NESTED_COLUMN_SEPARATOR", ":");
        let rh = _rh;
        function vC(o, e, i, u, c, m) {
          return i.type === "scalarType" ? (function(v, x, C, k, E, D) {
            let F = null, V = 0;
            if (v === 0) return null;
            if (D.nullable) {
              const H = Mn.decode(x, C);
              V = H.numValues;
              const Y = C.get(), ie = th(x, V, C);
              C.set(Y + H.byteLength), F = new na(ie, H.numValues);
            }
            const G = F ?? k;
            switch (E.physicalType) {
              case 4:
              case 3:
                return (function(H, Y, ie, we, ce) {
                  const pe = Mn.decode(H, Y), Te = pr.getVectorType(pe, ce, H, Y), Oe = we.physicalType === 3;
                  if (Te === Wi.FLAT) {
                    const Xe = ih(ce) ? pr.decodeNullableIntStream(H, Y, pe, Oe, ce) : pr.decodeIntStream(H, Y, pe, Oe);
                    return new vg(ie.name, Xe, ce);
                  }
                  if (Te === Wi.SEQUENCE) {
                    const Xe = pr.decodeSequenceIntStream(H, Y, pe);
                    return new _g(ie.name, Xe[0], Xe[1], pe.numRleValues);
                  }
                  {
                    const Xe = pr.decodeConstIntStream(H, Y, pe, Oe);
                    return new bg(ie.name, Xe, ce);
                  }
                })(x, C, D, E, G);
              case 9:
                return rh.decode(D.name, x, C, D.nullable ? v - 1 : v, F);
              case 0:
                return (function(H, Y, ie, we, ce) {
                  const pe = Mn.decode(H, Y), Te = pe.numValues, Oe = Y.get(), Xe = ih(ce) ? (function(ft, wt, Rt, Et) {
                    const Mt = qy(ft, Math.ceil(wt / 8), Rt), lt = new na(Mt, wt), rr = Et.size(), Qt = new na(new Uint8Array(rr), rr);
                    let tr = 0;
                    for (let Vt = 0; Vt < Et.size(); Vt++) {
                      const wr = !!Et.get(Vt) && lt.get(tr++);
                      Qt.set(Vt, wr);
                    }
                    return Qt.getBuffer();
                  })(H, Te, Y, ce) : th(H, Te, Y);
                  Y.set(Oe + pe.byteLength);
                  const yt = new na(Xe, Te);
                  return new fC(ie.name, yt, ce);
                })(x, C, D, 0, G);
              case 6:
              case 5:
                return (function(H, Y, ie, we, ce) {
                  const pe = Mn.decode(H, Y), Te = pr.getVectorType(pe, we, H, Y), Oe = ce.physicalType === 5;
                  if (Te === Wi.FLAT) {
                    const Xe = ih(we) ? pr.decodeNullableLongStream(H, Y, pe, Oe, we) : pr.decodeLongStream(H, Y, pe, Oe);
                    return new Oy(ie.name, Xe, we);
                  }
                  if (Te === Wi.SEQUENCE) {
                    const Xe = pr.decodeSequenceLongStream(H, Y, pe);
                    return new $y(ie.name, Xe[0], Xe[1], pe.numRleValues);
                  }
                  {
                    const Xe = pr.decodeConstLongStream(H, Y, pe, Oe);
                    return new Gy(ie.name, Xe, we);
                  }
                })(x, C, D, G, E);
              case 7:
                return (function(H, Y, ie, we) {
                  const ce = Mn.decode(H, Y), pe = ih(we) ? (function(Te, Oe, Xe, yt) {
                    const ft = Oe.get(), wt = ft + yt * Float32Array.BYTES_PER_ELEMENT, Rt = new Uint8Array(Te.subarray(ft, wt)).buffer, Et = new Float32Array(Rt);
                    Oe.set(wt);
                    const Mt = Xe.size(), lt = new Float32Array(Mt);
                    let rr = 0;
                    for (let Qt = 0; Qt < Mt; Qt++) lt[Qt] = Xe.get(Qt) ? Et[rr++] : 0;
                    return lt;
                  })(H, Y, we, ce.numValues) : (function(Te, Oe, Xe) {
                    const yt = Oe.get(), ft = yt + Xe * Float32Array.BYTES_PER_ELEMENT, wt = new Uint8Array(Te.subarray(yt, ft)).buffer, Rt = new Float32Array(wt);
                    return Oe.set(ft), Rt;
                  })(H, Y, ce.numValues);
                  return new pC(ie.name, pe, we);
                })(x, C, D, G);
              case 8:
                return (function(H, Y, ie, we) {
                  const ce = Mn.decode(H, Y), pe = ih(we) ? (function(Te, Oe, Xe, yt) {
                    const ft = Oe.get(), wt = ft + yt * Float64Array.BYTES_PER_ELEMENT, Rt = new Uint8Array(Te.subarray(ft, wt)).buffer, Et = new Float64Array(Rt);
                    Oe.set(wt);
                    const Mt = Xe.size(), lt = new Float64Array(Mt);
                    let rr = 0;
                    for (let Qt = 0; Qt < Mt; Qt++) lt[Qt] = Xe.get(Qt) ? Et[rr++] : 0;
                    return lt;
                  })(H, Y, we, ce.numValues) : (function(Te, Oe, Xe) {
                    const yt = Oe.get(), ft = yt + Xe * Float64Array.BYTES_PER_ELEMENT, wt = new Uint8Array(Te.subarray(yt, ft)).buffer, Rt = new Float64Array(wt);
                    return Oe.set(ft), Rt;
                  })(H, Y, ce.numValues);
                  return new yg(ie.name, pe, we);
                })(x, C, D, G);
              default:
                throw new Error(`The specified data type for the field is currently not supported: ${E}`);
            }
          })(u, o, e, c, i.scalarType, i) : u != 1 ? null : rh.decodeSharedDictionary(o, e, i, c, m);
        }
        function ih(o) {
          return o instanceof na;
        }
        class hp {
          static decodeColumnType(e) {
            switch (e) {
              case 0:
              case 1:
              case 2:
              case 3: {
                const i = {};
                i.nullable = !!(1 & e), i.columnScope = 0;
                const u = {};
                return u.physicalType = e > 1 ? 6 : 4, u.type = "physicalType", i.scalarType = u, i.type = "scalarType", i;
              }
              case 4: {
                const i = { nullable: false, columnScope: 0 }, u = { type: "physicalType", physicalType: 0 };
                return i.type = "complexType", i.complexType = u, i;
              }
              case 30: {
                const i = { nullable: false, columnScope: 0 }, u = { type: "physicalType", physicalType: 1 };
                return i.type = "complexType", i.complexType = u, i;
              }
              default:
                return this.mapScalarType(e);
            }
          }
          static columnTypeHasName(e) {
            return e >= 10;
          }
          static columnTypeHasChildren(e) {
            return e === 30;
          }
          static hasStreamCount(e) {
            if (e.name === "id") return false;
            if (e.type === "scalarType") {
              const i = e.scalarType;
              if (i.type === "physicalType") switch (i.physicalType) {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                default:
                  return false;
                case 9:
                  return true;
              }
              else if (i.type === "logicalType") return false;
            } else if (e.type === "complexType") {
              const i = e.complexType;
              if (i.type === "physicalType") switch (i.physicalType) {
                case 0:
                case 1:
                  return true;
                default:
                  return false;
              }
            }
            return console.warn("Unexpected column type in hasStreamCount", e), false;
          }
          static mapScalarType(e) {
            let i = null;
            switch (e) {
              case 10:
              case 11:
                i = 0;
                break;
              case 12:
              case 13:
                i = 1;
                break;
              case 14:
              case 15:
                i = 2;
                break;
              case 16:
              case 17:
                i = 3;
                break;
              case 18:
              case 19:
                i = 4;
                break;
              case 20:
              case 21:
                i = 5;
                break;
              case 22:
              case 23:
                i = 6;
                break;
              case 24:
              case 25:
                i = 7;
                break;
              case 26:
              case 27:
                i = 8;
                break;
              case 28:
              case 29:
                i = 9;
                break;
              default:
                return null;
            }
            const u = {};
            u.nullable = !!(1 & e), u.columnScope = 0;
            const c = { type: "physicalType" };
            return c.physicalType = i, u.type = "scalarType", u.scalarType = c, u;
          }
        }
        const yC = new TextDecoder();
        function Hy(o, e) {
          const i = $i(o, e, 1)[0];
          if (i === 0) return "";
          const u = e.get(), c = o.subarray(u, u + i);
          return e.add(i), yC.decode(c);
        }
        function Xy(o, e) {
          const i = $i(o, e, 1)[0] >>> 0, u = !!(4 & i), c = !!(2 & i), m = $i(o, e, 1)[0] >>> 0, v = {};
          if (1 & i && (v.nullable = true), c) {
            const x = {};
            if (u ? (x.type = "logicalType", x.logicalType = m) : (x.type = "physicalType", x.physicalType = m), 8 & i) {
              const C = $i(o, e, 1)[0] >>> 0;
              x.children = new Array(C);
              for (let k = 0; k < C; k++) x.children[k] = Xy(o, e);
            }
            v.type = "complexField", v.complexField = x;
          } else {
            const x = {};
            u ? (x.type = "logicalType", x.logicalType = m) : (x.type = "physicalType", x.physicalType = m), v.type = "scalarField", v.scalarField = x;
          }
          return v;
        }
        function _C(o, e) {
          const i = $i(o, e, 1)[0] >>> 0, u = hp.decodeColumnType(i);
          if (!u) throw new Error(`Unsupported column type code: ${i}`);
          if (hp.columnTypeHasName(i) ? u.name = Hy(o, e) : i >= 0 && i <= 3 ? u.name = "id" : i === 4 && (u.name = "geometry"), hp.columnTypeHasChildren(i)) {
            const c = $i(o, e, 1)[0] >>> 0, m = u.complexType;
            m.children = new Array(c);
            for (let v = 0; v < c; v++) m.children[v] = Xy(o, e);
          }
          return u;
        }
        function bC(o, e) {
          const i = { featureTables: [] }, u = {};
          u.name = Hy(o, e);
          const c = $i(o, e, 1)[0] >>> 0, m = $i(o, e, 1)[0] >>> 0;
          u.columns = new Array(m);
          for (let v = 0; v < m; v++) u.columns[v] = _C(o, e);
          return i.featureTables.push(u), [i, c];
        }
        function xC(o, e, i, u, c, m, v = false) {
          const x = e.scalarType.physicalType, C = pr.getVectorType(c, m, o, i);
          if (x === 4) switch (C) {
            case Wi.FLAT: {
              const k = pr.decodeIntStream(o, i, c, false);
              return new vg(u, k, m);
            }
            case Wi.SEQUENCE: {
              const k = pr.decodeSequenceIntStream(o, i, c);
              return new _g(u, k[0], k[1], c.numRleValues);
            }
            case Wi.CONST: {
              const k = pr.decodeConstIntStream(o, i, c, false);
              return new bg(u, k, m);
            }
          }
          else switch (C) {
            case Wi.FLAT: {
              if (v) {
                const E = pr.decodeLongFloat64Stream(o, i, c, false);
                return new yg(u, E, m);
              }
              const k = pr.decodeLongStream(o, i, c, false);
              return new Oy(u, k, m);
            }
            case Wi.SEQUENCE: {
              const k = pr.decodeSequenceLongStream(o, i, c);
              return new $y(u, k[0], k[1], c.numRleValues);
            }
            case Wi.CONST: {
              const k = pr.decodeConstLongStream(o, i, c, false);
              return new Gy(u, k, m);
            }
          }
          throw new Error("Vector type not supported for id column.");
        }
        class wC {
          constructor(e, i) {
            var u;
            switch (this._featureData = e, this.properties = this._featureData.properties || {}, (u = this._featureData.geometry) === null || u === void 0 ? void 0 : u.type) {
              case Zi.POINT:
              case Zi.MULTIPOINT:
                this.type = 1;
                break;
              case Zi.LINESTRING:
              case Zi.MULTILINESTRING:
                this.type = 2;
                break;
              case Zi.POLYGON:
              case Zi.MULTIPOLYGON:
                this.type = 3;
                break;
              default:
                this.type = 0;
            }
            this.extent = i, this.id = Number(this._featureData.id);
          }
          projectPoint(e, i, u, c) {
            return [360 * (e.x + i) / c - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (e.y + u) / c) * Math.PI)) - 90];
          }
          projectLine(e, i, u, c) {
            return e.map(((m) => this.projectPoint(m, i, u, c)));
          }
          toGeoJSON(e, i, u) {
            const c = this.extent * Math.pow(2, u), m = this.extent * e, v = this.extent * i, x = this.loadGeometry();
            let C;
            switch (this.type) {
              case 1: {
                const E = [];
                for (const F of x) E.push(F[0]);
                const D = this.projectLine(E, m, v, c);
                C = E.length === 1 ? { type: "Point", coordinates: D[0] } : { type: "MultiPoint", coordinates: D };
                break;
              }
              case 2: {
                const E = x.map(((D) => this.projectLine(D, m, v, c)));
                C = E.length === 1 ? { type: "LineString", coordinates: E[0] } : { type: "MultiLineString", coordinates: E };
                break;
              }
              case 3: {
                const E = sl(x), D = [];
                for (const F of E) D.push(F.map(((V) => this.projectLine(V, m, v, c))));
                C = D.length === 1 ? { type: "Polygon", coordinates: D[0] } : { type: "MultiPolygon", coordinates: D };
                break;
              }
              default:
                throw new Error(`unknown feature type: ${this.type}`);
            }
            const k = { type: "Feature", geometry: C, properties: this.properties };
            return this.id != null && (k.id = this.id), k;
          }
          loadGeometry() {
            const e = [];
            for (const i of this._featureData.geometry.coordinates) {
              const u = [];
              for (const c of i) u.push(new S(c.x, c.y));
              e.push(u);
            }
            return e;
          }
          bbox() {
            return [0, 0, 0, 0];
          }
        }
        class CC {
          constructor(e) {
            this.features = [], this.featureTable = e, this.name = e.name, this.extent = e.extent, this.version = 2, this.features = e.getFeatures(), this.length = this.features.length;
          }
          feature(e) {
            return new wC(this.features[e], this.extent);
          }
        }
        class Yy {
          constructor(e) {
            this.layers = {};
            const i = (function(u, c, m = true) {
              const v = new sC(0), x = [];
              for (; v.get() < u.length; ) {
                const C = $i(u, v, 1)[0] >>> 0, k = v.get() + C;
                if (k > u.length) throw new Error(`Block overruns tile: ${k} > ${u.length}`);
                if ($i(u, v, 1)[0] >>> 0 != 1) {
                  v.set(k);
                  continue;
                }
                const E = bC(u, v), D = E[1], F = E[0].featureTables[0];
                let V = null, G = null;
                const H = [];
                let Y = 0;
                for (const we of F.columns) {
                  const ce = we.name;
                  if (ce === "id") {
                    let pe = null;
                    if (we.nullable) {
                      const Oe = Mn.decode(u, v), Xe = v.get(), yt = th(u, Oe.numValues, v);
                      v.set(Xe + Oe.byteLength), pe = new na(yt, Oe.numValues);
                    }
                    const Te = Mn.decode(u, v);
                    Y = Te.getDecompressedCount(), V = xC(u, we, v, ce, Te, pe ?? Y, m);
                  } else if (ce === "geometry") {
                    const pe = $i(u, v, 1)[0];
                    if (Y === 0) {
                      const Te = v.get();
                      Y = Mn.decode(u, v).getDecompressedCount(), v.set(Te);
                    }
                    G = hC(u, pe, v, Y, c);
                  } else {
                    const pe = hp.hasStreamCount(we) ? $i(u, v, 1)[0] : 1;
                    if (pe === 0 && we.type === "scalarType") continue;
                    const Te = vC(u, v, we, pe, Y, void 0);
                    Te && (Array.isArray(Te) ? H.push(...Te) : H.push(Te));
                  }
                }
                const ie = new aC(F.name, G, V, H, D);
                x.push(ie), v.set(k);
              }
              return x;
            })(new Uint8Array(e));
            this.layers = i.reduce(((u, c) => Object.assign(Object.assign({}, u), { [c.name]: new CC(c) })), {});
          }
        }
        class Ky {
          constructor(e, i) {
            this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new _l(it, 16, 0), this.grid3D = new _l(it, 16, 0), this.featureIndexArray = new de(), this.promoteId = i;
          }
          insert(e, i, u, c, m, v) {
            const x = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(u, c, m);
            const C = v ? this.grid3D : this.grid;
            for (let k = 0; k < i.length; k++) {
              const E = i[k], D = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let F = 0; F < E.length; F++) {
                const V = E[F];
                D[0] = Math.min(D[0], V.x), D[1] = Math.min(D[1], V.y), D[2] = Math.max(D[2], V.x), D[3] = Math.max(D[3], V.y);
              }
              D[0] < it && D[1] < it && D[2] >= 0 && D[3] >= 0 && C.insert(x, D[0], D[1], D[2], D[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = this.encoding !== "mlt" ? new Zv(new ag(this.rawTileData)).layers : new Yy(this.rawTileData).layers, this.sourceLayerCoder = new Ey(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(e, i, u, c) {
            this.loadVTLayers();
            const m = e.params, v = it / e.tileSize / e.scale, x = hl(m.filter, m.globalState), C = e.queryGeometry, k = e.queryPadding * v, E = Rl.fromPoints(C), D = this.grid.query(E.minX - k, E.minY - k, E.maxX + k, E.maxY + k), F = Rl.fromPoints(e.cameraQueryGeometry).expandBy(k), V = this.grid3D.query(F.minX, F.minY, F.maxX, F.maxY, ((Y, ie, we, ce) => (function(pe, Te, Oe, Xe, yt) {
              for (const wt of pe) if (Te <= wt.x && Oe <= wt.y && Xe >= wt.x && yt >= wt.y) return true;
              const ft = [new S(Te, Oe), new S(Te, yt), new S(Xe, yt), new S(Xe, Oe)];
              if (pe.length > 2) {
                for (const wt of ft) if (Yu(pe, wt)) return true;
              }
              for (let wt = 0; wt < pe.length - 1; wt++) if (F2(pe[wt], pe[wt + 1], ft)) return true;
              return false;
            })(e.cameraQueryGeometry, Y - k, ie - k, we + k, ce + k)));
            for (const Y of V) D.push(Y);
            D.sort(SC);
            const G = {};
            let H;
            for (let Y = 0; Y < D.length; Y++) {
              const ie = D[Y];
              if (ie === H) continue;
              H = ie;
              const we = this.featureIndexArray.get(ie);
              let ce = null;
              this.loadMatchingFeature(G, we.bucketIndex, we.sourceLayerIndex, we.featureIndex, x, m.layers, m.availableImages, i, u, c, ((pe, Te, Oe) => (ce || (ce = Ta(pe)), Te.queryIntersectsFeature({ queryGeometry: C, feature: pe, featureState: Oe, geometry: ce, zoom: this.z, transform: e.transform, pixelsToTileUnits: v, pixelPosMatrix: e.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: e.getElevation }))));
            }
            return G;
          }
          loadMatchingFeature(e, i, u, c, m, v, x, C, k, E, D) {
            const F = this.bucketLayerIDs[i];
            if (v && !F.some(((Y) => v.has(Y)))) return;
            const V = this.sourceLayerCoder.decode(u), G = this.vtLayers[V].feature(c);
            if (m.needGeometry) {
              const Y = Pa(G, true);
              if (!m.filter(new qr(this.tileID.overscaledZ), Y, this.tileID.canonical)) return;
            } else if (!m.filter(new qr(this.tileID.overscaledZ), G)) return;
            const H = this.getId(G, V);
            for (let Y = 0; Y < F.length; Y++) {
              const ie = F[Y];
              if (v && !v.has(ie)) continue;
              const we = C[ie];
              if (!we) continue;
              let ce = {};
              H && E && (ce = E.getState(we.sourceLayer || "_geojsonTileLayer", H));
              const pe = Zt({}, k[ie]);
              pe.paint = Jy(pe.paint, we.paint, G, ce, x), pe.layout = Jy(pe.layout, we.layout, G, ce, x);
              const Te = !D || D(G, we, ce);
              if (!Te) continue;
              const Oe = new My(G, this.z, this.x, this.y, H);
              Oe.layer = pe;
              let Xe = e[ie];
              Xe === void 0 && (Xe = e[ie] = []), Xe.push({ featureIndex: c, feature: Oe, intersectionZ: Te });
            }
          }
          lookupSymbolFeatures(e, i, u, c, m, v, x, C) {
            const k = {};
            this.loadVTLayers();
            const E = hl(m.filterSpec, m.globalState);
            for (const D of e) this.loadMatchingFeature(k, u, c, D, E, v, x, C, i);
            return k;
          }
          hasLayer(e) {
            for (const i of this.bucketLayerIDs) for (const u of i) if (e === u) return true;
            return false;
          }
          getId(e, i) {
            var u;
            let c = e.id;
            return this.promoteId && (c = e.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[i]], typeof c == "boolean" && (c = Number(c)), c === void 0 && (!((u = e.properties) === null || u === void 0) && u.cluster) && this.promoteId && (c = Number(e.properties.cluster_id))), c;
          }
        }
        function Jy(o, e, i, u, c) {
          return yr(o, ((m, v) => {
            const x = e instanceof wl ? e.get(v) : null;
            return x && x.evaluate ? x.evaluate(i, u, c) : x;
          }));
        }
        function SC(o, e) {
          return e - o;
        }
        function Qy(o, e, i, u, c) {
          const m = [];
          for (let v = 0; v < o.length; v++) {
            const x = o[v];
            let C;
            for (let k = 0; k < x.length - 1; k++) {
              let E = x[k], D = x[k + 1];
              E.x < e && D.x < e || (E.x < e ? E = new S(e, E.y + (e - E.x) / (D.x - E.x) * (D.y - E.y))._round() : D.x < e && (D = new S(e, E.y + (e - E.x) / (D.x - E.x) * (D.y - E.y))._round()), E.y < i && D.y < i || (E.y < i ? E = new S(E.x + (i - E.y) / (D.y - E.y) * (D.x - E.x), i)._round() : D.y < i && (D = new S(E.x + (i - E.y) / (D.y - E.y) * (D.x - E.x), i)._round()), E.x >= u && D.x >= u || (E.x >= u ? E = new S(u, E.y + (u - E.x) / (D.x - E.x) * (D.y - E.y))._round() : D.x >= u && (D = new S(u, E.y + (u - E.x) / (D.x - E.x) * (D.y - E.y))._round()), E.y >= c && D.y >= c || (E.y >= c ? E = new S(E.x + (c - E.y) / (D.y - E.y) * (D.x - E.x), c)._round() : D.y >= c && (D = new S(E.x + (c - E.y) / (D.y - E.y) * (D.x - E.x), c)._round()), C && E.equals(C[C.length - 1]) || (C = [E], m.push(C)), C.push(D)))));
            }
          }
          return m;
        }
        function e_(o, e, i, u, c) {
          switch (e) {
            case 1:
              return (function(m, v, x, C) {
                const k = [];
                for (const E of m) for (const D of E) {
                  const F = C === 0 ? D.x : D.y;
                  F >= v && F <= x && k.push([D]);
                }
                return k;
              })(o, i, u, c);
            case 2:
              return t_(o, i, u, c, false);
            case 3:
              return t_(o, i, u, c, true);
          }
          return [];
        }
        function kC(o, e, i, u, c) {
          const m = u === 0 ? TC : PC;
          let v = [];
          const x = [];
          for (let E = 0; E < o.length - 1; E++) {
            const D = o[E], F = o[E + 1], V = u === 0 ? D.x : D.y, G = u === 0 ? F.x : F.y;
            let H = false;
            V < e ? G > e && v.push(m(D, F, e)) : V > i ? G < i && v.push(m(D, F, i)) : v.push(D), G < e && V >= e && (v.push(m(D, F, e)), H = true), G > i && V <= i && (v.push(m(D, F, i)), H = true), !c && H && (x.push(v), v = []);
          }
          const C = o.length - 1, k = u === 0 ? o[C].x : o[C].y;
          return k >= e && k <= i && v.push(o[C]), c && v.length > 0 && !v[0].equals(v[v.length - 1]) && v.push(new S(v[0].x, v[0].y)), v.length > 0 && x.push(v), x;
        }
        function t_(o, e, i, u, c) {
          const m = [];
          for (const v of o) {
            const x = kC(v, e, i, u, c);
            x.length > 0 && m.push(...x);
          }
          return m;
        }
        function TC(o, e, i) {
          return new S(i, o.y + (i - o.x) / (e.x - o.x) * (e.y - o.y));
        }
        function PC(o, e, i) {
          return new S(o.x + (i - o.y) / (e.y - o.y) * (e.x - o.x), i);
        }
        Lt("FeatureIndex", Ky, { omit: ["rawTileData", "sourceLayerCoder"] });
        class zs extends S {
          constructor(e, i, u, c) {
            super(e, i), this.angle = u, c !== void 0 && (this.segment = c);
          }
          clone() {
            return new zs(this.x, this.y, this.angle, this.segment);
          }
        }
        function r_(o, e, i, u, c) {
          if (e.segment === void 0 || i === 0) return true;
          let m = e, v = e.segment + 1, x = 0;
          for (; x > -i / 2; ) {
            if (v--, v < 0) return false;
            x -= o[v].dist(m), m = o[v];
          }
          x += o[v].dist(o[v + 1]), v++;
          const C = [];
          let k = 0;
          for (; x < i / 2; ) {
            const E = o[v], D = o[v + 1];
            if (!D) return false;
            let F = o[v - 1].angleTo(E) - E.angleTo(D);
            for (F = Math.abs((F + 3 * Math.PI) % (2 * Math.PI) - Math.PI), C.push({ distance: x, angleDelta: F }), k += F; x - C[0].distance > u; ) k -= C.shift().angleDelta;
            if (k > c) return false;
            v++, x += E.dist(D);
          }
          return true;
        }
        function i_(o) {
          let e = 0;
          for (let i = 0; i < o.length - 1; i++) e += o[i].dist(o[i + 1]);
          return e;
        }
        function n_(o, e, i) {
          return o ? 0.6 * e * i : 0;
        }
        function o_(o, e) {
          return Math.max(o ? o.right - o.left : 0, e ? e.right - e.left : 0);
        }
        function IC(o, e, i, u, c, m) {
          const v = n_(i, c, m), x = o_(i, u) * m;
          let C = 0;
          const k = i_(o) / 2;
          for (let E = 0; E < o.length - 1; E++) {
            const D = o[E], F = o[E + 1], V = D.dist(F);
            if (C + V > k) {
              const G = (k - C) / V, H = yo.number(D.x, F.x, G), Y = yo.number(D.y, F.y, G), ie = new zs(H, Y, F.angleTo(D), E);
              return ie._round(), !v || r_(o, ie, x, v, e) ? ie : void 0;
            }
            C += V;
          }
        }
        function EC(o, e, i, u, c, m, v, x, C) {
          const k = n_(u, m, v), E = o_(u, c), D = E * v, F = o[0].x === 0 || o[0].x === C || o[0].y === 0 || o[0].y === C;
          return e - D < e / 4 && (e = D + e / 4), a_(o, F ? e / 2 * x % e : (E / 2 + 2 * m) * v * x % e, e, k, i, D, F, false, C);
        }
        function a_(o, e, i, u, c, m, v, x, C) {
          const k = m / 2, E = i_(o);
          let D = 0, F = e - i, V = [];
          for (let G = 0; G < o.length - 1; G++) {
            const H = o[G], Y = o[G + 1], ie = H.dist(Y), we = Y.angleTo(H);
            for (; F + i < D + ie; ) {
              F += i;
              const ce = (F - D) / ie, pe = yo.number(H.x, Y.x, ce), Te = yo.number(H.y, Y.y, ce);
              if (pe >= 0 && pe < C && Te >= 0 && Te < C && F - k >= 0 && F + k <= E) {
                const Oe = new zs(pe, Te, we, G);
                Oe._round(), u && !r_(o, Oe, m, u, c) || V.push(Oe);
              }
            }
            D += ie;
          }
          return x || V.length || v || (V = a_(o, D / 2, i, u, c, m, v, true, C)), V;
        }
        function s_(o, e, i, u) {
          const c = [], m = o.image, v = m.pixelRatio, x = m.paddedRect.w - 2, C = m.paddedRect.h - 2;
          let k = { x1: o.left, y1: o.top, x2: o.right, y2: o.bottom };
          const E = m.stretchX || [[0, x]], D = m.stretchY || [[0, C]], F = (lt, rr) => lt + rr[1] - rr[0], V = E.reduce(F, 0), G = D.reduce(F, 0), H = x - V, Y = C - G;
          let ie = 0, we = V, ce = 0, pe = G, Te = 0, Oe = H, Xe = 0, yt = Y;
          if (m.content && u) {
            const lt = m.content, rr = lt[2] - lt[0], Qt = lt[3] - lt[1];
            (m.textFitWidth || m.textFitHeight) && (k = fy(o)), ie = fp(E, 0, lt[0]), ce = fp(D, 0, lt[1]), we = fp(E, lt[0], lt[2]), pe = fp(D, lt[1], lt[3]), Te = lt[0] - ie, Xe = lt[1] - ce, Oe = rr - we, yt = Qt - pe;
          }
          const ft = k.x1, wt = k.y1, Rt = k.x2 - ft, Et = k.y2 - wt, Mt = (lt, rr, Qt, tr) => {
            const Vt = pp(lt.stretch - ie, we, Rt, ft), wr = mp(lt.fixed - Te, Oe, lt.stretch, V), bi = pp(rr.stretch - ce, pe, Et, wt), Ni = mp(rr.fixed - Xe, yt, rr.stretch, G), vn = pp(Qt.stretch - ie, we, Rt, ft), ko = mp(Qt.fixed - Te, Oe, Qt.stretch, V), Kn = pp(tr.stretch - ce, pe, Et, wt), nn = mp(tr.fixed - Xe, yt, tr.stretch, G), mi = new S(Vt, bi), Hi = new S(vn, bi), on = new S(vn, Kn), an = new S(Vt, Kn), jn = new S(wr / v, Ni / v), To = new S(ko / v, nn / v), Xi = e * Math.PI / 180;
            if (Xi) {
              const Yi = Math.sin(Xi), Ki = Math.cos(Xi), zi = [Ki, -Yi, Yi, Ki];
              mi._matMult(zi), Hi._matMult(zi), an._matMult(zi), on._matMult(zi);
            }
            const Jn = lt.stretch + lt.fixed, ji = rr.stretch + rr.fixed;
            return { tl: mi, tr: Hi, bl: an, br: on, tex: { x: m.paddedRect.x + 1 + Jn, y: m.paddedRect.y + 1 + ji, w: Qt.stretch + Qt.fixed - Jn, h: tr.stretch + tr.fixed - ji }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: jn, pixelOffsetBR: To, minFontScaleX: Oe / v / Rt, minFontScaleY: yt / v / Et, isSDF: i };
          };
          if (u && (m.stretchX || m.stretchY)) {
            const lt = l_(E, H, V), rr = l_(D, Y, G);
            for (let Qt = 0; Qt < lt.length - 1; Qt++) {
              const tr = lt[Qt], Vt = lt[Qt + 1];
              for (let wr = 0; wr < rr.length - 1; wr++) c.push(Mt(tr, rr[wr], Vt, rr[wr + 1]));
            }
          } else c.push(Mt({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: x + 1 }, { fixed: 0, stretch: C + 1 }));
          return c;
        }
        function fp(o, e, i) {
          let u = 0;
          for (const c of o) u += Math.max(e, Math.min(i, c[1])) - Math.max(e, Math.min(i, c[0]));
          return u;
        }
        function l_(o, e, i) {
          const u = [{ fixed: -1, stretch: 0 }];
          for (const [c, m] of o) {
            const v = u[u.length - 1];
            u.push({ fixed: c - v.stretch, stretch: v.stretch }), u.push({ fixed: c - v.stretch, stretch: v.stretch + (m - c) });
          }
          return u.push({ fixed: e + 1, stretch: i }), u;
        }
        function pp(o, e, i, u) {
          return o / e * i + u;
        }
        function mp(o, e, i, u) {
          return o - e * i / u;
        }
        Lt("Anchor", zs);
        class gp {
          constructor(e, i, u, c, m, v, x, C, k, E) {
            var D;
            if (this.boxStartIndex = e.length, k) {
              let F = v.top, V = v.bottom;
              const G = v.collisionPadding;
              G && (F -= G[1], V += G[3]);
              let H = V - F;
              H > 0 && (H = Math.max(10, H), this.circleDiameter = H);
            } else {
              const F = !((D = v.image) === null || D === void 0) && D.content && (v.image.textFitWidth || v.image.textFitHeight) ? fy(v) : { x1: v.left, y1: v.top, x2: v.right, y2: v.bottom };
              F.y1 = F.y1 * x - C[0], F.y2 = F.y2 * x + C[2], F.x1 = F.x1 * x - C[3], F.x2 = F.x2 * x + C[1];
              const V = v.collisionPadding;
              if (V && (F.x1 -= V[0] * x, F.y1 -= V[1] * x, F.x2 += V[2] * x, F.y2 += V[3] * x), E) {
                const G = new S(F.x1, F.y1), H = new S(F.x2, F.y1), Y = new S(F.x1, F.y2), ie = new S(F.x2, F.y2), we = E * Math.PI / 180;
                G._rotate(we), H._rotate(we), Y._rotate(we), ie._rotate(we), F.x1 = Math.min(G.x, H.x, Y.x, ie.x), F.x2 = Math.max(G.x, H.x, Y.x, ie.x), F.y1 = Math.min(G.y, H.y, Y.y, ie.y), F.y2 = Math.max(G.y, H.y, Y.y, ie.y);
              }
              e.emplaceBack(i.x, i.y, F.x1, F.y1, F.x2, F.y2, u, c, m);
            }
            this.boxEndIndex = e.length;
          }
        }
        class MC {
          constructor(e = [], i = (u, c) => u < c ? -1 : u > c ? 1 : 0) {
            if (this.data = e, this.length = this.data.length, this.compare = i, this.length > 0) for (let u = (this.length >> 1) - 1; u >= 0; u--) this._down(u);
          }
          push(e) {
            this.data.push(e), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const e = this.data[0], i = this.data.pop();
            return --this.length > 0 && (this.data[0] = i, this._down(0)), e;
          }
          peek() {
            return this.data[0];
          }
          _up(e) {
            const { data: i, compare: u } = this, c = i[e];
            for (; e > 0; ) {
              const m = e - 1 >> 1, v = i[m];
              if (u(c, v) >= 0) break;
              i[e] = v, e = m;
            }
            i[e] = c;
          }
          _down(e) {
            const { data: i, compare: u } = this, c = this.length >> 1, m = i[e];
            for (; e < c; ) {
              let v = 1 + (e << 1);
              const x = v + 1;
              if (x < this.length && u(i[x], i[v]) < 0 && (v = x), u(i[v], m) >= 0) break;
              i[e] = i[v], e = v;
            }
            i[e] = m;
          }
        }
        function DC(o, e = 1, i = false) {
          const u = Rl.fromPoints(o[0]), c = Math.min(u.width(), u.height());
          let m = c / 2;
          const v = new MC([], RC), { minX: x, minY: C, maxX: k, maxY: E } = u;
          if (c === 0) return new S(x, C);
          for (let V = x; V < k; V += c) for (let G = C; G < E; G += c) v.push(new dc(V + m, G + m, m, o));
          let D = (function(V) {
            let G = 0, H = 0, Y = 0;
            const ie = V[0];
            for (let we = 0, ce = ie.length, pe = ce - 1; we < ce; pe = we++) {
              const Te = ie[we], Oe = ie[pe], Xe = Te.x * Oe.y - Oe.x * Te.y;
              H += (Te.x + Oe.x) * Xe, Y += (Te.y + Oe.y) * Xe, G += 3 * Xe;
            }
            return new dc(H / G, Y / G, 0, V);
          })(o), F = v.length;
          for (; v.length; ) {
            const V = v.pop();
            (V.d > D.d || !D.d) && (D = V, i && console.log("found best %d after %d probes", Math.round(1e4 * V.d) / 1e4, F)), V.max - D.d <= e || (m = V.h / 2, v.push(new dc(V.p.x - m, V.p.y - m, m, o)), v.push(new dc(V.p.x + m, V.p.y - m, m, o)), v.push(new dc(V.p.x - m, V.p.y + m, m, o)), v.push(new dc(V.p.x + m, V.p.y + m, m, o)), F += 4);
          }
          return i && (console.log(`num probes: ${F}`), console.log(`best distance: ${D.d}`)), D.p;
        }
        function RC(o, e) {
          return e.max - o.max;
        }
        function dc(o, e, i, u) {
          this.p = new S(o, e), this.h = i, this.d = (function(c, m) {
            let v = false, x = 1 / 0;
            for (let C = 0; C < m.length; C++) {
              const k = m[C];
              for (let E = 0, D = k.length, F = D - 1; E < D; F = E++) {
                const V = k[E], G = k[F];
                V.y > c.y != G.y > c.y && c.x < (G.x - V.x) * (c.y - V.y) / (G.y - V.y) + V.x && (v = !v), x = Math.min(x, Sv(c, V, G));
              }
            }
            return (v ? 1 : -1) * Math.sqrt(x);
          })(this.p, u), this.max = this.d + this.h * Math.SQRT2;
        }
        var gn;
        p.aJ = void 0, (gn = p.aJ || (p.aJ = {}))[gn.center = 1] = "center", gn[gn.left = 2] = "left", gn[gn.right = 3] = "right", gn[gn.top = 4] = "top", gn[gn.bottom = 5] = "bottom", gn[gn["top-left"] = 6] = "top-left", gn[gn["top-right"] = 7] = "top-right", gn[gn["bottom-left"] = 8] = "bottom-left", gn[gn["bottom-right"] = 9] = "bottom-right";
        const Eg = Number.POSITIVE_INFINITY;
        function u_(o, e) {
          return e[1] !== Eg ? (function(i, u, c) {
            let m = 0, v = 0;
            switch (u = Math.abs(u), c = Math.abs(c), i) {
              case "top-right":
              case "top-left":
              case "top":
                v = c - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                v = 7 - c;
            }
            switch (i) {
              case "top-right":
              case "bottom-right":
              case "right":
                m = -u;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                m = u;
            }
            return [m, v];
          })(o, e[0], e[1]) : (function(i, u) {
            let c = 0, m = 0;
            u < 0 && (u = 0);
            const v = u / Math.SQRT2;
            switch (i) {
              case "top-right":
              case "top-left":
                m = v - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                m = 7 - v;
                break;
              case "bottom":
                m = 7 - u;
                break;
              case "top":
                m = u - 7;
            }
            switch (i) {
              case "top-right":
              case "bottom-right":
                c = -v;
                break;
              case "top-left":
              case "bottom-left":
                c = v;
                break;
              case "left":
                c = u;
                break;
              case "right":
                c = -u;
            }
            return [c, m];
          })(o, e[0]);
        }
        function c_(o, e, i) {
          var u;
          const c = o.layout, m = (u = c.get("text-variable-anchor-offset")) === null || u === void 0 ? void 0 : u.evaluate(e, {}, i);
          if (m) {
            const x = m.values, C = [];
            for (let k = 0; k < x.length; k += 2) {
              const E = C[k] = x[k], D = x[k + 1].map(((F) => F * qi));
              E.startsWith("top") ? D[1] -= 7 : E.startsWith("bottom") && (D[1] += 7), C[k + 1] = D;
            }
            return new Pn(C);
          }
          const v = c.get("text-variable-anchor");
          if (v) {
            let x;
            x = o._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [c.get("text-radial-offset").evaluate(e, {}, i) * qi, Eg] : c.get("text-offset").evaluate(e, {}, i).map(((k) => k * qi));
            const C = [];
            for (const k of v) C.push(k, u_(k, x));
            return new Pn(C);
          }
          return null;
        }
        function Mg(o) {
          switch (o) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function AC(o, e, i, u, c, m, v, x, C, k, E, D) {
          let F = m.textMaxSize.evaluate(e, {});
          F === void 0 && (F = v);
          const V = o.layers[0].layout, G = V.get("icon-offset").evaluate(e, {}, E), H = h_(i.horizontal), Y = v / 24, ie = o.tilePixelRatio * Y, we = o.tilePixelRatio * F / 24, ce = o.tilePixelRatio * x, pe = o.tilePixelRatio * V.get("symbol-spacing"), Te = V.get("text-padding") * o.tilePixelRatio, Oe = (function(Qt, tr, Vt, wr = 1) {
            const bi = Qt.get("icon-padding").evaluate(tr, {}, Vt), Ni = bi && bi.values;
            return [Ni[0] * wr, Ni[1] * wr, Ni[2] * wr, Ni[3] * wr];
          })(V, e, E, o.tilePixelRatio), Xe = V.get("text-max-angle") / 180 * Math.PI, yt = V.get("text-rotation-alignment") !== "viewport" && V.get("symbol-placement") !== "point", ft = V.get("icon-rotation-alignment") === "map" && V.get("symbol-placement") !== "point", wt = V.get("symbol-placement"), Rt = pe / 2, Et = V.get("icon-text-fit");
          let Mt;
          u && Et !== "none" && (o.allowVerticalPlacement && i.vertical && (Mt = py(u, i.vertical, Et, V.get("icon-text-fit-padding"), G, Y)), H && (u = py(u, H, Et, V.get("icon-text-fit-padding"), G, Y)));
          const lt = E ? D.line.getGranularityForZoomLevel(E.z) : 1, rr = (Qt, tr) => {
            tr.x < 0 || tr.x >= it || tr.y < 0 || tr.y >= it || (function(Vt, wr, bi, Ni, vn, ko, Kn, nn, mi, Hi, on, an, jn, To, Xi, Jn, ji, Yi, Ki, zi, ni, oa, hc, aa, LC) {
              const fc = Vt.addToLineVertexArray(wr, bi);
              let Ll, pc, mc, gc, g_ = 0, v_ = 0, y_ = 0, __ = 0, Og = -1, $g = -1;
              const rs = {};
              let b_ = pn("");
              if (Vt.allowVerticalPlacement && Ni.vertical) {
                const Dn = nn.layout.get("text-rotate").evaluate(ni, {}, aa) + 90;
                mc = new gp(mi, wr, Hi, on, an, Ni.vertical, jn, To, Xi, Dn), Kn && (gc = new gp(mi, wr, Hi, on, an, Kn, ji, Yi, Xi, Dn));
              }
              if (vn) {
                const Dn = nn.layout.get("icon-rotate").evaluate(ni, {}), Po = nn.layout.get("icon-text-fit") !== "none", Bl = s_(vn, Dn, hc, Po), la = Kn ? s_(Kn, Dn, hc, Po) : void 0;
                pc = new gp(mi, wr, Hi, on, an, vn, ji, Yi, false, Dn), g_ = 4 * Bl.length;
                const Ol = Vt.iconSizeData;
                let Ia = null;
                Ol.kind === "source" ? (Ia = [es * nn.layout.get("icon-size").evaluate(ni, {})], Ia[0] > Ds && Ht(`${Vt.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : Ol.kind === "composite" && (Ia = [es * oa.compositeIconSizes[0].evaluate(ni, {}, aa), es * oa.compositeIconSizes[1].evaluate(ni, {}, aa)], (Ia[0] > Ds || Ia[1] > Ds) && Ht(`${Vt.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), Vt.addSymbols(Vt.icon, Bl, Ia, zi, Ki, ni, p.at.none, wr, fc.lineStartIndex, fc.lineLength, -1, aa), Og = Vt.icon.placedSymbolArray.length - 1, la && (v_ = 4 * la.length, Vt.addSymbols(Vt.icon, la, Ia, zi, Ki, ni, p.at.vertical, wr, fc.lineStartIndex, fc.lineLength, -1, aa), $g = Vt.icon.placedSymbolArray.length - 1);
              }
              const x_ = Object.keys(Ni.horizontal);
              for (const Dn of x_) {
                const Po = Ni.horizontal[Dn];
                if (!Ll) {
                  b_ = pn(Po.text);
                  const la = nn.layout.get("text-rotate").evaluate(ni, {}, aa);
                  Ll = new gp(mi, wr, Hi, on, an, Po, jn, To, Xi, la);
                }
                const Bl = Po.positionedLines.length === 1;
                if (y_ += d_(Vt, wr, Po, ko, nn, Xi, ni, Jn, fc, Ni.vertical ? p.at.horizontal : p.at.horizontalOnly, Bl ? x_ : [Dn], rs, Og, oa, aa), Bl) break;
              }
              Ni.vertical && (__ += d_(Vt, wr, Ni.vertical, ko, nn, Xi, ni, Jn, fc, p.at.vertical, ["vertical"], rs, $g, oa, aa));
              const BC = Ll ? Ll.boxStartIndex : Vt.collisionBoxArray.length, OC = Ll ? Ll.boxEndIndex : Vt.collisionBoxArray.length, $C = mc ? mc.boxStartIndex : Vt.collisionBoxArray.length, NC = mc ? mc.boxEndIndex : Vt.collisionBoxArray.length, jC = pc ? pc.boxStartIndex : Vt.collisionBoxArray.length, VC = pc ? pc.boxEndIndex : Vt.collisionBoxArray.length, UC = gc ? gc.boxStartIndex : Vt.collisionBoxArray.length, GC = gc ? gc.boxEndIndex : Vt.collisionBoxArray.length;
              let sa = -1;
              const yp = (Dn, Po) => Dn && Dn.circleDiameter ? Math.max(Dn.circleDiameter, Po) : Po;
              sa = yp(Ll, sa), sa = yp(mc, sa), sa = yp(pc, sa), sa = yp(gc, sa);
              const w_ = sa > -1 ? 1 : 0;
              w_ && (sa *= LC / qi), Vt.glyphOffsetArray.length >= nc.MAX_GLYPHS && Ht("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), ni.sortKey !== void 0 && Vt.addToSortKeyRanges(Vt.symbolInstances.length, ni.sortKey);
              const qC = c_(nn, ni, aa), [WC, ZC] = (function(Dn, Po) {
                const Bl = Dn.length, la = Po == null ? void 0 : Po.values;
                if ((la == null ? void 0 : la.length) > 0) for (let Ol = 0; Ol < la.length; Ol += 2) {
                  const Ia = la[Ol + 1];
                  Dn.emplaceBack(p.aJ[la[Ol]], Ia[0], Ia[1]);
                }
                return [Bl, Dn.length];
              })(Vt.textAnchorOffsets, qC);
              Vt.symbolInstances.emplaceBack(wr.x, wr.y, rs.right >= 0 ? rs.right : -1, rs.center >= 0 ? rs.center : -1, rs.left >= 0 ? rs.left : -1, rs.vertical || -1, Og, $g, b_, BC, OC, $C, NC, jC, VC, UC, GC, Hi, y_, __, g_, v_, w_, 0, jn, sa, WC, ZC);
            })(o, tr, Qt, i, u, c, Mt, o.layers[0], o.collisionBoxArray, e.index, e.sourceLayerIndex, o.index, ie, [Te, Te, Te, Te], yt, C, ce, Oe, ft, G, e, m, k, E, v);
          };
          if (wt === "line") for (const Qt of Qy(e.geometry, 0, 0, it, it)) {
            const tr = Dl(Qt, lt), Vt = EC(tr, pe, Xe, i.vertical || H, u, 24, we, o.overscaling, it);
            for (const wr of Vt) H && zC(o, H.text, Rt, wr) || rr(tr, wr);
          }
          else if (wt === "line-center") {
            for (const Qt of e.geometry) if (Qt.length > 1) {
              const tr = Dl(Qt, lt), Vt = IC(tr, Xe, i.vertical || H, u, 24, we);
              Vt && rr(tr, Vt);
            }
          } else if (e.type === "Polygon") for (const Qt of sl(e.geometry, 0)) {
            const tr = DC(Qt, 16);
            rr(Dl(Qt[0], lt, true), new zs(tr.x, tr.y, 0));
          }
          else if (e.type === "LineString") for (const Qt of e.geometry) {
            const tr = Dl(Qt, lt);
            rr(tr, new zs(tr[0].x, tr[0].y, 0));
          }
          else if (e.type === "Point") for (const Qt of e.geometry) for (const tr of Qt) rr([tr], new zs(tr.x, tr.y, 0));
        }
        function d_(o, e, i, u, c, m, v, x, C, k, E, D, F, V, G) {
          const H = (function(we, ce, pe, Te, Oe, Xe, yt, ft) {
            const wt = Te.layout.get("text-rotate").evaluate(Xe, {}) * Math.PI / 180, Rt = [];
            for (const Et of ce.positionedLines) for (const Mt of Et.positionedGlyphs) {
              if (!Mt.rect) continue;
              const lt = Mt.rect || {};
              let rr = 4, Qt = true, tr = 1, Vt = 0;
              const wr = (Oe || ft) && Mt.vertical, bi = Mt.metrics.advance * Mt.scale / 2;
              if (ft && ce.verticalizable && (Vt = Et.lineOffset / 2 - (Mt.imageName ? -(qi - Mt.metrics.width * Mt.scale) / 2 : (Mt.scale - 1) * qi)), Mt.imageName) {
                const Yi = yt[Mt.imageName];
                Qt = Yi.sdf, tr = Yi.pixelRatio, rr = 1 / tr;
              }
              const Ni = Oe ? [Mt.x + bi, Mt.y] : [0, 0];
              let vn = Oe ? [0, 0] : [Mt.x + bi + pe[0], Mt.y + pe[1] - Vt], ko = [0, 0];
              wr && (ko = vn, vn = [0, 0]);
              const Kn = Mt.metrics.isDoubleResolution ? 2 : 1, nn = (Mt.metrics.left - rr) * Mt.scale - bi + vn[0], mi = (-Mt.metrics.top - rr) * Mt.scale + vn[1], Hi = nn + lt.w / Kn * Mt.scale / tr, on = mi + lt.h / Kn * Mt.scale / tr, an = new S(nn, mi), jn = new S(Hi, mi), To = new S(nn, on), Xi = new S(Hi, on);
              if (wr) {
                const Yi = new S(-bi, bi - -17), Ki = -Math.PI / 2, zi = 12 - bi, ni = new S(22 - zi, -(Mt.imageName ? zi : 0)), oa = new S(...ko);
                an._rotateAround(Ki, Yi)._add(ni)._add(oa), jn._rotateAround(Ki, Yi)._add(ni)._add(oa), To._rotateAround(Ki, Yi)._add(ni)._add(oa), Xi._rotateAround(Ki, Yi)._add(ni)._add(oa);
              }
              if (wt) {
                const Yi = Math.sin(wt), Ki = Math.cos(wt), zi = [Ki, -Yi, Yi, Ki];
                an._matMult(zi), jn._matMult(zi), To._matMult(zi), Xi._matMult(zi);
              }
              const Jn = new S(0, 0), ji = new S(0, 0);
              Rt.push({ tl: an, tr: jn, bl: To, br: Xi, tex: lt, writingMode: ce.writingMode, glyphOffset: Ni, sectionIndex: Mt.sectionIndex, isSDF: Qt, pixelOffsetTL: Jn, pixelOffsetBR: ji, minFontScaleX: 0, minFontScaleY: 0 });
            }
            return Rt;
          })(0, i, x, c, m, v, u, o.allowVerticalPlacement), Y = o.textSizeData;
          let ie = null;
          Y.kind === "source" ? (ie = [es * c.layout.get("text-size").evaluate(v, {})], ie[0] > Ds && Ht(`${o.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : Y.kind === "composite" && (ie = [es * V.compositeTextSizes[0].evaluate(v, {}, G), es * V.compositeTextSizes[1].evaluate(v, {}, G)], (ie[0] > Ds || ie[1] > Ds) && Ht(`${o.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), o.addSymbols(o.text, H, ie, x, m, v, k, e, C.lineStartIndex, C.lineLength, F, G);
          for (const we of E) D[we] = o.text.placedSymbolArray.length - 1;
          return 4 * H.length;
        }
        function h_(o) {
          for (const e in o) return o[e];
          return null;
        }
        function zC(o, e, i, u) {
          const c = o.compareText;
          if (e in c) {
            const m = c[e];
            for (let v = m.length - 1; v >= 0; v--) if (u.dist(m[v]) < i) return true;
          } else c[e] = [];
          return c[e].push(u), false;
        }
        const f_ = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class Dg {
          static from(e) {
            if (!(e instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [i, u] = new Uint8Array(e, 0, 2);
            if (i !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const c = u >> 4;
            if (c !== 1) throw new Error(`Got v${c} data when expected v1.`);
            const m = f_[15 & u];
            if (!m) throw new Error("Unrecognized array type.");
            const [v] = new Uint16Array(e, 2, 1), [x] = new Uint32Array(e, 4, 1);
            return new Dg(x, v, m, e);
          }
          constructor(e, i = 64, u = Float64Array, c) {
            if (isNaN(e) || e < 0) throw new Error(`Unpexpected numItems value: ${e}.`);
            this.numItems = +e, this.nodeSize = Math.min(Math.max(+i, 2), 65535), this.ArrayType = u, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
            const m = f_.indexOf(this.ArrayType), v = 2 * e * this.ArrayType.BYTES_PER_ELEMENT, x = e * this.IndexArrayType.BYTES_PER_ELEMENT, C = (8 - x % 8) % 8;
            if (m < 0) throw new Error(`Unexpected typed array class: ${u}.`);
            c && c instanceof ArrayBuffer ? (this.data = c, this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + x + C, 2 * e), this._pos = 2 * e, this._finished = true) : (this.data = new ArrayBuffer(8 + v + x + C), this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + x + C, 2 * e), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + m]), new Uint16Array(this.data, 2, 1)[0] = i, new Uint32Array(this.data, 4, 1)[0] = e);
          }
          add(e, i) {
            const u = this._pos >> 1;
            return this.ids[u] = u, this.coords[this._pos++] = e, this.coords[this._pos++] = i, u;
          }
          finish() {
            const e = this._pos >> 1;
            if (e !== this.numItems) throw new Error(`Added ${e} items when expected ${this.numItems}.`);
            return Rg(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
          }
          range(e, i, u, c) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: m, coords: v, nodeSize: x } = this, C = [0, m.length - 1, 0], k = [];
            for (; C.length; ) {
              const E = C.pop() || 0, D = C.pop() || 0, F = C.pop() || 0;
              if (D - F <= x) {
                for (let Y = F; Y <= D; Y++) {
                  const ie = v[2 * Y], we = v[2 * Y + 1];
                  ie >= e && ie <= u && we >= i && we <= c && k.push(m[Y]);
                }
                continue;
              }
              const V = F + D >> 1, G = v[2 * V], H = v[2 * V + 1];
              G >= e && G <= u && H >= i && H <= c && k.push(m[V]), (E === 0 ? e <= G : i <= H) && (C.push(F), C.push(V - 1), C.push(1 - E)), (E === 0 ? u >= G : c >= H) && (C.push(V + 1), C.push(D), C.push(1 - E));
            }
            return k;
          }
          within(e, i, u) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: c, coords: m, nodeSize: v } = this, x = [0, c.length - 1, 0], C = [], k = u * u;
            for (; x.length; ) {
              const E = x.pop() || 0, D = x.pop() || 0, F = x.pop() || 0;
              if (D - F <= v) {
                for (let Y = F; Y <= D; Y++) m_(m[2 * Y], m[2 * Y + 1], e, i) <= k && C.push(c[Y]);
                continue;
              }
              const V = F + D >> 1, G = m[2 * V], H = m[2 * V + 1];
              m_(G, H, e, i) <= k && C.push(c[V]), (E === 0 ? e - u <= G : i - u <= H) && (x.push(F), x.push(V - 1), x.push(1 - E)), (E === 0 ? e + u >= G : i + u >= H) && (x.push(V + 1), x.push(D), x.push(1 - E));
            }
            return C;
          }
        }
        function Rg(o, e, i, u, c, m) {
          if (c - u <= i) return;
          const v = u + c >> 1;
          p_(o, e, v, u, c, m), Rg(o, e, i, u, v - 1, 1 - m), Rg(o, e, i, v + 1, c, 1 - m);
        }
        function p_(o, e, i, u, c, m) {
          for (; c > u; ) {
            if (c - u > 600) {
              const k = c - u + 1, E = i - u + 1, D = Math.log(k), F = 0.5 * Math.exp(2 * D / 3), V = 0.5 * Math.sqrt(D * F * (k - F) / k) * (E - k / 2 < 0 ? -1 : 1);
              p_(o, e, i, Math.max(u, Math.floor(i - E * F / k + V)), Math.min(c, Math.floor(i + (k - E) * F / k + V)), m);
            }
            const v = e[2 * i + m];
            let x = u, C = c;
            for (nh(o, e, u, i), e[2 * c + m] > v && nh(o, e, u, c); x < C; ) {
              for (nh(o, e, x, C), x++, C--; e[2 * x + m] < v; ) x++;
              for (; e[2 * C + m] > v; ) C--;
            }
            e[2 * u + m] === v ? nh(o, e, u, C) : (C++, nh(o, e, C, c)), C <= i && (u = C + 1), i <= C && (c = C - 1);
          }
        }
        function nh(o, e, i, u) {
          Ag(o, i, u), Ag(e, 2 * i, 2 * u), Ag(e, 2 * i + 1, 2 * u + 1);
        }
        function Ag(o, e, i) {
          const u = o[e];
          o[e] = o[i], o[i] = u;
        }
        function m_(o, e, i, u) {
          const c = o - i, m = e - u;
          return c * c + m * m;
        }
        var zg;
        p.cB = void 0, (zg = p.cB || (p.cB = {})).create = "create", zg.load = "load", zg.fullLoad = "fullLoad";
        let vp = null, oh = [];
        const Fg = 1e3 / 60, Lg = "loadTime", Bg = "fullLoadTime", FC = { mark(o) {
          performance.mark(o);
        }, frame(o) {
          const e = o;
          vp != null && oh.push(e - vp), vp = e;
        }, clearMetrics() {
          vp = null, oh = [], performance.clearMeasures(Lg), performance.clearMeasures(Bg);
          for (const o in p.cB) performance.clearMarks(p.cB[o]);
        }, getPerformanceMetrics() {
          performance.measure(Lg, p.cB.create, p.cB.load), performance.measure(Bg, p.cB.create, p.cB.fullLoad);
          const o = performance.getEntriesByName(Lg)[0].duration, e = performance.getEntriesByName(Bg)[0].duration, i = oh.length, u = 1 / (oh.reduce(((m, v) => m + v), 0) / i / 1e3), c = oh.filter(((m) => m > Fg)).reduce(((m, v) => m + (v - Fg) / Fg), 0);
          return { loadTime: o, fullLoadTime: e, fps: u, percentDroppedFrames: c / (i + c) * 100, totalFrames: i };
        } };
        p.$ = $e, p.A = ne, p.B = Xa, p.C = function([o, e, i]) {
          return e += 90, e *= Math.PI / 180, i *= Math.PI / 180, { x: o * Math.cos(e) * Math.sin(i), y: o * Math.sin(e) * Math.sin(i), z: o * Math.cos(i) };
        }, p.D = Wt, p.E = Re, p.F = yo, p.G = qr, p.H = Om, p.I = sg, p.J = function(o) {
          if (gt == null) {
            const e = o.navigator ? o.navigator.userAgent : null;
            gt = !!o.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")));
          }
          return gt;
        }, p.K = class {
          constructor(o, e) {
            this.target = o, this.mapId = e, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new nC((() => this.process())), this.subscription = St(this.target, "message", ((i) => this.receive(i)), false), this.globalScope = xr(self) ? o : window;
          }
          registerMessageHandler(o, e) {
            this.messageHandlers[o] = e;
          }
          unregisterMessageHandler(o) {
            delete this.messageHandlers[o];
          }
          sendAsync(o, e) {
            return new Promise(((i, u) => {
              const c = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), m = e ? St(e.signal, "abort", (() => {
                m == null ? void 0 : m.unsubscribe(), delete this.resolveRejects[c];
                const C = { id: c, type: "<cancel>", origin: location.origin, targetMapId: o.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(C);
              }), oC) : null;
              this.resolveRejects[c] = { resolve: (C) => {
                m == null ? void 0 : m.unsubscribe(), i(C);
              }, reject: (C) => {
                m == null ? void 0 : m.unsubscribe(), u(C);
              } };
              const v = [], x = Object.assign(Object.assign({}, o), { id: c, sourceMapId: this.mapId, origin: location.origin, data: bl(o.data, v) });
              this.target.postMessage(x, { transfer: v });
            }));
          }
          receive(o) {
            const e = o.data, i = e.id;
            if (!(e.origin !== "file://" && location.origin !== "file://" && e.origin !== "resource://android" && location.origin !== "resource://android" && e.origin !== location.origin || e.targetMapId && this.mapId !== e.targetMapId)) {
              if (e.type === "<cancel>") {
                delete this.tasks[i];
                const u = this.abortControllers[i];
                return delete this.abortControllers[i], void (u && u.abort());
              }
              if (xr(self) || e.mustQueue) return this.tasks[i] = e, this.taskQueue.push(i), void this.invoker.trigger();
              this.processTask(i, e);
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const o = this.taskQueue.shift(), e = this.tasks[o];
            delete this.tasks[o], this.taskQueue.length > 0 && this.invoker.trigger(), e && this.processTask(o, e);
          }
          processTask(o, e) {
            return s(this, void 0, void 0, (function* () {
              if (e.type === "<response>") {
                const c = this.resolveRejects[o];
                return delete this.resolveRejects[o], c ? void (e.error ? c.reject(Yo(e.error)) : c.resolve(Yo(e.data))) : void 0;
              }
              if (!this.messageHandlers[e.type]) return void this.completeTask(o, new Error(`Could not find a registered handler for ${e.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const i = Yo(e.data), u = new AbortController();
              this.abortControllers[o] = u;
              try {
                const c = yield this.messageHandlers[e.type](e.sourceMapId, i, u);
                this.completeTask(o, null, c);
              } catch (c) {
                this.completeTask(o, c);
              }
            }));
          }
          completeTask(o, e, i) {
            const u = [];
            delete this.abortControllers[o];
            const c = { id: o, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: e ? bl(e) : null, data: bl(i, u) };
            this.target.postMessage(c, { transfer: u });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, p.L = Cn, p.M = function() {
          var o = new ne(16);
          return ne != Float32Array && (o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0), o[0] = 1, o[5] = 1, o[10] = 1, o[15] = 1, o;
        }, p.N = function(o, e, i) {
          var u, c, m, v, x, C, k, E, D, F, V, G, H = i[0], Y = i[1], ie = i[2];
          return e === o ? (o[12] = e[0] * H + e[4] * Y + e[8] * ie + e[12], o[13] = e[1] * H + e[5] * Y + e[9] * ie + e[13], o[14] = e[2] * H + e[6] * Y + e[10] * ie + e[14], o[15] = e[3] * H + e[7] * Y + e[11] * ie + e[15]) : (c = e[1], m = e[2], v = e[3], x = e[4], C = e[5], k = e[6], E = e[7], D = e[8], F = e[9], V = e[10], G = e[11], o[0] = u = e[0], o[1] = c, o[2] = m, o[3] = v, o[4] = x, o[5] = C, o[6] = k, o[7] = E, o[8] = D, o[9] = F, o[10] = V, o[11] = G, o[12] = u * H + x * Y + D * ie + e[12], o[13] = c * H + C * Y + F * ie + e[13], o[14] = m * H + k * Y + V * ie + e[14], o[15] = v * H + E * Y + G * ie + e[15]), o;
        }, p.O = function(o, e, i) {
          var u = i[0], c = i[1], m = i[2];
          return o[0] = e[0] * u, o[1] = e[1] * u, o[2] = e[2] * u, o[3] = e[3] * u, o[4] = e[4] * c, o[5] = e[5] * c, o[6] = e[6] * c, o[7] = e[7] * c, o[8] = e[8] * m, o[9] = e[9] * m, o[10] = e[10] * m, o[11] = e[11] * m, o[12] = e[12], o[13] = e[13], o[14] = e[14], o[15] = e[15], o;
        }, p.P = S, p.Q = function(o, e, i) {
          var u = e[0], c = e[1], m = e[2], v = e[3], x = e[4], C = e[5], k = e[6], E = e[7], D = e[8], F = e[9], V = e[10], G = e[11], H = e[12], Y = e[13], ie = e[14], we = e[15], ce = i[0], pe = i[1], Te = i[2], Oe = i[3];
          return o[0] = ce * u + pe * x + Te * D + Oe * H, o[1] = ce * c + pe * C + Te * F + Oe * Y, o[2] = ce * m + pe * k + Te * V + Oe * ie, o[3] = ce * v + pe * E + Te * G + Oe * we, o[4] = (ce = i[4]) * u + (pe = i[5]) * x + (Te = i[6]) * D + (Oe = i[7]) * H, o[5] = ce * c + pe * C + Te * F + Oe * Y, o[6] = ce * m + pe * k + Te * V + Oe * ie, o[7] = ce * v + pe * E + Te * G + Oe * we, o[8] = (ce = i[8]) * u + (pe = i[9]) * x + (Te = i[10]) * D + (Oe = i[11]) * H, o[9] = ce * c + pe * C + Te * F + Oe * Y, o[10] = ce * m + pe * k + Te * V + Oe * ie, o[11] = ce * v + pe * E + Te * G + Oe * we, o[12] = (ce = i[12]) * u + (pe = i[13]) * x + (Te = i[14]) * D + (Oe = i[15]) * H, o[13] = ce * c + pe * C + Te * F + Oe * Y, o[14] = ce * m + pe * k + Te * V + Oe * ie, o[15] = ce * v + pe * E + Te * G + Oe * we, o;
        }, p.R = Yn, p.S = function(o, e) {
          const i = {};
          for (let u = 0; u < e.length; u++) {
            const c = e[u];
            c in o && (i[c] = o[c]);
          }
          return i;
        }, p.T = Km, p.U = Rs, p.V = Dt, p.W = Cy, p.X = wy, p.Y = N, p.Z = J, p._ = s, p.a = en, p.a$ = function(o, e) {
          return o[0] * e[0] + o[1] * e[1] + o[2] * e[2];
        }, p.a0 = Co, p.a1 = ky, p.a2 = ip, p.a3 = it, p.a4 = function(o, e) {
          var i, u, c, m, v;
          if (!o) return e ?? {};
          if (!e) return o;
          let x = Object.assign({}, o);
          if (e.removeAll && (x = { removeAll: true }), e.remove) {
            const C = new Set(e.remove);
            x.add && (x.add = x.add.filter(((E) => !C.has(E.id)))), x.update && (x.update = x.update.filter(((E) => !C.has(E.id))));
            const k = new Set(((i = o.add) !== null && i !== void 0 ? i : []).map(((E) => E.id)));
            e.remove = e.remove.filter(((E) => !k.has(E)));
          }
          if (e.remove) {
            const C = new Set(x.remove ? x.remove.concat(e.remove) : e.remove);
            x.remove = Array.from(C.values());
          }
          if (e.add) {
            const C = x.add ? x.add.concat(e.add) : e.add, k = new Map(C.map(((E) => [E.id, E])));
            x.add = Array.from(k.values());
          }
          if (e.update) {
            const C = new Map((u = x.update) === null || u === void 0 ? void 0 : u.map(((k) => [k.id, k])));
            for (const k of e.update) {
              const E = (c = C.get(k.id)) !== null && c !== void 0 ? c : { id: k.id };
              k.newGeometry && (E.newGeometry = k.newGeometry), k.addOrUpdateProperties && (E.addOrUpdateProperties = ((m = E.addOrUpdateProperties) !== null && m !== void 0 ? m : []).concat(k.addOrUpdateProperties)), k.removeProperties && (E.removeProperties = ((v = E.removeProperties) !== null && v !== void 0 ? v : []).concat(k.removeProperties)), k.removeAllProperties && (E.removeAllProperties = true), C.set(k.id, E);
            }
            x.update = Array.from(C.values());
          }
          return x.remove && x.add && (x.remove = x.remove.filter(((C) => x.add.findIndex(((k) => k.id === C)) === -1))), x;
        }, p.a5 = Yd, p.a6 = Rl, p.a7 = 25, p.a8 = gg, p.a9 = (o) => {
          const e = window.document.createElement("video");
          return e.muted = true, new Promise(((i) => {
            e.onloadstart = () => {
              i(e);
            };
            for (const u of o) {
              const c = window.document.createElement("source");
              $(u) || (e.crossOrigin = "Anonymous"), c.src = u, e.appendChild(c);
            }
          }));
        }, p.aA = dg, p.aB = et, p.aC = function(o, e, i, u) {
          const c = e.y - o.y, m = e.x - o.x, v = u.y - i.y, x = u.x - i.x, C = v * m - x * c;
          if (C === 0) return null;
          const k = (x * (o.y - i.y) - v * (o.x - i.x)) / C;
          return new S(o.x + k * m, o.y + k * c);
        }, p.aD = Qy, p.aE = wv, p.aF = function(o) {
          let e = 1 / 0, i = 1 / 0, u = -1 / 0, c = -1 / 0;
          for (const m of o) e = Math.min(e, m.x), i = Math.min(i, m.y), u = Math.max(u, m.x), c = Math.max(c, m.y);
          return [e, i, u, c];
        }, p.aG = qi, p.aH = pt, p.aI = function(o, e, i, u, c = false) {
          if (!i[0] && !i[1]) return [0, 0];
          const m = c ? u === "map" ? -o.bearingInRadians : 0 : u === "viewport" ? o.bearingInRadians : 0;
          if (m) {
            const v = Math.sin(m), x = Math.cos(m);
            i = [i[0] * x - i[1] * v, i[0] * v + i[1] * x];
          }
          return [c ? i[0] : pt(e, i[0], o.zoom), c ? i[1] : pt(e, i[1], o.zoom)];
        }, p.aK = cg, p.aL = Mg, p.aM = ug, p.aN = Dg, p.aO = Xr, p.aP = Kf, p.aQ = fe, p.aR = Yt, p.aS = Tt, p.aT = mt, p.aU = Ty, p.aV = ue, p.aW = le, p.aX = function(o) {
          var e = new ne(3);
          return e[0] = o[0], e[1] = o[1], e[2] = o[2], e;
        }, p.aY = function(o, e, i) {
          return o[0] = e[0] - i[0], o[1] = e[1] - i[1], o[2] = e[2] - i[2], o;
        }, p.aZ = function(o, e) {
          var i = e[0], u = e[1], c = e[2], m = i * i + u * u + c * c;
          return m > 0 && (m = 1 / Math.sqrt(m)), o[0] = e[0] * m, o[1] = e[1] * m, o[2] = e[2] * m, o;
        }, p.a_ = be, p.aa = ye, p.ab = function() {
          return dr++;
        }, p.ac = b, p.ad = nc, p.ae = hl, p.af = Pa, p.ag = My, p.ah = function(o) {
          const e = {};
          if (o.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((i, u, c, m) => {
            const v = c || m;
            return e[u] = !v || v.toLowerCase(), "";
          })), e["max-age"]) {
            const i = parseInt(e["max-age"], 10);
            isNaN(i) ? delete e["max-age"] : e["max-age"] = i;
          }
          return e;
        }, p.ai = bt, p.aj = 85.051129, p.ak = rt, p.al = function(o) {
          return Math.pow(2, o);
        }, p.am = oe, p.an = Sy, p.ao = function(o) {
          return Math.log(o) / Math.LN2;
        }, p.ap = function(o) {
          var e = o[0], i = o[1];
          return e * e + i * i;
        }, p.aq = class {
          constructor(o, e) {
            this.max = o, this.onRemove = e, this.reset();
          }
          reset() {
            for (const o in this.data) for (const e of this.data[o]) e.timeout && clearTimeout(e.timeout), this.onRemove(e.value);
            return this.data = {}, this.order = [], this;
          }
          add(o, e, i) {
            const u = o.wrapped().key;
            this.data[u] === void 0 && (this.data[u] = []);
            const c = { value: e, timeout: void 0 };
            if (i !== void 0 && (c.timeout = setTimeout((() => {
              this.remove(o, c);
            }), i)), this.data[u].push(c), this.order.push(u), this.order.length > this.max) {
              const m = this._getAndRemoveByKey(this.order[0]);
              m && this.onRemove(m);
            }
            return this;
          }
          has(o) {
            return o.wrapped().key in this.data;
          }
          getAndRemove(o) {
            return this.has(o) ? this._getAndRemoveByKey(o.wrapped().key) : null;
          }
          _getAndRemoveByKey(o) {
            const e = this.data[o].shift();
            return e.timeout && clearTimeout(e.timeout), this.data[o].length === 0 && delete this.data[o], this.order.splice(this.order.indexOf(o), 1), e.value;
          }
          getByKey(o) {
            const e = this.data[o];
            return e ? e[0].value : null;
          }
          get(o) {
            return this.has(o) ? this.data[o.wrapped().key][0].value : null;
          }
          remove(o, e) {
            if (!this.has(o)) return this;
            const i = o.wrapped().key, u = e === void 0 ? 0 : this.data[i].indexOf(e), c = this.data[i][u];
            return this.data[i].splice(u, 1), c.timeout && clearTimeout(c.timeout), this.data[i].length === 0 && delete this.data[i], this.onRemove(c.value), this.order.splice(this.order.indexOf(i), 1), this;
          }
          setMaxSize(o) {
            for (this.max = o; this.order.length > this.max; ) {
              const e = this._getAndRemoveByKey(this.order[0]);
              e && this.onRemove(e);
            }
            return this;
          }
          filter(o) {
            const e = [];
            for (const i in this.data) for (const u of this.data[i]) o(u.value) || e.push(u);
            for (const i of e) this.remove(i.value.tileID, i);
          }
        }, p.ar = function(o) {
          if (!o.length) return /* @__PURE__ */ new Set();
          const e = Math.max(...o.map(((C) => C.canonical.z)));
          let i = 1 / 0, u = -1 / 0, c = 1 / 0, m = -1 / 0;
          const v = [];
          for (const C of o) {
            const { x: k, y: E, z: D } = C.canonical, F = Math.pow(2, e - D), V = k * F, G = E * F;
            v.push({ id: C, x: V, y: G }), V < i && (i = V), V > u && (u = V), G < c && (c = G), G > m && (m = G);
          }
          const x = /* @__PURE__ */ new Set();
          for (const C of v) C.x !== i && C.x !== u && C.y !== c && C.y !== m || x.add(C.id);
          return x;
        }, p.as = function(o, e) {
          let i = 0, u = 0;
          if (o.kind === "constant") u = o.layoutSize;
          else if (o.kind !== "source") {
            const { interpolationType: c, minZoom: m, maxZoom: v } = o, x = c ? bt(rn.interpolationFactor(c, e, m, v), 0, 1) : 0;
            o.kind === "camera" ? u = yo.number(o.minSize, o.maxSize, x) : i = x;
          }
          return { uSizeT: i, uSize: u };
        }, p.au = function(o, { uSize: e, uSizeT: i }, { lowerSize: u, upperSize: c }) {
          return o.kind === "source" ? u / es : o.kind === "composite" ? yo.number(u / es, c / es, i) : e;
        }, p.av = function(o, e) {
          var i = e[0], u = e[1], c = e[2], m = e[3], v = e[4], x = e[5], C = e[6], k = e[7], E = e[8], D = e[9], F = e[10], V = e[11], G = e[12], H = e[13], Y = e[14], ie = e[15], we = i * x - u * v, ce = i * C - c * v, pe = i * k - m * v, Te = u * C - c * x, Oe = u * k - m * x, Xe = c * k - m * C, yt = E * H - D * G, ft = E * Y - F * G, wt = E * ie - V * G, Rt = D * Y - F * H, Et = D * ie - V * H, Mt = F * ie - V * Y, lt = we * Mt - ce * Et + pe * Rt + Te * wt - Oe * ft + Xe * yt;
          return lt ? (o[0] = (x * Mt - C * Et + k * Rt) * (lt = 1 / lt), o[1] = (c * Et - u * Mt - m * Rt) * lt, o[2] = (H * Xe - Y * Oe + ie * Te) * lt, o[3] = (F * Oe - D * Xe - V * Te) * lt, o[4] = (C * wt - v * Mt - k * ft) * lt, o[5] = (i * Mt - c * wt + m * ft) * lt, o[6] = (Y * pe - G * Xe - ie * ce) * lt, o[7] = (E * Xe - F * pe + V * ce) * lt, o[8] = (v * Et - x * wt + k * yt) * lt, o[9] = (u * wt - i * Et - m * yt) * lt, o[10] = (G * Oe - H * pe + ie * we) * lt, o[11] = (D * pe - E * Oe - V * we) * lt, o[12] = (x * ft - v * Rt - C * yt) * lt, o[13] = (i * Rt - u * ft + c * yt) * lt, o[14] = (H * ce - G * Te - Y * we) * lt, o[15] = (E * Te - D * ce + F * we) * lt, o) : null;
        }, p.aw = kt, p.ax = function(o) {
          var e = o[0], i = o[1];
          return Math.sqrt(e * e + i * i);
        }, p.ay = function(o) {
          return o[0] = 0, o[1] = 0, o;
        }, p.az = function(o, e, i) {
          return o[0] = e[0] * i, o[1] = e[1] * i, o;
        }, p.b = Be, p.b$ = function(o, e) {
          var i = Math.sin(e), u = Math.cos(e);
          return o[0] = u, o[1] = i, o[2] = 0, o[3] = -i, o[4] = u, o[5] = 0, o[6] = 0, o[7] = 0, o[8] = 1, o;
        }, p.b0 = function(o, e, i) {
          return o[0] = e[0] * i[0], o[1] = e[1] * i[1], o[2] = e[2] * i[2], o[3] = e[3] * i[3], o;
        }, p.b1 = ke, p.b2 = function(o, e, i) {
          const u = e[0] * i[0] + e[1] * i[1] + e[2] * i[2];
          return u === 0 ? null : (-(o[0] * i[0] + o[1] * i[1] + o[2] * i[2]) - i[3]) / u;
        }, p.b3 = Ge, p.b4 = function(o, e, i) {
          return o[0] = e[0] * i, o[1] = e[1] * i, o[2] = e[2] * i, o[3] = e[3] * i, o;
        }, p.b5 = function(o, e) {
          return o[0] * e[0] + o[1] * e[1] + o[2] * e[2] + o[3];
        }, p.b6 = Iy, p.b7 = oc, p.b8 = function(o, e, i, u, c) {
          var m = 1 / Math.tan(e / 2);
          if (o[0] = m / i, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = m, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[11] = -1, o[12] = 0, o[13] = 0, o[15] = 0, c != null && c !== 1 / 0) {
            var v = 1 / (u - c);
            o[10] = (c + u) * v, o[14] = 2 * c * u * v;
          } else o[10] = -1, o[14] = -2 * u;
          return o;
        }, p.b9 = function(o) {
          var e = new ne(16);
          return e[0] = o[0], e[1] = o[1], e[2] = o[2], e[3] = o[3], e[4] = o[4], e[5] = o[5], e[6] = o[6], e[7] = o[7], e[8] = o[8], e[9] = o[9], e[10] = o[10], e[11] = o[11], e[12] = o[12], e[13] = o[13], e[14] = o[14], e[15] = o[15], e;
        }, p.bA = function(o, e, i, u) {
          var c = [], m = [];
          return c[0] = e[0] - i[0], c[1] = e[1] - i[1], c[2] = e[2] - i[2], m[0] = c[0] * Math.cos(u) - c[1] * Math.sin(u), m[1] = c[0] * Math.sin(u) + c[1] * Math.cos(u), m[2] = c[2], o[0] = m[0] + i[0], o[1] = m[1] + i[1], o[2] = m[2] + i[2], o;
        }, p.bB = function(o, e, i, u) {
          var c = [], m = [];
          return c[0] = e[0] - i[0], c[1] = e[1] - i[1], c[2] = e[2] - i[2], m[0] = c[0], m[1] = c[1] * Math.cos(u) - c[2] * Math.sin(u), m[2] = c[1] * Math.sin(u) + c[2] * Math.cos(u), o[0] = m[0] + i[0], o[1] = m[1] + i[1], o[2] = m[2] + i[2], o;
        }, p.bC = function(o, e, i, u) {
          var c = [], m = [];
          return c[0] = e[0] - i[0], c[1] = e[1] - i[1], c[2] = e[2] - i[2], m[0] = c[2] * Math.sin(u) + c[0] * Math.cos(u), m[1] = c[1], m[2] = c[2] * Math.cos(u) - c[0] * Math.sin(u), o[0] = m[0] + i[0], o[1] = m[1] + i[1], o[2] = m[2] + i[2], o;
        }, p.bD = function(o, e, i) {
          var u = Math.sin(i), c = Math.cos(i), m = e[0], v = e[1], x = e[2], C = e[3], k = e[8], E = e[9], D = e[10], F = e[11];
          return e !== o && (o[4] = e[4], o[5] = e[5], o[6] = e[6], o[7] = e[7], o[12] = e[12], o[13] = e[13], o[14] = e[14], o[15] = e[15]), o[0] = m * c - k * u, o[1] = v * c - E * u, o[2] = x * c - D * u, o[3] = C * c - F * u, o[8] = m * u + k * c, o[9] = v * u + E * c, o[10] = x * u + D * c, o[11] = C * u + F * c, o;
        }, p.bE = function(o, e) {
          const i = $t(o, 360), u = $t(e, 360), c = u - i, m = u > i ? c - 360 : c + 360;
          return Math.abs(c) < Math.abs(m) ? c : m;
        }, p.bF = function(o) {
          return o[0] = 0, o[1] = 0, o[2] = 0, o;
        }, p.bG = function(o, e, i, u) {
          const c = Math.sqrt(o * o + e * e), m = Math.sqrt(i * i + u * u);
          o /= c, e /= c, i /= m, u /= m;
          const v = Math.acos(o * i + e * u);
          return -e * i + o * u > 0 ? v : -v;
        }, p.bH = function(o, e) {
          const i = $t(o, 2 * Math.PI), u = $t(e, 2 * Math.PI);
          return Math.min(Math.abs(i - u), Math.abs(i - u + 2 * Math.PI), Math.abs(i - u - 2 * Math.PI));
        }, p.bI = function() {
          const o = {}, e = se.$version;
          for (const i in se.$root) {
            const u = se.$root[i];
            if (u.required) {
              let c = null;
              c = i === "version" ? e : u.type === "array" ? [] : {}, c != null && (o[i] = c);
            }
          }
          return o;
        }, p.bJ = Ci, p.bK = Sd, p.bL = function o(e, i) {
          if (Array.isArray(e)) {
            if (!Array.isArray(i) || e.length !== i.length) return false;
            for (let u = 0; u < e.length; u++) if (!o(e[u], i[u])) return false;
            return true;
          }
          if (typeof e == "object" && e !== null && i !== null) {
            if (typeof i != "object" || Object.keys(e).length !== Object.keys(i).length) return false;
            for (const u in e) if (!o(e[u], i[u])) return false;
            return true;
          }
          return e === i;
        }, p.bM = function(o) {
          o = o.slice();
          const e = /* @__PURE__ */ Object.create(null);
          for (let i = 0; i < o.length; i++) e[o[i].id] = o[i];
          for (let i = 0; i < o.length; i++) "ref" in o[i] && (o[i] = We(o[i], e[o[i].ref]));
          return o;
        }, p.bN = function(o, e) {
          if (o.type === "custom") return new iC(o, e);
          switch (o.type) {
            case "background":
              return new rC(o, e);
            case "circle":
              return new j2(o, e);
            case "color-relief":
              return new Z2(o, e);
            case "fill":
              return new lw(o, e);
            case "fill-extrusion":
              return new _w(o, e);
            case "heatmap":
              return new U2(o, e);
            case "hillshade":
              return new q2(o, e);
            case "line":
              return new Tw(o, e);
            case "raster":
              return new Vm(o, e);
            case "symbol":
              return new rp(o, e);
          }
        }, p.bO = (o) => o.type === "raster", p.bP = lr, p.bQ = function(o, e) {
          if (!o) return [{ command: "setStyle", args: [e] }];
          let i = [];
          try {
            if (!Qe(o.version, e.version)) return [{ command: "setStyle", args: [e] }];
            Qe(o.center, e.center) || i.push({ command: "setCenter", args: [e.center] }), Qe(o.state, e.state) || i.push({ command: "setGlobalState", args: [e.state] }), Qe(o.centerAltitude, e.centerAltitude) || i.push({ command: "setCenterAltitude", args: [e.centerAltitude] }), Qe(o.zoom, e.zoom) || i.push({ command: "setZoom", args: [e.zoom] }), Qe(o.bearing, e.bearing) || i.push({ command: "setBearing", args: [e.bearing] }), Qe(o.pitch, e.pitch) || i.push({ command: "setPitch", args: [e.pitch] }), Qe(o.roll, e.roll) || i.push({ command: "setRoll", args: [e.roll] }), Qe(o.sprite, e.sprite) || i.push({ command: "setSprite", args: [e.sprite] }), Qe(o.glyphs, e.glyphs) || i.push({ command: "setGlyphs", args: [e.glyphs] }), Qe(o.transition, e.transition) || i.push({ command: "setTransition", args: [e.transition] }), Qe(o.light, e.light) || i.push({ command: "setLight", args: [e.light] }), Qe(o.terrain, e.terrain) || i.push({ command: "setTerrain", args: [e.terrain] }), Qe(o.sky, e.sky) || i.push({ command: "setSky", args: [e.sky] }), Qe(o.projection, e.projection) || i.push({ command: "setProjection", args: [e.projection] });
            const u = {}, c = [];
            (function(v, x, C, k) {
              let E;
              for (E in x = x || {}, v = v || {}) Object.prototype.hasOwnProperty.call(v, E) && (Object.prototype.hasOwnProperty.call(x, E) || qt(E, C, k));
              for (E in x) Object.prototype.hasOwnProperty.call(x, E) && (Object.prototype.hasOwnProperty.call(v, E) ? Qe(v[E], x[E]) || (v[E].type === "geojson" && x[E].type === "geojson" && Ur(v, x, E) ? tt(C, { command: "setGeoJSONSourceData", args: [E, x[E].data] }) : sr(E, x, C, k)) : At(E, x, C));
            })(o.sources, e.sources, c, u);
            const m = [];
            o.layers && o.layers.forEach(((v) => {
              "source" in v && u[v.source] ? i.push({ command: "removeLayer", args: [v.id] }) : m.push(v);
            })), i = i.concat(c), (function(v, x, C) {
              x = x || [];
              const k = (v = v || []).map(Sr), E = x.map(Sr), D = v.reduce(Dr, {}), F = x.reduce(Dr, {}), V = k.slice(), G = /* @__PURE__ */ Object.create(null);
              let H, Y, ie, we, ce;
              for (let pe = 0, Te = 0; pe < k.length; pe++) H = k[pe], Object.prototype.hasOwnProperty.call(F, H) ? Te++ : (tt(C, { command: "removeLayer", args: [H] }), V.splice(V.indexOf(H, Te), 1));
              for (let pe = 0, Te = 0; pe < E.length; pe++) H = E[E.length - 1 - pe], V[V.length - 1 - pe] !== H && (Object.prototype.hasOwnProperty.call(D, H) ? (tt(C, { command: "removeLayer", args: [H] }), V.splice(V.lastIndexOf(H, V.length - Te), 1)) : Te++, we = V[V.length - pe], tt(C, { command: "addLayer", args: [F[H], we] }), V.splice(V.length - pe, 0, H), G[H] = true);
              for (let pe = 0; pe < E.length; pe++) if (H = E[pe], Y = D[H], ie = F[H], !G[H] && !Qe(Y, ie)) if (Qe(Y.source, ie.source) && Qe(Y["source-layer"], ie["source-layer"]) && Qe(Y.type, ie.type)) {
                for (ce in mr(Y.layout, ie.layout, C, H, null, "setLayoutProperty"), mr(Y.paint, ie.paint, C, H, null, "setPaintProperty"), Qe(Y.filter, ie.filter) || tt(C, { command: "setFilter", args: [H, ie.filter] }), Qe(Y.minzoom, ie.minzoom) && Qe(Y.maxzoom, ie.maxzoom) || tt(C, { command: "setLayerZoomRange", args: [H, ie.minzoom, ie.maxzoom] }), Y) Object.prototype.hasOwnProperty.call(Y, ce) && ce !== "layout" && ce !== "paint" && ce !== "filter" && ce !== "metadata" && ce !== "minzoom" && ce !== "maxzoom" && (ce.indexOf("paint.") === 0 ? mr(Y[ce], ie[ce], C, H, ce.slice(6), "setPaintProperty") : Qe(Y[ce], ie[ce]) || tt(C, { command: "setLayerProperty", args: [H, ce, ie[ce]] }));
                for (ce in ie) Object.prototype.hasOwnProperty.call(ie, ce) && !Object.prototype.hasOwnProperty.call(Y, ce) && ce !== "layout" && ce !== "paint" && ce !== "filter" && ce !== "metadata" && ce !== "minzoom" && ce !== "maxzoom" && (ce.indexOf("paint.") === 0 ? mr(Y[ce], ie[ce], C, H, ce.slice(6), "setPaintProperty") : Qe(Y[ce], ie[ce]) || tt(C, { command: "setLayerProperty", args: [H, ce, ie[ce]] }));
              } else tt(C, { command: "removeLayer", args: [H] }), we = V[V.lastIndexOf(H) + 1], tt(C, { command: "addLayer", args: [ie, we] });
            })(m, e.layers, i);
          } catch (u) {
            console.warn("Unable to compute style diff:", u), i = [{ command: "setStyle", args: [e] }];
          }
          return i;
        }, p.bR = function(o) {
          const e = [], i = o.id;
          return i === void 0 && e.push({ message: `layers.${i}: missing required property "id"` }), o.render === void 0 && e.push({ message: `layers.${i}: missing required method "render"` }), o.renderingMode && o.renderingMode !== "2d" && o.renderingMode !== "3d" && e.push({ message: `layers.${i}: property "renderingMode" must be either "2d" or "3d"` }), e;
        }, p.bS = yr, p.bT = Pr, p.bU = class extends lo {
          constructor(o, e) {
            super(o, e), this.current = 0;
          }
          set(o) {
            this.current !== o && (this.current = o, this.gl.uniform1i(this.location, o));
          }
        }, p.bV = Xn, p.bW = class extends lo {
          constructor(o, e) {
            super(o, e), this.current = ka;
          }
          set(o) {
            if (o[12] !== this.current[12] || o[0] !== this.current[0]) return this.current = o, void this.gl.uniformMatrix4fv(this.location, false, o);
            for (let e = 1; e < 16; e++) if (o[e] !== this.current[e]) {
              this.current = o, this.gl.uniformMatrix4fv(this.location, false, o);
              break;
            }
          }
        }, p.bX = Ja, p.bY = class extends lo {
          constructor(o, e) {
            super(o, e), this.current = [0, 0, 0];
          }
          set(o) {
            o[0] === this.current[0] && o[1] === this.current[1] && o[2] === this.current[2] || (this.current = o, this.gl.uniform3f(this.location, o[0], o[1], o[2]));
          }
        }, p.bZ = class extends lo {
          constructor(o, e) {
            super(o, e), this.current = [0, 0];
          }
          set(o) {
            o[0] === this.current[0] && o[1] === this.current[1] || (this.current = o, this.gl.uniform2f(this.location, o[0], o[1]));
          }
        }, p.b_ = ae, p.ba = function(o, e, i) {
          var u = Math.sin(i), c = Math.cos(i), m = e[0], v = e[1], x = e[2], C = e[3], k = e[4], E = e[5], D = e[6], F = e[7];
          return e !== o && (o[8] = e[8], o[9] = e[9], o[10] = e[10], o[11] = e[11], o[12] = e[12], o[13] = e[13], o[14] = e[14], o[15] = e[15]), o[0] = m * c + k * u, o[1] = v * c + E * u, o[2] = x * c + D * u, o[3] = C * c + F * u, o[4] = k * c - m * u, o[5] = E * c - v * u, o[6] = D * c - x * u, o[7] = F * c - C * u, o;
        }, p.bb = function(o, e, i) {
          var u = Math.sin(i), c = Math.cos(i), m = e[4], v = e[5], x = e[6], C = e[7], k = e[8], E = e[9], D = e[10], F = e[11];
          return e !== o && (o[0] = e[0], o[1] = e[1], o[2] = e[2], o[3] = e[3], o[12] = e[12], o[13] = e[13], o[14] = e[14], o[15] = e[15]), o[4] = m * c + k * u, o[5] = v * c + E * u, o[6] = x * c + D * u, o[7] = C * c + F * u, o[8] = k * c - m * u, o[9] = E * c - v * u, o[10] = D * c - x * u, o[11] = F * c - C * u, o;
        }, p.bc = function() {
          const o = new Float32Array(16);
          return oe(o), o;
        }, p.bd = function() {
          const o = new Float64Array(16);
          return oe(o), o;
        }, p.be = function() {
          return new Float64Array(16);
        }, p.bf = function(o, e, i) {
          const u = new Float64Array(4);
          return Ct(u, o, e - 90, i), u;
        }, p.bg = function(o, e, i, u) {
          var c, m, v, x, C, k = e[0], E = e[1], D = e[2], F = e[3], V = i[0], G = i[1], H = i[2], Y = i[3];
          return (m = k * V + E * G + D * H + F * Y) < 0 && (m = -m, V = -V, G = -G, H = -H, Y = -Y), 1 - m > te ? (c = Math.acos(m), v = Math.sin(c), x = Math.sin((1 - u) * c) / v, C = Math.sin(u * c) / v) : (x = 1 - u, C = u), o[0] = x * k + C * V, o[1] = x * E + C * G, o[2] = x * D + C * H, o[3] = x * F + C * Y, o;
        }, p.bh = function(o) {
          const e = new Float64Array(9);
          var i, u, c, m, v, x, C, k, E, D, F, V, G, H, Y, ie, we, ce;
          D = (c = (u = o)[0]) * (C = c + c), F = (m = u[1]) * C, G = (v = u[2]) * C, H = v * (k = m + m), ie = (x = u[3]) * C, we = x * k, ce = x * (E = v + v), (i = e)[0] = 1 - (V = m * k) - (Y = v * E), i[3] = F - ce, i[6] = G + we, i[1] = F + ce, i[4] = 1 - D - Y, i[7] = H - ie, i[2] = G - we, i[5] = H + ie, i[8] = 1 - D - V;
          const pe = mt(-Math.asin(bt(e[2], -1, 1)));
          let Te, Oe;
          return Math.hypot(e[5], e[8]) < 1e-3 ? (Te = 0, Oe = -mt(Math.atan2(e[3], e[4]))) : (Te = mt(e[5] === 0 && e[8] === 0 ? 0 : Math.atan2(e[5], e[8])), Oe = mt(e[1] === 0 && e[0] === 0 ? 0 : Math.atan2(e[1], e[0]))), { roll: Te, pitch: pe + 90, bearing: Oe };
        }, p.bi = function(o, e) {
          return o.roll == e.roll && o.pitch == e.pitch && o.bearing == e.bearing;
        }, p.bj = br, p.bk = Ka, p.bl = ec, p.bm = Gd, p.bn = Qu, p.bo = vt, p.bp = Pt, p.bq = fn, p.br = function(o, e, i, u, c) {
          return vt(u, c, bt((o - e) / (i - e), 0, 1));
        }, p.bs = $t, p.bt = function() {
          return new Float64Array(3);
        }, p.bu = function(o, e, i, u) {
          return o[0] = e[0] + i[0] * u, o[1] = e[1] + i[1] * u, o[2] = e[2] + i[2] * u, o;
        }, p.bv = Ct, p.bw = function(o, e, i) {
          var u = i[0], c = i[1], m = i[2], v = i[3], x = e[0], C = e[1], k = e[2], E = c * k - m * C, D = m * x - u * k, F = u * C - c * x;
          return o[0] = x + v * (E += E) + c * (F += F) - m * (D += D), o[1] = C + v * D + m * E - u * F, o[2] = k + v * F + u * D - c * E, o;
        }, p.bx = function(o, e, i) {
          const u = (c = [o[0], o[1], o[2], e[0], e[1], e[2], i[0], i[1], i[2]])[0] * ((E = c[8]) * (v = c[4]) - (x = c[5]) * (k = c[7])) + c[1] * (-E * (m = c[3]) + x * (C = c[6])) + c[2] * (k * m - v * C);
          var c, m, v, x, C, k, E;
          if (u === 0) return null;
          const D = be([], [e[0], e[1], e[2]], [i[0], i[1], i[2]]), F = be([], [i[0], i[1], i[2]], [o[0], o[1], o[2]]), V = be([], [o[0], o[1], o[2]], [e[0], e[1], e[2]]), G = ue([], D, -o[3]);
          return le(G, G, ue([], F, -e[3])), le(G, G, ue([], V, -i[3])), ue(G, G, 1 / u), G;
        }, p.by = mg, p.bz = function() {
          return new Float64Array(4);
        }, p.c = xn, p.c$ = function(o, e) {
          const i = /* @__PURE__ */ new Map();
          if (o != null) if (o.type === "Feature") i.set(Kd(o, e), o);
          else for (const u of o.features) i.set(Kd(u, e), u);
          return i;
        }, p.c0 = function(o, e, i) {
          var u = e[0], c = e[1], m = e[2];
          return o[0] = u * i[0] + c * i[3] + m * i[6], o[1] = u * i[1] + c * i[4] + m * i[7], o[2] = u * i[2] + c * i[5] + m * i[8], o;
        }, p.c1 = function(o, e, i, u, c, m, v) {
          var x = 1 / (e - i), C = 1 / (u - c), k = 1 / (m - v);
          return o[0] = -2 * x, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = -2 * C, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 2 * k, o[11] = 0, o[12] = (e + i) * x, o[13] = (c + u) * C, o[14] = (v + m) * k, o[15] = 1, o;
        }, p.c2 = class extends lo {
          constructor(o, e) {
            super(o, e), this.current = new Array();
          }
          set(o) {
            if (o != this.current) {
              this.current = o;
              const e = new Float32Array(4 * o.length);
              for (let i = 0; i < o.length; i++) e[4 * i] = o[i].r, e[4 * i + 1] = o[i].g, e[4 * i + 2] = o[i].b, e[4 * i + 3] = o[i].a;
              this.gl.uniform4fv(this.location, e);
            }
          }
        }, p.c3 = class extends lo {
          constructor(o, e) {
            super(o, e), this.current = new Array();
          }
          set(o) {
            if (o != this.current) {
              this.current = o;
              const e = new Float32Array(o);
              this.gl.uniform1fv(this.location, e);
            }
          }
        }, p.c4 = class extends zd {
        }, p.c5 = Mw, p.c6 = class extends Ca {
        }, p.c7 = Ym, p.c8 = function(o) {
          return o <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(o) / Math.LN2));
        }, p.c9 = Rv, p.cA = FC, p.cC = function(o) {
          return o.message === wi;
        }, p.cD = Bi, p.cE = function(o, e) {
          en.REGISTERED_PROTOCOLS[o] = e;
        }, p.cF = function(o) {
          delete en.REGISTERED_PROTOCOLS[o];
        }, p.cG = function(o, e) {
          const i = {};
          for (let c = 0; c < o.length; c++) {
            const m = e && e[o[c].id] || bf(o[c]);
            e && (e[o[c].id] = m);
            let v = i[m];
            v || (v = i[m] = []), v.push(o[c]);
          }
          const u = [];
          for (const c in i) u.push(i[c]);
          return u;
        }, p.cH = Lt, p.cI = Ey, p.cJ = Ky, p.cK = sy, p.cL = function(o) {
          o.bucket.createArrays(), o.bucket.tilePixelRatio = it / (512 * o.bucket.overscaling), o.bucket.compareText = {}, o.bucket.iconsNeedLinear = false;
          const e = o.bucket.layers[0], i = e.layout, u = e._unevaluatedLayout._values, c = { layoutIconSize: u["icon-size"].possiblyEvaluate(new qr(o.bucket.zoom + 1), o.canonical), layoutTextSize: u["text-size"].possiblyEvaluate(new qr(o.bucket.zoom + 1), o.canonical), textMaxSize: u["text-size"].possiblyEvaluate(new qr(18)) };
          if (o.bucket.textSizeData.kind === "composite") {
            const { minZoom: k, maxZoom: E } = o.bucket.textSizeData;
            c.compositeTextSizes = [u["text-size"].possiblyEvaluate(new qr(k), o.canonical), u["text-size"].possiblyEvaluate(new qr(E), o.canonical)];
          }
          if (o.bucket.iconSizeData.kind === "composite") {
            const { minZoom: k, maxZoom: E } = o.bucket.iconSizeData;
            c.compositeIconSizes = [u["icon-size"].possiblyEvaluate(new qr(k), o.canonical), u["icon-size"].possiblyEvaluate(new qr(E), o.canonical)];
          }
          const m = i.get("text-line-height") * qi, v = i.get("text-rotation-alignment") !== "viewport" && i.get("symbol-placement") !== "point", x = i.get("text-keep-upright"), C = i.get("text-size");
          for (const k of o.bucket.features) {
            const E = i.get("text-font").evaluate(k, {}, o.canonical).join(","), D = C.evaluate(k, {}, o.canonical), F = c.layoutTextSize.evaluate(k, {}, o.canonical), V = c.layoutIconSize.evaluate(k, {}, o.canonical), G = { horizontal: {}, vertical: void 0 }, H = k.text;
            let Y, ie = [0, 0];
            if (H) {
              const pe = H.toString(), Te = i.get("text-letter-spacing").evaluate(k, {}, o.canonical) * qi, Oe = Td(pe) ? Te : 0, Xe = i.get("text-anchor").evaluate(k, {}, o.canonical), yt = c_(e, k, o.canonical);
              if (!yt) {
                const Et = i.get("text-radial-offset").evaluate(k, {}, o.canonical);
                ie = Et ? u_(Xe, [Et * qi, Eg]) : i.get("text-offset").evaluate(k, {}, o.canonical).map(((Mt) => Mt * qi));
              }
              let ft = v ? "center" : i.get("text-justify").evaluate(k, {}, o.canonical);
              const wt = i.get("symbol-placement") === "point" ? i.get("text-max-width").evaluate(k, {}, o.canonical) * qi : 1 / 0, Rt = () => {
                o.bucket.allowVerticalPlacement && kd(pe) && (G.vertical = Qf(H, o.glyphMap, o.glyphPositions, o.imagePositions, E, wt, m, Xe, "left", Oe, ie, p.at.vertical, true, F, D));
              };
              if (!v && yt) {
                const Et = /* @__PURE__ */ new Set();
                if (ft === "auto") for (let lt = 0; lt < yt.values.length; lt += 2) Et.add(Mg(yt.values[lt]));
                else Et.add(ft);
                let Mt = false;
                for (const lt of Et) if (!G.horizontal[lt]) if (Mt) G.horizontal[lt] = G.horizontal[0];
                else {
                  const rr = Qf(H, o.glyphMap, o.glyphPositions, o.imagePositions, E, wt, m, "center", lt, Oe, ie, p.at.horizontal, false, F, D);
                  rr && (G.horizontal[lt] = rr, Mt = rr.positionedLines.length === 1);
                }
                Rt();
              } else {
                ft === "auto" && (ft = Mg(Xe));
                const Et = Qf(H, o.glyphMap, o.glyphPositions, o.imagePositions, E, wt, m, Xe, ft, Oe, ie, p.at.horizontal, false, F, D);
                Et && (G.horizontal[ft] = Et), Rt(), kd(pe) && v && x && (G.vertical = Qf(H, o.glyphMap, o.glyphPositions, o.imagePositions, E, wt, m, Xe, ft, Oe, ie, p.at.vertical, false, F, D));
              }
            }
            let we = false;
            if (k.icon && k.icon.name) {
              const pe = o.imageMap[k.icon.name];
              pe && (Y = Jw(o.imagePositions[k.icon.name], i.get("icon-offset").evaluate(k, {}, o.canonical), i.get("icon-anchor").evaluate(k, {}, o.canonical)), we = !!pe.sdf, o.bucket.sdfIcons === void 0 ? o.bucket.sdfIcons = we : o.bucket.sdfIcons !== we && Ht("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (pe.pixelRatio !== o.bucket.pixelRatio || i.get("icon-rotate").constantOr(1) !== 0) && (o.bucket.iconsNeedLinear = true));
            }
            const ce = h_(G.horizontal) || G.vertical;
            o.bucket.iconsInText = !!ce && ce.iconsInText, (ce || Y) && AC(o.bucket, k, G, Y, o.imageMap, c, F, V, ie, we, o.canonical, o.subdivisionGranularity);
          }
          o.showCollisionBoxes && o.bucket.generateCollisionDebugBuffers();
        }, p.cM = tg, p.cN = ig, p.cO = ng, p.cP = Wv, p.cQ = ag, p.cR = tc, p.cS = function(o, e, i, u, c, m) {
          let v = e_(o, e, i, c, 0);
          return v = e_(v, e, u, m, 1), v;
        }, p.cT = class {
          constructor(o) {
            this.maxEntries = o, this.map = /* @__PURE__ */ new Map();
          }
          get(o) {
            const e = this.map.get(o);
            return e !== void 0 && (this.map.delete(o), this.map.set(o, e)), e;
          }
          set(o, e) {
            if (this.map.has(o)) this.map.delete(o);
            else if (this.map.size >= this.maxEntries) {
              const i = this.map.keys().next().value;
              this.map.delete(i);
            }
            this.map.set(o, e);
          }
          clear() {
            this.map.clear();
          }
        }, p.cU = Zv, p.cV = Yy, p.cW = class {
          constructor(o) {
            this._marks = { start: [o.url, "start"].join("#"), end: [o.url, "end"].join("#"), measure: o.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let o = performance.getEntriesByName(this._marks.measure);
            return o.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), o = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), o;
          }
        }, p.cX = function(o, e, i, u, c) {
          return s(this, void 0, void 0, (function* () {
            if (J()) try {
              return yield $e(o, e, i, u, c);
            } catch {
            }
            return (function(m, v, x, C, k) {
              const E = m.width, D = m.height;
              Ye && ht || (Ye = new OffscreenCanvas(E, D), ht = Ye.getContext("2d", { willReadFrequently: true })), Ye.width = E, Ye.height = D, ht.drawImage(m, 0, 0, E, D);
              const F = ht.getImageData(v, x, C, k);
              return ht.clearRect(0, 0, E, D), F.data;
            })(o, e, i, u, c);
          }));
        }, p.cY = Fv, p.cZ = P, p.c_ = Eu, p.ca = function(o, e, i) {
          var u = e[0], c = e[1], m = e[2], v = i[3] * u + i[7] * c + i[11] * m + i[15];
          return o[0] = (i[0] * u + i[4] * c + i[8] * m + i[12]) / (v = v || 1), o[1] = (i[1] * u + i[5] * c + i[9] * m + i[13]) / v, o[2] = (i[2] * u + i[6] * c + i[10] * m + i[14]) / v, o;
        }, p.cb = class extends qu {
        }, p.cc = class extends a {
        }, p.cd = function(o, e) {
          return o[0] === e[0] && o[1] === e[1] && o[2] === e[2] && o[3] === e[3] && o[4] === e[4] && o[5] === e[5] && o[6] === e[6] && o[7] === e[7] && o[8] === e[8] && o[9] === e[9] && o[10] === e[10] && o[11] === e[11] && o[12] === e[12] && o[13] === e[13] && o[14] === e[14] && o[15] === e[15];
        }, p.ce = function(o, e) {
          var i = o[0], u = o[1], c = o[2], m = o[3], v = o[4], x = o[5], C = o[6], k = o[7], E = o[8], D = o[9], F = o[10], V = o[11], G = o[12], H = o[13], Y = o[14], ie = o[15], we = e[0], ce = e[1], pe = e[2], Te = e[3], Oe = e[4], Xe = e[5], yt = e[6], ft = e[7], wt = e[8], Rt = e[9], Et = e[10], Mt = e[11], lt = e[12], rr = e[13], Qt = e[14], tr = e[15];
          return Math.abs(i - we) <= te * Math.max(1, Math.abs(i), Math.abs(we)) && Math.abs(u - ce) <= te * Math.max(1, Math.abs(u), Math.abs(ce)) && Math.abs(c - pe) <= te * Math.max(1, Math.abs(c), Math.abs(pe)) && Math.abs(m - Te) <= te * Math.max(1, Math.abs(m), Math.abs(Te)) && Math.abs(v - Oe) <= te * Math.max(1, Math.abs(v), Math.abs(Oe)) && Math.abs(x - Xe) <= te * Math.max(1, Math.abs(x), Math.abs(Xe)) && Math.abs(C - yt) <= te * Math.max(1, Math.abs(C), Math.abs(yt)) && Math.abs(k - ft) <= te * Math.max(1, Math.abs(k), Math.abs(ft)) && Math.abs(E - wt) <= te * Math.max(1, Math.abs(E), Math.abs(wt)) && Math.abs(D - Rt) <= te * Math.max(1, Math.abs(D), Math.abs(Rt)) && Math.abs(F - Et) <= te * Math.max(1, Math.abs(F), Math.abs(Et)) && Math.abs(V - Mt) <= te * Math.max(1, Math.abs(V), Math.abs(Mt)) && Math.abs(G - lt) <= te * Math.max(1, Math.abs(G), Math.abs(lt)) && Math.abs(H - rr) <= te * Math.max(1, Math.abs(H), Math.abs(rr)) && Math.abs(Y - Qt) <= te * Math.max(1, Math.abs(Y), Math.abs(Qt)) && Math.abs(ie - tr) <= te * Math.max(1, Math.abs(ie), Math.abs(tr));
        }, p.cf = function(o, e) {
          return o[0] = e[0], o[1] = e[1], o[2] = e[2], o[3] = e[3], o[4] = e[4], o[5] = e[5], o[6] = e[6], o[7] = e[7], o[8] = e[8], o[9] = e[9], o[10] = e[10], o[11] = e[11], o[12] = e[12], o[13] = e[13], o[14] = e[14], o[15] = e[15], o;
        }, p.cg = (o) => o.type === "symbol", p.ch = (o) => o.type === "circle", p.ci = (o) => o.type === "heatmap", p.cj = (o) => o.type === "line", p.ck = (o) => o.type === "fill", p.cl = (o) => o.type === "fill-extrusion", p.cm = (o) => o.type === "hillshade", p.cn = (o) => o.type === "color-relief", p.co = (o) => o.type === "background", p.cp = (o) => o.type === "custom", p.cq = Nt, p.cr = function(o, e, i) {
          const u = ct(e.x - i.x, e.y - i.y), c = ct(o.x - i.x, o.y - i.y);
          var m, v;
          return mt(Math.atan2(u[0] * c[1] - u[1] * c[0], (m = u)[0] * (v = c)[0] + m[1] * v[1]));
        }, p.cs = ir, p.ct = function(o, e) {
          return di[e] && (o instanceof MouseEvent || o instanceof WheelEvent);
        }, p.cu = function(o, e) {
          return nr[e] && "touches" in o;
        }, p.cv = function(o) {
          return nr[o] || di[o];
        }, p.cw = function(o, e, i) {
          var u = e[0], c = e[1];
          return o[0] = i[0] * u + i[4] * c + i[12], o[1] = i[1] * u + i[5] * c + i[13], o;
        }, p.cx = function(o, e) {
          const { x: i, y: u } = Yd.fromLngLat(e);
          return !(o < 0 || o > 25 || u < 0 || u >= 1 || i < 0 || i >= 1);
        }, p.cy = function(o, e) {
          return o[0] = e[0], o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = e[1], o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = e[2], o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, o;
        }, p.cz = class extends Gu {
        }, p.d = $, p.d0 = function(o, e) {
          if (o == null) return true;
          if (o.type === "Feature") return Kd(o, e) != null;
          if (o.type === "FeatureCollection") {
            const i = /* @__PURE__ */ new Set();
            for (const u of o.features) {
              const c = Kd(u, e);
              if (c == null || i.has(c)) return false;
              i.add(c);
            }
            return true;
          }
          return false;
        }, p.d1 = function(o, e, i) {
          var u, c, m, v;
          if (e.removeAll && o.clear(), e.remove) for (const x of e.remove) o.delete(x);
          if (e.add) for (const x of e.add) {
            const C = Kd(x, i);
            C != null && o.set(C, x);
          }
          if (e.update) for (const x of e.update) {
            let C = o.get(x.id);
            if (C == null) continue;
            const k = !x.removeAllProperties && (((u = x.removeProperties) === null || u === void 0 ? void 0 : u.length) > 0 || ((c = x.addOrUpdateProperties) === null || c === void 0 ? void 0 : c.length) > 0);
            if ((x.newGeometry || x.removeAllProperties || k) && (C = Object.assign({}, C), o.set(x.id, C), k && (C.properties = Object.assign({}, C.properties))), x.newGeometry && (C.geometry = x.newGeometry), x.removeAllProperties) C.properties = {};
            else if (((m = x.removeProperties) === null || m === void 0 ? void 0 : m.length) > 0) for (const E of x.removeProperties) Object.prototype.hasOwnProperty.call(C.properties, E) && delete C.properties[E];
            if (((v = x.addOrUpdateProperties) === null || v === void 0 ? void 0 : v.length) > 0) for (const { key: E, value: D } of x.addOrUpdateProperties) C.properties[E] = D;
          }
        }, p.d2 = Ko, p.e = Zt, p.f = (o) => s(void 0, void 0, void 0, (function* () {
          if (o.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const e = new Blob([new Uint8Array(o)], { type: "image/png" });
          try {
            return createImageBitmap(e);
          } catch (i) {
            throw new Error(`Could not load image because of ${i.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
          }
        })), p.g = wn, p.h = (o) => new Promise(((e, i) => {
          const u = new Image();
          u.onload = () => {
            e(u), URL.revokeObjectURL(u.src), u.onload = null, window.requestAnimationFrame((() => {
              u.src = ot;
            }));
          }, u.onerror = () => i(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const c = new Blob([new Uint8Array(o)], { type: "image/png" });
          u.src = o.byteLength ? URL.createObjectURL(c) : ot;
        })), p.i = xr, p.j = (o, e) => Me(Zt(o, { type: "json" }), e), p.k = _e, p.l = ge, p.m = Me, p.n = (o, e) => Me(Zt(o, { type: "arrayBuffer" }), e), p.o = function(o) {
          return new ag(o).readFields(jw, []);
        }, p.p = ay, p.q = function(o) {
          return /[\u1100-\u11FF\u3000-\u30FF\u3131-\u318E\u31F0-\u321E\u3260-\u327E\u32D0-\u32FE\u3300-\u3357\u3400-\u4DBF\u4E00-\u9FFF\uA960-\uA97C\uAC00-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFF00-\uFFEF]|\uD81B[\uDFE4\uDFF2-\uDFF6]|[\uD81C-\uD822\uD840-\uD868\uD86A-\uD86D\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD88C][\uDC00-\uDFFF]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD1E\uDD80-\uDDF2]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD83C\uDE00|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEAD\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD88D[\uDC00-\uDC79]/gim.test(String.fromCodePoint(o));
        }, p.r = $d, p.s = St, p.t = En, p.u = se, p.v = vl, p.w = Ht, p.x = Id, p.y = Bm, p.z = Ou;
      })), f("worker", ["./shared"], (function(p) {
        class s {
          constructor($, Z) {
            this.keyCache = {}, $ && this.replace($, Z);
          }
          replace($, Z) {
            this._layerConfigs = {}, this._layers = {}, this.update($, [], Z);
          }
          update($, Z, Q) {
            for (const _e of $) {
              this._layerConfigs[_e.id] = _e;
              const Re = this._layers[_e.id] = p.bN(_e, Q);
              Re._featureFilter = p.ae(Re.filter, Q), this.keyCache[_e.id] && delete this.keyCache[_e.id];
            }
            for (const _e of Z) delete this.keyCache[_e], delete this._layerConfigs[_e], delete this._layers[_e];
            this.familiesBySource = {};
            const ge = p.cG(Object.values(this._layerConfigs), this.keyCache);
            for (const _e of ge) {
              const Re = _e.map(((At) => this._layers[At.id])), se = Re[0];
              if (se.visibility === "none") continue;
              const Fe = se.source || "";
              let We = this.familiesBySource[Fe];
              We || (We = this.familiesBySource[Fe] = {});
              const Qe = se.sourceLayer || "_geojsonTileLayer";
              let tt = We[Qe];
              tt || (tt = We[Qe] = []), tt.push(Re);
            }
          }
        }
        class S {
          constructor($) {
            const Z = {}, Q = [];
            for (const se in $) {
              const Fe = $[se], We = Z[se] = {};
              for (const Qe in Fe) {
                const tt = Fe[+Qe];
                if (!tt || tt.bitmap.width === 0 || tt.bitmap.height === 0) continue;
                const At = { x: 0, y: 0, w: tt.bitmap.width + 2, h: tt.bitmap.height + 2 };
                Q.push(At), We[Qe] = { rect: At, metrics: tt.metrics };
              }
            }
            const { w: ge, h: _e } = p.p(Q), Re = new p.r({ width: ge || 1, height: _e || 1 });
            for (const se in $) {
              const Fe = $[se];
              for (const We in Fe) {
                const Qe = Fe[+We];
                if (!Qe || Qe.bitmap.width === 0 || Qe.bitmap.height === 0) continue;
                const tt = Z[se][We].rect;
                p.r.copy(Qe.bitmap, Re, { x: 0, y: 0 }, { x: tt.x + 1, y: tt.y + 1 }, Qe.bitmap);
              }
            }
            this.image = Re, this.positions = Z;
          }
        }
        p.cH("GlyphAtlas", S);
        class P {
          constructor($) {
            this.tileID = new p.a0($.tileID.overscaledZ, $.tileID.wrap, $.tileID.canonical.z, $.tileID.canonical.x, $.tileID.canonical.y), this.uid = $.uid, this.zoom = $.zoom, this.pixelRatio = $.pixelRatio, this.tileSize = $.tileSize, this.source = $.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = $.showCollisionBoxes, this.collectResourceTiming = !!$.collectResourceTiming, this.returnDependencies = !!$.returnDependencies, this.promoteId = $.promoteId, this.inFlightDependencies = [];
          }
          parse($, Z, Q, ge, _e) {
            return p._(this, void 0, void 0, (function* () {
              this.status = "parsing", this.data = $, this.collisionBoxArray = new p.ac();
              const Re = new p.cI(Object.keys($.layers).sort()), se = new p.cJ(this.tileID, this.promoteId);
              se.bucketLayerIDs = [];
              const Fe = {}, We = { featureIndex: se, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, dashDependencies: {}, availableImages: Q, subdivisionGranularity: _e }, Qe = Z.familiesBySource[this.source];
              for (const Bt in Qe) {
                const Xt = $.layers[Bt];
                if (!Xt) continue;
                Xt.version === 1 && p.w(`Vector tile source "${this.source}" layer "${Bt}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const hi = Re.encode(Bt), Sn = [];
                for (let Jr = 0; Jr < Xt.length; Jr++) {
                  const ar = Xt.feature(Jr), Wn = se.getId(ar, Bt);
                  Sn.push({ feature: ar, id: Wn, index: Jr, sourceLayerIndex: hi });
                }
                for (const Jr of Qe[Bt]) {
                  const ar = Jr[0];
                  ar.source !== this.source && p.w(`layer.source = ${ar.source} does not equal this.source = ${this.source}`), ar.isHidden(this.zoom, true) || (M(Jr, this.zoom, Q), (Fe[ar.id] = ar.createBucket({ index: se.bucketLayerIDs.length, layers: Jr, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: hi, sourceID: this.source })).populate(Sn, We, this.tileID.canonical), se.bucketLayerIDs.push(Jr.map(((Wn) => Wn.id))));
                }
              }
              const tt = p.bS(We.glyphDependencies, ((Bt) => Object.keys(Bt).map(Number)));
              this.inFlightDependencies.forEach(((Bt) => Bt == null ? void 0 : Bt.abort())), this.inFlightDependencies = [];
              let At = Promise.resolve({});
              if (Object.keys(tt).length) {
                const Bt = new AbortController();
                this.inFlightDependencies.push(Bt), At = ge.sendAsync({ type: "GG", data: { stacks: tt, source: this.source, tileID: this.tileID, type: "glyphs" } }, Bt);
              }
              const qt = Object.keys(We.iconDependencies);
              let sr = Promise.resolve({});
              if (qt.length) {
                const Bt = new AbortController();
                this.inFlightDependencies.push(Bt), sr = ge.sendAsync({ type: "GI", data: { icons: qt, source: this.source, tileID: this.tileID, type: "icons" } }, Bt);
              }
              const Ur = Object.keys(We.patternDependencies);
              let mr = Promise.resolve({});
              if (Ur.length) {
                const Bt = new AbortController();
                this.inFlightDependencies.push(Bt), mr = ge.sendAsync({ type: "GI", data: { icons: Ur, source: this.source, tileID: this.tileID, type: "patterns" } }, Bt);
              }
              const Sr = We.dashDependencies;
              let Dr = Promise.resolve({});
              if (Object.keys(Sr).length) {
                const Bt = new AbortController();
                this.inFlightDependencies.push(Bt), Dr = ge.sendAsync({ type: "GDA", data: { dashes: Sr } }, Bt);
              }
              const [ye, at, Ft, hr] = yield Promise.all([At, sr, mr, Dr]), ur = new S(ye), st = new p.cK(at, Ft);
              for (const Bt in Fe) {
                const Xt = Fe[Bt];
                Xt instanceof p.ad ? (M(Xt.layers, this.zoom, Q), p.cL({ bucket: Xt, glyphMap: ye, glyphPositions: ur.positions, imageMap: at, imagePositions: st.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: We.subdivisionGranularity })) : Xt.hasDependencies && (Xt instanceof p.cM || Xt instanceof p.cN || Xt instanceof p.cO) && (M(Xt.layers, this.zoom, Q), Xt.addFeatures(We, this.tileID.canonical, st.patternPositions, hr));
              }
              return this.status = "done", { buckets: Object.values(Fe).filter(((Bt) => !Bt.isEmpty())), featureIndex: se, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: ur.image, imageAtlas: st, dashPositions: hr, glyphMap: this.returnDependencies ? ye : null, iconMap: this.returnDependencies ? at : null, glyphPositions: this.returnDependencies ? ur.positions : null };
            }));
          }
        }
        function M(Me, $, Z) {
          const Q = new p.G($);
          for (const ge of Me) ge.recalculate(Q, Z);
        }
        class A extends p.cR {
          constructor($, Z) {
            super(new p.cQ(), 0, Z, [], []), this.feature = $, this.type = $.type, this.properties = $.tags ? $.tags : {}, "id" in $ && (typeof $.id == "string" ? this.id = parseInt($.id, 10) : typeof $.id != "number" || isNaN($.id) || (this.id = $.id));
          }
          loadGeometry() {
            const $ = [], Z = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const Q of Z) {
              const ge = [];
              for (const _e of Q) ge.push(new p.P(_e[0], _e[1]));
              $.push(ge);
            }
            return $;
          }
        }
        class O extends p.cP {
          constructor($, Z) {
            super(new p.cQ()), this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.version = Z ? Z.version : 1, this.extent = Z ? Z.extent : 4096, this.length = $.length, this.features = $;
          }
          feature($) {
            return new A(this.features[$], this.extent);
          }
        }
        function j(Me, $) {
          $.writeVarintField(15, Me.version || 1), $.writeStringField(1, Me.name || ""), $.writeVarintField(5, Me.extent || 4096);
          const Z = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (let _e = 0; _e < Me.length; _e++) Z.feature = Me.feature(_e), $.writeMessage(2, L, Z);
          const Q = Z.keys;
          for (const _e of Q) $.writeStringField(3, _e);
          const ge = Z.values;
          for (const _e of ge) $.writeMessage(4, ne, _e);
        }
        function L(Me, $) {
          if (!Me.feature) return;
          const Z = Me.feature;
          Z.id !== void 0 && $.writeVarintField(1, Z.id), $.writeMessage(2, q, Me), $.writeVarintField(3, Z.type), $.writeMessage(4, te, Z);
        }
        function q(Me, $) {
          var _a2;
          for (const Z in (_a2 = Me.feature) == null ? void 0 : _a2.properties) {
            let Q = Me.feature.properties[Z], ge = Me.keycache[Z];
            if (Q === null) continue;
            ge === void 0 && (Me.keys.push(Z), ge = Me.keys.length - 1, Me.keycache[Z] = ge), $.writeVarint(ge), typeof Q != "string" && typeof Q != "boolean" && typeof Q != "number" && (Q = JSON.stringify(Q));
            const _e = typeof Q + ":" + Q;
            let Re = Me.valuecache[_e];
            Re === void 0 && (Me.values.push(Q), Re = Me.values.length - 1, Me.valuecache[_e] = Re), $.writeVarint(Re);
          }
        }
        function N(Me, $) {
          return ($ << 3) + (7 & Me);
        }
        function J(Me) {
          return Me << 1 ^ Me >> 31;
        }
        function te(Me, $) {
          const Z = Me.loadGeometry(), Q = Me.type;
          let ge = 0, _e = 0;
          for (const Re of Z) {
            let se = 1;
            Q === 1 && (se = Re.length), $.writeVarint(N(1, se));
            const Fe = Q === 3 ? Re.length - 1 : Re.length;
            for (let We = 0; We < Fe; We++) {
              We === 1 && Q !== 1 && $.writeVarint(N(2, Fe - 1));
              const Qe = Re[We].x - ge, tt = Re[We].y - _e;
              $.writeVarint(J(Qe)), $.writeVarint(J(tt)), ge += Qe, _e += tt;
            }
            Me.type === 3 && $.writeVarint(N(7, 1));
          }
        }
        function ne(Me, $) {
          const Z = typeof Me;
          Z === "string" ? $.writeStringField(1, Me) : Z === "boolean" ? $.writeBooleanField(7, Me) : Z === "number" && (Me % 1 != 0 ? $.writeDoubleField(3, Me) : Me < 0 ? $.writeSVarintField(6, Me) : $.writeVarintField(5, Me));
        }
        class ae extends p.cR {
          constructor($, Z, Q, ge, _e) {
            super(new p.cQ(), 0, _e, [], []), this.type = $, this.properties = Q || {}, this.extent = _e, this.pointsArray = Z, this.id = ge;
          }
          loadGeometry() {
            return this.pointsArray.map((($) => $.map(((Z) => new p.P(Z.x, Z.y)))));
          }
        }
        class oe extends p.cP {
          constructor($, Z, Q) {
            super(new p.cQ()), this.version = 2, this._myFeatures = $, this.name = Z, this.length = $.length, this.extent = Q;
          }
          feature($) {
            return this._myFeatures[$];
          }
        }
        class ee {
          constructor() {
            this.layers = {};
          }
          addLayer($) {
            this.layers[$.name] = $;
          }
        }
        function ke(Me) {
          let $ = (function(Z) {
            const Q = new p.cQ();
            return (function(ge, _e) {
              for (const Re in ge.layers) _e.writeMessage(3, j, ge.layers[Re]);
            })(Z, Q), Q.finish();
          })(Me);
          return $.byteOffset === 0 && $.byteLength === $.buffer.byteLength || ($ = new Uint8Array($)), { vectorTile: Me, rawData: $.buffer };
        }
        function ve(Me, $, Z) {
          const { extent: Q } = Me, ge = Math.pow(2, Z.z - $.z), _e = (Z.x - $.x * ge) * Q, Re = (Z.y - $.y * ge) * Q, se = [];
          for (let Fe = 0; Fe < Me.length; Fe++) {
            const We = Me.feature(Fe);
            let Qe = We.loadGeometry();
            for (const At of Qe) for (const qt of At) qt.x = qt.x * ge - _e, qt.y = qt.y * ge - Re;
            const tt = 128;
            Qe = p.cS(Qe, We.type, -tt, -tt, Q + tt, Q + tt), Qe.length !== 0 && se.push(new ae(We.type, Qe, We.properties, We.id, Q));
          }
          return new oe(se, Me.name, Q);
        }
        class le {
          constructor($, Z, Q) {
            this.actor = $, this.layerIndex = Z, this.availableImages = Q, this.fetching = {}, this.loading = {}, this.loaded = {}, this.overzoomedTileResultCache = new p.cT(1e3);
          }
          loadVectorTile($, Z) {
            return p._(this, void 0, void 0, (function* () {
              const Q = yield p.n($.request, Z);
              try {
                return { vectorTile: $.encoding !== "mlt" ? new p.cU(new p.cQ(Q.data)) : new p.cV(Q.data), rawData: Q.data, cacheControl: Q.cacheControl, expires: Q.expires };
              } catch (ge) {
                const _e = new Uint8Array(Q.data);
                let Re = `Unable to parse the tile at ${$.request.url}, `;
                throw Re += _e[0] === 31 && _e[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${ge.message}`, new Error(Re);
              }
            }));
          }
          loadTile($) {
            return p._(this, void 0, void 0, (function* () {
              const { uid: Z, overzoomParameters: Q } = $;
              Q && ($.request = Q.overzoomRequest);
              const ge = !!($ && $.request && $.request.collectResourceTiming) && new p.cW($.request), _e = new P($);
              this.loading[Z] = _e;
              const Re = new AbortController();
              _e.abort = Re;
              try {
                const se = yield this.loadVectorTile($, Re);
                if (delete this.loading[Z], !se) return null;
                if (Q) {
                  const At = this._getOverzoomTile($, se.vectorTile);
                  se.rawData = At.rawData, se.vectorTile = At.vectorTile;
                }
                const Fe = se.rawData, We = {};
                se.expires && (We.expires = se.expires), se.cacheControl && (We.cacheControl = se.cacheControl);
                const Qe = {};
                if (ge) {
                  const At = ge.finish();
                  At && (Qe.resourceTiming = JSON.parse(JSON.stringify(At)));
                }
                _e.vectorTile = se.vectorTile;
                const tt = _e.parse(se.vectorTile, this.layerIndex, this.availableImages, this.actor, $.subdivisionGranularity);
                this.loaded[Z] = _e, this.fetching[Z] = { rawTileData: Fe, cacheControl: We, resourceTiming: Qe };
                try {
                  const At = yield tt;
                  return p.e({ rawTileData: Fe.slice(0), encoding: $.encoding }, At, We, Qe);
                } finally {
                  delete this.fetching[Z];
                }
              } catch (se) {
                throw delete this.loading[Z], _e.status = "done", this.loaded[Z] = _e, se;
              }
            }));
          }
          _getOverzoomTile($, Z) {
            const { tileID: Q, source: ge, overzoomParameters: _e } = $, { maxZoomTileID: Re } = _e, se = `${Re.key}_${Q.key}`, Fe = this.overzoomedTileResultCache.get(se);
            if (Fe) return Fe;
            const We = new ee(), Qe = this.layerIndex.familiesBySource[ge];
            for (const At in Qe) {
              const qt = Z.layers[At];
              if (!qt) continue;
              const sr = ve(qt, Re, Q.canonical);
              sr.length > 0 && We.addLayer(sr);
            }
            const tt = ke(We);
            return this.overzoomedTileResultCache.set(se, tt), tt;
          }
          reloadTile($) {
            return p._(this, void 0, void 0, (function* () {
              const Z = $.uid;
              if (!this.loaded || !this.loaded[Z]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const Q = this.loaded[Z];
              if (Q.showCollisionBoxes = $.showCollisionBoxes, Q.status === "parsing") {
                const ge = yield Q.parse(Q.vectorTile, this.layerIndex, this.availableImages, this.actor, $.subdivisionGranularity);
                let _e;
                if (this.fetching[Z]) {
                  const { rawTileData: Re, cacheControl: se, resourceTiming: Fe } = this.fetching[Z];
                  delete this.fetching[Z], _e = p.e({ rawTileData: Re.slice(0), encoding: $.encoding }, ge, se, Fe);
                } else _e = ge;
                return _e;
              }
              if (Q.status === "done" && Q.vectorTile) return Q.parse(Q.vectorTile, this.layerIndex, this.availableImages, this.actor, $.subdivisionGranularity);
            }));
          }
          abortTile($) {
            return p._(this, void 0, void 0, (function* () {
              const Z = this.loading, Q = $.uid;
              Z && Z[Q] && Z[Q].abort && (Z[Q].abort.abort(), delete Z[Q]);
            }));
          }
          removeTile($) {
            return p._(this, void 0, void 0, (function* () {
              this.loaded && this.loaded[$.uid] && delete this.loaded[$.uid];
            }));
          }
        }
        class ue {
          constructor() {
            this.loaded = {};
          }
          loadTile($) {
            return p._(this, void 0, void 0, (function* () {
              const { uid: Z, encoding: Q, rawImageData: ge, redFactor: _e, greenFactor: Re, blueFactor: se, baseShift: Fe } = $, We = ge.width + 2, Qe = ge.height + 2, tt = p.b(ge) ? new p.R({ width: We, height: Qe }, yield p.cX(ge, -1, -1, We, Qe)) : ge, At = new p.cY(Z, tt, Q, _e, Re, se, Fe);
              return this.loaded = this.loaded || {}, this.loaded[Z] = At, At;
            }));
          }
          removeTile($) {
            const Z = this.loaded, Q = $.uid;
            Z && Z[Q] && delete Z[Q];
          }
        }
        var be, Ve, Ge = (function() {
          if (Ve) return be;
          function Me(Z, Q) {
            if (Z.length !== 0) {
              $(Z[0], Q);
              for (var ge = 1; ge < Z.length; ge++) $(Z[ge], !Q);
            }
          }
          function $(Z, Q) {
            for (var ge = 0, _e = 0, Re = 0, se = Z.length, Fe = se - 1; Re < se; Fe = Re++) {
              var We = (Z[Re][0] - Z[Fe][0]) * (Z[Fe][1] + Z[Re][1]), Qe = ge + We;
              _e += Math.abs(ge) >= Math.abs(We) ? ge - Qe + We : We - Qe + ge, ge = Qe;
            }
            ge + _e >= 0 != !!Q && Z.reverse();
          }
          return Ve = 1, be = function Z(Q, ge) {
            var _e, Re = Q && Q.type;
            if (Re === "FeatureCollection") for (_e = 0; _e < Q.features.length; _e++) Z(Q.features[_e], ge);
            else if (Re === "GeometryCollection") for (_e = 0; _e < Q.geometries.length; _e++) Z(Q.geometries[_e], ge);
            else if (Re === "Feature") Z(Q.geometry, ge);
            else if (Re === "Polygon") Me(Q.coordinates, ge);
            else if (Re === "MultiPolygon") for (_e = 0; _e < Q.coordinates.length; _e++) Me(Q.coordinates[_e], ge);
            return Q;
          };
        })(), et = p.cZ(Ge);
        const dt = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (Me) => Me }, Ct = Math.fround || (kt = new Float32Array(1), (Me) => (kt[0] = +Me, kt[0]));
        var kt;
        class ct {
          constructor($) {
            this.options = Object.assign(Object.create(dt), $), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load($) {
            const { log: Z, minZoom: Q, maxZoom: ge } = this.options;
            Z && console.time("total time");
            const _e = `prepare ${$.length} points`;
            Z && console.time(_e), this.points = $;
            const Re = [];
            for (let Fe = 0; Fe < $.length; Fe++) {
              const We = $[Fe];
              if (!We.geometry) continue;
              const [Qe, tt] = We.geometry.coordinates, At = Ct($t(Qe)), qt = Ct(vt(tt));
              Re.push(At, qt, 1 / 0, Fe, -1, 1), this.options.reduce && Re.push(0);
            }
            let se = this.trees[ge + 1] = this._createTree(Re);
            Z && console.timeEnd(_e);
            for (let Fe = ge; Fe >= Q; Fe--) {
              const We = +Date.now();
              se = this.trees[Fe] = this._createTree(this._cluster(se, Fe)), Z && console.log("z%d: %d clusters in %dms", Fe, se.numItems, +Date.now() - We);
            }
            return Z && console.timeEnd("total time"), this;
          }
          getClusters($, Z) {
            let Q = (($[0] + 180) % 360 + 360) % 360 - 180;
            const ge = Math.max(-90, Math.min(90, $[1]));
            let _e = $[2] === 180 ? 180 : (($[2] + 180) % 360 + 360) % 360 - 180;
            const Re = Math.max(-90, Math.min(90, $[3]));
            if ($[2] - $[0] >= 360) Q = -180, _e = 180;
            else if (Q > _e) {
              const tt = this.getClusters([Q, ge, 180, Re], Z), At = this.getClusters([-180, ge, _e, Re], Z);
              return tt.concat(At);
            }
            const se = this.trees[this._limitZoom(Z)], Fe = se.range($t(Q), vt(Re), $t(_e), vt(ge)), We = se.data, Qe = [];
            for (const tt of Fe) {
              const At = this.stride * tt;
              Qe.push(We[At + 5] > 1 ? it(We, At, this.clusterProps) : this.points[We[At + 3]]);
            }
            return Qe;
          }
          getChildren($) {
            const Z = this._getOriginId($), Q = this._getOriginZoom($), ge = "No cluster with the specified id.", _e = this.trees[Q];
            if (!_e) throw new Error(ge);
            const Re = _e.data;
            if (Z * this.stride >= Re.length) throw new Error(ge);
            const se = this.options.radius / (this.options.extent * Math.pow(2, Q - 1)), Fe = _e.within(Re[Z * this.stride], Re[Z * this.stride + 1], se), We = [];
            for (const Qe of Fe) {
              const tt = Qe * this.stride;
              Re[tt + 4] === $ && We.push(Re[tt + 5] > 1 ? it(Re, tt, this.clusterProps) : this.points[Re[tt + 3]]);
            }
            if (We.length === 0) throw new Error(ge);
            return We;
          }
          getLeaves($, Z, Q) {
            const ge = [];
            return this._appendLeaves(ge, $, Z = Z || 10, Q = Q || 0, 0), ge;
          }
          getTile($, Z, Q) {
            const ge = this.trees[this._limitZoom($)], _e = Math.pow(2, $), { extent: Re, radius: se } = this.options, Fe = se / Re, We = (Q - Fe) / _e, Qe = (Q + 1 + Fe) / _e, tt = { features: [] };
            return this._addTileFeatures(ge.range((Z - Fe) / _e, We, (Z + 1 + Fe) / _e, Qe), ge.data, Z, Q, _e, tt), Z === 0 && this._addTileFeatures(ge.range(1 - Fe / _e, We, 1, Qe), ge.data, _e, Q, _e, tt), Z === _e - 1 && this._addTileFeatures(ge.range(0, We, Fe / _e, Qe), ge.data, -1, Q, _e, tt), tt.features.length ? tt : null;
          }
          getClusterExpansionZoom($) {
            let Z = this._getOriginZoom($) - 1;
            for (; Z <= this.options.maxZoom; ) {
              const Q = this.getChildren($);
              if (Z++, Q.length !== 1) break;
              $ = Q[0].properties.cluster_id;
            }
            return Z;
          }
          _appendLeaves($, Z, Q, ge, _e) {
            const Re = this.getChildren(Z);
            for (const se of Re) {
              const Fe = se.properties;
              if (Fe && Fe.cluster ? _e + Fe.point_count <= ge ? _e += Fe.point_count : _e = this._appendLeaves($, Fe.cluster_id, Q, ge, _e) : _e < ge ? _e++ : $.push(se), $.length === Q) break;
            }
            return _e;
          }
          _createTree($) {
            const Z = new p.aN($.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let Q = 0; Q < $.length; Q += this.stride) Z.add($[Q], $[Q + 1]);
            return Z.finish(), Z.data = $, Z;
          }
          _addTileFeatures($, Z, Q, ge, _e, Re) {
            for (const se of $) {
              const Fe = se * this.stride, We = Z[Fe + 5] > 1;
              let Qe, tt, At;
              if (We) Qe = pt(Z, Fe, this.clusterProps), tt = Z[Fe], At = Z[Fe + 1];
              else {
                const Ur = this.points[Z[Fe + 3]];
                Qe = Ur.properties;
                const [mr, Sr] = Ur.geometry.coordinates;
                tt = $t(mr), At = vt(Sr);
              }
              const qt = { type: 1, geometry: [[Math.round(this.options.extent * (tt * _e - Q)), Math.round(this.options.extent * (At * _e - ge))]], tags: Qe };
              let sr;
              sr = We || this.options.generateId ? Z[Fe + 3] : this.points[Z[Fe + 3]].id, sr !== void 0 && (qt.id = sr), Re.features.push(qt);
            }
          }
          _limitZoom($) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+$), this.options.maxZoom + 1));
          }
          _cluster($, Z) {
            const { radius: Q, extent: ge, reduce: _e, minPoints: Re } = this.options, se = Q / (ge * Math.pow(2, Z)), Fe = $.data, We = [], Qe = this.stride;
            for (let tt = 0; tt < Fe.length; tt += Qe) {
              if (Fe[tt + 2] <= Z) continue;
              Fe[tt + 2] = Z;
              const At = Fe[tt], qt = Fe[tt + 1], sr = $.within(Fe[tt], Fe[tt + 1], se), Ur = Fe[tt + 5];
              let mr = Ur;
              for (const Sr of sr) {
                const Dr = Sr * Qe;
                Fe[Dr + 2] > Z && (mr += Fe[Dr + 5]);
              }
              if (mr > Ur && mr >= Re) {
                let Sr, Dr = At * Ur, ye = qt * Ur, at = -1;
                const Ft = (tt / Qe << 5) + (Z + 1) + this.points.length;
                for (const hr of sr) {
                  const ur = hr * Qe;
                  if (Fe[ur + 2] <= Z) continue;
                  Fe[ur + 2] = Z;
                  const st = Fe[ur + 5];
                  Dr += Fe[ur] * st, ye += Fe[ur + 1] * st, Fe[ur + 4] = Ft, _e && (Sr || (Sr = this._map(Fe, tt, true), at = this.clusterProps.length, this.clusterProps.push(Sr)), _e(Sr, this._map(Fe, ur)));
                }
                Fe[tt + 4] = Ft, We.push(Dr / mr, ye / mr, 1 / 0, Ft, -1, mr), _e && We.push(at);
              } else {
                for (let Sr = 0; Sr < Qe; Sr++) We.push(Fe[tt + Sr]);
                if (mr > 1) for (const Sr of sr) {
                  const Dr = Sr * Qe;
                  if (!(Fe[Dr + 2] <= Z)) {
                    Fe[Dr + 2] = Z;
                    for (let ye = 0; ye < Qe; ye++) We.push(Fe[Dr + ye]);
                  }
                }
              }
            }
            return We;
          }
          _getOriginId($) {
            return $ - this.points.length >> 5;
          }
          _getOriginZoom($) {
            return ($ - this.points.length) % 32;
          }
          _map($, Z, Q) {
            if ($[Z + 5] > 1) {
              const Re = this.clusterProps[$[Z + 6]];
              return Q ? Object.assign({}, Re) : Re;
            }
            const ge = this.points[$[Z + 3]].properties, _e = this.options.map(ge);
            return Q && _e === ge ? Object.assign({}, _e) : _e;
          }
        }
        function it(Me, $, Z) {
          return { type: "Feature", id: Me[$ + 3], properties: pt(Me, $, Z), geometry: { type: "Point", coordinates: [(Q = Me[$], 360 * (Q - 0.5)), Pt(Me[$ + 1])] } };
          var Q;
        }
        function pt(Me, $, Z) {
          const Q = Me[$ + 5], ge = Q >= 1e4 ? `${Math.round(Q / 1e3)}k` : Q >= 1e3 ? Math.round(Q / 100) / 10 + "k" : Q, _e = Me[$ + 6], Re = _e === -1 ? {} : Object.assign({}, Z[_e]);
          return Object.assign(Re, { cluster: true, cluster_id: Me[$ + 3], point_count: Q, point_count_abbreviated: ge });
        }
        function $t(Me) {
          return Me / 360 + 0.5;
        }
        function vt(Me) {
          const $ = Math.sin(Me * Math.PI / 180), Z = 0.5 - 0.25 * Math.log((1 + $) / (1 - $)) / Math.PI;
          return Z < 0 ? 0 : Z > 1 ? 1 : Z;
        }
        function Pt(Me) {
          const $ = (180 - 360 * Me) * Math.PI / 180;
          return 360 * Math.atan(Math.exp($)) / Math.PI - 90;
        }
        function Nt(Me, $, Z, Q) {
          let ge = Q;
          const _e = $ + (Z - $ >> 1);
          let Re, se = Z - $;
          const Fe = Me[$], We = Me[$ + 1], Qe = Me[Z], tt = Me[Z + 1];
          for (let At = $ + 3; At < Z; At += 3) {
            const qt = ir(Me[At], Me[At + 1], Fe, We, Qe, tt);
            if (qt > ge) Re = At, ge = qt;
            else if (qt === ge) {
              const sr = Math.abs(At - _e);
              sr < se && (Re = At, se = sr);
            }
          }
          ge > Q && (Re - $ > 3 && Nt(Me, $, Re, Q), Me[Re + 2] = ge, Z - Re > 3 && Nt(Me, Re, Z, Q));
        }
        function ir(Me, $, Z, Q, ge, _e) {
          let Re = ge - Z, se = _e - Q;
          if (Re !== 0 || se !== 0) {
            const Fe = ((Me - Z) * Re + ($ - Q) * se) / (Re * Re + se * se);
            Fe > 1 ? (Z = ge, Q = _e) : Fe > 0 && (Z += Re * Fe, Q += se * Fe);
          }
          return Re = Me - Z, se = $ - Q, Re * Re + se * se;
        }
        function bt(Me, $, Z, Q) {
          const ge = { id: Me ?? null, type: $, geometry: Z, tags: Q, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if ($ === "Point" || $ === "MultiPoint" || $ === "LineString") Dt(ge, Z);
          else if ($ === "Polygon") Dt(ge, Z[0]);
          else if ($ === "MultiLineString") for (const _e of Z) Dt(ge, _e);
          else if ($ === "MultiPolygon") for (const _e of Z) Dt(ge, _e[0]);
          return ge;
        }
        function Dt(Me, $) {
          for (let Z = 0; Z < $.length; Z += 3) Me.minX = Math.min(Me.minX, $[Z]), Me.minY = Math.min(Me.minY, $[Z + 1]), Me.maxX = Math.max(Me.maxX, $[Z]), Me.maxY = Math.max(Me.maxY, $[Z + 1]);
        }
        function Zt(Me, $, Z, Q) {
          if (!$.geometry) return;
          const ge = $.geometry.coordinates;
          if (ge && ge.length === 0) return;
          const _e = $.geometry.type, Re = Math.pow(Z.tolerance / ((1 << Z.maxZoom) * Z.extent), 2);
          let se = [], Fe = $.id;
          if (Z.promoteId ? Fe = $.properties[Z.promoteId] : Z.generateId && (Fe = Q || 0), _e === "Point") dr(ge, se);
          else if (_e === "MultiPoint") for (const We of ge) dr(We, se);
          else if (_e === "LineString") yr(ge, se, Re, false);
          else if (_e === "MultiLineString") {
            if (Z.lineMetrics) {
              for (const We of ge) se = [], yr(We, se, Re, false), Me.push(bt(Fe, "LineString", se, $.properties));
              return;
            }
            Pr(ge, se, Re, false);
          } else if (_e === "Polygon") Pr(ge, se, Re, true);
          else {
            if (_e !== "MultiPolygon") {
              if (_e === "GeometryCollection") {
                for (const We of $.geometry.geometries) Zt(Me, { id: Fe, geometry: We, properties: $.properties }, Z, Q);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const We of ge) {
              const Qe = [];
              Pr(We, Qe, Re, true), se.push(Qe);
            }
          }
          Me.push(bt(Fe, _e, se, $.properties));
        }
        function dr(Me, $) {
          $.push(lr(Me[0]), Ir(Me[1]), 0);
        }
        function yr(Me, $, Z, Q) {
          let ge, _e, Re = 0;
          for (let Fe = 0; Fe < Me.length; Fe++) {
            const We = lr(Me[Fe][0]), Qe = Ir(Me[Fe][1]);
            $.push(We, Qe, 0), Fe > 0 && (Re += Q ? (ge * Qe - We * _e) / 2 : Math.sqrt(Math.pow(We - ge, 2) + Math.pow(Qe - _e, 2))), ge = We, _e = Qe;
          }
          const se = $.length - 3;
          $[2] = 1, Nt($, 0, se, Z), $[se + 2] = 1, $.size = Math.abs(Re), $.start = 0, $.end = $.size;
        }
        function Pr(Me, $, Z, Q) {
          for (let ge = 0; ge < Me.length; ge++) {
            const _e = [];
            yr(Me[ge], _e, Z, Q), $.push(_e);
          }
        }
        function lr(Me) {
          return Me / 360 + 0.5;
        }
        function Ir(Me) {
          const $ = Math.sin(Me * Math.PI / 180), Z = 0.5 - 0.25 * Math.log((1 + $) / (1 - $)) / Math.PI;
          return Z < 0 ? 0 : Z > 1 ? 1 : Z;
        }
        function Ht(Me, $, Z, Q, ge, _e, Re, se) {
          if (Q /= $, _e >= (Z /= $) && Re < Q) return Me;
          if (Re < Z || _e >= Q) return null;
          const Fe = [];
          for (const We of Me) {
            const Qe = We.geometry;
            let tt = We.type;
            const At = ge === 0 ? We.minX : We.minY, qt = ge === 0 ? We.maxX : We.maxY;
            if (At >= Z && qt < Q) {
              Fe.push(We);
              continue;
            }
            if (qt < Z || At >= Q) continue;
            let sr = [];
            if (tt === "Point" || tt === "MultiPoint") Rr(Qe, sr, Z, Q, ge);
            else if (tt === "LineString") xr(Qe, sr, Z, Q, ge, false, se.lineMetrics);
            else if (tt === "MultiLineString") Be(Qe, sr, Z, Q, ge, false);
            else if (tt === "Polygon") Be(Qe, sr, Z, Q, ge, true);
            else if (tt === "MultiPolygon") for (const Ur of Qe) {
              const mr = [];
              Be(Ur, mr, Z, Q, ge, true), mr.length && sr.push(mr);
            }
            if (sr.length) {
              if (se.lineMetrics && tt === "LineString") {
                for (const Ur of sr) Fe.push(bt(We.id, tt, Ur, We.tags));
                continue;
              }
              tt !== "LineString" && tt !== "MultiLineString" || (sr.length === 1 ? (tt = "LineString", sr = sr[0]) : tt = "MultiLineString"), tt !== "Point" && tt !== "MultiPoint" || (tt = sr.length === 3 ? "Point" : "MultiPoint"), Fe.push(bt(We.id, tt, sr, We.tags));
            }
          }
          return Fe.length ? Fe : null;
        }
        function Rr(Me, $, Z, Q, ge) {
          for (let _e = 0; _e < Me.length; _e += 3) {
            const Re = Me[_e + ge];
            Re >= Z && Re <= Q && ot($, Me[_e], Me[_e + 1], Me[_e + 2]);
          }
        }
        function xr(Me, $, Z, Q, ge, _e, Re) {
          let se = gt(Me);
          const Fe = ge === 0 ? $e : Ye;
          let We, Qe, tt = Me.start;
          for (let mr = 0; mr < Me.length - 3; mr += 3) {
            const Sr = Me[mr], Dr = Me[mr + 1], ye = Me[mr + 2], at = Me[mr + 3], Ft = Me[mr + 4], hr = ge === 0 ? Sr : Dr, ur = ge === 0 ? at : Ft;
            let st = false;
            Re && (We = Math.sqrt(Math.pow(Sr - at, 2) + Math.pow(Dr - Ft, 2))), hr < Z ? ur > Z && (Qe = Fe(se, Sr, Dr, at, Ft, Z), Re && (se.start = tt + We * Qe)) : hr > Q ? ur < Q && (Qe = Fe(se, Sr, Dr, at, Ft, Q), Re && (se.start = tt + We * Qe)) : ot(se, Sr, Dr, ye), ur < Z && hr >= Z && (Qe = Fe(se, Sr, Dr, at, Ft, Z), st = true), ur > Q && hr <= Q && (Qe = Fe(se, Sr, Dr, at, Ft, Q), st = true), !_e && st && (Re && (se.end = tt + We * Qe), $.push(se), se = gt(Me)), Re && (tt += We);
          }
          let At = Me.length - 3;
          const qt = Me[At], sr = Me[At + 1], Ur = ge === 0 ? qt : sr;
          Ur >= Z && Ur <= Q && ot(se, qt, sr, Me[At + 2]), At = se.length - 3, _e && At >= 3 && (se[At] !== se[0] || se[At + 1] !== se[1]) && ot(se, se[0], se[1], se[2]), se.length && $.push(se);
        }
        function gt(Me) {
          const $ = [];
          return $.size = Me.size, $.start = Me.start, $.end = Me.end, $;
        }
        function Be(Me, $, Z, Q, ge, _e) {
          for (const Re of Me) xr(Re, $, Z, Q, ge, _e, false);
        }
        function ot(Me, $, Z, Q) {
          Me.push($, Z, Q);
        }
        function $e(Me, $, Z, Q, ge, _e) {
          const Re = (_e - $) / (Q - $);
          return ot(Me, _e, Z + (ge - Z) * Re, 1), Re;
        }
        function Ye(Me, $, Z, Q, ge, _e) {
          const Re = (_e - Z) / (ge - Z);
          return ot(Me, $ + (Q - $) * Re, _e, 1), Re;
        }
        function ht(Me, $) {
          const Z = [];
          for (let Q = 0; Q < Me.length; Q++) {
            const ge = Me[Q], _e = ge.type;
            let Re;
            if (_e === "Point" || _e === "MultiPoint" || _e === "LineString") Re = St(ge.geometry, $);
            else if (_e === "MultiLineString" || _e === "Polygon") {
              Re = [];
              for (const se of ge.geometry) Re.push(St(se, $));
            } else if (_e === "MultiPolygon") {
              Re = [];
              for (const se of ge.geometry) {
                const Fe = [];
                for (const We of se) Fe.push(St(We, $));
                Re.push(Fe);
              }
            }
            Z.push(bt(ge.id, _e, Re, ge.tags));
          }
          return Z;
        }
        function St(Me, $) {
          const Z = [];
          Z.size = Me.size, Me.start !== void 0 && (Z.start = Me.start, Z.end = Me.end);
          for (let Q = 0; Q < Me.length; Q += 3) Z.push(Me[Q] + $, Me[Q + 1], Me[Q + 2]);
          return Z;
        }
        function rt(Me, $) {
          if (Me.transformed) return Me;
          const Z = 1 << Me.z, Q = Me.x, ge = Me.y;
          for (const _e of Me.features) {
            const Re = _e.geometry, se = _e.type;
            if (_e.geometry = [], se === 1) for (let Fe = 0; Fe < Re.length; Fe += 2) _e.geometry.push(mt(Re[Fe], Re[Fe + 1], $, Z, Q, ge));
            else for (let Fe = 0; Fe < Re.length; Fe++) {
              const We = [];
              for (let Qe = 0; Qe < Re[Fe].length; Qe += 2) We.push(mt(Re[Fe][Qe], Re[Fe][Qe + 1], $, Z, Q, ge));
              _e.geometry.push(We);
            }
          }
          return Me.transformed = true, Me;
        }
        function mt(Me, $, Z, Q, ge, _e) {
          return [Math.round(Z * (Me * Q - ge)), Math.round(Z * ($ * Q - _e))];
        }
        function nr(Me, $, Z, Q, ge) {
          const _e = $ === ge.maxZoom ? 0 : ge.tolerance / ((1 << $) * ge.extent), Re = { features: [], numPoints: 0, numSimplified: 0, numFeatures: Me.length, source: null, x: Z, y: Q, z: $, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const se of Me) di(Re, se, _e, ge);
          return Re;
        }
        function di(Me, $, Z, Q) {
          const ge = $.geometry, _e = $.type, Re = [];
          if (Me.minX = Math.min(Me.minX, $.minX), Me.minY = Math.min(Me.minY, $.minY), Me.maxX = Math.max(Me.maxX, $.maxX), Me.maxY = Math.max(Me.maxY, $.maxY), _e === "Point" || _e === "MultiPoint") for (let se = 0; se < ge.length; se += 3) Re.push(ge[se], ge[se + 1]), Me.numPoints++, Me.numSimplified++;
          else if (_e === "LineString") wi(Re, ge, Me, Z, false, false);
          else if (_e === "MultiLineString" || _e === "Polygon") for (let se = 0; se < ge.length; se++) wi(Re, ge[se], Me, Z, _e === "Polygon", se === 0);
          else if (_e === "MultiPolygon") for (let se = 0; se < ge.length; se++) {
            const Fe = ge[se];
            for (let We = 0; We < Fe.length; We++) wi(Re, Fe[We], Me, Z, true, We === 0);
          }
          if (Re.length) {
            let se = $.tags || null;
            if (_e === "LineString" && Q.lineMetrics) {
              se = {};
              for (const We in $.tags) se[We] = $.tags[We];
              se.mapbox_clip_start = ge.start / ge.size, se.mapbox_clip_end = ge.end / ge.size;
            }
            const Fe = { geometry: Re, type: _e === "Polygon" || _e === "MultiPolygon" ? 3 : _e === "LineString" || _e === "MultiLineString" ? 2 : 1, tags: se };
            $.id !== null && (Fe.id = $.id), Me.features.push(Fe);
          }
        }
        function wi(Me, $, Z, Q, ge, _e) {
          const Re = Q * Q;
          if (Q > 0 && $.size < (ge ? Re : Q)) return void (Z.numPoints += $.length / 3);
          const se = [];
          for (let Fe = 0; Fe < $.length; Fe += 3) (Q === 0 || $[Fe + 2] > Re) && (Z.numSimplified++, se.push($[Fe], $[Fe + 1])), Z.numPoints++;
          ge && (function(Fe, We) {
            let Qe = 0;
            for (let tt = 0, At = Fe.length, qt = At - 2; tt < At; qt = tt, tt += 2) Qe += (Fe[tt] - Fe[qt]) * (Fe[tt + 1] + Fe[qt + 1]);
            if (Qe > 0 === We) for (let tt = 0, At = Fe.length; tt < At / 2; tt += 2) {
              const qt = Fe[tt], sr = Fe[tt + 1];
              Fe[tt] = Fe[At - 2 - tt], Fe[tt + 1] = Fe[At - 1 - tt], Fe[At - 2 - tt] = qt, Fe[At - 1 - tt] = sr;
            }
          })(se, _e), Me.push(se);
        }
        const xn = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 };
        class en {
          constructor($, Z) {
            const Q = (Z = this.options = (function(_e, Re) {
              for (const se in Re) _e[se] = Re[se];
              return _e;
            })(Object.create(xn), Z)).debug;
            if (Q && console.time("preprocess data"), Z.maxZoom < 0 || Z.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (Z.promoteId && Z.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let ge = (function(_e, Re) {
              const se = [];
              if (_e.type === "FeatureCollection") for (let Fe = 0; Fe < _e.features.length; Fe++) Zt(se, _e.features[Fe], Re, Fe);
              else Zt(se, _e.type === "Feature" ? _e : { geometry: _e }, Re);
              return se;
            })($, Z);
            this.tiles = {}, this.tileCoords = [], Q && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", Z.indexMaxZoom, Z.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), ge = (function(_e, Re) {
              const se = Re.buffer / Re.extent;
              let Fe = _e;
              const We = Ht(_e, 1, -1 - se, se, 0, -1, 2, Re), Qe = Ht(_e, 1, 1 - se, 2 + se, 0, -1, 2, Re);
              return (We || Qe) && (Fe = Ht(_e, 1, -se, 1 + se, 0, -1, 2, Re) || [], We && (Fe = ht(We, 1).concat(Fe)), Qe && (Fe = Fe.concat(ht(Qe, -1)))), Fe;
            })(ge, Z), ge.length && this.splitTile(ge, 0, 0, 0), Q && (ge.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile($, Z, Q, ge, _e, Re, se) {
            const Fe = [$, Z, Q, ge], We = this.options, Qe = We.debug;
            for (; Fe.length; ) {
              ge = Fe.pop(), Q = Fe.pop(), Z = Fe.pop(), $ = Fe.pop();
              const tt = 1 << Z, At = wn(Z, Q, ge);
              let qt = this.tiles[At];
              if (!qt && (Qe > 1 && console.time("creation"), qt = this.tiles[At] = nr($, Z, Q, ge, We), this.tileCoords.push({ z: Z, x: Q, y: ge }), Qe)) {
                Qe > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", Z, Q, ge, qt.numFeatures, qt.numPoints, qt.numSimplified), console.timeEnd("creation"));
                const st = `z${Z}`;
                this.stats[st] = (this.stats[st] || 0) + 1, this.total++;
              }
              if (qt.source = $, _e == null) {
                if (Z === We.indexMaxZoom || qt.numPoints <= We.indexMaxPoints) continue;
              } else {
                if (Z === We.maxZoom || Z === _e) continue;
                if (_e != null) {
                  const st = _e - Z;
                  if (Q !== Re >> st || ge !== se >> st) continue;
                }
              }
              if (qt.source = null, $.length === 0) continue;
              Qe > 1 && console.time("clipping");
              const sr = 0.5 * We.buffer / We.extent, Ur = 0.5 - sr, mr = 0.5 + sr, Sr = 1 + sr;
              let Dr = null, ye = null, at = null, Ft = null, hr = Ht($, tt, Q - sr, Q + mr, 0, qt.minX, qt.maxX, We), ur = Ht($, tt, Q + Ur, Q + Sr, 0, qt.minX, qt.maxX, We);
              $ = null, hr && (Dr = Ht(hr, tt, ge - sr, ge + mr, 1, qt.minY, qt.maxY, We), ye = Ht(hr, tt, ge + Ur, ge + Sr, 1, qt.minY, qt.maxY, We), hr = null), ur && (at = Ht(ur, tt, ge - sr, ge + mr, 1, qt.minY, qt.maxY, We), Ft = Ht(ur, tt, ge + Ur, ge + Sr, 1, qt.minY, qt.maxY, We), ur = null), Qe > 1 && console.timeEnd("clipping"), Fe.push(Dr || [], Z + 1, 2 * Q, 2 * ge), Fe.push(ye || [], Z + 1, 2 * Q, 2 * ge + 1), Fe.push(at || [], Z + 1, 2 * Q + 1, 2 * ge), Fe.push(Ft || [], Z + 1, 2 * Q + 1, 2 * ge + 1);
            }
          }
          getTile($, Z, Q) {
            $ = +$, Z = +Z, Q = +Q;
            const ge = this.options, { extent: _e, debug: Re } = ge;
            if ($ < 0 || $ > 24) return null;
            const se = 1 << $, Fe = wn($, Z = Z + se & se - 1, Q);
            if (this.tiles[Fe]) return rt(this.tiles[Fe], _e);
            Re > 1 && console.log("drilling down to z%d-%d-%d", $, Z, Q);
            let We, Qe = $, tt = Z, At = Q;
            for (; !We && Qe > 0; ) Qe--, tt >>= 1, At >>= 1, We = this.tiles[wn(Qe, tt, At)];
            return We && We.source ? (Re > 1 && (console.log("found parent tile z%d-%d-%d", Qe, tt, At), console.time("drilling down")), this.splitTile(We.source, Qe, tt, At, $, Z, Q), Re > 1 && console.timeEnd("drilling down"), this.tiles[Fe] ? rt(this.tiles[Fe], _e) : null) : null;
          }
        }
        function wn(Me, $, Z) {
          return 32 * ((1 << Me) * Z + $) + Me;
        }
        class Cn extends le {
          constructor($, Z, Q, ge = Bi) {
            super($, Z, Q), this._dataUpdateable = /* @__PURE__ */ new Map(), this._createGeoJSONIndex = ge;
          }
          loadVectorTile($, Z) {
            return p._(this, void 0, void 0, (function* () {
              const Q = $.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const ge = this._geoJSONIndex.getTile(Q.z, Q.x, Q.y);
              return ge ? ke(new O(ge.features, { version: 2, extent: p.a3 })) : null;
            }));
          }
          loadData($) {
            return p._(this, void 0, void 0, (function* () {
              var Z;
              (Z = this._pendingRequest) === null || Z === void 0 || Z.abort();
              const Q = !!($ && $.request && $.request.collectResourceTiming) && new p.cW($.request);
              this._pendingRequest = new AbortController();
              try {
                (!this._pendingData || $.request || $.data || $.dataDiff) && (this._pendingData = this.loadAndProcessGeoJSON($, this._pendingRequest));
                const ge = yield this._pendingData;
                this._geoJSONIndex = this._createGeoJSONIndex(ge, $), this.loaded = {};
                const _e = { data: ge };
                if (Q) {
                  const Re = Q.finish();
                  Re && (_e.resourceTiming = {}, _e.resourceTiming[$.source] = JSON.parse(JSON.stringify(Re)));
                }
                return _e;
              } catch (ge) {
                if (delete this._pendingRequest, p.cC(ge)) return { abandoned: true };
                throw ge;
              }
            }));
          }
          getData() {
            return p._(this, void 0, void 0, (function* () {
              return this._pendingData;
            }));
          }
          reloadTile($) {
            const Z = this.loaded;
            return Z && Z[$.uid] ? super.reloadTile($) : this.loadTile($);
          }
          loadAndProcessGeoJSON($, Z) {
            return p._(this, void 0, void 0, (function* () {
              let Q = yield this.loadGeoJSON($, Z);
              if (delete this._pendingRequest, typeof Q != "object") throw new Error(`Input data given to '${$.source}' is not a valid GeoJSON object.`);
              if (et(Q, true), $.filter) {
                const ge = p.c_($.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                if (ge.result === "error") throw new Error(ge.value.map(((Re) => `${Re.key}: ${Re.message}`)).join(", "));
                Q = { type: "FeatureCollection", features: Q.features.filter(((Re) => ge.value.evaluate({ zoom: 0 }, Re))) };
              }
              return Q;
            }));
          }
          loadGeoJSON($, Z) {
            return p._(this, void 0, void 0, (function* () {
              const { promoteId: Q } = $;
              if ($.request) {
                const ge = yield p.j($.request, Z);
                return this._dataUpdateable = p.d0(ge.data, Q) ? p.c$(ge.data, Q) : void 0, ge.data;
              }
              if (typeof $.data == "string") try {
                const ge = JSON.parse($.data);
                return this._dataUpdateable = p.d0(ge, Q) ? p.c$(ge, Q) : void 0, ge;
              } catch {
                throw new Error(`Input data given to '${$.source}' is not a valid GeoJSON object.`);
              }
              if (!$.dataDiff) throw new Error(`Input data given to '${$.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${$.source}`);
              return p.d1(this._dataUpdateable, $.dataDiff, Q), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
            }));
          }
          removeSource($) {
            return p._(this, void 0, void 0, (function* () {
              this._pendingRequest && this._pendingRequest.abort();
            }));
          }
          getClusterExpansionZoom($) {
            return this._geoJSONIndex.getClusterExpansionZoom($.clusterId);
          }
          getClusterChildren($) {
            return this._geoJSONIndex.getChildren($.clusterId);
          }
          getClusterLeaves($) {
            return this._geoJSONIndex.getLeaves($.clusterId, $.limit, $.offset);
          }
        }
        function Bi(Me, $) {
          return $.cluster ? new ct((function({ superclusterOptions: Z, clusterProperties: Q }) {
            if (!Q || !Z) return Z;
            const ge = {}, _e = {}, Re = { accumulated: null, zoom: 0 }, se = { properties: null }, Fe = Object.keys(Q);
            for (const We of Fe) {
              const [Qe, tt] = Q[We], At = p.c_(tt), qt = p.c_(typeof Qe == "string" ? [Qe, ["accumulated"], ["get", We]] : Qe);
              ge[We] = At.value, _e[We] = qt.value;
            }
            return Z.map = (We) => {
              se.properties = We;
              const Qe = {};
              for (const tt of Fe) Qe[tt] = ge[tt].evaluate(Re, se);
              return Qe;
            }, Z.reduce = (We, Qe) => {
              se.properties = Qe;
              for (const tt of Fe) Re.accumulated = We[tt], We[tt] = _e[tt].evaluate(Re, se);
            }, Z;
          })($)).load(Me.features) : (function(Z, Q) {
            return new en(Z, Q);
          })(Me, $.geojsonVtOptions);
        }
        class Ci {
          constructor($) {
            this.self = $, this.actor = new p.K($), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = /* @__PURE__ */ new Map(), this.self.registerWorkerSource = (Z, Q) => {
              if (this.externalWorkerSourceTypes[Z]) throw new Error(`Worker source with name "${Z}" already registered.`);
              this.externalWorkerSourceTypes[Z] = Q;
            }, this.self.addProtocol = p.cE, this.self.removeProtocol = p.cF, this.self.registerRTLTextPlugin = (Z) => {
              p.d2.setMethods(Z);
            }, this.actor.registerMessageHandler("LDT", ((Z, Q) => this._getDEMWorkerSource(Z, Q.source).loadTile(Q))), this.actor.registerMessageHandler("RDT", ((Z, Q) => p._(this, void 0, void 0, (function* () {
              this._getDEMWorkerSource(Z, Q.source).removeTile(Q);
            })))), this.actor.registerMessageHandler("GCEZ", ((Z, Q) => p._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(Z, Q.type, Q.source).getClusterExpansionZoom(Q);
            })))), this.actor.registerMessageHandler("GCC", ((Z, Q) => p._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(Z, Q.type, Q.source).getClusterChildren(Q);
            })))), this.actor.registerMessageHandler("GCL", ((Z, Q) => p._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(Z, Q.type, Q.source).getClusterLeaves(Q);
            })))), this.actor.registerMessageHandler("LD", ((Z, Q) => this._getWorkerSource(Z, Q.type, Q.source).loadData(Q))), this.actor.registerMessageHandler("GD", ((Z, Q) => this._getWorkerSource(Z, Q.type, Q.source).getData())), this.actor.registerMessageHandler("LT", ((Z, Q) => this._getWorkerSource(Z, Q.type, Q.source).loadTile(Q))), this.actor.registerMessageHandler("RT", ((Z, Q) => this._getWorkerSource(Z, Q.type, Q.source).reloadTile(Q))), this.actor.registerMessageHandler("AT", ((Z, Q) => this._getWorkerSource(Z, Q.type, Q.source).abortTile(Q))), this.actor.registerMessageHandler("RMT", ((Z, Q) => this._getWorkerSource(Z, Q.type, Q.source).removeTile(Q))), this.actor.registerMessageHandler("RS", ((Z, Q) => p._(this, void 0, void 0, (function* () {
              if (!this.workerSources[Z] || !this.workerSources[Z][Q.type] || !this.workerSources[Z][Q.type][Q.source]) return;
              const ge = this.workerSources[Z][Q.type][Q.source];
              delete this.workerSources[Z][Q.type][Q.source], ge.removeSource !== void 0 && ge.removeSource(Q);
            })))), this.actor.registerMessageHandler("RM", ((Z) => p._(this, void 0, void 0, (function* () {
              delete this.layerIndexes[Z], delete this.availableImages[Z], delete this.workerSources[Z], delete this.demWorkerSources[Z], this.globalStates.delete(Z);
            })))), this.actor.registerMessageHandler("SR", ((Z, Q) => p._(this, void 0, void 0, (function* () {
              this.referrer = Q;
            })))), this.actor.registerMessageHandler("SRPS", ((Z, Q) => this._syncRTLPluginState(Z, Q))), this.actor.registerMessageHandler("IS", ((Z, Q) => p._(this, void 0, void 0, (function* () {
              this.self.importScripts(Q);
            })))), this.actor.registerMessageHandler("SI", ((Z, Q) => this._setImages(Z, Q))), this.actor.registerMessageHandler("UL", ((Z, Q) => p._(this, void 0, void 0, (function* () {
              this._getLayerIndex(Z).update(Q.layers, Q.removedIds, this._getGlobalState(Z));
            })))), this.actor.registerMessageHandler("UGS", ((Z, Q) => p._(this, void 0, void 0, (function* () {
              const ge = this._getGlobalState(Z);
              for (const _e in Q) ge[_e] = Q[_e];
            })))), this.actor.registerMessageHandler("SL", ((Z, Q) => p._(this, void 0, void 0, (function* () {
              this._getLayerIndex(Z).replace(Q, this._getGlobalState(Z));
            }))));
          }
          _getGlobalState($) {
            let Z = this.globalStates.get($);
            return Z || (Z = {}, this.globalStates.set($, Z)), Z;
          }
          _setImages($, Z) {
            return p._(this, void 0, void 0, (function* () {
              this.availableImages[$] = Z;
              for (const Q in this.workerSources[$]) {
                const ge = this.workerSources[$][Q];
                for (const _e in ge) ge[_e].availableImages = Z;
              }
            }));
          }
          _syncRTLPluginState($, Z) {
            return p._(this, void 0, void 0, (function* () {
              return yield p.d2.syncState(Z, this.self.importScripts);
            }));
          }
          _getAvailableImages($) {
            let Z = this.availableImages[$];
            return Z || (Z = []), Z;
          }
          _getLayerIndex($) {
            let Z = this.layerIndexes[$];
            return Z || (Z = this.layerIndexes[$] = new s()), Z;
          }
          _getWorkerSource($, Z, Q) {
            if (this.workerSources[$] || (this.workerSources[$] = {}), this.workerSources[$][Z] || (this.workerSources[$][Z] = {}), !this.workerSources[$][Z][Q]) {
              const ge = { sendAsync: (_e, Re) => (_e.targetMapId = $, this.actor.sendAsync(_e, Re)) };
              switch (Z) {
                case "vector":
                  this.workerSources[$][Z][Q] = new le(ge, this._getLayerIndex($), this._getAvailableImages($));
                  break;
                case "geojson":
                  this.workerSources[$][Z][Q] = new Cn(ge, this._getLayerIndex($), this._getAvailableImages($));
                  break;
                default:
                  this.workerSources[$][Z][Q] = new this.externalWorkerSourceTypes[Z](ge, this._getLayerIndex($), this._getAvailableImages($));
              }
            }
            return this.workerSources[$][Z][Q];
          }
          _getDEMWorkerSource($, Z) {
            return this.demWorkerSources[$] || (this.demWorkerSources[$] = {}), this.demWorkerSources[$][Z] || (this.demWorkerSources[$][Z] = new ue()), this.demWorkerSources[$][Z];
          }
        }
        return p.i(self) && (self.worker = new Ci(self)), Ci;
      })), f("index", ["exports", "./shared"], (function(p, s) {
        var S = "5.12.0";
        function P() {
          var _ = new s.A(4);
          return s.A != Float32Array && (_[1] = 0, _[2] = 0), _[0] = 1, _[3] = 1, _;
        }
        let M, A, O;
        const j = { frame(_, t, a) {
          const d = requestAnimationFrame(((b) => {
            g(), t(b);
          })), { unsubscribe: g } = s.s(_.signal, "abort", (() => {
            g(), cancelAnimationFrame(d), a(s.c());
          }), false);
        }, frameAsync(_) {
          return new Promise(((t, a) => {
            this.frame(_, t, a);
          }));
        }, getImageData(_, t = 0) {
          return this.getImageCanvasContext(_).getImageData(-t, -t, _.width + 2 * t, _.height + 2 * t);
        }, getImageCanvasContext(_) {
          const t = window.document.createElement("canvas"), a = t.getContext("2d", { willReadFrequently: true });
          if (!a) throw new Error("failed to create canvas 2d context");
          return t.width = _.width, t.height = _.height, a.drawImage(_, 0, 0, _.width, _.height), a;
        }, resolveURL: (_) => (M || (M = document.createElement("a")), M.href = _, M.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return O !== void 0 ? O : !!matchMedia && (A == null && (A = matchMedia("(prefers-reduced-motion: reduce)")), A.matches);
        }, set prefersReducedMotion(_) {
          O = _;
        } }, L = new class {
          constructor() {
            this._realTime = typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), this._frozenAt = null;
          }
          getCurrentTime() {
            return this._frozenAt !== null ? this._frozenAt : this._realTime();
          }
          setNow(_) {
            this._frozenAt = _;
          }
          restoreNow() {
            this._frozenAt = null;
          }
          isFrozen() {
            return this._frozenAt !== null;
          }
        }();
        function q() {
          return L.getCurrentTime();
        }
        class N {
          static testProp(t) {
            if (!N.docStyle) return t[0];
            for (let a = 0; a < t.length; a++) if (t[a] in N.docStyle) return t[a];
            return t[0];
          }
          static create(t, a, d) {
            const g = window.document.createElement(t);
            return a !== void 0 && (g.className = a), d && d.appendChild(g), g;
          }
          static createNS(t, a) {
            return window.document.createElementNS(t, a);
          }
          static disableDrag() {
            N.docStyle && N.selectProp && (N.userSelect = N.docStyle[N.selectProp], N.docStyle[N.selectProp] = "none");
          }
          static enableDrag() {
            N.docStyle && N.selectProp && (N.docStyle[N.selectProp] = N.userSelect);
          }
          static setTransform(t, a) {
            t.style[N.transformProp] = a;
          }
          static addEventListener(t, a, d, g = {}) {
            t.addEventListener(a, d, "passive" in g ? g : g.capture);
          }
          static removeEventListener(t, a, d, g = {}) {
            t.removeEventListener(a, d, "passive" in g ? g : g.capture);
          }
          static suppressClickInternal(t) {
            t.preventDefault(), t.stopPropagation(), window.removeEventListener("click", N.suppressClickInternal, true);
          }
          static suppressClick() {
            window.addEventListener("click", N.suppressClickInternal, true), window.setTimeout((() => {
              window.removeEventListener("click", N.suppressClickInternal, true);
            }), 0);
          }
          static getScale(t) {
            const a = t.getBoundingClientRect();
            return { x: a.width / t.offsetWidth || 1, y: a.height / t.offsetHeight || 1, boundingClientRect: a };
          }
          static getPoint(t, a, d) {
            const g = a.boundingClientRect;
            return new s.P((d.clientX - g.left) / a.x - t.clientLeft, (d.clientY - g.top) / a.y - t.clientTop);
          }
          static mousePos(t, a) {
            const d = N.getScale(t);
            return N.getPoint(t, d, a);
          }
          static touchPos(t, a) {
            const d = [], g = N.getScale(t);
            for (let b = 0; b < a.length; b++) d.push(N.getPoint(t, g, a[b]));
            return d;
          }
          static mouseButton(t) {
            return t.button;
          }
          static remove(t) {
            t.parentNode && t.parentNode.removeChild(t);
          }
          static sanitize(t) {
            const a = new DOMParser().parseFromString(t, "text/html").body || document.createElement("body"), d = a.querySelectorAll("script");
            for (const g of d) g.remove();
            return N.clean(a), a.innerHTML;
          }
          static isPossiblyDangerous(t, a) {
            const d = a.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(t) || !d.includes("javascript:") && !d.includes("data:")) || !!t.startsWith("on") || void 0;
          }
          static clean(t) {
            const a = t.children;
            for (const d of a) N.removeAttributes(d), N.clean(d);
          }
          static removeAttributes(t) {
            for (const { name: a, value: d } of t.attributes) N.isPossiblyDangerous(a, d) && t.removeAttribute(a);
          }
        }
        N.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, N.selectProp = N.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), N.transformProp = N.testProp(["transform", "WebkitTransform"]);
        const J = { supported: false, testSupport: function(_) {
          !ae && ne && (oe ? ee(_) : te = _);
        } };
        let te, ne, ae = false, oe = false;
        function ee(_) {
          const t = _.createTexture();
          _.bindTexture(_.TEXTURE_2D, t);
          try {
            if (_.texImage2D(_.TEXTURE_2D, 0, _.RGBA, _.RGBA, _.UNSIGNED_BYTE, ne), _.isContextLost()) return;
            J.supported = true;
          } catch {
          }
          _.deleteTexture(t), ae = true;
        }
        var ke;
        typeof document < "u" && (ne = document.createElement("img"), ne.onload = () => {
          te && ee(te), te = null, oe = true;
        }, ne.onerror = () => {
          ae = true, te = null;
        }, ne.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(_) {
          let t, a, d, g;
          _.resetRequestQueue = () => {
            t = [], a = 0, d = 0, g = {};
          }, _.addThrottleControl = (I) => {
            const R = d++;
            return g[R] = I, R;
          }, _.removeThrottleControl = (I) => {
            delete g[I], w();
          }, _.getImage = (I, R, z = true) => new Promise(((W, U) => {
            J.supported && (I.headers || (I.headers = {}), I.headers.accept = "image/webp,*/*"), s.e(I, { type: "image" }), t.push({ abortController: R, requestParameters: I, supportImageRefresh: z, state: "queued", onError: (X) => {
              U(X);
            }, onSuccess: (X) => {
              W(X);
            } }), w();
          }));
          const b = (I) => s._(this, void 0, void 0, (function* () {
            I.state = "running";
            const { requestParameters: R, supportImageRefresh: z, onError: W, onSuccess: U, abortController: X } = I, re = z === false && !s.i(self) && !s.g(R.url) && (!R.headers || Object.keys(R.headers).reduce(((me, Ce) => me && Ce === "accept"), true));
            a++;
            const de = re ? T(R, X) : s.m(R, X);
            try {
              const me = yield de;
              delete I.abortController, I.state = "completed", me.data instanceof HTMLImageElement || s.b(me.data) ? U(me) : me.data && U({ data: yield (fe = me.data, typeof createImageBitmap == "function" ? s.f(fe) : s.h(fe)), cacheControl: me.cacheControl, expires: me.expires });
            } catch (me) {
              delete I.abortController, W(me);
            } finally {
              a--, w();
            }
            var fe;
          })), w = () => {
            const I = (() => {
              for (const R of Object.keys(g)) if (g[R]()) return true;
              return false;
            })() ? s.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : s.a.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let R = a; R < I && t.length > 0; R++) {
              const z = t.shift();
              z.abortController.signal.aborted ? R-- : b(z);
            }
          }, T = (I, R) => new Promise(((z, W) => {
            const U = new Image(), X = I.url, re = I.credentials;
            re && re === "include" ? U.crossOrigin = "use-credentials" : (re && re === "same-origin" || !s.d(X)) && (U.crossOrigin = "anonymous"), R.signal.addEventListener("abort", (() => {
              U.src = "", W(s.c());
            })), U.fetchPriority = "high", U.onload = () => {
              U.onerror = U.onload = null, z({ data: U });
            }, U.onerror = () => {
              U.onerror = U.onload = null, R.signal.aborted || W(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, U.src = X;
          }));
        })(ke || (ke = {})), ke.resetRequestQueue();
        class ve {
          constructor(t) {
            this._transformRequestFn = t ?? null;
          }
          transformRequest(t, a) {
            return this._transformRequestFn && this._transformRequestFn(t, a) || { url: t };
          }
          setTransformRequest(t) {
            this._transformRequestFn = t;
          }
        }
        function le(_) {
          const t = [];
          if (typeof _ == "string") t.push({ id: "default", url: _ });
          else if (_ && _.length > 0) {
            const a = [];
            for (const { id: d, url: g } of _) {
              const b = `${d}${g}`;
              a.indexOf(b) === -1 && (a.push(b), t.push({ id: d, url: g }));
            }
          }
          return t;
        }
        function ue(_, t, a) {
          try {
            const d = new URL(_);
            return d.pathname += `${t}${a}`, d.toString();
          } catch {
            throw new Error(`Invalid sprite URL "${_}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
          }
        }
        function be(_) {
          const { userImage: t } = _;
          return !!(t && t.render && t.render()) && (_.data.replace(new Uint8Array(t.data.buffer)), true);
        }
        class Ve extends s.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new s.R({ width: 1, height: 1 }), this.dirty = true;
          }
          destroy() {
            this.atlasTexture && (this.atlasTexture.destroy(), this.atlasTexture = null);
            for (const t of Object.keys(this.images)) this.removeImage(t);
            this.patterns = {}, this.atlasImage = new s.R({ width: 1, height: 1 }), this.dirty = true;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(t) {
            if (this.loaded !== t && (this.loaded = t, t)) {
              for (const { ids: a, promiseResolve: d } of this.requestors) d(this._getImagesForIds(a));
              this.requestors = [];
            }
          }
          getImage(t) {
            const a = this.images[t];
            if (a && !a.data && a.spriteData) {
              const d = a.spriteData;
              a.data = new s.R({ width: d.width, height: d.height }, d.context.getImageData(d.x, d.y, d.width, d.height).data), a.spriteData = null;
            }
            return a;
          }
          addImage(t, a) {
            if (this.images[t]) throw new Error(`Image id ${t} already exist, use updateImage instead`);
            this._validate(t, a) && (this.images[t] = a);
          }
          _validate(t, a) {
            let d = true;
            const g = a.data || a.spriteData;
            return this._validateStretch(a.stretchX, g && g.width) || (this.fire(new s.k(new Error(`Image "${t}" has invalid "stretchX" value`))), d = false), this._validateStretch(a.stretchY, g && g.height) || (this.fire(new s.k(new Error(`Image "${t}" has invalid "stretchY" value`))), d = false), this._validateContent(a.content, a) || (this.fire(new s.k(new Error(`Image "${t}" has invalid "content" value`))), d = false), d;
          }
          _validateStretch(t, a) {
            if (!t) return true;
            let d = 0;
            for (const g of t) {
              if (g[0] < d || g[1] < g[0] || a < g[1]) return false;
              d = g[1];
            }
            return true;
          }
          _validateContent(t, a) {
            if (!t) return true;
            if (t.length !== 4) return false;
            const d = a.spriteData, g = d && d.width || a.data.width, b = d && d.height || a.data.height;
            return !(t[0] < 0 || g < t[0] || t[1] < 0 || b < t[1] || t[2] < 0 || g < t[2] || t[3] < 0 || b < t[3] || t[2] < t[0] || t[3] < t[1]);
          }
          updateImage(t, a, d = true) {
            const g = this.getImage(t);
            if (d && (g.data.width !== a.data.width || g.data.height !== a.data.height)) throw new Error(`size mismatch between old image (${g.data.width}x${g.data.height}) and new image (${a.data.width}x${a.data.height}).`);
            a.version = g.version + 1, this.images[t] = a, this.updatedImages[t] = true;
          }
          removeImage(t) {
            const a = this.images[t];
            delete this.images[t], delete this.patterns[t], a.userImage && a.userImage.onRemove && a.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(t) {
            return new Promise(((a, d) => {
              let g = true;
              if (!this.isLoaded()) for (const b of t) this.images[b] || (g = false);
              this.isLoaded() || g ? a(this._getImagesForIds(t)) : this.requestors.push({ ids: t, promiseResolve: a });
            }));
          }
          _getImagesForIds(t) {
            const a = {};
            for (const d of t) {
              let g = this.getImage(d);
              g || (this.fire(new s.l("styleimagemissing", { id: d })), g = this.getImage(d)), g ? a[d] = { data: g.data.clone(), pixelRatio: g.pixelRatio, sdf: g.sdf, version: g.version, stretchX: g.stretchX, stretchY: g.stretchY, content: g.content, textFitWidth: g.textFitWidth, textFitHeight: g.textFitHeight, hasRenderCallback: !!(g.userImage && g.userImage.render) } : s.w(`Image "${d}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            return a;
          }
          getPixelSize() {
            const { width: t, height: a } = this.atlasImage;
            return { width: t, height: a };
          }
          getPattern(t) {
            const a = this.patterns[t], d = this.getImage(t);
            if (!d) return null;
            if (a && a.position.version === d.version) return a.position;
            if (a) a.position.version = d.version;
            else {
              const g = { w: d.data.width + 2, h: d.data.height + 2, x: 0, y: 0 }, b = new s.I(g, d);
              this.patterns[t] = { bin: g, position: b };
            }
            return this._updatePatternAtlas(), this.patterns[t].position;
          }
          bind(t) {
            const a = t.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new s.T(t, this.atlasImage, a.RGBA), this.atlasTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const t = [];
            for (const b in this.patterns) t.push(this.patterns[b].bin);
            const { w: a, h: d } = s.p(t), g = this.atlasImage;
            g.resize({ width: a || 1, height: d || 1 });
            for (const b in this.patterns) {
              const { bin: w } = this.patterns[b], T = w.x + 1, I = w.y + 1, R = this.getImage(b).data, z = R.width, W = R.height;
              s.R.copy(R, g, { x: 0, y: 0 }, { x: T, y: I }, { width: z, height: W }), s.R.copy(R, g, { x: 0, y: W - 1 }, { x: T, y: I - 1 }, { width: z, height: 1 }), s.R.copy(R, g, { x: 0, y: 0 }, { x: T, y: I + W }, { width: z, height: 1 }), s.R.copy(R, g, { x: z - 1, y: 0 }, { x: T - 1, y: I }, { width: 1, height: W }), s.R.copy(R, g, { x: 0, y: 0 }, { x: T + z, y: I }, { width: 1, height: W });
            }
            this.dirty = true;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(t) {
            for (const a of t) {
              if (this.callbackDispatchedThisFrame[a]) continue;
              this.callbackDispatchedThisFrame[a] = true;
              const d = this.getImage(a);
              d || s.w(`Image with ID: "${a}" was not found`), be(d) && this.updateImage(a, d);
            }
          }
          cloneImages() {
            const t = {};
            for (const a in this.images) {
              const d = this.images[a];
              t[a] = Object.assign(Object.assign({}, d), { data: d.data ? d.data.clone() : null });
            }
            return t;
          }
        }
        const Ge = 1e20;
        function et(_, t, a, d, g, b, w, T, I) {
          for (let R = t; R < t + d; R++) dt(_, a * b + R, b, g, w, T, I);
          for (let R = a; R < a + g; R++) dt(_, R * b + t, 1, d, w, T, I);
        }
        function dt(_, t, a, d, g, b, w) {
          b[0] = 0, w[0] = -Ge, w[1] = Ge, g[0] = _[t];
          for (let T = 1, I = 0, R = 0; T < d; T++) {
            g[T] = _[t + T * a];
            const z = T * T;
            do {
              const W = b[I];
              R = (g[T] - g[W] + z - W * W) / (T - W) / 2;
            } while (R <= w[I] && --I > -1);
            I++, b[I] = T, w[I] = R, w[I + 1] = Ge;
          }
          for (let T = 0, I = 0; T < d; T++) {
            for (; w[I + 1] < T; ) I++;
            const R = b[I], z = T - R;
            _[t + T * a] = g[R] + z * z;
          }
        }
        const Ct = s.v.layout_symbol["text-font"].default.join(",");
        class kt {
          constructor(t, a, d) {
            this.requestManager = t, this.localIdeographFontFamily = a, this.entries = {}, this.lang = d;
          }
          setURL(t) {
            this.url = t;
          }
          getGlyphs(t) {
            return s._(this, void 0, void 0, (function* () {
              const a = [];
              for (const b in t) for (const w of t[b]) a.push(this._getAndCacheGlyphsPromise(b, w));
              const d = yield Promise.all(a), g = {};
              for (const { stack: b, id: w, glyph: T } of d) g[b] || (g[b] = {}), g[b][w] = T && { id: T.id, bitmap: T.bitmap.clone(), metrics: T.metrics };
              return g;
            }));
          }
          _getAndCacheGlyphsPromise(t, a) {
            return s._(this, void 0, void 0, (function* () {
              let d = this.entries[t];
              d || (d = this.entries[t] = { glyphs: {}, requests: {}, ranges: {} });
              let g = d.glyphs[a];
              return g !== void 0 ? { stack: t, id: a, glyph: g } : !this.url || this._charUsesLocalIdeographFontFamily(a) ? (g = d.glyphs[a] = this._drawGlyph(d, t, a), { stack: t, id: a, glyph: g }) : yield this._downloadAndCacheRangePromise(t, a);
            }));
          }
          _downloadAndCacheRangePromise(t, a) {
            return s._(this, void 0, void 0, (function* () {
              const d = Math.floor(a / 256);
              if (256 * d > 65535) throw new Error("glyphs > 65535 not supported");
              const g = this.entries[t];
              if (g.ranges[d]) return { stack: t, id: a, glyph: null };
              if (!g.requests[d]) {
                const b = kt.loadGlyphRange(t, d, this.url, this.requestManager);
                g.requests[d] = b;
              }
              try {
                const b = yield g.requests[d];
                for (const w in b) g.glyphs[+w] = b[+w];
                return g.ranges[d] = true, { stack: t, id: a, glyph: b[a] || null };
              } catch (b) {
                const w = g.glyphs[a] = this._drawGlyph(g, t, a);
                return this._warnOnMissingGlyphRange(w, d, a, b), { stack: t, id: a, glyph: w };
              }
            }));
          }
          _warnOnMissingGlyphRange(t, a, d, g) {
            const b = 256 * a, w = b + 255, T = d.toString(16).padStart(4, "0").toUpperCase();
            s.w(`Unable to load glyph range ${a}, ${b}-${w}. Rendering codepoint U+${T} locally instead. ${g}`);
          }
          _charUsesLocalIdeographFontFamily(t) {
            return !!this.localIdeographFontFamily && s.q(t);
          }
          _drawGlyph(t, a, d) {
            const g = a === Ct && this.localIdeographFontFamily !== "" && this._charUsesLocalIdeographFontFamily(d), b = g ? "ideographTinySDF" : "tinySDF";
            t[b] || (t[b] = this._createTinySDF(g ? this.localIdeographFontFamily : a));
            const w = t[b].draw(String.fromCharCode(d));
            return { id: d, bitmap: new s.r({ width: w.width || 60, height: w.height || 60 }, w.data), metrics: { width: w.glyphWidth / 2 || 24, height: w.glyphHeight / 2 || 24, left: w.glyphLeft / 2 + 0.5 || 0, top: w.glyphTop / 2 - 27.5 || -8, advance: w.glyphAdvance / 2 || 24, isDoubleResolution: true } };
          }
          _createTinySDF(t) {
            const a = t ? t.split(",") : [];
            a.push("sans-serif");
            const d = a.map(((g) => /[-\w]+/.test(g) ? g : `'${CSS.escape(g)}'`)).join(",");
            return new kt.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: d, fontWeight: this._fontWeight(a[0]), fontStyle: this._fontStyle(a[0]), lang: this.lang });
          }
          _fontStyle(t) {
            return /italic/i.test(t) ? "italic" : /oblique/i.test(t) ? "oblique" : "normal";
          }
          _fontWeight(t) {
            const a = { thin: 100, hairline: 100, "extra light": 200, "ultra light": 200, light: 300, normal: 400, regular: 400, medium: 500, semibold: 600, demibold: 600, bold: 700, "extra bold": 800, "ultra bold": 800, black: 900, heavy: 900, "extra black": 950, "ultra black": 950 };
            let d;
            for (const [g, b] of Object.entries(a)) new RegExp(`\\b${g}\\b`, "i").test(t) && (d = `${b}`);
            return d;
          }
          destroy() {
            for (const t in this.entries) {
              const a = this.entries[t];
              a.tinySDF && (a.tinySDF = null), a.ideographTinySDF && (a.ideographTinySDF = null), a.glyphs = {}, a.requests = {}, a.ranges = {};
            }
            this.entries = {};
          }
        }
        kt.loadGlyphRange = function(_, t, a, d) {
          return s._(this, void 0, void 0, (function* () {
            const g = 256 * t, b = g + 255, w = d.transformRequest(a.replace("{fontstack}", _).replace("{range}", `${g}-${b}`), "Glyphs"), T = yield s.n(w, new AbortController());
            if (!T || !T.data) throw new Error(`Could not load glyph range. range: ${t}, ${g}-${b}`);
            const I = {};
            for (const R of s.o(T.data)) I[R.id] = R;
            return I;
          }));
        }, kt.TinySDF = class {
          constructor({ fontSize: _ = 24, buffer: t = 3, radius: a = 8, cutoff: d = 0.25, fontFamily: g = "sans-serif", fontWeight: b = "normal", fontStyle: w = "normal", lang: T = null } = {}) {
            this.buffer = t, this.cutoff = d, this.radius = a, this.lang = T;
            const I = this.size = _ + 4 * t, R = this._createCanvas(I), z = this.ctx = R.getContext("2d", { willReadFrequently: true });
            z.font = `${w} ${b} ${_}px ${g}`, z.textBaseline = "alphabetic", z.textAlign = "left", z.fillStyle = "black", this.gridOuter = new Float64Array(I * I), this.gridInner = new Float64Array(I * I), this.f = new Float64Array(I), this.z = new Float64Array(I + 1), this.v = new Uint16Array(I);
          }
          _createCanvas(_) {
            const t = document.createElement("canvas");
            return t.width = t.height = _, t;
          }
          draw(_) {
            const { width: t, actualBoundingBoxAscent: a, actualBoundingBoxDescent: d, actualBoundingBoxLeft: g, actualBoundingBoxRight: b } = this.ctx.measureText(_), w = Math.ceil(a), T = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(b - g))), I = Math.min(this.size - this.buffer, w + Math.ceil(d)), R = T + 2 * this.buffer, z = I + 2 * this.buffer, W = Math.max(R * z, 0), U = new Uint8ClampedArray(W), X = { data: U, width: R, height: z, glyphWidth: T, glyphHeight: I, glyphTop: w, glyphLeft: 0, glyphAdvance: t };
            if (T === 0 || I === 0) return X;
            const { ctx: re, buffer: de, gridInner: fe, gridOuter: me } = this;
            this.lang && (re.lang = this.lang), re.clearRect(de, de, T, I), re.fillText(_, de, de + w);
            const Ce = re.getImageData(de, de, T, I);
            me.fill(Ge, 0, W), fe.fill(0, 0, W);
            for (let Pe = 0; Pe < I; Pe++) for (let xe = 0; xe < T; xe++) {
              const Ie = Ce.data[4 * (Pe * T + xe) + 3] / 255;
              if (Ie === 0) continue;
              const De = (Pe + de) * R + xe + de;
              if (Ie === 1) me[De] = 0, fe[De] = Ge;
              else {
                const Se = 0.5 - Ie;
                me[De] = Se > 0 ? Se * Se : 0, fe[De] = Se < 0 ? Se * Se : 0;
              }
            }
            et(me, 0, 0, R, z, R, this.f, this.v, this.z), et(fe, de, de, T, I, R, this.f, this.v, this.z);
            for (let Pe = 0; Pe < W; Pe++) {
              const xe = Math.sqrt(me[Pe]) - Math.sqrt(fe[Pe]);
              U[Pe] = Math.round(255 - 255 * (xe / this.radius + this.cutoff));
            }
            return X;
          }
        };
        class ct {
          constructor() {
            this.specification = s.u.light.position;
          }
          possiblyEvaluate(t, a) {
            return s.C(t.expression.evaluate(a));
          }
          interpolate(t, a, d) {
            return { x: s.F.number(t.x, a.x, d), y: s.F.number(t.y, a.y, d), z: s.F.number(t.z, a.z, d) };
          }
        }
        let it;
        class pt extends s.E {
          constructor(t) {
            super(), it = it || new s.t({ anchor: new s.D(s.u.light.anchor), position: new ct(), color: new s.D(s.u.light.color), intensity: new s.D(s.u.light.intensity) }), this._transitionable = new s.x(it, void 0), this.setLight(t), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(t, a = {}) {
            if (!this._validate(s.y, t, a)) for (const d in t) {
              const g = t[d];
              d.endsWith("-transition") ? this._transitionable.setTransition(d.slice(0, -11), g) : this._transitionable.setValue(d, g);
            }
          }
          updateTransitions(t) {
            this._transitioning = this._transitionable.transitioned(t, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t) {
            this.properties = this._transitioning.possiblyEvaluate(t);
          }
          _validate(t, a, d) {
            return (!d || d.validate !== false) && s.z(this, t.call(s.B, { value: a, style: { glyphs: true, sprite: true }, styleSpec: s.u }));
          }
        }
        const $t = new s.t({ "sky-color": new s.D(s.u.sky["sky-color"]), "horizon-color": new s.D(s.u.sky["horizon-color"]), "fog-color": new s.D(s.u.sky["fog-color"]), "fog-ground-blend": new s.D(s.u.sky["fog-ground-blend"]), "horizon-fog-blend": new s.D(s.u.sky["horizon-fog-blend"]), "sky-horizon-blend": new s.D(s.u.sky["sky-horizon-blend"]), "atmosphere-blend": new s.D(s.u.sky["atmosphere-blend"]) });
        class vt extends s.E {
          constructor(t) {
            super(), this._transitionable = new s.x($t, void 0), this.setSky(t), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.G(0));
          }
          setSky(t, a = {}) {
            if (!this._validate(s.H, t, a)) {
              t || (t = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
              for (const d in t) {
                const g = t[d];
                d.endsWith("-transition") ? this._transitionable.setTransition(d.slice(0, -11), g) : this._transitionable.setValue(d, g);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(t) {
            this._transitioning = this._transitionable.transitioned(t, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t) {
            this.properties = this._transitioning.possiblyEvaluate(t);
          }
          _validate(t, a, d = {}) {
            return (d == null ? void 0 : d.validate) !== false && s.z(this, t.call(s.B, s.e({ value: a, style: { glyphs: true, sprite: true }, styleSpec: s.u })));
          }
          calculateFogBlendOpacity(t) {
            return t < 60 ? 0 : t < 70 ? (t - 60) / 10 : 1;
          }
        }
        class Pt {
          constructor(t, a) {
            this.width = t, this.height = a, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(t, a) {
            const d = t.join(",") + String(a);
            return this.dashEntry[d] || (this.dashEntry[d] = this.addDash(t, a)), this.dashEntry[d];
          }
          getDashRanges(t, a, d) {
            const g = [];
            let b = t.length % 2 == 1 ? -t[t.length - 1] * d : 0, w = t[0] * d, T = true;
            g.push({ left: b, right: w, isDash: T, zeroLength: t[0] === 0 });
            let I = t[0];
            for (let R = 1; R < t.length; R++) {
              T = !T;
              const z = t[R];
              b = I * d, I += z, w = I * d, g.push({ left: b, right: w, isDash: T, zeroLength: z === 0 });
            }
            return g;
          }
          addRoundDash(t, a, d) {
            const g = a / 2;
            for (let b = -d; b <= d; b++) {
              const w = this.width * (this.nextRow + d + b);
              let T = 0, I = t[T];
              for (let R = 0; R < this.width; R++) {
                R / I.right > 1 && (I = t[++T]);
                const z = Math.abs(R - I.left), W = Math.abs(R - I.right), U = Math.min(z, W);
                let X;
                const re = b / d * (g + 1);
                if (I.isDash) {
                  const de = g - Math.abs(re);
                  X = Math.sqrt(U * U + de * de);
                } else X = g - Math.sqrt(U * U + re * re);
                this.data[w + R] = Math.max(0, Math.min(255, X + 128));
              }
            }
          }
          addRegularDash(t) {
            for (let T = t.length - 1; T >= 0; --T) {
              const I = t[T], R = t[T + 1];
              I.zeroLength ? t.splice(T, 1) : R && R.isDash === I.isDash && (R.left = I.left, t.splice(T, 1));
            }
            const a = t[0], d = t[t.length - 1];
            a.isDash === d.isDash && (a.left = d.left - this.width, d.right = a.right + this.width);
            const g = this.width * this.nextRow;
            let b = 0, w = t[b];
            for (let T = 0; T < this.width; T++) {
              T / w.right > 1 && (w = t[++b]);
              const I = Math.abs(T - w.left), R = Math.abs(T - w.right), z = Math.min(I, R);
              this.data[g + T] = Math.max(0, Math.min(255, (w.isDash ? z : -z) + 128));
            }
          }
          addDash(t, a) {
            const d = a ? 7 : 0, g = 2 * d + 1;
            if (this.nextRow + g > this.height) return s.w("LineAtlas out of space"), null;
            let b = 0;
            for (let T = 0; T < t.length; T++) b += t[T];
            if (b !== 0) {
              const T = this.width / b, I = this.getDashRanges(t, this.width, T);
              a ? this.addRoundDash(I, T, d) : this.addRegularDash(I);
            }
            const w = { y: this.nextRow + d, height: 2 * d, width: b };
            return this.nextRow += g, this.dirty = true, w;
          }
          bind(t) {
            const a = t.gl;
            this.texture ? (a.bindTexture(a.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, this.width, this.height, a.ALPHA, a.UNSIGNED_BYTE, this.data))) : (this.texture = a.createTexture(), a.bindTexture(a.TEXTURE_2D, this.texture), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.REPEAT), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.REPEAT), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR), a.texImage2D(a.TEXTURE_2D, 0, a.ALPHA, this.width, this.height, 0, a.ALPHA, a.UNSIGNED_BYTE, this.data));
          }
        }
        const Nt = "maplibre_preloaded_worker_pool";
        class ir {
          constructor() {
            this.active = {};
          }
          acquire(t) {
            if (!this.workers) for (this.workers = []; this.workers.length < ir.workerCount; ) this.workers.push(new Worker(s.a.WORKER_URL));
            return this.active[t] = true, this.workers.slice();
          }
          release(t) {
            delete this.active[t], this.numActive() === 0 && (this.workers.forEach(((a) => {
              a.terminate();
            })), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[Nt];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const bt = Math.floor(j.hardwareConcurrency / 2);
        let Dt, Zt;
        function dr() {
          return Dt || (Dt = new ir()), Dt;
        }
        ir.workerCount = s.J(globalThis) ? Math.max(Math.min(bt, 3), 1) : 1;
        class yr {
          constructor(t, a) {
            this.workerPool = t, this.actors = [], this.currentActor = 0, this.id = a;
            const d = this.workerPool.acquire(a);
            for (let g = 0; g < d.length; g++) {
              const b = new s.K(d[g], a);
              b.name = `Worker ${g}`, this.actors.push(b);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(t, a) {
            const d = [];
            for (const g of this.actors) d.push(g.sendAsync({ type: t, data: a }));
            return Promise.all(d);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(t = true) {
            this.actors.forEach(((a) => {
              a.remove();
            })), this.actors = [], t && this.workerPool.release(this.id);
          }
          registerMessageHandler(t, a) {
            for (const d of this.actors) d.registerMessageHandler(t, a);
          }
          unregisterMessageHandler(t) {
            for (const a of this.actors) a.unregisterMessageHandler(t);
          }
        }
        function Pr() {
          return Zt || (Zt = new yr(dr(), s.L), Zt.registerMessageHandler("GR", ((_, t, a) => s.m(t, a)))), Zt;
        }
        function lr(_, t) {
          const a = s.M();
          return s.N(a, a, [1, 1, 0]), s.O(a, a, [0.5 * _.width, 0.5 * _.height, 1]), _.calculatePosMatrix ? s.Q(a, a, _.calculatePosMatrix(t.toUnwrapped())) : a;
        }
        function Ir(_, t, a, d, g, b, w) {
          var T;
          const I = (function(U, X, re) {
            if (U) for (const de of U) {
              const fe = X[de];
              if (fe && fe.source === re && fe.type === "fill-extrusion") return true;
            }
            else for (const de in X) {
              const fe = X[de];
              if (fe.source === re && fe.type === "fill-extrusion") return true;
            }
            return false;
          })((T = g == null ? void 0 : g.layers) !== null && T !== void 0 ? T : null, t, _.id), R = b.maxPitchScaleFactor(), z = _.tilesIn(d, R, I);
          z.sort(Ht);
          const W = [];
          for (const U of z) W.push({ wrappedTileID: U.tileID.wrapped().key, queryResults: U.tile.queryRenderedFeatures(t, a, _.getState(), U.queryGeometry, U.cameraQueryGeometry, U.scale, g, b, R, lr(b, U.tileID), w ? (X, re) => w(U.tileID, X, re) : void 0) });
          return (function(U, X) {
            for (const re in U) for (const de of U[re]) Rr(de, X);
            return U;
          })((function(U) {
            const X = {}, re = {};
            for (const de of U) {
              const fe = de.queryResults, me = de.wrappedTileID, Ce = re[me] = re[me] || {};
              for (const Pe in fe) {
                const xe = fe[Pe], Ie = Ce[Pe] = Ce[Pe] || {}, De = X[Pe] = X[Pe] || [];
                for (const Se of xe) Ie[Se.featureIndex] || (Ie[Se.featureIndex] = true, De.push(Se));
              }
            }
            return X;
          })(W), _);
        }
        function Ht(_, t) {
          const a = _.tileID, d = t.tileID;
          return a.overscaledZ - d.overscaledZ || a.canonical.y - d.canonical.y || a.wrap - d.wrap || a.canonical.x - d.canonical.x;
        }
        function Rr(_, t) {
          const a = _.feature, d = t.getFeatureState(a.layer["source-layer"], a.id);
          a.source = a.layer.source, a.layer["source-layer"] && (a.sourceLayer = a.layer["source-layer"]), a.state = d;
        }
        function xr(_, t, a) {
          return s._(this, void 0, void 0, (function* () {
            let d = _;
            if (_.url ? d = (yield s.j(t.transformRequest(_.url, "Source"), a)).data : yield j.frameAsync(a), !d) return null;
            const g = s.S(s.e(d, _), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in d && d.vector_layers && (g.vectorLayerIds = d.vector_layers.map(((b) => b.id))), g;
          }));
        }
        class gt {
          constructor(t, a) {
            t && (a ? this.setSouthWest(t).setNorthEast(a) : Array.isArray(t) && (t.length === 4 ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1])));
          }
          setNorthEast(t) {
            return this._ne = t instanceof s.U ? new s.U(t.lng, t.lat) : s.U.convert(t), this;
          }
          setSouthWest(t) {
            return this._sw = t instanceof s.U ? new s.U(t.lng, t.lat) : s.U.convert(t), this;
          }
          extend(t) {
            const a = this._sw, d = this._ne;
            let g, b;
            if (t instanceof s.U) g = t, b = t;
            else {
              if (!(t instanceof gt)) return Array.isArray(t) ? t.length === 4 || t.every(Array.isArray) ? this.extend(gt.convert(t)) : this.extend(s.U.convert(t)) : t && ("lng" in t || "lon" in t) && "lat" in t ? this.extend(s.U.convert(t)) : this;
              if (g = t._sw, b = t._ne, !g || !b) return this;
            }
            return a || d ? (a.lng = Math.min(g.lng, a.lng), a.lat = Math.min(g.lat, a.lat), d.lng = Math.max(b.lng, d.lng), d.lat = Math.max(b.lat, d.lat)) : (this._sw = new s.U(g.lng, g.lat), this._ne = new s.U(b.lng, b.lat)), this;
          }
          getCenter() {
            return new s.U((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new s.U(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new s.U(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(t) {
            const { lng: a, lat: d } = s.U.convert(t);
            let g = this._sw.lng <= a && a <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (g = this._sw.lng >= a && a >= this._ne.lng), this._sw.lat <= d && d <= this._ne.lat && g;
          }
          intersects(t) {
            if ((t = gt.convert(t)).getNorth() < this.getSouth() || t.getSouth() > this.getNorth()) return false;
            const a = s.V(this.getWest(), -180, 180), d = s.V(this.getEast(), -180, 180), g = s.V(t.getWest(), -180, 180), b = s.V(t.getEast(), -180, 180), w = a > d, T = g > b;
            return !(!w || !T) || (w ? b >= a || g <= d : T ? d >= g || a <= b : !(g > d || b < a));
          }
          static convert(t) {
            return t instanceof gt ? t : t && new gt(t);
          }
          static fromLngLat(t, a = 0) {
            const d = 360 * a / 40075017, g = d / Math.cos(Math.PI / 180 * t.lat);
            return new gt(new s.U(t.lng - g, t.lat - d), new s.U(t.lng + g, t.lat + d));
          }
          adjustAntiMeridian() {
            const t = new s.U(this._sw.lng, this._sw.lat), a = new s.U(this._ne.lng, this._ne.lat);
            return new gt(t, t.lng > a.lng ? new s.U(a.lng + 360, a.lat) : a);
          }
        }
        class Be {
          constructor(t, a, d) {
            this.bounds = gt.convert(this.validateBounds(t)), this.minzoom = a || 0, this.maxzoom = d || 24;
          }
          validateBounds(t) {
            return Array.isArray(t) && t.length === 4 ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90];
          }
          contains(t) {
            const a = Math.pow(2, t.z), d = Math.floor(s.X(this.bounds.getWest()) * a), g = Math.floor(s.W(this.bounds.getNorth()) * a), b = Math.ceil(s.X(this.bounds.getEast()) * a), w = Math.ceil(s.W(this.bounds.getSouth()) * a);
            return t.x >= d && t.x < b && t.y >= g && t.y < w;
          }
        }
        class ot extends s.E {
          constructor(t, a, d, g) {
            if (super(), this.id = t, this.dispatcher = d, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, s.e(this, s.S(a, ["url", "scheme", "tileSize", "promoteId", "encoding"])), this._options = s.e({ type: "vector" }, a), this._collectResourceTiming = a.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(g);
          }
          load() {
            return s._(this, void 0, void 0, (function* () {
              this._loaded = false, this.fire(new s.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const t = yield xr(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, this.map.style.tileManagers[this.id].clearTiles(), t && (s.e(this, t), t.bounds && (this.tileBounds = new Be(t.bounds, this.minzoom, this.maxzoom)), this.fire(new s.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.l("data", { dataType: "source", sourceDataType: "content" })));
              } catch (t) {
                this._tileJSONRequest = null, this._loaded = true, this.fire(new s.k(t));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          hasTile(t) {
            return !this.tileBounds || this.tileBounds.contains(t.canonical);
          }
          onAdd(t) {
            this.map = t, this.load();
          }
          setSourceProperty(t) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), t(), this.load();
          }
          setTiles(t) {
            return this.setSourceProperty((() => {
              this._options.tiles = t;
            })), this;
          }
          setUrl(t) {
            return this.setSourceProperty((() => {
              this.url = t, this._options.url = t;
            })), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return s.e({}, this._options);
          }
          loadTile(t) {
            return s._(this, void 0, void 0, (function* () {
              const a = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), d = { request: this.map._requestManager.transformRequest(a, "Tile"), uid: t.uid, tileID: t.tileID, zoom: t.tileID.overscaledZ, tileSize: this.tileSize * t.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity, encoding: this.encoding, overzoomParameters: this._getOverzoomParameters(t) };
              d.request.collectResourceTiming = this._collectResourceTiming;
              let g = "RT";
              if (t.actor && t.state !== "expired") {
                if (t.state === "loading") return new Promise(((b, w) => {
                  t.reloadPromise = { resolve: b, reject: w };
                }));
              } else t.actor = this.dispatcher.getActor(), g = "LT";
              t.abortController = new AbortController();
              try {
                const b = yield t.actor.sendAsync({ type: g, data: d }, t.abortController);
                if (delete t.abortController, t.aborted) return;
                this._afterTileLoadWorkerResponse(t, b);
              } catch (b) {
                if (delete t.abortController, t.aborted) return;
                if (b && b.status !== 404) throw b;
                this._afterTileLoadWorkerResponse(t, null);
              }
            }));
          }
          _getOverzoomParameters(t) {
            if (t.tileID.canonical.z <= this.maxzoom || this.map._zoomLevelsToOverscale === void 0) return;
            const a = t.tileID.scaledTo(this.maxzoom).canonical, d = a.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            return { maxZoomTileID: a, overzoomRequest: this.map._requestManager.transformRequest(d, "Tile") };
          }
          _afterTileLoadWorkerResponse(t, a) {
            if (a && a.resourceTiming && (t.resourceTiming = a.resourceTiming), a && this.map._refreshExpiredTiles && t.setExpiryData(a), t.loadVectorData(a, this.map.painter), t.reloadPromise) {
              const d = t.reloadPromise;
              t.reloadPromise = null, this.loadTile(t).then(d.resolve).catch(d.reject);
            }
          }
          abortTile(t) {
            return s._(this, void 0, void 0, (function* () {
              t.abortController && (t.abortController.abort(), delete t.abortController), t.actor && (yield t.actor.sendAsync({ type: "AT", data: { uid: t.uid, type: this.type, source: this.id } }));
            }));
          }
          unloadTile(t) {
            return s._(this, void 0, void 0, (function* () {
              t.unloadVectorData(), t.actor && (yield t.actor.sendAsync({ type: "RMT", data: { uid: t.uid, type: this.type, source: this.id } }));
            }));
          }
          hasTransition() {
            return false;
          }
        }
        class $e extends s.E {
          constructor(t, a, d, g) {
            super(), this.id = t, this.dispatcher = d, this.setEventedParent(g), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = s.e({ type: "raster" }, a), s.e(this, s.S(a, ["url", "scheme", "tileSize"]));
          }
          load() {
            return s._(this, arguments, void 0, (function* (t = false) {
              this._loaded = false, this.fire(new s.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const a = yield xr(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, a && (s.e(this, a), a.bounds && (this.tileBounds = new Be(a.bounds, this.minzoom, this.maxzoom)), this.fire(new s.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: t })));
              } catch (a) {
                this._tileJSONRequest = null, this._loaded = true, this.fire(new s.k(a));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(t) {
            this.map = t, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(t) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), t(), this.load(true);
          }
          setTiles(t) {
            return this.setSourceProperty((() => {
              this._options.tiles = t;
            })), this;
          }
          setUrl(t) {
            return this.setSourceProperty((() => {
              this.url = t, this._options.url = t;
            })), this;
          }
          serialize() {
            return s.e({}, this._options);
          }
          hasTile(t) {
            return !this.tileBounds || this.tileBounds.contains(t.canonical);
          }
          loadTile(t) {
            return s._(this, void 0, void 0, (function* () {
              const a = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              t.abortController = new AbortController();
              try {
                const d = yield ke.getImage(this.map._requestManager.transformRequest(a, "Tile"), t.abortController, this.map._refreshExpiredTiles);
                if (delete t.abortController, t.aborted) return void (t.state = "unloaded");
                if (d && d.data) {
                  this.map._refreshExpiredTiles && (d.cacheControl || d.expires) && t.setExpiryData({ cacheControl: d.cacheControl, expires: d.expires });
                  const g = this.map.painter.context, b = g.gl, w = d.data;
                  t.texture = this.map.painter.getTileTexture(w.width), t.texture ? t.texture.update(w, { useMipmap: true }) : (t.texture = new s.T(g, w, b.RGBA, { useMipmap: true }), t.texture.bind(b.LINEAR, b.CLAMP_TO_EDGE, b.LINEAR_MIPMAP_NEAREST)), t.state = "loaded";
                }
              } catch (d) {
                if (delete t.abortController, t.aborted) t.state = "unloaded";
                else if (d) throw t.state = "errored", d;
              }
            }));
          }
          abortTile(t) {
            return s._(this, void 0, void 0, (function* () {
              t.abortController && (t.abortController.abort(), delete t.abortController);
            }));
          }
          unloadTile(t) {
            return s._(this, void 0, void 0, (function* () {
              t.texture && this.map.painter.saveTileTexture(t.texture);
            }));
          }
          hasTransition() {
            return false;
          }
        }
        class Ye extends $e {
          constructor(t, a, d, g) {
            super(t, a, d, g), this.type = "raster-dem", this.maxzoom = 22, this._options = s.e({ type: "raster-dem" }, a), this.encoding = a.encoding || "mapbox", this.redFactor = a.redFactor, this.greenFactor = a.greenFactor, this.blueFactor = a.blueFactor, this.baseShift = a.baseShift;
          }
          loadTile(t) {
            return s._(this, void 0, void 0, (function* () {
              const a = t.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), d = this.map._requestManager.transformRequest(a, "Tile");
              t.neighboringTiles = this._getNeighboringTiles(t.tileID), t.abortController = new AbortController();
              try {
                const g = yield ke.getImage(d, t.abortController, this.map._refreshExpiredTiles);
                if (delete t.abortController, t.aborted) return void (t.state = "unloaded");
                if (g && g.data) {
                  const b = g.data;
                  this.map._refreshExpiredTiles && (g.cacheControl || g.expires) && t.setExpiryData({ cacheControl: g.cacheControl, expires: g.expires });
                  const w = s.b(b) && s.Y() ? b : yield this.readImageNow(b), T = { type: this.type, uid: t.uid, source: this.id, rawImageData: w, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!t.actor || t.state === "expired") {
                    t.actor = this.dispatcher.getActor();
                    const I = yield t.actor.sendAsync({ type: "LDT", data: T });
                    t.dem = I, t.needsHillshadePrepare = true, t.needsTerrainPrepare = true, t.state = "loaded";
                  }
                }
              } catch (g) {
                if (delete t.abortController, t.aborted) t.state = "unloaded";
                else if (g) throw t.state = "errored", g;
              }
            }));
          }
          readImageNow(t) {
            return s._(this, void 0, void 0, (function* () {
              if (typeof VideoFrame < "u" && s.Z()) {
                const a = t.width + 2, d = t.height + 2;
                try {
                  return new s.R({ width: a, height: d }, yield s.$(t, -1, -1, a, d));
                } catch {
                }
              }
              return j.getImageData(t, 1);
            }));
          }
          _getNeighboringTiles(t) {
            const a = t.canonical, d = Math.pow(2, a.z), g = (a.x - 1 + d) % d, b = a.x === 0 ? t.wrap - 1 : t.wrap, w = (a.x + 1 + d) % d, T = a.x + 1 === d ? t.wrap + 1 : t.wrap, I = {};
            return I[new s.a0(t.overscaledZ, b, a.z, g, a.y).key] = { backfilled: false }, I[new s.a0(t.overscaledZ, T, a.z, w, a.y).key] = { backfilled: false }, a.y > 0 && (I[new s.a0(t.overscaledZ, b, a.z, g, a.y - 1).key] = { backfilled: false }, I[new s.a0(t.overscaledZ, t.wrap, a.z, a.x, a.y - 1).key] = { backfilled: false }, I[new s.a0(t.overscaledZ, T, a.z, w, a.y - 1).key] = { backfilled: false }), a.y + 1 < d && (I[new s.a0(t.overscaledZ, b, a.z, g, a.y + 1).key] = { backfilled: false }, I[new s.a0(t.overscaledZ, t.wrap, a.z, a.x, a.y + 1).key] = { backfilled: false }, I[new s.a0(t.overscaledZ, T, a.z, w, a.y + 1).key] = { backfilled: false }), I;
          }
          unloadTile(t) {
            return s._(this, void 0, void 0, (function* () {
              t.demTexture && this.map.painter.saveTileTexture(t.demTexture), t.fbo && (t.fbo.destroy(), delete t.fbo), t.dem && delete t.dem, delete t.neighboringTiles, t.state = "unloaded", t.actor && (yield t.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: t.uid, source: this.id } }));
            }));
          }
        }
        function ht(_) {
          return _.type === "GeometryCollection" ? _.geometries.map(((t) => t.coordinates)).flat(1 / 0) : _.coordinates.flat(1 / 0);
        }
        function St(_) {
          const t = new gt();
          let a;
          switch (_.type) {
            case "FeatureCollection":
              a = _.features.map(((d) => ht(d.geometry))).flat(1 / 0);
              break;
            case "Feature":
              a = ht(_.geometry);
              break;
            default:
              a = ht(_);
          }
          if (a.length == 0) return t;
          for (let d = 0; d < a.length - 1; d += 2) t.extend([a[d], a[d + 1]]);
          return t;
        }
        class rt extends s.E {
          constructor(t, a, d, g) {
            super(), this.id = t, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._isUpdatingWorker = false, this._pendingWorkerUpdate = { data: a.data }, this.actor = d.getActor(), this.setEventedParent(g), this._data = a.data, this._options = s.e({}, a), this._collectResourceTiming = a.collectResourceTiming, a.maxzoom !== void 0 && (this.maxzoom = a.maxzoom), a.type && (this.type = a.type), a.attribution && (this.attribution = a.attribution), this.promoteId = a.promoteId, a.clusterMaxZoom !== void 0 && this.maxzoom <= a.clusterMaxZoom && s.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${a.clusterMaxZoom}".`), this.workerOptions = s.e({ source: this.id, cluster: a.cluster || false, geojsonVtOptions: { buffer: this._pixelsToTileUnits(a.buffer !== void 0 ? a.buffer : 128), tolerance: this._pixelsToTileUnits(a.tolerance !== void 0 ? a.tolerance : 0.375), extent: s.a3, maxZoom: this.maxzoom, lineMetrics: a.lineMetrics || false, generateId: a.generateId || false }, superclusterOptions: { maxZoom: this._getClusterMaxZoom(a.clusterMaxZoom), minPoints: Math.max(2, a.clusterMinPoints || 2), extent: s.a3, radius: this._pixelsToTileUnits(a.clusterRadius || 50), log: false, generateId: a.generateId || false }, clusterProperties: a.clusterProperties, filter: a.filter }, a.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
          }
          _hasPendingWorkerUpdate() {
            return this._pendingWorkerUpdate.data !== void 0 || this._pendingWorkerUpdate.diff !== void 0 || this._pendingWorkerUpdate.optionsChanged;
          }
          _pixelsToTileUnits(t) {
            return t * (s.a3 / this.tileSize);
          }
          _getClusterMaxZoom(t) {
            const a = t ? Math.round(t) : this.maxzoom - 1;
            return Number.isInteger(t) || t === void 0 || s.w(`Integer expected for option 'clusterMaxZoom': provided value "${t}" rounded to "${a}"`), a;
          }
          load() {
            return s._(this, void 0, void 0, (function* () {
              yield this._updateWorkerData();
            }));
          }
          onAdd(t) {
            this.map = t, this.load();
          }
          setData(t) {
            return this._data = t, this._pendingWorkerUpdate = { data: t }, this._updateWorkerData(), this;
          }
          updateData(t) {
            return this._pendingWorkerUpdate.diff = s.a4(this._pendingWorkerUpdate.diff, t), this._updateWorkerData(), this;
          }
          getData() {
            return s._(this, void 0, void 0, (function* () {
              const t = s.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: "GD", data: t });
            }));
          }
          getBounds() {
            return s._(this, void 0, void 0, (function* () {
              return St(yield this.getData());
            }));
          }
          setClusterOptions(t) {
            return this.workerOptions.cluster = t.cluster, t.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(t.clusterRadius)), t.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(t.clusterMaxZoom)), this._pendingWorkerUpdate.optionsChanged = true, this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(t) {
            return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: t, source: this.id } });
          }
          getClusterChildren(t) {
            return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: t, source: this.id } });
          }
          getClusterLeaves(t, a, d) {
            return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: t, limit: a, offset: d } });
          }
          _updateWorkerData() {
            return s._(this, void 0, void 0, (function* () {
              if (this._isUpdatingWorker) return;
              if (!this._hasPendingWorkerUpdate()) return void s.w(`No pending worker updates for GeoJSONSource ${this.id}.`);
              const { data: t, diff: a } = this._pendingWorkerUpdate, d = s.e({ type: this.type }, this.workerOptions);
              t ? (typeof t == "string" ? (d.request = this.map._requestManager.transformRequest(j.resolveURL(t), "Source"), d.request.collectResourceTiming = this._collectResourceTiming) : d.data = JSON.stringify(t), this._pendingWorkerUpdate.data = void 0) : a && (d.dataDiff = a, this._pendingWorkerUpdate.diff = void 0), this._pendingWorkerUpdate.optionsChanged = void 0, this._isUpdatingWorker = true, this.fire(new s.l("dataloading", { dataType: "source" }));
              try {
                const g = yield this.actor.sendAsync({ type: "LD", data: d });
                if (this._isUpdatingWorker = false, this._removed || g.abandoned) return void this.fire(new s.l("dataabort", { dataType: "source" }));
                this._data = g.data;
                let b = null;
                g.resourceTiming && g.resourceTiming[this.id] && (b = g.resourceTiming[this.id].slice(0));
                const w = { dataType: "source" };
                this._collectResourceTiming && b && b.length > 0 && s.e(w, { resourceTiming: b }), this.fire(new s.l("data", Object.assign(Object.assign({}, w), { sourceDataType: "metadata" }))), this.fire(new s.l("data", Object.assign(Object.assign({}, w), { sourceDataType: "content", shouldReloadTileOptions: this._getShouldReloadTileOptions(a) })));
              } catch (g) {
                if (this._isUpdatingWorker = false, this._removed) return void this.fire(new s.l("dataabort", { dataType: "source" }));
                this.fire(new s.k(g));
              } finally {
                this._hasPendingWorkerUpdate() && this._updateWorkerData();
              }
            }));
          }
          _getShouldReloadTileOptions(t) {
            if (!t || t.removeAll) return;
            const { add: a = [], update: d = [], remove: g = [] } = t || {}, b = /* @__PURE__ */ new Set([...d.map(((w) => w.id)), ...g]);
            return { nextBounds: [...d.map(((w) => w.newGeometry)), ...a.map(((w) => w.geometry))].map(((w) => St(w))), prevIds: b };
          }
          shouldReloadTile(t, { nextBounds: a, prevIds: d }) {
            const g = t.latestFeatureIndex.loadVTLayers();
            for (let I = 0; I < t.latestFeatureIndex.featureIndexArray.length; I++) {
              const R = t.latestFeatureIndex.featureIndexArray.get(I), z = g._geojsonTileLayer.feature(R.featureIndex);
              if (d.has(z.id)) return true;
            }
            const { buffer: b, extent: w } = this.workerOptions.geojsonVtOptions, T = (function({ x: I, y: R, z }, W = 0) {
              const U = s.a1((I - W) / Math.pow(2, z)), X = s.a2((R + 1 + W) / Math.pow(2, z)), re = s.a1((I + 1 + W) / Math.pow(2, z)), de = s.a2((R - W) / Math.pow(2, z));
              return new gt([U, X], [re, de]);
            })(t.tileID.canonical, b / w);
            for (const I of a) if (T.intersects(I)) return true;
            return false;
          }
          loaded() {
            return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate();
          }
          loadTile(t) {
            return s._(this, void 0, void 0, (function* () {
              const a = t.actor ? "RT" : "LT";
              t.actor = this.actor;
              const d = { type: this.type, uid: t.uid, tileID: t.tileID, zoom: t.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
              t.abortController = new AbortController();
              const g = yield this.actor.sendAsync({ type: a, data: d }, t.abortController);
              delete t.abortController, t.unloadVectorData(), t.aborted || t.loadVectorData(g, this.map.painter, a === "RT");
            }));
          }
          abortTile(t) {
            return s._(this, void 0, void 0, (function* () {
              t.abortController && (t.abortController.abort(), delete t.abortController), t.aborted = true;
            }));
          }
          unloadTile(t) {
            return s._(this, void 0, void 0, (function* () {
              t.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: t.uid, type: this.type, source: this.id } });
            }));
          }
          onRemove() {
            this._removed = true, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return s.e({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return false;
          }
        }
        class mt extends s.E {
          constructor(t, a, d, g) {
            super(), this.flippedWindingOrder = false, this.id = t, this.dispatcher = d, this.coordinates = a.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(g), this.options = a;
          }
          load(t) {
            return s._(this, void 0, void 0, (function* () {
              this._loaded = false, this.fire(new s.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const a = yield ke.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = true, a && a.data && (this.image = a.data, t && (this.coordinates = t), this._finishLoading());
              } catch (a) {
                this._request = null, this._loaded = true, this.fire(new s.k(a));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          updateImage(t) {
            return t.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = t.url, this.load(t.coordinates).finally((() => {
              this.texture = null;
            })), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new s.l("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(t) {
            this.map = t, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(t) {
            this.coordinates = t;
            const a = t.map(s.a5.fromLngLat);
            var d;
            return this.tileID = (function(g) {
              const b = s.a6.fromPoints(g), w = b.width(), T = b.height(), I = Math.max(w, T), R = Math.max(0, Math.floor(-Math.log(I) / Math.LN2)), z = Math.pow(2, R);
              return new s.a8(R, Math.floor((b.minX + b.maxX) / 2 * z), Math.floor((b.minY + b.maxY) / 2 * z));
            })(a), this.terrainTileRanges = this._getOverlappingTileRanges(a), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = a.map(((g) => this.tileID.getTilePoint(g)._round())), this.flippedWindingOrder = ((d = this.tileCoords)[1].x - d[0].x) * (d[2].y - d[0].y) - (d[1].y - d[0].y) * (d[2].x - d[0].x) < 0, this.fire(new s.l("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const t = this.map.painter.context, a = t.gl;
            this.texture || (this.texture = new s.T(t, this.image, a.RGBA), this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
            let d = false;
            for (const g in this.tiles) {
              const b = this.tiles[g];
              b.state !== "loaded" && (b.state = "loaded", b.texture = this.texture, d = true);
            }
            d && this.fire(new s.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(t) {
            return s._(this, void 0, void 0, (function* () {
              this.tileID && this.tileID.equals(t.tileID.canonical) ? (this.tiles[String(t.tileID.wrap)] = t, t.buckets = {}) : t.state = "errored";
            }));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return false;
          }
          _getOverlappingTileRanges(t) {
            const { minX: a, minY: d, maxX: g, maxY: b } = s.a6.fromPoints(t), w = {};
            for (let T = 0; T <= s.a7; T++) {
              const I = Math.pow(2, T), R = Math.floor(a * I), z = Math.floor(d * I), W = Math.floor(g * I), U = Math.floor(b * I);
              w[T] = { minTileX: R, minTileY: z, maxTileX: W, maxTileY: U };
            }
            return w;
          }
        }
        class nr extends mt {
          constructor(t, a, d, g) {
            super(t, a, d, g), this.roundZoom = true, this.type = "video", this.options = a;
          }
          load() {
            return s._(this, void 0, void 0, (function* () {
              this._loaded = false;
              const t = this.options;
              this.urls = [];
              for (const a of t.urls) this.urls.push(this.map._requestManager.transformRequest(a, "Source").url);
              try {
                const a = yield s.a9(this.urls);
                if (this._loaded = true, !a) return;
                this.video = a, this.video.loop = true, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint();
                })), this.map && this.video.play(), this._finishLoading();
              } catch (a) {
                this.fire(new s.k(a));
              }
            }));
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(t) {
            if (this.video) {
              const a = this.video.seekable;
              t < a.start(0) || t > a.end(0) ? this.fire(new s.k(new s.aa(`sources.${this.id}`, null, `Playback for this video can be set only between the ${a.start(0)} and ${a.end(0)}-second mark.`))) : this.video.currentTime = t;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(t) {
            this.map || (this.map = t, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const t = this.map.painter.context, a = t.gl;
            this.texture ? this.video.paused || (this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE), a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, a.RGBA, a.UNSIGNED_BYTE, this.video)) : (this.texture = new s.T(t, this.video, a.RGBA), this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
            let d = false;
            for (const g in this.tiles) {
              const b = this.tiles[g];
              b.state !== "loaded" && (b.state = "loaded", b.texture = this.texture, d = true);
            }
            d && this.fire(new s.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class di extends mt {
          constructor(t, a, d, g) {
            super(t, a, d, g), a.coordinates ? Array.isArray(a.coordinates) && a.coordinates.length === 4 && !a.coordinates.some(((b) => !Array.isArray(b) || b.length !== 2 || b.some(((w) => typeof w != "number")))) || this.fire(new s.k(new s.aa(`sources.${t}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new s.k(new s.aa(`sources.${t}`, null, 'missing required property "coordinates"'))), a.animate && typeof a.animate != "boolean" && this.fire(new s.k(new s.aa(`sources.${t}`, null, 'optional "animate" property must be a boolean value'))), a.canvas ? typeof a.canvas == "string" || a.canvas instanceof HTMLCanvasElement || this.fire(new s.k(new s.aa(`sources.${t}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new s.k(new s.aa(`sources.${t}`, null, 'missing required property "canvas"'))), this.options = a, this.animate = a.animate === void 0 || a.animate;
          }
          load() {
            return s._(this, void 0, void 0, (function* () {
              this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new s.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = true, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = false);
              }, this._finishLoading());
            }));
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(t) {
            this.map = t, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let t = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, t = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t = true), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const a = this.map.painter.context, d = a.gl;
            this.texture ? (t || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new s.T(a, this.canvas, d.RGBA, { premultiply: true });
            let g = false;
            for (const b in this.tiles) {
              const w = this.tiles[b];
              w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture, g = true);
            }
            g && this.fire(new s.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", animate: this.animate, canvas: this.options.canvas, coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const t of [this.canvas.width, this.canvas.height]) if (isNaN(t) || t <= 0) return true;
            return false;
          }
        }
        const wi = {}, xn = (_) => {
          switch (_) {
            case "geojson":
              return rt;
            case "image":
              return mt;
            case "raster":
              return $e;
            case "raster-dem":
              return Ye;
            case "vector":
              return ot;
            case "video":
              return nr;
            case "canvas":
              return di;
          }
          return wi[_];
        }, en = "RTLPluginLoaded";
        class wn extends s.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Pr();
          }
          _syncState(t) {
            return this.status = t, this.dispatcher.broadcast("SRPS", { pluginStatus: t, pluginURL: this.url }).catch(((a) => {
              throw this.status = "error", a;
            }));
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null;
          }
          setRTLTextPlugin(t) {
            return s._(this, arguments, void 0, (function* (a, d = false) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = j.resolveURL(a), !this.url) throw new Error(`requested url ${a} is invalid`);
              if (this.status === "unavailable") {
                if (!d) return this._requestImport();
                this.status = "deferred", this._syncState(this.status);
              } else if (this.status === "requested") return this._requestImport();
            }));
          }
          _requestImport() {
            return s._(this, void 0, void 0, (function* () {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new s.l(en));
            }));
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
          }
        }
        let Cn = null;
        function Bi() {
          return Cn || (Cn = new wn()), Cn;
        }
        var Ci, Me;
        (function(_) {
          _[_.Base = 0] = "Base", _[_.Parent = 1] = "Parent";
        })(Ci || (Ci = {})), (function(_) {
          _[_.Departing = 0] = "Departing", _[_.Incoming = 1] = "Incoming";
        })(Me || (Me = {}));
        class $ {
          constructor(t, a) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.fadeOpacity = 1, this.tileID = t, this.uid = s.ab(), this.uses = 0, this.tileSize = a, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          isRenderable(t) {
            return this.hasData() && (!this.fadeEndTime || this.fadeOpacity > 0) && (t || !this.holdingForSymbolFade());
          }
          setCrossFadeLogic({ fadingRole: t, fadingDirection: a, fadingParentID: d, fadeEndTime: g }) {
            this.resetFadeLogic(), this.fadingRole = t, this.fadingDirection = a, this.fadingParentID = d, this.fadeEndTime = g;
          }
          setSelfFadeLogic(t) {
            this.resetFadeLogic(), this.selfFading = true, this.fadeEndTime = t;
          }
          resetFadeLogic() {
            this.fadingRole = null, this.fadingDirection = null, this.fadingParentID = null, this.selfFading = false, this.timeAdded = q(), this.fadeEndTime = 0, this.fadeOpacity = 1;
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
          }
          clearTextures(t) {
            this.demTexture && t.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(t, a, d) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t) {
              t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData, this.latestFeatureIndex.encoding = t.encoding) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData, this.latestFeatureIndex.encoding = this.latestEncoding)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = (function(g, b) {
                const w = {};
                if (!b) return w;
                for (const T of g) {
                  const I = T.layerIds.map(((R) => b.getLayer(R))).filter(Boolean);
                  if (I.length !== 0) {
                    T.layers = I, T.stateDependentLayerIds && (T.stateDependentLayers = T.stateDependentLayerIds.map(((R) => I.filter(((z) => z.id === R))[0])));
                    for (const R of I) w[R.id] = T;
                  }
                }
                return w;
              })(t.buckets, a == null ? void 0 : a.style), this.hasSymbolBuckets = false;
              for (const g in this.buckets) {
                const b = this.buckets[g];
                if (b instanceof s.ad) {
                  if (this.hasSymbolBuckets = true, !d) break;
                  b.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets) for (const g in this.buckets) {
                const b = this.buckets[g];
                if (b instanceof s.ad && b.hasRTLText) {
                  this.hasRTLText = true, Bi().lazyLoad();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const g in this.buckets) {
                const b = this.buckets[g];
                this.queryPadding = Math.max(this.queryPadding, a.style.getLayer(g).queryRadius(b));
              }
              t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage), this.dashPositions = t.dashPositions;
            } else this.collisionBoxArray = new s.ac();
          }
          unloadVectorData() {
            for (const t in this.buckets) this.buckets[t].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(t) {
            return this.buckets[t.id];
          }
          upload(t) {
            for (const d in this.buckets) {
              const g = this.buckets[d];
              g.uploadPending() && g.upload(t);
            }
            const a = t.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new s.T(t, this.imageAtlas.image, a.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new s.T(t, this.glyphAtlasImage, a.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(t) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture);
          }
          queryRenderedFeatures(t, a, d, g, b, w, T, I, R, z, W) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: g, cameraQueryGeometry: b, scale: w, tileSize: this.tileSize, pixelPosMatrix: z, transform: I, params: T, queryPadding: this.queryPadding * R, getElevation: W }, t, a, d) : {};
          }
          querySourceFeatures(t, a) {
            const d = this.latestFeatureIndex;
            if (!d || !d.rawTileData) return;
            const g = d.loadVTLayers(), b = a && a.sourceLayer ? a.sourceLayer : "", w = g._geojsonTileLayer || g[b];
            if (!w) return;
            const T = s.ae(a == null ? void 0 : a.filter, a == null ? void 0 : a.globalState), { z: I, x: R, y: z } = this.tileID.canonical, W = { z: I, x: R, y: z };
            for (let U = 0; U < w.length; U++) {
              const X = w.feature(U);
              if (T.needGeometry) {
                const fe = s.af(X, true);
                if (!T.filter(new s.G(this.tileID.overscaledZ), fe, this.tileID.canonical)) continue;
              } else if (!T.filter(new s.G(this.tileID.overscaledZ), X)) continue;
              const re = d.getId(X, b), de = new s.ag(X, I, R, z, re);
              de.tile = W, t.push(de);
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(t) {
            const a = this.expirationTime;
            if (t.cacheControl) {
              const d = s.ah(t.cacheControl);
              d["max-age"] && (this.expirationTime = Date.now() + 1e3 * d["max-age"]);
            } else t.expires && (this.expirationTime = new Date(t.expires).getTime());
            if (this.expirationTime) {
              const d = Date.now();
              let g = false;
              if (this.expirationTime > d) g = false;
              else if (a) if (this.expirationTime < a) g = true;
              else {
                const b = this.expirationTime - a;
                b ? this.expirationTime = d + Math.max(b, 3e4) : g = true;
              }
              else g = true;
              g ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(t, a) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(t).length === 0) return;
            const d = this.latestFeatureIndex.loadVTLayers();
            for (const g in this.buckets) {
              if (!a.style.hasLayer(g)) continue;
              const b = this.buckets[g], w = b.layers[0].sourceLayer || "_geojsonTileLayer", T = d[w], I = t[w];
              if (!T || !I || Object.keys(I).length === 0) continue;
              b.update(I, T, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
              const R = a && a.style && a.style.getLayer(g);
              R && (this.queryPadding = Math.max(this.queryPadding, R.queryRadius(b)));
            }
          }
          holdingForSymbolFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < q();
          }
          clearSymbolFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setSymbolHoldDuration(t) {
            this.symbolFadeHoldUntil = q() + t;
          }
          setDependencies(t, a) {
            const d = {};
            for (const g of a) d[g] = true;
            this.dependencies[t] = d;
          }
          hasDependency(t, a) {
            for (const d of t) {
              const g = this.dependencies[d];
              if (g) {
                for (const b of a) if (g[b]) return true;
              }
            }
            return false;
          }
        }
        class Z {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(t, a, d) {
            const g = String(a);
            if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][g] = this.stateChanges[t][g] || {}, s.e(this.stateChanges[t][g], d), this.deletedStates[t] === null) {
              this.deletedStates[t] = {};
              for (const b in this.state[t]) b !== g && (this.deletedStates[t][b] = null);
            } else if (this.deletedStates[t] && this.deletedStates[t][g] === null) {
              this.deletedStates[t][g] = {};
              for (const b in this.state[t][g]) d[b] || (this.deletedStates[t][g][b] = null);
            } else for (const b in d) this.deletedStates[t] && this.deletedStates[t][g] && this.deletedStates[t][g][b] === null && delete this.deletedStates[t][g][b];
          }
          removeFeatureState(t, a, d) {
            if (this.deletedStates[t] === null) return;
            const g = String(a);
            if (this.deletedStates[t] = this.deletedStates[t] || {}, d && a !== void 0) this.deletedStates[t][g] !== null && (this.deletedStates[t][g] = this.deletedStates[t][g] || {}, this.deletedStates[t][g][d] = null);
            else if (a !== void 0) if (this.stateChanges[t] && this.stateChanges[t][g]) for (d in this.deletedStates[t][g] = {}, this.stateChanges[t][g]) this.deletedStates[t][g][d] = null;
            else this.deletedStates[t][g] = null;
            else this.deletedStates[t] = null;
          }
          getState(t, a) {
            const d = String(a), g = s.e({}, (this.state[t] || {})[d], (this.stateChanges[t] || {})[d]);
            if (this.deletedStates[t] === null) return {};
            if (this.deletedStates[t]) {
              const b = this.deletedStates[t][a];
              if (b === null) return {};
              for (const w in b) delete g[w];
            }
            return g;
          }
          initializeTileState(t, a) {
            t.setFeatureState(this.state, a);
          }
          coalesceChanges(t, a) {
            const d = {};
            for (const g in this.stateChanges) {
              this.state[g] = this.state[g] || {};
              const b = {};
              for (const w in this.stateChanges[g]) this.state[g][w] || (this.state[g][w] = {}), s.e(this.state[g][w], this.stateChanges[g][w]), b[w] = this.state[g][w];
              d[g] = b;
            }
            for (const g in this.deletedStates) {
              this.state[g] = this.state[g] || {};
              const b = {};
              if (this.deletedStates[g] === null) for (const w in this.state[g]) b[w] = {}, this.state[g][w] = {};
              else for (const w in this.deletedStates[g]) {
                if (this.deletedStates[g][w] === null) this.state[g][w] = {};
                else for (const T of Object.keys(this.deletedStates[g][w])) delete this.state[g][w][T];
                b[w] = this.state[g][w];
              }
              d[g] = d[g] || {}, s.e(d[g], b);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(d).length !== 0) for (const g in t) t[g].setFeatureState(d, a);
          }
        }
        const Q = 89.25;
        function ge(_, t) {
          const a = s.ai(t.lat, -s.aj, s.aj);
          return new s.P(s.X(t.lng) * _, s.W(a) * _);
        }
        function _e(_, t) {
          return new s.a5(t.x / _, t.y / _).toLngLat();
        }
        function Re(_) {
          return _.cameraToCenterDistance * Math.min(0.85 * Math.tan(s.ak(90 - _.pitch)), Math.tan(s.ak(Q - _.pitch)));
        }
        function se(_, t) {
          const a = _.canonical, d = t / s.al(a.z), g = a.x + Math.pow(2, a.z) * _.wrap, b = s.am(new Float64Array(16));
          return s.N(b, b, [g * d, a.y * d, 0]), s.O(b, b, [d / s.a3, d / s.a3, 1]), b;
        }
        function Fe(_, t, a, d, g) {
          const b = s.a5.fromLngLat(_, t), w = g * s.an(1, _.lat), T = w * Math.cos(s.ak(a)), I = Math.sqrt(w * w - T * T), R = I * Math.sin(s.ak(-d)), z = I * Math.cos(s.ak(-d));
          return new s.a5(b.x + R, b.y + z, b.z + T);
        }
        function We(_, t, a) {
          const d = t.intersectsFrustum(_);
          if (!a || d === 0) return d;
          const g = t.intersectsPlane(a);
          return g === 0 ? 0 : d === 2 && g === 2 ? 2 : 1;
        }
        function Qe(_, t, a) {
          let d = 0;
          const g = (a - t) / 10;
          for (let b = 0; b < 10; b++) d += g * Math.pow(Math.cos(t + (b + 0.5) / 10 * (a - t)), _);
          return d;
        }
        function tt(_, t) {
          return function(a, d, g, b, w) {
            const T = 2 * ((_ - 1) / s.ao(Math.cos(s.ak(Q - w)) / Math.cos(s.ak(Q))) - 1), I = Math.acos(g / b), R = 2 * Qe(T - 1, 0, s.ak(w / 2)), z = Math.min(s.ak(Q), I + s.ak(w / 2)), W = Qe(T - 1, Math.min(z, I - s.ak(w / 2)), z), U = Math.atan(d / g), X = Math.hypot(d, g);
            let re = a;
            return re += s.ao(b / X / Math.max(0.5, Math.cos(s.ak(w / 2)))), re += T * s.ao(Math.cos(U)) / 2, re -= s.ao(Math.max(1, W / R / t)) / 2, re;
          };
        }
        const At = tt(9.314, 3);
        function qt(_, t) {
          const a = (t.roundZoom ? Math.round : Math.floor)(_.zoom + s.ao(_.tileSize / t.tileSize));
          return Math.max(0, a);
        }
        function sr(_, t) {
          const a = _.getCameraFrustum(), d = _.getClippingPlane(), g = _.screenPointToMercatorCoordinate(_.getCameraPoint()), b = s.a5.fromLngLat(_.center, _.elevation);
          g.z = b.z + Math.cos(_.pitchInRadians) * _.cameraToCenterDistance / _.worldSize;
          const w = _.getCoveringTilesDetailsProvider(), T = w.allowVariableZoom(_, t), I = qt(_, t), R = t.minzoom || 0, z = t.maxzoom !== void 0 ? t.maxzoom : _.maxZoom, W = Math.min(Math.max(0, I), z), U = Math.pow(2, W), X = [U * g.x, U * g.y, 0], re = [U * b.x, U * b.y, 0], de = Math.hypot(b.x - g.x, b.y - g.y), fe = Math.abs(b.z - g.z), me = Math.hypot(de, fe), Ce = (Ie) => ({ zoom: 0, x: 0, y: 0, wrap: Ie, fullyVisible: false }), Pe = [], xe = [];
          if (_.renderWorldCopies && w.allowWorldCopies()) for (let Ie = 1; Ie <= 3; Ie++) Pe.push(Ce(-Ie)), Pe.push(Ce(Ie));
          for (Pe.push(Ce(0)); Pe.length > 0; ) {
            const Ie = Pe.pop(), De = Ie.x, Se = Ie.y;
            let Ne = Ie.fullyVisible;
            const Ke = { x: De, y: Se, z: Ie.zoom }, Ze = w.getTileBoundingVolume(Ke, Ie.wrap, _.elevation, t);
            if (!Ne) {
              const It = We(a, Ze, d);
              if (It === 0) continue;
              Ne = It === 2;
            }
            const He = w.distanceToTile2d(g.x, g.y, Ke, Ze);
            let Je = I;
            T && (Je = (t.calculateTileZoom || At)(_.zoom + s.ao(_.tileSize / t.tileSize), He, fe, me, _.fov)), Je = (t.roundZoom ? Math.round : Math.floor)(Je), Je = Math.max(0, Je);
            const Tt = Math.min(Je, z);
            if (Ie.wrap = w.getWrap(b, Ke, Ie.wrap), Ie.zoom >= Tt) {
              if (Ie.zoom < R) continue;
              const It = W - Ie.zoom, _t = X[0] - 0.5 - (De << It), Gt = X[1] - 0.5 - (Se << It), Yt = t.reparseOverscaled ? Math.max(Ie.zoom, Je) : Ie.zoom;
              xe.push({ tileID: new s.a0(Ie.zoom === z ? Yt : Ie.zoom, Ie.wrap, Ie.zoom, De, Se), distanceSq: s.ap([re[0] - 0.5 - De, re[1] - 0.5 - Se]), tileDistanceToCamera: Math.sqrt(_t * _t + Gt * Gt) });
            } else for (let It = 0; It < 4; It++) Pe.push({ zoom: Ie.zoom + 1, x: (De << 1) + It % 2, y: (Se << 1) + (It >> 1), wrap: Ie.wrap, fullyVisible: Ne });
          }
          return xe.sort(((Ie, De) => Ie.distanceSq - De.distanceSq)).map(((Ie) => Ie.tileID));
        }
        const Ur = s.a6.fromPoints([new s.P(0, 0), new s.P(s.a3, s.a3)]);
        class mr extends s.E {
          constructor(t, a, d) {
            super(), this.id = t, this.dispatcher = d, this.on("data", ((g) => this._dataHandler(g))), this.on("dataloading", (() => {
              this._sourceErrored = false;
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded();
            })), this._source = ((g, b, w, T) => {
              const I = new (xn(b.type))(g, b, w, T);
              if (I.id !== g) throw new Error(`Expected Source id to be ${g} instead of ${I.id}`);
              return I;
            })(t, a, d, this), this._tiles = {}, this._cache = new s.aq(0, ((g) => this._unloadTile(g))), this._timers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._rasterFadeDuration = 0, this._maxFadingAncestorLevels = 5, this._state = new Z(), this._didEmitContent = false, this._updated = false;
          }
          onAdd(t) {
            this.map = t, this._maxTileCacheSize = t ? t._maxTileCacheSize : null, this._maxTileCacheZoomLevels = t ? t._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(t);
          }
          onRemove(t) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t);
          }
          loaded() {
            if (this._sourceErrored) return true;
            if (!this._sourceLoaded || !this._source.loaded()) return false;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return true;
            if (!this._updated) return false;
            for (const t in this._tiles) {
              const a = this._tiles[t];
              if (a.state !== "loaded" && a.state !== "errored") return false;
            }
            return true;
          }
          getSource() {
            return this._source;
          }
          getState() {
            return this._state;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused) return;
            const t = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, t && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(t, a, d) {
            return s._(this, void 0, void 0, (function* () {
              try {
                yield this._source.loadTile(t), this._tileLoaded(t, a, d);
              } catch (g) {
                t.state = "errored", g.status !== 404 ? this._source.fire(new s.k(g, { tile: t })) : this.update(this.transform, this.terrain);
              }
            }));
          }
          _unloadTile(t) {
            this._source.unloadTile && this._source.unloadTile(t);
          }
          _abortTile(t) {
            this._source.abortTile && this._source.abortTile(t), this._source.fire(new s.l("dataabort", { tile: t, coord: t.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(t) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const a in this._tiles) {
              const d = this._tiles[a];
              d.upload(t), d.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map(((t) => t.tileID)).sort(Sr).map(((t) => t.key));
          }
          getRenderableIds(t) {
            const a = [];
            for (const d in this._tiles) this._isIdRenderable(d, t) && a.push(this._tiles[d]);
            return t ? a.sort(((d, g) => {
              const b = d.tileID, w = g.tileID, T = new s.P(b.canonical.x, b.canonical.y)._rotate(-this.transform.bearingInRadians), I = new s.P(w.canonical.x, w.canonical.y)._rotate(-this.transform.bearingInRadians);
              return b.overscaledZ - w.overscaledZ || I.y - T.y || I.x - T.x;
            })).map(((d) => d.tileID.key)) : a.map(((d) => d.tileID)).sort(Sr).map(((d) => d.key));
          }
          hasRenderableParent(t) {
            const a = t.overscaledZ - 1;
            if (a >= this._source.minzoom) {
              const d = this.getLoadedTile(t.scaledTo(a));
              if (d) return this._isIdRenderable(d.tileID.key);
            }
            return false;
          }
          _isIdRenderable(t, a = false) {
            var d;
            return (d = this._tiles[t]) === null || d === void 0 ? void 0 : d.isRenderable(a);
          }
          reload(t, a = void 0) {
            if (this._paused) this._shouldReloadOnResume = true;
            else {
              this._cache.reset();
              for (const d in this._tiles) a && this._source.shouldReloadTile && !this._source.shouldReloadTile(this._tiles[d], a) || (t ? this._reloadTile(d, "expired") : this._tiles[d].state !== "errored" && this._reloadTile(d, "reloading"));
            }
          }
          _reloadTile(t, a) {
            return s._(this, void 0, void 0, (function* () {
              const d = this._tiles[t];
              d && (d.state !== "loading" && (d.state = a), yield this._loadTile(d, t, a));
            }));
          }
          _tileLoaded(t, a, d) {
            t.timeAdded = q(), t.selfFading && (t.fadeEndTime = t.timeAdded + this._rasterFadeDuration), d === "expired" && (t.refreshedUponExpiration = true), this._setTileReloadTimer(a, t), this.getSource().type === "raster-dem" && t.dem && this._backfillDEM(t), this._state.initializeTileState(t, this.map ? this.map.painter : null), t.aborted || this._source.fire(new s.l("data", { dataType: "source", tile: t, coord: t.tileID }));
          }
          _backfillDEM(t) {
            const a = this.getRenderableIds();
            for (let g = 0; g < a.length; g++) {
              const b = a[g];
              if (t.neighboringTiles && t.neighboringTiles[b]) {
                const w = this.getTileByID(b);
                d(t, w), d(w, t);
              }
            }
            function d(g, b) {
              g.needsHillshadePrepare = true, g.needsTerrainPrepare = true;
              let w = b.tileID.canonical.x - g.tileID.canonical.x;
              const T = b.tileID.canonical.y - g.tileID.canonical.y, I = Math.pow(2, g.tileID.canonical.z), R = b.tileID.key;
              w === 0 && T === 0 || Math.abs(T) > 1 || (Math.abs(w) > 1 && (Math.abs(w + I) === 1 ? w += I : Math.abs(w - I) === 1 && (w -= I)), b.dem && g.dem && (g.dem.backfillBorder(b.dem, w, T), g.neighboringTiles && g.neighboringTiles[R] && (g.neighboringTiles[R].backfilled = true)));
            }
          }
          getTile(t) {
            return this.getTileByID(t.key);
          }
          getTileByID(t) {
            return this._tiles[t];
          }
          _retainLoadedChildren(t, a) {
            const d = Object.values(t), g = this._getLoadedDescendents(d), b = {};
            for (const w of d) {
              const T = g[w.key];
              if (!(T == null ? void 0 : T.length)) {
                b[w.key] = w;
                continue;
              }
              const I = w.overscaledZ + mr.maxUnderzooming, R = T.filter(((U) => U.tileID.overscaledZ <= I));
              if (!R.length) {
                b[w.key] = w;
                continue;
              }
              const z = Math.min(...R.map(((U) => U.tileID.overscaledZ))), W = R.filter(((U) => U.tileID.overscaledZ === z)).map(((U) => U.tileID));
              for (const U of W) a[U.key] = U;
              this._areDescendentsComplete(W, z, w.overscaledZ) || (b[w.key] = w);
            }
            return b;
          }
          _getLoadedDescendents(t) {
            var a;
            const d = {};
            for (const g in this._tiles) {
              const b = this._tiles[g];
              if (b.hasData()) for (const w of t) b.tileID.isChildOf(w) && (d[a = w.key] || (d[a] = [])).push(b);
            }
            return d;
          }
          _areDescendentsComplete(t, a, d) {
            return t.length === 1 && t[0].isOverscaled() ? t[0].overscaledZ === a : Math.pow(4, a - d) === t.length;
          }
          getLoadedTile(t) {
            const a = this._tiles[t.key];
            return (a == null ? void 0 : a.hasData()) ? a : null;
          }
          updateCacheSize(t) {
            const a = Math.ceil(t.width / this._source.tileSize) + 1, d = Math.ceil(t.height / this._source.tileSize) + 1, g = Math.floor(a * d * (this._maxTileCacheZoomLevels === null ? s.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), b = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, g) : g;
            this._cache.setMaxSize(b);
          }
          handleWrapJump(t) {
            const a = Math.round((t - (this._prevLng === void 0 ? t : this._prevLng)) / 360);
            if (this._prevLng = t, a) {
              const d = {};
              for (const g in this._tiles) {
                const b = this._tiles[g];
                b.tileID = b.tileID.unwrapTo(b.tileID.wrap + a), d[b.tileID.key] = b;
              }
              this._tiles = d, this._resetTileReloadTimers();
            }
          }
          update(t, a) {
            if (!this._sourceLoaded || this._paused) return;
            let d;
            this.transform = t, this.terrain = a, this.updateCacheSize(t), this.handleWrapJump(this.transform.center.lng), this.used || this.usedForTerrain ? this._source.tileID ? d = t.getVisibleUnwrappedCoordinates(this._source.tileID).map(((I) => new s.a0(I.canonical.z, I.wrap, I.canonical.z, I.canonical.x, I.canonical.y))) : (d = sr(t, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.type === "vector" && this.map._zoomLevelsToOverscale !== void 0 ? t.maxZoom - this.map._zoomLevelsToOverscale : this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: a, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (d = d.filter(((I) => this._source.hasTile(I))))) : d = [], this.usedForTerrain && (d = this._addTerrainIdealTiles(d));
            const g = d.length === 0 && !this._updated && this._didEmitContent;
            this._updated = true, g && this.fire(new s.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const b = qt(t, this._source), w = this._updateRetainedTiles(d, b), T = Dr(this._source.type);
            T && this._rasterFadeDuration > 0 && !a && this._updateFadingTiles(d, w), T ? this._cleanUpRasterTiles(w) : this._cleanUpVectorTiles(w);
          }
          _cleanUpRasterTiles(t) {
            for (const a in this._tiles) t[a] || this._removeTile(a);
          }
          _cleanUpVectorTiles(t) {
            for (const a in this._tiles) {
              const d = this._tiles[a];
              t[a] ? d.clearSymbolFadeHold() : d.hasSymbolBuckets ? d.holdingForSymbolFade() ? d.symbolFadeFinished() && this._removeTile(a) : d.setSymbolHoldDuration(this.map._fadeDuration) : this._removeTile(a);
            }
          }
          _addTerrainIdealTiles(t) {
            const a = [];
            for (const d of t) if (d.canonical.z > this._source.minzoom) {
              const g = d.scaledTo(d.canonical.z - 1);
              a.push(g);
              const b = d.scaledTo(Math.max(this._source.minzoom, Math.min(d.canonical.z, 5)));
              a.push(b);
            }
            return t.concat(a);
          }
          releaseSymbolFadeTiles() {
            for (const t in this._tiles) this._tiles[t].holdingForSymbolFade() && this._removeTile(t);
          }
          _updateRetainedTiles(t, a) {
            var d;
            const g = {}, b = {}, w = Math.max(a - mr.maxOverzooming, this._source.minzoom);
            let T = {};
            for (const I of t) {
              const R = this._addTile(I);
              g[I.key] = I, R.hasData() || (T[I.key] = I);
            }
            T = this._retainLoadedChildren(T, g);
            for (const I in T) {
              const R = T[I];
              let z = this._tiles[I], W = z == null ? void 0 : z.wasRequested();
              for (let U = R.overscaledZ - 1; U >= w; --U) {
                const X = R.scaledTo(U);
                if (b[X.key]) break;
                if (b[X.key] = true, z = this.getTile(X), !z && W && (z = this._addTile(X)), z) {
                  const re = z.hasData();
                  if ((re || !(!((d = this.map) === null || d === void 0) && d.cancelPendingTileRequestsWhileZooming) || W) && (g[X.key] = X), W = z.wasRequested(), re) break;
                }
              }
            }
            return g;
          }
          _updateFadingTiles(t, a) {
            const d = q(), g = s.ar(t);
            for (const b of t) {
              const w = this._tiles[b.key];
              w.fadingDirection !== Me.Departing && w.fadeOpacity !== 0 || w.resetFadeLogic(), this._updateFadingAncestor(w, a, d) || this._updateFadingDescendents(w, a, d) || this._updateFadingEdge(w, g, d) || w.resetFadeLogic();
            }
          }
          _updateFadingAncestor(t, a, d) {
            if (!t.hasData()) return false;
            const { tileID: g, fadingRole: b, fadingDirection: w, fadingParentID: T } = t;
            if (b === Ci.Base && w === Me.Incoming && T) return a[T.key] = T, true;
            const I = Math.max(g.overscaledZ - this._maxFadingAncestorLevels, this._source.minzoom);
            for (let R = g.overscaledZ - 1; R >= I; R--) {
              const z = g.scaledTo(R), W = this.getLoadedTile(z);
              if (W) return t.setCrossFadeLogic({ fadingRole: Ci.Base, fadingDirection: Me.Incoming, fadingParentID: W.tileID, fadeEndTime: d + this._rasterFadeDuration }), W.setCrossFadeLogic({ fadingRole: Ci.Parent, fadingDirection: Me.Departing, fadeEndTime: d + this._rasterFadeDuration }), a[z.key] = z, true;
            }
            return false;
          }
          _updateFadingDescendents(t, a, d) {
            if (!t.hasData()) return false;
            const g = t.tileID.children(this._source.maxzoom);
            let b = this._updateFadingChildren(t, g, a, d);
            if (b) return true;
            for (const w of g) {
              const T = w.children(this._source.maxzoom);
              this._updateFadingChildren(t, T, a, d) && (b = true);
            }
            return b;
          }
          _updateFadingChildren(t, a, d, g) {
            if (a[0].overscaledZ >= this._source.maxzoom) return false;
            let b = false;
            for (const w of a) {
              const T = this.getLoadedTile(w);
              if (!T) continue;
              const { fadingRole: I, fadingDirection: R, fadingParentID: z } = T;
              I === Ci.Base && R === Me.Departing && z || (T.setCrossFadeLogic({ fadingRole: Ci.Base, fadingDirection: Me.Departing, fadingParentID: t.tileID, fadeEndTime: g + this._rasterFadeDuration }), t.setCrossFadeLogic({ fadingRole: Ci.Parent, fadingDirection: Me.Incoming, fadeEndTime: g + this._rasterFadeDuration })), d[w.key] = w, b = true;
            }
            return b;
          }
          _updateFadingEdge(t, a, d) {
            const g = t.tileID;
            return !!t.selfFading || !t.hasData() && !!a.has(g) && (t.setSelfFadeLogic(d + this._rasterFadeDuration), true);
          }
          _addTile(t) {
            let a = this._tiles[t.key];
            if (a) return a;
            a = this._cache.getAndRemove(t), a && (a.resetFadeLogic(), this._setTileReloadTimer(t.key, a), a.tileID = t, this._state.initializeTileState(a, this.map ? this.map.painter : null));
            const d = a;
            return a || (a = new $(t, this._source.tileSize * t.overscaleFactor()), this._loadTile(a, t.key, a.state)), a.uses++, this._tiles[t.key] = a, d || this._source.fire(new s.l("dataloading", { tile: a, coord: a.tileID, dataType: "source" })), a;
          }
          _setTileReloadTimer(t, a) {
            this._clearTileReloadTimer(t);
            const d = a.getExpiryTimeout();
            d && (this._timers[t] = setTimeout((() => {
              this._reloadTile(t, "expired"), delete this._timers[t];
            }), d));
          }
          _clearTileReloadTimer(t) {
            const a = this._timers[t];
            a && (clearTimeout(a), delete this._timers[t]);
          }
          _resetTileReloadTimers() {
            for (const t in this._timers) clearTimeout(this._timers[t]), delete this._timers[t];
            for (const t in this._tiles) this._setTileReloadTimer(t, this._tiles[t]);
          }
          refreshTiles(t) {
            for (const a in this._tiles) (this._isIdRenderable(a) || this._tiles[a].state == "errored") && t.some(((d) => d.equals(this._tiles[a].tileID.canonical))) && this._reloadTile(a, "expired");
          }
          _removeTile(t) {
            const a = this._tiles[t];
            a && (a.uses--, delete this._tiles[t], this._clearTileReloadTimer(t), a.uses > 0 || (a.hasData() && a.state !== "reloading" ? this._cache.add(a.tileID, a, a.getExpiryTimeout()) : (a.aborted = true, this._abortTile(a), this._unloadTile(a))));
          }
          _dataHandler(t) {
            t.dataType === "source" && (t.sourceDataType !== "metadata" ? t.sourceDataType === "content" && this._sourceLoaded && !this._paused && (this.reload(t.sourceDataChanged, t.shouldReloadTileOptions), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true) : this._sourceLoaded = true);
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const t in this._tiles) this._removeTile(t);
            this._cache.reset();
          }
          tilesIn(t, a, d) {
            const g = [], b = this.transform;
            if (!b) return g;
            const w = b.getCoveringTilesDetailsProvider().allowWorldCopies(), T = d ? b.getCameraQueryGeometry(t) : t, I = (X) => b.screenPointToMercatorCoordinate(X, this.terrain), R = this.transformBbox(t, I, !w), z = this.transformBbox(T, I, !w), W = this.getIds(), U = s.a6.fromPoints(z);
            for (let X = 0; X < W.length; X++) {
              const re = this._tiles[W[X]];
              if (re.holdingForSymbolFade()) continue;
              const de = w ? [re.tileID] : [re.tileID.unwrapTo(-1), re.tileID.unwrapTo(0)], fe = Math.pow(2, b.zoom - re.tileID.overscaledZ), me = a * re.queryPadding * s.a3 / re.tileSize / fe;
              for (const Ce of de) {
                const Pe = U.map(((xe) => Ce.getTilePoint(new s.a5(xe.x, xe.y))));
                if (Pe.expandBy(me), Pe.intersects(Ur)) {
                  const xe = R.map(((De) => Ce.getTilePoint(De))), Ie = z.map(((De) => Ce.getTilePoint(De)));
                  g.push({ tile: re, tileID: w ? Ce : Ce.unwrapTo(0), queryGeometry: xe, cameraQueryGeometry: Ie, scale: fe });
                }
              }
            }
            return g;
          }
          transformBbox(t, a, d) {
            let g = t.map(a);
            if (d) {
              const b = s.a6.fromPoints(t);
              b.shrinkBy(1e-3 * Math.min(b.width(), b.height()));
              const w = b.map(a);
              s.a6.fromPoints(g).covers(w) || (g = g.map(((T) => T.x > 0.5 ? new s.a5(T.x - 1, T.y, T.z) : T)));
            }
            return g;
          }
          getVisibleCoordinates(t) {
            const a = this.getRenderableIds(t).map(((d) => this._tiles[d].tileID));
            return this.transform && this.transform.populateCache(a), a;
          }
          hasTransition() {
            if (this._source.hasTransition()) return true;
            if (Dr(this._source.type) && this._rasterFadeDuration > 0) {
              const t = q();
              for (const a in this._tiles) if (this._tiles[a].fadeEndTime >= t) return true;
            }
            return false;
          }
          setRasterFadeDuration(t) {
            this._rasterFadeDuration = t;
          }
          setFeatureState(t, a, d) {
            this._state.updateState(t = t || "_geojsonTileLayer", a, d);
          }
          removeFeatureState(t, a, d) {
            this._state.removeFeatureState(t = t || "_geojsonTileLayer", a, d);
          }
          getFeatureState(t, a) {
            return this._state.getState(t = t || "_geojsonTileLayer", a);
          }
          setDependencies(t, a, d) {
            const g = this._tiles[t];
            g && g.setDependencies(a, d);
          }
          reloadTilesForDependencies(t, a) {
            for (const d in this._tiles) this._tiles[d].hasDependency(t, a) && this._reloadTile(d, "reloading");
            this._cache.filter(((d) => !d.hasDependency(t, a)));
          }
        }
        function Sr(_, t) {
          const a = Math.abs(2 * _.wrap) - +(_.wrap < 0), d = Math.abs(2 * t.wrap) - +(t.wrap < 0);
          return _.overscaledZ - t.overscaledZ || d - a || t.canonical.y - _.canonical.y || t.canonical.x - _.canonical.x;
        }
        function Dr(_) {
          return _ === "raster" || _ === "image" || _ === "video";
        }
        mr.maxOverzooming = 10, mr.maxUnderzooming = 3;
        class ye {
          constructor(t, a) {
            this.reset(t, a);
          }
          reset(t, a) {
            this.points = t || [], this._distances = [0];
            for (let d = 1; d < this.points.length; d++) this._distances[d] = this._distances[d - 1] + this.points[d].dist(this.points[d - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(a || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(t) {
            if (this.points.length === 1) return this.points[0];
            t = s.ai(t, 0, 1);
            let a = 1, d = this._distances[a];
            const g = t * this.paddedLength + this.padding;
            for (; d < g && a < this._distances.length; ) d = this._distances[++a];
            const b = a - 1, w = this._distances[b], T = d - w, I = T > 0 ? (g - w) / T : 0;
            return this.points[b].mult(1 - I).add(this.points[a].mult(I));
          }
        }
        function at(_, t) {
          let a = true;
          return _ === "always" || _ !== "never" && t !== "never" || (a = false), a;
        }
        class Ft {
          constructor(t, a, d) {
            const g = this.boxCells = [], b = this.circleCells = [];
            this.xCellCount = Math.ceil(t / d), this.yCellCount = Math.ceil(a / d);
            for (let w = 0; w < this.xCellCount * this.yCellCount; w++) g.push([]), b.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t, this.height = a, this.xScale = this.xCellCount / t, this.yScale = this.yCellCount / a, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(t, a, d, g, b) {
            this._forEachCell(a, d, g, b, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(a), this.bboxes.push(d), this.bboxes.push(g), this.bboxes.push(b);
          }
          insertCircle(t, a, d, g) {
            this._forEachCell(a - g, d - g, a + g, d + g, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t), this.circles.push(a), this.circles.push(d), this.circles.push(g);
          }
          _insertBoxCell(t, a, d, g, b, w) {
            this.boxCells[b].push(w);
          }
          _insertCircleCell(t, a, d, g, b, w) {
            this.circleCells[b].push(w);
          }
          _query(t, a, d, g, b, w, T) {
            if (d < 0 || t > this.width || g < 0 || a > this.height) return [];
            const I = [];
            if (t <= 0 && a <= 0 && this.width <= d && this.height <= g) {
              if (b) return [{ key: null, x1: t, y1: a, x2: d, y2: g }];
              for (let R = 0; R < this.boxKeys.length; R++) I.push({ key: this.boxKeys[R], x1: this.bboxes[4 * R], y1: this.bboxes[4 * R + 1], x2: this.bboxes[4 * R + 2], y2: this.bboxes[4 * R + 3] });
              for (let R = 0; R < this.circleKeys.length; R++) {
                const z = this.circles[3 * R], W = this.circles[3 * R + 1], U = this.circles[3 * R + 2];
                I.push({ key: this.circleKeys[R], x1: z - U, y1: W - U, x2: z + U, y2: W + U });
              }
            } else this._forEachCell(t, a, d, g, this._queryCell, I, { hitTest: b, overlapMode: w, seenUids: { box: {}, circle: {} } }, T);
            return I;
          }
          query(t, a, d, g) {
            return this._query(t, a, d, g, false, null);
          }
          hitTest(t, a, d, g, b, w) {
            return this._query(t, a, d, g, true, b, w).length > 0;
          }
          hitTestCircle(t, a, d, g, b) {
            const w = t - d, T = t + d, I = a - d, R = a + d;
            if (T < 0 || w > this.width || R < 0 || I > this.height) return false;
            const z = [];
            return this._forEachCell(w, I, T, R, this._queryCellCircle, z, { hitTest: true, overlapMode: g, circle: { x: t, y: a, radius: d }, seenUids: { box: {}, circle: {} } }, b), z.length > 0;
          }
          _queryCell(t, a, d, g, b, w, T, I) {
            const { seenUids: R, hitTest: z, overlapMode: W } = T, U = this.boxCells[b];
            if (U !== null) {
              const re = this.bboxes;
              for (const de of U) if (!R.box[de]) {
                R.box[de] = true;
                const fe = 4 * de, me = this.boxKeys[de];
                if (t <= re[fe + 2] && a <= re[fe + 3] && d >= re[fe + 0] && g >= re[fe + 1] && (!I || I(me)) && (!z || !at(W, me.overlapMode)) && (w.push({ key: me, x1: re[fe], y1: re[fe + 1], x2: re[fe + 2], y2: re[fe + 3] }), z)) return true;
              }
            }
            const X = this.circleCells[b];
            if (X !== null) {
              const re = this.circles;
              for (const de of X) if (!R.circle[de]) {
                R.circle[de] = true;
                const fe = 3 * de, me = this.circleKeys[de];
                if (this._circleAndRectCollide(re[fe], re[fe + 1], re[fe + 2], t, a, d, g) && (!I || I(me)) && (!z || !at(W, me.overlapMode))) {
                  const Ce = re[fe], Pe = re[fe + 1], xe = re[fe + 2];
                  if (w.push({ key: me, x1: Ce - xe, y1: Pe - xe, x2: Ce + xe, y2: Pe + xe }), z) return true;
                }
              }
            }
            return false;
          }
          _queryCellCircle(t, a, d, g, b, w, T, I) {
            const { circle: R, seenUids: z, overlapMode: W } = T, U = this.boxCells[b];
            if (U !== null) {
              const re = this.bboxes;
              for (const de of U) if (!z.box[de]) {
                z.box[de] = true;
                const fe = 4 * de, me = this.boxKeys[de];
                if (this._circleAndRectCollide(R.x, R.y, R.radius, re[fe + 0], re[fe + 1], re[fe + 2], re[fe + 3]) && (!I || I(me)) && !at(W, me.overlapMode)) return w.push(true), true;
              }
            }
            const X = this.circleCells[b];
            if (X !== null) {
              const re = this.circles;
              for (const de of X) if (!z.circle[de]) {
                z.circle[de] = true;
                const fe = 3 * de, me = this.circleKeys[de];
                if (this._circlesCollide(re[fe], re[fe + 1], re[fe + 2], R.x, R.y, R.radius) && (!I || I(me)) && !at(W, me.overlapMode)) return w.push(true), true;
              }
            }
          }
          _forEachCell(t, a, d, g, b, w, T, I) {
            const R = this._convertToXCellCoord(t), z = this._convertToYCellCoord(a), W = this._convertToXCellCoord(d), U = this._convertToYCellCoord(g);
            for (let X = R; X <= W; X++) for (let re = z; re <= U; re++) if (b.call(this, t, a, d, g, this.xCellCount * re + X, w, T, I)) return;
          }
          _convertToXCellCoord(t) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)));
          }
          _convertToYCellCoord(t) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)));
          }
          _circlesCollide(t, a, d, g, b, w) {
            const T = g - t, I = b - a, R = d + w;
            return R * R > T * T + I * I;
          }
          _circleAndRectCollide(t, a, d, g, b, w, T) {
            const I = (w - g) / 2, R = Math.abs(t - (g + I));
            if (R > I + d) return false;
            const z = (T - b) / 2, W = Math.abs(a - (b + z));
            if (W > z + d) return false;
            if (R <= I || W <= z) return true;
            const U = R - I, X = W - z;
            return U * U + X * X <= d * d;
          }
        }
        function hr(_, t, a) {
          const d = s.M();
          if (!_) {
            const { vecSouth: W, vecEast: U } = st(t), X = P();
            X[0] = U[0], X[1] = U[1], X[2] = W[0], X[3] = W[1], g = X, (z = (w = (b = X)[0]) * (R = b[3]) - (I = b[2]) * (T = b[1])) && (g[0] = R * (z = 1 / z), g[1] = -T * z, g[2] = -I * z, g[3] = w * z), d[0] = X[0], d[1] = X[1], d[4] = X[2], d[5] = X[3];
          }
          var g, b, w, T, I, R, z;
          return s.O(d, d, [1 / a, 1 / a, 1]), d;
        }
        function ur(_, t, a, d) {
          if (_) {
            const g = s.M();
            if (!t) {
              const { vecSouth: b, vecEast: w } = st(a);
              g[0] = w[0], g[1] = w[1], g[4] = b[0], g[5] = b[1];
            }
            return s.O(g, g, [d, d, 1]), g;
          }
          return a.pixelsToClipSpaceMatrix;
        }
        function st(_) {
          const t = Math.cos(_.rollInRadians), a = Math.sin(_.rollInRadians), d = Math.cos(_.pitchInRadians), g = Math.cos(_.bearingInRadians), b = Math.sin(_.bearingInRadians), w = s.aw();
          w[0] = -g * d * a - b * t, w[1] = -b * d * a + g * t;
          const T = s.ax(w);
          T < 1e-9 ? s.ay(w) : s.az(w, w, 1 / T);
          const I = s.aw();
          I[0] = g * d * t - b * a, I[1] = b * d * t + g * a;
          const R = s.ax(I);
          return R < 1e-9 ? s.ay(I) : s.az(I, I, 1 / R), { vecEast: I, vecSouth: w };
        }
        function Bt(_, t, a, d) {
          let g;
          d ? (g = [_, t, d(_, t), 1], s.aB(g, g, a)) : (g = [_, t, 0, 1], Na(g, g, a));
          const b = g[3];
          return { point: new s.P(g[0] / b, g[1] / b), signedDistanceFromCamera: b, isOccluded: false };
        }
        function Xt(_, t) {
          return 0.5 + _ / t * 0.5;
        }
        function hi(_, t) {
          return _.x >= -t[0] && _.x <= t[0] && _.y >= -t[1] && _.y <= t[1];
        }
        function Sn(_, t, a, d, g, b, w, T, I, R, z, W, U) {
          const X = a ? _.textSizeData : _.iconSizeData, re = s.as(X, t.transform.zoom), de = [256 / t.width * 2 + 1, 256 / t.height * 2 + 1], fe = a ? _.text.dynamicLayoutVertexArray : _.icon.dynamicLayoutVertexArray;
          fe.clear();
          const me = _.lineVertexArray, Ce = a ? _.text.placedSymbolArray : _.icon.placedSymbolArray, Pe = t.transform.width / t.transform.height;
          let xe = false;
          for (let Ie = 0; Ie < Ce.length; Ie++) {
            const De = Ce.get(Ie);
            if (De.hidden || De.writingMode === s.at.vertical && !xe) {
              ro(De.numGlyphs, fe);
              continue;
            }
            xe = false;
            const Se = new s.P(De.anchorX, De.anchorY), Ne = { getElevation: U, pitchedLabelPlaneMatrix: d, lineVertexArray: me, pitchWithMap: b, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: t.transform, tileAnchorPoint: Se, unwrappedTileID: I, width: R, height: z, translation: W }, Ke = Zn(De.anchorX, De.anchorY, Ne);
            if (!hi(Ke.point, de)) {
              ro(De.numGlyphs, fe);
              continue;
            }
            const Ze = Xt(t.transform.cameraToCenterDistance, Ke.signedDistanceFromCamera), He = s.au(X, re, De), Je = b ? He * t.transform.getPitchedTextCorrection(De.anchorX, De.anchorY, I) / Ze : He * Ze, Tt = Wn({ projectionContext: Ne, pitchedLabelPlaneMatrixInverse: g, symbol: De, fontSize: Je, flip: false, keepUpright: w, glyphOffsetArray: _.glyphOffsetArray, dynamicLayoutVertexArray: fe, aspectRatio: Pe, rotateToLine: T });
            xe = Tt.useVertical, (Tt.notEnoughRoom || xe || Tt.needsFlipping && Wn({ projectionContext: Ne, pitchedLabelPlaneMatrixInverse: g, symbol: De, fontSize: Je, flip: true, keepUpright: w, glyphOffsetArray: _.glyphOffsetArray, dynamicLayoutVertexArray: fe, aspectRatio: Pe, rotateToLine: T }).notEnoughRoom) && ro(De.numGlyphs, fe);
          }
          a ? _.text.dynamicLayoutVertexBuffer.updateData(fe) : _.icon.dynamicLayoutVertexBuffer.updateData(fe);
        }
        function Jr(_, t, a, d, g, b, w, T) {
          const I = b.glyphStartIndex + b.numGlyphs, R = b.lineStartIndex, z = b.lineStartIndex + b.lineLength, W = t.getoffsetX(b.glyphStartIndex), U = t.getoffsetX(I - 1), X = Gr(_ * W, a, d, g, b.segment, R, z, T, w);
          if (!X) return null;
          const re = Gr(_ * U, a, d, g, b.segment, R, z, T, w);
          return re ? T.projectionCache.anyProjectionOccluded ? null : { first: X, last: re } : null;
        }
        function ar(_, t, a, d) {
          return _ === s.at.horizontal && Math.abs(a.y - t.y) > Math.abs(a.x - t.x) * d ? { useVertical: true } : (_ === s.at.vertical ? t.y < a.y : t.x > a.x) ? { needsFlipping: true } : null;
        }
        function Wn(_) {
          const { projectionContext: t, pitchedLabelPlaneMatrixInverse: a, symbol: d, fontSize: g, flip: b, keepUpright: w, glyphOffsetArray: T, dynamicLayoutVertexArray: I, aspectRatio: R, rotateToLine: z } = _, W = g / 24, U = d.lineOffsetX * W, X = d.lineOffsetY * W;
          let re;
          if (d.numGlyphs > 1) {
            const de = d.glyphStartIndex + d.numGlyphs, fe = d.lineStartIndex, me = d.lineStartIndex + d.lineLength, Ce = Jr(W, T, U, X, b, d, z, t);
            if (!Ce) return { notEnoughRoom: true };
            const Pe = mo(Ce.first.point.x, Ce.first.point.y, t, a), xe = mo(Ce.last.point.x, Ce.last.point.y, t, a);
            if (w && !b) {
              const Ie = ar(d.writingMode, Pe, xe, R);
              if (Ie) return Ie;
            }
            re = [Ce.first];
            for (let Ie = d.glyphStartIndex + 1; Ie < de - 1; Ie++) {
              const De = Gr(W * T.getoffsetX(Ie), U, X, b, d.segment, fe, me, t, z);
              if (!De) return { notEnoughRoom: true };
              re.push(De);
            }
            re.push(Ce.last);
          } else {
            if (w && !b) {
              const fe = kn(t.tileAnchorPoint.x, t.tileAnchorPoint.y, t).point, me = d.lineStartIndex + d.segment + 1, Ce = new s.P(t.lineVertexArray.getx(me), t.lineVertexArray.gety(me)), Pe = kn(Ce.x, Ce.y, t), xe = Pe.signedDistanceFromCamera > 0 ? Pe.point : Lo(t.tileAnchorPoint, Ce, fe, 1, t), Ie = mo(fe.x, fe.y, t, a), De = mo(xe.x, xe.y, t, a), Se = ar(d.writingMode, Ie, De, R);
              if (Se) return Se;
            }
            const de = Gr(W * T.getoffsetX(d.glyphStartIndex), U, X, b, d.segment, d.lineStartIndex, d.lineStartIndex + d.lineLength, t, z);
            if (!de || t.projectionCache.anyProjectionOccluded) return { notEnoughRoom: true };
            re = [de];
          }
          for (const de of re) s.aA(I, de.point, de.angle);
          return {};
        }
        function Lo(_, t, a, d, g) {
          const b = _.add(_.sub(t)._unit()), w = kn(b.x, b.y, g).point, T = a.sub(w);
          return a.add(T._mult(d / T.mag()));
        }
        function Bo(_, t, a) {
          const d = t.projectionCache;
          if (d.projections[_]) return d.projections[_];
          const g = new s.P(t.lineVertexArray.getx(_), t.lineVertexArray.gety(_)), b = kn(g.x, g.y, t);
          if (b.signedDistanceFromCamera > 0) return d.projections[_] = b.point, d.anyProjectionOccluded = d.anyProjectionOccluded || b.isOccluded, b.point;
          const w = _ - a.direction;
          return Lo(a.distanceFromAnchor === 0 ? t.tileAnchorPoint : new s.P(t.lineVertexArray.getx(w), t.lineVertexArray.gety(w)), g, a.previousVertex, a.absOffsetX - a.distanceFromAnchor + 1, t);
        }
        function kn(_, t, a) {
          const d = _ + a.translation[0], g = t + a.translation[1];
          let b;
          return a.pitchWithMap ? (b = Bt(d, g, a.pitchedLabelPlaneMatrix, a.getElevation), b.isOccluded = false) : (b = a.transform.projectTileCoordinates(d, g, a.unwrappedTileID, a.getElevation), b.point.x = (0.5 * b.point.x + 0.5) * a.width, b.point.y = (0.5 * -b.point.y + 0.5) * a.height), b;
        }
        function mo(_, t, a, d) {
          if (a.pitchWithMap) {
            const g = [_, t, 0, 1];
            return s.aB(g, g, d), a.transform.projectTileCoordinates(g[0] / g[3], g[1] / g[3], a.unwrappedTileID, a.getElevation).point;
          }
          return { x: _ / a.width * 2 - 1, y: 1 - t / a.height * 2 };
        }
        function Zn(_, t, a) {
          return a.transform.projectTileCoordinates(_, t, a.unwrappedTileID, a.getElevation);
        }
        function Hn(_, t, a) {
          return _._unit()._perp()._mult(t * a);
        }
        function Tn(_, t, a, d, g, b, w, T, I) {
          if (T.projectionCache.offsets[_]) return T.projectionCache.offsets[_];
          const R = a.add(t);
          if (_ + I.direction < d || _ + I.direction >= g) return T.projectionCache.offsets[_] = R, R;
          const z = Bo(_ + I.direction, T, I), W = Hn(z.sub(a), w, I.direction), U = a.add(W), X = z.add(W);
          return T.projectionCache.offsets[_] = s.aC(b, R, U, X) || R, T.projectionCache.offsets[_];
        }
        function Gr(_, t, a, d, g, b, w, T, I) {
          const R = d ? _ - t : _ + t;
          let z = R > 0 ? 1 : -1, W = 0;
          d && (z *= -1, W = Math.PI), z < 0 && (W += Math.PI);
          let U, X = z > 0 ? b + g : b + g + 1;
          T.projectionCache.cachedAnchorPoint ? U = T.projectionCache.cachedAnchorPoint : (U = kn(T.tileAnchorPoint.x, T.tileAnchorPoint.y, T).point, T.projectionCache.cachedAnchorPoint = U);
          let re, de, fe = U, me = U, Ce = 0, Pe = 0;
          const xe = Math.abs(R), Ie = [];
          let De;
          for (; Ce + Pe <= xe; ) {
            if (X += z, X < b || X >= w) return null;
            Ce += Pe, me = fe, de = re;
            const Ke = { absOffsetX: xe, direction: z, distanceFromAnchor: Ce, previousVertex: me };
            if (fe = Bo(X, T, Ke), a === 0) Ie.push(me), De = fe.sub(me);
            else {
              let Ze;
              const He = fe.sub(me);
              Ze = He.mag() === 0 ? Hn(Bo(X + z, T, Ke).sub(fe), a, z) : Hn(He, a, z), de || (de = me.add(Ze)), re = Tn(X, Ze, fe, b, w, de, a, T, Ke), Ie.push(de), De = re.sub(de);
            }
            Pe = De.mag();
          }
          const Se = De._mult((xe - Ce) / Pe)._add(de || me), Ne = W + Math.atan2(fe.y - me.y, fe.x - me.x);
          return Ie.push(Se), { point: Se, angle: I ? Ne : 0, path: Ie };
        }
        const Gc = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function ro(_, t) {
          for (let a = 0; a < _; a++) {
            const d = t.length;
            t.resize(d + 4), t.float32.set(Gc, 3 * d);
          }
        }
        function Na(_, t, a) {
          const d = t[0], g = t[1];
          return _[0] = a[0] * d + a[4] * g + a[12], _[1] = a[1] * d + a[5] * g + a[13], _[3] = a[3] * d + a[7] * g + a[15], _;
        }
        const Qr = 100;
        class Oo {
          constructor(t, a = new Ft(t.width + 200, t.height + 200, 25), d = new Ft(t.width + 200, t.height + 200, 25)) {
            this.transform = t, this.grid = a, this.ignoredGrid = d, this.pitchFactor = Math.cos(t.pitch * Math.PI / 180) * t.cameraToCenterDistance, this.screenRightBoundary = t.width + Qr, this.screenBottomBoundary = t.height + Qr, this.gridRightBoundary = t.width + 200, this.gridBottomBoundary = t.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(t, a, d, g, b, w, T, I, R, z, W, U) {
            const X = this.projectAndGetPerspectiveRatio(t.anchorPointX + I[0], t.anchorPointY + I[1], b, z, U), re = d * X.perspectiveRatio;
            let de;
            if (w || T) de = this._projectCollisionBox(t, re, g, b, w, T, I, X, z, W, U);
            else {
              const De = X.x + (W ? W.x * re : 0), Se = X.y + (W ? W.y * re : 0);
              de = { allPointsOccluded: false, box: [De + t.x1 * re, Se + t.y1 * re, De + t.x2 * re, Se + t.y2 * re] };
            }
            const [fe, me, Ce, Pe] = de.box, xe = w ? de.allPointsOccluded : X.isOccluded;
            let Ie = xe;
            return Ie || (Ie = X.perspectiveRatio < this.perspectiveRatioCutoff), Ie || (Ie = !this.isInsideGrid(fe, me, Ce, Pe)), Ie || a !== "always" && this.grid.hitTest(fe, me, Ce, Pe, a, R) ? { box: [fe, me, Ce, Pe], placeable: false, offscreen: false, occluded: xe } : { box: [fe, me, Ce, Pe], placeable: true, offscreen: this.isOffscreen(fe, me, Ce, Pe), occluded: xe };
          }
          placeCollisionCircles(t, a, d, g, b, w, T, I, R, z, W, U, X, re) {
            const de = [], fe = new s.P(a.anchorX, a.anchorY), me = this.getPerspectiveRatio(fe.x, fe.y, w, re), Ce = (R ? b * this.transform.getPitchedTextCorrection(a.anchorX, a.anchorY, w) / me : b * me) / s.aG, Pe = { getElevation: re, pitchedLabelPlaneMatrix: T, lineVertexArray: d, pitchWithMap: R, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: this.transform, tileAnchorPoint: fe, unwrappedTileID: w, width: this.transform.width, height: this.transform.height, translation: X }, xe = Jr(Ce, g, a.lineOffsetX * Ce, a.lineOffsetY * Ce, false, a, false, Pe);
            let Ie = false, De = false, Se = true;
            if (xe) {
              const Ne = 0.5 * W * me + U, Ke = new s.P(-100, -100), Ze = new s.P(this.screenRightBoundary, this.screenBottomBoundary), He = new ye(), Je = xe.first, Tt = xe.last;
              let It = [];
              for (let Yt = Je.path.length - 1; Yt >= 1; Yt--) It.push(Je.path[Yt]);
              for (let Yt = 1; Yt < Tt.path.length; Yt++) It.push(Tt.path[Yt]);
              const _t = 2.5 * Ne;
              if (R) {
                const Yt = this.projectPathToScreenSpace(It, Pe);
                It = Yt.some(((Br) => Br.signedDistanceFromCamera <= 0)) ? [] : Yt.map(((Br) => Br.point));
              }
              let Gt = [];
              if (It.length > 0) {
                const Yt = It[0].clone(), Br = It[0].clone();
                for (let ri = 1; ri < It.length; ri++) Yt.x = Math.min(Yt.x, It[ri].x), Yt.y = Math.min(Yt.y, It[ri].y), Br.x = Math.max(Br.x, It[ri].x), Br.y = Math.max(Br.y, It[ri].y);
                Gt = Yt.x >= Ke.x && Br.x <= Ze.x && Yt.y >= Ke.y && Br.y <= Ze.y ? [It] : Br.x < Ke.x || Yt.x > Ze.x || Br.y < Ke.y || Yt.y > Ze.y ? [] : s.aD([It], Ke.x, Ke.y, Ze.x, Ze.y);
              }
              for (const Yt of Gt) {
                He.reset(Yt, 0.25 * Ne);
                let Br = 0;
                Br = He.length <= 0.5 * Ne ? 1 : Math.ceil(He.paddedLength / _t) + 1;
                for (let ri = 0; ri < Br; ri++) {
                  const Yr = ri / Math.max(Br - 1, 1), si = He.lerp(Yr), Wr = si.x + Qr, Ri = si.y + Qr;
                  de.push(Wr, Ri, Ne, 0);
                  const Zr = Wr - Ne, Gi = Ri - Ne, Si = Wr + Ne, Ai = Ri + Ne;
                  if (Se = Se && this.isOffscreen(Zr, Gi, Si, Ai), De = De || this.isInsideGrid(Zr, Gi, Si, Ai), t !== "always" && this.grid.hitTestCircle(Wr, Ri, Ne, t, z) && (Ie = true, !I)) return { circles: [], offscreen: false, collisionDetected: Ie };
                }
              }
            }
            return { circles: !I && Ie || !De || me < this.perspectiveRatioCutoff ? [] : de, offscreen: Se, collisionDetected: Ie };
          }
          projectPathToScreenSpace(t, a) {
            const d = (function(g, b) {
              const w = s.M();
              return s.av(w, b.pitchedLabelPlaneMatrix), g.map(((T) => {
                const I = Bt(T.x, T.y, w, b.getElevation), R = b.transform.projectTileCoordinates(I.point.x, I.point.y, b.unwrappedTileID, b.getElevation);
                return R.point.x = (0.5 * R.point.x + 0.5) * b.width, R.point.y = (0.5 * -R.point.y + 0.5) * b.height, R;
              }));
            })(t, a);
            return (function(g) {
              let b = 0, w = 0, T = 0, I = 0;
              for (let R = 0; R < g.length; R++) g[R].isOccluded ? (T = R + 1, I = 0) : (I++, I > w && (w = I, b = T));
              return g.slice(b, b + w);
            })(d);
          }
          queryRenderedSymbols(t) {
            if (t.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const a = [], d = new s.a6();
            for (const W of t) {
              const U = new s.P(W.x + Qr, W.y + Qr);
              d.extend(U), a.push(U);
            }
            const { minX: g, minY: b, maxX: w, maxY: T } = d, I = this.grid.query(g, b, w, T).concat(this.ignoredGrid.query(g, b, w, T)), R = {}, z = {};
            for (const W of I) {
              const U = W.key;
              if (R[U.bucketInstanceId] === void 0 && (R[U.bucketInstanceId] = {}), R[U.bucketInstanceId][U.featureIndex]) continue;
              const X = [new s.P(W.x1, W.y1), new s.P(W.x2, W.y1), new s.P(W.x2, W.y2), new s.P(W.x1, W.y2)];
              s.aE(a, X) && (R[U.bucketInstanceId][U.featureIndex] = true, z[U.bucketInstanceId] === void 0 && (z[U.bucketInstanceId] = []), z[U.bucketInstanceId].push(U.featureIndex));
            }
            return z;
          }
          insertCollisionBox(t, a, d, g, b, w) {
            (d ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: g, featureIndex: b, collisionGroupID: w, overlapMode: a }, t[0], t[1], t[2], t[3]);
          }
          insertCollisionCircles(t, a, d, g, b, w) {
            const T = d ? this.ignoredGrid : this.grid, I = { bucketInstanceId: g, featureIndex: b, collisionGroupID: w, overlapMode: a };
            for (let R = 0; R < t.length; R += 4) T.insertCircle(I, t[R], t[R + 1], t[R + 2]);
          }
          projectAndGetPerspectiveRatio(t, a, d, g, b) {
            if (b) {
              let w;
              g ? (w = [t, a, g(t, a), 1], s.aB(w, w, b)) : (w = [t, a, 0, 1], Na(w, w, b));
              const T = w[3];
              return { x: (w[0] / T + 1) / 2 * this.transform.width + Qr, y: (-w[1] / T + 1) / 2 * this.transform.height + Qr, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / T * 0.5, isOccluded: false, signedDistanceFromCamera: T };
            }
            {
              const w = this.transform.projectTileCoordinates(t, a, d, g);
              return { x: (w.point.x + 1) / 2 * this.transform.width + Qr, y: (1 - w.point.y) / 2 * this.transform.height + Qr, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / w.signedDistanceFromCamera * 0.5, isOccluded: w.isOccluded, signedDistanceFromCamera: w.signedDistanceFromCamera };
            }
          }
          getPerspectiveRatio(t, a, d, g) {
            const b = this.transform.projectTileCoordinates(t, a, d, g);
            return 0.5 + this.transform.cameraToCenterDistance / b.signedDistanceFromCamera * 0.5;
          }
          isOffscreen(t, a, d, g) {
            return d < Qr || t >= this.screenRightBoundary || g < Qr || a > this.screenBottomBoundary;
          }
          isInsideGrid(t, a, d, g) {
            return d >= 0 && t < this.gridRightBoundary && g >= 0 && a < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const t = s.am([]);
            return s.N(t, t, [-100, -100, 0]), t;
          }
          _projectCollisionBox(t, a, d, g, b, w, T, I, R, z, W) {
            let U = 1, X = 0, re = 0, de = 1;
            const fe = t.anchorPointX + T[0], me = t.anchorPointY + T[1];
            if (w && !b) {
              const It = this.projectAndGetPerspectiveRatio(fe + 1, me, g, R, W), _t = It.x - I.x, Gt = Math.atan((It.y - I.y) / _t) + (_t < 0 ? Math.PI : 0), Yt = Math.sin(Gt), Br = Math.cos(Gt);
              U = Br, X = Yt, re = -Yt, de = Br;
            } else if (!w && b) {
              const It = st(this.transform);
              U = It.vecEast[0], X = It.vecEast[1], re = It.vecSouth[0], de = It.vecSouth[1];
            }
            let Ce = I.x, Pe = I.y, xe = a;
            b && (Ce = fe, Pe = me, xe = Math.pow(2, -(this.transform.zoom - d.overscaledZ)), xe *= this.transform.getPitchedTextCorrection(fe, me, g), z || (xe *= s.ai(0.5 + I.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), z && (Ce += U * z.x * xe + re * z.y * xe, Pe += X * z.x * xe + de * z.y * xe);
            const Ie = t.x1 * xe, De = t.x2 * xe, Se = (Ie + De) / 2, Ne = t.y1 * xe, Ke = t.y2 * xe, Ze = (Ne + Ke) / 2, He = [{ offsetX: Ie, offsetY: Ne }, { offsetX: Se, offsetY: Ne }, { offsetX: De, offsetY: Ne }, { offsetX: De, offsetY: Ze }, { offsetX: De, offsetY: Ke }, { offsetX: Se, offsetY: Ke }, { offsetX: Ie, offsetY: Ke }, { offsetX: Ie, offsetY: Ze }];
            let Je = [];
            for (const { offsetX: It, offsetY: _t } of He) Je.push(new s.P(Ce + U * It + re * _t, Pe + X * It + de * _t));
            let Tt = false;
            if (b) {
              const It = Je.map(((_t) => this.projectAndGetPerspectiveRatio(_t.x, _t.y, g, R, W)));
              Tt = It.some(((_t) => !_t.isOccluded)), Je = It.map(((_t) => new s.P(_t.x, _t.y)));
            } else Tt = true;
            return { box: s.aF(Je), allPointsOccluded: !Tt };
          }
        }
        class Zs {
          constructor(t, a, d, g) {
            this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? a : -a))) : g && d ? 1 : 0, this.placed = d;
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class ga {
          constructor(t, a, d, g, b) {
            this.text = new Zs(t ? t.text : null, a, d, b), this.icon = new Zs(t ? t.icon : null, a, g, b);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Hs {
          constructor(t, a, d) {
            this.text = t, this.icon = a, this.skipFade = d;
          }
        }
        class va {
          constructor(t, a, d, g, b) {
            this.bucketInstanceId = t, this.featureIndex = a, this.sourceLayerIndex = d, this.bucketIndex = g, this.tileID = b;
          }
        }
        class tu {
          constructor(t) {
            this.crossSourceCollisions = t, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(t) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[t]) {
              const a = ++this.maxGroupID;
              this.collisionGroups[t] = { ID: a, predicate: (d) => d.collisionGroupID === a };
            }
            return this.collisionGroups[t];
          }
        }
        function ru(_, t, a, d, g) {
          const { horizontalAlign: b, verticalAlign: w } = s.aM(_);
          return new s.P(-(b - 0.5) * t + d[0] * g, -(w - 0.5) * a + d[1] * g);
        }
        class qc {
          constructor(t, a, d, g, b) {
            this.transform = t.clone(), this.terrain = a, this.collisionIndex = new Oo(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = d, this.retainedQueryData = {}, this.collisionGroups = new tu(g), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = b, b && (b.prevPlacement = void 0), this.placedOrientations = {};
          }
          _getTerrainElevationFunc(t) {
            const a = this.terrain;
            return a ? (d, g) => a.getElevation(t, d, g) : null;
          }
          getBucketParts(t, a, d, g) {
            const b = d.getBucket(a), w = d.latestFeatureIndex;
            if (!b || !w || a.id !== b.layerIds[0]) return;
            const T = d.collisionBoxArray, I = b.layers[0].layout, R = b.layers[0].paint, z = Math.pow(2, this.transform.zoom - d.tileID.overscaledZ), W = d.tileSize / s.a3, U = d.tileID.toUnwrapped(), X = I.get("text-rotation-alignment") === "map", re = s.aH(d, 1, this.transform.zoom), de = s.aI(this.collisionIndex.transform, d, R.get("text-translate"), R.get("text-translate-anchor")), fe = s.aI(this.collisionIndex.transform, d, R.get("icon-translate"), R.get("icon-translate-anchor")), me = hr(X, this.transform, re);
            this.retainedQueryData[b.bucketInstanceId] = new va(b.bucketInstanceId, w, b.sourceLayerIndex, b.index, d.tileID);
            const Ce = { bucket: b, layout: I, translationText: de, translationIcon: fe, unwrappedTileID: U, pitchedLabelPlaneMatrix: me, scale: z, textPixelRatio: W, holdingForFade: d.holdingForSymbolFade(), collisionBoxArray: T, partiallyEvaluatedTextSize: s.as(b.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(b.sourceID) };
            if (g) for (const Pe of b.sortKeyRanges) {
              const { sortKey: xe, symbolInstanceStart: Ie, symbolInstanceEnd: De } = Pe;
              t.push({ sortKey: xe, symbolInstanceStart: Ie, symbolInstanceEnd: De, parameters: Ce });
            }
            else t.push({ symbolInstanceStart: 0, symbolInstanceEnd: b.symbolInstances.length, parameters: Ce });
          }
          attemptAnchorPlacement(t, a, d, g, b, w, T, I, R, z, W, U, X, re, de, fe, me, Ce, Pe, xe) {
            const Ie = s.aJ[t.textAnchor], De = [t.textOffset0, t.textOffset1], Se = ru(Ie, d, g, De, b), Ne = this.collisionIndex.placeCollisionBox(a, U, I, R, z, T, w, fe, W.predicate, Pe, Se, xe);
            if ((!Ce || this.collisionIndex.placeCollisionBox(Ce, U, I, R, z, T, w, me, W.predicate, Pe, Se, xe).placeable) && Ne.placeable) {
              let Ke;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[X.crossTileID] && this.prevPlacement.placements[X.crossTileID] && this.prevPlacement.placements[X.crossTileID].text && (Ke = this.prevPlacement.variableOffsets[X.crossTileID].anchor), X.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[X.crossTileID] = { textOffset: De, width: d, height: g, anchor: Ie, textBoxScale: b, prevAnchor: Ke }, this.markUsedJustification(re, Ie, X, de), re.allowVerticalPlacement && (this.markUsedOrientation(re, de, X), this.placedOrientations[X.crossTileID] = de), { shift: Se, placedGlyphBoxes: Ne };
            }
          }
          placeLayerBucketPart(t, a, d) {
            const { bucket: g, layout: b, translationText: w, translationIcon: T, unwrappedTileID: I, pitchedLabelPlaneMatrix: R, textPixelRatio: z, holdingForFade: W, collisionBoxArray: U, partiallyEvaluatedTextSize: X, collisionGroup: re } = t.parameters, de = b.get("text-optional"), fe = b.get("icon-optional"), me = s.aK(b, "text-overlap", "text-allow-overlap"), Ce = me === "always", Pe = s.aK(b, "icon-overlap", "icon-allow-overlap"), xe = Pe === "always", Ie = b.get("text-rotation-alignment") === "map", De = b.get("text-pitch-alignment") === "map", Se = b.get("icon-text-fit") !== "none", Ne = b.get("symbol-z-order") === "viewport-y", Ke = Ce && (xe || !g.hasIconData() || fe), Ze = xe && (Ce || !g.hasTextData() || de);
            !g.collisionArrays && U && g.deserializeCollisionBoxes(U);
            const He = this.retainedQueryData[g.bucketInstanceId].tileID, Je = this._getTerrainElevationFunc(He), Tt = this.transform.getFastPathSimpleProjectionMatrix(He), It = (_t, Gt, Yt) => {
              var Br, ri;
              if (a[_t.crossTileID]) return;
              if (W) return void (this.placements[_t.crossTileID] = new Hs(false, false, false));
              let Yr = false, si = false, Wr = true, Ri = null, Zr = { box: null, placeable: false, offscreen: null, occluded: false }, Gi = { placeable: false }, Si = null, Ai = null, pn = null, Go = 0, Sa = 0, Jo = 0;
              Gt.textFeatureIndex ? Go = Gt.textFeatureIndex : _t.useRuntimeCollisionCircles && (Go = _t.featureIndex), Gt.verticalTextFeatureIndex && (Sa = Gt.verticalTextFeatureIndex);
              const Qo = Gt.textBox;
              if (Qo) {
                const Xn = (li) => {
                  let ii = s.at.horizontal;
                  if (g.allowVerticalPlacement && !li && this.prevPlacement) {
                    const ki = this.prevPlacement.placedOrientations[_t.crossTileID];
                    ki && (this.placedOrientations[_t.crossTileID] = ki, ii = ki, this.markUsedOrientation(g, ii, _t));
                  }
                  return ii;
                }, ka = (li, ii) => {
                  if (g.allowVerticalPlacement && _t.numVerticalGlyphVertices > 0 && Gt.verticalTextBox) {
                    for (const ki of g.writingModes) if (ki === s.at.vertical ? (Zr = ii(), Gi = Zr) : Zr = li(), Zr && Zr.placeable) break;
                  } else Zr = li();
                }, ea = _t.textAnchorOffsetStartIndex, ta = _t.textAnchorOffsetEndIndex;
                if (ta === ea) {
                  const li = (ii, ki) => {
                    const ui = this.collisionIndex.placeCollisionBox(ii, me, z, He, I, De, Ie, w, re.predicate, Je, void 0, Tt);
                    return ui && ui.placeable && (this.markUsedOrientation(g, ki, _t), this.placedOrientations[_t.crossTileID] = ki), ui;
                  };
                  ka((() => li(Qo, s.at.horizontal)), (() => {
                    const ii = Gt.verticalTextBox;
                    return g.allowVerticalPlacement && _t.numVerticalGlyphVertices > 0 && ii ? li(ii, s.at.vertical) : { box: null, offscreen: null };
                  })), Xn(Zr && Zr.placeable);
                } else {
                  let li = s.aJ[(ri = (Br = this.prevPlacement) === null || Br === void 0 ? void 0 : Br.variableOffsets[_t.crossTileID]) === null || ri === void 0 ? void 0 : ri.anchor];
                  const ii = (ui, Nf, jf) => {
                    const Vf = ui.x2 - ui.x1, Qa = ui.y2 - ui.y1, Gm = _t.textBoxScale, Uf = Se && Pe === "never" ? Nf : null;
                    let ra = null, Od = me === "never" ? 1 : 2, Ta = "never";
                    li && Od++;
                    for (let Pa = 0; Pa < Od; Pa++) {
                      for (let Xu = ea; Xu < ta; Xu++) {
                        const Gf = g.textAnchorOffsets.get(Xu);
                        if (li && Gf.textAnchor !== li) continue;
                        const El = this.attemptAnchorPlacement(Gf, ui, Vf, Qa, Gm, Ie, De, z, He, I, re, Ta, _t, g, jf, w, T, Uf, Je);
                        if (El && (ra = El.placedGlyphBoxes, ra && ra.placeable)) return Yr = true, Ri = El.shift, ra;
                      }
                      li ? li = null : Ta = me;
                    }
                    return d && !ra && (ra = { box: this.collisionIndex.placeCollisionBox(Qo, "always", z, He, I, De, Ie, w, re.predicate, Je, void 0, Tt).box, offscreen: false, placeable: false, occluded: false }), ra;
                  };
                  ka((() => ii(Qo, Gt.iconBox, s.at.horizontal)), (() => {
                    const ui = Gt.verticalTextBox;
                    return g.allowVerticalPlacement && (!Zr || !Zr.placeable) && _t.numVerticalGlyphVertices > 0 && ui ? ii(ui, Gt.verticalIconBox, s.at.vertical) : { box: null, occluded: true, offscreen: null };
                  })), Zr && (Yr = Zr.placeable, Wr = Zr.offscreen);
                  const ki = Xn(Zr && Zr.placeable);
                  if (!Yr && this.prevPlacement) {
                    const ui = this.prevPlacement.variableOffsets[_t.crossTileID];
                    ui && (this.variableOffsets[_t.crossTileID] = ui, this.markUsedJustification(g, ui.anchor, _t, ki));
                  }
                }
              }
              if (Si = Zr, Yr = Si && Si.placeable, Wr = Si && Si.offscreen, _t.useRuntimeCollisionCircles && _t.centerJustifiedTextSymbolIndex >= 0) {
                const Xn = g.text.placedSymbolArray.get(_t.centerJustifiedTextSymbolIndex), ka = s.au(g.textSizeData, X, Xn), ea = b.get("text-padding");
                Ai = this.collisionIndex.placeCollisionCircles(me, Xn, g.lineVertexArray, g.glyphOffsetArray, ka, I, R, d, De, re.predicate, _t.collisionCircleDiameter, ea, w, Je), Ai.circles.length && Ai.collisionDetected && !d && s.w("Collisions detected, but collision boxes are not shown"), Yr = Ce || Ai.circles.length > 0 && !Ai.collisionDetected, Wr = Wr && Ai.offscreen;
              }
              if (Gt.iconFeatureIndex && (Jo = Gt.iconFeatureIndex), Gt.iconBox) {
                const Xn = (ka) => this.collisionIndex.placeCollisionBox(ka, Pe, z, He, I, De, Ie, T, re.predicate, Je, Se && Ri ? Ri : void 0, Tt);
                Gi && Gi.placeable && Gt.verticalIconBox ? (pn = Xn(Gt.verticalIconBox), si = pn.placeable) : (pn = Xn(Gt.iconBox), si = pn.placeable), Wr = Wr && pn.offscreen;
              }
              const lo = de || _t.numHorizontalGlyphVertices === 0 && _t.numVerticalGlyphVertices === 0, Ka = fe || _t.numIconVertices === 0;
              lo || Ka ? Ka ? lo || (si = si && Yr) : Yr = si && Yr : si = Yr = si && Yr;
              const Ja = si && pn.placeable;
              if (Yr && Si.placeable && this.collisionIndex.insertCollisionBox(Si.box, me, b.get("text-ignore-placement"), g.bucketInstanceId, Gi && Gi.placeable && Sa ? Sa : Go, re.ID), Ja && this.collisionIndex.insertCollisionBox(pn.box, Pe, b.get("icon-ignore-placement"), g.bucketInstanceId, Jo, re.ID), Ai && Yr && this.collisionIndex.insertCollisionCircles(Ai.circles, me, b.get("text-ignore-placement"), g.bucketInstanceId, Go, re.ID), d && this.storeCollisionData(g.bucketInstanceId, Yt, Gt, Si, pn, Ai), _t.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              if (g.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[_t.crossTileID] = new Hs((Yr || Ke) && !(Si == null ? void 0 : Si.occluded), (si || Ze) && !(pn == null ? void 0 : pn.occluded), Wr || g.justReloaded), a[_t.crossTileID] = true;
            };
            if (Ne) {
              if (t.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const _t = g.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let Gt = _t.length - 1; Gt >= 0; --Gt) {
                const Yt = _t[Gt];
                It(g.symbolInstances.get(Yt), g.collisionArrays[Yt], Yt);
              }
            } else for (let _t = t.symbolInstanceStart; _t < t.symbolInstanceEnd; _t++) It(g.symbolInstances.get(_t), g.collisionArrays[_t], _t);
            g.justReloaded = false;
          }
          storeCollisionData(t, a, d, g, b, w) {
            if (d.textBox || d.iconBox) {
              let T, I;
              this.collisionBoxArrays.has(t) ? T = this.collisionBoxArrays.get(t) : (T = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(t, T)), T.has(a) ? I = T.get(a) : (I = { text: null, icon: null }, T.set(a, I)), d.textBox && (I.text = g.box), d.iconBox && (I.icon = b.box);
            }
            if (w) {
              let T = this.collisionCircleArrays[t];
              T === void 0 && (T = this.collisionCircleArrays[t] = []);
              for (let I = 0; I < w.circles.length; I += 4) T.push(w.circles[I + 0] - Qr), T.push(w.circles[I + 1] - Qr), T.push(w.circles[I + 2]), T.push(w.collisionDetected ? 1 : 0);
            }
          }
          markUsedJustification(t, a, d, g) {
            let b;
            b = g === s.at.vertical ? d.verticalPlacedTextSymbolIndex : { left: d.leftJustifiedTextSymbolIndex, center: d.centerJustifiedTextSymbolIndex, right: d.rightJustifiedTextSymbolIndex }[s.aL(a)];
            const w = [d.leftJustifiedTextSymbolIndex, d.centerJustifiedTextSymbolIndex, d.rightJustifiedTextSymbolIndex, d.verticalPlacedTextSymbolIndex];
            for (const T of w) T >= 0 && (t.text.placedSymbolArray.get(T).crossTileID = b >= 0 && T !== b ? 0 : d.crossTileID);
          }
          markUsedOrientation(t, a, d) {
            const g = a === s.at.horizontal || a === s.at.horizontalOnly ? a : 0, b = a === s.at.vertical ? a : 0, w = [d.leftJustifiedTextSymbolIndex, d.centerJustifiedTextSymbolIndex, d.rightJustifiedTextSymbolIndex];
            for (const T of w) t.text.placedSymbolArray.get(T).placedOrientation = g;
            d.verticalPlacedTextSymbolIndex && (t.text.placedSymbolArray.get(d.verticalPlacedTextSymbolIndex).placedOrientation = b);
          }
          commit(t) {
            this.commitTime = t, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const a = this.prevPlacement;
            let d = false;
            this.prevZoomAdjustment = a ? a.zoomAdjustment(this.transform.zoom) : 0;
            const g = a ? a.symbolFadeChange(t) : 1, b = a ? a.opacities : {}, w = a ? a.variableOffsets : {}, T = a ? a.placedOrientations : {};
            for (const I in this.placements) {
              const R = this.placements[I], z = b[I];
              z ? (this.opacities[I] = new ga(z, g, R.text, R.icon), d = d || R.text !== z.text.placed || R.icon !== z.icon.placed) : (this.opacities[I] = new ga(null, g, R.text, R.icon, R.skipFade), d = d || R.text || R.icon);
            }
            for (const I in b) {
              const R = b[I];
              if (!this.opacities[I]) {
                const z = new ga(R, g, false, false);
                z.isHidden() || (this.opacities[I] = z, d = d || R.text.placed || R.icon.placed);
              }
            }
            for (const I in w) this.variableOffsets[I] || !this.opacities[I] || this.opacities[I].isHidden() || (this.variableOffsets[I] = w[I]);
            for (const I in T) this.placedOrientations[I] || !this.opacities[I] || this.opacities[I].isHidden() || (this.placedOrientations[I] = T[I]);
            if (a && a.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            d ? this.lastPlacementChangeTime = t : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = a ? a.lastPlacementChangeTime : t);
          }
          updateLayerOpacities(t, a) {
            const d = {};
            for (const g of a) {
              const b = g.getBucket(t);
              b && g.latestFeatureIndex && t.id === b.layerIds[0] && this.updateBucketOpacities(b, g.tileID, d, g.collisionBoxArray);
            }
          }
          updateBucketOpacities(t, a, d, g) {
            t.hasTextData() && (t.text.opacityVertexArray.clear(), t.text.hasVisibleVertices = false), t.hasIconData() && (t.icon.opacityVertexArray.clear(), t.icon.hasVisibleVertices = false), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();
            const b = t.layers[0], w = b.layout, T = new ga(null, 0, false, false, true), I = w.get("text-allow-overlap"), R = w.get("icon-allow-overlap"), z = b._unevaluatedLayout.hasValue("text-variable-anchor") || b._unevaluatedLayout.hasValue("text-variable-anchor-offset"), W = w.get("text-rotation-alignment") === "map", U = w.get("text-pitch-alignment") === "map", X = w.get("icon-text-fit") !== "none", re = new ga(null, 0, I && (R || !t.hasIconData() || w.get("icon-optional")), R && (I || !t.hasTextData() || w.get("text-optional")), true);
            !t.collisionArrays && g && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(g);
            const de = (me, Ce, Pe) => {
              for (let xe = 0; xe < Ce / 4; xe++) me.opacityVertexArray.emplaceBack(Pe);
              me.hasVisibleVertices = me.hasVisibleVertices || Pe !== go;
            }, fe = this.collisionBoxArrays.get(t.bucketInstanceId);
            for (let me = 0; me < t.symbolInstances.length; me++) {
              const Ce = t.symbolInstances.get(me), { numHorizontalGlyphVertices: Pe, numVerticalGlyphVertices: xe, crossTileID: Ie } = Ce;
              let De = this.opacities[Ie];
              d[Ie] ? De = T : De || (De = re, this.opacities[Ie] = De), d[Ie] = true;
              const Se = Ce.numIconVertices > 0, Ne = this.placedOrientations[Ce.crossTileID], Ke = Ne === s.at.vertical, Ze = Ne === s.at.horizontal || Ne === s.at.horizontalOnly;
              if (Pe > 0 || xe > 0) {
                const Je = su(De.text);
                de(t.text, Pe, Ke ? go : Je), de(t.text, xe, Ze ? go : Je);
                const Tt = De.text.isHidden();
                [Ce.rightJustifiedTextSymbolIndex, Ce.centerJustifiedTextSymbolIndex, Ce.leftJustifiedTextSymbolIndex].forEach(((Gt) => {
                  Gt >= 0 && (t.text.placedSymbolArray.get(Gt).hidden = Tt || Ke ? 1 : 0);
                })), Ce.verticalPlacedTextSymbolIndex >= 0 && (t.text.placedSymbolArray.get(Ce.verticalPlacedTextSymbolIndex).hidden = Tt || Ze ? 1 : 0);
                const It = this.variableOffsets[Ce.crossTileID];
                It && this.markUsedJustification(t, It.anchor, Ce, Ne);
                const _t = this.placedOrientations[Ce.crossTileID];
                _t && (this.markUsedJustification(t, "left", Ce, _t), this.markUsedOrientation(t, _t, Ce));
              }
              if (Se) {
                const Je = su(De.icon), Tt = !(X && Ce.verticalPlacedIconSymbolIndex && Ke);
                Ce.placedIconSymbolIndex >= 0 && (de(t.icon, Ce.numIconVertices, Tt ? Je : go), t.icon.placedSymbolArray.get(Ce.placedIconSymbolIndex).hidden = De.icon.isHidden()), Ce.verticalPlacedIconSymbolIndex >= 0 && (de(t.icon, Ce.numVerticalIconVertices, Tt ? go : Je), t.icon.placedSymbolArray.get(Ce.verticalPlacedIconSymbolIndex).hidden = De.icon.isHidden());
              }
              const He = fe && fe.has(me) ? fe.get(me) : { text: null, icon: null };
              if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {
                const Je = t.collisionArrays[me];
                if (Je) {
                  let Tt = new s.P(0, 0);
                  if (Je.textBox || Je.verticalTextBox) {
                    let It = true;
                    if (z) {
                      const _t = this.variableOffsets[Ie];
                      _t ? (Tt = ru(_t.anchor, _t.width, _t.height, _t.textOffset, _t.textBoxScale), W && Tt._rotate(U ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : It = false;
                    }
                    if (Je.textBox || Je.verticalTextBox) {
                      let _t;
                      Je.textBox && (_t = Ke), Je.verticalTextBox && (_t = Ze), iu(t.textCollisionBox.collisionVertexArray, De.text.placed, !It || _t, He.text, Tt.x, Tt.y);
                    }
                  }
                  if (Je.iconBox || Je.verticalIconBox) {
                    const It = !!(!Ze && Je.verticalIconBox);
                    let _t;
                    Je.iconBox && (_t = It), Je.verticalIconBox && (_t = !It), iu(t.iconCollisionBox.collisionVertexArray, De.icon.placed, _t, He.icon, X ? Tt.x : 0, X ? Tt.y : 0);
                  }
                }
              }
            }
            if (t.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.text.opacityVertexArray.length !== t.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${t.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${t.text.layoutVertexArray.length}) / 4`);
            if (t.icon.opacityVertexArray.length !== t.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${t.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${t.icon.layoutVertexArray.length}) / 4`);
            t.bucketInstanceId in this.collisionCircleArrays && (t.collisionCircleArray = this.collisionCircleArrays[t.bucketInstanceId], delete this.collisionCircleArrays[t.bucketInstanceId]);
          }
          symbolFadeChange(t) {
            return this.fadeDuration === 0 ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(t) {
            return Math.max(0, (this.transform.zoom - t) / 1.5);
          }
          hasTransitions(t) {
            return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(t, a) {
            const d = this.zoomAtLastRecencyCheck === a ? 1 - this.zoomAdjustment(a) : 1;
            return this.zoomAtLastRecencyCheck = a, this.commitTime + this.fadeDuration * d > t;
          }
          setStale() {
            this.stale = true;
          }
        }
        function iu(_, t, a, d, g, b) {
          d && d.length !== 0 || (d = [0, 0, 0, 0]);
          const w = d[0] - Qr, T = d[1] - Qr, I = d[2] - Qr, R = d[3] - Qr;
          _.emplaceBack(t ? 1 : 0, a ? 1 : 0, g || 0, b || 0, w, T), _.emplaceBack(t ? 1 : 0, a ? 1 : 0, g || 0, b || 0, I, T), _.emplaceBack(t ? 1 : 0, a ? 1 : 0, g || 0, b || 0, I, R), _.emplaceBack(t ? 1 : 0, a ? 1 : 0, g || 0, b || 0, w, R);
        }
        const nu = Math.pow(2, 25), ou = Math.pow(2, 24), Xs = Math.pow(2, 17), Ys = Math.pow(2, 16), au = Math.pow(2, 9), Ks = Math.pow(2, 8), Js = Math.pow(2, 1);
        function su(_) {
          if (_.opacity === 0 && !_.placed) return 0;
          if (_.opacity === 1 && _.placed) return 4294967295;
          const t = _.placed ? 1 : 0, a = Math.floor(127 * _.opacity);
          return a * nu + t * ou + a * Xs + t * Ys + a * au + t * Ks + a * Js + t;
        }
        const go = 0;
        class fs {
          constructor(t) {
            this._sortAcrossTiles = t.layout.get("symbol-z-order") !== "viewport-y" && !t.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(t, a, d, g, b) {
            const w = this._bucketParts;
            for (; this._currentTileIndex < t.length; ) if (a.getBucketParts(w, g, t[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, b()) return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, w.sort(((T, I) => T.sortKey - I.sortKey))); this._currentPartIndex < w.length; ) if (a.placeLayerBucketPart(w[this._currentPartIndex], this._seenCrossTileIDs, d), this._currentPartIndex++, b()) return true;
            return false;
          }
        }
        class lu {
          constructor(t, a, d, g, b, w, T, I) {
            this.placement = new qc(t, a, w, T, I), this._currentPlacementIndex = d.length - 1, this._forceFullPlacement = g, this._showCollisionBoxes = b, this._done = false;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(t, a, d) {
            const g = q(), b = () => !this._forceFullPlacement && q() - g > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const w = a[t[this._currentPlacementIndex]], T = this.placement.collisionIndex.transform.zoom;
              if (w.type === "symbol" && (!w.minzoom || w.minzoom <= T) && (!w.maxzoom || w.maxzoom > T)) {
                if (this._inProgressLayer || (this._inProgressLayer = new fs(w)), this._inProgressLayer.continuePlacement(d[w.source], this.placement, this._showCollisionBoxes, w, b)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }
          commit(t) {
            return this.placement.commit(t), this.placement;
          }
        }
        const io = 512 / s.a3 / 2;
        class uu {
          constructor(t, a, d) {
            this.tileID = t, this.bucketInstanceId = d, this._symbolsByKey = {};
            const g = /* @__PURE__ */ new Map();
            for (let b = 0; b < a.length; b++) {
              const w = a.get(b), T = w.key, I = g.get(T);
              I ? I.push(w) : g.set(T, [w]);
            }
            for (const [b, w] of g) {
              const T = { positions: w.map(((I) => ({ x: Math.floor(I.anchorX * io), y: Math.floor(I.anchorY * io) }))), crossTileIDs: w.map(((I) => I.crossTileID)) };
              if (T.positions.length > 128) {
                const I = new s.aN(T.positions.length, 16, Uint16Array);
                for (const { x: R, y: z } of T.positions) I.add(R, z);
                I.finish(), delete T.positions, T.index = I;
              }
              this._symbolsByKey[b] = T;
            }
          }
          getScaledCoordinates(t, a) {
            const { x: d, y: g, z: b } = this.tileID.canonical, { x: w, y: T, z: I } = a.canonical, R = io / Math.pow(2, I - b), z = (T * s.a3 + t.anchorY) * R, W = g * s.a3 * io;
            return { x: Math.floor((w * s.a3 + t.anchorX) * R - d * s.a3 * io), y: Math.floor(z - W) };
          }
          findMatches(t, a, d) {
            const g = this.tileID.canonical.z < a.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - a.canonical.z);
            for (let b = 0; b < t.length; b++) {
              const w = t.get(b);
              if (w.crossTileID) continue;
              const T = this._symbolsByKey[w.key];
              if (!T) continue;
              const I = this.getScaledCoordinates(w, a);
              if (T.index) {
                const R = T.index.range(I.x - g, I.y - g, I.x + g, I.y + g).sort();
                for (const z of R) {
                  const W = T.crossTileIDs[z];
                  if (!d[W]) {
                    d[W] = true, w.crossTileID = W;
                    break;
                  }
                }
              } else if (T.positions) for (let R = 0; R < T.positions.length; R++) {
                const z = T.positions[R], W = T.crossTileIDs[R];
                if (Math.abs(z.x - I.x) <= g && Math.abs(z.y - I.y) <= g && !d[W]) {
                  d[W] = true, w.crossTileID = W;
                  break;
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({ crossTileIDs: t }) => t));
          }
        }
        class Wc {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class $o {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(t) {
            const a = Math.round((t - this.lng) / 360);
            if (a !== 0) for (const d in this.indexes) {
              const g = this.indexes[d], b = {};
              for (const w in g) {
                const T = g[w];
                T.tileID = T.tileID.unwrapTo(T.tileID.wrap + a), b[T.tileID.key] = T;
              }
              this.indexes[d] = b;
            }
            this.lng = t;
          }
          addBucket(t, a, d) {
            if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) {
              if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === a.bucketInstanceId) return false;
              this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key]);
            }
            for (let b = 0; b < a.symbolInstances.length; b++) a.symbolInstances.get(b).crossTileID = 0;
            this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = {});
            const g = this.usedCrossTileIDs[t.overscaledZ];
            for (const b in this.indexes) {
              const w = this.indexes[b];
              if (Number(b) > t.overscaledZ) for (const T in w) {
                const I = w[T];
                I.tileID.isChildOf(t) && I.findMatches(a.symbolInstances, t, g);
              }
              else {
                const T = w[t.scaledTo(Number(b)).key];
                T && T.findMatches(a.symbolInstances, t, g);
              }
            }
            for (let b = 0; b < a.symbolInstances.length; b++) {
              const w = a.symbolInstances.get(b);
              w.crossTileID || (w.crossTileID = d.generate(), g[w.crossTileID] = true);
            }
            return this.indexes[t.overscaledZ] === void 0 && (this.indexes[t.overscaledZ] = {}), this.indexes[t.overscaledZ][t.key] = new uu(t, a.symbolInstances, a.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(t, a) {
            for (const d of a.getCrossTileIDsLists()) for (const g of d) delete this.usedCrossTileIDs[t][g];
          }
          removeStaleBuckets(t) {
            let a = false;
            for (const d in this.indexes) {
              const g = this.indexes[d];
              for (const b in g) t[g[b].bucketInstanceId] || (this.removeBucketCrossTileIDs(d, g[b]), delete g[b], a = true);
            }
            return a;
          }
        }
        class Ho {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Wc(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(t, a, d) {
            let g = this.layerIndexes[t.id];
            g === void 0 && (g = this.layerIndexes[t.id] = new $o());
            let b = false;
            const w = {};
            g.handleWrapJump(d);
            for (const T of a) {
              const I = T.getBucket(t);
              I && t.id === I.layerIds[0] && (I.bucketInstanceId || (I.bucketInstanceId = ++this.maxBucketInstanceId), g.addBucket(T.tileID, I, this.crossTileIDs) && (b = true), w[I.bucketInstanceId] = true);
            }
            return g.removeStaleBuckets(w) && (b = true), b;
          }
          pruneUnusedLayers(t) {
            const a = {};
            t.forEach(((d) => {
              a[d] = true;
            }));
            for (const d in this.layerIndexes) a[d] || delete this.layerIndexes[d];
          }
        }
        var br = "void main() {fragColor=vec4(1.0);}";
        const no = { prelude: Er(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: Er("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: Er("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: Er(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: Er(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Er(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Er(br, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: Er(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: Er(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Er("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Er("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), colorRelief: Er(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), debug: Er("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: Er(br, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: Er(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: Er(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: Er(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: Er(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Er(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Er(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Er(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Er(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: Er(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Er(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Er(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Er(`uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`), lineGradientSDF: Er(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`), raster: Er(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: Er(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Er(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Er(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Er("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Er("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Er("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: Er("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: Er(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: Er("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
        function Er(_, t) {
          const a = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, d = t.match(/in ([\w]+) ([\w]+)/g), g = _.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), b = t.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), w = b ? b.concat(g) : g, T = {};
          return { fragmentSource: _ = _.replace(a, ((I, R, z, W, U) => (T[U] = true, R === "define" ? `
#ifndef HAS_UNIFORM_u_${U}
in ${z} ${W} ${U};
#else
uniform ${z} ${W} u_${U};
#endif
` : `
#ifdef HAS_UNIFORM_u_${U}
    ${z} ${W} ${U} = u_${U};
#endif
`))), vertexSource: t = t.replace(a, ((I, R, z, W, U) => {
            const X = W === "float" ? "vec2" : "vec4", re = U.match(/color/) ? "color" : X;
            return T[U] ? R === "define" ? `
#ifndef HAS_UNIFORM_u_${U}
uniform lowp float u_${U}_t;
in ${z} ${X} a_${U};
out ${z} ${W} ${U};
#else
uniform ${z} ${W} u_${U};
#endif
` : re === "vec4" ? `
#ifndef HAS_UNIFORM_u_${U}
    ${U} = a_${U};
#else
    ${z} ${W} ${U} = u_${U};
#endif
` : `
#ifndef HAS_UNIFORM_u_${U}
    ${U} = unpack_mix_${re}(a_${U}, u_${U}_t);
#else
    ${z} ${W} ${U} = u_${U};
#endif
` : R === "define" ? `
#ifndef HAS_UNIFORM_u_${U}
uniform lowp float u_${U}_t;
in ${z} ${X} a_${U};
#else
uniform ${z} ${W} u_${U};
#endif
` : re === "vec4" ? `
#ifndef HAS_UNIFORM_u_${U}
    ${z} ${W} ${U} = a_${U};
#else
    ${z} ${W} ${U} = u_${U};
#endif
` : `
#ifndef HAS_UNIFORM_u_${U}
    ${z} ${W} ${U} = unpack_mix_${re}(a_${U}, u_${U}_t);
#else
    ${z} ${W} ${U} = u_${U};
#endif
`;
          })), staticAttributes: d, staticUniforms: w };
        }
        class ya {
          constructor(t, a, d) {
            this.vertexBuffer = t, this.indexBuffer = a, this.segments = d;
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
          }
        }
        var Mi = s.aO([{ name: "a_pos", type: "Int16", components: 2 }]);
        const dn = "#define PROJECTION_MERCATOR", hn = "mercator";
        class Oi {
          constructor() {
            this._cachedMesh = null;
          }
          get name() {
            return "mercator";
          }
          get useSubdivision() {
            return false;
          }
          get shaderVariantName() {
            return hn;
          }
          get shaderDefine() {
            return dn;
          }
          get shaderPreludeCode() {
            return no.projectionMercator;
          }
          get vertexShaderPreludeCode() {
            return no.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return s.aP.noSubdivision;
          }
          get useGlobeControls() {
            return false;
          }
          get transitionState() {
            return 0;
          }
          get latitudeErrorCorrectionRadians() {
            return 0;
          }
          destroy() {
          }
          updateGPUdependent(t) {
          }
          getMeshFromTileID(t, a, d, g, b) {
            if (this._cachedMesh) return this._cachedMesh;
            const w = new s.aQ();
            w.emplaceBack(0, 0), w.emplaceBack(s.a3, 0), w.emplaceBack(0, s.a3), w.emplaceBack(s.a3, s.a3);
            const T = t.createVertexBuffer(w, Mi.members), I = s.aR.simpleSegment(0, 0, 4, 2), R = new s.aS();
            R.emplaceBack(1, 0, 2), R.emplaceBack(1, 2, 3);
            const z = t.createIndexBuffer(R);
            return this._cachedMesh = new ya(T, z, I), this._cachedMesh;
          }
          recalculate() {
          }
          hasTransition() {
            return false;
          }
          setErrorQueryLatitudeDegrees(t) {
          }
        }
        class Hr {
          constructor(t = 0, a = 0, d = 0, g = 0) {
            if (isNaN(t) || t < 0 || isNaN(a) || a < 0 || isNaN(d) || d < 0 || isNaN(g) || g < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = t, this.bottom = a, this.left = d, this.right = g;
          }
          interpolate(t, a, d) {
            return a.top != null && t.top != null && (this.top = s.F.number(t.top, a.top, d)), a.bottom != null && t.bottom != null && (this.bottom = s.F.number(t.bottom, a.bottom, d)), a.left != null && t.left != null && (this.left = s.F.number(t.left, a.left, d)), a.right != null && t.right != null && (this.right = s.F.number(t.right, a.right, d)), this;
          }
          getCenter(t, a) {
            const d = s.ai((this.left + t - this.right) / 2, 0, t), g = s.ai((this.top + a - this.bottom) / 2, 0, a);
            return new s.P(d, g);
          }
          equals(t) {
            return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right;
          }
          clone() {
            return new Hr(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function cu(_, t) {
          if (!_.renderWorldCopies || _.lngRange) return;
          const a = t.lng - _.center.lng;
          t.lng += a > 180 ? -360 : a < -180 ? 360 : 0;
        }
        function Pn(_) {
          return Math.max(0, Math.floor(_));
        }
        class Bn {
          constructor(t, a) {
            var d;
            this.applyConstrain = (g, b) => this._constrainOverride !== null ? this._constrainOverride(g, b) : this._callbacks.defaultConstrain(g, b), this._callbacks = t, this._tileSize = 512, this._renderWorldCopies = (a == null ? void 0 : a.renderWorldCopies) === void 0 || !!(a == null ? void 0 : a.renderWorldCopies), this._minZoom = (a == null ? void 0 : a.minZoom) || 0, this._maxZoom = (a == null ? void 0 : a.maxZoom) || 22, this._minPitch = (a == null ? void 0 : a.minPitch) == null ? 0 : a == null ? void 0 : a.minPitch, this._maxPitch = (a == null ? void 0 : a.maxPitch) == null ? 60 : a == null ? void 0 : a.maxPitch, this._constrainOverride = (d = a == null ? void 0 : a.constrainOverride) !== null && d !== void 0 ? d : null, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new s.U(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Pn(this._zoom), this._scale = s.al(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = true, this._edgeInsets = new Hr(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = true;
          }
          apply(t, a, d) {
            this._constrainOverride = t.constrainOverride, this._latRange = t.latRange, this._lngRange = t.lngRange, this._width = t.width, this._height = t.height, this._center = t.center, this._elevation = t.elevation, this._minElevationForCurrentTile = t.minElevationForCurrentTile, this._zoom = t.zoom, this._tileZoom = Pn(this._zoom), this._scale = s.al(this._zoom), this._bearingInRadians = t.bearingInRadians, this._fovInRadians = t.fovInRadians, this._pitchInRadians = t.pitchInRadians, this._rollInRadians = t.rollInRadians, this._unmodified = t.unmodified, this._edgeInsets = new Hr(t.padding.top, t.padding.bottom, t.padding.left, t.padding.right), this._minZoom = t.minZoom, this._maxZoom = t.maxZoom, this._minPitch = t.minPitch, this._maxPitch = t.maxPitch, this._renderWorldCopies = t.renderWorldCopies, this._cameraToCenterDistance = t.cameraToCenterDistance, this._nearZ = t.nearZ, this._farZ = t.farZ, this._autoCalculateNearFarZ = !d && t.autoCalculateNearFarZ, a && this.constrainInternal(), this._calcMatrices();
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix;
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile;
          }
          setMinElevationForCurrentTile(t) {
            this._minElevationForCurrentTile = t;
          }
          get tileSize() {
            return this._tileSize;
          }
          get tileZoom() {
            return this._tileZoom;
          }
          get scale() {
            return this._scale;
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get bearingInRadians() {
            return this._bearingInRadians;
          }
          get lngRange() {
            return this._lngRange;
          }
          get latRange() {
            return this._latRange;
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits;
          }
          get minZoom() {
            return this._minZoom;
          }
          setMinZoom(t) {
            this._minZoom !== t && (this._minZoom = t, this.setZoom(this.applyConstrain(this._center, this.zoom).zoom));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          setMaxZoom(t) {
            this._maxZoom !== t && (this._maxZoom = t, this.setZoom(this.applyConstrain(this._center, this.zoom).zoom));
          }
          get minPitch() {
            return this._minPitch;
          }
          setMinPitch(t) {
            this._minPitch !== t && (this._minPitch = t, this.setPitch(Math.max(this.pitch, t)));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          setMaxPitch(t) {
            this._maxPitch !== t && (this._maxPitch = t, this.setPitch(Math.min(this.pitch, t)));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          setRenderWorldCopies(t) {
            t === void 0 ? t = true : t === null && (t = false), this._renderWorldCopies = t;
          }
          get constrainOverride() {
            return this._constrainOverride;
          }
          setConstrainOverride(t) {
            t === void 0 && (t = null), this._constrainOverride !== t && (this._constrainOverride = t, this.constrainInternal(), this._calcMatrices());
          }
          get worldSize() {
            return this._tileSize * this._scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new s.P(this._width, this._height);
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180;
          }
          setBearing(t) {
            const a = s.V(t, -180, 180) * Math.PI / 180;
            var d, g, b, w, T, I, R, z, W;
            this._bearingInRadians !== a && (this._unmodified = false, this._bearingInRadians = a, this._calcMatrices(), this._rotationMatrix = P(), d = this._rotationMatrix, b = -this._bearingInRadians, w = (g = this._rotationMatrix)[0], T = g[1], I = g[2], R = g[3], z = Math.sin(b), W = Math.cos(b), d[0] = w * W + I * z, d[1] = T * W + R * z, d[2] = w * -z + I * W, d[3] = T * -z + R * W);
          }
          get rotationMatrix() {
            return this._rotationMatrix;
          }
          get pitchInRadians() {
            return this._pitchInRadians;
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180;
          }
          setPitch(t) {
            const a = s.ai(t, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== a && (this._unmodified = false, this._pitchInRadians = a, this._calcMatrices());
          }
          get rollInRadians() {
            return this._rollInRadians;
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180;
          }
          setRoll(t) {
            const a = t / 180 * Math.PI;
            this._rollInRadians !== a && (this._unmodified = false, this._rollInRadians = a, this._calcMatrices());
          }
          get fovInRadians() {
            return this._fovInRadians;
          }
          get fov() {
            return s.aT(this._fovInRadians);
          }
          setFov(t) {
            t = s.ai(t, 0.1, 150), this.fov !== t && (this._unmodified = false, this._fovInRadians = s.ak(t), this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          setZoom(t) {
            const a = this.applyConstrain(this._center, t).zoom;
            this._zoom !== a && (this._unmodified = false, this._zoom = a, this._tileZoom = Math.max(0, Math.floor(a)), this._scale = s.al(a), this.constrainInternal(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          setCenter(t) {
            t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = false, this._center = t, this.constrainInternal(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          setElevation(t) {
            t !== this._elevation && (this._elevation = t, this.constrainInternal(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          setPadding(t) {
            this._edgeInsets.equals(t) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, t, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height);
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter;
          }
          get unmodified() {
            return this._unmodified;
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance;
          }
          get nearZ() {
            return this._nearZ;
          }
          get farZ() {
            return this._farZ;
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ;
          }
          overrideNearFarZ(t, a) {
            this._autoCalculateNearFarZ = false, this._nearZ = t, this._farZ = a, this._calcMatrices();
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = true, this._calcMatrices();
          }
          isPaddingEqual(t) {
            return this._edgeInsets.equals(t);
          }
          interpolatePadding(t, a, d) {
            this._unmodified = false, this._edgeInsets.interpolate(t, a, d), this.constrainInternal(), this._calcMatrices();
          }
          resize(t, a, d = true) {
            this._width = t, this._height = a, d && this.constrainInternal(), this._calcMatrices();
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new gt([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
          }
          setMaxBounds(t) {
            t ? (this._lngRange = [t.getWest(), t.getEast()], this._latRange = [t.getSouth(), t.getNorth()], this.constrainInternal()) : (this._lngRange = null, this._latRange = [-s.aj, s.aj]);
          }
          getCameraQueryGeometry(t, a) {
            if (a.length === 1) return [a[0], t];
            {
              const { minX: d, minY: g, maxX: b, maxY: w } = s.a6.fromPoints(a).extend(t);
              return [new s.P(d, g), new s.P(b, g), new s.P(b, w), new s.P(d, w), new s.P(d, g)];
            }
          }
          constrainInternal() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = true;
            const t = this._unmodified, { center: a, zoom: d } = this.applyConstrain(this.center, this.zoom);
            this.setCenter(a), this.setZoom(d), this._unmodified = t, this._constraining = false;
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let t = s.am(new Float64Array(16));
              s.O(t, t, [this._width / 2, -this._height / 2, 1]), s.N(t, t, [1, -1, 0]), this._clipSpaceToPixelsMatrix = t, t = s.am(new Float64Array(16)), s.O(t, t, [1, -1, 1]), s.N(t, t, [-1, -1, 0]), s.O(t, t, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = t, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
            }
            this._callbacks.calcMatrices();
          }
          calculateCenterFromCameraLngLatAlt(t, a, d, g) {
            const b = d !== void 0 ? d : this.bearing, w = g = g !== void 0 ? g : this.pitch, T = s.a5.fromLngLat(t, a), I = -Math.cos(s.ak(w)), R = Math.sin(s.ak(w)), z = R * Math.sin(s.ak(b)), W = -R * Math.cos(s.ak(b));
            let U = this.elevation;
            const X = a - U;
            let re;
            I * X >= 0 || Math.abs(I) < 0.1 ? (re = 1e4, U = a + re * I) : re = -X / I;
            let de, fe, me = s.aU(1, T.y), Ce = 0;
            do {
              if (Ce += 1, Ce > 10) break;
              fe = re / me, de = new s.a5(T.x + z * fe, T.y + W * fe), me = 1 / de.meterInMercatorCoordinateUnits();
            } while (Math.abs(re - fe * me) > 1e-12);
            return { center: de.toLngLat(), elevation: U, zoom: s.ao(this.height / 2 / Math.tan(this.fovInRadians / 2) / fe / this.tileSize) };
          }
          recalculateZoomAndCenter(t) {
            if (this.elevation - t == 0) return;
            const a = s.an(1, this.center.lat) * this.worldSize, d = this.cameraToCenterDistance / a, g = s.a5.fromLngLat(this.center, this.elevation), b = Fe(this.center, this.elevation, this.pitch, this.bearing, d);
            this._elevation = t;
            const w = this.calculateCenterFromCameraLngLatAlt(b.toLngLat(), s.aU(b.z, g.y), this.bearing, this.pitch);
            this._elevation = w.elevation, this._center = w.center, this.setZoom(w.zoom);
          }
          getCameraPoint() {
            const t = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new s.P(t * Math.sin(this.rollInRadians), t * Math.cos(this.rollInRadians)));
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
          }
          getCameraLngLat() {
            const t = s.an(1, this.center.lat) * this.worldSize;
            return Fe(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / t).toLngLat();
          }
          getMercatorTileCoordinates(t) {
            if (!t) return [0, 0, 1, 1];
            const a = t.canonical.z >= 0 ? 1 << t.canonical.z : Math.pow(2, t.canonical.z);
            return [t.canonical.x / a, t.canonical.y / a, 1 / a / s.a3, 1 / a / s.a3];
          }
        }
        class fn {
          constructor(t, a) {
            this.min = t, this.max = a, this.center = s.aV([], s.aW([], this.min, this.max), 0.5);
          }
          quadrant(t) {
            const a = [t % 2 == 0, t < 2], d = s.aX(this.min), g = s.aX(this.max);
            for (let b = 0; b < a.length; b++) d[b] = a[b] ? this.min[b] : this.center[b], g[b] = a[b] ? this.center[b] : this.max[b];
            return g[2] = this.max[2], new fn(d, g);
          }
          distanceX(t) {
            return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];
          }
          distanceY(t) {
            return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];
          }
          intersectsFrustum(t) {
            let a = true;
            for (let d = 0; d < t.planes.length; d++) {
              const g = this.intersectsPlane(t.planes[d]);
              if (g === 0) return 0;
              g === 1 && (a = false);
            }
            return a ? 2 : t.aabb.min[0] > this.max[0] || t.aabb.min[1] > this.max[1] || t.aabb.min[2] > this.max[2] || t.aabb.max[0] < this.min[0] || t.aabb.max[1] < this.min[1] || t.aabb.max[2] < this.min[2] ? 0 : 1;
          }
          intersectsPlane(t) {
            let a = t[3], d = t[3];
            for (let g = 0; g < 3; g++) t[g] > 0 ? (a += t[g] * this.min[g], d += t[g] * this.max[g]) : (d += t[g] * this.min[g], a += t[g] * this.max[g]);
            return a >= 0 ? 2 : d < 0 ? 0 : 1;
          }
        }
        class Zh {
          distanceToTile2d(t, a, d, g) {
            const b = g.distanceX([t, a]), w = g.distanceY([t, a]);
            return Math.hypot(b, w);
          }
          getWrap(t, a, d) {
            return d;
          }
          getTileBoundingVolume(t, a, d, g) {
            var b, w;
            let T = 0, I = 0;
            if (g == null ? void 0 : g.terrain) {
              const z = new s.a0(t.z, a, t.z, t.x, t.y), W = g.terrain.getMinMaxElevation(z);
              T = (b = W.minElevation) !== null && b !== void 0 ? b : Math.min(0, d), I = (w = W.maxElevation) !== null && w !== void 0 ? w : Math.max(0, d);
            }
            const R = 1 << t.z;
            return new fn([a + t.x / R, t.y / R, T], [a + (t.x + 1) / R, (t.y + 1) / R, I]);
          }
          allowVariableZoom(t, a) {
            const d = t.fov * (Math.abs(Math.cos(t.rollInRadians)) * t.height + Math.abs(Math.sin(t.rollInRadians)) * t.width) / t.height, g = s.ai(78.5 - d / 2, 0, 60);
            return !!a.terrain || t.pitch > g;
          }
          allowWorldCopies() {
            return true;
          }
          prepareNextFrame() {
          }
        }
        class _a2 {
          constructor(t, a, d) {
            this.points = t, this.planes = a, this.aabb = d;
          }
          static fromInvProjectionMatrix(t, a = 1, d = 0, g, b) {
            const w = b ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]], T = Math.pow(2, d), I = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(((U) => (function(X, re, de, fe) {
              const me = s.aB([], X, re), Ce = 1 / me[3] / de * fe;
              return s.b0(me, me, [Ce, Ce, 1 / me[3], Ce]);
            })(U, t, a, T)));
            g && (function(U, X, re, de) {
              const fe = de ? 4 : 0, me = de ? 0 : 4;
              let Ce = 0;
              const Pe = [], xe = [];
              for (let Se = 0; Se < 4; Se++) {
                const Ne = s.aY([], U[Se + me], U[Se + fe]), Ke = s.b1(Ne);
                s.aV(Ne, Ne, 1 / Ke), Pe.push(Ke), xe.push(Ne);
              }
              for (let Se = 0; Se < 4; Se++) {
                const Ne = s.b2(U[Se + fe], xe[Se], re);
                Ce = Ne !== null && Ne >= 0 ? Math.max(Ce, Ne) : Math.max(Ce, Pe[Se]);
              }
              const Ie = (function(Se, Ne) {
                const Ke = s.aY([], Se[Ne[0]], Se[Ne[1]]), Ze = s.aY([], Se[Ne[2]], Se[Ne[1]]), He = [0, 0, 0, 0];
                return s.aZ(He, s.a_([], Ke, Ze)), He[3] = -s.a$(He, Se[Ne[0]]), He;
              })(U, X), De = (function(Se, Ne) {
                const Ke = s.b3(Se), Ze = s.b4([], Se, 1 / Ke), He = s.aY([], Ne, s.aV([], Ze, s.a$(Ne, Ze))), Je = s.b3(He);
                if (Je > 0) {
                  const Tt = Math.sqrt(1 - Ze[3] * Ze[3]), It = s.aV([], Ze, -Ze[3]), _t = s.aW([], It, s.aV([], He, Tt / Je));
                  return s.b5(Ne, _t);
                }
                return null;
              })(re, Ie);
              if (De !== null) {
                const Se = De / s.a$(xe[0], Ie);
                Ce = Math.min(Ce, Se);
              }
              for (let Se = 0; Se < 4; Se++) {
                const Ne = Math.min(Ce, Pe[Se]);
                U[Se + me] = [U[Se + fe][0] + xe[Se][0] * Ne, U[Se + fe][1] + xe[Se][1] * Ne, U[Se + fe][2] + xe[Se][2] * Ne, 1];
              }
            })(I, w[0], g, b);
            const R = w.map(((U) => {
              const X = s.aY([], I[U[0]], I[U[1]]), re = s.aY([], I[U[2]], I[U[1]]), de = s.aZ([], s.a_([], X, re)), fe = -s.a$(de, I[U[1]]);
              return de.concat(fe);
            })), z = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], W = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const U of I) for (let X = 0; X < 3; X++) z[X] = Math.min(z[X], U[X]), W[X] = Math.max(W[X], U[X]);
            return new _a2(I, R, new fn(z, W));
          }
        }
        class ei {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(t) {
            this._helper.setMinZoom(t);
          }
          setMaxZoom(t) {
            this._helper.setMaxZoom(t);
          }
          setMinPitch(t) {
            this._helper.setMinPitch(t);
          }
          setMaxPitch(t) {
            this._helper.setMaxPitch(t);
          }
          setRenderWorldCopies(t) {
            this._helper.setRenderWorldCopies(t);
          }
          setBearing(t) {
            this._helper.setBearing(t);
          }
          setPitch(t) {
            this._helper.setPitch(t);
          }
          setRoll(t) {
            this._helper.setRoll(t);
          }
          setFov(t) {
            this._helper.setFov(t);
          }
          setZoom(t) {
            this._helper.setZoom(t);
          }
          setCenter(t) {
            this._helper.setCenter(t);
          }
          setElevation(t) {
            this._helper.setElevation(t);
          }
          setMinElevationForCurrentTile(t) {
            this._helper.setMinElevationForCurrentTile(t);
          }
          setPadding(t) {
            this._helper.setPadding(t);
          }
          interpolatePadding(t, a, d) {
            return this._helper.interpolatePadding(t, a, d);
          }
          isPaddingEqual(t) {
            return this._helper.isPaddingEqual(t);
          }
          resize(t, a, d = true) {
            this._helper.resize(t, a, d);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(t) {
            this._helper.setMaxBounds(t);
          }
          setConstrainOverride(t) {
            this._helper.setConstrainOverride(t);
          }
          overrideNearFarZ(t, a) {
            this._helper.overrideNearFarZ(t, a);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(t) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), t);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get constrainOverride() {
            return this._helper.constrainOverride;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(t, a) {
          }
          constructor(t) {
            this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this.defaultConstrain = (a, d) => {
              d = s.ai(+d, this.minZoom, this.maxZoom);
              const g = { center: new s.U(a.lng, a.lat), zoom: d };
              let b = this._helper._lngRange;
              if (!this._helper._renderWorldCopies && b === null) {
                const xe = 179.9999999999;
                b = [-xe, xe];
              }
              const w = this.tileSize * s.al(g.zoom);
              let T = 0, I = w, R = 0, z = w, W = 0, U = 0;
              const { x: X, y: re } = this.size;
              if (this._helper._latRange) {
                const xe = this._helper._latRange;
                T = s.W(xe[1]) * w, I = s.W(xe[0]) * w, I - T < re && (W = re / (I - T));
              }
              b && (R = s.V(s.X(b[0]) * w, 0, w), z = s.V(s.X(b[1]) * w, 0, w), z < R && (z += w), z - R < X && (U = X / (z - R)));
              const { x: de, y: fe } = ge(w, a);
              let me, Ce;
              const Pe = Math.max(U || 0, W || 0);
              if (Pe) {
                const xe = new s.P(U ? (z + R) / 2 : de, W ? (I + T) / 2 : fe);
                return g.center = _e(w, xe).wrap(), g.zoom += s.ao(Pe), g;
              }
              if (this._helper._latRange) {
                const xe = re / 2;
                fe - xe < T && (Ce = T + xe), fe + xe > I && (Ce = I - xe);
              }
              if (b) {
                const xe = (R + z) / 2;
                let Ie = de;
                this._helper._renderWorldCopies && (Ie = s.V(de, xe - w / 2, xe + w / 2));
                const De = X / 2;
                Ie - De < R && (me = R + De), Ie + De > z && (me = z - De);
              }
              if (me !== void 0 || Ce !== void 0) {
                const xe = new s.P(me ?? de, Ce ?? fe);
                g.center = _e(w, xe).wrap();
              }
              return g;
            }, this.applyConstrain = (a, d) => this._helper.applyConstrain(a, d), this._helper = new Bn({ calcMatrices: () => {
              this._calcMatrices();
            }, defaultConstrain: (a, d) => this.defaultConstrain(a, d) }, t), this._coveringTilesDetailsProvider = new Zh();
          }
          clone() {
            const t = new ei();
            return t.apply(this), t;
          }
          apply(t, a, d) {
            this._helper.apply(t, a, d);
          }
          get cameraPosition() {
            return this._cameraPosition;
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix;
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix;
          }
          get mercatorMatrix() {
            return this._mercatorMatrix;
          }
          getVisibleUnwrappedCoordinates(t) {
            const a = [new s.b6(0, t)];
            if (this._helper._renderWorldCopies) {
              const d = this.screenPointToMercatorCoordinate(new s.P(0, 0)), g = this.screenPointToMercatorCoordinate(new s.P(this._helper._width, 0)), b = this.screenPointToMercatorCoordinate(new s.P(this._helper._width, this._helper._height)), w = this.screenPointToMercatorCoordinate(new s.P(0, this._helper._height)), T = Math.floor(Math.min(d.x, g.x, b.x, w.x)), I = Math.floor(Math.max(d.x, g.x, b.x, w.x)), R = 1;
              for (let z = T - R; z <= I + R; z++) z !== 0 && a.push(new s.b6(z, t));
            }
            return a;
          }
          getCameraFrustum() {
            return _a2.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
          }
          getClippingPlane() {
            return null;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(t) {
            const a = this.screenPointToLocation(this.centerPoint, t), d = t ? t.getElevationForLngLatZoom(a, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(d);
          }
          setLocationAtPoint(t, a) {
            const d = s.an(this.elevation, this.center.lat), g = this.screenPointToMercatorCoordinateAtZ(a, d), b = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, d), w = s.a5.fromLngLat(t), T = new s.a5(w.x - (g.x - b.x), w.y - (g.y - b.y));
            this.setCenter(T == null ? void 0 : T.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
          }
          locationToScreenPoint(t, a) {
            return a ? this.coordinatePoint(s.a5.fromLngLat(t), a.getElevationForLngLatZoom(t, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(s.a5.fromLngLat(t));
          }
          screenPointToLocation(t, a) {
            var d;
            return (d = this.screenPointToMercatorCoordinate(t, a)) === null || d === void 0 ? void 0 : d.toLngLat();
          }
          screenPointToMercatorCoordinate(t, a) {
            if (a) {
              const d = a.pointCoordinate(t);
              if (d != null) return d;
            }
            return this.screenPointToMercatorCoordinateAtZ(t);
          }
          screenPointToMercatorCoordinateAtZ(t, a) {
            const d = a || 0, g = [t.x, t.y, 0, 1], b = [t.x, t.y, 1, 1];
            s.aB(g, g, this._pixelMatrixInverse), s.aB(b, b, this._pixelMatrixInverse);
            const w = g[3], T = b[3], I = g[1] / w, R = b[1] / T, z = g[2] / w, W = b[2] / T, U = z === W ? 0 : (d - z) / (W - z);
            return new s.a5(s.F.number(g[0] / w, b[0] / T, U) / this.worldSize, s.F.number(I, R, U) / this.worldSize, d);
          }
          coordinatePoint(t, a = 0, d = this._pixelMatrix) {
            const g = [t.x * this.worldSize, t.y * this.worldSize, a, 1];
            return s.aB(g, g, d), new s.P(g[0] / g[3], g[1] / g[3]);
          }
          getBounds() {
            const t = Math.max(0, this._helper._height / 2 - Re(this));
            return new gt().extend(this.screenPointToLocation(new s.P(0, t))).extend(this.screenPointToLocation(new s.P(this._helper._width, t))).extend(this.screenPointToLocation(new s.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new s.P(0, this._helper._height)));
          }
          isPointOnMapSurface(t, a) {
            return a ? a.pointCoordinate(t) != null : t.y > this.height / 2 - Re(this);
          }
          calculatePosMatrix(t, a = false, d) {
            var g;
            const b = (g = t.key) !== null && g !== void 0 ? g : s.b7(t.wrap, t.canonical.z, t.canonical.z, t.canonical.x, t.canonical.y), w = a ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (w.has(b)) {
              const R = w.get(b);
              return d ? R.f32 : R.f64;
            }
            const T = se(t, this.worldSize);
            s.Q(T, a ? this._alignedProjMatrix : this._viewProjMatrix, T);
            const I = { f64: T, f32: new Float32Array(T) };
            return w.set(b, I), d ? I.f32 : I.f64;
          }
          calculateFogMatrix(t) {
            const a = t.key, d = this._fogMatrixCacheF32;
            if (d.has(a)) return d.get(a);
            const g = se(t, this.worldSize);
            return s.Q(g, this._fogMatrix, g), d.set(a, new Float32Array(g)), d.get(a);
          }
          calculateCenterFromCameraLngLatAlt(t, a, d, g) {
            return this._helper.calculateCenterFromCameraLngLatAlt(t, a, d, g);
          }
          _calculateNearFarZIfNeeded(t, a, d) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const g = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), b = t - g * this._helper._pixelPerMeter / Math.cos(a), w = g < 0 ? b : t, T = Math.PI / 2 + this.pitchInRadians, I = s.ak(this.fov) * (Math.abs(Math.cos(s.ak(this.roll))) * this.height + Math.abs(Math.sin(s.ak(this.roll))) * this.width) / this.height * (0.5 + d.y / this.height), R = Math.sin(I) * w / Math.sin(s.ai(Math.PI - T - I, 0.01, Math.PI - 0.01)), z = Re(this), W = Math.atan(z / this._helper.cameraToCenterDistance), U = s.ak(0.75), X = W > U ? 2 * W * (0.5 + d.y / (2 * z)) : U, re = Math.sin(X) * w / Math.sin(s.ai(Math.PI - T - X, 0.01, Math.PI - 0.01)), de = Math.min(R, re);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - a) * de + w), this._helper._nearZ = this._helper._height / 50;
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const t = this.centerOffset, a = ge(this.worldSize, this.center), d = a.x, g = a.y;
            this._helper._pixelPerMeter = s.an(1, this.center.lat) * this.worldSize;
            const b = s.ak(Math.min(this.pitch, Q)), w = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(b));
            let T;
            this._calculateNearFarZIfNeeded(w, b, t), T = new Float64Array(16), s.b8(T, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), s.av(this._invProjMatrix, T), T[8] = 2 * -t.x / this._helper._width, T[9] = 2 * t.y / this._helper._height, this._projectionMatrix = s.b9(T), s.O(T, T, [1, -1, 1]), s.N(T, T, [0, 0, -this._helper.cameraToCenterDistance]), s.ba(T, T, -this.rollInRadians), s.bb(T, T, this.pitchInRadians), s.ba(T, T, -this.bearingInRadians), s.N(T, T, [-d, -g, 0]), this._mercatorMatrix = s.O([], T, [this.worldSize, this.worldSize, this.worldSize]), s.O(T, T, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = s.Q(new Float64Array(16), this.clipSpaceToPixelsMatrix, T), s.N(T, T, [0, 0, -this.elevation]), this._viewProjMatrix = T, this._invViewProjMatrix = s.av([], T);
            const I = [0, 0, -1, 1];
            s.aB(I, I, this._invViewProjMatrix), this._cameraPosition = [I[0] / I[3], I[1] / I[3], I[2] / I[3]], this._fogMatrix = new Float64Array(16), s.b8(this._fogMatrix, this.fovInRadians, this.width / this.height, w, this._helper._farZ), this._fogMatrix[8] = 2 * -t.x / this.width, this._fogMatrix[9] = 2 * t.y / this.height, s.O(this._fogMatrix, this._fogMatrix, [1, -1, 1]), s.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), s.ba(this._fogMatrix, this._fogMatrix, -this.rollInRadians), s.bb(this._fogMatrix, this._fogMatrix, this.pitchInRadians), s.ba(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), s.N(this._fogMatrix, this._fogMatrix, [-d, -g, 0]), s.O(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), s.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = s.Q(new Float64Array(16), this.clipSpaceToPixelsMatrix, T);
            const R = this._helper._width % 2 / 2, z = this._helper._height % 2 / 2, W = Math.cos(this.bearingInRadians), U = Math.sin(-this.bearingInRadians), X = d - Math.round(d) + W * R + U * z, re = g - Math.round(g) + W * z + U * R, de = new Float64Array(T);
            if (s.N(de, de, [X > 0.5 ? X - 1 : X, re > 0.5 ? re - 1 : re, 0]), this._alignedProjMatrix = de, T = s.av(new Float64Array(16), this._pixelMatrix), !T) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = T, this._clearMatrixCaches();
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const t = this.screenPointToMercatorCoordinate(new s.P(0, 0)), a = [t.x * this.worldSize, t.y * this.worldSize, 0, 1];
            return s.aB(a, a, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            const t = s.an(1, this.center.lat) * this.worldSize;
            return Fe(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / t).toLngLat();
          }
          lngLatToCameraDepth(t, a) {
            const d = s.a5.fromLngLat(t), g = [d.x * this.worldSize, d.y * this.worldSize, a, 1];
            return s.aB(g, g, this._viewProjMatrix), g[2] / g[3];
          }
          getProjectionData(t) {
            const { overscaledTileID: a, aligned: d, applyTerrainMatrix: g } = t, b = this._helper.getMercatorTileCoordinates(a), w = a ? this.calculatePosMatrix(a, d, true) : null;
            let T;
            return T = a && a.terrainRttPosMatrix32f && g ? a.terrainRttPosMatrix32f : w || s.bc(), { mainMatrix: T, tileMercatorCoords: b, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: T };
          }
          isLocationOccluded(t) {
            return false;
          }
          getPixelScale() {
            return 1;
          }
          getCircleRadiusCorrection() {
            return 1;
          }
          getPitchedTextCorrection(t, a, d) {
            return 1;
          }
          transformLightDirection(t) {
            return s.aX(t);
          }
          getRayDirectionFromPixel(t) {
            throw new Error("Not implemented.");
          }
          projectTileCoordinates(t, a, d, g) {
            const b = this.calculatePosMatrix(d);
            let w;
            g ? (w = [t, a, g(t, a), 1], s.aB(w, w, b)) : (w = [t, a, 0, 1], Na(w, w, b));
            const T = w[3];
            return { point: new s.P(w[0] / T, w[1] / T), signedDistanceFromCamera: T, isOccluded: false };
          }
          populateCache(t) {
            for (const a of t) this.calculatePosMatrix(a);
          }
          getMatrixForModel(t, a) {
            const d = s.a5.fromLngLat(t, a), g = d.meterInMercatorCoordinateUnits(), b = s.bd();
            return s.N(b, b, [d.x, d.y, d.z]), s.ba(b, b, Math.PI), s.bb(b, b, Math.PI / 2), s.O(b, b, [-g, g, g]), b;
          }
          getProjectionDataForCustomLayer(t = true) {
            const a = new s.a0(0, 0, 0, 0, 0), d = this.getProjectionData({ overscaledTileID: a, applyGlobeMatrix: t }), g = se(a, this.worldSize);
            s.Q(g, this._viewProjMatrix, g), d.tileMercatorCoords = [0, 0, 1, 1];
            const b = [s.a3, s.a3, this.worldSize / this._helper.pixelsPerMeter], w = s.be();
            return s.O(w, g, b), d.fallbackMatrix = w, d.mainMatrix = w, d;
          }
          getFastPathSimpleProjectionMatrix(t) {
            return this.calculatePosMatrix(t);
          }
        }
        function ps() {
          s.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }
        function ba(_) {
          if (_.useSlerp) if (_.k < 1) {
            const t = s.bf(_.startEulerAngles.roll, _.startEulerAngles.pitch, _.startEulerAngles.bearing), a = s.bf(_.endEulerAngles.roll, _.endEulerAngles.pitch, _.endEulerAngles.bearing), d = new Float64Array(4);
            s.bg(d, t, a, _.k);
            const g = s.bh(d);
            _.tr.setRoll(g.roll), _.tr.setPitch(g.pitch), _.tr.setBearing(g.bearing);
          } else _.tr.setRoll(_.endEulerAngles.roll), _.tr.setPitch(_.endEulerAngles.pitch), _.tr.setBearing(_.endEulerAngles.bearing);
          else _.tr.setRoll(s.F.number(_.startEulerAngles.roll, _.endEulerAngles.roll, _.k)), _.tr.setPitch(s.F.number(_.startEulerAngles.pitch, _.endEulerAngles.pitch, _.k)), _.tr.setBearing(s.F.number(_.startEulerAngles.bearing, _.endEulerAngles.bearing, _.k));
        }
        function Qs(_, t, a, d, g) {
          const b = g.padding, w = ge(g.worldSize, a.getNorthWest()), T = ge(g.worldSize, a.getNorthEast()), I = ge(g.worldSize, a.getSouthEast()), R = ge(g.worldSize, a.getSouthWest()), z = s.ak(-d), W = w.rotate(z), U = T.rotate(z), X = I.rotate(z), re = R.rotate(z), de = new s.P(Math.max(W.x, U.x, re.x, X.x), Math.max(W.y, U.y, re.y, X.y)), fe = new s.P(Math.min(W.x, U.x, re.x, X.x), Math.min(W.y, U.y, re.y, X.y)), me = de.sub(fe), Ce = (g.width - (b.left + b.right + t.left + t.right)) / me.x, Pe = (g.height - (b.top + b.bottom + t.top + t.bottom)) / me.y;
          if (Pe < 0 || Ce < 0) return void ps();
          const xe = Math.min(s.ao(g.scale * Math.min(Ce, Pe)), _.maxZoom), Ie = s.P.convert(_.offset), De = new s.P((t.left - t.right) / 2, (t.top - t.bottom) / 2).rotate(s.ak(d)), Se = Ie.add(De).mult(g.scale / s.al(xe));
          return { center: _e(g.worldSize, w.add(I).div(2).sub(Se)), zoom: xe, bearing: d };
        }
        class On {
          get useGlobeControls() {
            return false;
          }
          handlePanInertia(t, a) {
            const d = t.mag(), g = Math.abs(Re(a));
            return { easingOffset: t.mult(Math.min(0.75 * g / d, 1)), easingCenter: a.center };
          }
          handleMapControlsRollPitchBearingZoom(t, a) {
            t.bearingDelta && a.setBearing(a.bearing + t.bearingDelta), t.pitchDelta && a.setPitch(a.pitch + t.pitchDelta), t.rollDelta && a.setRoll(a.roll + t.rollDelta), t.zoomDelta && a.setZoom(a.zoom + t.zoomDelta);
          }
          handleMapControlsPan(t, a, d) {
            t.around.distSqr(a.centerPoint) < 0.01 || a.setLocationAtPoint(d, t.around);
          }
          cameraForBoxAndBearing(t, a, d, g, b) {
            return Qs(t, a, d, g, b);
          }
          handleJumpToCenterZoom(t, a) {
            t.zoom !== (a.zoom !== void 0 ? +a.zoom : t.zoom) && t.setZoom(+a.zoom), a.center !== void 0 && t.setCenter(s.U.convert(a.center));
          }
          handleEaseTo(t, a) {
            const d = t.zoom, g = t.padding, b = { roll: t.roll, pitch: t.pitch, bearing: t.bearing }, w = { roll: a.roll === void 0 ? t.roll : a.roll, pitch: a.pitch === void 0 ? t.pitch : a.pitch, bearing: a.bearing === void 0 ? t.bearing : a.bearing }, T = a.zoom !== void 0, I = !t.isPaddingEqual(a.padding);
            let R = false;
            const z = T ? +a.zoom : t.zoom;
            let W = t.centerPoint.add(a.offsetAsPoint);
            const U = t.screenPointToLocation(W), { center: X, zoom: re } = t.applyConstrain(s.U.convert(a.center || U), z ?? d);
            cu(t, X);
            const de = ge(t.worldSize, U), fe = ge(t.worldSize, X).sub(de), me = s.al(re - d);
            return R = re !== d, { easeFunc: (Ce) => {
              if (R && t.setZoom(s.F.number(d, re, Ce)), s.bi(b, w) || ba({ startEulerAngles: b, endEulerAngles: w, tr: t, k: Ce, useSlerp: b.roll != w.roll }), I && (t.interpolatePadding(g, a.padding, Ce), W = t.centerPoint.add(a.offsetAsPoint)), a.around) t.setLocationAtPoint(a.around, a.aroundPoint);
              else {
                const Pe = s.al(t.zoom - d), xe = re > d ? Math.min(2, me) : Math.max(0.5, me), Ie = Math.pow(xe, 1 - Ce), De = _e(t.worldSize, de.add(fe.mult(Ce * Ie)).mult(Pe));
                t.setLocationAtPoint(t.renderWorldCopies ? De.wrap() : De, W);
              }
            }, isZooming: R, elevationCenter: X };
          }
          handleFlyTo(t, a) {
            const d = a.zoom !== void 0, g = t.zoom, b = t.applyConstrain(s.U.convert(a.center || a.locationAtOffset), d ? +a.zoom : g), w = b.center, T = b.zoom;
            cu(t, w);
            const I = ge(t.worldSize, a.locationAtOffset), R = ge(t.worldSize, w).sub(I), z = R.mag(), W = s.al(T - g);
            let U;
            if (a.minZoom !== void 0) {
              const X = Math.min(+a.minZoom, g, T), re = t.applyConstrain(w, X).zoom;
              U = s.al(re - g);
            }
            return { easeFunc: (X, re, de, fe) => {
              t.setZoom(X === 1 ? T : g + s.ao(re));
              const me = X === 1 ? w : _e(t.worldSize, I.add(R.mult(de)).mult(re));
              t.setLocationAtPoint(t.renderWorldCopies ? me.wrap() : me, fe);
            }, scaleOfZoom: W, targetCenter: w, scaleOfMinZoom: U, pixelPathLength: z };
          }
        }
        class ti {
          constructor(t, a, d) {
            this.blendFunction = t, this.blendColor = a, this.mask = d;
          }
        }
        ti.Replace = [1, 0], ti.disabled = new ti(ti.Replace, s.bj.transparent, [false, false, false, false]), ti.unblended = new ti(ti.Replace, s.bj.transparent, [true, true, true, true]), ti.alphaBlended = new ti([1, 771], s.bj.transparent, [true, true, true, true]);
        const No = 2305;
        class Ar {
          constructor(t, a, d) {
            this.enable = t, this.mode = a, this.frontFace = d;
          }
        }
        Ar.disabled = new Ar(false, 1029, No), Ar.backCCW = new Ar(true, 1029, No), Ar.frontCCW = new Ar(true, 1028, No);
        class gr {
          constructor(t, a, d) {
            this.func = t, this.mask = a, this.range = d;
          }
        }
        gr.ReadOnly = false, gr.ReadWrite = true, gr.disabled = new gr(519, gr.ReadOnly, [0, 1]);
        const ms = 7680;
        class Mr {
          constructor(t, a, d, g, b, w) {
            this.test = t, this.ref = a, this.mask = d, this.fail = g, this.depthFail = b, this.pass = w;
          }
        }
        Mr.disabled = new Mr({ func: 519, mask: 0 }, 0, 0, ms, ms, ms);
        const gs = /* @__PURE__ */ new WeakMap();
        function vo(_) {
          var t;
          if (gs.has(_)) return gs.get(_);
          {
            const a = (t = _.getParameter(_.VERSION)) === null || t === void 0 ? void 0 : t.startsWith("WebGL 2.0");
            return gs.set(_, a), a;
          }
        }
        class el {
          get awaitingQuery() {
            return !!this._readbackQueue;
          }
          constructor(t) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = t;
            const a = t.context, d = a.gl;
            this._texFormat = d.RGBA, this._texType = d.UNSIGNED_BYTE;
            const g = new s.aQ();
            g.emplaceBack(-1, -1), g.emplaceBack(2, -1), g.emplaceBack(-1, 2);
            const b = new s.aS();
            b.emplaceBack(0, 1, 2), this._fullscreenTriangle = new ya(a.createVertexBuffer(g, Mi.members), a.createIndexBuffer(b), s.aR.simpleSegment(0, 0, g.length, b.length)), this._resultBuffer = new Uint8Array(4), a.activeTexture.set(d.TEXTURE1);
            const w = d.createTexture();
            d.bindTexture(d.TEXTURE_2D, w), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, d.NEAREST), d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.NEAREST), d.texImage2D(d.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = a.createFramebuffer(this._texWidth, this._texHeight, false, false), this._fbo.colorAttachment.set(w), vo(d) && (this._pbo = d.createBuffer(), d.bindBuffer(d.PIXEL_PACK_BUFFER, this._pbo), d.bufferData(d.PIXEL_PACK_BUFFER, 4, d.STREAM_READ), d.bindBuffer(d.PIXEL_PACK_BUFFER, null));
          }
          destroy() {
            const t = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), t.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
          }
          updateErrorLoop(t, a) {
            const d = this._updateCount;
            return this._readbackQueue ? d >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : d >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(t, a), this._updateCount++, this._measuredError;
          }
          _bindFramebuffer() {
            const t = this._cachedRenderContext.context, a = t.gl;
            t.activeTexture.set(a.TEXTURE1), a.bindTexture(a.TEXTURE_2D, this._fbo.colorAttachment.get()), t.bindFramebuffer.set(this._fbo.framebuffer);
          }
          _renderErrorTexture(t, a) {
            const d = this._cachedRenderContext.context, g = d.gl;
            if (this._bindFramebuffer(), d.viewport.set([0, 0, this._texWidth, this._texHeight]), d.clear({ color: s.bj.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(d, g.TRIANGLES, gr.disabled, Mr.disabled, ti.unblended, Ar.disabled, /* @__PURE__ */ ((b, w) => ({ u_input: b, u_output_expected: w }))(t, a), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && vo(g)) {
              g.bindBuffer(g.PIXEL_PACK_BUFFER, this._pbo), g.readBuffer(g.COLOR_ATTACHMENT0), g.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), g.bindBuffer(g.PIXEL_PACK_BUFFER, null);
              const b = g.fenceSync(g.SYNC_GPU_COMMANDS_COMPLETE, 0);
              g.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: b };
            } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
          }
          _tryReadback() {
            const t = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && vo(t)) {
              const a = t.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (a === t.WAIT_FAILED) return s.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
              if (a === t.TIMEOUT_EXPIRED) return;
              t.bindBuffer(t.PIXEL_PACK_BUFFER, this._pbo), t.getBufferSubData(t.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), t.bindBuffer(t.PIXEL_PACK_BUFFER, null);
            } else this._bindFramebuffer(), t.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = el._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
          }
          static _parseRGBA8float(t) {
            let a = 0;
            return a += t[0] / 256, a += t[1] / 65536, a += t[2] / 16777216, t[3] < 127 && (a = -a), a / 128;
          }
        }
        const ja = s.a3 / 128;
        function du(_, t) {
          const a = _.granularity !== void 0 ? Math.max(_.granularity, 1) : 1, d = a + (_.generateBorders ? 2 : 0), g = a + (_.extendToNorthPole || _.generateBorders ? 1 : 0) + (_.extendToSouthPole || _.generateBorders ? 1 : 0), b = d + 1, w = g + 1, T = _.generateBorders ? -1 : 0, I = _.generateBorders || _.extendToNorthPole ? -1 : 0, R = a + (_.generateBorders ? 1 : 0), z = a + (_.generateBorders || _.extendToSouthPole ? 1 : 0), W = b * w, U = d * g * 6, X = b * w > 65536;
          if (X && t === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const re = X || t === "32bit", de = new Int16Array(2 * W);
          let fe = 0;
          for (let Pe = I; Pe <= z; Pe++) for (let xe = T; xe <= R; xe++) {
            let Ie = xe / a * s.a3;
            xe === -1 && (Ie = -ja), xe === a + 1 && (Ie = s.a3 + ja);
            let De = Pe / a * s.a3;
            Pe === -1 && (De = _.extendToNorthPole ? s.bl : -ja), Pe === a + 1 && (De = _.extendToSouthPole ? s.bm : s.a3 + ja), de[fe++] = Ie, de[fe++] = De;
          }
          const me = re ? new Uint32Array(U) : new Uint16Array(U);
          let Ce = 0;
          for (let Pe = 0; Pe < g; Pe++) for (let xe = 0; xe < d; xe++) {
            const Ie = xe + 1 + Pe * b, De = xe + (Pe + 1) * b, Se = xe + 1 + (Pe + 1) * b;
            me[Ce++] = xe + Pe * b, me[Ce++] = De, me[Ce++] = Ie, me[Ce++] = Ie, me[Ce++] = De, me[Ce++] = Se;
          }
          return { vertices: de.buffer.slice(0), indices: me.buffer.slice(0), uses32bitIndices: re };
        }
        const tl = new s.aP({ fill: new s.bn(128, 2), line: new s.bn(512, 0), tile: new s.bn(128, 32), stencil: new s.bn(128, 1), circle: 3 });
        class rl {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
          }
          get name() {
            return "vertical-perspective";
          }
          get transitionState() {
            return 1;
          }
          get useSubdivision() {
            return true;
          }
          get shaderVariantName() {
            return "globe";
          }
          get shaderDefine() {
            return "#define GLOBE";
          }
          get shaderPreludeCode() {
            return no.projectionGlobe;
          }
          get vertexShaderPreludeCode() {
            return no.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return tl;
          }
          get useGlobeControls() {
            return true;
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable;
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy();
          }
          updateGPUdependent(t) {
            this._errorMeasurement || (this._errorMeasurement = new el(t));
            const a = s.W(this._errorQueryLatitudeDegrees), d = 2 * Math.atan(Math.exp(Math.PI - a * Math.PI * 2)) - 0.5 * Math.PI, g = this._errorMeasurement.updateErrorLoop(a, d), b = q();
            g !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = g, this._errorMeasurementLastChangeTime = b);
            const w = Math.min(Math.max((b - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
            this._errorCorrectionUsable = s.bo(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, s.bp(w));
          }
          _getMeshKey(t) {
            return `${t.granularity.toString(36)}_${t.generateBorders ? "b" : ""}${t.extendToNorthPole ? "n" : ""}${t.extendToSouthPole ? "s" : ""}`;
          }
          getMeshFromTileID(t, a, d, g, b) {
            const w = (b === "stencil" ? tl.stencil : tl.tile).getGranularityForZoomLevel(a.z);
            return this._getMesh(t, { granularity: w, generateBorders: d, extendToNorthPole: a.y === 0 && g, extendToSouthPole: a.y === (1 << a.z) - 1 && g });
          }
          _getMesh(t, a) {
            const d = this._getMeshKey(a);
            if (d in this._tileMeshCache) return this._tileMeshCache[d];
            const g = (function(b, w) {
              const T = du(w, "16bit"), I = s.aQ.deserialize({ arrayBuffer: T.vertices, length: T.vertices.byteLength / 2 / 2 }), R = s.aS.deserialize({ arrayBuffer: T.indices, length: T.indices.byteLength / 2 / 3 });
              return new ya(b.createVertexBuffer(I, Mi.members), b.createIndexBuffer(R), s.aR.simpleSegment(0, 0, I.length, R.length));
            })(t, a);
            return this._tileMeshCache[d] = g, g;
          }
          recalculate(t) {
          }
          hasTransition() {
            const t = q();
            let a = false;
            return a = a || (t - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, a = a || this._errorMeasurement && this._errorMeasurement.awaitingQuery, a;
          }
          setErrorQueryLatitudeDegrees(t) {
            this._errorQueryLatitudeDegrees = t;
          }
        }
        const hu = new s.t({ type: new s.D(s.u.projection.type) });
        class vs extends s.E {
          constructor(t) {
            super(), this._transitionable = new s.x(hu, void 0), this.setProjection(t), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.G(0)), this._mercatorProjection = new Oi(), this._verticalPerspectiveProjection = new rl();
          }
          get transitionState() {
            const t = this.properties.get("type");
            if (typeof t == "string" && t === "mercator") return 0;
            if (typeof t == "string" && t === "vertical-perspective") return 1;
            if (t instanceof s.bq) {
              if (t.from === "vertical-perspective" && t.to === "mercator") return 1 - t.transition;
              if (t.from === "mercator" && t.to === "vertical-perspective") return t.transition;
            }
            return 1;
          }
          get useGlobeRendering() {
            return this.transitionState > 0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
          }
          get name() {
            return "globe";
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision;
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName;
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine;
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode;
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode;
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity;
          }
          get useGlobeControls() {
            return this.transitionState > 0;
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
          }
          updateGPUdependent(t) {
            this._mercatorProjection.updateGPUdependent(t), this._verticalPerspectiveProjection.updateGPUdependent(t);
          }
          getMeshFromTileID(t, a, d, g, b) {
            return this.currentProjection.getMeshFromTileID(t, a, d, g, b);
          }
          setProjection(t) {
            this._transitionable.setValue("type", (t == null ? void 0 : t.type) || "mercator");
          }
          updateTransitions(t) {
            this._transitioning = this._transitionable.transitioned(t, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
          }
          recalculate(t) {
            this.properties = this._transitioning.possiblyEvaluate(t);
          }
          setErrorQueryLatitudeDegrees(t) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(t), this._mercatorProjection.setErrorQueryLatitudeDegrees(t);
          }
        }
        function Hh(_) {
          const t = fu(_.worldSize, _.center.lat);
          return 2 * Math.PI * t;
        }
        function jo(_, t, a, d, g) {
          const b = 1 / (1 << g), w = t / s.a3 * b + d * b, T = s.bs((_ / s.a3 * b + a * b) * Math.PI * 2 + Math.PI, 2 * Math.PI), I = 2 * Math.atan(Math.exp(Math.PI - w * Math.PI * 2)) - 0.5 * Math.PI, R = Math.cos(I), z = new Float64Array(3);
          return z[0] = Math.sin(T) * R, z[1] = Math.sin(I), z[2] = Math.cos(T) * R, z;
        }
        function tn(_) {
          return (function(t, a) {
            const d = Math.cos(a), g = new Float64Array(3);
            return g[0] = Math.sin(t) * d, g[1] = Math.sin(a), g[2] = Math.cos(t) * d, g;
          })(_.lng * Math.PI / 180, _.lat * Math.PI / 180);
        }
        function fu(_, t) {
          return _ / (2 * Math.PI) / Math.cos(t * Math.PI / 180);
        }
        function Xh(_) {
          const t = Math.asin(_[1]) / Math.PI * 180, a = Math.sqrt(_[0] * _[0] + _[2] * _[2]);
          if (a > 1e-6) {
            const d = _[0] / a, g = Math.acos(_[2] / a), b = (d > 0 ? g : -g) / Math.PI * 180;
            return new s.U(s.V(b, -180, 180), t);
          }
          return new s.U(0, t);
        }
        function rn(_) {
          return Math.cos(_ * Math.PI / 180);
        }
        function Di(_, t) {
          const a = rn(_), d = rn(t);
          return s.ao(d / a);
        }
        function yo(_, t) {
          const a = _.rotate(t.bearingInRadians), d = t.zoom + Di(t.center.lat, 0), g = s.bo(1 / rn(t.center.lat), 1 / rn(Math.min(Math.abs(t.center.lat), 60)), s.br(d, 7, 3, 0, 1)), b = 360 / Hh({ worldSize: t.worldSize, center: { lat: t.center.lat } });
          return new s.U(t.center.lng - a.x * b * g, s.ai(t.center.lat + a.y * b, -s.aj, s.aj));
        }
        function ys(_) {
          const t = 0.5 * _, a = Math.sin(t), d = Math.cos(t);
          return Math.log(a + d) - Math.log(d - a);
        }
        function Zc(_, t, a, d) {
          const g = _.lat + a * d;
          if (Math.abs(a) > 1) {
            const b = (Math.sign(_.lat + a) !== Math.sign(_.lat) ? -Math.abs(_.lat) : Math.abs(_.lat)) * Math.PI / 180, w = Math.abs(_.lat + a) * Math.PI / 180, T = ys(b + d * (w - b)), I = ys(b), R = ys(w);
            return new s.U(_.lng + t * ((T - I) / (R - I)), g);
          }
          return new s.U(_.lng + t * d, g);
        }
        class Yh {
          constructor(t) {
            this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = false, this._boundingVolumeFactory = t;
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const t = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = t, this._cache.clear(), this._hadAnyChanges = false;
          }
          getTileBoundingVolume(t, a, d, g) {
            const b = `${t.z}_${t.x}_${t.y}_${(g == null ? void 0 : g.terrain) ? "t" : ""}`, w = this._cache.get(b);
            if (w) return w;
            const T = this._cachePrevious.get(b);
            if (T) return this._cache.set(b, T), T;
            const I = this._boundingVolumeFactory(t, a, d, g);
            return this._cache.set(b, I), this._hadAnyChanges = true, I;
          }
        }
        class _o {
          constructor(t, a, d, g) {
            this.min = d, this.max = g, this.points = t, this.planes = a;
          }
          static fromAabb(t, a) {
            const d = [];
            for (let g = 0; g < 8; g++) d.push([1 & ~g ? t[0] : a[0], (g >> 1 & 1) == 1 ? a[1] : t[1], (g >> 2 & 1) == 1 ? a[2] : t[2]]);
            return new _o(d, [[-1, 0, 0, a[0]], [1, 0, 0, -t[0]], [0, -1, 0, a[1]], [0, 1, 0, -t[1]], [0, 0, -1, a[2]], [0, 0, 1, -t[2]]], t, a);
          }
          static fromCenterSizeAngles(t, a, d) {
            const g = s.bv([], d[0], d[1], d[2]), b = s.bw([], [a[0], 0, 0], g), w = s.bw([], [0, a[1], 0], g), T = s.bw([], [0, 0, a[2]], g), I = [...t], R = [...t];
            for (let W = 0; W < 8; W++) for (let U = 0; U < 3; U++) {
              const X = t[U] + b[U] * (1 & ~W ? -1 : 1) + w[U] * ((W >> 1 & 1) == 1 ? 1 : -1) + T[U] * ((W >> 2 & 1) == 1 ? 1 : -1);
              I[U] = Math.min(I[U], X), R[U] = Math.max(R[U], X);
            }
            const z = [];
            for (let W = 0; W < 8; W++) {
              const U = [...t];
              s.aW(U, U, s.aV([], b, 1 & ~W ? -1 : 1)), s.aW(U, U, s.aV([], w, (W >> 1 & 1) == 1 ? 1 : -1)), s.aW(U, U, s.aV([], T, (W >> 2 & 1) == 1 ? 1 : -1)), z.push(U);
            }
            return new _o(z, [[...b, -s.a$(b, z[0])], [...w, -s.a$(w, z[0])], [...T, -s.a$(T, z[0])], [-b[0], -b[1], -b[2], -s.a$(b, z[7])], [-w[0], -w[1], -w[2], -s.a$(w, z[7])], [-T[0], -T[1], -T[2], -s.a$(T, z[7])]], I, R);
          }
          intersectsFrustum(t) {
            let a = true;
            const d = this.points.length, g = this.planes.length, b = t.planes.length, w = t.points.length;
            for (let T = 0; T < b; T++) {
              const I = t.planes[T];
              let R = 0;
              for (let z = 0; z < d; z++) {
                const W = this.points[z];
                I[0] * W[0] + I[1] * W[1] + I[2] * W[2] + I[3] >= 0 && R++;
              }
              if (R === 0) return 0;
              R < d && (a = false);
            }
            if (a) return 2;
            for (let T = 0; T < g; T++) {
              const I = this.planes[T];
              let R = 0;
              for (let z = 0; z < w; z++) {
                const W = t.points[z];
                I[0] * W[0] + I[1] * W[1] + I[2] * W[2] + I[3] >= 0 && R++;
              }
              if (R === 0) return 0;
            }
            return 1;
          }
          intersectsPlane(t) {
            const a = this.points.length;
            let d = 0;
            for (let g = 0; g < a; g++) {
              const b = this.points[g];
              t[0] * b[0] + t[1] * b[1] + t[2] * b[2] + t[3] >= 0 && d++;
            }
            return d === a ? 2 : d === 0 ? 0 : 1;
          }
        }
        function pu(_, t, a) {
          const d = _ - t;
          return d < 0 ? -d : Math.max(0, d - a);
        }
        function Hc(_, t, a, d, g) {
          const b = _ - a;
          let w;
          return w = b < 0 ? Math.min(-b, 1 + b - g) : b > 1 ? Math.min(Math.max(b - g, 0), 1 - b) : 0, Math.max(w, pu(t, d, g));
        }
        class Cm {
          constructor() {
            this._boundingVolumeCache = new Yh(this._computeTileBoundingVolume);
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers();
          }
          distanceToTile2d(t, a, d, g) {
            const b = 1 << d.z, w = 1 / b, T = d.x / b, I = d.y / b;
            let R = 2;
            return R = Math.min(R, Hc(t, a, T, I, w)), R = Math.min(R, Hc(t, a, T + 0.5, -I - w, w)), R = Math.min(R, Hc(t, a, T + 0.5, 2 - I - w, w)), R;
          }
          getWrap(t, a, d) {
            const g = 1 << a.z, b = 1 / g, w = a.x / g, T = pu(t.x, w, b), I = pu(t.x, w - 1, b), R = pu(t.x, w + 1, b), z = Math.min(T, I, R);
            return z === R ? 1 : z === I ? -1 : 0;
          }
          allowVariableZoom(t, a) {
            return qt(t, a) > 4;
          }
          allowWorldCopies() {
            return false;
          }
          getTileBoundingVolume(t, a, d, g) {
            return this._boundingVolumeCache.getTileBoundingVolume(t, a, d, g);
          }
          _computeTileBoundingVolume(t, a, d, g) {
            var b, w;
            let T = 0, I = 0;
            if (g == null ? void 0 : g.terrain) {
              const R = new s.a0(t.z, a, t.z, t.x, t.y), z = g.terrain.getMinMaxElevation(R);
              T = (b = z.minElevation) !== null && b !== void 0 ? b : Math.min(0, d), I = (w = z.maxElevation) !== null && w !== void 0 ? w : Math.max(0, d);
            }
            if (T /= s.by, I /= s.by, T += 1, I += 1, t.z <= 0) return _o.fromAabb([-I, -I, -I], [I, I, I]);
            if (t.z === 1) return _o.fromAabb([t.x === 0 ? -I : 0, t.y === 0 ? 0 : -I, -I], [t.x === 0 ? 0 : I, t.y === 0 ? I : 0, I]);
            {
              const R = [jo(0, 0, t.x, t.y, t.z), jo(s.a3, 0, t.x, t.y, t.z), jo(s.a3, s.a3, t.x, t.y, t.z), jo(0, s.a3, t.x, t.y, t.z)], z = [];
              for (const He of R) z.push(s.aV([], He, I));
              if (I !== T) for (const He of R) z.push(s.aV([], He, T));
              t.y === 0 && z.push([0, 1, 0]), t.y === (1 << t.z) - 1 && z.push([0, -1, 0]);
              const W = [1, 1, 1], U = [-1, -1, -1];
              for (const He of z) for (let Je = 0; Je < 3; Je++) W[Je] = Math.min(W[Je], He[Je]), U[Je] = Math.max(U[Je], He[Je]);
              const X = jo(s.a3 / 2, s.a3 / 2, t.x, t.y, t.z), re = s.a_([], [0, 1, 0], X);
              s.aZ(re, re);
              const de = s.a_([], X, re);
              s.aZ(de, de);
              const fe = s.a_([], R[2], R[1]);
              s.aZ(fe, fe);
              const me = s.a_([], R[0], R[3]);
              s.aZ(me, me), z.push(s.aV([], X, I)), t.y >= (1 << t.z) / 2 && z.push(s.aV([], jo(s.a3 / 2, 0, t.x, t.y, t.z), I)), t.y < (1 << t.z) / 2 && z.push(s.aV([], jo(s.a3 / 2, s.a3, t.x, t.y, t.z), I));
              const Ce = Kh(X, z), Pe = Kh(de, z), xe = [-X[0], -X[1], -X[2], Ce.max], Ie = [X[0], X[1], X[2], -Ce.min], De = [-de[0], -de[1], -de[2], Pe.max], Se = [de[0], de[1], de[2], -Pe.min], Ne = [...fe, 0], Ke = [...me, 0], Ze = [];
              return t.y === 0 ? Ze.push(s.bx(Ke, Ne, xe), s.bx(Ke, Ne, Ie)) : Ze.push(s.bx(De, Ne, xe), s.bx(De, Ne, Ie), s.bx(De, Ke, xe), s.bx(De, Ke, Ie)), t.y === (1 << t.z) - 1 ? Ze.push(s.bx(Ke, Ne, xe), s.bx(Ke, Ne, Ie)) : Ze.push(s.bx(Se, Ne, xe), s.bx(Se, Ne, Ie), s.bx(Se, Ke, xe), s.bx(Se, Ke, Ie)), new _o(Ze, [xe, Ie, De, Se, Ne, Ke], W, U);
            }
          }
        }
        function Kh(_, t) {
          let a = 1 / 0, d = -1 / 0;
          for (const g of t) {
            const b = s.a$(_, g);
            a = Math.min(a, b), d = Math.max(d, b);
          }
          return { min: a, max: d };
        }
        class mu {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(t) {
            this._helper.setMinZoom(t);
          }
          setMaxZoom(t) {
            this._helper.setMaxZoom(t);
          }
          setMinPitch(t) {
            this._helper.setMinPitch(t);
          }
          setMaxPitch(t) {
            this._helper.setMaxPitch(t);
          }
          setRenderWorldCopies(t) {
            this._helper.setRenderWorldCopies(t);
          }
          setBearing(t) {
            this._helper.setBearing(t);
          }
          setPitch(t) {
            this._helper.setPitch(t);
          }
          setRoll(t) {
            this._helper.setRoll(t);
          }
          setFov(t) {
            this._helper.setFov(t);
          }
          setZoom(t) {
            this._helper.setZoom(t);
          }
          setCenter(t) {
            this._helper.setCenter(t);
          }
          setElevation(t) {
            this._helper.setElevation(t);
          }
          setMinElevationForCurrentTile(t) {
            this._helper.setMinElevationForCurrentTile(t);
          }
          setPadding(t) {
            this._helper.setPadding(t);
          }
          interpolatePadding(t, a, d) {
            return this._helper.interpolatePadding(t, a, d);
          }
          isPaddingEqual(t) {
            return this._helper.isPaddingEqual(t);
          }
          resize(t, a) {
            this._helper.resize(t, a);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(t) {
            this._helper.setMaxBounds(t);
          }
          setConstrainOverride(t) {
            this._helper.setConstrainOverride(t);
          }
          overrideNearFarZ(t, a) {
            this._helper.overrideNearFarZ(t, a);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(t) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), t);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get constrainOverride() {
            return this._helper.constrainOverride;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(t) {
          }
          constructor(t) {
            this._cachedClippingPlane = s.bz(), this._projectionMatrix = s.bd(), this._globeViewProjMatrix32f = s.bc(), this._globeViewProjMatrixNoCorrection = s.bd(), this._globeViewProjMatrixNoCorrectionInverted = s.bd(), this._globeProjMatrixInverted = s.bd(), this._cameraPosition = s.bt(), this._globeLatitudeErrorCorrectionRadians = 0, this.defaultConstrain = (a, d) => {
              const g = s.ai(a.lat, -s.aj, s.aj), b = s.ai(+d, this.minZoom + Di(0, g), this.maxZoom);
              return { center: new s.U(a.lng, g), zoom: b };
            }, this.applyConstrain = (a, d) => this._helper.applyConstrain(a, d), this._helper = new Bn({ calcMatrices: () => {
              this._calcMatrices();
            }, defaultConstrain: (a, d) => this.defaultConstrain(a, d) }, t), this._coveringTilesDetailsProvider = new Cm();
          }
          clone() {
            const t = new mu();
            return t.apply(this), t;
          }
          apply(t, a) {
            this._globeLatitudeErrorCorrectionRadians = a || 0, this._helper.apply(t);
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection;
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted;
          }
          get cameraPosition() {
            const t = s.bt();
            return t[0] = this._cameraPosition[0], t[1] = this._cameraPosition[1], t[2] = this._cameraPosition[2], t;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          getProjectionData(t) {
            const { overscaledTileID: a, applyGlobeMatrix: d } = t, g = this._helper.getMercatorTileCoordinates(a);
            return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: g, clippingPlane: this._cachedClippingPlane, projectionTransition: d ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
          }
          _computeClippingPlane(t) {
            const a = this.pitchInRadians, d = this.cameraToCenterDistance / t, g = Math.sin(a) * d, b = Math.cos(a) * d + 1, w = 1 / Math.sqrt(g * g + b * b) * 1;
            let T = -g, I = b;
            const R = Math.sqrt(T * T + I * I);
            T /= R, I /= R;
            const z = [0, T, I];
            s.bA(z, z, [0, 0, 0], -this.bearingInRadians), s.bB(z, z, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), s.bC(z, z, [0, 0, 0], this.center.lng * Math.PI / 180);
            const W = 1 / s.b1(z);
            return s.aV(z, z, W), [...z, -w * W];
          }
          isLocationOccluded(t) {
            return !this.isSurfacePointVisible(tn(t));
          }
          transformLightDirection(t) {
            const a = this._helper._center.lng * Math.PI / 180, d = this._helper._center.lat * Math.PI / 180, g = Math.cos(d), b = [Math.sin(a) * g, Math.sin(d), Math.cos(a) * g], w = [b[2], 0, -b[0]], T = [0, 0, 0];
            s.a_(T, w, b), s.aZ(w, w), s.aZ(T, T);
            const I = [0, 0, 0];
            return s.aZ(I, [w[0] * t[0] + T[0] * t[1] + b[0] * t[2], w[1] * t[0] + T[1] * t[1] + b[1] * t[2], w[2] * t[0] + T[2] * t[1] + b[2] * t[2]]), I;
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getPitchedTextCorrection(t, a, d) {
            const g = (function(T, I, R) {
              const z = 1 / (1 << R.z);
              return new s.a5(T / s.a3 * z + R.x * z, I / s.a3 * z + R.y * z);
            })(t, a, d.canonical), b = (w = g.y, [s.bs(g.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - w * Math.PI * 2)) - 0.5 * Math.PI]);
            var w;
            return this.getCircleRadiusCorrection() / Math.cos(b[1]);
          }
          projectTileCoordinates(t, a, d, g) {
            const b = d.canonical, w = jo(t, a, b.x, b.y, b.z), T = 1 + (g ? g(t, a) : 0) / s.by, I = [w[0] * T, w[1] * T, w[2] * T, 1];
            s.aB(I, I, this._globeViewProjMatrixNoCorrection);
            const R = this._cachedClippingPlane, z = R[0] * w[0] + R[1] * w[1] + R[2] * w[2] + R[3] < 0;
            return { point: new s.P(I[0] / I[3], I[1] / I[3]), signedDistanceFromCamera: I[3], isOccluded: z };
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const t = fu(this.worldSize, this.center.lat), a = s.be(), d = s.be();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * t), s.b8(a, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const g = this.centerOffset;
            a[8] = 2 * -g.x / this._helper._width, a[9] = 2 * g.y / this._helper._height, this._projectionMatrix = s.b9(a), this._globeProjMatrixInverted = s.be(), s.av(this._globeProjMatrixInverted, a), s.N(a, a, [0, 0, -this.cameraToCenterDistance]), s.ba(a, a, this.rollInRadians), s.bb(a, a, -this.pitchInRadians), s.ba(a, a, this.bearingInRadians), s.N(a, a, [0, 0, -t]);
            const b = s.bt();
            b[0] = t, b[1] = t, b[2] = t, s.bb(d, a, this.center.lat * Math.PI / 180), s.bD(d, d, -this.center.lng * Math.PI / 180), s.O(d, d, b), this._globeViewProjMatrixNoCorrection = d, s.bb(a, a, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), s.bD(a, a, -this.center.lng * Math.PI / 180), s.O(a, a, b), this._globeViewProjMatrix32f = new Float32Array(a), this._globeViewProjMatrixNoCorrectionInverted = s.be(), s.av(this._globeViewProjMatrixNoCorrectionInverted, d);
            const w = s.bt();
            this._cameraPosition = s.bt(), this._cameraPosition[2] = this.cameraToCenterDistance / t, s.bA(this._cameraPosition, this._cameraPosition, w, -this.rollInRadians), s.bB(this._cameraPosition, this._cameraPosition, w, this.pitchInRadians), s.bA(this._cameraPosition, this._cameraPosition, w, -this.bearingInRadians), s.aW(this._cameraPosition, this._cameraPosition, [0, 0, 1]), s.bB(this._cameraPosition, this._cameraPosition, w, -this.center.lat * Math.PI / 180), s.bC(this._cameraPosition, this._cameraPosition, w, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(t);
            const T = s.b9(this._globeViewProjMatrixNoCorrectionInverted);
            s.O(T, T, [1, 1, -1]), this._cachedFrustum = _a2.fromInvProjectionMatrix(T, 1, 0, this._cachedClippingPlane, true);
          }
          calculateFogMatrix(t) {
            s.w("calculateFogMatrix is not supported on globe projection.");
            const a = s.be();
            return s.am(a), a;
          }
          getVisibleUnwrappedCoordinates(t) {
            return [new s.b6(0, t)];
          }
          getCameraFrustum() {
            return this._cachedFrustum;
          }
          getClippingPlane() {
            return this._cachedClippingPlane;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(t) {
            t && s.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
          }
          maxPitchScaleFactor() {
            return 1;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(t, a) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const d = tn(t);
            s.aV(d, d, 1 + a / s.by);
            const g = s.bz();
            return s.aB(g, [d[0], d[1], d[2], 1], this._globeViewProjMatrixNoCorrection), g[2] / g[3];
          }
          populateCache(t) {
          }
          getBounds() {
            const t = 0.5 * this.width, a = 0.5 * this.height, d = [new s.P(0, 0), new s.P(t, 0), new s.P(this.width, 0), new s.P(this.width, a), new s.P(this.width, this.height), new s.P(t, this.height), new s.P(0, this.height), new s.P(0, a)], g = [];
            for (const W of d) g.push(this.unprojectScreenPoint(W));
            let b = 0, w = 0, T = 0, I = 0;
            const R = this.center;
            for (const W of g) {
              const U = s.bE(R.lng, W.lng), X = s.bE(R.lat, W.lat);
              U < w && (w = U), U > b && (b = U), X < I && (I = X), X > T && (T = X);
            }
            const z = [R.lng + w, R.lat + I, R.lng + b, R.lat + T];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (z[3] = 90, z[0] = -180, z[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (z[1] = -90, z[0] = -180, z[2] = 180), new gt(z);
          }
          calculateCenterFromCameraLngLatAlt(t, a, d, g) {
            return this._helper.calculateCenterFromCameraLngLatAlt(t, a, d, g);
          }
          setLocationAtPoint(t, a) {
            const d = tn(this.unprojectScreenPoint(a)), g = tn(t), b = s.bt();
            s.bF(b);
            const w = s.bt();
            s.bC(w, d, b, -this.center.lng * Math.PI / 180), s.bB(w, w, b, this.center.lat * Math.PI / 180);
            const T = g[0] * g[0] + g[2] * g[2], I = w[0] * w[0];
            if (T < I) return;
            const R = Math.sqrt(T - I), z = -R, W = s.bG(g[0], g[2], w[0], R), U = s.bG(g[0], g[2], w[0], z), X = s.bt();
            s.bC(X, g, b, -W);
            const re = s.bG(X[1], X[2], w[1], w[2]), de = s.bt();
            s.bC(de, g, b, -U);
            const fe = s.bG(de[1], de[2], w[1], w[2]), me = 0.5 * Math.PI, Ce = re >= -me && re <= me, Pe = fe >= -me && fe <= me;
            let xe, Ie;
            if (Ce && Pe) {
              const Ke = this.center.lng * Math.PI / 180, Ze = this.center.lat * Math.PI / 180;
              s.bH(W, Ke) + s.bH(re, Ze) < s.bH(U, Ke) + s.bH(fe, Ze) ? (xe = W, Ie = re) : (xe = U, Ie = fe);
            } else if (Ce) xe = W, Ie = re;
            else {
              if (!Pe) return;
              xe = U, Ie = fe;
            }
            const De = xe / Math.PI * 180, Se = Ie / Math.PI * 180, Ne = this.center.lat;
            this.setCenter(new s.U(De, s.ai(Se, -90, 90))), this.setZoom(this.zoom + Di(Ne, this.center.lat));
          }
          locationToScreenPoint(t, a) {
            const d = tn(t);
            if (a) {
              const g = a.getElevationForLngLatZoom(t, this._helper._tileZoom);
              s.aV(d, d, 1 + g / s.by);
            }
            return this._projectSurfacePointToScreen(d);
          }
          _projectSurfacePointToScreen(t) {
            const a = s.bz();
            return s.aB(a, [...t, 1], this._globeViewProjMatrixNoCorrection), a[0] /= a[3], a[1] /= a[3], new s.P((0.5 * a[0] + 0.5) * this.width, (0.5 * -a[1] + 0.5) * this.height);
          }
          screenPointToMercatorCoordinate(t, a) {
            if (a) {
              const d = a.pointCoordinate(t);
              if (d) return d;
            }
            return s.a5.fromLngLat(this.unprojectScreenPoint(t));
          }
          screenPointToLocation(t, a) {
            var d;
            return (d = this.screenPointToMercatorCoordinate(t, a)) === null || d === void 0 ? void 0 : d.toLngLat();
          }
          isPointOnMapSurface(t, a) {
            const d = this._cameraPosition, g = this.getRayDirectionFromPixel(t);
            return !!this.rayPlanetIntersection(d, g);
          }
          getRayDirectionFromPixel(t) {
            const a = s.bz();
            a[0] = t.x / this.width * 2 - 1, a[1] = -1 * (t.y / this.height * 2 - 1), a[2] = 1, a[3] = 1, s.aB(a, a, this._globeViewProjMatrixNoCorrectionInverted), a[0] /= a[3], a[1] /= a[3], a[2] /= a[3];
            const d = s.bt();
            d[0] = a[0] - this._cameraPosition[0], d[1] = a[1] - this._cameraPosition[1], d[2] = a[2] - this._cameraPosition[2];
            const g = s.bt();
            return s.aZ(g, d), g;
          }
          isSurfacePointVisible(t) {
            const a = this._cachedClippingPlane;
            return a[0] * t[0] + a[1] * t[1] + a[2] * t[2] + a[3] >= 0;
          }
          isSurfacePointOnScreen(t) {
            if (!this.isSurfacePointVisible(t)) return false;
            const a = s.bz();
            return s.aB(a, [...t, 1], this._globeViewProjMatrixNoCorrection), a[0] /= a[3], a[1] /= a[3], a[2] /= a[3], a[0] > -1 && a[0] < 1 && a[1] > -1 && a[1] < 1 && a[2] > -1 && a[2] < 1;
          }
          rayPlanetIntersection(t, a) {
            const d = s.a$(t, a), g = s.bt(), b = s.bt();
            s.aV(b, a, d), s.aY(g, t, b);
            const w = 1 - s.a$(g, g);
            if (w < 0) return null;
            const T = s.a$(t, t) - 1, I = -d + (d < 0 ? 1 : -1) * Math.sqrt(w), R = T / I, z = I;
            return { tMin: Math.min(R, z), tMax: Math.max(R, z) };
          }
          unprojectScreenPoint(t) {
            const a = this._cameraPosition, d = this.getRayDirectionFromPixel(t), g = this.rayPlanetIntersection(a, d);
            if (g) {
              const z = s.bt();
              s.aW(z, a, [d[0] * g.tMin, d[1] * g.tMin, d[2] * g.tMin]);
              const W = s.bt();
              return s.aZ(W, z), Xh(W);
            }
            const b = this._cachedClippingPlane, w = b[0] * d[0] + b[1] * d[1] + b[2] * d[2], T = -s.b5(b, a) / w, I = s.bt();
            if (T > 0) s.aW(I, a, [d[0] * T, d[1] * T, d[2] * T]);
            else {
              const z = s.bt();
              s.aW(z, a, [2 * d[0], 2 * d[1], 2 * d[2]]);
              const W = s.b5(this._cachedClippingPlane, z);
              s.aY(I, z, [this._cachedClippingPlane[0] * W, this._cachedClippingPlane[1] * W, this._cachedClippingPlane[2] * W]);
            }
            const R = (function(z) {
              const W = s.bt();
              return W[0] = z[0] * -z[3], W[1] = z[1] * -z[3], W[2] = z[2] * -z[3], { center: W, radius: Math.sqrt(1 - z[3] * z[3]) };
            })(b);
            return Xh((function(z, W, U) {
              const X = s.bt();
              s.aY(X, U, z);
              const re = s.bt();
              return s.bu(re, z, X, W / s.b3(X)), re;
            })(R.center, R.radius, I));
          }
          getMatrixForModel(t, a) {
            const d = s.U.convert(t), g = 1 / s.by, b = s.bd();
            return s.bD(b, b, d.lng / 180 * Math.PI), s.bb(b, b, -d.lat / 180 * Math.PI), s.N(b, b, [0, 0, 1 + a / s.by]), s.bb(b, b, 0.5 * Math.PI), s.O(b, b, [g, g, g]), b;
          }
          getProjectionDataForCustomLayer(t = true) {
            const a = this.getProjectionData({ overscaledTileID: new s.a0(0, 0, 0, 0, 0), applyGlobeMatrix: t });
            return a.tileMercatorCoords = [0, 0, 1, 1], a;
          }
          getFastPathSimpleProjectionMatrix(t) {
          }
        }
        class gu {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(t) {
            this._helper.setMinZoom(t);
          }
          setMaxZoom(t) {
            this._helper.setMaxZoom(t);
          }
          setMinPitch(t) {
            this._helper.setMinPitch(t);
          }
          setMaxPitch(t) {
            this._helper.setMaxPitch(t);
          }
          setRenderWorldCopies(t) {
            this._helper.setRenderWorldCopies(t);
          }
          setBearing(t) {
            this._helper.setBearing(t);
          }
          setPitch(t) {
            this._helper.setPitch(t);
          }
          setRoll(t) {
            this._helper.setRoll(t);
          }
          setFov(t) {
            this._helper.setFov(t);
          }
          setZoom(t) {
            this._helper.setZoom(t);
          }
          setCenter(t) {
            this._helper.setCenter(t);
          }
          setElevation(t) {
            this._helper.setElevation(t);
          }
          setMinElevationForCurrentTile(t) {
            this._helper.setMinElevationForCurrentTile(t);
          }
          setPadding(t) {
            this._helper.setPadding(t);
          }
          interpolatePadding(t, a, d) {
            return this._helper.interpolatePadding(t, a, d);
          }
          isPaddingEqual(t) {
            return this._helper.isPaddingEqual(t);
          }
          resize(t, a, d = true) {
            this._helper.resize(t, a, d);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(t) {
            this._helper.setMaxBounds(t);
          }
          setConstrainOverride(t) {
            this._helper.setConstrainOverride(t);
          }
          overrideNearFarZ(t, a) {
            this._helper.overrideNearFarZ(t, a);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(t) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), t);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get constrainOverride() {
            return this._helper.constrainOverride;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          get isGlobeRendering() {
            return this._globeness > 0;
          }
          setTransitionState(t, a) {
            this._globeness = t, this._globeLatitudeErrorCorrectionRadians = a, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
          }
          constructor(t) {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this.defaultConstrain = (a, d) => this.currentTransform.defaultConstrain(a, d), this.applyConstrain = (a, d) => this._helper.applyConstrain(a, d), this._helper = new Bn({ calcMatrices: () => {
              this._calcMatrices();
            }, defaultConstrain: (a, d) => this.defaultConstrain(a, d) }, t), this._globeness = 1, this._mercatorTransform = new ei(), this._verticalPerspectiveTransform = new mu();
          }
          clone() {
            const t = new gu();
            return t._globeness = this._globeness, t._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, t.apply(this), t;
          }
          apply(t) {
            this._helper.apply(t), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix;
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix;
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition;
          }
          getProjectionData(t) {
            const a = this._mercatorTransform.getProjectionData(t), d = this._verticalPerspectiveTransform.getProjectionData(t);
            return { mainMatrix: this.isGlobeRendering ? d.mainMatrix : a.mainMatrix, clippingPlane: d.clippingPlane, tileMercatorCoords: d.tileMercatorCoords, projectionTransition: t.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: a.fallbackMatrix };
          }
          isLocationOccluded(t) {
            return this.currentTransform.isLocationOccluded(t);
          }
          transformLightDirection(t) {
            return this.currentTransform.transformLightDirection(t);
          }
          getPixelScale() {
            return s.bo(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
          }
          getCircleRadiusCorrection() {
            return s.bo(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
          }
          getPitchedTextCorrection(t, a, d) {
            const g = this._mercatorTransform.getPitchedTextCorrection(t, a, d), b = this._verticalPerspectiveTransform.getPitchedTextCorrection(t, a, d);
            return s.bo(g, b, this._globeness);
          }
          projectTileCoordinates(t, a, d, g) {
            return this.currentTransform.projectTileCoordinates(t, a, d, g);
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, true, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
          }
          calculateFogMatrix(t) {
            return this.currentTransform.calculateFogMatrix(t);
          }
          getVisibleUnwrappedCoordinates(t) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(t);
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum();
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane();
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider();
          }
          recalculateZoomAndCenter(t) {
            this._mercatorTransform.recalculateZoomAndCenter(t), this._verticalPerspectiveTransform.recalculateZoomAndCenter(t);
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor();
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(t, a) {
            return this.currentTransform.lngLatToCameraDepth(t, a);
          }
          populateCache(t) {
            this._mercatorTransform.populateCache(t), this._verticalPerspectiveTransform.populateCache(t);
          }
          getBounds() {
            return this.currentTransform.getBounds();
          }
          calculateCenterFromCameraLngLatAlt(t, a, d, g) {
            return this._helper.calculateCenterFromCameraLngLatAlt(t, a, d, g);
          }
          setLocationAtPoint(t, a) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(t, a), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(t, a), this.apply(this._verticalPerspectiveTransform);
          }
          locationToScreenPoint(t, a) {
            return this.currentTransform.locationToScreenPoint(t, a);
          }
          screenPointToMercatorCoordinate(t, a) {
            return this.currentTransform.screenPointToMercatorCoordinate(t, a);
          }
          screenPointToLocation(t, a) {
            return this.currentTransform.screenPointToLocation(t, a);
          }
          isPointOnMapSurface(t, a) {
            return this.currentTransform.isPointOnMapSurface(t, a);
          }
          getRayDirectionFromPixel(t) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(t);
          }
          getMatrixForModel(t, a) {
            return this.currentTransform.getMatrixForModel(t, a);
          }
          getProjectionDataForCustomLayer(t = true) {
            const a = this._mercatorTransform.getProjectionDataForCustomLayer(t);
            if (!this.isGlobeRendering) return a;
            const d = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(t);
            return d.fallbackMatrix = a.mainMatrix, d;
          }
          getFastPathSimpleProjectionMatrix(t) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(t);
          }
        }
        class $n {
          get useGlobeControls() {
            return true;
          }
          handlePanInertia(t, a) {
            const d = yo(t, a);
            return Math.abs(d.lng - a.center.lng) > 180 && (d.lng = a.center.lng + 179.5 * Math.sign(d.lng - a.center.lng)), { easingCenter: d, easingOffset: new s.P(0, 0) };
          }
          handleMapControlsRollPitchBearingZoom(t, a) {
            const d = t.around, g = a.screenPointToLocation(d);
            t.bearingDelta && a.setBearing(a.bearing + t.bearingDelta), t.pitchDelta && a.setPitch(a.pitch + t.pitchDelta), t.rollDelta && a.setRoll(a.roll + t.rollDelta);
            const b = a.zoom;
            t.zoomDelta && a.setZoom(a.zoom + t.zoomDelta);
            const w = a.zoom - b;
            if (w === 0) return;
            const T = s.bE(a.center.lng, g.lng), I = T / (Math.abs(T / 180) + 1), R = s.bE(a.center.lat, g.lat), z = a.getRayDirectionFromPixel(d), W = a.cameraPosition, U = -1 * s.a$(W, z), X = s.bt();
            s.aW(X, W, [z[0] * U, z[1] * U, z[2] * U]);
            const re = s.b1(X) - 1, de = Math.exp(0.5 * -Math.max(re - 0.3, 0)), fe = fu(a.worldSize, a.center.lat) / Math.min(a.width, a.height), me = s.br(fe, 0.9, 0.5, 1, 0.25), Ce = (1 - s.al(-w)) * Math.min(de, me), Pe = a.center.lat, xe = a.zoom, Ie = new s.U(a.center.lng + I * Ce, s.ai(a.center.lat + R * Ce, -s.aj, s.aj));
            a.setLocationAtPoint(g, d);
            const De = a.center, Se = s.br(Math.abs(T), 45, 85, 0, 1), Ne = s.br(fe, 0.75, 0.35, 0, 1), Ke = Math.pow(Math.max(Se, Ne), 0.25), Ze = s.bE(De.lng, Ie.lng), He = s.bE(De.lat, Ie.lat);
            a.setCenter(new s.U(De.lng + Ze * Ke, De.lat + He * Ke).wrap()), a.setZoom(xe + Di(Pe, a.center.lat));
          }
          handleMapControlsPan(t, a, d) {
            if (!t.panDelta) return;
            const g = a.center.lat, b = a.zoom;
            a.setCenter(yo(t.panDelta, a).wrap()), a.setZoom(b + Di(g, a.center.lat));
          }
          cameraForBoxAndBearing(t, a, d, g, b) {
            const w = Qs(t, a, d, g, b), T = a.left / b.width * 2 - 1, I = (b.width - a.right) / b.width * 2 - 1, R = a.top / b.height * -2 + 1, z = (b.height - a.bottom) / b.height * -2 + 1, W = s.bE(d.getWest(), d.getEast()) < 0, U = W ? d.getEast() : d.getWest(), X = W ? d.getWest() : d.getEast(), re = Math.max(d.getNorth(), d.getSouth()), de = Math.min(d.getNorth(), d.getSouth()), fe = U + 0.5 * s.bE(U, X), me = re + 0.5 * s.bE(re, de), Ce = b.clone();
            Ce.setCenter(w.center), Ce.setBearing(w.bearing), Ce.setPitch(0), Ce.setRoll(0), Ce.setZoom(w.zoom);
            const Pe = Ce.modelViewProjectionMatrix, xe = [tn(d.getNorthWest()), tn(d.getNorthEast()), tn(d.getSouthWest()), tn(d.getSouthEast()), tn(new s.U(X, me)), tn(new s.U(U, me)), tn(new s.U(fe, re)), tn(new s.U(fe, de))], Ie = tn(w.center);
            let De = Number.POSITIVE_INFINITY;
            for (const Se of xe) T < 0 && (De = $n.getLesserNonNegativeNonNull(De, $n.solveVectorScale(Se, Ie, Pe, "x", T))), I > 0 && (De = $n.getLesserNonNegativeNonNull(De, $n.solveVectorScale(Se, Ie, Pe, "x", I))), R > 0 && (De = $n.getLesserNonNegativeNonNull(De, $n.solveVectorScale(Se, Ie, Pe, "y", R))), z < 0 && (De = $n.getLesserNonNegativeNonNull(De, $n.solveVectorScale(Se, Ie, Pe, "y", z)));
            if (Number.isFinite(De) && De !== 0) return w.zoom = Ce.zoom + s.ao(De), w;
            ps();
          }
          handleJumpToCenterZoom(t, a) {
            const d = t.center.lat, g = t.applyConstrain(a.center ? s.U.convert(a.center) : t.center, t.zoom).center;
            t.setCenter(g.wrap());
            const b = a.zoom !== void 0 ? +a.zoom : t.zoom + Di(d, g.lat);
            t.zoom !== b && t.setZoom(b);
          }
          handleEaseTo(t, a) {
            const d = t.zoom, g = t.center, b = t.padding, w = { roll: t.roll, pitch: t.pitch, bearing: t.bearing }, T = { roll: a.roll === void 0 ? t.roll : a.roll, pitch: a.pitch === void 0 ? t.pitch : a.pitch, bearing: a.bearing === void 0 ? t.bearing : a.bearing }, I = a.zoom !== void 0, R = !t.isPaddingEqual(a.padding);
            let z = false;
            const W = a.center ? s.U.convert(a.center) : g, U = t.applyConstrain(W, d).center;
            cu(t, U);
            const X = t.clone();
            X.setCenter(U), X.setZoom(I ? +a.zoom : d + Di(g.lat, W.lat)), X.setBearing(a.bearing);
            const re = new s.P(s.ai(t.centerPoint.x + a.offsetAsPoint.x, 0, t.width), s.ai(t.centerPoint.y + a.offsetAsPoint.y, 0, t.height));
            X.setLocationAtPoint(U, re);
            const de = (a.offset && a.offsetAsPoint.mag()) > 0 ? X.center : U, fe = I ? +a.zoom : d + Di(g.lat, de.lat), me = d + Di(g.lat, 0), Ce = fe + Di(de.lat, 0), Pe = s.bE(g.lng, de.lng), xe = s.bE(g.lat, de.lat), Ie = s.al(Ce - me);
            return z = fe !== d, { easeFunc: (De) => {
              if (s.bi(w, T) || ba({ startEulerAngles: w, endEulerAngles: T, tr: t, k: De, useSlerp: w.roll != T.roll }), R && t.interpolatePadding(b, a.padding, De), a.around) s.w("Easing around a point is not supported under globe projection."), t.setLocationAtPoint(a.around, a.aroundPoint);
              else {
                const Se = Ce > me ? Math.min(2, Ie) : Math.max(0.5, Ie), Ne = Math.pow(Se, 1 - De), Ke = Zc(g, Pe, xe, De * Ne);
                t.setCenter(Ke.wrap());
              }
              if (z) {
                const Se = s.F.number(me, Ce, De) + Di(0, t.center.lat);
                t.setZoom(Se);
              }
            }, isZooming: z, elevationCenter: de };
          }
          handleFlyTo(t, a) {
            const d = a.zoom !== void 0, g = t.center, b = t.zoom, w = t.padding, T = !t.isPaddingEqual(a.padding), I = t.applyConstrain(s.U.convert(a.center || a.locationAtOffset), b).center, R = d ? +a.zoom : t.zoom + Di(t.center.lat, I.lat), z = t.clone();
            z.setCenter(I), z.setZoom(R), z.setBearing(a.bearing);
            const W = new s.P(s.ai(t.centerPoint.x + a.offsetAsPoint.x, 0, t.width), s.ai(t.centerPoint.y + a.offsetAsPoint.y, 0, t.height));
            z.setLocationAtPoint(I, W);
            const U = z.center;
            cu(t, U);
            const X = (function(xe, Ie, De) {
              const Se = tn(Ie), Ne = tn(De), Ke = s.a$(Se, Ne), Ze = Math.acos(Ke), He = Hh(xe);
              return Ze / (2 * Math.PI) * He;
            })(t, g, U), re = b + Di(g.lat, 0), de = R + Di(U.lat, 0), fe = s.al(de - re);
            let me;
            if (typeof a.minZoom == "number") {
              const xe = +a.minZoom + Di(U.lat, 0), Ie = Math.min(xe, re, de) + Di(0, U.lat), De = t.applyConstrain(U, Ie).zoom + Di(U.lat, 0);
              me = s.al(De - re);
            }
            const Ce = s.bE(g.lng, U.lng), Pe = s.bE(g.lat, U.lat);
            return { easeFunc: (xe, Ie, De, Se) => {
              const Ne = Zc(g, Ce, Pe, De);
              T && t.interpolatePadding(w, a.padding, xe);
              const Ke = xe === 1 ? U : Ne;
              t.setCenter(Ke.wrap());
              const Ze = re + s.ao(Ie);
              t.setZoom(xe === 1 ? R : Ze + Di(0, Ke.lat));
            }, scaleOfZoom: fe, targetCenter: U, scaleOfMinZoom: me, pixelPathLength: X };
          }
          static solveVectorScale(t, a, d, g, b) {
            const w = g === "x" ? [d[0], d[4], d[8], d[12]] : [d[1], d[5], d[9], d[13]], T = [d[3], d[7], d[11], d[15]], I = t[0] * w[0] + t[1] * w[1] + t[2] * w[2], R = t[0] * T[0] + t[1] * T[1] + t[2] * T[2], z = a[0] * w[0] + a[1] * w[1] + a[2] * w[2], W = a[0] * T[0] + a[1] * T[1] + a[2] * T[2];
            return z + b * R === I + b * W || T[3] * (I - z) + w[3] * (W - R) + I * W == z * R ? null : (z + w[3] - b * W - b * T[3]) / (z - I - b * W + b * R);
          }
          static getLesserNonNegativeNonNull(t, a) {
            return a !== null && a >= 0 && a < t ? a : t;
          }
        }
        class vu {
          constructor(t) {
            this._globe = t, this._mercatorCameraHelper = new On(), this._verticalPerspectiveCameraHelper = new $n();
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering;
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
          }
          handlePanInertia(t, a) {
            return this.currentHelper.handlePanInertia(t, a);
          }
          handleMapControlsRollPitchBearingZoom(t, a) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(t, a);
          }
          handleMapControlsPan(t, a, d) {
            this.currentHelper.handleMapControlsPan(t, a, d);
          }
          cameraForBoxAndBearing(t, a, d, g, b) {
            return this.currentHelper.cameraForBoxAndBearing(t, a, d, g, b);
          }
          handleJumpToCenterZoom(t, a) {
            this.currentHelper.handleJumpToCenterZoom(t, a);
          }
          handleEaseTo(t, a) {
            return this.currentHelper.handleEaseTo(t, a);
          }
          handleFlyTo(t, a) {
            return this.currentHelper.handleFlyTo(t, a);
          }
        }
        const Va = (_, t) => s.z(_, t && t.filter(((a) => a.identifier !== "source.canvas"))), Xc = s.bI();
        class il extends s.E {
          constructor(t, a = {}) {
            var d, g;
            super(), this._rtlPluginLoaded = () => {
              for (const w in this.tileManagers) {
                const T = this.tileManagers[w].getSource().type;
                T !== "vector" && T !== "geojson" || this.tileManagers[w].reload();
              }
            }, this.map = t, this.dispatcher = new yr(dr(), t._getMapId()), this.dispatcher.registerMessageHandler("GG", ((w, T) => this.getGlyphs(w, T))), this.dispatcher.registerMessageHandler("GI", ((w, T) => this.getImages(w, T))), this.dispatcher.registerMessageHandler("GDA", ((w, T) => this.getDashes(w, T))), this.imageManager = new Ve(), this.imageManager.setEventedParent(this);
            const b = ((d = t._container) === null || d === void 0 ? void 0 : d.lang) || typeof document < "u" && ((g = document.documentElement) === null || g === void 0 ? void 0 : g.lang) || void 0;
            this.glyphManager = new kt(t._requestManager, a.localIdeographFontFamily, b), this.lineAtlas = new Pt(256, 512), this.crossTileSymbolIndex = new Ho(), this._setInitialValues(), this._resetUpdates(), this.dispatcher.broadcast("SR", s.bJ()), Bi().on(en, this._rtlPluginLoaded), this.on("data", ((w) => {
              if (w.dataType !== "source" || w.sourceDataType !== "metadata") return;
              const T = this.tileManagers[w.sourceId];
              if (!T) return;
              const I = T.getSource();
              if (I && I.vectorLayerIds) for (const R in this._layers) {
                const z = this._layers[R];
                z.source === I.id && this._validateLayer(z);
              }
            }));
          }
          _setInitialValues() {
            var t;
            this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.tileManagers = {}, this.zoomHistory = new s.bK(), this._availableImages = [], this._globalState = {}, this._serializedLayers = {}, this.stylesheet = null, this.light = null, this.sky = null, this.projection && (this.projection.destroy(), delete this.projection), this._loaded = false, this._changed = false, this._updatedLayers = {}, this._updatedSources = {}, this._changedImages = {}, this._glyphsDidChange = false, this._updatedPaintProps = {}, this._layerOrderChanged = false, this.crossTileSymbolIndex = new (((t = this.crossTileSymbolIndex) === null || t === void 0 ? void 0 : t.constructor) || Object)(), this.pauseablePlacement = void 0, this.placement = void 0, this.z = 0;
          }
          setGlobalStateProperty(t, a) {
            var d, g, b;
            this._checkLoaded();
            const w = a === null ? (b = (g = (d = this.stylesheet.state) === null || d === void 0 ? void 0 : d[t]) === null || g === void 0 ? void 0 : g.default) !== null && b !== void 0 ? b : null : a;
            if (s.bL(w, this._globalState[t])) return this;
            this._globalState[t] = w, this._applyGlobalStateChanges([t]);
          }
          getGlobalState() {
            return this._globalState;
          }
          setGlobalState(t) {
            this._checkLoaded();
            const a = [];
            for (const d in t) !s.bL(this._globalState[d], t[d].default) && (a.push(d), this._globalState[d] = t[d].default);
            this._applyGlobalStateChanges(a);
          }
          _applyGlobalStateChanges(t) {
            if (t.length === 0) return;
            const a = /* @__PURE__ */ new Set(), d = {};
            for (const g of t) {
              d[g] = this._globalState[g];
              for (const b in this._layers) {
                const w = this._layers[b], T = w.getLayoutAffectingGlobalStateRefs(), I = w.getPaintAffectingGlobalStateRefs();
                if (T.has(g) && a.add(w.source), I.has(g)) for (const { name: R, value: z } of I.get(g)) this._updatePaintProperty(w, R, z);
              }
            }
            this.dispatcher.broadcast("UGS", d);
            for (const g in this.tileManagers) a.has(g) && (this._reloadSource(g), this._changed = true);
          }
          loadURL(t, a = {}, d) {
            this.fire(new s.l("dataloading", { dataType: "style" })), a.validate = typeof a.validate != "boolean" || a.validate;
            const g = this.map._requestManager.transformRequest(t, "Style");
            this._loadStyleRequest = new AbortController();
            const b = this._loadStyleRequest;
            s.j(g, this._loadStyleRequest).then(((w) => {
              this._loadStyleRequest = null, this._load(w.data, a, d);
            })).catch(((w) => {
              this._loadStyleRequest = null, w && !b.signal.aborted && this.fire(new s.k(w));
            }));
          }
          loadJSON(t, a = {}, d) {
            this.fire(new s.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), j.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, a.validate = a.validate !== false, this._load(t, a, d);
            })).catch((() => {
            }));
          }
          loadEmpty() {
            this.fire(new s.l("dataloading", { dataType: "style" })), this._load(Xc, { validate: false });
          }
          _load(t, a, d) {
            var g, b;
            let w = a.transformStyle ? a.transformStyle(d, t) : t;
            if (!a.validate || !Va(this, s.B(w))) {
              w = Object.assign({}, w), this._loaded = true, this.stylesheet = w;
              for (const T in w.sources) this.addSource(T, w.sources[T], { validate: false });
              w.sprite ? this._loadSprite(w.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(w.glyphs), this._createLayers(), this.light = new pt(this.stylesheet.light), this._setProjectionInternal(((g = this.stylesheet.projection) === null || g === void 0 ? void 0 : g.type) || "mercator"), this.sky = new vt(this.stylesheet.sky), this.map.setTerrain((b = this.stylesheet.terrain) !== null && b !== void 0 ? b : null), this.fire(new s.l("data", { dataType: "style" })), this.fire(new s.l("style.load"));
            }
          }
          _createLayers() {
            var t, a, d;
            const g = s.bM(this.stylesheet.layers);
            this.setGlobalState((t = this.stylesheet.state) !== null && t !== void 0 ? t : null), this.dispatcher.broadcast("SL", g), this._order = g.map(((b) => b.id)), this._layers = {}, this._serializedLayers = null;
            for (const b of g) {
              const w = s.bN(b, this._globalState);
              if (w.setEventedParent(this, { layer: { id: b.id } }), this._layers[b.id] = w, s.bO(w) && this.tileManagers[w.source]) {
                const T = (d = (a = b.paint) === null || a === void 0 ? void 0 : a["raster-fade-duration"]) !== null && d !== void 0 ? d : w.paint.get("raster-fade-duration");
                this.tileManagers[w.source].setRasterFadeDuration(T);
              }
            }
          }
          _loadSprite(t, a = false, d = void 0) {
            let g;
            this.imageManager.setLoaded(false), this._spriteRequest = new AbortController(), (function(b, w, T, I) {
              return s._(this, void 0, void 0, (function* () {
                const R = le(b), z = T > 1 ? "@2x" : "", W = {}, U = {};
                for (const { id: X, url: re } of R) {
                  const de = w.transformRequest(ue(re, z, ".json"), "SpriteJSON");
                  W[X] = s.j(de, I);
                  const fe = w.transformRequest(ue(re, z, ".png"), "SpriteImage");
                  U[X] = ke.getImage(fe, I);
                }
                return yield Promise.all([...Object.values(W), ...Object.values(U)]), (function(X, re) {
                  return s._(this, void 0, void 0, (function* () {
                    const de = {};
                    for (const fe in X) {
                      de[fe] = {};
                      const me = j.getImageCanvasContext((yield re[fe]).data), Ce = (yield X[fe]).data;
                      for (const Pe in Ce) {
                        const { width: xe, height: Ie, x: De, y: Se, sdf: Ne, pixelRatio: Ke, stretchX: Ze, stretchY: He, content: Je, textFitWidth: Tt, textFitHeight: It } = Ce[Pe];
                        de[fe][Pe] = { data: null, pixelRatio: Ke, sdf: Ne, stretchX: Ze, stretchY: He, content: Je, textFitWidth: Tt, textFitHeight: It, spriteData: { width: xe, height: Ie, x: De, y: Se, context: me } };
                      }
                    }
                    return de;
                  }));
                })(W, U);
              }));
            })(t, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(((b) => {
              if (this._spriteRequest = null, b) for (const w in b) {
                this._spritesImagesIds[w] = [];
                const T = this._spritesImagesIds[w] ? this._spritesImagesIds[w].filter(((I) => !(I in b))) : [];
                for (const I of T) this.imageManager.removeImage(I), this._changedImages[I] = true;
                for (const I in b[w]) {
                  const R = w === "default" ? I : `${w}:${I}`;
                  this._spritesImagesIds[w].push(R), R in this.imageManager.images ? this.imageManager.updateImage(R, b[w][I], false) : this.imageManager.addImage(R, b[w][I]), a && (this._changedImages[R] = true);
                }
              }
            })).catch(((b) => {
              this._spriteRequest = null, g = b, this.fire(new s.k(g));
            })).finally((() => {
              this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), a && (this._changed = true), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", { dataType: "style" })), d && d(g);
            }));
          }
          _unloadSprite() {
            for (const t of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(t), this._changedImages[t] = true;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", { dataType: "style" }));
          }
          _validateLayer(t) {
            const a = this.tileManagers[t.source];
            if (!a) return;
            const d = t.sourceLayer;
            if (!d) return;
            const g = a.getSource();
            (g.type === "geojson" || g.vectorLayerIds && g.vectorLayerIds.indexOf(d) === -1) && this.fire(new s.k(new Error(`Source layer "${d}" does not exist on source "${g.id}" as specified by style layer "${t.id}".`)));
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return false;
            for (const t in this.tileManagers) if (!this.tileManagers[t].loaded()) return false;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(t, a = false) {
            const d = this._serializedAllLayers();
            if (!t || t.length === 0) return Object.values(a ? s.bP(d) : d);
            const g = [];
            for (const b of t) if (d[b]) {
              const w = a ? s.bP(d[b]) : d[b];
              g.push(w);
            }
            return g;
          }
          _serializedAllLayers() {
            let t = this._serializedLayers;
            if (t) return t;
            t = this._serializedLayers = {};
            const a = Object.keys(this._layers);
            for (const d of a) {
              const g = this._layers[d];
              g.type !== "custom" && (t[d] = g.serialize());
            }
            return t;
          }
          hasTransitions() {
            var t, a, d;
            if (!((t = this.light) === null || t === void 0) && t.hasTransition() || !((a = this.sky) === null || a === void 0) && a.hasTransition() || !((d = this.projection) === null || d === void 0) && d.hasTransition()) return true;
            for (const g in this.tileManagers) if (this.tileManagers[g].hasTransition()) return true;
            for (const g in this._layers) if (this._layers[g].hasTransition()) return true;
            return false;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(t) {
            if (!this._loaded) return;
            const a = this._changed;
            if (a) {
              const g = Object.keys(this._updatedLayers), b = Object.keys(this._removedLayers);
              (g.length || b.length) && this._updateWorkerLayers(g, b);
              for (const w in this._updatedSources) {
                const T = this._updatedSources[w];
                if (T === "reload") this._reloadSource(w);
                else {
                  if (T !== "clear") throw new Error(`Invalid action ${T}`);
                  this._clearSource(w);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const w in this._updatedPaintProps) this._layers[w].updateTransitions(t);
              this.light.updateTransitions(t), this.sky.updateTransitions(t), this._resetUpdates();
            }
            const d = {};
            for (const g in this.tileManagers) {
              const b = this.tileManagers[g];
              d[g] = b.used, b.used = false;
            }
            for (const g of this._order) {
              const b = this._layers[g];
              b.recalculate(t, this._availableImages), !b.isHidden(t.zoom) && b.source && (this.tileManagers[b.source].used = true);
            }
            for (const g in d) {
              const b = this.tileManagers[g];
              !!d[g] != !!b.used && b.fire(new s.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: g }));
            }
            this.light.recalculate(t), this.sky.recalculate(t), this.projection.recalculate(t), this.z = t.zoom, a && this.fire(new s.l("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const t = Object.keys(this._changedImages);
            if (t.length) {
              for (const a in this.tileManagers) this.tileManagers[a].reloadTilesForDependencies(["icons", "patterns"], t);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const t in this.tileManagers) this.tileManagers[t].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = false;
            }
          }
          _updateWorkerLayers(t, a) {
            this.dispatcher.broadcast("UL", { layers: this._serializeByIds(t, false), removedIds: a });
          }
          _resetUpdates() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
          }
          setState(t, a = {}) {
            var d;
            this._checkLoaded();
            const g = this.serialize();
            if (t = a.transformStyle ? a.transformStyle(g, t) : t, ((d = a.validate) === null || d === void 0 || d) && Va(this, s.B(t))) return false;
            (t = s.bP(t)).layers = s.bM(t.layers);
            const b = s.bQ(g, t), w = this._getOperationsToPerform(b);
            if (w.unimplemented.length > 0) throw new Error(`Unimplemented: ${w.unimplemented.join(", ")}.`);
            if (w.operations.length === 0) return false;
            for (const T of w.operations) T();
            return this.stylesheet = t, this._serializedLayers = null, true;
          }
          _getOperationsToPerform(t) {
            const a = [], d = [];
            for (const g of t) switch (g.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                a.push((() => this.addLayer.apply(this, g.args)));
                break;
              case "removeLayer":
                a.push((() => this.removeLayer.apply(this, g.args)));
                break;
              case "setPaintProperty":
                a.push((() => this.setPaintProperty.apply(this, g.args)));
                break;
              case "setLayoutProperty":
                a.push((() => this.setLayoutProperty.apply(this, g.args)));
                break;
              case "setFilter":
                a.push((() => this.setFilter.apply(this, g.args)));
                break;
              case "addSource":
                a.push((() => this.addSource.apply(this, g.args)));
                break;
              case "removeSource":
                a.push((() => this.removeSource.apply(this, g.args)));
                break;
              case "setLayerZoomRange":
                a.push((() => this.setLayerZoomRange.apply(this, g.args)));
                break;
              case "setLight":
                a.push((() => this.setLight.apply(this, g.args)));
                break;
              case "setGeoJSONSourceData":
                a.push((() => this.setGeoJSONSourceData.apply(this, g.args)));
                break;
              case "setGlyphs":
                a.push((() => this.setGlyphs.apply(this, g.args)));
                break;
              case "setSprite":
                a.push((() => this.setSprite.apply(this, g.args)));
                break;
              case "setTerrain":
                a.push((() => this.map.setTerrain.apply(this, g.args)));
                break;
              case "setSky":
                a.push((() => this.setSky.apply(this, g.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, g.args);
                break;
              case "setGlobalState":
                a.push((() => this.setGlobalState.apply(this, g.args)));
                break;
              case "setTransition":
                a.push((() => {
                }));
                break;
              default:
                d.push(g.command);
            }
            return { operations: a, unimplemented: d };
          }
          addImage(t, a) {
            if (this.getImage(t)) return this.fire(new s.k(new Error(`An image named "${t}" already exists.`)));
            this.imageManager.addImage(t, a), this._afterImageUpdated(t);
          }
          updateImage(t, a) {
            this.imageManager.updateImage(t, a);
          }
          getImage(t) {
            return this.imageManager.getImage(t);
          }
          removeImage(t) {
            if (!this.getImage(t)) return this.fire(new s.k(new Error(`An image named "${t}" does not exist.`)));
            this.imageManager.removeImage(t), this._afterImageUpdated(t);
          }
          _afterImageUpdated(t) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[t] = true, this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(t, a, d = {}) {
            if (this._checkLoaded(), this.tileManagers[t] !== void 0) throw new Error(`Source "${t}" already exists.`);
            if (!a.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(a).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(a.type) >= 0 && this._validate(s.B.source, `sources.${t}`, a, null, d)) return;
            this.map && this.map._collectResourceTiming && (a.collectResourceTiming = true);
            const g = this.tileManagers[t] = new mr(t, a, this.dispatcher);
            g.style = this, g.setEventedParent(this, (() => ({ isSourceLoaded: g.loaded(), source: g.serialize(), sourceId: t }))), g.onAdd(this.map), this._changed = true;
          }
          removeSource(t) {
            if (this._checkLoaded(), this.tileManagers[t] === void 0) throw new Error("There is no source with this ID");
            for (const d in this._layers) if (this._layers[d].source === t) return this.fire(new s.k(new Error(`Source "${t}" cannot be removed while layer "${d}" is using it.`)));
            const a = this.tileManagers[t];
            delete this.tileManagers[t], delete this._updatedSources[t], a.fire(new s.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: t })), a.setEventedParent(null), a.onRemove(this.map), this._changed = true;
          }
          setGeoJSONSourceData(t, a) {
            if (this._checkLoaded(), this.tileManagers[t] === void 0) throw new Error(`There is no source with this ID=${t}`);
            const d = this.tileManagers[t].getSource();
            if (d.type !== "geojson") throw new Error(`geojsonSource.type is ${d.type}, which is !== 'geojson`);
            d.setData(a), this._changed = true;
          }
          getSource(t) {
            return this.tileManagers[t] && this.tileManagers[t].getSource();
          }
          addLayer(t, a, d = {}) {
            this._checkLoaded();
            const g = t.id;
            if (this.getLayer(g)) return void this.fire(new s.k(new Error(`Layer "${g}" already exists on this map.`)));
            let b;
            if (t.type === "custom") {
              if (Va(this, s.bR(t))) return;
              b = s.bN(t, this._globalState);
            } else {
              if ("source" in t && typeof t.source == "object" && (this.addSource(g, t.source), t = s.bP(t), t = s.e(t, { source: g })), this._validate(s.B.layer, `layers.${g}`, t, { arrayIndex: -1 }, d)) return;
              b = s.bN(t, this._globalState), this._validateLayer(b), b.setEventedParent(this, { layer: { id: g } });
            }
            const w = a ? this._order.indexOf(a) : this._order.length;
            if (a && w === -1) this.fire(new s.k(new Error(`Cannot add layer "${g}" before non-existing layer "${a}".`)));
            else {
              if (this._order.splice(w, 0, g), this._layerOrderChanged = true, this._layers[g] = b, this._removedLayers[g] && b.source && b.type !== "custom") {
                const T = this._removedLayers[g];
                delete this._removedLayers[g], T.type !== b.type ? this._updatedSources[b.source] = "clear" : (this._updatedSources[b.source] = "reload", this.tileManagers[b.source].pause());
              }
              this._updateLayer(b), b.onAdd && b.onAdd(this.map);
            }
          }
          moveLayer(t, a) {
            if (this._checkLoaded(), this._changed = true, !this._layers[t]) return void this.fire(new s.k(new Error(`The layer '${t}' does not exist in the map's style and cannot be moved.`)));
            if (t === a) return;
            const d = this._order.indexOf(t);
            this._order.splice(d, 1);
            const g = a ? this._order.indexOf(a) : this._order.length;
            a && g === -1 ? this.fire(new s.k(new Error(`Cannot move layer "${t}" before non-existing layer "${a}".`))) : (this._order.splice(g, 0, t), this._layerOrderChanged = true);
          }
          removeLayer(t) {
            this._checkLoaded();
            const a = this._layers[t];
            if (!a) return void this.fire(new s.k(new Error(`Cannot remove non-existing layer "${t}".`)));
            a.setEventedParent(null);
            const d = this._order.indexOf(t);
            this._order.splice(d, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[t] = a, delete this._layers[t], this._serializedLayers && delete this._serializedLayers[t], delete this._updatedLayers[t], delete this._updatedPaintProps[t], a.onRemove && a.onRemove(this.map);
          }
          getLayer(t) {
            return this._layers[t];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(t) {
            return t in this._layers;
          }
          setLayerZoomRange(t, a, d) {
            this._checkLoaded();
            const g = this.getLayer(t);
            g ? g.minzoom === a && g.maxzoom === d || (a != null && (g.minzoom = a), d != null && (g.maxzoom = d), this._updateLayer(g)) : this.fire(new s.k(new Error(`Cannot set the zoom range of non-existing layer "${t}".`)));
          }
          setFilter(t, a, d = {}) {
            this._checkLoaded();
            const g = this.getLayer(t);
            if (g) {
              if (!s.bL(g.filter, a)) return a == null ? (g.setFilter(void 0), void this._updateLayer(g)) : void (this._validate(s.B.filter, `layers.${g.id}.filter`, a, null, d) || (g.setFilter(s.bP(a)), this._updateLayer(g)));
            } else this.fire(new s.k(new Error(`Cannot filter non-existing layer "${t}".`)));
          }
          getFilter(t) {
            return s.bP(this.getLayer(t).filter);
          }
          setLayoutProperty(t, a, d, g = {}) {
            this._checkLoaded();
            const b = this.getLayer(t);
            b ? s.bL(b.getLayoutProperty(a), d) || (b.setLayoutProperty(a, d, g), this._updateLayer(b)) : this.fire(new s.k(new Error(`Cannot style non-existing layer "${t}".`)));
          }
          getLayoutProperty(t, a) {
            const d = this.getLayer(t);
            if (d) return d.getLayoutProperty(a);
            this.fire(new s.k(new Error(`Cannot get style of non-existing layer "${t}".`)));
          }
          setPaintProperty(t, a, d, g = {}) {
            this._checkLoaded();
            const b = this.getLayer(t);
            b ? s.bL(b.getPaintProperty(a), d) || this._updatePaintProperty(b, a, d, g) : this.fire(new s.k(new Error(`Cannot style non-existing layer "${t}".`)));
          }
          _updatePaintProperty(t, a, d, g = {}) {
            t.setPaintProperty(a, d, g) && this._updateLayer(t), s.bO(t) && a === "raster-fade-duration" && this.tileManagers[t.source].setRasterFadeDuration(d), this._changed = true, this._updatedPaintProps[t.id] = true, this._serializedLayers = null;
          }
          getPaintProperty(t, a) {
            return this.getLayer(t).getPaintProperty(a);
          }
          setFeatureState(t, a) {
            this._checkLoaded();
            const d = t.source, g = t.sourceLayer, b = this.tileManagers[d];
            if (b === void 0) return void this.fire(new s.k(new Error(`The source '${d}' does not exist in the map's style.`)));
            const w = b.getSource().type;
            w === "geojson" && g ? this.fire(new s.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : w !== "vector" || g ? (t.id === void 0 && this.fire(new s.k(new Error("The feature id parameter must be provided."))), b.setFeatureState(g, t.id, a)) : this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(t, a) {
            this._checkLoaded();
            const d = t.source, g = this.tileManagers[d];
            if (g === void 0) return void this.fire(new s.k(new Error(`The source '${d}' does not exist in the map's style.`)));
            const b = g.getSource().type, w = b === "vector" ? t.sourceLayer : void 0;
            b !== "vector" || w ? a && typeof t.id != "string" && typeof t.id != "number" ? this.fire(new s.k(new Error("A feature id is required to remove its specific state property."))) : g.removeFeatureState(w, t.id, a) : this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(t) {
            this._checkLoaded();
            const a = t.source, d = t.sourceLayer, g = this.tileManagers[a];
            if (g !== void 0) return g.getSource().type !== "vector" || d ? (t.id === void 0 && this.fire(new s.k(new Error("The feature id parameter must be provided."))), g.getFeatureState(d, t.id)) : void this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new s.k(new Error(`The source '${a}' does not exist in the map's style.`)));
          }
          getTransition() {
            return s.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded) return;
            const t = s.bS(this.tileManagers, ((b) => b.serialize())), a = this._serializeByIds(this._order, true), d = this.map.getTerrain() || void 0, g = this.stylesheet;
            return s.bT({ version: g.version, name: g.name, metadata: g.metadata, light: g.light, sky: g.sky, center: g.center, zoom: g.zoom, bearing: g.bearing, pitch: g.pitch, sprite: g.sprite, glyphs: g.glyphs, transition: g.transition, projection: g.projection, sources: t, layers: a, terrain: d }, ((b) => b !== void 0));
          }
          _updateLayer(t) {
            this._updatedLayers[t.id] = true, t.source && !this._updatedSources[t.source] && this.tileManagers[t.source].getSource().type !== "raster" && (this._updatedSources[t.source] = "reload", this.tileManagers[t.source].pause()), this._serializedLayers = null, this._changed = true;
          }
          _flattenAndSortRenderedFeatures(t) {
            const a = (w) => this._layers[w].type === "fill-extrusion", d = {}, g = [];
            for (let w = this._order.length - 1; w >= 0; w--) {
              const T = this._order[w];
              if (a(T)) {
                d[T] = w;
                for (const I of t) {
                  const R = I[T];
                  if (R) for (const z of R) g.push(z);
                }
              }
            }
            g.sort(((w, T) => T.intersectionZ - w.intersectionZ));
            const b = [];
            for (let w = this._order.length - 1; w >= 0; w--) {
              const T = this._order[w];
              if (a(T)) for (let I = g.length - 1; I >= 0; I--) {
                const R = g[I].feature;
                if (d[R.layer.id] < w) break;
                b.push(R), g.pop();
              }
              else for (const I of t) {
                const R = I[T];
                if (R) for (const z of R) b.push(z.feature);
              }
            }
            return b;
          }
          queryRenderedFeatures(t, a, d) {
            a && a.filter && this._validate(s.B.filter, "queryRenderedFeatures.filter", a.filter, null, a);
            const g = {};
            if (a && a.layers) {
              if (!(Array.isArray(a.layers) || a.layers instanceof Set)) return this.fire(new s.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const R of a.layers) {
                const z = this._layers[R];
                if (!z) return this.fire(new s.k(new Error(`The layer '${R}' does not exist in the map's style and cannot be queried for features.`))), [];
                g[z.source] = true;
              }
            }
            const b = [];
            a.availableImages = this._availableImages;
            const w = this._serializedAllLayers(), T = a.layers instanceof Set ? a.layers : Array.isArray(a.layers) ? new Set(a.layers) : null, I = Object.assign(Object.assign({}, a), { layers: T, globalState: this._globalState });
            for (const R in this.tileManagers) a.layers && !g[R] || b.push(Ir(this.tileManagers[R], this._layers, w, t, I, d, this.map.terrain ? (z, W, U) => this.map.terrain.getElevation(z, W, U) : void 0));
            return this.placement && b.push((function(R, z, W, U, X, re, de) {
              const fe = {}, me = re.queryRenderedSymbols(U), Ce = [];
              for (const Pe of Object.keys(me).map(Number)) Ce.push(de[Pe]);
              Ce.sort(Ht);
              for (const Pe of Ce) {
                const xe = Pe.featureIndex.lookupSymbolFeatures(me[Pe.bucketInstanceId], z, Pe.bucketIndex, Pe.sourceLayerIndex, { filterSpec: X.filter, globalState: X.globalState }, X.layers, X.availableImages, R);
                for (const Ie in xe) {
                  const De = fe[Ie] = fe[Ie] || [], Se = xe[Ie];
                  Se.sort(((Ne, Ke) => {
                    const Ze = Pe.featureSortOrder;
                    if (Ze) {
                      const He = Ze.indexOf(Ne.featureIndex);
                      return Ze.indexOf(Ke.featureIndex) - He;
                    }
                    return Ke.featureIndex - Ne.featureIndex;
                  }));
                  for (const Ne of Se) De.push(Ne);
                }
              }
              return (function(Pe, xe, Ie) {
                for (const De in Pe) for (const Se of Pe[De]) Rr(Se, Ie[xe[De].source]);
                return Pe;
              })(fe, R, W);
            })(this._layers, w, this.tileManagers, t, I, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(b);
          }
          querySourceFeatures(t, a) {
            (a == null ? void 0 : a.filter) && this._validate(s.B.filter, "querySourceFeatures.filter", a.filter, null, a);
            const d = this.tileManagers[t];
            return d ? (function(g, b) {
              const w = g.getRenderableIds().map(((R) => g.getTileByID(R))), T = [], I = {};
              for (let R = 0; R < w.length; R++) {
                const z = w[R], W = z.tileID.canonical.key;
                I[W] || (I[W] = true, z.querySourceFeatures(T, b));
              }
              return T;
            })(d, a ? Object.assign(Object.assign({}, a), { globalState: this._globalState }) : { globalState: this._globalState }) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(t, a = {}) {
            this._checkLoaded();
            const d = this.light.getLight();
            let g = false;
            for (const w in t) if (!s.bL(t[w], d[w])) {
              g = true;
              break;
            }
            if (!g) return;
            const b = { now: q(), transition: s.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(t, a), this.light.updateTransitions(b);
          }
          getProjection() {
            var t;
            return (t = this.stylesheet) === null || t === void 0 ? void 0 : t.projection;
          }
          setProjection(t) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === t.type) return;
              this.projection.destroy(), delete this.projection;
            }
            this.stylesheet.projection = t, this._setProjectionInternal(t.type);
          }
          getSky() {
            var t;
            return (t = this.stylesheet) === null || t === void 0 ? void 0 : t.sky;
          }
          setSky(t, a = {}) {
            this._checkLoaded();
            const d = this.getSky();
            let g = false;
            if (!t && !d) return;
            if (t && !d) g = true;
            else if (!t && d) g = true;
            else for (const w in t) if (!s.bL(t[w], d[w])) {
              g = true;
              break;
            }
            if (!g) return;
            const b = { now: q(), transition: s.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.stylesheet.sky = t, this.sky.setSky(t, a), this.sky.updateTransitions(b);
          }
          _setProjectionInternal(t) {
            const a = (function(d, g) {
              const b = { constrainOverride: g };
              if (Array.isArray(d)) {
                const w = new vs({ type: d });
                return { projection: w, transform: new gu(b), cameraHelper: new vu(w) };
              }
              switch (d) {
                case "mercator":
                  return { projection: new Oi(), transform: new ei(b), cameraHelper: new On() };
                case "globe": {
                  const w = new vs({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                  return { projection: w, transform: new gu(b), cameraHelper: new vu(w) };
                }
                case "vertical-perspective":
                  return { projection: new rl(), transform: new mu(b), cameraHelper: new $n() };
                default:
                  return s.w(`Unknown projection name: ${d}. Falling back to mercator projection.`), { projection: new Oi(), transform: new ei(b), cameraHelper: new On() };
              }
            })(t, this.map.transformConstrain);
            this.projection = a.projection, this.map.migrateProjection(a.transform, a.cameraHelper);
            for (const d in this.tileManagers) this.tileManagers[d].reload();
          }
          _validate(t, a, d, g, b = {}) {
            return (!b || b.validate !== false) && Va(this, t.call(s.B, s.e({ key: a, style: this.serialize(), value: d, styleSpec: s.u }, g)));
          }
          _remove(t = true) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Bi().off(en, this._rtlPluginLoaded);
            for (const a in this._layers) this._layers[a].setEventedParent(null);
            for (const a in this.tileManagers) {
              const d = this.tileManagers[a];
              d.setEventedParent(null), d.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), t && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(t);
          }
          _clearSource(t) {
            this.tileManagers[t].clearTiles();
          }
          _reloadSource(t) {
            this.tileManagers[t].resume(), this.tileManagers[t].reload();
          }
          _updateSources(t) {
            for (const a in this.tileManagers) this.tileManagers[a].update(t, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const t in this.tileManagers) this._reloadSource(t);
          }
          _updatePlacement(t, a, d, g, b = false) {
            let w = false, T = false;
            const I = {};
            for (const R of this._order) {
              const z = this._layers[R];
              if (z.type !== "symbol") continue;
              if (!I[z.source]) {
                const U = this.tileManagers[z.source];
                I[z.source] = U.getRenderableIds(true).map(((X) => U.getTileByID(X))).sort(((X, re) => re.tileID.overscaledZ - X.tileID.overscaledZ || (X.tileID.isLessThan(re.tileID) ? -1 : 1)));
              }
              const W = this.crossTileSymbolIndex.addLayer(z, I[z.source], t.center.lng);
              w = w || W;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((b = b || this._layerOrderChanged || d === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(q(), t.zoom)) && (this.pauseablePlacement = new lu(t, this.map.terrain, this._order, b, a, d, g, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, I), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(q()), T = true), w && this.pauseablePlacement.placement.setStale()), T || w) for (const R of this._order) {
              const z = this._layers[R];
              z.type === "symbol" && this.placement.updateLayerOpacities(z, I[z.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(q());
          }
          _releaseSymbolFadeTiles() {
            for (const t in this.tileManagers) this.tileManagers[t].releaseSymbolFadeTiles();
          }
          getImages(t, a) {
            return s._(this, void 0, void 0, (function* () {
              const d = yield this.imageManager.getImages(a.icons);
              this._updateTilesForChangedImages();
              const g = this.tileManagers[a.source];
              return g && g.setDependencies(a.tileID.key, a.type, a.icons), d;
            }));
          }
          getGlyphs(t, a) {
            return s._(this, void 0, void 0, (function* () {
              const d = yield this.glyphManager.getGlyphs(a.stacks), g = this.tileManagers[a.source];
              return g && g.setDependencies(a.tileID.key, a.type, [""]), d;
            }));
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(t, a = {}) {
            this._checkLoaded(), t && this._validate(s.B.glyphs, "glyphs", t, null, a) || (this._glyphsDidChange = true, this.stylesheet.glyphs = t, this.glyphManager.entries = {}, this.glyphManager.setURL(t));
          }
          getDashes(t, a) {
            return s._(this, void 0, void 0, (function* () {
              const d = {};
              for (const [g, b] of Object.entries(a.dashes)) d[g] = this.lineAtlas.getDash(b.dasharray, b.round);
              return d;
            }));
          }
          addSprite(t, a, d = {}, g) {
            this._checkLoaded();
            const b = [{ id: t, url: a }], w = [...le(this.stylesheet.sprite), ...b];
            this._validate(s.B.sprite, "sprite", w, null, d) || (this.stylesheet.sprite = w, this._loadSprite(b, true, g));
          }
          removeSprite(t) {
            this._checkLoaded();
            const a = le(this.stylesheet.sprite);
            if (a.find(((d) => d.id === t))) {
              if (this._spritesImagesIds[t]) for (const d of this._spritesImagesIds[t]) this.imageManager.removeImage(d), this._changedImages[d] = true;
              a.splice(a.findIndex(((d) => d.id === t)), 1), this.stylesheet.sprite = a.length > 0 ? a : void 0, delete this._spritesImagesIds[t], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", { dataType: "style" }));
            } else this.fire(new s.k(new Error(`Sprite "${t}" doesn't exists on this map.`)));
          }
          getSprite() {
            return le(this.stylesheet.sprite);
          }
          setSprite(t, a = {}, d) {
            this._checkLoaded(), t && this._validate(s.B.sprite, "sprite", t, null, a) || (this.stylesheet.sprite = t, t ? this._loadSprite(t, true, d) : (this._unloadSprite(), d && d(null)));
          }
          destroy() {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null);
            for (const t in this.tileManagers) {
              const a = this.tileManagers[t];
              if (a.setEventedParent(null), a._tiles) {
                for (const d in a._tiles) a._tiles[d].unloadVectorData();
                a._tiles = {};
              }
              a._cache.reset(), a.onRemove(this.map);
            }
            this.tileManagers = {}, this.imageManager && (this.imageManager.setEventedParent(null), this.imageManager.destroy(), this._availableImages = [], this._spritesImagesIds = {}), this.glyphManager && this.glyphManager.destroy();
            for (const t in this._layers) {
              const a = this._layers[t];
              a.setEventedParent(null), a.onRemove && a.onRemove(this.map);
            }
            this._setInitialValues(), this.setEventedParent(null), this.dispatcher.unregisterMessageHandler("GG"), this.dispatcher.unregisterMessageHandler("GI"), this.dispatcher.unregisterMessageHandler("GDA"), this.dispatcher.remove(true), this._listeners = {}, this._oneTimeListeners = {};
          }
        }
        var Vo = s.aO([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class Sm {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(t, a, d, g, b, w, T, I, R) {
            this.context = t;
            let z = this.boundPaintVertexBuffers.length !== g.length;
            for (let W = 0; !z && W < g.length; W++) this.boundPaintVertexBuffers[W] !== g[W] && (z = true);
            !this.vao || this.boundProgram !== a || this.boundLayoutVertexBuffer !== d || z || this.boundIndexBuffer !== b || this.boundVertexOffset !== w || this.boundDynamicVertexBuffer !== T || this.boundDynamicVertexBuffer2 !== I || this.boundDynamicVertexBuffer3 !== R ? this.freshBind(a, d, g, b, w, T, I, R) : (t.bindVertexArray.set(this.vao), T && T.bind(), b && b.dynamicDraw && b.bind(), I && I.bind(), R && R.bind());
          }
          freshBind(t, a, d, g, b, w, T, I) {
            const R = t.numAttributes, z = this.context, W = z.gl;
            this.vao && this.destroy(), this.vao = z.createVertexArray(), z.bindVertexArray.set(this.vao), this.boundProgram = t, this.boundLayoutVertexBuffer = a, this.boundPaintVertexBuffers = d, this.boundIndexBuffer = g, this.boundVertexOffset = b, this.boundDynamicVertexBuffer = w, this.boundDynamicVertexBuffer2 = T, this.boundDynamicVertexBuffer3 = I, a.enableAttributes(W, t);
            for (const U of d) U.enableAttributes(W, t);
            w && w.enableAttributes(W, t), T && T.enableAttributes(W, t), I && I.enableAttributes(W, t), a.bind(), a.setVertexAttribPointers(W, t, b);
            for (const U of d) U.bind(), U.setVertexAttribPointers(W, t, b);
            w && (w.bind(), w.setVertexAttribPointers(W, t, b)), g && g.bind(), T && (T.bind(), T.setVertexAttribPointers(W, t, b)), I && (I.bind(), I.setVertexAttribPointers(W, t, b)), z.currentNumAttributes = R;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        const Yc = (_, t, a, d, g) => ({ u_texture: 0, u_ele_delta: _, u_fog_matrix: t, u_fog_color: a ? a.properties.get("fog-color") : s.bj.white, u_fog_ground_blend: a ? a.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: g ? 0 : a ? a.calculateFogBlendOpacity(d) : 0, u_horizon_color: a ? a.properties.get("horizon-color") : s.bj.white, u_horizon_fog_blend: a ? a.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: g ? 1 : 0 }), nl = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
        function xa(_) {
          const t = [];
          for (let a = 0; a < _.length; a++) {
            if (_[a] === null) continue;
            const d = _[a].split(" ");
            t.push(d.pop());
          }
          return t;
        }
        class km {
          constructor(t, a, d, g, b, w, T, I, R = []) {
            const z = t.gl;
            this.program = z.createProgram();
            const W = xa(a.staticAttributes), U = d ? d.getBinderAttributes() : [], X = W.concat(U), re = no.prelude.staticUniforms ? xa(no.prelude.staticUniforms) : [], de = T.staticUniforms ? xa(T.staticUniforms) : [], fe = a.staticUniforms ? xa(a.staticUniforms) : [], me = d ? d.getBinderUniforms() : [], Ce = re.concat(de).concat(fe).concat(me), Pe = [];
            for (const Ze of Ce) Pe.indexOf(Ze) < 0 && Pe.push(Ze);
            const xe = d ? d.defines() : [];
            vo(z) && xe.unshift("#version 300 es"), b && xe.push("#define OVERDRAW_INSPECTOR;"), w && xe.push("#define TERRAIN3D;"), I && xe.push(I), R && xe.push(...R);
            let Ie = xe.concat(no.prelude.fragmentSource, T.fragmentSource, a.fragmentSource).join(`
`), De = xe.concat(no.prelude.vertexSource, T.vertexSource, a.vertexSource).join(`
`);
            vo(z) || (Ie = (function(Ze) {
              return Ze.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
            })(Ie), De = (function(Ze) {
              return Ze.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
            })(De));
            const Se = z.createShader(z.FRAGMENT_SHADER);
            if (z.isContextLost()) return void (this.failedToCreate = true);
            if (z.shaderSource(Se, Ie), z.compileShader(Se), !z.getShaderParameter(Se, z.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${z.getShaderInfoLog(Se)}`);
            z.attachShader(this.program, Se);
            const Ne = z.createShader(z.VERTEX_SHADER);
            if (z.isContextLost()) return void (this.failedToCreate = true);
            if (z.shaderSource(Ne, De), z.compileShader(Ne), !z.getShaderParameter(Ne, z.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${z.getShaderInfoLog(Ne)}`);
            z.attachShader(this.program, Ne), this.attributes = {};
            const Ke = {};
            this.numAttributes = X.length;
            for (let Ze = 0; Ze < this.numAttributes; Ze++) X[Ze] && (z.bindAttribLocation(this.program, Ze, X[Ze]), this.attributes[X[Ze]] = Ze);
            if (z.linkProgram(this.program), !z.getProgramParameter(this.program, z.LINK_STATUS)) throw new Error(`Program failed to link: ${z.getProgramInfoLog(this.program)}`);
            z.deleteShader(Ne), z.deleteShader(Se);
            for (let Ze = 0; Ze < Pe.length; Ze++) {
              const He = Pe[Ze];
              if (He && !Ke[He]) {
                const Je = z.getUniformLocation(this.program, He);
                Je && (Ke[He] = Je);
              }
            }
            this.fixedUniforms = g(t, Ke), this.terrainUniforms = ((Ze, He) => ({ u_depth: new s.bU(Ze, He.u_depth), u_terrain: new s.bU(Ze, He.u_terrain), u_terrain_dim: new s.bk(Ze, He.u_terrain_dim), u_terrain_matrix: new s.bW(Ze, He.u_terrain_matrix), u_terrain_unpack: new s.bX(Ze, He.u_terrain_unpack), u_terrain_exaggeration: new s.bk(Ze, He.u_terrain_exaggeration) }))(t, Ke), this.projectionUniforms = ((Ze, He) => ({ u_projection_matrix: new s.bW(Ze, He.u_projection_matrix), u_projection_tile_mercator_coords: new s.bX(Ze, He.u_projection_tile_mercator_coords), u_projection_clipping_plane: new s.bX(Ze, He.u_projection_clipping_plane), u_projection_transition: new s.bk(Ze, He.u_projection_transition), u_projection_fallback_matrix: new s.bW(Ze, He.u_projection_fallback_matrix) }))(t, Ke), this.binderUniforms = d ? d.getUniforms(t, Ke) : [];
          }
          draw(t, a, d, g, b, w, T, I, R, z, W, U, X, re, de, fe, me, Ce, Pe) {
            const xe = t.gl;
            if (this.failedToCreate) return;
            if (t.program.set(this.program), t.setDepthMode(d), t.setStencilMode(g), t.setColorMode(b), t.setCullFace(w), I) {
              t.activeTexture.set(xe.TEXTURE2), xe.bindTexture(xe.TEXTURE_2D, I.depthTexture), t.activeTexture.set(xe.TEXTURE3), xe.bindTexture(xe.TEXTURE_2D, I.texture);
              for (const De in this.terrainUniforms) this.terrainUniforms[De].set(I[De]);
            }
            if (R) for (const De in R) this.projectionUniforms[nl[De]].set(R[De]);
            if (T) for (const De in this.fixedUniforms) this.fixedUniforms[De].set(T[De]);
            fe && fe.setUniforms(t, this.binderUniforms, re, { zoom: de });
            let Ie = 0;
            switch (a) {
              case xe.LINES:
                Ie = 2;
                break;
              case xe.TRIANGLES:
                Ie = 3;
                break;
              case xe.LINE_STRIP:
                Ie = 1;
            }
            for (const De of X.get()) {
              const Se = De.vaos || (De.vaos = {});
              (Se[z] || (Se[z] = new Sm())).bind(t, this, W, fe ? fe.getPaintVertexBuffers() : [], U, De.vertexOffset, me, Ce, Pe), xe.drawElements(a, De.primitiveLength * Ie, xe.UNSIGNED_SHORT, De.primitiveOffset * Ie * 2);
            }
          }
        }
        function ol(_, t, a) {
          const d = 1 / s.aH(a, 1, t.transform.tileZoom), g = Math.pow(2, a.tileID.overscaledZ), b = a.tileSize * Math.pow(2, t.transform.tileZoom) / g, w = b * (a.tileID.canonical.x + a.tileID.wrap * g), T = b * a.tileID.canonical.y;
          return { u_image: 0, u_texsize: a.imageAtlasTexture.size, u_scale: [d, _.fromScale, _.toScale], u_fade: _.t, u_pixel_coord_upper: [w >> 16, T >> 16], u_pixel_coord_lower: [65535 & w, 65535 & T] };
        }
        const Jh = (_, t, a, d) => {
          const g = _.style.light, b = g.properties.get("position"), w = [b.x, b.y, b.z], T = s.b_();
          g.properties.get("anchor") === "viewport" && s.b$(T, _.transform.bearingInRadians), s.c0(w, w, T);
          const I = _.transform.transformLightDirection(w), R = g.properties.get("color");
          return { u_lightpos: w, u_lightpos_globe: I, u_lightintensity: g.properties.get("intensity"), u_lightcolor: [R.r, R.g, R.b], u_vertical_gradient: +t, u_opacity: a, u_fill_translate: d };
        }, _s = (_, t, a, d, g, b, w) => s.e(Jh(_, t, a, d), ol(b, _, w), { u_height_factor: -Math.pow(2, g.overscaledZ) / w.tileSize / 8 }), Qh = (_, t, a, d) => s.e(ol(t, _, a), { u_fill_translate: d }), ef = (_, t) => ({ u_world: _, u_fill_translate: t }), Tm = (_, t, a, d, g) => s.e(Qh(_, t, a, g), { u_world: d }), tf = (_, t, a, d, g) => {
          const b = _.transform;
          let w, T, I = 0;
          if (a.paint.get("circle-pitch-alignment") === "map") {
            const R = s.aH(t, 1, b.zoom);
            w = true, T = [R, R], I = R / (s.a3 * Math.pow(2, t.tileID.overscaledZ)) * 2 * Math.PI * g;
          } else w = false, T = b.pixelsToGLUnits;
          return { u_camera_to_center_distance: b.cameraToCenterDistance, u_scale_with_map: +(a.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +w, u_device_pixel_ratio: _.pixelRatio, u_extrude_scale: T, u_globe_extrude_scale: I, u_translate: d };
        }, Kc = (_) => ({ u_pixel_extrude_scale: [1 / _.width, 1 / _.height] }), rf = (_) => ({ u_viewport_size: [_.width, _.height] }), Jc = (_, t = 1) => ({ u_color: _, u_overlay: 0, u_overlay_scale: t }), Qc = (_, t, a, d) => {
          const g = s.aH(_, 1, t) / (s.a3 * Math.pow(2, _.tileID.overscaledZ)) * 2 * Math.PI * d;
          return { u_extrude_scale: s.aH(_, 1, t), u_intensity: a, u_globe_extrude_scale: g };
        }, ed = (_, t, a, d) => {
          const g = s.M();
          s.c1(g, 0, _.width, _.height, 0, 0, 1);
          const b = _.context.gl;
          return { u_matrix: g, u_world: [b.drawingBufferWidth, b.drawingBufferHeight], u_image: a, u_color_ramp: d, u_opacity: t.paint.get("heatmap-opacity") };
        }, Ua = (_, t, a) => {
          const d = a.paint.get("hillshade-accent-color");
          let g;
          switch (a.paint.get("hillshade-method")) {
            case "basic":
              g = 4;
              break;
            case "combined":
              g = 1;
              break;
            case "igor":
              g = 2;
              break;
            case "multidirectional":
              g = 3;
              break;
            default:
              g = 0;
          }
          const b = a.getIlluminationProperties();
          for (let w = 0; w < b.directionRadians.length; w++) a.paint.get("hillshade-illumination-anchor") === "viewport" && (b.directionRadians[w] += _.transform.bearingInRadians);
          return { u_image: 0, u_latrange: of(0, t.tileID), u_exaggeration: a.paint.get("hillshade-exaggeration"), u_altitudes: b.altitudeRadians, u_azimuths: b.directionRadians, u_accent: d, u_method: g, u_highlights: b.highlightColor, u_shadows: b.shadowColor };
        }, nf = (_, t) => {
          const a = t.stride, d = s.M();
          return s.c1(d, 0, s.a3, -s.a3, 0, 0, 1), s.N(d, d, [0, -s.a3, 0]), { u_matrix: d, u_image: 1, u_dimension: [a, a], u_zoom: _.overscaledZ, u_unpack: t.getUnpackVector() };
        };
        function of(_, t) {
          const a = Math.pow(2, t.canonical.z), d = t.canonical.y;
          return [new s.a5(0, d / a).toLngLat().lat, new s.a5(0, (d + 1) / a).toLngLat().lat];
        }
        const al = (_, t, a = 0) => ({ u_image: 0, u_unpack: t.getUnpackVector(), u_dimension: [t.stride, t.stride], u_elevation_stops: 1, u_color_stops: 4, u_color_ramp_size: a, u_opacity: _.paint.get("color-relief-opacity") }), yu = (_, t, a, d) => {
          const g = _.transform;
          return { u_translation: td(_, t, a), u_ratio: d / s.aH(t, 1, g.zoom), u_device_pixel_ratio: _.pixelRatio, u_units_to_pixels: [1 / g.pixelsToGLUnits[0], 1 / g.pixelsToGLUnits[1]] };
        }, sl = (_, t, a, d, g) => s.e(yu(_, t, a, d), { u_image: 0, u_image_height: g }), Pm = (_, t, a, d, g) => {
          const b = _.transform, w = _u(t, b);
          return { u_translation: td(_, t, a), u_texsize: t.imageAtlasTexture.size, u_ratio: d / s.aH(t, 1, b.zoom), u_device_pixel_ratio: _.pixelRatio, u_image: 0, u_scale: [w, g.fromScale, g.toScale], u_fade: g.t, u_units_to_pixels: [1 / b.pixelsToGLUnits[0], 1 / b.pixelsToGLUnits[1]] };
        }, Im = (_, t, a, d, g) => {
          const b = _u(t, _.transform);
          return s.e(yu(_, t, a, d), { u_tileratio: b, u_crossfade_from: g.fromScale, u_crossfade_to: g.toScale, u_image: 0, u_mix: g.t, u_lineatlas_width: _.lineAtlas.width, u_lineatlas_height: _.lineAtlas.height });
        }, af = (_, t, a, d, g, b) => {
          const w = _u(t, _.transform);
          return s.e(yu(_, t, a, d), { u_image: 0, u_image_height: b, u_tileratio: w, u_crossfade_from: g.fromScale, u_crossfade_to: g.toScale, u_image_dash: 1, u_mix: g.t, u_lineatlas_width: _.lineAtlas.width, u_lineatlas_height: _.lineAtlas.height });
        };
        function _u(_, t) {
          return 1 / s.aH(_, 1, t.tileZoom);
        }
        function td(_, t, a) {
          return s.aI(_.transform, t, a.paint.get("line-translate"), a.paint.get("line-translate-anchor"));
        }
        const rd = (_, t, a, d, g) => {
          return { u_tl_parent: _, u_scale_parent: t, u_buffer_scale: 1, u_fade_t: a.mix, u_opacity: a.opacity * d.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: d.paint.get("raster-brightness-min"), u_brightness_high: d.paint.get("raster-brightness-max"), u_saturation_factor: (w = d.paint.get("raster-saturation"), w > 0 ? 1 - 1 / (1.001 - w) : -w), u_contrast_factor: (b = d.paint.get("raster-contrast"), b > 0 ? 1 / (1 - b) : 1 + b), u_spin_weights: sf(d.paint.get("raster-hue-rotate")), u_coords_top: [g[0].x, g[0].y, g[1].x, g[1].y], u_coords_bottom: [g[3].x, g[3].y, g[2].x, g[2].y] };
          var b, w;
        };
        function sf(_) {
          _ *= Math.PI / 180;
          const t = Math.sin(_), a = Math.cos(_);
          return [(2 * a + 1) / 3, (-Math.sqrt(3) * t - a + 1) / 3, (Math.sqrt(3) * t - a + 1) / 3];
        }
        const ll = (_, t, a, d, g, b, w, T, I, R, z, W, U) => {
          const X = w.transform;
          return { u_is_size_zoom_constant: +(_ === "constant" || _ === "source"), u_is_size_feature_constant: +(_ === "constant" || _ === "camera"), u_size_t: t ? t.uSizeT : 0, u_size: t ? t.uSize : 0, u_camera_to_center_distance: X.cameraToCenterDistance, u_pitch: X.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +a, u_aspect_ratio: X.width / X.height, u_fade_change: w.options.fadeDuration ? w.symbolFadeChange : 1, u_label_plane_matrix: T, u_coord_matrix: I, u_is_text: +z, u_pitch_with_map: +d, u_is_along_line: g, u_is_variable_anchor: b, u_texsize: W, u_texture: 0, u_translation: R, u_pitched_scale: U };
        }, Uo = (_, t, a, d, g, b, w, T, I, R, z, W, U, X) => {
          const re = w.transform;
          return s.e(ll(_, t, a, d, g, b, w, T, I, R, z, W, X), { u_gamma_scale: d ? Math.cos(re.pitch * Math.PI / 180) * re.cameraToCenterDistance : 1, u_device_pixel_ratio: w.pixelRatio, u_is_halo: 1 });
        }, id = (_, t, a, d, g, b, w, T, I, R, z, W, U) => s.e(Uo(_, t, a, d, g, b, w, T, I, R, true, z, 0, U), { u_texsize_icon: W, u_texture_icon: 1 }), nd = (_, t) => ({ u_opacity: _, u_color: t }), od = (_, t, a, d, g) => s.e((function(b, w, T, I) {
          const R = T.imageManager.getPattern(b.from.toString()), z = T.imageManager.getPattern(b.to.toString()), { width: W, height: U } = T.imageManager.getPixelSize(), X = Math.pow(2, I.tileID.overscaledZ), re = I.tileSize * Math.pow(2, T.transform.tileZoom) / X, de = re * (I.tileID.canonical.x + I.tileID.wrap * X), fe = re * I.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: R.tl, u_pattern_br_a: R.br, u_pattern_tl_b: z.tl, u_pattern_br_b: z.br, u_texsize: [W, U], u_mix: w.t, u_pattern_size_a: R.displaySize, u_pattern_size_b: z.displaySize, u_scale_a: w.fromScale, u_scale_b: w.toScale, u_tile_units_to_pixels: 1 / s.aH(I, 1, T.transform.tileZoom), u_pixel_coord_upper: [de >> 16, fe >> 16], u_pixel_coord_lower: [65535 & de, 65535 & fe] };
        })(a, g, t, d), { u_opacity: _ }), ad = (_, t) => {
        }, sd = { fillExtrusion: (_, t) => ({ u_lightpos: new s.bY(_, t.u_lightpos), u_lightpos_globe: new s.bY(_, t.u_lightpos_globe), u_lightintensity: new s.bk(_, t.u_lightintensity), u_lightcolor: new s.bY(_, t.u_lightcolor), u_vertical_gradient: new s.bk(_, t.u_vertical_gradient), u_opacity: new s.bk(_, t.u_opacity), u_fill_translate: new s.bZ(_, t.u_fill_translate) }), fillExtrusionPattern: (_, t) => ({ u_lightpos: new s.bY(_, t.u_lightpos), u_lightpos_globe: new s.bY(_, t.u_lightpos_globe), u_lightintensity: new s.bk(_, t.u_lightintensity), u_lightcolor: new s.bY(_, t.u_lightcolor), u_vertical_gradient: new s.bk(_, t.u_vertical_gradient), u_height_factor: new s.bk(_, t.u_height_factor), u_opacity: new s.bk(_, t.u_opacity), u_fill_translate: new s.bZ(_, t.u_fill_translate), u_image: new s.bU(_, t.u_image), u_texsize: new s.bZ(_, t.u_texsize), u_pixel_coord_upper: new s.bZ(_, t.u_pixel_coord_upper), u_pixel_coord_lower: new s.bZ(_, t.u_pixel_coord_lower), u_scale: new s.bY(_, t.u_scale), u_fade: new s.bk(_, t.u_fade) }), fill: (_, t) => ({ u_fill_translate: new s.bZ(_, t.u_fill_translate) }), fillPattern: (_, t) => ({ u_image: new s.bU(_, t.u_image), u_texsize: new s.bZ(_, t.u_texsize), u_pixel_coord_upper: new s.bZ(_, t.u_pixel_coord_upper), u_pixel_coord_lower: new s.bZ(_, t.u_pixel_coord_lower), u_scale: new s.bY(_, t.u_scale), u_fade: new s.bk(_, t.u_fade), u_fill_translate: new s.bZ(_, t.u_fill_translate) }), fillOutline: (_, t) => ({ u_world: new s.bZ(_, t.u_world), u_fill_translate: new s.bZ(_, t.u_fill_translate) }), fillOutlinePattern: (_, t) => ({ u_world: new s.bZ(_, t.u_world), u_image: new s.bU(_, t.u_image), u_texsize: new s.bZ(_, t.u_texsize), u_pixel_coord_upper: new s.bZ(_, t.u_pixel_coord_upper), u_pixel_coord_lower: new s.bZ(_, t.u_pixel_coord_lower), u_scale: new s.bY(_, t.u_scale), u_fade: new s.bk(_, t.u_fade), u_fill_translate: new s.bZ(_, t.u_fill_translate) }), circle: (_, t) => ({ u_camera_to_center_distance: new s.bk(_, t.u_camera_to_center_distance), u_scale_with_map: new s.bU(_, t.u_scale_with_map), u_pitch_with_map: new s.bU(_, t.u_pitch_with_map), u_extrude_scale: new s.bZ(_, t.u_extrude_scale), u_device_pixel_ratio: new s.bk(_, t.u_device_pixel_ratio), u_globe_extrude_scale: new s.bk(_, t.u_globe_extrude_scale), u_translate: new s.bZ(_, t.u_translate) }), collisionBox: (_, t) => ({ u_pixel_extrude_scale: new s.bZ(_, t.u_pixel_extrude_scale) }), collisionCircle: (_, t) => ({ u_viewport_size: new s.bZ(_, t.u_viewport_size) }), debug: (_, t) => ({ u_color: new s.bV(_, t.u_color), u_overlay: new s.bU(_, t.u_overlay), u_overlay_scale: new s.bk(_, t.u_overlay_scale) }), depth: ad, clippingMask: ad, heatmap: (_, t) => ({ u_extrude_scale: new s.bk(_, t.u_extrude_scale), u_intensity: new s.bk(_, t.u_intensity), u_globe_extrude_scale: new s.bk(_, t.u_globe_extrude_scale) }), heatmapTexture: (_, t) => ({ u_matrix: new s.bW(_, t.u_matrix), u_world: new s.bZ(_, t.u_world), u_image: new s.bU(_, t.u_image), u_color_ramp: new s.bU(_, t.u_color_ramp), u_opacity: new s.bk(_, t.u_opacity) }), hillshade: (_, t) => ({ u_image: new s.bU(_, t.u_image), u_latrange: new s.bZ(_, t.u_latrange), u_exaggeration: new s.bk(_, t.u_exaggeration), u_altitudes: new s.c3(_, t.u_altitudes), u_azimuths: new s.c3(_, t.u_azimuths), u_accent: new s.bV(_, t.u_accent), u_method: new s.bU(_, t.u_method), u_shadows: new s.c2(_, t.u_shadows), u_highlights: new s.c2(_, t.u_highlights) }), hillshadePrepare: (_, t) => ({ u_matrix: new s.bW(_, t.u_matrix), u_image: new s.bU(_, t.u_image), u_dimension: new s.bZ(_, t.u_dimension), u_zoom: new s.bk(_, t.u_zoom), u_unpack: new s.bX(_, t.u_unpack) }), colorRelief: (_, t) => ({ u_image: new s.bU(_, t.u_image), u_unpack: new s.bX(_, t.u_unpack), u_dimension: new s.bZ(_, t.u_dimension), u_elevation_stops: new s.bU(_, t.u_elevation_stops), u_color_stops: new s.bU(_, t.u_color_stops), u_color_ramp_size: new s.bU(_, t.u_color_ramp_size), u_opacity: new s.bk(_, t.u_opacity) }), line: (_, t) => ({ u_translation: new s.bZ(_, t.u_translation), u_ratio: new s.bk(_, t.u_ratio), u_device_pixel_ratio: new s.bk(_, t.u_device_pixel_ratio), u_units_to_pixels: new s.bZ(_, t.u_units_to_pixels) }), lineGradient: (_, t) => ({ u_translation: new s.bZ(_, t.u_translation), u_ratio: new s.bk(_, t.u_ratio), u_device_pixel_ratio: new s.bk(_, t.u_device_pixel_ratio), u_units_to_pixels: new s.bZ(_, t.u_units_to_pixels), u_image: new s.bU(_, t.u_image), u_image_height: new s.bk(_, t.u_image_height) }), linePattern: (_, t) => ({ u_translation: new s.bZ(_, t.u_translation), u_texsize: new s.bZ(_, t.u_texsize), u_ratio: new s.bk(_, t.u_ratio), u_device_pixel_ratio: new s.bk(_, t.u_device_pixel_ratio), u_image: new s.bU(_, t.u_image), u_units_to_pixels: new s.bZ(_, t.u_units_to_pixels), u_scale: new s.bY(_, t.u_scale), u_fade: new s.bk(_, t.u_fade) }), lineSDF: (_, t) => ({ u_translation: new s.bZ(_, t.u_translation), u_ratio: new s.bk(_, t.u_ratio), u_device_pixel_ratio: new s.bk(_, t.u_device_pixel_ratio), u_units_to_pixels: new s.bZ(_, t.u_units_to_pixels), u_image: new s.bU(_, t.u_image), u_mix: new s.bk(_, t.u_mix), u_tileratio: new s.bk(_, t.u_tileratio), u_crossfade_from: new s.bk(_, t.u_crossfade_from), u_crossfade_to: new s.bk(_, t.u_crossfade_to), u_lineatlas_width: new s.bk(_, t.u_lineatlas_width), u_lineatlas_height: new s.bk(_, t.u_lineatlas_height) }), lineGradientSDF: (_, t) => ({ u_translation: new s.bZ(_, t.u_translation), u_ratio: new s.bk(_, t.u_ratio), u_device_pixel_ratio: new s.bk(_, t.u_device_pixel_ratio), u_units_to_pixels: new s.bZ(_, t.u_units_to_pixels), u_image: new s.bU(_, t.u_image), u_image_height: new s.bk(_, t.u_image_height), u_tileratio: new s.bk(_, t.u_tileratio), u_crossfade_from: new s.bk(_, t.u_crossfade_from), u_crossfade_to: new s.bk(_, t.u_crossfade_to), u_image_dash: new s.bU(_, t.u_image_dash), u_mix: new s.bk(_, t.u_mix), u_lineatlas_width: new s.bk(_, t.u_lineatlas_width), u_lineatlas_height: new s.bk(_, t.u_lineatlas_height) }), raster: (_, t) => ({ u_tl_parent: new s.bZ(_, t.u_tl_parent), u_scale_parent: new s.bk(_, t.u_scale_parent), u_buffer_scale: new s.bk(_, t.u_buffer_scale), u_fade_t: new s.bk(_, t.u_fade_t), u_opacity: new s.bk(_, t.u_opacity), u_image0: new s.bU(_, t.u_image0), u_image1: new s.bU(_, t.u_image1), u_brightness_low: new s.bk(_, t.u_brightness_low), u_brightness_high: new s.bk(_, t.u_brightness_high), u_saturation_factor: new s.bk(_, t.u_saturation_factor), u_contrast_factor: new s.bk(_, t.u_contrast_factor), u_spin_weights: new s.bY(_, t.u_spin_weights), u_coords_top: new s.bX(_, t.u_coords_top), u_coords_bottom: new s.bX(_, t.u_coords_bottom) }), symbolIcon: (_, t) => ({ u_is_size_zoom_constant: new s.bU(_, t.u_is_size_zoom_constant), u_is_size_feature_constant: new s.bU(_, t.u_is_size_feature_constant), u_size_t: new s.bk(_, t.u_size_t), u_size: new s.bk(_, t.u_size), u_camera_to_center_distance: new s.bk(_, t.u_camera_to_center_distance), u_pitch: new s.bk(_, t.u_pitch), u_rotate_symbol: new s.bU(_, t.u_rotate_symbol), u_aspect_ratio: new s.bk(_, t.u_aspect_ratio), u_fade_change: new s.bk(_, t.u_fade_change), u_label_plane_matrix: new s.bW(_, t.u_label_plane_matrix), u_coord_matrix: new s.bW(_, t.u_coord_matrix), u_is_text: new s.bU(_, t.u_is_text), u_pitch_with_map: new s.bU(_, t.u_pitch_with_map), u_is_along_line: new s.bU(_, t.u_is_along_line), u_is_variable_anchor: new s.bU(_, t.u_is_variable_anchor), u_texsize: new s.bZ(_, t.u_texsize), u_texture: new s.bU(_, t.u_texture), u_translation: new s.bZ(_, t.u_translation), u_pitched_scale: new s.bk(_, t.u_pitched_scale) }), symbolSDF: (_, t) => ({ u_is_size_zoom_constant: new s.bU(_, t.u_is_size_zoom_constant), u_is_size_feature_constant: new s.bU(_, t.u_is_size_feature_constant), u_size_t: new s.bk(_, t.u_size_t), u_size: new s.bk(_, t.u_size), u_camera_to_center_distance: new s.bk(_, t.u_camera_to_center_distance), u_pitch: new s.bk(_, t.u_pitch), u_rotate_symbol: new s.bU(_, t.u_rotate_symbol), u_aspect_ratio: new s.bk(_, t.u_aspect_ratio), u_fade_change: new s.bk(_, t.u_fade_change), u_label_plane_matrix: new s.bW(_, t.u_label_plane_matrix), u_coord_matrix: new s.bW(_, t.u_coord_matrix), u_is_text: new s.bU(_, t.u_is_text), u_pitch_with_map: new s.bU(_, t.u_pitch_with_map), u_is_along_line: new s.bU(_, t.u_is_along_line), u_is_variable_anchor: new s.bU(_, t.u_is_variable_anchor), u_texsize: new s.bZ(_, t.u_texsize), u_texture: new s.bU(_, t.u_texture), u_gamma_scale: new s.bk(_, t.u_gamma_scale), u_device_pixel_ratio: new s.bk(_, t.u_device_pixel_ratio), u_is_halo: new s.bU(_, t.u_is_halo), u_translation: new s.bZ(_, t.u_translation), u_pitched_scale: new s.bk(_, t.u_pitched_scale) }), symbolTextAndIcon: (_, t) => ({ u_is_size_zoom_constant: new s.bU(_, t.u_is_size_zoom_constant), u_is_size_feature_constant: new s.bU(_, t.u_is_size_feature_constant), u_size_t: new s.bk(_, t.u_size_t), u_size: new s.bk(_, t.u_size), u_camera_to_center_distance: new s.bk(_, t.u_camera_to_center_distance), u_pitch: new s.bk(_, t.u_pitch), u_rotate_symbol: new s.bU(_, t.u_rotate_symbol), u_aspect_ratio: new s.bk(_, t.u_aspect_ratio), u_fade_change: new s.bk(_, t.u_fade_change), u_label_plane_matrix: new s.bW(_, t.u_label_plane_matrix), u_coord_matrix: new s.bW(_, t.u_coord_matrix), u_is_text: new s.bU(_, t.u_is_text), u_pitch_with_map: new s.bU(_, t.u_pitch_with_map), u_is_along_line: new s.bU(_, t.u_is_along_line), u_is_variable_anchor: new s.bU(_, t.u_is_variable_anchor), u_texsize: new s.bZ(_, t.u_texsize), u_texsize_icon: new s.bZ(_, t.u_texsize_icon), u_texture: new s.bU(_, t.u_texture), u_texture_icon: new s.bU(_, t.u_texture_icon), u_gamma_scale: new s.bk(_, t.u_gamma_scale), u_device_pixel_ratio: new s.bk(_, t.u_device_pixel_ratio), u_is_halo: new s.bU(_, t.u_is_halo), u_translation: new s.bZ(_, t.u_translation), u_pitched_scale: new s.bk(_, t.u_pitched_scale) }), background: (_, t) => ({ u_opacity: new s.bk(_, t.u_opacity), u_color: new s.bV(_, t.u_color) }), backgroundPattern: (_, t) => ({ u_opacity: new s.bk(_, t.u_opacity), u_image: new s.bU(_, t.u_image), u_pattern_tl_a: new s.bZ(_, t.u_pattern_tl_a), u_pattern_br_a: new s.bZ(_, t.u_pattern_br_a), u_pattern_tl_b: new s.bZ(_, t.u_pattern_tl_b), u_pattern_br_b: new s.bZ(_, t.u_pattern_br_b), u_texsize: new s.bZ(_, t.u_texsize), u_mix: new s.bk(_, t.u_mix), u_pattern_size_a: new s.bZ(_, t.u_pattern_size_a), u_pattern_size_b: new s.bZ(_, t.u_pattern_size_b), u_scale_a: new s.bk(_, t.u_scale_a), u_scale_b: new s.bk(_, t.u_scale_b), u_pixel_coord_upper: new s.bZ(_, t.u_pixel_coord_upper), u_pixel_coord_lower: new s.bZ(_, t.u_pixel_coord_lower), u_tile_units_to_pixels: new s.bk(_, t.u_tile_units_to_pixels) }), terrain: (_, t) => ({ u_texture: new s.bU(_, t.u_texture), u_ele_delta: new s.bk(_, t.u_ele_delta), u_fog_matrix: new s.bW(_, t.u_fog_matrix), u_fog_color: new s.bV(_, t.u_fog_color), u_fog_ground_blend: new s.bk(_, t.u_fog_ground_blend), u_fog_ground_blend_opacity: new s.bk(_, t.u_fog_ground_blend_opacity), u_horizon_color: new s.bV(_, t.u_horizon_color), u_horizon_fog_blend: new s.bk(_, t.u_horizon_fog_blend), u_is_globe_mode: new s.bk(_, t.u_is_globe_mode) }), terrainDepth: (_, t) => ({ u_ele_delta: new s.bk(_, t.u_ele_delta) }), terrainCoords: (_, t) => ({ u_texture: new s.bU(_, t.u_texture), u_terrain_coords_id: new s.bk(_, t.u_terrain_coords_id), u_ele_delta: new s.bk(_, t.u_ele_delta) }), projectionErrorMeasurement: (_, t) => ({ u_input: new s.bk(_, t.u_input), u_output_expected: new s.bk(_, t.u_output_expected) }), atmosphere: (_, t) => ({ u_sun_pos: new s.bY(_, t.u_sun_pos), u_atmosphere_blend: new s.bk(_, t.u_atmosphere_blend), u_globe_position: new s.bY(_, t.u_globe_position), u_globe_radius: new s.bk(_, t.u_globe_radius), u_inv_proj_matrix: new s.bW(_, t.u_inv_proj_matrix) }), sky: (_, t) => ({ u_sky_color: new s.bV(_, t.u_sky_color), u_horizon_color: new s.bV(_, t.u_horizon_color), u_horizon: new s.bZ(_, t.u_horizon), u_horizon_normal: new s.bZ(_, t.u_horizon_normal), u_sky_horizon_blend: new s.bk(_, t.u_sky_horizon_blend), u_sky_blend: new s.bk(_, t.u_sky_blend) }) };
        class Ga {
          constructor(t, a, d) {
            this.context = t;
            const g = t.gl;
            this.buffer = g.createBuffer(), this.dynamicDraw = !!d, this.context.unbindVAO(), t.bindElementBuffer.set(this.buffer), g.bufferData(g.ELEMENT_ARRAY_BUFFER, a.arrayBuffer, this.dynamicDraw ? g.DYNAMIC_DRAW : g.STATIC_DRAW), this.dynamicDraw || delete a.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(t) {
            const a = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), a.bufferSubData(a.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const ld = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class Em {
          constructor(t, a, d, g) {
            this.length = a.length, this.attributes = d, this.itemSize = a.bytesPerElement, this.dynamicDraw = g, this.context = t;
            const b = t.gl;
            this.buffer = b.createBuffer(), t.bindVertexBuffer.set(this.buffer), b.bufferData(b.ARRAY_BUFFER, a.arrayBuffer, this.dynamicDraw ? b.DYNAMIC_DRAW : b.STATIC_DRAW), this.dynamicDraw || delete a.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(t) {
            if (t.length !== this.length) throw new Error(`Length of new data is ${t.length}, which doesn't match current length of ${this.length}`);
            const a = this.context.gl;
            this.bind(), a.bufferSubData(a.ARRAY_BUFFER, 0, t.arrayBuffer);
          }
          enableAttributes(t, a) {
            for (let d = 0; d < this.attributes.length; d++) {
              const g = a.attributes[this.attributes[d].name];
              g !== void 0 && t.enableVertexAttribArray(g);
            }
          }
          setVertexAttribPointers(t, a, d) {
            for (let g = 0; g < this.attributes.length; g++) {
              const b = this.attributes[g], w = a.attributes[b.name];
              w !== void 0 && t.vertexAttribPointer(w, b.components, t[ld[b.type]], false, this.itemSize, b.offset + this.itemSize * (d || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class Lr {
          constructor(t) {
            this.gl = t.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(t) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Mm extends Lr {
          getDefault() {
            return s.bj.transparent;
          }
          set(t) {
            const a = this.current;
            (t.r !== a.r || t.g !== a.g || t.b !== a.b || t.a !== a.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = false);
          }
        }
        class Dm extends Lr {
          getDefault() {
            return 1;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.clearDepth(t), this.current = t, this.dirty = false);
          }
        }
        class lf extends Lr {
          getDefault() {
            return 0;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.clearStencil(t), this.current = t, this.dirty = false);
          }
        }
        class Rm extends Lr {
          getDefault() {
            return [true, true, true, true];
          }
          set(t) {
            const a = this.current;
            (t[0] !== a[0] || t[1] !== a[1] || t[2] !== a[2] || t[3] !== a[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = false);
          }
        }
        class uf extends Lr {
          getDefault() {
            return true;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.depthMask(t), this.current = t, this.dirty = false);
          }
        }
        class bu extends Lr {
          getDefault() {
            return 255;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.stencilMask(t), this.current = t, this.dirty = false);
          }
        }
        class xu extends Lr {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(t) {
            const a = this.current;
            (t.func !== a.func || t.ref !== a.ref || t.mask !== a.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask), this.current = t, this.dirty = false);
          }
        }
        class wu extends Lr {
          getDefault() {
            const t = this.gl;
            return [t.KEEP, t.KEEP, t.KEEP];
          }
          set(t) {
            const a = this.current;
            (t[0] !== a[0] || t[1] !== a[1] || t[2] !== a[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]), this.current = t, this.dirty = false);
          }
        }
        class ud extends Lr {
          getDefault() {
            return false;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const a = this.gl;
            t ? a.enable(a.STENCIL_TEST) : a.disable(a.STENCIL_TEST), this.current = t, this.dirty = false;
          }
        }
        class qa extends Lr {
          getDefault() {
            return [0, 1];
          }
          set(t) {
            const a = this.current;
            (t[0] !== a[0] || t[1] !== a[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]), this.current = t, this.dirty = false);
          }
        }
        class ul extends Lr {
          getDefault() {
            return false;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const a = this.gl;
            t ? a.enable(a.DEPTH_TEST) : a.disable(a.DEPTH_TEST), this.current = t, this.dirty = false;
          }
        }
        class bs extends Lr {
          getDefault() {
            return this.gl.LESS;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.depthFunc(t), this.current = t, this.dirty = false);
          }
        }
        class oo extends Lr {
          getDefault() {
            return false;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const a = this.gl;
            t ? a.enable(a.BLEND) : a.disable(a.BLEND), this.current = t, this.dirty = false;
          }
        }
        class cf extends Lr {
          getDefault() {
            const t = this.gl;
            return [t.ONE, t.ZERO];
          }
          set(t) {
            const a = this.current;
            (t[0] !== a[0] || t[1] !== a[1] || this.dirty) && (this.gl.blendFunc(t[0], t[1]), this.current = t, this.dirty = false);
          }
        }
        class df extends Lr {
          getDefault() {
            return s.bj.transparent;
          }
          set(t) {
            const a = this.current;
            (t.r !== a.r || t.g !== a.g || t.b !== a.b || t.a !== a.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = false);
          }
        }
        class cd extends Lr {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.blendEquation(t), this.current = t, this.dirty = false);
          }
        }
        class Wa extends Lr {
          getDefault() {
            return false;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const a = this.gl;
            t ? a.enable(a.CULL_FACE) : a.disable(a.CULL_FACE), this.current = t, this.dirty = false;
          }
        }
        class Cu extends Lr {
          getDefault() {
            return this.gl.BACK;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.cullFace(t), this.current = t, this.dirty = false);
          }
        }
        class Su extends Lr {
          getDefault() {
            return this.gl.CCW;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.frontFace(t), this.current = t, this.dirty = false);
          }
        }
        class cl extends Lr {
          getDefault() {
            return null;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.useProgram(t), this.current = t, this.dirty = false);
          }
        }
        class ku extends Lr {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.activeTexture(t), this.current = t, this.dirty = false);
          }
        }
        class hf extends Lr {
          getDefault() {
            const t = this.gl;
            return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight];
          }
          set(t) {
            const a = this.current;
            (t[0] !== a[0] || t[1] !== a[1] || t[2] !== a[2] || t[3] !== a[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = false);
          }
        }
        class xs extends Lr {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindFramebuffer(a.FRAMEBUFFER, t), this.current = t, this.dirty = false;
          }
        }
        class ws extends Lr {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindRenderbuffer(a.RENDERBUFFER, t), this.current = t, this.dirty = false;
          }
        }
        class ff extends Lr {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindTexture(a.TEXTURE_2D, t), this.current = t, this.dirty = false;
          }
        }
        class dd extends Lr {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindBuffer(a.ARRAY_BUFFER, t), this.current = t, this.dirty = false;
          }
        }
        class kr extends Lr {
          getDefault() {
            return null;
          }
          set(t) {
            const a = this.gl;
            a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, t), this.current = t, this.dirty = false;
          }
        }
        class Tu extends Lr {
          getDefault() {
            return null;
          }
          set(t) {
            var a;
            if (t === this.current && !this.dirty) return;
            const d = this.gl;
            vo(d) ? d.bindVertexArray(t) : (a = d.getExtension("OES_vertex_array_object")) === null || a === void 0 || a.bindVertexArrayOES(t), this.current = t, this.dirty = false;
          }
        }
        class Am extends Lr {
          getDefault() {
            return 4;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_ALIGNMENT, t), this.current = t, this.dirty = false;
          }
        }
        class pf extends Lr {
          getDefault() {
            return false;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t), this.current = t, this.dirty = false;
          }
        }
        class dl extends Lr {
          getDefault() {
            return false;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, t), this.current = t, this.dirty = false;
          }
        }
        class hd extends Lr {
          constructor(t, a) {
            super(t), this.context = t, this.parent = a;
          }
          getDefault() {
            return null;
          }
        }
        class zm extends hd {
          setDirty() {
            this.dirty = true;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, t, 0), this.current = t, this.dirty = false;
          }
        }
        class mf extends hd {
          set(t) {
            if (t === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, t), this.current = t, this.dirty = false;
          }
        }
        class Fm extends hd {
          set(t) {
            if (t === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, t), this.current = t, this.dirty = false;
          }
        }
        const Pu = "Framebuffer is not complete";
        class Iu {
          constructor(t, a, d, g, b) {
            this.context = t, this.width = a, this.height = d;
            const w = t.gl, T = this.framebuffer = w.createFramebuffer();
            if (this.colorAttachment = new zm(t, T), g) this.depthAttachment = b ? new Fm(t, T) : new mf(t, T);
            else if (b) throw new Error("Stencil cannot be set without depth");
            if (w.checkFramebufferStatus(w.FRAMEBUFFER) !== w.FRAMEBUFFER_COMPLETE) throw new Error(Pu);
          }
          destroy() {
            const t = this.context.gl, a = this.colorAttachment.get();
            if (a && t.deleteTexture(a), this.depthAttachment) {
              const d = this.depthAttachment.get();
              d && t.deleteRenderbuffer(d);
            }
            t.deleteFramebuffer(this.framebuffer);
          }
        }
        class Eu {
          constructor(t) {
            var a, d;
            if (this.gl = t, this.clearColor = new Mm(this), this.clearDepth = new Dm(this), this.clearStencil = new lf(this), this.colorMask = new Rm(this), this.depthMask = new uf(this), this.stencilMask = new bu(this), this.stencilFunc = new xu(this), this.stencilOp = new wu(this), this.stencilTest = new ud(this), this.depthRange = new qa(this), this.depthTest = new ul(this), this.depthFunc = new bs(this), this.blend = new oo(this), this.blendFunc = new cf(this), this.blendColor = new df(this), this.blendEquation = new cd(this), this.cullFace = new Wa(this), this.cullFaceSide = new Cu(this), this.frontFace = new Su(this), this.program = new cl(this), this.activeTexture = new ku(this), this.viewport = new hf(this), this.bindFramebuffer = new xs(this), this.bindRenderbuffer = new ws(this), this.bindTexture = new ff(this), this.bindVertexBuffer = new dd(this), this.bindElementBuffer = new kr(this), this.bindVertexArray = new Tu(this), this.pixelStoreUnpack = new Am(this), this.pixelStoreUnpackPremultiplyAlpha = new pf(this), this.pixelStoreUnpackFlipY = new dl(this), this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), vo(t)) {
              this.HALF_FLOAT = t.HALF_FLOAT;
              const g = t.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (a = t.RGBA16F) !== null && a !== void 0 ? a : g == null ? void 0 : g.RGBA16F_EXT, this.RGB16F = (d = t.RGB16F) !== null && d !== void 0 ? d : g == null ? void 0 : g.RGB16F_EXT, t.getExtension("EXT_color_buffer_float");
            } else {
              t.getExtension("EXT_color_buffer_half_float"), t.getExtension("OES_texture_half_float_linear");
              const g = t.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = g == null ? void 0 : g.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(t, a) {
            return new Ga(this, t, a);
          }
          createVertexBuffer(t, a, d) {
            return new Em(this, t, a, d);
          }
          createRenderbuffer(t, a, d) {
            const g = this.gl, b = g.createRenderbuffer();
            return this.bindRenderbuffer.set(b), g.renderbufferStorage(g.RENDERBUFFER, t, a, d), this.bindRenderbuffer.set(null), b;
          }
          createFramebuffer(t, a, d, g) {
            return new Iu(this, t, a, d, g);
          }
          clear({ color: t, depth: a, stencil: d }) {
            const g = this.gl;
            let b = 0;
            t && (b |= g.COLOR_BUFFER_BIT, this.clearColor.set(t), this.colorMask.set([true, true, true, true])), a !== void 0 && (b |= g.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(a), this.depthMask.set(true)), d !== void 0 && (b |= g.STENCIL_BUFFER_BIT, this.clearStencil.set(d), this.stencilMask.set(255)), g.clear(b);
          }
          setCullFace(t) {
            t.enable === false ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(t.mode), this.frontFace.set(t.frontFace));
          }
          setDepthMode(t) {
            t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(true), this.depthFunc.set(t.func), this.depthMask.set(t.mask), this.depthRange.set(t.range)) : this.depthTest.set(false);
          }
          setStencilMode(t) {
            t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(true), this.stencilMask.set(t.mask), this.stencilOp.set([t.fail, t.depthFail, t.pass]), this.stencilFunc.set({ func: t.test.func, ref: t.ref, mask: t.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(t) {
            s.bL(t.blendFunction, ti.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor)), this.colorMask.set(t.mask);
          }
          createVertexArray() {
            var t;
            return vo(this.gl) ? this.gl.createVertexArray() : (t = this.gl.getExtension("OES_vertex_array_object")) === null || t === void 0 ? void 0 : t.createVertexArrayOES();
          }
          deleteVertexArray(t) {
            var a;
            return vo(this.gl) ? this.gl.deleteVertexArray(t) : (a = this.gl.getExtension("OES_vertex_array_object")) === null || a === void 0 ? void 0 : a.deleteVertexArrayOES(t);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        let Za;
        function Mu(_, t, a, d, g) {
          const b = _.context, w = _.transform, T = b.gl, I = _.useProgram("collisionBox"), R = [];
          let z = 0, W = 0;
          for (let me = 0; me < d.length; me++) {
            const Ce = d[me], Pe = t.getTile(Ce).getBucket(a);
            if (!Pe) continue;
            const xe = g ? Pe.textCollisionBox : Pe.iconCollisionBox, Ie = Pe.collisionCircleArray;
            Ie.length > 0 && (R.push({ circleArray: Ie, circleOffset: W, coord: Ce }), z += Ie.length / 4, W = z), xe && I.draw(b, T.LINES, gr.disabled, Mr.disabled, _.colorModeForRenderPass(), Ar.disabled, Kc(_.transform), _.style.map.terrain && _.style.map.terrain.getTerrainData(Ce), w.getProjectionData({ overscaledTileID: Ce, applyGlobeMatrix: true, applyTerrainMatrix: true }), a.id, xe.layoutVertexBuffer, xe.indexBuffer, xe.segments, null, _.transform.zoom, null, null, xe.collisionVertexBuffer);
          }
          if (!g || !R.length) return;
          const U = _.useProgram("collisionCircle"), X = new s.c4();
          X.resize(4 * z), X._trim();
          let re = 0;
          for (const me of R) for (let Ce = 0; Ce < me.circleArray.length / 4; Ce++) {
            const Pe = 4 * Ce, xe = me.circleArray[Pe + 0], Ie = me.circleArray[Pe + 1], De = me.circleArray[Pe + 2], Se = me.circleArray[Pe + 3];
            X.emplace(re++, xe, Ie, De, Se, 0), X.emplace(re++, xe, Ie, De, Se, 1), X.emplace(re++, xe, Ie, De, Se, 2), X.emplace(re++, xe, Ie, De, Se, 3);
          }
          (!Za || Za.length < 2 * z) && (Za = (function(me) {
            const Ce = 2 * me, Pe = new s.c6();
            Pe.resize(Ce), Pe._trim();
            for (let xe = 0; xe < Ce; xe++) {
              const Ie = 6 * xe;
              Pe.uint16[Ie + 0] = 4 * xe + 0, Pe.uint16[Ie + 1] = 4 * xe + 1, Pe.uint16[Ie + 2] = 4 * xe + 2, Pe.uint16[Ie + 3] = 4 * xe + 2, Pe.uint16[Ie + 4] = 4 * xe + 3, Pe.uint16[Ie + 5] = 4 * xe + 0;
            }
            return Pe;
          })(z));
          const de = b.createIndexBuffer(Za, true), fe = b.createVertexBuffer(X, s.c5.members, true);
          for (const me of R) {
            const Ce = rf(_.transform);
            U.draw(b, T.TRIANGLES, gr.disabled, Mr.disabled, _.colorModeForRenderPass(), Ar.disabled, Ce, _.style.map.terrain && _.style.map.terrain.getTerrainData(me.coord), null, a.id, fe, de, s.aR.simpleSegment(0, 2 * me.circleOffset, me.circleArray.length, me.circleArray.length / 2), null, _.transform.zoom, null, null, null);
          }
          fe.destroy(), de.destroy();
        }
        const gf = s.am(new Float32Array(16));
        function Du(_, t, a, d, g, b) {
          const { horizontalAlign: w, verticalAlign: T } = s.aM(_);
          return new s.P((-(w - 0.5) * t / g + d[0]) * b, (-(T - 0.5) * a / g + d[1]) * b);
        }
        function Ru(_, t, a, d, g, b) {
          const w = t.tileAnchorPoint.add(new s.P(t.translation[0], t.translation[1]));
          if (t.pitchWithMap) {
            let T = d.mult(b);
            a || (T = T.rotate(-g));
            const I = w.add(T);
            return Bt(I.x, I.y, t.pitchedLabelPlaneMatrix, t.getElevation).point;
          }
          if (a) {
            const T = kn(t.tileAnchorPoint.x + 1, t.tileAnchorPoint.y, t).point.sub(_), I = Math.atan(T.y / T.x) + (T.x < 0 ? Math.PI : 0);
            return _.add(d.rotate(I));
          }
          return _.add(d);
        }
        function Au(_, t, a, d, g, b, w, T, I, R, z, W) {
          const U = _.text.placedSymbolArray, X = _.text.dynamicLayoutVertexArray, re = _.icon.dynamicLayoutVertexArray, de = {};
          X.clear();
          for (let fe = 0; fe < U.length; fe++) {
            const me = U.get(fe), Ce = me.hidden || !me.crossTileID || _.allowVerticalPlacement && !me.placedOrientation ? null : d[me.crossTileID];
            if (Ce) {
              const Pe = new s.P(me.anchorX, me.anchorY), xe = { getElevation: W, width: g.width, height: g.height, pitchedLabelPlaneMatrix: b, pitchWithMap: a, transform: g, tileAnchorPoint: Pe, translation: R, unwrappedTileID: z }, Ie = a ? Zn(Pe.x, Pe.y, xe) : kn(Pe.x, Pe.y, xe), De = Xt(g.cameraToCenterDistance, Ie.signedDistanceFromCamera);
              let Se = s.au(_.textSizeData, T, me) * De / s.aG;
              a && (Se *= _.tilePixelRatio / w);
              const { width: Ne, height: Ke, anchor: Ze, textOffset: He, textBoxScale: Je } = Ce, Tt = Du(Ze, Ne, Ke, He, Je, Se), It = g.getPitchedTextCorrection(Pe.x + R[0], Pe.y + R[1], z), _t = Ru(Ie.point, xe, t, Tt, -g.bearingInRadians, It), Gt = _.allowVerticalPlacement && me.placedOrientation === s.at.vertical ? Math.PI / 2 : 0;
              for (let Yt = 0; Yt < me.numGlyphs; Yt++) s.aA(X, _t, Gt);
              I && me.associatedIconIndex >= 0 && (de[me.associatedIconIndex] = { shiftedAnchor: _t, angle: Gt });
            } else ro(me.numGlyphs, X);
          }
          if (I) {
            re.clear();
            const fe = _.icon.placedSymbolArray;
            for (let me = 0; me < fe.length; me++) {
              const Ce = fe.get(me);
              if (Ce.hidden) ro(Ce.numGlyphs, re);
              else {
                const Pe = de[me];
                if (Pe) for (let xe = 0; xe < Ce.numGlyphs; xe++) s.aA(re, Pe.shiftedAnchor, Pe.angle);
                else ro(Ce.numGlyphs, re);
              }
            }
            _.icon.dynamicLayoutVertexBuffer.updateData(re);
          }
          _.text.dynamicLayoutVertexBuffer.updateData(X);
        }
        function Cs(_, t, a) {
          return a.iconsInText && t ? "symbolTextAndIcon" : _ ? "symbolSDF" : "symbolIcon";
        }
        function zu(_, t, a, d, g, b, w, T, I, R, z, W, U) {
          const X = _.context, re = X.gl, de = _.transform, fe = T === "map", me = I === "map", Ce = T !== "viewport" && a.layout.get("symbol-placement") !== "point", Pe = fe && !me && !Ce, xe = !a.layout.get("symbol-sort-key").isConstant();
          let Ie = false;
          const De = _.getDepthModeForSublayer(0, gr.ReadOnly), Se = a._unevaluatedLayout.hasValue("text-variable-anchor") || a._unevaluatedLayout.hasValue("text-variable-anchor-offset"), Ne = [], Ke = de.getCircleRadiusCorrection();
          for (const Ze of d) {
            const He = t.getTile(Ze), Je = He.getBucket(a);
            if (!Je) continue;
            const Tt = g ? Je.text : Je.icon;
            if (!Tt || !Tt.segments.get().length || !Tt.hasVisibleVertices) continue;
            const It = Tt.programConfigurations.get(a.id), _t = g || Je.sdfIcons, Gt = g ? Je.textSizeData : Je.iconSizeData, Yt = me || de.pitch !== 0, Br = _.useProgram(Cs(_t, g, Je), It), ri = s.as(Gt, de.zoom), Yr = _.style.map.terrain && _.style.map.terrain.getTerrainData(Ze);
            let si, Wr, Ri, Zr, Gi = [0, 0], Si = null;
            if (g) Wr = He.glyphAtlasTexture, Ri = re.LINEAR, si = He.glyphAtlasTexture.size, Je.iconsInText && (Gi = He.imageAtlasTexture.size, Si = He.imageAtlasTexture, Zr = Yt || _.options.rotating || _.options.zooming || Gt.kind === "composite" || Gt.kind === "camera" ? re.LINEAR : re.NEAREST);
            else {
              const li = a.layout.get("icon-size").constantOr(0) !== 1 || Je.iconsNeedLinear;
              Wr = He.imageAtlasTexture, Ri = _t || _.options.rotating || _.options.zooming || li || Yt ? re.LINEAR : re.NEAREST, si = He.imageAtlasTexture.size;
            }
            const Ai = s.aH(He, 1, _.transform.zoom), pn = hr(fe, _.transform, Ai), Go = s.M();
            s.av(Go, pn);
            const Sa = ur(me, fe, _.transform, Ai), Jo = s.aI(de, He, b, w), Qo = de.getProjectionData({ overscaledTileID: Ze, applyGlobeMatrix: !U, applyTerrainMatrix: true }), lo = Se && Je.hasTextData(), Ka = a.layout.get("icon-text-fit") !== "none" && lo && Je.hasIconData();
            if (Ce) {
              const li = _.style.map.terrain ? (ki, ui) => _.style.map.terrain.getElevation(Ze, ki, ui) : null, ii = a.layout.get("text-rotation-alignment") === "map";
              Sn(Je, _, g, pn, Go, me, R, ii, Ze.toUnwrapped(), de.width, de.height, Jo, li);
            }
            const Ja = g && Se || Ka, Xn = Ce || Ja ? gf : me ? pn : _.transform.clipSpaceToPixelsMatrix, ka = _t && a.paint.get(g ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let ea;
            ea = _t ? Je.iconsInText ? id(Gt.kind, ri, Pe, me, Ce, Ja, _, Xn, Sa, Jo, si, Gi, Ke) : Uo(Gt.kind, ri, Pe, me, Ce, Ja, _, Xn, Sa, Jo, g, si, 0, Ke) : ll(Gt.kind, ri, Pe, me, Ce, Ja, _, Xn, Sa, Jo, g, si, Ke);
            const ta = { program: Br, buffers: Tt, uniformValues: ea, projectionData: Qo, atlasTexture: Wr, atlasTextureIcon: Si, atlasInterpolation: Ri, atlasInterpolationIcon: Zr, isSDF: _t, hasHalo: ka };
            if (xe && Je.canOverlap) {
              Ie = true;
              const li = Tt.segments.get();
              for (const ii of li) Ne.push({ segments: new s.aR([ii]), sortKey: ii.sortKey, state: ta, terrainData: Yr });
            } else Ne.push({ segments: Tt.segments, sortKey: 0, state: ta, terrainData: Yr });
          }
          Ie && Ne.sort(((Ze, He) => Ze.sortKey - He.sortKey));
          for (const Ze of Ne) {
            const He = Ze.state;
            if (X.activeTexture.set(re.TEXTURE0), He.atlasTexture.bind(He.atlasInterpolation, re.CLAMP_TO_EDGE), He.atlasTextureIcon && (X.activeTexture.set(re.TEXTURE1), He.atlasTextureIcon && He.atlasTextureIcon.bind(He.atlasInterpolationIcon, re.CLAMP_TO_EDGE)), He.isSDF) {
              const Je = He.uniformValues;
              He.hasHalo && (Je.u_is_halo = 1, vf(He.buffers, Ze.segments, a, _, He.program, De, z, W, Je, He.projectionData, Ze.terrainData)), Je.u_is_halo = 0;
            }
            vf(He.buffers, Ze.segments, a, _, He.program, De, z, W, He.uniformValues, He.projectionData, Ze.terrainData);
          }
        }
        function vf(_, t, a, d, g, b, w, T, I, R, z) {
          const W = d.context;
          g.draw(W, W.gl.TRIANGLES, b, w, T, Ar.backCCW, I, z, R, a.id, _.layoutVertexBuffer, _.indexBuffer, t, a.paint, d.transform.zoom, _.programConfigurations.get(a.id), _.dynamicLayoutVertexBuffer, _.opacityVertexBuffer);
        }
        function hl(_, t, a, d, g) {
          const b = _.context, w = b.gl, T = Mr.disabled, I = new ti([w.ONE, w.ONE], s.bj.transparent, [true, true, true, true]), R = t.getBucket(a);
          if (!R) return;
          const z = d.key;
          let W = a.heatmapFbos.get(z);
          W || (W = fd(b, t.tileSize, t.tileSize), a.heatmapFbos.set(z, W)), b.bindFramebuffer.set(W.framebuffer), b.viewport.set([0, 0, t.tileSize, t.tileSize]), b.clear({ color: s.bj.transparent });
          const U = R.programConfigurations.get(a.id), X = _.useProgram("heatmap", U, !g), re = _.transform.getProjectionData({ overscaledTileID: t.tileID, applyGlobeMatrix: true, applyTerrainMatrix: true }), de = _.style.map.terrain.getTerrainData(d);
          X.draw(b, w.TRIANGLES, gr.disabled, T, I, Ar.disabled, Qc(t, _.transform.zoom, a.paint.get("heatmap-intensity"), 1), de, re, a.id, R.layoutVertexBuffer, R.indexBuffer, R.segments, a.paint, _.transform.zoom, U);
        }
        function Lm(_, t, a, d, g) {
          const b = _.context, w = b.gl, T = _.transform;
          b.setColorMode(_.colorModeForRenderPass());
          const I = fl(b, t), R = a.key, z = t.heatmapFbos.get(R);
          if (!z) return;
          b.activeTexture.set(w.TEXTURE0), w.bindTexture(w.TEXTURE_2D, z.colorAttachment.get()), b.activeTexture.set(w.TEXTURE1), I.bind(w.LINEAR, w.CLAMP_TO_EDGE);
          const W = T.getProjectionData({ overscaledTileID: a, applyTerrainMatrix: g, applyGlobeMatrix: !d });
          _.useProgram("heatmapTexture").draw(b, w.TRIANGLES, gr.disabled, Mr.disabled, _.colorModeForRenderPass(), Ar.disabled, ed(_, t, 0, 1), null, W, t.id, _.rasterBoundsBuffer, _.quadTriangleIndexBuffer, _.rasterBoundsSegments, t.paint, T.zoom), z.destroy(), t.heatmapFbos.delete(R);
        }
        function fd(_, t, a) {
          var d, g;
          const b = _.gl, w = b.createTexture();
          b.bindTexture(b.TEXTURE_2D, w), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.LINEAR);
          const T = (d = _.HALF_FLOAT) !== null && d !== void 0 ? d : b.UNSIGNED_BYTE, I = (g = _.RGBA16F) !== null && g !== void 0 ? g : b.RGBA;
          b.texImage2D(b.TEXTURE_2D, 0, I, t, a, 0, b.RGBA, T, null);
          const R = _.createFramebuffer(t, a, false, false);
          return R.colorAttachment.set(w), R;
        }
        function fl(_, t) {
          return t.colorRampTexture || (t.colorRampTexture = new s.T(_, t.colorRamp, _.gl.RGBA)), t.colorRampTexture;
        }
        function Fu(_, t, a, d, g, b, w, T) {
          let I = 256;
          if (g.stepInterpolant) {
            const R = t.getSource().maxzoom, z = w.canonical.z === R ? Math.ceil(1 << _.transform.maxZoom - w.canonical.z) : 1;
            I = s.ai(s.c8(b.maxLineLength / s.a3 * 1024 * z), 256, a.maxTextureSize);
          }
          return T.gradient = s.c9({ expression: g.gradientExpression(), evaluationKey: "lineProgress", resolution: I, image: T.gradient || void 0, clips: b.lineClipsArray }), T.texture ? T.texture.update(T.gradient) : T.texture = new s.T(a, T.gradient, d.RGBA), T.version = g.gradientVersion, T.texture;
        }
        function yf(_, t, a, d, g) {
          _.activeTexture.set(t.TEXTURE0), a.imageAtlasTexture.bind(t.LINEAR, t.CLAMP_TO_EDGE), d.updatePaintBuffers(g);
        }
        function _f(_, t, a, d, g, b) {
          (g || _.lineAtlas.dirty) && (t.activeTexture.set(a.TEXTURE0), _.lineAtlas.bind(t)), d.updatePaintBuffers(b);
        }
        function Lu(_, t, a, d, g, b, w) {
          const T = b.gradients[g.id];
          let I = T.texture;
          g.gradientVersion !== T.version && (I = Fu(_, t, a, d, g, b, w, T)), a.activeTexture.set(d.TEXTURE0), I.bind(g.stepInterpolant ? d.NEAREST : d.LINEAR, d.CLAMP_TO_EDGE);
        }
        function pd(_, t, a, d, g, b, w, T, I) {
          const R = b.gradients[g.id];
          let z = R.texture;
          g.gradientVersion !== R.version && (z = Fu(_, t, a, d, g, b, w, R)), a.activeTexture.set(d.TEXTURE0), z.bind(g.stepInterpolant ? d.NEAREST : d.LINEAR, d.CLAMP_TO_EDGE), a.activeTexture.set(d.TEXTURE1), _.lineAtlas.bind(a), T.updatePaintBuffers(I);
        }
        function bf(_, t, a, d, g) {
          if (!a || !d || !d.imageAtlas) return;
          const b = d.imageAtlas.patternPositions;
          let w = b[a.to.toString()], T = b[a.from.toString()];
          if (!w && T && (w = T), !T && w && (T = w), !w || !T) {
            const I = g.getPaintProperty(t);
            w = b[I], T = b[I];
          }
          w && T && _.setConstantPatternPositions(w, T);
        }
        function md(_, t, a, d, g, b, w, T) {
          const I = _.context.gl, R = "fill-pattern", z = a.paint.get(R), W = z && z.constantOr(1), U = a.getCrossfadeParameters();
          let X, re, de, fe, me;
          const Ce = _.transform, Pe = a.paint.get("fill-translate"), xe = a.paint.get("fill-translate-anchor");
          w ? (re = W && !a.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", X = I.LINES) : (re = W ? "fillPattern" : "fill", X = I.TRIANGLES);
          const Ie = z.constantOr(null);
          for (const De of d) {
            const Se = t.getTile(De);
            if (W && !Se.patternsLoaded()) continue;
            const Ne = Se.getBucket(a);
            if (!Ne) continue;
            const Ke = Ne.programConfigurations.get(a.id), Ze = _.useProgram(re, Ke), He = _.style.map.terrain && _.style.map.terrain.getTerrainData(De);
            W && (_.context.activeTexture.set(I.TEXTURE0), Se.imageAtlasTexture.bind(I.LINEAR, I.CLAMP_TO_EDGE), Ke.updatePaintBuffers(U)), bf(Ke, R, Ie, Se, a);
            const Je = Ce.getProjectionData({ overscaledTileID: De, applyGlobeMatrix: !T, applyTerrainMatrix: true }), Tt = s.aI(Ce, Se, Pe, xe);
            if (w) {
              fe = Ne.indexBuffer2, me = Ne.segments2;
              const _t = [I.drawingBufferWidth, I.drawingBufferHeight];
              de = re === "fillOutlinePattern" && W ? Tm(_, U, Se, _t, Tt) : ef(_t, Tt);
            } else fe = Ne.indexBuffer, me = Ne.segments, de = W ? Qh(_, U, Se, Tt) : { u_fill_translate: Tt };
            const It = _.stencilModeForClipping(De);
            Ze.draw(_.context, X, g, It, b, Ar.backCCW, de, He, Je, a.id, Ne.layoutVertexBuffer, fe, me, a.paint, _.transform.zoom, Ke);
          }
        }
        function fi(_, t, a, d, g, b, w, T) {
          const I = _.context, R = I.gl, z = "fill-extrusion-pattern", W = a.paint.get(z), U = W.constantOr(1), X = a.getCrossfadeParameters(), re = a.paint.get("fill-extrusion-opacity"), de = W.constantOr(null), fe = _.transform;
          for (const me of d) {
            const Ce = t.getTile(me), Pe = Ce.getBucket(a);
            if (!Pe) continue;
            const xe = _.style.map.terrain && _.style.map.terrain.getTerrainData(me), Ie = Pe.programConfigurations.get(a.id), De = _.useProgram(U ? "fillExtrusionPattern" : "fillExtrusion", Ie);
            U && (_.context.activeTexture.set(R.TEXTURE0), Ce.imageAtlasTexture.bind(R.LINEAR, R.CLAMP_TO_EDGE), Ie.updatePaintBuffers(X));
            const Se = fe.getProjectionData({ overscaledTileID: me, applyGlobeMatrix: !T, applyTerrainMatrix: true });
            bf(Ie, z, de, Ce, a);
            const Ne = s.aI(fe, Ce, a.paint.get("fill-extrusion-translate"), a.paint.get("fill-extrusion-translate-anchor")), Ke = a.paint.get("fill-extrusion-vertical-gradient"), Ze = U ? _s(_, Ke, re, Ne, me, X, Ce) : Jh(_, Ke, re, Ne);
            De.draw(I, I.gl.TRIANGLES, g, b, w, Ar.backCCW, Ze, xe, Se, a.id, Pe.layoutVertexBuffer, Pe.indexBuffer, Pe.segments, a.paint, _.transform.zoom, Ie, _.style.map.terrain && Pe.centroidVertexBuffer);
          }
        }
        function Xo(_, t, a, d, g, b, w, T, I) {
          var R;
          const z = _.style.projection, W = _.context, U = _.transform, X = W.gl, re = [`#define NUM_ILLUMINATION_SOURCES ${a.paint.get("hillshade-highlight-color").values.length}`], de = _.useProgram("hillshade", null, false, re), fe = !_.options.moving;
          for (const me of d) {
            const Ce = t.getTile(me), Pe = Ce.fbo;
            if (!Pe) continue;
            const xe = z.getMeshFromTileID(W, me.canonical, T, true, "raster"), Ie = (R = _.style.map.terrain) === null || R === void 0 ? void 0 : R.getTerrainData(me);
            W.activeTexture.set(X.TEXTURE0), X.bindTexture(X.TEXTURE_2D, Pe.colorAttachment.get());
            const De = U.getProjectionData({ overscaledTileID: me, aligned: fe, applyGlobeMatrix: !I, applyTerrainMatrix: true });
            de.draw(W, X.TRIANGLES, b, g[me.overscaledZ], w, Ar.backCCW, Ua(_, Ce, a), Ie, De, a.id, xe.vertexBuffer, xe.indexBuffer, xe.segments);
          }
        }
        function Nn(_, t, a, d, g, b, w, T, I) {
          var R;
          const z = _.style.projection, W = _.context, U = _.transform, X = W.gl, re = _.useProgram("colorRelief"), de = !_.options.moving;
          let fe = true, me = 0;
          for (const Ce of d) {
            const Pe = t.getTile(Ce), xe = Pe.dem;
            if (fe) {
              const Ze = X.getParameter(X.MAX_TEXTURE_SIZE), { elevationTexture: He, colorTexture: Je } = a.getColorRampTextures(W, Ze, xe.getUnpackVector());
              W.activeTexture.set(X.TEXTURE1), He.bind(X.NEAREST, X.CLAMP_TO_EDGE), W.activeTexture.set(X.TEXTURE4), Je.bind(X.LINEAR, X.CLAMP_TO_EDGE), fe = false, me = He.size[0];
            }
            if (!xe || !xe.data) continue;
            const Ie = xe.stride, De = xe.getPixels();
            if (W.activeTexture.set(X.TEXTURE0), W.pixelStoreUnpackPremultiplyAlpha.set(false), Pe.demTexture = Pe.demTexture || _.getTileTexture(Ie), Pe.demTexture) {
              const Ze = Pe.demTexture;
              Ze.update(De, { premultiply: false }), Ze.bind(X.LINEAR, X.CLAMP_TO_EDGE);
            } else Pe.demTexture = new s.T(W, De, X.RGBA, { premultiply: false }), Pe.demTexture.bind(X.LINEAR, X.CLAMP_TO_EDGE);
            const Se = z.getMeshFromTileID(W, Ce.canonical, T, true, "raster"), Ne = (R = _.style.map.terrain) === null || R === void 0 ? void 0 : R.getTerrainData(Ce), Ke = U.getProjectionData({ overscaledTileID: Ce, aligned: de, applyGlobeMatrix: !I, applyTerrainMatrix: true });
            re.draw(W, X.TRIANGLES, b, g[Ce.overscaledZ], w, Ar.backCCW, al(a, Pe.dem, me), Ne, Ke, a.id, Se.vertexBuffer, Se.indexBuffer, Se.segments);
          }
        }
        const pl = [new s.P(0, 0), new s.P(s.a3, 0), new s.P(s.a3, s.a3), new s.P(0, s.a3)];
        function Ha(_, t, a, d, g, b, w, T, I = false, R = false) {
          const z = d[d.length - 1].overscaledZ, W = _.context, U = W.gl, X = _.useProgram("raster"), re = _.transform, de = _.style.projection, fe = _.colorModeForRenderPass(), me = !_.options.moving, Ce = a.paint.get("raster-opacity"), Pe = a.paint.get("raster-resampling"), xe = a.paint.get("raster-fade-duration"), Ie = !!_.style.map.terrain;
          for (const De of d) {
            const Se = _.getDepthModeForSublayer(De.overscaledZ - z, Ce === 1 ? gr.ReadWrite : gr.ReadOnly, U.LESS), Ne = t.getTile(De), Ke = Pe === "nearest" ? U.NEAREST : U.LINEAR;
            W.activeTexture.set(U.TEXTURE0), Ne.texture.bind(Ke, U.CLAMP_TO_EDGE, U.LINEAR_MIPMAP_NEAREST), W.activeTexture.set(U.TEXTURE1);
            const { parentTile: Ze, parentScaleBy: He, parentTopLeft: Je, fadeValues: Tt } = xf(Ne, t, xe, Ie);
            Ne.fadeOpacity = Tt.tileOpacity, Ze ? (Ze.fadeOpacity = Tt.parentTileOpacity, Ze.texture.bind(Ke, U.CLAMP_TO_EDGE, U.LINEAR_MIPMAP_NEAREST)) : Ne.texture.bind(Ke, U.CLAMP_TO_EDGE, U.LINEAR_MIPMAP_NEAREST), Ne.texture.useMipmap && W.extTextureFilterAnisotropic && _.transform.pitch > 20 && U.texParameterf(U.TEXTURE_2D, W.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, W.extTextureFilterAnisotropicMax);
            const It = _.style.map.terrain && _.style.map.terrain.getTerrainData(De), _t = re.getProjectionData({ overscaledTileID: De, aligned: me, applyGlobeMatrix: !R, applyTerrainMatrix: true }), Gt = rd(Je, He, Tt.fadeMix, a, T), Yt = de.getMeshFromTileID(W, De.canonical, b, w, "raster");
            X.draw(W, U.TRIANGLES, Se, g ? g[De.overscaledZ] : Mr.disabled, fe, I ? Ar.frontCCW : Ar.backCCW, Gt, It, _t, a.id, Yt.vertexBuffer, Yt.indexBuffer, Yt.segments);
          }
        }
        function xf(_, t, a, d) {
          const g = { parentTile: null, parentScaleBy: 1, parentTopLeft: [0, 0], fadeValues: { tileOpacity: 1, parentTileOpacity: 1, fadeMix: { opacity: 1, mix: 0 } } };
          if (a === 0 || d) return g;
          if (_.fadingParentID) {
            const b = t.getLoadedTile(_.fadingParentID);
            if (!b) return g;
            const w = Math.pow(2, b.tileID.overscaledZ - _.tileID.overscaledZ), T = [_.tileID.canonical.x * w % 1, _.tileID.canonical.y * w % 1], I = (function(R, z, W) {
              const U = q(), X = (U - z.timeAdded) / W, re = R.fadingDirection === Me.Incoming, de = s.ai((U - R.timeAdded) / W, 0, 1), fe = s.ai(1 - X, 0, 1), me = re ? de : fe;
              return { tileOpacity: me, parentTileOpacity: re ? fe : de, fadeMix: { opacity: 1, mix: 1 - me } };
            })(_, b, a);
            return { parentTile: b, parentScaleBy: w, parentTopLeft: T, fadeValues: I };
          }
          if (_.selfFading) {
            const b = (function(w, T) {
              const I = (q() - w.timeAdded) / T, R = s.ai(I, 0, 1);
              return { tileOpacity: R, fadeMix: { opacity: R, mix: 0 } };
            })(_, a);
            return { parentTile: null, parentScaleBy: 1, parentTopLeft: [0, 0], fadeValues: b };
          }
          return g;
        }
        const Ss = new s.bj(1, 0, 0, 1), gd = new s.bj(0, 1, 0, 1), ml = new s.bj(0, 0, 1, 1), vd = new s.bj(1, 0, 1, 1), wf = new s.bj(0, 1, 1, 1);
        function yd(_, t, a, d) {
          gl(_, 0, t + a / 2, _.transform.width, a, d);
        }
        function _d(_, t, a, d) {
          gl(_, t - a / 2, 0, a, _.transform.height, d);
        }
        function gl(_, t, a, d, g, b) {
          const w = _.context, T = w.gl;
          T.enable(T.SCISSOR_TEST), T.scissor(t * _.pixelRatio, a * _.pixelRatio, d * _.pixelRatio, g * _.pixelRatio), w.clear({ color: b }), T.disable(T.SCISSOR_TEST);
        }
        function Cf(_, t, a) {
          const d = _.context, g = d.gl, b = _.useProgram("debug"), w = gr.disabled, T = Mr.disabled, I = _.colorModeForRenderPass(), R = "$debug", z = _.style.map.terrain && _.style.map.terrain.getTerrainData(a);
          d.activeTexture.set(g.TEXTURE0);
          const W = t.getTileByID(a.key).latestRawTileData, U = Math.floor((W && W.byteLength || 0) / 1024), X = t.getTile(a).tileSize, re = 512 / Math.min(X, 512) * (a.overscaledZ / _.transform.zoom) * 0.5;
          let de = a.canonical.toString();
          a.overscaledZ !== a.canonical.z && (de += ` => ${a.overscaledZ}`), (function(me, Ce) {
            me.initDebugOverlayCanvas();
            const Pe = me.debugOverlayCanvas, xe = me.context.gl, Ie = me.debugOverlayCanvas.getContext("2d");
            Ie.clearRect(0, 0, Pe.width, Pe.height), Ie.shadowColor = "white", Ie.shadowBlur = 2, Ie.lineWidth = 1.5, Ie.strokeStyle = "white", Ie.textBaseline = "top", Ie.font = "bold 36px Open Sans, sans-serif", Ie.fillText(Ce, 5, 5), Ie.strokeText(Ce, 5, 5), me.debugOverlayTexture.update(Pe), me.debugOverlayTexture.bind(xe.LINEAR, xe.CLAMP_TO_EDGE);
          })(_, `${de} ${U}kB`);
          const fe = _.transform.getProjectionData({ overscaledTileID: a, applyGlobeMatrix: true, applyTerrainMatrix: true });
          b.draw(d, g.TRIANGLES, w, T, ti.alphaBlended, Ar.disabled, Jc(s.bj.transparent, re), null, fe, R, _.debugBuffer, _.quadTriangleIndexBuffer, _.debugSegments), b.draw(d, g.LINE_STRIP, w, T, I, Ar.disabled, Jc(s.bj.red), z, fe, R, _.debugBuffer, _.tileBorderIndexBuffer, _.debugSegments);
        }
        function wa(_, t, a, d) {
          const { isRenderingGlobe: g } = d, b = _.context, w = b.gl, T = _.transform, I = _.colorModeForRenderPass(), R = _.getDepthModeFor3D(), z = _.useProgram("terrain");
          b.bindFramebuffer.set(null), b.viewport.set([0, 0, _.width, _.height]);
          for (const W of a) {
            const U = t.getTerrainMesh(W.tileID), X = _.renderToTexture.getTexture(W), re = t.getTerrainData(W.tileID);
            b.activeTexture.set(w.TEXTURE0), w.bindTexture(w.TEXTURE_2D, X.texture);
            const de = t.getMeshFrameDelta(T.zoom), fe = T.calculateFogMatrix(W.tileID.toUnwrapped()), me = Yc(de, fe, _.style.sky, T.pitch, g), Ce = T.getProjectionData({ overscaledTileID: W.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
            z.draw(b, w.TRIANGLES, R, Mr.disabled, I, Ar.backCCW, me, re, Ce, "terrain", U.vertexBuffer, U.indexBuffer, U.segments);
          }
        }
        function bd(_, t) {
          if (!t.mesh) {
            const a = new s.aQ();
            a.emplaceBack(-1, -1), a.emplaceBack(1, -1), a.emplaceBack(1, 1), a.emplaceBack(-1, 1);
            const d = new s.aS();
            d.emplaceBack(0, 1, 2), d.emplaceBack(0, 2, 3), t.mesh = new ya(_.createVertexBuffer(a, Mi.members), _.createIndexBuffer(d), s.aR.simpleSegment(0, 0, a.length, d.length));
          }
          return t.mesh;
        }
        class Sf {
          constructor(t, a) {
            this.context = new Eu(t), this.transform = a, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: s.am(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = mr.maxUnderzooming + mr.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Ho();
          }
          resize(t, a, d) {
            if (this.width = Math.floor(t * d), this.height = Math.floor(a * d), this.pixelRatio = d, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const g of this.style._order) this.style._layers[g].resize();
          }
          setup() {
            const t = this.context, a = new s.aQ();
            a.emplaceBack(0, 0), a.emplaceBack(s.a3, 0), a.emplaceBack(0, s.a3), a.emplaceBack(s.a3, s.a3), this.tileExtentBuffer = t.createVertexBuffer(a, Mi.members), this.tileExtentSegments = s.aR.simpleSegment(0, 0, 4, 2);
            const d = new s.aQ();
            d.emplaceBack(0, 0), d.emplaceBack(s.a3, 0), d.emplaceBack(0, s.a3), d.emplaceBack(s.a3, s.a3), this.debugBuffer = t.createVertexBuffer(d, Mi.members), this.debugSegments = s.aR.simpleSegment(0, 0, 4, 5);
            const g = new s.cb();
            g.emplaceBack(0, 0, 0, 0), g.emplaceBack(s.a3, 0, s.a3, 0), g.emplaceBack(0, s.a3, 0, s.a3), g.emplaceBack(s.a3, s.a3, s.a3, s.a3), this.rasterBoundsBuffer = t.createVertexBuffer(g, Vo.members), this.rasterBoundsSegments = s.aR.simpleSegment(0, 0, 4, 2);
            const b = new s.aQ();
            b.emplaceBack(0, 0), b.emplaceBack(s.a3, 0), b.emplaceBack(0, s.a3), b.emplaceBack(s.a3, s.a3), this.rasterBoundsBufferPosOnly = t.createVertexBuffer(b, Mi.members), this.rasterBoundsSegmentsPosOnly = s.aR.simpleSegment(0, 0, 4, 5);
            const w = new s.aQ();
            w.emplaceBack(0, 0), w.emplaceBack(1, 0), w.emplaceBack(0, 1), w.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(w, Mi.members), this.viewportSegments = s.aR.simpleSegment(0, 0, 4, 2);
            const T = new s.cc();
            T.emplaceBack(0), T.emplaceBack(1), T.emplaceBack(3), T.emplaceBack(2), T.emplaceBack(0), this.tileBorderIndexBuffer = t.createIndexBuffer(T);
            const I = new s.aS();
            I.emplaceBack(1, 0, 2), I.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(I);
            const R = this.context.gl;
            this.stencilClearMode = new Mr({ func: R.ALWAYS, mask: 0 }, 0, 255, R.ZERO, R.ZERO, R.ZERO), this.tileExtentMesh = new ya(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
          clearStencil() {
            const t = this.context, a = t.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const d = s.M();
            s.c1(d, 0, this.width, this.height, 0, 0, 1), s.O(d, d, [a.drawingBufferWidth, a.drawingBufferHeight, 0]);
            const g = { mainMatrix: d, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: d };
            this.useProgram("clippingMask", null, true).draw(t, a.TRIANGLES, gr.disabled, this.stencilClearMode, ti.disabled, Ar.disabled, null, null, g, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(t, a, d) {
            if (this.currentStencilSource === t.source || !t.isTileClipped() || !a || !a.length) return;
            this.currentStencilSource = t.source, this.nextStencilID + a.length > 256 && this.clearStencil();
            const g = this.context;
            g.setColorMode(ti.disabled), g.setDepthMode(gr.disabled);
            const b = {};
            for (const w of a) b[w.key] = this.nextStencilID++;
            this._renderTileMasks(b, a, d, true), this._renderTileMasks(b, a, d, false), this._tileClippingMaskIDs = b;
          }
          _renderTileMasks(t, a, d, g) {
            const b = this.context, w = b.gl, T = this.style.projection, I = this.transform, R = this.useProgram("clippingMask");
            for (const z of a) {
              const W = t[z.key], U = this.style.map.terrain && this.style.map.terrain.getTerrainData(z), X = T.getMeshFromTileID(this.context, z.canonical, g, true, "stencil"), re = I.getProjectionData({ overscaledTileID: z, applyGlobeMatrix: !d, applyTerrainMatrix: true });
              R.draw(b, w.TRIANGLES, gr.disabled, new Mr({ func: w.ALWAYS, mask: 0 }, W, 255, w.KEEP, w.KEEP, w.REPLACE), ti.disabled, d ? Ar.disabled : Ar.backCCW, null, U, re, "$clipping", X.vertexBuffer, X.indexBuffer, X.segments);
            }
          }
          _renderTilesDepthBuffer() {
            const t = this.context, a = t.gl, d = this.style.projection, g = this.transform, b = this.useProgram("depth"), w = this.getDepthModeFor3D(), T = sr(g, { tileSize: g.tileSize });
            for (const I of T) {
              const R = this.style.map.terrain && this.style.map.terrain.getTerrainData(I), z = d.getMeshFromTileID(this.context, I.canonical, true, true, "raster"), W = g.getProjectionData({ overscaledTileID: I, applyGlobeMatrix: true, applyTerrainMatrix: true });
              b.draw(t, a.TRIANGLES, w, Mr.disabled, ti.disabled, Ar.backCCW, null, R, W, "$clipping", z.vertexBuffer, z.indexBuffer, z.segments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const t = this.nextStencilID++, a = this.context.gl;
            return new Mr({ func: a.NOTEQUAL, mask: 255 }, t, 255, a.KEEP, a.KEEP, a.REPLACE);
          }
          stencilModeForClipping(t) {
            const a = this.context.gl;
            return new Mr({ func: a.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t.key], 0, a.KEEP, a.KEEP, a.REPLACE);
          }
          getStencilConfigForOverlapAndUpdateStencilID(t) {
            const a = this.context.gl, d = t.sort(((w, T) => T.overscaledZ - w.overscaledZ)), g = d[d.length - 1].overscaledZ, b = d[0].overscaledZ - g + 1;
            if (b > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + b > 256 && this.clearStencil();
              const w = {};
              for (let T = 0; T < b; T++) w[T + g] = new Mr({ func: a.GEQUAL, mask: 255 }, T + this.nextStencilID, 255, a.KEEP, a.KEEP, a.REPLACE);
              return this.nextStencilID += b, [w, d];
            }
            return [{ [g]: Mr.disabled }, d];
          }
          stencilConfigForOverlapTwoPass(t) {
            const a = this.context.gl, d = t.sort(((w, T) => T.overscaledZ - w.overscaledZ)), g = d[d.length - 1].overscaledZ, b = d[0].overscaledZ - g + 1;
            if (this.clearStencil(), b > 1) {
              const w = {}, T = {};
              for (let I = 0; I < b; I++) w[I + g] = new Mr({ func: a.GREATER, mask: 255 }, b + 1 + I, 255, a.KEEP, a.KEEP, a.REPLACE), T[I + g] = new Mr({ func: a.GREATER, mask: 255 }, 1 + I, 255, a.KEEP, a.KEEP, a.REPLACE);
              return this.nextStencilID = 2 * b + 1, [w, T, d];
            }
            return this.nextStencilID = 3, [{ [g]: new Mr({ func: a.GREATER, mask: 255 }, 2, 255, a.KEEP, a.KEEP, a.REPLACE) }, { [g]: new Mr({ func: a.GREATER, mask: 255 }, 1, 255, a.KEEP, a.KEEP, a.REPLACE) }, d];
          }
          colorModeForRenderPass() {
            const t = this.context.gl;
            return this._showOverdrawInspector ? new ti([t.CONSTANT_COLOR, t.ONE], new s.bj(0.125, 0.125, 0.125, 0), [true, true, true, true]) : this.renderPass === "opaque" ? ti.unblended : ti.alphaBlended;
          }
          getDepthModeForSublayer(t, a, d) {
            if (!this.opaquePassEnabledForLayer()) return gr.disabled;
            const g = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;
            return new gr(d || this.context.gl.LEQUAL, a, [g, g]);
          }
          getDepthModeFor3D() {
            return new gr(this.context.gl.LEQUAL, gr.ReadWrite, this.depthRangeFor3D);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(t, a) {
            var d, g;
            this.style = t, this.options = a, this.lineAtlas = t.lineAtlas, this.imageManager = t.imageManager, this.glyphManager = t.glyphManager, this.symbolFadeChange = t.placement.symbolFadeChange(q()), this.imageManager.beginFrame();
            const b = this.style._order, w = this.style.tileManagers, T = {}, I = {}, R = {}, z = { isRenderingToTexture: false, isRenderingGlobe: ((d = t.projection) === null || d === void 0 ? void 0 : d.transitionState) > 0 };
            for (const U in w) {
              const X = w[U];
              X.used && X.prepare(this.context), T[U] = X.getVisibleCoordinates(false), I[U] = T[U].slice().reverse(), R[U] = X.getVisibleCoordinates(true).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let U = 0; U < b.length; U++) if (this.style._layers[b[U]].is3D()) {
              this.opaquePassCutoff = U;
              break;
            }
            this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const U of b) {
              const X = this.style._layers[U];
              if (!X.hasOffscreenPass() || X.isHidden(this.transform.zoom)) continue;
              const re = I[X.source];
              (X.type === "custom" || re.length) && this.renderLayer(this, w[X.source], X, re, z);
            }
            if ((g = this.style.projection) === null || g === void 0 || g.updateGPUdependent({ context: this.context, useProgram: (U) => this.useProgram(U) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: a.showOverdrawInspector ? s.bj.black : s.bj.transparent, depth: 1 }), this.clearStencil(), this.style.sky && (function(U, X) {
              const re = U.context, de = re.gl, fe = ((De, Se, Ne) => {
                const Ke = Math.cos(Se.rollInRadians), Ze = Math.sin(Se.rollInRadians), He = Re(Se), Je = Se.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }).projectionTransition;
                return { u_sky_color: De.properties.get("sky-color"), u_horizon_color: De.properties.get("horizon-color"), u_horizon: [(Se.width / 2 - He * Ze) * Ne, (Se.height / 2 + He * Ke) * Ne], u_horizon_normal: [-Ze, Ke], u_sky_horizon_blend: De.properties.get("sky-horizon-blend") * Se.height / 2 * Ne, u_sky_blend: Je };
              })(X, U.style.map.transform, U.pixelRatio), me = new gr(de.LEQUAL, gr.ReadWrite, [0, 1]), Ce = Mr.disabled, Pe = U.colorModeForRenderPass(), xe = U.useProgram("sky"), Ie = bd(re, X);
              xe.draw(re, de.TRIANGLES, me, Ce, Pe, Ar.disabled, fe, null, void 0, "sky", Ie.vertexBuffer, Ie.indexBuffer, Ie.segments);
            })(this, this.style.sky), this._showOverdrawInspector = a.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (t._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = b.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const U = this.style._layers[b[this.currentLayer]], X = w[U.source], re = T[U.source];
              this._renderTileClippingMasks(U, re, false), this.renderLayer(this, X, U, re, z);
            }
            this.renderPass = "translucent";
            let W = false;
            for (this.currentLayer = 0; this.currentLayer < b.length; this.currentLayer++) {
              const U = this.style._layers[b[this.currentLayer]], X = w[U.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(U, z)) continue;
              this.opaquePassEnabledForLayer() || W || (W = true, z.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const re = (U.type === "symbol" ? R : I)[U.source];
              this._renderTileClippingMasks(U, T[U.source], !!this.renderToTexture), this.renderLayer(this, X, U, re, z);
            }
            if (z.isRenderingGlobe && (function(U, X, re) {
              const de = U.context, fe = de.gl, me = U.useProgram("atmosphere"), Ce = new gr(fe.LEQUAL, gr.ReadOnly, [0, 1]), Pe = U.transform, xe = (function(Je, Tt) {
                const It = Je.properties.get("position"), _t = [-It.x, -It.y, -It.z], Gt = s.am(new Float64Array(16));
                return Je.properties.get("anchor") === "map" && (s.ba(Gt, Gt, Tt.rollInRadians), s.bb(Gt, Gt, -Tt.pitchInRadians), s.ba(Gt, Gt, Tt.bearingInRadians), s.bb(Gt, Gt, Tt.center.lat * Math.PI / 180), s.bD(Gt, Gt, -Tt.center.lng * Math.PI / 180)), s.ca(_t, _t, Gt), _t;
              })(re, U.transform), Ie = Pe.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }), De = X.properties.get("atmosphere-blend") * Ie.projectionTransition;
              if (De === 0) return;
              const Se = fu(Pe.worldSize, Pe.center.lat), Ne = Pe.inverseProjectionMatrix, Ke = new Float64Array(4);
              Ke[3] = 1, s.aB(Ke, Ke, Pe.modelViewProjectionMatrix), Ke[0] /= Ke[3], Ke[1] /= Ke[3], Ke[2] /= Ke[3], Ke[3] = 1, s.aB(Ke, Ke, Ne), Ke[0] /= Ke[3], Ke[1] /= Ke[3], Ke[2] /= Ke[3], Ke[3] = 1;
              const Ze = /* @__PURE__ */ ((Je, Tt, It, _t, Gt) => ({ u_sun_pos: Je, u_atmosphere_blend: Tt, u_globe_position: It, u_globe_radius: _t, u_inv_proj_matrix: Gt }))(xe, De, [Ke[0], Ke[1], Ke[2]], Se, Ne), He = bd(de, X);
              me.draw(de, fe.TRIANGLES, Ce, Mr.disabled, ti.alphaBlended, Ar.disabled, Ze, null, null, "atmosphere", He.vertexBuffer, He.indexBuffer, He.segments);
            })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const U = (function(X, re) {
                let de = null;
                const fe = Object.values(X._layers).flatMap(((xe) => xe.source && !xe.isHidden(re) ? [X.tileManagers[xe.source]] : [])), me = fe.filter(((xe) => xe.getSource().type === "vector")), Ce = fe.filter(((xe) => xe.getSource().type !== "vector")), Pe = (xe) => {
                  (!de || de.getSource().maxzoom < xe.getSource().maxzoom) && (de = xe);
                };
                return me.forEach(((xe) => Pe(xe))), de || Ce.forEach(((xe) => Pe(xe))), de;
              })(this.style, this.transform.zoom);
              U && (function(X, re, de) {
                for (let fe = 0; fe < de.length; fe++) Cf(X, re, de[fe]);
              })(this, U, U.getVisibleCoordinates());
            }
            this.options.showPadding && (function(U) {
              const X = U.transform.padding;
              yd(U, U.transform.height - (X.top || 0), 3, Ss), yd(U, X.bottom || 0, 3, gd), _d(U, X.left || 0, 3, ml), _d(U, U.transform.width - (X.right || 0), 3, vd);
              const re = U.transform.centerPoint;
              (function(de, fe, me, Ce) {
                gl(de, fe - 1, me - 10, 2, 20, Ce), gl(de, fe - 10, me - 1, 20, 2, Ce);
              })(U, re.x, U.transform.height - re.y, wf);
            })(this), this.context.setDefault();
          }
          maybeDrawDepthAndCoords(t) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const a = this.terrainFacilitator.matrix, d = this.transform.modelViewProjectionMatrix;
            let g = this.terrainFacilitator.dirty;
            g || (g = t ? !s.cd(a, d) : !s.ce(a, d)), g || (g = this.style.map.terrain.tileManager.anyTilesAfterTime(this.terrainFacilitator.renderTime)), g && (s.cf(a, d), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, (function(b, w) {
              const T = b.context, I = T.gl, R = b.transform, z = ti.unblended, W = new gr(I.LEQUAL, gr.ReadWrite, [0, 1]), U = w.tileManager.getRenderableTiles(), X = b.useProgram("terrainDepth");
              T.bindFramebuffer.set(w.getFramebuffer("depth").framebuffer), T.viewport.set([0, 0, b.width / devicePixelRatio, b.height / devicePixelRatio]), T.clear({ color: s.bj.transparent, depth: 1 });
              for (const re of U) {
                const de = w.getTerrainMesh(re.tileID), fe = w.getTerrainData(re.tileID), me = R.getProjectionData({ overscaledTileID: re.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true }), Ce = { u_ele_delta: w.getMeshFrameDelta(R.zoom) };
                X.draw(T, I.TRIANGLES, W, Mr.disabled, z, Ar.backCCW, Ce, fe, me, "terrain", de.vertexBuffer, de.indexBuffer, de.segments);
              }
              T.bindFramebuffer.set(null), T.viewport.set([0, 0, b.width, b.height]);
            })(this, this.style.map.terrain), (function(b, w) {
              const T = b.context, I = T.gl, R = b.transform, z = ti.unblended, W = new gr(I.LEQUAL, gr.ReadWrite, [0, 1]), U = w.getCoordsTexture(), X = w.tileManager.getRenderableTiles(), re = b.useProgram("terrainCoords");
              T.bindFramebuffer.set(w.getFramebuffer("coords").framebuffer), T.viewport.set([0, 0, b.width / devicePixelRatio, b.height / devicePixelRatio]), T.clear({ color: s.bj.transparent, depth: 1 }), w.coordsIndex = [];
              for (const de of X) {
                const fe = w.getTerrainMesh(de.tileID), me = w.getTerrainData(de.tileID);
                T.activeTexture.set(I.TEXTURE0), I.bindTexture(I.TEXTURE_2D, U.texture);
                const Ce = { u_terrain_coords_id: (255 - w.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: w.getMeshFrameDelta(R.zoom) }, Pe = R.getProjectionData({ overscaledTileID: de.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
                re.draw(T, I.TRIANGLES, W, Mr.disabled, z, Ar.backCCW, Ce, me, Pe, "terrain", fe.vertexBuffer, fe.indexBuffer, fe.segments), w.coordsIndex.push(de.tileID.key);
              }
              T.bindFramebuffer.set(null), T.viewport.set([0, 0, b.width, b.height]);
            })(this, this.style.map.terrain));
          }
          renderLayer(t, a, d, g, b) {
            d.isHidden(this.transform.zoom) || (d.type === "background" || d.type === "custom" || (g || []).length) && (this.id = d.id, s.cg(d) ? (function(w, T, I, R, z, W) {
              if (w.renderPass !== "translucent") return;
              const { isRenderingToTexture: U } = W, X = Mr.disabled, re = w.colorModeForRenderPass();
              (I._unevaluatedLayout.hasValue("text-variable-anchor") || I._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(de, fe, me, Ce, Pe, xe, Ie, De, Se) {
                const Ne = fe.transform, Ke = fe.style.map.terrain, Ze = Pe === "map", He = xe === "map";
                for (const Je of de) {
                  const Tt = Ce.getTile(Je), It = Tt.getBucket(me);
                  if (!It || !It.text || !It.text.segments.get().length) continue;
                  const _t = s.as(It.textSizeData, Ne.zoom), Gt = s.aH(Tt, 1, fe.transform.zoom), Yt = hr(Ze, fe.transform, Gt), Br = me.layout.get("icon-text-fit") !== "none" && It.hasIconData();
                  if (_t) {
                    const ri = Math.pow(2, Ne.zoom - Tt.tileID.overscaledZ), Yr = Ke ? (si, Wr) => Ke.getElevation(Je, si, Wr) : null;
                    Au(It, Ze, He, Se, Ne, Yt, ri, _t, Br, s.aI(Ne, Tt, Ie, De), Je.toUnwrapped(), Yr);
                  }
                }
              })(R, w, I, T, I.layout.get("text-rotation-alignment"), I.layout.get("text-pitch-alignment"), I.paint.get("text-translate"), I.paint.get("text-translate-anchor"), z), I.paint.get("icon-opacity").constantOr(1) !== 0 && zu(w, T, I, R, false, I.paint.get("icon-translate"), I.paint.get("icon-translate-anchor"), I.layout.get("icon-rotation-alignment"), I.layout.get("icon-pitch-alignment"), I.layout.get("icon-keep-upright"), X, re, U), I.paint.get("text-opacity").constantOr(1) !== 0 && zu(w, T, I, R, true, I.paint.get("text-translate"), I.paint.get("text-translate-anchor"), I.layout.get("text-rotation-alignment"), I.layout.get("text-pitch-alignment"), I.layout.get("text-keep-upright"), X, re, U), T.map.showCollisionBoxes && (Mu(w, T, I, R, true), Mu(w, T, I, R, false));
            })(t, a, d, g, this.style.placement.variableOffsets, b) : s.ch(d) ? (function(w, T, I, R, z) {
              if (w.renderPass !== "translucent") return;
              const { isRenderingToTexture: W } = z, U = I.paint.get("circle-opacity"), X = I.paint.get("circle-stroke-width"), re = I.paint.get("circle-stroke-opacity"), de = !I.layout.get("circle-sort-key").isConstant();
              if (U.constantOr(1) === 0 && (X.constantOr(1) === 0 || re.constantOr(1) === 0)) return;
              const fe = w.context, me = fe.gl, Ce = w.transform, Pe = w.getDepthModeForSublayer(0, gr.ReadOnly), xe = Mr.disabled, Ie = w.colorModeForRenderPass(), De = [], Se = Ce.getCircleRadiusCorrection();
              for (let Ne = 0; Ne < R.length; Ne++) {
                const Ke = R[Ne], Ze = T.getTile(Ke), He = Ze.getBucket(I);
                if (!He) continue;
                const Je = I.paint.get("circle-translate"), Tt = I.paint.get("circle-translate-anchor"), It = s.aI(Ce, Ze, Je, Tt), _t = He.programConfigurations.get(I.id), Gt = w.useProgram("circle", _t), Yt = He.layoutVertexBuffer, Br = He.indexBuffer, ri = w.style.map.terrain && w.style.map.terrain.getTerrainData(Ke), Yr = { programConfiguration: _t, program: Gt, layoutVertexBuffer: Yt, indexBuffer: Br, uniformValues: tf(w, Ze, I, It, Se), terrainData: ri, projectionData: Ce.getProjectionData({ overscaledTileID: Ke, applyGlobeMatrix: !W, applyTerrainMatrix: true }) };
                if (de) {
                  const si = He.segments.get();
                  for (const Wr of si) De.push({ segments: new s.aR([Wr]), sortKey: Wr.sortKey, state: Yr });
                } else De.push({ segments: He.segments, sortKey: 0, state: Yr });
              }
              de && De.sort(((Ne, Ke) => Ne.sortKey - Ke.sortKey));
              for (const Ne of De) {
                const { programConfiguration: Ke, program: Ze, layoutVertexBuffer: He, indexBuffer: Je, uniformValues: Tt, terrainData: It, projectionData: _t } = Ne.state;
                Ze.draw(fe, me.TRIANGLES, Pe, xe, Ie, Ar.backCCW, Tt, It, _t, I.id, He, Je, Ne.segments, I.paint, w.transform.zoom, Ke);
              }
            })(t, a, d, g, b) : s.ci(d) ? (function(w, T, I, R, z) {
              if (I.paint.get("heatmap-opacity") === 0) return;
              const W = w.context, { isRenderingToTexture: U, isRenderingGlobe: X } = z;
              if (w.style.map.terrain) {
                for (const re of R) {
                  const de = T.getTile(re);
                  T.hasRenderableParent(re) || (w.renderPass === "offscreen" ? hl(w, de, I, re, X) : w.renderPass === "translucent" && Lm(w, I, re, U, X));
                }
                W.viewport.set([0, 0, w.width, w.height]);
              } else w.renderPass === "offscreen" ? (function(re, de, fe, me) {
                const Ce = re.context, Pe = Ce.gl, xe = re.transform, Ie = Mr.disabled, De = new ti([Pe.ONE, Pe.ONE], s.bj.transparent, [true, true, true, true]);
                (function(Se, Ne, Ke) {
                  const Ze = Se.gl;
                  Se.activeTexture.set(Ze.TEXTURE1), Se.viewport.set([0, 0, Ne.width / 4, Ne.height / 4]);
                  let He = Ke.heatmapFbos.get(s.c7);
                  He ? (Ze.bindTexture(Ze.TEXTURE_2D, He.colorAttachment.get()), Se.bindFramebuffer.set(He.framebuffer)) : (He = fd(Se, Ne.width / 4, Ne.height / 4), Ke.heatmapFbos.set(s.c7, He));
                })(Ce, re, fe), Ce.clear({ color: s.bj.transparent });
                for (let Se = 0; Se < me.length; Se++) {
                  const Ne = me[Se];
                  if (de.hasRenderableParent(Ne)) continue;
                  const Ke = de.getTile(Ne), Ze = Ke.getBucket(fe);
                  if (!Ze) continue;
                  const He = Ze.programConfigurations.get(fe.id), Je = re.useProgram("heatmap", He), Tt = xe.getProjectionData({ overscaledTileID: Ne, applyGlobeMatrix: true, applyTerrainMatrix: false }), It = xe.getCircleRadiusCorrection();
                  Je.draw(Ce, Pe.TRIANGLES, gr.disabled, Ie, De, Ar.backCCW, Qc(Ke, xe.zoom, fe.paint.get("heatmap-intensity"), It), null, Tt, fe.id, Ze.layoutVertexBuffer, Ze.indexBuffer, Ze.segments, fe.paint, xe.zoom, He);
                }
                Ce.viewport.set([0, 0, re.width, re.height]);
              })(w, T, I, R) : w.renderPass === "translucent" && (function(re, de) {
                const fe = re.context, me = fe.gl;
                fe.setColorMode(re.colorModeForRenderPass());
                const Ce = de.heatmapFbos.get(s.c7);
                Ce && (fe.activeTexture.set(me.TEXTURE0), me.bindTexture(me.TEXTURE_2D, Ce.colorAttachment.get()), fe.activeTexture.set(me.TEXTURE1), fl(fe, de).bind(me.LINEAR, me.CLAMP_TO_EDGE), re.useProgram("heatmapTexture").draw(fe, me.TRIANGLES, gr.disabled, Mr.disabled, re.colorModeForRenderPass(), Ar.disabled, ed(re, de, 0, 1), null, null, de.id, re.viewportBuffer, re.quadTriangleIndexBuffer, re.viewportSegments, de.paint, re.transform.zoom));
              })(w, I);
            })(t, a, d, g, b) : s.cj(d) ? (function(w, T, I, R, z) {
              if (w.renderPass !== "translucent") return;
              const { isRenderingToTexture: W } = z, U = I.paint.get("line-opacity"), X = I.paint.get("line-width");
              if (U.constantOr(1) === 0 || X.constantOr(1) === 0) return;
              const re = w.getDepthModeForSublayer(0, gr.ReadOnly), de = w.colorModeForRenderPass(), fe = I.paint.get("line-dasharray"), me = fe.constantOr(1), Ce = I.paint.get("line-pattern"), Pe = Ce.constantOr(1), xe = I.paint.get("line-gradient"), Ie = I.getCrossfadeParameters();
              let De;
              De = Pe ? "linePattern" : me && xe ? "lineGradientSDF" : me ? "lineSDF" : xe ? "lineGradient" : "line";
              const Se = w.context, Ne = Se.gl, Ke = w.transform;
              let Ze = true;
              for (const He of R) {
                const Je = T.getTile(He);
                if (Pe && !Je.patternsLoaded()) continue;
                const Tt = Je.getBucket(I);
                if (!Tt) continue;
                const It = Tt.programConfigurations.get(I.id), _t = w.context.program.get(), Gt = w.useProgram(De, It), Yt = Ze || Gt.program !== _t, Br = w.style.map.terrain && w.style.map.terrain.getTerrainData(He), ri = Ce.constantOr(null), Yr = fe && fe.constantOr(null);
                if (ri && Je.imageAtlas) {
                  const Gi = Je.imageAtlas, Si = Gi.patternPositions[ri.to.toString()], Ai = Gi.patternPositions[ri.from.toString()];
                  Si && Ai && It.setConstantPatternPositions(Si, Ai);
                } else if (Yr) {
                  const Gi = I.layout.get("line-cap") === "round", Si = w.lineAtlas.getDash(Yr.to, Gi), Ai = w.lineAtlas.getDash(Yr.from, Gi);
                  It.setConstantDashPositions(Si, Ai);
                }
                const si = Ke.getProjectionData({ overscaledTileID: He, applyGlobeMatrix: !W, applyTerrainMatrix: true }), Wr = Ke.getPixelScale();
                let Ri;
                Pe ? (Ri = Pm(w, Je, I, Wr, Ie), yf(Se, Ne, Je, It, Ie)) : me && xe ? (Ri = af(w, Je, I, Wr, Ie, Tt.lineClipsArray.length), pd(w, T, Se, Ne, I, Tt, He, It, Ie)) : me ? (Ri = Im(w, Je, I, Wr, Ie), _f(w, Se, Ne, It, Yt, Ie)) : xe ? (Ri = sl(w, Je, I, Wr, Tt.lineClipsArray.length), Lu(w, T, Se, Ne, I, Tt, He)) : Ri = yu(w, Je, I, Wr);
                const Zr = w.stencilModeForClipping(He);
                Gt.draw(Se, Ne.TRIANGLES, re, Zr, de, Ar.disabled, Ri, Br, si, I.id, Tt.layoutVertexBuffer, Tt.indexBuffer, Tt.segments, I.paint, w.transform.zoom, It, Tt.layoutVertexBuffer2), Ze = false;
              }
            })(t, a, d, g, b) : s.ck(d) ? (function(w, T, I, R, z) {
              const W = I.paint.get("fill-color"), U = I.paint.get("fill-opacity");
              if (U.constantOr(1) === 0) return;
              const { isRenderingToTexture: X } = z, re = w.colorModeForRenderPass(), de = I.paint.get("fill-pattern"), fe = w.opaquePassEnabledForLayer() && !de.constantOr(1) && W.constantOr(s.bj.transparent).a === 1 && U.constantOr(0) === 1 ? "opaque" : "translucent";
              if (w.renderPass === fe) {
                const me = w.getDepthModeForSublayer(1, w.renderPass === "opaque" ? gr.ReadWrite : gr.ReadOnly);
                md(w, T, I, R, me, re, false, X);
              }
              if (w.renderPass === "translucent" && I.paint.get("fill-antialias")) {
                const me = w.getDepthModeForSublayer(I.getPaintProperty("fill-outline-color") ? 2 : 0, gr.ReadOnly);
                md(w, T, I, R, me, re, true, X);
              }
            })(t, a, d, g, b) : s.cl(d) ? (function(w, T, I, R, z) {
              const W = I.paint.get("fill-extrusion-opacity");
              if (W === 0) return;
              const { isRenderingToTexture: U } = z;
              if (w.renderPass === "translucent") {
                const X = new gr(w.context.gl.LEQUAL, gr.ReadWrite, w.depthRangeFor3D);
                if (W !== 1 || I.paint.get("fill-extrusion-pattern").constantOr(1)) fi(w, T, I, R, X, Mr.disabled, ti.disabled, U), fi(w, T, I, R, X, w.stencilModeFor3D(), w.colorModeForRenderPass(), U);
                else {
                  const re = w.colorModeForRenderPass();
                  fi(w, T, I, R, X, Mr.disabled, re, U);
                }
              }
            })(t, a, d, g, b) : s.cm(d) ? (function(w, T, I, R, z) {
              if (w.renderPass !== "offscreen" && w.renderPass !== "translucent") return;
              const { isRenderingToTexture: W } = z, U = w.context, X = w.style.projection.useSubdivision, re = w.getDepthModeForSublayer(0, gr.ReadOnly), de = w.colorModeForRenderPass();
              if (w.renderPass === "offscreen") (function(fe, me, Ce, Pe, xe, Ie, De) {
                const Se = fe.context, Ne = Se.gl;
                for (const Ke of Ce) {
                  const Ze = me.getTile(Ke), He = Ze.dem;
                  if (!He || !He.data || !Ze.needsHillshadePrepare) continue;
                  const Je = He.dim, Tt = He.stride, It = He.getPixels();
                  if (Se.activeTexture.set(Ne.TEXTURE1), Se.pixelStoreUnpackPremultiplyAlpha.set(false), Ze.demTexture = Ze.demTexture || fe.getTileTexture(Tt), Ze.demTexture) {
                    const Gt = Ze.demTexture;
                    Gt.update(It, { premultiply: false }), Gt.bind(Ne.NEAREST, Ne.CLAMP_TO_EDGE);
                  } else Ze.demTexture = new s.T(Se, It, Ne.RGBA, { premultiply: false }), Ze.demTexture.bind(Ne.NEAREST, Ne.CLAMP_TO_EDGE);
                  Se.activeTexture.set(Ne.TEXTURE0);
                  let _t = Ze.fbo;
                  if (!_t) {
                    const Gt = new s.T(Se, { width: Je, height: Je, data: null }, Ne.RGBA);
                    Gt.bind(Ne.LINEAR, Ne.CLAMP_TO_EDGE), _t = Ze.fbo = Se.createFramebuffer(Je, Je, true, false), _t.colorAttachment.set(Gt.texture);
                  }
                  Se.bindFramebuffer.set(_t.framebuffer), Se.viewport.set([0, 0, Je, Je]), fe.useProgram("hillshadePrepare").draw(Se, Ne.TRIANGLES, xe, Ie, De, Ar.disabled, nf(Ze.tileID, He), null, null, Pe.id, fe.rasterBoundsBuffer, fe.quadTriangleIndexBuffer, fe.rasterBoundsSegments), Ze.needsHillshadePrepare = false;
                }
              })(w, T, R, I, re, Mr.disabled, de), U.viewport.set([0, 0, w.width, w.height]);
              else if (w.renderPass === "translucent") if (X) {
                const [fe, me, Ce] = w.stencilConfigForOverlapTwoPass(R);
                Xo(w, T, I, Ce, fe, re, de, false, W), Xo(w, T, I, Ce, me, re, de, true, W);
              } else {
                const [fe, me] = w.getStencilConfigForOverlapAndUpdateStencilID(R);
                Xo(w, T, I, me, fe, re, de, false, W);
              }
            })(t, a, d, g, b) : s.cn(d) ? (function(w, T, I, R, z) {
              if (w.renderPass !== "translucent" || !R.length) return;
              const { isRenderingToTexture: W } = z, U = w.style.projection.useSubdivision, X = w.getDepthModeForSublayer(0, gr.ReadOnly), re = w.colorModeForRenderPass();
              if (U) {
                const [de, fe, me] = w.stencilConfigForOverlapTwoPass(R);
                Nn(w, T, I, me, de, X, re, false, W), Nn(w, T, I, me, fe, X, re, true, W);
              } else {
                const [de, fe] = w.getStencilConfigForOverlapAndUpdateStencilID(R);
                Nn(w, T, I, fe, de, X, re, false, W);
              }
            })(t, a, d, g, b) : s.bO(d) ? (function(w, T, I, R, z) {
              if (w.renderPass !== "translucent" || I.paint.get("raster-opacity") === 0 || !R.length) return;
              const { isRenderingToTexture: W } = z, U = T.getSource(), X = w.style.projection.useSubdivision;
              if (U instanceof mt) Ha(w, T, I, R, null, false, false, U.tileCoords, U.flippedWindingOrder, W);
              else if (X) {
                const [re, de, fe] = w.stencilConfigForOverlapTwoPass(R);
                Ha(w, T, I, fe, re, false, true, pl, false, W), Ha(w, T, I, fe, de, true, true, pl, false, W);
              } else {
                const [re, de] = w.getStencilConfigForOverlapAndUpdateStencilID(R);
                Ha(w, T, I, de, re, false, true, pl, false, W);
              }
            })(t, a, d, g, b) : s.co(d) ? (function(w, T, I, R, z) {
              const W = I.paint.get("background-color"), U = I.paint.get("background-opacity");
              if (U === 0) return;
              const { isRenderingToTexture: X } = z, re = w.context, de = re.gl, fe = w.style.projection, me = w.transform, Ce = me.tileSize, Pe = I.paint.get("background-pattern");
              if (w.isPatternMissing(Pe)) return;
              const xe = !Pe && W.a === 1 && U === 1 && w.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (w.renderPass !== xe) return;
              const Ie = Mr.disabled, De = w.getDepthModeForSublayer(0, xe === "opaque" ? gr.ReadWrite : gr.ReadOnly), Se = w.colorModeForRenderPass(), Ne = w.useProgram(Pe ? "backgroundPattern" : "background"), Ke = R || sr(me, { tileSize: Ce, terrain: w.style.map.terrain });
              Pe && (re.activeTexture.set(de.TEXTURE0), w.imageManager.bind(w.context));
              const Ze = I.getCrossfadeParameters();
              for (const He of Ke) {
                const Je = me.getProjectionData({ overscaledTileID: He, applyGlobeMatrix: !X, applyTerrainMatrix: true }), Tt = Pe ? od(U, w, Pe, { tileID: He, tileSize: Ce }, Ze) : nd(U, W), It = w.style.map.terrain && w.style.map.terrain.getTerrainData(He), _t = fe.getMeshFromTileID(re, He.canonical, false, true, "raster");
                Ne.draw(re, de.TRIANGLES, De, Ie, Se, Ar.backCCW, Tt, It, Je, I.id, _t.vertexBuffer, _t.indexBuffer, _t.segments);
              }
            })(t, 0, d, g, b) : s.cp(d) && (function(w, T, I, R) {
              const { isRenderingGlobe: z } = R, W = w.context, U = I.implementation, X = w.style.projection, re = w.transform, de = re.getProjectionDataForCustomLayer(z), fe = { farZ: re.farZ, nearZ: re.nearZ, fov: re.fov * Math.PI / 180, modelViewProjectionMatrix: re.modelViewProjectionMatrix, projectionMatrix: re.projectionMatrix, shaderData: { variantName: X.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${X.shaderPreludeCode.vertexSource}`, define: X.shaderDefine }, defaultProjectionData: de }, me = U.renderingMode ? U.renderingMode : "2d";
              if (w.renderPass === "offscreen") {
                const Ce = U.prerender;
                Ce && (w.setCustomLayerDefaults(), W.setColorMode(w.colorModeForRenderPass()), Ce.call(U, W.gl, fe), W.setDirty(), w.setBaseState());
              } else if (w.renderPass === "translucent") {
                w.setCustomLayerDefaults(), W.setColorMode(w.colorModeForRenderPass()), W.setStencilMode(Mr.disabled);
                const Ce = me === "3d" ? w.getDepthModeFor3D() : w.getDepthModeForSublayer(0, gr.ReadOnly);
                W.setDepthMode(Ce), U.render(W.gl, fe), W.setDirty(), w.setBaseState(), W.bindFramebuffer.set(null);
              }
            })(t, 0, d, b));
          }
          saveTileTexture(t) {
            const a = this._tileTextures[t.size[0]];
            a ? a.push(t) : this._tileTextures[t.size[0]] = [t];
          }
          getTileTexture(t) {
            const a = this._tileTextures[t];
            return a && a.length > 0 ? a.pop() : null;
          }
          isPatternMissing(t) {
            if (!t) return false;
            if (!t.from || !t.to) return true;
            const a = this.imageManager.getPattern(t.from.toString()), d = this.imageManager.getPattern(t.to.toString());
            return !a || !d;
          }
          useProgram(t, a, d = false, g = []) {
            this.cache = this.cache || {};
            const b = !!this.style.map.terrain, w = this.style.projection, T = d ? no.projectionMercator : w.shaderPreludeCode, I = d ? dn : w.shaderDefine, R = t + (a ? a.cacheKey : "") + `/${d ? hn : w.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (b ? "/terrain" : "") + (g ? `/${g.join("/")}` : "");
            return this.cache[R] || (this.cache[R] = new km(this.context, no[t], a, sd[t], this._showOverdrawInspector, b, T, I, g)), this.cache[R];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const t = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new s.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            var t, a;
            if (this._tileTextures) {
              for (const d in this._tileTextures) {
                const g = this._tileTextures[d];
                if (g) for (const b of g) b.destroy();
              }
              this._tileTextures = {};
            }
            if (this.tileExtentBuffer && this.tileExtentBuffer.destroy(), this.debugBuffer && this.debugBuffer.destroy(), this.rasterBoundsBuffer && this.rasterBoundsBuffer.destroy(), this.rasterBoundsBufferPosOnly && this.rasterBoundsBufferPosOnly.destroy(), this.viewportBuffer && this.viewportBuffer.destroy(), this.tileBorderIndexBuffer && this.tileBorderIndexBuffer.destroy(), this.quadTriangleIndexBuffer && this.quadTriangleIndexBuffer.destroy(), this.tileExtentMesh && ((t = this.tileExtentMesh.vertexBuffer) === null || t === void 0 || t.destroy()), this.tileExtentMesh && ((a = this.tileExtentMesh.indexBuffer) === null || a === void 0 || a.destroy()), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.cache) {
              for (const d in this.cache) {
                const g = this.cache[d];
                g && g.program && this.context.gl.deleteProgram(g.program);
              }
              this.cache = {};
            }
            this.context && this.context.setDefault();
          }
          overLimit() {
            const { drawingBufferWidth: t, drawingBufferHeight: a } = this.context.gl;
            return this.width !== t || this.height !== a;
          }
        }
        function xd(_, t) {
          let a, d = false, g = null, b = null;
          const w = () => {
            g = null, d && (_.apply(b, a), g = setTimeout(w, t), d = false);
          };
          return (...T) => (d = true, b = this, a = T, g || w(), g);
        }
        class wd {
          constructor(t) {
            this._getCurrentHash = () => {
              const a = window.location.hash.replace("#", "");
              if (this._hashName) {
                let d;
                return a.split("&").map(((g) => g.split("="))).forEach(((g) => {
                  g[0] === this._hashName && (d = g);
                })), (d && d[1] || "").split("/");
              }
              return a.split("/");
            }, this._onHashChange = () => {
              const a = this._getCurrentHash();
              if (!this._isValidHash(a)) return false;
              const d = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(a[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+a[2], +a[1]], zoom: +a[0], bearing: d, pitch: +(a[4] || 0) }), true;
            }, this._updateHashUnthrottled = () => {
              const a = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, a);
            }, this._removeHash = () => {
              const a = this._getCurrentHash();
              if (a.length === 0) return;
              const d = a.join("/");
              let g = d;
              g.split("&").length > 0 && (g = g.split("&")[0]), this._hashName && (g = `${this._hashName}=${d}`);
              let b = window.location.hash.replace(g, "");
              b.startsWith("#&") ? b = b.slice(0, 1) + b.slice(2) : b === "#" && (b = "");
              let w = window.location.href.replace(/(#.+)?$/, b);
              w = w.replace("&&", "&"), window.history.replaceState(window.history.state, null, w);
            }, this._updateHash = xd(this._updateHashUnthrottled, 300), this._hashName = t && encodeURIComponent(t);
          }
          addTo(t) {
            return this._map = t, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
          }
          getHashString(t) {
            const a = this._map.getCenter(), d = Math.round(100 * this._map.getZoom()) / 100, g = Math.ceil((d * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), b = Math.pow(10, g), w = Math.round(a.lng * b) / b, T = Math.round(a.lat * b) / b, I = this._map.getBearing(), R = this._map.getPitch();
            let z = "";
            if (z += t ? `/${w}/${T}/${d}` : `${d}/${T}/${w}`, (I || R) && (z += "/" + Math.round(10 * I) / 10), R && (z += `/${Math.round(R)}`), this._hashName) {
              const W = this._hashName;
              let U = false;
              const X = window.location.hash.slice(1).split("&").map(((re) => {
                const de = re.split("=")[0];
                return de === W ? (U = true, `${de}=${z}`) : re;
              })).filter(((re) => re));
              return U || X.push(`${W}=${z}`), `#${X.join("&")}`;
            }
            return `#${z}`;
          }
          _isValidHash(t) {
            if (t.length < 3 || t.some(isNaN)) return false;
            try {
              new s.U(+t[2], +t[1]);
            } catch {
              return false;
            }
            const a = +t[0], d = +(t[3] || 0), g = +(t[4] || 0);
            return a >= this._map.getMinZoom() && a <= this._map.getMaxZoom() && d >= -180 && d <= 180 && g >= this._map.getMinPitch() && g <= this._map.getMaxPitch();
          }
        }
        const ks = { linearity: 0.3, easing: s.cq(0, 0, 0.3, 1) }, kf = s.e({ deceleration: 2500, maxSpeed: 1400 }, ks), Tf = s.e({ deceleration: 20, maxSpeed: 1400 }, ks), Pf = s.e({ deceleration: 1e3, maxSpeed: 360 }, ks), Bu = s.e({ deceleration: 1e3, maxSpeed: 90 }, ks), If = s.e({ deceleration: 1e3, maxSpeed: 360 }, ks);
        class ao {
          constructor(t) {
            this._map = t, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(t) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: q(), settings: t });
          }
          _drainInertiaBuffer() {
            const t = this._inertiaBuffer, a = q();
            for (; t.length > 0 && a - t[0].time > 160; ) t.shift();
          }
          _onMoveEnd(t) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const a = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new s.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: b } of this._inertiaBuffer) a.zoom += b.zoomDelta || 0, a.bearing += b.bearingDelta || 0, a.pitch += b.pitchDelta || 0, a.roll += b.rollDelta || 0, b.panDelta && a.pan._add(b.panDelta), b.around && (a.around = b.around), b.pinchAround && (a.pinchAround = b.pinchAround);
            const d = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, g = {};
            if (a.pan.mag()) {
              const b = Ts(a.pan.mag(), d, s.e({}, kf, t || {})), w = a.pan.mult(b.amount / a.pan.mag()), T = this._map.cameraHelper.handlePanInertia(w, this._map.transform);
              g.center = T.easingCenter, g.offset = T.easingOffset, In(g, b);
            }
            if (a.zoom) {
              const b = Ts(a.zoom, d, Tf);
              g.zoom = this._map.transform.zoom + b.amount, In(g, b);
            }
            if (a.bearing) {
              const b = Ts(a.bearing, d, Pf);
              g.bearing = this._map.transform.bearing + s.ai(b.amount, -179, 179), In(g, b);
            }
            if (a.pitch) {
              const b = Ts(a.pitch, d, Bu);
              g.pitch = this._map.transform.pitch + b.amount, In(g, b);
            }
            if (a.roll) {
              const b = Ts(a.roll, d, If);
              g.roll = this._map.transform.roll + s.ai(b.amount, -179, 179), In(g, b);
            }
            if (g.zoom || g.bearing) {
              const b = a.pinchAround === void 0 ? a.around : a.pinchAround;
              g.around = b ? this._map.unproject(b) : this._map.getCenter();
            }
            return this.clear(), s.e(g, { noMoveStart: true });
          }
        }
        function In(_, t) {
          (!_.duration || _.duration < t.duration) && (_.duration = t.duration, _.easing = t.easing);
        }
        function Ts(_, t, a) {
          const { maxSpeed: d, linearity: g, deceleration: b } = a, w = s.ai(_ * g / (t / 1e3), -d, d), T = Math.abs(w) / (b * g);
          return { easing: a.easing, duration: 1e3 * T, amount: w * (T / 2) };
        }
        class _i extends s.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t, a, d, g = {}) {
            d = d instanceof MouseEvent ? d : new MouseEvent(t, d);
            const b = N.mousePos(a.getCanvas(), d), w = a.unproject(b);
            super(t, s.e({ point: b, lngLat: w, originalEvent: d }, g)), this._defaultPrevented = false, this.target = a;
          }
        }
        class vl extends s.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t, a, d) {
            const g = t === "touchend" ? d.changedTouches : d.touches, b = N.touchPos(a.getCanvasContainer(), g), w = b.map(((I) => a.unproject(I))), T = b.reduce(((I, R, z, W) => I.add(R.div(W.length))), new s.P(0, 0));
            super(t, { points: b, point: T, lngLats: w, lngLat: a.unproject(T), originalEvent: d }), this._defaultPrevented = false;
          }
        }
        class Xa extends s.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t, a, d) {
            super(t, { originalEvent: d }), this._defaultPrevented = false;
          }
        }
        class Bm {
          constructor(t, a) {
            this._map = t, this._clickTolerance = a.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(t) {
            return this._firePreventable(new Xa(t.type, this._map, t));
          }
          mousedown(t, a) {
            return this._mousedownPos = a, this._firePreventable(new _i(t.type, this._map, t));
          }
          mouseup(t) {
            this._map.fire(new _i(t.type, this._map, t));
          }
          click(t, a) {
            this._mousedownPos && this._mousedownPos.dist(a) >= this._clickTolerance || this._map.fire(new _i(t.type, this._map, t));
          }
          dblclick(t) {
            return this._firePreventable(new _i(t.type, this._map, t));
          }
          mouseover(t) {
            this._map.fire(new _i(t.type, this._map, t));
          }
          mouseout(t) {
            this._map.fire(new _i(t.type, this._map, t));
          }
          touchstart(t) {
            return this._firePreventable(new vl(t.type, this._map, t));
          }
          touchmove(t) {
            this._map.fire(new vl(t.type, this._map, t));
          }
          touchend(t) {
            this._map.fire(new vl(t.type, this._map, t));
          }
          touchcancel(t) {
            this._map.fire(new vl(t.type, this._map, t));
          }
          _firePreventable(t) {
            if (this._map.fire(t), t.defaultPrevented) return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class Om {
          constructor(t) {
            this._map = t;
          }
          reset() {
            this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
          }
          mousemove(t) {
            this._map.fire(new _i(t.type, this._map, t));
          }
          mousedown() {
            this._delayContextMenu = true, this._ignoreContextMenu = false;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new _i("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(t) {
            this._delayContextMenu ? this._contextMenuEvent = t : this._ignoreContextMenu || this._map.fire(new _i(t.type, this._map, t)), this._map.listens("contextmenu") && t.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class yl {
          constructor(t) {
            this._map = t;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(t) {
            return this.transform.screenPointToLocation(s.P.convert(t), this._map.terrain);
          }
        }
        class Ef {
          constructor(t, a) {
            this._map = t, this._tr = new yl(t), this._el = t.getCanvasContainer(), this._container = t.getContainer(), this._clickTolerance = a.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(t, a) {
            this.isEnabled() && t.shiftKey && t.button === 0 && (N.disableDrag(), this._startPos = this._lastPos = a, this._active = true);
          }
          mousemoveWindow(t, a) {
            if (!this._active) return;
            const d = a;
            if (this._lastPos.equals(d) || !this._box && d.dist(this._startPos) < this._clickTolerance) return;
            const g = this._startPos;
            this._lastPos = d, this._box || (this._box = N.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", t));
            const b = Math.min(g.x, d.x), w = Math.max(g.x, d.x), T = Math.min(g.y, d.y), I = Math.max(g.y, d.y);
            N.setTransform(this._box, `translate(${b}px,${T}px)`), this._box.style.width = w - b + "px", this._box.style.height = I - T + "px";
          }
          mouseupWindow(t, a) {
            if (!this._active || t.button !== 0) return;
            const d = this._startPos, g = a;
            if (this.reset(), N.suppressClick(), d.x !== g.x || d.y !== g.y) return this._map.fire(new s.l("boxzoomend", { originalEvent: t })), { cameraAnimation: (b) => b.fitScreenCoordinates(d, g, this._tr.bearing, { linear: true }) };
            this._fireEvent("boxzoomcancel", t);
          }
          keydown(t) {
            this._active && t.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", t));
          }
          reset() {
            this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (N.remove(this._box), this._box = null), N.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(t, a) {
            return this._map.fire(new s.l(t, { originalEvent: a }));
          }
        }
        function Ou(_, t) {
          if (_.length !== t.length) throw new Error(`The number of touches and points are not equal - touches ${_.length}, points ${t.length}`);
          const a = {};
          for (let d = 0; d < _.length; d++) a[_[d].identifier] = t[d];
          return a;
        }
        class _l {
          constructor(t) {
            this.reset(), this.numTouches = t.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
          }
          touchstart(t, a, d) {
            (this.centroid || d.length > this.numTouches) && (this.aborted = true), this.aborted || (this.startTime === void 0 && (this.startTime = t.timeStamp), d.length === this.numTouches && (this.centroid = (function(g) {
              const b = new s.P(0, 0);
              for (const w of g) b._add(w);
              return b.div(g.length);
            })(a), this.touches = Ou(d, a)));
          }
          touchmove(t, a, d) {
            if (this.aborted || !this.centroid) return;
            const g = Ou(d, a);
            for (const b in this.touches) {
              const w = g[b];
              (!w || w.dist(this.touches[b]) > 30) && (this.aborted = true);
            }
          }
          touchend(t, a, d) {
            if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = true), d.length === 0) {
              const g = !this.aborted && this.centroid;
              if (this.reset(), g) return g;
            }
          }
        }
        class bo {
          constructor(t) {
            this.singleTap = new _l(t), this.numTaps = t.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(t, a, d) {
            this.singleTap.touchstart(t, a, d);
          }
          touchmove(t, a, d) {
            this.singleTap.touchmove(t, a, d);
          }
          touchend(t, a, d) {
            const g = this.singleTap.touchend(t, a, d);
            if (g) {
              const b = t.timeStamp - this.lastTime < 500, w = !this.lastTap || this.lastTap.dist(g) < 30;
              if (b && w || this.reset(), this.count++, this.lastTime = t.timeStamp, this.lastTap = g, this.count === this.numTaps) return this.reset(), g;
            }
          }
        }
        class Lt {
          constructor(t) {
            this._tr = new yl(t), this._zoomIn = new bo({ numTouches: 1, numTaps: 2 }), this._zoomOut = new bo({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(t, a, d) {
            this._zoomIn.touchstart(t, a, d), this._zoomOut.touchstart(t, a, d);
          }
          touchmove(t, a, d) {
            this._zoomIn.touchmove(t, a, d), this._zoomOut.touchmove(t, a, d);
          }
          touchend(t, a, d) {
            const g = this._zoomIn.touchend(t, a, d), b = this._zoomOut.touchend(t, a, d), w = this._tr;
            return g ? (this._active = true, t.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (T) => T.easeTo({ duration: 300, zoom: w.zoom + 1, around: w.unproject(g) }, { originalEvent: t }) }) : b ? (this._active = true, t.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (T) => T.easeTo({ duration: 300, zoom: w.zoom - 1, around: w.unproject(b) }, { originalEvent: t }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Ps {
          constructor(t) {
            this._enabled = !!t.enable, this._moveStateManager = t.moveStateManager, this._clickTolerance = t.clickTolerance || 1, this._moveFunction = t.move, this._activateOnStart = !!t.activateOnStart, t.assignEvents(this), this.reset();
          }
          reset(t) {
            this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(t);
          }
          _move(...t) {
            const a = this._moveFunction(...t);
            if (a.bearingDelta || a.pitchDelta || a.rollDelta || a.around || a.panDelta) return this._active = true, a;
          }
          dragStart(t, a) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(t) && (this._moveStateManager.startMove(t), this._lastPoint = Array.isArray(a) ? a[0] : a, this._activateOnStart && this._lastPoint && (this._active = true));
          }
          dragMove(t, a) {
            if (!this.isEnabled()) return;
            const d = this._lastPoint;
            if (!d) return;
            if (t.preventDefault(), !this._moveStateManager.isValidMoveEvent(t)) return void this.reset(t);
            const g = Array.isArray(a) ? a[0] : a;
            return !this._moved && g.dist(d) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = g, this._move(d, g));
          }
          dragEnd(t) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(t) && (this._moved && N.suppressClick(), this.reset(t));
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const Cd = 0, Mf = 2, bl = { [Cd]: 1, [Mf]: 2 };
        class Yo {
          constructor(t) {
            this._correctEvent = t.checkCorrectEvent;
          }
          startMove(t) {
            const a = N.mouseButton(t);
            this._eventButton = a;
          }
          endMove(t) {
            delete this._eventButton;
          }
          isValidStartEvent(t) {
            return this._correctEvent(t);
          }
          isValidMoveEvent(t) {
            return !(function(a, d) {
              const g = bl[d];
              return a.buttons === void 0 || (a.buttons & g) !== g;
            })(t, this._eventButton);
          }
          isValidEndEvent(t) {
            return N.mouseButton(t) === this._eventButton;
          }
        }
        class Sd {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(t) {
            return t.targetTouches.length === 1;
          }
          _isSameTouchEvent(t) {
            return t.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(t) {
            this._firstTouch = t.targetTouches[0].identifier;
          }
          endMove(t) {
            delete this._firstTouch;
          }
          isValidStartEvent(t) {
            return this._isOneFingerTouch(t);
          }
          isValidMoveEvent(t) {
            return this._isOneFingerTouch(t) && this._isSameTouchEvent(t);
          }
          isValidEndEvent(t) {
            return this._isOneFingerTouch(t) && this._isSameTouchEvent(t);
          }
        }
        class $m {
          constructor(t = new Yo({ checkCorrectEvent: () => true }), a = new Sd()) {
            this.mouseMoveStateManager = t, this.oneFingerTouchMoveStateManager = a;
          }
          _executeRelevantHandler(t, a, d) {
            return t instanceof MouseEvent ? a(t) : typeof TouchEvent < "u" && t instanceof TouchEvent ? d(t) : void 0;
          }
          startMove(t) {
            this._executeRelevantHandler(t, ((a) => this.mouseMoveStateManager.startMove(a)), ((a) => this.oneFingerTouchMoveStateManager.startMove(a)));
          }
          endMove(t) {
            this._executeRelevantHandler(t, ((a) => this.mouseMoveStateManager.endMove(a)), ((a) => this.oneFingerTouchMoveStateManager.endMove(a)));
          }
          isValidStartEvent(t) {
            return this._executeRelevantHandler(t, ((a) => this.mouseMoveStateManager.isValidStartEvent(a)), ((a) => this.oneFingerTouchMoveStateManager.isValidStartEvent(a)));
          }
          isValidMoveEvent(t) {
            return this._executeRelevantHandler(t, ((a) => this.mouseMoveStateManager.isValidMoveEvent(a)), ((a) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(a)));
          }
          isValidEndEvent(t) {
            return this._executeRelevantHandler(t, ((a) => this.mouseMoveStateManager.isValidEndEvent(a)), ((a) => this.oneFingerTouchMoveStateManager.isValidEndEvent(a)));
          }
        }
        const Is = (_) => {
          _.mousedown = _.dragStart, _.mousemoveWindow = _.dragMove, _.mouseup = _.dragEnd, _.contextmenu = (t) => {
            t.preventDefault();
          };
        };
        class kd {
          constructor(t, a) {
            this._clickTolerance = t.clickTolerance || 1, this._map = a, this.reset();
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new s.P(0, 0);
          }
          _shouldBePrevented(t) {
            return t < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(t, a, d) {
            return this._calculateTransform(t, a, d);
          }
          touchmove(t, a, d) {
            if (this._active) {
              if (!this._shouldBePrevented(d.length)) return t.preventDefault(), this._calculateTransform(t, a, d);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", t);
            }
          }
          touchend(t, a, d) {
            this._calculateTransform(t, a, d), this._active && this._shouldBePrevented(d.length) && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(t, a, d) {
            d.length > 0 && (this._active = true);
            const g = Ou(d, a), b = new s.P(0, 0), w = new s.P(0, 0);
            let T = 0;
            for (const R in g) {
              const z = g[R], W = this._touches[R];
              W && (b._add(z), w._add(z.sub(W)), T++, g[R] = z);
            }
            if (this._touches = g, this._shouldBePrevented(T) || !w.mag()) return;
            const I = w.div(T);
            return this._sum._add(I), this._sum.mag() < this._clickTolerance ? void 0 : { around: b.div(T), panDelta: I };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Td {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, delete this._firstTwoTouches;
          }
          touchstart(t, a, d) {
            this._firstTwoTouches || d.length < 2 || (this._firstTwoTouches = [d[0].identifier, d[1].identifier], this._start([a[0], a[1]]));
          }
          touchmove(t, a, d) {
            if (!this._firstTwoTouches) return;
            t.preventDefault();
            const [g, b] = this._firstTwoTouches, w = xl(d, a, g), T = xl(d, a, b);
            if (!w || !T) return;
            const I = this._aroundCenter ? null : w.add(T).div(2);
            return this._move([w, T], I, t);
          }
          touchend(t, a, d) {
            if (!this._firstTwoTouches) return;
            const [g, b] = this._firstTwoTouches, w = xl(d, a, g), T = xl(d, a, b);
            w && T || (this._active && N.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(t) {
            this._enabled = true, this._aroundCenter = !!t && t.around === "center";
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function xl(_, t, a) {
          for (let d = 0; d < _.length; d++) if (_[d].identifier === a) return t[d];
        }
        function Df(_, t) {
          return Math.log(_ / t) / Math.LN2;
        }
        class Rf extends Td {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(t) {
            this._startDistance = this._distance = t[0].dist(t[1]);
          }
          _move(t, a) {
            const d = this._distance;
            if (this._distance = t[0].dist(t[1]), this._active || !(Math.abs(Df(this._distance, this._startDistance)) < 0.1)) return this._active = true, { zoomDelta: Df(this._distance, d), pinchAround: a };
          }
        }
        function Pd(_, t) {
          return 180 * _.angleWith(t) / Math.PI;
        }
        class Af extends Td {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(t) {
            this._startVector = this._vector = t[0].sub(t[1]), this._minDiameter = t[0].dist(t[1]);
          }
          _move(t, a, d) {
            const g = this._vector;
            if (this._vector = t[0].sub(t[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = true, { bearingDelta: Pd(this._vector, g), pinchAround: a };
          }
          _isBelowThreshold(t) {
            this._minDiameter = Math.min(this._minDiameter, t.mag());
            const a = 25 / (Math.PI * this._minDiameter) * 360, d = Pd(t, this._startVector);
            return Math.abs(d) < a;
          }
        }
        function $u(_) {
          return Math.abs(_.y) > Math.abs(_.x);
        }
        class zf extends Td {
          constructor(t) {
            super(), this._currentTouchCount = 0, this._map = t;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(t, a, d) {
            super.touchstart(t, a, d), this._currentTouchCount = d.length;
          }
          _start(t) {
            this._lastPoints = t, $u(t[0].sub(t[1])) && (this._valid = false);
          }
          _move(t, a, d) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const g = t[0].sub(this._lastPoints[0]), b = t[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(g, b, d.timeStamp), this._valid ? (this._lastPoints = t, this._active = true, { pitchDelta: (g.y + b.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(t, a, d) {
            if (this._valid !== void 0) return this._valid;
            const g = t.mag() >= 2, b = a.mag() >= 2;
            if (!g && !b) return;
            if (!g || !b) return this._firstMove === void 0 && (this._firstMove = d), d - this._firstMove < 100 && void 0;
            const w = t.y > 0 == a.y > 0;
            return $u(t) && $u(a) && w;
          }
        }
        const Nm = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class Ko {
          constructor(t) {
            this._tr = new yl(t);
            const a = Nm;
            this._panStep = a.panStep, this._bearingStep = a.bearingStep, this._pitchStep = a.pitchStep, this._rotationDisabled = false;
          }
          reset() {
            this._active = false;
          }
          keydown(t) {
            if (t.altKey || t.ctrlKey || t.metaKey) return;
            let a = 0, d = 0, g = 0, b = 0, w = 0;
            switch (t.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                a = 1;
                break;
              case 189:
              case 109:
              case 173:
                a = -1;
                break;
              case 37:
                t.shiftKey ? d = -1 : (t.preventDefault(), b = -1);
                break;
              case 39:
                t.shiftKey ? d = 1 : (t.preventDefault(), b = 1);
                break;
              case 38:
                t.shiftKey ? g = 1 : (t.preventDefault(), w = -1);
                break;
              case 40:
                t.shiftKey ? g = -1 : (t.preventDefault(), w = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (d = 0, g = 0), { cameraAnimation: (T) => {
              const I = this._tr;
              T.easeTo({ duration: 300, easeId: "keyboardHandler", easing: qr, zoom: a ? Math.round(I.zoom) + a * (t.shiftKey ? 2 : 1) : I.zoom, bearing: I.bearing + d * this._bearingStep, pitch: I.pitch + g * this._pitchStep, offset: [-b * this._panStep, -w * this._panStep], center: I.center }, { originalEvent: t });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function qr(_) {
          return _ * (2 - _);
        }
        const Ff = 4.000244140625, Nu = 1 / 450;
        class ju {
          constructor(t, a) {
            this._onTimeout = (d) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(d);
            }, this._map = t, this._tr = new yl(t), this._triggerRenderFrame = a, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = Nu;
          }
          setZoomRate(t) {
            this._defaultZoomRate = t;
          }
          setWheelZoomRate(t) {
            this._wheelZoomRate = t;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(t) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = !!t && t.around === "center");
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          _shouldBePrevented(t) {
            return !!this._map.cooperativeGestures.isEnabled() && !(t.ctrlKey || this._map.cooperativeGestures.isBypassed(t));
          }
          wheel(t) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(t)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", t);
            let a = t.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;
            const d = q(), g = d - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = d, a !== 0 && a % Ff == 0 ? this._type = "wheel" : a !== 0 && Math.abs(a) < 4 ? this._type = "trackpad" : g > 400 ? (this._type = null, this._lastValue = a, this._timeout = setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(g * a) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, a += this._lastValue)), t.shiftKey && a && (a /= 4), this._type && (this._lastWheelEvent = t, this._delta -= a, this._active || this._start(t)), t.preventDefault();
          }
          _start(t) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const a = N.mousePos(this._map.getCanvas(), t), d = this._tr;
            this._aroundPoint = this._aroundCenter ? d.transform.locationToScreenPoint(s.U.convert(d.center)) : a, this._frameId || (this._frameId = true, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const t = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const T = t.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += T), typeof this._targetZoom == "number" && (this._targetZoom += T);
            }
            if (this._delta !== 0) {
              const T = this._type === "wheel" && Math.abs(this._delta) > Ff ? this._wheelZoomRate : this._defaultZoomRate;
              let I = 2 / (1 + Math.exp(-Math.abs(this._delta * T)));
              this._delta < 0 && I !== 0 && (I = 1 / I);
              const R = typeof this._targetZoom != "number" ? t.scale : s.al(this._targetZoom);
              this._targetZoom = t.applyConstrain(t.getCameraLngLat(), s.ao(R * I)).zoom, this._type === "wheel" && (this._startZoom = t.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const a = typeof this._targetZoom != "number" ? t.zoom : this._targetZoom, d = this._startZoom, g = this._easing;
            let b, w = false;
            if (this._type === "wheel" && d && g) {
              const T = q() - this._lastWheelEventTime, I = Math.min((T + 5) / 200, 1), R = g(I);
              b = s.F.number(d, a, R), I < 1 ? this._frameId || (this._frameId = true) : w = true;
            } else b = a, w = true;
            return this._active = true, w && (this._active = false, this._finishTimeout = setTimeout((() => {
              this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
            }), 200)), this._lastExpectedZoom = b, { noInertia: true, needsRenderFrame: !w, zoomDelta: b - t.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(t) {
            let a = s.cs;
            if (this._prevEase) {
              const d = this._prevEase, g = (q() - d.start) / d.duration, b = d.easing(g + 0.01) - d.easing(g), w = 0.27 / Math.sqrt(b * b + 1e-4) * 0.01, T = Math.sqrt(0.0729 - w * w);
              a = s.cq(w, T, 0.25, 1);
            }
            return this._prevEase = { start: q(), duration: t, easing: a }, a;
          }
          reset() {
            this._active = false, this._zooming = false, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class Id {
          constructor(t, a) {
            this._clickZoom = t, this._tapZoom = a;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class Lf {
          constructor(t) {
            this._tr = new yl(t), this.reset();
          }
          reset() {
            this._active = false;
          }
          dblclick(t, a) {
            return t.preventDefault(), { cameraAnimation: (d) => {
              d.easeTo({ duration: 300, zoom: this._tr.zoom + (t.shiftKey ? -1 : 1), around: this._tr.unproject(a) }, { originalEvent: t });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Bf {
          constructor() {
            this._tap = new bo({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(t, a, d) {
            if (!this._swipePoint) if (this._tapTime) {
              const g = a[0], b = t.timeStamp - this._tapTime < 500, w = this._tapPoint.dist(g) < 30;
              b && w ? d.length > 0 && (this._swipePoint = g, this._swipeTouch = d[0].identifier) : this.reset();
            } else this._tap.touchstart(t, a, d);
          }
          touchmove(t, a, d) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (d[0].identifier !== this._swipeTouch) return;
                const g = a[0], b = g.y - this._swipePoint.y;
                return this._swipePoint = g, t.preventDefault(), this._active = true, { zoomDelta: b / 128 };
              }
            } else this._tap.touchmove(t, a, d);
          }
          touchend(t, a, d) {
            if (this._tapTime) this._swipePoint && d.length === 0 && this.reset();
            else {
              const g = this._tap.touchend(t, a, d);
              g && (this._tapTime = t.timeStamp, this._tapPoint = g);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Of {
          constructor(t, a, d) {
            this._el = t, this._mousePan = a, this._touchPan = d;
          }
          enable(t) {
            this._inertiaOptions = t || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class xo {
          constructor(t, a, d, g) {
            this._pitchWithRotate = t.pitchWithRotate, this._rollEnabled = t.rollEnabled, this._mouseRotate = a, this._mousePitch = d, this._mouseRoll = g;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
          }
        }
        class wl {
          constructor(t, a, d, g) {
            this._el = t, this._touchZoom = a, this._touchRotate = d, this._tapDragZoom = g, this._rotationDisabled = false, this._enabled = true;
          }
          enable(t) {
            this._touchZoom.enable(t), this._rotationDisabled || this._touchRotate.enable(t), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class Wt {
          constructor(t, a) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = t, this._options = a, this._enabled = false;
          }
          isActive() {
            return false;
          }
          reset() {
          }
          _setupUI() {
            if (this._container) return;
            const t = this._map.getCanvasContainer();
            t.classList.add("maplibregl-cooperative-gestures"), this._container = N.create("div", "maplibregl-cooperative-gesture-screen", t);
            let a = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (a = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const d = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), g = document.createElement("div");
            g.className = "maplibregl-desktop-message", g.textContent = a, this._container.appendChild(g);
            const b = document.createElement("div");
            b.className = "maplibregl-mobile-message", b.textContent = d, this._container.appendChild(b), this._container.setAttribute("aria-hidden", "true");
          }
          _destroyUI() {
            this._container && (N.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = true;
          }
          disable() {
            this._enabled = false, this._destroyUI();
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(t) {
            return t[this._bypassKey];
          }
          notifyGestureBlocked(t, a) {
            this._enabled && (this._map.fire(new s.l("cooperativegestureprevented", { gestureType: t, originalEvent: a })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show");
            }), 100));
          }
        }
        const or = (_) => _.zoom || _.drag || _.roll || _.pitch || _.rotate;
        class Cl extends s.l {
        }
        function Vu(_) {
          return _.panDelta && _.panDelta.mag() || _.zoomDelta || _.bearingDelta || _.pitchDelta || _.rollDelta;
        }
        class Uu {
          constructor(t, a) {
            this.handleWindowEvent = (g) => {
              this.handleEvent(g, `${g.type}Window`);
            }, this.handleEvent = (g, b) => {
              if (g.type === "blur") return void this.stop(true);
              this._updatingCamera = true;
              const w = g.type === "renderFrame" ? void 0 : g, T = { needsRenderFrame: false }, I = {}, R = {};
              for (const { handlerName: U, handler: X, allowed: re } of this._handlers) {
                if (!X.isEnabled()) continue;
                let de;
                if (this._blockedByActive(R, re, U)) X.reset();
                else if (X[b || g.type]) {
                  if (s.ct(g, b || g.type)) {
                    const fe = N.mousePos(this._map.getCanvas(), g);
                    de = X[b || g.type](g, fe);
                  } else if (s.cu(g, b || g.type)) {
                    const fe = this._getMapTouches(g.touches), me = N.touchPos(this._map.getCanvas(), fe);
                    de = X[b || g.type](g, me, fe);
                  } else s.cv(b || g.type) || (de = X[b || g.type](g));
                  this.mergeHandlerResult(T, I, de, U, w), de && de.needsRenderFrame && this._triggerRenderFrame();
                }
                (de || X.isActive()) && (R[U] = X);
              }
              const z = {};
              for (const U in this._previousActiveHandlers) R[U] || (z[U] = w);
              this._previousActiveHandlers = R, (Object.keys(z).length || Vu(T)) && (this._changes.push([T, I, z]), this._triggerRenderFrame()), (Object.keys(R).length || Vu(T)) && this._map._stop(true), this._updatingCamera = false;
              const { cameraAnimation: W } = T;
              W && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], W(this._map));
            }, this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ao(t), this._bearingSnap = a.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(a);
            const d = this._el;
            this._listeners = [[d, "touchstart", { passive: true }], [d, "touchmove", { passive: false }], [d, "touchend", void 0], [d, "touchcancel", void 0], [d, "mousedown", void 0], [d, "mousemove", void 0], [d, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [d, "mouseover", void 0], [d, "mouseout", void 0], [d, "dblclick", void 0], [d, "click", void 0], [d, "keydown", { capture: false }], [d, "keyup", void 0], [d, "wheel", { passive: false }], [d, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [g, b, w] of this._listeners) N.addEventListener(g, b, g === document ? this.handleWindowEvent : this.handleEvent, w);
          }
          destroy() {
            for (const [t, a, d] of this._listeners) N.removeEventListener(t, a, t === document ? this.handleWindowEvent : this.handleEvent, d);
          }
          _addDefaultHandlers(t) {
            const a = this._map, d = a.getCanvasContainer();
            this._add("mapEvent", new Bm(a, t));
            const g = a.boxZoom = new Ef(a, t);
            this._add("boxZoom", g), t.interactive && t.boxZoom && g.enable();
            const b = a.cooperativeGestures = new Wt(a, t.cooperativeGestures);
            this._add("cooperativeGestures", b), t.cooperativeGestures && b.enable();
            const w = new Lt(a), T = new Lf(a);
            a.doubleClickZoom = new Id(T, w), this._add("tapZoom", w), this._add("clickZoom", T), t.interactive && t.doubleClickZoom && a.doubleClickZoom.enable();
            const I = new Bf();
            this._add("tapDragZoom", I);
            const R = a.touchPitch = new zf(a);
            this._add("touchPitch", R), t.interactive && t.touchPitch && a.touchPitch.enable(t.touchPitch);
            const z = () => a.project(a.getCenter()), W = (function({ enable: xe, clickTolerance: Ie, aroundCenter: De = true, minPixelCenterThreshold: Se = 100, rotateDegreesPerPixelMoved: Ne = 0.8 }, Ke) {
              const Ze = new Yo({ checkCorrectEvent: (He) => N.mouseButton(He) === 0 && He.ctrlKey || N.mouseButton(He) === 2 && !He.ctrlKey });
              return new Ps({ clickTolerance: Ie, move: (He, Je) => {
                const Tt = Ke();
                if (De && Math.abs(Tt.y - He.y) > Se) return { bearingDelta: s.cr(new s.P(He.x, Je.y), Je, Tt) };
                let It = (Je.x - He.x) * Ne;
                return De && Je.y < Tt.y && (It = -It), { bearingDelta: It };
              }, moveStateManager: Ze, enable: xe, assignEvents: Is });
            })(t, z), U = (function({ enable: xe, clickTolerance: Ie, pitchDegreesPerPixelMoved: De = -0.5 }) {
              const Se = new Yo({ checkCorrectEvent: (Ne) => N.mouseButton(Ne) === 0 && Ne.ctrlKey || N.mouseButton(Ne) === 2 });
              return new Ps({ clickTolerance: Ie, move: (Ne, Ke) => ({ pitchDelta: (Ke.y - Ne.y) * De }), moveStateManager: Se, enable: xe, assignEvents: Is });
            })(t), X = (function({ enable: xe, clickTolerance: Ie, rollDegreesPerPixelMoved: De = 0.3 }, Se) {
              const Ne = new Yo({ checkCorrectEvent: (Ke) => N.mouseButton(Ke) === 2 && Ke.ctrlKey });
              return new Ps({ clickTolerance: Ie, move: (Ke, Ze) => {
                const He = Se();
                let Je = (Ze.x - Ke.x) * De;
                return Ze.y < He.y && (Je = -Je), { rollDelta: Je };
              }, moveStateManager: Ne, enable: xe, assignEvents: Is });
            })(t, z);
            a.dragRotate = new xo(t, W, U, X), this._add("mouseRotate", W, ["mousePitch"]), this._add("mousePitch", U, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", X, ["mousePitch"]), t.interactive && t.dragRotate && a.dragRotate.enable();
            const re = (function({ enable: xe, clickTolerance: Ie }) {
              const De = new Yo({ checkCorrectEvent: (Se) => N.mouseButton(Se) === 0 && !Se.ctrlKey });
              return new Ps({ clickTolerance: Ie, move: (Se, Ne) => ({ around: Ne, panDelta: Ne.sub(Se) }), activateOnStart: true, moveStateManager: De, enable: xe, assignEvents: Is });
            })(t), de = new kd(t, a);
            a.dragPan = new Of(d, re, de), this._add("mousePan", re), this._add("touchPan", de, ["touchZoom", "touchRotate"]), t.interactive && t.dragPan && a.dragPan.enable(t.dragPan);
            const fe = new Af(), me = new Rf();
            a.touchZoomRotate = new wl(d, me, fe, I), this._add("touchRotate", fe, ["touchPan", "touchZoom"]), this._add("touchZoom", me, ["touchPan", "touchRotate"]), t.interactive && t.touchZoomRotate && a.touchZoomRotate.enable(t.touchZoomRotate), this._add("blockableMapEvent", new Om(a));
            const Ce = a.scrollZoom = new ju(a, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", Ce, ["mousePan"]), t.interactive && t.scrollZoom && a.scrollZoom.enable(t.scrollZoom);
            const Pe = a.keyboard = new Ko(a);
            this._add("keyboard", Pe), t.interactive && t.keyboard && a.keyboard.enable();
          }
          _add(t, a, d) {
            this._handlers.push({ handlerName: t, handler: a, allowed: d }), this._handlersById[t] = a;
          }
          stop(t) {
            if (!this._updatingCamera) {
              for (const { handler: a } of this._handlers) a.reset();
              this._inertia.clear(), this._fireEvents({}, {}, t), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: t } of this._handlers) if (t.isActive()) return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!or(this._eventsInProgress) || this.isZooming();
          }
          _blockedByActive(t, a, d) {
            for (const g in t) if (g !== d && (!a || a.indexOf(g) < 0)) return true;
            return false;
          }
          _getMapTouches(t) {
            const a = [];
            for (const d of t) this._el.contains(d.target) && a.push(d);
            return a;
          }
          mergeHandlerResult(t, a, d, g, b) {
            if (!d) return;
            s.e(t, d);
            const w = { handlerName: g, originalEvent: d.originalEvent || b };
            d.zoomDelta !== void 0 && (a.zoom = w), d.panDelta !== void 0 && (a.drag = w), d.rollDelta !== void 0 && (a.roll = w), d.pitchDelta !== void 0 && (a.pitch = w), d.bearingDelta !== void 0 && (a.rotate = w);
          }
          _applyChanges() {
            const t = {}, a = {}, d = {};
            for (const [g, b, w] of this._changes) g.panDelta && (t.panDelta = (t.panDelta || new s.P(0, 0))._add(g.panDelta)), g.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + g.zoomDelta), g.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + g.bearingDelta), g.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + g.pitchDelta), g.rollDelta && (t.rollDelta = (t.rollDelta || 0) + g.rollDelta), g.around !== void 0 && (t.around = g.around), g.pinchAround !== void 0 && (t.pinchAround = g.pinchAround), g.noInertia && (t.noInertia = g.noInertia), s.e(a, b), s.e(d, w);
            this._updateMapTransform(t, a, d), this._changes = [];
          }
          _updateMapTransform(t, a, d) {
            const g = this._map, b = g._getTransformForUpdate(), w = g.terrain;
            if (!(Vu(t) || w && this._terrainMovement)) return this._fireEvents(a, d, true);
            g._stop(true);
            let { panDelta: T, zoomDelta: I, bearingDelta: R, pitchDelta: z, rollDelta: W, around: U, pinchAround: X } = t;
            X !== void 0 && (U = X), U = U || g.transform.centerPoint, w && !b.isPointOnMapSurface(U) && (U = b.centerPoint);
            const re = { panDelta: T, zoomDelta: I, rollDelta: W, pitchDelta: z, bearingDelta: R, around: U };
            this._map.cameraHelper.useGlobeControls && !b.isPointOnMapSurface(U) && (U = b.centerPoint);
            const de = U.distSqr(b.centerPoint) < 0.01 ? b.center : b.screenPointToLocation(T ? U.sub(T) : U);
            this._handleMapControls({ terrain: w, tr: b, deltasForHelper: re, preZoomAroundLoc: de, combinedEventsInProgress: a, panDelta: T }), g._applyUpdatedTransform(b), this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(a, d, true);
          }
          _handleMapControls({ terrain: t, tr: a, deltasForHelper: d, preZoomAroundLoc: g, combinedEventsInProgress: b, panDelta: w }) {
            const T = this._map.cameraHelper;
            if (T.handleMapControlsRollPitchBearingZoom(d, a), t) return T.useGlobeControls ? (this._terrainMovement || !b.drag && !b.zoom || (this._terrainMovement = true, this._map._elevationFreeze = true), void T.handleMapControlsPan(d, a, g)) : this._terrainMovement || !b.drag && !b.zoom ? void (b.drag && this._terrainMovement && w ? a.setCenter(a.screenPointToLocation(a.centerPoint.sub(w))) : T.handleMapControlsPan(d, a, g)) : (this._terrainMovement = true, this._map._elevationFreeze = true, void T.handleMapControlsPan(d, a, g));
            T.handleMapControlsPan(d, a, g);
          }
          _fireEvents(t, a, d) {
            const g = or(this._eventsInProgress), b = or(t), w = {};
            for (const W in t) {
              const { originalEvent: U } = t[W];
              this._eventsInProgress[W] || (w[`${W}start`] = U), this._eventsInProgress[W] = t[W];
            }
            !g && b && this._fireEvent("movestart", b.originalEvent);
            for (const W in w) this._fireEvent(W, w[W]);
            b && this._fireEvent("move", b.originalEvent);
            for (const W in t) {
              const { originalEvent: U } = t[W];
              this._fireEvent(W, U);
            }
            const T = {};
            let I;
            for (const W in this._eventsInProgress) {
              const { handlerName: U, originalEvent: X } = this._eventsInProgress[W];
              this._handlersById[U].isActive() || (delete this._eventsInProgress[W], I = a[U] || X, T[`${W}end`] = I);
            }
            for (const W in T) this._fireEvent(W, T[W]);
            const R = or(this._eventsInProgress), z = (g || b) && !R;
            if (z && this._terrainMovement) {
              this._map._elevationFreeze = false, this._terrainMovement = false;
              const W = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && W.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(W);
            }
            if (d && z) {
              this._updatingCamera = true;
              const W = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), U = (X) => X !== 0 && -this._bearingSnap < X && X < this._bearingSnap;
              !W || !W.essential && j.prefersReducedMotion ? (this._map.fire(new s.l("moveend", { originalEvent: I })), U(this._map.getBearing()) && this._map.resetNorth()) : (U(W.bearing || this._map.getBearing()) && (W.bearing = 0), W.freezeElevation = true, this._map.easeTo(W, { originalEvent: I })), this._updatingCamera = false;
            }
          }
          _fireEvent(t, a) {
            this._map.fire(new s.l(t, a ? { originalEvent: a } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add(((t) => {
              delete this._frameId, this.handleEvent(new Cl("renderFrame", { timeStamp: t })), this._applyChanges();
            }));
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        class En extends s.E {
          constructor(t, a, d) {
            super(), this._renderFrameCallback = () => {
              const g = Math.min((q() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(g)), g < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = false, this._zooming = false, this.transform = t, this._bearingSnap = d.bearingSnap, this.cameraHelper = a, this.on("moveend", (() => {
              delete this._requestedCameraState;
            }));
          }
          migrateProjection(t, a) {
            t.apply(this.transform), this.transform = t, this.cameraHelper = a;
          }
          getCenter() {
            return new s.U(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(t, a) {
            return this.jumpTo({ center: t }, a);
          }
          getCenterElevation() {
            return this.transform.elevation;
          }
          setCenterElevation(t, a) {
            return this.jumpTo({ elevation: t }, a), this;
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround;
          }
          setCenterClampedToGround(t) {
            this._centerClampedToGround = t;
          }
          panBy(t, a, d) {
            return t = s.P.convert(t).mult(-1), this.panTo(this.transform.center, s.e({ offset: t }, a), d);
          }
          panTo(t, a, d) {
            return this.easeTo(s.e({ center: t }, a), d);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(t, a) {
            return this.jumpTo({ zoom: t }, a), this;
          }
          zoomTo(t, a, d) {
            return this.easeTo(s.e({ zoom: t }, a), d);
          }
          zoomIn(t, a) {
            return this.zoomTo(this.getZoom() + 1, t, a), this;
          }
          zoomOut(t, a) {
            return this.zoomTo(this.getZoom() - 1, t, a), this;
          }
          getVerticalFieldOfView() {
            return this.transform.fov;
          }
          setVerticalFieldOfView(t, a) {
            return t != this.transform.fov && (this.transform.setFov(t), this.fire(new s.l("movestart", a)).fire(new s.l("move", a)).fire(new s.l("moveend", a))), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(t, a) {
            return this.jumpTo({ bearing: t }, a), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(t, a) {
            return this.jumpTo({ padding: t }, a), this;
          }
          rotateTo(t, a, d) {
            return this.easeTo(s.e({ bearing: t }, a), d);
          }
          resetNorth(t, a) {
            return this.rotateTo(0, s.e({ duration: 1e3 }, t), a), this;
          }
          resetNorthPitch(t, a) {
            return this.easeTo(s.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, t), a), this;
          }
          snapToNorth(t, a) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, a) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(t, a) {
            return this.jumpTo({ pitch: t }, a), this;
          }
          getRoll() {
            return this.transform.roll;
          }
          setRoll(t, a) {
            return this.jumpTo({ roll: t }, a), this;
          }
          cameraForBounds(t, a) {
            t = gt.convert(t).adjustAntiMeridian();
            const d = a && a.bearing || 0;
            return this._cameraForBoxAndBearing(t.getNorthWest(), t.getSouthEast(), d, a);
          }
          _cameraForBoxAndBearing(t, a, d, g) {
            const b = { top: 0, bottom: 0, right: 0, left: 0 };
            if (typeof (g = s.e({ padding: b, offset: [0, 0], maxZoom: this.transform.maxZoom }, g)).padding == "number") {
              const R = g.padding;
              g.padding = { top: R, bottom: R, right: R, left: R };
            }
            const w = s.e(b, g.padding);
            g.padding = w;
            const T = this.transform, I = new gt(t, a);
            return this.cameraHelper.cameraForBoxAndBearing(g, w, I, d, T);
          }
          fitBounds(t, a, d) {
            return this._fitInternal(this.cameraForBounds(t, a), a, d);
          }
          fitScreenCoordinates(t, a, d, g, b) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(s.P.convert(t)), this.transform.screenPointToLocation(s.P.convert(a)), d, g), g, b);
          }
          _fitInternal(t, a, d) {
            return t ? (delete (a = s.e(t, a)).padding, a.linear ? this.easeTo(a, d) : this.flyTo(a, d)) : this;
          }
          jumpTo(t, a) {
            this.stop();
            const d = this._getTransformForUpdate();
            let g = false, b = false, w = false;
            const T = d.zoom;
            this.cameraHelper.handleJumpToCenterZoom(d, t);
            const I = d.zoom !== T;
            return "elevation" in t && d.elevation !== +t.elevation && d.setElevation(+t.elevation), "bearing" in t && d.bearing !== +t.bearing && (g = true, d.setBearing(+t.bearing)), "pitch" in t && d.pitch !== +t.pitch && (b = true, d.setPitch(+t.pitch)), "roll" in t && d.roll !== +t.roll && (w = true, d.setRoll(+t.roll)), t.padding == null || d.isPaddingEqual(t.padding) || d.setPadding(t.padding), this._applyUpdatedTransform(d), this.fire(new s.l("movestart", a)).fire(new s.l("move", a)), I && this.fire(new s.l("zoomstart", a)).fire(new s.l("zoom", a)).fire(new s.l("zoomend", a)), g && this.fire(new s.l("rotatestart", a)).fire(new s.l("rotate", a)).fire(new s.l("rotateend", a)), b && this.fire(new s.l("pitchstart", a)).fire(new s.l("pitch", a)).fire(new s.l("pitchend", a)), w && this.fire(new s.l("rollstart", a)).fire(new s.l("roll", a)).fire(new s.l("rollend", a)), this.fire(new s.l("moveend", a));
          }
          calculateCameraOptionsFromTo(t, a, d, g = 0) {
            const b = s.a5.fromLngLat(t, a), w = s.a5.fromLngLat(d, g), T = w.x - b.x, I = w.y - b.y, R = w.z - b.z, z = Math.hypot(T, I, R);
            if (z === 0) throw new Error("Can't calculate camera options with same From and To");
            const W = Math.hypot(T, I), U = s.ao(this.transform.cameraToCenterDistance / z / this.transform.tileSize), X = 180 * Math.atan2(T, -I) / Math.PI;
            let re = 180 * Math.acos(W / z) / Math.PI;
            return re = R < 0 ? 90 - re : 90 + re, { center: w.toLngLat(), elevation: g, zoom: U, pitch: re, bearing: X };
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(t, a, d, g, b) {
            const w = this.transform.calculateCenterFromCameraLngLatAlt(t, a, d, g);
            return { center: w.center, elevation: w.elevation, zoom: w.zoom, bearing: d, pitch: g, roll: b };
          }
          easeTo(t, a) {
            this._stop(false, t.easeId), ((t = s.e({ offset: [0, 0], duration: 500, easing: s.cs }, t)).animate === false || !t.essential && j.prefersReducedMotion) && (t.duration = 0);
            const d = this._getTransformForUpdate(), g = this.getBearing(), b = d.pitch, w = d.roll, T = "bearing" in t ? this._normalizeBearing(t.bearing, g) : g, I = "pitch" in t ? +t.pitch : b, R = "roll" in t ? this._normalizeBearing(t.roll, w) : w, z = "padding" in t ? t.padding : d.padding, W = s.P.convert(t.offset);
            let U, X;
            t.around && (U = s.U.convert(t.around), X = d.locationToScreenPoint(U));
            const re = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, de = this.cameraHelper.handleEaseTo(d, { bearing: T, pitch: I, roll: R, padding: z, around: U, aroundPoint: X, offsetAsPoint: W, offset: t.offset, zoom: t.zoom, center: t.center });
            return this._rotating = this._rotating || g !== T, this._pitching = this._pitching || I !== b, this._rolling = this._rolling || R !== w, this._padding = !d.isPaddingEqual(z), this._zooming = this._zooming || de.isZooming, this._easeId = t.easeId, this._prepareEase(a, t.noMoveStart, re), this.terrain && this._prepareElevation(de.elevationCenter), this._ease(((fe) => {
              de.easeFunc(fe), this.terrain && !t.freezeElevation && this._updateElevation(fe), this._applyUpdatedTransform(d), this._fireMoveEvents(a);
            }), ((fe) => {
              this.terrain && t.freezeElevation && this._finalizeElevation(), this._afterEase(a, fe);
            }), t), this;
          }
          _prepareEase(t, a, d = {}) {
            this._moving = true, a || d.moving || this.fire(new s.l("movestart", t)), this._zooming && !d.zooming && this.fire(new s.l("zoomstart", t)), this._rotating && !d.rotating && this.fire(new s.l("rotatestart", t)), this._pitching && !d.pitching && this.fire(new s.l("pitchstart", t)), this._rolling && !d.rolling && this.fire(new s.l("rollstart", t));
          }
          _prepareElevation(t) {
            this._elevationCenter = t, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(t, this.transform.tileZoom), this._elevationFreeze = true;
          }
          _updateElevation(t) {
            this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const a = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (t < 1 && a !== this._elevationTarget) {
              const d = this._elevationTarget - this._elevationStart;
              this._elevationStart += t * (d - (a - (d * t + this._elevationStart)) / (1 - t)), this._elevationTarget = a;
            }
            this.transform.setElevation(s.F.number(this._elevationStart, this._elevationTarget, t));
          }
          _finalizeElevation() {
            this._elevationFreeze = false, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _elevateCameraIfInsideTerrain(t) {
            if (!this.terrain && t.elevation >= 0 && t.pitch <= 90) return {};
            const a = t.getCameraLngLat(), d = t.getCameraAltitude(), g = this.terrain ? this.terrain.getElevationForLngLatZoom(a, t.zoom) : 0;
            if (d < g) {
              const b = this.calculateCameraOptionsFromTo(a, g, t.center, t.elevation);
              return { pitch: b.pitch, zoom: b.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(t) {
            const a = [];
            if (a.push(((g) => this._elevateCameraIfInsideTerrain(g))), this.transformCameraUpdate && a.push(((g) => this.transformCameraUpdate(g))), !a.length) return;
            const d = t.clone();
            for (const g of a) {
              const b = d.clone(), { center: w, zoom: T, roll: I, pitch: R, bearing: z, elevation: W } = g(b);
              w && b.setCenter(w), W !== void 0 && b.setElevation(W), T !== void 0 && b.setZoom(T), I !== void 0 && b.setRoll(I), R !== void 0 && b.setPitch(R), z !== void 0 && b.setBearing(z), d.apply(b);
            }
            this.transform.apply(d);
          }
          _fireMoveEvents(t) {
            this.fire(new s.l("move", t)), this._zooming && this.fire(new s.l("zoom", t)), this._rotating && this.fire(new s.l("rotate", t)), this._pitching && this.fire(new s.l("pitch", t)), this._rolling && this.fire(new s.l("roll", t));
          }
          _afterEase(t, a) {
            if (this._easeId && a && this._easeId === a) return;
            delete this._easeId;
            const d = this._zooming, g = this._rotating, b = this._pitching, w = this._rolling;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._rolling = false, this._padding = false, d && this.fire(new s.l("zoomend", t)), g && this.fire(new s.l("rotateend", t)), b && this.fire(new s.l("pitchend", t)), w && this.fire(new s.l("rollend", t)), this.fire(new s.l("moveend", t));
          }
          flyTo(t, a) {
            if (!t.essential && j.prefersReducedMotion) {
              const Je = s.S(t, ["center", "zoom", "bearing", "pitch", "roll", "elevation", "padding"]);
              return this.jumpTo(Je, a);
            }
            this.stop(), t = s.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: s.cs }, t);
            const d = this._getTransformForUpdate(), g = d.bearing, b = d.pitch, w = d.roll, T = d.padding, I = "bearing" in t ? this._normalizeBearing(t.bearing, g) : g, R = "pitch" in t ? +t.pitch : b, z = "roll" in t ? this._normalizeBearing(t.roll, w) : w, W = "padding" in t ? t.padding : d.padding, U = s.P.convert(t.offset);
            let X = d.centerPoint.add(U);
            const re = d.screenPointToLocation(X), de = this.cameraHelper.handleFlyTo(d, { bearing: I, pitch: R, roll: z, padding: W, locationAtOffset: re, offsetAsPoint: U, center: t.center, minZoom: t.minZoom, zoom: t.zoom });
            let fe = t.curve;
            const me = Math.max(d.width, d.height), Ce = me / de.scaleOfZoom, Pe = de.pixelPathLength;
            typeof de.scaleOfMinZoom == "number" && (fe = Math.sqrt(me / de.scaleOfMinZoom / Pe * 2));
            const xe = fe * fe;
            function Ie(Je) {
              const Tt = (Ce * Ce - me * me + (Je ? -1 : 1) * xe * xe * Pe * Pe) / (2 * (Je ? Ce : me) * xe * Pe);
              return Math.log(Math.sqrt(Tt * Tt + 1) - Tt);
            }
            function De(Je) {
              return (Math.exp(Je) - Math.exp(-Je)) / 2;
            }
            function Se(Je) {
              return (Math.exp(Je) + Math.exp(-Je)) / 2;
            }
            const Ne = Ie(false);
            let Ke = function(Je) {
              return Se(Ne) / Se(Ne + fe * Je);
            }, Ze = function(Je) {
              return me * ((Se(Ne) * (De(Tt = Ne + fe * Je) / Se(Tt)) - De(Ne)) / xe) / Pe;
              var Tt;
            }, He = (Ie(true) - Ne) / fe;
            if (Math.abs(Pe) < 2e-6 || !isFinite(He)) {
              if (Math.abs(me - Ce) < 1e-6) return this.easeTo(t, a);
              const Je = Ce < me ? -1 : 1;
              He = Math.abs(Math.log(Ce / me)) / fe, Ze = () => 0, Ke = (Tt) => Math.exp(Je * fe * Tt);
            }
            return t.duration = "duration" in t ? +t.duration : 1e3 * He / ("screenSpeed" in t ? +t.screenSpeed / fe : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0), this._zooming = true, this._rotating = g !== I, this._pitching = R !== b, this._rolling = z !== w, this._padding = !d.isPaddingEqual(W), this._prepareEase(a, false), this.terrain && this._prepareElevation(de.targetCenter), this._ease(((Je) => {
              const Tt = Je * He, It = 1 / Ke(Tt), _t = Ze(Tt);
              this._rotating && d.setBearing(s.F.number(g, I, Je)), this._pitching && d.setPitch(s.F.number(b, R, Je)), this._rolling && d.setRoll(s.F.number(w, z, Je)), this._padding && (d.interpolatePadding(T, W, Je), X = d.centerPoint.add(U)), de.easeFunc(Je, It, _t, X), this.terrain && !t.freezeElevation && this._updateElevation(Je), this._applyUpdatedTransform(d), this._fireMoveEvents(a);
            }), (() => {
              this.terrain && t.freezeElevation && this._finalizeElevation(), this._afterEase(a);
            }), t), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(t, a) {
            var d;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const g = this._onEaseEnd;
              delete this._onEaseEnd, g.call(this, a);
            }
            return t || (d = this.handlers) === null || d === void 0 || d.stop(false), this;
          }
          _ease(t, a, d) {
            d.animate === false || d.duration === 0 ? (t(1), a()) : (this._easeStart = q(), this._easeOptions = d, this._onEaseFrame = t, this._onEaseEnd = a, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(t, a) {
            t = s.V(t, -180, 180);
            const d = Math.abs(t - a);
            return Math.abs(t - 360 - a) < d && (t -= 360), Math.abs(t + 360 - a) < d && (t += 360), t;
          }
          queryTerrainElevation(t) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(s.U.convert(t), this.transform.tileZoom) : null;
          }
        }
        const Ed = { compact: true, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class so {
          constructor(t = Ed) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (a) => {
              !a || a.sourceDataType !== "metadata" && a.sourceDataType !== "visibility" && a.dataType !== "style" && a.type !== "terrain" || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === false ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = t;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(t) {
            return this._map = t, this._compact = this.options.compact, this._container = N.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = N.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = N.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            N.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(t, a) {
            const d = this._map._getUIString(`AttributionControl.${a}`);
            t.title = d, t.setAttribute("aria-label", d);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let t = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = t.concat(this.options.customAttribution.map(((g) => typeof g != "string" ? "" : g))) : typeof this.options.customAttribution == "string" && t.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const g = this._map.style.stylesheet;
              this.styleOwner = g.owner, this.styleId = g.id;
            }
            const a = this._map.style.tileManagers;
            for (const g in a) {
              const b = a[g];
              if (b.used || b.usedForTerrain) {
                const w = b.getSource();
                w.attribution && t.indexOf(w.attribution) < 0 && t.push(w.attribution);
              }
            }
            t = t.filter(((g) => String(g).trim())), t.sort(((g, b) => g.length - b.length)), t = t.filter(((g, b) => {
              for (let w = b + 1; w < t.length; w++) if (t[w].indexOf(g) >= 0) return false;
              return true;
            }));
            const d = t.join(" | ");
            d !== this._attribHTML && (this._attribHTML = d, t.length ? (this._innerContainer.innerHTML = N.sanitize(d), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class Md {
          constructor(t = {}) {
            this._updateCompact = () => {
              const a = this._container.children;
              if (a.length) {
                const d = a[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== false && d.classList.add("maplibregl-compact") : d.classList.remove("maplibregl-compact");
              }
            }, this.options = t;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(t) {
            this._map = t, this._compact = this.options && this.options.compact, this._container = N.create("div", "maplibregl-ctrl");
            const a = N.create("a", "maplibregl-ctrl-logo");
            return a.target = "_blank", a.rel = "noopener nofollow", a.href = "https://maplibre.org/", a.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), a.setAttribute("rel", "noopener nofollow"), this._container.appendChild(a), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            N.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class jm {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(t) {
            const a = ++this._id;
            return this._queue.push({ callback: t, id: a, cancelled: false }), a;
          }
          remove(t) {
            const a = this._currentlyRunning, d = a ? this._queue.concat(a) : this._queue;
            for (const g of d) if (g.id === t) return void (g.cancelled = true);
          }
          run(t = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const a = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const d of a) if (!d.cancelled && (d.callback(t), this._cleared)) break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        var Vm = s.aO([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class Um extends s.E {
          constructor(t) {
            super(), this._lastTilesetChange = q(), this.tileManager = t, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = t._source.tileSize * 2 ** this.deltaZoom, t.usedForTerrain = true, t.tileSize = this.tileSize;
          }
          destruct() {
            this.tileManager.usedForTerrain = false, this.tileManager.tileSize = null;
          }
          getSource() {
            return this.tileManager._source;
          }
          update(t, a) {
            this.tileManager.update(t, a), this._renderableTilesKeys = [];
            const d = {};
            for (const g of sr(t, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: a, calculateTileZoom: this.tileManager._source.calculateTileZoom })) d[g.key] = true, this._renderableTilesKeys.push(g.key), this._tiles[g.key] || (g.terrainRttPosMatrix32f = new Float64Array(16), s.c1(g.terrainRttPosMatrix32f, 0, s.a3, s.a3, 0, 0, 1), this._tiles[g.key] = new $(g, this.tileSize), this._lastTilesetChange = q());
            for (const g in this._tiles) d[g] || delete this._tiles[g];
          }
          freeRtt(t) {
            for (const a in this._tiles) {
              const d = this._tiles[a];
              (!t || d.tileID.equals(t) || d.tileID.isChildOf(t) || t.isChildOf(d.tileID)) && (d.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map(((t) => this.getTileByID(t)));
          }
          getTileByID(t) {
            return this._tiles[t];
          }
          getTerrainCoords(t, a) {
            return a ? this._getTerrainCoordsForTileRanges(t, a) : this._getTerrainCoordsForRegularTile(t);
          }
          _getTerrainCoordsForRegularTile(t) {
            const a = {};
            for (const d of this._renderableTilesKeys) {
              const g = this._tiles[d].tileID, b = t.clone(), w = s.be();
              if (g.canonical.equals(t.canonical)) s.c1(w, 0, s.a3, s.a3, 0, 0, 1);
              else if (g.canonical.isChildOf(t.canonical)) {
                const T = g.canonical.z - t.canonical.z, I = g.canonical.x - (g.canonical.x >> T << T), R = g.canonical.y - (g.canonical.y >> T << T), z = s.a3 >> T;
                s.c1(w, 0, z, z, 0, 0, 1), s.N(w, w, [-I * z, -R * z, 0]);
              } else {
                if (!t.canonical.isChildOf(g.canonical)) continue;
                {
                  const T = t.canonical.z - g.canonical.z, I = t.canonical.x - (t.canonical.x >> T << T), R = t.canonical.y - (t.canonical.y >> T << T), z = s.a3 >> T;
                  s.c1(w, 0, s.a3, s.a3, 0, 0, 1), s.N(w, w, [I * z, R * z, 0]), s.O(w, w, [1 / 2 ** T, 1 / 2 ** T, 0]);
                }
              }
              b.terrainRttPosMatrix32f = new Float32Array(w), a[d] = b;
            }
            return a;
          }
          _getTerrainCoordsForTileRanges(t, a) {
            const d = {};
            for (const g of this._renderableTilesKeys) {
              const b = this._tiles[g].tileID;
              if (!this._isWithinTileRanges(b, a)) continue;
              const w = t.clone(), T = s.be();
              if (b.canonical.z === t.canonical.z) {
                const I = t.canonical.x - b.canonical.x, R = t.canonical.y - b.canonical.y;
                s.c1(T, 0, s.a3, s.a3, 0, 0, 1), s.N(T, T, [I * s.a3, R * s.a3, 0]);
              } else if (b.canonical.z > t.canonical.z) {
                const I = b.canonical.z - t.canonical.z, R = b.canonical.x - (b.canonical.x >> I << I), z = b.canonical.y - (b.canonical.y >> I << I), W = t.canonical.x - (b.canonical.x >> I), U = t.canonical.y - (b.canonical.y >> I), X = s.a3 >> I;
                s.c1(T, 0, X, X, 0, 0, 1), s.N(T, T, [-R * X + W * s.a3, -z * X + U * s.a3, 0]);
              } else {
                const I = t.canonical.z - b.canonical.z, R = t.canonical.x - (t.canonical.x >> I << I), z = t.canonical.y - (t.canonical.y >> I << I), W = (t.canonical.x >> I) - b.canonical.x, U = (t.canonical.y >> I) - b.canonical.y, X = s.a3 << I;
                s.c1(T, 0, X, X, 0, 0, 1), s.N(T, T, [R * s.a3 + W * X, z * s.a3 + U * X, 0]);
              }
              w.terrainRttPosMatrix32f = new Float32Array(T), d[g] = w;
            }
            return d;
          }
          getSourceTile(t, a) {
            const d = this.tileManager._source;
            let g = t.overscaledZ - this.deltaZoom;
            if (g > d.maxzoom && (g = d.maxzoom), g < d.minzoom) return null;
            this._sourceTileCache[t.key] || (this._sourceTileCache[t.key] = t.scaledTo(g).key);
            let b = this.tileManager.getTileByID(this._sourceTileCache[t.key]);
            if ((!b || !b.dem) && a) for (; g >= d.minzoom && (!b || !b.dem); ) b = this.tileManager.getTileByID(t.scaledTo(g--).key);
            return b;
          }
          anyTilesAfterTime(t = Date.now()) {
            return this._lastTilesetChange >= t;
          }
          _isWithinTileRanges(t, a) {
            return a[t.canonical.z] && t.canonical.x >= a[t.canonical.z].minTileX && t.canonical.x <= a[t.canonical.z].maxTileX && t.canonical.y >= a[t.canonical.z].minTileY && t.canonical.y <= a[t.canonical.z].maxTileY;
          }
        }
        class Sl {
          constructor(t, a, d) {
            this._meshCache = {}, this.painter = t, this.tileManager = new Um(a), this.options = d, this.exaggeration = typeof d.exaggeration == "number" ? d.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(t, a, d, g = s.a3) {
            var b;
            if (!(a >= 0 && a < g && d >= 0 && d < g)) return 0;
            const w = this.getTerrainData(t), T = (b = w.tile) === null || b === void 0 ? void 0 : b.dem;
            if (!T) return 0;
            const I = s.cw([], [a / g * s.a3, d / g * s.a3], w.u_terrain_matrix), R = [I[0] * T.dim, I[1] * T.dim], z = Math.floor(R[0]), W = Math.floor(R[1]), U = R[0] - z, X = R[1] - W;
            return T.get(z, W) * (1 - U) * (1 - X) + T.get(z + 1, W) * U * (1 - X) + T.get(z, W + 1) * (1 - U) * X + T.get(z + 1, W + 1) * U * X;
          }
          getElevationForLngLatZoom(t, a) {
            if (!s.cx(a, t.wrap())) return 0;
            const { tileID: d, mercatorX: g, mercatorY: b } = this._getOverscaledTileIDFromLngLatZoom(t, a);
            return this.getElevation(d, g % s.a3, b % s.a3, s.a3);
          }
          getElevation(t, a, d, g = s.a3) {
            return this.getDEMElevation(t, a, d, g) * this.exaggeration;
          }
          getTerrainData(t) {
            if (!this._emptyDemTexture) {
              const g = this.painter.context, b = new s.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new s.T(g, b, g.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new s.T(g, new s.R({ width: 1, height: 1 }), g.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(g.gl.NEAREST, g.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = s.am([]);
            }
            const a = this.tileManager.getSourceTile(t, true);
            if (a && a.dem && (!a.demTexture || a.needsTerrainPrepare)) {
              const g = this.painter.context;
              a.demTexture = this.painter.getTileTexture(a.dem.stride), a.demTexture ? a.demTexture.update(a.dem.getPixels(), { premultiply: false }) : a.demTexture = new s.T(g, a.dem.getPixels(), g.gl.RGBA, { premultiply: false }), a.demTexture.bind(g.gl.NEAREST, g.gl.CLAMP_TO_EDGE), a.needsTerrainPrepare = false;
            }
            const d = a && a + a.tileID.key + t.key;
            if (d && !this._demMatrixCache[d]) {
              const g = this.tileManager.getSource().maxzoom;
              let b = t.canonical.z - a.tileID.canonical.z;
              t.overscaledZ > t.canonical.z && (t.canonical.z >= g ? b = t.canonical.z - g : s.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const w = t.canonical.x - (t.canonical.x >> b << b), T = t.canonical.y - (t.canonical.y >> b << b), I = s.cy(new Float64Array(16), [1 / (s.a3 << b), 1 / (s.a3 << b), 0]);
              s.N(I, I, [w * s.a3, T * s.a3, 0]), this._demMatrixCache[t.key] = { matrix: I, coord: t };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: a && a.dem && a.dem.dim || 1, u_terrain_matrix: d ? this._demMatrixCache[t.key].matrix : this._emptyDemMatrix, u_terrain_unpack: a && a.dem && a.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (a && a.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: a };
          }
          getFramebuffer(t) {
            const a = this.painter, d = a.width / devicePixelRatio, g = a.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === d && this._fbo.height === g || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new s.T(a.context, { width: d, height: g, data: null }, a.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(a.context.gl.NEAREST, a.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new s.T(a.context, { width: d, height: g, data: null }, a.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(a.context.gl.NEAREST, a.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = a.context.createFramebuffer(d, g, true, false), this._fbo.depthAttachment.set(a.context.createRenderbuffer(a.context.gl.DEPTH_COMPONENT16, d, g))), this._fbo.colorAttachment.set(t === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const t = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const a = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let b = 0, w = 0; b < this._coordsTextureSize; b++) for (let T = 0; T < this._coordsTextureSize; T++, w += 4) a[w + 0] = 255 & T, a[w + 1] = 255 & b, a[w + 2] = T >> 8 << 4 | b >> 8, a[w + 3] = 0;
            const d = new s.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(a.buffer)), g = new s.T(t, d, t.gl.RGBA, { premultiply: false });
            return g.bind(t.gl.NEAREST, t.gl.CLAMP_TO_EDGE), this._coordsTexture = g, g;
          }
          pointCoordinate(t) {
            this.painter.maybeDrawDepthAndCoords(true);
            const a = new Uint8Array(4), d = this.painter.context, g = d.gl, b = Math.round(t.x * this.painter.pixelRatio / devicePixelRatio), w = Math.round(t.y * this.painter.pixelRatio / devicePixelRatio), T = Math.round(this.painter.height / devicePixelRatio);
            d.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), g.readPixels(b, T - w - 1, 1, 1, g.RGBA, g.UNSIGNED_BYTE, a), d.bindFramebuffer.set(null);
            const I = a[0] + (a[2] >> 4 << 8), R = a[1] + ((15 & a[2]) << 8), z = this.coordsIndex[255 - a[3]], W = z && this.tileManager.getTileByID(z);
            if (!W) return null;
            const U = this._coordsTextureSize, X = (1 << W.tileID.canonical.z) * U;
            return new s.a5((W.tileID.canonical.x * U + I) / X + W.tileID.wrap, (W.tileID.canonical.y * U + R) / X, this.getElevation(W.tileID, I, R, U));
          }
          depthAtPoint(t) {
            const a = new Uint8Array(4), d = this.painter.context, g = d.gl;
            return d.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), g.readPixels(t.x, this.painter.height / devicePixelRatio - t.y - 1, 1, 1, g.RGBA, g.UNSIGNED_BYTE, a), d.bindFramebuffer.set(null), (a[0] / 16777216 + a[1] / 65536 + a[2] / 256 + a[3]) / 256;
          }
          getTerrainMesh(t) {
            var a;
            const d = ((a = this.painter.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0, g = d && t.canonical.y === 0, b = d && t.canonical.y === (1 << t.canonical.z) - 1, w = `m_${g ? "n" : ""}_${b ? "s" : ""}`;
            if (this._meshCache[w]) return this._meshCache[w];
            const T = this.painter.context, I = new s.cz(), R = new s.aS(), z = this.meshSize, W = s.a3 / z, U = z * z;
            for (let Se = 0; Se <= z; Se++) for (let Ne = 0; Ne <= z; Ne++) I.emplaceBack(Ne * W, Se * W, 0);
            for (let Se = 0; Se < U; Se += z + 1) for (let Ne = 0; Ne < z; Ne++) R.emplaceBack(Ne + Se, z + Ne + Se + 1, z + Ne + Se + 2), R.emplaceBack(Ne + Se, z + Ne + Se + 2, Ne + Se + 1);
            const X = I.length, re = X + (z + 1), de = (z + 1) * z, fe = g ? s.bl : 0, me = g ? 0 : 1, Ce = b ? s.bm : s.a3, Pe = b ? 0 : 1;
            for (let Se = 0; Se <= z; Se++) I.emplaceBack(Se * W, fe, me);
            for (let Se = 0; Se <= z; Se++) I.emplaceBack(Se * W, Ce, Pe);
            for (let Se = 0; Se < z; Se++) R.emplaceBack(de + Se, re + Se, re + Se + 1), R.emplaceBack(de + Se, re + Se + 1, de + Se + 1), R.emplaceBack(0 + Se, X + Se + 1, X + Se), R.emplaceBack(0 + Se, 0 + Se + 1, X + Se + 1);
            const xe = I.length, Ie = xe + 2 * (z + 1);
            for (const Se of [0, 1]) for (let Ne = 0; Ne <= z; Ne++) for (const Ke of [0, 1]) I.emplaceBack(Se * s.a3, Ne * W, Ke);
            for (let Se = 0; Se < 2 * z; Se += 2) R.emplaceBack(xe + Se, xe + Se + 1, xe + Se + 3), R.emplaceBack(xe + Se, xe + Se + 3, xe + Se + 2), R.emplaceBack(Ie + Se, Ie + Se + 3, Ie + Se + 1), R.emplaceBack(Ie + Se, Ie + Se + 2, Ie + Se + 3);
            const De = new ya(T.createVertexBuffer(I, Vm.members), T.createIndexBuffer(R), s.aR.simpleSegment(0, 0, I.length, R.length));
            return this._meshCache[w] = De, De;
          }
          getMeshFrameDelta(t) {
            return 2 * Math.PI * s.by / Math.pow(2, Math.max(t, 0)) / 5;
          }
          getMinTileElevationForLngLatZoom(t, a) {
            var d;
            const { tileID: g } = this._getOverscaledTileIDFromLngLatZoom(t, a);
            return (d = this.getMinMaxElevation(g).minElevation) !== null && d !== void 0 ? d : 0;
          }
          getMinMaxElevation(t) {
            const a = this.getTerrainData(t).tile, d = { minElevation: null, maxElevation: null };
            return a && a.dem && (d.minElevation = a.dem.min * this.exaggeration, d.maxElevation = a.dem.max * this.exaggeration), d;
          }
          _getOverscaledTileIDFromLngLatZoom(t, a) {
            const d = s.a5.fromLngLat(t.wrap()), g = (1 << a) * s.a3, b = d.x * g, w = d.y * g, T = Math.floor(b / s.a3), I = Math.floor(w / s.a3);
            return { tileID: new s.a0(a, 0, a, T, I), mercatorX: b, mercatorY: w };
          }
        }
        class pi {
          constructor(t, a, d) {
            this._context = t, this._size = a, this._tileSize = d, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const t of this._objects) t.texture.destroy(), t.fbo.destroy();
          }
          _createObject(t) {
            const a = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), d = new s.T(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return d.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), a.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), a.colorAttachment.set(d.texture), { id: t, fbo: a, texture: d, stamp: -1, inUse: false };
          }
          getObjectForId(t) {
            return this._objects[t];
          }
          useObject(t) {
            t.inUse = true, this._recentlyUsed = this._recentlyUsed.filter(((a) => t.id !== a)), this._recentlyUsed.push(t.id);
          }
          stampObject(t) {
            t.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const a of this._recentlyUsed) if (!this._objects[a].inUse) return this._objects[a];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const t = this._createObject(this._objects.length);
            return this._objects.push(t), t;
          }
          freeObject(t) {
            t.inUse = false;
          }
          freeAllObjects() {
            for (const t of this._objects) this.freeObject(t);
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some(((t) => !t.inUse)) === false;
          }
        }
        const Xr = { background: true, fill: true, line: true, raster: true, hillshade: true, "color-relief": true };
        class $f {
          constructor(t, a) {
            this.painter = t, this.terrain = a, this.pool = new pi(t.context, 30, a.tileManager.tileSize * a.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(t) {
            return this.pool.getObjectForId(t.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(t, a) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.tileManager.getRenderableTiles(), this._renderableLayerIds = t._order.filter(((d) => !t._layers[d].isHidden(a))), this._coordsAscending = {};
            for (const d in t.tileManagers) {
              this._coordsAscending[d] = {};
              const g = t.tileManagers[d].getVisibleCoordinates(), b = t.tileManagers[d].getSource(), w = b instanceof mt ? b.terrainTileRanges : null;
              for (const T of g) {
                const I = this.terrain.tileManager.getTerrainCoords(T, w);
                for (const R in I) this._coordsAscending[d][R] || (this._coordsAscending[d][R] = []), this._coordsAscending[d][R].push(I[R]);
              }
            }
            this._coordsAscendingStr = {};
            for (const d of t._order) {
              const g = t._layers[d], b = g.source;
              if (Xr[g.type] && !this._coordsAscendingStr[b]) {
                this._coordsAscendingStr[b] = {};
                for (const w in this._coordsAscending[b]) this._coordsAscendingStr[b][w] = this._coordsAscending[b][w].map(((T) => T.key)).sort().join();
              }
            }
            for (const d of this._renderableTiles) for (const g in this._coordsAscendingStr) {
              const b = this._coordsAscendingStr[g][d.tileID.key];
              b && b !== d.rttCoords[g] && (d.rtt = []);
            }
          }
          renderLayer(t, a) {
            if (t.isHidden(this.painter.transform.zoom)) return false;
            const d = Object.assign(Object.assign({}, a), { isRenderingToTexture: true }), g = t.type, b = this.painter, w = this._renderableLayerIds[this._renderableLayerIds.length - 1] === t.id;
            if (Xr[g] && (this._prevType && Xr[this._prevType] || this._stacks.push([]), this._prevType = g, this._stacks[this._stacks.length - 1].push(t.id), !w)) return true;
            if (Xr[this._prevType] || Xr[g] && w) {
              this._prevType = g;
              const T = this._stacks.length - 1, I = this._stacks[T] || [];
              for (const R of this._renderableTiles) {
                if (this.pool.isFull() && (wa(this.painter, this.terrain, this._rttTiles, d), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(R), R.rtt[T]) {
                  const W = this.pool.getObjectForId(R.rtt[T].id);
                  if (W.stamp === R.rtt[T].stamp) {
                    this.pool.useObject(W);
                    continue;
                  }
                }
                const z = this.pool.getOrCreateFreeObject();
                this.pool.useObject(z), this.pool.stampObject(z), R.rtt[T] = { id: z.id, stamp: z.stamp }, b.context.bindFramebuffer.set(z.fbo.framebuffer), b.context.clear({ color: s.bj.transparent, stencil: 0 }), b.currentStencilSource = void 0;
                for (let W = 0; W < I.length; W++) {
                  const U = b.style._layers[I[W]], X = U.source ? this._coordsAscending[U.source][R.tileID.key] : [R.tileID];
                  b.context.viewport.set([0, 0, z.fbo.width, z.fbo.height]), b._renderTileClippingMasks(U, X, true), b.renderLayer(b, b.style.tileManagers[U.source], U, X, d), U.source && (R.rttCoords[U.source] = this._coordsAscendingStr[U.source][R.tileID.key]);
                }
              }
              return wa(this.painter, this.terrain, this._rttTiles, d), this._rttTiles = [], this.pool.freeAllObjects(), Xr[g];
            }
            return false;
          }
        }
        const kl = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use \u2318 + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, Gu = S, qu = { hash: false, interactive: true, bearingSnap: 7, attributionControl: Ed, maplibreLogo: false, refreshExpiredTiles: true, canvasContextAttributes: { antialias: false, preserveDrawingBuffer: false, powerPreference: "high-performance", failIfMajorPerformanceCaveat: false, desynchronized: false, contextType: void 0 }, scrollZoom: true, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, trackResize: true, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: true, maxTileCacheSize: null, maxTileCacheZoomLevels: s.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, transformConstrain: null, fadeDuration: 300, crossSourceCollisions: true, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: true, rollEnabled: false, reduceMotion: void 0, validateStyle: true, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: true, centerClampedToGround: true, experimentalZoomLevelsToOverscale: void 0 }, Dd = { showCompass: true, showZoom: true, visualizePitch: false, visualizeRoll: true };
        class Rd {
          constructor(t, a, d = false) {
            this.mousedown = (b) => {
              this.startMove(b, N.mousePos(this.element, b)), N.addEventListener(window, "mousemove", this.mousemove), N.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (b) => {
              this.move(b, N.mousePos(this.element, b));
            }, this.mouseup = (b) => {
              this._rotatePitchHandler.dragEnd(b), this.offTemp();
            }, this.touchstart = (b) => {
              b.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = N.touchPos(this.element, b.targetTouches)[0], this.startMove(b, this._startPos), N.addEventListener(window, "touchmove", this.touchmove, { passive: false }), N.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (b) => {
              b.targetTouches.length !== 1 ? this.reset() : (this._lastPos = N.touchPos(this.element, b.targetTouches)[0], this.move(b, this._lastPos));
            }, this.touchend = (b) => {
              b.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10, this.element = a;
            const g = new $m();
            this._rotatePitchHandler = new Ps({ clickTolerance: 3, move: (b, w) => {
              const T = a.getBoundingClientRect(), I = new s.P((T.bottom - T.top) / 2, (T.right - T.left) / 2);
              return { bearingDelta: s.cr(new s.P(b.x, w.y), w, I), pitchDelta: d ? -0.5 * (w.y - b.y) : void 0 };
            }, moveStateManager: g, enable: true, assignEvents: () => {
            } }), this.map = t, N.addEventListener(a, "mousedown", this.mousedown), N.addEventListener(a, "touchstart", this.touchstart, { passive: false }), N.addEventListener(a, "touchcancel", this.reset);
          }
          startMove(t, a) {
            this._rotatePitchHandler.dragStart(t, a), N.disableDrag();
          }
          move(t, a) {
            const d = this.map, { bearingDelta: g, pitchDelta: b } = this._rotatePitchHandler.dragMove(t, a) || {};
            g && d.setBearing(d.getBearing() + g), b && d.setPitch(d.getPitch() + b);
          }
          off() {
            const t = this.element;
            N.removeEventListener(t, "mousedown", this.mousedown), N.removeEventListener(t, "touchstart", this.touchstart, { passive: false }), N.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), N.removeEventListener(window, "touchend", this.touchend), N.removeEventListener(t, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            N.enableDrag(), N.removeEventListener(window, "mousemove", this.mousemove), N.removeEventListener(window, "mouseup", this.mouseup), N.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), N.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let wo;
        function Wu(_, t, a, d = false) {
          if (d || !a.getCoveringTilesDetailsProvider().allowWorldCopies()) return _ == null ? void 0 : _.wrap();
          const g = new s.U(_.lng, _.lat);
          if (_ = new s.U(_.lng, _.lat), t) {
            const b = new s.U(_.lng - 360, _.lat), w = new s.U(_.lng + 360, _.lat), T = a.locationToScreenPoint(_).distSqr(t);
            a.locationToScreenPoint(b).distSqr(t) < T ? _ = b : a.locationToScreenPoint(w).distSqr(t) < T && (_ = w);
          }
          for (; Math.abs(_.lng - a.center.lng) > 180; ) {
            const b = a.locationToScreenPoint(_);
            if (b.x >= 0 && b.y >= 0 && b.x <= a.width && b.y <= a.height) break;
            _.lng > a.center.lng ? _.lng -= 360 : _.lng += 360;
          }
          return _.lng !== g.lng && a.isPointOnMapSurface(a.locationToScreenPoint(_)) ? _ : g;
        }
        const Tl = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function Zu(_, t, a) {
          const d = _.classList;
          for (const g in Tl) d.remove(`maplibregl-${a}-anchor-${g}`);
          d.add(`maplibregl-${a}-anchor-${t}`);
        }
        class Pl extends s.E {
          constructor(t) {
            if (super(), this._onKeyPress = (a) => {
              const d = a.code, g = a.charCode || a.keyCode;
              d !== "Space" && d !== "Enter" && g !== 32 && g !== 13 || this.togglePopup();
            }, this._onMapClick = (a) => {
              const d = a.originalEvent.target, g = this._element;
              this._popup && (d === g || g.contains(d)) && this.togglePopup();
            }, this._update = (a) => {
              if (!this._map) return;
              const d = this._map.loaded() && !this._map.isMoving();
              ((a == null ? void 0 : a.type) === "terrain" || (a == null ? void 0 : a.type) === "render" && !d) && this._map.once("render", this._update), this._lngLat = Wu(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
              let g = "";
              this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? g = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (g = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let b = "";
              this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? b = "rotateX(0deg)" : this._pitchAlignment === "map" && (b = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || a && a.type !== "moveend" || (this._pos = this._pos.round()), N.setTransform(this._element, `${Tl[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${b} ${g}`), j.frameAsync(new AbortController()).then((() => {
                this._updateOpacity(a && a.type === "moveend");
              })).catch((() => {
              }));
            }, this._onMove = (a) => {
              if (!this._isDragging) {
                const d = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = a.point.dist(this._pointerdownPos) >= d;
              }
              this._isDragging && (this._pos = a.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new s.l("dragstart"))), this.fire(new s.l("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new s.l("dragend")), this._state = "inactive";
            }, this._addDragHandler = (a) => {
              this._element.contains(a.originalEvent.target) && (a.preventDefault(), this._positionDelta = a.point.sub(this._pos).add(this._offset), this._pointerdownPos = a.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = t && t.anchor || "center", this._color = t && t.color || "#3FB1CE", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || false, this._clickTolerance = t && t.clickTolerance || 0, this._subpixelPositioning = t && t.subpixelPositioning || false, this._isDragging = false, this._state = "inactive", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || "auto", this._pitchAlignment = t && t.pitchAlignment && t.pitchAlignment !== "auto" ? t.pitchAlignment : this._rotationAlignment, this.setOpacity(t == null ? void 0 : t.opacity, t == null ? void 0 : t.opacityWhenCovered), t && t.element) this._element = t.element, this._offset = s.P.convert(t && t.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = N.create("div");
              const a = N.createNS("http://www.w3.org/2000/svg", "svg"), d = 41, g = 27;
              a.setAttributeNS(null, "display", "block"), a.setAttributeNS(null, "height", `${d}px`), a.setAttributeNS(null, "width", `${g}px`), a.setAttributeNS(null, "viewBox", `0 0 ${g} ${d}`);
              const b = N.createNS("http://www.w3.org/2000/svg", "g");
              b.setAttributeNS(null, "stroke", "none"), b.setAttributeNS(null, "stroke-width", "1"), b.setAttributeNS(null, "fill", "none"), b.setAttributeNS(null, "fill-rule", "evenodd");
              const w = N.createNS("http://www.w3.org/2000/svg", "g");
              w.setAttributeNS(null, "fill-rule", "nonzero");
              const T = N.createNS("http://www.w3.org/2000/svg", "g");
              T.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), T.setAttributeNS(null, "fill", "#000000");
              const I = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const me of I) {
                const Ce = N.createNS("http://www.w3.org/2000/svg", "ellipse");
                Ce.setAttributeNS(null, "opacity", "0.04"), Ce.setAttributeNS(null, "cx", "10.5"), Ce.setAttributeNS(null, "cy", "5.80029008"), Ce.setAttributeNS(null, "rx", me.rx), Ce.setAttributeNS(null, "ry", me.ry), T.appendChild(Ce);
              }
              const R = N.createNS("http://www.w3.org/2000/svg", "g");
              R.setAttributeNS(null, "fill", this._color);
              const z = N.createNS("http://www.w3.org/2000/svg", "path");
              z.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), R.appendChild(z);
              const W = N.createNS("http://www.w3.org/2000/svg", "g");
              W.setAttributeNS(null, "opacity", "0.25"), W.setAttributeNS(null, "fill", "#000000");
              const U = N.createNS("http://www.w3.org/2000/svg", "path");
              U.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), W.appendChild(U);
              const X = N.createNS("http://www.w3.org/2000/svg", "g");
              X.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), X.setAttributeNS(null, "fill", "#FFFFFF");
              const re = N.createNS("http://www.w3.org/2000/svg", "g");
              re.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const de = N.createNS("http://www.w3.org/2000/svg", "circle");
              de.setAttributeNS(null, "fill", "#000000"), de.setAttributeNS(null, "opacity", "0.25"), de.setAttributeNS(null, "cx", "5.5"), de.setAttributeNS(null, "cy", "5.5"), de.setAttributeNS(null, "r", "5.4999962");
              const fe = N.createNS("http://www.w3.org/2000/svg", "circle");
              fe.setAttributeNS(null, "fill", "#FFFFFF"), fe.setAttributeNS(null, "cx", "5.5"), fe.setAttributeNS(null, "cy", "5.5"), fe.setAttributeNS(null, "r", "5.4999962"), re.appendChild(de), re.appendChild(fe), w.appendChild(T), w.appendChild(R), w.appendChild(W), w.appendChild(X), w.appendChild(re), a.appendChild(w), a.setAttributeNS(null, "height", d * this._scale + "px"), a.setAttributeNS(null, "width", g * this._scale + "px"), this._element.appendChild(a), this._offset = s.P.convert(t && t.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", ((a) => {
              a.preventDefault();
            })), this._element.addEventListener("mousedown", ((a) => {
              a.preventDefault();
            })), Zu(this._element, this._anchor, "marker"), t && t.className) for (const a of t.className.split(" ")) this._element.classList.add(a);
            this._popup = null;
          }
          addTo(t) {
            return this.remove(), this._map = t, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", t._getUIString("Marker.Title")), this._element.hasAttribute("role") || this._element.setAttribute("role", "button"), t.getCanvasContainer().appendChild(this._element), t.on("move", this._update), t.on("moveend", this._update), t.on("terrain", this._update), t.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), N.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t) {
            return this._lngLat = s.U.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(t) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t) {
              if (!("offset" in t.options)) {
                const g = Math.abs(13.5) / Math.SQRT2;
                t.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [g, -1 * (38.1 - 13.5 + g)], "bottom-right": [-g, -1 * (38.1 - 13.5 + g)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
              }
              this._popup = t, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          setSubpixelPositioning(t) {
            return this._subpixelPositioning = t, this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const t = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : t ? (t.isOpen() ? t.remove() : (t.setLngLat(this._lngLat), t.addTo(this._map)), this) : this;
          }
          _updateOpacity(t = false) {
            var a, d;
            const g = (a = this._map) === null || a === void 0 ? void 0 : a.terrain, b = this._map.transform.isLocationOccluded(this._lngLat);
            if (!g || b) {
              const X = b ? this._opacityWhenCovered : this._opacity;
              return void (this._element.style.opacity !== X && (this._element.style.opacity = X));
            }
            if (t) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null;
              }), 100);
            }
            const w = this._map, T = w.terrain.depthAtPoint(this._pos), I = w.terrain.getElevationForLngLatZoom(this._lngLat, w.transform.tileZoom);
            if (w.transform.lngLatToCameraDepth(this._lngLat, I) - T < 6e-3) return void (this._element.style.opacity = this._opacity);
            const R = -this._offset.y / w.transform.pixelsPerMeter, z = Math.sin(w.getPitch() * Math.PI / 180) * R, W = w.terrain.depthAtPoint(new s.P(this._pos.x, this._pos.y - this._offset.y)), U = w.transform.lngLatToCameraDepth(this._lngLat, I + z) - W > 6e-3;
            !((d = this._popup) === null || d === void 0) && d.isOpen() && U && this._popup.remove(), this._element.style.opacity = U ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(t) {
            return this._offset = s.P.convert(t), this._update(), this;
          }
          addClassName(t) {
            this._element.classList.add(t);
          }
          removeClassName(t) {
            this._element.classList.remove(t);
          }
          toggleClassName(t) {
            return this._element.classList.toggle(t);
          }
          setDraggable(t) {
            return this._draggable = !!t, this._map && (t ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(t) {
            return this._rotation = t || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(t) {
            return this._rotationAlignment = t || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(t) {
            return this._pitchAlignment = t && t !== "auto" ? t : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(t, a) {
            return (this._opacity === void 0 || t === void 0 && a === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), t !== void 0 && (this._opacity = t), a !== void 0 && (this._opacityWhenCovered = a), this._map && this._updateOpacity(true), this;
          }
        }
        const Ad = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
        let Es = 0, Ya = false;
        const zd = { maxWidth: 100, unit: "metric" };
        function Hu(_, t, a) {
          const d = a && a.maxWidth || 100, g = _._container.clientHeight / 2, b = _._container.clientWidth / 2, w = _.unproject([b - d / 2, g]), T = _.unproject([b + d / 2, g]), I = Math.round(_.project(T).x - _.project(w).x), R = Math.min(d, I, _._container.clientWidth), z = w.distanceTo(T);
          if (a && a.unit === "imperial") {
            const W = 3.2808 * z;
            W > 5280 ? Ca(t, R, W / 5280, _._getUIString("ScaleControl.Miles")) : Ca(t, R, W, _._getUIString("ScaleControl.Feet"));
          } else a && a.unit === "nautical" ? Ca(t, R, z / 1852, _._getUIString("ScaleControl.NauticalMiles")) : z >= 1e3 ? Ca(t, R, z / 1e3, _._getUIString("ScaleControl.Kilometers")) : Ca(t, R, z, _._getUIString("ScaleControl.Meters"));
        }
        function Ca(_, t, a, d) {
          const g = (function(b) {
            const w = Math.pow(10, `${Math.floor(b)}`.length - 1);
            let T = b / w;
            return T = T >= 10 ? 10 : T >= 5 ? 5 : T >= 3 ? 3 : T >= 2 ? 2 : T >= 1 ? 1 : (function(I) {
              const R = Math.pow(10, Math.ceil(-Math.log(I) / Math.LN10));
              return Math.round(I * R) / R;
            })(T), w * T;
          })(a);
          _.style.width = t * (g / a) + "px", _.innerHTML = `${g}&nbsp;${d}`;
        }
        const Fd = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", subpixelPositioning: false, locationOccludedOpacity: void 0 }, Ld = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function Il(_) {
          if (_) {
            if (typeof _ == "number") {
              const t = Math.round(Math.abs(_) / Math.SQRT2);
              return { center: new s.P(0, 0), top: new s.P(0, _), "top-left": new s.P(t, t), "top-right": new s.P(-t, t), bottom: new s.P(0, -_), "bottom-left": new s.P(t, -t), "bottom-right": new s.P(-t, -t), left: new s.P(_, 0), right: new s.P(-_, 0) };
            }
            if (_ instanceof s.P || Array.isArray(_)) {
              const t = s.P.convert(_);
              return { center: t, top: t, "top-left": t, "top-right": t, bottom: t, "bottom-left": t, "bottom-right": t, left: t, right: t };
            }
            return { center: s.P.convert(_.center || [0, 0]), top: s.P.convert(_.top || [0, 0]), "top-left": s.P.convert(_["top-left"] || [0, 0]), "top-right": s.P.convert(_["top-right"] || [0, 0]), bottom: s.P.convert(_.bottom || [0, 0]), "bottom-left": s.P.convert(_["bottom-left"] || [0, 0]), "bottom-right": s.P.convert(_["bottom-right"] || [0, 0]), left: s.P.convert(_.left || [0, 0]), right: s.P.convert(_.right || [0, 0]) };
          }
          return Il(new s.P(0, 0));
        }
        const Bd = S;
        p.AJAXError = s.cD, p.Event = s.l, p.Evented = s.E, p.LngLat = s.U, p.MercatorCoordinate = s.a5, p.Point = s.P, p.addProtocol = s.cE, p.config = s.a, p.removeProtocol = s.cF, p.AttributionControl = so, p.BoxZoomHandler = Ef, p.CanvasSource = di, p.CooperativeGesturesHandler = Wt, p.DoubleClickZoomHandler = Id, p.DragPanHandler = Of, p.DragRotateHandler = xo, p.EdgeInsets = Hr, p.FullscreenControl = class extends s.E {
          constructor(_ = {}) {
            super(), this._onFullscreenChange = () => {
              var t;
              let a = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((t = a == null ? void 0 : a.shadowRoot) === null || t === void 0) && t.fullscreenElement; ) a = a.shadowRoot.fullscreenElement;
              a === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = false, _ && _.container && (_.container instanceof HTMLElement ? this._container = _.container : s.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(_) {
            return this._map = _, this._container || (this._container = this._map.getContainer()), this._controlContainer = N.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            N.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const _ = this._fullscreenButton = N.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            N.create("span", "maplibregl-ctrl-icon", _).setAttribute("aria-hidden", "true"), _.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const _ = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", _), this._fullscreenButton.title = _;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new s.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new s.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, p.GeoJSONSource = rt, p.GeolocateControl = class extends s.E {
          constructor(_) {
            super(), this._onSuccess = (t) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(t)) return this._setErrorState(), this.fire(new s.l("outofmaxbounds", t)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = t, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(t), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(t), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new s.l("geolocate", t)), this._finish();
              }
            }, this._updateCamera = (t) => {
              const a = new s.U(t.coords.longitude, t.coords.latitude), d = t.coords.accuracy, g = this._map.getBearing(), b = s.e({ bearing: g }, this.options.fitBoundsOptions), w = gt.fromLngLat(a, d);
              this._map.fitBounds(w, b, { geolocateSource: true });
            }, this._updateMarker = (t) => {
              if (t) {
                const a = new s.U(t.coords.longitude, t.coords.latitude);
                this._accuracyCircleMarker.setLngLat(a).addTo(this._map), this._userLocationDotMarker.setLngLat(a).addTo(this._map), this._accuracy = t.coords.accuracy, this._updateCircleRadiusIfNeeded();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onUpdate = () => {
              this._updateCircleRadiusIfNeeded();
            }, this._onError = (t) => {
              if (this._map) {
                if (t.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                  const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a), this._geolocationWatchID !== void 0 && this._clearWatch();
                } else {
                  if (t.code === 3 && Ya) return;
                  this._setErrorState();
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new s.l("error", t)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", ((t) => t.preventDefault())), this._geolocateButton = N.create("button", "maplibregl-ctrl-geolocate", this._container), N.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = true);
            }, this._finishSetupUI = (t) => {
              if (this._map) {
                if (t === false) {
                  s.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = true, this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a);
                } else {
                  const a = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = false, this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = N.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Pl({ element: this._dotElement }), this._circleElement = N.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Pl({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", ((a) => {
                  const d = (a == null ? void 0 : a[0]) instanceof ResizeObserverEntry;
                  a.geolocateSource || this._watchState !== "ACTIVE_LOCK" || d || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new s.l("trackuserlocationend")), this.fire(new s.l("userlocationlostfocus")));
                }));
              }
            }, this.options = s.e({}, Ad, _);
          }
          onAdd(_) {
            return this._map = _, this._container = N.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return s._(this, arguments, void 0, (function* (t = false) {
                if (wo !== void 0 && !t) return wo;
                if (window.navigator.permissions === void 0) return wo = !!window.navigator.geolocation, wo;
                try {
                  wo = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
                } catch {
                  wo = !!window.navigator.geolocation;
                }
                return wo;
              }));
            })().then(((t) => this._finishSetupUI(t))), this._container;
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), N.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, Es = 0, Ya = false;
          }
          _isOutOfMapMaxBounds(_) {
            const t = this._map.getMaxBounds(), a = _.coords;
            return t && (a.longitude < t.getWest() || a.longitude > t.getEast() || a.latitude < t.getSouth() || a.latitude > t.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
              case "OFF":
              case void 0:
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadiusIfNeeded() {
            const _ = this._userLocationDotMarker.getLngLat();
            if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && _)) return;
            const t = this._map.project(_), a = this._map.unproject([t.x + 100, t.y]), d = _.distanceTo(a) / 100, g = 2 * this._accuracy / d;
            this._circleElement.style.width = `${g.toFixed(2)}px`, this._circleElement.style.height = `${g.toFixed(2)}px`;
          }
          trigger() {
            if (!this._setup) return s.w("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new s.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Es--, Ya = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new s.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new s.l("trackuserlocationstart")), this.fire(new s.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let _;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Es++, Es > 1 ? (_ = { maximumAge: 6e5, timeout: 0 }, Ya = true) : (_ = this.options.positionOptions, Ya = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, _);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, p.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var _;
              const t = (_ = this._map.getProjection()) === null || _ === void 0 ? void 0 : _.type;
              this._map.setProjection(t !== "mercator" && t ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
            }, this._updateGlobeIcon = () => {
              var _;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((_ = this._map.getProjection()) === null || _ === void 0 ? void 0 : _.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
            };
          }
          onAdd(_) {
            return this._map = _, this._container = N.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = N.create("button", "maplibregl-ctrl-globe", this._container), N.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
          }
          onRemove() {
            N.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
          }
        }, p.Hash = wd, p.ImageSource = mt, p.KeyboardHandler = Ko, p.LngLatBounds = gt, p.LogoControl = Md, p.Map = class extends En {
          constructor(_) {
            var t, a;
            s.cA.mark(s.cB.create);
            const d = Object.assign(Object.assign(Object.assign({}, qu), _), { canvasContextAttributes: Object.assign(Object.assign({}, qu.canvasContextAttributes), _.canvasContextAttributes) });
            if (d.minZoom != null && d.maxZoom != null && d.minZoom > d.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (d.minPitch != null && d.maxPitch != null && d.minPitch > d.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (d.minPitch != null && d.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (d.maxPitch != null && d.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const g = new ei(), b = new On();
            if (d.minZoom !== void 0 && g.setMinZoom(d.minZoom), d.maxZoom !== void 0 && g.setMaxZoom(d.maxZoom), d.minPitch !== void 0 && g.setMinPitch(d.minPitch), d.maxPitch !== void 0 && g.setMaxPitch(d.maxPitch), d.renderWorldCopies !== void 0 && g.setRenderWorldCopies(d.renderWorldCopies), d.transformConstrain !== null && g.setConstrainOverride(d.transformConstrain), super(g, b, { bearingSnap: d.bearingSnap }), this._idleTriggered = false, this._crossFadingFactor = 1, this._renderTaskQueue = new jm(), this._controls = [], this._mapId = s.ab(), this._lostContextStyle = { style: null, images: null }, this._contextLost = (T) => {
              T.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.painter.destroy();
              for (const I of Object.values(this.style._layers)) if (I.type === "custom" && console.warn(`Custom layer with id '${I.id}' cannot be restored after WebGL context loss. You will need to re-add it manually after context restoration.`), I._listeners) for (const [R] of Object.entries(I._listeners)) console.warn(`Custom layer with id '${I.id}' had event listeners for event '${R}' which cannot be restored after WebGL context loss. You will need to re-add them manually after context restoration.`);
              this._lostContextStyle = this._getStyleAndImages(), this.style.destroy(), this.style = null, this.fire(new s.l("webglcontextlost", { originalEvent: T }));
            }, this._contextRestored = (T) => {
              this._lostContextStyle.style && this.setStyle(this._lostContextStyle.style, { diff: false }), this._lostContextStyle.images && (this.style.imageManager.images = this._lostContextStyle.images), this._setupPainter(), this.resize(), this._update(), this.fire(new s.l("webglcontextrestored", { originalEvent: T }));
            }, this._onMapScroll = (T) => {
              if (T.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = d.interactive, this._maxTileCacheSize = d.maxTileCacheSize, this._maxTileCacheZoomLevels = d.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, d.canvasContextAttributes), this._trackResize = d.trackResize === true, this._bearingSnap = d.bearingSnap, this._centerClampedToGround = d.centerClampedToGround, this._refreshExpiredTiles = d.refreshExpiredTiles === true, this._fadeDuration = d.fadeDuration, this._crossSourceCollisions = d.crossSourceCollisions === true, this._collectResourceTiming = d.collectResourceTiming === true, this._locale = Object.assign(Object.assign({}, kl), d.locale), this._clickTolerance = d.clickTolerance, this._overridePixelRatio = d.pixelRatio, this._maxCanvasSize = d.maxCanvasSize, this._zoomLevelsToOverscale = d.experimentalZoomLevelsToOverscale, this.transformCameraUpdate = d.transformCameraUpdate, this.transformConstrain = d.transformConstrain, this.cancelPendingTileRequestsWhileZooming = d.cancelPendingTileRequestsWhileZooming === true, d.reduceMotion !== void 0 && (j.prefersReducedMotion = d.reduceMotion), this._imageQueueHandle = ke.addThrottleControl((() => this.isMoving())), this._requestManager = new ve(d.transformRequest), typeof d.container == "string") {
              if (this._container = document.getElementById(d.container), !this._container) throw new Error(`Container '${d.container}' not found.`);
            } else {
              if (!(d.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = d.container;
            }
            if (d.maxBounds && this.setMaxBounds(d.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(false))), this.on("moveend", (() => this._update(false))), this.on("zoom", (() => this._update(true))), this.on("terrain", (() => {
              this.painter.terrainFacilitator.dirty = true, this._update(true);
            })), this.once("idle", (() => {
              this._idleTriggered = true;
            })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, false);
              let T = false;
              const I = xd(((R) => {
                this._trackResize && !this._removed && (this.resize(R), this.redraw());
              }), 50);
              this._resizeObserver = new ResizeObserver(((R) => {
                T ? I(R) : T = true;
              })), this._resizeObserver.observe(this._container);
            }
            this.handlers = new Uu(this, d), this._hash = d.hash && new wd(typeof d.hash == "string" && d.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: d.center, elevation: d.elevation, zoom: d.zoom, bearing: d.bearing, pitch: d.pitch, roll: d.roll }), d.bounds && (this.resize(), this.fitBounds(d.bounds, s.e({}, d.fitBoundsOptions, { duration: 0 }))));
            const w = typeof d.style == "string" || ((a = (t = d.style) === null || t === void 0 ? void 0 : t.projection) === null || a === void 0 ? void 0 : a.type) !== "globe";
            this.resize(null, w), this._localIdeographFontFamily = d.localIdeographFontFamily, this._validateStyle = d.validateStyle, d.style && this.setStyle(d.style, { localIdeographFontFamily: d.localIdeographFontFamily }), d.attributionControl && this.addControl(new so(typeof d.attributionControl == "boolean" ? void 0 : d.attributionControl)), d.maplibreLogo && this.addControl(new Md(), d.logoPosition), this.on("style.load", (() => {
              if (w || this._resizeTransform(), this.transform.unmodified) {
                const T = s.S(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(T);
              }
            })), this.on("data", ((T) => {
              this._update(T.dataType === "style"), this.fire(new s.l(`${T.dataType}data`, T));
            })), this.on("dataloading", ((T) => {
              this.fire(new s.l(`${T.dataType}dataloading`, T));
            })), this.on("dataabort", ((T) => {
              this.fire(new s.l("sourcedataabort", T));
            }));
          }
          _getMapId() {
            return this._mapId;
          }
          setGlobalStateProperty(_, t) {
            return this.style.setGlobalStateProperty(_, t), this._update(true);
          }
          getGlobalState() {
            return this.style.getGlobalState();
          }
          addControl(_, t) {
            if (t === void 0 && (t = _.getDefaultPosition ? _.getDefaultPosition() : "top-right"), !_ || !_.onAdd) return this.fire(new s.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const a = _.onAdd(this);
            this._controls.push(_);
            const d = this._controlPositions[t];
            return t.indexOf("bottom") !== -1 ? d.insertBefore(a, d.firstChild) : d.appendChild(a), this;
          }
          removeControl(_) {
            if (!_ || !_.onRemove) return this.fire(new s.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const t = this._controls.indexOf(_);
            return t > -1 && this._controls.splice(t, 1), _.onRemove(this), this;
          }
          hasControl(_) {
            return this._controls.indexOf(_) > -1;
          }
          coveringTiles(_) {
            return sr(this.transform, _);
          }
          calculateCameraOptionsFromTo(_, t, a, d) {
            return d == null && this.terrain && (d = this.terrain.getElevationForLngLatZoom(a, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(_, t, a, d);
          }
          resize(_, t = true) {
            const [a, d] = this._containerDimensions(), g = this._getClampedPixelRatio(a, d);
            if (this._resizeCanvas(a, d, g), this.painter.resize(a, d, g), this.painter.overLimit()) {
              const w = this.painter.context.gl;
              this._maxCanvasSize = [w.drawingBufferWidth, w.drawingBufferHeight];
              const T = this._getClampedPixelRatio(a, d);
              this._resizeCanvas(a, d, T), this.painter.resize(a, d, T);
            }
            this._resizeTransform(t);
            const b = !this._moving;
            return b && (this.stop(), this.fire(new s.l("movestart", _)).fire(new s.l("move", _))), this.fire(new s.l("resize", _)), b && this.fire(new s.l("moveend", _)), this;
          }
          _resizeTransform(_ = true) {
            var t;
            const [a, d] = this._containerDimensions();
            this.transform.resize(a, d, _), (t = this._requestedCameraState) === null || t === void 0 || t.resize(a, d, _);
          }
          _getClampedPixelRatio(_, t) {
            const { 0: a, 1: d } = this._maxCanvasSize, g = this.getPixelRatio(), b = _ * g, w = t * g;
            return Math.min(b > a ? a / b : 1, w > d ? d / w : 1) * g;
          }
          getPixelRatio() {
            var _;
            return (_ = this._overridePixelRatio) !== null && _ !== void 0 ? _ : devicePixelRatio;
          }
          setPixelRatio(_) {
            this._overridePixelRatio = _, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(_) {
            return this.transform.setMaxBounds(gt.convert(_)), this._update();
          }
          setMinZoom(_) {
            if ((_ = _ ?? -2) >= -2 && _ <= this.transform.maxZoom) return this.transform.setMinZoom(_), this._update(), this.getZoom() < _ && this.setZoom(_), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(_) {
            if ((_ = _ ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(_), this._update(), this.getZoom() > _ && this.setZoom(_), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(_) {
            if ((_ = _ ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (_ >= 0 && _ <= this.transform.maxPitch) return this.transform.setMinPitch(_), this._update(), this.getPitch() < _ && this.setPitch(_), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(_) {
            if ((_ = _ ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (_ >= this.transform.minPitch) return this.transform.setMaxPitch(_), this._update(), this.getPitch() > _ && this.setPitch(_), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(_) {
            return this.transform.setRenderWorldCopies(_), this._update();
          }
          setTransformConstrain(_) {
            return this.transform.setConstrainOverride(_), this._update();
          }
          project(_) {
            return this.transform.locationToScreenPoint(s.U.convert(_), this.style && this.terrain);
          }
          unproject(_) {
            return this.transform.screenPointToLocation(s.P.convert(_), this.terrain);
          }
          isMoving() {
            var _;
            return this._moving || ((_ = this.handlers) === null || _ === void 0 ? void 0 : _.isMoving());
          }
          isZooming() {
            var _;
            return this._zooming || ((_ = this.handlers) === null || _ === void 0 ? void 0 : _.isZooming());
          }
          isRotating() {
            var _;
            return this._rotating || ((_ = this.handlers) === null || _ === void 0 ? void 0 : _.isRotating());
          }
          _createDelegatedListener(_, t, a) {
            if (_ === "mouseenter" || _ === "mouseover") {
              let d = false;
              return { layers: t, listener: a, delegates: { mousemove: (b) => {
                const w = t.filter(((I) => this.getLayer(I))), T = w.length !== 0 ? this.queryRenderedFeatures(b.point, { layers: w }) : [];
                T.length ? d || (d = true, a.call(this, new _i(_, this, b.originalEvent, { features: T }))) : d = false;
              }, mouseout: () => {
                d = false;
              } } };
            }
            if (_ === "mouseleave" || _ === "mouseout") {
              let d = false;
              return { layers: t, listener: a, delegates: { mousemove: (w) => {
                const T = t.filter(((I) => this.getLayer(I)));
                (T.length !== 0 ? this.queryRenderedFeatures(w.point, { layers: T }) : []).length ? d = true : d && (d = false, a.call(this, new _i(_, this, w.originalEvent)));
              }, mouseout: (w) => {
                d && (d = false, a.call(this, new _i(_, this, w.originalEvent)));
              } } };
            }
            {
              const d = (g) => {
                const b = t.filter(((T) => this.getLayer(T))), w = b.length !== 0 ? this.queryRenderedFeatures(g.point, { layers: b }) : [];
                w.length && (g.features = w, a.call(this, g), delete g.features);
              };
              return { layers: t, listener: a, delegates: { [_]: d } };
            }
          }
          _saveDelegatedListener(_, t) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[_] = this._delegatedListeners[_] || [], this._delegatedListeners[_].push(t);
          }
          _removeDelegatedListener(_, t, a) {
            if (!this._delegatedListeners || !this._delegatedListeners[_]) return;
            const d = this._delegatedListeners[_];
            for (let g = 0; g < d.length; g++) {
              const b = d[g];
              if (b.listener === a && b.layers.length === t.length && b.layers.every(((w) => t.includes(w)))) {
                for (const w in b.delegates) this.off(w, b.delegates[w]);
                return void d.splice(g, 1);
              }
            }
          }
          on(_, t, a) {
            if (a === void 0) return super.on(_, t);
            const d = typeof t == "string" ? [t] : t, g = this._createDelegatedListener(_, d, a);
            this._saveDelegatedListener(_, g);
            for (const b in g.delegates) this.on(b, g.delegates[b]);
            return { unsubscribe: () => {
              this._removeDelegatedListener(_, d, a);
            } };
          }
          once(_, t, a) {
            if (a === void 0) return super.once(_, t);
            const d = typeof t == "string" ? [t] : t, g = this._createDelegatedListener(_, d, a);
            for (const b in g.delegates) {
              const w = g.delegates[b];
              g.delegates[b] = (...T) => {
                this._removeDelegatedListener(_, d, a), w(...T);
              };
            }
            this._saveDelegatedListener(_, g);
            for (const b in g.delegates) this.once(b, g.delegates[b]);
            return this;
          }
          off(_, t, a) {
            return a === void 0 ? super.off(_, t) : (this._removeDelegatedListener(_, typeof t == "string" ? [t] : t, a), this);
          }
          queryRenderedFeatures(_, t) {
            if (!this.style) return [];
            let a;
            const d = _ instanceof s.P || Array.isArray(_), g = d ? _ : [[0, 0], [this.transform.width, this.transform.height]];
            if (t = t || (d ? {} : _) || {}, g instanceof s.P || typeof g[0] == "number") a = [s.P.convert(g)];
            else {
              const b = s.P.convert(g[0]), w = s.P.convert(g[1]);
              a = [b, new s.P(w.x, b.y), w, new s.P(b.x, w.y), b];
            }
            return this.style.queryRenderedFeatures(a, t, this.transform);
          }
          querySourceFeatures(_, t) {
            return this.style.querySourceFeatures(_, t);
          }
          setStyle(_, t) {
            return (t = s.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, t)).diff !== false && t.localIdeographFontFamily === this._localIdeographFontFamily && this.style && _ ? (this._diffStyle(_, t), this) : (this._localIdeographFontFamily = t.localIdeographFontFamily, this._updateStyle(_, t));
          }
          setTransformRequest(_) {
            return this._requestManager.setTransformRequest(_), this;
          }
          _getUIString(_) {
            const t = this._locale[_];
            if (t == null) throw new Error(`Missing UI string '${_}'`);
            return t;
          }
          _updateStyle(_, t) {
            var a, d;
            if (t.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(_, t)));
            const g = this.style && t.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!_)), _ ? (this.style = new il(this, t || {}), this.style.setEventedParent(this, { style: this.style }), typeof _ == "string" ? this.style.loadURL(_, t, g) : this.style.loadJSON(_, t, g), this) : ((d = (a = this.style) === null || a === void 0 ? void 0 : a.projection) === null || d === void 0 || d.destroy(), delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new il(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(_, t) {
            if (typeof _ == "string") {
              const a = this._requestManager.transformRequest(_, "Style");
              s.j(a, new AbortController()).then(((d) => {
                this._updateDiff(d.data, t);
              })).catch(((d) => {
                d && this.fire(new s.k(d));
              }));
            } else typeof _ == "object" && this._updateDiff(_, t);
          }
          _updateDiff(_, t) {
            try {
              this.style.setState(_, t) && this._update(true);
            } catch (a) {
              s.w(`Unable to perform style diff: ${a.message || a.error || a}.  Rebuilding the style from scratch.`), this._updateStyle(_, t);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          _getStyleAndImages() {
            return this.style ? { style: this.style.serialize(), images: this.style.imageManager.cloneImages() } : { style: null, images: {} };
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : s.w("There is no style added to the map.");
          }
          addSource(_, t) {
            return this._lazyInitEmptyStyle(), this.style.addSource(_, t), this._update(true);
          }
          isSourceLoaded(_) {
            const t = this.style && this.style.tileManagers[_];
            if (t !== void 0) return t.loaded();
            this.fire(new s.k(new Error(`There is no tile manager with ID '${_}'`)));
          }
          setTerrain(_) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), _) {
              const t = this.style.tileManagers[_.source];
              if (!t) throw new Error(`cannot load terrain, because there exists no source with ID: ${_.source}`);
              this.terrain === null && t.reload();
              for (const a in this.style._layers) {
                const d = this.style._layers[a];
                d.type === "hillshade" && d.source === _.source && s.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), d.type === "color-relief" && d.source === _.source && s.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new Sl(this.painter, t, _), this.painter.renderToTexture = new $f(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (a) => {
                var d;
                a.dataType === "style" ? this.terrain.tileManager.freeRtt() : a.dataType === "source" && a.tile && (a.sourceId !== _.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((d = a.source) === null || d === void 0 ? void 0 : d.type) === "image" ? this.terrain.tileManager.freeRtt() : this.terrain.tileManager.freeRtt(a.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.tileManager.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new s.l("terrain", { terrain: _ })), this;
          }
          getTerrain() {
            var _, t;
            return (t = (_ = this.terrain) === null || _ === void 0 ? void 0 : _.options) !== null && t !== void 0 ? t : null;
          }
          areTilesLoaded() {
            const _ = this.style && this.style.tileManagers;
            for (const t in _) {
              const a = _[t]._tiles;
              for (const d in a) {
                const g = a[d];
                if (g.state !== "loaded" && g.state !== "errored") return false;
              }
            }
            return true;
          }
          removeSource(_) {
            return this.style.removeSource(_), this._update(true);
          }
          getSource(_) {
            return this.style.getSource(_);
          }
          setSourceTileLodParams(_, t, a) {
            if (a) {
              const d = this.getSource(a);
              if (!d) throw new Error(`There is no source with ID "${a}", cannot set LOD parameters`);
              d.calculateTileZoom = tt(Math.max(1, _), Math.max(1, t));
            } else for (const d in this.style.tileManagers) this.style.tileManagers[d].getSource().calculateTileZoom = tt(Math.max(1, _), Math.max(1, t));
            return this._update(true), this;
          }
          refreshTiles(_, t) {
            const a = this.style.tileManagers[_];
            if (!a) throw new Error(`There is no tile manager with ID "${_}", cannot refresh tile`);
            t === void 0 ? a.reload(true) : a.refreshTiles(t.map(((d) => new s.a8(d.z, d.x, d.y))));
          }
          addImage(_, t, a = {}) {
            const { pixelRatio: d = 1, sdf: g = false, stretchX: b, stretchY: w, content: T, textFitWidth: I, textFitHeight: R } = a;
            if (this._lazyInitEmptyStyle(), !(t instanceof HTMLImageElement || s.b(t))) {
              if (t.width === void 0 || t.height === void 0) return this.fire(new s.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: z, height: W, data: U } = t, X = t;
                return this.style.addImage(_, { data: new s.R({ width: z, height: W }, new Uint8Array(U)), pixelRatio: d, stretchX: b, stretchY: w, content: T, textFitWidth: I, textFitHeight: R, sdf: g, version: 0, userImage: X }), X.onAdd && X.onAdd(this, _), this;
              }
            }
            {
              const { width: z, height: W, data: U } = j.getImageData(t);
              this.style.addImage(_, { data: new s.R({ width: z, height: W }, U), pixelRatio: d, stretchX: b, stretchY: w, content: T, textFitWidth: I, textFitHeight: R, sdf: g, version: 0 });
            }
          }
          updateImage(_, t) {
            const a = this.style.getImage(_);
            if (!a) return this.fire(new s.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const d = t instanceof HTMLImageElement || s.b(t) ? j.getImageData(t) : t, { width: g, height: b, data: w } = d;
            if (g === void 0 || b === void 0) return this.fire(new s.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (g !== a.data.width || b !== a.data.height) return this.fire(new s.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const T = !(t instanceof HTMLImageElement || s.b(t));
            return a.data.replace(w, T), this.style.updateImage(_, a), this;
          }
          getImage(_) {
            return this.style.getImage(_);
          }
          hasImage(_) {
            return _ ? !!this.style.getImage(_) : (this.fire(new s.k(new Error("Missing required image id"))), false);
          }
          removeImage(_) {
            this.style.removeImage(_);
          }
          loadImage(_) {
            return ke.getImage(this._requestManager.transformRequest(_, "Image"), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(_, t) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(_, t), this._update(true);
          }
          moveLayer(_, t) {
            return this.style.moveLayer(_, t), this._update(true);
          }
          removeLayer(_) {
            return this.style.removeLayer(_), this._update(true);
          }
          getLayer(_) {
            return this.style.getLayer(_);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(_, t, a) {
            return this.style.setLayerZoomRange(_, t, a), this._update(true);
          }
          setFilter(_, t, a = {}) {
            return this.style.setFilter(_, t, a), this._update(true);
          }
          getFilter(_) {
            return this.style.getFilter(_);
          }
          setPaintProperty(_, t, a, d = {}) {
            return this.style.setPaintProperty(_, t, a, d), this._update(true);
          }
          getPaintProperty(_, t) {
            return this.style.getPaintProperty(_, t);
          }
          setLayoutProperty(_, t, a, d = {}) {
            return this.style.setLayoutProperty(_, t, a, d), this._update(true);
          }
          getLayoutProperty(_, t) {
            return this.style.getLayoutProperty(_, t);
          }
          setGlyphs(_, t = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(_, t), this._update(true);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(_, t, a = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(_, t, a, ((d) => {
              d || this._update(true);
            })), this;
          }
          removeSprite(_) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(_), this._update(true);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(_, t = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(_, t, ((a) => {
              a || this._update(true);
            })), this;
          }
          setLight(_, t = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(_, t), this._update(true);
          }
          getLight() {
            return this.style.getLight();
          }
          setSky(_, t = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(_, t), this._update(true);
          }
          getSky() {
            return this.style.getSky();
          }
          setFeatureState(_, t) {
            return this.style.setFeatureState(_, t), this._update();
          }
          removeFeatureState(_, t) {
            return this.style.removeFeatureState(_, t), this._update();
          }
          getFeatureState(_) {
            return this.style.getFeatureState(_);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let _ = 0, t = 0;
            return this._container && (_ = this._container.clientWidth || 400, t = this._container.clientHeight || 300), [_, t];
          }
          _setupContainer() {
            const _ = this._container;
            _.classList.add("maplibregl-map");
            const t = this._canvasContainer = N.create("div", "maplibregl-canvas-container", _);
            this._interactive && t.classList.add("maplibregl-interactive"), this._canvas = N.create("canvas", "maplibregl-canvas", t), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const a = this._containerDimensions(), d = this._getClampedPixelRatio(a[0], a[1]);
            this._resizeCanvas(a[0], a[1], d);
            const g = this._controlContainer = N.create("div", "maplibregl-control-container", _), b = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(((w) => {
              b[w] = N.create("div", `maplibregl-ctrl-${w} `, g);
            })), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _resizeCanvas(_, t, a) {
            this._canvas.width = Math.floor(a * _), this._canvas.height = Math.floor(a * t), this._canvas.style.width = `${_}px`, this._canvas.style.height = `${t}px`;
          }
          _setupPainter() {
            const _ = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: true, depth: true, stencil: true, premultipliedAlpha: true });
            let t = null;
            this._canvas.addEventListener("webglcontextcreationerror", ((d) => {
              t = { requestedAttributes: _ }, d && (t.statusMessage = d.statusMessage, t.type = d.type);
            }), { once: true });
            let a = null;
            if (a = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, _) : this._canvas.getContext("webgl2", _) || this._canvas.getContext("webgl", _), !a) {
              const d = "Failed to initialize WebGL";
              throw t ? (t.message = d, new Error(JSON.stringify(t))) : new Error(d);
            }
            this.painter = new Sf(a, this.transform), J.testSupport(a);
          }
          migrateProjection(_, t) {
            super.migrateProjection(_, t), this.painter.transform = _, this.fire(new s.l("projectiontransition", { newProjection: this.style.projection.name }));
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(_) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || _, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(_) {
            return this._update(), this._renderTaskQueue.add(_);
          }
          _cancelRenderFrame(_) {
            this._renderTaskQueue.remove(_);
          }
          _render(_) {
            var t, a, d, g, b;
            const w = this._idleTriggered ? this._fadeDuration : 0, T = ((t = this.style.projection) === null || t === void 0 ? void 0 : t.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(_), this._removed) return;
            let I = false;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const W = this.transform.zoom, U = q();
              this.style.zoomHistory.update(W, U);
              const X = new s.G(W, { now: U, fadeDuration: w, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), re = X.crossFadingFactor();
              re === 1 && re === this._crossFadingFactor || (I = true, this._crossFadingFactor = re), this.style.update(X);
            }
            const R = ((a = this.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0 !== T;
            (d = this.style.projection) === null || d === void 0 || d.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((g = this.style.projection) === null || g === void 0 ? void 0 : g.transitionState, (b = this.style.projection) === null || b === void 0 ? void 0 : b.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || R) && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.tileManager.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, w, this._crossSourceCollisions, R), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: w, showPadding: this.showPadding }), this.fire(new s.l("render")), this.loaded() && !this._loaded && (this._loaded = true, s.cA.mark(s.cB.load), this.fire(new s.l("load"))), this.style && (this.style.hasTransitions() || I) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const z = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return z || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new s.l("idle")), !this._loaded || this._fullyLoaded || z || (this._fullyLoaded = true, s.cA.mark(s.cB.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var _;
            this._hash && this._hash.remove();
            for (const a of this._controls) a.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, false), ke.removeThrottleControl(this._imageQueueHandle), (_ = this._resizeObserver) === null || _ === void 0 || _.disconnect();
            const t = this.painter.context.gl.getExtension("WEBGL_lose_context");
            (t == null ? void 0 : t.loseContext) && t.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), N.remove(this._canvasContainer), N.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, false), this._container.classList.remove("maplibregl-map"), s.cA.clearMetrics(), this._removed = true, this.fire(new s.l("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), j.frame(this._frameRequest, ((_) => {
              s.cA.frame(_), this._frameRequest = null;
              try {
                this._render(_);
              } catch (t) {
                if (!s.cC(t) && !(function(a) {
                  return a.message === Pu;
                })(t)) throw t;
              }
            }), (() => {
            })));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(_) {
            this._showTileBoundaries !== _ && (this._showTileBoundaries = _, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(_) {
            this._showPadding !== _ && (this._showPadding = _, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(_) {
            this._showCollisionBoxes !== _ && (this._showCollisionBoxes = _, _ ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(_) {
            this._showOverdrawInspector !== _ && (this._showOverdrawInspector = _, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(_) {
            this._repaint !== _ && (this._repaint = _, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(_) {
            this._vertices = _, this._update();
          }
          get version() {
            return Gu;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
          getProjection() {
            return this.style.getProjection();
          }
          setProjection(_) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(_), this._update(true);
          }
        }, p.MapMouseEvent = _i, p.MapTouchEvent = vl, p.MapWheelEvent = Xa, p.Marker = Pl, p.NavigationControl = class {
          constructor(_) {
            this._updateZoomButtons = () => {
              const t = this._map.getZoom(), a = t === this._map.getMaxZoom(), d = t === this._map.getMinZoom();
              this._zoomInButton.disabled = a, this._zoomOutButton.disabled = d, this._zoomInButton.setAttribute("aria-disabled", a.toString()), this._zoomOutButton.setAttribute("aria-disabled", d.toString());
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
            }, this._setButtonTitle = (t, a) => {
              const d = this._map._getUIString(`NavigationControl.${a}`);
              t.title = d, t.setAttribute("aria-label", d);
            }, this.options = s.e({}, Dd, _), this._container = N.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", ((t) => t.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", ((t) => this._map.zoomIn({}, { originalEvent: t }))), N.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", ((t) => this._map.zoomOut({}, { originalEvent: t }))), N.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", ((t) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t }) : this._map.resetNorth({}, { originalEvent: t });
            })), this._compassIcon = N.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(_) {
            return this._map = _, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Rd(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            N.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(_, t) {
            const a = N.create("button", _, this._container);
            return a.type = "button", a.addEventListener("click", t), a;
          }
        }, p.Popup = class extends s.E {
          constructor(_) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "");
            }, this.remove = () => (this._content && N.remove(this._content), this._container && (N.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new s.l("close"))), this), this._onMouseUp = (t) => {
              this._update(t.point);
            }, this._onMouseMove = (t) => {
              this._update(t.point);
            }, this._onDrag = (t) => {
              this._update(t.point);
            }, this._update = (t) => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = N.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = N.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const w of this.options.className.split(" ")) this._container.classList.add(w);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = Wu(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !t) return;
              const a = this._flatPos = this._pos = this._trackPointer && t ? t : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && t ? t : this._map.transform.locationToScreenPoint(this._lngLat));
              let d = this.options.anchor;
              const g = Il(this.options.offset);
              if (!d) {
                const w = this._container.offsetWidth, T = this._container.offsetHeight;
                let I;
                I = a.y + g.bottom.y < T ? ["top"] : a.y > this._map.transform.height - T ? ["bottom"] : [], a.x < w / 2 ? I.push("left") : a.x > this._map.transform.width - w / 2 && I.push("right"), d = I.length === 0 ? "bottom" : I.join("-");
              }
              let b = a.add(g[d]);
              this.options.subpixelPositioning || (b = b.round()), N.setTransform(this._container, `${Tl[d]} translate(${b.x}px,${b.y}px)`), Zu(this._container, d, "popup"), this._updateOpacity();
            }, this._onClose = () => {
              this.remove();
            }, this.options = s.e(Object.create(Fd), _);
          }
          addTo(_) {
            return this._map && this.remove(), this._map = _, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new s.l("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(_) {
            return this._lngLat = s.U.convert(_), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(_) {
            return this.setDOMContent(document.createTextNode(_));
          }
          setHTML(_) {
            const t = document.createDocumentFragment(), a = document.createElement("body");
            let d;
            for (a.innerHTML = _; d = a.firstChild, d; ) t.appendChild(d);
            return this.setDOMContent(t);
          }
          getMaxWidth() {
            var _;
            return (_ = this._container) === null || _ === void 0 ? void 0 : _.style.maxWidth;
          }
          setMaxWidth(_) {
            return this.options.maxWidth = _, this._update(), this;
          }
          setDOMContent(_) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = N.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(_), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(_) {
            return this._container && this._container.classList.add(_), this;
          }
          removeClassName(_) {
            return this._container && this._container.classList.remove(_), this;
          }
          setOffset(_) {
            return this.options.offset = _, this._update(), this;
          }
          toggleClassName(_) {
            if (this._container) return this._container.classList.toggle(_);
          }
          setSubpixelPositioning(_) {
            this.options.subpixelPositioning = _;
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = N.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const _ = this._container.querySelector(Ld);
            _ && _.focus();
          }
        }, p.RasterDEMTileSource = Ye, p.RasterTileSource = $e, p.ScaleControl = class {
          constructor(_) {
            this._onMove = () => {
              Hu(this._map, this._container, this.options);
            }, this.setUnit = (t) => {
              this.options.unit = t, Hu(this._map, this._container, this.options);
            }, this.options = Object.assign(Object.assign({}, zd), _);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(_) {
            return this._map = _, this._container = N.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", _.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            N.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, p.ScrollZoomHandler = ju, p.Style = il, p.TerrainControl = class {
          constructor(_) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = _;
          }
          onAdd(_) {
            return this._map = _, this._container = N.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = N.create("button", "maplibregl-ctrl-terrain", this._container), N.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            N.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, p.TwoFingersTouchPitchHandler = zf, p.TwoFingersTouchRotateHandler = Af, p.TwoFingersTouchZoomHandler = Rf, p.TwoFingersTouchZoomRotateHandler = wl, p.VectorTileSource = ot, p.VideoSource = nr, p.addSourceType = (_, t) => s._(void 0, void 0, void 0, (function* () {
          if (xn(_)) throw new Error(`A source type called "${_}" already exists.`);
          ((a, d) => {
            wi[a] = d;
          })(_, t);
        })), p.clearPrewarmedResources = function() {
          const _ = Dt;
          _ && (_.isPreloaded() && _.numActive() === 1 ? (_.release(Nt), Dt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, p.createTileMesh = du, p.getMaxParallelImageRequests = function() {
          return s.a.MAX_PARALLEL_IMAGE_REQUESTS;
        }, p.getRTLTextPluginStatus = function() {
          return Bi().getRTLTextPluginStatus();
        }, p.getVersion = function() {
          return Bd;
        }, p.getWorkerCount = function() {
          return ir.workerCount;
        }, p.getWorkerUrl = function() {
          return s.a.WORKER_URL;
        }, p.importScriptInWorkers = function(_) {
          return Pr().broadcast("IS", _);
        }, p.isTimeFrozen = function() {
          return L.isFrozen();
        }, p.now = q, p.prewarm = function() {
          dr().acquire(Nt);
        }, p.restoreNow = function() {
          L.restoreNow();
        }, p.setMaxParallelImageRequests = function(_) {
          s.a.MAX_PARALLEL_IMAGE_REQUESTS = _;
        }, p.setNow = function(_) {
          L.setNow(_);
        }, p.setRTLTextPlugin = function(_, t) {
          return Bi().setRTLTextPlugin(_, t);
        }, p.setWorkerCount = function(_) {
          ir.workerCount = _;
        }, p.setWorkerUrl = function(_) {
          s.a.WORKER_URL = _;
        };
      }));
      var y = l;
      return y;
    }));
  })(Np)), Np.exports;
}
var Jl = bI();
/*!
* @indoorequal/vue-maplibre-gl v8.4.2
* (c) 2025 Franois de Metz <francois@2metz.fr>
* @license MIT
*/
const xI = Symbol("map"), eu = xI, Vh = Symbol("isLoaded"), wI = Symbol("isInitialized"), zx = wI, uv = Symbol("componentId"), cv = Symbol("sourceId"), Fx = Symbol("sourceLayerRegistry"), CI = Symbol("marker"), SI = ["error", "load", "idle", "remove", "render", "resize", "webglcontextlost", "webglcontextrestored", "dataloading", "data", "tiledataloading", "sourcedataloading", "styledataloading", "sourcedata", "styledata", "styleimagemissing", "dataabort", "sourcedataabort", "boxzoomcancel", "boxzoomstart", "boxzoomend", "touchcancel", "touchmove", "touchend", "touchstart", "click", "contextmenu", "dblclick", "mousemove", "mouseup", "mousedown", "mouseout", "mouseover", "movestart", "move", "moveend", "zoomstart", "zoom", "zoomend", "rotatestart", "rotate", "rotateend", "dragstart", "drag", "dragend", "pitchstart", "pitch", "pitchend", "wheel", "terrain", "cooperativegestureprevented"];
function kI(r, n, l, h) {
  return (f) => l.emit(h, { type: f.type, map: n, component: r, event: f });
}
function TI(r, n) {
  const l = Jl.LngLat.convert(r), h = Jl.LngLat.convert(n);
  return l.lng === h.lng && l.lat === h.lat;
}
var mm = ((r) => (r.TOP_LEFT = "top-left", r.TOP_RIGHT = "top-right", r.BOTTOM_LEFT = "bottom-left", r.BOTTOM_RIGHT = "bottom-right", r))(mm || {});
const Uh = Object.values(mm), gb = /* @__PURE__ */ new Map(), PI = Symbol("default");
function II(r, n, l = PI) {
  var _a2;
  let h = gb.get(l);
  return h || (h = r3({ isLoaded: false, isMounted: false, language: null }), gb.set(l, h)), h.isLoaded = ((_a2 = n.value) == null ? void 0 : _a2.loaded()) || false, h.isMounted = false, h.component = r, h.map = n.value, h;
}
const Lx = nt({ name: "MglMap", props: { width: { type: [Number, String], default: "100%" }, height: { type: [Number, String], default: "100%" }, attributionControl: { type: [Boolean, Object], default: void 0 }, bearing: { type: Number }, bearingSnap: { type: Number }, bounds: { type: [Array, Object] }, boxZoom: { type: Boolean, default: void 0 }, center: { type: [Array, Object] }, clickTolerance: { type: Number }, collectResourceTiming: { type: Boolean, default: void 0 }, crossSourceCollisions: { type: Boolean, default: void 0 }, dragPan: { type: Boolean, default: void 0 }, dragRotate: { type: Boolean, default: void 0 }, doubleClickZoom: { type: Boolean, default: void 0 }, hash: { type: [Boolean, String], default: void 0 }, fadeDuration: { type: Number }, fitBoundsOptions: { type: Object }, interactive: { type: Boolean, default: void 0 }, keyboard: { type: Boolean, default: void 0 }, locale: { type: Object }, localIdeographFontFamily: { type: String }, logoPosition: { type: [String], validator: (r) => r in mm }, maxBounds: { type: [Array, Object] }, maxPitch: { type: Number }, maxZoom: { type: Number }, minPitch: { type: Number }, minZoom: { type: Number }, pitch: { type: Number }, pitchWithRotate: { type: Boolean, default: void 0 }, canvasContextAttributes: { type: Object }, refreshExpiredTiles: { type: Boolean, default: void 0 }, renderWorldCopies: { type: Boolean, default: void 0 }, scrollZoom: { type: Boolean, default: void 0 }, mapStyle: { type: [String, Object] }, trackResize: { type: Boolean, default: void 0 }, transformRequest: { type: Function }, transformCameraUpdate: { type: Function }, touchZoomRotate: { type: Boolean, default: void 0 }, touchPitch: { type: Boolean, default: void 0 }, zoom: { type: Number }, maxTileCacheSize: { type: Number }, mapKey: { type: [String, Symbol] }, pixelRatio: { type: Number }, validateStyle: { type: Boolean, default: void 0 }, cooperativeGestures: { type: Boolean } }, emits: ["map:error", "map:load", "map:idle", "map:remove", "map:render", "map:resize", "map:webglcontextlost", "map:webglcontextrestored", "map:dataloading", "map:data", "map:tiledataloading", "map:sourcedataloading", "map:styledataloading", "map:sourcedata", "map:styledata", "map:styleimagemissing", "map:dataabort", "map:sourcedataabort", "map:boxzoomcancel", "map:boxzoomstart", "map:boxzoomend", "map:touchcancel", "map:touchmove", "map:touchend", "map:touchstart", "map:click", "map:contextmenu", "map:dblclick", "map:mousemove", "map:mouseup", "map:mousedown", "map:mouseout", "map:mouseover", "map:movestart", "map:move", "map:moveend", "map:zoomstart", "map:zoom", "map:zoomend", "map:rotatestart", "map:rotate", "map:rotateend", "map:dragstart", "map:drag", "map:dragend", "map:pitchstart", "map:pitch", "map:pitchend", "map:wheel", "map:terrain", "map:cooperativegestureprevented", "map:projectiontransition", "update:center", "update:zoom", "update:pitch", "update:bearing"], slots: Object, setup(r, n) {
  const l = C_(Lh()), h = Fa(), f = Fa(), y = Ee(false), p = Ee(false), s = /* @__PURE__ */ new Map(), S = II(l, f, r.mapKey);
  Vr(eu, f), Vr(Vh, p), Vr(zx, y), Vr(uv, l.uid), Vr(cv, ""), Kt(() => r.bearing, (O) => {
    var _a2;
    O && ((_a2 = f.value) == null ? void 0 : _a2.setBearing(O));
  }), Kt(() => r.bounds, (O) => {
    var _a2;
    O && ((_a2 = f.value) == null ? void 0 : _a2.fitBounds(O, r.fitBoundsOptions));
  }), Kt(() => r.center, (O) => {
    var _a2, _b2;
    const j = (_a2 = f.value) == null ? void 0 : _a2.getCenter();
    O && j && !TI(O, j) && ((_b2 = f.value) == null ? void 0 : _b2.setCenter(O));
  }), Kt(() => r.maxBounds, (O) => {
    var _a2;
    O && ((_a2 = f.value) == null ? void 0 : _a2.setMaxBounds(O));
  }), Kt(() => r.maxPitch, (O) => {
    var _a2;
    O && ((_a2 = f.value) == null ? void 0 : _a2.setMaxPitch(O));
  }), Kt(() => r.maxZoom, (O) => {
    var _a2;
    O && ((_a2 = f.value) == null ? void 0 : _a2.setMaxZoom(O));
  }), Kt(() => r.minPitch, (O) => {
    var _a2;
    O && ((_a2 = f.value) == null ? void 0 : _a2.setMinPitch(O));
  }), Kt(() => r.minZoom, (O) => {
    var _a2;
    O && ((_a2 = f.value) == null ? void 0 : _a2.setMinZoom(O));
  }), Kt(() => r.pitch, (O) => {
    var _a2;
    O && ((_a2 = f.value) == null ? void 0 : _a2.setPitch(O));
  }), Kt(() => r.renderWorldCopies, (O) => {
    var _a2;
    O && ((_a2 = f.value) == null ? void 0 : _a2.setRenderWorldCopies(O));
  }), Kt(() => r.mapStyle, (O) => {
    var _a2;
    O && ((_a2 = f.value) == null ? void 0 : _a2.setStyle(O));
  }), Kt(() => r.transformRequest, (O) => {
    var _a2;
    O && ((_a2 = f.value) == null ? void 0 : _a2.setTransformRequest(O));
  }), Kt(() => r.zoom, (O) => {
    var _a2;
    O && ((_a2 = f.value) == null ? void 0 : _a2.setZoom(O));
  }), Kt(() => r.zoom, (O) => {
    var _a2;
    O && ((_a2 = f.value) == null ? void 0 : _a2.setZoom(O));
  });
  function P() {
    S.isMounted = true;
    const O = { ...r, style: r.mapStyle, container: h.value };
    for (const j of Object.keys(O)) O[j] === void 0 && delete O[j];
    if (f.value = C_(new Jl.Map(O)), S.map = f.value, y.value = true, s.set("__load", () => (p.value = true, S.isLoaded = true)), f.value.on("load", s.get("__load")), s.set("__moveend", () => n.emit("update:center", f.value.getCenter())), f.value.on("moveend", s.get("__moveend")), s.set("__zoomend", () => n.emit("update:zoom", f.value.getZoom())), f.value.on("zoomend", s.get("__zoomend")), s.set("__pitchend", () => n.emit("update:pitch", f.value.getPitch())), f.value.on("pitchend", s.get("__pitchend")), s.set("__rotateend", () => n.emit("update:bearing", f.value.getBearing())), f.value.on("rotateend", s.get("__rotateend")), l.vnode.props) {
      for (const j of SI) if (l.vnode.props["onMap:" + j]) {
        const L = `map:${j}`, q = kI(l, f.value, n, L);
        s.set(j, q), f.value.on(j, q);
      }
    }
    f.value.getCanvas().addEventListener("webglcontextlost", A);
  }
  async function M() {
    S.isMounted = false, S.isLoaded = false, p.value = false, f.value && (f.value.getCanvas().removeEventListener("webglcontextlost", A), y.value = false, s.forEach((O, j) => {
      f.value.off(j.startsWith("__") ? j.substring(2) : j, O);
    }), f.value.remove());
  }
  function A() {
    M(), eo(P);
  }
  return Ei(P), Fn(M), n.expose({ map: f }), () => [B("div", { ref: h, style: { height: r.height, width: r.width } }), y.value && n.slots.default ? n.slots.default({}) : void 0];
}, render() {
  return null;
} });
function EI(r, n, l) {
  Kt(r, (h) => {
    var _a2, _b2;
    h && Uh.indexOf(h) === -1 || (((_a2 = n.value) == null ? void 0 : _a2.hasControl(l)) && n.value.removeControl(l), (_b2 = n.value) == null ? void 0 : _b2.addControl(l, h));
  }, { immediate: true });
}
function gm(r, n) {
  const l = cr(eu), h = cr(zx), f = Fa();
  return f.value = r(), EI(() => n.position, l, f.value), Fn(() => {
    var _a2;
    return h.value && ((_a2 = l.value) == null ? void 0 : _a2.removeControl(f.value));
  }), { control: f, map: l };
}
class MI {
  constructor(n, l) {
    __publicField(this, "container");
    this.isAdded = n, this.container = document.createElement("div"), this.setClasses(l);
  }
  getDefaultPosition() {
    return mm.TOP_LEFT;
  }
  onAdd() {
    return eo(() => this.isAdded.value = true), this.container;
  }
  onRemove() {
    this.isAdded.value = false, this.container.remove();
  }
  setClasses(n) {
    this.container.className = n;
  }
}
const vm = nt({ name: "MglCustomControl", props: { position: { type: String, validator: (r) => Uh.indexOf(r) !== -1 }, class: { type: String, default: "maplibregl-ctrl maplibregl-ctrl-group" } }, slots: Object, setup(r, { slots: n }) {
  const l = Ee(false), { control: h } = gm(() => new MI(l, r.class), r);
  return Kt(() => r.class, () => h.value.setClasses(r.class)), () => {
    var _a2;
    return l.value ? B(Jb, { to: h.value.container }, (_a2 = n.default) == null ? void 0 : _a2.call(n, {})) : _r("custom-component");
  };
}, render() {
  return null;
} }), Bx = nt({ name: "MglFullscreenControl", props: { position: { type: String, validator: (r) => Uh.indexOf(r) !== -1 }, container: { type: Object, default: null } }, setup(r) {
  const { control: n, map: l } = gm(() => new Jl.FullscreenControl({ container: r.container || void 0 }), r);
  function h() {
    eo(() => {
      var _a2;
      return (_a2 = l.value) == null ? void 0 : _a2.resize();
    });
  }
  n.value.on("fullscreenstart", h), n.value.on("fullscreenend", h), Fn(() => {
    n.value.off("fullscreenstart", h), n.value.off("fullscreenend", h);
  });
}, render() {
  return null;
} }), Ox = nt({ name: "MglNavigationControl", props: { position: { type: String, validator: (r) => Uh.indexOf(r) !== -1 }, showCompass: { type: Boolean, default: true }, showZoom: { type: Boolean, default: true }, visualizePitch: Boolean }, setup(r) {
  gm(() => new Jl.NavigationControl({ showCompass: r.showCompass, showZoom: r.showZoom, visualizePitch: r.visualizePitch }), r);
}, render() {
  return null;
} });
var $x = ((r) => (r.IMPERIAL = "imperial", r.METRIC = "metric", r.NAUTICAL = "nautical", r))($x || {});
const DI = Object.values($x), Nx = nt({ name: "MglScaleControl", props: { position: { type: String, validator: (r) => Uh.indexOf(r) !== -1 }, maxWidth: { type: Number, default: 100 }, unit: { type: String, default: "metric", validator: (r) => DI.indexOf(r) !== -1 } }, setup(r) {
  gm(() => new Jl.ScaleControl({ maxWidth: r.maxWidth, unit: r.unit }), r);
}, render() {
  return null;
} }), RI = nt({ name: "MglMarker", emits: ["dragstart", "drag", "dragend", "update:coordinates"], props: { coordinates: { type: [Object, Array], required: true }, className: String, offset: [Object, Array], anchor: String, color: String, draggable: Boolean, clickTolerance: Number, rotation: Number, rotationAlignment: String, pitchAlignment: String, scale: Number, opacity: String, opacityWhenCovered: String, subpixelPositioning: { type: Boolean, default: false } }, setup(r, { slots: n, emit: l }) {
  const h = cr(eu), f = Fa(), y = Ee(), p = Ee(false), s = /* @__PURE__ */ new Map();
  function S(P, M) {
    const A = (O) => {
      M && M(), l(P, O);
    };
    f.value.on(P, A), s.set(P, A);
  }
  return Vr(CI, f), Ei(() => {
    const P = { ...r };
    n.marker && (P.element = y.value), f.value = new Jl.Marker(P), f.value.setLngLat(r.coordinates).addTo(h.value), S("dragstart"), S("drag", () => {
      var _a2;
      l("update:coordinates", (_a2 = f.value) == null ? void 0 : _a2.getLngLat());
    }), S("dragend", () => {
      var _a2;
      l("update:coordinates", (_a2 = f.value) == null ? void 0 : _a2.getLngLat());
    }), p.value = true;
  }), Kt(() => r.coordinates, (P) => {
    var _a2;
    return (_a2 = f.value) == null ? void 0 : _a2.setLngLat(P);
  }, { deep: true }), Kt(() => r.draggable, (P) => {
    var _a2;
    return (_a2 = f.value) == null ? void 0 : _a2.setDraggable(P);
  }), Kt(() => r.offset, (P) => {
    var _a2;
    return (_a2 = f.value) == null ? void 0 : _a2.setOffset(P || [0, 0]);
  }), Kt(() => r.pitchAlignment, (P) => {
    var _a2;
    return (_a2 = f.value) == null ? void 0 : _a2.setPitchAlignment(P || "auto");
  }), Kt(() => r.rotation, (P) => {
    var _a2;
    return (_a2 = f.value) == null ? void 0 : _a2.setRotation(P);
  }), Kt(() => r.rotationAlignment, (P) => {
    var _a2;
    return (_a2 = f.value) == null ? void 0 : _a2.setRotationAlignment(P || "auto");
  }), Kt(() => r.opacity, (P) => {
    var _a2;
    return (_a2 = f.value) == null ? void 0 : _a2.setOpacity(P, r.opacityWhenCovered);
  }), Kt(() => r.opacityWhenCovered, (P) => {
    var _a2;
    return (_a2 = f.value) == null ? void 0 : _a2.setOpacity(r.opacity, P);
  }), Kt(() => r.subpixelPositioning, (P) => {
    var _a2;
    return (_a2 = f.value) == null ? void 0 : _a2.setSubpixelPositioning(P);
  }), Kt(() => r.className, (P, M) => {
    var _a2, _b2;
    M && ((_a2 = f.value) == null ? void 0 : _a2.removeClassName(M)), P && ((_b2 = f.value) == null ? void 0 : _b2.addClassName(P));
  }), Fn(() => {
    var _a2;
    s.forEach((P, M) => {
      var _a3;
      (_a3 = f.value) == null ? void 0 : _a3.off(M, P);
    }), (_a2 = f.value) == null ? void 0 : _a2.remove();
  }), () => [B("div", n.default && p.value ? n.default({}) : void 0), B("div", { ref: y }, n.marker ? n.marker() : void 0)];
}, render() {
  return null;
} });
let AI = class {
  constructor() {
    __publicField(this, "unmountHandlers", /* @__PURE__ */ new Map());
  }
  registerUnmountHandler(n, l) {
    this.unmountHandlers.set(n, l);
  }
  unregisterUnmountHandler(n) {
    this.unmountHandlers.delete(n);
  }
  unmount() {
    this.unmountHandlers.forEach((n) => n());
  }
}, dv = (_a = class {
  static genSourceOpts(n) {
    const l = { ...n };
    for (const h of Object.keys(l)) (l[h] === void 0 || h === "sourceId") && delete l[h];
    return l;
  }
  static getSourceRef(n, l) {
    const h = typeof l == "string", f = String(n) + (h ? l : "");
    let y = _a.REFS.get(f);
    return y || (y = Ee(h ? null : void 0), _a.REFS.set(f, y)), y;
  }
}, __publicField(_a, "REFS", /* @__PURE__ */ new Map()), _a);
function zI(r, n, l) {
  const h = cr(eu), f = cr(Vh);
  function y() {
    f.value && (h.value.addSource(n.sourceId, dv.genSourceOpts(n)), r.value = h.value.getSource(n.sourceId));
  }
  return Kt(f, y, { immediate: true }), h.value.on("style.load", y), Fn(() => {
    f.value && (l.unmount(), h.value.removeSource(n.sourceId)), h.value.off("style.load", y);
  });
}
const FI = nt({ name: "MglGeoJsonSource", props: { sourceId: { type: String, required: true }, data: { type: [Object, String], required: true }, maxzoom: Number, attribution: String, buffer: Number, tolerance: Number, cluster: Boolean, clusterRadius: Number, clusterMaxZoom: Number, clusterMinPoints: Number, clusterProperties: Object, lineMetrics: Boolean, generateId: Boolean, promoteId: [Object, String], filter: [Array, String, Object] }, slots: Object, setup(r, { slots: n }) {
  const l = cr(uv), h = dv.getSourceRef(l, r.sourceId), f = new AI(), y = { ...r, type: "geojson" };
  return Vr(cv, r.sourceId), Vr(Fx, f), zI(h, y, f), Kt([t3(r.data) ? r.data : () => r.data, h], ([p, s]) => {
    s == null ? void 0 : s.setData(p || { type: "FeatureCollection", features: [] });
  }, { immediate: true }), () => [_r("GeoJSON Source"), h.value && n.default ? n.default({}) : void 0];
} }), pa = ["click", "dblclick", "mousedown", "mouseup", "mousemove", "mouseenter", "mouseleave", "mouseover", "mouseout", "contextmenu", "touchstart", "touchend", "touchcancel"];
function qs() {
  return { layerId: { type: String, required: true }, source: { type: String }, metadata: { type: [Object, Array, String, Number] }, sourceLayer: { type: String }, minzoom: { type: Number }, maxzoom: { type: Number }, filter: { type: Object }, before: { type: String }, layout: { type: Object }, paint: { type: Object } };
}
function LI(r, n, l, h) {
  const f = { id: r, type: n, source: l.source || h, metadata: l.metadata, minzoom: l.minzoom, maxzoom: l.maxzoom, "source-layer": l.sourceLayer, filter: l.filter, paint: l.paint, layout: l.layout };
  for (const y of Object.keys(f)) f[y] === void 0 && delete f[y];
  return f;
}
function BI(r, n, l) {
  if (l.props) for (const h of pa) {
    const f = "on" + h.charAt(0).toUpperCase() + h.substr(1);
    l.props[f] && r.on(h, n, l.props[f]);
  }
}
function OI(r, n, l) {
  if (l.props) for (const h of pa) {
    const f = "on" + h.charAt(0).toUpperCase() + h.substr(1);
    l.props[f] && r.off(h, n, l.props[f]);
  }
}
function jx(r, n) {
  const l = cr(eu), h = cr(Vh), f = cr(Fx);
  function y() {
    h.value && (n && OI(l.value, r, n.vnode), l.value.getLayer(r) && l.value.removeLayer(r));
  }
  f.registerUnmountHandler(r, y), Fn(() => {
    f.unregisterUnmountHandler(r), y();
  });
}
nt({ name: "MglBackgroundLayer", props: { layerId: { type: String, required: true }, metadata: [Object, Array, String, Number], minzoom: Number, maxzoom: Number, before: String, layout: Object, paint: Object }, emits: [...pa], setup(r) {
  const n = cr(eu), l = cr(Vh);
  return jx(r.layerId), Kt(() => r.layout, (h) => {
    if (h) for (const [f, y] of Object.entries(h)) n.value.setLayoutProperty(r.layerId, f, y);
  }), Kt(() => r.paint, (h) => {
    if (h) for (const [f, y] of Object.entries(h)) n.value.setPaintProperty(r.layerId, f, y);
  }), Kt(l, (h) => {
    h && n.value.addLayer({ id: r.layerId, type: "background", metadata: r.metadata, minzoom: r.minzoom, maxzoom: r.maxzoom, layout: r.layout, paint: r.paint }, r.before || void 0);
  }, { immediate: true }), () => _r("Background Layer");
} });
function Ws(r, n) {
  const l = cr(cv);
  if (!l && !n.source) return;
  const h = Lh(), f = cr(eu), y = cr(Vh), p = cr(uv), s = dv.getSourceRef(p, n.source || l);
  return jx(n.layerId, h), Kt(() => n.minzoom, () => f.value.setLayerZoomRange(n.layerId, n.minzoom || 0, n.maxzoom || 24)), Kt(() => n.maxzoom, () => f.value.setLayerZoomRange(n.layerId, n.minzoom || 0, n.maxzoom || 24)), Kt(() => n.layout, (S) => {
    if (S) for (const [P, M] of Object.entries(S)) f.value.setLayoutProperty(n.layerId, P, M);
  }, { deep: true }), Kt(() => n.paint, (S) => {
    if (S) for (const [P, M] of Object.entries(S)) f.value.setPaintProperty(n.layerId, P, M);
  }, { deep: true }), Kt(() => n.filter, (S) => f.value.setFilter(n.layerId, S), { deep: true }), Kt([y, s], ([S, P]) => {
    S && (P || P === void 0) && (f.value.addLayer(LI(n.layerId, r, n, l), n.before || void 0), BI(f.value, n.layerId, h.vnode));
  }, { immediate: true }), () => _r(`${r} Layer`);
}
nt({ name: "MglCircleLayer", props: qs(), emits: [...pa], setup(r) {
  return Ws("circle", r);
} });
nt({ name: "MglFillLayer", props: qs(), emits: [...pa], setup(r) {
  return Ws("fill", r);
} });
nt({ name: "MglFillExtrusionLayer", props: qs(), emits: [...pa], setup(r) {
  return Ws("fill-extrusion", r);
} });
nt({ name: "MglHeatmapLayer", props: qs(), emits: [...pa], setup(r) {
  return Ws("heatmap", r);
} });
nt({ name: "MglHillshadeLayer", props: qs(), emits: [...pa], setup(r) {
  return Ws("hillshade", r);
} });
const $I = nt({ name: "MglLineLayer", props: qs(), emits: [...pa], setup(r) {
  return Ws("line", r);
} });
nt({ name: "MglRasterLayer", props: qs(), emits: [...pa], setup(r) {
  return Ws("raster", r);
} });
nt({ name: "MglSymbolLayer", props: qs(), emits: [...pa], setup(r) {
  return Ws("symbol", r);
} });
const NI = 0.3, jI = nt({ __name: "MapCompass", props: cs({ pitch: {}, size: {}, tracking: { type: Boolean } }, { bearing: { default: 0 }, bearingModifiers: {} }), emits: cs(["toggleTracking"], ["update:bearing"]), setup(r, { emit: n }) {
  Gs((ee) => ({ v1c8003b6: K(l).primaryColor, v11ea132b: K(l).modalColor, v1738aa7c: K(l).borderColor, v34c26392: K(l).textColorBase }));
  const l = Vs(), h = r, f = Dc(r, "bearing"), y = n, p = Ae(() => `transform: rotate(${-f.value % 360}deg)`), s = Ae(() => `transform: rotateX(${Math.min(45, h.pitch ? h.pitch : 0)}deg); transition: all 0.3s ease;`), S = Ae(() => h.size || 40), P = Ae(() => S.value / 6), M = Ae(() => P.value / 2), A = Ae(() => S.value / 8), O = Ae(() => A.value / 2), j = Ae(() => S.value / 3), L = Ae(() => ({ width: `${P.value}px`, height: `${P.value}px`, top: "0px", left: `calc(50% - ${P.value / 2}px)`, transform: `translateY(-${M.value}px)` })), q = Ae(() => ({ width: `${A.value}px`, height: `${A.value}px`, top: `calc(50% - ${A.value / 2}px)`, right: "0px", transform: `translateX(${O.value}px)` })), N = Ae(() => ({ width: `${A.value}px`, height: `${A.value}px`, bottom: "0px", left: `calc(50% - ${A.value / 2}px)`, transform: `translateY(${O.value}px)` })), J = Ae(() => ({ width: `${A.value}px`, height: `${A.value}px`, top: `calc(50% - ${A.value / 2}px)`, left: "0px", transform: `translateX(-${O.value}px)` })), te = Ae(() => ({ height: `${j.value}px`, width: "100%", top: `calc(50% - ${j.value / 2}px)`, fontSize: `${j.value}px`, lineHeight: `${j.value}px` })), ne = Ae(() => ({ width: `${S.value}px`, height: `${S.value}px` })), ae = ["N", "E", "S", "W"], oe = Ae(() => {
    const ee = f.value > 0 ? f.value : 360 + f.value;
    return ae[Math.round(ee % 360 / 90) % 4];
  });
  return Ei(() => {
    const ee = document.querySelector(".map-compass");
    ee.onclick = () => {
      y("toggleTracking"), h.tracking || (f.value = 0);
    }, ee && ee.addEventListener("wheel", (ke) => {
      if (h.tracking) return;
      ke.preventDefault();
      const ve = (f.value + ke.deltaY * NI) % 360;
      f.value = Math.round(ve >= 0 ? ve : 360 + ve);
    });
  }), (ee, ke) => (ut(), Ot("div", { style: zn(s.value) }, [xt("div", { class: ha(["map-compass", { "tracking-active": h.tracking }]), style: zn(ne.value) }, [xt("div", { class: "compass-panel", style: zn(p.value) }, [xt("div", { class: "pin north-pin", style: zn(L.value) }, null, 4), xt("div", { class: "pin east-pin", style: zn(q.value) }, null, 4), xt("div", { class: "pin south-pin", style: zn(N.value) }, null, 4), xt("div", { class: "pin west-pin", style: zn(J.value) }, null, 4)], 4), xt("span", { class: "compass-orientation-text", style: zn(te.value) }, Jt(oe.value), 5)], 6)], 4));
} }), VI = Ui(jI, [["__scopeId", "data-v-0f30b63f"]]), Rn = [];
for (let r = 0; r < 256; ++r) Rn.push((r + 256).toString(16).slice(1));
function UI(r, n = 0) {
  return (Rn[r[n + 0]] + Rn[r[n + 1]] + Rn[r[n + 2]] + Rn[r[n + 3]] + "-" + Rn[r[n + 4]] + Rn[r[n + 5]] + "-" + Rn[r[n + 6]] + Rn[r[n + 7]] + "-" + Rn[r[n + 8]] + Rn[r[n + 9]] + "-" + Rn[r[n + 10]] + Rn[r[n + 11]] + Rn[r[n + 12]] + Rn[r[n + 13]] + Rn[r[n + 14]] + Rn[r[n + 15]]).toLowerCase();
}
let o0;
const GI = new Uint8Array(16);
function qI() {
  if (!o0) {
    if (typeof crypto > "u" || !crypto.getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    o0 = crypto.getRandomValues.bind(crypto);
  }
  return o0(GI);
}
const WI = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), vb = { randomUUID: WI };
function xh(r, n, l) {
  var _a2;
  if (vb.randomUUID && !r) return vb.randomUUID();
  r = r || {};
  const h = r.random ?? ((_a2 = r.rng) == null ? void 0 : _a2.call(r)) ?? qI();
  if (h.length < 16) throw new Error("Random bytes length must be >= 16");
  return h[6] = h[6] & 15 | 64, h[8] = h[8] & 63 | 128, UI(h);
}
function da() {
  return { name: "Untitled", description: "A new geographic item", creation_timestamp: Date.now(), modification_timestamp: Date.now(), created_by: "anonymous", modified_by: "anonymous", tags: [] };
}
function ZI() {
  return { ...da(), version: 1, signature: void 0 };
}
class Yl {
  constructor(n = xh(), l, h, f) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "routes");
    __publicField(this, "drafts");
    this.id = n, this.routes = l || { id: xh(), meta: da(), routes: [] }, this.drafts = h || { id: xh(), meta: da(), drafts: [] }, this.meta = { ...ZI(), ...f };
  }
  toStorage() {
    return { id: this.id, meta: this.meta, routes: this.routes, drafts: this.drafts };
  }
  static fromStorage(n) {
    return new Yl(n.id, n.routes, n.drafts, n.meta);
  }
  clone() {
    return Yl.fromStorage(this.toStorage());
  }
  updateName(n) {
    this.meta.name = n, this.meta.modification_timestamp = Date.now();
  }
  updateDescription(n) {
    this.meta.description = n, this.meta.modification_timestamp = Date.now();
  }
  addTag(n) {
    this.meta.tags.includes(n) || (this.meta.tags.push(n), this.meta.modification_timestamp = Date.now());
  }
  removeTag(n) {
    const l = this.meta.tags.indexOf(n);
    l > -1 && (this.meta.tags.splice(l, 1), this.meta.modification_timestamp = Date.now());
  }
}
class HI {
  constructor(n = [], l = xh(), h = da()) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "routesInternal");
    this.id = l, this.meta = h || da(), this.routesInternal = n;
  }
  get name() {
    return this.meta || (this.meta = da()), this.meta.name;
  }
  set name(n) {
    this.meta || (this.meta = da()), this.meta.name = n;
  }
  get routes() {
    return ns(this.routesInternal);
  }
  set routes(n) {
    this.routesInternal = ns(n);
  }
  findRoute(n) {
    return this.routesInternal.find((l) => l.id === n);
  }
  existRoute(n) {
    return this.routesInternal.some((l) => l.id === n);
  }
  addRoute(n) {
    if (this.existRoute(n.id)) throw new Error(`[CartoSketch.Route] Route ${n.id} already exist`);
    this.routesInternal.push(ns(n)), this.updateModificationTime();
  }
  updateRoute(n) {
    const l = this.routesInternal.findIndex((h) => h.id === n.id);
    if (l === -1) throw new Error(`[CartoSketch.Route] Route ${n.id} not found`);
    this.routesInternal[l] = ns(n), this.updateModificationTime();
  }
  removeRoute(n) {
    const l = this.routesInternal.findIndex((h) => h.id === n);
    l !== -1 && (this.routesInternal.splice(l, 1), this.updateModificationTime());
  }
  updateModificationTime() {
    this.meta.modification_timestamp = Date.now();
  }
  exportAsGeoJSON() {
    return { type: "FeatureCollection", features: this.routesInternal.map((n) => n.exportAsGeoJSON()), properties: this.meta };
  }
  exportToStorage() {
    return Object.freeze({ id: this.id, meta: this.meta, routes: this.routesInternal.map((n) => n.exportToStorage()) });
  }
}
class a0 {
  constructor(n = xh(), l = [], h = {}, f) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "properties");
    __publicField(this, "points");
    this.id = n, this.meta = { ...da(), record_timespan: 0, ...f }, this.properties = h, this.points = l;
  }
  get name() {
    return this.meta || (this.meta = da()), this.meta.name;
  }
  set name(n) {
    this.meta || (this.meta = da()), this.meta.name = n;
  }
  get distance() {
    return this.meta.distance || 0;
  }
  set distance(n) {
    this.meta.distance = n;
  }
  get recordTimespan() {
    return this.meta.record_timespan || 0;
  }
  set recordTimespan(n) {
    this.meta.record_timespan = n;
  }
  setPoints(n) {
    this.points = ns(n), this.updateModificationTime();
  }
  appendPoint(n) {
    this.points.push(ns(n)), this.updateModificationTime();
  }
  getPoints() {
    return ns(this.points);
  }
  setProperties(n) {
    const l = ns(n);
    Object.assign(this.properties, l), this.updateModificationTime();
  }
  updateModificationTime() {
    this.meta.modification_timestamp = Date.now();
  }
  exportAsGeoJSON() {
    return { type: "Feature", properties: { ...this.properties, ...this.meta, description: JSON.stringify({ name: this.meta.name, id: this.id }) }, geometry: { type: "LineString", coordinates: this.points.map((n) => [n.longitude, n.latitude]) } };
  }
  exportToStorage() {
    return ns({ id: this.id, meta: this.meta, properties: this.properties, points: this.points });
  }
}
var Kr = ((r) => (r.MIGRATION_FAILED = "MIGRATION_FAILED", r.INVALID_VERSION = "INVALID_VERSION", r.UNSUPPORTED_VERSION = "UNSUPPORTED_VERSION", r.ROLLBACK_FAILED = "ROLLBACK_FAILED", r.VALIDATION_FAILED = "VALIDATION_FAILED", r.STRATEGY_NOT_FOUND = "STRATEGY_NOT_FOUND", r.DATA_CORRUPTION = "DATA_CORRUPTION", r))(Kr || {});
class gi extends i3 {
  constructor(n, l = "MIGRATION_FAILED", h) {
    super(n, h);
    __publicField(this, "code");
    __publicField(this, "domain", n3.GENERIC);
    this.code = l;
  }
}
class Ma extends gi {
  constructor(n, l = "INVALID_VERSION", h, f, y) {
    super(n, l, y), this.currentVersion = h, this.targetVersion = f;
  }
}
class $r extends gi {
  constructor(n, l, h, f) {
    super(n, "VALIDATION_FAILED", f), this.field = l, this.value = h;
  }
}
class yb extends gi {
  constructor(n, l, h) {
    super(n, "DATA_CORRUPTION", h), this.corruptedData = l;
  }
}
class XI extends gi {
  constructor(n, l, h, f) {
    super(n, "ROLLBACK_FAILED", f), this.originalError = l, this.rollbackError = h;
  }
}
class dh {
  static getCurrentVersion() {
    return this.CURRENT_VERSION;
  }
  static getMinimumSupportedVersion() {
    return this.MIN_SUPPORTED_VERSION;
  }
  static extractVersion(n) {
    try {
      if (typeof n == "object" && n !== null && "version" in n) {
        const l = n.version;
        if (typeof l == "number" && l >= 0) return Vi(l);
      }
      if (this.isRouteCollectionFormat(n)) return Vi(0);
      if (this.isSketchArrayFormat(n)) return Vi(1);
      throw new Error("Unable to determine data version");
    } catch (l) {
      const h = l instanceof Ma ? l : new Ma(`Failed to extract version from data: ${l}`, Kr.INVALID_VERSION, void 0, void 0, l instanceof Error ? l : new Error(String(l)));
      return zr(h);
    }
  }
  static isRouteCollectionFormat(n) {
    return typeof n == "object" && n !== null && "routes" in n && !("sketches" in n) && Array.isArray(n.routes);
  }
  static isSketchArrayFormat(n) {
    return Array.isArray(n) && n.length > 0 && this.isSketchObject(n[0]);
  }
  static isSketchObject(n) {
    return typeof n == "object" && n !== null && "id" in n && "meta" in n && "routes" in n && "drafts" in n;
  }
  static validateVersion(n) {
    try {
      if (n < this.MIN_SUPPORTED_VERSION) throw new Ma(`Version ${n} is below minimum supported version ${this.MIN_SUPPORTED_VERSION}`, Kr.UNSUPPORTED_VERSION, n);
      if (n > this.CURRENT_VERSION) throw new Ma(`Version ${n} is above current version ${this.CURRENT_VERSION}`, Kr.UNSUPPORTED_VERSION, n, this.CURRENT_VERSION);
      return Vi(void 0);
    } catch (l) {
      const h = l instanceof Ma ? l : new Ma(`Version validation failed: ${l}`, Kr.INVALID_VERSION, n, void 0, l instanceof Error ? l : new Error(String(l)));
      return zr(h);
    }
  }
  static addVersionMetadata(n, l = this.CURRENT_VERSION) {
    return { ...n, [this.VERSION_KEY]: { version: l, timestamp: Date.now(), description: `Version ${l} data format` } };
  }
  static extractVersionMetadata(n) {
    try {
      if (typeof n == "object" && n !== null && this.VERSION_KEY in n) {
        const l = n[this.VERSION_KEY];
        if (this.isValidVersionInfo(l)) return Vi(l);
      }
      return Vi(null);
    } catch (l) {
      const h = l instanceof Ma ? l : new Ma(`Failed to extract version metadata: ${l}`, Kr.INVALID_VERSION, void 0, void 0, l instanceof Error ? l : new Error(String(l)));
      return zr(h);
    }
  }
  static isValidVersionInfo(n) {
    return typeof n == "object" && n !== null && "version" in n && "timestamp" in n && typeof n.version == "number" && typeof n.timestamp == "number";
  }
  static determineMigrationPath(n, l) {
    try {
      const h = this.validateVersion(n);
      if (h.isErr()) throw h.error;
      const f = this.validateVersion(l);
      if (f.isErr()) throw f.error;
      if (n === l) return Vi([]);
      const y = [], p = n < l ? 1 : -1;
      for (let s = n; s !== l; s += p) y.push(s + p);
      return Vi(y);
    } catch (h) {
      const f = h instanceof Ma ? h : new Ma(`Failed to determine migration path: ${h}`, Kr.INVALID_VERSION, n, l, h instanceof Error ? h : new Error(String(h)));
      return zr(f);
    }
  }
  static isMigrationNeeded(n) {
    return this.extractVersion(n).map((l) => l !== this.CURRENT_VERSION);
  }
}
__publicField(dh, "CURRENT_VERSION", 1);
__publicField(dh, "VERSION_KEY", "_data_version");
__publicField(dh, "MIN_SUPPORTED_VERSION", 0);
class os {
  static validateSketchData(n) {
    try {
      if (!n || typeof n != "object") throw new $r("Sketch data must be an object", "data", n);
      const l = n, h = ["id", "meta", "routes", "drafts"];
      for (const y of h) if (!(y in l)) throw new $r(`Missing required field: ${y}`, y, l[y]);
      if (typeof l.id != "string" || !l.id) throw new $r("Sketch ID must be a non-empty string", "id", l.id);
      if (!l.meta || typeof l.meta != "object") throw new $r("Sketch meta must be an object", "meta", l.meta);
      const f = this.validateRouteCollectionData(l.routes);
      if (f.isErr()) throw f.error;
      if (!l.drafts || typeof l.drafts != "object") throw new $r("Sketch drafts must be an object", "drafts", l.drafts);
      return Vi(l);
    } catch (l) {
      if (l instanceof $r) return zr(l);
      const h = new $r(`Unexpected validation error: ${l}`, void 0, n, l instanceof Error ? l : new Error(String(l)));
      return zr(h);
    }
  }
  static validateRouteCollectionData(n) {
    try {
      if (!n || typeof n != "object") throw new $r("Route collection data must be an object", "data", n);
      const l = n, h = ["id", "meta", "routes"];
      for (const f of h) if (!(f in l)) throw new $r(`Missing required field: ${f}`, f, l[f]);
      if (typeof l.id != "string" || !l.id) throw new $r("Route collection ID must be a non-empty string", "id", l.id);
      if (!l.meta || typeof l.meta != "object") throw new $r("Route collection meta must be an object", "meta", l.meta);
      if (!Array.isArray(l.routes)) throw new $r("Routes must be an array", "routes", l.routes);
      for (let f = 0; f < l.routes.length; f++) {
        const y = l.routes[f], p = this.validateRouteItem(y);
        if (p.isErr()) throw new $r(`Invalid route at index ${f}: ${p.error.message}`, `routes[${f}]`, y, p.error);
      }
      return Vi(l);
    } catch (l) {
      if (l instanceof $r) return zr(l);
      const h = new $r(`Unexpected validation error: ${l}`, void 0, n, l instanceof Error ? l : new Error(String(l)));
      return zr(h);
    }
  }
  static validateRouteItem(n) {
    try {
      if (!n || typeof n != "object") throw new $r("Route item must be an object", "data", n);
      const l = n, h = ["id", "meta", "properties", "points"];
      for (const f of h) if (!(f in l)) throw new $r(`Missing required field: ${f}`, f, l[f]);
      if (typeof l.id != "string" || !l.id) throw new $r("Route item ID must be a non-empty string", "id", l.id);
      if (!Array.isArray(l.points)) throw new $r("Route points must be an array", "points", l.points);
      for (let f = 0; f < l.points.length; f++) {
        const y = l.points[f];
        if (!y || typeof y != "object") throw new $r(`Route point at index ${f} must be an object`, `points[${f}]`, y);
        const p = y;
        if (typeof p.latitude != "number" || typeof p.longitude != "number") throw new $r(`Route point at index ${f} must have numeric latitude and longitude`, `points[${f}]`, y);
      }
      return Vi(l);
    } catch (l) {
      if (l instanceof $r) return zr(l);
      const h = new $r(`Unexpected validation error: ${l}`, void 0, n, l instanceof Error ? l : new Error(String(l)));
      return zr(h);
    }
  }
  static validateSketchArray(n) {
    try {
      if (!Array.isArray(n)) throw new $r("Sketch array must be an array", "data", n);
      if (n.length === 0) throw new $r("Sketch array cannot be empty", "data.length", n.length);
      for (let l = 0; l < n.length; l++) {
        const h = n[l], f = this.validateSketchData(h);
        if (f.isErr()) throw new $r(`Invalid sketch at index ${l}: ${f.error.message}`, `[${l}]`, h, f.error);
      }
      return Vi(n);
    } catch (l) {
      if (l instanceof $r) return zr(l);
      const h = new $r(`Unexpected validation error: ${l}`, void 0, n, l instanceof Error ? l : new Error(String(l)));
      return zr(h);
    }
  }
  static validateData(n, l) {
    switch (l) {
      case "sketch":
        return this.validateSketchData(n);
      case "route-collection":
        return this.validateRouteCollectionData(n);
      case "sketch-array":
        return this.validateSketchArray(n);
      default:
        return zr(new $r(`Unknown expected format: ${l}`, "expectedFormat", l));
    }
  }
  static checkDataIntegrity(n, l) {
    try {
      const h = this.validateData(n, l);
      return h.isErr() ? zr(new yb(`Data validation failed: ${h.error.message}`, n, h.error)) : Vi({ isValid: true, errors: [], warnings: [] });
    } catch (h) {
      return zr(new yb(`Data integrity check failed: ${h}`, n, h instanceof Error ? h : new Error(String(h))));
    }
  }
}
class YI {
  constructor() {
    __publicField(this, "fromVersion", 0);
    __publicField(this, "toVersion", 1);
    __publicField(this, "name", "route-collection-to-sketch");
  }
  migrate(n) {
    try {
      const l = os.validateRouteCollectionData(n);
      if (l.isErr()) return zr(new gi(`Invalid route collection data: ${l.error.message}`, Kr.VALIDATION_FAILED, l.error));
      const h = l.value, f = new Yl();
      f.meta.name = h.meta.name || "Migrated Routes", f.meta.description = h.meta.description || "Migrated from route collection", f.meta.creation_timestamp = h.meta.creation_timestamp, f.meta.modification_timestamp = Date.now(), f.routes = h;
      const y = [f.toStorage()];
      return Vi(y);
    } catch (l) {
      return zr(new gi(`Route collection to sketch migration failed: ${l}`, Kr.MIGRATION_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
  rollback(n) {
    try {
      const l = os.validateSketchArray(n);
      if (l.isErr()) return zr(new gi(`Invalid sketch array data for rollback: ${l.error.message}`, Kr.VALIDATION_FAILED, l.error));
      const h = l.value;
      if (h.length === 0) return zr(new gi("Cannot rollback: empty sketch array", Kr.MIGRATION_FAILED));
      const f = h[0];
      return Vi(f.routes);
    } catch (l) {
      return zr(new gi(`Route collection to sketch rollback failed: ${l}`, Kr.ROLLBACK_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
  validateBefore(n) {
    return os.validateRouteCollectionData(n).map(() => {
    }).mapErr((l) => new $r(`Pre-migration validation failed: ${l.message}`, l.field, l.value, l));
  }
  validateAfter(n) {
    return os.validateSketchArray(n).map(() => {
    }).mapErr((l) => new $r(`Post-migration validation failed: ${l.message}`, l.field, l.value, l));
  }
}
class KI {
  constructor() {
    __publicField(this, "fromVersion", 1);
    __publicField(this, "toVersion", 2);
    __publicField(this, "name", "sketch-v1-to-v2");
  }
  migrate() {
    return zr(new gi("Sketch V1 to V2 migration not yet implemented", Kr.STRATEGY_NOT_FOUND));
  }
  validateBefore(n) {
    return os.validateSketchArray(n).map(() => {
    }).mapErr((l) => new $r(`Pre-migration validation failed: ${l.message}`, l.field, l.value, l));
  }
  validateAfter(n) {
    return zr(new $r("Sketch V2 validation not yet implemented", void 0, n));
  }
}
const _JI = class _JI {
  static register(n) {
    const l = this.getStrategyKey(n.fromVersion, n.toVersion);
    this.strategies.set(l, n);
  }
  static getStrategy(n, l) {
    const h = this.getStrategyKey(n, l), f = this.strategies.get(h);
    return f ? Vi(f) : zr(new gi(`No migration strategy found for version ${n} to ${l}`, Kr.STRATEGY_NOT_FOUND));
  }
  static getAllStrategies() {
    return Array.from(this.strategies.values());
  }
  static hasStrategy(n, l) {
    const h = this.getStrategyKey(n, l);
    return this.strategies.has(h);
  }
  static getStrategyKey(n, l) {
    return `${n}->${l}`;
  }
};
__publicField(_JI, "strategies", /* @__PURE__ */ new Map());
_JI.register(new YI()), _JI.register(new KI());
let JI = _JI;
class QI {
  static createStrategy(n, l) {
    return JI.getStrategy(n, l);
  }
  static createStrategiesForPath(n) {
    try {
      const l = [];
      for (let h = 0; h < n.length; h++) {
        const f = h === 0 ? n[0] - 1 : n[h - 1], y = n[h], p = this.createStrategy(f, y);
        if (p.isErr()) return zr(p.error);
        l.push(p.value);
      }
      return Vi(l);
    } catch (l) {
      return zr(new gi(`Failed to create strategies for migration path: ${l}`, Kr.MIGRATION_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
}
class eE {
  static isMigrationNeeded(n) {
    return dh.isMigrationNeeded(n);
  }
  static getDataVersion(n) {
    return dh.extractVersion(n);
  }
  static migrateToCurrent(n, l = {}) {
    return this.migrateToVersion(n, dh.getCurrentVersion(), l);
  }
  static migrateToVersion(n, l, h = {}) {
    try {
      const f = { ...this.DEFAULT_OPTIONS, ...h }, y = dh.extractVersion(n);
      if (y.isErr()) return zr(new gi(`Failed to extract current version: ${y.error.message}`, Kr.INVALID_VERSION, y.error));
      const p = y.value;
      if (p === l) return Vi({ data: n, fromVersion: p, toVersion: l, migratedVersions: [] });
      const s = dh.determineMigrationPath(p, l);
      if (s.isErr()) return zr(new gi(`Failed to determine migration path: ${s.error.message}`, Kr.INVALID_VERSION, s.error));
      const S = s.value, P = QI.createStrategiesForPath(S);
      if (P.isErr()) return zr(P.error);
      const M = P.value;
      if (f.validateBefore) {
        const L = this.validateDataBeforeMigration(n, p);
        if (L.isErr()) return zr(new gi(`Pre-migration validation failed: ${L.error.message}`, Kr.VALIDATION_FAILED, L.error));
      }
      const A = f.enableRollback ? n : void 0;
      let O = n;
      const j = [];
      for (const L of M) {
        const q = this.executeMigrationWithRetry(L, O, f);
        if (q.isErr()) {
          if (f.enableRollback && A) {
            const N = this.rollbackToVersion(A);
            if (N.isErr()) return zr(new XI(`Migration failed and rollback also failed: ${N.error.message}`, q.error, N.error));
          }
          return zr(q.error);
        }
        O = q.value, j.push(L.toVersion);
      }
      if (f.validateAfter) {
        const L = this.validateDataAfterMigration(O, l);
        if (L.isErr()) return zr(new gi(`Post-migration validation failed: ${L.error.message}`, Kr.VALIDATION_FAILED, L.error));
      }
      return Vi({ data: O, fromVersion: p, toVersion: l, migratedVersions: j, rollbackData: f.enableRollback ? A : void 0 });
    } catch (f) {
      return zr(new gi(`Migration service error: ${f}`, Kr.MIGRATION_FAILED, f instanceof Error ? f : new Error(String(f))));
    }
  }
  static executeMigrationWithRetry(n, l, h) {
    let f = null;
    for (let y = 0; y <= (h.maxRetries || 0); y++) {
      try {
        const p = n.migrate(l);
        if (p.isErr()) {
          f = p.error;
          continue;
        }
        if (n.validateAfter) {
          const s = n.validateAfter(p.value);
          if (s.isErr()) {
            f = new gi(`Post-migration validation failed: ${s.error.message}`, Kr.VALIDATION_FAILED, s.error);
            continue;
          }
        }
        return Vi(p.value);
      } catch (p) {
        f = new gi(`Migration attempt ${y + 1} failed: ${p}`, Kr.MIGRATION_FAILED, p instanceof Error ? p : new Error(String(p)));
      }
      y < (h.maxRetries || 0) && h.retryDelay && console.warn(`Migration failed, retrying in ${h.retryDelay}ms...`);
    }
    return zr(f || new gi("Migration failed after all retry attempts", Kr.MIGRATION_FAILED));
  }
  static rollbackToVersion(n) {
    try {
      return Vi(n);
    } catch (l) {
      return zr(new gi(`Rollback failed: ${l}`, Kr.ROLLBACK_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
  static validateDataBeforeMigration(n, l) {
    switch (l) {
      case 0:
        return os.validateRouteCollectionData(n).map(() => {
        }).mapErr((h) => new gi(`Route collection validation failed: ${h.message}`, Kr.VALIDATION_FAILED, h));
      case 1:
        return os.validateSketchArray(n).map(() => {
        }).mapErr((h) => new gi(`Sketch array validation failed: ${h.message}`, Kr.VALIDATION_FAILED, h));
      default:
        return zr(new gi(`Unknown version for pre-migration validation: ${l}`, Kr.VALIDATION_FAILED));
    }
  }
  static validateDataAfterMigration(n, l) {
    switch (l) {
      case 1:
        return os.validateSketchArray(n).map(() => {
        }).mapErr((h) => new gi(`Sketch array validation failed: ${h.message}`, Kr.VALIDATION_FAILED, h));
      default:
        return zr(new gi(`Unknown version for post-migration validation: ${l}`, Kr.VALIDATION_FAILED));
    }
  }
  static checkDataIntegrity(n, l) {
    return os.checkDataIntegrity(n, l);
  }
}
__publicField(eE, "DEFAULT_OPTIONS", { validateBefore: true, validateAfter: true, enableRollback: true, maxRetries: 3, retryDelay: 1e3 });
const hv = X0("sketches", () => {
  const r = Ee([]), n = Ee(null), l = Ee(null), h = Ae(() => {
    if (!n.value) return null;
    const ve = r.value.find((le) => le.id === n.value);
    return ve ? new HI(ve.routes.routes.map((le) => new a0(le.id, le.points, le.properties, le.meta)), ve.routes.id, ve.routes.meta) : null;
  }), f = Ae(() => h.value ? h.value.routes.map((ve) => ({ id: ve.id, name: ve.name, points: ve.getPoints(), meta: ve.meta })) : []), y = Ae(() => n.value && r.value.find((ve) => ve.id === n.value) || null), p = Ae(() => y.value ? y.value.drafts.drafts : []);
  async function s() {
    const ve = await w1("sketches");
    if (ve) {
      const le = eE.migrateToCurrent(ve, { validateBefore: true, validateAfter: true, enableRollback: true });
      if (le.isErr()) {
        console.error("[SketchStore] Data migration failed:", le.error), await S();
        return;
      }
      const ue = le.value;
      ue.migratedVersions.length > 0 && console.info(`[SketchStore] Successfully migrated data from version ${ue.fromVersion} to ${ue.toVersion}`), Array.isArray(ue.data) ? (r.value = ue.data.map((be) => Yl.fromStorage(be)), r.value.forEach((be) => {
        be.routes.routes.forEach(async (Ve) => {
          if (Ve.points.length > 1 && !Ve.meta.distance) try {
            Ve.meta.distance = await Ng(Ve.points);
          } catch (Ge) {
            console.warn("Failed to calculate route distance:", Ge), Ve.meta.distance = 0;
          }
        });
      }), !n.value && r.value.length > 0 && (n.value = r.value[0].id)) : await S();
    } else await S();
  }
  async function S() {
    const ve = new Yl();
    ve.meta.name = "Default Sketch", r.value = [ve], n.value = ve.id, await Io("sketches", r.value.map((le) => le.toStorage())), await Eo();
  }
  async function P(ve = "New Sketch") {
    const le = new Yl();
    return le.meta.name = ve, r.value.push(le), await Io("sketches", r.value.map((ue) => ue.toStorage())), await Eo(), le;
  }
  async function M(ve, le) {
    const ue = r.value.find((be) => be.id === ve);
    ue && (le.name !== void 0 && ue.updateName(le.name), le.description !== void 0 && ue.updateDescription(le.description), le.tags !== void 0 && (ue.meta.tags.forEach((be) => ue.removeTag(be)), le.tags.forEach((be) => ue.addTag(be))), await Io("sketches", r.value.map((be) => be.toStorage())), await Eo());
  }
  async function A(ve) {
    const le = r.value.findIndex((ue) => ue.id === ve);
    le !== -1 && (r.value.splice(le, 1), n.value === ve && (n.value = r.value.length > 0 ? r.value[0].id : null), await Io("sketches", r.value.map((ue) => ue.toStorage())), await Eo());
  }
  function O(ve) {
    n.value = ve, l.value = null;
  }
  async function j(ve, le = {}, ue = {}) {
    y.value || await S();
    const be = new a0(void 0, [], le, ue);
    return be.meta.name = ve, y.value && y.value.routes.routes.push(be.exportToStorage()), await Io("sketches", r.value.map((Ve) => Ve.toStorage())), await Eo(), be;
  }
  async function L(ve) {
    if (!y.value) return;
    const le = y.value.routes.routes.findIndex((ue) => ue.id === ve);
    le !== -1 && (y.value.routes.routes.splice(le, 1), l.value === ve && (l.value = null), await Io("sketches", r.value.map((ue) => ue.toStorage())), await Eo());
  }
  async function q(ve, le) {
    if (!y.value) return;
    const ue = y.value.routes.routes.find((be) => be.id === ve);
    if (ue) {
      if (ue.points.push(le), ue.meta.modification_timestamp = Date.now(), ue.points.length > 1) try {
        if (ue.meta.distance) {
          const be = await Ng([ue.points[ue.points.length - 2], le]);
          ue.meta.distance += be;
        } else {
          const be = await Ng(ue.points);
          ue.meta.distance = be;
        }
      } catch (be) {
        console.warn("Failed to calculate route distance:", be), ue.meta.distance || (ue.meta.distance = 0);
      }
      await Io("sketches", r.value.map((be) => be.toStorage())), await Eo();
    }
  }
  async function N(ve, le) {
    if (!y.value) return;
    const ue = y.value.routes.routes.find((be) => be.id === ve);
    ue && (le.meta !== void 0 && (ue.meta = { ...ue.meta, ...le.meta }), le.properties !== void 0 && (ue.properties = { ...ue.properties, ...le.properties }), ue.meta.modification_timestamp = Date.now(), await Io("sketches", r.value.map((be) => be.toStorage())), await Eo());
  }
  async function J(ve) {
    if (!y.value) return;
    const le = y.value.routes.routes.find((ue) => ue.id === ve);
    le && (le.points = [], le.meta.modification_timestamp = Date.now(), await Io("sketches", r.value.map((ue) => ue.toStorage())), await Eo());
  }
  function te(ve) {
    if (!y.value) return null;
    const le = y.value.routes.routes.find((ue) => ue.id === ve);
    return le ? new a0(le.id, le.points, le.properties, le.meta) : null;
  }
  function ne(ve) {
    l.value = ve;
  }
  async function ae(ve, le = {}, ue = {}) {
    y.value || await S();
    const be = { id: crypto.randomUUID(), meta: { ...da(), ...ue }, shape: ve, properties: le };
    return y.value && y.value.drafts.drafts.push(be), await Io("sketches", r.value.map((Ve) => Ve.toStorage())), await Eo(), be;
  }
  async function oe(ve, le) {
    if (!y.value) return;
    const ue = y.value.drafts.drafts.find((be) => be.id === ve);
    ue && (le.shape !== void 0 && (ue.shape = le.shape), le.properties !== void 0 && (ue.properties = { ...ue.properties, ...le.properties }), le.meta !== void 0 && (ue.meta = { ...ue.meta, ...le.meta }, ue.meta.modification_timestamp = Date.now()), await Io("sketches", r.value.map((be) => be.toStorage())), await Eo());
  }
  async function ee(ve) {
    if (!y.value) return;
    const le = y.value.drafts.drafts.findIndex((ue) => ue.id === ve);
    le !== -1 && (y.value.drafts.drafts.splice(le, 1), await Io("sketches", r.value.map((ue) => ue.toStorage())), await Eo());
  }
  function ke(ve) {
    return y.value && y.value.drafts.drafts.find((le) => le.id === ve) || null;
  }
  return { sketches: r, currentSketchId: n, currentRouteId: l, routeCollection: h, routes: f, currentSketch: y, currentDrafts: p, init: s, createSketch: P, updateSketch: M, deleteSketch: A, setCurrentSketchId: O, addRoute: j, deleteRoute: L, addPointToRoute: q, updateRoute: N, clearRoutePoints: J, getRouteById: te, setCurrentRouteId: ne, addDraft: ae, updateDraft: oe, deleteDraft: ee, getDraftById: ke };
}), Vx = X0("routes", () => {
  const r = hv(), n = Ae(() => r.routeCollection), l = Ae({ get: () => r.currentRouteId, set: (ee) => r.setCurrentRouteId(ee) }), h = Ee(0);
  Kt(l, (ee) => {
    var _a2, _b2;
    ee && (h.value = ((_b2 = (_a2 = r.getRouteById(ee)) == null ? void 0 : _a2.meta) == null ? void 0 : _b2.record_timespan) ?? 0);
  });
  const f = Ee(false), y = Ee(-1), p = Ee(null);
  let s;
  const S = Ae(() => r.routes);
  function P(ee) {
    p.value = ee;
  }
  async function M() {
    await r.init();
  }
  async function A(ee, ke = {}) {
    return await r.addRoute(ee, ke);
  }
  async function O(ee) {
    await r.deleteRoute(ee);
  }
  async function j(ee, ke) {
    await r.addPointToRoute(ee, ke);
  }
  async function L(ee, ke) {
    await r.updateRoute(ee, ke);
  }
  async function q(ee) {
    await r.clearRoutePoints(ee);
  }
  function N(ee) {
    return r.getRouteById(ee);
  }
  function J(ee) {
    r.setCurrentRouteId(ee);
  }
  function te(ee) {
    f.value || !p.value || (f.value = true, ee && j(l.value, ee), y.value = p.value.addLocationListener((ke) => {
      l.value && j(l.value, ke);
    }), r.updateRoute(l.value, { meta: { modification_timestamp: Date.now() } }), s = setInterval(async () => {
      const ke = r.getRouteById(l.value);
      ke.recordTimespan !== void 0 && ke.meta.modification_timestamp && (h.value = ke.recordTimespan + (Date.now() - ke.meta.modification_timestamp), await r.updateRoute(l.value, { meta: { record_timespan: h.value } }));
    }, 100));
  }
  function ne() {
    !f.value || !p.value || (y.value !== -1 && (p.value.removeLocationListener(y.value), y.value = -1), s && (clearTimeout(s), s = void 0), f.value = false);
  }
  async function ae(ee) {
    try {
      if (!p.value) throw new Error("Geolocation service not available");
      if (f.value) ne();
      else if (l.value) te();
      else {
        const ke = await A(ee("trackerView.nameNewRoute"));
        J(ke.id), te(p.value.getLastKnownLocation());
      }
    } catch (ke) {
      throw console.error(ke), ke;
    }
  }
  function oe() {
    y.value !== -1 && p.value && (p.value.removeLocationListener(y.value), y.value = -1), f.value = false;
  }
  return { routeCollection: n, routes: S, currentRouteId: l, isRecording: f, watchingHandler: y, currentRouteRecordTimespan: h, setLocator: P, init: M, addRoute: A, deleteRoute: O, addPointToRoute: j, updateRoute: L, clearRoutePoints: q, getRouteById: N, setCurrentRouteId: J, startRecording: te, stopRecording: ne, toggleRecording: ae, cleanup: oe };
}), tE = { class: "upload-container" }, rE = { class: "action-buttons" }, iE = nt({ __name: "TextFileUploaderDialog", props: cs({ multiple: { type: Boolean }, icon: {}, prompt: {}, types: {} }, { show: { default: false, type: Boolean }, showModifiers: {} }), emits: cs(["update:value", "confirm"], ["update:show"]), setup(r, { emit: n }) {
  const l = pm(), h = r, f = n, y = Dc(r, "show");
  let p = [];
  const s = (M) => {
    p = [];
    for (const A of M) {
      const O = A.file;
      if (O) if (h.types.includes(O.type)) {
        const j = new FileReader();
        j.onload = (L) => {
          var _a2;
          ((_a2 = L.target) == null ? void 0 : _a2.result) && p.push(L.target.result), p.length === M.length && f("update:value", p);
        }, j.readAsText(O);
      } else l.warning(`Skipped file ${A.name} due to unsupported type ${O.type}`);
    }
  }, S = () => {
    f("confirm", p), y.value = false;
  }, P = (M) => {
    var _a2, _b2;
    return h.types.includes(((_a2 = M.file.file) == null ? void 0 : _a2.type) ?? "") ? true : (l.error(`Unsupported file type ${((_b2 = M.file.file) == null ? void 0 : _b2.type) ?? "unknown"}. Supported types: ['${h.types.join("', '")}']`), false);
  };
  return (M, A) => (ut(), fr(K(kh), { show: y.value, "onUpdate:show": A[2] || (A[2] = (O) => y.value = O), preset: "dialog", title: "Dialog" }, { header: je(() => [...A[3] || (A[3] = [vr(" File Upload ", -1)])]), default: je(() => [xt("div", tE, [ze(K(yI), { multiple: h.multiple ?? false, onChange: A[0] || (A[0] = ({ fileList: O }) => s(O)), onBeforeUpload: P }, { default: je(() => [ze(K(Ix), null, { default: je(() => [ze(K(xi), { size: 36, name: "upload", class: "upload-icon" }, { default: je(() => [(ut(), fr($c(h.icon ?? K(U1))))]), _: 1 }), xt("div", null, Jt(h.prompt ?? "Drag and drop a file here or click to upload"), 1)]), _: 1 })]), _: 1 }, 8, ["multiple"])])]), action: je(() => [xt("div", rE, [ze(K(Or), { onClick: A[1] || (A[1] = (O) => y.value = false) }, { default: je(() => [...A[4] || (A[4] = [vr(" Cancel ", -1)])]), _: 1 }), ze(K(Or), { type: "primary", onClick: S }, { default: je(() => [...A[5] || (A[5] = [vr(" Upload ", -1)])]), _: 1 })])]), _: 1 }, 8, ["show"]));
} }), nE = Ui(iE, [["__scopeId", "data-v-14c5a0c1"]]), oE = nt({ __name: "MglDrawer", props: cs({ position: {} }, { show: { type: Boolean, default: false }, showModifiers: {} }), emits: cs(["update:width", "update:height", "click", "contextmenu"], ["update:show"]), setup(r, { emit: n }) {
  Gs((O) => ({ a1b7bba2: K(f).modalColor, v305889d2: K(f).borderRadius, v60287bc6: M.value, v048a7f4c: P.value }));
  const l = r, h = n, f = Vs(), y = o3("route-drawer"), p = Ae(() => l.position || "left"), s = Ae(() => {
    var _a2, _b2, _c2, _d;
    return Math.min(P0(Math.round((((_b2 = (_a2 = y.value) == null ? void 0 : _a2.parentElement) == null ? void 0 : _b2.clientWidth) ?? 2e3) * 0.4), 320, 640), (((_d = (_c2 = y.value) == null ? void 0 : _c2.parentElement) == null ? void 0 : _d.clientWidth) ?? 1 / 0) - 48);
  }), S = Ae(() => {
    var _a2, _b2, _c2, _d;
    return Math.min(P0(Math.round((((_b2 = (_a2 = y.value) == null ? void 0 : _a2.parentElement) == null ? void 0 : _b2.clientHeight) ?? 2e3) * 0.4), 320, 640), (((_d = (_c2 = y.value) == null ? void 0 : _c2.parentElement) == null ? void 0 : _d.clientHeight) ?? 1 / 0) - 48);
  }), P = Ae(() => p.value === "left" ? `${-16 - s.value}px` : p.value === "right" ? `${16 + s.value}px` : p.value === "top" ? `${-16 - S.value}px` : p.value === "bottom" ? `${16 + S.value}px` : "0px"), M = Ae(() => p.value === "left" || p.value === "right" ? `${s.value}px` : `${S.value}px`), A = Dc(r, "show");
  return Kt(s, () => h("update:width", s.value)), Kt(S, () => h("update:height", S.value)), (O, j) => (ut(), fr(Wo, { name: `slide-${p.value}` }, { default: je(() => [za(xt("div", { ref: "route-drawer", class: ha(["route-drawer", `route-drawer--${p.value}`]), onClick: j[0] || (j[0] = (L) => h("click", L)), onContextmenu: j[1] || (j[1] = (L) => h("contextmenu", L)) }, [tm(O.$slots, "default", {}, void 0, true)], 34), [[us, A.value]])]), _: 3 }, 8, ["name"]));
} }), aE = Ui(oE, [["__scopeId", "data-v-72b274a7"]]), sE = { class: "menu-list" }, lE = ["onClick", "onContextmenu", "onTouchstart"], uE = { class: "swipe-container" }, cE = { style: { height: "fit-content", padding: "8px 12px" } }, dE = ["onClick"], hE = { style: { padding: "16px" } }, fE = 120, pE = 40, mE = nt({ __name: "SelectableSwipeableMenuList", props: cs({ items: {}, menuOptions: {}, swipeActions: {} }, { selection: { type: String, default: null }, selectionModifiers: {}, multipleSelection: { type: Array, default: () => [] }, multipleSelectionModifiers: {} }), emits: cs(["contextmenu"], ["update:selection", "update:multipleSelection"]), setup(r, { emit: n }) {
  Gs((ae) => ({ af602246: K(p).hoverColor, v2c598f52: K(p).primaryColor, f032366a: K(p).bodyColor, v6ce963b2: s.value }));
  const l = r, h = Dc(r, "selection"), f = Dc(r, "multipleSelection"), y = n, p = Vs(), s = Ee("0s"), S = Ee({ startX: 0, delta: 0, currentX: 0, containerWidth: 0, activeId: null, leftMax: 0, rightMax: 0 }), P = Ee(false), M = Ee(0), A = Ee(0), O = Ee(null);
  function j(ae, oe) {
    S.value.activeId !== oe && J();
    const ee = ae.touches[0];
    S.value = { startX: ee.clientX, delta: S.value.delta ?? 0, currentX: ee.clientX, containerWidth: ae.currentTarget.offsetWidth, activeId: oe, leftMax: fE, rightMax: pE };
  }
  function L(ae) {
    S.value.activeId && (S.value.currentX = ae.touches[0].clientX, S.value.delta += S.value.currentX - S.value.startX, S.value.delta = P0(S.value.delta, -S.value.leftMax, S.value.rightMax), S.value.startX = ae.touches[0].clientX);
  }
  function q() {
    if (!S.value.activeId) return;
    s.value = `${Math.abs(S.value.delta) / S.value.containerWidth * 0.3}s`, setTimeout(() => {
      s.value = "0s";
    }, 300);
    const ae = S.value.delta < 0 ? S.value.leftMax : S.value.rightMax;
    S.value.delta = Math.abs(S.value.delta) > ae * 0.4 ? Math.sign(S.value.delta) * ae : 0, S.value.delta === 0 && Math.abs(S.value.delta) < 5;
  }
  function N(ae, oe) {
    ae.stopPropagation(), !(S.value.delta > 5) && (J(), h.value !== oe.id && (h.value = oe.id));
  }
  function J() {
    S.value.delta > 0 || (S.value = { startX: 0, delta: 0, currentX: 0, containerWidth: 0, activeId: null, leftMax: 0, rightMax: 0 });
  }
  function te(ae, oe) {
    if (ae.stopPropagation(), ae.preventDefault(), P.value) {
      P.value = false;
      return;
    }
    O.value = oe, M.value = ae.clientX, A.value = ae.clientY, P.value = true, y("contextmenu", ae, oe);
  }
  function ne(ae) {
    const oe = [...f.value];
    if (oe.includes(ae)) {
      const ee = oe.indexOf(ae);
      oe.splice(ee, 1);
    } else oe.push(ae);
    f.value = oe;
  }
  return (ae, oe) => (ut(), Ot(jr, null, [xt("div", sE, [(ut(true), Ot(jr, null, un(l.items, (ee) => (ut(), Ot("div", { key: ee.id, class: ha(["menu-list-item", ...ee.id === h.value ? ["active"] : []]), style: zn({ "touch-action": S.value.activeId === ee.id ? "pan-y" : "auto" }), onClick: (ke) => N(ke, ee), onContextmenu: wh((ke) => te(ke, ee), ["prevent"]), onTouchstart: (ke) => j(ke, ee.id), onTouchmove: L, onTouchend: q }, [xt("div", uE, [xt("div", { class: "content-col", style: zn({ transform: `translateX(${S.value.activeId === ee.id || S.value.delta > 0 ? S.value.delta : 0}px)`, willChange: S.value.activeId === ee.id ? "transform" : "auto", flexDirection: S.value.delta >= 0 || S.value.activeId !== ee.id ? "row" : "row-reverse" }) }, [tm(ae.$slots, "item", { item: ee }, () => [xt("div", cE, [xt("div", null, Jt(ee.name ?? "Untitled"), 1)])], true)], 4), xt("div", { class: "actions-col", style: zn({ width: `${S.value.activeId === ee.id && S.value.delta < 0 ? -S.value.delta : 0}px`, visibility: S.value.activeId === ee.id && S.value.delta < 0 ? "visible" : "hidden", willChange: S.value.activeId === ee.id ? "width" : "auto" }) }, [(ut(true), Ot(jr, null, un(l.swipeActions, (ke) => (ut(), Ot("button", { key: ke.name, class: "menu-action", style: zn({ background: ke.color || K(p).primaryColorSuppl }), onClick: () => {
    ke.action(ee.id), S.value.activeId = null;
  } }, Jt(ke.label), 13, dE))), 128))], 4), xt("div", { class: "select-col", style: zn({ width: `${S.value.delta > 0 ? S.value.delta : 0}px`, backgroundColor: h.value === ee.id ? K(p).primaryColor : "transparent", visibility: S.value.delta > 0 ? "visible" : "hidden" }) }, [xt("div", hE, [ze(K(i5), { checked: f.value.includes(ee.id), style: zn({ border: h.value === ee.id ? `1px solid ${K(p).bodyColor}` : "none", BorderRadius: h.value === ee.id ? K(p).borderRadiusSmall : "none" }), "onUpdate:checked": () => ne(ee.id) }, null, 8, ["checked", "style", "onUpdate:checked"])])], 4)])], 46, lE))), 128))]), ze(K(C1), { show: P.value, x: M.value, y: A.value, options: l.menuOptions.map((ee) => {
    var _a2;
    return { ...ee, label: ((_a2 = ee.label) == null ? void 0 : _a2.value) ?? ee.label };
  }), placement: "bottom-start", trigger: "manual", onClick: oe[0] || (oe[0] = (ee) => P.value = false), onClickoutside: oe[1] || (oe[1] = (ee) => P.value = false) }, null, 8, ["show", "x", "y", "options"])], 64));
} }), gE = Ui(mE, [["__scopeId", "data-v-b353d352"]]), vE = { class: "drawer-floating" }, yE = { class: "drawer-container" }, _E = { class: "drawer-header" }, bE = { class: "drawer-title" }, xE = { class: "drawer-content" }, wE = { style: { height: "fit-content", padding: "8px 12px", "text-align": "left" } }, CE = { style: { "font-size": "0.8rem", opacity: "0.7", display: "flex", "flex-direction": "row", gap: "12px" } }, SE = { key: 0 }, kE = nt({ __name: "TrackerViewRouteDrawer", props: { show: { type: Boolean, default: false }, showModifiers: {} }, emits: cs(["update:width"], ["update:show"]), setup(r, { emit: n }) {
  Gs((ve) => ({ v38b2b83c: K(S).borderRadius, v3ddcb48b: K(S).hoverColor, v485009dd: K(S).primaryColorPressed, v4f454a85: K(S).primaryColor, v73f3b15d: K(S).bodyColor }));
  const h = new jc().isMobile, { t: f } = Gn(), y = ux(), p = n, s = Vx(), S = Vs(), P = Dc(r, "show"), M = Ee(false), A = Ee(0), O = Ee(0), j = Ee(null), L = Ee(false), q = Ee(""), N = Ee(null), J = [{ label: Ae(() => f("components.trackerViewRouteDrawer.contextMenu.new")), key: "new", props: { onClick: () => {
    M.value = false, s.addRoute(f("components.trackerViewRouteDrawer.nameNewRoute"));
  } } }], te = [{ label: Ae(() => f("components.trackerViewRouteDrawer.contextMenu.rename")), key: "rename", props: { onClick: () => {
    var _a2;
    ((_a2 = j.value) == null ? void 0 : _a2.id) && (q.value = j.value.name || "", L.value = true);
  } } }, { label: Ae(() => f("components.trackerViewRouteDrawer.contextMenu.delete")), key: "delete", props: { onClick: () => {
    j.value && s.deleteRoute(j.value.id);
  } } }, { key: "divider-1", type: "divider" }, ...J], ne = [{ label: Ae(() => f("components.trackerViewRouteDrawer.contextMenu.rename")), name: "rename", action: (ve) => {
    const le = s.routes.find((ue) => ue.id === ve);
    N.value = ve, q.value = (le == null ? void 0 : le.name) || "", L.value = true;
  } }, { label: Ae(() => f("components.trackerViewRouteDrawer.contextMenu.delete")), name: "delete", action: (ve) => s.deleteRoute(ve), color: S.value.errorColorSuppl }];
  function ae(ve) {
    if (ve.stopPropagation(), ve.preventDefault(), N.value = s.currentRouteId, M.value) {
      M.value = false;
      return;
    }
    A.value = ve.clientX, O.value = ve.clientY, M.value = true;
  }
  async function oe(ve) {
    q.value.trim() && (await s.updateRoute(ve, { meta: { name: q.value.trim() } }), L.value = false);
  }
  const ee = Ee([]);
  function ke() {
    y.warning({ title: f("components.trackerViewRouteDrawer.deleteConfirmation.title"), content: f("components.trackerViewRouteDrawer.deleteConfirmation.prompt"), positiveText: f("components.trackerViewRouteDrawer.deleteConfirmation.yes"), negativeText: f("components.trackerViewRouteDrawer.deleteConfirmation.no"), onPositiveClick: () => {
      ee.value.forEach((ve) => {
        s.deleteRoute(ve), ee.value = ee.value.filter((le) => le !== ve);
      });
    } });
  }
  return (ve, le) => (ut(), Ot(jr, null, [ze(aE, { show: P.value, "onUpdate:show": le[3] || (le[3] = (ue) => P.value = ue), position: K(h) ? "bottom" : "left", onClick: le[4] || (le[4] = () => K(s).currentRouteId = null), "onUpdate:width": le[5] || (le[5] = (ue) => p("update:width", ue)), onContextmenu: le[6] || (le[6] = (ue) => ae(ue)) }, { default: je(() => [xt("div", vE, [K(h) && P.value ? tm(ve.$slots, "bottom-floating", { key: 0 }, void 0, true) : _r("", true)]), xt("div", yE, [xt("div", _E, [xt("p", bE, Jt(K(f)("components.trackerViewRouteDrawer.routes")), 1), ee.value.length > 0 ? (ut(), fr(K(Or), { key: 0, strong: "", secondary: "", circle: "", type: "error", onClick: ke }, { icon: je(() => [ze(K(xi), { component: K(dm) }, null, 8, ["component"])]), _: 1 })) : _r("", true)]), xt("div", xE, [ze(gE, { selection: K(s).currentRouteId, "onUpdate:selection": le[0] || (le[0] = (ue) => K(s).currentRouteId = ue), "multiple-selection": ee.value, "onUpdate:multipleSelection": le[1] || (le[1] = (ue) => ee.value = ue), items: K(s).routes, "menu-options": te, "swipe-actions": ne, onContextmenu: le[2] || (le[2] = (ue, be) => {
    N.value = (be == null ? void 0 : be.id) ?? null, j.value = be ?? null;
  }) }, { item: je(({ item: ue }) => {
    var _a2;
    return [xt("div", wE, [xt("div", null, Jt(ue.name ?? K(f)("components.trackerViewRouteDrawer.nameNewRoute")), 1), xt("div", CE, [xt("div", null, Jt(K(f)("components.trackerViewRouteDrawer.points", { num: ue.points.length })), 1), ue.points.length > 1 && ((_a2 = ue.meta) == null ? void 0 : _a2.distance) ? (ut(), Ot("div", SE, Jt(K(f)("components.trackerViewRouteDrawer.distance", { distance: K(a3)(ue.meta.distance) })), 1)) : _r("", true)])])];
  }), _: 1 }, 8, ["selection", "multiple-selection", "items"])])])]), _: 3 }, 8, ["show", "position"]), ze(K(C1), { show: M.value, x: A.value, y: O.value, options: J.map((ue) => ({ ...ue, label: ue.label.value })), placement: "bottom-start", trigger: "manual", onClickoutside: le[7] || (le[7] = (ue) => M.value = false) }, null, 8, ["show", "x", "y", "options"]), ze(K(kh), { show: L.value, "onUpdate:show": le[10] || (le[10] = (ue) => L.value = ue), preset: "dialog", title: "Rename Route", "positive-text": "Save", "negative-text": "Cancel", onPositiveClick: le[11] || (le[11] = () => {
    N.value && oe(N.value);
  }) }, { default: je(() => [ze(K(Do), { value: q.value, "onUpdate:value": le[8] || (le[8] = (ue) => q.value = ue), placeholder: "Enter new route name", onKeyup: le[9] || (le[9] = Qb(() => {
    N.value && oe(N.value);
  }, ["enter"])) }, null, 8, ["value"])]), _: 1 }, 8, ["show"])], 64));
} }), TE = Ui(kE, [["__scopeId", "data-v-a6ce157e"]]), Ux = X0("map", () => {
  const r = Ee(7), n = Ee([0, 0]), l = Ee(0), h = Ee(0), f = Ee(false);
  async function y() {
    const O = await w1("mapState");
    O && (r.value = O.zoom, n.value = O.center, l.value = O.bearing, f.value = O.isTrackingOrientation, h.value = O.lastUpdateTime);
  }
  async function p() {
    h.value = Date.now();
    const O = { zoom: r.value, center: n.value, bearing: l.value, isTrackingOrientation: f.value, lastUpdateTime: h.value };
    await Io("mapState", JSON.parse(JSON.stringify(O))), await Eo();
  }
  function s(O) {
    r.value = O;
  }
  function S(O) {
    n.value = O.toLngLatLike();
  }
  function P(O) {
    l.value = O;
  }
  function M(O) {
    f.value = O;
  }
  function A() {
    r.value = 7, n.value = [0, 0], l.value = 0, f.value = false;
  }
  return Kt([r, n, l, f], p, { deep: true }), { zoom: r, center: n, bearing: l, isTrackingOrientation: f, lastUpdateTime: h, init: y, save: p, setZoom: s, setCenter: S, setBearing: P, setTrackingOrientation: M, resetToDefault: A };
});
function PE() {
  for (const r of js.handlers) r.callback(360 - js.bearing);
}
var js;
((r) => {
  r.bearing = 0;
  let n = false;
  r.handlers = [];
  function l(p) {
    if (!(yk(p.alpha) || typeof p.webkitCompassHeading < "u")) {
      y();
      return;
    }
    r.bearing = p.alpha, typeof p.webkitCompassHeading < "u" && (r.bearing = p.webkitCompassHeading), PE();
  }
  r.updater = l;
  function h(p) {
    const s = r.handlers.length > 0 ? r.handlers[r.handlers.length - 1].id + 1 : 0;
    return r.handlers.push({ callback: p, id: s }), s;
  }
  r.addHandler = h;
  function f() {
    n || (window.addEventListener("deviceorientation", l, true), n = true);
  }
  r.start = f;
  function y() {
    n && (window.removeEventListener("deviceorientation", l, true), n = false);
  }
  r.stop = y;
})(js || (js = {}));
function bn() {
  return bn = Object.assign ? Object.assign.bind() : function(r) {
    for (var n = 1; n < arguments.length; n++) {
      var l = arguments[n];
      for (var h in l) ({}).hasOwnProperty.call(l, h) && (r[h] = l[h]);
    }
    return r;
  }, bn.apply(null, arguments);
}
var Vn;
(function(r) {
  r.Commit = "commit", r.Provisional = "provisional", r.Finish = "finish";
})(Vn || (Vn = {}));
const IE = "https://raw.githubusercontent.com/JamesLMilner/terra-draw/refs/heads/main/assets/markers/marker-blue.png", Ji = { SELECTED: "selected", MID_POINT: "midPoint", SELECTION_POINT_FEATURE_ID: "selectionPointFeatureId", SELECTION_POINT: "selectionPoint" }, Ti = { MODE: "mode", CURRENTLY_DRAWING: "currentlyDrawing", EDITED: "edited", CLOSING_POINT: "closingPoint", SNAPPING_POINT: "snappingPoint", COORDINATE_POINT: "coordinatePoint", COORDINATE_POINT_FEATURE_ID: "coordinatePointFeatureId", COORDINATE_POINT_IDS: "coordinatePointIds", PROVISIONAL_COORDINATE_COUNT: "provisionalCoordinateCount", COMMITTED_COORDINATE_COUNT: "committedCoordinateCount", MARKER: "marker" }, jp = 10;
function s0(r) {
  return !!(r && typeof r == "object" && r !== null && !Array.isArray(r));
}
function _b(r) {
  return !!(r && typeof r == "object" && "properties" in r && typeof r.properties == "object" && r.properties !== null && "mode" in r.properties);
}
function bb(r) {
  return !!(function(n) {
    return typeof n == "number" && !isNaN(new Date(n).valueOf());
  })(r);
}
const EE = "Feature mode property does not match the mode being added to";
var zc;
(function(r) {
  r.Drawing = "drawing", r.Select = "select", r.Static = "static", r.Render = "render";
})(zc || (zc = {}));
const ME = { rightClick: true, contextMenu: false, leftClick: true, onDragStart: true, onDrag: true, onDragEnd: true };
class ym {
  get state() {
    return this._state;
  }
  set state(n) {
    throw new Error("Please use the modes lifecycle methods");
  }
  get styles() {
    return this._styles;
  }
  set styles(n) {
    if (typeof n != "object") throw new Error("Styling must be an object");
    this.onStyleChange && this.onStyleChange([], "styling"), this._styles = n;
  }
  registerBehaviors(n) {
  }
  constructor(n, l = false) {
    this._state = "unregistered", this._styles = {}, this.pointerEvents = ME, this.behaviors = [], this.validate = void 0, this.pointerDistance = 40, this.coordinatePrecision = void 0, this.onStyleChange = void 0, this.store = void 0, this.projection = "web-mercator", this.setDoubleClickToZoom = void 0, this.unproject = void 0, this.project = void 0, this.setCursor = void 0, this.isInitialUpdate = false, this.type = zc.Drawing, this.mode = "base", l ? this.isInitialUpdate = true : this.updateOptions(bn({}, n));
  }
  updateOptions(n) {
    n != null && n.styles && (this.styles = bn({}, this._styles, n.styles)), n != null && n.pointerDistance && (this.pointerDistance = n.pointerDistance), n != null && n.validation && (this.validate = n && n.validation), n != null && n.projection && (this.projection = n.projection), (n == null ? void 0 : n.pointerEvents) !== void 0 && (this.pointerEvents = n.pointerEvents), n != null && n.modeName && this.isInitialUpdate === true && (this.mode = n.modeName), this.isInitialUpdate = false;
  }
  allowPointerEvent(n, l) {
    return typeof n == "boolean" ? n : typeof n != "function" || n(l);
  }
  setDrawing() {
    if (this._state !== "started") throw new Error("Mode must be unregistered or stopped to start");
    this._state = "drawing";
  }
  setStarted() {
    if (this._state !== "stopped" && this._state !== "registered" && this._state !== "drawing" && this._state !== "selecting") throw new Error("Mode must be unregistered or stopped to start");
    this._state = "started", this.setDoubleClickToZoom(false);
  }
  setStopped() {
    if (this._state !== "started") throw new Error("Mode must be started to be stopped");
    this._state = "stopped", this.setDoubleClickToZoom(true);
  }
  register(n) {
    if (this._state !== "unregistered") throw new Error("Can not register unless mode is unregistered");
    this._state = "registered", this.store = n.store, this.store.registerOnChange(n.onChange), this.setDoubleClickToZoom = n.setDoubleClickToZoom, this.project = n.project, this.unproject = n.unproject, this.onSelect = n.onSelect, this.onDeselect = n.onDeselect, this.setCursor = n.setCursor, this.onStyleChange = n.onChange, this.onFinish = n.onFinish, this.coordinatePrecision = n.coordinatePrecision, this.registerBehaviors({ mode: n.mode, store: this.store, project: this.project, unproject: this.unproject, pointerDistance: this.pointerDistance, coordinatePrecision: n.coordinatePrecision, projection: this.projection });
  }
  validateFeature(n) {
    return this.performFeatureValidation(n);
  }
  afterFeatureAdded(n) {
  }
  afterFeatureUpdated(n) {
  }
  performFeatureValidation(n) {
    if (this._state === "unregistered") throw new Error("Mode must be registered");
    const l = (function(h, f) {
      let y;
      if (s0(h)) if (h.id == null) y = "Feature has no id";
      else if (typeof h.id != "string" && typeof h.id != "number") y = "Feature must be string or number as per GeoJSON spec";
      else if (f(h.id)) if (s0(h.geometry)) if (s0(h.properties)) if (typeof h.geometry.type == "string" && ["Polygon", "LineString", "Point"].includes(h.geometry.type)) if (Array.isArray(h.geometry.coordinates)) {
        if (!h.properties.mode || typeof h.properties.mode != "string") return { valid: false, reason: "Feature does not have a valid mode property" };
      } else y = "Feature coordinates is not an array";
      else y = "Feature is not Point, LineString or Polygon";
      else y = "Feature has no properties";
      else y = "Feature has no geometry";
      else y = "Feature must match the id strategy (default is UUID4)";
      else y = "Feature is not object";
      return y ? { valid: false, reason: y } : { valid: true };
    })(n, this.store.idStrategy.isValidId);
    if (this.validate) {
      const h = this.validate(n, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Vn.Provisional });
      return { valid: l.valid && h.valid, reason: h.reason };
    }
    return { valid: l.valid, reason: l.reason };
  }
  validateModeFeature(n, l) {
    const h = this.performFeatureValidation(n);
    return h.valid ? n.properties.mode !== this.mode ? { valid: false, reason: EE } : l(n) : { valid: false, reason: h.reason };
  }
  onFinish(n, l) {
  }
  onDeselect(n) {
  }
  onSelect(n) {
  }
  onKeyDown(n) {
  }
  onKeyUp(n) {
  }
  onMouseMove(n) {
  }
  onClick(n) {
  }
  onDragStart(n, l) {
  }
  onDrag(n, l) {
  }
  onDragEnd(n, l) {
  }
  getHexColorStylingValue(n, l, h) {
    return this.getStylingValue(n, l, h);
  }
  getNumericStylingValue(n, l, h) {
    return this.getStylingValue(n, l, h);
  }
  getUrlStylingValue(n, l, h) {
    return this.getStylingValue(n, l, h);
  }
  getStylingValue(n, l, h) {
    return n === void 0 ? l : typeof n == "function" ? n(h) : n;
  }
}
class DE extends ym {
  constructor(...n) {
    super(...n), this.type = zc.Select;
  }
}
function hs(r, n) {
  const l = (P) => P * Math.PI / 180, h = l(r[1]), f = l(r[0]), y = l(n[1]), p = y - h, s = l(n[0]) - f, S = Math.sin(p / 2) * Math.sin(p / 2) + Math.cos(h) * Math.cos(y) * Math.sin(s / 2) * Math.sin(s / 2);
  return 2 * Math.atan2(Math.sqrt(S), Math.sqrt(1 - S)) * 6371e3 / 1e3;
}
const Gx = 63710088e-1;
function ho(r) {
  return r % 360 * Math.PI / 180;
}
function RE(r) {
  return r / 6371.0088;
}
function Fc(r) {
  return r % (2 * Math.PI) * 180 / Math.PI;
}
function Li(r, n = 9) {
  const l = Math.pow(10, n);
  return Math.round(r * l) / l;
}
const xb = 57.29577951308232, wb = 0.017453292519943295, Xp = 6378137, Fi = (r, n) => ({ x: r === 0 ? 0 : r * wb * Xp, y: n === 0 ? 0 : Math.log(Math.tan(Math.PI / 4 + n * wb / 2)) * Xp }), Lc = (r, n) => ({ lng: r === 0 ? 0 : xb * (r / Xp), lat: n === 0 ? 0 : (2 * Math.atan(Math.exp(n / Xp)) - Math.PI / 2) * xb });
function AE(r) {
  let n;
  if (r.geometry.type === "Polygon") n = r.geometry.coordinates;
  else {
    if (r.geometry.type !== "LineString") throw new Error("Self intersects only accepts Polygons and LineStrings");
    n = [r.geometry.coordinates];
  }
  const l = [];
  for (let y = 0; y < n.length; y++) for (let p = 0; p < n[y].length - 1; p++) for (let s = 0; s < n.length; s++) for (let S = 0; S < n[s].length - 1; S++) f(y, p, s, S);
  return l.length > 0;
  function h(y) {
    return y < 0 || y > 1;
  }
  function f(y, p, s, S) {
    const P = n[y][p], M = n[y][p + 1], A = n[s][S], O = n[s][S + 1], j = (function(N, J, te, ne) {
      if (Ip(N, te) || Ip(N, ne) || Ip(J, te) || Ip(ne, te)) return null;
      const ae = N[0], oe = N[1], ee = J[0], ke = J[1], ve = te[0], le = te[1], ue = ne[0], be = ne[1], Ve = (ae - ee) * (le - be) - (oe - ke) * (ve - ue);
      return Ve === 0 ? null : [((ae * ke - oe * ee) * (ve - ue) - (ae - ee) * (ve * be - le * ue)) / Ve, ((ae * ke - oe * ee) * (le - be) - (oe - ke) * (ve * be - le * ue)) / Ve];
    })(P, M, A, O);
    if (j === null) return;
    let L, q;
    L = M[0] !== P[0] ? (j[0] - P[0]) / (M[0] - P[0]) : (j[1] - P[1]) / (M[1] - P[1]), q = O[0] !== A[0] ? (j[0] - A[0]) / (O[0] - A[0]) : (j[1] - A[1]) / (O[1] - A[1]), h(L) || h(q) || (j.toString(), l.push(j));
  }
}
function Ip(r, n) {
  return r[0] === n[0] && r[1] === n[1];
}
function fv(r, n) {
  return Cb(r[0]) <= n && Cb(r[1]) <= n;
}
function qx(r) {
  return r.length === 2 && typeof r[0] == "number" && typeof r[1] == "number" && r[0] !== 1 / 0 && r[1] !== 1 / 0 && (l = r[0]) >= -180 && l <= 180 && (n = r[1]) >= -90 && n <= 90;
  var n, l;
}
function Cb(r) {
  let n = 1, l = 0;
  for (; Math.round(r * n) / n !== r; ) n *= 10, l++;
  return l;
}
const Aa = (r, n) => {
  const { x: l, y: h } = r, { x: f, y } = n, p = f - l, s = y - h;
  return Math.sqrt(s * s + p * p);
};
class po {
  constructor({ store: n, mode: l, project: h, unproject: f, pointerDistance: y, coordinatePrecision: p, projection: s }) {
    this.store = void 0, this.mode = void 0, this.project = void 0, this.unproject = void 0, this.pointerDistance = void 0, this.coordinatePrecision = void 0, this.projection = void 0, this.store = n, this.mode = l, this.project = h, this.unproject = f, this.pointerDistance = y, this.coordinatePrecision = p, this.projection = s;
  }
}
function Wx({ unproject: r, point: n, pointerDistance: l }) {
  const h = l / 2, { x: f, y } = n;
  return { type: "Feature", properties: {}, geometry: { type: "Polygon", coordinates: [[r(f - h, y - h), r(f + h, y - h), r(f + h, y + h), r(f - h, y + h), r(f - h, y - h)].map((p) => [p.lng, p.lat])] } };
}
class Yp extends po {
  constructor(n) {
    super(n);
  }
  create(n) {
    const { containerX: l, containerY: h } = n;
    return Wx({ unproject: this.unproject, point: { x: l, y: h }, pointerDistance: this.pointerDistance });
  }
}
class Kp extends po {
  constructor(n) {
    super(n);
  }
  measure(n, l) {
    const { x: h, y: f } = this.project(l[0], l[1]);
    return Aa({ x: h, y: f }, { x: n.containerX, y: n.containerY });
  }
}
let j0 = class extends po {
  constructor(n, l, h) {
    super(n), this.config = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.getSnappableCoordinateFirstClick = (f) => this.getSnappable(f, (y) => !!(y.properties && y.properties.mode === this.mode)).coordinate, this.getSnappableCoordinate = (f, y) => this.getSnappable(f, (p) => !!(p.properties && p.properties.mode === this.mode && p.id !== y)).coordinate, this.config = n, this.pixelDistance = l, this.clickBoundingBox = h;
  }
  getSnappable(n, l) {
    const h = this.clickBoundingBox.create(n), f = this.store.search(h, l), y = { featureId: void 0, featureCoordinateIndex: void 0, coordinate: void 0, minDist: 1 / 0 };
    return f.forEach((p) => {
      let s;
      if (p.geometry.type === "Polygon") s = p.geometry.coordinates[0];
      else {
        if (p.geometry.type !== "LineString") return;
        s = p.geometry.coordinates;
      }
      s.forEach((S, P) => {
        const M = this.pixelDistance.measure(n, S);
        M < y.minDist && M < this.pointerDistance && (y.coordinate = S, y.minDist = M, y.featureId = p.id, y.featureCoordinateIndex = P);
      });
    }), y;
  }
};
function Sb(r, n, l) {
  const h = ho(r[0]), f = ho(r[1]), y = ho(l), p = RE(n), s = Math.asin(Math.sin(f) * Math.cos(p) + Math.cos(f) * Math.sin(p) * Math.cos(y));
  return [Fc(h + Math.atan2(Math.sin(y) * Math.sin(p) * Math.cos(f), Math.cos(p) - Math.sin(f) * Math.sin(s))), Fc(s)];
}
function kb(r, n) {
  const l = ho(r[0]), h = ho(n[0]), f = ho(r[1]), y = ho(n[1]), p = Math.sin(h - l) * Math.cos(y), s = Math.cos(f) * Math.sin(y) - Math.sin(f) * Math.cos(y) * Math.cos(h - l);
  return Fc(Math.atan2(p, s));
}
function zE({ x: r, y: n }, { x: l, y: h }) {
  const f = l - r, y = h - n;
  if (f === 0 && y === 0) return 0;
  let p = Math.atan2(y, f);
  return p *= 180 / Math.PI, p > 180 ? p -= 360 : p < -180 && (p += 360), p;
}
function FE(r, n, l) {
  const h = [], f = r.length;
  let y, p, s, S = 0;
  for (let M = 0; M < r.length && !(n >= S && M === r.length - 1); M++) {
    if (S > n && h.length === 0) {
      if (y = n - S, !y) return h.push(r[M]), h;
      p = kb(r[M], r[M - 1]) - 180, s = Sb(r[M], y, p), h.push(s);
    }
    if (S >= l) return y = l - S, y ? (p = kb(r[M], r[M - 1]) - 180, s = Sb(r[M], y, p), h.push(s), h) : (h.push(r[M]), h);
    if (S >= n && h.push(r[M]), M === r.length - 1) return h;
    S += hs(r[M], r[M + 1]);
  }
  if (S < n && r.length === f) throw new Error("Start position is beyond line");
  const P = r[r.length - 1];
  return [P, P];
}
function Ep(r) {
  return r * (Math.PI / 180);
}
function Tb(r) {
  return r * (180 / Math.PI);
}
class LE extends po {
  constructor(n) {
    super(n), this.config = void 0, this.config = n;
  }
  generateInsertionCoordinates(n, l, h) {
    const f = [n, l];
    let y = 0;
    for (let P = 0; P < f.length - 1; P++) y += hs(f[0], f[1]);
    if (y <= h) return f;
    let p = y / h - 1;
    Number.isInteger(p) || (p = Math.floor(p) + 1);
    const s = [];
    for (let P = 0; P < p; P++) {
      const M = FE(f, h * P, h * (P + 1));
      s.push(M);
    }
    const S = [];
    for (let P = 0; P < s.length; P++) S.push(s[P][1]);
    return this.limitCoordinates(S);
  }
  generateInsertionGeodesicCoordinates(n, l, h) {
    const f = hs(n, l), y = (function(p, s, S) {
      const P = [], M = Ep(p[1]), A = Ep(p[0]), O = Ep(s[1]), j = Ep(s[0]);
      S += 1;
      const L = 2 * Math.asin(Math.sqrt(Math.sin((O - M) / 2) ** 2 + Math.cos(M) * Math.cos(O) * Math.sin((j - A) / 2) ** 2));
      if (L === 0 || isNaN(L)) return P;
      for (let q = 0; q <= S; q++) {
        const N = q / S, J = Math.sin((1 - N) * L) / Math.sin(L), te = Math.sin(N * L) / Math.sin(L), ne = J * Math.cos(M) * Math.cos(A) + te * Math.cos(O) * Math.cos(j), ae = J * Math.cos(M) * Math.sin(A) + te * Math.cos(O) * Math.sin(j), oe = J * Math.sin(M) + te * Math.sin(O);
        if (isNaN(ne) || isNaN(ae) || isNaN(oe)) continue;
        const ee = Math.atan2(oe, Math.sqrt(ne ** 2 + ae ** 2)), ke = Math.atan2(ae, ne);
        isNaN(ee) || isNaN(ke) || P.push([Tb(ke), Tb(ee)]);
      }
      return P.slice(1, -1);
    })(n, l, Math.floor(f / h));
    return this.limitCoordinates(y);
  }
  limitCoordinates(n) {
    return n.map((l) => [Li(l[0], this.config.coordinatePrecision), Li(l[1], this.config.coordinatePrecision)]);
  }
}
function BE(r, n) {
  return r[0] === n[0] && r[1] === n[1];
}
function OE(r, n) {
  if (r.geometry.type !== "LineString") return { valid: false, reason: "Feature is not a LineString" };
  if (r.geometry.coordinates.length < 2) return { valid: false, reason: "Feature has less than 2 coordinates" };
  for (let l = 0; l < r.geometry.coordinates.length; l++) {
    if (!qx(r.geometry.coordinates[l])) return { valid: false, reason: "Feature has invalid coordinates" };
    if (!fv(r.geometry.coordinates[l], n)) return { valid: false, reason: "Feature has coordinates with excessive precision" };
  }
  return { valid: true };
}
function Pb(r) {
  return Math.sqrt(Math.pow(r[0], 2) + Math.pow(r[1], 2) + Math.pow(r[2], 2));
}
function jl(r, n) {
  const l = (function(h, f) {
    const [y, p, s] = h, [S, P, M] = f;
    return y * S + p * P + s * M;
  })(r, n) / (Pb(r) * Pb(n));
  return Math.acos(Math.min(Math.max(l, -1), 1));
}
function l0(r) {
  const n = ho(r[1]), l = ho(r[0]);
  return [Math.cos(n) * Math.cos(l), Math.cos(n) * Math.sin(l), Math.sin(n)];
}
function Vl(r) {
  const [n, l, h] = r, f = Fc(Math.asin(h));
  return [Fc(Math.atan2(l, n)), f];
}
function $E(r, n, l) {
  const h = l0(r), f = l0(n), y = l0(l), [p, s, S] = y, [P, M, A] = (function(be, Ve) {
    const [Ge, et, dt] = be, [Ct, kt, ct] = Ve;
    return [et * ct - dt * kt, dt * Ct - Ge * ct, Ge * kt - et * Ct];
  })(h, f), O = M * S - A * s, j = A * p - P * S, L = P * s - M * p, q = L * M - j * A, N = O * A - L * P, J = j * P - O * M, te = 1 / Math.sqrt(Math.pow(q, 2) + Math.pow(N, 2) + Math.pow(J, 2)), ne = [q * te, N * te, J * te], ae = [-1 * q * te, -1 * N * te, -1 * J * te], oe = jl(h, f), ee = jl(h, ne), ke = jl(f, ne), ve = jl(h, ae), le = jl(f, ae);
  let ue;
  return ue = ee < ve && ee < le || ke < ve && ke < le ? ne : ae, jl(h, ue) > oe || jl(f, ue) > oe ? hs(Vl(ue), Vl(h)) <= hs(Vl(ue), Vl(f)) ? [Vl(h), true, false] : [Vl(f), false, true] : [Vl(ue), false, false];
}
function NE(r, n, l) {
  const h = n.x - r.x, f = n.y - r.y, y = Math.max(0, Math.min(1, ((l.x - r.x) * h + (l.y - r.y) * f) / (h * h + f * f)));
  return { x: r.x + y * h, y: r.y + y * f };
}
class Zx extends po {
  constructor(n, l, h) {
    super(n), this.config = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.getSnappableCoordinateFirstClick = (f) => {
      const y = this.getSnappable(f, (p) => !!(p.properties && p.properties.mode === this.mode));
      return y.coordinate ? [Li(y.coordinate[0], this.config.coordinatePrecision), Li(y.coordinate[1], this.config.coordinatePrecision)] : void 0;
    }, this.getSnappableCoordinate = (f, y) => {
      const p = this.getSnappable(f, (s) => !!(s.properties && s.properties.mode === this.mode && s.id !== y));
      return p.coordinate ? [Li(p.coordinate[0], this.config.coordinatePrecision), Li(p.coordinate[1], this.config.coordinatePrecision)] : void 0;
    }, this.config = n, this.pixelDistance = l, this.clickBoundingBox = h;
  }
  getSnappable(n, l) {
    const h = this.clickBoundingBox.create(n), f = this.store.search(h, l), y = { featureId: void 0, featureCoordinateIndex: void 0, coordinate: void 0, minDistance: 1 / 0 };
    return f.forEach((p) => {
      let s;
      if (p.geometry.type === "Polygon") s = p.geometry.coordinates[0];
      else {
        if (p.geometry.type !== "LineString") return;
        s = p.geometry.coordinates;
      }
      const S = [];
      for (let O = 0; O < s.length - 1; O++) S.push([s[O], s[O + 1]]);
      let P;
      const M = [n.lng, n.lat];
      if (this.config.projection === "web-mercator" ? P = (function(O, j) {
        let L = [1 / 0, 1 / 0], q = 1 / 0, N = 0;
        for (let J of j) {
          const te = J[0], ne = J[1];
          let ae, oe = 1 / 0;
          const ee = Fi(te[0], te[1]), ke = Fi(ne[0], ne[1]), ve = Fi(O[0], O[1]);
          if (te[0] === O[0] && te[1] === O[1]) ae = te;
          else if (ne[0] === O[0] && ne[1] === O[1]) ae = ne;
          else {
            const { x: le, y: ue } = NE(ee, ke, ve), { lng: be, lat: Ve } = Lc(le, ue);
            ae = [be, Ve];
          }
          ae && (oe = Aa(ve, Fi(ae[0], ae[1])), oe < q && (L = ae, q = oe, N = j.indexOf(J)));
        }
        return q === 1 / 0 ? void 0 : { coordinate: L, lineIndex: N, distance: q };
      })(M, S) : this.config.projection === "globe" && (P = (function(O, j) {
        let L = [1 / 0, 1 / 0], q = 1 / 0, N = 0;
        for (let J of j) {
          const te = J[0], ne = J[1];
          let ae, oe = 1 / 0;
          te[0] === O[0] && te[1] === O[1] ? ae = te : ne[0] === O[0] && ne[1] === O[1] ? ae = ne : [ae] = $E(te, ne, O), ae && (oe = hs(O, ae), oe < q && (L = ae, q = oe, N = j.indexOf(J)));
        }
        return q === 1 / 0 ? void 0 : { coordinate: L, distance: q, lineIndex: N };
      })(M, S)), !P) return;
      const A = this.pixelDistance.measure(n, P.coordinate);
      A < y.minDistance && A < this.pointerDistance && (y.featureId = p.id, y.coordinate = [Li(P.coordinate[0], this.config.coordinatePrecision), Li(P.coordinate[1], this.config.coordinatePrecision)], y.featureCoordinateIndex = P.lineIndex, y.minDistance = A);
    }), y;
  }
}
const jE = { cancel: "Escape", finish: "Enter" }, VE = { start: "crosshair", close: "pointer", dragStart: "grabbing", dragEnd: "crosshair" };
class Hx extends ym {
  constructor(n) {
    super(n, true), this.mode = "linestring", this.currentCoordinate = 0, this.currentId = void 0, this.closingPointId = void 0, this.keyEvents = jE, this.snapping = void 0, this.cursors = VE, this.mouseMove = false, this.insertCoordinates = void 0, this.lastCommittedCoordinates = void 0, this.snappedPointId = void 0, this.lastMouseMoveEvent = void 0, this.editable = false, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedSnapType = void 0, this.editedInsertIndex = void 0, this.editedPointId = void 0, this.coordinateSnapping = void 0, this.insertPoint = void 0, this.lineSnapping = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.updateOptions(n);
  }
  updateOptions(n) {
    super.updateOptions(n), n != null && n.cursors && (this.cursors = bn({}, this.cursors, n.cursors)), n != null && n.snapping && (this.snapping = n.snapping), (n == null ? void 0 : n.keyEvents) === null ? this.keyEvents = { cancel: null, finish: null } : n != null && n.keyEvents && (this.keyEvents = bn({}, this.keyEvents, n.keyEvents)), n != null && n.insertCoordinates && (this.insertCoordinates = n.insertCoordinates), n && n.editable && (this.editable = n.editable);
  }
  updateSnappedCoordinate(n) {
    const l = this.snapCoordinate(n);
    if (l) {
      if (this.snappedPointId) this.store.updateGeometry([{ id: this.snappedPointId, geometry: { type: "Point", coordinates: l } }]);
      else {
        const [h] = this.store.create([{ geometry: { type: "Point", coordinates: l }, properties: { mode: this.mode, [Ti.SNAPPING_POINT]: true } }]);
        this.snappedPointId = h;
      }
      n.lng = l[0], n.lat = l[1];
    } else this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0);
    return l;
  }
  close() {
    if (this.currentId === void 0) return;
    const n = this.store.getGeometryCopy(this.currentId);
    n.coordinates.pop(), this.updateGeometries([...n.coordinates], void 0, Vn.Commit), this.store.updateProperty([{ id: this.currentId, property: Ti.CURRENTLY_DRAWING, value: void 0 }]);
    const l = this.currentId;
    this.closingPointId && this.store.delete([this.closingPointId]), this.snappedPointId && this.store.delete([this.snappedPointId]), this.currentCoordinate = 0, this.currentId = void 0, this.closingPointId = void 0, this.snappedPointId = void 0, this.lastCommittedCoordinates = void 0, this.state === "drawing" && this.setStarted(), this.onFinish(l, { mode: this.mode, action: "draw" });
  }
  updateGeometries(n, l, h) {
    if (!this.currentId) return;
    const f = { type: "LineString", coordinates: n };
    if (this.validate && !this.validate({ type: "Feature", geometry: f }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: h }).valid) return;
    const y = [{ id: this.currentId, geometry: f }];
    this.closingPointId && l && y.push({ id: this.closingPointId, geometry: { type: "Point", coordinates: l } }), h === "commit" && (this.lastCommittedCoordinates = f.coordinates), this.store.updateGeometry(y);
  }
  generateInsertCoordinates(n, l) {
    if (!this.insertCoordinates || !this.lastCommittedCoordinates) throw new Error("Not able to insert coordinates");
    if (this.insertCoordinates.strategy !== "amount") throw new Error("Strategy does not exist");
    const h = hs(n, l) / (this.insertCoordinates.value + 1);
    let f = [];
    return this.projection === "globe" ? f = this.insertPoint.generateInsertionGeodesicCoordinates(n, l, h) : this.projection === "web-mercator" && (f = this.insertPoint.generateInsertionCoordinates(n, l, h)), f;
  }
  createLine(n) {
    const [l] = this.store.create([{ geometry: { type: "LineString", coordinates: [n, n] }, properties: { mode: this.mode, [Ti.CURRENTLY_DRAWING]: true } }]);
    this.lastCommittedCoordinates = [n, n], this.currentId = l, this.currentCoordinate++, this.setDrawing();
  }
  firstUpdateToLine(n) {
    if (!this.currentId) return;
    const l = this.store.getGeometryCopy(this.currentId).coordinates, [h] = this.store.create([{ geometry: { type: "Point", coordinates: [...n] }, properties: { mode: this.mode, [Ti.CLOSING_POINT]: true } }]);
    this.closingPointId = h, this.setCursor(this.cursors.close);
    const f = [...l, n];
    this.updateGeometries(f, void 0, Vn.Commit), this.currentCoordinate++;
  }
  updateToLine(n, l) {
    if (!this.currentId) return;
    const h = this.store.getGeometryCopy(this.currentId).coordinates, [f, y] = this.lastCommittedCoordinates ? this.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1] : h[h.length - 2], { x: p, y: s } = this.project(f, y);
    if (Aa({ x: p, y: s }, { x: l.x, y: l.y }) < this.pointerDistance) return void this.close();
    this.setCursor(this.cursors.close);
    const S = [...h, n];
    this.updateGeometries(S, h[h.length - 1], Vn.Commit), this.currentCoordinate++;
  }
  registerBehaviors(n) {
    this.coordinateSnapping = new j0(n, new Kp(n), new Yp(n)), this.insertPoint = new LE(n), this.clickBoundingBox = new Yp(n), this.pixelDistance = new Kp(n), this.lineSnapping = new Zx(n, this.pixelDistance, this.clickBoundingBox), this.coordinateSnapping = new j0(n, this.pixelDistance, this.clickBoundingBox);
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.start);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onMouseMove(n) {
    this.mouseMove = true, this.setCursor(this.cursors.start), this.lastMouseMoveEvent = n;
    const l = this.updateSnappedCoordinate(n) || [n.lng, n.lat];
    if (this.currentId === void 0 || this.currentCoordinate === 0) return;
    const h = this.store.getGeometryCopy(this.currentId).coordinates;
    if (h.pop(), this.closingPointId) {
      const [y, p] = h[h.length - 1], { x: s, y: S } = this.project(y, p);
      Aa({ x: s, y: S }, { x: n.containerX, y: n.containerY }) < this.pointerDistance && this.setCursor(this.cursors.close);
    }
    let f = [...h, l];
    if (this.insertCoordinates && this.currentId && this.lastCommittedCoordinates) {
      const y = this.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1], p = l;
      if (!BE(y, p)) {
        const s = this.generateInsertCoordinates(y, p);
        f = [...this.lastCommittedCoordinates.slice(0, -1), ...s, l];
      }
    }
    this.updateGeometries(f, void 0, Vn.Provisional);
  }
  onRightClick(n) {
    if (!this.editable || this.state !== "started") return;
    const { featureId: l, featureCoordinateIndex: h } = this.coordinateSnapping.getSnappable(n, (p) => this.lineStringFilter(p));
    if (!l || h === void 0) return;
    const f = this.store.getGeometryCopy(l);
    let y;
    if (f.type === "LineString" && (y = f.coordinates, !(y.length <= 2))) {
      if (y.splice(h, 1), this.validate && !this.validate({ id: l, type: "Feature", geometry: f, properties: {} }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Vn.Commit }).valid) return;
      this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.store.updateGeometry([{ id: l, geometry: f }]), this.onFinish(l, { mode: this.mode, action: "edit" });
    }
  }
  onLeftClick(n) {
    this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0);
    const l = this.snapCoordinate(n) || [n.lng, n.lat];
    this.currentCoordinate === 0 ? this.createLine(l) : this.currentCoordinate === 1 && this.currentId ? this.firstUpdateToLine(l) : this.currentId && this.updateToLine(l, { x: n.containerX, y: n.containerY });
  }
  onClick(n) {
    (n.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, n) || n.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, n) || n.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, n)) && (this.currentCoordinate > 0 && !this.mouseMove && this.onMouseMove(n), this.mouseMove = false, n.button === "right" ? this.onRightClick(n) : n.button === "left" && this.onLeftClick(n));
  }
  onKeyDown() {
  }
  onKeyUp(n) {
    n.key === this.keyEvents.cancel && this.cleanUp(), n.key === this.keyEvents.finish && this.close();
  }
  onDragStart(n, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDragStart, n) || !this.editable) return;
    let h;
    if (this.state === "started") {
      const f = this.lineSnapping.getSnappable(n, (p) => this.lineStringFilter(p));
      f.coordinate && (this.editedSnapType = "line", this.editedFeatureCoordinateIndex = f.featureCoordinateIndex, this.editedFeatureId = f.featureId, h = f.coordinate);
      const y = this.coordinateSnapping.getSnappable(n, (p) => this.lineStringFilter(p));
      y.coordinate && (this.editedSnapType = "coordinate", this.editedFeatureCoordinateIndex = y.featureCoordinateIndex, this.editedFeatureId = y.featureId, h = y.coordinate);
    }
    if (this.editedFeatureId && h) {
      if (!this.editedPointId) {
        const [f] = this.store.create([{ geometry: { type: "Point", coordinates: h }, properties: { mode: this.mode, [Ti.EDITED]: true } }]);
        this.editedPointId = f;
      }
      this.setCursor(this.cursors.dragStart), l(false);
    }
  }
  onDrag(n, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDrag, n) || this.editedFeatureId === void 0 || this.editedFeatureCoordinateIndex === void 0) return;
    const h = this.store.getGeometryCopy(this.editedFeatureId);
    this.editedSnapType === "coordinate" || this.editedSnapType === "line" && this.editedInsertIndex !== void 0 ? h.coordinates[this.editedFeatureCoordinateIndex] = [n.lng, n.lat] : this.editedSnapType === "line" && this.editedInsertIndex === void 0 && (this.editedInsertIndex = this.editedFeatureCoordinateIndex + 1, h.coordinates.splice(this.editedInsertIndex, 0, [n.lng, n.lat]), this.editedFeatureCoordinateIndex++);
    const f = { type: "LineString", coordinates: h.coordinates };
    this.validate && !this.validate({ type: "Feature", geometry: f, properties: this.store.getPropertiesCopy(this.editedFeatureId) }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Vn.Provisional }).valid || (this.snapping && this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.store.updateGeometry([{ id: this.editedFeatureId, geometry: f }]), this.editedPointId && this.store.updateGeometry([{ id: this.editedPointId, geometry: { type: "Point", coordinates: [n.lng, n.lat] } }]), this.store.updateProperty([{ id: this.editedFeatureId, property: Ti.EDITED, value: true }]));
  }
  onDragEnd(n, l) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, n) && this.editedFeatureId !== void 0 && (this.setCursor(this.cursors.dragEnd), this.editedPointId && (this.store.delete([this.editedPointId]), this.editedPointId = void 0), this.store.updateProperty([{ id: this.editedFeatureId, property: Ti.EDITED, value: false }]), this.onFinish(this.editedFeatureId, { mode: this.mode, action: "edit" }), this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedInsertIndex = void 0, this.editedSnapType = void 0, l(true));
  }
  cleanUp() {
    const n = this.currentId, l = this.closingPointId, h = this.snappedPointId;
    this.closingPointId = void 0, this.snappedPointId = void 0, this.currentId = void 0, this.currentCoordinate = 0, this.state === "drawing" && this.setStarted();
    try {
      n !== void 0 && this.store.delete([n]), h !== void 0 && this.store.delete([h]), l !== void 0 && this.store.delete([l]);
    } catch {
    }
  }
  styleFeature(n) {
    const l = bn({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0, markerUrl: void 0, markerHeight: void 0, markerWidth: void 0 });
    if (n.type === "Feature" && n.geometry.type === "LineString" && n.properties.mode === this.mode) return l.lineStringColor = this.getHexColorStylingValue(this.styles.lineStringColor, l.lineStringColor, n), l.lineStringWidth = this.getNumericStylingValue(this.styles.lineStringWidth, l.lineStringWidth, n), l.zIndex = jp, l;
    if (n.type === "Feature" && n.geometry.type === "Point" && n.properties.mode === this.mode) {
      const h = n.properties[Ti.CLOSING_POINT];
      return l.pointColor = this.getHexColorStylingValue(h ? this.styles.closingPointColor : this.styles.snappingPointColor, l.pointColor, n), l.pointWidth = this.getNumericStylingValue(h ? this.styles.closingPointWidth : this.styles.snappingPointWidth, l.pointWidth, n), l.pointOutlineColor = this.getHexColorStylingValue(h ? this.styles.closingPointOutlineColor : this.styles.snappingPointOutlineColor, "#ffffff", n), l.pointOutlineWidth = this.getNumericStylingValue(h ? this.styles.closingPointOutlineWidth : this.styles.snappingPointOutlineWidth, 2, n), l.zIndex = 50, l;
    }
    return l;
  }
  validateFeature(n) {
    return this.validateModeFeature(n, (l) => OE(l, this.coordinatePrecision));
  }
  lineStringFilter(n) {
    return !!(n.geometry.type === "LineString" && n.properties && n.properties.mode === this.mode);
  }
  snapCoordinate(n) {
    var l, h, f;
    let y;
    if ((l = this.snapping) != null && l.toLine) {
      let p;
      p = this.currentId ? this.lineSnapping.getSnappableCoordinate(n, this.currentId) : this.lineSnapping.getSnappableCoordinateFirstClick(n), p && (y = p);
    }
    return (h = this.snapping) != null && h.toCoordinate && (y = this.currentId ? this.coordinateSnapping.getSnappableCoordinate(n, this.currentId) : this.coordinateSnapping.getSnappableCoordinateFirstClick(n)), (f = this.snapping) != null && f.toCustom && (y = this.snapping.toCustom(n, { currentCoordinate: this.currentCoordinate, currentId: this.currentId, getCurrentGeometrySnapshot: this.currentId ? () => this.store.getGeometryCopy(this.currentId) : () => null, project: this.project, unproject: this.unproject })), y;
  }
  afterFeatureUpdated(n) {
    this.editedFeatureId === n.id && this.editedPointId && (this.store.delete([this.editedPointId]), this.editedPointId = void 0, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedSnapType = void 0), this.snappedPointId && this.lastMouseMoveEvent && this.updateSnappedCoordinate(this.lastMouseMoveEvent), this.currentId === n.id && (this.closingPointId && (this.store.delete([this.closingPointId]), this.closingPointId = void 0), this.currentCoordinate = 0, this.currentId = void 0, this.state === "drawing" && this.setStarted());
  }
}
const UE = "Feature is not a Point", GE = "Feature has invalid coordinates", qE = "Feature has coordinates with excessive precision";
function WE(r, n) {
  return r.geometry.type !== "Point" ? { valid: false, reason: UE } : qx(r.geometry.coordinates) ? fv(r.geometry.coordinates, n) ? { valid: true } : { valid: false, reason: qE } : { valid: false, reason: GE };
}
const ZE = { create: "crosshair", dragStart: "grabbing", dragEnd: "crosshair" };
class Xx extends ym {
  constructor(n) {
    super(n, true), this.mode = "point", this.cursors = ZE, this.editable = false, this.editedFeatureId = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.updateOptions(n);
  }
  updateOptions(n) {
    super.updateOptions(n), n != null && n.cursors && (this.cursors = bn({}, this.cursors, n.cursors)), n != null && n.editable && (this.editable = n.editable);
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.create);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onClick(n) {
    n.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, n) || n.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, n) ? this.onRightClick(n) : n.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, n) && this.onLeftClick(n);
  }
  onMouseMove() {
  }
  onKeyDown() {
  }
  onKeyUp() {
  }
  cleanUp() {
    this.editedFeatureId = void 0;
  }
  onDragStart(n, l) {
    if (this.allowPointerEvent(this.pointerEvents.onDragStart, n)) {
      if (this.editable) {
        const h = this.getNearestPointFeature(n);
        this.editedFeatureId = h == null ? void 0 : h.id;
      }
      this.editedFeatureId && (this.setCursor(this.cursors.dragStart), l(false));
    }
  }
  onDrag(n, l) {
    this.allowPointerEvent(this.pointerEvents.onDrag, n) && this.editedFeatureId !== void 0 && (this.validate && !this.validate({ type: "Feature", geometry: { type: "Point", coordinates: [n.lng, n.lat] }, properties: this.store.getPropertiesCopy(this.editedFeatureId) }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Vn.Finish }).valid || (this.store.updateGeometry([{ id: this.editedFeatureId, geometry: { type: "Point", coordinates: [n.lng, n.lat] } }]), this.store.updateProperty([{ id: this.editedFeatureId, property: Ti.EDITED, value: true }])));
  }
  onDragEnd(n, l) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, n) && this.editedFeatureId !== void 0 && (this.onFinish(this.editedFeatureId, { mode: this.mode, action: "edit" }), this.setCursor(this.cursors.dragEnd), this.store.updateProperty([{ id: this.editedFeatureId, property: Ti.EDITED, value: false }]), this.editedFeatureId = void 0, l(true));
  }
  registerBehaviors(n) {
    this.pixelDistance = new Kp(n), this.clickBoundingBox = new Yp(n);
  }
  styleFeature(n) {
    const l = bn({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0, markerUrl: void 0, markerHeight: void 0, markerWidth: void 0 });
    if (n.type === "Feature" && n.geometry.type === "Point" && n.properties.mode === this.mode) {
      const h = !!(n.id && this.editedFeatureId === n.id);
      l.pointWidth = this.getNumericStylingValue(h ? this.styles.editedPointWidth : this.styles.pointWidth, l.pointWidth, n), l.pointColor = this.getHexColorStylingValue(h ? this.styles.editedPointColor : this.styles.pointColor, l.pointColor, n), l.pointOutlineColor = this.getHexColorStylingValue(h ? this.styles.editedPointOutlineColor : this.styles.pointOutlineColor, l.pointOutlineColor, n), l.pointOutlineWidth = this.getNumericStylingValue(h ? this.styles.editedPointOutlineWidth : this.styles.pointOutlineWidth, 2, n), l.zIndex = 30;
    }
    return l;
  }
  validateFeature(n) {
    return this.validateModeFeature(n, (l) => WE(l, this.coordinatePrecision));
  }
  onLeftClick(n) {
    const l = { type: "Point", coordinates: [n.lng, n.lat] }, h = { mode: this.mode };
    if (this.validate && !this.validate({ type: "Feature", geometry: l, properties: h }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Vn.Finish }).valid) return;
    const [f] = this.store.create([{ geometry: l, properties: h }]);
    this.onFinish(f, { mode: this.mode, action: "draw" });
  }
  onRightClick(n) {
    if (!this.editable) return;
    const l = this.getNearestPointFeature(n);
    l && this.store.delete([l.id]);
  }
  getNearestPointFeature(n) {
    const l = this.clickBoundingBox.create(n), h = this.store.search(l);
    let f, y = 1 / 0;
    for (let p = 0; p < h.length; p++) {
      const s = h[p];
      if (s.geometry.type !== "Point" || s.properties.mode !== this.mode) continue;
      const S = this.pixelDistance.measure(n, s.geometry.coordinates);
      S > y || S > this.pointerDistance || (y = S, f = s);
    }
    return f;
  }
  afterFeatureUpdated(n) {
    this.editedFeatureId === n.id && (this.editedFeatureId = void 0, this.setCursor(this.cursors.create));
  }
}
class HE extends po {
  constructor(n) {
    super(n);
  }
  createOrUpdate(n) {
    const l = this.store.getGeometryCopy(n), h = this.store.getPropertiesCopy(n);
    let f;
    if (l.type === "Polygon") f = l.coordinates[0].slice(0, -1);
    else {
      if (l.type !== "LineString") return;
      f = l.coordinates;
    }
    const y = this.store.getPropertiesCopy(n), p = y.coordinatePointIds;
    if (p) if (p && p.every((s) => this.store.has(s))) {
      const s = y.coordinatePointIds, S = s.map((P) => this.store.getGeometryCopy(P).coordinates);
      if (s.length !== f.length) {
        this.deleteCoordinatePoints(s);
        const P = this.createPoints(f, h.mode, n);
        this.setFeatureCoordinatePoints(n, P);
      } else f.forEach((P, M) => {
        P[0] === S[M][0] && P[1] === S[M][1] || this.store.updateGeometry([{ id: s[M], geometry: { type: "Point", coordinates: P } }]);
      });
    } else {
      const s = p.filter((P) => this.store.has(P));
      s.length && this.deleteCoordinatePoints(s);
      const S = this.createPoints(f, h.mode, n);
      this.setFeatureCoordinatePoints(n, S);
    }
    else {
      const s = this.createPoints(f, h.mode, n);
      this.setFeatureCoordinatePoints(n, s);
    }
  }
  deletePointsByFeatureIds(n) {
    for (const l of n) this.deleteIfPresent(l);
  }
  getUpdated(n, l) {
    const h = this.store.getPropertiesCopy(n);
    if (h.coordinatePointIds) return h.coordinatePointIds.map((f, y) => ({ id: f, geometry: bn({}, this.store.getGeometryCopy(f), { coordinates: l[y] }) }));
  }
  createPoints(n, l, h) {
    return this.store.create(n.map((f, y) => ({ geometry: { type: "Point", coordinates: f }, properties: { mode: l, [Ti.COORDINATE_POINT]: true, [Ti.COORDINATE_POINT_FEATURE_ID]: h, index: y } })));
  }
  setFeatureCoordinatePoints(n, l) {
    this.store.updateProperty([{ id: n, property: Ti.COORDINATE_POINT_IDS, value: l }]);
  }
  deleteCoordinatePoints(n) {
    const l = n.filter((h) => this.store.has(h));
    this.store.delete(l);
  }
  deleteIfPresent(n) {
    const l = this.store.getPropertiesCopy(n).coordinatePointIds;
    l && (this.deleteCoordinatePoints(l), this.setFeatureCoordinatePoints(n, null));
  }
}
function V0(r, n) {
  const l = r, h = n, f = ho(l[1]), y = ho(h[1]);
  let p = ho(h[0] - l[0]);
  p > Math.PI && (p -= 2 * Math.PI), p < -Math.PI && (p += 2 * Math.PI);
  const s = Math.log(Math.tan(y / 2 + Math.PI / 4) / Math.tan(f / 2 + Math.PI / 4)), S = (Fc(Math.atan2(p, s)) + 360) % 360;
  return S > 180 ? -(360 - S) : S;
}
function Yx(r, n, l) {
  let h = n;
  n < 0 && (h = -Math.abs(h));
  const f = h / Gx, y = r[0] * Math.PI / 180, p = ho(r[1]), s = ho(l), S = f * Math.cos(s);
  let P = p + S;
  Math.abs(P) > Math.PI / 2 && (P = P > 0 ? Math.PI - P : -Math.PI - P);
  const M = Math.log(Math.tan(P / 2 + Math.PI / 4) / Math.tan(p / 2 + Math.PI / 4)), A = Math.abs(M) > 1e-11 ? S / M : Math.cos(p), O = [(180 * (y + f * Math.sin(s) / A) / Math.PI + 540) % 360 - 180, 180 * P / Math.PI];
  return O[0] += O[0] - r[0] > 180 ? -360 : r[0] - O[0] > 180 ? 360 : 0, O;
}
function XE(r, n, l, h, f) {
  const y = h(r[0], r[1]), p = h(n[0], n[1]), { lng: s, lat: S } = f((y.x + p.x) / 2, (y.y + p.y) / 2);
  return [Li(s, l), Li(S, l)];
}
function YE(r, n, l) {
  const h = Yx(r, 1e3 * hs(r, n) / 2, V0(r, n));
  return [Li(h[0], l), Li(h[1], l)];
}
function Ib({ featureCoords: r, precision: n, unproject: l, project: h, projection: f }) {
  const y = [];
  for (let p = 0; p < r.length - 1; p++) {
    let s;
    if (f === "web-mercator") s = XE(r[p], r[p + 1], n, h, l);
    else {
      if (f !== "globe") throw new Error("Invalid projection");
      s = YE(r[p], r[p + 1], n);
    }
    y.push(s);
  }
  return y;
}
class KE extends po {
  constructor(n, l, h) {
    super(n), this.config = void 0, this.selectionPointBehavior = void 0, this.coordinatePointBehavior = void 0, this._midPoints = [], this.config = n, this.selectionPointBehavior = l, this.coordinatePointBehavior = h;
  }
  get ids() {
    return this._midPoints.concat();
  }
  set ids(n) {
  }
  insert(n, l, h) {
    const f = this.store.getGeometryCopy(l), { midPointFeatureId: y, midPointSegment: p } = this.store.getPropertiesCopy(l), s = this.store.getGeometryCopy(y), S = s.type === "Polygon" ? s.coordinates[0] : s.coordinates;
    S.splice(p + 1, 0, f.coordinates), s.coordinates = s.type === "Polygon" ? [S] : S, this.store.updateGeometry([{ id: y, geometry: s }]), this.store.getPropertiesCopy(n)[Ti.COORDINATE_POINT_IDS] && this.coordinatePointBehavior.createOrUpdate(n), this.store.delete([...this._midPoints, ...this.selectionPointBehavior.ids]), this.create(S, y, h), this.selectionPointBehavior.create(S, s.type, y);
  }
  create(n, l, h) {
    if (!this.store.has(l)) throw new Error("Store does not have feature with this id");
    this._midPoints = this.store.create((function(f, y, p, s, S, P) {
      return Ib({ featureCoords: f, precision: p, project: s, unproject: S, projection: P }).map((M, A) => ({ geometry: { type: "Point", coordinates: M }, properties: y(A) }));
    })(n, (f) => ({ mode: this.mode, [Ji.MID_POINT]: true, midPointSegment: f, midPointFeatureId: l }), h, this.config.project, this.config.unproject, this.projection));
  }
  delete() {
    this._midPoints.length && (this.store.delete(this._midPoints), this._midPoints = []);
  }
  getUpdated(n) {
    if (this._midPoints.length !== 0) return Ib({ featureCoords: n, precision: this.coordinatePrecision, project: this.config.project, unproject: this.config.unproject, projection: this.config.projection }).map((l, h) => ({ id: this._midPoints[h], geometry: { type: "Point", coordinates: l } }));
  }
}
class JE extends po {
  constructor(n) {
    super(n), this._selectionPoints = [];
  }
  get ids() {
    return this._selectionPoints.concat();
  }
  set ids(n) {
  }
  create(n, l, h) {
    this._selectionPoints = this.store.create((function(f, y, p) {
      const s = [], S = y === "Polygon" ? f.length - 1 : f.length;
      for (let P = 0; P < S; P++) s.push({ geometry: { type: "Point", coordinates: f[P] }, properties: p(P) });
      return s;
    })(n, l, (f) => ({ mode: this.mode, index: f, [Ji.SELECTION_POINT]: true, [Ji.SELECTION_POINT_FEATURE_ID]: h })));
  }
  delete() {
    this.ids.length && (this.store.delete(this.ids), this._selectionPoints = []);
  }
  getUpdated(n) {
    if (this._selectionPoints.length !== 0) return this._selectionPoints.map((l, h) => ({ id: l, geometry: { type: "Point", coordinates: n[h] } }));
  }
  getOneUpdated(n, l) {
    if (this._selectionPoints[n] !== void 0) return { id: this._selectionPoints[n], geometry: { type: "Point", coordinates: l } };
  }
}
function Kx(r, n) {
  let l = false;
  for (let p = 0, s = n.length; p < s; p++) {
    const S = n[p];
    for (let P = 0, M = S.length, A = M - 1; P < M; A = P++) (f = S[P])[1] > (h = r)[1] != (y = S[A])[1] > h[1] && h[0] < (y[0] - f[0]) * (h[1] - f[1]) / (y[1] - f[1]) + f[0] && (l = !l);
  }
  var h, f, y;
  return l;
}
const U0 = (r, n, l) => {
  const h = (y) => y * y, f = (y, p) => h(y.x - p.x) + h(y.y - p.y);
  return Math.sqrt(((y, p, s) => {
    const S = f(p, s);
    if (S === 0) return f(y, p);
    let P = ((y.x - p.x) * (s.x - p.x) + (y.y - p.y) * (s.y - p.y)) / S;
    return P = Math.max(0, Math.min(1, P)), f(y, { x: p.x + P * (s.x - p.x), y: p.y + P * (s.y - p.y) });
  })(r, n, l));
};
class QE extends po {
  constructor(n, l, h) {
    super(n), this.config = void 0, this.createClickBoundingBox = void 0, this.pixelDistance = void 0, this.config = n, this.createClickBoundingBox = l, this.pixelDistance = h;
  }
  find(n, l) {
    let h, f, y, p, s = 1 / 0, S = 1 / 0, P = 1 / 0;
    const M = this.createClickBoundingBox.create(n), A = this.store.search(M);
    for (let O = 0; O < A.length; O++) {
      const j = A[O], L = j.geometry;
      if (L.type === "Point") {
        if (j.properties.selectionPoint || j.properties.coordinatePoint || !l && j.properties[Ji.MID_POINT]) continue;
        const q = this.pixelDistance.measure(n, L.coordinates);
        j.properties[Ji.MID_POINT] && q < this.pointerDistance && q < P ? (P = q, y = j) : !j.properties[Ji.MID_POINT] && q < this.pointerDistance && q < s && (s = q, h = j);
      } else if (L.type === "LineString") {
        if (h) continue;
        for (let q = 0; q < L.coordinates.length - 1; q++) {
          const N = L.coordinates[q], J = L.coordinates[q + 1], te = U0({ x: n.containerX, y: n.containerY }, this.project(N[0], N[1]), this.project(J[0], J[1]));
          te < this.pointerDistance && te < S && (S = te, f = j);
        }
      } else if (L.type === "Polygon") {
        if (h || f) continue;
        Kx([n.lng, n.lat], L.coordinates) && (p = j);
      }
    }
    return { clickedFeature: h || f || p, clickedMidPoint: y };
  }
}
class eM extends po {
  constructor(n, l, h, f, y) {
    super(n), this.config = void 0, this.featuresAtCursorEvent = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.draggedFeatureId = null, this.dragPosition = void 0, this.config = n, this.featuresAtCursorEvent = l, this.selectionPoints = h, this.midPoints = f, this.coordinatePoints = y;
  }
  startDragging(n, l) {
    this.draggedFeatureId = l, this.dragPosition = [n.lng, n.lat];
  }
  stopDragging() {
    this.draggedFeatureId = null, this.dragPosition = void 0;
  }
  isDragging() {
    return this.draggedFeatureId !== null;
  }
  canDrag(n, l) {
    const { clickedFeature: h } = this.featuresAtCursorEvent.find(n, true);
    return !(!h || h.id !== l);
  }
  drag(n, l) {
    if (!this.draggedFeatureId) return;
    const h = this.store.getGeometryCopy(this.draggedFeatureId), f = [n.lng, n.lat];
    if (h.type === "Polygon" || h.type === "LineString") {
      let y, p;
      if (h.type === "Polygon" ? (y = h.coordinates[0], p = y.length - 1) : (y = h.coordinates, p = y.length), !this.dragPosition) return false;
      for (let M = 0; M < p; M++) {
        const A = y[M];
        let O, j;
        if (this.config.projection === "web-mercator") {
          const L = Fi(this.dragPosition[0], this.dragPosition[1]), q = Fi(f[0], f[1]), N = Fi(A[0], A[1]), J = { x: L.x - q.x, y: L.y - q.y }, te = N.x - J.x, ne = N.y - J.y, { lng: ae, lat: oe } = Lc(te, ne);
          O = ae, j = oe;
        } else {
          const L = [this.dragPosition[0] - f[0], this.dragPosition[1] - f[1]];
          O = A[0] - L[0], j = A[1] - L[1];
        }
        if (O = Li(O, this.config.coordinatePrecision), j = Li(j, this.config.coordinatePrecision), O > 180 || O < -180 || j > 90 || j < -90) return false;
        y[M] = [O, j];
      }
      h.type === "Polygon" && (y[y.length - 1] = [y[0][0], y[0][1]]);
      const s = this.selectionPoints.getUpdated(y) || [], S = this.midPoints.getUpdated(y) || [], P = this.coordinatePoints.getUpdated(this.draggedFeatureId, y) || [];
      if (l && !l({ type: "Feature", id: this.draggedFeatureId, geometry: h, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Vn.Provisional }).valid) return false;
      this.store.updateGeometry([{ id: this.draggedFeatureId, geometry: h }, ...s, ...S, ...P]), this.dragPosition = [n.lng, n.lat];
    } else h.type === "Point" && (this.store.updateGeometry([{ id: this.draggedFeatureId, geometry: { type: "Point", coordinates: f } }]), this.dragPosition = [n.lng, n.lat]);
  }
}
class tM extends po {
  constructor(n, l, h, f, y, p, s) {
    super(n), this.config = void 0, this.pixelDistance = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.coordinateSnapping = void 0, this.lineSnapping = void 0, this.draggedCoordinate = { id: null, index: -1 }, this.config = n, this.pixelDistance = l, this.selectionPoints = h, this.midPoints = f, this.coordinatePoints = y, this.coordinateSnapping = p, this.lineSnapping = s;
  }
  getClosestCoordinate(n, l) {
    const h = { dist: 1 / 0, index: -1, isFirstOrLastPolygonCoord: false };
    let f;
    if (l.type === "LineString") f = l.coordinates;
    else {
      if (l.type !== "Polygon") return h;
      f = l.coordinates[0];
    }
    for (let y = 0; y < f.length; y++) {
      const p = this.pixelDistance.measure(n, f[y]);
      if (p < this.pointerDistance && p < h.dist) {
        const s = l.type === "Polygon" && (y === f.length - 1 || y === 0);
        h.dist = p, h.index = s ? 0 : y, h.isFirstOrLastPolygonCoord = s;
      }
    }
    return h;
  }
  getDraggableIndex(n, l) {
    const h = this.store.getGeometryCopy(l), f = this.getClosestCoordinate(n, h);
    return f.index === -1 ? -1 : f.index;
  }
  snapCoordinate(n, l, h) {
    let f = [n.lng, n.lat];
    const y = (p) => !!(p.properties && p.properties.mode === h.properties.mode && p.id !== this.draggedCoordinate.id);
    if (l != null && l.toLine) {
      let p;
      p = this.lineSnapping.getSnappable(n, y).coordinate, p && (f = p);
    }
    if (l.toCoordinate) {
      let p;
      p = this.coordinateSnapping.getSnappable(n, y).coordinate, p && (f = p);
    }
    if (l != null && l.toCustom) {
      let p;
      p = l.toCustom(n, { currentCoordinate: this.draggedCoordinate.index, currentId: h.id, getCurrentGeometrySnapshot: h.id ? () => this.store.getGeometryCopy(h.id) : () => null, project: this.project, unproject: this.unproject }), p && (f = p);
    }
    return f;
  }
  drag(n, l, h, f) {
    const y = this.draggedCoordinate.id;
    if (y === null) return false;
    const p = this.draggedCoordinate.index, s = this.store.getGeometryCopy(y), S = this.store.getPropertiesCopy(y), P = s.type === "LineString" ? s.coordinates : s.coordinates[0], M = s.type === "Polygon" && (p === P.length - 1 || p === 0), A = { type: "Feature", id: y, geometry: s, properties: S }, O = this.snapCoordinate(n, f, A);
    if (n.lng > 180 || n.lng < -180 || n.lat > 90 || n.lat < -90) return false;
    if (M) {
      const J = P.length - 1;
      P[0] = O, P[J] = O;
    } else P[p] = O;
    const j = this.selectionPoints.getOneUpdated(p, O), L = j ? [j] : [], q = this.midPoints.getUpdated(P) || [], N = this.coordinatePoints.getUpdated(y, P) || [];
    return !(s.type !== "Point" && !l && AE({ geometry: s }) || h && !h(A, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Vn.Provisional }).valid || (this.store.updateGeometry([{ id: y, geometry: s }, ...L, ...q, ...N]), 0));
  }
  isDragging() {
    return this.draggedCoordinate.id !== null;
  }
  startDragging(n, l) {
    this.draggedCoordinate = { id: n, index: l };
  }
  stopDragging() {
    this.draggedCoordinate = { id: null, index: -1 };
  }
}
function Eb(r) {
  let n = 0, l = 0, h = 0;
  return (r.geometry.type === "Polygon" ? r.geometry.coordinates[0].slice(0, -1) : r.geometry.coordinates).forEach((f) => {
    n += f[0], l += f[1], h++;
  }, true), [n / h, l / h];
}
const Jx = (r, n) => {
  if (n === 0 || n === 360 || n === -360) return r;
  const l = 0.017453292519943295 * n, h = (r.geometry.type === "Polygon" ? r.geometry.coordinates[0] : r.geometry.coordinates).map(([p, s]) => Fi(p, s)), f = h.reduce((p, s) => ({ x: p.x + s.x, y: p.y + s.y }), { x: 0, y: 0 });
  f.x /= h.length, f.y /= h.length;
  const y = h.map((p) => ({ x: f.x + (p.x - f.x) * Math.cos(l) - (p.y - f.y) * Math.sin(l), y: f.y + (p.x - f.x) * Math.sin(l) + (p.y - f.y) * Math.cos(l) })).map(({ x: p, y: s }) => [Lc(p, s).lng, Lc(p, s).lat]);
  return r.geometry.type === "Polygon" ? r.geometry.coordinates[0] = y : r.geometry.coordinates = y, r;
};
function G0(r) {
  const n = (r.geometry.type === "Polygon" ? r.geometry.coordinates[0] : r.geometry.coordinates).map((l) => {
    const { x: h, y: f } = Fi(l[0], l[1]);
    return [h, f];
  });
  return r.geometry.type === "Polygon" ? (function(l) {
    let h = 0, f = 0, y = 0;
    const p = l.length;
    for (let s = 0; s < p - 1; s++) {
      const [S, P] = l[s], [M, A] = l[s + 1], O = S * A - M * P;
      h += O, f += (S + M) * O, y += (P + A) * O;
    }
    return h /= 2, f /= 6 * h, y /= 6 * h, { x: f, y };
  })(n) : (function(l) {
    const h = l.length;
    let f = 0, y = 0;
    for (let p = 0; p < h; p++) {
      const [s, S] = l[p];
      f += s, y += S;
    }
    return { x: f / h, y: y / h };
  })(n);
}
class rM extends po {
  constructor(n, l, h, f) {
    super(n), this.config = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.lastBearing = void 0, this.selectedGeometry = void 0, this.selectedGeometryCentroid = void 0, this.selectedGeometryWebMercatorCentroid = void 0, this.config = n, this.selectionPoints = l, this.midPoints = h, this.coordinatePoints = f;
  }
  reset() {
    this.lastBearing = void 0, this.selectedGeometry = void 0, this.selectedGeometryWebMercatorCentroid = void 0, this.selectedGeometryCentroid = void 0;
  }
  rotate(n, l, h) {
    this.selectedGeometry || (this.selectedGeometry = this.store.getGeometryCopy(l));
    const f = this.selectedGeometry;
    if (f.type !== "Polygon" && f.type !== "LineString") return;
    const y = [n.lng, n.lat];
    let p;
    const s = { type: "Feature", geometry: f, properties: {} };
    if (this.config.projection === "web-mercator") {
      this.selectedGeometryWebMercatorCentroid || (this.selectedGeometryWebMercatorCentroid = G0(s));
      const O = Fi(n.lng, n.lat);
      if (p = zE(this.selectedGeometryWebMercatorCentroid, O), p === 0) return;
      if (!this.lastBearing) return void (this.lastBearing = p);
      Jx(s, -(this.lastBearing - p));
    } else {
      if (this.config.projection !== "globe") throw new Error("Unsupported projection");
      if (this.selectedGeometryCentroid || (this.selectedGeometryCentroid = Eb({ geometry: f })), p = V0(this.selectedGeometryCentroid, y), !this.lastBearing) return void (this.lastBearing = p + 180);
      (function(O, j) {
        if (j === 0 || j === 360 || j === -360) return O;
        const L = Eb(O);
        (O.geometry.type === "Polygon" ? O.geometry.coordinates[0] : O.geometry.coordinates).forEach((q) => {
          const N = V0(L, q) + j, J = (function(ne, ae) {
            ne[0] += ne[0] - ae[0] > 180 ? -360 : ae[0] - ne[0] > 180 ? 360 : 0;
            const oe = Gx, ee = ae[1] * Math.PI / 180, ke = ne[1] * Math.PI / 180, ve = ke - ee;
            let le = Math.abs(ne[0] - ae[0]) * Math.PI / 180;
            le > Math.PI && (le -= 2 * Math.PI);
            const ue = Math.log(Math.tan(ke / 2 + Math.PI / 4) / Math.tan(ee / 2 + Math.PI / 4)), be = Math.abs(ue) > 1e-11 ? ve / ue : Math.cos(ee);
            return Math.sqrt(ve * ve + be * be * le * le) * oe;
          })(L, q), te = Yx(L, J, N);
          q[0] = te[0], q[1] = te[1];
        });
      })(s, -(this.lastBearing - (p + 180)));
    }
    const S = f.type === "Polygon" ? f.coordinates[0] : f.coordinates;
    S.forEach((O) => {
      O[0] = Li(O[0], this.coordinatePrecision), O[1] = Li(O[1], this.coordinatePrecision);
    });
    const P = this.midPoints.getUpdated(S) || [], M = this.selectionPoints.getUpdated(S) || [], A = this.coordinatePoints.getUpdated(l, S) || [];
    if (h && !h({ id: l, type: "Feature", geometry: f, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Vn.Provisional })) return false;
    this.store.updateGeometry([{ id: l, geometry: f }, ...M, ...P, ...A]), this.projection === "web-mercator" ? this.lastBearing = p : this.projection === "globe" && (this.lastBearing = p + 180);
  }
}
class iM extends po {
  constructor(n, l) {
    super(n), this.config = void 0, this.dragCoordinateResizeBehavior = void 0, this.config = n, this.dragCoordinateResizeBehavior = l;
  }
  scale(n, l, h) {
    if (!this.dragCoordinateResizeBehavior.isDragging()) {
      const f = this.dragCoordinateResizeBehavior.getDraggableIndex(n, l);
      this.dragCoordinateResizeBehavior.startDragging(l, f);
    }
    this.dragCoordinateResizeBehavior.drag(n, "center-fixed", h);
  }
  reset() {
    this.dragCoordinateResizeBehavior.stopDragging();
  }
}
function Qx({ coordinates: r, originX: n, originY: l, xScale: h, yScale: f }) {
  h === 1 && f === 1 || r.forEach((y) => {
    const { x: p, y: s } = Fi(y[0], y[1]), S = n + (p - n) * h, P = l + (s - l) * f, { lng: M, lat: A } = Lc(S, P);
    y[0] = M, y[1] = A;
  });
}
class nM extends po {
  constructor(n, l, h, f, y) {
    super(n), this.config = void 0, this.pixelDistance = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.minimumScale = 1e-4, this.draggedCoordinate = { id: null, index: -1 }, this.boundingBoxMaps = { opposite: { 0: 4, 1: 5, 2: 6, 3: 7, 4: 0, 5: 1, 6: 2, 7: 3 } }, this.config = n, this.pixelDistance = l, this.selectionPoints = h, this.midPoints = f, this.coordinatePoints = y;
  }
  getClosestCoordinate(n, l) {
    const h = { dist: 1 / 0, index: -1, isFirstOrLastPolygonCoord: false };
    let f;
    if (l.type === "LineString") f = l.coordinates;
    else {
      if (l.type !== "Polygon") return h;
      f = l.coordinates[0];
    }
    for (let y = 0; y < f.length; y++) {
      const p = this.pixelDistance.measure(n, f[y]);
      if (p < this.pointerDistance && p < h.dist) {
        const s = l.type === "Polygon" && (y === f.length - 1 || y === 0);
        h.dist = p, h.index = s ? 0 : y, h.isFirstOrLastPolygonCoord = s;
      }
    }
    return h;
  }
  isValidDragWebMercator(n, l, h) {
    switch (n) {
      case 0:
        if (l <= 0 || h >= 0) return false;
        break;
      case 1:
        if (h >= 0) return false;
        break;
      case 2:
        if (l >= 0 || h >= 0) return false;
        break;
      case 3:
        if (l >= 0) return false;
        break;
      case 4:
        if (l >= 0 || h <= 0) return false;
        break;
      case 5:
        if (h <= 0) return false;
        break;
      case 6:
        if (l <= 0 || h <= 0) return false;
        break;
      case 7:
        if (l <= 0) return false;
    }
    return true;
  }
  getSelectedFeatureDataWebMercator() {
    if (!this.draggedCoordinate.id || this.draggedCoordinate.index === -1) return null;
    const n = this.getFeature(this.draggedCoordinate.id);
    if (!n) return null;
    const l = this.getNormalisedCoordinates(n.geometry);
    return { boundingBox: this.getBBoxWebMercator(l), feature: n, updatedCoords: l, selectedCoordinate: l[this.draggedCoordinate.index] };
  }
  centerWebMercatorDrag(n) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { feature: h, boundingBox: f, updatedCoords: y, selectedCoordinate: p } = l, s = G0(h);
    if (!s) return null;
    const S = Fi(p[0], p[1]), { closestBBoxIndex: P } = this.getIndexesWebMercator(f, S), M = Fi(n.lng, n.lat);
    return this.scaleWebMercator({ closestBBoxIndex: P, updatedCoords: y, webMercatorCursor: M, webMercatorSelected: S, webMercatorOrigin: s }), y;
  }
  centerFixedWebMercatorDrag(n) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { feature: h, boundingBox: f, updatedCoords: y, selectedCoordinate: p } = l, s = G0(h);
    if (!s) return null;
    const S = Fi(p[0], p[1]), { closestBBoxIndex: P } = this.getIndexesWebMercator(f, S), M = Fi(n.lng, n.lat);
    return this.scaleFixedWebMercator({ closestBBoxIndex: P, updatedCoords: y, webMercatorCursor: M, webMercatorSelected: S, webMercatorOrigin: s }), y;
  }
  scaleFixedWebMercator({ closestBBoxIndex: n, webMercatorOrigin: l, webMercatorSelected: h, webMercatorCursor: f, updatedCoords: y }) {
    if (!this.isValidDragWebMercator(n, l.x - f.x, l.y - f.y)) return null;
    let p = Aa(l, f) / Aa(l, h);
    return p < 0 && (p = this.minimumScale), Qx({ coordinates: y, originX: l.x, originY: l.y, xScale: p, yScale: p }), y;
  }
  oppositeFixedWebMercatorDrag(n) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { boundingBox: h, updatedCoords: f, selectedCoordinate: y } = l, p = Fi(y[0], y[1]), { oppositeBboxIndex: s, closestBBoxIndex: S } = this.getIndexesWebMercator(h, p), P = { x: h[s][0], y: h[s][1] }, M = Fi(n.lng, n.lat);
    return this.scaleFixedWebMercator({ closestBBoxIndex: S, updatedCoords: f, webMercatorCursor: M, webMercatorSelected: p, webMercatorOrigin: P }), f;
  }
  oppositeWebMercatorDrag(n) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { boundingBox: h, updatedCoords: f, selectedCoordinate: y } = l, p = Fi(y[0], y[1]), { oppositeBboxIndex: s, closestBBoxIndex: S } = this.getIndexesWebMercator(h, p), P = { x: h[s][0], y: h[s][1] }, M = Fi(n.lng, n.lat);
    return this.scaleWebMercator({ closestBBoxIndex: S, updatedCoords: f, webMercatorCursor: M, webMercatorSelected: p, webMercatorOrigin: P }), f;
  }
  scaleWebMercator({ closestBBoxIndex: n, webMercatorOrigin: l, webMercatorSelected: h, webMercatorCursor: f, updatedCoords: y }) {
    const p = l.x - f.x, s = l.y - f.y;
    if (!this.isValidDragWebMercator(n, p, s)) return null;
    let S = 1;
    p !== 0 && n !== 1 && n !== 5 && (S = 1 - (l.x - h.x - p) / p);
    let P = 1;
    return s !== 0 && n !== 3 && n !== 7 && (P = 1 - (l.y - h.y - s) / s), this.validateScale(S, P) ? (S < 0 && (S = this.minimumScale), P < 0 && (P = this.minimumScale), this.performWebMercatorScale(y, l.x, l.y, S, P), y) : null;
  }
  getFeature(n) {
    if (this.draggedCoordinate.id === null) return null;
    const l = this.store.getGeometryCopy(n);
    return l.type !== "Polygon" && l.type !== "LineString" ? null : { id: n, type: "Feature", geometry: l, properties: {} };
  }
  getNormalisedCoordinates(n) {
    return n.type === "Polygon" ? n.coordinates[0] : n.coordinates;
  }
  validateScale(n, l) {
    const h = !isNaN(n) && l < Number.MAX_SAFE_INTEGER, f = !isNaN(l) && l < Number.MAX_SAFE_INTEGER;
    return h && f;
  }
  performWebMercatorScale(n, l, h, f, y) {
    n.forEach((p) => {
      const { x: s, y: S } = Fi(p[0], p[1]), P = l + (s - l) * f, M = h + (S - h) * y, { lng: A, lat: O } = Lc(P, M);
      p[0] = A, p[1] = O;
    });
  }
  getBBoxWebMercator(n) {
    const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    (n = n.map((s) => {
      const { x: S, y: P } = Fi(s[0], s[1]);
      return [S, P];
    })).forEach(([s, S]) => {
      s < l[0] && (l[0] = s), S < l[1] && (l[1] = S), s > l[2] && (l[2] = s), S > l[3] && (l[3] = S);
    });
    const [h, f, y, p] = l;
    return [[h, p], [(h + y) / 2, p], [y, p], [y, p + (f - p) / 2], [y, f], [(h + y) / 2, f], [h, f], [h, p + (f - p) / 2]];
  }
  getIndexesWebMercator(n, l) {
    let h, f = 1 / 0;
    for (let y = 0; y < n.length; y++) {
      const p = Aa({ x: l.x, y: l.y }, { x: n[y][0], y: n[y][1] });
      p < f && (h = y, f = p);
    }
    if (h === void 0) throw new Error("No closest coordinate found");
    return { oppositeBboxIndex: this.boundingBoxMaps.opposite[h], closestBBoxIndex: h };
  }
  isDragging() {
    return this.draggedCoordinate.id !== null;
  }
  startDragging(n, l) {
    this.draggedCoordinate = { id: n, index: l };
  }
  stopDragging() {
    this.draggedCoordinate = { id: null, index: -1 };
  }
  getDraggableIndex(n, l) {
    const h = this.store.getGeometryCopy(l), f = this.getClosestCoordinate(n, h);
    return f.index === -1 ? -1 : f.index;
  }
  drag(n, l, h) {
    if (!this.draggedCoordinate.id) return false;
    const f = this.getFeature(this.draggedCoordinate.id);
    if (!f) return false;
    let y = null;
    if (l === "center" ? y = this.centerWebMercatorDrag(n) : l === "opposite" ? y = this.oppositeWebMercatorDrag(n) : l === "center-fixed" ? y = this.centerFixedWebMercatorDrag(n) : l === "opposite-fixed" && (y = this.oppositeFixedWebMercatorDrag(n)), !y) return false;
    for (let M = 0; M < y.length; M++) {
      const A = y[M];
      if (A[0] = Li(A[0], this.coordinatePrecision), A[1] = Li(A[1], this.coordinatePrecision), !fv(A, this.coordinatePrecision)) return false;
    }
    const p = this.midPoints.getUpdated(y) || [], s = this.selectionPoints.getUpdated(y) || [], S = this.coordinatePoints.getUpdated(f.id, y) || [], P = { type: f.geometry.type, coordinates: f.geometry.type === "Polygon" ? [y] : y };
    return !(h && !h({ id: this.draggedCoordinate.id, type: "Feature", geometry: P, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Vn.Provisional }).valid || (this.store.updateGeometry([{ id: this.draggedCoordinate.id, geometry: P }, ...s, ...p, ...S]), 0));
  }
}
const oM = { deselect: "Escape", delete: "Delete", rotate: ["Control", "r"], scale: ["Control", "s"] }, Mb = { pointerOver: "move", dragStart: "move", dragEnd: "move", insertMidpoint: "crosshair" };
class e2 extends DE {
  constructor(n) {
    super(n, true), this.mode = "select", this.allowManualDeselection = true, this.dragEventThrottle = 5, this.dragEventCount = 0, this.selected = [], this.flags = {}, this.keyEvents = oM, this.cursors = Mb, this.validations = {}, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinateSnap = void 0, this.featuresAtMouseEvent = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.dragFeature = void 0, this.dragCoordinate = void 0, this.rotateFeature = void 0, this.scaleFeature = void 0, this.dragCoordinateResizeFeature = void 0, this.coordinatePoints = void 0, this.lineSnap = void 0, this.updateOptions(n);
  }
  updateOptions(n) {
    if (super.updateOptions(n), this.cursors = n && n.cursors ? bn({}, this.cursors, n.cursors) : Mb, (n == null ? void 0 : n.keyEvents) === null ? this.keyEvents = { deselect: null, delete: null, rotate: null, scale: null } : n != null && n.keyEvents && (this.keyEvents = bn({}, this.keyEvents, n.keyEvents)), (n == null ? void 0 : n.dragEventThrottle) !== void 0 && (this.dragEventThrottle = n.dragEventThrottle), (n == null ? void 0 : n.allowManualDeselection) !== void 0 && (this.allowManualDeselection = n.allowManualDeselection), n != null && n.flags) {
      this.flags = bn({}, this.flags, n.flags), this.validations = {};
      for (const l in this.flags) {
        const h = this.flags[l].feature;
        h && h.validation && (this.validations[l] = h.validation);
      }
    }
  }
  selectFeature(n) {
    this.select(n, false);
  }
  setSelecting() {
    if (this._state !== "started") throw new Error("Mode must be started to move to selecting state");
    this._state = "selecting";
  }
  registerBehaviors(n) {
    this.pixelDistance = new Kp(n), this.clickBoundingBox = new Yp(n), this.featuresAtMouseEvent = new QE(n, this.clickBoundingBox, this.pixelDistance), this.selectionPoints = new JE(n), this.coordinatePoints = new HE(n), this.midPoints = new KE(n, this.selectionPoints, this.coordinatePoints), this.coordinateSnap = new j0(n, this.pixelDistance, this.clickBoundingBox), this.lineSnap = new Zx(n, this.pixelDistance, this.clickBoundingBox), this.rotateFeature = new rM(n, this.selectionPoints, this.midPoints, this.coordinatePoints), this.dragFeature = new eM(n, this.featuresAtMouseEvent, this.selectionPoints, this.midPoints, this.coordinatePoints), this.dragCoordinate = new tM(n, this.pixelDistance, this.selectionPoints, this.midPoints, this.coordinatePoints, this.coordinateSnap, this.lineSnap), this.dragCoordinateResizeFeature = new nM(n, this.pixelDistance, this.selectionPoints, this.midPoints, this.coordinatePoints), this.scaleFeature = new iM(n, this.dragCoordinateResizeFeature);
  }
  deselectFeature() {
    this.deselect();
  }
  deselect() {
    const n = this.selected.filter((l) => this.store.has(l)).map((l) => ({ id: l, property: Ji.SELECTED, value: false }));
    this.store.updateProperty(n), this.onDeselect(this.selected[0]), this.selected = [], this.selectionPoints.delete(), this.midPoints.delete();
  }
  deleteSelected() {
    this.store.delete(this.selected), this.selected = [];
  }
  onRightClick(n) {
    if (!this.selectionPoints.ids.length) return;
    let l, h = 1 / 0;
    if (this.selectionPoints.ids.forEach((O) => {
      const j = this.store.getGeometryCopy(O), L = this.pixelDistance.measure(n, j.coordinates);
      L < this.pointerDistance && L < h && (h = L, l = this.store.getPropertiesCopy(O));
    }), !l) return;
    const f = l.selectionPointFeatureId, y = l.index, p = this.store.getPropertiesCopy(f), s = this.flags[p.mode], S = this.validations[p.mode];
    if (!(s && s.feature && s.feature.coordinates && s.feature.coordinates.deletable)) return;
    const P = this.store.getGeometryCopy(f);
    let M;
    if (P.type === "Polygon") {
      if (M = P.coordinates[0], M.length <= 4) return;
    } else if (P.type === "LineString" && (M = P.coordinates, M.length <= 2)) return;
    if (!M || (P.type !== "Polygon" || y !== 0 && y !== M.length - 1 ? M.splice(y, 1) : (M.shift(), M.pop(), M.push([M[0][0], M[0][1]])), S && !S({ id: f, type: "Feature", geometry: P, properties: p }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Vn.Commit }).valid)) return;
    const A = [...this.midPoints.ids, ...this.selectionPoints.ids];
    this.store.delete(A), this.store.updateGeometry([{ id: f, geometry: P }]), p.coordinatePointIds && this.coordinatePoints.createOrUpdate(f), this.selectionPoints.create(M, P.type, f), s && s.feature && s.feature.coordinates && s.feature.coordinates.midpoints && this.midPoints.create(M, f, this.coordinatePrecision);
  }
  select(n, l = true) {
    if (this.selected[0] === n) return;
    const { mode: h } = this.store.getPropertiesCopy(n), f = this.flags[h];
    if (!f || !f.feature) return;
    const y = this.selected[0];
    if (y) {
      if (y === n) return;
      this.deselect();
    }
    l && this.setCursor(this.cursors.pointerOver), this.selected = [n], this.store.updateProperty([{ id: n, property: Ji.SELECTED, value: true }]), this.onSelect(n);
    const { type: p, coordinates: s } = this.store.getGeometryCopy(n);
    if (p !== "LineString" && p !== "Polygon") return;
    const S = p === "LineString" ? s : s[0];
    S && f && f.feature.coordinates && (this.selectionPoints.create(S, p, n), f.feature.coordinates.midpoints && this.midPoints.create(S, n, this.coordinatePrecision));
  }
  onLeftClick(n) {
    const { clickedFeature: l, clickedMidPoint: h } = this.featuresAtMouseEvent.find(n, this.selected.length > 0);
    if (this.selected.length && h) this.midPoints.insert(this.selected[0], h.id, this.coordinatePrecision);
    else if (l && l.id) this.select(l.id, true);
    else if (this.selected.length && this.allowManualDeselection) return void this.deselect();
  }
  start() {
    this.setStarted(), this.setSelecting();
  }
  stop() {
    this.cleanUp(), this.setStarted(), this.setStopped();
  }
  onClick(n) {
    n.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, n) || n.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, n) ? this.onRightClick(n) : n.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, n) && this.onLeftClick(n);
  }
  canScale(n) {
    return this.keyEvents.scale && this.keyEvents.scale.every((l) => n.heldKeys.includes(l));
  }
  canRotate(n) {
    return this.keyEvents.rotate && this.keyEvents.rotate.every((l) => n.heldKeys.includes(l));
  }
  preventDefaultKeyEvent(n) {
    const l = this.canRotate(n), h = this.canScale(n);
    (l || h) && n.preventDefault();
  }
  onKeyDown(n) {
    this.preventDefaultKeyEvent(n);
  }
  onKeyUp(n) {
    if (this.preventDefaultKeyEvent(n), this.keyEvents.delete && n.key === this.keyEvents.delete) {
      if (!this.selected.length) return;
      const l = this.selected[0];
      this.onDeselect(this.selected[0]), this.coordinatePoints.deletePointsByFeatureIds([l]), this.deleteSelected(), this.selectionPoints.delete(), this.midPoints.delete();
    } else this.keyEvents.deselect && n.key === this.keyEvents.deselect && this.cleanUp();
  }
  cleanUp() {
    this.selected.length && this.deselect();
  }
  onDragStart(n, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDragStart, n) || !this.selected.length) return;
    const h = this.store.getPropertiesCopy(this.selected[0]), f = this.flags[h.mode];
    if (!(f && f.feature && (f.feature.draggable || f.feature.coordinates && f.feature.coordinates.draggable || f.feature.coordinates && f.feature.coordinates.resizable || f.feature.coordinates && typeof f.feature.coordinates.midpoints == "object" && f.feature.coordinates.midpoints.draggable))) return;
    this.dragEventCount = 0;
    const y = this.selected[0], p = this.dragCoordinate.getDraggableIndex(n, y);
    if (f && f.feature && f.feature.coordinates && (f.feature.coordinates.draggable || f.feature.coordinates.resizable) && p !== -1) return this.setCursor(this.cursors.dragStart), f.feature.coordinates.resizable ? this.dragCoordinateResizeFeature.startDragging(y, p) : this.dragCoordinate.startDragging(y, p), void l(false);
    if (f && f.feature && f.feature.coordinates && typeof f.feature.coordinates.midpoints == "object" && f.feature.coordinates.midpoints.draggable) {
      const { clickedMidPoint: s } = this.featuresAtMouseEvent.find(n, this.selected.length > 0);
      if (this.selected.length && s) {
        this.midPoints.insert(y, s.id, this.coordinatePrecision);
        const S = this.dragCoordinate.getDraggableIndex(n, y);
        return this.dragCoordinate.startDragging(y, S), void l(false);
      }
    }
    return f && f.feature && f.feature.draggable && this.dragFeature.canDrag(n, y) ? (this.setCursor(this.cursors.dragStart), this.dragFeature.startDragging(n, y), void l(false)) : void 0;
  }
  onDrag(n, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDrag, n)) return;
    const h = this.selected[0];
    if (!h) return;
    const f = this.store.getPropertiesCopy(h), y = this.flags[f.mode], p = (y && y.feature && y.feature.selfIntersectable) === true;
    if (this.dragEventCount++, this.dragEventCount % this.dragEventThrottle == 0) return;
    const s = this.validations[f.mode];
    if (y && y.feature && y.feature.rotateable && this.canRotate(n)) return l(false), void this.rotateFeature.rotate(n, h, s);
    if (y && y.feature && y.feature.scaleable && this.canScale(n)) return l(false), void this.scaleFeature.scale(n, h, s);
    if (this.dragCoordinateResizeFeature.isDragging() && y.feature && y.feature.coordinates && y.feature.coordinates.resizable) {
      if (this.projection === "globe") throw new Error("Globe is currently unsupported projection for resizable");
      return l(false), void this.dragCoordinateResizeFeature.drag(n, y.feature.coordinates.resizable, s);
    }
    if (this.dragCoordinate.isDragging()) {
      var S;
      const P = (S = y.feature) == null || (S = S.coordinates) == null ? void 0 : S.snappable;
      let M = { toCoordinate: false };
      return P === true ? M = { toCoordinate: true } : typeof P == "object" && (M = P), void this.dragCoordinate.drag(n, p, s, M);
    }
    this.dragFeature.isDragging() ? this.dragFeature.drag(n, s) : l(true);
  }
  onDragEnd(n, l) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, n) && (this.setCursor(this.cursors.dragEnd), this.dragCoordinate.isDragging() ? this.onFinish(this.selected[0], { mode: this.mode, action: "dragCoordinate" }) : this.dragFeature.isDragging() ? this.onFinish(this.selected[0], { mode: this.mode, action: "dragFeature" }) : this.dragCoordinateResizeFeature.isDragging() && this.onFinish(this.selected[0], { mode: this.mode, action: "dragCoordinateResize" }), this.dragCoordinate.stopDragging(), this.dragFeature.stopDragging(), this.dragCoordinateResizeFeature.stopDragging(), this.rotateFeature.reset(), this.scaleFeature.reset(), l(true));
  }
  onMouseMove(n) {
    if (!this.selected.length) return void this.setCursor("unset");
    if (this.dragFeature.isDragging()) return;
    let l = false;
    this.midPoints.ids.forEach((y) => {
      if (l) return;
      const p = this.store.getGeometryCopy(y);
      this.pixelDistance.measure(n, p.coordinates) < this.pointerDistance && (l = true);
    });
    let h = false;
    if (this.selectionPoints.ids.forEach((y) => {
      const p = this.store.getGeometryCopy(y);
      this.pixelDistance.measure(n, p.coordinates) < this.pointerDistance && (l = false, h = true);
    }), l) return void this.setCursor(this.cursors.insertMidpoint);
    const { clickedFeature: f } = this.featuresAtMouseEvent.find(n, true);
    this.setCursor(this.selected.length > 0 && (f && f.id === this.selected[0] || h) ? this.cursors.pointerOver : "unset");
  }
  styleFeature(n) {
    const l = bn({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0, markerUrl: void 0, markerHeight: void 0, markerWidth: void 0 });
    if (n.properties.mode === this.mode && n.geometry.type === "Point") {
      if (n.properties[Ji.SELECTION_POINT]) return l.pointColor = this.getHexColorStylingValue(this.styles.selectionPointColor, l.pointColor, n), l.pointOutlineColor = this.getHexColorStylingValue(this.styles.selectionPointOutlineColor, l.pointOutlineColor, n), l.pointWidth = this.getNumericStylingValue(this.styles.selectionPointWidth, l.pointWidth, n), l.pointOutlineWidth = this.getNumericStylingValue(this.styles.selectionPointOutlineWidth, 2, n), l.zIndex = 30, l;
      if (n.properties[Ji.MID_POINT]) return l.pointColor = this.getHexColorStylingValue(this.styles.midPointColor, l.pointColor, n), l.pointOutlineColor = this.getHexColorStylingValue(this.styles.midPointOutlineColor, l.pointOutlineColor, n), l.pointWidth = this.getNumericStylingValue(this.styles.midPointWidth, 4, n), l.pointOutlineWidth = this.getNumericStylingValue(this.styles.midPointOutlineWidth, 2, n), l.zIndex = 50, l;
    } else if (n.properties[Ji.SELECTED]) {
      if (n.geometry.type === "Point" && n.properties[Ti.MARKER]) return l.markerUrl = this.getUrlStylingValue(this.styles.selectedMarkerUrl, IE, n), l.markerHeight = this.getNumericStylingValue(this.styles.selectedMarkerHeight, 40, n), l.markerWidth = this.getNumericStylingValue(this.styles.selectedMarkerWidth, 32, n), l;
      if (n.geometry.type === "Polygon") return l.polygonFillColor = this.getHexColorStylingValue(this.styles.selectedPolygonColor, l.polygonFillColor, n), l.polygonOutlineWidth = this.getNumericStylingValue(this.styles.selectedPolygonOutlineWidth, l.polygonOutlineWidth, n), l.polygonOutlineColor = this.getHexColorStylingValue(this.styles.selectedPolygonOutlineColor, l.polygonOutlineColor, n), l.polygonFillOpacity = this.getNumericStylingValue(this.styles.selectedPolygonFillOpacity, l.polygonFillOpacity, n), l.zIndex = jp, l;
      if (n.geometry.type === "LineString") return l.lineStringColor = this.getHexColorStylingValue(this.styles.selectedLineStringColor, l.lineStringColor, n), l.lineStringWidth = this.getNumericStylingValue(this.styles.selectedLineStringWidth, l.lineStringWidth, n), l.zIndex = jp, l;
      if (n.geometry.type === "Point") return l.pointWidth = this.getNumericStylingValue(this.styles.selectedPointWidth, l.pointWidth, n), l.pointColor = this.getHexColorStylingValue(this.styles.selectedPointColor, l.pointColor, n), l.pointOutlineColor = this.getHexColorStylingValue(this.styles.selectedPointOutlineColor, l.pointOutlineColor, n), l.pointOutlineWidth = this.getNumericStylingValue(this.styles.selectedPointOutlineWidth, l.pointOutlineWidth, n), l.zIndex = jp, l;
    }
    return l;
  }
  afterFeatureUpdated(n) {
    if (this.selected.length && n.id === this.selected[0]) {
      var l, h;
      const f = this.flags[n.properties.mode];
      if (f == null || (l = f.feature) == null || !l.coordinates) return;
      const y = n.geometry.type, p = n.id;
      let s;
      if (this.selectionPoints.delete(), this.midPoints.delete(), y === "Polygon") s = n.geometry.coordinates[0];
      else {
        if (y !== "LineString") return;
        s = n.geometry.coordinates;
      }
      this.selectionPoints.create(s, y, p), f != null && (h = f.feature) != null && (h = h.coordinates) != null && h.midpoints && this.midPoints.create(y === "Polygon" ? n.geometry.coordinates[0] : n.geometry.coordinates, p, this.coordinatePrecision);
    }
  }
}
class aM extends ym {
  constructor(...n) {
    super(...n), this.type = zc.Static, this.mode = "static";
  }
  start() {
  }
  stop() {
  }
  onKeyUp() {
  }
  onKeyDown() {
  }
  onClick() {
  }
  onDragStart() {
  }
  onDrag() {
  }
  onDragEnd() {
  }
  onMouseMove() {
  }
  cleanUp() {
  }
  styleFeature() {
    return bn({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0, markerUrl: void 0, markerHeight: void 0, markerWidth: void 0 });
  }
}
function t2(r, n, l, h, f) {
  for (; h > l; ) {
    if (h - l > 600) {
      const S = h - l + 1, P = n - l + 1, M = Math.log(S), A = 0.5 * Math.exp(2 * M / 3), O = 0.5 * Math.sqrt(M * A * (S - A) / S) * (P - S / 2 < 0 ? -1 : 1);
      t2(r, n, Math.max(l, Math.floor(n - P * A / S + O)), Math.min(h, Math.floor(n + (S - P) * A / S + O)), f);
    }
    const y = r[n];
    let p = l, s = h;
    for (hh(r, l, n), f(r[h], y) > 0 && hh(r, l, h); p < s; ) {
      for (hh(r, p, s), p++, s--; f(r[p], y) < 0; ) p++;
      for (; f(r[s], y) > 0; ) s--;
    }
    f(r[l], y) === 0 ? hh(r, l, s) : (s++, hh(r, s, h)), s <= n && (l = s + 1), n <= s && (h = s - 1);
  }
}
function hh(r, n, l) {
  const h = r[n];
  r[n] = r[l], r[l] = h;
}
function Sc(r, n) {
  ph(r, 0, r.children.length, n, r);
}
function ph(r, n, l, h, f) {
  f || (f = Ic([])), f.minX = 1 / 0, f.minY = 1 / 0, f.maxX = -1 / 0, f.maxY = -1 / 0;
  for (let y = n; y < l; y++) {
    const p = r.children[y];
    mh(f, r.leaf ? h(p) : p);
  }
  return f;
}
function mh(r, n) {
  return r.minX = Math.min(r.minX, n.minX), r.minY = Math.min(r.minY, n.minY), r.maxX = Math.max(r.maxX, n.maxX), r.maxY = Math.max(r.maxY, n.maxY), r;
}
function sM(r, n) {
  return r.minX - n.minX;
}
function lM(r, n) {
  return r.minY - n.minY;
}
function u0(r) {
  return (r.maxX - r.minX) * (r.maxY - r.minY);
}
function Mp(r) {
  return r.maxX - r.minX + (r.maxY - r.minY);
}
function uM(r, n) {
  const l = Math.max(r.minX, n.minX), h = Math.max(r.minY, n.minY), f = Math.min(r.maxX, n.maxX), y = Math.min(r.maxY, n.maxY);
  return Math.max(0, f - l) * Math.max(0, y - h);
}
function c0(r, n) {
  return r.minX <= n.minX && r.minY <= n.minY && n.maxX <= r.maxX && n.maxY <= r.maxY;
}
function Dp(r, n) {
  return n.minX <= r.maxX && n.minY <= r.maxY && n.maxX >= r.minX && n.maxY >= r.minY;
}
function Ic(r) {
  return { children: r, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
}
function Db(r, n, l, h, f) {
  const y = [n, l];
  for (; y.length; ) {
    if ((l = y.pop()) - (n = y.pop()) <= h) continue;
    const p = n + Math.ceil((l - n) / h / 2) * h;
    t2(r, p, n, l, f), y.push(n, p, p, l);
  }
}
class cM {
  constructor(n) {
    this._maxEntries = void 0, this._minEntries = void 0, this.data = void 0, this._maxEntries = Math.max(4, n), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
  }
  search(n) {
    let l = this.data;
    const h = [];
    if (!Dp(n, l)) return h;
    const f = this.toBBox, y = [];
    for (; l; ) {
      for (let p = 0; p < l.children.length; p++) {
        const s = l.children[p], S = l.leaf ? f(s) : s;
        Dp(n, S) && (l.leaf ? h.push(s) : c0(n, S) ? this._all(s, h) : y.push(s));
      }
      l = y.pop();
    }
    return h;
  }
  collides(n) {
    let l = this.data;
    if (Dp(n, l)) {
      const h = [];
      for (; l; ) {
        for (let f = 0; f < l.children.length; f++) {
          const y = l.children[f], p = l.leaf ? this.toBBox(y) : y;
          if (Dp(n, p)) {
            if (l.leaf || c0(n, p)) return true;
            h.push(y);
          }
        }
        l = h.pop();
      }
    }
    return false;
  }
  load(n) {
    if (n.length < this._minEntries) {
      for (let h = 0; h < n.length; h++) this.insert(n[h]);
      return;
    }
    let l = this._build(n.slice(), 0, n.length - 1, 0);
    if (this.data.children.length) if (this.data.height === l.height) this._splitRoot(this.data, l);
    else {
      if (this.data.height < l.height) {
        const h = this.data;
        this.data = l, l = h;
      }
      this._insert(l, this.data.height - l.height - 1, true);
    }
    else this.data = l;
  }
  insert(n) {
    this._insert(n, this.data.height - 1);
  }
  clear() {
    this.data = Ic([]);
  }
  remove(n) {
    let l = this.data;
    const h = this.toBBox(n), f = [], y = [];
    let p, s, S = false;
    for (; l || f.length; ) {
      if (l || (l = f.pop(), s = f[f.length - 1], p = y.pop(), S = true), l.leaf) {
        const P = l.children.indexOf(n);
        P !== -1 && (l.children.splice(P, 1), f.push(l), this._condense(f));
      }
      S || l.leaf || !c0(l, h) ? s ? (p++, l = s.children[p], S = false) : l = null : (f.push(l), y.push(p), p = 0, s = l, l = l.children[0]);
    }
  }
  toBBox(n) {
    return n;
  }
  compareMinX(n, l) {
    return n.minX - l.minX;
  }
  compareMinY(n, l) {
    return n.minY - l.minY;
  }
  _all(n, l) {
    const h = [];
    for (; n; ) n.leaf ? l.push(...n.children) : h.push(...n.children), n = h.pop();
    return l;
  }
  _build(n, l, h, f) {
    const y = h - l + 1;
    let p, s = this._maxEntries;
    if (y <= s) return p = Ic(n.slice(l, h + 1)), Sc(p, this.toBBox), p;
    f || (f = Math.ceil(Math.log(y) / Math.log(s)), s = Math.ceil(y / Math.pow(s, f - 1))), p = Ic([]), p.leaf = false, p.height = f;
    const S = Math.ceil(y / s), P = S * Math.ceil(Math.sqrt(s));
    Db(n, l, h, P, this.compareMinX);
    for (let M = l; M <= h; M += P) {
      const A = Math.min(M + P - 1, h);
      Db(n, M, A, S, this.compareMinY);
      for (let O = M; O <= A; O += S) {
        const j = Math.min(O + S - 1, A);
        p.children.push(this._build(n, O, j, f - 1));
      }
    }
    return Sc(p, this.toBBox), p;
  }
  _chooseSubtree(n, l, h, f) {
    for (; f.push(l), !l.leaf && f.length - 1 !== h; ) {
      let s, S = 1 / 0, P = 1 / 0;
      for (let M = 0; M < l.children.length; M++) {
        const A = l.children[M], O = u0(A), j = (y = n, p = A, (Math.max(p.maxX, y.maxX) - Math.min(p.minX, y.minX)) * (Math.max(p.maxY, y.maxY) - Math.min(p.minY, y.minY)) - O);
        j < P ? (P = j, S = O < S ? O : S, s = A) : j === P && O < S && (S = O, s = A);
      }
      l = s || l.children[0];
    }
    var y, p;
    return l;
  }
  _insert(n, l, h) {
    const f = h ? n : this.toBBox(n), y = [], p = this._chooseSubtree(f, this.data, l, y);
    for (p.children.push(n), mh(p, f); l >= 0 && y[l].children.length > this._maxEntries; ) this._split(y, l), l--;
    this._adjustParentBBoxes(f, y, l);
  }
  _split(n, l) {
    const h = n[l], f = h.children.length, y = this._minEntries;
    this._chooseSplitAxis(h, y, f);
    const p = this._chooseSplitIndex(h, y, f), s = Ic(h.children.splice(p, h.children.length - p));
    s.height = h.height, s.leaf = h.leaf, Sc(h, this.toBBox), Sc(s, this.toBBox), l ? n[l - 1].children.push(s) : this._splitRoot(h, s);
  }
  _splitRoot(n, l) {
    this.data = Ic([n, l]), this.data.height = n.height + 1, this.data.leaf = false, Sc(this.data, this.toBBox);
  }
  _chooseSplitIndex(n, l, h) {
    let f, y = 1 / 0, p = 1 / 0;
    for (let s = l; s <= h - l; s++) {
      const S = ph(n, 0, s, this.toBBox), P = ph(n, s, h, this.toBBox), M = uM(S, P), A = u0(S) + u0(P);
      M < y ? (y = M, f = s, p = A < p ? A : p) : M === y && A < p && (p = A, f = s);
    }
    return f || h - l;
  }
  _chooseSplitAxis(n, l, h) {
    const f = n.leaf ? this.compareMinX : sM, y = n.leaf ? this.compareMinY : lM;
    this._allDistMargin(n, l, h, f) < this._allDistMargin(n, l, h, y) && n.children.sort(f);
  }
  _allDistMargin(n, l, h, f) {
    n.children.sort(f);
    const y = this.toBBox, p = ph(n, 0, l, y), s = ph(n, h - l, h, y);
    let S = Mp(p) + Mp(s);
    for (let P = l; P < h - l; P++) {
      const M = n.children[P];
      mh(p, n.leaf ? y(M) : M), S += Mp(p);
    }
    for (let P = h - l - 1; P >= l; P--) {
      const M = n.children[P];
      mh(s, n.leaf ? y(M) : M), S += Mp(s);
    }
    return S;
  }
  _adjustParentBBoxes(n, l, h) {
    for (let f = h; f >= 0; f--) mh(l[f], n);
  }
  _condense(n) {
    for (let l, h = n.length - 1; h >= 0; h--) n[h].children.length === 0 ? h > 0 ? (l = n[h - 1].children, l.splice(l.indexOf(n[h]), 1)) : this.clear() : Sc(n[h], this.toBBox);
  }
}
class dM {
  constructor(n) {
    this.tree = void 0, this.idToNode = void 0, this.nodeToId = void 0, this.tree = new cM(n && n.maxEntries ? n.maxEntries : 9), this.idToNode = /* @__PURE__ */ new Map(), this.nodeToId = /* @__PURE__ */ new Map();
  }
  setMaps(n, l) {
    this.idToNode.set(n.id, l), this.nodeToId.set(l, n.id);
  }
  toBBox(n) {
    const l = [], h = [];
    let f;
    if (n.geometry.type === "Polygon") f = n.geometry.coordinates[0];
    else if (n.geometry.type === "LineString") f = n.geometry.coordinates;
    else {
      if (n.geometry.type !== "Point") throw new Error("Not a valid feature to turn into a bounding box");
      f = [n.geometry.coordinates];
    }
    for (let s = 0; s < f.length; s++) h.push(f[s][1]), l.push(f[s][0]);
    const y = Math.min(...h), p = Math.max(...h);
    return { minX: Math.min(...l), minY: y, maxX: Math.max(...l), maxY: p };
  }
  insert(n) {
    if (this.idToNode.get(String(n.id))) throw new Error("Feature already exists");
    const l = this.toBBox(n);
    this.setMaps(n, l), this.tree.insert(l);
  }
  load(n) {
    const l = [], h = /* @__PURE__ */ new Set();
    n.forEach((f) => {
      const y = this.toBBox(f);
      if (this.setMaps(f, y), h.has(String(f.id))) throw new Error(`Duplicate feature ID found ${f.id}`);
      h.add(String(f.id)), l.push(y);
    }), this.tree.load(l);
  }
  update(n) {
    this.remove(n.id);
    const l = this.toBBox(n);
    this.setMaps(n, l), this.tree.insert(l);
  }
  remove(n) {
    const l = this.idToNode.get(n);
    if (!l) throw new Error(`${n} not inserted into the spatial index`);
    this.tree.remove(l);
  }
  clear() {
    this.tree.clear();
  }
  search(n) {
    return this.tree.search(this.toBBox(n)).map((l) => this.nodeToId.get(l));
  }
  collides(n) {
    return this.tree.collides(this.toBBox(n));
  }
}
const hM = { getId: () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(r) {
  const n = 16 * Math.random() | 0;
  return (r == "x" ? n : 3 & n | 8).toString(16);
}), isValidId: (r) => typeof r == "string" && r.length === 36 };
class fM {
  constructor(n) {
    this.idStrategy = void 0, this.tracked = void 0, this.spatialIndex = void 0, this.store = void 0, this._onChange = () => {
    }, this.store = {}, this.spatialIndex = new dM(), this.tracked = !n || n.tracked !== false, this.idStrategy = n && n.idStrategy ? n.idStrategy : hM;
  }
  clone(n) {
    return JSON.parse(JSON.stringify(n));
  }
  getId() {
    return this.idStrategy.getId();
  }
  has(n) {
    return !!this.store[n];
  }
  load(n, l, h, f) {
    if (n.length === 0) return [];
    let y = this.clone(n);
    const p = [], s = [];
    y = y.filter((P) => {
      P.id == null && (P.id = this.idStrategy.getId());
      const M = P.id;
      if (l) {
        const A = l(P);
        if (!A.valid) return p.push({ id: M, valid: false, reason: A.reason }), false;
      }
      if (this.tracked) {
        if (P.properties.createdAt) {
          if (!bb(P.properties.createdAt)) return p.push({ id: P.id, valid: false, reason: "createdAt is not a valid numeric timestamp" }), false;
        } else P.properties.createdAt = +/* @__PURE__ */ new Date();
        if (P.properties.updatedAt) {
          if (!bb(P.properties.updatedAt)) return p.push({ id: P.id, valid: false, reason: "updatedAt is not a valid numeric timestamp" }), false;
        } else P.properties.updatedAt = +/* @__PURE__ */ new Date();
      }
      return this.has(M) ? (p.push({ id: M, valid: false, reason: `Feature already exists with this id: ${M}` }), false) : (this.store[M] = P, s.push(P), p.push({ id: M, valid: true }), true);
    }), this.spatialIndex.load(y);
    const S = s.map(({ id: P }) => P);
    return S.length > 0 && (this._onChange(S, "create", f), h && s.forEach((P) => {
      h(P);
    })), p;
  }
  search(n, l) {
    const h = this.spatialIndex.search(n).map((f) => this.store[f]);
    return this.clone(l ? h.filter(l) : h);
  }
  registerOnChange(n) {
    this._onChange = (l, h, f) => {
      n(l, h, f);
    };
  }
  getGeometryCopy(n) {
    const l = this.store[n];
    if (!l) throw new Error(`No feature with this id (${n}), can not get geometry copy`);
    return this.clone(l.geometry);
  }
  getPropertiesCopy(n) {
    const l = this.store[n];
    if (!l) throw new Error(`No feature with this id (${n}), can not get properties copy`);
    return this.clone(l.properties);
  }
  updateProperty(n, l) {
    const h = [];
    n.forEach(({ id: f, property: y, value: p }) => {
      const s = this.store[f];
      if (!s) throw new Error(`No feature with this (${f}), can not update geometry`);
      h.push(f), p === void 0 ? delete s.properties[y] : s.properties[y] = p, this.tracked && (s.properties.updatedAt = +/* @__PURE__ */ new Date());
    }), this._onChange && this._onChange(h, "update", l);
  }
  updateGeometry(n, l) {
    const h = [];
    n.forEach(({ id: f, geometry: y }) => {
      h.push(f);
      const p = this.store[f];
      if (!p) throw new Error(`No feature with this (${f}), can not update geometry`);
      p.geometry = this.clone(y), this.spatialIndex.update(p), this.tracked && (p.properties.updatedAt = +/* @__PURE__ */ new Date());
    }), this._onChange && this._onChange(h, "update", l);
  }
  create(n, l) {
    const h = [];
    return n.forEach(({ geometry: f, properties: y }) => {
      let p, s = bn({}, y);
      this.tracked && (p = +/* @__PURE__ */ new Date(), y ? (s.createdAt = typeof y.createdAt == "number" ? y.createdAt : p, s.updatedAt = typeof y.updatedAt == "number" ? y.updatedAt : p) : s = { createdAt: p, updatedAt: p });
      const S = this.getId(), P = { id: S, type: "Feature", geometry: f, properties: s };
      this.store[S] = P, this.spatialIndex.insert(P), h.push(S);
    }), this._onChange && this._onChange([...h], "create", l), h;
  }
  delete(n, l) {
    n.forEach((h) => {
      if (!this.store[h]) throw new Error(`No feature with id ${h}, can not delete`);
      delete this.store[h], this.spatialIndex.remove(h);
    }), this._onChange && this._onChange([...n], "delete", l);
  }
  copy(n) {
    return this.clone(this.store[n]);
  }
  copyAll() {
    return this.clone(Object.keys(this.store).map((n) => this.store[n]));
  }
  copyAllWhere(n) {
    return this.clone(Object.keys(this.store).map((l) => this.store[l]).filter((l) => l.properties && n(l.properties)));
  }
  clear() {
    this.store = {}, this.spatialIndex.clear();
  }
  size() {
    return Object.keys(this.store).length;
  }
}
class kc {
  constructor({ name: n, callback: l, unregister: h, register: f }) {
    this.name = void 0, this.callback = void 0, this.registered = false, this.register = void 0, this.unregister = void 0, this.name = n, this.register = () => {
      this.registered || (this.registered = true, f(l));
    }, this.unregister = () => {
      this.register && (this.registered = false, h(l));
    }, this.callback = l;
  }
}
var pM = { __proto__: null, TerraDrawBaseAdapter: class {
  constructor(r) {
    this._nextKeyUpIsContextMenu = false, this._lastPointerDownEventTarget = void 0, this._ignoreMismatchedPointerEvents = false, this._minPixelDragDistance = void 0, this._minPixelDragDistanceDrawing = void 0, this._minPixelDragDistanceSelecting = void 0, this._lastDrawEvent = void 0, this._coordinatePrecision = void 0, this._heldKeys = /* @__PURE__ */ new Set(), this._listeners = [], this._dragState = "not-dragging", this._currentModeCallbacks = void 0, this._ignoreMismatchedPointerEvents = typeof r.ignoreMismatchedPointerEvents == "boolean" && r.ignoreMismatchedPointerEvents, this._minPixelDragDistance = typeof r.minPixelDragDistance == "number" ? r.minPixelDragDistance : 1, this._minPixelDragDistanceSelecting = typeof r.minPixelDragDistanceSelecting == "number" ? r.minPixelDragDistanceSelecting : 1, this._minPixelDragDistanceDrawing = typeof r.minPixelDragDistanceDrawing == "number" ? r.minPixelDragDistanceDrawing : 8, this._coordinatePrecision = typeof r.coordinatePrecision == "number" ? r.coordinatePrecision : 9;
  }
  getButton(r) {
    return r.button === -1 ? "neither" : r.button === 0 ? "left" : r.button === 1 ? "middle" : r.button === 2 ? "right" : "neither";
  }
  getMapElementXYPosition(r) {
    const n = this.getMapEventElement(), { left: l, top: h } = n.getBoundingClientRect();
    return { containerX: r.clientX - l, containerY: r.clientY - h };
  }
  getDrawEventFromEvent(r, n = false) {
    const l = this.getLngLatFromEvent(r);
    if (!l) return null;
    const { lng: h, lat: f } = l, { containerX: y, containerY: p } = this.getMapElementXYPosition(r), s = this.getButton(r), S = Array.from(this._heldKeys);
    return { lng: Li(h, this._coordinatePrecision), lat: Li(f, this._coordinatePrecision), containerX: y, containerY: p, button: s, heldKeys: S, isContextMenu: n };
  }
  register(r) {
    this._currentModeCallbacks = r, this._listeners = this.getAdapterListeners(), this._listeners.forEach((n) => {
      n.register();
    });
  }
  getCoordinatePrecision() {
    return this._coordinatePrecision;
  }
  getAdapterListeners() {
    return [new kc({ name: "pointerdown", callback: (r) => {
      if (!this._currentModeCallbacks || !r.isPrimary) return;
      const n = this.getDrawEventFromEvent(r);
      n && (this._dragState = "pre-dragging", this._lastDrawEvent = n, this._lastPointerDownEventTarget = r.target ? r.target : void 0);
    }, register: (r) => {
      this.getMapEventElement().addEventListener("pointerdown", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("pointerdown", r);
    } }), new kc({ name: "pointermove", callback: (r) => {
      if (!this._currentModeCallbacks || !r.isPrimary) return;
      r.preventDefault();
      const n = this.getDrawEventFromEvent(r);
      if (n) if (this._dragState === "not-dragging") this._currentModeCallbacks.onMouseMove(n), this._lastDrawEvent = n;
      else if (this._dragState === "pre-dragging") {
        if (!this._lastDrawEvent) return;
        const l = { x: this._lastDrawEvent.containerX, y: this._lastDrawEvent.containerY }, h = { x: n.containerX, y: n.containerY }, f = this._currentModeCallbacks.getState(), y = Aa(l, h);
        let p = false;
        if (p = f === "drawing" ? y < this._minPixelDragDistanceDrawing : f === "selecting" ? y < this._minPixelDragDistanceSelecting : y < this._minPixelDragDistance, p) return;
        this._nextKeyUpIsContextMenu = false, this._dragState = "dragging", this._currentModeCallbacks.onDragStart(n, (s) => {
          this.setDraggability.bind(this)(s);
        });
      } else this._dragState === "dragging" && this._currentModeCallbacks.onDrag(n, (l) => {
        this.setDraggability.bind(this)(l);
      });
    }, register: (r) => {
      this.getMapEventElement().addEventListener("pointermove", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("pointermove", r);
    } }), new kc({ name: "contextmenu", callback: (r) => {
      this._currentModeCallbacks && (r.preventDefault(), this._nextKeyUpIsContextMenu = true);
    }, register: (r) => {
      this.getMapEventElement().addEventListener("contextmenu", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("contextmenu", r);
    } }), new kc({ name: "pointerup", callback: (r) => {
      if (!this._currentModeCallbacks || r.target !== this.getMapEventElement() || this._ignoreMismatchedPointerEvents && this._lastPointerDownEventTarget !== r.target || (this._lastPointerDownEventTarget = void 0, !r.isPrimary)) return;
      const n = this.getDrawEventFromEvent(r);
      n && (this._dragState === "dragging" ? this._currentModeCallbacks.onDragEnd(n, (l) => {
        this.setDraggability.bind(this)(l);
      }) : this._dragState !== "not-dragging" && this._dragState !== "pre-dragging" || (this._nextKeyUpIsContextMenu && (n.isContextMenu = true, this._nextKeyUpIsContextMenu = false), this._currentModeCallbacks.onClick(n)), this._dragState = "not-dragging", this.setDraggability(true));
    }, register: (r) => {
      this.getMapEventElement().addEventListener("pointerup", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("pointerup", r);
    } }), new kc({ name: "keyup", callback: (r) => {
      this._currentModeCallbacks && (this._heldKeys.delete(r.key), this._currentModeCallbacks.onKeyUp({ key: r.key, heldKeys: Array.from(this._heldKeys), preventDefault: () => r.preventDefault() }));
    }, register: (r) => {
      this.getMapEventElement().addEventListener("keyup", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("keyup", r);
    } }), new kc({ name: "keydown", callback: (r) => {
      this._currentModeCallbacks && (this._heldKeys.add(r.key), this._currentModeCallbacks.onKeyDown({ key: r.key, heldKeys: Array.from(this._heldKeys), preventDefault: () => r.preventDefault() }));
    }, register: (r) => {
      this.getMapEventElement().addEventListener("keydown", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("keydown", r);
    } })];
  }
  unregister() {
    this._listeners.forEach((r) => {
      r.unregister();
    }), this.clear(), this._currentModeCallbacks = void 0, this._lastDrawEvent = void 0, this._lastPointerDownEventTarget = void 0, this._nextKeyUpIsContextMenu = false;
  }
} };
function q0(r) {
  if (r === null || typeof r == "boolean" || typeof r == "string") return true;
  if (r === void 0) return false;
  if (typeof r == "number") return Number.isFinite(r);
  if (typeof r == "bigint" || typeof r == "symbol" || typeof r == "function" || r instanceof RegExp || r instanceof Map || r instanceof Set || r instanceof Date) return false;
  if (typeof r == "object" && r !== null && !Array.isArray(r)) {
    const n = Object.getPrototypeOf(r);
    if (n !== Object.prototype && n !== null) return false;
  }
  if (ArrayBuffer.isView(r) && !(r instanceof DataView)) return false;
  if (Array.isArray(r)) {
    for (const n of r) if (!q0(n)) return false;
  }
  return typeof r == "object" && Object.keys(r).every((n) => typeof n == "string" && q0(r[n]));
}
class mM {
  constructor(n) {
    this._modes = void 0, this._mode = void 0, this._adapter = void 0, this._enabled = false, this._store = void 0, this._eventListeners = void 0, this._instanceSelectMode = void 0, this._adapter = n.adapter, this._mode = new aM();
    const l = /* @__PURE__ */ new Set(), h = n.modes.reduce((M, A) => {
      if (l.has(A.mode)) throw new Error(`There is already a ${A.mode} mode provided`);
      return l.add(A.mode), M[A.mode] = A, M;
    }, {}), f = Object.keys(h);
    if (f.length === 0) throw new Error("No modes provided");
    f.forEach((M) => {
      if (h[M].type === zc.Select) {
        if (this._instanceSelectMode) throw new Error("only one type of select mode can be provided");
        this._instanceSelectMode = M;
      }
    }), this._modes = bn({}, h, { static: this._mode }), this._eventListeners = { change: [], select: [], deselect: [], finish: [], ready: [] }, this._store = new fM({ tracked: !!n.tracked, idStrategy: n.idStrategy ? n.idStrategy : void 0 });
    const y = (M) => {
      const A = [], O = this._store.copyAll().filter((j) => !M.includes(j.id) || (A.push(j), false));
      return { changed: A, unchanged: O };
    }, p = (M, A) => {
      this._enabled && this._eventListeners.finish.forEach((O) => {
        O(M, A);
      });
    }, s = (M, A, O) => {
      if (!this._enabled) return;
      this._eventListeners.change.forEach((q) => {
        q(M, A, O);
      });
      const { changed: j, unchanged: L } = y(M);
      A === "create" ? this._adapter.render({ created: j, deletedIds: [], unchanged: L, updated: [] }, this.getModeStyles()) : A === "update" ? this._adapter.render({ created: [], deletedIds: [], unchanged: L, updated: j }, this.getModeStyles()) : A === "delete" ? this._adapter.render({ created: [], deletedIds: M, unchanged: L, updated: [] }, this.getModeStyles()) : A === "styling" && this._adapter.render({ created: [], deletedIds: [], unchanged: L, updated: [] }, this.getModeStyles());
    }, S = (M) => {
      if (!this._enabled) return;
      this._eventListeners.select.forEach((j) => {
        j(M);
      });
      const { changed: A, unchanged: O } = y([M]);
      this._adapter.render({ created: [], deletedIds: [], unchanged: O, updated: A }, this.getModeStyles());
    }, P = (M) => {
      if (!this._enabled) return;
      this._eventListeners.deselect.forEach((j) => {
        j();
      });
      const { changed: A, unchanged: O } = y([M]);
      A && this._adapter.render({ created: [], deletedIds: [], unchanged: O, updated: A }, this.getModeStyles());
    };
    Object.keys(this._modes).forEach((M) => {
      this._modes[M].register({ mode: M, store: this._store, setCursor: this._adapter.setCursor.bind(this._adapter), project: this._adapter.project.bind(this._adapter), unproject: this._adapter.unproject.bind(this._adapter), setDoubleClickToZoom: this._adapter.setDoubleClickToZoom.bind(this._adapter), onChange: s, onSelect: S, onDeselect: P, onFinish: p, coordinatePrecision: this._adapter.getCoordinatePrecision() });
    });
  }
  checkEnabled() {
    if (!this._enabled) throw new Error("Terra Draw is not enabled");
  }
  getModeStyles() {
    const n = {};
    return Object.keys(this._modes).forEach((l) => {
      n[l] = (h) => this._instanceSelectMode && h.properties[Ji.SELECTED] ? this._modes[this._instanceSelectMode].styleFeature.bind(this._modes[this._instanceSelectMode])(h) : this._modes[l].styleFeature.bind(this._modes[l])(h);
    }), n;
  }
  featuresAtLocation({ lng: n, lat: l }, h) {
    const f = h && h.pointerDistance !== void 0 ? h.pointerDistance : 30, y = !h || h.ignoreSelectFeatures === void 0 || h.ignoreSelectFeatures, p = !(!h || h.ignoreCoordinatePoints === void 0) && h.ignoreCoordinatePoints, s = !(!h || h.ignoreCurrentlyDrawing === void 0) && h.ignoreCurrentlyDrawing, S = !(!h || h.ignoreClosingPoints === void 0) && h.ignoreClosingPoints, P = !(!h || h.ignoreSnappingPoints === void 0) && h.ignoreSnappingPoints, M = this._adapter.unproject.bind(this._adapter), A = this._adapter.project.bind(this._adapter), O = A(n, l), j = Wx({ unproject: M, point: O, pointerDistance: f });
    return this._store.search(j).filter((L) => {
      if (y && (L.properties[Ji.MID_POINT] || L.properties[Ji.SELECTION_POINT]) || p && L.properties[Ti.COORDINATE_POINT] || S && L.properties[Ti.CLOSING_POINT] || s && L.properties[Ti.CURRENTLY_DRAWING] || P && L.properties[Ti.SNAPPING_POINT]) return false;
      if (L.geometry.type === "Point") {
        const q = L.geometry.coordinates, N = A(q[0], q[1]);
        return Aa(O, N) < f;
      }
      if (L.geometry.type === "LineString") {
        const q = L.geometry.coordinates;
        for (let N = 0; N < q.length - 1; N++) {
          const J = q[N], te = q[N + 1];
          if (U0(O, A(J[0], J[1]), A(te[0], te[1])) < f) return true;
        }
        return false;
      }
      if (Kx([n, l], L.geometry.coordinates)) return true;
      if (h != null && h.includePolygonsWithinPointerDistance) {
        const q = L.geometry.coordinates;
        for (const N of q) for (let J = 0; J < N.length - 1; J++) {
          const te = N[J], ne = N[J + 1], ae = A(te[0], te[1]), oe = A(ne[0], ne[1]);
          if (U0(O, ae, oe) < f) return true;
        }
      }
      return false;
    }).map((L) => {
      if (h == null || !h.addClosestCoordinateInfoToProperties) return L;
      let q;
      if (L.geometry.type === "Polygon") q = L.geometry.coordinates[0].slice(0, -1);
      else {
        if (L.geometry.type !== "LineString") return L;
        q = L.geometry.coordinates;
      }
      let N, J = -1, te = 1 / 0;
      for (let ne = 0; ne < q.length; ne++) {
        const ae = q[ne], oe = Aa(A(ae[0], ae[1]), O);
        oe < te && (J = ne, te = oe, N = ae);
      }
      return L.properties.closestCoordinateIndexToEvent = J, L.properties.closestCoordinatePixelDistanceToEvent = te, L.properties.closestCoordinateDistanceKmToEvent = hs(N, [n, l]), L;
    });
  }
  getSelectModeOrThrow() {
    const n = this.getSelectMode({ switchToSelectMode: true });
    if (!n) throw new Error("No select mode defined in instance");
    return n;
  }
  getSelectMode({ switchToSelectMode: n }) {
    if (this.checkEnabled(), !this._instanceSelectMode) return null;
    const l = this.getMode();
    return n && l !== this._instanceSelectMode && this.setMode(this._instanceSelectMode), this._modes[this._instanceSelectMode];
  }
  isGuidanceFeature(n) {
    return !!(n.properties[Ji.MID_POINT] || n.properties[Ji.SELECTION_POINT] || n.properties[Ti.COORDINATE_POINT] || n.properties[Ti.SNAPPING_POINT]);
  }
  setModeStyles(n, l) {
    if (this.checkEnabled(), !this._modes[n]) throw new Error("No mode with this name present");
    this._modes[n].styles = l;
  }
  updateModeOptions(n, l) {
    if (this.checkEnabled(), !this._modes[n]) throw new Error("No mode with this name present");
    this._modes[n].updateOptions(l);
  }
  getSnapshot() {
    return this._store.copyAll();
  }
  getSnapshotFeature(n) {
    if (this._store.has(n)) return this._store.copy(n);
  }
  clear() {
    this.checkEnabled(), this._adapter.clear();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(n) {
    throw new Error("Enabled is read only");
  }
  getMode() {
    return this._mode.mode;
  }
  getModeState() {
    return this._mode.state;
  }
  setMode(n) {
    if (this.checkEnabled(), !this._modes[n]) throw new Error("No mode with this name present");
    this._mode.stop(), this._mode = this._modes[n], this._mode.start();
  }
  removeFeatures(n) {
    this.checkEnabled();
    const l = [];
    n.forEach((h) => {
      if (!this._store.has(h)) throw new Error(`No feature with id ${h}, can not delete`);
      const f = this._store.copy(h);
      f.properties[Ji.SELECTED] && this.deselectFeature(h), f.properties[Ti.COORDINATE_POINT_IDS] && l.push(...f.properties[Ti.COORDINATE_POINT_IDS]);
    }), this._store.delete([...n, ...l], { origin: "api" });
  }
  selectFeature(n) {
    this.getSelectModeOrThrow().selectFeature(n);
  }
  deselectFeature(n) {
    this.getSelectModeOrThrow().deselectFeature(n);
  }
  getFeatureId() {
    return this._store.getId();
  }
  hasFeature(n) {
    return this._store.has(n);
  }
  checkIsReservedProperty(n) {
    return ![...Object.values(Ji), ...Object.values(Ti)].includes(n);
  }
  updateFeatureProperties(n, l) {
    if (!this._store.has(n)) throw new Error(`No feature with id ${n} present in store`);
    const h = this._store.copy(n);
    if (this.isGuidanceFeature(h)) throw new Error("Guidance features are not allowed to be updated directly.");
    const f = h.properties.mode;
    if (!this._modes[f]) throw new Error(`No mode with name ${f} present in instance`);
    const y = Object.entries(l);
    y.forEach(([p, s]) => {
      if (!this.checkIsReservedProperty(p)) throw new Error(`You are trying to update a reserved property name: ${p}. Please choose another name.`);
      if (s !== void 0 && !q0(s)) throw new Error(`Invalid JSON value provided for property ${p}`);
    }), this._store.updateProperty(y.map(([p, s]) => ({ id: h.id, property: p, value: s })), { origin: "api" });
  }
  updateFeatureGeometry(n, l) {
    if (!this._store.has(n)) throw new Error(`No feature with id ${n} present in store`);
    const h = this._store.copy(n);
    if (this.isGuidanceFeature(h)) throw new Error("Guidance features are not allowed to be updated directly.");
    if (!(h && l && l.type && l.coordinates)) throw new Error("Invalid geometry provided");
    if (l.type !== h.geometry.type) throw new Error(`Geometry type mismatch: expected ${h.geometry.type}, got ${l.type}`);
    const f = h.properties.mode, y = this._modes[f];
    if (!y) throw new Error(`No mode with name ${f} present in instance`);
    const p = bn({}, h, { geometry: l }), s = y.validateFeature(p);
    if (!s.valid) throw new Error(`Feature validation failed: ${s.reason || "Unknown reason"}`);
    if (this._store.updateGeometry([{ id: h.id, geometry: l }], { origin: "api" }), y.afterFeatureUpdated) {
      y.afterFeatureUpdated(p);
      const S = p.properties[Ji.SELECTED], P = this.getSelectMode({ switchToSelectMode: false });
      P && S && P.afterFeatureUpdated(p);
    }
  }
  transformFeatureGeometry(n, l) {
    if (!this._store.has(n)) throw new Error(`No feature with id ${n} present in store`);
    let h = this._store.copy(n);
    if (this.isGuidanceFeature(h)) throw new Error("Guidance features are not allowed to be updated directly.");
    const f = h.properties.mode, y = this._modes[f];
    if (!y) throw new Error(`No mode with name ${f} present in instance`);
    let p;
    if (h.geometry.type === "Polygon") p = h.geometry.coordinates[0];
    else {
      if (h.geometry.type !== "LineString") throw new Error(`Feature geometry type ${h.geometry.type} is not supported for transformation`);
      p = h.geometry.coordinates;
    }
    if (l.projection != "web-mercator") throw new Error(`Projection ${l.projection} is not currently supported for transformation`);
    if (l.type === "scale") {
      const { x: s, y: S } = Fi(l.origin[0], l.origin[1]);
      Qx({ coordinates: p, originX: s, originY: S, xScale: l.options.xScale || 1, yScale: l.options.yScale || 1 });
    } else l.type === "rotate" && (h = Jx(h, l.options.angle || 0), p = h.geometry.type === "Polygon" ? h.geometry.coordinates[0] : h.geometry.coordinates);
    if (p = p.map((s) => [Li(s[0], this._adapter.getCoordinatePrecision()), Li(s[1], this._adapter.getCoordinatePrecision())]), h.geometry.coordinates = h.geometry.type === "Polygon" ? [p] : p, this._store.updateGeometry([{ id: h.id, geometry: h.geometry }], { origin: "api" }), y.afterFeatureUpdated) {
      y.afterFeatureUpdated(h);
      const s = h.properties[Ji.SELECTED], S = this.getSelectMode({ switchToSelectMode: false });
      S && s && S.afterFeatureUpdated(h);
    }
  }
  addFeatures(n) {
    return this.checkEnabled(), n.length === 0 ? [] : this._store.load(n, (l) => {
      if (_b(l)) {
        const h = l.properties.mode, f = this._modes[h];
        if (!f) return { id: l.id, valid: false, reason: `${h} mode is not in the list of instantiated modes` };
        const y = f.validateFeature.bind(f)(l);
        return { id: l.id, valid: y.valid, reason: y.reason ? y.reason : y.valid ? void 0 : "Feature is invalid" };
      }
      return { id: l.id, valid: false, reason: "Mode property does not exist" };
    }, (l) => {
      if (_b(l)) {
        const h = this._modes[l.properties.mode];
        h && h.afterFeatureAdded && h.afterFeatureAdded(l);
      }
    }, { origin: "api" });
  }
  start() {
    this._enabled || (this._enabled = true, this._adapter.register({ onReady: () => {
      this._eventListeners.ready.forEach((n) => {
        n();
      });
    }, getState: () => this._mode.state, onClick: (n) => {
      this._mode.onClick(n);
    }, onMouseMove: (n) => {
      this._mode.onMouseMove(n);
    }, onKeyDown: (n) => {
      this._mode.onKeyDown(n);
    }, onKeyUp: (n) => {
      this._mode.onKeyUp(n);
    }, onDragStart: (n, l) => {
      this._mode.onDragStart(n, l);
    }, onDrag: (n, l) => {
      this._mode.onDrag(n, l);
    }, onDragEnd: (n, l) => {
      this._mode.onDragEnd(n, l);
    }, onClear: () => {
      this._mode.cleanUp(), this._store.clear();
    } }));
  }
  getFeaturesAtLngLat(n, l) {
    const { lng: h, lat: f } = n;
    return this.featuresAtLocation({ lng: h, lat: f }, l);
  }
  getFeaturesAtPointerEvent(n, l) {
    const h = this._adapter.getLngLatFromEvent.bind(this._adapter)(n);
    return h === null ? [] : this.featuresAtLocation(h, l);
  }
  stop() {
    this._enabled && (this._enabled = false, this._adapter.unregister());
  }
  on(n, l) {
    const h = this._eventListeners[n];
    h.includes(l) || h.push(l);
  }
  off(n, l) {
    const h = this._eventListeners[n];
    h.includes(l) && h.splice(h.indexOf(l), 1);
  }
}
const gM = nt({ __name: "MapContainer", props: { styleUrl: {}, geojsonSource: {}, drawerModes: {}, onMapInit: { type: Function }, onMapTouchStart: { type: Function }, onMapTouchEnd: { type: Function }, onMapClick: { type: Function } }, setup(r, { expose: n }) {
  const l = r, h = Fa(null), f = Fa(null), y = uS(), p = Ux(), s = Gn();
  Kt([() => y.settings.mapLanguage, () => s.locale.value], (j) => {
    j && h.value && S(h.value, j[0] === "interface" ? j[1] : j[0]);
  });
  const S = (j, L) => {
    const q = L === "zh-CN" ? "zh" : "en", N = ["City labels", "Road labels", "Station labels", "Airport labels", "Continent labels", "Country labels"];
    for (const J of N) j.setLayoutProperty(J, "text-field", ["get", `name:${q}`]);
  };
  function P(j) {
    const L = j.getStyle().layers;
    let q;
    for (let N = 0; N < L.length; N++) {
      const J = L[N];
      if (J.type === "symbol" && J.layout && typeof J.layout == "object" && "text-field" in J.layout) {
        q = J.id;
        break;
      }
    }
    j.addLayer({ id: "3d-buildings", source: "openfreemap", "source-layer": "building", type: "fill-extrusion", minzoom: 15, filter: ["!=", ["get", "hide_3d"], true], paint: { "fill-extrusion-color": ["interpolate", ["linear"], ["get", "render_height"], 0, "lightgray", 200, "royalblue", 400, "lightblue"], "fill-extrusion-height": ["interpolate", ["linear"], ["zoom"], 15, 0, 16, ["get", "render_height"]], "fill-extrusion-base": ["case", [">=", ["get", "zoom"], 16], ["get", "render_min_height"], 0] } }, q);
  }
  function M(j) {
    j.removeLayer("3d-buildings");
  }
  function A(j) {
    var _a2, _b2;
    h.value = j.map, (_a2 = h.value) == null ? void 0 : _a2.addSource("openfreemap", { url: "https://tiles.openfreemap.org/planet", type: "vector" }), h.value && S(h.value, s.locale.value), p.isTrackingOrientation && (O(), O()), (_b2 = h.value) == null ? void 0 : _b2.on("click", l.onMapClick), l.onMapInit(j);
  }
  const O = /* @__PURE__ */ (() => {
    let j = null;
    return () => {
      var _a2;
      p.setTrackingOrientation(!p.isTrackingOrientation), p.isTrackingOrientation ? j = js.addHandler((L) => {
        var _a3, _b2, _c2, _d;
        if (p.isTrackingOrientation) {
          if (((_a3 = h.value) == null ? void 0 : _a3.isEasing()) || ((_b2 = h.value) == null ? void 0 : _b2.isMoving()) || ((_c2 = h.value) == null ? void 0 : _c2.isRotating()) || ((_d = h.value) == null ? void 0 : _d.isZooming())) return;
          p.setBearing(L);
        }
      }) : j !== null && (j = null, p.setBearing(0), (_a2 = h.value) == null ? void 0 : _a2.setBearing(0));
    };
  })();
  return n({ setupBuildingLayer: P, removeBuildingLayer: M, toggleOrientationTracking: O, map: h, draw: f }), (j, L) => (ut(), fr(K(Lx), { bearing: K(p).bearing, "onUpdate:bearing": L[0] || (L[0] = (q) => K(p).bearing = q), zoom: K(p).zoom, "onUpdate:zoom": L[1] || (L[1] = (q) => K(p).zoom = q), center: K(p).center, "onUpdate:center": L[2] || (L[2] = (q) => K(p).center = q), "map-style": r.styleUrl, height: "100%", "onMap:load": A, "onMap:touchstart": r.onMapTouchStart, "onMap:touchend": r.onMapTouchEnd }, { default: je(() => [ze(K(FI), { "source-id": "geojson", data: r.geojsonSource, "line-metrics": true }, { default: je(() => [ze(K($I), { "layer-id": "geojson", layout: { "line-join": "round", "line-cap": "round" }, paint: { "line-width": 5, "line-gradient": ["interpolate", ["linear"], ["line-progress"], 0, "#00ff00", 0.7, "#00DD00", 0.9, "#00BB00", 1, "#008800"], "line-opacity": 0.8 } })]), _: 1 }, 8, ["data"]), tm(j.$slots, "default")]), _: 3 }, 8, ["bearing", "zoom", "center", "map-style", "onMap:touchstart", "onMap:touchend"]));
} }), vM = nt({ __name: "MapControls", setup(r) {
  return (n, l) => (ut(), Ot("div", null, [ze(K(Ox), { position: "top-left" }), ze(K(Bx), { position: "top-left" }), ze(K(Nx), { position: "bottom-left" })]));
} }), yM = Ui(vM, [["__scopeId", "data-v-ad570dc0"]]), _M = ["title", "onClick"], bM = nt({ __name: "DrawingTools", props: { activeDrawMethod: {} }, emits: ["update:activeDrawMethod", "setDrawMode"], setup(r, { emit: n }) {
  const { t: l } = Gn(), f = new jc().isMobile, y = false, p = [{ mode: new Xx(), name: l("trackerView.terraDrawTools.point"), icon: rv }, { mode: new Hx(), name: l("trackerView.terraDrawTools.line"), icon: j1 }, { mode: new e2({ allowManualDeselection: true, flags: { point: { feature: { draggable: true } }, polygon: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, linestring: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, freehand: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, circle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, rectangle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } } } }), name: l("trackerView.terraDrawTools.select"), icon: N1 }], s = r, S = n, P = (M) => {
    s.activeDrawMethod === M.mode ? (S("setDrawMode", "select"), S("update:activeDrawMethod", "select")) : (S("update:activeDrawMethod", M.mode), S("setDrawMode", M.mode));
  };
  return (M, A) => !K(f) || y ? (ut(), fr(K(vm), { key: 0, position: "top-right" }, { default: je(() => [(ut(), Ot(jr, null, un(p, (O) => xt("button", { key: O.name, class: ha(["btn-control", { active: O.mode.mode === r.activeDrawMethod }]), title: O.name, onClick: (j) => P(O.mode) }, [ze(K(xi), { size: 20 }, { default: je(() => [(ut(), fr($c(O.icon), { class: "btn-default" }))]), _: 2 }, 1024)], 10, _M)), 64))]), _: 1 })) : _r("", true);
} }), xM = Ui(bM, [["__scopeId", "data-v-0c23bdfa"]]), wM = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'%20?%3e%3c!DOCTYPE%20svg%20PUBLIC%20'-//W3C//DTD%20SVG%201.1//EN'%20'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg%20width='337pt'%20height='570pt'%20viewBox='0%200%20337%20570'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='%23010101ff'%3e%3c/g%3e%3cg%20id='%23fefefeff'%3e%3cpath%20fill='%23fefefe'%20opacity='1.00'%20d='%20M%20166.30%2034.31%20C%20170.55%2032.66%20175.49%2034.16%20177.91%2038.06%20C%20207.78%2088.56%20237.82%20138.97%20267.41%20189.64%20C%20272.78%20198.93%20278.71%20207.92%20283.33%20217.62%20C%20287.47%20225.84%20291.89%20234.58%20291.29%20244.05%20C%20290.88%20251.07%20284.88%20258.19%20277.33%20256.73%20C%20262.96%20252.68%20250.07%20244.73%20235.92%20240.03%20C%20214.99%20231.74%20192.42%20228.24%20170.00%20227.63%20C%20148.91%20228.22%20127.73%20231.43%20107.84%20238.63%20C%2092.90%20243.30%2079.32%20251.36%2064.47%20256.24%20C%2059.30%20258.15%2052.76%20255.48%2050.66%20250.31%20C%2046.78%20243.23%2049.19%20234.81%2051.89%20227.76%20C%2056.51%20217.17%2062.04%20206.98%2068.16%20197.18%20C%2098.26%20145.68%20128.69%2094.38%20159.14%2043.09%20C%20160.98%2039.80%20162.80%2036.10%20166.30%2034.31%20M%20165.46%2076.51%20C%20161.14%2084.39%20156.35%2091.99%20151.68%2099.66%20C%20146.23%20109.46%20140.40%20119.03%20134.68%20128.66%20C%20119.48%20155.09%20104.18%20181.47%2088.70%20207.74%20C%2086.55%20211.59%2083.58%20214.95%2081.76%20218.99%20C%2081.46%20221.46%2084.20%20221.79%2085.93%20221.02%20C%2093.56%20218.30%20100.92%20214.75%20108.82%20212.83%20C%20115.18%20211.22%20121.55%20209.66%20127.87%20207.89%20C%20150.73%20202.18%20174.79%20200.91%20198.04%20204.96%20C%20208.80%20206.29%20219.05%20209.99%20229.58%20212.41%20C%20237.78%20214.21%20245.35%20217.94%20253.21%20220.76%20C%20254.77%20221.45%20256.47%20221.24%20258.11%20221.06%20C%20258.49%20217.46%20255.67%20214.84%20254.00%20211.98%20C%20250.02%20205.59%20246.07%20199.18%20242.44%20192.58%20C%20220.66%20155.66%20199.60%20118.31%20177.40%2081.64%20C%20175.00%2077.57%20172.96%2073.26%20170.00%2069.54%20C%20168.29%2071.72%20166.77%2074.06%20165.46%2076.51%20Z'%20/%3e%3cpath%20fill='%23fefefe'%20opacity='1.00'%20d='%20M%20151.49%20254.95%20C%20168.99%20253.67%20186.81%20253.49%20204.06%20257.20%20C%20231.32%20262.97%20256.80%20276.81%20276.54%20296.49%20C%20293.71%20313.66%20306.14%20335.33%20313.41%20358.45%20C%20317.29%20371.60%20319.91%20385.24%20319.78%20398.99%20C%20321.35%20441.96%20301.66%20484.35%20269.99%20512.99%20C%20242.00%20538.39%20203.57%20551.09%20166.00%20549.73%20C%20133.58%20548.88%20101.34%20537.42%2076.23%20516.74%20C%2050.26%20494.62%2031.18%20463.95%2024.80%20430.27%20C%2021.58%20416.77%2021.93%20402.83%2022.47%20389.07%20C%2025.30%20359.23%2037.09%20330.28%2055.98%20306.99%20C%2079.44%20278.07%20114.56%20259.24%20151.49%20254.95%20M%20154.41%20286.41%20C%20133.59%20288.80%20113.47%20297.07%2096.91%20309.90%20C%2081.77%20321.39%2070.09%20337.09%2062.38%20354.40%20C%2053.40%20373.52%2050.49%20395.10%2052.40%20416.04%20C%2055.41%20439.33%2065.12%20461.74%2080.46%20479.57%20C%2096.06%20498.43%20118.19%20511.54%20141.99%20516.98%20C%20179.65%20526.00%20222.00%20516.17%20250.33%20489.33%20C%20272.99%20467.84%20287.59%20437.39%20288.11%20405.99%20C%20289.17%20369.33%20272.14%20332.49%20243.21%20309.87%20C%20231.81%20301.36%20219.11%20294.50%20205.43%20290.50%20C%20188.99%20285.41%20171.44%20284.58%20154.41%20286.41%20Z'%20/%3e%3c/g%3e%3cg%20id='%234da0e9ff'%3e%3cpath%20fill='%234da0e9'%20opacity='1.00'%20d='%20M%20165.46%2076.51%20C%20166.77%2074.06%20168.29%2071.72%20170.00%2069.54%20C%20172.96%2073.26%20175.00%2077.57%20177.40%2081.64%20C%20199.60%20118.31%20220.66%20155.66%20242.44%20192.58%20C%20246.07%20199.18%20250.02%20205.59%20254.00%20211.98%20C%20255.67%20214.84%20258.49%20217.46%20258.11%20221.06%20C%20256.47%20221.24%20254.77%20221.45%20253.21%20220.76%20C%20245.35%20217.94%20237.78%20214.21%20229.58%20212.41%20C%20219.05%20209.99%20208.80%20206.29%20198.04%20204.96%20C%20174.79%20200.91%20150.73%20202.18%20127.87%20207.89%20C%20121.55%20209.66%20115.18%20211.22%20108.82%20212.83%20C%20100.92%20214.75%2093.56%20218.30%2085.93%20221.02%20C%2084.20%20221.79%2081.46%20221.46%2081.76%20218.99%20C%2083.58%20214.95%2086.55%20211.59%2088.70%20207.74%20C%20104.18%20181.47%20119.48%20155.09%20134.68%20128.66%20C%20140.40%20119.03%20146.23%20109.46%20151.68%2099.66%20C%20156.35%2091.99%20161.14%2084.39%20165.46%2076.51%20Z'%20/%3e%3cpath%20fill='%234da0e9'%20opacity='1.00'%20d='%20M%20154.41%20286.41%20C%20171.44%20284.58%20188.99%20285.41%20205.43%20290.50%20C%20219.11%20294.50%20231.81%20301.36%20243.21%20309.87%20C%20272.14%20332.49%20289.17%20369.33%20288.11%20405.99%20C%20287.59%20437.39%20272.99%20467.84%20250.33%20489.33%20C%20222.00%20516.17%20179.65%20526.00%20141.99%20516.98%20C%20118.19%20511.54%2096.06%20498.43%2080.46%20479.57%20C%2065.12%20461.74%2055.41%20439.33%2052.40%20416.04%20C%2050.49%20395.10%2053.40%20373.52%2062.38%20354.40%20C%2070.09%20337.09%2081.77%20321.39%2096.91%20309.90%20C%20113.47%20297.07%20133.59%20288.80%20154.41%20286.41%20Z'%20/%3e%3c/g%3e%3c/svg%3e", CM = { style: { filter: "drop-shadow(0px 2px 4px #888)" } }, SM = ["src"], kM = nt({ __name: "LocationMarker", props: { isWatchingCurrentLocation: { type: Boolean }, deviceBearing: {} }, setup(r) {
  const n = cr("geolocation");
  return (l, h) => K(n) && K(n).isServiceRunning() && r.isWatchingCurrentLocation ? (ut(), fr(K(RI), { key: 0, coordinates: K(n).getLastKnownLocation().toLngLatLike() }, { marker: je(() => [xt("div", CM, [xt("img", { src: K(wM), style: zn({ height: "4em", width: "4em", transform: `rotate(${r.deviceBearing}deg)`, "transform-origin": "2em 2.83em" }) }, null, 12, SM)])]), _: 1 }, 8, ["coordinates"])) : _r("", true);
} }), TM = { style: { "font-family": "monospace", "padding-left": "8px" } }, PM = nt({ __name: "RecordingButton", props: { isRecording: { type: Boolean }, recordTimespan: {}, isRouteDrawerOpen: { type: Boolean } }, emits: ["toggleRecording"], setup(r, { emit: n }) {
  Gs((S) => {
    var _a2, _b2;
    return { v2835388b: (_a2 = K(yh).Button.common) == null ? void 0 : _a2.primaryColorSuppl, v6cac94de: (_b2 = K(yh).Button.common) == null ? void 0 : _b2.errorColorSuppl };
  });
  const { t: l } = Gn(), f = new jc().isMobile, y = false, p = n;
  function s(S) {
    const P = S / 1e3, M = P / 60, A = M / 60, O = P % 60, j = M % 60, L = A;
    let q = "";
    return Math.floor(L) > 0 && (q += `${String(Math.floor(L))}h `), Math.floor(j) > 0 && (q += `${String(Math.floor(j))}m `), q += `${String(O.toFixed(1)).padStart(4, "0")}s`, q;
  }
  return (S, P) => K(f) || y ? (ut(), Ot("div", { key: 0, class: ha(["mobile-record-button-container", { "drawer-open": r.isRouteDrawerOpen }]) }, [ze(K(S1), { theme: K(yh) }, { default: je(() => [ze(K(Or), { type: r.isRecording ? "error" : "primary", size: "large", class: ha(["mobile-record-button", r.isRecording ? "recording" : "not-recording"]), onClick: P[0] || (P[0] = (M) => p("toggleRecording")) }, { icon: je(() => [ze(K(xi), { size: 20 }, { default: je(() => [(ut(), fr($c(r.isRecording ? K(Hk) : K(Uk)), { size: r.isRecording ? 16 : 20 }, null, 8, ["size"]))]), _: 1 })]), default: je(() => [vr(" " + Jt(r.isRecording ? K(l)("trackerView.uiRecordingStatus.on") : K(l)("trackerView.uiRecordingStatus.off")) + " ", 1), xt("p", TM, Jt(r.recordTimespan ? `(${s(r.recordTimespan)})` : ""), 1)]), _: 1 }, 8, ["type", "class"])]), _: 1 }, 8, ["theme"])], 2)) : _r("", true);
} }), IM = Ui(PM, [["__scopeId", "data-v-bcc27af9"]]), EM = nt({ __name: "BuildingLayerToggle", props: { isShowingBuildingLayer: { type: Boolean } }, emits: ["toggle"], setup(r, { emit: n }) {
  const l = n, h = () => {
    l("toggle");
  };
  return (f, y) => (ut(), fr(K(vm), { position: "top-left" }, { default: je(() => [xt("button", { class: ha(["btn-control", { active: r.isShowingBuildingLayer }]), onClick: h }, [ze(K(xi), { size: 20 }, { default: je(() => [ze(K(kk))]), _: 1 })], 2)]), _: 1 }));
} }), MM = Ui(EM, [["__scopeId", "data-v-c189f5ba"]]), DM = nt({ __name: "CurrentLocationToggle", props: { locator: {}, isWatchingCurrentLocation: { type: Boolean } }, emits: ["toggle"], setup(r, { emit: n }) {
  const h = new jc().isMobile, f = false, y = n, p = () => {
    y("toggle");
  };
  return (s, S) => (ut(), fr(K(vm), { position: "top-left" }, { default: je(() => [K(h) && r.locator.isUsingGPS() || f ? (ut(), Ot("button", { key: 0, class: ha(["btn-control", { active: r.isWatchingCurrentLocation }]), onClick: p }, [ze(K(xi), { size: 20 }, { default: je(() => [ze(K(Ek))]), _: 1 })], 2)) : _r("", true)]), _: 1 }));
} }), RM = Ui(DM, [["__scopeId", "data-v-afaa8b50"]]);
class AM extends pM.TerraDrawBaseAdapter {
  constructor(n) {
    super(n), this._renderBeforeLayerId = void 0, this._prefixId = void 0, this._initialDragPan = void 0, this._initialDragRotate = void 0, this._nextRender = void 0, this._map = void 0, this._container = void 0, this.changedIds = { deletion: false, points: false, linestrings: false, polygons: false, styling: false }, this._map = n.map, this._container = this._map.getContainer(), this._initialDragRotate = this._map.dragRotate.isEnabled(), this._initialDragPan = this._map.dragPan.isEnabled(), this._renderBeforeLayerId = n.renderBelowLayerId, this._prefixId = n.prefixId || "td";
  }
  hashCode(n) {
    let l = 0;
    for (let h = 0; h < n.length; h++) l = (l << 5) - l + n.charCodeAt(h), l |= 0;
    return Math.abs(l);
  }
  resizeImage(n, l, h, f) {
    const y = new Image();
    y.crossOrigin = "anonymous", y.onload = () => {
      const p = document.createElement("canvas");
      p.width = l, p.height = h;
      const s = p.getContext("2d");
      if (!s) throw new Error("Could not get canvas context");
      s.drawImage(y, 0, 0, l, h);
      const S = p.toDataURL();
      f(S);
    }, y.src = n;
  }
  _addGeoJSONSource(n, l) {
    this._map.addSource(n, { type: "geojson", data: { type: "FeatureCollection", features: l }, tolerance: 0 });
  }
  _addFillLayer(n) {
    return this._map.addLayer({ id: n, source: n, type: "fill", layout: { "fill-sort-key": ["get", "zIndex"] }, paint: { "fill-color": ["get", "polygonFillColor"], "fill-opacity": ["get", "polygonFillOpacity"] } });
  }
  _addFillOutlineLayer(n) {
    return this._map.addLayer({ id: n + "-outline", source: n, type: "line", layout: { "line-sort-key": ["get", "zIndex"] }, paint: { "line-width": ["get", "polygonOutlineWidth"], "line-color": ["get", "polygonOutlineColor"] } });
  }
  _addLineLayer(n) {
    return this._map.addLayer({ id: n, source: n, type: "line", layout: { "line-sort-key": ["get", "zIndex"] }, paint: { "line-width": ["get", "lineStringWidth"], "line-color": ["get", "lineStringColor"] } });
  }
  _addPointLayer(n) {
    return this._map.addLayer({ id: n, source: n, type: "circle", layout: { "circle-sort-key": ["get", "zIndex"] }, paint: { "circle-stroke-color": ["get", "pointOutlineColor"], "circle-stroke-width": ["get", "pointOutlineWidth"], "circle-radius": ["get", "pointWidth"], "circle-color": ["get", "pointColor"] } });
  }
  _addMarkerLayer(n) {
    return this._map.addLayer({ id: n + "-marker", source: n, type: "symbol", filter: ["has", "markerId"], layout: { "icon-image": ["image", ["get", "markerId"]], "icon-anchor": "bottom", "icon-allow-overlap": true } });
  }
  _addLayer(n, l) {
    l === "Point" && (this._addPointLayer(n), this._addMarkerLayer(n)), l === "LineString" && this._addLineLayer(n), l === "Polygon" && (this._addFillLayer(n), this._addFillOutlineLayer(n));
  }
  _addGeoJSONLayer(n, l) {
    const h = `${this._prefixId}-${n.toLowerCase()}`;
    return this._addGeoJSONSource(h, l), this._addLayer(h, n), h;
  }
  _setGeoJSONLayerData(n, l) {
    const h = `${this._prefixId}-${n.toLowerCase()}`;
    return this._map.getSource(h).setData({ type: "FeatureCollection", features: l }), h;
  }
  updateChangedIds(n) {
    [...n.updated, ...n.created].forEach((l) => {
      l.geometry.type === "Point" ? this.changedIds.points = true : l.geometry.type === "LineString" ? this.changedIds.linestrings = true : l.geometry.type === "Polygon" && (this.changedIds.polygons = true);
    }), n.deletedIds.length > 0 && (this.changedIds.deletion = true), n.created.length === 0 && n.updated.length === 0 && n.deletedIds.length === 0 && (this.changedIds.styling = true);
  }
  getLngLatFromEvent(n) {
    const { left: l, top: h } = this._container.getBoundingClientRect();
    return this.unproject(n.clientX - l, n.clientY - h);
  }
  getMapEventElement() {
    return this._map.getCanvas();
  }
  setDraggability(n) {
    n ? (this._initialDragRotate && this._map.dragRotate.enable(), this._initialDragPan && this._map.dragPan.enable()) : (this._initialDragRotate && this._map.dragRotate.disable(), this._initialDragPan && this._map.dragPan.disable());
  }
  project(n, l) {
    const { x: h, y: f } = this._map.project({ lng: n, lat: l });
    return { x: h, y: f };
  }
  unproject(n, l) {
    const { lng: h, lat: f } = this._map.unproject({ x: n, y: l });
    return { lng: h, lat: f };
  }
  setCursor(n) {
    const l = this._map.getCanvas();
    n === "unset" ? l.style.removeProperty("cursor") : l.style.cursor = n;
  }
  setDoubleClickToZoom(n) {
    n ? this._map.doubleClickZoom.enable() : this._map.doubleClickZoom.disable();
  }
  render(n, l) {
    this.updateChangedIds(n), this._nextRender && cancelAnimationFrame(this._nextRender), this._nextRender = requestAnimationFrame(() => {
      if (!this._currentModeCallbacks) return;
      const h = [...n.created, ...n.updated, ...n.unchanged], f = [], y = [], p = [];
      for (let M = 0; M < h.length; M++) {
        const A = h[M], { properties: O } = A, j = l[O.mode](A);
        if (O.zIndex = j.zIndex, O.zIndex = j.zIndex, A.geometry.type === "Point") {
          if (O.pointColor = j.pointColor, O.pointOutlineColor = j.pointOutlineColor, O.pointOutlineWidth = j.pointOutlineWidth, O.pointWidth = j.pointWidth, j.markerUrl && j.markerWidth && j.markerHeight) {
            const L = `marker-${this.hashCode(j.markerUrl)}`;
            this._map.hasImage(L) || this.resizeImage(j.markerUrl, j.markerWidth, j.markerHeight, (q) => {
              this._map.loadImage(q).then((N) => {
                this._map.hasImage(L) || this._map.addImage(L, N.data);
              });
            }), O.markerId = L, O.pointWidth = 0;
          }
          f.push(A);
        } else A.geometry.type === "LineString" ? (O.lineStringColor = j.lineStringColor, O.lineStringWidth = j.lineStringWidth, y.push(A)) : A.geometry.type === "Polygon" && (O.polygonFillColor = j.polygonFillColor, O.polygonFillOpacity = j.polygonFillOpacity, O.polygonOutlineColor = j.polygonOutlineColor, O.polygonOutlineWidth = j.polygonOutlineWidth, p.push(A));
      }
      const s = this.changedIds.deletion || this.changedIds.styling, S = s || this.changedIds.linestrings, P = s || this.changedIds.polygons;
      (s || this.changedIds.points) && this._setGeoJSONLayerData("Point", f), S && this._setGeoJSONLayerData("LineString", y), P && this._setGeoJSONLayerData("Polygon", p), this.changedIds = { points: false, linestrings: false, polygons: false, deletion: false, styling: false };
    });
  }
  clear() {
    this._currentModeCallbacks && (this._currentModeCallbacks.onClear(), this._nextRender && (cancelAnimationFrame(this._nextRender), this._nextRender = void 0), this._setGeoJSONLayerData("Point", []), this._setGeoJSONLayerData("LineString", []), this._setGeoJSONLayerData("Polygon", []));
  }
  getCoordinatePrecision() {
    return super.getCoordinatePrecision();
  }
  unregister() {
    super.unregister(), this.changedIds = { points: false, linestrings: false, polygons: false, deletion: false, styling: false }, this._map.removeLayer(`${this._prefixId}-point`), this._map.removeLayer(`${this._prefixId}-point-marker`), this._map.removeSource(`${this._prefixId}-point`), this._map.removeLayer(`${this._prefixId}-linestring`), this._map.removeSource(`${this._prefixId}-linestring`), this._map.removeLayer(`${this._prefixId}-polygon`), this._map.removeLayer(`${this._prefixId}-polygon-outline`), this._map.removeSource(`${this._prefixId}-polygon`);
  }
  register(n) {
    var l;
    super.register(n);
    const h = this._addGeoJSONLayer("Polygon", []), f = this._addGeoJSONLayer("LineString", []), y = this._addGeoJSONLayer("Point", []);
    var p;
    this._renderBeforeLayerId && (this._map.moveLayer(y, this._renderBeforeLayerId), this._map.moveLayer(f, y), this._map.moveLayer(h + "-outline", f), this._map.moveLayer(h, f)), (l = this._currentModeCallbacks) != null && l.onReady && ((p = this._currentModeCallbacks) == null || p.onReady());
  }
}
const zM = { class: "map-layout-container" }, FM = { class: "map-layout" }, LM = { key: 0, style: { width: "100%", height: "100%" } }, BM = { style: { "z-index": "99", position: "absolute", right: "4px", top: "9em" } }, OM = { key: 1, style: { width: "100%", height: "100%", display: "grid", "place-content": "center" } }, $M = nt({ __name: "TrackerView", setup(r) {
  Gs((bt) => {
    var _a2;
    return { v711d3d66: (_a2 = K(yh).Button.common) == null ? void 0 : _a2.successColorSuppl, v022e29ef: K(h).boxShadow3, v7a403d45: K(h).borderRadius, v2c6efc50: K(h).borderColor };
  });
  const l = new jc().isMobile, h = Vs(), f = Ux(), y = pm(), p = cr("geolocation"), { t: s } = Gn(), P = "https://api.maptiler.com/maps/basic-v2/style.json?key=dCeXFrS9lgSF8hm5C6nm", M = Fa(null), A = Fa(null), O = Ee("select"), j = Vx();
  j.setLocator(p);
  const L = cr("noSleep"), q = Ae(() => {
    var _a2;
    return j.currentRouteId ? ((_a2 = j.routes.find((Dt) => Dt.id === j.currentRouteId)) == null ? void 0 : _a2.points) || [] : [];
  }), N = Ee(false), J = Ae(() => q.value.length > 1 || q.value.length === 0 ? { type: "FeatureCollection", features: [{ type: "Feature", properties: { description: j.currentRouteId }, geometry: { type: "LineString", coordinates: q.value.map((bt) => [bt.longitude, bt.latitude]) } }] } : { type: "FeatureCollection", features: [] }), te = [{ mode: new Xx(), name: s("trackerView.terraDrawTools.point"), icon: rv }, { mode: new Hx(), name: s("trackerView.terraDrawTools.line"), icon: j1 }, { mode: new e2({ allowManualDeselection: true, flags: { point: { feature: { draggable: true } }, polygon: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, linestring: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, freehand: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, circle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, rectangle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } } } }), name: s("trackerView.terraDrawTools.select"), icon: N1 }], ne = Ee(false), ae = Ee(true), oe = /* @__PURE__ */ (() => {
    let bt = true;
    return async function() {
      try {
        j.isRecording || (bt = j.currentRouteId === null), await j.toggleRecording(s), !j.isRecording && bt && (be.value = true, setTimeout(() => {
          be.value = false;
        }, 3e3)), j.isRecording ? L.enable() : L.disable();
      } catch (Dt) {
        console.error(Dt), L.disable();
      }
    };
  })(), ee = Ee(async () => {
  });
  function ke() {
    le.value = false, y.warning("Not implemented yet");
  }
  const ve = Ee(0), le = Ee(false);
  Kt(le, (bt) => {
    var _a2;
    const Dt = (_a2 = M.value) == null ? void 0 : _a2.map;
    Dt && Dt.easeTo({ padding: l ? { bottom: bt ? ve.value : 0 } : { left: bt ? ve.value : 0 }, duration: 500 });
  });
  const ue = () => le.value = !le.value, be = Ee(false), Ve = Ee(false), Ge = Ee(0), et = Ee(false);
  Ei(async () => {
    if (await j.init(), await f.init(), Date.now() - f.lastUpdateTime > 6e3 && f.lastUpdateTime !== 0) {
      const bt = p.getLastKnownLocation();
      bt.latitude !== 0 || bt.longitude !== 0 ? f.setCenter(bt) : console.warn("[TrackerView] No valid last known location available, skipping map center update");
    }
    js.addHandler((bt) => {
      Ge.value = bt;
    }), js.start(), Ve.value = true;
  });
  const dt = false;
  let Ct = 0;
  const kt = (bt) => {
    var _a2;
    if (Ct = bt, f.isTrackingOrientation) {
      const Dt = (_a2 = M.value) == null ? void 0 : _a2.map;
      if ((Dt == null ? void 0 : Dt.isEasing()) || (Dt == null ? void 0 : Dt.isMoving()) || (Dt == null ? void 0 : Dt.isRotating()) || (Dt == null ? void 0 : Dt.isZooming()) || et.value) return;
      f.setBearing(bt);
    }
  }, ct = /* @__PURE__ */ (() => {
    let bt = null;
    return () => {
      var _a2;
      if (f.setTrackingOrientation(!f.isTrackingOrientation), f.isTrackingOrientation) bt = js.addHandler(kt);
      else if (bt !== null) {
        bt = null, f.setBearing(0);
        const Dt = (_a2 = M.value) == null ? void 0 : _a2.map;
        Dt && Dt.setBearing(0);
      }
    };
  })(), it = (bt) => {
    A.value = new mM({ adapter: new AM({ map: bt.map }), modes: te.map((Dt) => Dt.mode) }), A.value.start();
  }, pt = () => {
    et.value = true;
  }, $t = () => {
    et.value = false, f.isTrackingOrientation && kt(Ct);
  }, vt = () => {
    le.value = false;
  }, Pt = (bt) => {
    A.value && (bt === "select" ? (A.value.setMode("select"), O.value = "select") : (O.value = bt, A.value.start(), A.value.setMode(bt)));
  }, Nt = () => {
    var _a2;
    if (ae.value = !ae.value, ae.value) {
      const bt = (_a2 = M.value) == null ? void 0 : _a2.map;
      if (bt) {
        const Dt = p.getLastKnownLocation();
        Dt.latitude !== 0 || Dt.longitude !== 0 ? bt.flyTo({ center: Dt.toLngLatLike(), zoom: 18 }) : console.warn("[TrackerView] No valid current location available for navigation");
      }
    }
  }, ir = () => {
    var _a2, _b2, _c2;
    ne.value = !ne.value;
    const bt = (_a2 = M.value) == null ? void 0 : _a2.map;
    bt && (ne.value ? (_b2 = M.value) == null ? void 0 : _b2.setupBuildingLayer(bt) : (_c2 = M.value) == null ? void 0 : _c2.removeBuildingLayer(bt));
  };
  return (bt, Dt) => (ut(), Ot("div", zM, [xt("div", FM, [ze(Wo, { name: "map-load" }, { default: je(() => [Ve.value ? (ut(), Ot("div", LM, [ze(gM, { ref_key: "mapContainerRef", ref: M, "style-url": P, "geojson-source": J.value, "drawer-modes": te, "on-map-init": it, "on-map-touch-start": pt, "on-map-touch-end": $t, "on-map-click": vt }, { default: je(() => [ze(yM), ze(RM, { locator: K(p), "is-watching-current-location": ae.value, onToggle: Nt }, null, 8, ["locator", "is-watching-current-location"]), ze(MM, { "is-showing-building-layer": ne.value, onToggle: ir }, null, 8, ["is-showing-building-layer"]), ze(xM, { "active-draw-method": O.value, "onUpdate:activeDrawMethod": Dt[0] || (Dt[0] = (Zt) => O.value = Zt), onSetDrawMode: Pt }, null, 8, ["active-draw-method"]), ze(K(vm), { position: "bottom-left" }, { default: je(() => [ze(K(K0), { trigger: "manual", show: be.value }, { trigger: je(() => [xt("button", { class: ha(["btn-control", { active: le.value }]), onClick: ue }, [ze(K(xi), { size: 24 }, { default: je(() => [ze(K(iv))]), _: 1 })], 2)]), default: je(() => [xt("span", null, Jt(K(s)("trackerView.uiRouteCheckoutTip")), 1)]), _: 1 }, 8, ["show"])]), _: 1 }), ze(kM, { "is-watching-current-location": ae.value, "device-bearing": Ge.value }, null, 8, ["is-watching-current-location", "device-bearing"])]), _: 1 }, 8, ["geojson-source"]), xt("div", BM, [K(l) || dt ? (ut(), fr(VI, { key: 0, bearing: K(f).bearing, "onUpdate:bearing": Dt[1] || (Dt[1] = (Zt) => K(f).bearing = Zt), tracking: K(f).isTrackingOrientation, onToggleTracking: K(ct) }, null, 8, ["bearing", "tracking", "onToggleTracking"])) : _r("", true)])])) : (ut(), Ot("div", OM, [ze(K(L4), { size: "large" }, { description: je(() => [ze(K(is), null, { default: je(() => [vr(Jt(K(s)("trackerView.mapLoading")), 1)]), _: 1 })]), _: 1 })]))]), _: 1 })]), ze(nE, { show: N.value, "onUpdate:show": Dt[2] || (Dt[2] = (Zt) => N.value = Zt), types: ["application/json", "text/plain"], onConfirm: ee.value }, null, 8, ["show", "onConfirm"]), ze(TE, { show: le.value, "onUpdate:show": Dt[3] || (Dt[3] = (Zt) => le.value = Zt), "onUpdate:width": Dt[4] || (Dt[4] = (Zt) => ve.value = Zt) }, { "bottom-floating": je(() => [ze(K(S1), { theme: K(yh) }, { default: je(() => [q.value.length > 1 ? (ut(), fr(K(Or), { key: 0, size: "large", type: "success", class: "drawer-floating-button", onClick: ke }, { default: je(() => [...Dt[5] || (Dt[5] = [vr(" Follow ", -1)])]), _: 1 })) : _r("", true)]), _: 1 }, 8, ["theme"])]), _: 1 }, 8, ["show"]), ze(IM, { "is-recording": K(j).isRecording, "record-timespan": K(j).currentRouteRecordTimespan, "is-route-drawer-open": le.value, onToggleRecording: K(oe) }, null, 8, ["is-recording", "record-timespan", "is-route-drawer-open", "onToggleRecording"])]));
} }), r2 = Ui($M, [["__scopeId", "data-v-9b2adda5"]]), NM = Object.freeze(Object.defineProperty({ __proto__: null, default: r2 }, Symbol.toStringTag, { value: "Module" })), jM = { class: "container" }, VM = { style: { height: "100%", width: "100%", display: "flex", "justify-items": "center" } }, UM = { style: { display: "flex", "flex-direction": "row", "flex-grow": "1" } }, GM = { style: { "font-weight": "500" } }, qM = { style: { display: "flex", "flex-wrap": "wrap", gap: "4px", "margin-left": "24px" } }, WM = nt({ __name: "SketchSelector", props: { list: { type: Array, default: () => [] } }, emits: ["select", "remove"], setup(r, { emit: n }) {
  const { t: l } = Gn(), h = r, f = n;
  function y(s) {
    f("select", s);
  }
  function p(s) {
    confirm(l("sketchEdit.deleteSketchConfirmation")) && f("remove", s);
  }
  return (s, S) => (ut(), Ot("div", jM, [ze(K(Nh), { class: "select-listview", hoverable: "" }, { default: je(() => [(ut(true), Ot(jr, null, un(h.list, (P) => (ut(), fr(K(jh), { key: P.id, title: P.name, onClick: (M) => y(P.id) }, { prefix: je(() => [xt("div", VM, [ze(K(xi), { size: "20" }, { default: je(() => [ze(K(V1))]), _: 1 })])]), suffix: je(() => [ze(K(Or), { quaternary: "", circle: "", onClick: wh((M) => p(P.id), ["stop"]) }, { icon: je(() => [ze(K(xi), null, { default: je(() => [ze(K(dm))]), _: 1 })]), _: 1 }, 8, ["onClick"])]), default: je(() => [xt("div", UM, [xt("div", GM, Jt(P.name), 1), xt("div", qM, [(ut(true), Ot(jr, null, un(P.tags, (M) => (ut(), fr(K(zo), { key: M, size: "small", type: "info" }, { default: je(() => [vr(Jt(M.toLocaleUpperCase()), 1)]), _: 2 }, 1024))), 128))])])]), _: 2 }, 1032, ["title", "onClick"]))), 128))]), _: 1 })]));
} }), ZM = Ui(WM, [["__scopeId", "data-v-dc2c6049"]]), HM = nt({ __name: "SelectorDrawer", props: { active: { type: Boolean, default: () => false }, placement: { type: String, default: () => "right" }, list: { type: Array, default: () => [] } }, emits: ["new", "update:active", "remove", "select", "import"], setup(r, { emit: n }) {
  const { t: l } = Gn(), h = r, f = [{ title: l("sketchEdit.import"), icon: U1, callback: () => {
    s("import");
  }, secondary: true, iconSize: 17, type: "default" }, { title: l("sketchEdit.new"), icon: Th, callback: () => s("new"), secondary: true, iconSize: 20, type: "default" }, { title: l("sketchEdit.close"), icon: jk, callback: () => {
    y.value = false;
  }, secondary: true, iconSize: 20, type: "error" }], y = Ee(false), p = Ee(h.placement);
  Kt(h, () => {
    y.value = h.active, p.value = h.placement;
  }, { deep: true }), Kt(y, () => {
    s("update:active", y.value);
  });
  const s = n;
  return (S, P) => (ut(), fr(K(dx), { show: y.value, "onUpdate:show": P[2] || (P[2] = (M) => y.value = M), width: 502, placement: p.value, "auto-focus": false }, { default: je(() => [ze(K(hx), { title: K(l)("sketchEdit.cartoSketchLibrary") }, { footer: je(() => [ze(K(KP), null, { default: je(() => [(ut(), Ot(jr, null, un(f, (M) => ze(K(Or), { key: M.title, secondary: M.secondary, type: M.type, title: M.title, onClick: M.callback }, { icon: je(() => [ze(K(xi), { size: M.iconSize }, { default: je(() => [(ut(), fr($c(M.icon)))]), _: 2 }, 1032, ["size"])]), _: 2 }, 1032, ["secondary", "type", "title", "onClick"])), 64))]), _: 1 })]), default: je(() => [ze(ZM, { list: r.list, onRemove: P[0] || (P[0] = (M) => s("remove", M)), onSelect: P[1] || (P[1] = (M) => s("select", M)) }, null, 8, ["list"])]), _: 1 }, 8, ["title"])]), _: 1 }, 8, ["show", "placement"]));
} }), XM = ["title", "onClick"], Rp = 20, YM = nt({ __name: "SketchToolbar", props: { sketchName: {}, draftCount: {}, routeCount: {} }, emits: ["save", "open", "create", "edit-meta"], setup(r, { emit: n }) {
  const { t: l } = Gn(), h = n, f = [{ title: l("sketchEdit.save"), icon: Dk, iconSize: Rp, callback: () => h("save") }, { title: l("sketchEdit.open"), icon: Lk, iconSize: Rp, callback: () => h("open") }, { title: l("sketchEdit.newComponent"), icon: Th, iconSize: Rp, callback: () => h("create") }, { title: l("sketchEdit.editMetadata"), icon: cS, iconSize: Rp, callback: () => h("edit-meta") }];
  return (y, p) => (ut(), fr(K(G_), { justify: "space-between", align: "center" }, { default: je(() => [ze(K(is), { strong: "" }, { default: je(() => [vr(Jt(r.sketchName || K(l)("sketchEdit.noSketchSelectedToolbar")), 1)]), _: 1 }), ze(K(G_), { align: "center" }, { default: je(() => [r.sketchName !== void 0 ? (ut(), fr(K(zo), { key: 0, type: "info", size: "small" }, { default: je(() => [vr(Jt(r.draftCount || 0) + " " + Jt(K(l)("sketchEdit.drafts")) + ", " + Jt(r.routeCount || 0) + " " + Jt(K(l)("sketchEdit.routes")), 1)]), _: 1 })) : _r("", true), (ut(), Ot(jr, null, un(f, (s, S) => xt("div", { key: S, title: s.title, class: "tool-tip-item", onClick: s.callback }, [ze(K(xi), { size: s.iconSize }, { default: je(() => [(ut(), fr($c(s.icon)))]), _: 2 }, 1032, ["size"])], 8, XM)), 64))]), _: 1 })]), _: 1 }));
} }), KM = Ui(YM, [["__scopeId", "data-v-5b012717"]]), JM = { key: 0, class: "empty-state" }, QM = nt({ __name: "ComponentList", props: { components: {}, selectedId: {} }, emits: ["select", "delete", "create"], setup(r, { emit: n }) {
  const { t: l } = Gn(), h = n;
  return (f, y) => (ut(), Ot(jr, null, [ze(K(Nh), { hoverable: "" }, { default: je(() => [(ut(true), Ot(jr, null, un(r.components, (p) => (ut(), fr(K(jh), { key: p.value, class: ha({ "selected-component": r.selectedId === p.value }), onClick: () => h("select", p.value, p.type) }, { prefix: je(() => [ze(K(xi), { color: p.type === "draft" ? "#007bff" : "#28a745" }, { default: je(() => [(ut(), fr($c(p.type === "draft" ? K(V1) : K(iv))))]), _: 2 }, 1032, ["color"])]), suffix: je(() => [ze(K(S4), { onPositiveClick: (s) => h("delete", p.value, p.type) }, { trigger: je(() => [ze(K(Or), { quaternary: "", circle: "", size: "small" }, { default: je(() => [ze(K(xi), null, { default: je(() => [ze(K(dm))]), _: 1 })]), _: 1 })]), default: je(() => [vr(" " + Jt(K(l)("sketchEdit.deleteComponent")), 1)]), _: 1 }, 8, ["onPositiveClick"])]), default: je(() => [vr(" " + Jt(p.label) + " ", 1)]), _: 2 }, 1032, ["class", "onClick"]))), 128))]), _: 1 }), r.components.length === 0 ? (ut(), Ot("div", JM, [ze(K(Ph), { description: K(l)("sketchEdit.noComponentsYet") }, { extra: je(() => [ze(K(Or), { size: "small", onClick: y[0] || (y[0] = (p) => h("create")) }, { default: je(() => [vr(Jt(K(l)("sketchEdit.createComponent")), 1)]), _: 1 })]), _: 1 }, 8, ["description"])])) : _r("", true)], 64));
} }), eD = Ui(QM, [["__scopeId", "data-v-3addb8a0"]]), tD = { key: 0, class: "properties-panel" }, rD = { key: 1, style: { height: "100%", width: "100%", display: "flex", "justify-content": "center", "align-items": "center" } }, iD = nt({ __name: "PropertiesPanel", props: { component: {}, type: {} }, emits: ["updateProperties", "updateMeta"], setup(r, { emit: n }) {
  const { t: l } = Gn(), h = n;
  return (f, y) => r.component ? (ut(), Ot("div", tD, [ze(K(W4), { type: "line", animated: "", "default-value": "properties" }, { default: je(() => [ze(K(sb), { name: "properties", tab: K(l)("sketchEdit.properties") }, { default: je(() => [ze(K(Eh), null, { default: je(() => [ze(K(An), { label: K(l)("sketchEdit.visible") }, { default: je(() => [ze(K(kx), { value: r.component.properties.visible !== false, "onUpdate:value": y[0] || (y[0] = (p) => h("updateProperties", { visible: p })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), r.type === "draft" ? (ut(), Ot(jr, { key: 0 }, [ze(K(An), { label: K(l)("sketchEdit.fillColor") }, { default: je(() => [ze(K(Kg), { value: r.component.properties.fillColor || "#007bff", "show-alpha": false, "onUpdate:value": y[1] || (y[1] = (p) => h("updateProperties", { fillColor: p })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), ze(K(An), { label: K(l)("sketchEdit.strokeColor") }, { default: je(() => [ze(K(Kg), { value: r.component.properties.strokeColor || "#0056b3", "show-alpha": false, "onUpdate:value": y[2] || (y[2] = (p) => h("updateProperties", { strokeColor: p })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), ze(K(An), { label: K(l)("sketchEdit.strokeThickness") }, { default: je(() => [ze(K(ib), { value: r.component.properties.strokeThickness || 2, min: 1, max: 10, "onUpdate:value": y[3] || (y[3] = (p) => h("updateProperties", { strokeThickness: p ?? void 0 })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"])], 64)) : _r("", true), r.type === "route" ? (ut(), Ot(jr, { key: 1 }, [ze(K(An), { label: K(l)("sketchEdit.strokeColor") }, { default: je(() => [ze(K(Kg), { value: r.component.properties.strokeColor || "#28a745", "show-alpha": false, "onUpdate:value": y[4] || (y[4] = (p) => h("updateProperties", { strokeColor: p })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), ze(K(An), { label: K(l)("sketchEdit.strokeThickness") }, { default: je(() => [ze(K(ib), { value: r.component.properties.strokeThickness || 3, min: 1, max: 10, "onUpdate:value": y[5] || (y[5] = (p) => h("updateProperties", { strokeThickness: p ?? void 0 })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"])], 64)) : _r("", true)]), _: 1 })]), _: 1 }, 8, ["tab"]), ze(K(sb), { name: "metadata", tab: K(l)("sketchEdit.metadata") }, { default: je(() => [ze(K(Eh), null, { default: je(() => [ze(K(An), { label: K(l)("sketchEdit.name") }, { default: je(() => [ze(K(Do), { value: r.component.meta.name, "onUpdate:value": y[6] || (y[6] = (p) => {
    var _a2, _b2;
    return h("updateMeta", { name: p, description: ((_a2 = r.component) == null ? void 0 : _a2.meta.description) ?? "", tags: ((_b2 = r.component) == null ? void 0 : _b2.meta.tags) ?? [] });
  }) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), ze(K(An), { label: K(l)("sketchEdit.description") }, { default: je(() => [ze(K(Do), { value: r.component.meta.description, type: "textarea", rows: 3, "onUpdate:value": y[7] || (y[7] = (p) => {
    var _a2, _b2;
    return h("updateMeta", { name: ((_a2 = r.component) == null ? void 0 : _a2.meta.name) ?? "", description: p, tags: ((_b2 = r.component) == null ? void 0 : _b2.meta.tags) ?? [] });
  }) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), ze(K(An), { label: K(l)("sketchEdit.tags") }, { default: je(() => [ze(K(h6), { value: r.component.meta.tags || [], placeholder: K(l)("sketchEdit.addTagPlaceholder"), "onUpdate:value": y[8] || (y[8] = (p) => {
    var _a2, _b2;
    return h("updateMeta", { name: ((_a2 = r.component) == null ? void 0 : _a2.meta.name) ?? "", description: ((_b2 = r.component) == null ? void 0 : _b2.meta.description) ?? "", tags: p });
  }) }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), ze(K(An), { label: "UUID" }, { default: je(() => [ze(K(Do), { value: r.component.id, style: { "font-family": "monospace" }, readonly: "" }, null, 8, ["value"])]), _: 1 })]), _: 1 })]), _: 1 }, 8, ["tab"])]), _: 1 })])) : (ut(), Ot("div", rD, [ze(K(Ph), { description: K(l)("sketchEdit.selectComponentToEdit") }, null, 8, ["description"])]));
} }), nD = Ui(iD, [["__scopeId", "data-v-f700b4bc"]]), oD = "dCeXFrS9lgSF8hm5C6nm", aD = `https://api.maptiler.com/maps/basic-v2/style.json?key=${oD}`;
function sD() {
  const r = Ee(7), n = Fa(null), l = Ee([0, 0]);
  function h(p) {
    n.value = p.map;
  }
  function f(p) {
    l.value = p, n.value && n.value.setCenter(p);
  }
  function y(p) {
    r.value = p, n.value && n.value.setZoom(p);
  }
  return { zoom: r, map: n, center: l, styleUrl: aD, initMap: h, setCenter: f, setZoom: y };
}
function lD(r, n) {
  const l = [];
  return r.forEach((h) => {
    l.push({ label: h.meta.name, value: h.id, type: "draft" });
  }), n.forEach((h) => {
    l.push({ label: h.meta.name, value: h.id, type: "route" });
  }), l;
}
function uD() {
  return { type: "Polygon", coordinates: [[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]] };
}
function cD() {
  return { fillColor: "#007bff", strokeColor: "#0056b3", strokeThickness: 2 };
}
function dD() {
  return { strokeColor: "#28a745", strokeThickness: 3 };
}
const hD = { style: { display: "flex", "flex-direction": "row", gap: "8px" } }, fD = { style: { display: "flex", gap: "8px", "margin-bottom": "8px" } }, pD = { class: "sketch-edit-container" }, mD = { class: "grid-layout" }, gD = { class: "meta-info-section" }, vD = { class: "metadata-item" }, yD = { class: "metadata-item" }, _D = nt({ __name: "SketchEdit", props: { liteMode: { type: Boolean }, forceHighDpi: { type: Boolean }, mapType: {}, sketchId: {} }, setup(r) {
  const n = r, { t: l } = Gn(), h = pm(), f = hv(), { zoom: y, styleUrl: p, initMap: s } = sD(), S = Ee(false), P = Ee(null), M = Ee(null), A = Ee(false), O = Ee(""), j = Ee("draft"), L = Ee(false), q = Ee({ name: "", description: "", tags: [], created_by: "", modified_by: "" }), N = Ee(""), J = Ae(() => f.currentSketch), te = Ae(() => f.currentDrafts), ne = Ae(() => {
    var _a2;
    return ((_a2 = J.value) == null ? void 0 : _a2.routes.routes) || [];
  }), ae = Ae(() => !!J.value), oe = Ae(() => !P.value || !M.value ? null : M.value === "draft" ? f.getDraftById(P.value) : f.getRouteById(P.value)), ee = Ae(() => lD(te.value, ne.value));
  async function ke() {
    if (J.value) try {
      await f.updateSketch(J.value.id, { name: J.value.meta.name, description: J.value.meta.description, tags: J.value.meta.tags }), h.success(l("sketchEdit.saveSuccess"));
    } catch (ct) {
      h.error(l("sketchEdit.saveError")), console.error(ct);
    }
  }
  async function ve() {
    const ct = prompt(l("sketchEdit.enterSketchName"));
    ct && (await f.createSketch(ct), S.value = false);
  }
  async function le() {
    if (!(!O.value.trim() || !J.value)) try {
      if (j.value === "draft") {
        const ct = await f.addDraft(uD(), cD(), { name: O.value });
        P.value = ct.id, M.value = "draft";
      } else {
        const ct = await f.addRoute(O.value, dD());
        P.value = ct.id, M.value = "route";
      }
      A.value = false, O.value = "", h.success(l("sketchEdit.componentCreated"));
    } catch (ct) {
      h.error(l("sketchEdit.componentCreateError")), console.error(ct);
    }
  }
  async function ue(ct, it) {
    try {
      it === "draft" ? await f.deleteDraft(ct) : await f.deleteRoute(ct), P.value === ct && (P.value = null, M.value = null), h.success(l("sketchEdit.componentDeleted"));
    } catch (pt) {
      h.error(l("sketchEdit.componentDeleteError")), console.error(pt);
    }
  }
  async function be(ct) {
    if (!(!oe.value || !M.value)) try {
      M.value === "draft" ? await f.updateDraft(P.value, { properties: ct }) : await f.updateRoute(P.value, { properties: ct }), h.success(l("sketchEdit.propertiesUpdated"));
    } catch (it) {
      h.error(l("sketchEdit.propertiesUpdateError")), console.error(it);
    }
  }
  async function Ve(ct) {
    if (!(!oe.value || !M.value)) try {
      M.value === "draft" ? await f.updateDraft(P.value, { meta: ct }) : await f.updateRoute(P.value, { name: ct.name }), h.success(l("sketchEdit.propertiesUpdated"));
    } catch (it) {
      h.error(l("sketchEdit.propertiesUpdateError")), console.error(it);
    }
  }
  function Ge() {
    J.value && (q.value = { name: J.value.meta.name, description: J.value.meta.description, tags: [...J.value.meta.tags], created_by: J.value.meta.created_by, modified_by: J.value.meta.modified_by }, L.value = true);
  }
  function et() {
    N.value.trim() && !q.value.tags.includes(N.value.trim()) && (q.value.tags.push(N.value.trim()), N.value = "");
  }
  function dt(ct) {
    q.value.tags = q.value.tags.filter((it) => it !== ct);
  }
  async function Ct() {
    if (J.value) try {
      await f.updateSketch(J.value.id, { name: q.value.name, description: q.value.description, tags: q.value.tags }), L.value = false, h.success(l("sketchEdit.saveSuccess"));
    } catch (ct) {
      h.error(l("sketchEdit.saveError")), console.error(ct);
    }
  }
  Ei(() => {
    n.sketchId && f.setCurrentSketchId(n.sketchId);
  }), Kt(() => f.currentSketchId, (ct) => {
    ct && (P.value = null, M.value = null);
  });
  const kt = (ct) => new Date(ct).toLocaleString();
  return (ct, it) => (ut(), Ot(jr, null, [ze(HM, { active: S.value, "onUpdate:active": it[0] || (it[0] = (pt) => S.value = pt), list: K(f).sketches.map((pt) => ({ id: pt.id, name: pt.meta.name, tags: pt.meta.tags })), placement: "right", onNew: ve, onRemove: it[1] || (it[1] = (pt) => K(f).deleteSketch(pt)), onSelect: it[2] || (it[2] = (pt) => K(f).setCurrentSketchId(pt)) }, null, 8, ["active", "list"]), ze(K(kh), { show: A.value, "onUpdate:show": it[6] || (it[6] = (pt) => A.value = pt), preset: "dialog", title: K(l)("sketchEdit.createNewComponent") }, { action: je(() => [ze(K(Or), { onClick: it[5] || (it[5] = (pt) => A.value = false) }, { default: je(() => [vr(Jt(K(l)("sketchEdit.cancel")), 1)]), _: 1 }), ze(K(Or), { type: "primary", disabled: !O.value.trim(), onClick: le }, { default: je(() => [vr(Jt(K(l)("sketchEdit.create")), 1)]), _: 1 }, 8, ["disabled"])]), default: je(() => [ze(K(Eh), null, { default: je(() => [xt("div", hD, [ze(K(An), { label: K(l)("sketchEdit.name"), style: { "flex-grow": "1" } }, { default: je(() => [ze(K(Do), { value: O.value, "onUpdate:value": it[3] || (it[3] = (pt) => O.value = pt), placeholder: K(l)("sketchEdit.enterComponentName") }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), ze(K(An), { label: K(l)("sketchEdit.type") }, { default: je(() => [ze(K(M0), { value: j.value, "onUpdate:value": it[4] || (it[4] = (pt) => j.value = pt), "consistent-menu-width": false, options: [{ label: K(l)("sketchEdit.draftShape"), value: "draft" }, { label: K(l)("sketchEdit.routePath"), value: "route" }] }, null, 8, ["value", "options"])]), _: 1 }, 8, ["label"])])]), _: 1 })]), _: 1 }, 8, ["show", "title"]), ze(K(kh), { show: L.value, "onUpdate:show": it[11] || (it[11] = (pt) => L.value = pt), preset: "dialog", title: K(l)("sketchEdit.editMetadata"), style: { "max-width": "600px" } }, { action: je(() => [ze(K(Or), { onClick: it[10] || (it[10] = (pt) => L.value = false) }, { default: je(() => [vr(Jt(K(l)("sketchEdit.cancel")), 1)]), _: 1 }), ze(K(Or), { type: "primary", disabled: !q.value.name.trim(), onClick: Ct }, { default: je(() => [vr(Jt(K(l)("sketchEdit.save")), 1)]), _: 1 }, 8, ["disabled"])]), default: je(() => [ze(K(Eh), null, { default: je(() => [ze(K(An), { label: K(l)("sketchEdit.name") }, { default: je(() => [ze(K(Do), { value: q.value.name, "onUpdate:value": it[7] || (it[7] = (pt) => q.value.name = pt), placeholder: K(l)("sketchEdit.sketchNamePlaceholder") }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), ze(K(An), { label: K(l)("sketchEdit.description") }, { default: je(() => [ze(K(Do), { value: q.value.description, "onUpdate:value": it[8] || (it[8] = (pt) => q.value.description = pt), type: "textarea", placeholder: K(l)("sketchEdit.sketchDescriptionPlaceholder"), rows: 3 }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), ze(K(An), { label: K(l)("sketchEdit.tags") }, { default: je(() => [xt("div", fD, [ze(K(Do), { value: N.value, "onUpdate:value": it[9] || (it[9] = (pt) => N.value = pt), placeholder: K(l)("sketchEdit.addTagPlaceholder"), onKeydown: Qb(wh(et, ["prevent"]), ["enter"]) }, null, 8, ["value", "placeholder", "onKeydown"]), ze(K(Or), { onClick: et }, { default: je(() => [vr(Jt(K(l)("sketchEdit.add")), 1)]), _: 1 })]), (ut(true), Ot(jr, null, un(q.value.tags, (pt) => (ut(), fr(K(zo), { key: pt, closable: "", style: { "margin-right": "8px", "margin-bottom": "8px" }, onClose: ($t) => dt(pt) }, { default: je(() => [vr(Jt(pt), 1)]), _: 2 }, 1032, ["onClose"]))), 128)), q.value.tags.length === 0 ? (ut(), fr(K(Ph), { key: 0, description: K(l)("sketchEdit.noTags"), size: "small" }, null, 8, ["description"])) : _r("", true)]), _: 1 }, 8, ["label"])]), _: 1 })]), _: 1 }, 8, ["show", "title"]), xt("div", pD, [xt("div", mD, [xt("div", gD, [ze(K(Mo), null, { default: je(() => {
    var _a2;
    return [ze(KM, { "sketch-name": (_a2 = J.value) == null ? void 0 : _a2.meta.name, "draft-count": te.value.length, "route-count": ne.value.length, onSave: ke, onOpen: it[12] || (it[12] = (pt) => S.value = true), onCreate: it[13] || (it[13] = (pt) => A.value = true), onEditMeta: Ge }, null, 8, ["sketch-name", "draft-count", "route-count"])];
  }), _: 1 })]), ze(K(ab), { direction: "horizontal", max: 0.8, min: 0.2, "default-size": 0.5, class: "bottom-row-split" }, { 1: je(() => [ze(K(ab), { style: { height: "100%" }, direction: "vertical" }, { 1: je(() => [ze(K(Mo), { style: { height: "100%" }, title: K(l)("sketchEdit.components"), "content-style": "min-height: 0; overflow-y: auto;" }, { "header-extra": je(() => [ze(K(Or), { quaternary: "", circle: "", onClick: it[16] || (it[16] = (pt) => A.value = true) }, { icon: je(() => [ze(K(Th))]), _: 1 })]), default: je(() => [ze(eD, { components: ee.value, "selected-id": P.value, onSelect: it[14] || (it[14] = (pt, $t) => {
    P.value = pt, M.value = $t;
  }), onDelete: ue, onCreate: it[15] || (it[15] = (pt) => A.value = true) }, null, 8, ["components", "selected-id"])]), _: 1 }, 8, ["title"])]), 2: je(() => [ze(K(Mo), { class: "map-container", "content-style": "padding: 0;" }, { default: je(() => [ze(K(Lx), { "map-style": K(p), center: [0, 0], zoom: K(y), height: "100%", "onMap:load": K(s) }, { default: je(() => [ze(K(Ox), { position: "top-left" }), ze(K(Nx), { position: "bottom-left" }), ze(K(Bx), { position: "top-left" })]), _: 1 }, 8, ["map-style", "zoom", "onMap:load"])]), _: 1 })]), _: 1 }), ae.value ? _r("", true) : (ut(), fr(K(Ph), { key: 0, description: K(l)("sketchEdit.noSketchSelected"), size: "huge", style: { height: "100%", "justify-content": "center" } }, { icon: je(() => [ze(K(xi), null, { default: je(() => [ze(K(dS))]), _: 1 })]), extra: je(() => [ze(K(Or), { size: "small", onClick: it[17] || (it[17] = (pt) => S.value = true) }, { default: je(() => [vr(Jt(K(l)("sketchEdit.selectSketch")), 1)]), _: 1 })]), _: 1 }, 8, ["description"]))]), 2: je(() => [ze(K(Mo), { class: "component-info-container", "content-style": "min-height: 0; overflow: auto;" }, { footer: je(() => [oe.value ? (ut(), fr(K(is), { key: 0, depth: "3", class: "metadata" }, { default: je(() => [xt("div", vD, Jt(K(l)("sketchEdit.createdTimeBy", { user: oe.value.meta.created_by, time: kt(oe.value.meta.creation_timestamp) })), 1), xt("div", yD, Jt(K(l)("sketchEdit.modifiedTimeBy", { user: oe.value.meta.modified_by, time: kt(oe.value.meta.modification_timestamp) })), 1)]), _: 1 })) : _r("", true)]), default: je(() => [ze(nD, { component: oe.value, type: M.value, onUpdateProperties: be, onUpdateMeta: it[18] || (it[18] = (pt) => Ve(pt)) }, null, 8, ["component", "type"])]), _: 1 })]), _: 1 })])])], 64));
} }), bD = Ui(_D, [["__scopeId", "data-v-b8cdd1f5"]]), xD = { class: "sketch-centre-view" }, wD = { class: "header" }, CD = { class: "title" }, SD = { class: "card-header" }, kD = { key: 0, class: "tags" }, TD = { class: "card-content" }, PD = { class: "meta-info" }, ID = { class: "meta-item" }, ED = { class: "meta-item" }, MD = { class: "meta-item" }, DD = { key: 0, class: "empty-state" }, RD = nt({ __name: "SketchCentreView", setup(r) {
  Gs((le) => ({ v460cb2d9: K(ve).bodyColor }));
  const { t: n } = Gn(), l = ux(), h = pm(), f = Vs(), y = hv(), p = Ae(() => y.sketches), s = Ae({ get: () => y.currentSketchId, set: (le) => y.setCurrentSketchId(le) }), S = (le) => {
    const ue = s.value === le;
    return { borderColor: ue ? f.value.primaryColor : "", borderWidth: ue ? "2px" : "1px", padding: ue ? "0px" : "1px", zIndex: ue ? 0 : 1 };
  }, P = Ee(false), M = Ee(""), A = Ee(""), O = Ee(false), j = Ee(""), L = async () => {
    await y.init();
  }, q = (le) => new Date(le).toLocaleDateString(), N = (le) => le.routes.routes.length, J = (le) => le.drafts.drafts.length, te = (le) => {
    y.setCurrentSketchId(le);
  }, ne = (le) => {
    j.value = le, O.value = true;
  }, ae = async () => {
    if (!M.value.trim()) {
      h.error(n("sketchCentreView.nameRequired"));
      return;
    }
    const le = await y.createSketch(M.value);
    await y.updateSketch(le.id, { description: A.value }), y.setCurrentSketchId(le.id), P.value = false, M.value = "", A.value = "", h.success(n("sketchCentreView.sketchCreated"));
  }, oe = (le) => {
    const ue = p.value.find((be) => be.id === le);
    ue && l.warning({ title: n("sketchCentreView.deleteConfirmation.title"), content: n("sketchCentreView.deleteConfirmation.prompt", { name: ue.meta.name }), positiveText: n("sketchCentreView.deleteConfirmation.yes"), negativeText: n("sketchCentreView.deleteConfirmation.no"), onPositiveClick: async () => {
      await y.deleteSketch(le), h.success(n("sketchCentreView.sketchDeleted"));
    } });
  }, { width: ee } = k1(), ke = Ae(() => Math.floor(ee.value / 360));
  Ei(() => {
    L();
  });
  const ve = Vs();
  return (le, ue) => (ut(), Ot("div", xD, [xt("div", wD, [xt("h1", CD, Jt(K(n)("sketchCentreView.title")), 1), ze(K(Or), { type: "primary", secondary: "", circle: "", onClick: ue[0] || (ue[0] = (be) => P.value = true) }, { icon: je(() => [ze(K(xi), null, { default: je(() => [ze(K(Th))]), _: 1 })]), _: 1 })]), ze(K(o4), { cols: ke.value, "x-gap": 16, "y-gap": 16, responsive: "screen" }, { default: je(() => [(ut(true), Ot(jr, null, un(p.value, (be) => (ut(), fr(K(r4), { key: be.id }, { default: je(() => [ze(K(Mo), { class: ha(["sketch-card", { selected: s.value === be.id }]), style: zn(S(be.id)), hoverable: "", bordered: "", clickable: "", onClick: (Ve) => te(be.id) }, { header: je(() => [xt("div", SD, [ze(K(is), { class: "sketch-name" }, { default: je(() => [vr(Jt(be.meta.name), 1)]), _: 2 }, 1024), be.meta.tags.length > 0 ? (ut(), Ot("div", kD, [(ut(true), Ot(jr, null, un(be.meta.tags.slice(0, 3), (Ve) => (ut(), fr(K(zo), { key: Ve, size: "small", round: "", type: "info" }, { default: je(() => [vr(Jt(Ve.toLocaleUpperCase()), 1)]), _: 2 }, 1024))), 128)), be.meta.tags.length > 3 ? (ut(), fr(K(zo), { key: 0, size: "small", round: "", type: "info" }, { default: je(() => [vr(" +" + Jt(be.meta.tags.length - 3), 1)]), _: 2 }, 1024)) : _r("", true)])) : _r("", true)])]), "header-extra": je(() => [ze(K(Os), null, { default: je(() => [ze(K(Or), { quaternary: "", circle: "", size: "small", onClick: wh((Ve) => ne(be.id), ["stop"]) }, { icon: je(() => [ze(K(xi), null, { default: je(() => [ze(K(Ak))]), _: 1 })]), _: 1 }, 8, ["onClick"]), ze(K(Or), { quaternary: "", circle: "", size: "small", onClick: wh((Ve) => oe(be.id), ["stop"]) }, { icon: je(() => [ze(K(xi), null, { default: je(() => [ze(K(dm))]), _: 1 })]), _: 1 }, 8, ["onClick"])]), _: 2 }, 1024)]), default: je(() => [xt("div", TD, [ze(K(is), { depth: "3", class: "description" }, { default: je(() => [vr(Jt(be.meta.description || K(n)("sketchCentreView.noDescription")), 1)]), _: 2 }, 1024), xt("div", PD, [xt("div", ID, [ze(K(xi), { size: 16 }, { default: je(() => [ze(K(Pk))]), _: 1 }), ze(K(is), { depth: "3", style: { "font-size": "12px" } }, { default: je(() => [vr(Jt(q(be.meta.creation_timestamp)), 1)]), _: 2 }, 1024)]), xt("div", ED, [ze(K(xi), { size: 16 }, { default: je(() => [ze(K(iv))]), _: 1 }), ze(K(is), { depth: "3", style: { "font-size": "12px" } }, { default: je(() => [vr(Jt(N(be)) + " " + Jt(K(n)("sketchCentreView.routes")), 1)]), _: 2 }, 1024)]), xt("div", MD, [ze(K(xi), { size: 16 }, { default: je(() => [ze(K($1))]), _: 1 }), ze(K(is), { depth: "3", style: { "font-size": "12px" } }, { default: je(() => [vr(Jt(J(be)) + " " + Jt(K(n)("sketchCentreView.drafts")), 1)]), _: 2 }, 1024)])])])]), _: 2 }, 1032, ["class", "style", "onClick"])]), _: 2 }, 1024))), 128))]), _: 1 }, 8, ["cols"]), p.value.length === 0 ? (ut(), Ot("div", DD, [ze(K(xi), { size: "48", depth: "3" }, { default: je(() => [ze(K(rv))]), _: 1 }), ze(K(is), { depth: "3" }, { default: je(() => [vr(Jt(K(n)("sketchCentreView.emptyState")), 1)]), _: 1 }), ze(K(Or), { type: "primary", onClick: ue[1] || (ue[1] = (be) => P.value = true) }, { icon: je(() => [ze(K(xi), null, { default: je(() => [ze(K(Th))]), _: 1 })]), default: je(() => [vr(" " + Jt(K(n)("sketchCentreView.createFirstSketch")), 1)]), _: 1 })])) : _r("", true), ze(K(kh), { show: P.value, "onUpdate:show": ue[5] || (ue[5] = (be) => P.value = be), "mask-closable": true, preset: "card", style: { "max-width": "500px" }, title: K(n)("sketchCentreView.newSketch") }, { footer: je(() => [ze(K(Os), { justify: "end" }, { default: je(() => [ze(K(Or), { onClick: ue[4] || (ue[4] = (be) => P.value = false) }, { default: je(() => [vr(Jt(K(n)("sketchCentreView.cancel")), 1)]), _: 1 }), ze(K(Or), { type: "primary", onClick: ae }, { default: je(() => [vr(Jt(K(n)("sketchCentreView.create")), 1)]), _: 1 })]), _: 1 })]), default: je(() => [ze(K(Eh), { model: { name: M.value, description: A.value }, "label-placement": "top", "require-mark-placement": "right-hanging" }, { default: je(() => [ze(K(An), { label: K(n)("sketchCentreView.sketchName"), required: "" }, { default: je(() => [ze(K(Do), { value: M.value, "onUpdate:value": ue[2] || (ue[2] = (be) => M.value = be), placeholder: K(n)("sketchCentreView.sketchNamePlaceholder") }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), ze(K(An), { label: K(n)("sketchCentreView.description") }, { default: je(() => [ze(K(Do), { value: A.value, "onUpdate:value": ue[3] || (ue[3] = (be) => A.value = be), type: "textarea", placeholder: K(n)("sketchCentreView.sketchDescriptionPlaceholder"), autosize: { minRows: 3, maxRows: 5 } }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"])]), _: 1 }, 8, ["model"])]), _: 1 }, 8, ["show", "title"]), ze(K(dx), { show: O.value, "onUpdate:show": ue[6] || (ue[6] = (be) => O.value = be), width: 800, placement: "right", "display-directive": "show", height: "100%" }, { default: je(() => [ze(K(hx), { title: K(n)("sketchCentreView.editSketch"), closable: "", "body-content-style": { padding: 0, height: "100%" } }, { default: je(() => [j.value ? (ut(), fr(bD, { key: 0, "sketch-id": j.value }, null, 8, ["sketch-id"])) : _r("", true)]), _: 1 }, 8, ["title"])]), _: 1 }, 8, ["show"])]));
} }), i2 = Ui(RD, [["__scopeId", "data-v-00cdfd4b"]]), AD = Object.freeze(Object.defineProperty({ __proto__: null, default: i2 }, Symbol.toStringTag, { value: "Module" })), Rb = {};
function zD(r) {
  let n = Rb[r];
  if (n) return n;
  n = Rb[r] = [];
  for (let l = 0; l < 128; l++) {
    const h = String.fromCharCode(l);
    n.push(h);
  }
  for (let l = 0; l < r.length; l++) {
    const h = r.charCodeAt(l);
    n[h] = "%" + ("0" + h.toString(16).toUpperCase()).slice(-2);
  }
  return n;
}
function Bc(r, n) {
  typeof n != "string" && (n = Bc.defaultChars);
  const l = zD(n);
  return r.replace(/(%[a-f0-9]{2})+/gi, function(h) {
    let f = "";
    for (let y = 0, p = h.length; y < p; y += 3) {
      const s = parseInt(h.slice(y + 1, y + 3), 16);
      if (s < 128) {
        f += l[s];
        continue;
      }
      if ((s & 224) === 192 && y + 3 < p) {
        const S = parseInt(h.slice(y + 4, y + 6), 16);
        if ((S & 192) === 128) {
          const P = s << 6 & 1984 | S & 63;
          P < 128 ? f += "\uFFFD\uFFFD" : f += String.fromCharCode(P), y += 3;
          continue;
        }
      }
      if ((s & 240) === 224 && y + 6 < p) {
        const S = parseInt(h.slice(y + 4, y + 6), 16), P = parseInt(h.slice(y + 7, y + 9), 16);
        if ((S & 192) === 128 && (P & 192) === 128) {
          const M = s << 12 & 61440 | S << 6 & 4032 | P & 63;
          M < 2048 || M >= 55296 && M <= 57343 ? f += "\uFFFD\uFFFD\uFFFD" : f += String.fromCharCode(M), y += 6;
          continue;
        }
      }
      if ((s & 248) === 240 && y + 9 < p) {
        const S = parseInt(h.slice(y + 4, y + 6), 16), P = parseInt(h.slice(y + 7, y + 9), 16), M = parseInt(h.slice(y + 10, y + 12), 16);
        if ((S & 192) === 128 && (P & 192) === 128 && (M & 192) === 128) {
          let A = s << 18 & 1835008 | S << 12 & 258048 | P << 6 & 4032 | M & 63;
          A < 65536 || A > 1114111 ? f += "\uFFFD\uFFFD\uFFFD\uFFFD" : (A -= 65536, f += String.fromCharCode(55296 + (A >> 10), 56320 + (A & 1023))), y += 9;
          continue;
        }
      }
      f += "\uFFFD";
    }
    return f;
  });
}
Bc.defaultChars = ";/?:@&=+$,#";
Bc.componentChars = "";
const Ab = {};
function FD(r) {
  let n = Ab[r];
  if (n) return n;
  n = Ab[r] = [];
  for (let l = 0; l < 128; l++) {
    const h = String.fromCharCode(l);
    /^[0-9a-z]$/i.test(h) ? n.push(h) : n.push("%" + ("0" + l.toString(16).toUpperCase()).slice(-2));
  }
  for (let l = 0; l < r.length; l++) n[r.charCodeAt(l)] = r[l];
  return n;
}
function Gh(r, n, l) {
  typeof n != "string" && (l = n, n = Gh.defaultChars), typeof l > "u" && (l = true);
  const h = FD(n);
  let f = "";
  for (let y = 0, p = r.length; y < p; y++) {
    const s = r.charCodeAt(y);
    if (l && s === 37 && y + 2 < p && /^[0-9a-f]{2}$/i.test(r.slice(y + 1, y + 3))) {
      f += r.slice(y, y + 3), y += 2;
      continue;
    }
    if (s < 128) {
      f += h[s];
      continue;
    }
    if (s >= 55296 && s <= 57343) {
      if (s >= 55296 && s <= 56319 && y + 1 < p) {
        const S = r.charCodeAt(y + 1);
        if (S >= 56320 && S <= 57343) {
          f += encodeURIComponent(r[y] + r[y + 1]), y++;
          continue;
        }
      }
      f += "%EF%BF%BD";
      continue;
    }
    f += encodeURIComponent(r[y]);
  }
  return f;
}
Gh.defaultChars = ";/?:@&=+$,-_.!~*'()#";
Gh.componentChars = "-_.!~*'()";
function pv(r) {
  let n = "";
  return n += r.protocol || "", n += r.slashes ? "//" : "", n += r.auth ? r.auth + "@" : "", r.hostname && r.hostname.indexOf(":") !== -1 ? n += "[" + r.hostname + "]" : n += r.hostname || "", n += r.port ? ":" + r.port : "", n += r.pathname || "", n += r.search || "", n += r.hash || "", n;
}
function Jp() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
const LD = /^([a-z0-9.+-]+:)/i, BD = /:[0-9]*$/, OD = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, $D = ["<", ">", '"', "`", " ", "\r", `
`, "	"], ND = ["{", "}", "|", "\\", "^", "`"].concat($D), jD = ["'"].concat(ND), zb = ["%", "/", "?", ";", "#"].concat(jD), Fb = ["/", "?", "#"], VD = 255, Lb = /^[+a-z0-9A-Z_-]{0,63}$/, UD = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, Bb = { javascript: true, "javascript:": true }, Ob = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
function mv(r, n) {
  if (r && r instanceof Jp) return r;
  const l = new Jp();
  return l.parse(r, n), l;
}
Jp.prototype.parse = function(r, n) {
  let l, h, f, y = r;
  if (y = y.trim(), !n && r.split("#").length === 1) {
    const P = OD.exec(y);
    if (P) return this.pathname = P[1], P[2] && (this.search = P[2]), this;
  }
  let p = LD.exec(y);
  if (p && (p = p[0], l = p.toLowerCase(), this.protocol = p, y = y.substr(p.length)), (n || p || y.match(/^\/\/[^@\/]+@[^@\/]+/)) && (f = y.substr(0, 2) === "//", f && !(p && Bb[p]) && (y = y.substr(2), this.slashes = true)), !Bb[p] && (f || p && !Ob[p])) {
    let P = -1;
    for (let L = 0; L < Fb.length; L++) h = y.indexOf(Fb[L]), h !== -1 && (P === -1 || h < P) && (P = h);
    let M, A;
    P === -1 ? A = y.lastIndexOf("@") : A = y.lastIndexOf("@", P), A !== -1 && (M = y.slice(0, A), y = y.slice(A + 1), this.auth = M), P = -1;
    for (let L = 0; L < zb.length; L++) h = y.indexOf(zb[L]), h !== -1 && (P === -1 || h < P) && (P = h);
    P === -1 && (P = y.length), y[P - 1] === ":" && P--;
    const O = y.slice(0, P);
    y = y.slice(P), this.parseHost(O), this.hostname = this.hostname || "";
    const j = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!j) {
      const L = this.hostname.split(/\./);
      for (let q = 0, N = L.length; q < N; q++) {
        const J = L[q];
        if (J && !J.match(Lb)) {
          let te = "";
          for (let ne = 0, ae = J.length; ne < ae; ne++) J.charCodeAt(ne) > 127 ? te += "x" : te += J[ne];
          if (!te.match(Lb)) {
            const ne = L.slice(0, q), ae = L.slice(q + 1), oe = J.match(UD);
            oe && (ne.push(oe[1]), ae.unshift(oe[2])), ae.length && (y = ae.join(".") + y), this.hostname = ne.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > VD && (this.hostname = ""), j && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  const s = y.indexOf("#");
  s !== -1 && (this.hash = y.substr(s), y = y.slice(0, s));
  const S = y.indexOf("?");
  return S !== -1 && (this.search = y.substr(S), y = y.slice(0, S)), y && (this.pathname = y), Ob[l] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
Jp.prototype.parseHost = function(r) {
  let n = BD.exec(r);
  n && (n = n[0], n !== ":" && (this.port = n.substr(1)), r = r.substr(0, r.length - n.length)), r && (this.hostname = r);
};
const GD = Object.freeze(Object.defineProperty({ __proto__: null, decode: Bc, encode: Gh, format: pv, parse: mv }, Symbol.toStringTag, { value: "Module" })), n2 = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, o2 = /[\0-\x1F\x7F-\x9F]/, qD = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/, gv = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, a2 = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/, s2 = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, WD = Object.freeze(Object.defineProperty({ __proto__: null, Any: n2, Cc: o2, Cf: qD, P: gv, S: a2, Z: s2 }, Symbol.toStringTag, { value: "Module" })), ZD = new Uint16Array('\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((r) => r.charCodeAt(0))), HD = new Uint16Array("\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((r) => r.charCodeAt(0)));
var d0;
const XD = /* @__PURE__ */ new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]), YD = (d0 = String.fromCodePoint) !== null && d0 !== void 0 ? d0 : function(r) {
  let n = "";
  return r > 65535 && (r -= 65536, n += String.fromCharCode(r >>> 10 & 1023 | 55296), r = 56320 | r & 1023), n += String.fromCharCode(r), n;
};
function KD(r) {
  var n;
  return r >= 55296 && r <= 57343 || r > 1114111 ? 65533 : (n = XD.get(r)) !== null && n !== void 0 ? n : r;
}
var _n;
(function(r) {
  r[r.NUM = 35] = "NUM", r[r.SEMI = 59] = "SEMI", r[r.EQUALS = 61] = "EQUALS", r[r.ZERO = 48] = "ZERO", r[r.NINE = 57] = "NINE", r[r.LOWER_A = 97] = "LOWER_A", r[r.LOWER_F = 102] = "LOWER_F", r[r.LOWER_X = 120] = "LOWER_X", r[r.LOWER_Z = 122] = "LOWER_Z", r[r.UPPER_A = 65] = "UPPER_A", r[r.UPPER_F = 70] = "UPPER_F", r[r.UPPER_Z = 90] = "UPPER_Z";
})(_n || (_n = {}));
const JD = 32;
var $s;
(function(r) {
  r[r.VALUE_LENGTH = 49152] = "VALUE_LENGTH", r[r.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", r[r.JUMP_TABLE = 127] = "JUMP_TABLE";
})($s || ($s = {}));
function W0(r) {
  return r >= _n.ZERO && r <= _n.NINE;
}
function QD(r) {
  return r >= _n.UPPER_A && r <= _n.UPPER_F || r >= _n.LOWER_A && r <= _n.LOWER_F;
}
function eR(r) {
  return r >= _n.UPPER_A && r <= _n.UPPER_Z || r >= _n.LOWER_A && r <= _n.LOWER_Z || W0(r);
}
function tR(r) {
  return r === _n.EQUALS || eR(r);
}
var yn;
(function(r) {
  r[r.EntityStart = 0] = "EntityStart", r[r.NumericStart = 1] = "NumericStart", r[r.NumericDecimal = 2] = "NumericDecimal", r[r.NumericHex = 3] = "NumericHex", r[r.NamedEntity = 4] = "NamedEntity";
})(yn || (yn = {}));
var Bs;
(function(r) {
  r[r.Legacy = 0] = "Legacy", r[r.Strict = 1] = "Strict", r[r.Attribute = 2] = "Attribute";
})(Bs || (Bs = {}));
class rR {
  constructor(n, l, h) {
    this.decodeTree = n, this.emitCodePoint = l, this.errors = h, this.state = yn.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Bs.Strict;
  }
  startEntity(n) {
    this.decodeMode = n, this.state = yn.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  write(n, l) {
    switch (this.state) {
      case yn.EntityStart:
        return n.charCodeAt(l) === _n.NUM ? (this.state = yn.NumericStart, this.consumed += 1, this.stateNumericStart(n, l + 1)) : (this.state = yn.NamedEntity, this.stateNamedEntity(n, l));
      case yn.NumericStart:
        return this.stateNumericStart(n, l);
      case yn.NumericDecimal:
        return this.stateNumericDecimal(n, l);
      case yn.NumericHex:
        return this.stateNumericHex(n, l);
      case yn.NamedEntity:
        return this.stateNamedEntity(n, l);
    }
  }
  stateNumericStart(n, l) {
    return l >= n.length ? -1 : (n.charCodeAt(l) | JD) === _n.LOWER_X ? (this.state = yn.NumericHex, this.consumed += 1, this.stateNumericHex(n, l + 1)) : (this.state = yn.NumericDecimal, this.stateNumericDecimal(n, l));
  }
  addToNumericResult(n, l, h, f) {
    if (l !== h) {
      const y = h - l;
      this.result = this.result * Math.pow(f, y) + parseInt(n.substr(l, y), f), this.consumed += y;
    }
  }
  stateNumericHex(n, l) {
    const h = l;
    for (; l < n.length; ) {
      const f = n.charCodeAt(l);
      if (W0(f) || QD(f)) l += 1;
      else return this.addToNumericResult(n, h, l, 16), this.emitNumericEntity(f, 3);
    }
    return this.addToNumericResult(n, h, l, 16), -1;
  }
  stateNumericDecimal(n, l) {
    const h = l;
    for (; l < n.length; ) {
      const f = n.charCodeAt(l);
      if (W0(f)) l += 1;
      else return this.addToNumericResult(n, h, l, 10), this.emitNumericEntity(f, 2);
    }
    return this.addToNumericResult(n, h, l, 10), -1;
  }
  emitNumericEntity(n, l) {
    var h;
    if (this.consumed <= l) return (h = this.errors) === null || h === void 0 || h.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (n === _n.SEMI) this.consumed += 1;
    else if (this.decodeMode === Bs.Strict) return 0;
    return this.emitCodePoint(KD(this.result), this.consumed), this.errors && (n !== _n.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  stateNamedEntity(n, l) {
    const { decodeTree: h } = this;
    let f = h[this.treeIndex], y = (f & $s.VALUE_LENGTH) >> 14;
    for (; l < n.length; l++, this.excess++) {
      const p = n.charCodeAt(l);
      if (this.treeIndex = iR(h, f, this.treeIndex + Math.max(1, y), p), this.treeIndex < 0) return this.result === 0 || this.decodeMode === Bs.Attribute && (y === 0 || tR(p)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (f = h[this.treeIndex], y = (f & $s.VALUE_LENGTH) >> 14, y !== 0) {
        if (p === _n.SEMI) return this.emitNamedEntityData(this.treeIndex, y, this.consumed + this.excess);
        this.decodeMode !== Bs.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  emitNotTerminatedNamedEntity() {
    var n;
    const { result: l, decodeTree: h } = this, f = (h[l] & $s.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(l, f, this.consumed), (n = this.errors) === null || n === void 0 || n.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  emitNamedEntityData(n, l, h) {
    const { decodeTree: f } = this;
    return this.emitCodePoint(l === 1 ? f[n] & ~$s.VALUE_LENGTH : f[n + 1], h), l === 3 && this.emitCodePoint(f[n + 2], h), h;
  }
  end() {
    var n;
    switch (this.state) {
      case yn.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== Bs.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case yn.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case yn.NumericHex:
        return this.emitNumericEntity(0, 3);
      case yn.NumericStart:
        return (n = this.errors) === null || n === void 0 || n.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case yn.EntityStart:
        return 0;
    }
  }
}
function l2(r) {
  let n = "";
  const l = new rR(r, (h) => n += YD(h));
  return function(f, y) {
    let p = 0, s = 0;
    for (; (s = f.indexOf("&", s)) >= 0; ) {
      n += f.slice(p, s), l.startEntity(y);
      const P = l.write(f, s + 1);
      if (P < 0) {
        p = s + l.end();
        break;
      }
      p = s + P, s = P === 0 ? p + 1 : p;
    }
    const S = n + f.slice(p);
    return n = "", S;
  };
}
function iR(r, n, l, h) {
  const f = (n & $s.BRANCH_LENGTH) >> 7, y = n & $s.JUMP_TABLE;
  if (f === 0) return y !== 0 && h === y ? l : -1;
  if (y) {
    const S = h - y;
    return S < 0 || S >= f ? -1 : r[l + S] - 1;
  }
  let p = l, s = p + f - 1;
  for (; p <= s; ) {
    const S = p + s >>> 1, P = r[S];
    if (P < h) p = S + 1;
    else if (P > h) s = S - 1;
    else return r[S + f];
  }
  return -1;
}
const nR = l2(ZD);
l2(HD);
function u2(r, n = Bs.Legacy) {
  return nR(r, n);
}
function oR(r) {
  return Object.prototype.toString.call(r);
}
function vv(r) {
  return oR(r) === "[object String]";
}
const aR = Object.prototype.hasOwnProperty;
function sR(r, n) {
  return aR.call(r, n);
}
function _m(r) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(l) {
    if (l) {
      if (typeof l != "object") throw new TypeError(l + "must be object");
      Object.keys(l).forEach(function(h) {
        r[h] = l[h];
      });
    }
  }), r;
}
function c2(r, n, l) {
  return [].concat(r.slice(0, n), l, r.slice(n + 1));
}
function yv(r) {
  return !(r >= 55296 && r <= 57343 || r >= 64976 && r <= 65007 || (r & 65535) === 65535 || (r & 65535) === 65534 || r >= 0 && r <= 8 || r === 11 || r >= 14 && r <= 31 || r >= 127 && r <= 159 || r > 1114111);
}
function Qp(r) {
  if (r > 65535) {
    r -= 65536;
    const n = 55296 + (r >> 10), l = 56320 + (r & 1023);
    return String.fromCharCode(n, l);
  }
  return String.fromCharCode(r);
}
const d2 = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g, lR = /&([a-z#][a-z0-9]{1,31});/gi, uR = new RegExp(d2.source + "|" + lR.source, "gi"), cR = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function dR(r, n) {
  if (n.charCodeAt(0) === 35 && cR.test(n)) {
    const h = n[1].toLowerCase() === "x" ? parseInt(n.slice(2), 16) : parseInt(n.slice(1), 10);
    return yv(h) ? Qp(h) : r;
  }
  const l = u2(r);
  return l !== r ? l : r;
}
function hR(r) {
  return r.indexOf("\\") < 0 ? r : r.replace(d2, "$1");
}
function Oc(r) {
  return r.indexOf("\\") < 0 && r.indexOf("&") < 0 ? r : r.replace(uR, function(n, l, h) {
    return l || dR(n, h);
  });
}
const fR = /[&<>"]/, pR = /[&<>"]/g, mR = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" };
function gR(r) {
  return mR[r];
}
function Us(r) {
  return fR.test(r) ? r.replace(pR, gR) : r;
}
const vR = /[.?*+^$[\]\\(){}|-]/g;
function yR(r) {
  return r.replace(vR, "\\$&");
}
function yi(r) {
  switch (r) {
    case 9:
    case 32:
      return true;
  }
  return false;
}
function Rh(r) {
  if (r >= 8192 && r <= 8202) return true;
  switch (r) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return true;
  }
  return false;
}
function Ah(r) {
  return gv.test(r) || a2.test(r);
}
function zh(r) {
  switch (r) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function bm(r) {
  return r = r.trim().replace(/\s+/g, " "), "\u1E9E".toLowerCase() === "\u1E7E" && (r = r.replace(//g, "\xDF")), r.toLowerCase().toUpperCase();
}
const _R = { mdurl: GD, ucmicro: WD }, bR = Object.freeze(Object.defineProperty({ __proto__: null, arrayReplaceAt: c2, assign: _m, escapeHtml: Us, escapeRE: yR, fromCodePoint: Qp, has: sR, isMdAsciiPunct: zh, isPunctChar: Ah, isSpace: yi, isString: vv, isValidEntityCode: yv, isWhiteSpace: Rh, lib: _R, normalizeReference: bm, unescapeAll: Oc, unescapeMd: hR }, Symbol.toStringTag, { value: "Module" }));
function xR(r, n, l) {
  let h, f, y, p;
  const s = r.posMax, S = r.pos;
  for (r.pos = n + 1, h = 1; r.pos < s; ) {
    if (y = r.src.charCodeAt(r.pos), y === 93 && (h--, h === 0)) {
      f = true;
      break;
    }
    if (p = r.pos, r.md.inline.skipToken(r), y === 91) {
      if (p === r.pos - 1) h++;
      else if (l) return r.pos = S, -1;
    }
  }
  let P = -1;
  return f && (P = r.pos), r.pos = S, P;
}
function wR(r, n, l) {
  let h, f = n;
  const y = { ok: false, pos: 0, str: "" };
  if (r.charCodeAt(f) === 60) {
    for (f++; f < l; ) {
      if (h = r.charCodeAt(f), h === 10 || h === 60) return y;
      if (h === 62) return y.pos = f + 1, y.str = Oc(r.slice(n + 1, f)), y.ok = true, y;
      if (h === 92 && f + 1 < l) {
        f += 2;
        continue;
      }
      f++;
    }
    return y;
  }
  let p = 0;
  for (; f < l && (h = r.charCodeAt(f), !(h === 32 || h < 32 || h === 127)); ) {
    if (h === 92 && f + 1 < l) {
      if (r.charCodeAt(f + 1) === 32) break;
      f += 2;
      continue;
    }
    if (h === 40 && (p++, p > 32)) return y;
    if (h === 41) {
      if (p === 0) break;
      p--;
    }
    f++;
  }
  return n === f || p !== 0 || (y.str = Oc(r.slice(n, f)), y.pos = f, y.ok = true), y;
}
function CR(r, n, l, h) {
  let f, y = n;
  const p = { ok: false, can_continue: false, pos: 0, str: "", marker: 0 };
  if (h) p.str = h.str, p.marker = h.marker;
  else {
    if (y >= l) return p;
    let s = r.charCodeAt(y);
    if (s !== 34 && s !== 39 && s !== 40) return p;
    n++, y++, s === 40 && (s = 41), p.marker = s;
  }
  for (; y < l; ) {
    if (f = r.charCodeAt(y), f === p.marker) return p.pos = y + 1, p.str += Oc(r.slice(n, y)), p.ok = true, p;
    if (f === 40 && p.marker === 41) return p;
    f === 92 && y + 1 < l && y++, y++;
  }
  return p.can_continue = true, p.str += Oc(r.slice(n, y)), p;
}
const SR = Object.freeze(Object.defineProperty({ __proto__: null, parseLinkDestination: wR, parseLinkLabel: xR, parseLinkTitle: CR }, Symbol.toStringTag, { value: "Module" })), Oa = {};
Oa.code_inline = function(r, n, l, h, f) {
  const y = r[n];
  return "<code" + f.renderAttrs(y) + ">" + Us(y.content) + "</code>";
};
Oa.code_block = function(r, n, l, h, f) {
  const y = r[n];
  return "<pre" + f.renderAttrs(y) + "><code>" + Us(r[n].content) + `</code></pre>
`;
};
Oa.fence = function(r, n, l, h, f) {
  const y = r[n], p = y.info ? Oc(y.info).trim() : "";
  let s = "", S = "";
  if (p) {
    const M = p.split(/(\s+)/g);
    s = M[0], S = M.slice(2).join("");
  }
  let P;
  if (l.highlight ? P = l.highlight(y.content, s, S) || Us(y.content) : P = Us(y.content), P.indexOf("<pre") === 0) return P + `
`;
  if (p) {
    const M = y.attrIndex("class"), A = y.attrs ? y.attrs.slice() : [];
    M < 0 ? A.push(["class", l.langPrefix + s]) : (A[M] = A[M].slice(), A[M][1] += " " + l.langPrefix + s);
    const O = { attrs: A };
    return `<pre><code${f.renderAttrs(O)}>${P}</code></pre>
`;
  }
  return `<pre><code${f.renderAttrs(y)}>${P}</code></pre>
`;
};
Oa.image = function(r, n, l, h, f) {
  const y = r[n];
  return y.attrs[y.attrIndex("alt")][1] = f.renderInlineAsText(y.children, l, h), f.renderToken(r, n, l);
};
Oa.hardbreak = function(r, n, l) {
  return l.xhtmlOut ? `<br />
` : `<br>
`;
};
Oa.softbreak = function(r, n, l) {
  return l.breaks ? l.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
Oa.text = function(r, n) {
  return Us(r[n].content);
};
Oa.html_block = function(r, n) {
  return r[n].content;
};
Oa.html_inline = function(r, n) {
  return r[n].content;
};
function Uc() {
  this.rules = _m({}, Oa);
}
Uc.prototype.renderAttrs = function(n) {
  let l, h, f;
  if (!n.attrs) return "";
  for (f = "", l = 0, h = n.attrs.length; l < h; l++) f += " " + Us(n.attrs[l][0]) + '="' + Us(n.attrs[l][1]) + '"';
  return f;
};
Uc.prototype.renderToken = function(n, l, h) {
  const f = n[l];
  let y = "";
  if (f.hidden) return "";
  f.block && f.nesting !== -1 && l && n[l - 1].hidden && (y += `
`), y += (f.nesting === -1 ? "</" : "<") + f.tag, y += this.renderAttrs(f), f.nesting === 0 && h.xhtmlOut && (y += " /");
  let p = false;
  if (f.block && (p = true, f.nesting === 1 && l + 1 < n.length)) {
    const s = n[l + 1];
    (s.type === "inline" || s.hidden || s.nesting === -1 && s.tag === f.tag) && (p = false);
  }
  return y += p ? `>
` : ">", y;
};
Uc.prototype.renderInline = function(r, n, l) {
  let h = "";
  const f = this.rules;
  for (let y = 0, p = r.length; y < p; y++) {
    const s = r[y].type;
    typeof f[s] < "u" ? h += f[s](r, y, n, l, this) : h += this.renderToken(r, y, n);
  }
  return h;
};
Uc.prototype.renderInlineAsText = function(r, n, l) {
  let h = "";
  for (let f = 0, y = r.length; f < y; f++) switch (r[f].type) {
    case "text":
      h += r[f].content;
      break;
    case "image":
      h += this.renderInlineAsText(r[f].children, n, l);
      break;
    case "html_inline":
    case "html_block":
      h += r[f].content;
      break;
    case "softbreak":
    case "hardbreak":
      h += `
`;
      break;
  }
  return h;
};
Uc.prototype.render = function(r, n, l) {
  let h = "";
  const f = this.rules;
  for (let y = 0, p = r.length; y < p; y++) {
    const s = r[y].type;
    s === "inline" ? h += this.renderInline(r[y].children, n, l) : typeof f[s] < "u" ? h += f[s](r, y, n, l, this) : h += this.renderToken(r, y, n, l);
  }
  return h;
};
function fo() {
  this.__rules__ = [], this.__cache__ = null;
}
fo.prototype.__find__ = function(r) {
  for (let n = 0; n < this.__rules__.length; n++) if (this.__rules__[n].name === r) return n;
  return -1;
};
fo.prototype.__compile__ = function() {
  const r = this, n = [""];
  r.__rules__.forEach(function(l) {
    l.enabled && l.alt.forEach(function(h) {
      n.indexOf(h) < 0 && n.push(h);
    });
  }), r.__cache__ = {}, n.forEach(function(l) {
    r.__cache__[l] = [], r.__rules__.forEach(function(h) {
      h.enabled && (l && h.alt.indexOf(l) < 0 || r.__cache__[l].push(h.fn));
    });
  });
};
fo.prototype.at = function(r, n, l) {
  const h = this.__find__(r), f = l || {};
  if (h === -1) throw new Error("Parser rule not found: " + r);
  this.__rules__[h].fn = n, this.__rules__[h].alt = f.alt || [], this.__cache__ = null;
};
fo.prototype.before = function(r, n, l, h) {
  const f = this.__find__(r), y = h || {};
  if (f === -1) throw new Error("Parser rule not found: " + r);
  this.__rules__.splice(f, 0, { name: n, enabled: true, fn: l, alt: y.alt || [] }), this.__cache__ = null;
};
fo.prototype.after = function(r, n, l, h) {
  const f = this.__find__(r), y = h || {};
  if (f === -1) throw new Error("Parser rule not found: " + r);
  this.__rules__.splice(f + 1, 0, { name: n, enabled: true, fn: l, alt: y.alt || [] }), this.__cache__ = null;
};
fo.prototype.push = function(r, n, l) {
  const h = l || {};
  this.__rules__.push({ name: r, enabled: true, fn: n, alt: h.alt || [] }), this.__cache__ = null;
};
fo.prototype.enable = function(r, n) {
  Array.isArray(r) || (r = [r]);
  const l = [];
  return r.forEach(function(h) {
    const f = this.__find__(h);
    if (f < 0) {
      if (n) return;
      throw new Error("Rules manager: invalid rule name " + h);
    }
    this.__rules__[f].enabled = true, l.push(h);
  }, this), this.__cache__ = null, l;
};
fo.prototype.enableOnly = function(r, n) {
  Array.isArray(r) || (r = [r]), this.__rules__.forEach(function(l) {
    l.enabled = false;
  }), this.enable(r, n);
};
fo.prototype.disable = function(r, n) {
  Array.isArray(r) || (r = [r]);
  const l = [];
  return r.forEach(function(h) {
    const f = this.__find__(h);
    if (f < 0) {
      if (n) return;
      throw new Error("Rules manager: invalid rule name " + h);
    }
    this.__rules__[f].enabled = false, l.push(h);
  }, this), this.__cache__ = null, l;
};
fo.prototype.getRules = function(r) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[r] || [];
};
function ma(r, n, l) {
  this.type = r, this.tag = n, this.attrs = null, this.map = null, this.nesting = l, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = false, this.hidden = false;
}
ma.prototype.attrIndex = function(n) {
  if (!this.attrs) return -1;
  const l = this.attrs;
  for (let h = 0, f = l.length; h < f; h++) if (l[h][0] === n) return h;
  return -1;
};
ma.prototype.attrPush = function(n) {
  this.attrs ? this.attrs.push(n) : this.attrs = [n];
};
ma.prototype.attrSet = function(n, l) {
  const h = this.attrIndex(n), f = [n, l];
  h < 0 ? this.attrPush(f) : this.attrs[h] = f;
};
ma.prototype.attrGet = function(n) {
  const l = this.attrIndex(n);
  let h = null;
  return l >= 0 && (h = this.attrs[l][1]), h;
};
ma.prototype.attrJoin = function(n, l) {
  const h = this.attrIndex(n);
  h < 0 ? this.attrPush([n, l]) : this.attrs[h][1] = this.attrs[h][1] + " " + l;
};
function h2(r, n, l) {
  this.src = r, this.env = l, this.tokens = [], this.inlineMode = false, this.md = n;
}
h2.prototype.Token = ma;
const kR = /\r\n?|\n/g, TR = /\0/g;
function PR(r) {
  let n;
  n = r.src.replace(kR, `
`), n = n.replace(TR, "\uFFFD"), r.src = n;
}
function IR(r) {
  let n;
  r.inlineMode ? (n = new r.Token("inline", "", 0), n.content = r.src, n.map = [0, 1], n.children = [], r.tokens.push(n)) : r.md.block.parse(r.src, r.md, r.env, r.tokens);
}
function ER(r) {
  const n = r.tokens;
  for (let l = 0, h = n.length; l < h; l++) {
    const f = n[l];
    f.type === "inline" && r.md.inline.parse(f.content, r.md, r.env, f.children);
  }
}
function MR(r) {
  return /^<a[>\s]/i.test(r);
}
function DR(r) {
  return /^<\/a\s*>/i.test(r);
}
function RR(r) {
  const n = r.tokens;
  if (r.md.options.linkify) for (let l = 0, h = n.length; l < h; l++) {
    if (n[l].type !== "inline" || !r.md.linkify.pretest(n[l].content)) continue;
    let f = n[l].children, y = 0;
    for (let p = f.length - 1; p >= 0; p--) {
      const s = f[p];
      if (s.type === "link_close") {
        for (p--; f[p].level !== s.level && f[p].type !== "link_open"; ) p--;
        continue;
      }
      if (s.type === "html_inline" && (MR(s.content) && y > 0 && y--, DR(s.content) && y++), !(y > 0) && s.type === "text" && r.md.linkify.test(s.content)) {
        const S = s.content;
        let P = r.md.linkify.match(S);
        const M = [];
        let A = s.level, O = 0;
        P.length > 0 && P[0].index === 0 && p > 0 && f[p - 1].type === "text_special" && (P = P.slice(1));
        for (let j = 0; j < P.length; j++) {
          const L = P[j].url, q = r.md.normalizeLink(L);
          if (!r.md.validateLink(q)) continue;
          let N = P[j].text;
          P[j].schema ? P[j].schema === "mailto:" && !/^mailto:/i.test(N) ? N = r.md.normalizeLinkText("mailto:" + N).replace(/^mailto:/, "") : N = r.md.normalizeLinkText(N) : N = r.md.normalizeLinkText("http://" + N).replace(/^http:\/\//, "");
          const J = P[j].index;
          if (J > O) {
            const oe = new r.Token("text", "", 0);
            oe.content = S.slice(O, J), oe.level = A, M.push(oe);
          }
          const te = new r.Token("link_open", "a", 1);
          te.attrs = [["href", q]], te.level = A++, te.markup = "linkify", te.info = "auto", M.push(te);
          const ne = new r.Token("text", "", 0);
          ne.content = N, ne.level = A, M.push(ne);
          const ae = new r.Token("link_close", "a", -1);
          ae.level = --A, ae.markup = "linkify", ae.info = "auto", M.push(ae), O = P[j].lastIndex;
        }
        if (O < S.length) {
          const j = new r.Token("text", "", 0);
          j.content = S.slice(O), j.level = A, M.push(j);
        }
        n[l].children = f = c2(f, p, M);
      }
    }
  }
}
const f2 = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, AR = /\((c|tm|r)\)/i, zR = /\((c|tm|r)\)/ig, FR = { c: "\xA9", r: "\xAE", tm: "\u2122" };
function LR(r, n) {
  return FR[n.toLowerCase()];
}
function BR(r) {
  let n = 0;
  for (let l = r.length - 1; l >= 0; l--) {
    const h = r[l];
    h.type === "text" && !n && (h.content = h.content.replace(zR, LR)), h.type === "link_open" && h.info === "auto" && n--, h.type === "link_close" && h.info === "auto" && n++;
  }
}
function OR(r) {
  let n = 0;
  for (let l = r.length - 1; l >= 0; l--) {
    const h = r[l];
    h.type === "text" && !n && f2.test(h.content) && (h.content = h.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013")), h.type === "link_open" && h.info === "auto" && n--, h.type === "link_close" && h.info === "auto" && n++;
  }
}
function $R(r) {
  let n;
  if (r.md.options.typographer) for (n = r.tokens.length - 1; n >= 0; n--) r.tokens[n].type === "inline" && (AR.test(r.tokens[n].content) && BR(r.tokens[n].children), f2.test(r.tokens[n].content) && OR(r.tokens[n].children));
}
const NR = /['"]/, $b = /['"]/g, Nb = "\u2019";
function Ap(r, n, l) {
  return r.slice(0, n) + l + r.slice(n + 1);
}
function jR(r, n) {
  let l;
  const h = [];
  for (let f = 0; f < r.length; f++) {
    const y = r[f], p = r[f].level;
    for (l = h.length - 1; l >= 0 && !(h[l].level <= p); l--) ;
    if (h.length = l + 1, y.type !== "text") continue;
    let s = y.content, S = 0, P = s.length;
    e: for (; S < P; ) {
      $b.lastIndex = S;
      const M = $b.exec(s);
      if (!M) break;
      let A = true, O = true;
      S = M.index + 1;
      const j = M[0] === "'";
      let L = 32;
      if (M.index - 1 >= 0) L = s.charCodeAt(M.index - 1);
      else for (l = f - 1; l >= 0 && !(r[l].type === "softbreak" || r[l].type === "hardbreak"); l--) if (r[l].content) {
        L = r[l].content.charCodeAt(r[l].content.length - 1);
        break;
      }
      let q = 32;
      if (S < P) q = s.charCodeAt(S);
      else for (l = f + 1; l < r.length && !(r[l].type === "softbreak" || r[l].type === "hardbreak"); l++) if (r[l].content) {
        q = r[l].content.charCodeAt(0);
        break;
      }
      const N = zh(L) || Ah(String.fromCharCode(L)), J = zh(q) || Ah(String.fromCharCode(q)), te = Rh(L), ne = Rh(q);
      if (ne ? A = false : J && (te || N || (A = false)), te ? O = false : N && (ne || J || (O = false)), q === 34 && M[0] === '"' && L >= 48 && L <= 57 && (O = A = false), A && O && (A = N, O = J), !A && !O) {
        j && (y.content = Ap(y.content, M.index, Nb));
        continue;
      }
      if (O) for (l = h.length - 1; l >= 0; l--) {
        let ae = h[l];
        if (h[l].level < p) break;
        if (ae.single === j && h[l].level === p) {
          ae = h[l];
          let oe, ee;
          j ? (oe = n.md.options.quotes[2], ee = n.md.options.quotes[3]) : (oe = n.md.options.quotes[0], ee = n.md.options.quotes[1]), y.content = Ap(y.content, M.index, ee), r[ae.token].content = Ap(r[ae.token].content, ae.pos, oe), S += ee.length - 1, ae.token === f && (S += oe.length - 1), s = y.content, P = s.length, h.length = l;
          continue e;
        }
      }
      A ? h.push({ token: f, pos: M.index, single: j, level: p }) : O && j && (y.content = Ap(y.content, M.index, Nb));
    }
  }
}
function VR(r) {
  if (r.md.options.typographer) for (let n = r.tokens.length - 1; n >= 0; n--) r.tokens[n].type !== "inline" || !NR.test(r.tokens[n].content) || jR(r.tokens[n].children, r);
}
function UR(r) {
  let n, l;
  const h = r.tokens, f = h.length;
  for (let y = 0; y < f; y++) {
    if (h[y].type !== "inline") continue;
    const p = h[y].children, s = p.length;
    for (n = 0; n < s; n++) p[n].type === "text_special" && (p[n].type = "text");
    for (n = l = 0; n < s; n++) p[n].type === "text" && n + 1 < s && p[n + 1].type === "text" ? p[n + 1].content = p[n].content + p[n + 1].content : (n !== l && (p[l] = p[n]), l++);
    n !== l && (p.length = l);
  }
}
const h0 = [["normalize", PR], ["block", IR], ["inline", ER], ["linkify", RR], ["replacements", $R], ["smartquotes", VR], ["text_join", UR]];
function _v() {
  this.ruler = new fo();
  for (let r = 0; r < h0.length; r++) this.ruler.push(h0[r][0], h0[r][1]);
}
_v.prototype.process = function(r) {
  const n = this.ruler.getRules("");
  for (let l = 0, h = n.length; l < h; l++) n[l](r);
};
_v.prototype.State = h2;
function $a(r, n, l, h) {
  this.src = r, this.md = n, this.env = l, this.tokens = h, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = false, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0;
  const f = this.src;
  for (let y = 0, p = 0, s = 0, S = 0, P = f.length, M = false; p < P; p++) {
    const A = f.charCodeAt(p);
    if (!M) if (yi(A)) {
      s++, A === 9 ? S += 4 - S % 4 : S++;
      continue;
    } else M = true;
    (A === 10 || p === P - 1) && (A !== 10 && p++, this.bMarks.push(y), this.eMarks.push(p), this.tShift.push(s), this.sCount.push(S), this.bsCount.push(0), M = false, s = 0, S = 0, y = p + 1);
  }
  this.bMarks.push(f.length), this.eMarks.push(f.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
$a.prototype.push = function(r, n, l) {
  const h = new ma(r, n, l);
  return h.block = true, l < 0 && this.level--, h.level = this.level, l > 0 && this.level++, this.tokens.push(h), h;
};
$a.prototype.isEmpty = function(n) {
  return this.bMarks[n] + this.tShift[n] >= this.eMarks[n];
};
$a.prototype.skipEmptyLines = function(n) {
  for (let l = this.lineMax; n < l && !(this.bMarks[n] + this.tShift[n] < this.eMarks[n]); n++) ;
  return n;
};
$a.prototype.skipSpaces = function(n) {
  for (let l = this.src.length; n < l; n++) {
    const h = this.src.charCodeAt(n);
    if (!yi(h)) break;
  }
  return n;
};
$a.prototype.skipSpacesBack = function(n, l) {
  if (n <= l) return n;
  for (; n > l; ) if (!yi(this.src.charCodeAt(--n))) return n + 1;
  return n;
};
$a.prototype.skipChars = function(n, l) {
  for (let h = this.src.length; n < h && this.src.charCodeAt(n) === l; n++) ;
  return n;
};
$a.prototype.skipCharsBack = function(n, l, h) {
  if (n <= h) return n;
  for (; n > h; ) if (l !== this.src.charCodeAt(--n)) return n + 1;
  return n;
};
$a.prototype.getLines = function(n, l, h, f) {
  if (n >= l) return "";
  const y = new Array(l - n);
  for (let p = 0, s = n; s < l; s++, p++) {
    let S = 0;
    const P = this.bMarks[s];
    let M = P, A;
    for (s + 1 < l || f ? A = this.eMarks[s] + 1 : A = this.eMarks[s]; M < A && S < h; ) {
      const O = this.src.charCodeAt(M);
      if (yi(O)) O === 9 ? S += 4 - (S + this.bsCount[s]) % 4 : S++;
      else if (M - P < this.tShift[s]) S++;
      else break;
      M++;
    }
    S > h ? y[p] = new Array(S - h + 1).join(" ") + this.src.slice(M, A) : y[p] = this.src.slice(M, A);
  }
  return y.join("");
};
$a.prototype.Token = ma;
const GR = 65536;
function f0(r, n) {
  const l = r.bMarks[n] + r.tShift[n], h = r.eMarks[n];
  return r.src.slice(l, h);
}
function jb(r) {
  const n = [], l = r.length;
  let h = 0, f = r.charCodeAt(h), y = false, p = 0, s = "";
  for (; h < l; ) f === 124 && (y ? (s += r.substring(p, h - 1), p = h) : (n.push(s + r.substring(p, h)), s = "", p = h + 1)), y = f === 92, h++, f = r.charCodeAt(h);
  return n.push(s + r.substring(p)), n;
}
function qR(r, n, l, h) {
  if (n + 2 > l) return false;
  let f = n + 1;
  if (r.sCount[f] < r.blkIndent || r.sCount[f] - r.blkIndent >= 4) return false;
  let y = r.bMarks[f] + r.tShift[f];
  if (y >= r.eMarks[f]) return false;
  const p = r.src.charCodeAt(y++);
  if (p !== 124 && p !== 45 && p !== 58 || y >= r.eMarks[f]) return false;
  const s = r.src.charCodeAt(y++);
  if (s !== 124 && s !== 45 && s !== 58 && !yi(s) || p === 45 && yi(s)) return false;
  for (; y < r.eMarks[f]; ) {
    const ae = r.src.charCodeAt(y);
    if (ae !== 124 && ae !== 45 && ae !== 58 && !yi(ae)) return false;
    y++;
  }
  let S = f0(r, n + 1), P = S.split("|");
  const M = [];
  for (let ae = 0; ae < P.length; ae++) {
    const oe = P[ae].trim();
    if (!oe) {
      if (ae === 0 || ae === P.length - 1) continue;
      return false;
    }
    if (!/^:?-+:?$/.test(oe)) return false;
    oe.charCodeAt(oe.length - 1) === 58 ? M.push(oe.charCodeAt(0) === 58 ? "center" : "right") : oe.charCodeAt(0) === 58 ? M.push("left") : M.push("");
  }
  if (S = f0(r, n).trim(), S.indexOf("|") === -1 || r.sCount[n] - r.blkIndent >= 4) return false;
  P = jb(S), P.length && P[0] === "" && P.shift(), P.length && P[P.length - 1] === "" && P.pop();
  const A = P.length;
  if (A === 0 || A !== M.length) return false;
  if (h) return true;
  const O = r.parentType;
  r.parentType = "table";
  const j = r.md.block.ruler.getRules("blockquote"), L = r.push("table_open", "table", 1), q = [n, 0];
  L.map = q;
  const N = r.push("thead_open", "thead", 1);
  N.map = [n, n + 1];
  const J = r.push("tr_open", "tr", 1);
  J.map = [n, n + 1];
  for (let ae = 0; ae < P.length; ae++) {
    const oe = r.push("th_open", "th", 1);
    M[ae] && (oe.attrs = [["style", "text-align:" + M[ae]]]);
    const ee = r.push("inline", "", 0);
    ee.content = P[ae].trim(), ee.children = [], r.push("th_close", "th", -1);
  }
  r.push("tr_close", "tr", -1), r.push("thead_close", "thead", -1);
  let te, ne = 0;
  for (f = n + 2; f < l && !(r.sCount[f] < r.blkIndent); f++) {
    let ae = false;
    for (let ee = 0, ke = j.length; ee < ke; ee++) if (j[ee](r, f, l, true)) {
      ae = true;
      break;
    }
    if (ae || (S = f0(r, f).trim(), !S) || r.sCount[f] - r.blkIndent >= 4 || (P = jb(S), P.length && P[0] === "" && P.shift(), P.length && P[P.length - 1] === "" && P.pop(), ne += A - P.length, ne > GR)) break;
    if (f === n + 2) {
      const ee = r.push("tbody_open", "tbody", 1);
      ee.map = te = [n + 2, 0];
    }
    const oe = r.push("tr_open", "tr", 1);
    oe.map = [f, f + 1];
    for (let ee = 0; ee < A; ee++) {
      const ke = r.push("td_open", "td", 1);
      M[ee] && (ke.attrs = [["style", "text-align:" + M[ee]]]);
      const ve = r.push("inline", "", 0);
      ve.content = P[ee] ? P[ee].trim() : "", ve.children = [], r.push("td_close", "td", -1);
    }
    r.push("tr_close", "tr", -1);
  }
  return te && (r.push("tbody_close", "tbody", -1), te[1] = f), r.push("table_close", "table", -1), q[1] = f, r.parentType = O, r.line = f, true;
}
function WR(r, n, l) {
  if (r.sCount[n] - r.blkIndent < 4) return false;
  let h = n + 1, f = h;
  for (; h < l; ) {
    if (r.isEmpty(h)) {
      h++;
      continue;
    }
    if (r.sCount[h] - r.blkIndent >= 4) {
      h++, f = h;
      continue;
    }
    break;
  }
  r.line = f;
  const y = r.push("code_block", "code", 0);
  return y.content = r.getLines(n, f, 4 + r.blkIndent, false) + `
`, y.map = [n, r.line], true;
}
function ZR(r, n, l, h) {
  let f = r.bMarks[n] + r.tShift[n], y = r.eMarks[n];
  if (r.sCount[n] - r.blkIndent >= 4 || f + 3 > y) return false;
  const p = r.src.charCodeAt(f);
  if (p !== 126 && p !== 96) return false;
  let s = f;
  f = r.skipChars(f, p);
  let S = f - s;
  if (S < 3) return false;
  const P = r.src.slice(s, f), M = r.src.slice(f, y);
  if (p === 96 && M.indexOf(String.fromCharCode(p)) >= 0) return false;
  if (h) return true;
  let A = n, O = false;
  for (; A++, !(A >= l || (f = s = r.bMarks[A] + r.tShift[A], y = r.eMarks[A], f < y && r.sCount[A] < r.blkIndent)); ) if (r.src.charCodeAt(f) === p && !(r.sCount[A] - r.blkIndent >= 4) && (f = r.skipChars(f, p), !(f - s < S) && (f = r.skipSpaces(f), !(f < y)))) {
    O = true;
    break;
  }
  S = r.sCount[n], r.line = A + (O ? 1 : 0);
  const j = r.push("fence", "code", 0);
  return j.info = M, j.content = r.getLines(n + 1, A, S, true), j.markup = P, j.map = [n, r.line], true;
}
function HR(r, n, l, h) {
  let f = r.bMarks[n] + r.tShift[n], y = r.eMarks[n];
  const p = r.lineMax;
  if (r.sCount[n] - r.blkIndent >= 4 || r.src.charCodeAt(f) !== 62) return false;
  if (h) return true;
  const s = [], S = [], P = [], M = [], A = r.md.block.ruler.getRules("blockquote"), O = r.parentType;
  r.parentType = "blockquote";
  let j = false, L;
  for (L = n; L < l; L++) {
    const ne = r.sCount[L] < r.blkIndent;
    if (f = r.bMarks[L] + r.tShift[L], y = r.eMarks[L], f >= y) break;
    if (r.src.charCodeAt(f++) === 62 && !ne) {
      let oe = r.sCount[L] + 1, ee, ke;
      r.src.charCodeAt(f) === 32 ? (f++, oe++, ke = false, ee = true) : r.src.charCodeAt(f) === 9 ? (ee = true, (r.bsCount[L] + oe) % 4 === 3 ? (f++, oe++, ke = false) : ke = true) : ee = false;
      let ve = oe;
      for (s.push(r.bMarks[L]), r.bMarks[L] = f; f < y; ) {
        const le = r.src.charCodeAt(f);
        if (yi(le)) le === 9 ? ve += 4 - (ve + r.bsCount[L] + (ke ? 1 : 0)) % 4 : ve++;
        else break;
        f++;
      }
      j = f >= y, S.push(r.bsCount[L]), r.bsCount[L] = r.sCount[L] + 1 + (ee ? 1 : 0), P.push(r.sCount[L]), r.sCount[L] = ve - oe, M.push(r.tShift[L]), r.tShift[L] = f - r.bMarks[L];
      continue;
    }
    if (j) break;
    let ae = false;
    for (let oe = 0, ee = A.length; oe < ee; oe++) if (A[oe](r, L, l, true)) {
      ae = true;
      break;
    }
    if (ae) {
      r.lineMax = L, r.blkIndent !== 0 && (s.push(r.bMarks[L]), S.push(r.bsCount[L]), M.push(r.tShift[L]), P.push(r.sCount[L]), r.sCount[L] -= r.blkIndent);
      break;
    }
    s.push(r.bMarks[L]), S.push(r.bsCount[L]), M.push(r.tShift[L]), P.push(r.sCount[L]), r.sCount[L] = -1;
  }
  const q = r.blkIndent;
  r.blkIndent = 0;
  const N = r.push("blockquote_open", "blockquote", 1);
  N.markup = ">";
  const J = [n, 0];
  N.map = J, r.md.block.tokenize(r, n, L);
  const te = r.push("blockquote_close", "blockquote", -1);
  te.markup = ">", r.lineMax = p, r.parentType = O, J[1] = r.line;
  for (let ne = 0; ne < M.length; ne++) r.bMarks[ne + n] = s[ne], r.tShift[ne + n] = M[ne], r.sCount[ne + n] = P[ne], r.bsCount[ne + n] = S[ne];
  return r.blkIndent = q, true;
}
function XR(r, n, l, h) {
  const f = r.eMarks[n];
  if (r.sCount[n] - r.blkIndent >= 4) return false;
  let y = r.bMarks[n] + r.tShift[n];
  const p = r.src.charCodeAt(y++);
  if (p !== 42 && p !== 45 && p !== 95) return false;
  let s = 1;
  for (; y < f; ) {
    const P = r.src.charCodeAt(y++);
    if (P !== p && !yi(P)) return false;
    P === p && s++;
  }
  if (s < 3) return false;
  if (h) return true;
  r.line = n + 1;
  const S = r.push("hr", "hr", 0);
  return S.map = [n, r.line], S.markup = Array(s + 1).join(String.fromCharCode(p)), true;
}
function Vb(r, n) {
  const l = r.eMarks[n];
  let h = r.bMarks[n] + r.tShift[n];
  const f = r.src.charCodeAt(h++);
  if (f !== 42 && f !== 45 && f !== 43) return -1;
  if (h < l) {
    const y = r.src.charCodeAt(h);
    if (!yi(y)) return -1;
  }
  return h;
}
function Ub(r, n) {
  const l = r.bMarks[n] + r.tShift[n], h = r.eMarks[n];
  let f = l;
  if (f + 1 >= h) return -1;
  let y = r.src.charCodeAt(f++);
  if (y < 48 || y > 57) return -1;
  for (; ; ) {
    if (f >= h) return -1;
    if (y = r.src.charCodeAt(f++), y >= 48 && y <= 57) {
      if (f - l >= 10) return -1;
      continue;
    }
    if (y === 41 || y === 46) break;
    return -1;
  }
  return f < h && (y = r.src.charCodeAt(f), !yi(y)) ? -1 : f;
}
function YR(r, n) {
  const l = r.level + 2;
  for (let h = n + 2, f = r.tokens.length - 2; h < f; h++) r.tokens[h].level === l && r.tokens[h].type === "paragraph_open" && (r.tokens[h + 2].hidden = true, r.tokens[h].hidden = true, h += 2);
}
function KR(r, n, l, h) {
  let f, y, p, s, S = n, P = true;
  if (r.sCount[S] - r.blkIndent >= 4 || r.listIndent >= 0 && r.sCount[S] - r.listIndent >= 4 && r.sCount[S] < r.blkIndent) return false;
  let M = false;
  h && r.parentType === "paragraph" && r.sCount[S] >= r.blkIndent && (M = true);
  let A, O, j;
  if ((j = Ub(r, S)) >= 0) {
    if (A = true, p = r.bMarks[S] + r.tShift[S], O = Number(r.src.slice(p, j - 1)), M && O !== 1) return false;
  } else if ((j = Vb(r, S)) >= 0) A = false;
  else return false;
  if (M && r.skipSpaces(j) >= r.eMarks[S]) return false;
  if (h) return true;
  const L = r.src.charCodeAt(j - 1), q = r.tokens.length;
  A ? (s = r.push("ordered_list_open", "ol", 1), O !== 1 && (s.attrs = [["start", O]])) : s = r.push("bullet_list_open", "ul", 1);
  const N = [S, 0];
  s.map = N, s.markup = String.fromCharCode(L);
  let J = false;
  const te = r.md.block.ruler.getRules("list"), ne = r.parentType;
  for (r.parentType = "list"; S < l; ) {
    y = j, f = r.eMarks[S];
    const ae = r.sCount[S] + j - (r.bMarks[S] + r.tShift[S]);
    let oe = ae;
    for (; y < f; ) {
      const dt = r.src.charCodeAt(y);
      if (dt === 9) oe += 4 - (oe + r.bsCount[S]) % 4;
      else if (dt === 32) oe++;
      else break;
      y++;
    }
    const ee = y;
    let ke;
    ee >= f ? ke = 1 : ke = oe - ae, ke > 4 && (ke = 1);
    const ve = ae + ke;
    s = r.push("list_item_open", "li", 1), s.markup = String.fromCharCode(L);
    const le = [S, 0];
    s.map = le, A && (s.info = r.src.slice(p, j - 1));
    const ue = r.tight, be = r.tShift[S], Ve = r.sCount[S], Ge = r.listIndent;
    if (r.listIndent = r.blkIndent, r.blkIndent = ve, r.tight = true, r.tShift[S] = ee - r.bMarks[S], r.sCount[S] = oe, ee >= f && r.isEmpty(S + 1) ? r.line = Math.min(r.line + 2, l) : r.md.block.tokenize(r, S, l, true), (!r.tight || J) && (P = false), J = r.line - S > 1 && r.isEmpty(r.line - 1), r.blkIndent = r.listIndent, r.listIndent = Ge, r.tShift[S] = be, r.sCount[S] = Ve, r.tight = ue, s = r.push("list_item_close", "li", -1), s.markup = String.fromCharCode(L), S = r.line, le[1] = S, S >= l || r.sCount[S] < r.blkIndent || r.sCount[S] - r.blkIndent >= 4) break;
    let et = false;
    for (let dt = 0, Ct = te.length; dt < Ct; dt++) if (te[dt](r, S, l, true)) {
      et = true;
      break;
    }
    if (et) break;
    if (A) {
      if (j = Ub(r, S), j < 0) break;
      p = r.bMarks[S] + r.tShift[S];
    } else if (j = Vb(r, S), j < 0) break;
    if (L !== r.src.charCodeAt(j - 1)) break;
  }
  return A ? s = r.push("ordered_list_close", "ol", -1) : s = r.push("bullet_list_close", "ul", -1), s.markup = String.fromCharCode(L), N[1] = S, r.line = S, r.parentType = ne, P && YR(r, q), true;
}
function JR(r, n, l, h) {
  let f = r.bMarks[n] + r.tShift[n], y = r.eMarks[n], p = n + 1;
  if (r.sCount[n] - r.blkIndent >= 4 || r.src.charCodeAt(f) !== 91) return false;
  function s(te) {
    const ne = r.lineMax;
    if (te >= ne || r.isEmpty(te)) return null;
    let ae = false;
    if (r.sCount[te] - r.blkIndent > 3 && (ae = true), r.sCount[te] < 0 && (ae = true), !ae) {
      const ke = r.md.block.ruler.getRules("reference"), ve = r.parentType;
      r.parentType = "reference";
      let le = false;
      for (let ue = 0, be = ke.length; ue < be; ue++) if (ke[ue](r, te, ne, true)) {
        le = true;
        break;
      }
      if (r.parentType = ve, le) return null;
    }
    const oe = r.bMarks[te] + r.tShift[te], ee = r.eMarks[te];
    return r.src.slice(oe, ee + 1);
  }
  let S = r.src.slice(f, y + 1);
  y = S.length;
  let P = -1;
  for (f = 1; f < y; f++) {
    const te = S.charCodeAt(f);
    if (te === 91) return false;
    if (te === 93) {
      P = f;
      break;
    } else if (te === 10) {
      const ne = s(p);
      ne !== null && (S += ne, y = S.length, p++);
    } else if (te === 92 && (f++, f < y && S.charCodeAt(f) === 10)) {
      const ne = s(p);
      ne !== null && (S += ne, y = S.length, p++);
    }
  }
  if (P < 0 || S.charCodeAt(P + 1) !== 58) return false;
  for (f = P + 2; f < y; f++) {
    const te = S.charCodeAt(f);
    if (te === 10) {
      const ne = s(p);
      ne !== null && (S += ne, y = S.length, p++);
    } else if (!yi(te)) break;
  }
  const M = r.md.helpers.parseLinkDestination(S, f, y);
  if (!M.ok) return false;
  const A = r.md.normalizeLink(M.str);
  if (!r.md.validateLink(A)) return false;
  f = M.pos;
  const O = f, j = p, L = f;
  for (; f < y; f++) {
    const te = S.charCodeAt(f);
    if (te === 10) {
      const ne = s(p);
      ne !== null && (S += ne, y = S.length, p++);
    } else if (!yi(te)) break;
  }
  let q = r.md.helpers.parseLinkTitle(S, f, y);
  for (; q.can_continue; ) {
    const te = s(p);
    if (te === null) break;
    S += te, f = y, y = S.length, p++, q = r.md.helpers.parseLinkTitle(S, f, y, q);
  }
  let N;
  for (f < y && L !== f && q.ok ? (N = q.str, f = q.pos) : (N = "", f = O, p = j); f < y; ) {
    const te = S.charCodeAt(f);
    if (!yi(te)) break;
    f++;
  }
  if (f < y && S.charCodeAt(f) !== 10 && N) for (N = "", f = O, p = j; f < y; ) {
    const te = S.charCodeAt(f);
    if (!yi(te)) break;
    f++;
  }
  if (f < y && S.charCodeAt(f) !== 10) return false;
  const J = bm(S.slice(1, P));
  return J ? (h || (typeof r.env.references > "u" && (r.env.references = {}), typeof r.env.references[J] > "u" && (r.env.references[J] = { title: N, href: A }), r.line = p), true) : false;
}
const QR = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"], eA = "[a-zA-Z_:][a-zA-Z0-9:._-]*", tA = "[^\"'=<>`\\x00-\\x20]+", rA = "'[^']*'", iA = '"[^"]*"', nA = "(?:" + tA + "|" + rA + "|" + iA + ")", oA = "(?:\\s+" + eA + "(?:\\s*=\\s*" + nA + ")?)", p2 = "<[A-Za-z][A-Za-z0-9\\-]*" + oA + "*\\s*\\/?>", m2 = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", aA = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->", sA = "<[?][\\s\\S]*?[?]>", lA = "<![A-Za-z][^>]*>", uA = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", cA = new RegExp("^(?:" + p2 + "|" + m2 + "|" + aA + "|" + sA + "|" + lA + "|" + uA + ")"), dA = new RegExp("^(?:" + p2 + "|" + m2 + ")"), Tc = [[/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp("^</?(" + QR.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true], [new RegExp(dA.source + "\\s*$"), /^$/, false]];
function hA(r, n, l, h) {
  let f = r.bMarks[n] + r.tShift[n], y = r.eMarks[n];
  if (r.sCount[n] - r.blkIndent >= 4 || !r.md.options.html || r.src.charCodeAt(f) !== 60) return false;
  let p = r.src.slice(f, y), s = 0;
  for (; s < Tc.length && !Tc[s][0].test(p); s++) ;
  if (s === Tc.length) return false;
  if (h) return Tc[s][2];
  let S = n + 1;
  if (!Tc[s][1].test(p)) {
    for (; S < l && !(r.sCount[S] < r.blkIndent); S++) if (f = r.bMarks[S] + r.tShift[S], y = r.eMarks[S], p = r.src.slice(f, y), Tc[s][1].test(p)) {
      p.length !== 0 && S++;
      break;
    }
  }
  r.line = S;
  const P = r.push("html_block", "", 0);
  return P.map = [n, S], P.content = r.getLines(n, S, r.blkIndent, true), true;
}
function fA(r, n, l, h) {
  let f = r.bMarks[n] + r.tShift[n], y = r.eMarks[n];
  if (r.sCount[n] - r.blkIndent >= 4) return false;
  let p = r.src.charCodeAt(f);
  if (p !== 35 || f >= y) return false;
  let s = 1;
  for (p = r.src.charCodeAt(++f); p === 35 && f < y && s <= 6; ) s++, p = r.src.charCodeAt(++f);
  if (s > 6 || f < y && !yi(p)) return false;
  if (h) return true;
  y = r.skipSpacesBack(y, f);
  const S = r.skipCharsBack(y, 35, f);
  S > f && yi(r.src.charCodeAt(S - 1)) && (y = S), r.line = n + 1;
  const P = r.push("heading_open", "h" + String(s), 1);
  P.markup = "########".slice(0, s), P.map = [n, r.line];
  const M = r.push("inline", "", 0);
  M.content = r.src.slice(f, y).trim(), M.map = [n, r.line], M.children = [];
  const A = r.push("heading_close", "h" + String(s), -1);
  return A.markup = "########".slice(0, s), true;
}
function pA(r, n, l) {
  const h = r.md.block.ruler.getRules("paragraph");
  if (r.sCount[n] - r.blkIndent >= 4) return false;
  const f = r.parentType;
  r.parentType = "paragraph";
  let y = 0, p, s = n + 1;
  for (; s < l && !r.isEmpty(s); s++) {
    if (r.sCount[s] - r.blkIndent > 3) continue;
    if (r.sCount[s] >= r.blkIndent) {
      let j = r.bMarks[s] + r.tShift[s];
      const L = r.eMarks[s];
      if (j < L && (p = r.src.charCodeAt(j), (p === 45 || p === 61) && (j = r.skipChars(j, p), j = r.skipSpaces(j), j >= L))) {
        y = p === 61 ? 1 : 2;
        break;
      }
    }
    if (r.sCount[s] < 0) continue;
    let O = false;
    for (let j = 0, L = h.length; j < L; j++) if (h[j](r, s, l, true)) {
      O = true;
      break;
    }
    if (O) break;
  }
  if (!y) return false;
  const S = r.getLines(n, s, r.blkIndent, false).trim();
  r.line = s + 1;
  const P = r.push("heading_open", "h" + String(y), 1);
  P.markup = String.fromCharCode(p), P.map = [n, r.line];
  const M = r.push("inline", "", 0);
  M.content = S, M.map = [n, r.line - 1], M.children = [];
  const A = r.push("heading_close", "h" + String(y), -1);
  return A.markup = String.fromCharCode(p), r.parentType = f, true;
}
function mA(r, n, l) {
  const h = r.md.block.ruler.getRules("paragraph"), f = r.parentType;
  let y = n + 1;
  for (r.parentType = "paragraph"; y < l && !r.isEmpty(y); y++) {
    if (r.sCount[y] - r.blkIndent > 3 || r.sCount[y] < 0) continue;
    let P = false;
    for (let M = 0, A = h.length; M < A; M++) if (h[M](r, y, l, true)) {
      P = true;
      break;
    }
    if (P) break;
  }
  const p = r.getLines(n, y, r.blkIndent, false).trim();
  r.line = y;
  const s = r.push("paragraph_open", "p", 1);
  s.map = [n, r.line];
  const S = r.push("inline", "", 0);
  return S.content = p, S.map = [n, r.line], S.children = [], r.push("paragraph_close", "p", -1), r.parentType = f, true;
}
const zp = [["table", qR, ["paragraph", "reference"]], ["code", WR], ["fence", ZR, ["paragraph", "reference", "blockquote", "list"]], ["blockquote", HR, ["paragraph", "reference", "blockquote", "list"]], ["hr", XR, ["paragraph", "reference", "blockquote", "list"]], ["list", KR, ["paragraph", "reference", "blockquote"]], ["reference", JR], ["html_block", hA, ["paragraph", "reference", "blockquote"]], ["heading", fA, ["paragraph", "reference", "blockquote"]], ["lheading", pA], ["paragraph", mA]];
function xm() {
  this.ruler = new fo();
  for (let r = 0; r < zp.length; r++) this.ruler.push(zp[r][0], zp[r][1], { alt: (zp[r][2] || []).slice() });
}
xm.prototype.tokenize = function(r, n, l) {
  const h = this.ruler.getRules(""), f = h.length, y = r.md.options.maxNesting;
  let p = n, s = false;
  for (; p < l && (r.line = p = r.skipEmptyLines(p), !(p >= l || r.sCount[p] < r.blkIndent)); ) {
    if (r.level >= y) {
      r.line = l;
      break;
    }
    const S = r.line;
    let P = false;
    for (let M = 0; M < f; M++) if (P = h[M](r, p, l, false), P) {
      if (S >= r.line) throw new Error("block rule didn't increment state.line");
      break;
    }
    if (!P) throw new Error("none of the block rules matched");
    r.tight = !s, r.isEmpty(r.line - 1) && (s = true), p = r.line, p < l && r.isEmpty(p) && (s = true, p++, r.line = p);
  }
};
xm.prototype.parse = function(r, n, l, h) {
  if (!r) return;
  const f = new this.State(r, n, l, h);
  this.tokenize(f, f.line, f.lineMax);
};
xm.prototype.State = $a;
function qh(r, n, l, h) {
  this.src = r, this.env = l, this.md = n, this.tokens = h, this.tokens_meta = Array(h.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = false, this.linkLevel = 0;
}
qh.prototype.pushPending = function() {
  const r = new ma("text", "", 0);
  return r.content = this.pending, r.level = this.pendingLevel, this.tokens.push(r), this.pending = "", r;
};
qh.prototype.push = function(r, n, l) {
  this.pending && this.pushPending();
  const h = new ma(r, n, l);
  let f = null;
  return l < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), h.level = this.level, l > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], f = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(h), this.tokens_meta.push(f), h;
};
qh.prototype.scanDelims = function(r, n) {
  const l = this.posMax, h = this.src.charCodeAt(r), f = r > 0 ? this.src.charCodeAt(r - 1) : 32;
  let y = r;
  for (; y < l && this.src.charCodeAt(y) === h; ) y++;
  const p = y - r, s = y < l ? this.src.charCodeAt(y) : 32, S = zh(f) || Ah(String.fromCharCode(f)), P = zh(s) || Ah(String.fromCharCode(s)), M = Rh(f), A = Rh(s), O = !A && (!P || M || S), j = !M && (!S || A || P);
  return { can_open: O && (n || !j || S), can_close: j && (n || !O || P), length: p };
};
qh.prototype.Token = ma;
function gA(r) {
  switch (r) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function vA(r, n) {
  let l = r.pos;
  for (; l < r.posMax && !gA(r.src.charCodeAt(l)); ) l++;
  return l === r.pos ? false : (n || (r.pending += r.src.slice(r.pos, l)), r.pos = l, true);
}
const yA = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function _A(r, n) {
  if (!r.md.options.linkify || r.linkLevel > 0) return false;
  const l = r.pos, h = r.posMax;
  if (l + 3 > h || r.src.charCodeAt(l) !== 58 || r.src.charCodeAt(l + 1) !== 47 || r.src.charCodeAt(l + 2) !== 47) return false;
  const f = r.pending.match(yA);
  if (!f) return false;
  const y = f[1], p = r.md.linkify.matchAtStart(r.src.slice(l - y.length));
  if (!p) return false;
  let s = p.url;
  if (s.length <= y.length) return false;
  s = s.replace(/\*+$/, "");
  const S = r.md.normalizeLink(s);
  if (!r.md.validateLink(S)) return false;
  if (!n) {
    r.pending = r.pending.slice(0, -y.length);
    const P = r.push("link_open", "a", 1);
    P.attrs = [["href", S]], P.markup = "linkify", P.info = "auto";
    const M = r.push("text", "", 0);
    M.content = r.md.normalizeLinkText(s);
    const A = r.push("link_close", "a", -1);
    A.markup = "linkify", A.info = "auto";
  }
  return r.pos += s.length - y.length, true;
}
function bA(r, n) {
  let l = r.pos;
  if (r.src.charCodeAt(l) !== 10) return false;
  const h = r.pending.length - 1, f = r.posMax;
  if (!n) if (h >= 0 && r.pending.charCodeAt(h) === 32) if (h >= 1 && r.pending.charCodeAt(h - 1) === 32) {
    let y = h - 1;
    for (; y >= 1 && r.pending.charCodeAt(y - 1) === 32; ) y--;
    r.pending = r.pending.slice(0, y), r.push("hardbreak", "br", 0);
  } else r.pending = r.pending.slice(0, -1), r.push("softbreak", "br", 0);
  else r.push("softbreak", "br", 0);
  for (l++; l < f && yi(r.src.charCodeAt(l)); ) l++;
  return r.pos = l, true;
}
const bv = [];
for (let r = 0; r < 256; r++) bv.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(r) {
  bv[r.charCodeAt(0)] = 1;
});
function xA(r, n) {
  let l = r.pos;
  const h = r.posMax;
  if (r.src.charCodeAt(l) !== 92 || (l++, l >= h)) return false;
  let f = r.src.charCodeAt(l);
  if (f === 10) {
    for (n || r.push("hardbreak", "br", 0), l++; l < h && (f = r.src.charCodeAt(l), !!yi(f)); ) l++;
    return r.pos = l, true;
  }
  let y = r.src[l];
  if (f >= 55296 && f <= 56319 && l + 1 < h) {
    const s = r.src.charCodeAt(l + 1);
    s >= 56320 && s <= 57343 && (y += r.src[l + 1], l++);
  }
  const p = "\\" + y;
  if (!n) {
    const s = r.push("text_special", "", 0);
    f < 256 && bv[f] !== 0 ? s.content = y : s.content = p, s.markup = p, s.info = "escape";
  }
  return r.pos = l + 1, true;
}
function wA(r, n) {
  let l = r.pos;
  if (r.src.charCodeAt(l) !== 96) return false;
  const f = l;
  l++;
  const y = r.posMax;
  for (; l < y && r.src.charCodeAt(l) === 96; ) l++;
  const p = r.src.slice(f, l), s = p.length;
  if (r.backticksScanned && (r.backticks[s] || 0) <= f) return n || (r.pending += p), r.pos += s, true;
  let S = l, P;
  for (; (P = r.src.indexOf("`", S)) !== -1; ) {
    for (S = P + 1; S < y && r.src.charCodeAt(S) === 96; ) S++;
    const M = S - P;
    if (M === s) {
      if (!n) {
        const A = r.push("code_inline", "code", 0);
        A.markup = p, A.content = r.src.slice(l, P).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      return r.pos = S, true;
    }
    r.backticks[M] = P;
  }
  return r.backticksScanned = true, n || (r.pending += p), r.pos += s, true;
}
function CA(r, n) {
  const l = r.pos, h = r.src.charCodeAt(l);
  if (n || h !== 126) return false;
  const f = r.scanDelims(r.pos, true);
  let y = f.length;
  const p = String.fromCharCode(h);
  if (y < 2) return false;
  let s;
  y % 2 && (s = r.push("text", "", 0), s.content = p, y--);
  for (let S = 0; S < y; S += 2) s = r.push("text", "", 0), s.content = p + p, r.delimiters.push({ marker: h, length: 0, token: r.tokens.length - 1, end: -1, open: f.can_open, close: f.can_close });
  return r.pos += f.length, true;
}
function Gb(r, n) {
  let l;
  const h = [], f = n.length;
  for (let y = 0; y < f; y++) {
    const p = n[y];
    if (p.marker !== 126 || p.end === -1) continue;
    const s = n[p.end];
    l = r.tokens[p.token], l.type = "s_open", l.tag = "s", l.nesting = 1, l.markup = "~~", l.content = "", l = r.tokens[s.token], l.type = "s_close", l.tag = "s", l.nesting = -1, l.markup = "~~", l.content = "", r.tokens[s.token - 1].type === "text" && r.tokens[s.token - 1].content === "~" && h.push(s.token - 1);
  }
  for (; h.length; ) {
    const y = h.pop();
    let p = y + 1;
    for (; p < r.tokens.length && r.tokens[p].type === "s_close"; ) p++;
    p--, y !== p && (l = r.tokens[p], r.tokens[p] = r.tokens[y], r.tokens[y] = l);
  }
}
function SA(r) {
  const n = r.tokens_meta, l = r.tokens_meta.length;
  Gb(r, r.delimiters);
  for (let h = 0; h < l; h++) n[h] && n[h].delimiters && Gb(r, n[h].delimiters);
}
const g2 = { tokenize: CA, postProcess: SA };
function kA(r, n) {
  const l = r.pos, h = r.src.charCodeAt(l);
  if (n || h !== 95 && h !== 42) return false;
  const f = r.scanDelims(r.pos, h === 42);
  for (let y = 0; y < f.length; y++) {
    const p = r.push("text", "", 0);
    p.content = String.fromCharCode(h), r.delimiters.push({ marker: h, length: f.length, token: r.tokens.length - 1, end: -1, open: f.can_open, close: f.can_close });
  }
  return r.pos += f.length, true;
}
function qb(r, n) {
  const l = n.length;
  for (let h = l - 1; h >= 0; h--) {
    const f = n[h];
    if (f.marker !== 95 && f.marker !== 42 || f.end === -1) continue;
    const y = n[f.end], p = h > 0 && n[h - 1].end === f.end + 1 && n[h - 1].marker === f.marker && n[h - 1].token === f.token - 1 && n[f.end + 1].token === y.token + 1, s = String.fromCharCode(f.marker), S = r.tokens[f.token];
    S.type = p ? "strong_open" : "em_open", S.tag = p ? "strong" : "em", S.nesting = 1, S.markup = p ? s + s : s, S.content = "";
    const P = r.tokens[y.token];
    P.type = p ? "strong_close" : "em_close", P.tag = p ? "strong" : "em", P.nesting = -1, P.markup = p ? s + s : s, P.content = "", p && (r.tokens[n[h - 1].token].content = "", r.tokens[n[f.end + 1].token].content = "", h--);
  }
}
function TA(r) {
  const n = r.tokens_meta, l = r.tokens_meta.length;
  qb(r, r.delimiters);
  for (let h = 0; h < l; h++) n[h] && n[h].delimiters && qb(r, n[h].delimiters);
}
const v2 = { tokenize: kA, postProcess: TA };
function PA(r, n) {
  let l, h, f, y, p = "", s = "", S = r.pos, P = true;
  if (r.src.charCodeAt(r.pos) !== 91) return false;
  const M = r.pos, A = r.posMax, O = r.pos + 1, j = r.md.helpers.parseLinkLabel(r, r.pos, true);
  if (j < 0) return false;
  let L = j + 1;
  if (L < A && r.src.charCodeAt(L) === 40) {
    for (P = false, L++; L < A && (l = r.src.charCodeAt(L), !(!yi(l) && l !== 10)); L++) ;
    if (L >= A) return false;
    if (S = L, f = r.md.helpers.parseLinkDestination(r.src, L, r.posMax), f.ok) {
      for (p = r.md.normalizeLink(f.str), r.md.validateLink(p) ? L = f.pos : p = "", S = L; L < A && (l = r.src.charCodeAt(L), !(!yi(l) && l !== 10)); L++) ;
      if (f = r.md.helpers.parseLinkTitle(r.src, L, r.posMax), L < A && S !== L && f.ok) for (s = f.str, L = f.pos; L < A && (l = r.src.charCodeAt(L), !(!yi(l) && l !== 10)); L++) ;
    }
    (L >= A || r.src.charCodeAt(L) !== 41) && (P = true), L++;
  }
  if (P) {
    if (typeof r.env.references > "u") return false;
    if (L < A && r.src.charCodeAt(L) === 91 ? (S = L + 1, L = r.md.helpers.parseLinkLabel(r, L), L >= 0 ? h = r.src.slice(S, L++) : L = j + 1) : L = j + 1, h || (h = r.src.slice(O, j)), y = r.env.references[bm(h)], !y) return r.pos = M, false;
    p = y.href, s = y.title;
  }
  if (!n) {
    r.pos = O, r.posMax = j;
    const q = r.push("link_open", "a", 1), N = [["href", p]];
    q.attrs = N, s && N.push(["title", s]), r.linkLevel++, r.md.inline.tokenize(r), r.linkLevel--, r.push("link_close", "a", -1);
  }
  return r.pos = L, r.posMax = A, true;
}
function IA(r, n) {
  let l, h, f, y, p, s, S, P, M = "";
  const A = r.pos, O = r.posMax;
  if (r.src.charCodeAt(r.pos) !== 33 || r.src.charCodeAt(r.pos + 1) !== 91) return false;
  const j = r.pos + 2, L = r.md.helpers.parseLinkLabel(r, r.pos + 1, false);
  if (L < 0) return false;
  if (y = L + 1, y < O && r.src.charCodeAt(y) === 40) {
    for (y++; y < O && (l = r.src.charCodeAt(y), !(!yi(l) && l !== 10)); y++) ;
    if (y >= O) return false;
    for (P = y, s = r.md.helpers.parseLinkDestination(r.src, y, r.posMax), s.ok && (M = r.md.normalizeLink(s.str), r.md.validateLink(M) ? y = s.pos : M = ""), P = y; y < O && (l = r.src.charCodeAt(y), !(!yi(l) && l !== 10)); y++) ;
    if (s = r.md.helpers.parseLinkTitle(r.src, y, r.posMax), y < O && P !== y && s.ok) for (S = s.str, y = s.pos; y < O && (l = r.src.charCodeAt(y), !(!yi(l) && l !== 10)); y++) ;
    else S = "";
    if (y >= O || r.src.charCodeAt(y) !== 41) return r.pos = A, false;
    y++;
  } else {
    if (typeof r.env.references > "u") return false;
    if (y < O && r.src.charCodeAt(y) === 91 ? (P = y + 1, y = r.md.helpers.parseLinkLabel(r, y), y >= 0 ? f = r.src.slice(P, y++) : y = L + 1) : y = L + 1, f || (f = r.src.slice(j, L)), p = r.env.references[bm(f)], !p) return r.pos = A, false;
    M = p.href, S = p.title;
  }
  if (!n) {
    h = r.src.slice(j, L);
    const q = [];
    r.md.inline.parse(h, r.md, r.env, q);
    const N = r.push("image", "img", 0), J = [["src", M], ["alt", ""]];
    N.attrs = J, N.children = q, N.content = h, S && J.push(["title", S]);
  }
  return r.pos = y, r.posMax = O, true;
}
const EA = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, MA = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function DA(r, n) {
  let l = r.pos;
  if (r.src.charCodeAt(l) !== 60) return false;
  const h = r.pos, f = r.posMax;
  for (; ; ) {
    if (++l >= f) return false;
    const p = r.src.charCodeAt(l);
    if (p === 60) return false;
    if (p === 62) break;
  }
  const y = r.src.slice(h + 1, l);
  if (MA.test(y)) {
    const p = r.md.normalizeLink(y);
    if (!r.md.validateLink(p)) return false;
    if (!n) {
      const s = r.push("link_open", "a", 1);
      s.attrs = [["href", p]], s.markup = "autolink", s.info = "auto";
      const S = r.push("text", "", 0);
      S.content = r.md.normalizeLinkText(y);
      const P = r.push("link_close", "a", -1);
      P.markup = "autolink", P.info = "auto";
    }
    return r.pos += y.length + 2, true;
  }
  if (EA.test(y)) {
    const p = r.md.normalizeLink("mailto:" + y);
    if (!r.md.validateLink(p)) return false;
    if (!n) {
      const s = r.push("link_open", "a", 1);
      s.attrs = [["href", p]], s.markup = "autolink", s.info = "auto";
      const S = r.push("text", "", 0);
      S.content = r.md.normalizeLinkText(y);
      const P = r.push("link_close", "a", -1);
      P.markup = "autolink", P.info = "auto";
    }
    return r.pos += y.length + 2, true;
  }
  return false;
}
function RA(r) {
  return /^<a[>\s]/i.test(r);
}
function AA(r) {
  return /^<\/a\s*>/i.test(r);
}
function zA(r) {
  const n = r | 32;
  return n >= 97 && n <= 122;
}
function FA(r, n) {
  if (!r.md.options.html) return false;
  const l = r.posMax, h = r.pos;
  if (r.src.charCodeAt(h) !== 60 || h + 2 >= l) return false;
  const f = r.src.charCodeAt(h + 1);
  if (f !== 33 && f !== 63 && f !== 47 && !zA(f)) return false;
  const y = r.src.slice(h).match(cA);
  if (!y) return false;
  if (!n) {
    const p = r.push("html_inline", "", 0);
    p.content = y[0], RA(p.content) && r.linkLevel++, AA(p.content) && r.linkLevel--;
  }
  return r.pos += y[0].length, true;
}
const LA = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, BA = /^&([a-z][a-z0-9]{1,31});/i;
function OA(r, n) {
  const l = r.pos, h = r.posMax;
  if (r.src.charCodeAt(l) !== 38 || l + 1 >= h) return false;
  if (r.src.charCodeAt(l + 1) === 35) {
    const y = r.src.slice(l).match(LA);
    if (y) {
      if (!n) {
        const p = y[1][0].toLowerCase() === "x" ? parseInt(y[1].slice(1), 16) : parseInt(y[1], 10), s = r.push("text_special", "", 0);
        s.content = yv(p) ? Qp(p) : Qp(65533), s.markup = y[0], s.info = "entity";
      }
      return r.pos += y[0].length, true;
    }
  } else {
    const y = r.src.slice(l).match(BA);
    if (y) {
      const p = u2(y[0]);
      if (p !== y[0]) {
        if (!n) {
          const s = r.push("text_special", "", 0);
          s.content = p, s.markup = y[0], s.info = "entity";
        }
        return r.pos += y[0].length, true;
      }
    }
  }
  return false;
}
function Wb(r) {
  const n = {}, l = r.length;
  if (!l) return;
  let h = 0, f = -2;
  const y = [];
  for (let p = 0; p < l; p++) {
    const s = r[p];
    if (y.push(0), (r[h].marker !== s.marker || f !== s.token - 1) && (h = p), f = s.token, s.length = s.length || 0, !s.close) continue;
    n.hasOwnProperty(s.marker) || (n[s.marker] = [-1, -1, -1, -1, -1, -1]);
    const S = n[s.marker][(s.open ? 3 : 0) + s.length % 3];
    let P = h - y[h] - 1, M = P;
    for (; P > S; P -= y[P] + 1) {
      const A = r[P];
      if (A.marker === s.marker && A.open && A.end < 0) {
        let O = false;
        if ((A.close || s.open) && (A.length + s.length) % 3 === 0 && (A.length % 3 !== 0 || s.length % 3 !== 0) && (O = true), !O) {
          const j = P > 0 && !r[P - 1].open ? y[P - 1] + 1 : 0;
          y[p] = p - P + j, y[P] = j, s.open = false, A.end = p, A.close = false, M = -1, f = -2;
          break;
        }
      }
    }
    M !== -1 && (n[s.marker][(s.open ? 3 : 0) + (s.length || 0) % 3] = M);
  }
}
function $A(r) {
  const n = r.tokens_meta, l = r.tokens_meta.length;
  Wb(r.delimiters);
  for (let h = 0; h < l; h++) n[h] && n[h].delimiters && Wb(n[h].delimiters);
}
function NA(r) {
  let n, l, h = 0;
  const f = r.tokens, y = r.tokens.length;
  for (n = l = 0; n < y; n++) f[n].nesting < 0 && h--, f[n].level = h, f[n].nesting > 0 && h++, f[n].type === "text" && n + 1 < y && f[n + 1].type === "text" ? f[n + 1].content = f[n].content + f[n + 1].content : (n !== l && (f[l] = f[n]), l++);
  n !== l && (f.length = l);
}
const p0 = [["text", vA], ["linkify", _A], ["newline", bA], ["escape", xA], ["backticks", wA], ["strikethrough", g2.tokenize], ["emphasis", v2.tokenize], ["link", PA], ["image", IA], ["autolink", DA], ["html_inline", FA], ["entity", OA]], m0 = [["balance_pairs", $A], ["strikethrough", g2.postProcess], ["emphasis", v2.postProcess], ["fragments_join", NA]];
function Wh() {
  this.ruler = new fo();
  for (let r = 0; r < p0.length; r++) this.ruler.push(p0[r][0], p0[r][1]);
  this.ruler2 = new fo();
  for (let r = 0; r < m0.length; r++) this.ruler2.push(m0[r][0], m0[r][1]);
}
Wh.prototype.skipToken = function(r) {
  const n = r.pos, l = this.ruler.getRules(""), h = l.length, f = r.md.options.maxNesting, y = r.cache;
  if (typeof y[n] < "u") {
    r.pos = y[n];
    return;
  }
  let p = false;
  if (r.level < f) {
    for (let s = 0; s < h; s++) if (r.level++, p = l[s](r, true), r.level--, p) {
      if (n >= r.pos) throw new Error("inline rule didn't increment state.pos");
      break;
    }
  } else r.pos = r.posMax;
  p || r.pos++, y[n] = r.pos;
};
Wh.prototype.tokenize = function(r) {
  const n = this.ruler.getRules(""), l = n.length, h = r.posMax, f = r.md.options.maxNesting;
  for (; r.pos < h; ) {
    const y = r.pos;
    let p = false;
    if (r.level < f) {
      for (let s = 0; s < l; s++) if (p = n[s](r, false), p) {
        if (y >= r.pos) throw new Error("inline rule didn't increment state.pos");
        break;
      }
    }
    if (p) {
      if (r.pos >= h) break;
      continue;
    }
    r.pending += r.src[r.pos++];
  }
  r.pending && r.pushPending();
};
Wh.prototype.parse = function(r, n, l, h) {
  const f = new this.State(r, n, l, h);
  this.tokenize(f);
  const y = this.ruler2.getRules(""), p = y.length;
  for (let s = 0; s < p; s++) y[s](f);
};
Wh.prototype.State = qh;
function jA(r) {
  const n = {};
  r = r || {}, n.src_Any = n2.source, n.src_Cc = o2.source, n.src_Z = s2.source, n.src_P = gv.source, n.src_ZPCc = [n.src_Z, n.src_P, n.src_Cc].join("|"), n.src_ZCc = [n.src_Z, n.src_Cc].join("|");
  const l = "[><\uFF5C]";
  return n.src_pseudo_letter = "(?:(?!" + l + "|" + n.src_ZPCc + ")" + n.src_Any + ")", n.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", n.src_auth = "(?:(?:(?!" + n.src_ZCc + "|[@/\\[\\]()]).)+@)?", n.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", n.src_host_terminator = "(?=$|" + l + "|" + n.src_ZPCc + ")(?!" + (r["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + n.src_ZPCc + "))", n.src_path = "(?:[/?#](?:(?!" + n.src_ZCc + "|" + l + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + n.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + n.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + n.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + n.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + n.src_ZCc + "|[']).)+\\'|\\'(?=" + n.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + n.src_ZCc + "|[.]|$)|" + (r["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + n.src_ZCc + "|$)|;(?!" + n.src_ZCc + "|$)|\\!+(?!" + n.src_ZCc + "|[!]|$)|\\?(?!" + n.src_ZCc + "|[?]|$))+|\\/)?", n.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', n.src_xn = "xn--[a-z0-9\\-]{1,59}", n.src_domain_root = "(?:" + n.src_xn + "|" + n.src_pseudo_letter + "{1,63})", n.src_domain = "(?:" + n.src_xn + "|(?:" + n.src_pseudo_letter + ")|(?:" + n.src_pseudo_letter + "(?:-|" + n.src_pseudo_letter + "){0,61}" + n.src_pseudo_letter + "))", n.src_host = "(?:(?:(?:(?:" + n.src_domain + ")\\.)*" + n.src_domain + "))", n.tpl_host_fuzzy = "(?:" + n.src_ip4 + "|(?:(?:(?:" + n.src_domain + ")\\.)+(?:%TLDS%)))", n.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + n.src_domain + ")\\.)+(?:%TLDS%))", n.src_host_strict = n.src_host + n.src_host_terminator, n.tpl_host_fuzzy_strict = n.tpl_host_fuzzy + n.src_host_terminator, n.src_host_port_strict = n.src_host + n.src_port + n.src_host_terminator, n.tpl_host_port_fuzzy_strict = n.tpl_host_fuzzy + n.src_port + n.src_host_terminator, n.tpl_host_port_no_ip_fuzzy_strict = n.tpl_host_no_ip_fuzzy + n.src_port + n.src_host_terminator, n.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + n.src_ZPCc + "|>|$))", n.tpl_email_fuzzy = "(^|" + l + '|"|\\(|' + n.src_ZCc + ")(" + n.src_email_name + "@" + n.tpl_host_fuzzy_strict + ")", n.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + n.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + n.tpl_host_port_fuzzy_strict + n.src_path + ")", n.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + n.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + n.tpl_host_port_no_ip_fuzzy_strict + n.src_path + ")", n;
}
function Z0(r) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(l) {
    l && Object.keys(l).forEach(function(h) {
      r[h] = l[h];
    });
  }), r;
}
function wm(r) {
  return Object.prototype.toString.call(r);
}
function VA(r) {
  return wm(r) === "[object String]";
}
function UA(r) {
  return wm(r) === "[object Object]";
}
function GA(r) {
  return wm(r) === "[object RegExp]";
}
function Zb(r) {
  return wm(r) === "[object Function]";
}
function qA(r) {
  return r.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
const y2 = { fuzzyLink: true, fuzzyEmail: true, fuzzyIP: false };
function WA(r) {
  return Object.keys(r || {}).reduce(function(n, l) {
    return n || y2.hasOwnProperty(l);
  }, false);
}
const ZA = { "http:": { validate: function(r, n, l) {
  const h = r.slice(n);
  return l.re.http || (l.re.http = new RegExp("^\\/\\/" + l.re.src_auth + l.re.src_host_port_strict + l.re.src_path, "i")), l.re.http.test(h) ? h.match(l.re.http)[0].length : 0;
} }, "https:": "http:", "ftp:": "http:", "//": { validate: function(r, n, l) {
  const h = r.slice(n);
  return l.re.no_http || (l.re.no_http = new RegExp("^" + l.re.src_auth + "(?:localhost|(?:(?:" + l.re.src_domain + ")\\.)+" + l.re.src_domain_root + ")" + l.re.src_port + l.re.src_host_terminator + l.re.src_path, "i")), l.re.no_http.test(h) ? n >= 3 && r[n - 3] === ":" || n >= 3 && r[n - 3] === "/" ? 0 : h.match(l.re.no_http)[0].length : 0;
} }, "mailto:": { validate: function(r, n, l) {
  const h = r.slice(n);
  return l.re.mailto || (l.re.mailto = new RegExp("^" + l.re.src_email_name + "@" + l.re.src_host_strict, "i")), l.re.mailto.test(h) ? h.match(l.re.mailto)[0].length : 0;
} } }, HA = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", XA = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
function YA(r) {
  r.__index__ = -1, r.__text_cache__ = "";
}
function KA(r) {
  return function(n, l) {
    const h = n.slice(l);
    return r.test(h) ? h.match(r)[0].length : 0;
  };
}
function Hb() {
  return function(r, n) {
    n.normalize(r);
  };
}
function em(r) {
  const n = r.re = jA(r.__opts__), l = r.__tlds__.slice();
  r.onCompile(), r.__tlds_replaced__ || l.push(HA), l.push(n.src_xn), n.src_tlds = l.join("|");
  function h(s) {
    return s.replace("%TLDS%", n.src_tlds);
  }
  n.email_fuzzy = RegExp(h(n.tpl_email_fuzzy), "i"), n.link_fuzzy = RegExp(h(n.tpl_link_fuzzy), "i"), n.link_no_ip_fuzzy = RegExp(h(n.tpl_link_no_ip_fuzzy), "i"), n.host_fuzzy_test = RegExp(h(n.tpl_host_fuzzy_test), "i");
  const f = [];
  r.__compiled__ = {};
  function y(s, S) {
    throw new Error('(LinkifyIt) Invalid schema "' + s + '": ' + S);
  }
  Object.keys(r.__schemas__).forEach(function(s) {
    const S = r.__schemas__[s];
    if (S === null) return;
    const P = { validate: null, link: null };
    if (r.__compiled__[s] = P, UA(S)) {
      GA(S.validate) ? P.validate = KA(S.validate) : Zb(S.validate) ? P.validate = S.validate : y(s, S), Zb(S.normalize) ? P.normalize = S.normalize : S.normalize ? y(s, S) : P.normalize = Hb();
      return;
    }
    if (VA(S)) {
      f.push(s);
      return;
    }
    y(s, S);
  }), f.forEach(function(s) {
    r.__compiled__[r.__schemas__[s]] && (r.__compiled__[s].validate = r.__compiled__[r.__schemas__[s]].validate, r.__compiled__[s].normalize = r.__compiled__[r.__schemas__[s]].normalize);
  }), r.__compiled__[""] = { validate: null, normalize: Hb() };
  const p = Object.keys(r.__compiled__).filter(function(s) {
    return s.length > 0 && r.__compiled__[s];
  }).map(qA).join("|");
  r.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + n.src_ZPCc + "))(" + p + ")", "i"), r.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + n.src_ZPCc + "))(" + p + ")", "ig"), r.re.schema_at_start = RegExp("^" + r.re.schema_search.source, "i"), r.re.pretest = RegExp("(" + r.re.schema_test.source + ")|(" + r.re.host_fuzzy_test.source + ")|@", "i"), YA(r);
}
function JA(r, n) {
  const l = r.__index__, h = r.__last_index__, f = r.__text_cache__.slice(l, h);
  this.schema = r.__schema__.toLowerCase(), this.index = l + n, this.lastIndex = h + n, this.raw = f, this.text = f, this.url = f;
}
function H0(r, n) {
  const l = new JA(r, n);
  return r.__compiled__[l.schema].normalize(l, r), l;
}
function Fo(r, n) {
  if (!(this instanceof Fo)) return new Fo(r, n);
  n || WA(r) && (n = r, r = {}), this.__opts__ = Z0({}, y2, n), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = Z0({}, ZA, r), this.__compiled__ = {}, this.__tlds__ = XA, this.__tlds_replaced__ = false, this.re = {}, em(this);
}
Fo.prototype.add = function(n, l) {
  return this.__schemas__[n] = l, em(this), this;
};
Fo.prototype.set = function(n) {
  return this.__opts__ = Z0(this.__opts__, n), this;
};
Fo.prototype.test = function(n) {
  if (this.__text_cache__ = n, this.__index__ = -1, !n.length) return false;
  let l, h, f, y, p, s, S, P, M;
  if (this.re.schema_test.test(n)) {
    for (S = this.re.schema_search, S.lastIndex = 0; (l = S.exec(n)) !== null; ) if (y = this.testSchemaAt(n, l[2], S.lastIndex), y) {
      this.__schema__ = l[2], this.__index__ = l.index + l[1].length, this.__last_index__ = l.index + l[0].length + y;
      break;
    }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (P = n.search(this.re.host_fuzzy_test), P >= 0 && (this.__index__ < 0 || P < this.__index__) && (h = n.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (p = h.index + h[1].length, (this.__index__ < 0 || p < this.__index__) && (this.__schema__ = "", this.__index__ = p, this.__last_index__ = h.index + h[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (M = n.indexOf("@"), M >= 0 && (f = n.match(this.re.email_fuzzy)) !== null && (p = f.index + f[1].length, s = f.index + f[0].length, (this.__index__ < 0 || p < this.__index__ || p === this.__index__ && s > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = p, this.__last_index__ = s))), this.__index__ >= 0;
};
Fo.prototype.pretest = function(n) {
  return this.re.pretest.test(n);
};
Fo.prototype.testSchemaAt = function(n, l, h) {
  return this.__compiled__[l.toLowerCase()] ? this.__compiled__[l.toLowerCase()].validate(n, h, this) : 0;
};
Fo.prototype.match = function(n) {
  const l = [];
  let h = 0;
  this.__index__ >= 0 && this.__text_cache__ === n && (l.push(H0(this, h)), h = this.__last_index__);
  let f = h ? n.slice(h) : n;
  for (; this.test(f); ) l.push(H0(this, h)), f = f.slice(this.__last_index__), h += this.__last_index__;
  return l.length ? l : null;
};
Fo.prototype.matchAtStart = function(n) {
  if (this.__text_cache__ = n, this.__index__ = -1, !n.length) return null;
  const l = this.re.schema_at_start.exec(n);
  if (!l) return null;
  const h = this.testSchemaAt(n, l[2], l[0].length);
  return h ? (this.__schema__ = l[2], this.__index__ = l.index + l[1].length, this.__last_index__ = l.index + l[0].length + h, H0(this, 0)) : null;
};
Fo.prototype.tlds = function(n, l) {
  return n = Array.isArray(n) ? n : [n], l ? (this.__tlds__ = this.__tlds__.concat(n).sort().filter(function(h, f, y) {
    return h !== y[f - 1];
  }).reverse(), em(this), this) : (this.__tlds__ = n.slice(), this.__tlds_replaced__ = true, em(this), this);
};
Fo.prototype.normalize = function(n) {
  n.schema || (n.url = "http://" + n.url), n.schema === "mailto:" && !/^mailto:/i.test(n.url) && (n.url = "mailto:" + n.url);
};
Fo.prototype.onCompile = function() {
};
const Mc = 2147483647, Da = 36, xv = 1, Fh = 26, QA = 38, e8 = 700, _2 = 72, b2 = 128, x2 = "-", t8 = /^xn--/, r8 = /[^\0-\x7F]/, i8 = /[\x2E\u3002\uFF0E\uFF61]/g, n8 = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, g0 = Da - xv, Ra = Math.floor, v0 = String.fromCharCode;
function Fs(r) {
  throw new RangeError(n8[r]);
}
function o8(r, n) {
  const l = [];
  let h = r.length;
  for (; h--; ) l[h] = n(r[h]);
  return l;
}
function w2(r, n) {
  const l = r.split("@");
  let h = "";
  l.length > 1 && (h = l[0] + "@", r = l[1]), r = r.replace(i8, ".");
  const f = r.split("."), y = o8(f, n).join(".");
  return h + y;
}
function C2(r) {
  const n = [];
  let l = 0;
  const h = r.length;
  for (; l < h; ) {
    const f = r.charCodeAt(l++);
    if (f >= 55296 && f <= 56319 && l < h) {
      const y = r.charCodeAt(l++);
      (y & 64512) == 56320 ? n.push(((f & 1023) << 10) + (y & 1023) + 65536) : (n.push(f), l--);
    } else n.push(f);
  }
  return n;
}
const a8 = (r) => String.fromCodePoint(...r), s8 = function(r) {
  return r >= 48 && r < 58 ? 26 + (r - 48) : r >= 65 && r < 91 ? r - 65 : r >= 97 && r < 123 ? r - 97 : Da;
}, Xb = function(r, n) {
  return r + 22 + 75 * (r < 26) - ((n != 0) << 5);
}, S2 = function(r, n, l) {
  let h = 0;
  for (r = l ? Ra(r / e8) : r >> 1, r += Ra(r / n); r > g0 * Fh >> 1; h += Da) r = Ra(r / g0);
  return Ra(h + (g0 + 1) * r / (r + QA));
}, k2 = function(r) {
  const n = [], l = r.length;
  let h = 0, f = b2, y = _2, p = r.lastIndexOf(x2);
  p < 0 && (p = 0);
  for (let s = 0; s < p; ++s) r.charCodeAt(s) >= 128 && Fs("not-basic"), n.push(r.charCodeAt(s));
  for (let s = p > 0 ? p + 1 : 0; s < l; ) {
    const S = h;
    for (let M = 1, A = Da; ; A += Da) {
      s >= l && Fs("invalid-input");
      const O = s8(r.charCodeAt(s++));
      O >= Da && Fs("invalid-input"), O > Ra((Mc - h) / M) && Fs("overflow"), h += O * M;
      const j = A <= y ? xv : A >= y + Fh ? Fh : A - y;
      if (O < j) break;
      const L = Da - j;
      M > Ra(Mc / L) && Fs("overflow"), M *= L;
    }
    const P = n.length + 1;
    y = S2(h - S, P, S == 0), Ra(h / P) > Mc - f && Fs("overflow"), f += Ra(h / P), h %= P, n.splice(h++, 0, f);
  }
  return String.fromCodePoint(...n);
}, T2 = function(r) {
  const n = [];
  r = C2(r);
  const l = r.length;
  let h = b2, f = 0, y = _2;
  for (const S of r) S < 128 && n.push(v0(S));
  const p = n.length;
  let s = p;
  for (p && n.push(x2); s < l; ) {
    let S = Mc;
    for (const M of r) M >= h && M < S && (S = M);
    const P = s + 1;
    S - h > Ra((Mc - f) / P) && Fs("overflow"), f += (S - h) * P, h = S;
    for (const M of r) if (M < h && ++f > Mc && Fs("overflow"), M === h) {
      let A = f;
      for (let O = Da; ; O += Da) {
        const j = O <= y ? xv : O >= y + Fh ? Fh : O - y;
        if (A < j) break;
        const L = A - j, q = Da - j;
        n.push(v0(Xb(j + L % q, 0))), A = Ra(L / q);
      }
      n.push(v0(Xb(A, 0))), y = S2(f, P, s === p), f = 0, ++s;
    }
    ++f, ++h;
  }
  return n.join("");
}, l8 = function(r) {
  return w2(r, function(n) {
    return t8.test(n) ? k2(n.slice(4).toLowerCase()) : n;
  });
}, u8 = function(r) {
  return w2(r, function(n) {
    return r8.test(n) ? "xn--" + T2(n) : n;
  });
}, P2 = { version: "2.3.1", ucs2: { decode: C2, encode: a8 }, decode: k2, encode: T2, toASCII: u8, toUnicode: l8 }, c8 = { options: { html: false, xhtmlOut: false, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 100 }, components: { core: {}, block: {}, inline: {} } }, d8 = { options: { html: false, xhtmlOut: false, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 20 }, components: { core: { rules: ["normalize", "block", "inline", "text_join"] }, block: { rules: ["paragraph"] }, inline: { rules: ["text"], rules2: ["balance_pairs", "fragments_join"] } } }, h8 = { options: { html: true, xhtmlOut: true, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 20 }, components: { core: { rules: ["normalize", "block", "inline", "text_join"] }, block: { rules: ["blockquote", "code", "fence", "heading", "hr", "html_block", "lheading", "list", "reference", "paragraph"] }, inline: { rules: ["autolink", "backticks", "emphasis", "entity", "escape", "html_inline", "image", "link", "newline", "text"], rules2: ["balance_pairs", "emphasis", "fragments_join"] } } }, f8 = { default: c8, zero: d8, commonmark: h8 }, p8 = /^(vbscript|javascript|file|data):/, m8 = /^data:image\/(gif|png|jpeg|webp);/;
function g8(r) {
  const n = r.trim().toLowerCase();
  return p8.test(n) ? m8.test(n) : true;
}
const I2 = ["http:", "https:", "mailto:"];
function v8(r) {
  const n = mv(r, true);
  if (n.hostname && (!n.protocol || I2.indexOf(n.protocol) >= 0)) try {
    n.hostname = P2.toASCII(n.hostname);
  } catch {
  }
  return Gh(pv(n));
}
function y8(r) {
  const n = mv(r, true);
  if (n.hostname && (!n.protocol || I2.indexOf(n.protocol) >= 0)) try {
    n.hostname = P2.toUnicode(n.hostname);
  } catch {
  }
  return Bc(pv(n), Bc.defaultChars + "%");
}
function Zo(r, n) {
  if (!(this instanceof Zo)) return new Zo(r, n);
  n || vv(r) || (n = r || {}, r = "default"), this.inline = new Wh(), this.block = new xm(), this.core = new _v(), this.renderer = new Uc(), this.linkify = new Fo(), this.validateLink = g8, this.normalizeLink = v8, this.normalizeLinkText = y8, this.utils = bR, this.helpers = _m({}, SR), this.options = {}, this.configure(r), n && this.set(n);
}
Zo.prototype.set = function(r) {
  return _m(this.options, r), this;
};
Zo.prototype.configure = function(r) {
  const n = this;
  if (vv(r)) {
    const l = r;
    if (r = f8[l], !r) throw new Error('Wrong `markdown-it` preset "' + l + '", check name');
  }
  if (!r) throw new Error("Wrong `markdown-it` preset, can't be empty");
  return r.options && n.set(r.options), r.components && Object.keys(r.components).forEach(function(l) {
    r.components[l].rules && n[l].ruler.enableOnly(r.components[l].rules), r.components[l].rules2 && n[l].ruler2.enableOnly(r.components[l].rules2);
  }), this;
};
Zo.prototype.enable = function(r, n) {
  let l = [];
  Array.isArray(r) || (r = [r]), ["core", "block", "inline"].forEach(function(f) {
    l = l.concat(this[f].ruler.enable(r, true));
  }, this), l = l.concat(this.inline.ruler2.enable(r, true));
  const h = r.filter(function(f) {
    return l.indexOf(f) < 0;
  });
  if (h.length && !n) throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + h);
  return this;
};
Zo.prototype.disable = function(r, n) {
  let l = [];
  Array.isArray(r) || (r = [r]), ["core", "block", "inline"].forEach(function(f) {
    l = l.concat(this[f].ruler.disable(r, true));
  }, this), l = l.concat(this.inline.ruler2.disable(r, true));
  const h = r.filter(function(f) {
    return l.indexOf(f) < 0;
  });
  if (h.length && !n) throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + h);
  return this;
};
Zo.prototype.use = function(r) {
  const n = [this].concat(Array.prototype.slice.call(arguments, 1));
  return r.apply(r, n), this;
};
Zo.prototype.parse = function(r, n) {
  if (typeof r != "string") throw new Error("Input data should be a String");
  const l = new this.core.State(r, this, n);
  return this.core.process(l), l.tokens;
};
Zo.prototype.render = function(r, n) {
  return n = n || {}, this.renderer.render(this.parse(r, n), this.options, n);
};
Zo.prototype.parseInline = function(r, n) {
  const l = new this.core.State(r, this, n);
  return l.inlineMode = true, this.core.process(l), l.tokens;
};
Zo.prototype.renderInline = function(r, n) {
  return n = n || {}, this.renderer.render(this.parseInline(r, n), this.options, n);
};
const Yb = nt((r) => {
  const n = Fa(new Zo(r.options ?? {}));
  for (const h of r.plugins ?? []) n.value.use(h);
  const l = Ae(() => n.value.render(r.source));
  return () => B("div", { innerHTML: l.value });
}, { props: ["source", "options", "plugins"] }), _8 = `Copyright (C) 2024-Present Heyan Zhu, LZ (lziii180511) , and the Trackmaker contributers. 

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see [https://www.gnu.org/licenses/](https://www.gnu.org/licenses/).
`, b8 = { class: "about-view" }, x8 = { id: "project", class: "section project-section" }, w8 = { class: "project-header" }, C8 = { class: "project-description" }, S8 = { id: "data-sources", class: "section data-sources" }, k8 = ["href"], T8 = { id: "credits", class: "section credits-section" }, P8 = { class: "credit-content" }, I8 = { key: 1 }, E8 = { class: "license-text" }, M8 = { class: "credit-links" }, D8 = ["href"], R8 = ["href"], A8 = { __name: "AboutView", setup(r) {
  Gs((S) => ({ v1e81317d: `${s.value}px` }));
  const n = Vs(), { t: l } = Gn(), h = Ee(false), f = () => {
    h.value = window.innerWidth >= 700;
  };
  Ei(() => {
    f(), window.addEventListener("resize", f);
  }), e1(() => {
    window.removeEventListener("resize", f);
  });
  const y = Ee(new URL("" + new URL("../favicon.svg", import.meta.url).href, import.meta.url).href), p = (S) => S.trim().replace(/\n([\s]*)\n/, `

`).split(`

`).map((P) => P.split(`
`).map((M) => M.trim()).join(" ")).join(`

`).trim(), s = Ee(20);
  return (S, P) => (ut(), Ot("div", b8, [h.value ? (ut(), fr(K(Q1), { key: 0, class: "page-anchor", "show-rail": true, "show-background": true }, { default: je(() => [ze(K(Op), { title: K(l)("aboutView.sections.project"), href: "#project" }, null, 8, ["title"]), ze(K(Op), { title: K(l)("aboutView.sections.dataSource"), href: "#data-sources" }, null, 8, ["title"]), ze(K(Op), { title: K(l)("aboutView.sections.credits"), href: "#credits" }, null, 8, ["title"])]), _: 1 })) : _r("", true), xt("section", x8, [ze(K(Mo), null, { default: je(() => [xt("div", w8, [ze(K(xx), { width: "100", src: y.value, "preview-disabled": "" }, null, 8, ["src"]), ze(K(Y4), null, { default: je(() => [...P[0] || (P[0] = [vr("Trackmaker", -1)])]), _: 1 })]), xt("p", C8, Jt(K(l)("aboutView.description")), 1), ze(K(j_), { class: "license-collapse" }, { default: je(() => [ze(K(V_), { title: "License", name: "license" }, { header: je(() => [ze(K(Os), null, { default: je(() => [ze(K(Tp), null, { default: je(() => [...P[1] || (P[1] = [vr("License", -1)])]), _: 1 }), ze(K(zo), { type: "info", round: "", size: "small" }, { default: je(() => [...P[2] || (P[2] = [vr(" GPL ", -1)])]), _: 1 })]), _: 1 })]), default: je(() => [ze(K(Yb), { source: K(_8), class: "license-text" }, null, 8, ["source"])]), _: 1 })]), _: 1 })]), _: 1 })]), xt("section", S8, [ze(K(Mo), null, { header: je(() => [vr(Jt(K(l)("aboutView.sections.dataSource")), 1)]), footer: je(() => [ze(K(Yb), { source: K(l)("aboutView.mapInaccuracyDeclaration"), class: "markdown-resource" }, null, 8, ["source"])]), default: je(() => [ze(K(Nh), null, { default: je(() => [(ut(true), Ot(jr, null, un(K(s3), (M) => (ut(), fr(K(jh), { key: M.id }, { default: je(() => [ze(K(Os), null, { default: je(() => [ze(K(Tp), null, { default: je(() => [vr(Jt(M.name), 1)]), _: 2 }, 1024), M.license ? (ut(), fr(K(zo), { key: 0, type: "info", round: "", size: "small" }, { default: je(() => [vr(Jt(M.license), 1)]), _: 2 }, 1024)) : _r("", true)]), _: 2 }, 1024)]), suffix: je(() => [xt("a", { href: M.url, class: "external-link" }, [ze(K(xi), { size: s.value, color: K(n).textColor1 }, { default: je(() => [ze(K(z_))]), _: 1 }, 8, ["size", "color"])], 8, k8)]), _: 2 }, 1024))), 128))]), _: 1 })]), _: 1 })]), xt("section", T8, [ze(K(Mo), { hoverable: "" }, { header: je(() => [vr(Jt(K(l)("aboutView.sections.credits")), 1)]), default: je(() => [ze(K(Tp), null, { default: je(() => [vr(Jt(K(l)("aboutView.creditIntro")), 1)]), _: 1 }), ze(K(j_), { accordion: "", class: "credits-list", "trigger-areas": ["arrow", "main"] }, { default: je(() => [(ut(true), Ot(jr, null, un(K(l3).sort((M, A) => M.name.localeCompare(A.name)), (M) => (ut(), fr(K(V_), { key: M.id, title: M.name, name: M.id }, { header: je(() => [ze(K(Os), null, { default: je(() => [vr(Jt(M.name) + " ", 1), M.licenseType.trim() ? (ut(), fr(K(Os), { key: 0 }, { default: je(() => [(ut(true), Ot(jr, null, un(M.licenseType.trim().split(",").map((A) => A.trim()), (A) => (ut(), fr(K(zo), { key: A, round: "", type: "info", size: "small" }, { default: je(() => [vr(Jt(A), 1)]), _: 2 }, 1024))), 128))]), _: 2 }, 1024)) : _r("", true)]), _: 2 }, 1024)]), "header-extra": je(() => [xt("div", M8, [M.homepage ? (ut(), Ot("a", { key: 0, href: M.homepage }, [ze(K(xi), { size: s.value, color: K(n).textColor1 }, { default: je(() => [ze(K(z_))]), _: 1 }, 8, ["size", "color"])], 8, D8)) : _r("", true), M.url ? (ut(), Ot("a", { key: 1, href: M.url }, [ze(K(xi), { size: s.value, color: K(n).textColor1 }, { default: je(() => [M.url.includes("github") ? (ut(), fr(K(Ck), { key: 0 })) : (ut(), fr(K($1), { key: 1 }))]), _: 2 }, 1032, ["size", "color"])], 8, R8)) : _r("", true)])]), default: je(() => [xt("div", P8, [xt("p", null, Jt(M.description), 1), M.license.trim() ? (ut(), fr(K(cx), { key: 0 })) : _r("", true), M.license ? (ut(), Ot("div", I8, [ze(K(Tp), null, { default: je(() => [...P[3] || (P[3] = [xt("strong", null, "License:", -1)])]), _: 1 }), xt("div", E8, [xt("pre", null, Jt(p(M.license)), 1)])])) : _r("", true)])]), _: 2 }, 1032, ["title", "name"]))), 128))]), _: 1 })]), _: 1 })])]));
} }, E2 = Ui(A8, [["__scopeId", "data-v-e19031a0"]]), z8 = Object.freeze(Object.defineProperty({ __proto__: null, default: E2 }, Symbol.toStringTag, { value: "Module" })), F8 = { class: "settings-view" }, L8 = { class: "settings-layout" }, B8 = { class: "settings-content" }, O8 = { style: { display: "flex", "flex-direction": "row", "justify-content": "space-between", "align-items": "center", "min-width": "0" } }, $8 = { key: 0 }, N8 = { key: 1 }, j8 = { key: 2 }, V8 = { key: 3 }, U8 = { key: 0, class: "settings-nav" }, G8 = nt({ __name: "SettingsView", setup(r) {
  const n = new jc(), l = hS(), h = Ae(() => n.isMobile), { width: f } = k1(), y = Ae(() => f.value < 800), p = Ae(() => f.value < 680), { t: s, availableLocales: S } = Gn(), P = cr("settings"), M = Ae(() => [{ title: "appearance", items: [{ title: "theme", type: "radio", items: [{ value: "light", label: s("settings.appearance.theme.options.light") }, { value: "dark", label: s("settings.appearance.theme.options.dark") }, { value: "system", label: s("settings.appearance.theme.options.system") }] }] }, { title: "geolocation", items: [{ title: "watchCompatibilityMode", type: "checkbox" }, { title: "geolocationCorrection", type: "checkbox" }] }, { title: "language", items: [{ title: "interfaceLanguage", type: "select", items: S.map((j) => ({ value: j, label: s(`settings.language.interfaceLanguage.options.${j}`) })) }, { title: "mapLanguage", type: "select", items: S.map((j) => ({ value: j, label: s(`settings.language.mapLanguage.options.${j}`) })).concat([{ value: "interface", label: s("settings.language.mapLanguage.options.interface") }]) }] }, { title: "tools", items: [{ title: "apiDetection", type: "button" }, { title: "imuOrientationTesting", type: "button" }] }]), A = () => {
    l.push("/api-detection");
  }, O = () => {
    l.push("/sensor-demo");
  };
  return Ei(() => {
    P.init();
  }), (j, L) => (ut(), Ot("div", F8, [xt("div", L8, [xt("div", B8, [(ut(true), Ot(jr, null, un(M.value, (q) => (ut(), fr(K(Mo), { id: "appearance", key: q.title, title: j.$t(`settings.${q.title}.title`) }, { default: je(() => [ze(K(Nh), null, { default: je(() => [(ut(true), Ot(jr, null, un(q.items, (N) => (ut(), fr(K(jh), { key: N.title }, { default: je(() => [xt("div", O8, [ze(K(lx), { style: { "white-space": "nowrap" }, tooltip: { trigger: h.value ? "click" : "hover" } }, { tooltip: je(() => [vr(Jt(N.items || N.type === "button" ? j.$t(`settings.${q.title}.${N.title}.title`) : j.$t(`settings.${q.title}.${N.title}`)), 1)]), default: je(() => [vr(Jt(N.items || N.type === "button" ? j.$t(`settings.${q.title}.${N.title}.title`) : j.$t(`settings.${q.title}.${N.title}`)) + " ", 1)]), _: 2 }, 1032, ["tooltip"]), N.type === "radio" ? (ut(), Ot("div", $8, [y.value ? (ut(), fr(K(M0), { key: 1, value: K(P).settings[N.title], "onUpdate:value": (J) => K(P).settings[N.title] = J, options: N.items, "consistent-menu-width": false }, null, 8, ["value", "onUpdate:value", "options"])) : (ut(), fr(K(V5), { key: 0, value: K(P).settings[N.title], "onUpdate:value": (J) => K(P).settings[N.title] = J }, { default: je(() => [(ut(true), Ot(jr, null, un(N.items, (J) => (ut(), fr(K(O5), { key: J.value, value: J.value, label: J.label, checked: K(P).settings[N.title] === J.value }, null, 8, ["value", "label", "checked"]))), 128))]), _: 2 }, 1032, ["value", "onUpdate:value"]))])) : N.type === "select" ? (ut(), Ot("div", N8, [ze(K(M0), { value: K(P).settings[N.title], "onUpdate:value": (J) => K(P).settings[N.title] = J, options: N.items, "consistent-menu-width": false }, null, 8, ["value", "onUpdate:value", "options"])])) : N.type === "checkbox" ? (ut(), Ot("div", j8, [ze(K(kx), { value: K(P).settings[N.title], "onUpdate:value": (J) => K(P).settings[N.title] = J }, null, 8, ["value", "onUpdate:value"])])) : N.type === "button" ? (ut(), Ot("div", V8, [ze(K(Or), { type: "primary", onClick: (J) => N.title === "apiDetection" ? A() : O() }, { default: je(() => [vr(Jt(j.$t(`settings.${q.title}.${N.title}.button`)), 1)]), _: 2 }, 1032, ["onClick"])])) : _r("", true)])]), _: 2 }, 1024))), 128))]), _: 2 }, 1024)]), _: 2 }, 1032, ["title"]))), 128))]), p.value ? _r("", true) : (ut(), Ot("div", U8, [ze(K(Q1), { "show-rail": true, style: { width: "128px" } }, { default: je(() => [(ut(true), Ot(jr, null, un(M.value, (q) => (ut(), fr(K(Op), { key: q.title, title: j.$t(`settings.${q.title}.title`), href: `#${q.title.toLowerCase()}` }, null, 8, ["title", "href"]))), 128))]), _: 1 })]))])]));
} }), M2 = Ui(G8, [["__scopeId", "data-v-8793c34f"]]), q8 = Object.freeze(Object.defineProperty({ __proto__: null, default: M2 }, Symbol.toStringTag, { value: "Module" })), W8 = { class: "api-detection-view" }, Z8 = { class: "api-detection-content" }, H8 = { class: "api-status-item" }, X8 = { class: "api-name" }, Y8 = { key: 0, class: "api-details" }, K8 = { key: 1, class: "api-error" }, J8 = nt({ __name: "ApiDetectionView", setup(r) {
  const { t: n } = Gn(), l = Ee([{ name: "fetch", available: false }, { name: "geolocation", available: false }, { name: "performance", available: false }, { name: "permission", available: false }, { name: "deviceorientation", available: false }, { name: "devicemotion", available: false }]), h = () => {
    try {
      l.value[0].available = typeof fetch < "u", l.value[0].details = l.value[0].available ? n("apiDetection.descriptions.fetch.available") : n("apiDetection.descriptions.fetch.unavailable");
    } catch (f) {
      l.value[0].available = false, l.value[0].error = f instanceof Error ? f.message : "Unknown error";
    }
    try {
      l.value[1].available = "geolocation" in navigator, l.value[1].details = l.value[1].available ? n("apiDetection.descriptions.geolocation.available") : n("apiDetection.descriptions.geolocation.unavailable");
    } catch (f) {
      l.value[1].available = false, l.value[1].error = f instanceof Error ? f.message : "Unknown error";
    }
    try {
      l.value[2].available = "performance" in window, l.value[2].details = l.value[2].available ? n("apiDetection.descriptions.performance.available") : n("apiDetection.descriptions.performance.unavailable");
    } catch (f) {
      l.value[2].available = false, l.value[2].error = f instanceof Error ? f.message : "Unknown error";
    }
    try {
      l.value[3].available = "permissions" in navigator, l.value[3].details = l.value[3].available ? n("apiDetection.descriptions.permission.available") : n("apiDetection.descriptions.permission.unavailable");
    } catch (f) {
      l.value[3].available = false, l.value[3].error = f instanceof Error ? f.message : "Unknown error";
    }
    try {
      l.value[4].available = "DeviceOrientationEvent" in window, l.value[4].details = l.value[4].available ? n("apiDetection.descriptions.deviceorientation.available") : n("apiDetection.descriptions.deviceorientation.unavailable");
    } catch (f) {
      l.value[4].available = false, l.value[4].error = f instanceof Error ? f.message : "Unknown error";
    }
    try {
      l.value[5].available = "DeviceMotionEvent" in window, l.value[5].details = l.value[5].available ? n("apiDetection.descriptions.devicemotion.available") : n("apiDetection.descriptions.devicemotion.unavailable");
    } catch (f) {
      l.value[5].available = false, l.value[5].error = f instanceof Error ? f.message : "Unknown error";
    }
  };
  return Ei(() => {
    h();
  }), (f, y) => (ut(), Ot("div", W8, [xt("div", Z8, [ze(K(Os), { vertical: "", size: "large" }, { default: je(() => [ze(K(Mo), { title: f.$t("apiDetection.title") }, { default: je(() => [ze(K(Lp), { type: "info", "show-icon": false }, { default: je(() => [vr(Jt(f.$t("apiDetection.description")), 1)]), _: 1 }), ze(K(cx), { horizontal: "" }), ze(K(Nh), null, { default: je(() => [(ut(true), Ot(jr, null, un(l.value, (p) => (ut(), fr(K(jh), { key: p.name }, { default: je(() => [xt("div", H8, [xt("div", X8, Jt(f.$t(`apiDetection.apis.${p.name}`)), 1), ze(K(zo), { type: p.available ? "success" : "error", bordered: false }, { default: je(() => [vr(Jt(p.available ? f.$t("apiDetection.available") : f.$t("apiDetection.unavailable")), 1)]), _: 2 }, 1032, ["type"])]), p.details ? (ut(), Ot("div", Y8, [ze(K(lx), null, { default: je(() => [vr(Jt(p.details), 1)]), _: 2 }, 1024)])) : _r("", true), p.error ? (ut(), Ot("div", K8, Jt(f.$t("apiDetection.error")) + ": " + Jt(p.error), 1)) : _r("", true)]), _: 2 }, 1024))), 128))]), _: 1 })]), _: 1 }, 8, ["title"])]), _: 1 })])]));
} }), D2 = Ui(J8, [["__scopeId", "data-v-485d4d3d"]]), Q8 = Object.freeze(Object.defineProperty({ __proto__: null, default: D2 }, Symbol.toStringTag, { value: "Module" })), ez = { class: "sensor-demo-view" }, tz = { class: "demo-container" }, rz = { key: 1, class: "data-section" }, iz = { class: "orientation-stats" }, nz = { class: "orientation-row" }, oz = { class: "orientation-row" }, az = { key: 1, class: "data-section" }, sz = { key: 0, class: "sensor-subsection" }, lz = { class: "xyz-row" }, uz = { class: "other-stats-row" }, cz = { key: 1, class: "sensor-subsection" }, dz = { class: "xyz-row" }, hz = { class: "other-stats-row" }, fz = { key: 1, class: "data-section" }, pz = { class: "gps-stats" }, mz = { class: "gps-row" }, gz = { class: "gps-row" }, vz = { key: 2, class: "data-section" }, yz = nt({ __name: "SensorTestView", setup(r) {
  const { t: n } = Gn(), l = Ee(null), h = Ee(null), f = Ee(null), y = Ee(null), p = Ee(null), s = Ee(null), S = new u3(), P = Ee(null), M = Ee(null), A = Ee(null), O = Ee(null), j = Ee(null), L = Ee(null), q = Ee(null), N = Ae(() => l.value ? l.value.webkitCompassHeading || 360 - l.value.alpha : 0), J = Ae(() => l.value ? Math.sqrt(l.value.beta ** 2 + l.value.gamma ** 2) : 0), te = Ae(() => f.value ? Math.sqrt(f.value.x ** 2 + f.value.y ** 2 + f.value.z ** 2) : 0), ne = Ae(() => y.value ? Math.sqrt(y.value.x ** 2 + y.value.y ** 2 + y.value.z ** 2) : 0);
  Ei(async () => {
    await ae(), await ke();
  }), e1(() => {
    le();
  });
  async function ae() {
    try {
      const ue = await Ea.initialize();
      if (ue.isErr()) {
        console.error("Failed to initialize IMU manager:", ue.error), L.value = "IMU manager initialization failed", q.value = "IMU manager initialization failed";
        return;
      }
      await oe(), await ee();
      const be = Ea.getLastKnownOrientation();
      be && (l.value = be);
      const Ve = Ea.getLastKnownMotion();
      Ve && (f.value = Ve.acceleration, y.value = Ve.gyroscope);
    } catch (ue) {
      console.error("Error initializing IMU manager:", ue), L.value = "Initialization error", q.value = "Initialization error";
    }
  }
  async function oe() {
    try {
      const ue = await Ea.startOrientationUpdates((be) => {
        l.value = be, L.value = null;
      });
      ue.isOk() ? (h.value = ue.value, L.value = null) : L.value = `Start failed: ${ue.error.message}`;
    } catch (ue) {
      L.value = `Error: ${ue instanceof Error ? ue.message : "Unknown error"}`;
    }
  }
  async function ee() {
    try {
      const ue = await Ea.startAccelerationUpdates({ normalizeToENU: true }, (Ve) => {
        f.value = Ve, q.value = null;
      });
      if (ue.isErr()) {
        q.value = `Acceleration start failed: ${ue.error.message}`;
        return;
      }
      const be = await Ea.startGyroscopeUpdates({ normalizeToENU: false }, (Ve) => {
        y.value = Ve, q.value = null;
      });
      if (be.isErr()) {
        ue.isOk() && Ea.stopAccelerationUpdates(ue.value), q.value = `Gyroscope start failed: ${be.error.message}`;
        return;
      }
      p.value = ue.value, s.value = be.value, q.value = null;
    } catch (ue) {
      q.value = `Error: ${ue instanceof Error ? ue.message : "Unknown error"}`;
    }
  }
  async function ke() {
    try {
      const ue = await S.initialize();
      if (ue.isErr()) {
        console.error("Failed to initialize GPS manager:", ue.error), A.value = "GPS manager initialization failed";
        return;
      }
      const be = S.getLastKnownLocation();
      be && be.latitude !== 0 && be.longitude !== 0 && (P.value = be, j.value = /* @__PURE__ */ new Date()), O.value = S.getCurrentBackend(), await ve();
    } catch (ue) {
      console.error("Error initializing GPS manager:", ue), A.value = "GPS initialization error";
    }
  }
  async function ve() {
    try {
      const ue = await S.startLocationUpdates((be) => {
        P.value = be, j.value = /* @__PURE__ */ new Date(), O.value = S.getCurrentBackend(), A.value = null;
      });
      ue.isOk() ? (M.value = ue.value, A.value = null) : A.value = `GPS start failed: ${ue.error.message}`;
    } catch (ue) {
      A.value = `Error: ${ue instanceof Error ? ue.message : "Unknown error"}`;
    }
  }
  function le() {
    h.value !== null && Ea.stopOrientationUpdates(h.value), p.value !== null && Ea.stopAccelerationUpdates(p.value), s.value !== null && Ea.stopGyroscopeUpdates(s.value), M.value !== null && S.stopLocationUpdates(M.value);
  }
  return (ue, be) => (ut(), Ot("div", ez, [xt("div", tz, [ze(K(Mo), { title: K(n)("sensorTest.deviceOrientation.title"), class: "sensor-card" }, { default: je(() => [L.value ? (ut(), fr(K(Lp), { key: 0, type: "error", title: L.value, style: { "margin-top": "16px" } }, null, 8, ["title"])) : _r("", true), l.value ? (ut(), Ot("div", rz, [xt("div", iz, [xt("div", nz, [ze(K(sn), { label: K(n)("sensorTest.deviceOrientation.compassHeading"), value: N.value.toFixed(1), suffix: "\xB0" }, null, 8, ["label", "value"]), ze(K(sn), { label: K(n)("sensorTest.deviceOrientation.alpha"), value: l.value.alpha.toFixed(1), suffix: "\xB0" }, null, 8, ["label", "value"]), ze(K(sn), { label: K(n)("sensorTest.deviceOrientation.beta"), value: l.value.beta.toFixed(1), suffix: "\xB0" }, null, 8, ["label", "value"])]), xt("div", oz, [ze(K(sn), { label: K(n)("sensorTest.deviceOrientation.gamma"), value: l.value.gamma.toFixed(1), suffix: "\xB0" }, null, 8, ["label", "value"]), ze(K(sn), { label: K(n)("sensorTest.deviceOrientation.tiltAngle"), value: J.value.toFixed(1), suffix: "\xB0" }, null, 8, ["label", "value"]), l.value.webkitCompassHeading ? (ut(), fr(K(sn), { key: 0, label: K(n)("sensorTest.deviceOrientation.iosHeading"), value: l.value.webkitCompassHeading.toFixed(1), suffix: "\xB0" }, null, 8, ["label", "value"])) : _r("", true)])])])) : _r("", true)]), _: 1 }, 8, ["title"]), ze(K(Mo), { title: K(n)("sensorTest.deviceMotion.title"), class: "sensor-card" }, { default: je(() => [q.value ? (ut(), fr(K(Lp), { key: 0, type: "error", title: q.value, style: { "margin-top": "16px" } }, null, 8, ["title"])) : _r("", true), f.value || y.value ? (ut(), Ot("div", az, [f.value ? (ut(), Ot("div", sz, [xt("h4", null, Jt(K(n)("sensorTest.deviceMotion.acceleration.title")), 1), xt("div", lz, [ze(K(sn), { label: K(n)("sensorTest.deviceMotion.acceleration.x"), value: f.value.x.toFixed(3), suffix: "m/s\xB2" }, null, 8, ["label", "value"]), ze(K(sn), { label: K(n)("sensorTest.deviceMotion.acceleration.y"), value: f.value.y.toFixed(3), suffix: "m/s\xB2" }, null, 8, ["label", "value"]), ze(K(sn), { label: K(n)("sensorTest.deviceMotion.acceleration.z"), value: f.value.z.toFixed(3), suffix: "m/s\xB2" }, null, 8, ["label", "value"])]), xt("div", uz, [ze(K(sn), { label: K(n)("sensorTest.deviceMotion.acceleration.magnitude"), value: te.value.toFixed(3), suffix: "m/s\xB2" }, null, 8, ["label", "value"])])])) : _r("", true), y.value ? (ut(), Ot("div", cz, [xt("h4", null, Jt(K(n)("sensorTest.deviceMotion.gyroscope.title")), 1), xt("div", dz, [ze(K(sn), { label: K(n)("sensorTest.deviceMotion.gyroscope.x"), value: y.value.x.toFixed(3), suffix: "rad/s" }, null, 8, ["label", "value"]), ze(K(sn), { label: K(n)("sensorTest.deviceMotion.gyroscope.y"), value: y.value.y.toFixed(3), suffix: "rad/s" }, null, 8, ["label", "value"]), ze(K(sn), { label: K(n)("sensorTest.deviceMotion.gyroscope.z"), value: y.value.z.toFixed(3), suffix: "rad/s" }, null, 8, ["label", "value"])]), xt("div", hz, [ze(K(sn), { label: K(n)("sensorTest.deviceMotion.gyroscope.rotationSpeed"), value: ne.value.toFixed(3), suffix: "rad/s" }, null, 8, ["label", "value"])])])) : _r("", true)])) : _r("", true)]), _: 1 }, 8, ["title"]), ze(K(Mo), { title: K(n)("sensorTest.gps.title"), class: "sensor-card" }, { default: je(() => [A.value ? (ut(), fr(K(Lp), { key: 0, type: "error", title: A.value, style: { "margin-top": "16px" } }, null, 8, ["title"])) : _r("", true), P.value ? (ut(), Ot("div", fz, [xt("div", pz, [xt("div", mz, [ze(K(sn), { label: K(n)("sensorTest.gps.latitude"), value: P.value.latitude.toFixed(6), suffix: "\xB0" }, null, 8, ["label", "value"]), ze(K(sn), { label: K(n)("sensorTest.gps.longitude"), value: P.value.longitude.toFixed(6), suffix: "\xB0" }, null, 8, ["label", "value"]), ze(K(sn), { label: K(n)("sensorTest.gps.accuracy"), value: P.value.accuracy.toFixed(1), suffix: "m" }, null, 8, ["label", "value"])]), xt("div", gz, [ze(K(sn), { label: K(n)("sensorTest.gps.backend"), value: O.value === "platform" ? K(n)("sensorTest.gps.backendGPS") : K(n)("sensorTest.gps.backendIP") }, null, 8, ["label", "value"]), j.value ? (ut(), fr(K(sn), { key: 0, label: K(n)("sensorTest.gps.timestamp"), value: j.value.toLocaleTimeString() }, null, 8, ["label", "value"])) : _r("", true)])])])) : A.value ? _r("", true) : (ut(), Ot("div", vz, [xt("p", null, Jt(K(n)("sensorTest.gps.noData")), 1)]))]), _: 1 }, 8, ["title"])])]));
} }), R2 = Ui(yz, [["__scopeId", "data-v-de8efb79"]]), _z = Object.freeze(Object.defineProperty({ __proto__: null, default: R2 }, Symbol.toStringTag, { value: "Module" })), kz = fS({ history: pS("./"), routes: [{ path: "/", redirect: "/tracker" }, { path: "/tracker", name: "Tracker", component: yc() ? r2 : () => vc(() => Promise.resolve().then(() => NM), void 0, import.meta.url), meta: { timeout: 5e3 } }, { path: "/sketch-centre", name: "sketchCentre", component: yc() ? i2 : () => vc(() => Promise.resolve().then(() => AD), void 0, import.meta.url) }, { path: "/about", name: "about", component: yc() ? E2 : () => vc(() => Promise.resolve().then(() => z8), void 0, import.meta.url) }, { path: "/settings", name: "settings", component: yc() ? M2 : () => vc(() => Promise.resolve().then(() => q8), void 0, import.meta.url) }, { path: "/api-detection", name: "apiDetection", component: yc() ? D2 : () => vc(() => Promise.resolve().then(() => Q8), void 0, import.meta.url) }, { path: "/sensor-demo", name: "sensorDemo", component: yc() ? R2 : () => vc(() => Promise.resolve().then(() => _z), void 0, import.meta.url) }] });
export {
  kz as default
};
