var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a, _b, _c, _d;
import { C as e, D as t, M as n, S as r, at as i, ct as a, dt as o, f as s, g as c, h as l, k as u, lt as d, ot as f, p, tt as m, u as h, ut as g, v as _, w as v, xt as y } from "./Card-ClR_k1CL.js";
import { G as b, Q as x, S, Y as C, Z as w, u as T } from "./light-C7QIC2jc.js";
import { At as E, Dt as D, H as O, It as k, Jt as A, Kt as ee, Lt as j, Rt as M, St as te, Tt as N, Ut as ne, Wt as P, Xt as re, Zt as ie, a as ae, c as oe, dt as se, gt as F, h as ce, ht as le, in as ue, kt as de, lt as fe, m as pe, mt as I, ot as me, rt as he, st as ge, tt as _e, ut as ve, v as L, vt as ye, x as be, y as xe } from "./index-Dp5QXTAC.js";
import { A as Se, F as Ce, g as we } from "./text-C2VTd_If.js";
import { E as Te, n as Ee, p as De, r as Oe, t as ke } from "./storage-CA2iFEnv.js";
import { t as Ae } from "./use-locale-BgdwVIoL.js";
import { n as je, t as Me } from "./Suffix-D5qi-ahW.js";
var Ne = /\s/;
function R(e3) {
  for (var t2 = e3.length; t2-- && Ne.test(e3.charAt(t2)); ) ;
  return t2;
}
var Pe = R, Fe = /^\s+/;
function Ie(e3) {
  return e3 && e3.slice(0, Pe(e3) + 1).replace(Fe, ``);
}
var Le = Ie, Re = NaN, ze = /^[-+]0x[0-9a-f]+$/i, Be = /^0b[01]+$/i, Ve = /^0o[0-7]+$/i, He = parseInt;
function Ue(e3) {
  if (typeof e3 == `number`) return e3;
  if (y(e3)) return Re;
  if (O(e3)) {
    var t2 = typeof e3.valueOf == `function` ? e3.valueOf() : e3;
    e3 = O(t2) ? t2 + `` : t2;
  }
  if (typeof e3 != `string`) return e3 === 0 ? e3 : +e3;
  e3 = Le(e3);
  var n2 = Be.test(e3);
  return n2 || Ve.test(e3) ? He(e3.slice(2), n2 ? 2 : 8) : ze.test(e3) ? Re : +e3;
}
var We = Ue, z = { xmlns: `http://www.w3.org/2000/svg`, "xmlns:xlink": `http://www.w3.org/1999/xlink`, viewBox: `0 0 24 24` }, Ge = I({ name: `Route`, render: function(e3, t2) {
  return de(), ve(`svg`, z, t2[0] || (t2[0] = [ge(`g`, { fill: `none`, stroke: `currentColor`, "stroke-width": `2`, "stroke-linecap": `round`, "stroke-linejoin": `round` }, [ge(`circle`, { cx: `6`, cy: `19`, r: `2` }), ge(`circle`, { cx: `18`, cy: `5`, r: `2` }), ge(`path`, { d: `M12 19h4.5a3.5 3.5 0 0 0 0-7h-8a3.5 3.5 0 0 1 0-7H12` })], -1)]));
} }), Ke = { xmlns: `http://www.w3.org/2000/svg`, "xmlns:xlink": `http://www.w3.org/1999/xlink`, viewBox: `0 0 24 24` }, qe = I({ name: `Trash`, render: function(e3, t2) {
  return de(), ve(`svg`, Ke, t2[0] || (t2[0] = [se(`<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 7h16"></path><path d="M10 11v6"></path><path d="M14 11v6"></path><path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2l1-12"></path><path d="M9 7V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3"></path></g>`, 1)]));
} }), Je = { xmlns: `http://www.w3.org/2000/svg`, "xmlns:xlink": `http://www.w3.org/1999/xlink`, viewBox: `0 0 24 24` }, B = I({ name: `Upload`, render: function(e3, t2) {
  return de(), ve(`svg`, Je, t2[0] || (t2[0] = [ge(`g`, { fill: `none`, stroke: `currentColor`, "stroke-width": `2`, "stroke-linecap": `round`, "stroke-linejoin": `round` }, [ge(`path`, { d: `M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2` }), ge(`path`, { d: `M7 9l5-5l5 5` }), ge(`path`, { d: `M12 4v12` })], -1)]));
} }), V = I({ name: `Add`, render() {
  return F(`svg`, { width: `512`, height: `512`, viewBox: `0 0 512 512`, fill: `none`, xmlns: `http://www.w3.org/2000/svg` }, F(`path`, { d: `M256 112V400M400 256H112`, stroke: `currentColor`, "stroke-width": `32`, "stroke-linecap": `round`, "stroke-linejoin": `round` }));
} }), H = I({ name: `Eye`, render() {
  return F(`svg`, { xmlns: `http://www.w3.org/2000/svg`, viewBox: `0 0 512 512` }, F(`path`, { d: `M255.66 112c-77.94 0-157.89 45.11-220.83 135.33a16 16 0 0 0-.27 17.77C82.92 340.8 161.8 400 255.66 400c92.84 0 173.34-59.38 221.79-135.25a16.14 16.14 0 0 0 0-17.47C428.89 172.28 347.8 112 255.66 112z`, fill: `none`, stroke: `currentColor`, "stroke-linecap": `round`, "stroke-linejoin": `round`, "stroke-width": `32` }), F(`circle`, { cx: `256`, cy: `256`, r: `80`, fill: `none`, stroke: `currentColor`, "stroke-miterlimit": `10`, "stroke-width": `32` }));
} }), Ye = I({ name: `EyeOff`, render() {
  return F(`svg`, { xmlns: `http://www.w3.org/2000/svg`, viewBox: `0 0 512 512` }, F(`path`, { d: `M432 448a15.92 15.92 0 0 1-11.31-4.69l-352-352a16 16 0 0 1 22.62-22.62l352 352A16 16 0 0 1 432 448z`, fill: `currentColor` }), F(`path`, { d: `M255.66 384c-41.49 0-81.5-12.28-118.92-36.5c-34.07-22-64.74-53.51-88.7-91v-.08c19.94-28.57 41.78-52.73 65.24-72.21a2 2 0 0 0 .14-2.94L93.5 161.38a2 2 0 0 0-2.71-.12c-24.92 21-48.05 46.76-69.08 76.92a31.92 31.92 0 0 0-.64 35.54c26.41 41.33 60.4 76.14 98.28 100.65C162 402 207.9 416 255.66 416a239.13 239.13 0 0 0 75.8-12.58a2 2 0 0 0 .77-3.31l-21.58-21.58a4 4 0 0 0-3.83-1a204.8 204.8 0 0 1-51.16 6.47z`, fill: `currentColor` }), F(`path`, { d: `M490.84 238.6c-26.46-40.92-60.79-75.68-99.27-100.53C349 110.55 302 96 255.66 96a227.34 227.34 0 0 0-74.89 12.83a2 2 0 0 0-.75 3.31l21.55 21.55a4 4 0 0 0 3.88 1a192.82 192.82 0 0 1 50.21-6.69c40.69 0 80.58 12.43 118.55 37c34.71 22.4 65.74 53.88 89.76 91a.13.13 0 0 1 0 .16a310.72 310.72 0 0 1-64.12 72.73a2 2 0 0 0-.15 2.95l19.9 19.89a2 2 0 0 0 2.7.13a343.49 343.49 0 0 0 68.64-78.48a32.2 32.2 0 0 0-.1-34.78z`, fill: `currentColor` }), F(`path`, { d: `M256 160a95.88 95.88 0 0 0-21.37 2.4a2 2 0 0 0-1 3.38l112.59 112.56a2 2 0 0 0 3.38-1A96 96 0 0 0 256 160z`, fill: `currentColor` }), F(`path`, { d: `M165.78 233.66a2 2 0 0 0-3.38 1a96 96 0 0 0 115 115a2 2 0 0 0 1-3.38z`, fill: `currentColor` }));
} });
const Xe = n(`n-input`);
var Ze = f(`input`, `
 max-width: 100%;
 cursor: text;
 line-height: 1.5;
 z-index: auto;
 outline: none;
 box-sizing: border-box;
 position: relative;
 display: inline-flex;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color .3s var(--n-bezier);
 font-size: var(--n-font-size);
 font-weight: var(--n-font-weight);
 --n-padding-vertical: calc((var(--n-height) - 1.5 * var(--n-font-size)) / 2);
`, [a(`input, textarea`, `
 overflow: hidden;
 flex-grow: 1;
 position: relative;
 `), a(`input-el, textarea-el, input-mirror, textarea-mirror, separator, placeholder`, `
 box-sizing: border-box;
 font-size: inherit;
 line-height: 1.5;
 font-family: inherit;
 border: none;
 outline: none;
 background-color: #0000;
 text-align: inherit;
 transition:
 -webkit-text-fill-color .3s var(--n-bezier),
 caret-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 `), a(`input-el, textarea-el`, `
 -webkit-appearance: none;
 scrollbar-width: none;
 width: 100%;
 min-width: 0;
 text-decoration-color: var(--n-text-decoration-color);
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 background-color: transparent;
 `, [i(`&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb`, `
 width: 0;
 height: 0;
 display: none;
 `), i(`&::placeholder`, `
 color: #0000;
 -webkit-text-fill-color: transparent !important;
 `), i(`&:-webkit-autofill ~`, [a(`placeholder`, `display: none;`)])]), d(`round`, [g(`textarea`, `border-radius: calc(var(--n-height) / 2);`)]), a(`placeholder`, `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: hidden;
 color: var(--n-placeholder-color);
 `, [i(`span`, `
 width: 100%;
 display: inline-block;
 `)]), d(`textarea`, [a(`placeholder`, `overflow: visible;`)]), g(`autosize`, `width: 100%;`), d(`autosize`, [a(`textarea-el, input-el`, `
 position: absolute;
 top: 0;
 left: 0;
 height: 100%;
 `)]), f(`input-wrapper`, `
 overflow: hidden;
 display: inline-flex;
 flex-grow: 1;
 position: relative;
 padding-left: var(--n-padding-left);
 padding-right: var(--n-padding-right);
 `), a(`input-mirror`, `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre;
 pointer-events: none;
 `), a(`input-el`, `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [i(`&[type=password]::-ms-reveal`, `display: none;`), i(`+`, [a(`placeholder`, `
 display: flex;
 align-items: center; 
 `)])]), g(`textarea`, [a(`placeholder`, `white-space: nowrap;`)]), a(`eye`, `
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `), d(`textarea`, `width: 100%;`, [f(`input-word-count`, `
 position: absolute;
 right: var(--n-padding-right);
 bottom: var(--n-padding-vertical);
 `), d(`resizable`, [f(`input-wrapper`, `
 resize: vertical;
 min-height: var(--n-height);
 `)]), a(`textarea-el, textarea-mirror, placeholder`, `
 height: 100%;
 padding-left: 0;
 padding-right: 0;
 padding-top: var(--n-padding-vertical);
 padding-bottom: var(--n-padding-vertical);
 word-break: break-word;
 display: inline-block;
 vertical-align: bottom;
 box-sizing: border-box;
 line-height: var(--n-line-height-textarea);
 margin: 0;
 resize: none;
 white-space: pre-wrap;
 scroll-padding-block-end: var(--n-padding-vertical);
 `), a(`textarea-mirror`, `
 width: 100%;
 pointer-events: none;
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre-wrap;
 overflow-wrap: break-word;
 `)]), d(`pair`, [a(`input-el, placeholder`, `text-align: center;`), a(`separator`, `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 white-space: nowrap;
 `, [f(`icon`, `
 color: var(--n-icon-color);
 `), f(`base-icon`, `
 color: var(--n-icon-color);
 `)])]), d(`disabled`, `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [a(`border`, `border: var(--n-border-disabled);`), a(`input-el, textarea-el`, `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 text-decoration-color: var(--n-text-color-disabled);
 `), a(`placeholder`, `color: var(--n-placeholder-color-disabled);`), a(`separator`, `color: var(--n-text-color-disabled);`, [f(`icon`, `
 color: var(--n-icon-color-disabled);
 `), f(`base-icon`, `
 color: var(--n-icon-color-disabled);
 `)]), f(`input-word-count`, `
 color: var(--n-count-text-color-disabled);
 `), a(`suffix, prefix`, `color: var(--n-text-color-disabled);`, [f(`icon`, `
 color: var(--n-icon-color-disabled);
 `), f(`internal-icon`, `
 color: var(--n-icon-color-disabled);
 `)])]), g(`disabled`, [a(`eye`, `
 color: var(--n-icon-color);
 cursor: pointer;
 `, [i(`&:hover`, `
 color: var(--n-icon-color-hover);
 `), i(`&:active`, `
 color: var(--n-icon-color-pressed);
 `)]), i(`&:hover`, [a(`state-border`, `border: var(--n-border-hover);`)]), d(`focus`, `background-color: var(--n-color-focus);`, [a(`state-border`, `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), a(`border, state-border`, `
 box-sizing: border-box;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border-radius: inherit;
 border: var(--n-border);
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), a(`state-border`, `
 border-color: #0000;
 z-index: 1;
 `), a(`prefix`, `margin-right: 4px;`), a(`suffix`, `
 margin-left: 4px;
 `), a(`suffix, prefix`, `
 transition: color .3s var(--n-bezier);
 flex-wrap: nowrap;
 flex-shrink: 0;
 line-height: var(--n-height);
 white-space: nowrap;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 color: var(--n-suffix-text-color);
 `, [f(`base-loading`, `
 font-size: var(--n-icon-size);
 margin: 0 2px;
 color: var(--n-loading-color);
 `), f(`base-clear`, `
 font-size: var(--n-icon-size);
 `, [a(`placeholder`, [f(`base-icon`, `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)])]), i(`>`, [f(`icon`, `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)]), f(`base-icon`, `
 font-size: var(--n-icon-size);
 `)]), f(`input-word-count`, `
 pointer-events: none;
 line-height: 1.5;
 font-size: .85em;
 color: var(--n-count-text-color);
 transition: color .3s var(--n-bezier);
 margin-left: 4px;
 font-variant: tabular-nums;
 `), [`warning`, `error`].map((e3) => d(`${e3}-status`, [g(`disabled`, [f(`base-loading`, `
 color: var(--n-loading-color-${e3})
 `), a(`input-el, textarea-el`, `
 caret-color: var(--n-caret-color-${e3});
 `), a(`state-border`, `
 border: var(--n-border-${e3});
 `), i(`&:hover`, [a(`state-border`, `
 border: var(--n-border-hover-${e3});
 `)]), i(`&:focus`, `
 background-color: var(--n-color-focus-${e3});
 `, [a(`state-border`, `
 box-shadow: var(--n-box-shadow-focus-${e3});
 border: var(--n-border-focus-${e3});
 `)]), d(`focus`, `
 background-color: var(--n-color-focus-${e3});
 `, [a(`state-border`, `
 box-shadow: var(--n-box-shadow-focus-${e3});
 border: var(--n-border-focus-${e3});
 `)])])]))]);
const U = f(`input`, [d(`disabled`, [a(`input-el, textarea-el`, `
 -webkit-text-fill-color: var(--n-text-color-disabled);
 `)])]);
function Qe(e3) {
  let t2 = 0;
  for (let n2 of e3) t2++;
  return t2;
}
function $e(e3) {
  return e3 === `` || e3 == null;
}
function et(e3) {
  let t2 = A(null);
  function n2() {
    let { value: n3 } = e3;
    if (!(n3 == null ? void 0 : n3.focus)) {
      i2();
      return;
    }
    let { selectionStart: r3, selectionEnd: a2, value: o2 } = n3;
    if (r3 == null || a2 == null) {
      i2();
      return;
    }
    t2.value = { start: r3, end: a2, beforeText: o2.slice(0, r3), afterText: o2.slice(a2) };
  }
  function r2() {
    var n3;
    let { value: r3 } = t2, { value: i3 } = e3;
    if (!r3 || !i3) return;
    let { value: a2 } = i3, { start: o2, beforeText: s2, afterText: c2 } = r3, l2 = a2.length;
    if (a2.endsWith(c2)) l2 = a2.length - c2.length;
    else if (a2.startsWith(s2)) l2 = s2.length;
    else {
      let e4 = s2[o2 - 1], t3 = a2.indexOf(e4, o2 - 1);
      t3 !== -1 && (l2 = t3 + 1);
    }
    (n3 = i3.setSelectionRange) == null || n3.call(i3, l2, l2);
  }
  function i2() {
    t2.value = null;
  }
  return j(e3, i2), { recordCursor: n2, restoreCursor: r2 };
}
var tt = I({ name: `InputWordCount`, setup(t2, { slots: n2 }) {
  let { mergedValueRef: r2, maxlengthRef: i2, mergedClsPrefixRef: a2, countGraphemesRef: o2 } = ye(Xe), s2 = me(() => {
    let { value: e3 } = r2;
    return e3 === null || Array.isArray(e3) ? 0 : (o2.value || Qe)(e3);
  });
  return () => {
    let { value: t3 } = i2, { value: o3 } = r2;
    return F(`span`, { class: `${a2.value}-input-word-count` }, e(n2.default, { value: o3 === null || Array.isArray(o3) ? `` : o3 }, () => [t3 === void 0 ? s2.value : `${s2.value} / ${t3}`]));
  };
} }), nt = I({ name: `Input`, props: Object.assign(Object.assign({}, s.props), { bordered: { type: Boolean, default: void 0 }, type: { type: String, default: `text` }, placeholder: [Array, String], defaultValue: { type: [String, Array], default: null }, value: [String, Array], disabled: { type: Boolean, default: void 0 }, size: String, rows: { type: [Number, String], default: 3 }, round: Boolean, minlength: [String, Number], maxlength: [String, Number], clearable: Boolean, autosize: { type: [Boolean, Object], default: false }, pair: Boolean, separator: String, readonly: { type: [String, Boolean], default: false }, passivelyActivated: Boolean, showPasswordOn: String, stateful: { type: Boolean, default: true }, autofocus: Boolean, inputProps: Object, resizable: { type: Boolean, default: true }, showCount: Boolean, loading: { type: Boolean, default: void 0 }, allowInput: Function, renderCount: Function, onMousedown: Function, onKeydown: Function, onKeyup: [Function, Array], onInput: [Function, Array], onFocus: [Function, Array], onBlur: [Function, Array], onClick: [Function, Array], onChange: [Function, Array], onClear: [Function, Array], countGraphemes: Function, status: String, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], textDecoration: [String, Array], attrSize: { type: Number, default: 20 }, onInputBlur: [Function, Array], onInputFocus: [Function, Array], onDeactivate: [Function, Array], onActivate: [Function, Array], onWrapperFocus: [Function, Array], onWrapperBlur: [Function, Array], internalDeactivateOnEnter: Boolean, internalForceFocus: Boolean, internalLoadingBeforeSuffix: { type: Boolean, default: true }, showPasswordToggle: Boolean }), slots: Object, setup(e3) {
  let { mergedClsPrefixRef: n2, mergedBorderedRef: r2, inlineThemeDisabled: i2, mergedRtlRef: a2 } = _(e3), u2 = s(`Input`, `-input`, Ze, Ce, e3, n2);
  De && p(`-input-safari`, U, n2);
  let d2 = A(null), f2 = A(null), h2 = A(null), g2 = A(null), v2 = A(null), y2 = A(null), S2 = A(null), T2 = et(S2), O2 = A(null), { localeRef: k2 } = Ae(`Input`), ee2 = A(e3.defaultValue), N2 = b(ie(e3, `value`), ee2), ne2 = Te(e3), { mergedSizeRef: P2, mergedDisabledRef: re2, mergedStatusRef: ae2 } = ne2, oe2 = A(false), se2 = A(false), F2 = A(false), ce2 = A(false), ue2 = null, de2 = me(() => {
    let { placeholder: t2, pair: n3 } = e3;
    return n3 ? Array.isArray(t2) ? t2 : t2 === void 0 ? [``, ``] : [t2, t2] : t2 === void 0 ? [k2.value.placeholder] : [t2];
  }), fe2 = me(() => {
    let { value: e4 } = F2, { value: t2 } = N2, { value: n3 } = de2;
    return !e4 && ($e(t2) || Array.isArray(t2) && $e(t2[0])) && n3[0];
  }), pe2 = me(() => {
    let { value: e4 } = F2, { value: t2 } = N2, { value: n3 } = de2;
    return !e4 && n3[1] && ($e(t2) || Array.isArray(t2) && $e(t2[1]));
  }), I2 = C(() => e3.internalForceFocus || oe2.value), he2 = C(() => {
    if (re2.value || e3.readonly || !e3.clearable || !I2.value && !se2.value) return false;
    let { value: t2 } = N2, { value: n3 } = I2;
    return e3.pair ? !!(Array.isArray(t2) && (t2[0] || t2[1])) && (se2.value || n3) : !!t2 && (se2.value || n3);
  }), ge2 = me(() => {
    let { showPasswordOn: t2 } = e3;
    if (t2) return t2;
    if (e3.showPasswordToggle) return `click`;
  }), _e2 = A(false), ve2 = me(() => {
    let { textDecoration: t2 } = e3;
    return t2 ? Array.isArray(t2) ? t2.map((e4) => ({ textDecoration: e4 })) : [{ textDecoration: t2 }] : [``, ``];
  }), L2 = A(void 0), ye2 = () => {
    var _a2, _b2;
    if (e3.type === `textarea`) {
      let { autosize: t2 } = e3;
      if (t2 && (L2.value = (_b2 = (_a2 = O2.value) == null ? void 0 : _a2.$el) == null ? void 0 : _b2.offsetWidth), !f2.value || typeof t2 == `boolean`) return;
      let { paddingTop: n3, paddingBottom: r3, lineHeight: i3 } = window.getComputedStyle(f2.value), a3 = Number(n3.slice(0, -2)), o2 = Number(r3.slice(0, -2)), s2 = Number(i3.slice(0, -2)), { value: c2 } = h2;
      if (!c2) return;
      if (t2.minRows) {
        let e4 = Math.max(t2.minRows, 1), n4 = `${a3 + o2 + s2 * e4}px`;
        c2.style.minHeight = n4;
      }
      if (t2.maxRows) {
        let e4 = `${a3 + o2 + s2 * t2.maxRows}px`;
        c2.style.maxHeight = e4;
      }
    }
  }, be2 = me(() => {
    let { maxlength: t2 } = e3;
    return t2 === void 0 ? void 0 : Number(t2);
  });
  D(() => {
    let { value: e4 } = N2;
    Array.isArray(e4) || ut2(e4);
  });
  let xe2 = le().proxy;
  function Se2(n3, r3) {
    let { onUpdateValue: i3, "onUpdate:value": a3, onInput: o2 } = e3, { nTriggerFormInput: s2 } = ne2;
    i3 && t(i3, n3, r3), a3 && t(a3, n3, r3), o2 && t(o2, n3, r3), ee2.value = n3, s2();
  }
  function we2(n3, r3) {
    let { onChange: i3 } = e3, { nTriggerFormChange: a3 } = ne2;
    i3 && t(i3, n3, r3), ee2.value = n3, a3();
  }
  function Ee2(n3) {
    let { onBlur: r3 } = e3, { nTriggerFormBlur: i3 } = ne2;
    r3 && t(r3, n3), i3();
  }
  function Oe2(n3) {
    let { onFocus: r3 } = e3, { nTriggerFormFocus: i3 } = ne2;
    r3 && t(r3, n3), i3();
  }
  function ke2(n3) {
    let { onClear: r3 } = e3;
    r3 && t(r3, n3);
  }
  function je2(n3) {
    let { onInputBlur: r3 } = e3;
    r3 && t(r3, n3);
  }
  function Me2(n3) {
    let { onInputFocus: r3 } = e3;
    r3 && t(r3, n3);
  }
  function Ne2() {
    let { onDeactivate: n3 } = e3;
    n3 && t(n3);
  }
  function R2() {
    let { onActivate: n3 } = e3;
    n3 && t(n3);
  }
  function Pe2(n3) {
    let { onClick: r3 } = e3;
    r3 && t(r3, n3);
  }
  function Fe2(n3) {
    let { onWrapperFocus: r3 } = e3;
    r3 && t(r3, n3);
  }
  function Ie2(n3) {
    let { onWrapperBlur: r3 } = e3;
    r3 && t(r3, n3);
  }
  function Le2() {
    F2.value = true;
  }
  function Re2(e4) {
    F2.value = false, e4.target === y2.value ? ze2(e4, 1) : ze2(e4, 0);
  }
  function ze2(t2, n3 = 0, r3 = `input`) {
    let i3 = t2.target.value;
    if (ut2(i3), t2 instanceof InputEvent && !t2.isComposing && (F2.value = false), e3.type === `textarea`) {
      let { value: e4 } = O2;
      e4 && e4.syncUnifiedContainer();
    }
    if (ue2 = i3, F2.value) return;
    T2.recordCursor();
    let a3 = Be2(i3);
    if (a3) if (!e3.pair) r3 === `input` ? Se2(i3, { source: n3 }) : we2(i3, { source: n3 });
    else {
      let { value: e4 } = N2;
      e4 = Array.isArray(e4) ? [e4[0], e4[1]] : [``, ``], e4[n3] = i3, r3 === `input` ? Se2(e4, { source: n3 }) : we2(e4, { source: n3 });
    }
    xe2.$forceUpdate(), a3 || te(T2.restoreCursor);
  }
  function Be2(t2) {
    let { countGraphemes: n3, maxlength: r3, minlength: i3 } = e3;
    if (n3) {
      let e4;
      if (r3 !== void 0 && (e4 === void 0 && (e4 = n3(t2)), e4 > Number(r3)) || i3 !== void 0 && (e4 === void 0 && (e4 = n3(t2)), e4 < Number(r3))) return false;
    }
    let { allowInput: a3 } = e3;
    return typeof a3 == `function` ? a3(t2) : true;
  }
  function Ve2(e4) {
    je2(e4), e4.relatedTarget === d2.value && Ne2(), e4.relatedTarget !== null && (e4.relatedTarget === v2.value || e4.relatedTarget === y2.value || e4.relatedTarget === f2.value) || (ce2.value = false), z2(e4, `blur`), S2.value = null;
  }
  function He2(e4, t2) {
    Me2(e4), oe2.value = true, ce2.value = true, R2(), z2(e4, `focus`), t2 === 0 ? S2.value = v2.value : t2 === 1 ? S2.value = y2.value : t2 === 2 && (S2.value = f2.value);
  }
  function Ue2(t2) {
    e3.passivelyActivated && (Ie2(t2), z2(t2, `blur`));
  }
  function We2(t2) {
    e3.passivelyActivated && (oe2.value = true, Fe2(t2), z2(t2, `focus`));
  }
  function z2(e4, t2) {
    e4.relatedTarget !== null && (e4.relatedTarget === v2.value || e4.relatedTarget === y2.value || e4.relatedTarget === f2.value || e4.relatedTarget === d2.value) || (t2 === `focus` ? (Oe2(e4), oe2.value = true) : t2 === `blur` && (Ee2(e4), oe2.value = false));
  }
  function Ge2(e4, t2) {
    ze2(e4, t2, `change`);
  }
  function Ke2(e4) {
    Pe2(e4);
  }
  function qe2(e4) {
    ke2(e4), Je2();
  }
  function Je2() {
    e3.pair ? (Se2([``, ``], { source: `clear` }), we2([``, ``], { source: `clear` })) : (Se2(``, { source: `clear` }), we2(``, { source: `clear` }));
  }
  function B2(t2) {
    let { onMousedown: n3 } = e3;
    n3 && n3(t2);
    let { tagName: r3 } = t2.target;
    if (r3 !== `INPUT` && r3 !== `TEXTAREA`) {
      if (e3.resizable) {
        let { value: e4 } = d2;
        if (e4) {
          let { left: n4, top: r4, width: i3, height: a3 } = e4.getBoundingClientRect();
          if (n4 + i3 - 14 < t2.clientX && t2.clientX < n4 + i3 && r4 + a3 - 14 < t2.clientY && t2.clientY < r4 + a3) return;
        }
      }
      t2.preventDefault(), oe2.value || at2();
    }
  }
  function V2() {
    var t2;
    se2.value = true, e3.type === `textarea` && ((t2 = O2.value) == null || t2.handleMouseEnterWrapper());
  }
  function H2() {
    var t2;
    se2.value = false, e3.type === `textarea` && ((t2 = O2.value) == null || t2.handleMouseLeaveWrapper());
  }
  function Ye2() {
    re2.value || ge2.value === `click` && (_e2.value = !_e2.value);
  }
  function Qe2(e4) {
    if (re2.value) return;
    e4.preventDefault();
    let t2 = (e5) => {
      e5.preventDefault(), w(`mouseup`, document, t2);
    };
    if (x(`mouseup`, document, t2), ge2.value !== `mousedown`) return;
    _e2.value = true;
    let n3 = () => {
      _e2.value = false, w(`mouseup`, document, n3);
    };
    x(`mouseup`, document, n3);
  }
  function tt2(n3) {
    e3.onKeyup && t(e3.onKeyup, n3);
  }
  function nt2(n3) {
    switch (e3.onKeydown && t(e3.onKeydown, n3), n3.key) {
      case `Escape`:
        it2();
        break;
      case `Enter`:
        rt2(n3);
        break;
    }
  }
  function rt2(t2) {
    var n3, r3;
    if (e3.passivelyActivated) {
      let { value: i3 } = ce2;
      if (i3) {
        e3.internalDeactivateOnEnter && it2();
        return;
      }
      t2.preventDefault(), e3.type === `textarea` ? (n3 = f2.value) == null || n3.focus() : (r3 = v2.value) == null || r3.focus();
    }
  }
  function it2() {
    e3.passivelyActivated && (ce2.value = false, te(() => {
      var e4;
      (e4 = d2.value) == null || e4.focus();
    }));
  }
  function at2() {
    var t2, n3, r3;
    re2.value || (e3.passivelyActivated ? (t2 = d2.value) == null || t2.focus() : ((n3 = f2.value) == null || n3.focus(), (r3 = v2.value) == null || r3.focus()));
  }
  function W2() {
    var _a2;
    ((_a2 = d2.value) == null ? void 0 : _a2.contains(document.activeElement)) && document.activeElement.blur();
  }
  function ot2() {
    var e4, t2;
    (e4 = f2.value) == null || e4.select(), (t2 = v2.value) == null || t2.select();
  }
  function st2() {
    re2.value || (f2.value ? f2.value.focus() : v2.value && v2.value.focus());
  }
  function ct2() {
    let { value: e4 } = d2;
    (e4 == null ? void 0 : e4.contains(document.activeElement)) && e4 !== document.activeElement && it2();
  }
  function lt2(t2) {
    if (e3.type === `textarea`) {
      let { value: e4 } = f2;
      e4 == null ? void 0 : e4.scrollTo(t2);
    } else {
      let { value: e4 } = v2;
      e4 == null ? void 0 : e4.scrollTo(t2);
    }
  }
  function ut2(t2) {
    let { type: n3, pair: r3, autosize: i3 } = e3;
    if (!r3 && i3) if (n3 === `textarea`) {
      let { value: e4 } = h2;
      e4 && (e4.textContent = `${t2 ?? ``}\r
`);
    } else {
      let { value: e4 } = g2;
      e4 && (t2 ? e4.textContent = t2 : e4.innerHTML = `&nbsp;`);
    }
  }
  function dt2() {
    ye2();
  }
  let ft2 = A({ top: `0` });
  function pt2(e4) {
    var t2;
    let { scrollTop: n3 } = e4.target;
    ft2.value.top = `${-n3}px`, (t2 = O2.value) == null || t2.syncUnifiedContainer();
  }
  let mt2 = null;
  M(() => {
    let { autosize: t2, type: n3 } = e3;
    t2 && n3 === `textarea` ? mt2 = j(N2, (e4) => {
      !Array.isArray(e4) && e4 !== ue2 && ut2(e4);
    }) : mt2 == null ? void 0 : mt2();
  });
  let ht2 = null;
  M(() => {
    e3.type === `textarea` ? ht2 = j(N2, (e4) => {
      var t2;
      !Array.isArray(e4) && e4 !== ue2 && ((t2 = O2.value) == null || t2.syncUnifiedContainer());
    }) : ht2 == null ? void 0 : ht2();
  }), E(Xe, { mergedValueRef: N2, maxlengthRef: be2, mergedClsPrefixRef: n2, countGraphemesRef: ie(e3, `countGraphemes`) });
  let gt2 = { wrapperElRef: d2, inputElRef: v2, textareaElRef: f2, isCompositing: F2, clear: Je2, focus: at2, blur: W2, select: ot2, deactivate: ct2, activate: st2, scrollTo: lt2 }, _t2 = l(`Input`, a2, n2), vt2 = me(() => {
    let { value: e4 } = P2, { common: { cubicBezierEaseInOut: t2 }, self: { color: n3, borderRadius: r3, textColor: i3, caretColor: a3, caretColorError: s2, caretColorWarning: c2, textDecorationColor: l2, border: d3, borderDisabled: f3, borderHover: p2, borderFocus: h3, placeholderColor: g3, placeholderColorDisabled: _2, lineHeightTextarea: v3, colorDisabled: y3, colorFocus: b2, textColorDisabled: x2, boxShadowFocus: S3, iconSize: C2, colorFocusWarning: w2, boxShadowFocusWarning: T3, borderWarning: E2, borderFocusWarning: D2, borderHoverWarning: O3, colorFocusError: k3, boxShadowFocusError: A2, borderError: ee3, borderFocusError: j2, borderHoverError: M2, clearSize: te2, clearColor: N3, clearColorHover: ne3, clearColorPressed: re3, iconColor: ie2, iconColorDisabled: ae3, suffixTextColor: oe3, countTextColor: se3, countTextColorDisabled: F3, iconColorHover: ce3, iconColorPressed: le2, loadingColor: ue3, loadingColorError: de3, loadingColorWarning: fe3, fontWeight: pe3, [o(`padding`, e4)]: I3, [o(`fontSize`, e4)]: me2, [o(`height`, e4)]: he3 } } = u2.value, { left: ge3, right: _e3 } = m(I3);
    return { "--n-bezier": t2, "--n-count-text-color": se3, "--n-count-text-color-disabled": F3, "--n-color": n3, "--n-font-size": me2, "--n-font-weight": pe3, "--n-border-radius": r3, "--n-height": he3, "--n-padding-left": ge3, "--n-padding-right": _e3, "--n-text-color": i3, "--n-caret-color": a3, "--n-text-decoration-color": l2, "--n-border": d3, "--n-border-disabled": f3, "--n-border-hover": p2, "--n-border-focus": h3, "--n-placeholder-color": g3, "--n-placeholder-color-disabled": _2, "--n-icon-size": C2, "--n-line-height-textarea": v3, "--n-color-disabled": y3, "--n-color-focus": b2, "--n-text-color-disabled": x2, "--n-box-shadow-focus": S3, "--n-loading-color": ue3, "--n-caret-color-warning": c2, "--n-color-focus-warning": w2, "--n-box-shadow-focus-warning": T3, "--n-border-warning": E2, "--n-border-focus-warning": D2, "--n-border-hover-warning": O3, "--n-loading-color-warning": fe3, "--n-caret-color-error": s2, "--n-color-focus-error": k3, "--n-box-shadow-focus-error": A2, "--n-border-error": ee3, "--n-border-focus-error": j2, "--n-border-hover-error": M2, "--n-loading-color-error": de3, "--n-clear-color": N3, "--n-clear-size": te2, "--n-clear-color-hover": ne3, "--n-clear-color-pressed": re3, "--n-icon-color": ie2, "--n-icon-color-hover": ce3, "--n-icon-color-pressed": le2, "--n-icon-color-disabled": ae3, "--n-suffix-text-color": oe3 };
  }), yt2 = i2 ? c(`input`, me(() => {
    let { value: e4 } = P2;
    return e4[0];
  }), vt2, e3) : void 0;
  return Object.assign(Object.assign({}, gt2), { wrapperElRef: d2, inputElRef: v2, inputMirrorElRef: g2, inputEl2Ref: y2, textareaElRef: f2, textareaMirrorElRef: h2, textareaScrollbarInstRef: O2, rtlEnabled: _t2, uncontrolledValue: ee2, mergedValue: N2, passwordVisible: _e2, mergedPlaceholder: de2, showPlaceholder1: fe2, showPlaceholder2: pe2, mergedFocus: I2, isComposing: F2, activated: ce2, showClearButton: he2, mergedSize: P2, mergedDisabled: re2, textDecorationStyle: ve2, mergedClsPrefix: n2, mergedBordered: r2, mergedShowPasswordOn: ge2, placeholderStyle: ft2, mergedStatus: ae2, textAreaScrollContainerWidth: L2, handleTextAreaScroll: pt2, handleCompositionStart: Le2, handleCompositionEnd: Re2, handleInput: ze2, handleInputBlur: Ve2, handleInputFocus: He2, handleWrapperBlur: Ue2, handleWrapperFocus: We2, handleMouseEnter: V2, handleMouseLeave: H2, handleMouseDown: B2, handleChange: Ge2, handleClick: Ke2, handleClear: qe2, handlePasswordToggleClick: Ye2, handlePasswordToggleMousedown: Qe2, handleWrapperKeydown: nt2, handleWrapperKeyup: tt2, handleTextAreaMirrorResize: dt2, getTextareaScrollContainer: () => f2.value, mergedTheme: u2, cssVars: i2 ? void 0 : vt2, themeClass: yt2 == null ? void 0 : yt2.themeClass, onRender: yt2 == null ? void 0 : yt2.onRender });
}, render() {
  var _a2, _b2, _c2, _d2, _e2, _f, _g;
  let { mergedClsPrefix: e3, mergedStatus: t2, themeClass: n2, type: i2, countGraphemes: a2, onRender: o2 } = this, s2 = this.$slots;
  return o2 == null ? void 0 : o2(), F(`div`, { ref: `wrapperElRef`, class: [`${e3}-input`, n2, t2 && `${e3}-input--${t2}-status`, { [`${e3}-input--rtl`]: this.rtlEnabled, [`${e3}-input--disabled`]: this.mergedDisabled, [`${e3}-input--textarea`]: i2 === `textarea`, [`${e3}-input--resizable`]: this.resizable && !this.autosize, [`${e3}-input--autosize`]: this.autosize, [`${e3}-input--round`]: this.round && i2 !== `textarea`, [`${e3}-input--pair`]: this.pair, [`${e3}-input--focus`]: this.mergedFocus, [`${e3}-input--stateful`]: this.stateful }], style: this.cssVars, tabindex: !this.mergedDisabled && this.passivelyActivated && !this.activated ? 0 : void 0, onFocus: this.handleWrapperFocus, onBlur: this.handleWrapperBlur, onClick: this.handleClick, onMousedown: this.handleMouseDown, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd, onKeyup: this.handleWrapperKeyup, onKeydown: this.handleWrapperKeydown }, F(`div`, { class: `${e3}-input-wrapper` }, v(s2.prefix, (t3) => t3 && F(`div`, { class: `${e3}-input__prefix` }, t3)), i2 === `textarea` ? F(T, { ref: `textareaScrollbarInstRef`, class: `${e3}-input__textarea`, container: this.getTextareaScrollContainer, theme: (_b2 = (_a2 = this.theme) == null ? void 0 : _a2.peers) == null ? void 0 : _b2.Scrollbar, themeOverrides: (_d2 = (_c2 = this.themeOverrides) == null ? void 0 : _c2.peers) == null ? void 0 : _d2.Scrollbar, triggerDisplayManually: true, useUnifiedContainer: true, internalHoistYRail: true }, { default: () => {
    var _a3, _b3;
    let { textAreaScrollContainerWidth: t3 } = this, n3 = { width: this.autosize && t3 && `${t3}px` };
    return F(_e, null, F(`textarea`, Object.assign({}, this.inputProps, { ref: `textareaElRef`, class: [`${e3}-input__textarea-el`, (_a3 = this.inputProps) == null ? void 0 : _a3.class], autofocus: this.autofocus, rows: Number(this.rows), placeholder: this.placeholder, value: this.mergedValue, disabled: this.mergedDisabled, maxlength: a2 ? void 0 : this.maxlength, minlength: a2 ? void 0 : this.minlength, readonly: this.readonly, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, style: [this.textDecorationStyle[0], (_b3 = this.inputProps) == null ? void 0 : _b3.style, n3], onBlur: this.handleInputBlur, onFocus: (e4) => {
      this.handleInputFocus(e4, 2);
    }, onInput: this.handleInput, onChange: this.handleChange, onScroll: this.handleTextAreaScroll })), this.showPlaceholder1 ? F(`div`, { class: `${e3}-input__placeholder`, style: [this.placeholderStyle, n3], key: `placeholder` }, this.mergedPlaceholder[0]) : null, this.autosize ? F(S, { onResize: this.handleTextAreaMirrorResize }, { default: () => F(`div`, { ref: `textareaMirrorElRef`, class: `${e3}-input__textarea-mirror`, key: `mirror` }) }) : null);
  } }) : F(`div`, { class: `${e3}-input__input` }, F(`input`, Object.assign({ type: i2 === `password` && this.mergedShowPasswordOn && this.passwordVisible ? `text` : i2 }, this.inputProps, { ref: `inputElRef`, class: [`${e3}-input__input-el`, (_e2 = this.inputProps) == null ? void 0 : _e2.class], style: [this.textDecorationStyle[0], (_f = this.inputProps) == null ? void 0 : _f.style], tabindex: this.passivelyActivated && !this.activated ? -1 : (_g = this.inputProps) == null ? void 0 : _g.tabindex, placeholder: this.mergedPlaceholder[0], disabled: this.mergedDisabled, maxlength: a2 ? void 0 : this.maxlength, minlength: a2 ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[0] : this.mergedValue, readonly: this.readonly, autofocus: this.autofocus, size: this.attrSize, onBlur: this.handleInputBlur, onFocus: (e4) => {
    this.handleInputFocus(e4, 0);
  }, onInput: (e4) => {
    this.handleInput(e4, 0);
  }, onChange: (e4) => {
    this.handleChange(e4, 0);
  } })), this.showPlaceholder1 ? F(`div`, { class: `${e3}-input__placeholder` }, F(`span`, null, this.mergedPlaceholder[0])) : null, this.autosize ? F(`div`, { class: `${e3}-input__input-mirror`, key: `mirror`, ref: `inputMirrorElRef` }, `\xA0`) : null), !this.pair && v(s2.suffix, (t3) => t3 || this.clearable || this.showCount || this.mergedShowPasswordOn || this.loading !== void 0 ? F(`div`, { class: `${e3}-input__suffix` }, [v(s2[`clear-icon-placeholder`], (t4) => (this.clearable || t4) && F(je, { clsPrefix: e3, show: this.showClearButton, onClear: this.handleClear }, { placeholder: () => t4, icon: () => {
    var _a3;
    var e4;
    return (_a3 = (e4 = this.$slots)[`clear-icon`]) == null ? void 0 : _a3.call(e4);
  } })), this.internalLoadingBeforeSuffix ? null : t3, this.loading === void 0 ? null : F(Me, { clsPrefix: e3, loading: this.loading, showArrow: false, showClear: false, style: this.cssVars }), this.internalLoadingBeforeSuffix ? t3 : null, this.showCount && this.type !== `textarea` ? F(tt, null, { default: (e4) => {
    var _a3;
    let { renderCount: t4 } = this;
    return t4 ? t4(e4) : (_a3 = s2.count) == null ? void 0 : _a3.call(s2, e4);
  } }) : null, this.mergedShowPasswordOn && this.type === `password` ? F(`div`, { class: `${e3}-input__eye`, onMousedown: this.handlePasswordToggleMousedown, onClick: this.handlePasswordToggleClick }, this.passwordVisible ? r(s2[`password-visible-icon`], () => [F(h, { clsPrefix: e3 }, { default: () => F(H, null) })]) : r(s2[`password-invisible-icon`], () => [F(h, { clsPrefix: e3 }, { default: () => F(Ye, null) })])) : null]) : null)), this.pair ? F(`span`, { class: `${e3}-input__separator` }, r(s2.separator, () => [this.separator])) : null, this.pair ? F(`div`, { class: `${e3}-input-wrapper` }, F(`div`, { class: `${e3}-input__input` }, F(`input`, { ref: `inputEl2Ref`, type: this.type, class: `${e3}-input__input-el`, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, placeholder: this.mergedPlaceholder[1], disabled: this.mergedDisabled, maxlength: a2 ? void 0 : this.maxlength, minlength: a2 ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[1] : void 0, readonly: this.readonly, style: this.textDecorationStyle[1], onBlur: this.handleInputBlur, onFocus: (e4) => {
    this.handleInputFocus(e4, 1);
  }, onInput: (e4) => {
    this.handleInput(e4, 1);
  }, onChange: (e4) => {
    this.handleChange(e4, 1);
  } }), this.showPlaceholder2 ? F(`div`, { class: `${e3}-input__placeholder` }, F(`span`, null, this.mergedPlaceholder[1])) : null), v(s2.suffix, (t3) => (this.clearable || t3) && F(`div`, { class: `${e3}-input__suffix` }, [this.clearable && F(je, { clsPrefix: e3, show: this.showClearButton, onClear: this.handleClear }, { icon: () => {
    var _a3;
    return (_a3 = s2[`clear-icon`]) == null ? void 0 : _a3.call(s2);
  }, placeholder: () => {
    var _a3;
    return (_a3 = s2[`clear-icon-placeholder`]) == null ? void 0 : _a3.call(s2);
  } }), t3]))) : null, this.mergedBordered ? F(`div`, { class: `${e3}-input__border` }) : null, this.mergedBordered ? F(`div`, { class: `${e3}-input__state-border` }) : null, this.showCount && i2 === `textarea` ? F(tt, null, { default: (e4) => {
    var _a3;
    let { renderCount: t3 } = this;
    return t3 ? t3(e4) : (_a3 = s2.count) == null ? void 0 : _a3.call(s2, e4);
  } }) : null);
} });
function rt() {
  let e3 = ye(Se, null);
  return e3 === null && u(`use-dialog`, `No outer <n-dialog-provider /> founded.`), e3;
}
function it() {
  let e3 = ye(we, null);
  return e3 === null && u(`use-message`, "No outer <n-message-provider /> founded. See prerequisite in https://www.naiveui.com/en-US/os-theme/components/message for more details. If you want to use `useMessage` outside setup, please check https://www.naiveui.com/zh-CN/os-theme/components/message#Q-&-A."), e3;
}
var at = ue(((e3, t2) => {
  (function(n2, r2) {
    typeof e3 == `object` && t2 !== void 0 ? t2.exports = r2() : typeof define == `function` && define.amd ? define(r2) : (n2 = typeof globalThis < `u` ? globalThis : n2 || self, n2.maplibregl = r2());
  })(e3, (function() {
    var e4 = {}, t3 = {};
    function n2(n3, r2, i2) {
      if (t3[n3] = i2, n3 === `index`) {
        var a2 = `var sharedModule = {}; (` + t3.shared + `)(sharedModule); (` + t3.worker + `)(sharedModule);`, o2 = {};
        return t3.shared(o2), t3.index(e4, o2), typeof window < `u` && e4.setWorkerUrl(window.URL.createObjectURL(new Blob([a2], { type: `text/javascript` }))), e4;
      }
    }
    return n2(`shared`, [`exports`], (function(e5) {
      function t4(e6, t5, n4, r3) {
        return new (n4 || (n4 = Promise))((function(i3, a3) {
          function o3(e7) {
            try {
              c3(r3.next(e7));
            } catch (e8) {
              a3(e8);
            }
          }
          function s3(e7) {
            try {
              c3(r3.throw(e7));
            } catch (e8) {
              a3(e8);
            }
          }
          function c3(e7) {
            var t6;
            e7.done ? i3(e7.value) : (t6 = e7.value, t6 instanceof n4 ? t6 : new n4((function(e8) {
              e8(t6);
            }))).then(o3, s3);
          }
          c3((r3 = r3.apply(e6, t5 || [])).next());
        }));
      }
      function n3(e6, t5) {
        this.x = e6, this.y = t5;
      }
      function r2(e6) {
        return e6 && e6.__esModule && Object.prototype.hasOwnProperty.call(e6, `default`) ? e6.default : e6;
      }
      var i2, a2;
      n3.prototype = { clone() {
        return new n3(this.x, this.y);
      }, add(e6) {
        return this.clone()._add(e6);
      }, sub(e6) {
        return this.clone()._sub(e6);
      }, multByPoint(e6) {
        return this.clone()._multByPoint(e6);
      }, divByPoint(e6) {
        return this.clone()._divByPoint(e6);
      }, mult(e6) {
        return this.clone()._mult(e6);
      }, div(e6) {
        return this.clone()._div(e6);
      }, rotate(e6) {
        return this.clone()._rotate(e6);
      }, rotateAround(e6, t5) {
        return this.clone()._rotateAround(e6, t5);
      }, matMult(e6) {
        return this.clone()._matMult(e6);
      }, unit() {
        return this.clone()._unit();
      }, perp() {
        return this.clone()._perp();
      }, round() {
        return this.clone()._round();
      }, mag() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals(e6) {
        return this.x === e6.x && this.y === e6.y;
      }, dist(e6) {
        return Math.sqrt(this.distSqr(e6));
      }, distSqr(e6) {
        let t5 = e6.x - this.x, n4 = e6.y - this.y;
        return t5 * t5 + n4 * n4;
      }, angle() {
        return Math.atan2(this.y, this.x);
      }, angleTo(e6) {
        return Math.atan2(this.y - e6.y, this.x - e6.x);
      }, angleWith(e6) {
        return this.angleWithSep(e6.x, e6.y);
      }, angleWithSep(e6, t5) {
        return Math.atan2(this.x * t5 - this.y * e6, this.x * e6 + this.y * t5);
      }, _matMult(e6) {
        let t5 = e6[2] * this.x + e6[3] * this.y;
        return this.x = e6[0] * this.x + e6[1] * this.y, this.y = t5, this;
      }, _add(e6) {
        return this.x += e6.x, this.y += e6.y, this;
      }, _sub(e6) {
        return this.x -= e6.x, this.y -= e6.y, this;
      }, _mult(e6) {
        return this.x *= e6, this.y *= e6, this;
      }, _div(e6) {
        return this.x /= e6, this.y /= e6, this;
      }, _multByPoint(e6) {
        return this.x *= e6.x, this.y *= e6.y, this;
      }, _divByPoint(e6) {
        return this.x /= e6.x, this.y /= e6.y, this;
      }, _unit() {
        return this._div(this.mag()), this;
      }, _perp() {
        let e6 = this.y;
        return this.y = this.x, this.x = -e6, this;
      }, _rotate(e6) {
        let t5 = Math.cos(e6), n4 = Math.sin(e6), r3 = n4 * this.x + t5 * this.y;
        return this.x = t5 * this.x - n4 * this.y, this.y = r3, this;
      }, _rotateAround(e6, t5) {
        let n4 = Math.cos(e6), r3 = Math.sin(e6), i3 = t5.y + r3 * (this.x - t5.x) + n4 * (this.y - t5.y);
        return this.x = t5.x + n4 * (this.x - t5.x) - r3 * (this.y - t5.y), this.y = i3, this;
      }, _round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      }, constructor: n3 }, n3.convert = function(e6) {
        if (e6 instanceof n3) return e6;
        if (Array.isArray(e6)) return new n3(+e6[0], +e6[1]);
        if (e6.x !== void 0 && e6.y !== void 0) return new n3(+e6.x, +e6.y);
        throw Error(`Expected [x, y] or {x, y} point format`);
      };
      var o2 = r2((function() {
        if (a2) return i2;
        function e6(e7, t5, n4, r3) {
          this.cx = 3 * e7, this.bx = 3 * (n4 - e7) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t5, this.by = 3 * (r3 - t5) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e7, this.p1y = t5, this.p2x = n4, this.p2y = r3;
        }
        return a2 = 1, i2 = e6, e6.prototype = { sampleCurveX: function(e7) {
          return ((this.ax * e7 + this.bx) * e7 + this.cx) * e7;
        }, sampleCurveY: function(e7) {
          return ((this.ay * e7 + this.by) * e7 + this.cy) * e7;
        }, sampleCurveDerivativeX: function(e7) {
          return (3 * this.ax * e7 + 2 * this.bx) * e7 + this.cx;
        }, solveCurveX: function(e7, t5) {
          if (t5 === void 0 && (t5 = 1e-6), e7 < 0) return 0;
          if (e7 > 1) return 1;
          for (var n4 = e7, r3 = 0; r3 < 8; r3++) {
            var i3 = this.sampleCurveX(n4) - e7;
            if (Math.abs(i3) < t5) return n4;
            var a3 = this.sampleCurveDerivativeX(n4);
            if (Math.abs(a3) < 1e-6) break;
            n4 -= i3 / a3;
          }
          var o3 = 0, s3 = 1;
          for (n4 = e7, r3 = 0; r3 < 20 && (i3 = this.sampleCurveX(n4), !(Math.abs(i3 - e7) < t5)); r3++) e7 > i3 ? o3 = n4 : s3 = n4, n4 = 0.5 * (s3 - o3) + o3;
          return n4;
        }, solve: function(e7, t5) {
          return this.sampleCurveY(this.solveCurveX(e7, t5));
        } }, i2;
      })());
      let s2, c2;
      function l2() {
        return s2 ?? (s2 = typeof OffscreenCanvas < `u` && new OffscreenCanvas(1, 1).getContext(`2d`) && typeof createImageBitmap == `function`), s2;
      }
      function u2() {
        if (c2 == null && (c2 = false, l2())) {
          let e6 = new OffscreenCanvas(5, 5).getContext(`2d`, { willReadFrequently: true });
          if (e6) {
            for (let t6 = 0; t6 < 25; t6++) {
              let n4 = 4 * t6;
              e6.fillStyle = `rgb(${n4},${n4 + 1},${n4 + 2})`, e6.fillRect(t6 % 5, Math.floor(t6 / 5), 1, 1);
            }
            let t5 = e6.getImageData(0, 0, 5, 5).data;
            for (let e7 = 0; e7 < 100; e7++) if (e7 % 4 != 3 && t5[e7] !== e7) {
              c2 = true;
              break;
            }
          }
        }
        return c2 || false;
      }
      var d2 = 1e-6, f2 = typeof Float32Array < `u` ? Float32Array : Array;
      function p2() {
        var e6 = new f2(9);
        return f2 != Float32Array && (e6[1] = 0, e6[2] = 0, e6[3] = 0, e6[5] = 0, e6[6] = 0, e6[7] = 0), e6[0] = 1, e6[4] = 1, e6[8] = 1, e6;
      }
      function m2(e6) {
        return e6[0] = 1, e6[1] = 0, e6[2] = 0, e6[3] = 0, e6[4] = 0, e6[5] = 1, e6[6] = 0, e6[7] = 0, e6[8] = 0, e6[9] = 0, e6[10] = 1, e6[11] = 0, e6[12] = 0, e6[13] = 0, e6[14] = 0, e6[15] = 1, e6;
      }
      function h2() {
        var e6 = new f2(3);
        return f2 != Float32Array && (e6[0] = 0, e6[1] = 0, e6[2] = 0), e6;
      }
      function g2(e6) {
        var t5 = e6[0], n4 = e6[1], r3 = e6[2];
        return Math.sqrt(t5 * t5 + n4 * n4 + r3 * r3);
      }
      function _2(e6, t5, n4) {
        var r3 = new f2(3);
        return r3[0] = e6, r3[1] = t5, r3[2] = n4, r3;
      }
      function v2(e6, t5, n4) {
        return e6[0] = t5[0] + n4[0], e6[1] = t5[1] + n4[1], e6[2] = t5[2] + n4[2], e6;
      }
      function y2(e6, t5, n4) {
        return e6[0] = t5[0] * n4, e6[1] = t5[1] * n4, e6[2] = t5[2] * n4, e6;
      }
      function b2(e6, t5, n4) {
        var r3 = t5[0], i3 = t5[1], a3 = t5[2], o3 = n4[0], s3 = n4[1], c3 = n4[2];
        return e6[0] = i3 * c3 - a3 * s3, e6[1] = a3 * o3 - r3 * c3, e6[2] = r3 * s3 - i3 * o3, e6;
      }
      var x2, S2 = g2;
      function C2(e6, t5, n4) {
        var r3 = t5[0], i3 = t5[1], a3 = t5[2], o3 = t5[3];
        return e6[0] = n4[0] * r3 + n4[4] * i3 + n4[8] * a3 + n4[12] * o3, e6[1] = n4[1] * r3 + n4[5] * i3 + n4[9] * a3 + n4[13] * o3, e6[2] = n4[2] * r3 + n4[6] * i3 + n4[10] * a3 + n4[14] * o3, e6[3] = n4[3] * r3 + n4[7] * i3 + n4[11] * a3 + n4[15] * o3, e6;
      }
      function w2() {
        var e6 = new f2(4);
        return f2 != Float32Array && (e6[0] = 0, e6[1] = 0, e6[2] = 0), e6[3] = 1, e6;
      }
      function T2(e6, t5, n4, r3) {
        var i3 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : `zyx`, a3 = Math.PI / 360;
        t5 *= a3, r3 *= a3, n4 *= a3;
        var o3 = Math.sin(t5), s3 = Math.cos(t5), c3 = Math.sin(n4), l3 = Math.cos(n4), u3 = Math.sin(r3), d3 = Math.cos(r3);
        switch (i3) {
          case `xyz`:
            e6[0] = o3 * l3 * d3 + s3 * c3 * u3, e6[1] = s3 * c3 * d3 - o3 * l3 * u3, e6[2] = s3 * l3 * u3 + o3 * c3 * d3, e6[3] = s3 * l3 * d3 - o3 * c3 * u3;
            break;
          case `xzy`:
            e6[0] = o3 * l3 * d3 - s3 * c3 * u3, e6[1] = s3 * c3 * d3 - o3 * l3 * u3, e6[2] = s3 * l3 * u3 + o3 * c3 * d3, e6[3] = s3 * l3 * d3 + o3 * c3 * u3;
            break;
          case `yxz`:
            e6[0] = o3 * l3 * d3 + s3 * c3 * u3, e6[1] = s3 * c3 * d3 - o3 * l3 * u3, e6[2] = s3 * l3 * u3 - o3 * c3 * d3, e6[3] = s3 * l3 * d3 + o3 * c3 * u3;
            break;
          case `yzx`:
            e6[0] = o3 * l3 * d3 + s3 * c3 * u3, e6[1] = s3 * c3 * d3 + o3 * l3 * u3, e6[2] = s3 * l3 * u3 - o3 * c3 * d3, e6[3] = s3 * l3 * d3 - o3 * c3 * u3;
            break;
          case `zxy`:
            e6[0] = o3 * l3 * d3 - s3 * c3 * u3, e6[1] = s3 * c3 * d3 + o3 * l3 * u3, e6[2] = s3 * l3 * u3 + o3 * c3 * d3, e6[3] = s3 * l3 * d3 - o3 * c3 * u3;
            break;
          case `zyx`:
            e6[0] = o3 * l3 * d3 - s3 * c3 * u3, e6[1] = s3 * c3 * d3 + o3 * l3 * u3, e6[2] = s3 * l3 * u3 - o3 * c3 * d3, e6[3] = s3 * l3 * d3 + o3 * c3 * u3;
            break;
          default:
            throw Error(`Unknown angle order ` + i3);
        }
        return e6;
      }
      function E2() {
        var e6 = new f2(2);
        return f2 != Float32Array && (e6[0] = 0, e6[1] = 0), e6;
      }
      function D2(e6, t5) {
        var n4 = new f2(2);
        return n4[0] = e6, n4[1] = t5, n4;
      }
      h2(), x2 = new f2(4), f2 != Float32Array && (x2[0] = 0, x2[1] = 0, x2[2] = 0, x2[3] = 0), h2(), _2(1, 0, 0), _2(0, 1, 0), w2(), w2(), p2(), E2();
      let O2 = 8192;
      function k2(e6, t5, n4) {
        return t5 * (O2 / (e6.tileSize * 2 ** (n4 - e6.tileID.overscaledZ)));
      }
      function A2(e6, t5) {
        return (e6 % t5 + t5) % t5;
      }
      function ee2(e6, t5, n4) {
        return e6 * (1 - n4) + t5 * n4;
      }
      function j2(e6) {
        if (e6 <= 0) return 0;
        if (e6 >= 1) return 1;
        let t5 = e6 * e6, n4 = t5 * e6;
        return 4 * (e6 < 0.5 ? n4 : 3 * (e6 - t5) + n4 - 0.75);
      }
      function M2(e6, t5, n4, r3) {
        let i3 = new o2(e6, t5, n4, r3);
        return (e7) => i3.solve(e7);
      }
      let te2 = M2(0.25, 0.1, 0.25, 1);
      function N2(e6, t5, n4) {
        return Math.min(n4, Math.max(t5, e6));
      }
      function ne2(e6, t5, n4) {
        let r3 = n4 - t5, i3 = ((e6 - t5) % r3 + r3) % r3 + t5;
        return i3 === t5 ? n4 : i3;
      }
      function P2(e6, ...t5) {
        for (let n4 of t5) for (let t6 in n4) e6[t6] = n4[t6];
        return e6;
      }
      let re2 = 1;
      function ie2(e6, t5, n4) {
        let r3 = {};
        for (let n5 in e6) r3[n5] = t5.call(this, e6[n5], n5, e6);
        return r3;
      }
      function ae2(e6, t5, n4) {
        let r3 = {};
        for (let n5 in e6) t5.call(this, e6[n5], n5, e6) && (r3[n5] = e6[n5]);
        return r3;
      }
      function oe2(e6) {
        return Array.isArray(e6) ? e6.map(oe2) : typeof e6 == `object` && e6 ? ie2(e6, oe2) : e6;
      }
      let se2 = {};
      function F2(e6) {
        se2[e6] || (typeof console < `u` && console.warn(e6), se2[e6] = true);
      }
      function ce2(e6, t5, n4) {
        return (n4.y - e6.y) * (t5.x - e6.x) > (t5.y - e6.y) * (n4.x - e6.x);
      }
      function le2(e6) {
        return typeof WorkerGlobalScope < `u` && e6 !== void 0 && e6 instanceof WorkerGlobalScope;
      }
      let ue2 = null;
      function de2(e6) {
        if (ue2 == null) {
          let t5 = e6.navigator ? e6.navigator.userAgent : null;
          ue2 = !!e6.safari || !(!t5 || !(/\b(iPad|iPhone|iPod)\b/.test(t5) || t5.match(`Safari`) && !t5.match(`Chrome`)));
        }
        return ue2;
      }
      function fe2(e6) {
        return typeof ImageBitmap < `u` && e6 instanceof ImageBitmap;
      }
      let pe2 = `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=`;
      function I2(e6, n4, r3, i3, a3) {
        return t4(this, void 0, void 0, (function* () {
          if (typeof VideoFrame > `u`) throw Error(`VideoFrame not supported`);
          let t5 = new VideoFrame(e6, { timestamp: 0 });
          try {
            let o3 = t5 == null ? void 0 : t5.format;
            if (!o3 || !o3.startsWith(`BGR`) && !o3.startsWith(`RGB`)) throw Error(`Unrecognized format ${o3}`);
            let s3 = o3.startsWith(`BGR`), c3 = new Uint8ClampedArray(i3 * a3 * 4);
            if (yield t5.copyTo(c3, (function(e7, t6, n5, r4, i4) {
              let a4 = 4 * Math.max(-t6, 0), o4 = (Math.max(0, n5) - n5) * r4 * 4 + a4, s4 = 4 * r4, c4 = Math.max(0, t6), l3 = Math.max(0, n5);
              return { rect: { x: c4, y: l3, width: Math.min(e7.width, t6 + r4) - c4, height: Math.min(e7.height, n5 + i4) - l3 }, layout: [{ offset: o4, stride: s4 }] };
            })(e6, n4, r3, i3, a3)), s3) for (let e7 = 0; e7 < c3.length; e7 += 4) {
              let t6 = c3[e7];
              c3[e7] = c3[e7 + 2], c3[e7 + 2] = t6;
            }
            return c3;
          } finally {
            t5.close();
          }
        }));
      }
      let me2, he2;
      function ge2(e6, t5, n4, r3) {
        return e6.addEventListener(t5, n4, r3), { unsubscribe: () => {
          e6.removeEventListener(t5, n4, r3);
        } };
      }
      function _e2(e6) {
        return e6 * Math.PI / 180;
      }
      function ve2(e6) {
        return e6 / Math.PI * 180;
      }
      let L2 = { touchstart: true, touchmove: true, touchmoveWindow: true, touchend: true, touchcancel: true }, ye2 = { dblclick: true, click: true, mouseover: true, mouseout: true, mousedown: true, mousemove: true, mousemoveWindow: true, mouseup: true, mouseupWindow: true, contextmenu: true, wheel: true }, be2 = `AbortError`;
      function xe2() {
        return Error(be2);
      }
      let Se2 = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: `` };
      function Ce2(e6) {
        return Se2.REGISTERED_PROTOCOLS[e6.substring(0, e6.indexOf(`://`))];
      }
      let we2 = `global-dispatcher`;
      class Te2 extends Error {
        constructor(e6, t5, n4, r3) {
          super(`AJAXError: ${t5} (${e6}): ${n4}`), this.status = e6, this.statusText = t5, this.url = n4, this.body = r3;
        }
      }
      let Ee2 = () => le2(self) ? self.worker && self.worker.referrer : (window.location.protocol === `blob:` ? window.parent : window).location.href, De2 = function(e6, n4) {
        if (/:\/\//.test(e6.url) && !/^https?:|^file:/.test(e6.url)) {
          let t5 = Ce2(e6.url);
          if (t5) return t5(e6, n4);
          if (le2(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: `GR`, data: e6, targetMapId: we2 }, n4);
        }
        if (!(/^file:/.test(r3 = e6.url) || /^file:/.test(Ee2()) && !/^\w+:/.test(r3))) {
          if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, `signal`)) return (function(e7, n5) {
            return t4(this, void 0, void 0, (function* () {
              let t5 = new Request(e7.url, { method: e7.method || `GET`, body: e7.body, credentials: e7.credentials, headers: e7.headers, cache: e7.cache, referrer: Ee2(), signal: n5.signal }), r4, i3;
              e7.type !== `json` || t5.headers.has(`Accept`) || t5.headers.set(`Accept`, `application/json`);
              try {
                r4 = yield fetch(t5);
              } catch (t6) {
                throw new Te2(0, t6.message, e7.url, new Blob());
              }
              if (!r4.ok) {
                let t6 = yield r4.blob();
                throw new Te2(r4.status, r4.statusText, e7.url, t6);
              }
              i3 = e7.type === `arrayBuffer` || e7.type === `image` ? r4.arrayBuffer() : e7.type === `json` ? r4.json() : r4.text();
              let a3 = yield i3;
              if (n5.signal.aborted) throw xe2();
              return { data: a3, cacheControl: r4.headers.get(`Cache-Control`), expires: r4.headers.get(`Expires`) };
            }));
          })(e6, n4);
          if (le2(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: `GR`, data: e6, mustQueue: true, targetMapId: we2 }, n4);
        }
        var r3;
        return (function(e7, t5) {
          return new Promise(((n5, r4) => {
            var i3;
            let a3 = new XMLHttpRequest();
            for (let t6 in a3.open(e7.method || `GET`, e7.url, true), e7.type !== `arrayBuffer` && e7.type !== `image` || (a3.responseType = `arraybuffer`), e7.headers) a3.setRequestHeader(t6, e7.headers[t6]);
            e7.type === `json` && (a3.responseType = `text`, (i3 = e7.headers) != null && i3.Accept || a3.setRequestHeader(`Accept`, `application/json`)), a3.withCredentials = e7.credentials === `include`, a3.onerror = () => {
              r4(Error(a3.statusText));
            }, a3.onload = () => {
              if (!t5.signal.aborted) if ((a3.status >= 200 && a3.status < 300 || a3.status === 0) && a3.response !== null) {
                let t6 = a3.response;
                if (e7.type === `json`) try {
                  t6 = JSON.parse(a3.response);
                } catch (e8) {
                  r4(e8);
                  return;
                }
                n5({ data: t6, cacheControl: a3.getResponseHeader(`Cache-Control`), expires: a3.getResponseHeader(`Expires`) });
              } else {
                let t6 = new Blob([a3.response], { type: a3.getResponseHeader(`Content-Type`) });
                r4(new Te2(a3.status, a3.statusText, e7.url, t6));
              }
            }, t5.signal.addEventListener(`abort`, (() => {
              a3.abort(), r4(xe2());
            })), a3.send(e7.body);
          }));
        })(e6, n4);
      };
      function Oe2(e6) {
        if (!e6 || e6.indexOf(`://`) <= 0 || e6.indexOf(`data:image/`) === 0 || e6.indexOf(`blob:`) === 0) return true;
        let t5 = new URL(e6), n4 = window.location;
        return t5.protocol === n4.protocol && t5.host === n4.host;
      }
      function ke2(e6, t5, n4) {
        n4[e6] && n4[e6].indexOf(t5) !== -1 || (n4[e6] = n4[e6] || [], n4[e6].push(t5));
      }
      function Ae2(e6, t5, n4) {
        if (n4 && n4[e6]) {
          let r3 = n4[e6].indexOf(t5);
          r3 !== -1 && n4[e6].splice(r3, 1);
        }
      }
      class je2 {
        constructor(e6, t5 = {}) {
          P2(this, t5), this.type = e6;
        }
      }
      class Me2 extends je2 {
        constructor(e6, t5 = {}) {
          super(`error`, P2({ error: e6 }, t5));
        }
      }
      class Ne2 {
        on(e6, t5) {
          return this._listeners = this._listeners || {}, ke2(e6, t5, this._listeners), { unsubscribe: () => {
            this.off(e6, t5);
          } };
        }
        off(e6, t5) {
          return Ae2(e6, t5, this._listeners), Ae2(e6, t5, this._oneTimeListeners), this;
        }
        once(e6, t5) {
          return t5 ? (this._oneTimeListeners = this._oneTimeListeners || {}, ke2(e6, t5, this._oneTimeListeners), this) : new Promise(((t6) => this.once(e6, t6)));
        }
        fire(e6, t5) {
          typeof e6 == `string` && (e6 = new je2(e6, t5 || {}));
          let n4 = e6.type;
          if (this.listens(n4)) {
            e6.target = this;
            let t6 = this._listeners && this._listeners[n4] ? this._listeners[n4].slice() : [];
            for (let n5 of t6) n5.call(this, e6);
            let r3 = this._oneTimeListeners && this._oneTimeListeners[n4] ? this._oneTimeListeners[n4].slice() : [];
            for (let t7 of r3) Ae2(n4, t7, this._oneTimeListeners), t7.call(this, e6);
            let i3 = this._eventedParent;
            i3 && (P2(e6, typeof this._eventedParentData == `function` ? this._eventedParentData() : this._eventedParentData), i3.fire(e6));
          } else e6 instanceof Me2 && console.error(e6.error);
          return this;
        }
        listens(e6) {
          return this._listeners && this._listeners[e6] && this._listeners[e6].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e6] && this._oneTimeListeners[e6].length > 0 || this._eventedParent && this._eventedParent.listens(e6);
        }
        setEventedParent(e6, t5) {
          return this._eventedParent = e6, this._eventedParentData = t5, this;
        }
      }
      var R2 = { $version: 8, $root: { version: { required: true, type: `enum`, values: [8] }, name: { type: `string` }, metadata: { type: `*` }, center: { type: `array`, value: `number` }, centerAltitude: { type: `number` }, zoom: { type: `number` }, bearing: { type: `number`, default: 0, period: 360, units: `degrees` }, pitch: { type: `number`, default: 0, units: `degrees` }, roll: { type: `number`, default: 0, units: `degrees` }, state: { type: `state`, default: {} }, light: { type: `light` }, sky: { type: `sky` }, projection: { type: `projection` }, terrain: { type: `terrain` }, sources: { required: true, type: `sources` }, sprite: { type: `sprite` }, glyphs: { type: `string` }, "font-faces": { type: `array`, value: `fontFaces` }, transition: { type: `transition` }, layers: { required: true, type: `array`, value: `layer` } }, sources: { "*": { type: `source` } }, source: [`source_vector`, `source_raster`, `source_raster_dem`, `source_geojson`, `source_video`, `source_image`], source_vector: { type: { required: true, type: `enum`, values: { vector: {} } }, url: { type: `string` }, tiles: { type: `array`, value: `string` }, bounds: { type: `array`, value: `number`, length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: `enum`, values: { xyz: {}, tms: {} }, default: `xyz` }, minzoom: { type: `number`, default: 0 }, maxzoom: { type: `number`, default: 22 }, attribution: { type: `string` }, promoteId: { type: `promoteId` }, volatile: { type: `boolean`, default: false }, encoding: { type: `enum`, values: { mvt: {}, mlt: {} }, default: `mvt` }, "*": { type: `*` } }, source_raster: { type: { required: true, type: `enum`, values: { raster: {} } }, url: { type: `string` }, tiles: { type: `array`, value: `string` }, bounds: { type: `array`, value: `number`, length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: `number`, default: 0 }, maxzoom: { type: `number`, default: 22 }, tileSize: { type: `number`, default: 512, units: `pixels` }, scheme: { type: `enum`, values: { xyz: {}, tms: {} }, default: `xyz` }, attribution: { type: `string` }, volatile: { type: `boolean`, default: false }, "*": { type: `*` } }, source_raster_dem: { type: { required: true, type: `enum`, values: { "raster-dem": {} } }, url: { type: `string` }, tiles: { type: `array`, value: `string` }, bounds: { type: `array`, value: `number`, length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: `number`, default: 0 }, maxzoom: { type: `number`, default: 22 }, tileSize: { type: `number`, default: 512, units: `pixels` }, attribution: { type: `string` }, encoding: { type: `enum`, values: { terrarium: {}, mapbox: {}, custom: {} }, default: `mapbox` }, redFactor: { type: `number`, default: 1 }, blueFactor: { type: `number`, default: 1 }, greenFactor: { type: `number`, default: 1 }, baseShift: { type: `number`, default: 0 }, volatile: { type: `boolean`, default: false }, "*": { type: `*` } }, source_geojson: { type: { required: true, type: `enum`, values: { geojson: {} } }, data: { required: true, type: `*` }, maxzoom: { type: `number`, default: 18 }, attribution: { type: `string` }, buffer: { type: `number`, default: 128, maximum: 512, minimum: 0 }, filter: { type: `*` }, tolerance: { type: `number`, default: 0.375 }, cluster: { type: `boolean`, default: false }, clusterRadius: { type: `number`, default: 50, minimum: 0 }, clusterMaxZoom: { type: `number` }, clusterMinPoints: { type: `number` }, clusterProperties: { type: `*` }, lineMetrics: { type: `boolean`, default: false }, generateId: { type: `boolean`, default: false }, promoteId: { type: `promoteId` } }, source_video: { type: { required: true, type: `enum`, values: { video: {} } }, urls: { required: true, type: `array`, value: `string` }, coordinates: { required: true, type: `array`, length: 4, value: { type: `array`, length: 2, value: `number` } } }, source_image: { type: { required: true, type: `enum`, values: { image: {} } }, url: { required: true, type: `string` }, coordinates: { required: true, type: `array`, length: 4, value: { type: `array`, length: 2, value: `number` } } }, layer: { id: { type: `string`, required: true }, type: { type: `enum`, values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, "color-relief": {}, background: {} }, required: true }, metadata: { type: `*` }, source: { type: `string` }, "source-layer": { type: `string` }, minzoom: { type: `number`, minimum: 0, maximum: 24 }, maxzoom: { type: `number`, minimum: 0, maximum: 24 }, filter: { type: `filter` }, layout: { type: `layout` }, paint: { type: `paint` } }, layout: [`layout_fill`, `layout_line`, `layout_circle`, `layout_heatmap`, `layout_fill-extrusion`, `layout_symbol`, `layout_raster`, `layout_hillshade`, `layout_color-relief`, `layout_background`], layout_background: { visibility: { type: `enum`, values: { visible: {}, none: {} }, default: `visible`, "property-type": `constant` } }, layout_fill: { "fill-sort-key": { type: `number`, expression: { interpolated: false, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, visibility: { type: `enum`, values: { visible: {}, none: {} }, default: `visible`, "property-type": `constant` } }, layout_circle: { "circle-sort-key": { type: `number`, expression: { interpolated: false, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, visibility: { type: `enum`, values: { visible: {}, none: {} }, default: `visible`, "property-type": `constant` } }, layout_heatmap: { visibility: { type: `enum`, values: { visible: {}, none: {} }, default: `visible`, "property-type": `constant` } }, "layout_fill-extrusion": { visibility: { type: `enum`, values: { visible: {}, none: {} }, default: `visible`, "property-type": `constant` } }, layout_line: { "line-cap": { type: `enum`, values: { butt: {}, round: {}, square: {} }, default: `butt`, expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "line-join": { type: `enum`, values: { bevel: {}, round: {}, miter: {} }, default: `miter`, expression: { interpolated: false, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, "line-miter-limit": { type: `number`, default: 2, requires: [{ "line-join": `miter` }], expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "line-round-limit": { type: `number`, default: 1.05, requires: [{ "line-join": `round` }], expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "line-sort-key": { type: `number`, expression: { interpolated: false, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, visibility: { type: `enum`, values: { visible: {}, none: {} }, default: `visible`, "property-type": `constant` } }, layout_symbol: { "symbol-placement": { type: `enum`, values: { point: {}, line: {}, "line-center": {} }, default: `point`, expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "symbol-spacing": { type: `number`, default: 250, minimum: 1, units: `pixels`, requires: [{ "symbol-placement": `line` }], expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "symbol-avoid-edges": { type: `boolean`, default: false, expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "symbol-sort-key": { type: `number`, expression: { interpolated: false, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, "symbol-z-order": { type: `enum`, values: { auto: {}, "viewport-y": {}, source: {} }, default: `auto`, expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "icon-allow-overlap": { type: `boolean`, default: false, requires: [`icon-image`, { "!": `icon-overlap` }], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "icon-overlap": { type: `enum`, values: { never: {}, always: {}, cooperative: {} }, requires: [`icon-image`], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "icon-ignore-placement": { type: `boolean`, default: false, requires: [`icon-image`], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "icon-optional": { type: `boolean`, default: false, requires: [`icon-image`, `text-field`], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "icon-rotation-alignment": { type: `enum`, values: { map: {}, viewport: {}, auto: {} }, default: `auto`, requires: [`icon-image`], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "icon-size": { type: `number`, default: 1, minimum: 0, units: `factor of the original icon size`, requires: [`icon-image`], expression: { interpolated: true, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, "icon-text-fit": { type: `enum`, values: { none: {}, width: {}, height: {}, both: {} }, default: `none`, requires: [`icon-image`, `text-field`], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "icon-text-fit-padding": { type: `array`, value: `number`, length: 4, default: [0, 0, 0, 0], units: `pixels`, requires: [`icon-image`, `text-field`, { "icon-text-fit": [`both`, `width`, `height`] }], expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "icon-image": { type: `resolvedImage`, tokens: true, expression: { interpolated: false, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, "icon-rotate": { type: `number`, default: 0, period: 360, units: `degrees`, requires: [`icon-image`], expression: { interpolated: true, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, "icon-padding": { type: `padding`, default: [2], units: `pixels`, requires: [`icon-image`], expression: { interpolated: true, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, "icon-keep-upright": { type: `boolean`, default: false, requires: [`icon-image`, { "icon-rotation-alignment": `map` }, { "symbol-placement": [`line`, `line-center`] }], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "icon-offset": { type: `array`, value: `number`, length: 2, default: [0, 0], requires: [`icon-image`], expression: { interpolated: true, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, "icon-anchor": { type: `enum`, values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: `center`, requires: [`icon-image`], expression: { interpolated: false, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, "icon-pitch-alignment": { type: `enum`, values: { map: {}, viewport: {}, auto: {} }, default: `auto`, requires: [`icon-image`], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "text-pitch-alignment": { type: `enum`, values: { map: {}, viewport: {}, auto: {} }, default: `auto`, requires: [`text-field`], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "text-rotation-alignment": { type: `enum`, values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: `auto`, requires: [`text-field`], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "text-field": { type: `formatted`, default: ``, tokens: true, expression: { interpolated: false, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, "text-font": { type: `array`, value: `string`, default: [`Open Sans Regular`, `Arial Unicode MS Regular`], requires: [`text-field`], expression: { interpolated: false, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, "text-size": { type: `number`, default: 16, minimum: 0, units: `pixels`, requires: [`text-field`], expression: { interpolated: true, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, "text-max-width": { type: `number`, default: 10, minimum: 0, units: `ems`, requires: [`text-field`], expression: { interpolated: true, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, "text-line-height": { type: `number`, default: 1.2, units: `ems`, requires: [`text-field`], expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "text-letter-spacing": { type: `number`, default: 0, units: `ems`, requires: [`text-field`], expression: { interpolated: true, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, "text-justify": { type: `enum`, values: { auto: {}, left: {}, center: {}, right: {} }, default: `center`, requires: [`text-field`], expression: { interpolated: false, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, "text-radial-offset": { type: `number`, units: `ems`, default: 0, requires: [`text-field`], "property-type": `data-driven`, expression: { interpolated: true, parameters: [`zoom`, `feature`] } }, "text-variable-anchor": { type: `array`, value: `enum`, values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: [`text-field`, { "symbol-placement": [`point`] }], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "text-variable-anchor-offset": { type: `variableAnchorOffsetCollection`, requires: [`text-field`, { "symbol-placement": [`point`] }], expression: { interpolated: true, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, "text-anchor": { type: `enum`, values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: `center`, requires: [`text-field`, { "!": `text-variable-anchor` }], expression: { interpolated: false, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, "text-max-angle": { type: `number`, default: 45, units: `degrees`, requires: [`text-field`, { "symbol-placement": [`line`, `line-center`] }], expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "text-writing-mode": { type: `array`, value: `enum`, values: { horizontal: {}, vertical: {} }, requires: [`text-field`, { "symbol-placement": [`point`] }], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "text-rotate": { type: `number`, default: 0, period: 360, units: `degrees`, requires: [`text-field`], expression: { interpolated: true, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, "text-padding": { type: `number`, default: 2, minimum: 0, units: `pixels`, requires: [`text-field`], expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "text-keep-upright": { type: `boolean`, default: true, requires: [`text-field`, { "text-rotation-alignment": `map` }, { "symbol-placement": [`line`, `line-center`] }], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "text-transform": { type: `enum`, values: { none: {}, uppercase: {}, lowercase: {} }, default: `none`, requires: [`text-field`], expression: { interpolated: false, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, "text-offset": { type: `array`, value: `number`, units: `ems`, length: 2, default: [0, 0], requires: [`text-field`, { "!": `text-radial-offset` }], expression: { interpolated: true, parameters: [`zoom`, `feature`] }, "property-type": `data-driven` }, "text-allow-overlap": { type: `boolean`, default: false, requires: [`text-field`, { "!": `text-overlap` }], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "text-overlap": { type: `enum`, values: { never: {}, always: {}, cooperative: {} }, requires: [`text-field`], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "text-ignore-placement": { type: `boolean`, default: false, requires: [`text-field`], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "text-optional": { type: `boolean`, default: false, requires: [`text-field`, `icon-image`], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, visibility: { type: `enum`, values: { visible: {}, none: {} }, default: `visible`, "property-type": `constant` } }, layout_raster: { visibility: { type: `enum`, values: { visible: {}, none: {} }, default: `visible`, "property-type": `constant` } }, layout_hillshade: { visibility: { type: `enum`, values: { visible: {}, none: {} }, default: `visible`, "property-type": `constant` } }, "layout_color-relief": { visibility: { type: `enum`, values: { visible: {}, none: {} }, default: `visible`, "property-type": `constant` } }, filter: { type: `array`, value: `*` }, filter_operator: { type: `enum`, values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: `enum`, values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: `expression` }, stops: { type: `array`, value: `function_stop` }, base: { type: `number`, default: 1, minimum: 0 }, property: { type: `string`, default: `$zoom` }, type: { type: `enum`, values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: `exponential` }, colorSpace: { type: `enum`, values: { rgb: {}, lab: {}, hcl: {} }, default: `rgb` }, default: { type: `*`, required: false } }, function_stop: { type: `array`, minimum: 0, maximum: 24, value: [`number`, `color`], length: 2 }, expression: { type: `array`, value: `*`, minimum: 1 }, light: { anchor: { type: `enum`, default: `viewport`, values: { map: {}, viewport: {} }, "property-type": `data-constant`, transition: false, expression: { interpolated: false, parameters: [`zoom`] } }, position: { type: `array`, default: [1.15, 210, 30], length: 3, value: `number`, "property-type": `data-constant`, transition: true, expression: { interpolated: true, parameters: [`zoom`] } }, color: { type: `color`, "property-type": `data-constant`, default: `#ffffff`, expression: { interpolated: true, parameters: [`zoom`] }, transition: true }, intensity: { type: `number`, "property-type": `data-constant`, default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: [`zoom`] }, transition: true } }, sky: { "sky-color": { type: `color`, "property-type": `data-constant`, default: `#88C6FC`, expression: { interpolated: true, parameters: [`zoom`] }, transition: true }, "horizon-color": { type: `color`, "property-type": `data-constant`, default: `#ffffff`, expression: { interpolated: true, parameters: [`zoom`] }, transition: true }, "fog-color": { type: `color`, "property-type": `data-constant`, default: `#ffffff`, expression: { interpolated: true, parameters: [`zoom`] }, transition: true }, "fog-ground-blend": { type: `number`, "property-type": `data-constant`, default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: [`zoom`] }, transition: true }, "horizon-fog-blend": { type: `number`, "property-type": `data-constant`, default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: [`zoom`] }, transition: true }, "sky-horizon-blend": { type: `number`, "property-type": `data-constant`, default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: [`zoom`] }, transition: true }, "atmosphere-blend": { type: `number`, "property-type": `data-constant`, default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: [`zoom`] }, transition: true } }, terrain: { source: { type: `string`, required: true }, exaggeration: { type: `number`, minimum: 0, default: 1 } }, projection: { type: { type: `projectionDefinition`, default: `mercator`, "property-type": `data-constant`, transition: false, expression: { interpolated: true, parameters: [`zoom`] } } }, paint: [`paint_fill`, `paint_line`, `paint_circle`, `paint_heatmap`, `paint_fill-extrusion`, `paint_symbol`, `paint_raster`, `paint_hillshade`, `paint_color-relief`, `paint_background`], paint_fill: { "fill-antialias": { type: `boolean`, default: true, expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "fill-opacity": { type: `number`, default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "fill-color": { type: `color`, default: `#000000`, transition: true, requires: [{ "!": `fill-pattern` }], expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "fill-outline-color": { type: `color`, transition: true, requires: [{ "!": `fill-pattern` }, { "fill-antialias": true }], expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "fill-translate": { type: `array`, value: `number`, length: 2, default: [0, 0], transition: true, units: `pixels`, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "fill-translate-anchor": { type: `enum`, values: { map: {}, viewport: {} }, default: `map`, requires: [`fill-translate`], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "fill-pattern": { type: `resolvedImage`, transition: true, expression: { interpolated: false, parameters: [`zoom`, `feature`] }, "property-type": `cross-faded-data-driven` } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: `number`, default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "fill-extrusion-color": { type: `color`, default: `#000000`, transition: true, requires: [{ "!": `fill-extrusion-pattern` }], expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "fill-extrusion-translate": { type: `array`, value: `number`, length: 2, default: [0, 0], transition: true, units: `pixels`, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "fill-extrusion-translate-anchor": { type: `enum`, values: { map: {}, viewport: {} }, default: `map`, requires: [`fill-extrusion-translate`], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "fill-extrusion-pattern": { type: `resolvedImage`, transition: true, expression: { interpolated: false, parameters: [`zoom`, `feature`] }, "property-type": `cross-faded-data-driven` }, "fill-extrusion-height": { type: `number`, default: 0, minimum: 0, units: `meters`, transition: true, expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "fill-extrusion-base": { type: `number`, default: 0, minimum: 0, units: `meters`, transition: true, requires: [`fill-extrusion-height`], expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "fill-extrusion-vertical-gradient": { type: `boolean`, default: true, transition: false, expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` } }, paint_line: { "line-opacity": { type: `number`, default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "line-color": { type: `color`, default: `#000000`, transition: true, requires: [{ "!": `line-pattern` }], expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "line-translate": { type: `array`, value: `number`, length: 2, default: [0, 0], transition: true, units: `pixels`, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "line-translate-anchor": { type: `enum`, values: { map: {}, viewport: {} }, default: `map`, requires: [`line-translate`], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "line-width": { type: `number`, default: 1, minimum: 0, transition: true, units: `pixels`, expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "line-gap-width": { type: `number`, default: 0, minimum: 0, transition: true, units: `pixels`, expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "line-offset": { type: `number`, default: 0, transition: true, units: `pixels`, expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "line-blur": { type: `number`, default: 0, minimum: 0, transition: true, units: `pixels`, expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "line-dasharray": { type: `array`, value: `number`, minimum: 0, transition: true, units: `line widths`, requires: [{ "!": `line-pattern` }], expression: { interpolated: false, parameters: [`zoom`, `feature`] }, "property-type": `cross-faded-data-driven` }, "line-pattern": { type: `resolvedImage`, transition: true, expression: { interpolated: false, parameters: [`zoom`, `feature`] }, "property-type": `cross-faded-data-driven` }, "line-gradient": { type: `color`, transition: false, requires: [{ "!": `line-dasharray` }, { "!": `line-pattern` }, { source: `geojson`, has: { lineMetrics: true } }], expression: { interpolated: true, parameters: [`line-progress`] }, "property-type": `color-ramp` } }, paint_circle: { "circle-radius": { type: `number`, default: 5, minimum: 0, transition: true, units: `pixels`, expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "circle-color": { type: `color`, default: `#000000`, transition: true, expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "circle-blur": { type: `number`, default: 0, transition: true, expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "circle-opacity": { type: `number`, default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "circle-translate": { type: `array`, value: `number`, length: 2, default: [0, 0], transition: true, units: `pixels`, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "circle-translate-anchor": { type: `enum`, values: { map: {}, viewport: {} }, default: `map`, requires: [`circle-translate`], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "circle-pitch-scale": { type: `enum`, values: { map: {}, viewport: {} }, default: `map`, expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "circle-pitch-alignment": { type: `enum`, values: { map: {}, viewport: {} }, default: `viewport`, expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "circle-stroke-width": { type: `number`, default: 0, minimum: 0, transition: true, units: `pixels`, expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "circle-stroke-color": { type: `color`, default: `#000000`, transition: true, expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "circle-stroke-opacity": { type: `number`, default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` } }, paint_heatmap: { "heatmap-radius": { type: `number`, default: 30, minimum: 1, transition: true, units: `pixels`, expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "heatmap-weight": { type: `number`, default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "heatmap-intensity": { type: `number`, default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "heatmap-color": { type: `color`, default: [`interpolate`, [`linear`], [`heatmap-density`], 0, `rgba(0, 0, 255, 0)`, 0.1, `royalblue`, 0.3, `cyan`, 0.5, `lime`, 0.7, `yellow`, 1, `red`], transition: false, expression: { interpolated: true, parameters: [`heatmap-density`] }, "property-type": `color-ramp` }, "heatmap-opacity": { type: `number`, default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` } }, paint_symbol: { "icon-opacity": { type: `number`, default: 1, minimum: 0, maximum: 1, transition: true, requires: [`icon-image`], expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "icon-color": { type: `color`, default: `#000000`, transition: true, requires: [`icon-image`], expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "icon-halo-color": { type: `color`, default: `rgba(0, 0, 0, 0)`, transition: true, requires: [`icon-image`], expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "icon-halo-width": { type: `number`, default: 0, minimum: 0, transition: true, units: `pixels`, requires: [`icon-image`], expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "icon-halo-blur": { type: `number`, default: 0, minimum: 0, transition: true, units: `pixels`, requires: [`icon-image`], expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "icon-translate": { type: `array`, value: `number`, length: 2, default: [0, 0], transition: true, units: `pixels`, requires: [`icon-image`], expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "icon-translate-anchor": { type: `enum`, values: { map: {}, viewport: {} }, default: `map`, requires: [`icon-image`, `icon-translate`], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "text-opacity": { type: `number`, default: 1, minimum: 0, maximum: 1, transition: true, requires: [`text-field`], expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "text-color": { type: `color`, default: `#000000`, transition: true, overridable: true, requires: [`text-field`], expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "text-halo-color": { type: `color`, default: `rgba(0, 0, 0, 0)`, transition: true, requires: [`text-field`], expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "text-halo-width": { type: `number`, default: 0, minimum: 0, transition: true, units: `pixels`, requires: [`text-field`], expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "text-halo-blur": { type: `number`, default: 0, minimum: 0, transition: true, units: `pixels`, requires: [`text-field`], expression: { interpolated: true, parameters: [`zoom`, `feature`, `feature-state`] }, "property-type": `data-driven` }, "text-translate": { type: `array`, value: `number`, length: 2, default: [0, 0], transition: true, units: `pixels`, requires: [`text-field`], expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "text-translate-anchor": { type: `enum`, values: { map: {}, viewport: {} }, default: `map`, requires: [`text-field`, `text-translate`], expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` } }, paint_raster: { "raster-opacity": { type: `number`, default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "raster-hue-rotate": { type: `number`, default: 0, period: 360, transition: true, units: `degrees`, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "raster-brightness-min": { type: `number`, default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "raster-brightness-max": { type: `number`, default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "raster-saturation": { type: `number`, default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "raster-contrast": { type: `number`, default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "raster-resampling": { type: `enum`, values: { linear: {}, nearest: {} }, default: `linear`, expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "raster-fade-duration": { type: `number`, default: 300, minimum: 0, transition: false, units: `milliseconds`, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` } }, paint_hillshade: { "hillshade-illumination-direction": { type: `numberArray`, default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "hillshade-illumination-altitude": { type: `numberArray`, default: 45, minimum: 0, maximum: 90, transition: false, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "hillshade-illumination-anchor": { type: `enum`, values: { map: {}, viewport: {} }, default: `viewport`, expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` }, "hillshade-exaggeration": { type: `number`, default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "hillshade-shadow-color": { type: `colorArray`, default: `#000000`, transition: true, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "hillshade-highlight-color": { type: `colorArray`, default: `#FFFFFF`, transition: true, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "hillshade-accent-color": { type: `color`, default: `#000000`, transition: true, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "hillshade-method": { type: `enum`, values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: `standard`, expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `data-constant` } }, "paint_color-relief": { "color-relief-opacity": { type: `number`, default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "color-relief-color": { type: `color`, transition: false, expression: { interpolated: true, parameters: [`elevation`] }, "property-type": `color-ramp` } }, paint_background: { "background-color": { type: `color`, default: `#000000`, transition: true, requires: [{ "!": `background-pattern` }], expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` }, "background-pattern": { type: `resolvedImage`, transition: true, expression: { interpolated: false, parameters: [`zoom`] }, "property-type": `cross-faded` }, "background-opacity": { type: `number`, default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: [`zoom`] }, "property-type": `data-constant` } }, transition: { duration: { type: `number`, default: 300, minimum: 0, units: `milliseconds` }, delay: { type: `number`, default: 0, minimum: 0, units: `milliseconds` } }, "property-type": { "data-driven": { type: `property-type` }, "cross-faded": { type: `property-type` }, "cross-faded-data-driven": { type: `property-type` }, "color-ramp": { type: `property-type` }, "data-constant": { type: `property-type` }, constant: { type: `property-type` } }, promoteId: { "*": { type: `string` } } };
      let Pe2 = [`type`, `source`, `source-layer`, `minzoom`, `maxzoom`, `filter`, `layout`];
      function Fe2(e6, t5) {
        let n4 = {};
        for (let t6 in e6) t6 !== `ref` && (n4[t6] = e6[t6]);
        return Pe2.forEach(((e7) => {
          e7 in t5 && (n4[e7] = t5[e7]);
        })), n4;
      }
      function Ie2(e6, t5) {
        if (Array.isArray(e6)) {
          if (!Array.isArray(t5) || e6.length !== t5.length) return false;
          for (let n4 = 0; n4 < e6.length; n4++) if (!Ie2(e6[n4], t5[n4])) return false;
          return true;
        }
        if (typeof e6 == `object` && e6 && t5 !== null) {
          if (typeof t5 != `object` || Object.keys(e6).length !== Object.keys(t5).length) return false;
          for (let n4 in e6) if (!Ie2(e6[n4], t5[n4])) return false;
          return true;
        }
        return e6 === t5;
      }
      function Le2(e6, t5) {
        e6.push(t5);
      }
      function Re2(e6, t5, n4) {
        Le2(n4, { command: `addSource`, args: [e6, t5[e6]] });
      }
      function ze2(e6, t5, n4) {
        Le2(t5, { command: `removeSource`, args: [e6] }), n4[e6] = true;
      }
      function Be2(e6, t5, n4, r3) {
        ze2(e6, n4, r3), Re2(e6, t5, n4);
      }
      function Ve2(e6, t5, n4) {
        let r3;
        for (r3 in e6[n4]) if (Object.prototype.hasOwnProperty.call(e6[n4], r3) && r3 !== `data` && !Ie2(e6[n4][r3], t5[n4][r3])) return false;
        for (r3 in t5[n4]) if (Object.prototype.hasOwnProperty.call(t5[n4], r3) && r3 !== `data` && !Ie2(e6[n4][r3], t5[n4][r3])) return false;
        return true;
      }
      function He2(e6, t5, n4, r3, i3, a3) {
        for (let o3 in e6 || (e6 = {}), t5 || (t5 = {}), e6) Object.prototype.hasOwnProperty.call(e6, o3) && (Ie2(e6[o3], t5[o3]) || n4.push({ command: a3, args: [r3, o3, t5[o3], i3] }));
        for (let o3 in t5) Object.prototype.hasOwnProperty.call(t5, o3) && !Object.prototype.hasOwnProperty.call(e6, o3) && (Ie2(e6[o3], t5[o3]) || n4.push({ command: a3, args: [r3, o3, t5[o3], i3] }));
      }
      function Ue2(e6) {
        return e6.id;
      }
      function We2(e6, t5) {
        return e6[t5.id] = t5, e6;
      }
      class z2 {
        constructor(e6, t5, n4, r3) {
          this.message = (e6 ? `${e6}: ` : ``) + n4, r3 && (this.identifier = r3), t5 != null && t5.__line__ && (this.line = t5.__line__);
        }
      }
      function Ge2(e6, ...t5) {
        for (let n4 of t5) for (let t6 in n4) e6[t6] = n4[t6];
        return e6;
      }
      class Ke2 extends Error {
        constructor(e6, t5) {
          super(t5), this.message = t5, this.key = e6;
        }
      }
      class qe2 {
        constructor(e6, t5 = []) {
          this.parent = e6, this.bindings = {};
          for (let [e7, n4] of t5) this.bindings[e7] = n4;
        }
        concat(e6) {
          return new qe2(this, e6);
        }
        get(e6) {
          if (this.bindings[e6]) return this.bindings[e6];
          if (this.parent) return this.parent.get(e6);
          throw Error(`${e6} not found in scope.`);
        }
        has(e6) {
          return !!this.bindings[e6] || !!this.parent && this.parent.has(e6);
        }
      }
      let Je2 = { kind: `null` }, B2 = { kind: `number` }, V2 = { kind: `string` }, H2 = { kind: `boolean` }, Ye2 = { kind: `color` }, Xe2 = { kind: `projectionDefinition` }, Ze2 = { kind: `object` }, U2 = { kind: `value` }, Qe2 = { kind: `collator` }, $e2 = { kind: `formatted` }, et2 = { kind: `padding` }, tt2 = { kind: `colorArray` }, nt2 = { kind: `numberArray` }, rt2 = { kind: `resolvedImage` }, it2 = { kind: `variableAnchorOffsetCollection` };
      function at2(e6, t5) {
        return { kind: `array`, itemType: e6, N: t5 };
      }
      function W2(e6) {
        if (e6.kind === `array`) {
          let t5 = W2(e6.itemType);
          return typeof e6.N == `number` ? `array<${t5}, ${e6.N}>` : e6.itemType.kind === `value` ? `array` : `array<${t5}>`;
        }
        return e6.kind;
      }
      let ot2 = [Je2, B2, V2, H2, Ye2, Xe2, $e2, Ze2, at2(U2), et2, nt2, tt2, rt2, it2];
      function st2(e6, t5) {
        if (t5.kind === `error`) return null;
        if (e6.kind === `array`) {
          if (t5.kind === `array` && (t5.N === 0 && t5.itemType.kind === `value` || !st2(e6.itemType, t5.itemType)) && (typeof e6.N != `number` || e6.N === t5.N)) return null;
        } else {
          if (e6.kind === t5.kind) return null;
          if (e6.kind === `value`) {
            for (let e7 of ot2) if (!st2(e7, t5)) return null;
          }
        }
        return `Expected ${W2(e6)} but found ${W2(t5)} instead.`;
      }
      function ct2(e6, t5) {
        return t5.some(((t6) => t6.kind === e6.kind));
      }
      function lt2(e6, t5) {
        return t5.some(((t6) => t6 === `null` ? e6 === null : t6 === `array` ? Array.isArray(e6) : t6 === `object` ? e6 && !Array.isArray(e6) && typeof e6 == `object` : t6 === typeof e6));
      }
      function ut2(e6, t5) {
        return e6.kind === `array` && t5.kind === `array` ? e6.itemType.kind === t5.itemType.kind && typeof e6.N == `number` : e6.kind === t5.kind;
      }
      let dt2 = 0.96422, ft2 = 0.82521, pt2 = 4 / 29, mt2 = 6 / 29, ht2 = 3 * mt2 * mt2;
      mt2 * mt2 * mt2;
      let gt2 = Math.PI / 180, _t2 = 180 / Math.PI;
      function vt2(e6) {
        return (e6 %= 360) < 0 && (e6 += 360), e6;
      }
      function yt2([e6, t5, n4, r3]) {
        let i3, a3, o3 = xt2((0.2225045 * (e6 = bt2(e6)) + 0.7168786 * (t5 = bt2(t5)) + 0.0606169 * (n4 = bt2(n4))) / 1);
        e6 === t5 && t5 === n4 ? i3 = a3 = o3 : (i3 = xt2((0.4360747 * e6 + 0.3850649 * t5 + 0.1430804 * n4) / dt2), a3 = xt2((0.0139322 * e6 + 0.0971045 * t5 + 0.7141733 * n4) / ft2));
        let s3 = 116 * o3 - 16;
        return [s3 < 0 ? 0 : s3, 500 * (i3 - o3), 200 * (o3 - a3), r3];
      }
      function bt2(e6) {
        return e6 <= 0.04045 ? e6 / 12.92 : ((e6 + 0.055) / 1.055) ** 2.4;
      }
      function xt2(e6) {
        return e6 > 0.008856451679035631 ? e6 ** (1 / 3) : e6 / ht2 + pt2;
      }
      function St2([e6, t5, n4, r3]) {
        let i3 = (e6 + 16) / 116, a3 = isNaN(t5) ? i3 : i3 + t5 / 500, o3 = isNaN(n4) ? i3 : i3 - n4 / 200;
        return i3 = 1 * wt2(i3), a3 = dt2 * wt2(a3), o3 = ft2 * wt2(o3), [Ct2(3.1338561 * a3 - 1.6168667 * i3 - 0.4906146 * o3), Ct2(-0.9787684 * a3 + 1.9161415 * i3 + 0.033454 * o3), Ct2(0.0719453 * a3 - 0.2289914 * i3 + 1.4052427 * o3), r3];
      }
      function Ct2(e6) {
        return (e6 = e6 <= 304e-5 ? 12.92 * e6 : 1.055 * e6 ** (1 / 2.4) - 0.055) < 0 ? 0 : e6 > 1 ? 1 : e6;
      }
      function wt2(e6) {
        return e6 > mt2 ? e6 * e6 * e6 : ht2 * (e6 - pt2);
      }
      let Tt2 = Object.hasOwn || function(e6, t5) {
        return Object.prototype.hasOwnProperty.call(e6, t5);
      };
      function Et2(e6, t5) {
        return Tt2(e6, t5) ? e6[t5] : void 0;
      }
      function Dt2(e6) {
        return parseInt(e6.padEnd(2, e6), 16) / 255;
      }
      function Ot2(e6, t5) {
        return kt2(t5 ? e6 / 100 : e6, 0, 1);
      }
      function kt2(e6, t5, n4) {
        return Math.min(Math.max(t5, e6), n4);
      }
      function At2(e6) {
        return !e6.some(Number.isNaN);
      }
      let jt2 = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
      function Mt2(e6, t5, n4) {
        return e6 + n4 * (t5 - e6);
      }
      function G2(e6, t5, n4) {
        return e6.map(((e7, r3) => Mt2(e7, t5[r3], n4)));
      }
      class K2 {
        constructor(e6, t5, n4, r3 = 1, i3 = true) {
          this.r = e6, this.g = t5, this.b = n4, this.a = r3, i3 || (this.r *= r3, this.g *= r3, this.b *= r3, r3 || this.overwriteGetter(`rgb`, [e6, t5, n4, r3]));
        }
        static parse(e6) {
          if (e6 instanceof K2) return e6;
          if (typeof e6 != `string`) return;
          let t5 = (function(e7) {
            if ((e7 = e7.toLowerCase().trim()) === `transparent`) return [0, 0, 0, 0];
            let t6 = Et2(jt2, e7);
            if (t6) {
              let [e8, n5, r3] = t6;
              return [e8 / 255, n5 / 255, r3 / 255, 1];
            }
            if (e7.startsWith(`#`) && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(e7)) {
              let t7 = e7.length < 6 ? 1 : 2, n5 = 1;
              return [Dt2(e7.slice(n5, n5 += t7)), Dt2(e7.slice(n5, n5 += t7)), Dt2(e7.slice(n5, n5 += t7)), Dt2(e7.slice(n5, n5 + t7) || `ff`)];
            }
            if (e7.startsWith(`rgb`)) {
              let t7 = e7.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (t7) {
                let [e8, n5, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3] = t7, p3 = [i3 || ` `, s3 || ` `, u3].join(``);
                if (p3 === `  ` || p3 === `  /` || p3 === `,,` || p3 === `,,,`) {
                  let e9 = [r3, o3, l3].join(``), t8 = e9 === `%%%` ? 100 : e9 === `` ? 255 : 0;
                  if (t8) {
                    let e10 = [kt2(+n5 / t8, 0, 1), kt2(+a3 / t8, 0, 1), kt2(+c3 / t8, 0, 1), d3 ? Ot2(+d3, f3) : 1];
                    if (At2(e10)) return e10;
                  }
                }
                return;
              }
            }
            let n4 = e7.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
            if (n4) {
              let [e8, t7, r3, i3, a3, o3, s3, c3, l3] = n4, u3 = [r3 || ` `, a3 || ` `, s3].join(``);
              if (u3 === `  ` || u3 === `  /` || u3 === `,,` || u3 === `,,,`) {
                let e9 = [+t7, kt2(+i3, 0, 100), kt2(+o3, 0, 100), c3 ? Ot2(+c3, l3) : 1];
                if (At2(e9)) return (function([e10, t8, n5, r4]) {
                  function i4(r5) {
                    let i5 = (r5 + e10 / 30) % 12, a4 = t8 * Math.min(n5, 1 - n5);
                    return n5 - a4 * Math.max(-1, Math.min(i5 - 3, 9 - i5, 1));
                  }
                  return e10 = vt2(e10), t8 /= 100, n5 /= 100, [i4(0), i4(8), i4(4), r4];
                })(e9);
              }
            }
          })(e6);
          return t5 ? new K2(...t5, false) : void 0;
        }
        get rgb() {
          let { r: e6, g: t5, b: n4, a: r3 } = this, i3 = r3 || 1 / 0;
          return this.overwriteGetter(`rgb`, [e6 / i3, t5 / i3, n4 / i3, r3]);
        }
        get hcl() {
          return this.overwriteGetter(`hcl`, (function(e6) {
            let [t5, n4, r3, i3] = yt2(e6), a3 = Math.sqrt(n4 * n4 + r3 * r3);
            return [Math.round(1e4 * a3) ? vt2(Math.atan2(r3, n4) * _t2) : NaN, a3, t5, i3];
          })(this.rgb));
        }
        get lab() {
          return this.overwriteGetter(`lab`, yt2(this.rgb));
        }
        overwriteGetter(e6, t5) {
          return Object.defineProperty(this, e6, { value: t5 }), t5;
        }
        toString() {
          let [e6, t5, n4, r3] = this.rgb;
          return `rgba(${[e6, t5, n4].map(((e7) => Math.round(255 * e7))).join(`,`)},${r3})`;
        }
        static interpolate(e6, t5, n4, r3 = `rgb`) {
          switch (r3) {
            case `rgb`: {
              let [r4, i3, a3, o3] = G2(e6.rgb, t5.rgb, n4);
              return new K2(r4, i3, a3, o3, false);
            }
            case `hcl`: {
              let [r4, i3, a3, o3] = e6.hcl, [s3, c3, l3, u3] = t5.hcl, d3, f3;
              if (isNaN(r4) || isNaN(s3)) isNaN(r4) ? isNaN(s3) ? d3 = NaN : (d3 = s3, a3 !== 1 && a3 !== 0 || (f3 = c3)) : (d3 = r4, l3 !== 1 && l3 !== 0 || (f3 = i3));
              else {
                let e7 = s3 - r4;
                s3 > r4 && e7 > 180 ? e7 -= 360 : s3 < r4 && r4 - s3 > 180 && (e7 += 360), d3 = r4 + n4 * e7;
              }
              let [p3, m3, h3, g3] = (function([e7, t6, n5, r5]) {
                return e7 = isNaN(e7) ? 0 : e7 * gt2, St2([n5, Math.cos(e7) * t6, Math.sin(e7) * t6, r5]);
              })([d3, f3 ?? Mt2(i3, c3, n4), Mt2(a3, l3, n4), Mt2(o3, u3, n4)]);
              return new K2(p3, m3, h3, g3, false);
            }
            case `lab`: {
              let [r4, i3, a3, o3] = St2(G2(e6.lab, t5.lab, n4));
              return new K2(r4, i3, a3, o3, false);
            }
          }
        }
      }
      K2.black = new K2(0, 0, 0, 1), K2.white = new K2(1, 1, 1, 1), K2.transparent = new K2(0, 0, 0, 0), K2.red = new K2(1, 0, 0, 1);
      class Nt2 {
        constructor(e6, t5, n4) {
          this.sensitivity = e6 ? t5 ? `variant` : `case` : t5 ? `accent` : `base`, this.locale = n4, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: `search` });
        }
        compare(e6, t5) {
          return this.collator.compare(e6, t5);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      let Pt2 = [`bottom`, `center`, `top`];
      class Ft2 {
        constructor(e6, t5, n4, r3, i3, a3) {
          this.text = e6, this.image = t5, this.scale = n4, this.fontStack = r3, this.textColor = i3, this.verticalAlign = a3;
        }
      }
      class It2 {
        constructor(e6) {
          this.sections = e6;
        }
        static fromString(e6) {
          return new It2([new Ft2(e6, null, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some(((e6) => e6.text.length !== 0 || e6.image && e6.image.name.length !== 0));
        }
        static factory(e6) {
          return e6 instanceof It2 ? e6 : It2.fromString(e6);
        }
        toString() {
          return this.sections.length === 0 ? `` : this.sections.map(((e6) => e6.text)).join(``);
        }
      }
      class Lt2 {
        constructor(e6) {
          this.values = e6.slice();
        }
        static parse(e6) {
          if (e6 instanceof Lt2) return e6;
          if (typeof e6 == `number`) return new Lt2([e6, e6, e6, e6]);
          if (Array.isArray(e6) && !(e6.length < 1 || e6.length > 4)) {
            for (let t5 of e6) if (typeof t5 != `number`) return;
            switch (e6.length) {
              case 1:
                e6 = [e6[0], e6[0], e6[0], e6[0]];
                break;
              case 2:
                e6 = [e6[0], e6[1], e6[0], e6[1]];
                break;
              case 3:
                e6 = [e6[0], e6[1], e6[2], e6[1]];
            }
            return new Lt2(e6);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
        static interpolate(e6, t5, n4) {
          return new Lt2(G2(e6.values, t5.values, n4));
        }
      }
      class Rt2 {
        constructor(e6) {
          this.values = e6.slice();
        }
        static parse(e6) {
          if (e6 instanceof Rt2) return e6;
          if (typeof e6 == `number`) return new Rt2([e6]);
          if (Array.isArray(e6)) {
            for (let t5 of e6) if (typeof t5 != `number`) return;
            return new Rt2(e6);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
        static interpolate(e6, t5, n4) {
          return new Rt2(G2(e6.values, t5.values, n4));
        }
      }
      class zt2 {
        constructor(e6) {
          this.values = e6.slice();
        }
        static parse(e6) {
          if (e6 instanceof zt2) return e6;
          if (typeof e6 == `string`) {
            let t6 = K2.parse(e6);
            return t6 ? new zt2([t6]) : void 0;
          }
          if (!Array.isArray(e6)) return;
          let t5 = [];
          for (let n4 of e6) {
            if (typeof n4 != `string`) return;
            let e7 = K2.parse(n4);
            if (!e7) return;
            t5.push(e7);
          }
          return new zt2(t5);
        }
        toString() {
          return JSON.stringify(this.values);
        }
        static interpolate(e6, t5, n4, r3 = `rgb`) {
          let i3 = [];
          if (e6.values.length != t5.values.length) throw Error(`colorArray: Arrays have mismatched length (${e6.values.length} vs. ${t5.values.length}), cannot interpolate.`);
          for (let a3 = 0; a3 < e6.values.length; a3++) i3.push(K2.interpolate(e6.values[a3], t5.values[a3], n4, r3));
          return new zt2(i3);
        }
      }
      class Bt2 extends Error {
        constructor(e6) {
          super(e6), this.name = `RuntimeError`;
        }
        toJSON() {
          return this.message;
        }
      }
      let Vt2 = /* @__PURE__ */ new Set([`center`, `left`, `right`, `top`, `bottom`, `top-left`, `top-right`, `bottom-left`, `bottom-right`]);
      class Ht2 {
        constructor(e6) {
          this.values = e6.slice();
        }
        static parse(e6) {
          if (e6 instanceof Ht2) return e6;
          if (Array.isArray(e6) && !(e6.length < 1) && e6.length % 2 == 0) {
            for (let t5 = 0; t5 < e6.length; t5 += 2) {
              let n4 = e6[t5], r3 = e6[t5 + 1];
              if (typeof n4 != `string` || !Vt2.has(n4) || !Array.isArray(r3) || r3.length !== 2 || typeof r3[0] != `number` || typeof r3[1] != `number`) return;
            }
            return new Ht2(e6);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
        static interpolate(e6, t5, n4) {
          let r3 = e6.values, i3 = t5.values;
          if (r3.length !== i3.length) throw new Bt2(`Cannot interpolate values of different length. from: ${e6.toString()}, to: ${t5.toString()}`);
          let a3 = [];
          for (let e7 = 0; e7 < r3.length; e7 += 2) {
            if (r3[e7] !== i3[e7]) throw new Bt2(`Cannot interpolate values containing mismatched anchors. from[${e7}]: ${r3[e7]}, to[${e7}]: ${i3[e7]}`);
            a3.push(r3[e7]);
            let [t6, o3] = r3[e7 + 1], [s3, c3] = i3[e7 + 1];
            a3.push([Mt2(t6, s3, n4), Mt2(o3, c3, n4)]);
          }
          return new Ht2(a3);
        }
      }
      class Ut2 {
        constructor(e6) {
          this.name = e6.name, this.available = e6.available;
        }
        toString() {
          return this.name;
        }
        static fromString(e6) {
          return e6 ? new Ut2({ name: e6, available: false }) : null;
        }
      }
      class Wt2 {
        constructor(e6, t5, n4) {
          this.from = e6, this.to = t5, this.transition = n4;
        }
        static interpolate(e6, t5, n4) {
          return new Wt2(e6, t5, n4);
        }
        static parse(e6) {
          return e6 instanceof Wt2 ? e6 : Array.isArray(e6) && e6.length === 3 && typeof e6[0] == `string` && typeof e6[1] == `string` && typeof e6[2] == `number` ? new Wt2(e6[0], e6[1], e6[2]) : typeof e6 == `object` && typeof e6.from == `string` && typeof e6.to == `string` && typeof e6.transition == `number` ? new Wt2(e6.from, e6.to, e6.transition) : typeof e6 == `string` ? new Wt2(e6, e6, 1) : void 0;
        }
      }
      function Gt2(e6, t5, n4, r3) {
        return typeof e6 == `number` && e6 >= 0 && e6 <= 255 && typeof t5 == `number` && t5 >= 0 && t5 <= 255 && typeof n4 == `number` && n4 >= 0 && n4 <= 255 ? r3 === void 0 || typeof r3 == `number` && r3 >= 0 && r3 <= 1 ? null : `Invalid rgba value [${[e6, t5, n4, r3].join(`, `)}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof r3 == `number` ? [e6, t5, n4, r3] : [e6, t5, n4]).join(`, `)}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function Kt2(e6) {
        if (e6 === null || typeof e6 == `string` || typeof e6 == `boolean` || typeof e6 == `number` || e6 instanceof Wt2 || e6 instanceof K2 || e6 instanceof Nt2 || e6 instanceof It2 || e6 instanceof Lt2 || e6 instanceof Rt2 || e6 instanceof zt2 || e6 instanceof Ht2 || e6 instanceof Ut2) return true;
        if (Array.isArray(e6)) {
          for (let t5 of e6) if (!Kt2(t5)) return false;
          return true;
        }
        if (typeof e6 == `object`) {
          for (let t5 in e6) if (!Kt2(e6[t5])) return false;
          return true;
        }
        return false;
      }
      function qt2(e6) {
        if (e6 === null) return Je2;
        if (typeof e6 == `string`) return V2;
        if (typeof e6 == `boolean`) return H2;
        if (typeof e6 == `number`) return B2;
        if (e6 instanceof K2) return Ye2;
        if (e6 instanceof Wt2) return Xe2;
        if (e6 instanceof Nt2) return Qe2;
        if (e6 instanceof It2) return $e2;
        if (e6 instanceof Lt2) return et2;
        if (e6 instanceof Rt2) return nt2;
        if (e6 instanceof zt2) return tt2;
        if (e6 instanceof Ht2) return it2;
        if (e6 instanceof Ut2) return rt2;
        if (Array.isArray(e6)) {
          let t5 = e6.length, n4;
          for (let t6 of e6) {
            let e7 = qt2(t6);
            if (n4) {
              if (n4 === e7) continue;
              n4 = U2;
              break;
            }
            n4 = e7;
          }
          return at2(n4 || U2, t5);
        }
        return Ze2;
      }
      function Jt2(e6) {
        let t5 = typeof e6;
        return e6 === null ? `` : t5 === `string` || t5 === `number` || t5 === `boolean` ? String(e6) : e6 instanceof K2 || e6 instanceof Wt2 || e6 instanceof It2 || e6 instanceof Lt2 || e6 instanceof Rt2 || e6 instanceof zt2 || e6 instanceof Ht2 || e6 instanceof Ut2 ? e6.toString() : JSON.stringify(e6);
      }
      class Yt2 {
        constructor(e6, t5) {
          this.type = e6, this.value = t5;
        }
        static parse(e6, t5) {
          if (e6.length !== 2) return t5.error(`'literal' expression requires exactly one argument, but found ${e6.length - 1} instead.`);
          if (!Kt2(e6[1])) return t5.error(`invalid value`);
          let n4 = e6[1], r3 = qt2(n4), i3 = t5.expectedType;
          return r3.kind !== `array` || r3.N !== 0 || !i3 || i3.kind !== `array` || typeof i3.N == `number` && i3.N !== 0 || (r3 = i3), new Yt2(r3, n4);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
      }
      let Xt2 = { string: V2, number: B2, boolean: H2, object: Ze2 };
      class q2 {
        constructor(e6, t5) {
          this.type = e6, this.args = t5;
        }
        static parse(e6, t5) {
          if (e6.length < 2) return t5.error(`Expected at least one argument.`);
          let n4, r3 = 1, i3 = e6[0];
          if (i3 === `array`) {
            let i4, a4;
            if (e6.length > 2) {
              let n5 = e6[1];
              if (typeof n5 != `string` || !(n5 in Xt2) || n5 === `object`) return t5.error(`The item type argument of "array" must be one of string, number, boolean`, 1);
              i4 = Xt2[n5], r3++;
            } else i4 = U2;
            if (e6.length > 3) {
              if (e6[2] !== null && (typeof e6[2] != `number` || e6[2] < 0 || e6[2] !== Math.floor(e6[2]))) return t5.error(`The length argument to "array" must be a positive integer literal`, 2);
              a4 = e6[2], r3++;
            }
            n4 = at2(i4, a4);
          } else {
            if (!Xt2[i3]) throw Error(`Types doesn't contain name = ${i3}`);
            n4 = Xt2[i3];
          }
          let a3 = [];
          for (; r3 < e6.length; r3++) {
            let n5 = t5.parse(e6[r3], r3, U2);
            if (!n5) return null;
            a3.push(n5);
          }
          return new q2(n4, a3);
        }
        evaluate(e6) {
          for (let t5 = 0; t5 < this.args.length; t5++) {
            let n4 = this.args[t5].evaluate(e6);
            if (!st2(this.type, qt2(n4))) return n4;
            if (t5 === this.args.length - 1) throw new Bt2(`Expected value to be of type ${W2(this.type)}, but found ${W2(qt2(n4))} instead.`);
          }
          throw Error();
        }
        eachChild(e6) {
          this.args.forEach(e6);
        }
        outputDefined() {
          return this.args.every(((e6) => e6.outputDefined()));
        }
      }
      let J2 = { "to-boolean": H2, "to-color": Ye2, "to-number": B2, "to-string": V2 };
      class Zt2 {
        constructor(e6, t5) {
          this.type = e6, this.args = t5;
        }
        static parse(e6, t5) {
          if (e6.length < 2) return t5.error(`Expected at least one argument.`);
          let n4 = e6[0];
          if (!J2[n4]) throw Error(`Can't parse ${n4} as it is not part of the known types`);
          if ((n4 === `to-boolean` || n4 === `to-string`) && e6.length !== 2) return t5.error(`Expected one argument.`);
          let r3 = J2[n4], i3 = [];
          for (let n5 = 1; n5 < e6.length; n5++) {
            let r4 = t5.parse(e6[n5], n5, U2);
            if (!r4) return null;
            i3.push(r4);
          }
          return new Zt2(r3, i3);
        }
        evaluate(e6) {
          switch (this.type.kind) {
            case `boolean`:
              return !!this.args[0].evaluate(e6);
            case `color`: {
              let t5, n4;
              for (let r3 of this.args) {
                if (t5 = r3.evaluate(e6), n4 = null, t5 instanceof K2) return t5;
                if (typeof t5 == `string`) {
                  let n5 = e6.parseColor(t5);
                  if (n5) return n5;
                } else if (Array.isArray(t5) && (n4 = t5.length < 3 || t5.length > 4 ? `Invalid rgba value ${JSON.stringify(t5)}: expected an array containing either three or four numeric values.` : Gt2(t5[0], t5[1], t5[2], t5[3]), !n4)) return new K2(t5[0] / 255, t5[1] / 255, t5[2] / 255, t5[3]);
              }
              throw new Bt2(n4 || `Could not parse color from value '${typeof t5 == `string` ? t5 : JSON.stringify(t5)}'`);
            }
            case `padding`: {
              let t5;
              for (let n4 of this.args) {
                t5 = n4.evaluate(e6);
                let r3 = Lt2.parse(t5);
                if (r3) return r3;
              }
              throw new Bt2(`Could not parse padding from value '${typeof t5 == `string` ? t5 : JSON.stringify(t5)}'`);
            }
            case `numberArray`: {
              let t5;
              for (let n4 of this.args) {
                t5 = n4.evaluate(e6);
                let r3 = Rt2.parse(t5);
                if (r3) return r3;
              }
              throw new Bt2(`Could not parse numberArray from value '${typeof t5 == `string` ? t5 : JSON.stringify(t5)}'`);
            }
            case `colorArray`: {
              let t5;
              for (let n4 of this.args) {
                t5 = n4.evaluate(e6);
                let r3 = zt2.parse(t5);
                if (r3) return r3;
              }
              throw new Bt2(`Could not parse colorArray from value '${typeof t5 == `string` ? t5 : JSON.stringify(t5)}'`);
            }
            case `variableAnchorOffsetCollection`: {
              let t5;
              for (let n4 of this.args) {
                t5 = n4.evaluate(e6);
                let r3 = Ht2.parse(t5);
                if (r3) return r3;
              }
              throw new Bt2(`Could not parse variableAnchorOffsetCollection from value '${typeof t5 == `string` ? t5 : JSON.stringify(t5)}'`);
            }
            case `number`: {
              let t5 = null;
              for (let n4 of this.args) {
                if (t5 = n4.evaluate(e6), t5 === null) return 0;
                let r3 = Number(t5);
                if (!isNaN(r3)) return r3;
              }
              throw new Bt2(`Could not convert ${JSON.stringify(t5)} to number.`);
            }
            case `formatted`:
              return It2.fromString(Jt2(this.args[0].evaluate(e6)));
            case `resolvedImage`:
              return Ut2.fromString(Jt2(this.args[0].evaluate(e6)));
            case `projectionDefinition`:
              return this.args[0].evaluate(e6);
            default:
              return Jt2(this.args[0].evaluate(e6));
          }
        }
        eachChild(e6) {
          this.args.forEach(e6);
        }
        outputDefined() {
          return this.args.every(((e6) => e6.outputDefined()));
        }
      }
      let Qt2 = [`Unknown`, `Point`, `LineString`, `Polygon`];
      class $t2 {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
        }
        id() {
          return this.feature && `id` in this.feature ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == `number` ? Qt2[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && `geometry` in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        parseColor(e6) {
          let t5 = this._parseColorCache.get(e6);
          return t5 || (t5 = K2.parse(e6), this._parseColorCache.set(e6, t5)), t5;
        }
      }
      class en2 {
        constructor(e6, t5, n4 = [], r3, i3 = new qe2(), a3 = []) {
          this.registry = e6, this.path = n4, this.key = n4.map(((e7) => `[${e7}]`)).join(``), this.scope = i3, this.errors = a3, this.expectedType = r3, this._isConstant = t5;
        }
        parse(e6, t5, n4, r3, i3 = {}) {
          return t5 ? this.concat(t5, n4, r3)._parse(e6, i3) : this._parse(e6, i3);
        }
        _parse(e6, t5) {
          function n4(e7, t6, n5) {
            return n5 === `assert` ? new q2(t6, [e7]) : n5 === `coerce` ? new Zt2(t6, [e7]) : e7;
          }
          if (e6 !== null && typeof e6 != `string` && typeof e6 != `boolean` && typeof e6 != `number` || (e6 = [`literal`, e6]), Array.isArray(e6)) {
            if (e6.length === 0) return this.error(`Expected an array with at least one element. If you wanted a literal array, use ["literal", []].`);
            let r3 = e6[0];
            if (typeof r3 != `string`) return this.error(`Expression name must be a string, but found ${typeof r3} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            let i3 = this.registry[r3];
            if (i3) {
              let r4 = i3.parse(e6, this);
              if (!r4) return null;
              if (this.expectedType) {
                let e7 = this.expectedType, i4 = r4.type;
                if (e7.kind !== `string` && e7.kind !== `number` && e7.kind !== `boolean` && e7.kind !== `object` && e7.kind !== `array` || i4.kind !== `value`) {
                  if (e7.kind === `projectionDefinition` && [`string`, `array`].includes(i4.kind) || [`color`, `formatted`, `resolvedImage`].includes(e7.kind) && [`value`, `string`].includes(i4.kind) || [`padding`, `numberArray`].includes(e7.kind) && [`value`, `number`, `array`].includes(i4.kind) || e7.kind === `colorArray` && [`value`, `string`, `array`].includes(i4.kind) || e7.kind === `variableAnchorOffsetCollection` && [`value`, `array`].includes(i4.kind)) r4 = n4(r4, e7, t5.typeAnnotation || `coerce`);
                  else if (this.checkSubtype(e7, i4)) return null;
                } else r4 = n4(r4, e7, t5.typeAnnotation || `assert`);
              }
              if (!(r4 instanceof Yt2) && r4.type.kind !== `resolvedImage` && this._isConstant(r4)) {
                let e7 = new $t2();
                try {
                  r4 = new Yt2(r4.type, r4.evaluate(e7));
                } catch (e8) {
                  return this.error(e8.message), null;
                }
              }
              return r4;
            }
            return this.error(`Unknown expression "${r3}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(e6 === void 0 ? `'undefined' value invalid. Use null instead.` : typeof e6 == `object` ? `Bare objects invalid. Use ["literal", {...}] instead.` : `Expected an array, but found ${typeof e6} instead.`);
        }
        concat(e6, t5, n4) {
          let r3 = typeof e6 == `number` ? this.path.concat(e6) : this.path, i3 = n4 ? this.scope.concat(n4) : this.scope;
          return new en2(this.registry, this._isConstant, r3, t5 || null, i3, this.errors);
        }
        error(e6, ...t5) {
          let n4 = `${this.key}${t5.map(((e7) => `[${e7}]`)).join(``)}`;
          this.errors.push(new Ke2(n4, e6));
        }
        checkSubtype(e6, t5) {
          let n4 = st2(e6, t5);
          return n4 && this.error(n4), n4;
        }
      }
      class tn2 {
        constructor(e6, t5) {
          this.type = t5.type, this.bindings = [].concat(e6), this.result = t5;
        }
        evaluate(e6) {
          return this.result.evaluate(e6);
        }
        eachChild(e6) {
          for (let t5 of this.bindings) e6(t5[1]);
          e6(this.result);
        }
        static parse(e6, t5) {
          if (e6.length < 4) return t5.error(`Expected at least 3 arguments, but found ${e6.length - 1} instead.`);
          let n4 = [];
          for (let r4 = 1; r4 < e6.length - 1; r4 += 2) {
            let i3 = e6[r4];
            if (typeof i3 != `string`) return t5.error(`Expected string, but found ${typeof i3} instead.`, r4);
            if (/[^a-zA-Z0-9_]/.test(i3)) return t5.error(`Variable names must contain only alphanumeric characters or '_'.`, r4);
            let a3 = t5.parse(e6[r4 + 1], r4 + 1);
            if (!a3) return null;
            n4.push([i3, a3]);
          }
          let r3 = t5.parse(e6[e6.length - 1], e6.length - 1, t5.expectedType, n4);
          return r3 ? new tn2(n4, r3) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
      }
      class nn2 {
        constructor(e6, t5) {
          this.type = t5.type, this.name = e6, this.boundExpression = t5;
        }
        static parse(e6, t5) {
          if (e6.length !== 2 || typeof e6[1] != `string`) return t5.error(`'var' expression requires exactly one string literal argument.`);
          let n4 = e6[1];
          return t5.scope.has(n4) ? new nn2(n4, t5.scope.get(n4)) : t5.error(`Unknown variable "${n4}". Make sure "${n4}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(e6) {
          return this.boundExpression.evaluate(e6);
        }
        eachChild() {
        }
        outputDefined() {
          return false;
        }
      }
      class rn2 {
        constructor(e6, t5, n4) {
          this.type = e6, this.index = t5, this.input = n4;
        }
        static parse(e6, t5) {
          if (e6.length !== 3) return t5.error(`Expected 2 arguments, but found ${e6.length - 1} instead.`);
          let n4 = t5.parse(e6[1], 1, B2), r3 = t5.parse(e6[2], 2, at2(t5.expectedType || U2));
          return n4 && r3 ? new rn2(r3.type.itemType, n4, r3) : null;
        }
        evaluate(e6) {
          let t5 = this.index.evaluate(e6), n4 = this.input.evaluate(e6);
          if (t5 < 0) throw new Bt2(`Array index out of bounds: ${t5} < 0.`);
          if (t5 >= n4.length) throw new Bt2(`Array index out of bounds: ${t5} > ${n4.length - 1}.`);
          if (t5 !== Math.floor(t5)) throw new Bt2(`Array index must be an integer, but found ${t5} instead.`);
          return n4[t5];
        }
        eachChild(e6) {
          e6(this.index), e6(this.input);
        }
        outputDefined() {
          return false;
        }
      }
      class an2 {
        constructor(e6, t5) {
          this.type = H2, this.needle = e6, this.haystack = t5;
        }
        static parse(e6, t5) {
          if (e6.length !== 3) return t5.error(`Expected 2 arguments, but found ${e6.length - 1} instead.`);
          let n4 = t5.parse(e6[1], 1, U2), r3 = t5.parse(e6[2], 2, U2);
          return n4 && r3 ? ct2(n4.type, [H2, V2, B2, Je2, U2]) ? new an2(n4, r3) : t5.error(`Expected first argument to be of type boolean, string, number or null, but found ${W2(n4.type)} instead`) : null;
        }
        evaluate(e6) {
          let t5 = this.needle.evaluate(e6), n4 = this.haystack.evaluate(e6);
          if (!n4) return false;
          if (!lt2(t5, [`boolean`, `string`, `number`, `null`])) throw new Bt2(`Expected first argument to be of type boolean, string, number or null, but found ${W2(qt2(t5))} instead.`);
          if (!lt2(n4, [`string`, `array`])) throw new Bt2(`Expected second argument to be of type array or string, but found ${W2(qt2(n4))} instead.`);
          return n4.indexOf(t5) >= 0;
        }
        eachChild(e6) {
          e6(this.needle), e6(this.haystack);
        }
        outputDefined() {
          return true;
        }
      }
      class on2 {
        constructor(e6, t5, n4) {
          this.type = B2, this.needle = e6, this.haystack = t5, this.fromIndex = n4;
        }
        static parse(e6, t5) {
          if (e6.length <= 2 || e6.length >= 5) return t5.error(`Expected 2 or 3 arguments, but found ${e6.length - 1} instead.`);
          let n4 = t5.parse(e6[1], 1, U2), r3 = t5.parse(e6[2], 2, U2);
          if (!n4 || !r3) return null;
          if (!ct2(n4.type, [H2, V2, B2, Je2, U2])) return t5.error(`Expected first argument to be of type boolean, string, number or null, but found ${W2(n4.type)} instead`);
          if (e6.length === 4) {
            let i3 = t5.parse(e6[3], 3, B2);
            return i3 ? new on2(n4, r3, i3) : null;
          }
          return new on2(n4, r3);
        }
        evaluate(e6) {
          let t5 = this.needle.evaluate(e6), n4 = this.haystack.evaluate(e6);
          if (!lt2(t5, [`boolean`, `string`, `number`, `null`])) throw new Bt2(`Expected first argument to be of type boolean, string, number or null, but found ${W2(qt2(t5))} instead.`);
          let r3;
          if (this.fromIndex && (r3 = this.fromIndex.evaluate(e6)), lt2(n4, [`string`])) {
            let e7 = n4.indexOf(t5, r3);
            return e7 === -1 ? -1 : [...n4.slice(0, e7)].length;
          }
          if (lt2(n4, [`array`])) return n4.indexOf(t5, r3);
          throw new Bt2(`Expected second argument to be of type array or string, but found ${W2(qt2(n4))} instead.`);
        }
        eachChild(e6) {
          e6(this.needle), e6(this.haystack), this.fromIndex && e6(this.fromIndex);
        }
        outputDefined() {
          return false;
        }
      }
      class sn2 {
        constructor(e6, t5, n4, r3, i3, a3) {
          this.inputType = e6, this.type = t5, this.input = n4, this.cases = r3, this.outputs = i3, this.otherwise = a3;
        }
        static parse(e6, t5) {
          if (e6.length < 5) return t5.error(`Expected at least 4 arguments, but found only ${e6.length - 1}.`);
          if (e6.length % 2 != 1) return t5.error(`Expected an even number of arguments.`);
          let n4, r3;
          t5.expectedType && t5.expectedType.kind !== `value` && (r3 = t5.expectedType);
          let i3 = {}, a3 = [];
          for (let o4 = 2; o4 < e6.length - 1; o4 += 2) {
            let s4 = e6[o4], c3 = e6[o4 + 1];
            Array.isArray(s4) || (s4 = [s4]);
            let l3 = t5.concat(o4);
            if (s4.length === 0) return l3.error(`Expected at least one branch label.`);
            for (let e7 of s4) {
              if (typeof e7 != `number` && typeof e7 != `string`) return l3.error(`Branch labels must be numbers or strings.`);
              if (typeof e7 == `number` && Math.abs(e7) > 2 ** 53 - 1) return l3.error(`Branch labels must be integers no larger than ${2 ** 53 - 1}.`);
              if (typeof e7 == `number` && Math.floor(e7) !== e7) return l3.error(`Numeric branch labels must be integer values.`);
              if (n4) {
                if (l3.checkSubtype(n4, qt2(e7))) return null;
              } else n4 = qt2(e7);
              if (i3[String(e7)] !== void 0) return l3.error(`Branch labels must be unique.`);
              i3[String(e7)] = a3.length;
            }
            let u3 = t5.parse(c3, o4, r3);
            if (!u3) return null;
            r3 || (r3 = u3.type), a3.push(u3);
          }
          let o3 = t5.parse(e6[1], 1, U2);
          if (!o3) return null;
          let s3 = t5.parse(e6[e6.length - 1], e6.length - 1, r3);
          return s3 ? o3.type.kind !== `value` && t5.concat(1).checkSubtype(n4, o3.type) ? null : new sn2(n4, r3, o3, i3, a3, s3) : null;
        }
        evaluate(e6) {
          let t5 = this.input.evaluate(e6);
          return (qt2(t5) === this.inputType && this.outputs[this.cases[t5]] || this.otherwise).evaluate(e6);
        }
        eachChild(e6) {
          e6(this.input), this.outputs.forEach(e6), e6(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every(((e6) => e6.outputDefined())) && this.otherwise.outputDefined();
        }
      }
      class cn2 {
        constructor(e6, t5, n4) {
          this.type = e6, this.branches = t5, this.otherwise = n4;
        }
        static parse(e6, t5) {
          if (e6.length < 4) return t5.error(`Expected at least 3 arguments, but found only ${e6.length - 1}.`);
          if (e6.length % 2 != 0) return t5.error(`Expected an odd number of arguments.`);
          let n4;
          t5.expectedType && t5.expectedType.kind !== `value` && (n4 = t5.expectedType);
          let r3 = [];
          for (let i4 = 1; i4 < e6.length - 1; i4 += 2) {
            let a3 = t5.parse(e6[i4], i4, H2);
            if (!a3) return null;
            let o3 = t5.parse(e6[i4 + 1], i4 + 1, n4);
            if (!o3) return null;
            r3.push([a3, o3]), n4 || (n4 = o3.type);
          }
          let i3 = t5.parse(e6[e6.length - 1], e6.length - 1, n4);
          if (!i3) return null;
          if (!n4) throw Error(`Can't infer output type`);
          return new cn2(n4, r3, i3);
        }
        evaluate(e6) {
          for (let [t5, n4] of this.branches) if (t5.evaluate(e6)) return n4.evaluate(e6);
          return this.otherwise.evaluate(e6);
        }
        eachChild(e6) {
          for (let [t5, n4] of this.branches) e6(t5), e6(n4);
          e6(this.otherwise);
        }
        outputDefined() {
          return this.branches.every((([e6, t5]) => t5.outputDefined())) && this.otherwise.outputDefined();
        }
      }
      class ln2 {
        constructor(e6, t5, n4, r3) {
          this.type = e6, this.input = t5, this.beginIndex = n4, this.endIndex = r3;
        }
        static parse(e6, t5) {
          if (e6.length <= 2 || e6.length >= 5) return t5.error(`Expected 2 or 3 arguments, but found ${e6.length - 1} instead.`);
          let n4 = t5.parse(e6[1], 1, U2), r3 = t5.parse(e6[2], 2, B2);
          if (!n4 || !r3) return null;
          if (!ct2(n4.type, [at2(U2), V2, U2])) return t5.error(`Expected first argument to be of type array or string, but found ${W2(n4.type)} instead`);
          if (e6.length === 4) {
            let i3 = t5.parse(e6[3], 3, B2);
            return i3 ? new ln2(n4.type, n4, r3, i3) : null;
          }
          return new ln2(n4.type, n4, r3);
        }
        evaluate(e6) {
          let t5 = this.input.evaluate(e6), n4 = this.beginIndex.evaluate(e6), r3;
          if (this.endIndex && (r3 = this.endIndex.evaluate(e6)), lt2(t5, [`string`])) return [...t5].slice(n4, r3).join(``);
          if (lt2(t5, [`array`])) return t5.slice(n4, r3);
          throw new Bt2(`Expected first argument to be of type array or string, but found ${W2(qt2(t5))} instead.`);
        }
        eachChild(e6) {
          e6(this.input), e6(this.beginIndex), this.endIndex && e6(this.endIndex);
        }
        outputDefined() {
          return false;
        }
      }
      function un2(e6, t5) {
        let n4 = e6.length - 1, r3, i3, a3 = 0, o3 = n4, s3 = 0;
        for (; a3 <= o3; ) if (s3 = Math.floor((a3 + o3) / 2), r3 = e6[s3], i3 = e6[s3 + 1], r3 <= t5) {
          if (s3 === n4 || t5 < i3) return s3;
          a3 = s3 + 1;
        } else {
          if (!(r3 > t5)) throw new Bt2(`Input is not a number.`);
          o3 = s3 - 1;
        }
        return 0;
      }
      class dn2 {
        constructor(e6, t5, n4) {
          this.type = e6, this.input = t5, this.labels = [], this.outputs = [];
          for (let [e7, t6] of n4) this.labels.push(e7), this.outputs.push(t6);
        }
        static parse(e6, t5) {
          if (e6.length - 1 < 4) return t5.error(`Expected at least 4 arguments, but found only ${e6.length - 1}.`);
          if ((e6.length - 1) % 2 != 0) return t5.error(`Expected an even number of arguments.`);
          let n4 = t5.parse(e6[1], 1, B2);
          if (!n4) return null;
          let r3 = [], i3 = null;
          t5.expectedType && t5.expectedType.kind !== `value` && (i3 = t5.expectedType);
          for (let n5 = 1; n5 < e6.length; n5 += 2) {
            let a3 = n5 === 1 ? -1 / 0 : e6[n5], o3 = e6[n5 + 1], s3 = n5, c3 = n5 + 1;
            if (typeof a3 != `number`) return t5.error(`Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.`, s3);
            if (r3.length && r3[r3.length - 1][0] >= a3) return t5.error(`Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.`, s3);
            let l3 = t5.parse(o3, c3, i3);
            if (!l3) return null;
            i3 || (i3 = l3.type), r3.push([a3, l3]);
          }
          return new dn2(i3, n4, r3);
        }
        evaluate(e6) {
          let t5 = this.labels, n4 = this.outputs;
          if (t5.length === 1) return n4[0].evaluate(e6);
          let r3 = this.input.evaluate(e6);
          if (r3 <= t5[0]) return n4[0].evaluate(e6);
          let i3 = t5.length;
          return r3 >= t5[i3 - 1] ? n4[i3 - 1].evaluate(e6) : n4[un2(t5, r3)].evaluate(e6);
        }
        eachChild(e6) {
          e6(this.input);
          for (let t5 of this.outputs) e6(t5);
        }
        outputDefined() {
          return this.outputs.every(((e6) => e6.outputDefined()));
        }
      }
      function fn2(e6) {
        return e6 && e6.__esModule && Object.prototype.hasOwnProperty.call(e6, `default`) ? e6.default : e6;
      }
      var pn2, mn, hn = fn2((function() {
        if (mn) return pn2;
        function e6(e7, t5, n4, r3) {
          this.cx = 3 * e7, this.bx = 3 * (n4 - e7) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t5, this.by = 3 * (r3 - t5) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e7, this.p1y = t5, this.p2x = n4, this.p2y = r3;
        }
        return mn = 1, pn2 = e6, e6.prototype = { sampleCurveX: function(e7) {
          return ((this.ax * e7 + this.bx) * e7 + this.cx) * e7;
        }, sampleCurveY: function(e7) {
          return ((this.ay * e7 + this.by) * e7 + this.cy) * e7;
        }, sampleCurveDerivativeX: function(e7) {
          return (3 * this.ax * e7 + 2 * this.bx) * e7 + this.cx;
        }, solveCurveX: function(e7, t5) {
          if (t5 === void 0 && (t5 = 1e-6), e7 < 0) return 0;
          if (e7 > 1) return 1;
          for (var n4 = e7, r3 = 0; r3 < 8; r3++) {
            var i3 = this.sampleCurveX(n4) - e7;
            if (Math.abs(i3) < t5) return n4;
            var a3 = this.sampleCurveDerivativeX(n4);
            if (Math.abs(a3) < 1e-6) break;
            n4 -= i3 / a3;
          }
          var o3 = 0, s3 = 1;
          for (n4 = e7, r3 = 0; r3 < 20 && (i3 = this.sampleCurveX(n4), !(Math.abs(i3 - e7) < t5)); r3++) e7 > i3 ? o3 = n4 : s3 = n4, n4 = 0.5 * (s3 - o3) + o3;
          return n4;
        }, solve: function(e7, t5) {
          return this.sampleCurveY(this.solveCurveX(e7, t5));
        } }, pn2;
      })());
      class gn {
        constructor(e6, t5, n4, r3, i3) {
          this.type = e6, this.operator = t5, this.interpolation = n4, this.input = r3, this.labels = [], this.outputs = [];
          for (let [e7, t6] of i3) this.labels.push(e7), this.outputs.push(t6);
        }
        static interpolationFactor(e6, t5, n4, r3) {
          let i3 = 0;
          if (e6.name === `exponential`) i3 = _n(t5, e6.base, n4, r3);
          else if (e6.name === `linear`) i3 = _n(t5, 1, n4, r3);
          else if (e6.name === `cubic-bezier`) {
            let a3 = e6.controlPoints;
            i3 = new hn(a3[0], a3[1], a3[2], a3[3]).solve(_n(t5, 1, n4, r3));
          }
          return i3;
        }
        static parse(e6, t5) {
          let [n4, r3, i3, ...a3] = e6;
          if (!Array.isArray(r3) || r3.length === 0) return t5.error(`Expected an interpolation type expression.`, 1);
          if (r3[0] === `linear`) r3 = { name: `linear` };
          else if (r3[0] === `exponential`) {
            let e7 = r3[1];
            if (typeof e7 != `number`) return t5.error(`Exponential interpolation requires a numeric base.`, 1, 1);
            r3 = { name: `exponential`, base: e7 };
          } else {
            if (r3[0] !== `cubic-bezier`) return t5.error(`Unknown interpolation type ${String(r3[0])}`, 1, 0);
            {
              let e7 = r3.slice(1);
              if (e7.length !== 4 || e7.some(((e8) => typeof e8 != `number` || e8 < 0 || e8 > 1))) return t5.error(`Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.`, 1);
              r3 = { name: `cubic-bezier`, controlPoints: e7 };
            }
          }
          if (e6.length - 1 < 4) return t5.error(`Expected at least 4 arguments, but found only ${e6.length - 1}.`);
          if ((e6.length - 1) % 2 != 0) return t5.error(`Expected an even number of arguments.`);
          if (i3 = t5.parse(i3, 2, B2), !i3) return null;
          let o3 = [], s3 = null;
          n4 !== `interpolate-hcl` && n4 !== `interpolate-lab` || t5.expectedType == tt2 ? t5.expectedType && t5.expectedType.kind !== `value` && (s3 = t5.expectedType) : s3 = Ye2;
          for (let e7 = 0; e7 < a3.length; e7 += 2) {
            let n5 = a3[e7], r4 = a3[e7 + 1], i4 = e7 + 3, c3 = e7 + 4;
            if (typeof n5 != `number`) return t5.error(`Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.`, i4);
            if (o3.length && o3[o3.length - 1][0] >= n5) return t5.error(`Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.`, i4);
            let l3 = t5.parse(r4, c3, s3);
            if (!l3) return null;
            s3 || (s3 = l3.type), o3.push([n5, l3]);
          }
          return ut2(s3, B2) || ut2(s3, Xe2) || ut2(s3, Ye2) || ut2(s3, et2) || ut2(s3, nt2) || ut2(s3, tt2) || ut2(s3, it2) || ut2(s3, at2(B2)) ? new gn(s3, n4, r3, i3, o3) : t5.error(`Type ${W2(s3)} is not interpolatable.`);
        }
        evaluate(e6) {
          let t5 = this.labels, n4 = this.outputs;
          if (t5.length === 1) return n4[0].evaluate(e6);
          let r3 = this.input.evaluate(e6);
          if (r3 <= t5[0]) return n4[0].evaluate(e6);
          let i3 = t5.length;
          if (r3 >= t5[i3 - 1]) return n4[i3 - 1].evaluate(e6);
          let a3 = un2(t5, r3), o3 = gn.interpolationFactor(this.interpolation, r3, t5[a3], t5[a3 + 1]), s3 = n4[a3].evaluate(e6), c3 = n4[a3 + 1].evaluate(e6);
          switch (this.operator) {
            case `interpolate`:
              switch (this.type.kind) {
                case `number`:
                  return Mt2(s3, c3, o3);
                case `color`:
                  return K2.interpolate(s3, c3, o3);
                case `padding`:
                  return Lt2.interpolate(s3, c3, o3);
                case `colorArray`:
                  return zt2.interpolate(s3, c3, o3);
                case `numberArray`:
                  return Rt2.interpolate(s3, c3, o3);
                case `variableAnchorOffsetCollection`:
                  return Ht2.interpolate(s3, c3, o3);
                case `array`:
                  return G2(s3, c3, o3);
                case `projectionDefinition`:
                  return Wt2.interpolate(s3, c3, o3);
              }
            case `interpolate-hcl`:
              switch (this.type.kind) {
                case `color`:
                  return K2.interpolate(s3, c3, o3, `hcl`);
                case `colorArray`:
                  return zt2.interpolate(s3, c3, o3, `hcl`);
              }
            case `interpolate-lab`:
              switch (this.type.kind) {
                case `color`:
                  return K2.interpolate(s3, c3, o3, `lab`);
                case `colorArray`:
                  return zt2.interpolate(s3, c3, o3, `lab`);
              }
          }
        }
        eachChild(e6) {
          e6(this.input);
          for (let t5 of this.outputs) e6(t5);
        }
        outputDefined() {
          return this.outputs.every(((e6) => e6.outputDefined()));
        }
      }
      function _n(e6, t5, n4, r3) {
        let i3 = r3 - n4, a3 = e6 - n4;
        return i3 === 0 ? 0 : t5 === 1 ? a3 / i3 : (t5 ** +a3 - 1) / (t5 ** +i3 - 1);
      }
      let vn = { color: K2.interpolate, number: Mt2, padding: Lt2.interpolate, numberArray: Rt2.interpolate, colorArray: zt2.interpolate, variableAnchorOffsetCollection: Ht2.interpolate, array: G2 };
      class yn {
        constructor(e6, t5) {
          this.type = e6, this.args = t5;
        }
        static parse(e6, t5) {
          if (e6.length < 2) return t5.error(`Expected at least one argument.`);
          let n4 = null, r3 = t5.expectedType;
          r3 && r3.kind !== `value` && (n4 = r3);
          let i3 = [];
          for (let r4 of e6.slice(1)) {
            let e7 = t5.parse(r4, 1 + i3.length, n4, void 0, { typeAnnotation: `omit` });
            if (!e7) return null;
            n4 || (n4 = e7.type), i3.push(e7);
          }
          if (!n4) throw Error(`No output type`);
          return new yn(r3 && i3.some(((e7) => st2(r3, e7.type))) ? U2 : n4, i3);
        }
        evaluate(e6) {
          let t5, n4 = null, r3 = 0;
          for (let i3 of this.args) if (r3++, n4 = i3.evaluate(e6), n4 && n4 instanceof Ut2 && !n4.available && (t5 || (t5 = n4.name), n4 = null, r3 === this.args.length && (n4 = t5)), n4 !== null) break;
          return n4;
        }
        eachChild(e6) {
          this.args.forEach(e6);
        }
        outputDefined() {
          return this.args.every(((e6) => e6.outputDefined()));
        }
      }
      function bn(e6, t5) {
        return e6 === `==` || e6 === `!=` ? t5.kind === `boolean` || t5.kind === `string` || t5.kind === `number` || t5.kind === `null` || t5.kind === `value` : t5.kind === `string` || t5.kind === `number` || t5.kind === `value`;
      }
      function xn(e6, t5, n4, r3) {
        return r3.compare(t5, n4) === 0;
      }
      function Sn(e6, t5, n4) {
        let r3 = e6 !== `==` && e6 !== `!=`;
        return class i3 {
          constructor(e7, t6, n5) {
            this.type = H2, this.lhs = e7, this.rhs = t6, this.collator = n5, this.hasUntypedArgument = e7.type.kind === `value` || t6.type.kind === `value`;
          }
          static parse(e7, t6) {
            if (e7.length !== 3 && e7.length !== 4) return t6.error(`Expected two or three arguments.`);
            let n5 = e7[0], a3 = t6.parse(e7[1], 1, U2);
            if (!a3) return null;
            if (!bn(n5, a3.type)) return t6.concat(1).error(`"${n5}" comparisons are not supported for type '${W2(a3.type)}'.`);
            let o3 = t6.parse(e7[2], 2, U2);
            if (!o3) return null;
            if (!bn(n5, o3.type)) return t6.concat(2).error(`"${n5}" comparisons are not supported for type '${W2(o3.type)}'.`);
            if (a3.type.kind !== o3.type.kind && a3.type.kind !== `value` && o3.type.kind !== `value`) return t6.error(`Cannot compare types '${W2(a3.type)}' and '${W2(o3.type)}'.`);
            r3 && (a3.type.kind === `value` && o3.type.kind !== `value` ? a3 = new q2(o3.type, [a3]) : a3.type.kind !== `value` && o3.type.kind === `value` && (o3 = new q2(a3.type, [o3])));
            let s3 = null;
            if (e7.length === 4) {
              if (a3.type.kind !== `string` && o3.type.kind !== `string` && a3.type.kind !== `value` && o3.type.kind !== `value`) return t6.error(`Cannot use collator to compare non-string types.`);
              if (s3 = t6.parse(e7[3], 3, Qe2), !s3) return null;
            }
            return new i3(a3, o3, s3);
          }
          evaluate(i4) {
            let a3 = this.lhs.evaluate(i4), o3 = this.rhs.evaluate(i4);
            if (r3 && this.hasUntypedArgument) {
              let t6 = qt2(a3), n5 = qt2(o3);
              if (t6.kind !== n5.kind || t6.kind !== `string` && t6.kind !== `number`) throw new Bt2(`Expected arguments for "${e6}" to be (string, string) or (number, number), but found (${t6.kind}, ${n5.kind}) instead.`);
            }
            if (this.collator && !r3 && this.hasUntypedArgument) {
              let e7 = qt2(a3), n5 = qt2(o3);
              if (e7.kind !== `string` || n5.kind !== `string`) return t5(i4, a3, o3);
            }
            return this.collator ? n4(i4, a3, o3, this.collator.evaluate(i4)) : t5(i4, a3, o3);
          }
          eachChild(e7) {
            e7(this.lhs), e7(this.rhs), this.collator && e7(this.collator);
          }
          outputDefined() {
            return true;
          }
        };
      }
      let Cn = Sn(`==`, (function(e6, t5, n4) {
        return t5 === n4;
      }), xn), wn = Sn(`!=`, (function(e6, t5, n4) {
        return t5 !== n4;
      }), (function(e6, t5, n4, r3) {
        return !xn(0, t5, n4, r3);
      })), Tn = Sn(`<`, (function(e6, t5, n4) {
        return t5 < n4;
      }), (function(e6, t5, n4, r3) {
        return r3.compare(t5, n4) < 0;
      })), En = Sn(`>`, (function(e6, t5, n4) {
        return t5 > n4;
      }), (function(e6, t5, n4, r3) {
        return r3.compare(t5, n4) > 0;
      })), Dn = Sn(`<=`, (function(e6, t5, n4) {
        return t5 <= n4;
      }), (function(e6, t5, n4, r3) {
        return r3.compare(t5, n4) <= 0;
      })), On = Sn(`>=`, (function(e6, t5, n4) {
        return t5 >= n4;
      }), (function(e6, t5, n4, r3) {
        return r3.compare(t5, n4) >= 0;
      }));
      class kn {
        constructor(e6, t5, n4) {
          this.type = Qe2, this.locale = n4, this.caseSensitive = e6, this.diacriticSensitive = t5;
        }
        static parse(e6, t5) {
          if (e6.length !== 2) return t5.error(`Expected one argument.`);
          let n4 = e6[1];
          if (typeof n4 != `object` || Array.isArray(n4)) return t5.error(`Collator options argument must be an object.`);
          let r3 = t5.parse(n4[`case-sensitive`] !== void 0 && n4[`case-sensitive`], 1, H2);
          if (!r3) return null;
          let i3 = t5.parse(n4[`diacritic-sensitive`] !== void 0 && n4[`diacritic-sensitive`], 1, H2);
          if (!i3) return null;
          let a3 = null;
          return n4.locale && (a3 = t5.parse(n4.locale, 1, V2), !a3) ? null : new kn(r3, i3, a3);
        }
        evaluate(e6) {
          return new Nt2(this.caseSensitive.evaluate(e6), this.diacriticSensitive.evaluate(e6), this.locale ? this.locale.evaluate(e6) : null);
        }
        eachChild(e6) {
          e6(this.caseSensitive), e6(this.diacriticSensitive), this.locale && e6(this.locale);
        }
        outputDefined() {
          return false;
        }
      }
      class An {
        constructor(e6, t5, n4, r3, i3) {
          this.type = V2, this.number = e6, this.locale = t5, this.currency = n4, this.minFractionDigits = r3, this.maxFractionDigits = i3;
        }
        static parse(e6, t5) {
          if (e6.length !== 3) return t5.error(`Expected two arguments.`);
          let n4 = t5.parse(e6[1], 1, B2);
          if (!n4) return null;
          let r3 = e6[2];
          if (typeof r3 != `object` || Array.isArray(r3)) return t5.error(`NumberFormat options argument must be an object.`);
          let i3 = null;
          if (r3.locale && (i3 = t5.parse(r3.locale, 1, V2), !i3)) return null;
          let a3 = null;
          if (r3.currency && (a3 = t5.parse(r3.currency, 1, V2), !a3)) return null;
          let o3 = null;
          if (r3[`min-fraction-digits`] && (o3 = t5.parse(r3[`min-fraction-digits`], 1, B2), !o3)) return null;
          let s3 = null;
          return r3[`max-fraction-digits`] && (s3 = t5.parse(r3[`max-fraction-digits`], 1, B2), !s3) ? null : new An(n4, i3, a3, o3, s3);
        }
        evaluate(e6) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e6) : [], { style: this.currency ? `currency` : `decimal`, currency: this.currency ? this.currency.evaluate(e6) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e6) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e6) : void 0 }).format(this.number.evaluate(e6));
        }
        eachChild(e6) {
          e6(this.number), this.locale && e6(this.locale), this.currency && e6(this.currency), this.minFractionDigits && e6(this.minFractionDigits), this.maxFractionDigits && e6(this.maxFractionDigits);
        }
        outputDefined() {
          return false;
        }
      }
      class jn {
        constructor(e6) {
          this.type = $e2, this.sections = e6;
        }
        static parse(e6, t5) {
          if (e6.length < 2) return t5.error(`Expected at least one argument.`);
          let n4 = e6[1];
          if (!Array.isArray(n4) && typeof n4 == `object`) return t5.error(`First argument must be an image or text section.`);
          let r3 = [], i3 = false;
          for (let n5 = 1; n5 <= e6.length - 1; ++n5) {
            let a3 = e6[n5];
            if (i3 && typeof a3 == `object` && !Array.isArray(a3)) {
              i3 = false;
              let e7 = null;
              if (a3[`font-scale`] && (e7 = t5.parse(a3[`font-scale`], 1, B2), !e7)) return null;
              let n6 = null;
              if (a3[`text-font`] && (n6 = t5.parse(a3[`text-font`], 1, at2(V2)), !n6)) return null;
              let o3 = null;
              if (a3[`text-color`] && (o3 = t5.parse(a3[`text-color`], 1, Ye2), !o3)) return null;
              let s3 = null;
              if (a3[`vertical-align`]) {
                if (typeof a3[`vertical-align`] == `string` && !Pt2.includes(a3[`vertical-align`])) return t5.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${a3[`vertical-align`]}' instead.`);
                if (s3 = t5.parse(a3[`vertical-align`], 1, V2), !s3) return null;
              }
              let c3 = r3[r3.length - 1];
              c3.scale = e7, c3.font = n6, c3.textColor = o3, c3.verticalAlign = s3;
            } else {
              let a4 = t5.parse(e6[n5], 1, U2);
              if (!a4) return null;
              let o3 = a4.type.kind;
              if (o3 !== `string` && o3 !== `value` && o3 !== `null` && o3 !== `resolvedImage`) return t5.error(`Formatted text type must be 'string', 'value', 'image' or 'null'.`);
              i3 = true, r3.push({ content: a4, scale: null, font: null, textColor: null, verticalAlign: null });
            }
          }
          return new jn(r3);
        }
        evaluate(e6) {
          return new It2(this.sections.map(((t5) => {
            let n4 = t5.content.evaluate(e6);
            return qt2(n4) === rt2 ? new Ft2(``, n4, null, null, null, t5.verticalAlign ? t5.verticalAlign.evaluate(e6) : null) : new Ft2(Jt2(n4), null, t5.scale ? t5.scale.evaluate(e6) : null, t5.font ? t5.font.evaluate(e6).join(`,`) : null, t5.textColor ? t5.textColor.evaluate(e6) : null, t5.verticalAlign ? t5.verticalAlign.evaluate(e6) : null);
          })));
        }
        eachChild(e6) {
          for (let t5 of this.sections) e6(t5.content), t5.scale && e6(t5.scale), t5.font && e6(t5.font), t5.textColor && e6(t5.textColor), t5.verticalAlign && e6(t5.verticalAlign);
        }
        outputDefined() {
          return false;
        }
      }
      class Mn {
        constructor(e6) {
          this.type = rt2, this.input = e6;
        }
        static parse(e6, t5) {
          if (e6.length !== 2) return t5.error(`Expected two arguments.`);
          let n4 = t5.parse(e6[1], 1, V2);
          return n4 ? new Mn(n4) : t5.error(`No image name provided.`);
        }
        evaluate(e6) {
          let t5 = this.input.evaluate(e6), n4 = Ut2.fromString(t5);
          return n4 && e6.availableImages && (n4.available = e6.availableImages.indexOf(t5) > -1), n4;
        }
        eachChild(e6) {
          e6(this.input);
        }
        outputDefined() {
          return false;
        }
      }
      class Nn {
        constructor(e6) {
          this.type = B2, this.input = e6;
        }
        static parse(e6, t5) {
          if (e6.length !== 2) return t5.error(`Expected 1 argument, but found ${e6.length - 1} instead.`);
          let n4 = t5.parse(e6[1], 1);
          return n4 ? n4.type.kind !== `array` && n4.type.kind !== `string` && n4.type.kind !== `value` ? t5.error(`Expected argument of type string or array, but found ${W2(n4.type)} instead.`) : new Nn(n4) : null;
        }
        evaluate(e6) {
          let t5 = this.input.evaluate(e6);
          if (typeof t5 == `string`) return [...t5].length;
          if (Array.isArray(t5)) return t5.length;
          throw new Bt2(`Expected value to be of type string or array, but found ${W2(qt2(t5))} instead.`);
        }
        eachChild(e6) {
          e6(this.input);
        }
        outputDefined() {
          return false;
        }
      }
      let Pn = 8192;
      function Fn(e6, t5) {
        let n4 = (180 + e6[0]) / 360, r3 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e6[1] * Math.PI / 360))) / 360, i3 = 2 ** t5.z;
        return [Math.round(n4 * i3 * Pn), Math.round(r3 * i3 * Pn)];
      }
      function In(e6, t5) {
        let n4 = 2 ** t5.z;
        return [(i3 = (e6[0] / Pn + t5.x) / n4, 360 * i3 - 180), (r3 = (e6[1] / Pn + t5.y) / n4, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * r3) * Math.PI / 180)) - 90)];
        var r3, i3;
      }
      function Ln(e6, t5) {
        e6[0] = Math.min(e6[0], t5[0]), e6[1] = Math.min(e6[1], t5[1]), e6[2] = Math.max(e6[2], t5[0]), e6[3] = Math.max(e6[3], t5[1]);
      }
      function Rn(e6, t5) {
        return !(e6[0] <= t5[0] || e6[2] >= t5[2] || e6[1] <= t5[1] || e6[3] >= t5[3]);
      }
      function zn(e6, t5, n4) {
        let r3 = e6[0] - t5[0], i3 = e6[1] - t5[1], a3 = e6[0] - n4[0], o3 = e6[1] - n4[1];
        return r3 * o3 - a3 * i3 == 0 && r3 * a3 <= 0 && i3 * o3 <= 0;
      }
      function Bn(e6, t5, n4, r3) {
        return (i3 = [r3[0] - n4[0], r3[1] - n4[1]])[0] * (a3 = [t5[0] - e6[0], t5[1] - e6[1]])[1] - i3[1] * a3[0] != 0 && !(!Kn(e6, t5, n4, r3) || !Kn(n4, r3, e6, t5));
        var i3, a3;
      }
      function Vn(e6, t5, n4) {
        for (let r3 of n4) for (let n5 = 0; n5 < r3.length - 1; ++n5) if (Bn(e6, t5, r3[n5], r3[n5 + 1])) return true;
        return false;
      }
      function Hn(e6, t5, n4 = false) {
        let r3 = false;
        for (let s3 of t5) for (let t6 = 0; t6 < s3.length - 1; t6++) {
          if (zn(e6, s3[t6], s3[t6 + 1])) return n4;
          (a3 = s3[t6])[1] > (i3 = e6)[1] != (o3 = s3[t6 + 1])[1] > i3[1] && i3[0] < (o3[0] - a3[0]) * (i3[1] - a3[1]) / (o3[1] - a3[1]) + a3[0] && (r3 = !r3);
        }
        var i3, a3, o3;
        return r3;
      }
      function Un(e6, t5) {
        for (let n4 of t5) if (Hn(e6, n4)) return true;
        return false;
      }
      function Wn(e6, t5) {
        for (let n4 of e6) if (!Hn(n4, t5)) return false;
        for (let n4 = 0; n4 < e6.length - 1; ++n4) if (Vn(e6[n4], e6[n4 + 1], t5)) return false;
        return true;
      }
      function Gn(e6, t5) {
        for (let n4 of t5) if (Wn(e6, n4)) return true;
        return false;
      }
      function Kn(e6, t5, n4, r3) {
        let i3 = r3[0] - n4[0], a3 = r3[1] - n4[1], o3 = (e6[0] - n4[0]) * a3 - i3 * (e6[1] - n4[1]), s3 = (t5[0] - n4[0]) * a3 - i3 * (t5[1] - n4[1]);
        return o3 > 0 && s3 < 0 || o3 < 0 && s3 > 0;
      }
      function qn(e6, t5, n4) {
        let r3 = [];
        for (let i3 = 0; i3 < e6.length; i3++) {
          let a3 = [];
          for (let r4 = 0; r4 < e6[i3].length; r4++) {
            let o3 = Fn(e6[i3][r4], n4);
            Ln(t5, o3), a3.push(o3);
          }
          r3.push(a3);
        }
        return r3;
      }
      function Jn(e6, t5, n4) {
        let r3 = [];
        for (let i3 = 0; i3 < e6.length; i3++) {
          let a3 = qn(e6[i3], t5, n4);
          r3.push(a3);
        }
        return r3;
      }
      function Yn(e6, t5, n4, r3) {
        if (e6[0] < n4[0] || e6[0] > n4[2]) {
          let t6 = 0.5 * r3, i3 = e6[0] - n4[0] > t6 ? -r3 : n4[0] - e6[0] > t6 ? r3 : 0;
          i3 === 0 && (i3 = e6[0] - n4[2] > t6 ? -r3 : n4[2] - e6[0] > t6 ? r3 : 0), e6[0] += i3;
        }
        Ln(t5, e6);
      }
      function Xn(e6, t5, n4, r3) {
        let i3 = 2 ** r3.z * Pn, a3 = [r3.x * Pn, r3.y * Pn], o3 = [];
        for (let r4 of e6) for (let e7 of r4) {
          let r5 = [e7.x + a3[0], e7.y + a3[1]];
          Yn(r5, t5, n4, i3), o3.push(r5);
        }
        return o3;
      }
      function Zn(e6, t5, n4, r3) {
        let i3 = 2 ** r3.z * Pn, a3 = [r3.x * Pn, r3.y * Pn], o3 = [];
        for (let n5 of e6) {
          let e7 = [];
          for (let r4 of n5) {
            let n6 = [r4.x + a3[0], r4.y + a3[1]];
            Ln(t5, n6), e7.push(n6);
          }
          o3.push(e7);
        }
        if (t5[2] - t5[0] <= i3 / 2) {
          (s3 = t5)[0] = s3[1] = 1 / 0, s3[2] = s3[3] = -1 / 0;
          for (let e7 of o3) for (let r4 of e7) Yn(r4, t5, n4, i3);
        }
        var s3;
        return o3;
      }
      class Qn {
        constructor(e6, t5) {
          this.type = H2, this.geojson = e6, this.geometries = t5;
        }
        static parse(e6, t5) {
          if (e6.length !== 2) return t5.error(`'within' expression requires exactly one argument, but found ${e6.length - 1} instead.`);
          if (Kt2(e6[1])) {
            let t6 = e6[1];
            if (t6.type === `FeatureCollection`) {
              let e7 = [];
              for (let n4 of t6.features) {
                let { type: t7, coordinates: r3 } = n4.geometry;
                t7 === `Polygon` && e7.push(r3), t7 === `MultiPolygon` && e7.push(...r3);
              }
              if (e7.length) return new Qn(t6, { type: `MultiPolygon`, coordinates: e7 });
            } else if (t6.type === `Feature`) {
              let e7 = t6.geometry.type;
              if (e7 === `Polygon` || e7 === `MultiPolygon`) return new Qn(t6, t6.geometry);
            } else if (t6.type === `Polygon` || t6.type === `MultiPolygon`) return new Qn(t6, t6);
          }
          return t5.error(`'within' expression requires valid geojson object that contains polygon geometry type.`);
        }
        evaluate(e6) {
          if (e6.geometry() != null && e6.canonicalID() != null) {
            if (e6.geometryType() === `Point`) return (function(e7, t5) {
              let n4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i3 = e7.canonicalID();
              if (t5.type === `Polygon`) {
                let a3 = qn(t5.coordinates, r3, i3), o3 = Xn(e7.geometry(), n4, r3, i3);
                if (!Rn(n4, r3)) return false;
                for (let e8 of o3) if (!Hn(e8, a3)) return false;
              }
              if (t5.type === `MultiPolygon`) {
                let a3 = Jn(t5.coordinates, r3, i3), o3 = Xn(e7.geometry(), n4, r3, i3);
                if (!Rn(n4, r3)) return false;
                for (let e8 of o3) if (!Un(e8, a3)) return false;
              }
              return true;
            })(e6, this.geometries);
            if (e6.geometryType() === `LineString`) return (function(e7, t5) {
              let n4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], r3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i3 = e7.canonicalID();
              if (t5.type === `Polygon`) {
                let a3 = qn(t5.coordinates, r3, i3), o3 = Zn(e7.geometry(), n4, r3, i3);
                if (!Rn(n4, r3)) return false;
                for (let e8 of o3) if (!Wn(e8, a3)) return false;
              }
              if (t5.type === `MultiPolygon`) {
                let a3 = Jn(t5.coordinates, r3, i3), o3 = Zn(e7.geometry(), n4, r3, i3);
                if (!Rn(n4, r3)) return false;
                for (let e8 of o3) if (!Gn(e8, a3)) return false;
              }
              return true;
            })(e6, this.geometries);
          }
          return false;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
      }
      let $n = class {
        constructor(e6 = [], t5 = (e7, t6) => e7 < t6 ? -1 : e7 > t6 ? 1 : 0) {
          if (this.data = e6, this.length = this.data.length, this.compare = t5, this.length > 0) for (let e7 = (this.length >> 1) - 1; e7 >= 0; e7--) this._down(e7);
        }
        push(e6) {
          this.data.push(e6), this._up(this.length++);
        }
        pop() {
          if (this.length === 0) return;
          let e6 = this.data[0], t5 = this.data.pop();
          return --this.length > 0 && (this.data[0] = t5, this._down(0)), e6;
        }
        peek() {
          return this.data[0];
        }
        _up(e6) {
          let { data: t5, compare: n4 } = this, r3 = t5[e6];
          for (; e6 > 0; ) {
            let i3 = e6 - 1 >> 1, a3 = t5[i3];
            if (n4(r3, a3) >= 0) break;
            t5[e6] = a3, e6 = i3;
          }
          t5[e6] = r3;
        }
        _down(e6) {
          let { data: t5, compare: n4 } = this, r3 = this.length >> 1, i3 = t5[e6];
          for (; e6 < r3; ) {
            let r4 = 1 + (e6 << 1), a3 = r4 + 1;
            if (a3 < this.length && n4(t5[a3], t5[r4]) < 0 && (r4 = a3), n4(t5[r4], i3) >= 0) break;
            t5[e6] = t5[r4], e6 = r4;
          }
          t5[e6] = i3;
        }
      };
      function er(e6, t5, n4 = 0, r3 = e6.length - 1, i3 = nr) {
        for (; r3 > n4; ) {
          if (r3 - n4 > 600) {
            let a4 = r3 - n4 + 1, o4 = t5 - n4 + 1, s4 = Math.log(a4), c3 = 0.5 * Math.exp(2 * s4 / 3), l3 = 0.5 * Math.sqrt(s4 * c3 * (a4 - c3) / a4) * (o4 - a4 / 2 < 0 ? -1 : 1);
            er(e6, t5, Math.max(n4, Math.floor(t5 - o4 * c3 / a4 + l3)), Math.min(r3, Math.floor(t5 + (a4 - o4) * c3 / a4 + l3)), i3);
          }
          let a3 = e6[t5], o3 = n4, s3 = r3;
          for (tr(e6, n4, t5), i3(e6[r3], a3) > 0 && tr(e6, n4, r3); o3 < s3; ) {
            for (tr(e6, o3, s3), o3++, s3--; i3(e6[o3], a3) < 0; ) o3++;
            for (; i3(e6[s3], a3) > 0; ) s3--;
          }
          i3(e6[n4], a3) === 0 ? tr(e6, n4, s3) : (s3++, tr(e6, s3, r3)), s3 <= t5 && (n4 = s3 + 1), t5 <= s3 && (r3 = s3 - 1);
        }
      }
      function tr(e6, t5, n4) {
        let r3 = e6[t5];
        e6[t5] = e6[n4], e6[n4] = r3;
      }
      function nr(e6, t5) {
        return e6 < t5 ? -1 : e6 > t5 ? 1 : 0;
      }
      function rr(e6, t5) {
        if (e6.length <= 1) return [e6];
        let n4 = [], r3, i3;
        for (let t6 of e6) {
          let e7 = ar(t6);
          e7 !== 0 && (t6.area = Math.abs(e7), i3 === void 0 && (i3 = e7 < 0), i3 === e7 < 0 ? (r3 && n4.push(r3), r3 = [t6]) : r3.push(t6));
        }
        if (r3 && n4.push(r3), t5 > 1) for (let e7 = 0; e7 < n4.length; e7++) n4[e7].length <= t5 || (er(n4[e7], t5, 1, n4[e7].length - 1, ir), n4[e7] = n4[e7].slice(0, t5));
        return n4;
      }
      function ir(e6, t5) {
        return t5.area - e6.area;
      }
      function ar(e6) {
        let t5 = 0;
        for (let n4, r3, i3 = 0, a3 = e6.length, o3 = a3 - 1; i3 < a3; o3 = i3++) n4 = e6[i3], r3 = e6[o3], t5 += (r3.x - n4.x) * (n4.y + r3.y);
        return t5;
      }
      let or = 1 / 298.257223563, sr = or * (2 - or), cr = Math.PI / 180;
      class lr {
        constructor(e6) {
          let t5 = 6378.137 * cr * 1e3, n4 = Math.cos(e6 * cr), r3 = 1 / (1 - sr * (1 - n4 * n4)), i3 = Math.sqrt(r3);
          this.kx = t5 * i3 * n4, this.ky = t5 * i3 * r3 * (1 - sr);
        }
        distance(e6, t5) {
          let n4 = this.wrap(e6[0] - t5[0]) * this.kx, r3 = (e6[1] - t5[1]) * this.ky;
          return Math.sqrt(n4 * n4 + r3 * r3);
        }
        pointOnLine(e6, t5) {
          let n4, r3, i3, a3, o3 = 1 / 0;
          for (let s3 = 0; s3 < e6.length - 1; s3++) {
            let c3 = e6[s3][0], l3 = e6[s3][1], u3 = this.wrap(e6[s3 + 1][0] - c3) * this.kx, d3 = (e6[s3 + 1][1] - l3) * this.ky, f3 = 0;
            u3 === 0 && d3 === 0 || (f3 = (this.wrap(t5[0] - c3) * this.kx * u3 + (t5[1] - l3) * this.ky * d3) / (u3 * u3 + d3 * d3), f3 > 1 ? (c3 = e6[s3 + 1][0], l3 = e6[s3 + 1][1]) : f3 > 0 && (c3 += u3 / this.kx * f3, l3 += d3 / this.ky * f3)), u3 = this.wrap(t5[0] - c3) * this.kx, d3 = (t5[1] - l3) * this.ky;
            let p3 = u3 * u3 + d3 * d3;
            p3 < o3 && (o3 = p3, n4 = c3, r3 = l3, i3 = s3, a3 = f3);
          }
          return { point: [n4, r3], index: i3, t: Math.max(0, Math.min(1, a3)) };
        }
        wrap(e6) {
          for (; e6 < -180; ) e6 += 360;
          for (; e6 > 180; ) e6 -= 360;
          return e6;
        }
      }
      function ur(e6, t5) {
        return t5[0] - e6[0];
      }
      function dr(e6) {
        return e6[1] - e6[0] + 1;
      }
      function fr(e6, t5) {
        return e6[1] >= e6[0] && e6[1] < t5;
      }
      function pr(e6, t5) {
        if (e6[0] > e6[1]) return [null, null];
        let n4 = dr(e6);
        if (t5) {
          if (n4 === 2) return [e6, null];
          let t6 = Math.floor(n4 / 2);
          return [[e6[0], e6[0] + t6], [e6[0] + t6, e6[1]]];
        }
        if (n4 === 1) return [e6, null];
        let r3 = Math.floor(n4 / 2) - 1;
        return [[e6[0], e6[0] + r3], [e6[0] + r3 + 1, e6[1]]];
      }
      function mr(e6, t5) {
        if (!fr(t5, e6.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        let n4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let r3 = t5[0]; r3 <= t5[1]; ++r3) Ln(n4, e6[r3]);
        return n4;
      }
      function hr(e6) {
        let t5 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let n4 of e6) for (let e7 of n4) Ln(t5, e7);
        return t5;
      }
      function gr(e6) {
        return e6[0] !== -1 / 0 && e6[1] !== -1 / 0 && e6[2] !== 1 / 0 && e6[3] !== 1 / 0;
      }
      function _r(e6, t5, n4) {
        if (!gr(e6) || !gr(t5)) return NaN;
        let r3 = 0, i3 = 0;
        return e6[2] < t5[0] && (r3 = t5[0] - e6[2]), e6[0] > t5[2] && (r3 = e6[0] - t5[2]), e6[1] > t5[3] && (i3 = e6[1] - t5[3]), e6[3] < t5[1] && (i3 = t5[1] - e6[3]), n4.distance([0, 0], [r3, i3]);
      }
      function vr(e6, t5, n4) {
        let r3 = n4.pointOnLine(t5, e6);
        return n4.distance(e6, r3.point);
      }
      function yr(e6, t5, n4, r3, i3) {
        let a3 = Math.min(vr(e6, [n4, r3], i3), vr(t5, [n4, r3], i3)), o3 = Math.min(vr(n4, [e6, t5], i3), vr(r3, [e6, t5], i3));
        return Math.min(a3, o3);
      }
      function br(e6, t5, n4, r3, i3) {
        if (!fr(t5, e6.length) || !fr(r3, n4.length)) return 1 / 0;
        let a3 = 1 / 0;
        for (let o3 = t5[0]; o3 < t5[1]; ++o3) {
          let t6 = e6[o3], s3 = e6[o3 + 1];
          for (let e7 = r3[0]; e7 < r3[1]; ++e7) {
            let r4 = n4[e7], o4 = n4[e7 + 1];
            if (Bn(t6, s3, r4, o4)) return 0;
            a3 = Math.min(a3, yr(t6, s3, r4, o4, i3));
          }
        }
        return a3;
      }
      function xr(e6, t5, n4, r3, i3) {
        if (!fr(t5, e6.length) || !fr(r3, n4.length)) return NaN;
        let a3 = 1 / 0;
        for (let o3 = t5[0]; o3 <= t5[1]; ++o3) for (let t6 = r3[0]; t6 <= r3[1]; ++t6) if (a3 = Math.min(a3, i3.distance(e6[o3], n4[t6])), a3 === 0) return a3;
        return a3;
      }
      function Sr(e6, t5, n4) {
        if (Hn(e6, t5, true)) return 0;
        let r3 = 1 / 0;
        for (let i3 of t5) {
          let t6 = i3[0], a3 = i3[i3.length - 1];
          if (t6 !== a3 && (r3 = Math.min(r3, vr(e6, [a3, t6], n4)), r3 === 0)) return r3;
          let o3 = n4.pointOnLine(i3, e6);
          if (r3 = Math.min(r3, n4.distance(e6, o3.point)), r3 === 0) return r3;
        }
        return r3;
      }
      function Cr(e6, t5, n4, r3) {
        if (!fr(t5, e6.length)) return NaN;
        for (let r4 = t5[0]; r4 <= t5[1]; ++r4) if (Hn(e6[r4], n4, true)) return 0;
        let i3 = 1 / 0;
        for (let a3 = t5[0]; a3 < t5[1]; ++a3) {
          let t6 = e6[a3], o3 = e6[a3 + 1];
          for (let e7 of n4) for (let n5 = 0, a4 = e7.length, s3 = a4 - 1; n5 < a4; s3 = n5++) {
            let a5 = e7[s3], c3 = e7[n5];
            if (Bn(t6, o3, a5, c3)) return 0;
            i3 = Math.min(i3, yr(t6, o3, a5, c3, r3));
          }
        }
        return i3;
      }
      function wr(e6, t5) {
        for (let n4 of e6) for (let e7 of n4) if (Hn(e7, t5, true)) return true;
        return false;
      }
      function Tr(e6, t5, n4, r3 = 1 / 0) {
        let i3 = hr(e6), a3 = hr(t5);
        if (r3 !== 1 / 0 && _r(i3, a3, n4) >= r3) return r3;
        if (Rn(i3, a3)) {
          if (wr(e6, t5)) return 0;
        } else if (wr(t5, e6)) return 0;
        let o3 = 1 / 0;
        for (let r4 of e6) for (let e7 = 0, i4 = r4.length, a4 = i4 - 1; e7 < i4; a4 = e7++) {
          let i5 = r4[a4], s3 = r4[e7];
          for (let e8 of t5) for (let t6 = 0, r5 = e8.length, a5 = r5 - 1; t6 < r5; a5 = t6++) {
            let r6 = e8[a5], c3 = e8[t6];
            if (Bn(i5, s3, r6, c3)) return 0;
            o3 = Math.min(o3, yr(i5, s3, r6, c3, n4));
          }
        }
        return o3;
      }
      function Er(e6, t5, n4, r3, i3, a3) {
        if (!a3) return;
        let o3 = _r(mr(r3, a3), i3, n4);
        o3 < t5 && e6.push([o3, a3, [0, 0]]);
      }
      function Dr(e6, t5, n4, r3, i3, a3, o3) {
        if (!a3 || !o3) return;
        let s3 = _r(mr(r3, a3), mr(i3, o3), n4);
        s3 < t5 && e6.push([s3, a3, o3]);
      }
      function Or(e6, t5, n4, r3, i3 = 1 / 0) {
        let a3 = Math.min(r3.distance(e6[0], n4[0][0]), i3);
        if (a3 === 0) return a3;
        let o3 = new $n([[0, [0, e6.length - 1], [0, 0]]], ur), s3 = hr(n4);
        for (; o3.length > 0; ) {
          let i4 = o3.pop();
          if (i4[0] >= a3) continue;
          let c3 = i4[1], l3 = t5 ? 50 : 100;
          if (dr(c3) <= l3) {
            if (!fr(c3, e6.length)) return NaN;
            if (t5) {
              let t6 = Cr(e6, c3, n4, r3);
              if (isNaN(t6) || t6 === 0) return t6;
              a3 = Math.min(a3, t6);
            } else for (let t6 = c3[0]; t6 <= c3[1]; ++t6) {
              let i5 = Sr(e6[t6], n4, r3);
              if (a3 = Math.min(a3, i5), a3 === 0) return 0;
            }
          } else {
            let n5 = pr(c3, t5);
            Er(o3, a3, r3, e6, s3, n5[0]), Er(o3, a3, r3, e6, s3, n5[1]);
          }
        }
        return a3;
      }
      function kr(e6, t5, n4, r3, i3, a3 = 1 / 0) {
        let o3 = Math.min(a3, i3.distance(e6[0], n4[0]));
        if (o3 === 0) return o3;
        let s3 = new $n([[0, [0, e6.length - 1], [0, n4.length - 1]]], ur);
        for (; s3.length > 0; ) {
          let a4 = s3.pop();
          if (a4[0] >= o3) continue;
          let c3 = a4[1], l3 = a4[2], u3 = t5 ? 50 : 100, d3 = r3 ? 50 : 100;
          if (dr(c3) <= u3 && dr(l3) <= d3) {
            if (!fr(c3, e6.length) && fr(l3, n4.length)) return NaN;
            let a5;
            if (t5 && r3) a5 = br(e6, c3, n4, l3, i3), o3 = Math.min(o3, a5);
            else if (t5 && !r3) {
              let t6 = e6.slice(c3[0], c3[1] + 1);
              for (let e7 = l3[0]; e7 <= l3[1]; ++e7) if (a5 = vr(n4[e7], t6, i3), o3 = Math.min(o3, a5), o3 === 0) return o3;
            } else if (!t5 && r3) {
              let t6 = n4.slice(l3[0], l3[1] + 1);
              for (let n5 = c3[0]; n5 <= c3[1]; ++n5) if (a5 = vr(e6[n5], t6, i3), o3 = Math.min(o3, a5), o3 === 0) return o3;
            } else a5 = xr(e6, c3, n4, l3, i3), o3 = Math.min(o3, a5);
          } else {
            let a5 = pr(c3, t5), u4 = pr(l3, r3);
            Dr(s3, o3, i3, e6, n4, a5[0], u4[0]), Dr(s3, o3, i3, e6, n4, a5[0], u4[1]), Dr(s3, o3, i3, e6, n4, a5[1], u4[0]), Dr(s3, o3, i3, e6, n4, a5[1], u4[1]);
          }
        }
        return o3;
      }
      function Ar(e6) {
        return e6.type === `MultiPolygon` ? e6.coordinates.map(((e7) => ({ type: `Polygon`, coordinates: e7 }))) : e6.type === `MultiLineString` ? e6.coordinates.map(((e7) => ({ type: `LineString`, coordinates: e7 }))) : e6.type === `MultiPoint` ? e6.coordinates.map(((e7) => ({ type: `Point`, coordinates: e7 }))) : [e6];
      }
      class jr {
        constructor(e6, t5) {
          this.type = B2, this.geojson = e6, this.geometries = t5;
        }
        static parse(e6, t5) {
          if (e6.length !== 2) return t5.error(`'distance' expression requires exactly one argument, but found ${e6.length - 1} instead.`);
          if (Kt2(e6[1])) {
            let t6 = e6[1];
            if (t6.type === `FeatureCollection`) return new jr(t6, t6.features.map(((e7) => Ar(e7.geometry))).flat());
            if (t6.type === `Feature`) return new jr(t6, Ar(t6.geometry));
            if (`type` in t6 && `coordinates` in t6) return new jr(t6, Ar(t6));
          }
          return t5.error(`'distance' expression requires valid geojson object that contains polygon geometry type.`);
        }
        evaluate(e6) {
          if (e6.geometry() != null && e6.canonicalID() != null) {
            if (e6.geometryType() === `Point`) return (function(e7, t5) {
              let n4 = e7.geometry(), r3 = n4.flat().map(((t6) => In([t6.x, t6.y], e7.canonical)));
              if (n4.length === 0) return NaN;
              let i3 = new lr(r3[0][1]), a3 = 1 / 0;
              for (let e8 of t5) {
                switch (e8.type) {
                  case `Point`:
                    a3 = Math.min(a3, kr(r3, false, [e8.coordinates], false, i3, a3));
                    break;
                  case `LineString`:
                    a3 = Math.min(a3, kr(r3, false, e8.coordinates, true, i3, a3));
                    break;
                  case `Polygon`:
                    a3 = Math.min(a3, Or(r3, false, e8.coordinates, i3, a3));
                }
                if (a3 === 0) return a3;
              }
              return a3;
            })(e6, this.geometries);
            if (e6.geometryType() === `LineString`) return (function(e7, t5) {
              let n4 = e7.geometry(), r3 = n4.flat().map(((t6) => In([t6.x, t6.y], e7.canonical)));
              if (n4.length === 0) return NaN;
              let i3 = new lr(r3[0][1]), a3 = 1 / 0;
              for (let e8 of t5) {
                switch (e8.type) {
                  case `Point`:
                    a3 = Math.min(a3, kr(r3, true, [e8.coordinates], false, i3, a3));
                    break;
                  case `LineString`:
                    a3 = Math.min(a3, kr(r3, true, e8.coordinates, true, i3, a3));
                    break;
                  case `Polygon`:
                    a3 = Math.min(a3, Or(r3, true, e8.coordinates, i3, a3));
                }
                if (a3 === 0) return a3;
              }
              return a3;
            })(e6, this.geometries);
            if (e6.geometryType() === `Polygon`) return (function(e7, t5) {
              let n4 = e7.geometry();
              if (n4.length === 0 || n4[0].length === 0) return NaN;
              let r3 = rr(n4, 0).map(((t6) => t6.map(((t7) => t7.map(((t8) => In([t8.x, t8.y], e7.canonical))))))), i3 = new lr(r3[0][0][0][1]), a3 = 1 / 0;
              for (let e8 of t5) for (let t6 of r3) {
                switch (e8.type) {
                  case `Point`:
                    a3 = Math.min(a3, Or([e8.coordinates], false, t6, i3, a3));
                    break;
                  case `LineString`:
                    a3 = Math.min(a3, Or(e8.coordinates, true, t6, i3, a3));
                    break;
                  case `Polygon`:
                    a3 = Math.min(a3, Tr(t6, e8.coordinates, i3, a3));
                }
                if (a3 === 0) return a3;
              }
              return a3;
            })(e6, this.geometries);
          }
          return NaN;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
      }
      class Mr {
        constructor(e6) {
          this.type = U2, this.key = e6;
        }
        static parse(e6, t5) {
          if (e6.length !== 2) return t5.error(`Expected 1 argument, but found ${e6.length - 1} instead.`);
          let n4 = e6[1];
          return n4 == null ? t5.error(`Global state property must be defined.`) : typeof n4 == `string` ? new Mr(n4) : t5.error(`Global state property must be string, but found ${typeof e6[1]} instead.`);
        }
        evaluate(e6) {
          var _a3;
          let t5 = (_a3 = e6.globals) == null ? void 0 : _a3.globalState;
          return t5 && Object.keys(t5).length !== 0 ? Et2(t5, this.key) : null;
        }
        eachChild() {
        }
        outputDefined() {
          return false;
        }
      }
      let Nr = { "==": Cn, "!=": wn, ">": En, "<": Tn, ">=": On, "<=": Dn, array: q2, at: rn2, boolean: q2, case: cn2, coalesce: yn, collator: kn, format: jn, image: Mn, in: an2, "index-of": on2, interpolate: gn, "interpolate-hcl": gn, "interpolate-lab": gn, length: Nn, let: tn2, literal: Yt2, match: sn2, number: q2, "number-format": An, object: q2, slice: ln2, step: dn2, string: q2, "to-boolean": Zt2, "to-color": Zt2, "to-number": Zt2, "to-string": Zt2, var: nn2, within: Qn, distance: jr, "global-state": Mr };
      class Pr {
        constructor(e6, t5, n4, r3) {
          this.name = e6, this.type = t5, this._evaluate = n4, this.args = r3;
        }
        evaluate(e6) {
          return this._evaluate(e6, this.args);
        }
        eachChild(e6) {
          this.args.forEach(e6);
        }
        outputDefined() {
          return false;
        }
        static parse(e6, t5) {
          let n4 = e6[0], r3 = Pr.definitions[n4];
          if (!r3) return t5.error(`Unknown expression "${n4}". If you wanted a literal array, use ["literal", [...]].`, 0);
          let i3 = Array.isArray(r3) ? r3[0] : r3.type, a3 = Array.isArray(r3) ? [[r3[1], r3[2]]] : r3.overloads, o3 = a3.filter((([t6]) => !Array.isArray(t6) || t6.length === e6.length - 1)), s3 = null;
          for (let [r4, a4] of o3) {
            s3 = new en2(t5.registry, zr, t5.path, null, t5.scope);
            let o4 = [], c3 = false;
            for (let t6 = 1; t6 < e6.length; t6++) {
              let n5 = e6[t6], i4 = Array.isArray(r4) ? r4[t6 - 1] : r4.type, a5 = s3.parse(n5, 1 + o4.length, i4);
              if (!a5) {
                c3 = true;
                break;
              }
              o4.push(a5);
            }
            if (!c3) if (Array.isArray(r4) && r4.length !== o4.length) s3.error(`Expected ${r4.length} arguments, but found ${o4.length} instead.`);
            else {
              for (let e7 = 0; e7 < o4.length; e7++) {
                let t6 = Array.isArray(r4) ? r4[e7] : r4.type, n5 = o4[e7];
                s3.concat(e7 + 1).checkSubtype(t6, n5.type);
              }
              if (s3.errors.length === 0) return new Pr(n4, i3, a4, o4);
            }
          }
          if (o3.length === 1) t5.errors.push(...s3.errors);
          else {
            let n5 = (o3.length ? o3 : a3).map((([e7]) => {
              return t6 = e7, Array.isArray(t6) ? `(${t6.map(W2).join(`, `)})` : `(${W2(t6.type)}...)`;
              var t6;
            })).join(` | `), r4 = [];
            for (let n6 = 1; n6 < e6.length; n6++) {
              let i4 = t5.parse(e6[n6], 1 + r4.length);
              if (!i4) return null;
              r4.push(W2(i4.type));
            }
            t5.error(`Expected arguments of type ${n5}, but found (${r4.join(`, `)}) instead.`);
          }
          return null;
        }
        static register(e6, t5) {
          for (let n4 in Pr.definitions = t5, t5) e6[n4] = Pr;
        }
      }
      function Fr(e6, [t5, n4, r3, i3]) {
        t5 = t5.evaluate(e6), n4 = n4.evaluate(e6), r3 = r3.evaluate(e6);
        let a3 = i3 ? i3.evaluate(e6) : 1, o3 = Gt2(t5, n4, r3, a3);
        if (o3) throw new Bt2(o3);
        return new K2(t5 / 255, n4 / 255, r3 / 255, a3, false);
      }
      function Ir(e6, t5) {
        return e6 in t5;
      }
      function Lr(e6, t5) {
        let n4 = t5[e6];
        return n4 === void 0 ? null : n4;
      }
      function Rr(e6) {
        return { type: e6 };
      }
      function zr(e6) {
        if (e6 instanceof nn2) return zr(e6.boundExpression);
        if (e6 instanceof Pr && e6.name === `error` || e6 instanceof kn || e6 instanceof Qn || e6 instanceof jr || e6 instanceof Mr) return false;
        let t5 = e6 instanceof Zt2 || e6 instanceof q2, n4 = true;
        return e6.eachChild(((e7) => {
          n4 = t5 ? n4 && zr(e7) : n4 && e7 instanceof Yt2;
        })), !!n4 && Br(e6) && Hr(e6, [`zoom`, `heatmap-density`, `elevation`, `line-progress`, `accumulated`, `is-supported-script`]);
      }
      function Br(e6) {
        if (e6 instanceof Pr && (e6.name === `get` && e6.args.length === 1 || e6.name === `feature-state` || e6.name === `has` && e6.args.length === 1 || e6.name === `properties` || e6.name === `geometry-type` || e6.name === `id` || /^filter-/.test(e6.name)) || e6 instanceof Qn || e6 instanceof jr) return false;
        let t5 = true;
        return e6.eachChild(((e7) => {
          t5 && !Br(e7) && (t5 = false);
        })), t5;
      }
      function Vr(e6) {
        if (e6 instanceof Pr && e6.name === `feature-state`) return false;
        let t5 = true;
        return e6.eachChild(((e7) => {
          t5 && !Vr(e7) && (t5 = false);
        })), t5;
      }
      function Hr(e6, t5) {
        if (e6 instanceof Pr && t5.indexOf(e6.name) >= 0) return false;
        let n4 = true;
        return e6.eachChild(((e7) => {
          n4 && !Hr(e7, t5) && (n4 = false);
        })), n4;
      }
      function Ur(e6) {
        return { result: `success`, value: e6 };
      }
      function Wr(e6) {
        return { result: `error`, value: e6 };
      }
      function Gr(e6) {
        return e6[`property-type`] === `data-driven` || e6[`property-type`] === `cross-faded-data-driven`;
      }
      function Kr(e6) {
        return !!e6.expression && e6.expression.parameters.indexOf(`zoom`) > -1;
      }
      function qr(e6) {
        return !!e6.expression && e6.expression.interpolated;
      }
      function Y(e6) {
        return e6 instanceof Number ? `number` : e6 instanceof String ? `string` : e6 instanceof Boolean ? `boolean` : Array.isArray(e6) ? `array` : e6 === null ? `null` : typeof e6;
      }
      function Jr(e6) {
        return typeof e6 == `object` && !!e6 && !Array.isArray(e6) && qt2(e6) === Ze2;
      }
      function Yr(e6) {
        return e6;
      }
      function Xr(e6, t5) {
        let n4 = e6.stops && typeof e6.stops[0][0] == `object`, r3 = n4 || !(n4 || e6.property !== void 0), i3 = e6.type || (qr(t5) ? `exponential` : `interval`), a3 = (function(e7) {
          switch (e7.type) {
            case `color`:
              return K2.parse;
            case `padding`:
              return Lt2.parse;
            case `numberArray`:
              return Rt2.parse;
            case `colorArray`:
              return zt2.parse;
            default:
              return null;
          }
        })(t5);
        if (a3 && ((e6 = Ge2({}, e6)).stops && (e6.stops = e6.stops.map(((e7) => [e7[0], a3(e7[1])]))), e6.default = a3(e6.default ? e6.default : t5.default)), e6.colorSpace && (o3 = e6.colorSpace) !== `rgb` && o3 !== `hcl` && o3 !== `lab`) throw Error(`Unknown color space: "${e6.colorSpace}"`);
        var o3;
        let s3 = (function(e7) {
          switch (e7) {
            case `exponential`:
              return ei;
            case `interval`:
              return $r;
            case `categorical`:
              return Qr;
            case `identity`:
              return ti;
            default:
              throw Error(`Unknown function type "${e7}"`);
          }
        })(i3), c3, l3;
        if (i3 === `categorical`) {
          c3 = /* @__PURE__ */ Object.create(null);
          for (let t6 of e6.stops) c3[t6[0]] = t6[1];
          l3 = typeof e6.stops[0][0];
        }
        if (n4) {
          let n5 = {}, r4 = [];
          for (let t6 = 0; t6 < e6.stops.length; t6++) {
            let i5 = e6.stops[t6], a5 = i5[0].zoom;
            n5[a5] === void 0 && (n5[a5] = { zoom: a5, type: e6.type, property: e6.property, default: e6.default, stops: [] }, r4.push(a5)), n5[a5].stops.push([i5[0].value, i5[1]]);
          }
          let i4 = [];
          for (let e7 of r4) i4.push([n5[e7].zoom, Xr(n5[e7], t5)]);
          let a4 = { name: `linear` };
          return { kind: `composite`, interpolationType: a4, interpolationFactor: gn.interpolationFactor.bind(void 0, a4), zoomStops: i4.map(((e7) => e7[0])), evaluate: ({ zoom: n6 }, r5) => ei({ stops: i4, base: e6.base }, t5, n6).evaluate(n6, r5) };
        }
        if (r3) {
          let n5 = i3 === `exponential` ? { name: `exponential`, base: e6.base === void 0 ? 1 : e6.base } : null;
          return { kind: `camera`, interpolationType: n5, interpolationFactor: gn.interpolationFactor.bind(void 0, n5), zoomStops: e6.stops.map(((e7) => e7[0])), evaluate: ({ zoom: n6 }) => s3(e6, t5, n6, c3, l3) };
        }
        return { kind: `source`, evaluate(n5, r4) {
          let i4 = r4 && r4.properties ? r4.properties[e6.property] : void 0;
          return i4 === void 0 ? Zr(e6.default, t5.default) : s3(e6, t5, i4, c3, l3);
        } };
      }
      function Zr(e6, t5, n4) {
        return e6 === void 0 ? t5 === void 0 ? n4 === void 0 ? void 0 : n4 : t5 : e6;
      }
      function Qr(e6, t5, n4, r3, i3) {
        return Zr(typeof n4 === i3 ? r3[n4] : void 0, e6.default, t5.default);
      }
      function $r(e6, t5, n4) {
        if (Y(n4) !== `number`) return Zr(e6.default, t5.default);
        let r3 = e6.stops.length;
        if (r3 === 1 || n4 <= e6.stops[0][0]) return e6.stops[0][1];
        if (n4 >= e6.stops[r3 - 1][0]) return e6.stops[r3 - 1][1];
        let i3 = un2(e6.stops.map(((e7) => e7[0])), n4);
        return e6.stops[i3][1];
      }
      function ei(e6, t5, n4) {
        let r3 = e6.base === void 0 ? 1 : e6.base;
        if (Y(n4) !== `number`) return Zr(e6.default, t5.default);
        let i3 = e6.stops.length;
        if (i3 === 1 || n4 <= e6.stops[0][0]) return e6.stops[0][1];
        if (n4 >= e6.stops[i3 - 1][0]) return e6.stops[i3 - 1][1];
        let a3 = un2(e6.stops.map(((e7) => e7[0])), n4), o3 = (function(e7, t6, n5, r4) {
          let i4 = r4 - n5, a4 = e7 - n5;
          return i4 === 0 ? 0 : t6 === 1 ? a4 / i4 : (t6 ** +a4 - 1) / (t6 ** +i4 - 1);
        })(n4, r3, e6.stops[a3][0], e6.stops[a3 + 1][0]), s3 = e6.stops[a3][1], c3 = e6.stops[a3 + 1][1], l3 = vn[t5.type] || Yr;
        return typeof s3.evaluate == `function` ? { evaluate(...t6) {
          let n5 = s3.evaluate.apply(void 0, t6), r4 = c3.evaluate.apply(void 0, t6);
          if (n5 !== void 0 && r4 !== void 0) return l3(n5, r4, o3, e6.colorSpace);
        } } : l3(s3, c3, o3, e6.colorSpace);
      }
      function ti(e6, t5, n4) {
        switch (t5.type) {
          case `color`:
            n4 = K2.parse(n4);
            break;
          case `formatted`:
            n4 = It2.fromString(n4.toString());
            break;
          case `resolvedImage`:
            n4 = Ut2.fromString(n4.toString());
            break;
          case `padding`:
            n4 = Lt2.parse(n4);
            break;
          case `colorArray`:
            n4 = zt2.parse(n4);
            break;
          case `numberArray`:
            n4 = Rt2.parse(n4);
            break;
          default:
            Y(n4) === t5.type || t5.type === `enum` && t5.values[n4] || (n4 = void 0);
        }
        return Zr(n4, e6.default, t5.default);
      }
      Pr.register(Nr, { error: [{ kind: `error` }, [V2], (e6, [t5]) => {
        throw new Bt2(t5.evaluate(e6));
      }], typeof: [V2, [U2], (e6, [t5]) => W2(qt2(t5.evaluate(e6)))], "to-rgba": [at2(B2, 4), [Ye2], (e6, [t5]) => {
        let [n4, r3, i3, a3] = t5.evaluate(e6).rgb;
        return [255 * n4, 255 * r3, 255 * i3, a3];
      }], rgb: [Ye2, [B2, B2, B2], Fr], rgba: [Ye2, [B2, B2, B2, B2], Fr], has: { type: H2, overloads: [[[V2], (e6, [t5]) => Ir(t5.evaluate(e6), e6.properties())], [[V2, Ze2], (e6, [t5, n4]) => Ir(t5.evaluate(e6), n4.evaluate(e6))]] }, get: { type: U2, overloads: [[[V2], (e6, [t5]) => Lr(t5.evaluate(e6), e6.properties())], [[V2, Ze2], (e6, [t5, n4]) => Lr(t5.evaluate(e6), n4.evaluate(e6))]] }, "feature-state": [U2, [V2], (e6, [t5]) => Lr(t5.evaluate(e6), e6.featureState || {})], properties: [Ze2, [], (e6) => e6.properties()], "geometry-type": [V2, [], (e6) => e6.geometryType()], id: [U2, [], (e6) => e6.id()], zoom: [B2, [], (e6) => e6.globals.zoom], "heatmap-density": [B2, [], (e6) => e6.globals.heatmapDensity || 0], elevation: [B2, [], (e6) => e6.globals.elevation || 0], "line-progress": [B2, [], (e6) => e6.globals.lineProgress || 0], accumulated: [U2, [], (e6) => e6.globals.accumulated === void 0 ? null : e6.globals.accumulated], "+": [B2, Rr(B2), (e6, t5) => {
        let n4 = 0;
        for (let r3 of t5) n4 += r3.evaluate(e6);
        return n4;
      }], "*": [B2, Rr(B2), (e6, t5) => {
        let n4 = 1;
        for (let r3 of t5) n4 *= r3.evaluate(e6);
        return n4;
      }], "-": { type: B2, overloads: [[[B2, B2], (e6, [t5, n4]) => t5.evaluate(e6) - n4.evaluate(e6)], [[B2], (e6, [t5]) => -t5.evaluate(e6)]] }, "/": [B2, [B2, B2], (e6, [t5, n4]) => t5.evaluate(e6) / n4.evaluate(e6)], "%": [B2, [B2, B2], (e6, [t5, n4]) => t5.evaluate(e6) % n4.evaluate(e6)], ln2: [B2, [], () => Math.LN2], pi: [B2, [], () => Math.PI], e: [B2, [], () => Math.E], "^": [B2, [B2, B2], (e6, [t5, n4]) => t5.evaluate(e6) ** +n4.evaluate(e6)], sqrt: [B2, [B2], (e6, [t5]) => Math.sqrt(t5.evaluate(e6))], log10: [B2, [B2], (e6, [t5]) => Math.log(t5.evaluate(e6)) / Math.LN10], ln: [B2, [B2], (e6, [t5]) => Math.log(t5.evaluate(e6))], log2: [B2, [B2], (e6, [t5]) => Math.log(t5.evaluate(e6)) / Math.LN2], sin: [B2, [B2], (e6, [t5]) => Math.sin(t5.evaluate(e6))], cos: [B2, [B2], (e6, [t5]) => Math.cos(t5.evaluate(e6))], tan: [B2, [B2], (e6, [t5]) => Math.tan(t5.evaluate(e6))], asin: [B2, [B2], (e6, [t5]) => Math.asin(t5.evaluate(e6))], acos: [B2, [B2], (e6, [t5]) => Math.acos(t5.evaluate(e6))], atan: [B2, [B2], (e6, [t5]) => Math.atan(t5.evaluate(e6))], min: [B2, Rr(B2), (e6, t5) => Math.min(...t5.map(((t6) => t6.evaluate(e6))))], max: [B2, Rr(B2), (e6, t5) => Math.max(...t5.map(((t6) => t6.evaluate(e6))))], abs: [B2, [B2], (e6, [t5]) => Math.abs(t5.evaluate(e6))], round: [B2, [B2], (e6, [t5]) => {
        let n4 = t5.evaluate(e6);
        return n4 < 0 ? -Math.round(-n4) : Math.round(n4);
      }], floor: [B2, [B2], (e6, [t5]) => Math.floor(t5.evaluate(e6))], ceil: [B2, [B2], (e6, [t5]) => Math.ceil(t5.evaluate(e6))], "filter-==": [H2, [V2, U2], (e6, [t5, n4]) => e6.properties()[t5.value] === n4.value], "filter-id-==": [H2, [U2], (e6, [t5]) => e6.id() === t5.value], "filter-type-==": [H2, [V2], (e6, [t5]) => e6.geometryType() === t5.value], "filter-<": [H2, [V2, U2], (e6, [t5, n4]) => {
        let r3 = e6.properties()[t5.value], i3 = n4.value;
        return typeof r3 == typeof i3 && r3 < i3;
      }], "filter-id-<": [H2, [U2], (e6, [t5]) => {
        let n4 = e6.id(), r3 = t5.value;
        return typeof n4 == typeof r3 && n4 < r3;
      }], "filter->": [H2, [V2, U2], (e6, [t5, n4]) => {
        let r3 = e6.properties()[t5.value], i3 = n4.value;
        return typeof r3 == typeof i3 && r3 > i3;
      }], "filter-id->": [H2, [U2], (e6, [t5]) => {
        let n4 = e6.id(), r3 = t5.value;
        return typeof n4 == typeof r3 && n4 > r3;
      }], "filter-<=": [H2, [V2, U2], (e6, [t5, n4]) => {
        let r3 = e6.properties()[t5.value], i3 = n4.value;
        return typeof r3 == typeof i3 && r3 <= i3;
      }], "filter-id-<=": [H2, [U2], (e6, [t5]) => {
        let n4 = e6.id(), r3 = t5.value;
        return typeof n4 == typeof r3 && n4 <= r3;
      }], "filter->=": [H2, [V2, U2], (e6, [t5, n4]) => {
        let r3 = e6.properties()[t5.value], i3 = n4.value;
        return typeof r3 == typeof i3 && r3 >= i3;
      }], "filter-id->=": [H2, [U2], (e6, [t5]) => {
        let n4 = e6.id(), r3 = t5.value;
        return typeof n4 == typeof r3 && n4 >= r3;
      }], "filter-has": [H2, [U2], (e6, [t5]) => t5.value in e6.properties()], "filter-has-id": [H2, [], (e6) => e6.id() !== null && e6.id() !== void 0], "filter-type-in": [H2, [at2(V2)], (e6, [t5]) => t5.value.indexOf(e6.geometryType()) >= 0], "filter-id-in": [H2, [at2(U2)], (e6, [t5]) => t5.value.indexOf(e6.id()) >= 0], "filter-in-small": [H2, [V2, at2(U2)], (e6, [t5, n4]) => n4.value.indexOf(e6.properties()[t5.value]) >= 0], "filter-in-large": [H2, [V2, at2(U2)], (e6, [t5, n4]) => (function(e7, t6, n5, r3) {
        for (; n5 <= r3; ) {
          let i3 = n5 + r3 >> 1;
          if (t6[i3] === e7) return true;
          t6[i3] > e7 ? r3 = i3 - 1 : n5 = i3 + 1;
        }
        return false;
      })(e6.properties()[t5.value], n4.value, 0, n4.value.length - 1)], all: { type: H2, overloads: [[[H2, H2], (e6, [t5, n4]) => t5.evaluate(e6) && n4.evaluate(e6)], [Rr(H2), (e6, t5) => {
        for (let n4 of t5) if (!n4.evaluate(e6)) return false;
        return true;
      }]] }, any: { type: H2, overloads: [[[H2, H2], (e6, [t5, n4]) => t5.evaluate(e6) || n4.evaluate(e6)], [Rr(H2), (e6, t5) => {
        for (let n4 of t5) if (n4.evaluate(e6)) return true;
        return false;
      }]] }, "!": [H2, [H2], (e6, [t5]) => !t5.evaluate(e6)], "is-supported-script": [H2, [V2], (e6, [t5]) => {
        let n4 = e6.globals && e6.globals.isSupportedScript;
        return !n4 || n4(t5.evaluate(e6));
      }], upcase: [V2, [V2], (e6, [t5]) => t5.evaluate(e6).toUpperCase()], downcase: [V2, [V2], (e6, [t5]) => t5.evaluate(e6).toLowerCase()], concat: [V2, Rr(U2), (e6, t5) => t5.map(((t6) => Jt2(t6.evaluate(e6)))).join(``)], "resolved-locale": [V2, [Qe2], (e6, [t5]) => t5.evaluate(e6).resolvedLocale()] });
      class ni {
        constructor(e6, t5, n4) {
          this.expression = e6, this._warningHistory = {}, this._evaluator = new $t2(), this._defaultValue = t5 ? (function(e7) {
            if (e7.type === `color` && Jr(e7.default)) return new K2(0, 0, 0, 0);
            switch (e7.type) {
              case `color`:
                return K2.parse(e7.default) || null;
              case `padding`:
                return Lt2.parse(e7.default) || null;
              case `numberArray`:
                return Rt2.parse(e7.default) || null;
              case `colorArray`:
                return zt2.parse(e7.default) || null;
              case `variableAnchorOffsetCollection`:
                return Ht2.parse(e7.default) || null;
              case `projectionDefinition`:
                return Wt2.parse(e7.default) || null;
              default:
                return e7.default === void 0 ? null : e7.default;
            }
          })(t5) : null, this._enumValues = t5 && t5.type === `enum` ? t5.values : null, this._globalState = n4;
        }
        evaluateWithoutErrorHandling(e6, t5, n4, r3, i3, a3) {
          return this._globalState && (e6 = di(e6, this._globalState)), this._evaluator.globals = e6, this._evaluator.feature = t5, this._evaluator.featureState = n4, this._evaluator.canonical = r3, this._evaluator.availableImages = i3 || null, this._evaluator.formattedSection = a3, this.expression.evaluate(this._evaluator);
        }
        evaluate(e6, t5, n4, r3, i3, a3) {
          this._globalState && (e6 = di(e6, this._globalState)), this._evaluator.globals = e6, this._evaluator.feature = t5 || null, this._evaluator.featureState = n4 || null, this._evaluator.canonical = r3, this._evaluator.availableImages = i3 || null, this._evaluator.formattedSection = a3 || null;
          try {
            let e7 = this.expression.evaluate(this._evaluator);
            if (e7 == null || typeof e7 == `number` && e7 != e7) return this._defaultValue;
            if (this._enumValues && !(e7 in this._enumValues)) throw new Bt2(`Expected value to be one of ${Object.keys(this._enumValues).map(((e8) => JSON.stringify(e8))).join(`, `)}, but found ${JSON.stringify(e7)} instead.`);
            return e7;
          } catch (e7) {
            return this._warningHistory[e7.message] || (this._warningHistory[e7.message] = true, typeof console < `u` && console.warn(e7.message)), this._defaultValue;
          }
        }
      }
      function ri(e6) {
        return Array.isArray(e6) && e6.length > 0 && typeof e6[0] == `string` && e6[0] in Nr;
      }
      function ii(e6, t5, n4) {
        let r3 = new en2(Nr, zr, [], t5 ? (function(e7) {
          let t6 = { color: Ye2, string: V2, number: B2, enum: V2, boolean: H2, formatted: $e2, padding: et2, numberArray: nt2, colorArray: tt2, projectionDefinition: Xe2, resolvedImage: rt2, variableAnchorOffsetCollection: it2 };
          return e7.type === `array` ? at2(t6[e7.value] || U2, e7.length) : t6[e7.type];
        })(t5) : void 0), i3 = r3.parse(e6, void 0, void 0, void 0, t5 && t5.type === `string` ? { typeAnnotation: `coerce` } : void 0);
        return i3 ? Ur(new ni(i3, t5, n4)) : Wr(r3.errors);
      }
      class ai {
        constructor(e6, t5, n4) {
          this.kind = e6, this._styleExpression = t5, this.isStateDependent = e6 !== `constant` && !Vr(t5.expression), this.globalStateRefs = ui(t5.expression), this._globalState = n4;
        }
        evaluateWithoutErrorHandling(e6, t5, n4, r3, i3, a3) {
          return this._globalState && (e6 = di(e6, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(e6, t5, n4, r3, i3, a3);
        }
        evaluate(e6, t5, n4, r3, i3, a3) {
          return this._globalState && (e6 = di(e6, this._globalState)), this._styleExpression.evaluate(e6, t5, n4, r3, i3, a3);
        }
      }
      class oi {
        constructor(e6, t5, n4, r3, i3) {
          this.kind = e6, this.zoomStops = n4, this._styleExpression = t5, this.isStateDependent = e6 !== `camera` && !Vr(t5.expression), this.globalStateRefs = ui(t5.expression), this.interpolationType = r3, this._globalState = i3;
        }
        evaluateWithoutErrorHandling(e6, t5, n4, r3, i3, a3) {
          return this._globalState && (e6 = di(e6, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(e6, t5, n4, r3, i3, a3);
        }
        evaluate(e6, t5, n4, r3, i3, a3) {
          return this._globalState && (e6 = di(e6, this._globalState)), this._styleExpression.evaluate(e6, t5, n4, r3, i3, a3);
        }
        interpolationFactor(e6, t5, n4) {
          return this.interpolationType ? gn.interpolationFactor(this.interpolationType, e6, t5, n4) : 0;
        }
      }
      function si(e6, t5, n4) {
        let r3 = ii(e6, t5, n4);
        if (r3.result === `error`) return r3;
        let i3 = r3.value.expression, a3 = Br(i3);
        if (!a3 && !Gr(t5)) return Wr([new Ke2(``, `data expressions not supported`)]);
        let o3 = Hr(i3, [`zoom`]);
        if (!o3 && !Kr(t5)) return Wr([new Ke2(``, `zoom expressions not supported`)]);
        let s3 = li(i3);
        return s3 || o3 ? s3 instanceof Ke2 ? Wr([s3]) : s3 instanceof gn && !qr(t5) ? Wr([new Ke2(``, `"interpolate" expressions cannot be used with this property`)]) : Ur(s3 ? new oi(a3 ? `camera` : `composite`, r3.value, s3.labels, s3 instanceof gn ? s3.interpolation : void 0, n4) : new ai(a3 ? `constant` : `source`, r3.value, n4)) : Wr([new Ke2(``, `"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.`)]);
      }
      class ci {
        constructor(e6, t5) {
          this._parameters = e6, this._specification = t5, Ge2(this, Xr(this._parameters, this._specification));
        }
        static deserialize(e6) {
          return new ci(e6._parameters, e6._specification);
        }
        static serialize(e6) {
          return { _parameters: e6._parameters, _specification: e6._specification };
        }
      }
      function li(e6) {
        let t5 = null;
        if (e6 instanceof tn2) t5 = li(e6.result);
        else if (e6 instanceof yn) {
          for (let n4 of e6.args) if (t5 = li(n4), t5) break;
        } else (e6 instanceof dn2 || e6 instanceof gn) && e6.input instanceof Pr && e6.input.name === `zoom` && (t5 = e6);
        return t5 instanceof Ke2 || e6.eachChild(((e7) => {
          let n4 = li(e7);
          n4 instanceof Ke2 ? t5 = n4 : !t5 && n4 ? t5 = new Ke2(``, `"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.`) : t5 && n4 && t5 !== n4 && (t5 = new Ke2(``, `Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.`));
        })), t5;
      }
      function ui(e6, t5 = /* @__PURE__ */ new Set()) {
        return e6 instanceof Mr && t5.add(e6.key), e6.eachChild(((e7) => {
          ui(e7, t5);
        })), t5;
      }
      function di(e6, t5) {
        let { zoom: n4, heatmapDensity: r3, elevation: i3, lineProgress: a3, isSupportedScript: o3, accumulated: s3 } = e6 ?? {};
        return { zoom: n4, heatmapDensity: r3, elevation: i3, lineProgress: a3, isSupportedScript: o3, accumulated: s3, globalState: t5 };
      }
      function fi(e6) {
        if (true === e6 || false === e6) return true;
        if (!Array.isArray(e6) || e6.length === 0) return false;
        switch (e6[0]) {
          case `has`:
            return e6.length >= 2 && e6[1] !== `$id` && e6[1] !== `$type`;
          case `in`:
            return e6.length >= 3 && (typeof e6[1] != `string` || Array.isArray(e6[2]));
          case `!in`:
          case `!has`:
          case `none`:
            return false;
          case `==`:
          case `!=`:
          case `>`:
          case `>=`:
          case `<`:
          case `<=`:
            return e6.length !== 3 || Array.isArray(e6[1]) || Array.isArray(e6[2]);
          case `any`:
          case `all`:
            for (let t5 of e6.slice(1)) if (!fi(t5) && typeof t5 != `boolean`) return false;
            return true;
          default:
            return true;
        }
      }
      let pi = { type: `boolean`, default: false, transition: false, "property-type": `data-driven`, expression: { interpolated: false, parameters: [`zoom`, `feature`] } };
      function mi(e6, t5) {
        if (e6 == null) return { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() };
        fi(e6) || (e6 = _i(e6));
        let n4 = ii(e6, pi, t5);
        if (n4.result === `error`) throw Error(n4.value.map(((e7) => `${e7.key}: ${e7.message}`)).join(`, `));
        return { filter: (e7, t6, r3) => n4.value.evaluate(e7, t6, {}, r3), needGeometry: gi(e6), getGlobalStateRefs: () => ui(n4.value.expression) };
      }
      function hi(e6, t5) {
        return e6 < t5 ? -1 : e6 > t5 ? 1 : 0;
      }
      function gi(e6) {
        if (!Array.isArray(e6)) return false;
        if (e6[0] === `within` || e6[0] === `distance`) return true;
        for (let t5 = 1; t5 < e6.length; t5++) if (gi(e6[t5])) return true;
        return false;
      }
      function _i(e6) {
        if (!e6) return true;
        let t5 = e6[0];
        return e6.length <= 1 ? t5 !== `any` : t5 === `==` ? vi(e6[1], e6[2], `==`) : t5 === `!=` ? xi(vi(e6[1], e6[2], `==`)) : t5 === `<` || t5 === `>` || t5 === `<=` || t5 === `>=` ? vi(e6[1], e6[2], t5) : t5 === `any` ? (n4 = e6.slice(1), [`any`].concat(n4.map(_i))) : t5 === `all` ? [`all`].concat(e6.slice(1).map(_i)) : t5 === `none` ? [`all`].concat(e6.slice(1).map(_i).map(xi)) : t5 === `in` ? yi(e6[1], e6.slice(2)) : t5 === `!in` ? xi(yi(e6[1], e6.slice(2))) : t5 === `has` ? bi(e6[1]) : t5 !== `!has` || xi(bi(e6[1]));
        var n4;
      }
      function vi(e6, t5, n4) {
        switch (e6) {
          case `$type`:
            return [`filter-type-${n4}`, t5];
          case `$id`:
            return [`filter-id-${n4}`, t5];
          default:
            return [`filter-${n4}`, e6, t5];
        }
      }
      function yi(e6, t5) {
        if (t5.length === 0) return false;
        switch (e6) {
          case `$type`:
            return [`filter-type-in`, [`literal`, t5]];
          case `$id`:
            return [`filter-id-in`, [`literal`, t5]];
          default:
            return t5.length > 200 && !t5.some(((e7) => typeof e7 != typeof t5[0])) ? [`filter-in-large`, e6, [`literal`, t5.sort(hi)]] : [`filter-in-small`, e6, [`literal`, t5]];
        }
      }
      function bi(e6) {
        switch (e6) {
          case `$type`:
            return true;
          case `$id`:
            return [`filter-has-id`];
          default:
            return [`filter-has`, e6];
        }
      }
      function xi(e6) {
        return [`!`, e6];
      }
      function Si(e6) {
        let t5 = typeof e6;
        if (t5 === `number` || t5 === `boolean` || t5 === `string` || e6 == null) return JSON.stringify(e6);
        if (Array.isArray(e6)) {
          let t6 = `[`;
          for (let n5 of e6) t6 += `${Si(n5)},`;
          return `${t6}]`;
        }
        let n4 = Object.keys(e6).sort(), r3 = `{`;
        for (let t6 = 0; t6 < n4.length; t6++) r3 += `${JSON.stringify(n4[t6])}:${Si(e6[n4[t6]])},`;
        return `${r3}}`;
      }
      function Ci(e6) {
        let t5 = ``;
        for (let n4 of Pe2) t5 += `/${Si(e6[n4])}`;
        return t5;
      }
      function wi(e6) {
        let t5 = e6.value;
        return t5 ? [new z2(e6.key, t5, `constants have been deprecated as of v8`)] : [];
      }
      function Ti(e6) {
        return e6 instanceof Number || e6 instanceof String || e6 instanceof Boolean ? e6.valueOf() : e6;
      }
      function Ei(e6) {
        if (Array.isArray(e6)) return e6.map(Ei);
        if (e6 instanceof Object && !(e6 instanceof Number || e6 instanceof String || e6 instanceof Boolean)) {
          let t5 = {};
          for (let n4 in e6) t5[n4] = Ei(e6[n4]);
          return t5;
        }
        return Ti(e6);
      }
      function Di(e6) {
        let t5 = e6.key, n4 = e6.value, r3 = e6.valueSpec || {}, i3 = e6.objectElementValidators || {}, a3 = e6.style, o3 = e6.styleSpec, s3 = e6.validateSpec, c3 = [], l3 = Y(n4);
        if (l3 !== `object`) return [new z2(t5, n4, `object expected, ${l3} found`)];
        for (let e7 in n4) {
          let l4 = e7.split(`.`)[0], u3 = Et2(r3, l4) || r3[`*`], d3;
          if (Et2(i3, l4)) d3 = i3[l4];
          else if (Et2(r3, l4)) d3 = s3;
          else if (i3[`*`]) d3 = i3[`*`];
          else {
            if (!r3[`*`]) {
              c3.push(new z2(t5, n4[e7], `unknown property "${e7}"`));
              continue;
            }
            d3 = s3;
          }
          c3 = c3.concat(d3({ key: (t5 && `${t5}.`) + e7, value: n4[e7], valueSpec: u3, style: a3, styleSpec: o3, object: n4, objectKey: e7, validateSpec: s3 }, n4));
        }
        for (let e7 in r3) i3[e7] || r3[e7].required && r3[e7].default === void 0 && n4[e7] === void 0 && c3.push(new z2(t5, n4, `missing required property "${e7}"`));
        return c3;
      }
      function Oi(e6) {
        let t5 = e6.value, n4 = e6.valueSpec, r3 = e6.style, i3 = e6.styleSpec, a3 = e6.key, o3 = e6.arrayElementValidator || e6.validateSpec;
        if (Y(t5) !== `array`) return [new z2(a3, t5, `array expected, ${Y(t5)} found`)];
        if (n4.length && t5.length !== n4.length) return [new z2(a3, t5, `array length ${n4.length} expected, length ${t5.length} found`)];
        if (n4[`min-length`] && t5.length < n4[`min-length`]) return [new z2(a3, t5, `array length at least ${n4[`min-length`]} expected, length ${t5.length} found`)];
        let s3 = { type: n4.value, values: n4.values };
        i3.$version < 7 && (s3.function = n4.function), Y(n4.value) === `object` && (s3 = n4.value);
        let c3 = [];
        for (let n5 = 0; n5 < t5.length; n5++) c3 = c3.concat(o3({ array: t5, arrayIndex: n5, value: t5[n5], valueSpec: s3, validateSpec: e6.validateSpec, style: r3, styleSpec: i3, key: `${a3}[${n5}]` }));
        return c3;
      }
      function ki(e6) {
        let t5 = e6.key, n4 = e6.value, r3 = e6.valueSpec, i3 = Y(n4);
        return i3 === `number` && n4 != n4 && (i3 = `NaN`), i3 === `number` ? `minimum` in r3 && n4 < r3.minimum ? [new z2(t5, n4, `${n4} is less than the minimum value ${r3.minimum}`)] : `maximum` in r3 && n4 > r3.maximum ? [new z2(t5, n4, `${n4} is greater than the maximum value ${r3.maximum}`)] : [] : [new z2(t5, n4, `number expected, ${i3} found`)];
      }
      function Ai(e6) {
        let t5 = e6.valueSpec, n4 = Ti(e6.value.type), r3, i3, a3, o3 = {}, s3 = n4 !== `categorical` && e6.value.property === void 0, c3 = !s3, l3 = Y(e6.value.stops) === `array` && Y(e6.value.stops[0]) === `array` && Y(e6.value.stops[0][0]) === `object`, u3 = Di({ key: e6.key, value: e6.value, valueSpec: e6.styleSpec.function, validateSpec: e6.validateSpec, style: e6.style, styleSpec: e6.styleSpec, objectElementValidators: { stops: function(e7) {
          if (n4 === `identity`) return [new z2(e7.key, e7.value, `identity function may not have a "stops" property`)];
          let t6 = [], r4 = e7.value;
          return t6 = t6.concat(Oi({ key: e7.key, value: r4, valueSpec: e7.valueSpec, validateSpec: e7.validateSpec, style: e7.style, styleSpec: e7.styleSpec, arrayElementValidator: d3 })), Y(r4) === `array` && r4.length === 0 && t6.push(new z2(e7.key, r4, `array must have at least one stop`)), t6;
        }, default: function(e7) {
          return e7.validateSpec({ key: e7.key, value: e7.value, valueSpec: t5, validateSpec: e7.validateSpec, style: e7.style, styleSpec: e7.styleSpec });
        } } });
        return n4 === `identity` && s3 && u3.push(new z2(e6.key, e6.value, `missing required property "property"`)), n4 === `identity` || e6.value.stops || u3.push(new z2(e6.key, e6.value, `missing required property "stops"`)), n4 === `exponential` && e6.valueSpec.expression && !qr(e6.valueSpec) && u3.push(new z2(e6.key, e6.value, `exponential functions not supported`)), e6.styleSpec.$version >= 8 && (c3 && !Gr(e6.valueSpec) ? u3.push(new z2(e6.key, e6.value, `property functions not supported`)) : s3 && !Kr(e6.valueSpec) && u3.push(new z2(e6.key, e6.value, `zoom functions not supported`))), n4 !== `categorical` && !l3 || e6.value.property !== void 0 || u3.push(new z2(e6.key, e6.value, `"property" property is required`)), u3;
        function d3(e7) {
          let n5 = [], r4 = e7.value, s4 = e7.key;
          if (Y(r4) !== `array`) return [new z2(s4, r4, `array expected, ${Y(r4)} found`)];
          if (r4.length !== 2) return [new z2(s4, r4, `array length 2 expected, length ${r4.length} found`)];
          if (l3) {
            if (Y(r4[0]) !== `object`) return [new z2(s4, r4, `object expected, ${Y(r4[0])} found`)];
            if (r4[0].zoom === void 0) return [new z2(s4, r4, `object stop key must have zoom`)];
            if (r4[0].value === void 0) return [new z2(s4, r4, `object stop key must have value`)];
            if (a3 && a3 > Ti(r4[0].zoom)) return [new z2(s4, r4[0].zoom, `stop zoom values must appear in ascending order`)];
            Ti(r4[0].zoom) !== a3 && (a3 = Ti(r4[0].zoom), i3 = void 0, o3 = {}), n5 = n5.concat(Di({ key: `${s4}[0]`, value: r4[0], valueSpec: { zoom: {} }, validateSpec: e7.validateSpec, style: e7.style, styleSpec: e7.styleSpec, objectElementValidators: { zoom: ki, value: f3 } }));
          } else n5 = n5.concat(f3({ key: `${s4}[0]`, value: r4[0], validateSpec: e7.validateSpec, style: e7.style, styleSpec: e7.styleSpec }, r4));
          return ri(Ei(r4[1])) ? n5.concat([new z2(`${s4}[1]`, r4[1], `expressions are not allowed in function stops.`)]) : n5.concat(e7.validateSpec({ key: `${s4}[1]`, value: r4[1], valueSpec: t5, validateSpec: e7.validateSpec, style: e7.style, styleSpec: e7.styleSpec }));
        }
        function f3(e7, a4) {
          let s4 = Y(e7.value), c4 = Ti(e7.value), l4 = e7.value === null ? a4 : e7.value;
          if (r3) {
            if (s4 !== r3) return [new z2(e7.key, l4, `${s4} stop domain type must match previous stop domain type ${r3}`)];
          } else r3 = s4;
          if (s4 !== `number` && s4 !== `string` && s4 !== `boolean`) return [new z2(e7.key, l4, `stop domain value must be a number, string, or boolean`)];
          if (s4 !== `number` && n4 !== `categorical`) {
            let r4 = `number expected, ${s4} found`;
            return Gr(t5) && n4 === void 0 && (r4 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new z2(e7.key, l4, r4)];
          }
          return n4 !== `categorical` || s4 !== `number` || isFinite(c4) && Math.floor(c4) === c4 ? n4 !== `categorical` && s4 === `number` && i3 !== void 0 && c4 < i3 ? [new z2(e7.key, l4, `stop domain values must appear in ascending order`)] : (i3 = c4, n4 === `categorical` && c4 in o3 ? [new z2(e7.key, l4, `stop domain values must be unique`)] : (o3[c4] = true, [])) : [new z2(e7.key, l4, `integer expected, found ${c4}`)];
        }
      }
      function ji(e6) {
        let t5 = (e6.expressionContext === `property` ? si : ii)(Ei(e6.value), e6.valueSpec);
        if (t5.result === `error`) return t5.value.map(((t6) => new z2(`${e6.key}${t6.key}`, e6.value, t6.message)));
        let n4 = t5.value.expression || t5.value._styleExpression.expression;
        if (e6.expressionContext === `property` && e6.propertyKey === `text-font` && !n4.outputDefined()) return [new z2(e6.key, e6.value, `Invalid data expression for "${e6.propertyKey}". Output values must be contained as literals within the expression.`)];
        if (e6.expressionContext === `property` && e6.propertyType === `layout` && !Vr(n4)) return [new z2(e6.key, e6.value, `"feature-state" data expressions are not supported with layout properties.`)];
        if (e6.expressionContext === `filter` && !Vr(n4)) return [new z2(e6.key, e6.value, `"feature-state" data expressions are not supported with filters.`)];
        if (e6.expressionContext && e6.expressionContext.indexOf(`cluster`) === 0) {
          if (!Hr(n4, [`zoom`, `feature-state`])) return [new z2(e6.key, e6.value, `"zoom" and "feature-state" expressions are not supported with cluster properties.`)];
          if (e6.expressionContext === `cluster-initial` && !Br(n4)) return [new z2(e6.key, e6.value, `Feature data expressions are not supported with initial expression part of cluster properties.`)];
        }
        return [];
      }
      function Mi(e6) {
        let t5 = e6.key, n4 = e6.value, r3 = Y(n4);
        return r3 === `string` ? K2.parse(String(n4)) ? [] : [new z2(t5, n4, `color expected, "${n4}" found`)] : [new z2(t5, n4, `color expected, ${r3} found`)];
      }
      function Ni(e6) {
        let t5 = e6.key, n4 = e6.value, r3 = e6.valueSpec, i3 = [];
        return Array.isArray(r3.values) ? r3.values.indexOf(Ti(n4)) === -1 && i3.push(new z2(t5, n4, `expected one of [${r3.values.join(`, `)}], ${JSON.stringify(n4)} found`)) : Object.keys(r3.values).indexOf(Ti(n4)) === -1 && i3.push(new z2(t5, n4, `expected one of [${Object.keys(r3.values).join(`, `)}], ${JSON.stringify(n4)} found`)), i3;
      }
      function Pi(e6) {
        return fi(Ei(e6.value)) ? ji(Ge2({}, e6, { expressionContext: `filter`, valueSpec: { value: `boolean` } })) : Fi(e6);
      }
      function Fi(e6) {
        let t5 = e6.value, n4 = e6.key;
        if (Y(t5) !== `array`) return [new z2(n4, t5, `array expected, ${Y(t5)} found`)];
        let r3 = e6.styleSpec, i3, a3 = [];
        if (t5.length < 1) return [new z2(n4, t5, `filter array must have at least 1 element`)];
        switch (a3 = a3.concat(Ni({ key: `${n4}[0]`, value: t5[0], valueSpec: r3.filter_operator, style: e6.style, styleSpec: e6.styleSpec })), Ti(t5[0])) {
          case `<`:
          case `<=`:
          case `>`:
          case `>=`:
            t5.length >= 2 && Ti(t5[1]) === `$type` && a3.push(new z2(n4, t5, `"$type" cannot be use with operator "${t5[0]}"`));
          case `==`:
          case `!=`:
            t5.length !== 3 && a3.push(new z2(n4, t5, `filter array for operator "${t5[0]}" must have 3 elements`));
          case `in`:
          case `!in`:
            t5.length >= 2 && (i3 = Y(t5[1]), i3 !== `string` && a3.push(new z2(`${n4}[1]`, t5[1], `string expected, ${i3} found`)));
            for (let o3 = 2; o3 < t5.length; o3++) i3 = Y(t5[o3]), Ti(t5[1]) === `$type` ? a3 = a3.concat(Ni({ key: `${n4}[${o3}]`, value: t5[o3], valueSpec: r3.geometry_type, style: e6.style, styleSpec: e6.styleSpec })) : i3 !== `string` && i3 !== `number` && i3 !== `boolean` && a3.push(new z2(`${n4}[${o3}]`, t5[o3], `string, number, or boolean expected, ${i3} found`));
            break;
          case `any`:
          case `all`:
          case `none`:
            for (let r4 = 1; r4 < t5.length; r4++) a3 = a3.concat(Fi({ key: `${n4}[${r4}]`, value: t5[r4], style: e6.style, styleSpec: e6.styleSpec }));
            break;
          case `has`:
          case `!has`:
            i3 = Y(t5[1]), t5.length === 2 ? i3 !== `string` && a3.push(new z2(`${n4}[1]`, t5[1], `string expected, ${i3} found`)) : a3.push(new z2(n4, t5, `filter array for "${t5[0]}" operator must have 2 elements`));
        }
        return a3;
      }
      function Ii(e6, t5) {
        let n4 = e6.key, r3 = e6.validateSpec, i3 = e6.style, a3 = e6.styleSpec, o3 = e6.value, s3 = e6.objectKey, c3 = a3[`${t5}_${e6.layerType}`];
        if (!c3) return [];
        let l3 = s3.match(/^(.*)-transition$/);
        if (t5 === `paint` && l3 && c3[l3[1]] && c3[l3[1]].transition) return r3({ key: n4, value: o3, valueSpec: a3.transition, style: i3, styleSpec: a3 });
        let u3 = e6.valueSpec || c3[s3];
        if (!u3) return [new z2(n4, o3, `unknown property "${s3}"`)];
        let d3;
        if (Y(o3) === `string` && Gr(u3) && !u3.tokens && (d3 = /^{([^}]+)}$/.exec(o3))) return [new z2(n4, o3, `"${s3}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(d3[1])} }\`.`)];
        let f3 = [];
        return e6.layerType === `symbol` && s3 === `text-font` && Jr(Ei(o3)) && Ti(o3.type) === `identity` && f3.push(new z2(n4, o3, `"text-font" does not support identity functions`)), f3.concat(r3({ key: e6.key, value: o3, valueSpec: u3, style: i3, styleSpec: a3, expressionContext: `property`, propertyType: t5, propertyKey: s3 }));
      }
      function Li(e6) {
        return Ii(e6, `paint`);
      }
      function Ri(e6) {
        return Ii(e6, `layout`);
      }
      function zi(e6) {
        let t5 = [], n4 = e6.value, r3 = e6.key, i3 = e6.style, a3 = e6.styleSpec;
        if (Y(n4) !== `object`) return [new z2(r3, n4, `object expected, ${Y(n4)} found`)];
        n4.type || n4.ref || t5.push(new z2(r3, n4, `either "type" or "ref" is required`));
        let o3 = Ti(n4.type), s3 = Ti(n4.ref);
        if (n4.id) {
          let a4 = Ti(n4.id);
          for (let o4 = 0; o4 < e6.arrayIndex; o4++) {
            let e7 = i3.layers[o4];
            Ti(e7.id) === a4 && t5.push(new z2(r3, n4.id, `duplicate layer id "${n4.id}", previously used at line ${e7.id.__line__}`));
          }
        }
        if (`ref` in n4) {
          let e7;
          [`type`, `source`, `source-layer`, `filter`, `layout`].forEach(((e8) => {
            e8 in n4 && t5.push(new z2(r3, n4[e8], `"${e8}" is prohibited for ref layers`));
          })), i3.layers.forEach(((t6) => {
            Ti(t6.id) === s3 && (e7 = t6);
          })), e7 ? e7.ref ? t5.push(new z2(r3, n4.ref, `ref cannot reference another ref layer`)) : o3 = Ti(e7.type) : t5.push(new z2(r3, n4.ref, `ref layer "${s3}" not found`));
        } else if (o3 !== `background`) if (n4.source) {
          let e7 = i3.sources && i3.sources[n4.source], a4 = e7 && Ti(e7.type);
          e7 ? a4 === `vector` && o3 === `raster` ? t5.push(new z2(r3, n4.source, `layer "${n4.id}" requires a raster source`)) : a4 !== `raster-dem` && o3 === `hillshade` || a4 !== `raster-dem` && o3 === `color-relief` ? t5.push(new z2(r3, n4.source, `layer "${n4.id}" requires a raster-dem source`)) : a4 === `raster` && o3 !== `raster` ? t5.push(new z2(r3, n4.source, `layer "${n4.id}" requires a vector source`)) : a4 !== `vector` || n4[`source-layer`] ? a4 === `raster-dem` && o3 !== `hillshade` && o3 !== `color-relief` ? t5.push(new z2(r3, n4.source, `raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.`)) : o3 !== `line` || !n4.paint || !n4.paint[`line-gradient`] || a4 === `geojson` && e7.lineMetrics || t5.push(new z2(r3, n4, `layer "${n4.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t5.push(new z2(r3, n4, `layer "${n4.id}" must specify a "source-layer"`)) : t5.push(new z2(r3, n4.source, `source "${n4.source}" not found`));
        } else t5.push(new z2(r3, n4, `missing required property "source"`));
        return t5 = t5.concat(Di({ key: r3, value: n4, valueSpec: a3.layer, style: e6.style, styleSpec: e6.styleSpec, validateSpec: e6.validateSpec, objectElementValidators: { "*": () => [], type: () => e6.validateSpec({ key: `${r3}.type`, value: n4.type, valueSpec: a3.layer.type, style: e6.style, styleSpec: e6.styleSpec, validateSpec: e6.validateSpec, object: n4, objectKey: `type` }), filter: Pi, layout: (e7) => Di({ layer: n4, key: e7.key, value: e7.value, style: e7.style, styleSpec: e7.styleSpec, validateSpec: e7.validateSpec, objectElementValidators: { "*": (e8) => Ri(Ge2({ layerType: o3 }, e8)) } }), paint: (e7) => Di({ layer: n4, key: e7.key, value: e7.value, style: e7.style, styleSpec: e7.styleSpec, validateSpec: e7.validateSpec, objectElementValidators: { "*": (e8) => Li(Ge2({ layerType: o3 }, e8)) } }) } })), t5;
      }
      function Bi(e6) {
        let t5 = e6.value, n4 = e6.key, r3 = Y(t5);
        return r3 === `string` ? [] : [new z2(n4, t5, `string expected, ${r3} found`)];
      }
      let Vi = { promoteId: function({ key: e6, value: t5 }) {
        if (Y(t5) === `string`) return Bi({ key: e6, value: t5 });
        {
          let n4 = [];
          for (let r3 in t5) n4.push(...Bi({ key: `${e6}.${r3}`, value: t5[r3] }));
          return n4;
        }
      } };
      function Hi(e6) {
        let t5 = e6.value, n4 = e6.key, r3 = e6.styleSpec, i3 = e6.style, a3 = e6.validateSpec;
        if (!t5.type) return [new z2(n4, t5, `"type" is required`)];
        let o3 = Ti(t5.type), s3;
        switch (o3) {
          case `vector`:
          case `raster`:
            return s3 = Di({ key: n4, value: t5, valueSpec: r3[`source_${o3.replace(`-`, `_`)}`], style: e6.style, styleSpec: r3, objectElementValidators: Vi, validateSpec: a3 }), s3;
          case `raster-dem`:
            return s3 = (function(e7) {
              let t6 = e7.sourceName ?? ``, n5 = e7.value, r4 = e7.styleSpec, i4 = r4.source_raster_dem, a4 = e7.style, o4 = [], s4 = Y(n5);
              if (n5 === void 0) return o4;
              if (s4 !== `object`) return o4.push(new z2(`source_raster_dem`, n5, `object expected, ${s4} found`)), o4;
              let c3 = Ti(n5.encoding) === `custom`, l3 = [`redFactor`, `greenFactor`, `blueFactor`, `baseShift`], u3 = e7.value.encoding ? `"${e7.value.encoding}"` : `Default`;
              for (let s5 in n5) !c3 && l3.includes(s5) ? o4.push(new z2(s5, n5[s5], `In "${t6}": "${s5}" is only valid when "encoding" is set to "custom". ${u3} encoding found`)) : i4[s5] ? o4 = o4.concat(e7.validateSpec({ key: s5, value: n5[s5], valueSpec: i4[s5], validateSpec: e7.validateSpec, style: a4, styleSpec: r4 })) : o4.push(new z2(s5, n5[s5], `unknown property "${s5}"`));
              return o4;
            })({ sourceName: n4, value: t5, style: e6.style, styleSpec: r3, validateSpec: a3 }), s3;
          case `geojson`:
            if (s3 = Di({ key: n4, value: t5, valueSpec: r3.source_geojson, style: i3, styleSpec: r3, validateSpec: a3, objectElementValidators: Vi }), t5.cluster) for (let e7 in t5.clusterProperties) {
              let [r4, i4] = t5.clusterProperties[e7], a4 = typeof r4 == `string` ? [r4, [`accumulated`], [`get`, e7]] : r4;
              s3.push(...ji({ key: `${n4}.${e7}.map`, value: i4, expressionContext: `cluster-map` })), s3.push(...ji({ key: `${n4}.${e7}.reduce`, value: a4, expressionContext: `cluster-reduce` }));
            }
            return s3;
          case `video`:
            return Di({ key: n4, value: t5, valueSpec: r3.source_video, style: i3, validateSpec: a3, styleSpec: r3 });
          case `image`:
            return Di({ key: n4, value: t5, valueSpec: r3.source_image, style: i3, validateSpec: a3, styleSpec: r3 });
          case `canvas`:
            return [new z2(n4, null, `Please use runtime APIs to add canvas sources, rather than including them in stylesheets.`, `source.canvas`)];
          default:
            return Ni({ key: `${n4}.type`, value: t5.type, valueSpec: { values: [`vector`, `raster`, `raster-dem`, `geojson`, `video`, `image`] } });
        }
      }
      function Ui(e6) {
        let t5 = e6.value, n4 = e6.styleSpec, r3 = n4.light, i3 = e6.style, a3 = [], o3 = Y(t5);
        if (t5 === void 0) return a3;
        if (o3 !== `object`) return a3 = a3.concat([new z2(`light`, t5, `object expected, ${o3} found`)]), a3;
        for (let o4 in t5) {
          let s3 = o4.match(/^(.*)-transition$/);
          a3 = a3.concat(s3 && r3[s3[1]] && r3[s3[1]].transition ? e6.validateSpec({ key: o4, value: t5[o4], valueSpec: n4.transition, validateSpec: e6.validateSpec, style: i3, styleSpec: n4 }) : r3[o4] ? e6.validateSpec({ key: o4, value: t5[o4], valueSpec: r3[o4], validateSpec: e6.validateSpec, style: i3, styleSpec: n4 }) : [new z2(o4, t5[o4], `unknown property "${o4}"`)]);
        }
        return a3;
      }
      function Wi(e6) {
        let t5 = e6.value, n4 = e6.styleSpec, r3 = n4.sky, i3 = e6.style, a3 = Y(t5);
        if (t5 === void 0) return [];
        if (a3 !== `object`) return [new z2(`sky`, t5, `object expected, ${a3} found`)];
        let o3 = [];
        for (let a4 in t5) o3 = o3.concat(r3[a4] ? e6.validateSpec({ key: a4, value: t5[a4], valueSpec: r3[a4], style: i3, styleSpec: n4 }) : [new z2(a4, t5[a4], `unknown property "${a4}"`)]);
        return o3;
      }
      function Gi(e6) {
        let t5 = e6.value, n4 = e6.styleSpec, r3 = n4.terrain, i3 = e6.style, a3 = [], o3 = Y(t5);
        if (t5 === void 0) return a3;
        if (o3 !== `object`) return a3 = a3.concat([new z2(`terrain`, t5, `object expected, ${o3} found`)]), a3;
        for (let o4 in t5) a3 = a3.concat(r3[o4] ? e6.validateSpec({ key: o4, value: t5[o4], valueSpec: r3[o4], validateSpec: e6.validateSpec, style: i3, styleSpec: n4 }) : [new z2(o4, t5[o4], `unknown property "${o4}"`)]);
        return a3;
      }
      function Ki(e6) {
        let t5 = [], n4 = e6.value, r3 = e6.key;
        if (Array.isArray(n4)) {
          let i3 = [], a3 = [];
          for (let o3 in n4) n4[o3].id && i3.includes(n4[o3].id) && t5.push(new z2(r3, n4, `all the sprites' ids must be unique, but ${n4[o3].id} is duplicated`)), i3.push(n4[o3].id), n4[o3].url && a3.includes(n4[o3].url) && t5.push(new z2(r3, n4, `all the sprites' URLs must be unique, but ${n4[o3].url} is duplicated`)), a3.push(n4[o3].url), t5 = t5.concat(Di({ key: `${r3}[${o3}]`, value: n4[o3], valueSpec: { id: { type: `string`, required: true }, url: { type: `string`, required: true } }, validateSpec: e6.validateSpec }));
          return t5;
        }
        return Bi({ key: r3, value: n4 });
      }
      function qi(e6) {
        return t5 = e6.value, t5 && t5.constructor === Object ? [] : [new z2(e6.key, e6.value, `object expected, ${Y(e6.value)} found`)];
        var t5;
      }
      let Ji = { "*": () => [], array: Oi, boolean: function(e6) {
        let t5 = e6.value, n4 = e6.key, r3 = Y(t5);
        return r3 === `boolean` ? [] : [new z2(n4, t5, `boolean expected, ${r3} found`)];
      }, number: ki, color: Mi, constants: wi, enum: Ni, filter: Pi, function: Ai, layer: zi, object: Di, source: Hi, light: Ui, sky: Wi, terrain: Gi, projection: function(e6) {
        let t5 = e6.value, n4 = e6.styleSpec, r3 = n4.projection, i3 = e6.style, a3 = Y(t5);
        if (t5 === void 0) return [];
        if (a3 !== `object`) return [new z2(`projection`, t5, `object expected, ${a3} found`)];
        let o3 = [];
        for (let a4 in t5) o3 = o3.concat(r3[a4] ? e6.validateSpec({ key: a4, value: t5[a4], valueSpec: r3[a4], style: i3, styleSpec: n4 }) : [new z2(a4, t5[a4], `unknown property "${a4}"`)]);
        return o3;
      }, projectionDefinition: function(e6) {
        let t5 = e6.key, n4 = e6.value;
        n4 = n4 instanceof String ? n4.valueOf() : n4;
        let r3 = Y(n4);
        return r3 !== `array` || (function(e7) {
          return Array.isArray(e7) && e7.length === 3 && typeof e7[0] == `string` && typeof e7[1] == `string` && typeof e7[2] == `number`;
        })(n4) || (function(e7) {
          return !![`interpolate`, `step`, `literal`].includes(e7[0]);
        })(n4) ? [`array`, `string`].includes(r3) ? [] : [new z2(t5, n4, `projection expected, invalid type "${r3}" found`)] : [new z2(t5, n4, `projection expected, invalid array ${JSON.stringify(n4)} found`)];
      }, string: Bi, formatted: function(e6) {
        return Bi(e6).length === 0 ? [] : ji(e6);
      }, resolvedImage: function(e6) {
        return Bi(e6).length === 0 ? [] : ji(e6);
      }, padding: function(e6) {
        let t5 = e6.key, n4 = e6.value;
        if (Y(n4) === `array`) {
          if (n4.length < 1 || n4.length > 4) return [new z2(t5, n4, `padding requires 1 to 4 values; ${n4.length} values found`)];
          let r3 = { type: `number` }, i3 = [];
          for (let a3 = 0; a3 < n4.length; a3++) i3 = i3.concat(e6.validateSpec({ key: `${t5}[${a3}]`, value: n4[a3], validateSpec: e6.validateSpec, valueSpec: r3 }));
          return i3;
        }
        return ki({ key: t5, value: n4, valueSpec: {} });
      }, numberArray: function(e6) {
        let t5 = e6.key, n4 = e6.value;
        if (Y(n4) === `array`) {
          let r3 = { type: `number` };
          if (n4.length < 1) return [new z2(t5, n4, `array length at least 1 expected, length 0 found`)];
          let i3 = [];
          for (let a3 = 0; a3 < n4.length; a3++) i3 = i3.concat(e6.validateSpec({ key: `${t5}[${a3}]`, value: n4[a3], validateSpec: e6.validateSpec, valueSpec: r3 }));
          return i3;
        }
        return ki({ key: t5, value: n4, valueSpec: {} });
      }, colorArray: function(e6) {
        let t5 = e6.key, n4 = e6.value;
        if (Y(n4) === `array`) {
          if (n4.length < 1) return [new z2(t5, n4, `array length at least 1 expected, length 0 found`)];
          let e7 = [];
          for (let r3 = 0; r3 < n4.length; r3++) e7 = e7.concat(Mi({ key: `${t5}[${r3}]`, value: n4[r3] }));
          return e7;
        }
        return Mi({ key: t5, value: n4 });
      }, variableAnchorOffsetCollection: function(e6) {
        let t5 = e6.key, n4 = e6.value, r3 = Y(n4), i3 = e6.styleSpec;
        if (r3 !== `array` || n4.length < 1 || n4.length % 2 != 0) return [new z2(t5, n4, `variableAnchorOffsetCollection requires a non-empty array of even length`)];
        let a3 = [];
        for (let r4 = 0; r4 < n4.length; r4 += 2) a3 = a3.concat(Ni({ key: `${t5}[${r4}]`, value: n4[r4], valueSpec: i3.layout_symbol[`text-anchor`] })), a3 = a3.concat(Oi({ key: `${t5}[${r4 + 1}]`, value: n4[r4 + 1], valueSpec: { length: 2, value: `number` }, validateSpec: e6.validateSpec, style: e6.style, styleSpec: i3 }));
        return a3;
      }, sprite: Ki, state: qi };
      function Yi(e6) {
        let t5 = e6.value, n4 = e6.valueSpec, r3 = e6.styleSpec;
        return e6.validateSpec = Yi, n4.expression && Jr(Ti(t5)) ? Ai(e6) : n4.expression && ri(Ei(t5)) ? ji(e6) : n4.type && Ji[n4.type] ? Ji[n4.type](e6) : Di(Ge2({}, e6, { valueSpec: n4.type ? r3[n4.type] : n4 }));
      }
      function Xi(e6) {
        let t5 = e6.value, n4 = e6.key, r3 = Bi(e6);
        return r3.length || (t5.indexOf(`{fontstack}`) === -1 && r3.push(new z2(n4, t5, `"glyphs" url must include a "{fontstack}" token`)), t5.indexOf(`{range}`) === -1 && r3.push(new z2(n4, t5, `"glyphs" url must include a "{range}" token`))), r3;
      }
      function Zi(e6, t5 = R2) {
        let n4 = [];
        return n4 = n4.concat(Yi({ key: ``, value: e6, valueSpec: t5.$root, styleSpec: t5, style: e6, validateSpec: Yi, objectElementValidators: { glyphs: Xi, "*": () => [] } })), e6.constants && (n4 = n4.concat(wi({ key: `constants`, value: e6.constants }))), $i(n4);
      }
      function Qi(e6) {
        return function(t5) {
          return e6(Object.assign({}, t5, { validateSpec: Yi }));
        };
      }
      function $i(e6) {
        return [].concat(e6).sort(((e7, t5) => e7.line - t5.line));
      }
      function ea(e6) {
        return function(...t5) {
          return $i(e6.apply(this, t5));
        };
      }
      Zi.source = ea(Qi(Hi)), Zi.sprite = ea(Qi(Ki)), Zi.glyphs = ea(Qi(Xi)), Zi.light = ea(Qi(Ui)), Zi.sky = ea(Qi(Wi)), Zi.terrain = ea(Qi(Gi)), Zi.state = ea(Qi(qi)), Zi.layer = ea(Qi(zi)), Zi.filter = ea(Qi(Pi)), Zi.paintProperty = ea(Qi(Li)), Zi.layoutProperty = ea(Qi(Ri));
      let ta = R2, na = Zi, ra = na.light, ia = na.sky, aa = na.paintProperty, oa = na.layoutProperty;
      function sa(e6, t5) {
        let n4 = false;
        if (t5 && t5.length) for (let r3 of t5) e6.fire(new Me2(Error(r3.message))), n4 = true;
        return n4;
      }
      class ca {
        constructor(e6, t5, n4) {
          let r3 = this.cells = [];
          if (e6 instanceof ArrayBuffer) {
            this.arrayBuffer = e6;
            let i4 = new Int32Array(this.arrayBuffer);
            e6 = i4[0], this.d = (t5 = i4[1]) + 2 * (n4 = i4[2]);
            for (let e7 = 0; e7 < this.d * this.d; e7++) {
              let t6 = i4[3 + e7], n5 = i4[3 + e7 + 1];
              r3.push(t6 === n5 ? null : i4.subarray(t6, n5));
            }
            let a3 = i4[3 + r3.length + 1];
            this.keys = i4.subarray(i4[3 + r3.length], a3), this.bboxes = i4.subarray(a3), this.insert = this._insertReadonly;
          } else {
            this.d = t5 + 2 * n4;
            for (let e7 = 0; e7 < this.d * this.d; e7++) r3.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = t5, this.extent = e6, this.padding = n4, this.scale = t5 / e6, this.uid = 0;
          let i3 = n4 / t5 * e6;
          this.min = -i3, this.max = e6 + i3;
        }
        insert(e6, t5, n4, r3, i3) {
          this._forEachCell(t5, n4, r3, i3, this._insertCell, this.uid++, void 0, void 0), this.keys.push(e6), this.bboxes.push(t5), this.bboxes.push(n4), this.bboxes.push(r3), this.bboxes.push(i3);
        }
        _insertReadonly() {
          throw Error(`Cannot insert into a GridIndex created from an ArrayBuffer.`);
        }
        _insertCell(e6, t5, n4, r3, i3, a3) {
          this.cells[i3].push(a3);
        }
        query(e6, t5, n4, r3, i3) {
          let a3 = this.min, o3 = this.max;
          if (e6 <= a3 && t5 <= a3 && o3 <= n4 && o3 <= r3 && !i3) return Array.prototype.slice.call(this.keys);
          {
            let a4 = [];
            return this._forEachCell(e6, t5, n4, r3, this._queryCell, a4, {}, i3), a4;
          }
        }
        _queryCell(e6, t5, n4, r3, i3, a3, o3, s3) {
          let c3 = this.cells[i3];
          if (c3 !== null) {
            let i4 = this.keys, l3 = this.bboxes;
            for (let u3 = 0; u3 < c3.length; u3++) {
              let d3 = c3[u3];
              if (o3[d3] === void 0) {
                let c4 = 4 * d3;
                (s3 ? s3(l3[c4 + 0], l3[c4 + 1], l3[c4 + 2], l3[c4 + 3]) : e6 <= l3[c4 + 2] && t5 <= l3[c4 + 3] && n4 >= l3[c4 + 0] && r3 >= l3[c4 + 1]) ? (o3[d3] = true, a3.push(i4[d3])) : o3[d3] = false;
              }
            }
          }
        }
        _forEachCell(e6, t5, n4, r3, i3, a3, o3, s3) {
          let c3 = this._convertToCellCoord(e6), l3 = this._convertToCellCoord(t5), u3 = this._convertToCellCoord(n4), d3 = this._convertToCellCoord(r3);
          for (let f3 = c3; f3 <= u3; f3++) for (let c4 = l3; c4 <= d3; c4++) {
            let l4 = this.d * c4 + f3;
            if ((!s3 || s3(this._convertFromCellCoord(f3), this._convertFromCellCoord(c4), this._convertFromCellCoord(f3 + 1), this._convertFromCellCoord(c4 + 1))) && i3.call(this, e6, t5, n4, r3, l4, a3, o3, s3)) return;
          }
        }
        _convertFromCellCoord(e6) {
          return (e6 - this.padding) / this.scale;
        }
        _convertToCellCoord(e6) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(e6 * this.scale) + this.padding));
        }
        toArrayBuffer() {
          if (this.arrayBuffer) return this.arrayBuffer;
          let e6 = this.cells, t5 = 3 + this.cells.length + 1 + 1, n4 = 0;
          for (let e7 = 0; e7 < this.cells.length; e7++) n4 += this.cells[e7].length;
          let r3 = new Int32Array(t5 + n4 + this.keys.length + this.bboxes.length);
          r3[0] = this.extent, r3[1] = this.n, r3[2] = this.padding;
          let i3 = t5;
          for (let t6 = 0; t6 < e6.length; t6++) {
            let n5 = e6[t6];
            r3[3 + t6] = i3, r3.set(n5, i3), i3 += n5.length;
          }
          return r3[3 + e6.length] = i3, r3.set(this.keys, i3), i3 += this.keys.length, r3[3 + e6.length + 1] = i3, r3.set(this.bboxes, i3), i3 += this.bboxes.length, r3.buffer;
        }
        static serialize(e6, t5) {
          let n4 = e6.toArrayBuffer();
          return t5 && t5.push(n4), { buffer: n4 };
        }
        static deserialize(e6) {
          return new ca(e6.buffer);
        }
      }
      let la = {};
      function X(e6, t5, n4 = {}) {
        if (la[e6]) throw Error(`${e6} is already registered.`);
        Object.defineProperty(t5, `_classRegistryKey`, { value: e6, writeable: false }), la[e6] = { klass: t5, omit: n4.omit || [], shallow: n4.shallow || [] };
      }
      for (let e6 in X(`Object`, Object), X(`Set`, Set), X(`TransferableGridIndex`, ca), X(`Color`, K2), X(`Error`, Error), X(`AJAXError`, Te2), X(`ResolvedImage`, Ut2), X(`StylePropertyFunction`, ci), X(`StyleExpression`, ni, { omit: [`_evaluator`] }), X(`ZoomDependentExpression`, oi), X(`ZoomConstantExpression`, ai), X(`CompoundExpression`, Pr, { omit: [`_evaluate`] }), Nr) Nr[e6]._classRegistryKey || X(`Expression_${e6}`, Nr[e6]);
      function ua(e6) {
        return e6 && typeof ArrayBuffer < `u` && (e6 instanceof ArrayBuffer || e6.constructor && e6.constructor.name === `ArrayBuffer`);
      }
      function da(e6) {
        return e6.$name || e6.constructor._classRegistryKey;
      }
      function fa(e6) {
        return !(function(e7) {
          if (typeof e7 != `object` || !e7) return false;
          let t5 = da(e7);
          return !(!t5 || t5 === `Object`);
        })(e6) && (e6 == null || typeof e6 == `boolean` || typeof e6 == `number` || typeof e6 == `string` || e6 instanceof Boolean || e6 instanceof Number || e6 instanceof String || e6 instanceof Date || e6 instanceof RegExp || e6 instanceof Blob || e6 instanceof Error || ua(e6) || fe2(e6) || ArrayBuffer.isView(e6) || e6 instanceof ImageData);
      }
      function pa(e6, t5) {
        if (fa(e6)) return (ua(e6) || fe2(e6)) && t5 && t5.push(e6), ArrayBuffer.isView(e6) && t5 && t5.push(e6.buffer), e6 instanceof ImageData && t5 && t5.push(e6.data.buffer), e6;
        if (Array.isArray(e6)) {
          let n5 = [];
          for (let r4 of e6) n5.push(pa(r4, t5));
          return n5;
        }
        if (typeof e6 != `object`) throw Error(`can't serialize object of type ` + typeof e6);
        let n4 = da(e6);
        if (!n4) throw Error(`can't serialize object of unregistered class ${e6.constructor.name}`);
        if (!la[n4]) throw Error(`${n4} is not registered.`);
        let { klass: r3 } = la[n4], i3 = r3.serialize ? r3.serialize(e6, t5) : {};
        if (r3.serialize) {
          if (t5 && i3 === t5[t5.length - 1]) throw Error(`statically serialized object won't survive transfer of $name property`);
        } else {
          for (let r4 in e6) {
            if (!e6.hasOwnProperty(r4) || la[n4].omit.indexOf(r4) >= 0) continue;
            let a3 = e6[r4];
            i3[r4] = la[n4].shallow.indexOf(r4) >= 0 ? a3 : pa(a3, t5);
          }
          e6 instanceof Error && (i3.message = e6.message);
        }
        if (i3.$name) throw Error(`$name property is reserved for worker serialization logic.`);
        return n4 !== `Object` && (i3.$name = n4), i3;
      }
      function ma(e6) {
        if (fa(e6)) return e6;
        if (Array.isArray(e6)) return e6.map(ma);
        if (typeof e6 != `object`) throw Error(`can't deserialize object of type ` + typeof e6);
        let t5 = da(e6) || `Object`;
        if (!la[t5]) throw Error(`can't deserialize unregistered class ${t5}`);
        let { klass: n4 } = la[t5];
        if (!n4) throw Error(`can't deserialize unregistered class ${t5}`);
        if (n4.deserialize) return n4.deserialize(e6);
        let r3 = Object.create(n4.prototype);
        for (let n5 of Object.keys(e6)) {
          if (n5 === `$name`) continue;
          let i3 = e6[n5];
          r3[n5] = la[t5].shallow.indexOf(n5) >= 0 ? i3 : ma(i3);
        }
        return r3;
      }
      class ha {
        constructor() {
          this.first = true;
        }
        update(e6, t5) {
          let n4 = Math.floor(e6);
          return this.first ? (this.first = false, this.lastIntegerZoom = n4, this.lastIntegerZoomTime = 0, this.lastZoom = e6, this.lastFloorZoom = n4, true) : (this.lastFloorZoom > n4 ? (this.lastIntegerZoom = n4 + 1, this.lastIntegerZoomTime = t5) : this.lastFloorZoom < n4 && (this.lastIntegerZoom = n4, this.lastIntegerZoomTime = t5), e6 !== this.lastZoom && (this.lastZoom = e6, this.lastFloorZoom = n4, true));
        }
      }
      let Z = { "Latin-1 Supplement": (e6) => e6 >= 128 && e6 <= 255, "Hangul Jamo": (e6) => e6 >= 4352 && e6 <= 4607, Khmer: (e6) => e6 >= 6016 && e6 <= 6143, "General Punctuation": (e6) => e6 >= 8192 && e6 <= 8303, "Letterlike Symbols": (e6) => e6 >= 8448 && e6 <= 8527, "Number Forms": (e6) => e6 >= 8528 && e6 <= 8591, "Miscellaneous Technical": (e6) => e6 >= 8960 && e6 <= 9215, "Control Pictures": (e6) => e6 >= 9216 && e6 <= 9279, "Optical Character Recognition": (e6) => e6 >= 9280 && e6 <= 9311, "Enclosed Alphanumerics": (e6) => e6 >= 9312 && e6 <= 9471, "Geometric Shapes": (e6) => e6 >= 9632 && e6 <= 9727, "Miscellaneous Symbols": (e6) => e6 >= 9728 && e6 <= 9983, "Miscellaneous Symbols and Arrows": (e6) => e6 >= 11008 && e6 <= 11263, "Ideographic Description Characters": (e6) => e6 >= 12272 && e6 <= 12287, "CJK Symbols and Punctuation": (e6) => e6 >= 12288 && e6 <= 12351, Hiragana: (e6) => e6 >= 12352 && e6 <= 12447, Katakana: (e6) => e6 >= 12448 && e6 <= 12543, Kanbun: (e6) => e6 >= 12688 && e6 <= 12703, "CJK Strokes": (e6) => e6 >= 12736 && e6 <= 12783, "Enclosed CJK Letters and Months": (e6) => e6 >= 12800 && e6 <= 13055, "CJK Compatibility": (e6) => e6 >= 13056 && e6 <= 13311, "Yijing Hexagram Symbols": (e6) => e6 >= 19904 && e6 <= 19967, "CJK Unified Ideographs": (e6) => e6 >= 19968 && e6 <= 40959, "Hangul Syllables": (e6) => e6 >= 44032 && e6 <= 55215, "Private Use Area": (e6) => e6 >= 57344 && e6 <= 63743, "Vertical Forms": (e6) => e6 >= 65040 && e6 <= 65055, "CJK Compatibility Forms": (e6) => e6 >= 65072 && e6 <= 65103, "Small Form Variants": (e6) => e6 >= 65104 && e6 <= 65135, "Halfwidth and Fullwidth Forms": (e6) => e6 >= 65280 && e6 <= 65519 };
      function ga(e6) {
        for (let t5 of e6) if (Sa(t5.charCodeAt(0))) return true;
        return false;
      }
      function _a2(e6) {
        for (let t5 of e6) if (!ba(t5.charCodeAt(0))) return false;
        return true;
      }
      function va(e6) {
        let t5 = e6.map(((e7) => {
          try {
            return RegExp(`\\p{sc=${e7}}`, `u`).source;
          } catch {
            return null;
          }
        })).filter(((e7) => e7));
        return new RegExp(t5.join(`|`), `u`);
      }
      let ya = va([`Arab`, `Dupl`, `Mong`, `Ougr`, `Syrc`]);
      function ba(e6) {
        return !ya.test(String.fromCodePoint(e6));
      }
      let xa = va([`Bopo`, `Hani`, `Hira`, `Kana`, `Kits`, `Nshu`, `Tang`, `Yiii`]);
      function Sa(e6) {
        return !(e6 !== 746 && e6 !== 747 && (e6 < 4352 || !(Z[`CJK Compatibility Forms`](e6) && !(e6 >= 65097 && e6 <= 65103) || Z[`CJK Compatibility`](e6) || Z[`CJK Strokes`](e6) || !(!Z[`CJK Symbols and Punctuation`](e6) || e6 >= 12296 && e6 <= 12305 || e6 >= 12308 && e6 <= 12319 || e6 === 12336) || Z[`Enclosed CJK Letters and Months`](e6) || Z[`Ideographic Description Characters`](e6) || Z.Kanbun(e6) || Z.Katakana(e6) && e6 !== 12540 || !(!Z[`Halfwidth and Fullwidth Forms`](e6) || e6 === 65288 || e6 === 65289 || e6 === 65293 || e6 >= 65306 && e6 <= 65310 || e6 === 65339 || e6 === 65341 || e6 === 65343 || e6 >= 65371 && e6 <= 65503 || e6 === 65507 || e6 >= 65512 && e6 <= 65519) || !(!Z[`Small Form Variants`](e6) || e6 >= 65112 && e6 <= 65118 || e6 >= 65123 && e6 <= 65126) || Z[`Vertical Forms`](e6) || Z[`Yijing Hexagram Symbols`](e6) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(e6)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(e6)) || xa.test(String.fromCodePoint(e6)))));
      }
      function Ca(e6) {
        return !(Sa(e6) || (function(e7) {
          return !!(Z[`Latin-1 Supplement`](e7) && (e7 === 167 || e7 === 169 || e7 === 174 || e7 === 177 || e7 === 188 || e7 === 189 || e7 === 190 || e7 === 215 || e7 === 247) || Z[`General Punctuation`](e7) && (e7 === 8214 || e7 === 8224 || e7 === 8225 || e7 === 8240 || e7 === 8241 || e7 === 8251 || e7 === 8252 || e7 === 8258 || e7 === 8263 || e7 === 8264 || e7 === 8265 || e7 === 8273) || Z[`Letterlike Symbols`](e7) || Z[`Number Forms`](e7) || Z[`Miscellaneous Technical`](e7) && (e7 >= 8960 && e7 <= 8967 || e7 >= 8972 && e7 <= 8991 || e7 >= 8996 && e7 <= 9e3 || e7 === 9003 || e7 >= 9085 && e7 <= 9114 || e7 >= 9150 && e7 <= 9165 || e7 === 9167 || e7 >= 9169 && e7 <= 9179 || e7 >= 9186 && e7 <= 9215) || Z[`Control Pictures`](e7) && e7 !== 9251 || Z[`Optical Character Recognition`](e7) || Z[`Enclosed Alphanumerics`](e7) || Z[`Geometric Shapes`](e7) || Z[`Miscellaneous Symbols`](e7) && !(e7 >= 9754 && e7 <= 9759) || Z[`Miscellaneous Symbols and Arrows`](e7) && (e7 >= 11026 && e7 <= 11055 || e7 >= 11088 && e7 <= 11097 || e7 >= 11192 && e7 <= 11243) || Z[`CJK Symbols and Punctuation`](e7) || Z.Katakana(e7) || Z[`Private Use Area`](e7) || Z[`CJK Compatibility Forms`](e7) || Z[`Small Form Variants`](e7) || Z[`Halfwidth and Fullwidth Forms`](e7) || e7 === 8734 || e7 === 8756 || e7 === 8757 || e7 >= 9984 && e7 <= 10087 || e7 >= 10102 && e7 <= 10131 || e7 === 65532 || e7 === 65533);
        })(e6));
      }
      let wa = va(`Adlm.Arab.Armi.Avst.Chrs.Cprt.Egyp.Elym.Gara.Hatr.Hebr.Hung.Khar.Lydi.Mand.Mani.Mend.Merc.Mero.Narb.Nbat.Nkoo.Orkh.Palm.Phli.Phlp.Phnx.Prti.Rohg.Samr.Sarb.Sogo.Syrc.Thaa.Todr.Yezi`.split(`.`));
      function Ta(e6) {
        return wa.test(String.fromCodePoint(e6));
      }
      function Ea(e6, t5) {
        return !(!t5 && Ta(e6) || e6 >= 2304 && e6 <= 3583 || e6 >= 3840 && e6 <= 4255 || Z.Khmer(e6));
      }
      function Da(e6) {
        for (let t5 of e6) if (Ta(t5.charCodeAt(0))) return true;
        return false;
      }
      let Oa = new class {
        constructor() {
          this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = `unavailable`, this.pluginURL = null, this.loadScriptResolve = () => {
          };
        }
        setState(e6) {
          this.pluginStatus = e6.pluginStatus, this.pluginURL = e6.pluginURL;
        }
        getState() {
          return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
        }
        setMethods(e6) {
          if (Oa.isParsed()) throw Error(`RTL text plugin already registered.`);
          this.applyArabicShaping = e6.applyArabicShaping, this.processBidirectionalText = e6.processBidirectionalText, this.processStyledBidirectionalText = e6.processStyledBidirectionalText, this.loadScriptResolve();
        }
        isParsed() {
          return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
        }
        getRTLTextPluginStatus() {
          return this.pluginStatus;
        }
        syncState(e6, n4) {
          return t4(this, void 0, void 0, (function* () {
            if (this.isParsed()) return this.getState();
            if (e6.pluginStatus !== `loading`) return this.setState(e6), e6;
            let t5 = e6.pluginURL, r3 = new Promise(((e7) => {
              this.loadScriptResolve = e7;
            }));
            n4(t5);
            let i3 = new Promise(((e7) => setTimeout((() => e7()), this.TIMEOUT)));
            if (yield Promise.race([r3, i3]), this.isParsed()) {
              let e7 = { pluginStatus: `loaded`, pluginURL: t5 };
              return this.setState(e7), e7;
            }
            throw this.setState({ pluginStatus: `error`, pluginURL: `` }), Error(`RTL Text Plugin failed to import scripts from ${t5}`);
          }));
        }
      }();
      class ka {
        constructor(e6, t5) {
          this.isSupportedScript = Aa, this.zoom = e6, t5 ? (this.now = t5.now || 0, this.fadeDuration = t5.fadeDuration || 0, this.zoomHistory = t5.zoomHistory || new ha(), this.transition = t5.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new ha(), this.transition = {});
        }
        crossFadingFactor() {
          return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }
        getCrossfadeParameters() {
          let e6 = this.zoom, t5 = e6 - Math.floor(e6), n4 = this.crossFadingFactor();
          return e6 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: t5 + (1 - t5) * n4 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - n4) * t5 };
        }
      }
      function Aa(e6) {
        return (function(e7, t5) {
          for (let n4 of e7) if (!Ea(n4.charCodeAt(0), t5)) return false;
          return true;
        })(e6, Oa.getRTLTextPluginStatus() === `loaded`);
      }
      class ja {
        constructor(e6, t5, n4) {
          this.property = e6, this.value = t5, this.expression = (function(e7, t6, n5) {
            if (Jr(e7)) return new ci(e7, t6);
            if (ri(e7)) {
              let r3 = si(e7, t6, n5);
              if (r3.result === `error`) throw Error(r3.value.map(((e8) => `${e8.key}: ${e8.message}`)).join(`, `));
              return r3.value;
            }
            {
              let n6 = e7;
              return t6.type === `color` && typeof e7 == `string` ? n6 = K2.parse(e7) : t6.type !== `padding` || typeof e7 != `number` && !Array.isArray(e7) ? t6.type !== `numberArray` || typeof e7 != `number` && !Array.isArray(e7) ? t6.type !== `colorArray` || typeof e7 != `string` && !Array.isArray(e7) ? t6.type === `variableAnchorOffsetCollection` && Array.isArray(e7) ? n6 = Ht2.parse(e7) : t6.type === `projectionDefinition` && typeof e7 == `string` && (n6 = Wt2.parse(e7)) : n6 = zt2.parse(e7) : n6 = Rt2.parse(e7) : n6 = Lt2.parse(e7), { globalStateRefs: /* @__PURE__ */ new Set(), _globalState: null, kind: `constant`, evaluate: () => n6 };
            }
          })(t5 === void 0 ? e6.specification.default : t5, e6.specification, n4);
        }
        isDataDriven() {
          return this.expression.kind === `source` || this.expression.kind === `composite`;
        }
        getGlobalStateRefs() {
          return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
        }
        possiblyEvaluate(e6, t5, n4) {
          return this.property.possiblyEvaluate(this, e6, t5, n4);
        }
      }
      class Ma {
        constructor(e6, t5) {
          this.property = e6, this.value = new ja(e6, void 0, t5);
        }
        transitioned(e6, t5) {
          return new Pa(this.property, this.value, t5, P2({}, e6.transition, this.transition), e6.now);
        }
        untransitioned() {
          return new Pa(this.property, this.value, null, {}, 0);
        }
      }
      class Na {
        constructor(e6, t5) {
          this._properties = e6, this._values = Object.create(e6.defaultTransitionablePropertyValues), this._globalState = t5;
        }
        getValue(e6) {
          return oe2(this._values[e6].value.value);
        }
        setValue(e6, t5) {
          Object.prototype.hasOwnProperty.call(this._values, e6) || (this._values[e6] = new Ma(this._values[e6].property, this._globalState)), this._values[e6].value = new ja(this._values[e6].property, t5 === null ? void 0 : oe2(t5), this._globalState);
        }
        getTransition(e6) {
          return oe2(this._values[e6].transition);
        }
        setTransition(e6, t5) {
          Object.prototype.hasOwnProperty.call(this._values, e6) || (this._values[e6] = new Ma(this._values[e6].property, this._globalState)), this._values[e6].transition = oe2(t5) || void 0;
        }
        serialize() {
          let e6 = {};
          for (let t5 of Object.keys(this._values)) {
            let n4 = this.getValue(t5);
            n4 !== void 0 && (e6[t5] = n4);
            let r3 = this.getTransition(t5);
            r3 !== void 0 && (e6[`${t5}-transition`] = r3);
          }
          return e6;
        }
        transitioned(e6, t5) {
          let n4 = new Fa(this._properties);
          for (let r3 of Object.keys(this._values)) n4._values[r3] = this._values[r3].transitioned(e6, t5._values[r3]);
          return n4;
        }
        untransitioned() {
          let e6 = new Fa(this._properties);
          for (let t5 of Object.keys(this._values)) e6._values[t5] = this._values[t5].untransitioned();
          return e6;
        }
      }
      class Pa {
        constructor(e6, t5, n4, r3, i3) {
          this.property = e6, this.value = t5, this.begin = i3 + r3.delay || 0, this.end = this.begin + r3.duration || 0, e6.specification.transition && (r3.delay || r3.duration) && (this.prior = n4);
        }
        possiblyEvaluate(e6, t5, n4) {
          let r3 = e6.now || 0, i3 = this.value.possiblyEvaluate(e6, t5, n4), a3 = this.prior;
          if (a3) {
            if (r3 > this.end || this.value.isDataDriven()) return this.prior = null, i3;
            if (r3 < this.begin) return a3.possiblyEvaluate(e6, t5, n4);
            {
              let o3 = (r3 - this.begin) / (this.end - this.begin);
              return this.property.interpolate(a3.possiblyEvaluate(e6, t5, n4), i3, j2(o3));
            }
          }
          return i3;
        }
      }
      class Fa {
        constructor(e6) {
          this._properties = e6, this._values = Object.create(e6.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(e6, t5, n4) {
          let r3 = new Ra(this._properties);
          for (let i3 of Object.keys(this._values)) r3._values[i3] = this._values[i3].possiblyEvaluate(e6, t5, n4);
          return r3;
        }
        hasTransition() {
          for (let e6 of Object.keys(this._values)) if (this._values[e6].prior) return true;
          return false;
        }
      }
      class Ia {
        constructor(e6, t5) {
          this._properties = e6, this._values = Object.create(e6.defaultPropertyValues), this._globalState = t5;
        }
        hasValue(e6) {
          return this._values[e6].value !== void 0;
        }
        getValue(e6) {
          return oe2(this._values[e6].value);
        }
        setValue(e6, t5) {
          this._values[e6] = new ja(this._values[e6].property, t5 === null ? void 0 : oe2(t5), this._globalState);
        }
        serialize() {
          let e6 = {};
          for (let t5 of Object.keys(this._values)) {
            let n4 = this.getValue(t5);
            n4 !== void 0 && (e6[t5] = n4);
          }
          return e6;
        }
        possiblyEvaluate(e6, t5, n4) {
          let r3 = new Ra(this._properties);
          for (let i3 of Object.keys(this._values)) r3._values[i3] = this._values[i3].possiblyEvaluate(e6, t5, n4);
          return r3;
        }
      }
      class La {
        constructor(e6, t5, n4) {
          this.property = e6, this.value = t5, this.parameters = n4;
        }
        isConstant() {
          return this.value.kind === `constant`;
        }
        constantOr(e6) {
          return this.value.kind === `constant` ? this.value.value : e6;
        }
        evaluate(e6, t5, n4, r3) {
          return this.property.evaluate(this.value, this.parameters, e6, t5, n4, r3);
        }
      }
      class Ra {
        constructor(e6) {
          this._properties = e6, this._values = Object.create(e6.defaultPossiblyEvaluatedValues);
        }
        get(e6) {
          return this._values[e6];
        }
      }
      class Q {
        constructor(e6) {
          this.specification = e6;
        }
        possiblyEvaluate(e6, t5) {
          if (e6.isDataDriven()) throw Error(`Value should not be data driven`);
          return e6.expression.evaluate(t5);
        }
        interpolate(e6, t5, n4) {
          let r3 = vn[this.specification.type];
          return r3 ? r3(e6, t5, n4) : e6;
        }
      }
      class $ {
        constructor(e6, t5) {
          this.specification = e6, this.overrides = t5;
        }
        possiblyEvaluate(e6, t5, n4, r3) {
          return new La(this, e6.expression.kind === `constant` || e6.expression.kind === `camera` ? { kind: `constant`, value: e6.expression.evaluate(t5, null, {}, n4, r3) } : e6.expression, t5);
        }
        interpolate(e6, t5, n4) {
          if (e6.value.kind !== `constant` || t5.value.kind !== `constant`) return e6;
          if (e6.value.value === void 0 || t5.value.value === void 0) return new La(this, { kind: `constant`, value: void 0 }, e6.parameters);
          let r3 = vn[this.specification.type];
          if (r3) {
            let i3 = r3(e6.value.value, t5.value.value, n4);
            return new La(this, { kind: `constant`, value: i3 }, e6.parameters);
          }
          return e6;
        }
        evaluate(e6, t5, n4, r3, i3, a3) {
          return e6.kind === `constant` ? e6.value : e6.evaluate(t5, n4, r3, i3, a3);
        }
      }
      class za extends $ {
        possiblyEvaluate(e6, t5, n4, r3) {
          if (e6.value === void 0) return new La(this, { kind: `constant`, value: void 0 }, t5);
          if (e6.expression.kind === `constant`) {
            let i3 = e6.expression.evaluate(t5, null, {}, n4, r3), a3 = e6.property.specification.type === `resolvedImage` && typeof i3 != `string` ? i3.name : i3, o3 = this._calculate(a3, a3, a3, t5);
            return new La(this, { kind: `constant`, value: o3 }, t5);
          }
          if (e6.expression.kind === `camera`) {
            let n5 = this._calculate(e6.expression.evaluate({ zoom: t5.zoom - 1 }), e6.expression.evaluate({ zoom: t5.zoom }), e6.expression.evaluate({ zoom: t5.zoom + 1 }), t5);
            return new La(this, { kind: `constant`, value: n5 }, t5);
          }
          return new La(this, e6.expression, t5);
        }
        evaluate(e6, t5, n4, r3, i3, a3) {
          if (e6.kind === `source`) {
            let o3 = e6.evaluate(t5, n4, r3, i3, a3);
            return this._calculate(o3, o3, o3, t5);
          }
          return e6.kind === `composite` ? this._calculate(e6.evaluate({ zoom: Math.floor(t5.zoom) - 1 }, n4, r3), e6.evaluate({ zoom: Math.floor(t5.zoom) }, n4, r3), e6.evaluate({ zoom: Math.floor(t5.zoom) + 1 }, n4, r3), t5) : e6.value;
        }
        _calculate(e6, t5, n4, r3) {
          return r3.zoom > r3.zoomHistory.lastIntegerZoom ? { from: e6, to: t5 } : { from: n4, to: t5 };
        }
        interpolate(e6) {
          return e6;
        }
      }
      class Ba {
        constructor(e6) {
          this.specification = e6;
        }
        possiblyEvaluate(e6, t5, n4, r3) {
          if (e6.value !== void 0) {
            if (e6.expression.kind === `constant`) {
              let i3 = e6.expression.evaluate(t5, null, {}, n4, r3);
              return this._calculate(i3, i3, i3, t5);
            }
            return this._calculate(e6.expression.evaluate(new ka(Math.floor(t5.zoom - 1), t5)), e6.expression.evaluate(new ka(Math.floor(t5.zoom), t5)), e6.expression.evaluate(new ka(Math.floor(t5.zoom + 1), t5)), t5);
          }
        }
        _calculate(e6, t5, n4, r3) {
          return r3.zoom > r3.zoomHistory.lastIntegerZoom ? { from: e6, to: t5 } : { from: n4, to: t5 };
        }
        interpolate(e6) {
          return e6;
        }
      }
      class Va {
        constructor(e6) {
          this.specification = e6;
        }
        possiblyEvaluate(e6, t5, n4, r3) {
          return !!e6.expression.evaluate(t5, null, {}, n4, r3);
        }
        interpolate() {
          return false;
        }
      }
      class Ha {
        constructor(e6) {
          for (let t5 in this.properties = e6, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [], e6) {
            let n4 = e6[t5];
            n4.specification.overridable && this.overridableProperties.push(t5);
            let r3 = this.defaultPropertyValues[t5] = new ja(n4, void 0, void 0), i3 = this.defaultTransitionablePropertyValues[t5] = new Ma(n4, void 0);
            this.defaultTransitioningPropertyValues[t5] = i3.untransitioned(), this.defaultPossiblyEvaluatedValues[t5] = r3.possiblyEvaluate({});
          }
        }
      }
      X(`DataDrivenProperty`, $), X(`DataConstantProperty`, Q), X(`CrossFadedDataDrivenProperty`, za), X(`CrossFadedProperty`, Ba), X(`ColorRampProperty`, Va);
      let Ua = `-transition`;
      class Wa extends Ne2 {
        constructor(e6, t5, n4) {
          if (super(), this.id = e6.id, this.type = e6.type, this._globalState = n4, this._featureFilter = { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() }, e6.type !== `custom` && (this.metadata = e6.metadata, this.minzoom = e6.minzoom, this.maxzoom = e6.maxzoom, e6.type !== `background` && (this.source = e6.source, this.sourceLayer = e6[`source-layer`], this.filter = e6.filter, this._featureFilter = mi(e6.filter, n4)), t5.layout && (this._unevaluatedLayout = new Ia(t5.layout, n4)), t5.paint)) {
            for (let r3 in this._transitionablePaint = new Na(t5.paint, n4), e6.paint) this.setPaintProperty(r3, e6.paint[r3], { validate: false });
            for (let t6 in e6.layout) this.setLayoutProperty(t6, e6.layout[t6], { validate: false });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Ra(t5.paint);
          }
        }
        setFilter(e6) {
          this.filter = e6, this._featureFilter = mi(e6, this._globalState);
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(e6) {
          return e6 === `visibility` ? this.visibility : this._unevaluatedLayout.getValue(e6);
        }
        getLayoutAffectingGlobalStateRefs() {
          let e6 = /* @__PURE__ */ new Set();
          if (this._unevaluatedLayout) for (let t5 in this._unevaluatedLayout._values) {
            let n4 = this._unevaluatedLayout._values[t5];
            for (let t6 of n4.getGlobalStateRefs()) e6.add(t6);
          }
          for (let t5 of this._featureFilter.getGlobalStateRefs()) e6.add(t5);
          return e6;
        }
        getPaintAffectingGlobalStateRefs() {
          let e6 = new globalThis.Map();
          if (this._transitionablePaint) for (let t5 in this._transitionablePaint._values) {
            let n4 = this._transitionablePaint._values[t5].value;
            for (let r3 of n4.getGlobalStateRefs()) {
              let i3 = e6.get(r3) ?? [];
              i3.push({ name: t5, value: n4.value }), e6.set(r3, i3);
            }
          }
          return e6;
        }
        setLayoutProperty(e6, t5, n4 = {}) {
          t5 != null && this._validate(oa, `layers.${this.id}.layout.${e6}`, e6, t5, n4) || (e6 === `visibility` ? this.visibility = t5 : this._unevaluatedLayout.setValue(e6, t5));
        }
        getPaintProperty(e6) {
          return e6.endsWith(Ua) ? this._transitionablePaint.getTransition(e6.slice(0, -11)) : this._transitionablePaint.getValue(e6);
        }
        setPaintProperty(e6, t5, n4 = {}) {
          if (t5 != null && this._validate(aa, `layers.${this.id}.paint.${e6}`, e6, t5, n4)) return false;
          if (e6.endsWith(Ua)) return this._transitionablePaint.setTransition(e6.slice(0, -11), t5 || void 0), false;
          {
            let n5 = this._transitionablePaint._values[e6], r3 = n5.property.specification[`property-type`] === `cross-faded-data-driven`, i3 = n5.value.isDataDriven(), a3 = n5.value;
            this._transitionablePaint.setValue(e6, t5), this._handleSpecialPaintPropertyUpdate(e6);
            let o3 = this._transitionablePaint._values[e6].value;
            return o3.isDataDriven() || i3 || r3 || this._handleOverridablePaintPropertyUpdate(e6, a3, o3);
          }
        }
        _handleSpecialPaintPropertyUpdate(e6) {
        }
        _handleOverridablePaintPropertyUpdate(e6, t5, n4) {
          return false;
        }
        isHidden(e6, t5 = false) {
          return !!(this.minzoom && e6 < (t5 ? Math.floor(this.minzoom) : this.minzoom)) || !!(this.maxzoom && e6 >= this.maxzoom) || this.visibility === `none`;
        }
        updateTransitions(e6) {
          this._transitioningPaint = this._transitionablePaint.transitioned(e6, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(e6, t5) {
          e6.getCrossfadeParameters && (this._crossfadeParameters = e6.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e6, void 0, t5)), this.paint = this._transitioningPaint.possiblyEvaluate(e6, void 0, t5);
        }
        serialize() {
          let e6 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (e6.layout = e6.layout || {}, e6.layout.visibility = this.visibility), ae2(e6, ((e7, t5) => !(e7 === void 0 || t5 === `layout` && !Object.keys(e7).length || t5 === `paint` && !Object.keys(e7).length)));
        }
        _validate(e6, t5, n4, r3, i3 = {}) {
          return (!i3 || false !== i3.validate) && sa(this, e6.call(na, { key: t5, layerType: this.type, objectKey: n4, value: r3, styleSpec: R2, style: { glyphs: true, sprite: true } }));
        }
        is3D() {
          return false;
        }
        isTileClipped() {
          return false;
        }
        hasOffscreenPass() {
          return false;
        }
        resize() {
        }
        isStateDependent() {
          for (let e6 in this.paint._values) {
            let t5 = this.paint.get(e6);
            if (t5 instanceof La && Gr(t5.property.specification) && (t5.value.kind === `source` || t5.value.kind === `composite`) && t5.value.isStateDependent) return true;
          }
          return false;
        }
      }
      let Ga;
      var Ka = { get paint() {
        return Ga || (Ga = new Ha({ "raster-opacity": new Q(R2.paint_raster[`raster-opacity`]), "raster-hue-rotate": new Q(R2.paint_raster[`raster-hue-rotate`]), "raster-brightness-min": new Q(R2.paint_raster[`raster-brightness-min`]), "raster-brightness-max": new Q(R2.paint_raster[`raster-brightness-max`]), "raster-saturation": new Q(R2.paint_raster[`raster-saturation`]), "raster-contrast": new Q(R2.paint_raster[`raster-contrast`]), "raster-resampling": new Q(R2.paint_raster[`raster-resampling`]), "raster-fade-duration": new Q(R2.paint_raster[`raster-fade-duration`]) }));
      } };
      class qa extends Wa {
        constructor(e6, t5) {
          super(e6, Ka, t5);
        }
      }
      let Ja = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class Ya {
        constructor(e6, t5) {
          this._structArray = e6, this._pos1 = t5 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class Xa {
        constructor() {
          this.isTransferred = false, this.capacity = -1, this.resize(0);
        }
        static serialize(e6, t5) {
          return e6._trim(), t5 && (e6.isTransferred = true, t5.push(e6.arrayBuffer)), { length: e6.length, arrayBuffer: e6.arrayBuffer };
        }
        static deserialize(e6) {
          let t5 = Object.create(this.prototype);
          return t5.arrayBuffer = e6.arrayBuffer, t5.length = e6.length, t5.capacity = e6.arrayBuffer.byteLength / t5.bytesPerElement, t5._refreshViews(), t5;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(e6) {
          this.reserve(e6), this.length = e6;
        }
        reserve(e6) {
          if (e6 > this.capacity) {
            this.capacity = Math.max(e6, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            let t5 = this.uint8;
            this._refreshViews(), t5 && this.uint8.set(t5);
          }
        }
        _refreshViews() {
          throw Error(`_refreshViews() must be implemented by each concrete StructArray layout`);
        }
      }
      function Za(e6, t5 = 1) {
        let n4 = 0, r3 = 0;
        return { members: e6.map(((e7) => {
          let i3 = Ja[e7.type].BYTES_PER_ELEMENT, a3 = n4 = Qa(n4, Math.max(t5, i3)), o3 = e7.components || 1;
          return r3 = Math.max(r3, i3), n4 += i3 * o3, { name: e7.name, type: e7.type, components: o3, offset: a3 };
        })), size: Qa(n4, Math.max(r3, t5)), alignment: t5 };
      }
      function Qa(e6, t5) {
        return Math.ceil(e6 / t5) * t5;
      }
      class $a extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5) {
          let n4 = this.length;
          return this.resize(n4 + 1), this.emplace(n4, e6, t5);
        }
        emplace(e6, t5, n4) {
          let r3 = 2 * e6;
          return this.int16[r3 + 0] = t5, this.int16[r3 + 1] = n4, e6;
        }
      }
      $a.prototype.bytesPerElement = 4, X(`StructArrayLayout2i4`, $a);
      class eo extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5, n4) {
          let r3 = this.length;
          return this.resize(r3 + 1), this.emplace(r3, e6, t5, n4);
        }
        emplace(e6, t5, n4, r3) {
          let i3 = 3 * e6;
          return this.int16[i3 + 0] = t5, this.int16[i3 + 1] = n4, this.int16[i3 + 2] = r3, e6;
        }
      }
      eo.prototype.bytesPerElement = 6, X(`StructArrayLayout3i6`, eo);
      class to extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5, n4, r3) {
          let i3 = this.length;
          return this.resize(i3 + 1), this.emplace(i3, e6, t5, n4, r3);
        }
        emplace(e6, t5, n4, r3, i3) {
          let a3 = 4 * e6;
          return this.int16[a3 + 0] = t5, this.int16[a3 + 1] = n4, this.int16[a3 + 2] = r3, this.int16[a3 + 3] = i3, e6;
        }
      }
      to.prototype.bytesPerElement = 8, X(`StructArrayLayout4i8`, to);
      class no extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5, n4, r3, i3, a3) {
          let o3 = this.length;
          return this.resize(o3 + 1), this.emplace(o3, e6, t5, n4, r3, i3, a3);
        }
        emplace(e6, t5, n4, r3, i3, a3, o3) {
          let s3 = 6 * e6;
          return this.int16[s3 + 0] = t5, this.int16[s3 + 1] = n4, this.int16[s3 + 2] = r3, this.int16[s3 + 3] = i3, this.int16[s3 + 4] = a3, this.int16[s3 + 5] = o3, e6;
        }
      }
      no.prototype.bytesPerElement = 12, X(`StructArrayLayout2i4i12`, no);
      class ro extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5, n4, r3, i3, a3) {
          let o3 = this.length;
          return this.resize(o3 + 1), this.emplace(o3, e6, t5, n4, r3, i3, a3);
        }
        emplace(e6, t5, n4, r3, i3, a3, o3) {
          let s3 = 4 * e6, c3 = 8 * e6;
          return this.int16[s3 + 0] = t5, this.int16[s3 + 1] = n4, this.uint8[c3 + 4] = r3, this.uint8[c3 + 5] = i3, this.uint8[c3 + 6] = a3, this.uint8[c3 + 7] = o3, e6;
        }
      }
      ro.prototype.bytesPerElement = 8, X(`StructArrayLayout2i4ub8`, ro);
      class io extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5) {
          let n4 = this.length;
          return this.resize(n4 + 1), this.emplace(n4, e6, t5);
        }
        emplace(e6, t5, n4) {
          let r3 = 2 * e6;
          return this.float32[r3 + 0] = t5, this.float32[r3 + 1] = n4, e6;
        }
      }
      io.prototype.bytesPerElement = 8, X(`StructArrayLayout2f8`, io);
      class ao extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5, n4, r3, i3, a3, o3, s3, c3, l3) {
          let u3 = this.length;
          return this.resize(u3 + 1), this.emplace(u3, e6, t5, n4, r3, i3, a3, o3, s3, c3, l3);
        }
        emplace(e6, t5, n4, r3, i3, a3, o3, s3, c3, l3, u3) {
          let d3 = 10 * e6;
          return this.uint16[d3 + 0] = t5, this.uint16[d3 + 1] = n4, this.uint16[d3 + 2] = r3, this.uint16[d3 + 3] = i3, this.uint16[d3 + 4] = a3, this.uint16[d3 + 5] = o3, this.uint16[d3 + 6] = s3, this.uint16[d3 + 7] = c3, this.uint16[d3 + 8] = l3, this.uint16[d3 + 9] = u3, e6;
        }
      }
      ao.prototype.bytesPerElement = 20, X(`StructArrayLayout10ui20`, ao);
      class oo extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5, n4, r3, i3, a3, o3, s3) {
          let c3 = this.length;
          return this.resize(c3 + 1), this.emplace(c3, e6, t5, n4, r3, i3, a3, o3, s3);
        }
        emplace(e6, t5, n4, r3, i3, a3, o3, s3, c3) {
          let l3 = 8 * e6;
          return this.uint16[l3 + 0] = t5, this.uint16[l3 + 1] = n4, this.uint16[l3 + 2] = r3, this.uint16[l3 + 3] = i3, this.uint16[l3 + 4] = a3, this.uint16[l3 + 5] = o3, this.uint16[l3 + 6] = s3, this.uint16[l3 + 7] = c3, e6;
        }
      }
      oo.prototype.bytesPerElement = 16, X(`StructArrayLayout8ui16`, oo);
      class so extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3) {
          let f3 = this.length;
          return this.resize(f3 + 1), this.emplace(f3, e6, t5, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3);
        }
        emplace(e6, t5, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3) {
          let p3 = 12 * e6;
          return this.int16[p3 + 0] = t5, this.int16[p3 + 1] = n4, this.int16[p3 + 2] = r3, this.int16[p3 + 3] = i3, this.uint16[p3 + 4] = a3, this.uint16[p3 + 5] = o3, this.uint16[p3 + 6] = s3, this.uint16[p3 + 7] = c3, this.int16[p3 + 8] = l3, this.int16[p3 + 9] = u3, this.int16[p3 + 10] = d3, this.int16[p3 + 11] = f3, e6;
        }
      }
      so.prototype.bytesPerElement = 24, X(`StructArrayLayout4i4ui4i24`, so);
      class co extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5, n4) {
          let r3 = this.length;
          return this.resize(r3 + 1), this.emplace(r3, e6, t5, n4);
        }
        emplace(e6, t5, n4, r3) {
          let i3 = 3 * e6;
          return this.float32[i3 + 0] = t5, this.float32[i3 + 1] = n4, this.float32[i3 + 2] = r3, e6;
        }
      }
      co.prototype.bytesPerElement = 12, X(`StructArrayLayout3f12`, co);
      class lo extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(e6) {
          let t5 = this.length;
          return this.resize(t5 + 1), this.emplace(t5, e6);
        }
        emplace(e6, t5) {
          return this.uint32[1 * e6 + 0] = t5, e6;
        }
      }
      lo.prototype.bytesPerElement = 4, X(`StructArrayLayout1ul4`, lo);
      class uo extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5, n4, r3, i3, a3, o3, s3, c3) {
          let l3 = this.length;
          return this.resize(l3 + 1), this.emplace(l3, e6, t5, n4, r3, i3, a3, o3, s3, c3);
        }
        emplace(e6, t5, n4, r3, i3, a3, o3, s3, c3, l3) {
          let u3 = 10 * e6, d3 = 5 * e6;
          return this.int16[u3 + 0] = t5, this.int16[u3 + 1] = n4, this.int16[u3 + 2] = r3, this.int16[u3 + 3] = i3, this.int16[u3 + 4] = a3, this.int16[u3 + 5] = o3, this.uint32[d3 + 3] = s3, this.uint16[u3 + 8] = c3, this.uint16[u3 + 9] = l3, e6;
        }
      }
      uo.prototype.bytesPerElement = 20, X(`StructArrayLayout6i1ul2ui20`, uo);
      class fo extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5, n4, r3, i3, a3) {
          let o3 = this.length;
          return this.resize(o3 + 1), this.emplace(o3, e6, t5, n4, r3, i3, a3);
        }
        emplace(e6, t5, n4, r3, i3, a3, o3) {
          let s3 = 6 * e6;
          return this.int16[s3 + 0] = t5, this.int16[s3 + 1] = n4, this.int16[s3 + 2] = r3, this.int16[s3 + 3] = i3, this.int16[s3 + 4] = a3, this.int16[s3 + 5] = o3, e6;
        }
      }
      fo.prototype.bytesPerElement = 12, X(`StructArrayLayout2i2i2i12`, fo);
      class po extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5, n4, r3, i3) {
          let a3 = this.length;
          return this.resize(a3 + 1), this.emplace(a3, e6, t5, n4, r3, i3);
        }
        emplace(e6, t5, n4, r3, i3, a3) {
          let o3 = 4 * e6, s3 = 8 * e6;
          return this.float32[o3 + 0] = t5, this.float32[o3 + 1] = n4, this.float32[o3 + 2] = r3, this.int16[s3 + 6] = i3, this.int16[s3 + 7] = a3, e6;
        }
      }
      po.prototype.bytesPerElement = 16, X(`StructArrayLayout2f1f2i16`, po);
      class mo extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5, n4, r3, i3, a3) {
          let o3 = this.length;
          return this.resize(o3 + 1), this.emplace(o3, e6, t5, n4, r3, i3, a3);
        }
        emplace(e6, t5, n4, r3, i3, a3, o3) {
          let s3 = 16 * e6, c3 = 4 * e6, l3 = 8 * e6;
          return this.uint8[s3 + 0] = t5, this.uint8[s3 + 1] = n4, this.float32[c3 + 1] = r3, this.float32[c3 + 2] = i3, this.int16[l3 + 6] = a3, this.int16[l3 + 7] = o3, e6;
        }
      }
      mo.prototype.bytesPerElement = 16, X(`StructArrayLayout2ub2f2i16`, mo);
      class ho extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5, n4) {
          let r3 = this.length;
          return this.resize(r3 + 1), this.emplace(r3, e6, t5, n4);
        }
        emplace(e6, t5, n4, r3) {
          let i3 = 3 * e6;
          return this.uint16[i3 + 0] = t5, this.uint16[i3 + 1] = n4, this.uint16[i3 + 2] = r3, e6;
        }
      }
      ho.prototype.bytesPerElement = 6, X(`StructArrayLayout3ui6`, ho);
      class go extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3, p3, m3, h3, g3) {
          let _3 = this.length;
          return this.resize(_3 + 1), this.emplace(_3, e6, t5, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3, p3, m3, h3, g3);
        }
        emplace(e6, t5, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3, p3, m3, h3, g3, _3) {
          let v3 = 24 * e6, y3 = 12 * e6, b3 = 48 * e6;
          return this.int16[v3 + 0] = t5, this.int16[v3 + 1] = n4, this.uint16[v3 + 2] = r3, this.uint16[v3 + 3] = i3, this.uint32[y3 + 2] = a3, this.uint32[y3 + 3] = o3, this.uint32[y3 + 4] = s3, this.uint16[v3 + 10] = c3, this.uint16[v3 + 11] = l3, this.uint16[v3 + 12] = u3, this.float32[y3 + 7] = d3, this.float32[y3 + 8] = f3, this.uint8[b3 + 36] = p3, this.uint8[b3 + 37] = m3, this.uint8[b3 + 38] = h3, this.uint32[y3 + 10] = g3, this.int16[v3 + 22] = _3, e6;
        }
      }
      go.prototype.bytesPerElement = 48, X(`StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48`, go);
      class _o extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3, p3, m3, h3, g3, _3, v3, y3, b3, x3, S3, C3, w3, T3, E3, D3) {
          let O3 = this.length;
          return this.resize(O3 + 1), this.emplace(O3, e6, t5, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3, p3, m3, h3, g3, _3, v3, y3, b3, x3, S3, C3, w3, T3, E3, D3);
        }
        emplace(e6, t5, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3, p3, m3, h3, g3, _3, v3, y3, b3, x3, S3, C3, w3, T3, E3, D3, O3) {
          let k3 = 32 * e6, A3 = 16 * e6;
          return this.int16[k3 + 0] = t5, this.int16[k3 + 1] = n4, this.int16[k3 + 2] = r3, this.int16[k3 + 3] = i3, this.int16[k3 + 4] = a3, this.int16[k3 + 5] = o3, this.int16[k3 + 6] = s3, this.int16[k3 + 7] = c3, this.uint16[k3 + 8] = l3, this.uint16[k3 + 9] = u3, this.uint16[k3 + 10] = d3, this.uint16[k3 + 11] = f3, this.uint16[k3 + 12] = p3, this.uint16[k3 + 13] = m3, this.uint16[k3 + 14] = h3, this.uint16[k3 + 15] = g3, this.uint16[k3 + 16] = _3, this.uint16[k3 + 17] = v3, this.uint16[k3 + 18] = y3, this.uint16[k3 + 19] = b3, this.uint16[k3 + 20] = x3, this.uint16[k3 + 21] = S3, this.uint16[k3 + 22] = C3, this.uint32[A3 + 12] = w3, this.float32[A3 + 13] = T3, this.float32[A3 + 14] = E3, this.uint16[k3 + 30] = D3, this.uint16[k3 + 31] = O3, e6;
        }
      }
      _o.prototype.bytesPerElement = 64, X(`StructArrayLayout8i15ui1ul2f2ui64`, _o);
      class vo extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e6) {
          let t5 = this.length;
          return this.resize(t5 + 1), this.emplace(t5, e6);
        }
        emplace(e6, t5) {
          return this.float32[1 * e6 + 0] = t5, e6;
        }
      }
      vo.prototype.bytesPerElement = 4, X(`StructArrayLayout1f4`, vo);
      class yo extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5, n4) {
          let r3 = this.length;
          return this.resize(r3 + 1), this.emplace(r3, e6, t5, n4);
        }
        emplace(e6, t5, n4, r3) {
          let i3 = 3 * e6;
          return this.uint16[6 * e6 + 0] = t5, this.float32[i3 + 1] = n4, this.float32[i3 + 2] = r3, e6;
        }
      }
      yo.prototype.bytesPerElement = 12, X(`StructArrayLayout1ui2f12`, yo);
      class bo extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5, n4) {
          let r3 = this.length;
          return this.resize(r3 + 1), this.emplace(r3, e6, t5, n4);
        }
        emplace(e6, t5, n4, r3) {
          let i3 = 4 * e6;
          return this.uint32[2 * e6 + 0] = t5, this.uint16[i3 + 2] = n4, this.uint16[i3 + 3] = r3, e6;
        }
      }
      bo.prototype.bytesPerElement = 8, X(`StructArrayLayout1ul2ui8`, bo);
      class xo extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5) {
          let n4 = this.length;
          return this.resize(n4 + 1), this.emplace(n4, e6, t5);
        }
        emplace(e6, t5, n4) {
          let r3 = 2 * e6;
          return this.uint16[r3 + 0] = t5, this.uint16[r3 + 1] = n4, e6;
        }
      }
      xo.prototype.bytesPerElement = 4, X(`StructArrayLayout2ui4`, xo);
      class So extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e6) {
          let t5 = this.length;
          return this.resize(t5 + 1), this.emplace(t5, e6);
        }
        emplace(e6, t5) {
          return this.uint16[1 * e6 + 0] = t5, e6;
        }
      }
      So.prototype.bytesPerElement = 2, X(`StructArrayLayout1ui2`, So);
      class Co extends Xa {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e6, t5, n4, r3) {
          let i3 = this.length;
          return this.resize(i3 + 1), this.emplace(i3, e6, t5, n4, r3);
        }
        emplace(e6, t5, n4, r3, i3) {
          let a3 = 4 * e6;
          return this.float32[a3 + 0] = t5, this.float32[a3 + 1] = n4, this.float32[a3 + 2] = r3, this.float32[a3 + 3] = i3, e6;
        }
      }
      Co.prototype.bytesPerElement = 16, X(`StructArrayLayout4f16`, Co);
      class wo extends Ya {
        get anchorPointX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorPointY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get x1() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get y1() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get x2() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get y2() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get anchorPoint() {
          return new n3(this.anchorPointX, this.anchorPointY);
        }
      }
      wo.prototype.size = 20;
      class To extends uo {
        get(e6) {
          return new wo(this, e6);
        }
      }
      X(`CollisionBoxArray`, To);
      class Eo extends Ya {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 2];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 4];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 7];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 8];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 36];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 37];
        }
        set placedOrientation(e6) {
          this._structArray.uint8[this._pos1 + 37] = e6;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 38];
        }
        set hidden(e6) {
          this._structArray.uint8[this._pos1 + 38] = e6;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 10];
        }
        set crossTileID(e6) {
          this._structArray.uint32[this._pos4 + 10] = e6;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 22];
        }
      }
      Eo.prototype.size = 48;
      class Do extends go {
        get(e6) {
          return new Eo(this, e6);
        }
      }
      X(`PlacedSymbolArray`, Do);
      class Oo extends Ya {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 12];
        }
        set crossTileID(e6) {
          this._structArray.uint32[this._pos4 + 12] = e6;
        }
        get textBoxScale() {
          return this._structArray.float32[this._pos4 + 13];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 14];
        }
        get textAnchorOffsetStartIndex() {
          return this._structArray.uint16[this._pos2 + 30];
        }
        get textAnchorOffsetEndIndex() {
          return this._structArray.uint16[this._pos2 + 31];
        }
      }
      Oo.prototype.size = 64;
      class ko extends _o {
        get(e6) {
          return new Oo(this, e6);
        }
      }
      X(`SymbolInstanceArray`, ko);
      class Ao extends vo {
        getoffsetX(e6) {
          return this.float32[1 * e6 + 0];
        }
      }
      X(`GlyphOffsetArray`, Ao);
      class jo extends eo {
        getx(e6) {
          return this.int16[3 * e6 + 0];
        }
        gety(e6) {
          return this.int16[3 * e6 + 1];
        }
        gettileUnitDistanceFromAnchor(e6) {
          return this.int16[3 * e6 + 2];
        }
      }
      X(`SymbolLineVertexArray`, jo);
      class Mo extends Ya {
        get textAnchor() {
          return this._structArray.uint16[this._pos2 + 0];
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 2];
        }
      }
      Mo.prototype.size = 12;
      class No extends yo {
        get(e6) {
          return new Mo(this, e6);
        }
      }
      X(`TextAnchorOffsetArray`, No);
      class Po extends Ya {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
      }
      Po.prototype.size = 8;
      class Fo extends bo {
        get(e6) {
          return new Po(this, e6);
        }
      }
      X(`FeatureIndexArray`, Fo);
      class Io extends $a {
      }
      class Lo extends $a {
      }
      class Ro extends $a {
      }
      class zo extends no {
      }
      class Bo extends ro {
      }
      class Vo extends io {
      }
      class Ho extends ao {
      }
      class Uo extends oo {
      }
      class Wo extends so {
      }
      class Go extends co {
      }
      class Ko extends lo {
      }
      class qo extends fo {
      }
      class Jo extends mo {
      }
      class Yo extends ho {
      }
      class Xo extends xo {
      }
      let { members: Zo } = Za([{ name: `a_pos`, components: 2, type: `Int16` }], 4);
      class Qo {
        constructor(e6 = []) {
          this._forceNewSegmentOnNextPrepare = false, this.segments = e6;
        }
        prepareSegment(e6, t5, n4, r3) {
          let i3 = this.segments[this.segments.length - 1];
          return e6 > Qo.MAX_VERTEX_ARRAY_LENGTH && F2(`Max vertices per segment is ${Qo.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e6}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Qo.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !i3 || i3.vertexLength + e6 > Qo.MAX_VERTEX_ARRAY_LENGTH || i3.sortKey !== r3 ? this.createNewSegment(t5, n4, r3) : i3;
        }
        createNewSegment(e6, t5, n4) {
          let r3 = { vertexOffset: e6.length, primitiveOffset: t5.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
          return n4 !== void 0 && (r3.sortKey = n4), this._forceNewSegmentOnNextPrepare = false, this.segments.push(r3), r3;
        }
        getOrCreateLatestSegment(e6, t5, n4) {
          return this.prepareSegment(0, e6, t5, n4);
        }
        forceNewSegmentOnNextPrepare() {
          this._forceNewSegmentOnNextPrepare = true;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (let e6 of this.segments) for (let t5 in e6.vaos) e6.vaos[t5].destroy();
        }
        static simpleSegment(e6, t5, n4, r3) {
          return new Qo([{ vertexOffset: e6, primitiveOffset: t5, vertexLength: n4, primitiveLength: r3, vaos: {}, sortKey: 0 }]);
        }
      }
      function $o(e6, t5) {
        return 256 * (e6 = N2(Math.floor(e6), 0, 255)) + N2(Math.floor(t5), 0, 255);
      }
      Qo.MAX_VERTEX_ARRAY_LENGTH = 2 ** 16 - 1, X(`SegmentVector`, Qo);
      let es = Za([{ name: `a_pattern_from`, components: 4, type: `Uint16` }, { name: `a_pattern_to`, components: 4, type: `Uint16` }, { name: `a_pixel_ratio_from`, components: 1, type: `Uint16` }, { name: `a_pixel_ratio_to`, components: 1, type: `Uint16` }]), ts = Za([{ name: `a_dasharray_from`, components: 4, type: `Uint16` }, { name: `a_dasharray_to`, components: 4, type: `Uint16` }]);
      var ns, rs, is, as = { exports: {} }, os = { exports: {} }, ss = { exports: {} }, cs = r2((function() {
        if (is) return as.exports;
        is = 1;
        var e6 = (ns || (ns = 1, os.exports = function(e7, t6) {
          var n4, r3, i3, a3, o3, s3, c3, l3;
          for (r3 = e7.length - (n4 = 3 & e7.length), i3 = t6, o3 = 3432918353, s3 = 461845907, l3 = 0; l3 < r3; ) c3 = 255 & e7.charCodeAt(l3) | (255 & e7.charCodeAt(++l3)) << 8 | (255 & e7.charCodeAt(++l3)) << 16 | (255 & e7.charCodeAt(++l3)) << 24, ++l3, i3 = 27492 + (65535 & (a3 = 5 * (65535 & (i3 = (i3 ^= c3 = (65535 & (c3 = (c3 = (65535 & c3) * o3 + (((c3 >>> 16) * o3 & 65535) << 16) & 4294967295) << 15 | c3 >>> 17)) * s3 + (((c3 >>> 16) * s3 & 65535) << 16) & 4294967295) << 13 | i3 >>> 19)) + ((5 * (i3 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (a3 >>> 16) & 65535) << 16);
          switch (c3 = 0, n4) {
            case 3:
              c3 ^= (255 & e7.charCodeAt(l3 + 2)) << 16;
            case 2:
              c3 ^= (255 & e7.charCodeAt(l3 + 1)) << 8;
            case 1:
              i3 ^= c3 = (65535 & (c3 = (c3 = (65535 & (c3 ^= 255 & e7.charCodeAt(l3))) * o3 + (((c3 >>> 16) * o3 & 65535) << 16) & 4294967295) << 15 | c3 >>> 17)) * s3 + (((c3 >>> 16) * s3 & 65535) << 16) & 4294967295;
          }
          return i3 ^= e7.length, i3 = 2246822507 * (65535 & (i3 ^= i3 >>> 16)) + ((2246822507 * (i3 >>> 16) & 65535) << 16) & 4294967295, i3 = 3266489909 * (65535 & (i3 ^= i3 >>> 13)) + ((3266489909 * (i3 >>> 16) & 65535) << 16) & 4294967295, (i3 ^= i3 >>> 16) >>> 0;
        }), os.exports), t5 = (rs || (rs = 1, ss.exports = function(e7, t6) {
          for (var n4, r3 = e7.length, i3 = t6 ^ r3, a3 = 0; r3 >= 4; ) n4 = 1540483477 * (65535 & (n4 = 255 & e7.charCodeAt(a3) | (255 & e7.charCodeAt(++a3)) << 8 | (255 & e7.charCodeAt(++a3)) << 16 | (255 & e7.charCodeAt(++a3)) << 24)) + ((1540483477 * (n4 >>> 16) & 65535) << 16), i3 = 1540483477 * (65535 & i3) + ((1540483477 * (i3 >>> 16) & 65535) << 16) ^ (n4 = 1540483477 * (65535 & (n4 ^= n4 >>> 24)) + ((1540483477 * (n4 >>> 16) & 65535) << 16)), r3 -= 4, ++a3;
          switch (r3) {
            case 3:
              i3 ^= (255 & e7.charCodeAt(a3 + 2)) << 16;
            case 2:
              i3 ^= (255 & e7.charCodeAt(a3 + 1)) << 8;
            case 1:
              i3 = 1540483477 * (65535 & (i3 ^= 255 & e7.charCodeAt(a3))) + ((1540483477 * (i3 >>> 16) & 65535) << 16);
          }
          return i3 = 1540483477 * (65535 & (i3 ^= i3 >>> 13)) + ((1540483477 * (i3 >>> 16) & 65535) << 16), (i3 ^= i3 >>> 15) >>> 0;
        }), ss.exports);
        return as.exports = e6, as.exports.murmur3 = e6, as.exports.murmur2 = t5, as.exports;
      })());
      class ls {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = false;
        }
        add(e6, t5, n4, r3) {
          this.ids.push(us(e6)), this.positions.push(t5, n4, r3);
        }
        getPositions(e6) {
          if (!this.indexed) throw Error(`Trying to get index, but feature positions are not indexed`);
          let t5 = us(e6), n4 = 0, r3 = this.ids.length - 1;
          for (; n4 < r3; ) {
            let e7 = n4 + r3 >> 1;
            this.ids[e7] >= t5 ? r3 = e7 : n4 = e7 + 1;
          }
          let i3 = [];
          for (; this.ids[n4] === t5; ) i3.push({ index: this.positions[3 * n4], start: this.positions[3 * n4 + 1], end: this.positions[3 * n4 + 2] }), n4++;
          return i3;
        }
        static serialize(e6, t5) {
          let n4 = new Float64Array(e6.ids), r3 = new Uint32Array(e6.positions);
          return ds(n4, r3, 0, n4.length - 1), t5 && t5.push(n4.buffer, r3.buffer), { ids: n4, positions: r3 };
        }
        static deserialize(e6) {
          let t5 = new ls();
          return t5.ids = e6.ids, t5.positions = e6.positions, t5.indexed = true, t5;
        }
      }
      function us(e6) {
        let t5 = +e6;
        return !isNaN(t5) && t5 <= 2 ** 53 - 1 ? t5 : cs(String(e6));
      }
      function ds(e6, t5, n4, r3) {
        for (; n4 < r3; ) {
          let i3 = e6[n4 + r3 >> 1], a3 = n4 - 1, o3 = r3 + 1;
          for (; ; ) {
            do
              a3++;
            while (e6[a3] < i3);
            do
              o3--;
            while (e6[o3] > i3);
            if (a3 >= o3) break;
            fs(e6, a3, o3), fs(t5, 3 * a3, 3 * o3), fs(t5, 3 * a3 + 1, 3 * o3 + 1), fs(t5, 3 * a3 + 2, 3 * o3 + 2);
          }
          o3 - n4 < r3 - o3 ? (ds(e6, t5, n4, o3), n4 = o3 + 1) : (ds(e6, t5, o3 + 1, r3), r3 = o3);
        }
      }
      function fs(e6, t5, n4) {
        let r3 = e6[t5];
        e6[t5] = e6[n4], e6[n4] = r3;
      }
      X(`FeaturePositionMap`, ls);
      class ps {
        constructor(e6, t5) {
          this.gl = e6.gl, this.location = t5;
        }
      }
      class ms extends ps {
        constructor(e6, t5) {
          super(e6, t5), this.current = 0;
        }
        set(e6) {
          this.current !== e6 && (this.current = e6, this.gl.uniform1f(this.location, e6));
        }
      }
      class hs extends ps {
        constructor(e6, t5) {
          super(e6, t5), this.current = [0, 0, 0, 0];
        }
        set(e6) {
          e6[0] === this.current[0] && e6[1] === this.current[1] && e6[2] === this.current[2] && e6[3] === this.current[3] || (this.current = e6, this.gl.uniform4f(this.location, e6[0], e6[1], e6[2], e6[3]));
        }
      }
      class gs extends ps {
        constructor(e6, t5) {
          super(e6, t5), this.current = K2.transparent;
        }
        set(e6) {
          e6.r === this.current.r && e6.g === this.current.g && e6.b === this.current.b && e6.a === this.current.a || (this.current = e6, this.gl.uniform4f(this.location, e6.r, e6.g, e6.b, e6.a));
        }
      }
      let _s = new Float32Array(16);
      function vs(e6) {
        return [$o(255 * e6.r, 255 * e6.g), $o(255 * e6.b, 255 * e6.a)];
      }
      class ys {
        constructor(e6, t5, n4) {
          this.value = e6, this.uniformNames = t5.map(((e7) => `u_${e7}`)), this.type = n4;
        }
        setUniform(e6, t5, n4) {
          e6.set(n4.constantOr(this.value));
        }
        getBinding(e6, t5, n4) {
          return this.type === `color` ? new gs(e6, t5) : new ms(e6, t5);
        }
      }
      class bs {
        constructor(e6, t5) {
          this.uniformNames = t5.map(((e7) => `u_${e7}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
        }
        setConstantPatternPositions(e6, t5) {
          this.pixelRatioFrom = t5.pixelRatio, this.pixelRatioTo = e6.pixelRatio, this.patternFrom = t5.tlbr, this.patternTo = e6.tlbr;
        }
        setConstantDashPositions(e6, t5) {
          this.dashTo = [0, e6.y, e6.height, e6.width], this.dashFrom = [0, t5.y, t5.height, t5.width];
        }
        setUniform(e6, t5, n4, r3) {
          let i3 = null;
          r3 === `u_pattern_to` ? i3 = this.patternTo : r3 === `u_pattern_from` ? i3 = this.patternFrom : r3 === `u_dasharray_to` ? i3 = this.dashTo : r3 === `u_dasharray_from` ? i3 = this.dashFrom : r3 === `u_pixel_ratio_to` ? i3 = this.pixelRatioTo : r3 === `u_pixel_ratio_from` && (i3 = this.pixelRatioFrom), i3 !== null && e6.set(i3);
        }
        getBinding(e6, t5, n4) {
          return n4.substr(0, 9) === `u_pattern` || n4.substr(0, 12) === `u_dasharray_` ? new hs(e6, t5) : new ms(e6, t5);
        }
      }
      class xs {
        constructor(e6, t5, n4, r3) {
          this.expression = e6, this.type = n4, this.maxValue = 0, this.paintVertexAttributes = t5.map(((e7) => ({ name: `a_${e7}`, type: `Float32`, components: n4 === `color` ? 2 : 1, offset: 0 }))), this.paintVertexArray = new r3();
        }
        populatePaintArray(e6, t5, n4) {
          let r3 = this.paintVertexArray.length, i3 = this.expression.evaluate(new ka(0, n4), t5, {}, n4.canonical, [], n4.formattedSection);
          this.paintVertexArray.resize(e6), this._setPaintValue(r3, e6, i3);
        }
        updatePaintArray(e6, t5, n4, r3, i3) {
          let a3 = this.expression.evaluate(new ka(0, i3), n4, r3);
          this._setPaintValue(e6, t5, a3);
        }
        _setPaintValue(e6, t5, n4) {
          if (this.type === `color`) {
            let r3 = vs(n4);
            for (let n5 = e6; n5 < t5; n5++) this.paintVertexArray.emplace(n5, r3[0], r3[1]);
          } else {
            for (let r3 = e6; r3 < t5; r3++) this.paintVertexArray.emplace(r3, n4);
            this.maxValue = Math.max(this.maxValue, Math.abs(n4));
          }
        }
        upload(e6) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e6.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class Ss {
        constructor(e6, t5, n4, r3, i3, a3) {
          this.expression = e6, this.uniformNames = t5.map(((e7) => `u_${e7}_t`)), this.type = n4, this.useIntegerZoom = r3, this.zoom = i3, this.maxValue = 0, this.paintVertexAttributes = t5.map(((e7) => ({ name: `a_${e7}`, type: `Float32`, components: n4 === `color` ? 4 : 2, offset: 0 }))), this.paintVertexArray = new a3();
        }
        populatePaintArray(e6, t5, n4) {
          let r3 = this.expression.evaluate(new ka(this.zoom, n4), t5, {}, n4.canonical, [], n4.formattedSection), i3 = this.expression.evaluate(new ka(this.zoom + 1, n4), t5, {}, n4.canonical, [], n4.formattedSection), a3 = this.paintVertexArray.length;
          this.paintVertexArray.resize(e6), this._setPaintValue(a3, e6, r3, i3);
        }
        updatePaintArray(e6, t5, n4, r3, i3) {
          let a3 = this.expression.evaluate(new ka(this.zoom, i3), n4, r3), o3 = this.expression.evaluate(new ka(this.zoom + 1, i3), n4, r3);
          this._setPaintValue(e6, t5, a3, o3);
        }
        _setPaintValue(e6, t5, n4, r3) {
          if (this.type === `color`) {
            let i3 = vs(n4), a3 = vs(r3);
            for (let n5 = e6; n5 < t5; n5++) this.paintVertexArray.emplace(n5, i3[0], i3[1], a3[0], a3[1]);
          } else {
            for (let i3 = e6; i3 < t5; i3++) this.paintVertexArray.emplace(i3, n4, r3);
            this.maxValue = Math.max(this.maxValue, Math.abs(n4), Math.abs(r3));
          }
        }
        upload(e6) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e6.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(e6, t5) {
          let n4 = this.useIntegerZoom ? Math.floor(t5.zoom) : t5.zoom, r3 = N2(this.expression.interpolationFactor(n4, this.zoom, this.zoom + 1), 0, 1);
          e6.set(r3);
        }
        getBinding(e6, t5, n4) {
          return new ms(e6, t5);
        }
      }
      class Cs {
        constructor(e6, t5, n4, r3, i3, a3) {
          this.expression = e6, this.type = t5, this.useIntegerZoom = n4, this.zoom = r3, this.layerId = a3, this.zoomInPaintVertexArray = new i3(), this.zoomOutPaintVertexArray = new i3();
        }
        populatePaintArray(e6, t5, n4) {
          let r3 = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(e6), this.zoomOutPaintVertexArray.resize(e6), this._setPaintValues(r3, e6, this.getPositionIds(t5), n4);
        }
        updatePaintArray(e6, t5, n4, r3, i3) {
          this._setPaintValues(e6, t5, this.getPositionIds(n4), i3);
        }
        _setPaintValues(e6, t5, n4, r3) {
          let i3 = this.getPositions(r3);
          if (!i3 || !n4) return;
          let a3 = i3[n4.min], o3 = i3[n4.mid], s3 = i3[n4.max];
          if (a3 && o3 && s3) for (let n5 = e6; n5 < t5; n5++) this.emplace(this.zoomInPaintVertexArray, n5, o3, a3), this.emplace(this.zoomOutPaintVertexArray, n5, o3, s3);
        }
        upload(e6) {
          if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
            let t5 = this.getVertexAttributes();
            this.zoomInPaintVertexBuffer = e6.createVertexBuffer(this.zoomInPaintVertexArray, t5, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = e6.createVertexBuffer(this.zoomOutPaintVertexArray, t5, this.expression.isStateDependent);
          }
        }
        destroy() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        }
      }
      class ws extends Cs {
        getPositions(e6) {
          return e6.imagePositions;
        }
        getPositionIds(e6) {
          return e6.patterns && e6.patterns[this.layerId];
        }
        getVertexAttributes() {
          return es.members;
        }
        emplace(e6, t5, n4, r3) {
          e6.emplace(t5, n4.tlbr[0], n4.tlbr[1], n4.tlbr[2], n4.tlbr[3], r3.tlbr[0], r3.tlbr[1], r3.tlbr[2], r3.tlbr[3], n4.pixelRatio, r3.pixelRatio);
        }
      }
      class Ts extends Cs {
        getPositions(e6) {
          return e6.dashPositions;
        }
        getPositionIds(e6) {
          return e6.dashes && e6.dashes[this.layerId];
        }
        getVertexAttributes() {
          return ts.members;
        }
        emplace(e6, t5, n4, r3) {
          e6.emplace(t5, 0, n4.y, n4.height, n4.width, 0, r3.y, r3.height, r3.width);
        }
      }
      class Es {
        constructor(e6, t5, n4) {
          this.binders = {}, this._buffers = [];
          let r3 = [];
          for (let i3 in e6.paint._values) {
            if (!n4(i3)) continue;
            let a3 = e6.paint.get(i3);
            if (!(a3 instanceof La && Gr(a3.property.specification))) continue;
            let o3 = Os(i3, e6.type), s3 = a3.value, c3 = a3.property.specification.type, l3 = a3.property.useIntegerZoom, u3 = a3.property.specification[`property-type`], d3 = u3 === `cross-faded` || u3 === `cross-faded-data-driven`;
            if (s3.kind === `constant`) this.binders[i3] = d3 ? new bs(s3.value, o3) : new ys(s3.value, o3, c3), r3.push(`/u_${i3}`);
            else if (s3.kind === `source` || d3) {
              let n5 = ks(i3, c3, `source`);
              this.binders[i3] = d3 ? i3 === `line-dasharray` ? new Ts(s3, c3, l3, t5, n5, e6.id) : new ws(s3, c3, l3, t5, n5, e6.id) : new xs(s3, o3, c3, n5), r3.push(`/a_${i3}`);
            } else {
              let e7 = ks(i3, c3, `composite`);
              this.binders[i3] = new Ss(s3, o3, c3, l3, t5, e7), r3.push(`/z_${i3}`);
            }
          }
          this.cacheKey = r3.sort().join(``);
        }
        getMaxValue(e6) {
          let t5 = this.binders[e6];
          return t5 instanceof xs || t5 instanceof Ss ? t5.maxValue : 0;
        }
        populatePaintArrays(e6, t5, n4) {
          for (let r3 in this.binders) {
            let i3 = this.binders[r3];
            (i3 instanceof xs || i3 instanceof Ss || i3 instanceof Cs) && i3.populatePaintArray(e6, t5, n4);
          }
        }
        setConstantPatternPositions(e6, t5) {
          for (let n4 in this.binders) {
            let r3 = this.binders[n4];
            r3 instanceof bs && r3.setConstantPatternPositions(e6, t5);
          }
        }
        setConstantDashPositions(e6, t5) {
          for (let n4 in this.binders) {
            let r3 = this.binders[n4];
            r3 instanceof bs && r3.setConstantDashPositions(e6, t5);
          }
        }
        updatePaintArrays(e6, t5, n4, r3, i3) {
          let a3 = false;
          for (let o3 in e6) {
            let s3 = t5.getPositions(o3);
            for (let t6 of s3) {
              let s4 = n4.feature(t6.index);
              for (let n5 in this.binders) {
                let c3 = this.binders[n5];
                (c3 instanceof xs || c3 instanceof Ss || c3 instanceof Cs) && true === c3.expression.isStateDependent && (c3.expression = r3.paint.get(n5).value, c3.updatePaintArray(t6.start, t6.end, s4, e6[o3], i3), a3 = true);
              }
            }
          }
          return a3;
        }
        defines() {
          let e6 = [];
          for (let t5 in this.binders) {
            let n4 = this.binders[t5];
            (n4 instanceof ys || n4 instanceof bs) && e6.push(...n4.uniformNames.map(((e7) => `#define HAS_UNIFORM_${e7}`)));
          }
          return e6;
        }
        getBinderAttributes() {
          let e6 = [];
          for (let t5 in this.binders) {
            let n4 = this.binders[t5];
            if (n4 instanceof xs || n4 instanceof Ss) for (let t6 = 0; t6 < n4.paintVertexAttributes.length; t6++) e6.push(n4.paintVertexAttributes[t6].name);
            else if (n4 instanceof Cs) {
              let t6 = n4.getVertexAttributes();
              for (let n5 of t6) e6.push(n5.name);
            }
          }
          return e6;
        }
        getBinderUniforms() {
          let e6 = [];
          for (let t5 in this.binders) {
            let n4 = this.binders[t5];
            if (n4 instanceof ys || n4 instanceof bs || n4 instanceof Ss) for (let t6 of n4.uniformNames) e6.push(t6);
          }
          return e6;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(e6, t5) {
          let n4 = [];
          for (let r3 in this.binders) {
            let i3 = this.binders[r3];
            if (i3 instanceof ys || i3 instanceof bs || i3 instanceof Ss) {
              for (let a3 of i3.uniformNames) if (t5[a3]) {
                let o3 = i3.getBinding(e6, t5[a3], a3);
                n4.push({ name: a3, property: r3, binding: o3 });
              }
            }
          }
          return n4;
        }
        setUniforms(e6, t5, n4, r3) {
          for (let { name: e7, property: i3, binding: a3 } of t5) this.binders[i3].setUniform(a3, r3, n4.get(i3), e7);
        }
        updatePaintBuffers(e6) {
          for (let t5 in this._buffers = [], this.binders) {
            let n4 = this.binders[t5];
            if (e6 && n4 instanceof Cs) {
              let t6 = e6.fromScale === 2 ? n4.zoomInPaintVertexBuffer : n4.zoomOutPaintVertexBuffer;
              t6 && this._buffers.push(t6);
            } else (n4 instanceof xs || n4 instanceof Ss) && n4.paintVertexBuffer && this._buffers.push(n4.paintVertexBuffer);
          }
        }
        upload(e6) {
          for (let t5 in this.binders) {
            let n4 = this.binders[t5];
            (n4 instanceof xs || n4 instanceof Ss || n4 instanceof Cs) && n4.upload(e6);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (let e6 in this.binders) {
            let t5 = this.binders[e6];
            (t5 instanceof xs || t5 instanceof Ss || t5 instanceof Cs) && t5.destroy();
          }
        }
      }
      class Ds {
        constructor(e6, t5, n4 = () => true) {
          this.programConfigurations = {};
          for (let r3 of e6) this.programConfigurations[r3.id] = new Es(r3, t5, n4);
          this.needsUpload = false, this._featureMap = new ls(), this._bufferOffset = 0;
        }
        populatePaintArrays(e6, t5, n4, r3) {
          for (let n5 in this.programConfigurations) this.programConfigurations[n5].populatePaintArrays(e6, t5, r3);
          t5.id !== void 0 && this._featureMap.add(t5.id, n4, this._bufferOffset, e6), this._bufferOffset = e6, this.needsUpload = true;
        }
        updatePaintArrays(e6, t5, n4, r3) {
          for (let i3 of n4) this.needsUpload = this.programConfigurations[i3.id].updatePaintArrays(e6, this._featureMap, t5, i3, r3) || this.needsUpload;
        }
        get(e6) {
          return this.programConfigurations[e6];
        }
        upload(e6) {
          if (this.needsUpload) {
            for (let t5 in this.programConfigurations) this.programConfigurations[t5].upload(e6);
            this.needsUpload = false;
          }
        }
        destroy() {
          for (let e6 in this.programConfigurations) this.programConfigurations[e6].destroy();
        }
      }
      function Os(e6, t5) {
        return { "text-opacity": [`opacity`], "icon-opacity": [`opacity`], "text-color": [`fill_color`], "icon-color": [`fill_color`], "text-halo-color": [`halo_color`], "icon-halo-color": [`halo_color`], "text-halo-blur": [`halo_blur`], "icon-halo-blur": [`halo_blur`], "text-halo-width": [`halo_width`], "icon-halo-width": [`halo_width`], "line-gap-width": [`gapwidth`], "line-dasharray": [`dasharray_to`, `dasharray_from`], "line-pattern": [`pattern_to`, `pattern_from`, `pixel_ratio_to`, `pixel_ratio_from`], "fill-pattern": [`pattern_to`, `pattern_from`, `pixel_ratio_to`, `pixel_ratio_from`], "fill-extrusion-pattern": [`pattern_to`, `pattern_from`, `pixel_ratio_to`, `pixel_ratio_from`] }[e6] || [e6.replace(`${t5}-`, ``).replace(/-/g, `_`)];
      }
      function ks(e6, t5, n4) {
        let r3 = { color: { source: io, composite: Co }, number: { source: vo, composite: io } }, i3 = (function(e7) {
          return { "line-pattern": { source: Ho, composite: Ho }, "fill-pattern": { source: Ho, composite: Ho }, "fill-extrusion-pattern": { source: Ho, composite: Ho }, "line-dasharray": { source: Uo, composite: Uo } }[e7];
        })(e6);
        return i3 && i3[n4] || r3[t5][n4];
      }
      X(`ConstantBinder`, ys), X(`CrossFadedConstantBinder`, bs), X(`SourceExpressionBinder`, xs), X(`CrossFadedPatternBinder`, ws), X(`CrossFadedDasharrayBinder`, Ts), X(`CompositeExpressionBinder`, Ss), X(`ProgramConfiguration`, Es, { omit: [`_buffers`] }), X(`ProgramConfigurationSet`, Ds);
      let As = 2 ** 14 - 1, js = -As - 1;
      function Ms(e6) {
        let t5 = O2 / e6.extent, n4 = e6.loadGeometry();
        for (let e7 = 0; e7 < n4.length; e7++) {
          let r3 = n4[e7];
          for (let e8 = 0; e8 < r3.length; e8++) {
            let n5 = r3[e8], i3 = Math.round(n5.x * t5), a3 = Math.round(n5.y * t5);
            n5.x = N2(i3, js, As), n5.y = N2(a3, js, As), (i3 < n5.x || i3 > n5.x + 1 || a3 < n5.y || a3 > n5.y + 1) && F2(`Geometry exceeds allowed extent, reduce your vector tile buffer size`);
          }
        }
        return n4;
      }
      function Ns(e6, t5) {
        return { type: e6.type, id: e6.id, properties: e6.properties, geometry: t5 ? Ms(e6) : [] };
      }
      let Ps = -32768;
      function Fs(e6, t5, n4, r3, i3) {
        e6.emplaceBack(Ps + 8 * t5 + r3, Ps + 8 * n4 + i3);
      }
      class Is {
        constructor(e6) {
          this.zoom = e6.zoom, this.overscaling = e6.overscaling, this.layers = e6.layers, this.layerIds = this.layers.map(((e7) => e7.id)), this.index = e6.index, this.hasDependencies = false, this.layoutVertexArray = new Lo(), this.indexArray = new Yo(), this.segments = new Qo(), this.programConfigurations = new Ds(e6.layers, e6.zoom), this.stateDependentLayerIds = this.layers.filter(((e7) => e7.isStateDependent())).map(((e7) => e7.id));
        }
        populate(e6, t5, n4) {
          let r3 = this.layers[0], i3 = [], a3 = null, o3 = false, s3 = r3.type === `heatmap`;
          if (r3.type === `circle`) {
            let e7 = r3;
            a3 = e7.layout.get(`circle-sort-key`), o3 = !a3.isConstant(), s3 || (s3 = e7.paint.get(`circle-pitch-alignment`) === `map`);
          }
          let c3 = s3 ? t5.subdivisionGranularity.circle : 1;
          for (let { feature: t6, id: r4, index: s4, sourceLayerIndex: c4 } of e6) {
            let e7 = this.layers[0]._featureFilter.needGeometry, l3 = Ns(t6, e7);
            if (!this.layers[0]._featureFilter.filter(new ka(this.zoom), l3, n4)) continue;
            let u3 = o3 ? a3.evaluate(l3, {}, n4) : void 0, d3 = { id: r4, properties: t6.properties, type: t6.type, sourceLayerIndex: c4, index: s4, geometry: e7 ? l3.geometry : Ms(t6), patterns: {}, sortKey: u3 };
            i3.push(d3);
          }
          o3 && i3.sort(((e7, t6) => e7.sortKey - t6.sortKey));
          for (let r4 of i3) {
            let { geometry: i4, index: a4, sourceLayerIndex: o4 } = r4, s4 = e6[a4].feature;
            this.addFeature(r4, i4, a4, n4, c3), t5.featureIndex.insert(s4, i4, a4, o4, this.index);
          }
        }
        update(e6, t5, n4) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e6, t5, this.stateDependentLayers, { imagePositions: n4 });
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e6) {
          this.uploaded || (this.layoutVertexBuffer = e6.createVertexBuffer(this.layoutVertexArray, Zo), this.indexBuffer = e6.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e6), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(e6, t5, n4, r3, i3 = 1) {
          let a3;
          switch (i3) {
            case 1:
              a3 = [0, 7];
              break;
            case 3:
              a3 = [0, 2, 5, 7];
              break;
            case 5:
              a3 = [0, 1, 3, 4, 6, 7];
              break;
            case 7:
              a3 = [0, 1, 2, 3, 4, 5, 6, 7];
              break;
            default:
              throw Error(`Invalid circle bucket granularity: ${i3}; valid values are 1, 3, 5, 7.`);
          }
          let o3 = a3.length;
          for (let n5 of t5) for (let t6 of n5) {
            let n6 = t6.x, r4 = t6.y;
            if (n6 < 0 || n6 >= O2 || r4 < 0 || r4 >= O2) continue;
            let i4 = this.segments.prepareSegment(o3 * o3, this.layoutVertexArray, this.indexArray, e6.sortKey), s3 = i4.vertexLength;
            for (let e7 = 0; e7 < o3; e7++) for (let t7 = 0; t7 < o3; t7++) Fs(this.layoutVertexArray, n6, r4, a3[t7], a3[e7]);
            for (let e7 = 0; e7 < o3 - 1; e7++) for (let t7 = 0; t7 < o3 - 1; t7++) {
              let n7 = s3 + e7 * o3 + t7, r5 = s3 + (e7 + 1) * o3 + t7;
              this.indexArray.emplaceBack(n7, r5 + 1, n7 + 1), this.indexArray.emplaceBack(n7, r5, r5 + 1);
            }
            i4.vertexLength += o3 * o3, i4.primitiveLength += (o3 - 1) * (o3 - 1) * 2;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e6, n4, { imagePositions: {}, canonical: r3 });
        }
      }
      function Ls(e6, t5) {
        for (let n4 = 0; n4 < e6.length; n4++) if (Ks(t5, e6[n4])) return true;
        for (let n4 = 0; n4 < t5.length; n4++) if (Ks(e6, t5[n4])) return true;
        return !!Vs(e6, t5);
      }
      function Rs(e6, t5, n4) {
        return !!Ks(e6, t5) || !!Us(t5, e6, n4);
      }
      function zs(e6, t5) {
        if (e6.length === 1) return Gs(t5, e6[0]);
        for (let n4 = 0; n4 < t5.length; n4++) {
          let r3 = t5[n4];
          for (let t6 = 0; t6 < r3.length; t6++) if (Ks(e6, r3[t6])) return true;
        }
        for (let n4 = 0; n4 < e6.length; n4++) if (Gs(t5, e6[n4])) return true;
        for (let n4 = 0; n4 < t5.length; n4++) if (Vs(e6, t5[n4])) return true;
        return false;
      }
      function Bs(e6, t5, n4) {
        if (e6.length > 1) {
          if (Vs(e6, t5)) return true;
          for (let r3 = 0; r3 < t5.length; r3++) if (Us(t5[r3], e6, n4)) return true;
        }
        for (let r3 = 0; r3 < e6.length; r3++) if (Us(e6[r3], t5, n4)) return true;
        return false;
      }
      function Vs(e6, t5) {
        if (e6.length === 0 || t5.length === 0) return false;
        for (let n4 = 0; n4 < e6.length - 1; n4++) {
          let r3 = e6[n4], i3 = e6[n4 + 1];
          for (let e7 = 0; e7 < t5.length - 1; e7++) if (Hs(r3, i3, t5[e7], t5[e7 + 1])) return true;
        }
        return false;
      }
      function Hs(e6, t5, n4, r3) {
        return ce2(e6, n4, r3) !== ce2(t5, n4, r3) && ce2(e6, t5, n4) !== ce2(e6, t5, r3);
      }
      function Us(e6, t5, n4) {
        let r3 = n4 * n4;
        if (t5.length === 1) return e6.distSqr(t5[0]) < r3;
        for (let n5 = 1; n5 < t5.length; n5++) if (Ws(e6, t5[n5 - 1], t5[n5]) < r3) return true;
        return false;
      }
      function Ws(e6, t5, n4) {
        let r3 = t5.distSqr(n4);
        if (r3 === 0) return e6.distSqr(t5);
        let i3 = ((e6.x - t5.x) * (n4.x - t5.x) + (e6.y - t5.y) * (n4.y - t5.y)) / r3;
        return e6.distSqr(i3 < 0 ? t5 : i3 > 1 ? n4 : n4.sub(t5)._mult(i3)._add(t5));
      }
      function Gs(e6, t5) {
        let n4, r3, i3, a3 = false;
        for (let o3 = 0; o3 < e6.length; o3++) {
          n4 = e6[o3];
          for (let e7 = 0, o4 = n4.length - 1; e7 < n4.length; o4 = e7++) r3 = n4[e7], i3 = n4[o4], r3.y > t5.y != i3.y > t5.y && t5.x < (i3.x - r3.x) * (t5.y - r3.y) / (i3.y - r3.y) + r3.x && (a3 = !a3);
        }
        return a3;
      }
      function Ks(e6, t5) {
        let n4 = false;
        for (let r3 = 0, i3 = e6.length - 1; r3 < e6.length; i3 = r3++) {
          let a3 = e6[r3], o3 = e6[i3];
          a3.y > t5.y != o3.y > t5.y && t5.x < (o3.x - a3.x) * (t5.y - a3.y) / (o3.y - a3.y) + a3.x && (n4 = !n4);
        }
        return n4;
      }
      function qs(e6, t5, n4) {
        let r3 = n4[0], i3 = n4[2];
        if (e6.x < r3.x && t5.x < r3.x || e6.x > i3.x && t5.x > i3.x || e6.y < r3.y && t5.y < r3.y || e6.y > i3.y && t5.y > i3.y) return false;
        let a3 = ce2(e6, t5, n4[0]);
        return a3 !== ce2(e6, t5, n4[1]) || a3 !== ce2(e6, t5, n4[2]) || a3 !== ce2(e6, t5, n4[3]);
      }
      function Js(e6, t5, n4) {
        let r3 = t5.paint.get(e6).value;
        return r3.kind === `constant` ? r3.value : n4.programConfigurations.get(t5.id).getMaxValue(e6);
      }
      function Ys(e6) {
        return Math.sqrt(e6[0] * e6[0] + e6[1] * e6[1]);
      }
      function Xs(e6, t5, r3, i3, a3) {
        if (!t5[0] && !t5[1]) return e6;
        let o3 = n3.convert(t5)._mult(a3);
        r3 === `viewport` && o3._rotate(-i3);
        let s3 = [];
        for (let t6 = 0; t6 < e6.length; t6++) s3.push(e6[t6].sub(o3));
        return s3;
      }
      function Zs({ queryGeometry: e6, size: t5 }, n4) {
        return Rs(e6, n4, t5);
      }
      function Qs({ queryGeometry: e6, size: t5, transform: n4, unwrappedTileID: r3, getElevation: i3 }, a3) {
        return Rs(e6, a3, t5 * (n4.projectTileCoordinates(a3.x, a3.y, r3, i3).signedDistanceFromCamera / n4.cameraToCenterDistance));
      }
      function $s({ queryGeometry: e6, size: t5, transform: n4, unwrappedTileID: r3, getElevation: i3 }, a3) {
        let o3 = n4.projectTileCoordinates(a3.x, a3.y, r3, i3).signedDistanceFromCamera, s3 = t5 * (n4.cameraToCenterDistance / o3);
        return Rs(e6, nc(a3, n4, r3, i3), s3);
      }
      function ec({ queryGeometry: e6, size: t5, transform: n4, unwrappedTileID: r3, getElevation: i3 }, a3) {
        return Rs(e6, nc(a3, n4, r3, i3), t5);
      }
      function tc({ queryGeometry: e6, size: t5, transform: n4, unwrappedTileID: r3, getElevation: i3, pitchAlignment: a3 = `map`, pitchScale: o3 = `map` }, s3) {
        let c3 = a3 === `map` ? o3 === `map` ? Zs : Qs : o3 === `map` ? $s : ec, l3 = { queryGeometry: e6, size: t5, transform: n4, unwrappedTileID: r3, getElevation: i3 };
        for (let e7 of s3) for (let t6 of e7) if (c3(l3, t6)) return true;
        return false;
      }
      function nc(e6, t5, r3, i3) {
        let a3 = t5.projectTileCoordinates(e6.x, e6.y, r3, i3).point;
        return new n3((0.5 * a3.x + 0.5) * t5.width, (0.5 * -a3.y + 0.5) * t5.height);
      }
      let rc, ic;
      X(`CircleBucket`, Is, { omit: [`layers`] });
      var ac = { get paint() {
        return ic || (ic = new Ha({ "circle-radius": new $(R2.paint_circle[`circle-radius`]), "circle-color": new $(R2.paint_circle[`circle-color`]), "circle-blur": new $(R2.paint_circle[`circle-blur`]), "circle-opacity": new $(R2.paint_circle[`circle-opacity`]), "circle-translate": new Q(R2.paint_circle[`circle-translate`]), "circle-translate-anchor": new Q(R2.paint_circle[`circle-translate-anchor`]), "circle-pitch-scale": new Q(R2.paint_circle[`circle-pitch-scale`]), "circle-pitch-alignment": new Q(R2.paint_circle[`circle-pitch-alignment`]), "circle-stroke-width": new $(R2.paint_circle[`circle-stroke-width`]), "circle-stroke-color": new $(R2.paint_circle[`circle-stroke-color`]), "circle-stroke-opacity": new $(R2.paint_circle[`circle-stroke-opacity`]) }));
      }, get layout() {
        return rc || (rc = new Ha({ "circle-sort-key": new $(R2.layout_circle[`circle-sort-key`]) }));
      } };
      class oc extends Wa {
        constructor(e6, t5) {
          super(e6, ac, t5);
        }
        createBucket(e6) {
          return new Is(e6);
        }
        queryRadius(e6) {
          let t5 = e6;
          return Js(`circle-radius`, this, t5) + Js(`circle-stroke-width`, this, t5) + Ys(this.paint.get(`circle-translate`));
        }
        queryIntersectsFeature({ queryGeometry: e6, feature: t5, featureState: n4, geometry: r3, transform: i3, pixelsToTileUnits: a3, unwrappedTileID: o3, getElevation: s3 }) {
          let c3 = Xs(e6, this.paint.get(`circle-translate`), this.paint.get(`circle-translate-anchor`), -i3.bearingInRadians, a3), l3 = this.paint.get(`circle-radius`).evaluate(t5, n4) + this.paint.get(`circle-stroke-width`).evaluate(t5, n4), u3 = this.paint.get(`circle-pitch-scale`), d3 = this.paint.get(`circle-pitch-alignment`), f3, p3;
          return d3 === `map` ? (f3 = c3, p3 = l3 * a3) : (f3 = (function(e7, t6, n5, r4) {
            return e7.map(((e8) => nc(e8, t6, n5, r4)));
          })(c3, i3, o3, s3), p3 = l3), tc({ queryGeometry: f3, size: p3, transform: i3, unwrappedTileID: o3, getElevation: s3, pitchAlignment: d3, pitchScale: u3 }, r3);
        }
      }
      class sc extends Is {
      }
      let cc;
      X(`HeatmapBucket`, sc, { omit: [`layers`] });
      var lc = { get paint() {
        return cc || (cc = new Ha({ "heatmap-radius": new $(R2.paint_heatmap[`heatmap-radius`]), "heatmap-weight": new $(R2.paint_heatmap[`heatmap-weight`]), "heatmap-intensity": new Q(R2.paint_heatmap[`heatmap-intensity`]), "heatmap-color": new Va(R2.paint_heatmap[`heatmap-color`]), "heatmap-opacity": new Q(R2.paint_heatmap[`heatmap-opacity`]) }));
      } };
      function uc(e6, { width: t5, height: n4 }, r3, i3) {
        if (i3) {
          if (i3 instanceof Uint8ClampedArray) i3 = new Uint8Array(i3.buffer);
          else if (i3.length !== t5 * n4 * r3) throw RangeError(`mismatched image size. expected: ${i3.length} but got: ${t5 * n4 * r3}`);
        } else i3 = new Uint8Array(t5 * n4 * r3);
        return e6.width = t5, e6.height = n4, e6.data = i3, e6;
      }
      function dc(e6, { width: t5, height: n4 }, r3) {
        if (t5 === e6.width && n4 === e6.height) return;
        let i3 = uc({}, { width: t5, height: n4 }, r3);
        fc(e6, i3, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(e6.width, t5), height: Math.min(e6.height, n4) }, r3), e6.width = t5, e6.height = n4, e6.data = i3.data;
      }
      function fc(e6, t5, n4, r3, i3, a3) {
        if (i3.width === 0 || i3.height === 0) return t5;
        if (i3.width > e6.width || i3.height > e6.height || n4.x > e6.width - i3.width || n4.y > e6.height - i3.height) throw RangeError(`out of range source coordinates for image copy`);
        if (i3.width > t5.width || i3.height > t5.height || r3.x > t5.width - i3.width || r3.y > t5.height - i3.height) throw RangeError(`out of range destination coordinates for image copy`);
        let o3 = e6.data, s3 = t5.data;
        if (o3 === s3) throw Error(`srcData equals dstData, so image is already copied`);
        for (let c3 = 0; c3 < i3.height; c3++) {
          let l3 = ((n4.y + c3) * e6.width + n4.x) * a3, u3 = ((r3.y + c3) * t5.width + r3.x) * a3;
          for (let e7 = 0; e7 < i3.width * a3; e7++) s3[u3 + e7] = o3[l3 + e7];
        }
        return t5;
      }
      class pc {
        constructor(e6, t5) {
          uc(this, e6, 1, t5);
        }
        resize(e6) {
          dc(this, e6, 1);
        }
        clone() {
          return new pc({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(e6, t5, n4, r3, i3) {
          fc(e6, t5, n4, r3, i3, 1);
        }
      }
      class mc {
        constructor(e6, t5) {
          uc(this, e6, 4, t5);
        }
        resize(e6) {
          dc(this, e6, 4);
        }
        replace(e6, t5) {
          t5 ? this.data.set(e6) : this.data = e6 instanceof Uint8ClampedArray ? new Uint8Array(e6.buffer) : e6;
        }
        clone() {
          return new mc({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(e6, t5, n4, r3, i3) {
          fc(e6, t5, n4, r3, i3, 4);
        }
        setPixel(e6, t5, n4) {
          let r3 = 4 * (e6 * this.width + t5);
          this.data[r3 + 0] = Math.round(255 * n4.r / n4.a), this.data[r3 + 1] = Math.round(255 * n4.g / n4.a), this.data[r3 + 2] = Math.round(255 * n4.b / n4.a), this.data[r3 + 3] = Math.round(255 * n4.a);
        }
      }
      function hc(e6) {
        let t5 = {}, n4 = e6.resolution || 256, r3 = e6.clips ? e6.clips.length : 1, i3 = e6.image || new mc({ width: n4, height: r3 });
        if (Math.log(n4) / Math.LN2 % 1 != 0) throw Error(`width is not a power of 2 - ${n4}`);
        let a3 = (r4, a4, o3) => {
          t5[e6.evaluationKey] = o3;
          let s3 = e6.expression.evaluate(t5);
          i3.setPixel(r4 / 4 / n4, a4 / 4, s3);
        };
        if (e6.clips) for (let t6 = 0, i4 = 0; t6 < r3; ++t6, i4 += 4 * n4) for (let r4 = 0, o3 = 0; r4 < n4; r4++, o3 += 4) {
          let s3 = r4 / (n4 - 1), { start: c3, end: l3 } = e6.clips[t6];
          a3(i4, o3, c3 * (1 - s3) + l3 * s3);
        }
        else for (let e7 = 0, t6 = 0; e7 < n4; e7++, t6 += 4) a3(0, t6, e7 / (n4 - 1));
        return i3;
      }
      X(`AlphaImage`, pc), X(`RGBAImage`, mc);
      let gc = `big-fb`;
      class _c2 extends Wa {
        createBucket(e6) {
          return new sc(e6);
        }
        constructor(e6, t5) {
          super(e6, lc, t5), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(e6) {
          e6 === `heatmap-color` && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = hc({ expression: this._transitionablePaint._values[`heatmap-color`].value.expression, evaluationKey: `heatmapDensity`, image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbos.has(gc) && this.heatmapFbos.delete(gc);
        }
        queryRadius(e6) {
          return Js(`heatmap-radius`, this, e6);
        }
        queryIntersectsFeature({ queryGeometry: e6, feature: t5, featureState: n4, geometry: r3, transform: i3, pixelsToTileUnits: a3, unwrappedTileID: o3, getElevation: s3 }) {
          return tc({ queryGeometry: e6, size: this.paint.get(`heatmap-radius`).evaluate(t5, n4) * a3, transform: i3, unwrappedTileID: o3, getElevation: s3 }, r3);
        }
        hasOffscreenPass() {
          return this.paint.get(`heatmap-opacity`) !== 0 && this.visibility !== `none`;
        }
      }
      let vc;
      var yc = { get paint() {
        return vc || (vc = new Ha({ "hillshade-illumination-direction": new Q(R2.paint_hillshade[`hillshade-illumination-direction`]), "hillshade-illumination-altitude": new Q(R2.paint_hillshade[`hillshade-illumination-altitude`]), "hillshade-illumination-anchor": new Q(R2.paint_hillshade[`hillshade-illumination-anchor`]), "hillshade-exaggeration": new Q(R2.paint_hillshade[`hillshade-exaggeration`]), "hillshade-shadow-color": new Q(R2.paint_hillshade[`hillshade-shadow-color`]), "hillshade-highlight-color": new Q(R2.paint_hillshade[`hillshade-highlight-color`]), "hillshade-accent-color": new Q(R2.paint_hillshade[`hillshade-accent-color`]), "hillshade-method": new Q(R2.paint_hillshade[`hillshade-method`]) }));
      } };
      class bc extends Wa {
        constructor(e6, t5) {
          super(e6, yc, t5), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
        }
        getIlluminationProperties() {
          let e6 = this.paint.get(`hillshade-illumination-direction`).values, t5 = this.paint.get(`hillshade-illumination-altitude`).values, n4 = this.paint.get(`hillshade-highlight-color`).values, r3 = this.paint.get(`hillshade-shadow-color`).values, i3 = Math.max(e6.length, t5.length, n4.length, r3.length);
          e6 = e6.concat(Array(i3 - e6.length).fill(e6.at(-1))), t5 = t5.concat(Array(i3 - t5.length).fill(t5.at(-1))), n4 = n4.concat(Array(i3 - n4.length).fill(n4.at(-1))), r3 = r3.concat(Array(i3 - r3.length).fill(r3.at(-1)));
          let a3 = t5.map(_e2);
          return { directionRadians: e6.map(_e2), altitudeRadians: a3, shadowColor: r3, highlightColor: n4 };
        }
        hasOffscreenPass() {
          return this.paint.get(`hillshade-exaggeration`) !== 0 && this.visibility !== `none`;
        }
      }
      let xc;
      var Sc = { get paint() {
        return xc || (xc = new Ha({ "color-relief-opacity": new Q(R2[`paint_color-relief`][`color-relief-opacity`]), "color-relief-color": new Va(R2[`paint_color-relief`][`color-relief-color`]) }));
      } };
      class Cc {
        constructor(e6, t5, n4, r3) {
          this.context = e6, this.format = n4, this.texture = e6.gl.createTexture(), this.update(t5, r3);
        }
        update(e6, t5, n4) {
          let { width: r3, height: i3 } = e6, a3 = !(this.size && this.size[0] === r3 && this.size[1] === i3 || n4), { context: o3 } = this, { gl: s3 } = o3;
          if (this.useMipmap = !!(t5 && t5.useMipmap), s3.bindTexture(s3.TEXTURE_2D, this.texture), o3.pixelStoreUnpackFlipY.set(false), o3.pixelStoreUnpack.set(1), o3.pixelStoreUnpackPremultiplyAlpha.set(this.format === s3.RGBA && (!t5 || false !== t5.premultiply)), a3) this.size = [r3, i3], e6 instanceof HTMLImageElement || e6 instanceof HTMLCanvasElement || e6 instanceof HTMLVideoElement || e6 instanceof ImageData || fe2(e6) ? s3.texImage2D(s3.TEXTURE_2D, 0, this.format, this.format, s3.UNSIGNED_BYTE, e6) : s3.texImage2D(s3.TEXTURE_2D, 0, this.format, r3, i3, 0, this.format, s3.UNSIGNED_BYTE, e6.data);
          else {
            let { x: t6, y: a4 } = n4 || { x: 0, y: 0 };
            e6 instanceof HTMLImageElement || e6 instanceof HTMLCanvasElement || e6 instanceof HTMLVideoElement || e6 instanceof ImageData || fe2(e6) ? s3.texSubImage2D(s3.TEXTURE_2D, 0, t6, a4, s3.RGBA, s3.UNSIGNED_BYTE, e6) : s3.texSubImage2D(s3.TEXTURE_2D, 0, t6, a4, r3, i3, s3.RGBA, s3.UNSIGNED_BYTE, e6.data);
          }
          this.useMipmap && this.isSizePowerOfTwo() && s3.generateMipmap(s3.TEXTURE_2D), o3.pixelStoreUnpackFlipY.setDefault(), o3.pixelStoreUnpack.setDefault(), o3.pixelStoreUnpackPremultiplyAlpha.setDefault();
        }
        bind(e6, t5, n4) {
          let { context: r3 } = this, { gl: i3 } = r3;
          i3.bindTexture(i3.TEXTURE_2D, this.texture), n4 !== i3.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (n4 = i3.LINEAR), e6 !== this.filter && (i3.texParameteri(i3.TEXTURE_2D, i3.TEXTURE_MAG_FILTER, e6), i3.texParameteri(i3.TEXTURE_2D, i3.TEXTURE_MIN_FILTER, n4 || e6), this.filter = e6), t5 !== this.wrap && (i3.texParameteri(i3.TEXTURE_2D, i3.TEXTURE_WRAP_S, t5), i3.texParameteri(i3.TEXTURE_2D, i3.TEXTURE_WRAP_T, t5), this.wrap = t5);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          let { gl: e6 } = this.context;
          e6.deleteTexture(this.texture), this.texture = null;
        }
      }
      class wc {
        constructor(e6, t5, n4, r3 = 1, i3 = 1, a3 = 1, o3 = 0) {
          if (this.uid = e6, t5.height !== t5.width) throw RangeError(`DEM tiles must be square`);
          if (n4 && ![`mapbox`, `terrarium`, `custom`].includes(n4)) return void F2(`"${n4}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
          this.stride = t5.height;
          let s3 = this.dim = t5.height - 2;
          switch (this.data = new Uint32Array(t5.data.buffer), n4) {
            case `terrarium`:
              this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
              break;
            case `custom`:
              this.redFactor = r3, this.greenFactor = i3, this.blueFactor = a3, this.baseShift = o3;
              break;
            default:
              this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
          }
          for (let e7 = 0; e7 < s3; e7++) this.data[this._idx(-1, e7)] = this.data[this._idx(0, e7)], this.data[this._idx(s3, e7)] = this.data[this._idx(s3 - 1, e7)], this.data[this._idx(e7, -1)] = this.data[this._idx(e7, 0)], this.data[this._idx(e7, s3)] = this.data[this._idx(e7, s3 - 1)];
          this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(s3, -1)] = this.data[this._idx(s3 - 1, 0)], this.data[this._idx(-1, s3)] = this.data[this._idx(0, s3 - 1)], this.data[this._idx(s3, s3)] = this.data[this._idx(s3 - 1, s3 - 1)], this.min = 2 ** 53 - 1, this.max = -(2 ** 53 - 1);
          for (let e7 = 0; e7 < s3; e7++) for (let t6 = 0; t6 < s3; t6++) {
            let n5 = this.get(e7, t6);
            n5 > this.max && (this.max = n5), n5 < this.min && (this.min = n5);
          }
        }
        get(e6, t5) {
          let n4 = new Uint8Array(this.data.buffer), r3 = 4 * this._idx(e6, t5);
          return this.unpack(n4[r3], n4[r3 + 1], n4[r3 + 2]);
        }
        getUnpackVector() {
          return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
        }
        _idx(e6, t5) {
          if (e6 < -1 || e6 >= this.dim + 1 || t5 < -1 || t5 >= this.dim + 1) throw RangeError(`out of range source coordinates for DEM data`);
          return (t5 + 1) * this.stride + (e6 + 1);
        }
        unpack(e6, t5, n4) {
          return e6 * this.redFactor + t5 * this.greenFactor + n4 * this.blueFactor - this.baseShift;
        }
        pack(e6) {
          return Tc(e6, this.getUnpackVector());
        }
        getPixels() {
          return new mc({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }
        backfillBorder(e6, t5, n4) {
          if (this.dim !== e6.dim) throw Error(`dem dimension mismatch`);
          let r3 = t5 * this.dim, i3 = t5 * this.dim + this.dim, a3 = n4 * this.dim, o3 = n4 * this.dim + this.dim;
          switch (t5) {
            case -1:
              r3 = i3 - 1;
              break;
            case 1:
              i3 = r3 + 1;
          }
          switch (n4) {
            case -1:
              a3 = o3 - 1;
              break;
            case 1:
              o3 = a3 + 1;
          }
          let s3 = -t5 * this.dim, c3 = -n4 * this.dim;
          for (let t6 = a3; t6 < o3; t6++) for (let n5 = r3; n5 < i3; n5++) this.data[this._idx(n5, t6)] = e6.data[this._idx(n5 + s3, t6 + c3)];
        }
      }
      function Tc(e6, t5) {
        let n4 = t5[0], r3 = t5[1], i3 = t5[2], a3 = t5[3], o3 = Math.min(n4, r3, i3), s3 = Math.round((e6 + a3) / o3);
        return { r: Math.floor(s3 * o3 / n4) % 256, g: Math.floor(s3 * o3 / r3) % 256, b: Math.floor(s3 * o3 / i3) % 256 };
      }
      X(`DEMData`, wc);
      class Ec extends Wa {
        constructor(e6, t5) {
          super(e6, Sc, t5);
        }
        _createColorRamp(e6) {
          let t5 = { elevationStops: [], colorStops: [] }, n4 = this._transitionablePaint._values[`color-relief-color`].value.expression;
          if (n4 instanceof ai && n4._styleExpression.expression instanceof gn) {
            this.colorRampExpression = n4;
            let e7 = n4._styleExpression.expression;
            t5.elevationStops = e7.labels, t5.colorStops = [];
            for (let n5 of t5.elevationStops) t5.colorStops.push(e7.evaluate({ globals: { elevation: n5 } }));
          }
          if (t5.elevationStops.length < 1 && (t5.elevationStops = [0], t5.colorStops = [K2.transparent]), t5.elevationStops.length < 2 && (t5.elevationStops.push(t5.elevationStops[0] + 1), t5.colorStops.push(t5.colorStops[0])), t5.elevationStops.length <= e6) return t5;
          let r3 = { elevationStops: [], colorStops: [] }, i3 = (t5.elevationStops.length - 1) / (e6 - 1);
          for (let e7 = 0; e7 < t5.elevationStops.length - 0.5; e7 += i3) r3.elevationStops.push(t5.elevationStops[Math.round(e7)]), r3.colorStops.push(t5.colorStops[Math.round(e7)]);
          return F2(`Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${e6}, provided: ${t5.elevationStops.length}`), r3;
        }
        _colorRampChanged() {
          return this.colorRampExpression != this._transitionablePaint._values[`color-relief-color`].value.expression;
        }
        getColorRampTextures(e6, t5, n4) {
          if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
          let r3 = this._createColorRamp(t5), i3 = new mc({ width: r3.colorStops.length, height: 1 }), a3 = new mc({ width: r3.colorStops.length, height: 1 });
          for (let e7 = 0; e7 < r3.elevationStops.length; e7++) {
            let t6 = Tc(r3.elevationStops[e7], n4);
            a3.setPixel(0, e7, new K2(t6.r / 255, t6.g / 255, t6.b / 255, 1)), i3.setPixel(0, e7, r3.colorStops[e7]);
          }
          return this.colorRampTextures = { elevationTexture: new Cc(e6, a3, e6.gl.RGBA), colorTexture: new Cc(e6, i3, e6.gl.RGBA) }, this.colorRampTextures;
        }
        hasOffscreenPass() {
          return this.visibility !== `none` && !!this.colorRampTextures;
        }
      }
      let { members: Dc } = Za([{ name: `a_pos`, components: 2, type: `Int16` }], 4);
      function Oc(e6, t5, n4) {
        let r3 = n4.patternDependencies, i3 = false;
        for (let n5 of t5) {
          let t6 = n5.paint.get(`${e6}-pattern`);
          t6.isConstant() || (i3 = true);
          let a3 = t6.constantOr(null);
          a3 && (i3 = true, r3[a3.to] = true, r3[a3.from] = true);
        }
        return i3;
      }
      function kc(e6, t5, n4, r3, i3) {
        let { zoom: a3 } = r3, o3 = i3.patternDependencies;
        for (let r4 of t5) {
          let t6 = r4.paint.get(`${e6}-pattern`).value;
          if (t6.kind !== `constant`) {
            let e7 = t6.evaluate({ zoom: a3 - 1 }, n4, {}, i3.availableImages), s3 = t6.evaluate({ zoom: a3 }, n4, {}, i3.availableImages), c3 = t6.evaluate({ zoom: a3 + 1 }, n4, {}, i3.availableImages);
            e7 = e7 && e7.name ? e7.name : e7, s3 = s3 && s3.name ? s3.name : s3, c3 = c3 && c3.name ? c3.name : c3, o3[e7] = true, o3[s3] = true, o3[c3] = true, n4.patterns[r4.id] = { min: e7, mid: s3, max: c3 };
          }
        }
        return n4;
      }
      function Ac(e6, t5, n4, r3, i3) {
        let a3;
        if (i3 === (function(e7, t6, n5, r4) {
          let i4 = 0;
          for (let a4 = t6, o3 = n5 - r4; a4 < n5; a4 += r4) i4 += (e7[o3] - e7[a4]) * (e7[a4 + 1] + e7[o3 + 1]), o3 = a4;
          return i4;
        })(e6, t5, n4, r3) > 0) for (let i4 = t5; i4 < n4; i4 += r3) a3 = Qc(i4 / r3 | 0, e6[i4], e6[i4 + 1], a3);
        else for (let i4 = n4 - r3; i4 >= t5; i4 -= r3) a3 = Qc(i4 / r3 | 0, e6[i4], e6[i4 + 1], a3);
        return a3 && Kc(a3, a3.next) && ($c(a3), a3 = a3.next), a3;
      }
      function jc(e6, t5) {
        if (!e6) return e6;
        t5 || (t5 = e6);
        let n4, r3 = e6;
        do
          if (n4 = false, r3.steiner || !Kc(r3, r3.next) && Gc(r3.prev, r3, r3.next) !== 0) r3 = r3.next;
          else {
            if ($c(r3), r3 = t5 = r3.prev, r3 === r3.next) break;
            n4 = true;
          }
        while (n4 || r3 !== t5);
        return t5;
      }
      function Mc(e6, t5, n4, r3, i3, a3, o3) {
        if (!e6) return;
        !o3 && a3 && (function(e7, t6, n5, r4) {
          let i4 = e7;
          do
            i4.z === 0 && (i4.z = Bc(i4.x, i4.y, t6, n5, r4)), i4.prevZ = i4.prev, i4.nextZ = i4.next, i4 = i4.next;
          while (i4 !== e7);
          i4.prevZ.nextZ = null, i4.prevZ = null, (function(e8) {
            let t7, n6 = 1;
            do {
              let r5, i5 = e8;
              e8 = null;
              let a4 = null;
              for (t7 = 0; i5; ) {
                t7++;
                let o4 = i5, s4 = 0;
                for (let e9 = 0; e9 < n6 && (s4++, o4 = o4.nextZ, o4); e9++) ;
                let c3 = n6;
                for (; s4 > 0 || c3 > 0 && o4; ) s4 !== 0 && (c3 === 0 || !o4 || i5.z <= o4.z) ? (r5 = i5, i5 = i5.nextZ, s4--) : (r5 = o4, o4 = o4.nextZ, c3--), a4 ? a4.nextZ = r5 : e8 = r5, r5.prevZ = a4, a4 = r5;
                i5 = o4;
              }
              a4.nextZ = null, n6 *= 2;
            } while (t7 > 1);
          })(i4);
        })(e6, r3, i3, a3);
        let s3 = e6;
        for (; e6.prev !== e6.next; ) {
          let c3 = e6.prev, l3 = e6.next;
          if (a3 ? Pc(e6, r3, i3, a3) : Nc(e6)) t5.push(c3.i, e6.i, l3.i), $c(e6), e6 = l3.next, s3 = l3.next;
          else if ((e6 = l3) === s3) {
            o3 ? o3 === 1 ? Mc(e6 = Fc(jc(e6), t5), t5, n4, r3, i3, a3, 2) : o3 === 2 && Ic(e6, t5, n4, r3, i3, a3) : Mc(jc(e6), t5, n4, r3, i3, a3, 1);
            break;
          }
        }
      }
      function Nc(e6) {
        let t5 = e6.prev, n4 = e6, r3 = e6.next;
        if (Gc(t5, n4, r3) >= 0) return false;
        let i3 = t5.x, a3 = n4.x, o3 = r3.x, s3 = t5.y, c3 = n4.y, l3 = r3.y, u3 = Math.min(i3, a3, o3), d3 = Math.min(s3, c3, l3), f3 = Math.max(i3, a3, o3), p3 = Math.max(s3, c3, l3), m3 = r3.next;
        for (; m3 !== t5; ) {
          if (m3.x >= u3 && m3.x <= f3 && m3.y >= d3 && m3.y <= p3 && Uc(i3, s3, a3, c3, o3, l3, m3.x, m3.y) && Gc(m3.prev, m3, m3.next) >= 0) return false;
          m3 = m3.next;
        }
        return true;
      }
      function Pc(e6, t5, n4, r3) {
        let i3 = e6.prev, a3 = e6, o3 = e6.next;
        if (Gc(i3, a3, o3) >= 0) return false;
        let s3 = i3.x, c3 = a3.x, l3 = o3.x, u3 = i3.y, d3 = a3.y, f3 = o3.y, p3 = Math.min(s3, c3, l3), m3 = Math.min(u3, d3, f3), h3 = Math.max(s3, c3, l3), g3 = Math.max(u3, d3, f3), _3 = Bc(p3, m3, t5, n4, r3), v3 = Bc(h3, g3, t5, n4, r3), y3 = e6.prevZ, b3 = e6.nextZ;
        for (; y3 && y3.z >= _3 && b3 && b3.z <= v3; ) {
          if (y3.x >= p3 && y3.x <= h3 && y3.y >= m3 && y3.y <= g3 && y3 !== i3 && y3 !== o3 && Uc(s3, u3, c3, d3, l3, f3, y3.x, y3.y) && Gc(y3.prev, y3, y3.next) >= 0 || (y3 = y3.prevZ, b3.x >= p3 && b3.x <= h3 && b3.y >= m3 && b3.y <= g3 && b3 !== i3 && b3 !== o3 && Uc(s3, u3, c3, d3, l3, f3, b3.x, b3.y) && Gc(b3.prev, b3, b3.next) >= 0)) return false;
          b3 = b3.nextZ;
        }
        for (; y3 && y3.z >= _3; ) {
          if (y3.x >= p3 && y3.x <= h3 && y3.y >= m3 && y3.y <= g3 && y3 !== i3 && y3 !== o3 && Uc(s3, u3, c3, d3, l3, f3, y3.x, y3.y) && Gc(y3.prev, y3, y3.next) >= 0) return false;
          y3 = y3.prevZ;
        }
        for (; b3 && b3.z <= v3; ) {
          if (b3.x >= p3 && b3.x <= h3 && b3.y >= m3 && b3.y <= g3 && b3 !== i3 && b3 !== o3 && Uc(s3, u3, c3, d3, l3, f3, b3.x, b3.y) && Gc(b3.prev, b3, b3.next) >= 0) return false;
          b3 = b3.nextZ;
        }
        return true;
      }
      function Fc(e6, t5) {
        let n4 = e6;
        do {
          let r3 = n4.prev, i3 = n4.next.next;
          !Kc(r3, i3) && qc(r3, n4, n4.next, i3) && Xc(r3, i3) && Xc(i3, r3) && (t5.push(r3.i, n4.i, i3.i), $c(n4), $c(n4.next), n4 = e6 = i3), n4 = n4.next;
        } while (n4 !== e6);
        return jc(n4);
      }
      function Ic(e6, t5, n4, r3, i3, a3) {
        let o3 = e6;
        do {
          let e7 = o3.next.next;
          for (; e7 !== o3.prev; ) {
            if (o3.i !== e7.i && Wc(o3, e7)) {
              let s3 = Zc(o3, e7);
              o3 = jc(o3, o3.next), s3 = jc(s3, s3.next), Mc(o3, t5, n4, r3, i3, a3, 0), Mc(s3, t5, n4, r3, i3, a3, 0);
              return;
            }
            e7 = e7.next;
          }
          o3 = o3.next;
        } while (o3 !== e6);
      }
      function Lc(e6, t5) {
        let n4 = e6.x - t5.x;
        return n4 === 0 && (n4 = e6.y - t5.y, n4 === 0) && (n4 = (e6.next.y - e6.y) / (e6.next.x - e6.x) - (t5.next.y - t5.y) / (t5.next.x - t5.x)), n4;
      }
      function Rc(e6, t5) {
        let n4 = (function(e7, t6) {
          let n5 = t6, r4 = e7.x, i3 = e7.y, a3, o3 = -1 / 0;
          if (Kc(e7, n5)) return n5;
          do {
            if (Kc(e7, n5.next)) return n5.next;
            if (i3 <= n5.y && i3 >= n5.next.y && n5.next.y !== n5.y) {
              let e8 = n5.x + (i3 - n5.y) * (n5.next.x - n5.x) / (n5.next.y - n5.y);
              if (e8 <= r4 && e8 > o3 && (o3 = e8, a3 = n5.x < n5.next.x ? n5 : n5.next, e8 === r4)) return a3;
            }
            n5 = n5.next;
          } while (n5 !== t6);
          if (!a3) return null;
          let s3 = a3, c3 = a3.x, l3 = a3.y, u3 = 1 / 0;
          n5 = a3;
          do {
            if (r4 >= n5.x && n5.x >= c3 && r4 !== n5.x && Hc(i3 < l3 ? r4 : o3, i3, c3, l3, i3 < l3 ? o3 : r4, i3, n5.x, n5.y)) {
              let t7 = Math.abs(i3 - n5.y) / (r4 - n5.x);
              Xc(n5, e7) && (t7 < u3 || t7 === u3 && (n5.x > a3.x || n5.x === a3.x && zc(a3, n5))) && (a3 = n5, u3 = t7);
            }
            n5 = n5.next;
          } while (n5 !== s3);
          return a3;
        })(e6, t5);
        if (!n4) return t5;
        let r3 = Zc(n4, e6);
        return jc(r3, r3.next), jc(n4, n4.next);
      }
      function zc(e6, t5) {
        return Gc(e6.prev, e6, t5.prev) < 0 && Gc(t5.next, e6, e6.next) < 0;
      }
      function Bc(e6, t5, n4, r3, i3) {
        return (e6 = 1431655765 & ((e6 = 858993459 & ((e6 = 252645135 & ((e6 = 16711935 & ((e6 = (e6 - n4) * i3 | 0) | e6 << 8)) | e6 << 4)) | e6 << 2)) | e6 << 1)) | (t5 = 1431655765 & ((t5 = 858993459 & ((t5 = 252645135 & ((t5 = 16711935 & ((t5 = (t5 - r3) * i3 | 0) | t5 << 8)) | t5 << 4)) | t5 << 2)) | t5 << 1)) << 1;
      }
      function Vc(e6) {
        let t5 = e6, n4 = e6;
        do
          (t5.x < n4.x || t5.x === n4.x && t5.y < n4.y) && (n4 = t5), t5 = t5.next;
        while (t5 !== e6);
        return n4;
      }
      function Hc(e6, t5, n4, r3, i3, a3, o3, s3) {
        return (i3 - o3) * (t5 - s3) >= (e6 - o3) * (a3 - s3) && (e6 - o3) * (r3 - s3) >= (n4 - o3) * (t5 - s3) && (n4 - o3) * (a3 - s3) >= (i3 - o3) * (r3 - s3);
      }
      function Uc(e6, t5, n4, r3, i3, a3, o3, s3) {
        return !(e6 === o3 && t5 === s3) && Hc(e6, t5, n4, r3, i3, a3, o3, s3);
      }
      function Wc(e6, t5) {
        return e6.next.i !== t5.i && e6.prev.i !== t5.i && !(function(e7, t6) {
          let n4 = e7;
          do {
            if (n4.i !== e7.i && n4.next.i !== e7.i && n4.i !== t6.i && n4.next.i !== t6.i && qc(n4, n4.next, e7, t6)) return true;
            n4 = n4.next;
          } while (n4 !== e7);
          return false;
        })(e6, t5) && (Xc(e6, t5) && Xc(t5, e6) && (function(e7, t6) {
          let n4 = e7, r3 = false, i3 = (e7.x + t6.x) / 2, a3 = (e7.y + t6.y) / 2;
          do
            n4.y > a3 != n4.next.y > a3 && n4.next.y !== n4.y && i3 < (n4.next.x - n4.x) * (a3 - n4.y) / (n4.next.y - n4.y) + n4.x && (r3 = !r3), n4 = n4.next;
          while (n4 !== e7);
          return r3;
        })(e6, t5) && (Gc(e6.prev, e6, t5.prev) || Gc(e6, t5.prev, t5)) || Kc(e6, t5) && Gc(e6.prev, e6, e6.next) > 0 && Gc(t5.prev, t5, t5.next) > 0);
      }
      function Gc(e6, t5, n4) {
        return (t5.y - e6.y) * (n4.x - t5.x) - (t5.x - e6.x) * (n4.y - t5.y);
      }
      function Kc(e6, t5) {
        return e6.x === t5.x && e6.y === t5.y;
      }
      function qc(e6, t5, n4, r3) {
        let i3 = Yc(Gc(e6, t5, n4)), a3 = Yc(Gc(e6, t5, r3)), o3 = Yc(Gc(n4, r3, e6)), s3 = Yc(Gc(n4, r3, t5));
        return i3 !== a3 && o3 !== s3 || !(i3 !== 0 || !Jc(e6, n4, t5)) || !(a3 !== 0 || !Jc(e6, r3, t5)) || !(o3 !== 0 || !Jc(n4, e6, r3)) || !(s3 !== 0 || !Jc(n4, t5, r3));
      }
      function Jc(e6, t5, n4) {
        return t5.x <= Math.max(e6.x, n4.x) && t5.x >= Math.min(e6.x, n4.x) && t5.y <= Math.max(e6.y, n4.y) && t5.y >= Math.min(e6.y, n4.y);
      }
      function Yc(e6) {
        return e6 > 0 ? 1 : e6 < 0 ? -1 : 0;
      }
      function Xc(e6, t5) {
        return Gc(e6.prev, e6, e6.next) < 0 ? Gc(e6, t5, e6.next) >= 0 && Gc(e6, e6.prev, t5) >= 0 : Gc(e6, t5, e6.prev) < 0 || Gc(e6, e6.next, t5) < 0;
      }
      function Zc(e6, t5) {
        let n4 = el(e6.i, e6.x, e6.y), r3 = el(t5.i, t5.x, t5.y), i3 = e6.next, a3 = t5.prev;
        return e6.next = t5, t5.prev = e6, n4.next = i3, i3.prev = n4, r3.next = n4, n4.prev = r3, a3.next = r3, r3.prev = a3, r3;
      }
      function Qc(e6, t5, n4, r3) {
        let i3 = el(e6, t5, n4);
        return r3 ? (i3.next = r3.next, i3.prev = r3, r3.next.prev = i3, r3.next = i3) : (i3.prev = i3, i3.next = i3), i3;
      }
      function $c(e6) {
        e6.next.prev = e6.prev, e6.prev.next = e6.next, e6.prevZ && (e6.prevZ.nextZ = e6.nextZ), e6.nextZ && (e6.nextZ.prevZ = e6.prevZ);
      }
      function el(e6, t5, n4) {
        return { i: e6, x: t5, y: n4, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
      }
      class tl {
        constructor(e6, t5) {
          if (t5 > e6) throw Error(`Min granularity must not be greater than base granularity.`);
          this._baseZoomGranularity = e6, this._minGranularity = t5;
        }
        getGranularityForZoomLevel(e6) {
          return Math.max(Math.floor(this._baseZoomGranularity / (1 << e6)), this._minGranularity, 1);
        }
      }
      class nl {
        constructor(e6) {
          this.fill = e6.fill, this.line = e6.line, this.tile = e6.tile, this.stencil = e6.stencil, this.circle = e6.circle;
        }
      }
      nl.noSubdivision = new nl({ fill: new tl(0, 0), line: new tl(0, 0), tile: new tl(0, 0), stencil: new tl(0, 0), circle: 1 }), X(`SubdivisionGranularityExpression`, tl), X(`SubdivisionGranularitySetting`, nl);
      let rl = -32768, il = 32767;
      class al {
        constructor(e6, t5) {
          this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = false, this._granularity = e6, this._granularityCellSize = O2 / e6, this._canonical = t5;
        }
        _getKey(e6, t5) {
          return (e6 += 32768) << 16 | t5 + 32768;
        }
        _vertexToIndex(e6, t5) {
          if (e6 < -32768 || t5 < -32768 || e6 > 32767 || t5 > 32767) throw Error(`Vertex coordinates are out of signed 16 bit integer range.`);
          let n4 = 0 | Math.round(e6), r3 = 0 | Math.round(t5), i3 = this._getKey(n4, r3);
          if (this._vertexDictionary.has(i3)) return this._vertexDictionary.get(i3);
          let a3 = this._vertexBuffer.length / 2;
          return this._vertexDictionary.set(i3, a3), this._vertexBuffer.push(n4, r3), a3;
        }
        _subdivideTrianglesScanline(e6) {
          if (this._granularity < 2) return (function(e7, t6) {
            let n5 = [];
            for (let r3 = 0; r3 < t6.length; r3 += 3) {
              let i3 = t6[r3], a3 = t6[r3 + 1], o3 = t6[r3 + 2], s3 = e7[2 * i3], c3 = e7[2 * i3 + 1];
              (e7[2 * a3] - s3) * (e7[2 * o3 + 1] - c3) - (e7[2 * a3 + 1] - c3) * (e7[2 * o3] - s3) > 0 ? (n5.push(i3), n5.push(o3), n5.push(a3)) : (n5.push(i3), n5.push(a3), n5.push(o3));
            }
            return n5;
          })(this._vertexBuffer, e6);
          let t5 = [], n4 = e6.length;
          for (let r3 = 0; r3 < n4; r3 += 3) {
            let n5 = [e6[r3 + 0], e6[r3 + 1], e6[r3 + 2]], i3 = [this._vertexBuffer[2 * e6[r3 + 0] + 0], this._vertexBuffer[2 * e6[r3 + 0] + 1], this._vertexBuffer[2 * e6[r3 + 1] + 0], this._vertexBuffer[2 * e6[r3 + 1] + 1], this._vertexBuffer[2 * e6[r3 + 2] + 0], this._vertexBuffer[2 * e6[r3 + 2] + 1]], a3 = 1 / 0, o3 = 1 / 0, s3 = -1 / 0, c3 = -1 / 0;
            for (let e7 = 0; e7 < 3; e7++) {
              let t6 = i3[2 * e7], n6 = i3[2 * e7 + 1];
              a3 = Math.min(a3, t6), s3 = Math.max(s3, t6), o3 = Math.min(o3, n6), c3 = Math.max(c3, n6);
            }
            if (a3 === s3 || o3 === c3) continue;
            let l3 = Math.floor(a3 / this._granularityCellSize), u3 = Math.ceil(s3 / this._granularityCellSize), d3 = Math.floor(o3 / this._granularityCellSize), f3 = Math.ceil(c3 / this._granularityCellSize);
            if (l3 !== u3 || d3 !== f3) for (let e7 = d3; e7 < f3; e7++) {
              let r4 = this._scanlineGenerateVertexRingForCellRow(e7, i3, n5);
              cl(this._vertexBuffer, r4, t5);
            }
            else t5.push(...n5);
          }
          return t5;
        }
        _scanlineGenerateVertexRingForCellRow(e6, t5, n4) {
          let r3 = e6 * this._granularityCellSize, i3 = r3 + this._granularityCellSize, a3 = [];
          for (let e7 = 0; e7 < 3; e7++) {
            let o3 = t5[2 * e7], s3 = t5[2 * e7 + 1], c3 = t5[2 * (e7 + 1) % 6], l3 = t5[(2 * (e7 + 1) + 1) % 6], u3 = t5[2 * (e7 + 2) % 6], d3 = t5[(2 * (e7 + 2) + 1) % 6], f3 = c3 - o3, p3 = l3 - s3, m3 = f3 === 0, h3 = p3 === 0, g3 = (r3 - s3) / p3, _3 = (i3 - s3) / p3, v3 = Math.min(g3, _3), y3 = Math.max(g3, _3);
            if (!h3 && (v3 >= 1 || y3 <= 0) || h3 && (s3 < r3 || s3 > i3)) {
              l3 >= r3 && l3 <= i3 && a3.push(n4[(e7 + 1) % 3]);
              continue;
            }
            !h3 && v3 > 0 && a3.push(this._vertexToIndex(o3 + f3 * v3, s3 + p3 * v3));
            let b3 = o3 + f3 * Math.max(v3, 0), x3 = o3 + f3 * Math.min(y3, 1);
            m3 || this._generateIntraEdgeVertices(a3, o3, s3, c3, l3, b3, x3), !h3 && y3 < 1 && a3.push(this._vertexToIndex(o3 + f3 * y3, s3 + p3 * y3)), (h3 || l3 >= r3 && l3 <= i3) && a3.push(n4[(e7 + 1) % 3]), !h3 && (l3 <= r3 || l3 >= i3) && this._generateInterEdgeVertices(a3, o3, s3, c3, l3, u3, d3, x3, r3, i3);
          }
          return a3;
        }
        _generateIntraEdgeVertices(e6, t5, n4, r3, i3, a3, o3) {
          let s3 = r3 - t5, c3 = i3 - n4, l3 = c3 === 0, u3 = l3 ? Math.min(t5, r3) : Math.min(a3, o3), d3 = l3 ? Math.max(t5, r3) : Math.max(a3, o3), f3 = Math.floor(u3 / this._granularityCellSize) + 1, p3 = Math.ceil(d3 / this._granularityCellSize) - 1;
          if (l3 ? t5 < r3 : a3 < o3) for (let r4 = f3; r4 <= p3; r4++) {
            let i4 = r4 * this._granularityCellSize;
            e6.push(this._vertexToIndex(i4, n4 + c3 * (i4 - t5) / s3));
          }
          else for (let r4 = p3; r4 >= f3; r4--) {
            let i4 = r4 * this._granularityCellSize;
            e6.push(this._vertexToIndex(i4, n4 + c3 * (i4 - t5) / s3));
          }
        }
        _generateInterEdgeVertices(e6, t5, n4, r3, i3, a3, o3, s3, c3, l3) {
          let u3 = i3 - n4, d3 = a3 - r3, f3 = o3 - i3, p3 = (c3 - i3) / f3, m3 = (l3 - i3) / f3, h3 = Math.min(p3, m3), g3 = Math.max(p3, m3), _3 = r3 + d3 * h3, v3 = Math.floor(Math.min(_3, s3) / this._granularityCellSize) + 1, y3 = Math.ceil(Math.max(_3, s3) / this._granularityCellSize) - 1, b3 = s3 < _3, x3 = f3 === 0;
          if (x3 && (o3 === c3 || o3 === l3)) return;
          if (x3 || h3 >= 1 || g3 <= 0) {
            let e7 = n4 - o3, r4 = a3 + (t5 - a3) * Math.min((c3 - o3) / e7, (l3 - o3) / e7);
            v3 = Math.floor(Math.min(r4, s3) / this._granularityCellSize) + 1, y3 = Math.ceil(Math.max(r4, s3) / this._granularityCellSize) - 1, b3 = s3 < r4;
          }
          let S3 = u3 > 0 ? l3 : c3;
          if (b3) for (let t6 = v3; t6 <= y3; t6++) e6.push(this._vertexToIndex(t6 * this._granularityCellSize, S3));
          else for (let t6 = y3; t6 >= v3; t6--) e6.push(this._vertexToIndex(t6 * this._granularityCellSize, S3));
        }
        _generateOutline(e6) {
          let t5 = [];
          for (let n4 of e6) {
            let e7 = sl(n4, this._granularity, true), r3 = this._pointArrayToIndices(e7), i3 = [];
            for (let e8 = 1; e8 < r3.length; e8++) i3.push(r3[e8 - 1]), i3.push(r3[e8]);
            t5.push(i3);
          }
          return t5;
        }
        _handlePoles(e6) {
          let t5 = false, n4 = false;
          this._canonical && (this._canonical.y === 0 && (t5 = true), this._canonical.y === (1 << this._canonical.z) - 1 && (n4 = true)), (t5 || n4) && this._fillPoles(e6, t5, n4);
        }
        _ensureNoPoleVertices() {
          let e6 = this._vertexBuffer;
          for (let t5 = 0; t5 < e6.length; t5 += 2) {
            let n4 = e6[t5 + 1];
            n4 === rl && (e6[t5 + 1] = -32767), n4 === il && (e6[t5 + 1] = 32766);
          }
        }
        _generatePoleQuad(e6, t5, n4, r3, i3, a3) {
          r3 > i3 == (a3 === rl) ? (e6.push(n4), e6.push(t5), e6.push(this._vertexToIndex(r3, a3)), e6.push(this._vertexToIndex(i3, a3)), e6.push(n4), e6.push(this._vertexToIndex(r3, a3))) : (e6.push(t5), e6.push(n4), e6.push(this._vertexToIndex(r3, a3)), e6.push(n4), e6.push(this._vertexToIndex(i3, a3)), e6.push(this._vertexToIndex(r3, a3)));
        }
        _fillPoles(e6, t5, n4) {
          let r3 = this._vertexBuffer, i3 = O2, a3 = e6.length;
          for (let o3 = 2; o3 < a3; o3 += 3) {
            let a4 = e6[o3 - 2], s3 = e6[o3 - 1], c3 = e6[o3], l3 = r3[2 * a4], u3 = r3[2 * a4 + 1], d3 = r3[2 * s3], f3 = r3[2 * s3 + 1], p3 = r3[2 * c3], m3 = r3[2 * c3 + 1];
            t5 && (u3 === 0 && f3 === 0 && this._generatePoleQuad(e6, a4, s3, l3, d3, rl), f3 === 0 && m3 === 0 && this._generatePoleQuad(e6, s3, c3, d3, p3, rl), m3 === 0 && u3 === 0 && this._generatePoleQuad(e6, c3, a4, p3, l3, rl)), n4 && (u3 === i3 && f3 === i3 && this._generatePoleQuad(e6, a4, s3, l3, d3, il), f3 === i3 && m3 === i3 && this._generatePoleQuad(e6, s3, c3, d3, p3, il), m3 === i3 && u3 === i3 && this._generatePoleQuad(e6, c3, a4, p3, l3, il));
          }
        }
        _initializeVertices(e6) {
          for (let t5 = 0; t5 < e6.length; t5 += 2) this._vertexToIndex(e6[t5], e6[t5 + 1]);
        }
        subdividePolygonInternal(e6, t5) {
          if (this._used) throw Error(`Subdivision: multiple use not allowed.`);
          this._used = true;
          let { flattened: n4, holeIndices: r3 } = (function(e7) {
            let t6 = [], n5 = [];
            for (let r4 of e7) if (r4.length !== 0) {
              r4 !== e7[0] && t6.push(n5.length / 2);
              for (let e8 = 0; e8 < r4.length; e8++) n5.push(r4[e8].x), n5.push(r4[e8].y);
            }
            return { flattened: n5, holeIndices: t6 };
          })(e6), i3;
          this._initializeVertices(n4);
          try {
            let e7 = (function(e8, t7, n5 = 2) {
              let r4 = t7 && t7.length, i4 = r4 ? t7[0] * n5 : e8.length, a4 = Ac(e8, 0, i4, n5, true), o3 = [];
              if (!a4 || a4.next === a4.prev) return o3;
              let s3, c3, l3;
              if (r4 && (a4 = (function(e9, t8, n6, r5) {
                let i5 = [];
                for (let n7 = 0, a5 = t8.length; n7 < a5; n7++) {
                  let o4 = Ac(e9, t8[n7] * r5, n7 < a5 - 1 ? t8[n7 + 1] * r5 : e9.length, r5, false);
                  o4 === o4.next && (o4.steiner = true), i5.push(Vc(o4));
                }
                i5.sort(Lc);
                for (let e10 = 0; e10 < i5.length; e10++) n6 = Rc(i5[e10], n6);
                return n6;
              })(e8, t7, a4, n5)), e8.length > 80 * n5) {
                s3 = e8[0], c3 = e8[1];
                let t8 = s3, r5 = c3;
                for (let a5 = n5; a5 < i4; a5 += n5) {
                  let n6 = e8[a5], i5 = e8[a5 + 1];
                  n6 < s3 && (s3 = n6), i5 < c3 && (c3 = i5), n6 > t8 && (t8 = n6), i5 > r5 && (r5 = i5);
                }
                l3 = Math.max(t8 - s3, r5 - c3), l3 = l3 === 0 ? 0 : 32767 / l3;
              }
              return Mc(a4, o3, n5, s3, c3, l3, 0), o3;
            })(n4, r3), t6 = this._convertIndices(n4, e7);
            i3 = this._subdivideTrianglesScanline(t6);
          } catch (e7) {
            console.error(e7);
          }
          let a3 = [];
          return t5 && (a3 = this._generateOutline(e6)), this._ensureNoPoleVertices(), this._handlePoles(i3), { verticesFlattened: this._vertexBuffer, indicesTriangles: i3, indicesLineList: a3 };
        }
        _convertIndices(e6, t5) {
          let n4 = [];
          for (let r3 = 0; r3 < t5.length; r3++) n4.push(this._vertexToIndex(e6[2 * t5[r3]], e6[2 * t5[r3] + 1]));
          return n4;
        }
        _pointArrayToIndices(e6) {
          let t5 = [];
          for (let n4 = 0; n4 < e6.length; n4++) {
            let r3 = e6[n4];
            t5.push(this._vertexToIndex(r3.x, r3.y));
          }
          return t5;
        }
      }
      function ol(e6, t5, n4, r3 = true) {
        return new al(n4, t5).subdividePolygonInternal(e6, r3);
      }
      function sl(e6, t5, r3 = false) {
        if (!e6 || e6.length < 1 || e6.length < 2) return [];
        let i3 = e6[0], a3 = e6[e6.length - 1], o3 = r3 && (i3.x !== a3.x || i3.y !== a3.y);
        if (t5 < 2) return o3 ? [...e6, e6[0]] : [...e6];
        let s3 = Math.floor(O2 / t5), c3 = [];
        c3.push(new n3(e6[0].x, e6[0].y));
        let l3 = e6.length, u3 = o3 ? l3 : l3 - 1;
        for (let t6 = 0; t6 < u3; t6++) {
          let r4 = e6[t6], i4 = t6 < l3 - 1 ? e6[t6 + 1] : e6[0], a4 = r4.x, o4 = r4.y, u4 = i4.x, d3 = i4.y, f3 = a4 !== u4, p3 = o4 !== d3;
          if (!f3 && !p3) continue;
          let m3 = u4 - a4, h3 = d3 - o4, g3 = Math.abs(m3), _3 = Math.abs(h3), v3 = a4, y3 = o4;
          for (; ; ) {
            let e7 = m3 > 0 ? (Math.floor(v3 / s3) + 1) * s3 : (Math.ceil(v3 / s3) - 1) * s3, t7 = h3 > 0 ? (Math.floor(y3 / s3) + 1) * s3 : (Math.ceil(y3 / s3) - 1) * s3, r5 = Math.abs(v3 - e7), i5 = Math.abs(y3 - t7), a5 = Math.abs(v3 - u4), o5 = Math.abs(y3 - d3), l4 = f3 ? r5 / g3 : 1 / 0, b4 = p3 ? i5 / _3 : 1 / 0;
            if ((a5 <= r5 || !f3) && (o5 <= i5 || !p3)) break;
            if (l4 < b4 && f3 || !p3) {
              v3 = e7, y3 += h3 * l4;
              let t8 = new n3(v3, Math.round(y3));
              c3[c3.length - 1].x === t8.x && c3[c3.length - 1].y === t8.y || c3.push(t8);
            } else {
              v3 += m3 * b4, y3 = t7;
              let e8 = new n3(Math.round(v3), y3);
              c3[c3.length - 1].x === e8.x && c3[c3.length - 1].y === e8.y || c3.push(e8);
            }
          }
          let b3 = new n3(u4, d3);
          c3[c3.length - 1].x === b3.x && c3[c3.length - 1].y === b3.y || c3.push(b3);
        }
        return c3;
      }
      function cl(e6, t5, n4) {
        if (t5.length === 0) throw Error(`Subdivision vertex ring is empty.`);
        let r3 = 0, i3 = e6[2 * t5[0]];
        for (let n5 = 1; n5 < t5.length; n5++) {
          let a4 = e6[2 * t5[n5]];
          a4 < i3 && (i3 = a4, r3 = n5);
        }
        let a3 = t5.length, o3 = r3, s3 = (o3 + 1) % a3;
        for (; ; ) {
          let r4 = o3 - 1 >= 0 ? o3 - 1 : a3 - 1, i4 = (s3 + 1) % a3, c3 = e6[2 * t5[r4]], l3 = e6[2 * t5[i4]], u3 = e6[2 * t5[o3]], d3 = e6[2 * t5[o3] + 1], f3 = e6[2 * t5[s3] + 1], p3 = false;
          if (c3 < l3) p3 = true;
          else if (c3 > l3) p3 = false;
          else {
            let n5 = f3 - d3, a4 = -(e6[2 * t5[s3]] - u3), o4 = d3 < f3 ? 1 : -1;
            ((c3 - u3) * n5 + (e6[2 * t5[r4] + 1] - d3) * a4) * o4 > ((l3 - u3) * n5 + (e6[2 * t5[i4] + 1] - d3) * a4) * o4 && (p3 = true);
          }
          if (p3) {
            let e7 = t5[r4], i5 = t5[o3], c4 = t5[s3];
            e7 !== i5 && e7 !== c4 && i5 !== c4 && n4.push(c4, i5, e7), o3--, o3 < 0 && (o3 = a3 - 1);
          } else {
            let e7 = t5[i4], r5 = t5[o3], c4 = t5[s3];
            e7 !== r5 && e7 !== c4 && r5 !== c4 && n4.push(c4, r5, e7), s3++, s3 >= a3 && (s3 = 0);
          }
          if (r4 === i4) break;
        }
      }
      function ll(e6, t5, n4, r3, i3, a3, o3, s3, c3) {
        let l3 = i3.length / 2, u3 = o3 && s3 && c3;
        if (l3 < Qo.MAX_VERTEX_ARRAY_LENGTH) {
          let d3 = t5.prepareSegment(l3, n4, r3), f3 = d3.vertexLength;
          for (let e7 = 0; e7 < a3.length; e7 += 3) r3.emplaceBack(f3 + a3[e7], f3 + a3[e7 + 1], f3 + a3[e7 + 2]);
          let p3, m3;
          d3.vertexLength += l3, d3.primitiveLength += a3.length / 3, u3 && (m3 = o3.prepareSegment(l3, n4, s3), p3 = m3.vertexLength, m3.vertexLength += l3);
          for (let t6 = 0; t6 < i3.length; t6 += 2) e6(i3[t6], i3[t6 + 1]);
          if (u3) for (let e7 = 0; e7 < c3.length; e7++) {
            let t6 = c3[e7];
            for (let e8 = 1; e8 < t6.length; e8 += 2) s3.emplaceBack(p3 + t6[e8 - 1], p3 + t6[e8]);
            m3.primitiveLength += t6.length / 2;
          }
        } else (function(e7, t6, n5, r4, i4, a4) {
          let o4 = [];
          for (let e8 = 0; e8 < r4.length / 2; e8++) o4.push(-1);
          let s4 = { count: 0 }, c4 = 0, l4 = e7.getOrCreateLatestSegment(t6, n5), u4 = l4.vertexLength;
          for (let d3 = 2; d3 < i4.length; d3 += 3) {
            let f3 = i4[d3 - 2], p3 = i4[d3 - 1], m3 = i4[d3], h3 = o4[f3] < c4, g3 = o4[p3] < c4, _3 = o4[m3] < c4;
            l4.vertexLength + ((h3 ? 1 : 0) + (g3 ? 1 : 0) + (_3 ? 1 : 0)) > Qo.MAX_VERTEX_ARRAY_LENGTH && (l4 = e7.createNewSegment(t6, n5), c4 = s4.count, h3 = true, g3 = true, _3 = true, u4 = 0);
            let v3 = ul(o4, r4, a4, s4, f3, h3, l4), y3 = ul(o4, r4, a4, s4, p3, g3, l4), b3 = ul(o4, r4, a4, s4, m3, _3, l4);
            n5.emplaceBack(u4 + v3 - c4, u4 + y3 - c4, u4 + b3 - c4), l4.primitiveLength++;
          }
        })(t5, n4, r3, i3, a3, e6), u3 && (function(e7, t6, n5, r4, i4, a4) {
          let o4 = [];
          for (let e8 = 0; e8 < r4.length / 2; e8++) o4.push(-1);
          let s4 = { count: 0 }, c4 = 0, l4 = e7.getOrCreateLatestSegment(t6, n5), u4 = l4.vertexLength;
          for (let d3 = 0; d3 < i4.length; d3++) {
            let f3 = i4[d3];
            for (let p3 = 1; p3 < i4[d3].length; p3 += 2) {
              let i5 = f3[p3 - 1], d4 = f3[p3], m3 = o4[i5] < c4, h3 = o4[d4] < c4;
              l4.vertexLength + ((m3 ? 1 : 0) + (h3 ? 1 : 0)) > Qo.MAX_VERTEX_ARRAY_LENGTH && (l4 = e7.createNewSegment(t6, n5), c4 = s4.count, m3 = true, h3 = true, u4 = 0);
              let g3 = ul(o4, r4, a4, s4, i5, m3, l4), _3 = ul(o4, r4, a4, s4, d4, h3, l4);
              n5.emplaceBack(u4 + g3 - c4, u4 + _3 - c4), l4.primitiveLength++;
            }
          }
        })(o3, n4, s3, i3, c3, e6), t5.forceNewSegmentOnNextPrepare(), o3 == null ? void 0 : o3.forceNewSegmentOnNextPrepare();
      }
      function ul(e6, t5, n4, r3, i3, a3, o3) {
        if (a3) {
          let a4 = r3.count;
          return n4(t5[2 * i3], t5[2 * i3 + 1]), e6[i3] = r3.count, r3.count++, o3.vertexLength++, a4;
        }
        return e6[i3];
      }
      class dl {
        constructor(e6) {
          this.zoom = e6.zoom, this.overscaling = e6.overscaling, this.layers = e6.layers, this.layerIds = this.layers.map(((e7) => e7.id)), this.index = e6.index, this.hasDependencies = false, this.patternFeatures = [], this.layoutVertexArray = new Ro(), this.indexArray = new Yo(), this.indexArray2 = new Xo(), this.programConfigurations = new Ds(e6.layers, e6.zoom), this.segments = new Qo(), this.segments2 = new Qo(), this.stateDependentLayerIds = this.layers.filter(((e7) => e7.isStateDependent())).map(((e7) => e7.id));
        }
        populate(e6, t5, n4) {
          this.hasDependencies = Oc(`fill`, this.layers, t5);
          let r3 = this.layers[0].layout.get(`fill-sort-key`), i3 = !r3.isConstant(), a3 = [];
          for (let { feature: o3, id: s3, index: c3, sourceLayerIndex: l3 } of e6) {
            let e7 = this.layers[0]._featureFilter.needGeometry, u3 = Ns(o3, e7);
            if (!this.layers[0]._featureFilter.filter(new ka(this.zoom), u3, n4)) continue;
            let d3 = i3 ? r3.evaluate(u3, {}, n4, t5.availableImages) : void 0, f3 = { id: s3, properties: o3.properties, type: o3.type, sourceLayerIndex: l3, index: c3, geometry: e7 ? u3.geometry : Ms(o3), patterns: {}, sortKey: d3 };
            a3.push(f3);
          }
          i3 && a3.sort(((e7, t6) => e7.sortKey - t6.sortKey));
          for (let r4 of a3) {
            let { geometry: i4, index: a4, sourceLayerIndex: o3 } = r4;
            if (this.hasDependencies) {
              let e7 = kc(`fill`, this.layers, r4, { zoom: this.zoom }, t5);
              this.patternFeatures.push(e7);
            } else this.addFeature(r4, i4, a4, n4, {}, t5.subdivisionGranularity);
            t5.featureIndex.insert(e6[a4].feature, i4, a4, o3, this.index);
          }
        }
        update(e6, t5, n4) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e6, t5, this.stateDependentLayers, { imagePositions: n4 });
        }
        addFeatures(e6, t5, n4) {
          for (let r3 of this.patternFeatures) this.addFeature(r3, r3.geometry, r3.index, t5, n4, e6.subdivisionGranularity);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e6) {
          this.uploaded || (this.layoutVertexBuffer = e6.createVertexBuffer(this.layoutVertexArray, Dc), this.indexBuffer = e6.createIndexBuffer(this.indexArray), this.indexBuffer2 = e6.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e6), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(e6, t5, n4, r3, i3, a3) {
          for (let e7 of rr(t5, 500)) {
            let t6 = ol(e7, r3, a3.fill.getGranularityForZoomLevel(r3.z)), n5 = this.layoutVertexArray;
            ll(((e8, t7) => {
              n5.emplaceBack(e8, t7);
            }), this.segments, this.layoutVertexArray, this.indexArray, t6.verticesFlattened, t6.indicesTriangles, this.segments2, this.indexArray2, t6.indicesLineList);
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e6, n4, { imagePositions: i3, canonical: r3 });
        }
      }
      let fl, pl;
      X(`FillBucket`, dl, { omit: [`layers`, `patternFeatures`] });
      var ml = { get paint() {
        return pl || (pl = new Ha({ "fill-antialias": new Q(R2.paint_fill[`fill-antialias`]), "fill-opacity": new $(R2.paint_fill[`fill-opacity`]), "fill-color": new $(R2.paint_fill[`fill-color`]), "fill-outline-color": new $(R2.paint_fill[`fill-outline-color`]), "fill-translate": new Q(R2.paint_fill[`fill-translate`]), "fill-translate-anchor": new Q(R2.paint_fill[`fill-translate-anchor`]), "fill-pattern": new za(R2.paint_fill[`fill-pattern`]) }));
      }, get layout() {
        return fl || (fl = new Ha({ "fill-sort-key": new $(R2.layout_fill[`fill-sort-key`]) }));
      } };
      class hl extends Wa {
        constructor(e6, t5) {
          super(e6, ml, t5);
        }
        recalculate(e6, t5) {
          super.recalculate(e6, t5);
          let n4 = this.paint._values[`fill-outline-color`];
          n4.value.kind === `constant` && n4.value.value === void 0 && (this.paint._values[`fill-outline-color`] = this.paint._values[`fill-color`]);
        }
        createBucket(e6) {
          return new dl(e6);
        }
        queryRadius() {
          return Ys(this.paint.get(`fill-translate`));
        }
        queryIntersectsFeature({ queryGeometry: e6, geometry: t5, transform: n4, pixelsToTileUnits: r3 }) {
          return zs(Xs(e6, this.paint.get(`fill-translate`), this.paint.get(`fill-translate-anchor`), -n4.bearingInRadians, r3), t5);
        }
        isTileClipped() {
          return true;
        }
      }
      let gl = Za([{ name: `a_pos`, components: 2, type: `Int16` }, { name: `a_normal_ed`, components: 4, type: `Int16` }], 4), _l = Za([{ name: `a_centroid`, components: 2, type: `Int16` }], 4), { members: vl } = gl;
      class yl {
        constructor(e6, t5, n4, r3, i3) {
          this.properties = {}, this.extent = n4, this.type = 0, this.id = void 0, this._pbf = e6, this._geometry = -1, this._keys = r3, this._values = i3, e6.readFields(bl, this, t5);
        }
        loadGeometry() {
          let e6 = this._pbf;
          e6.pos = this._geometry;
          let t5 = e6.readVarint() + e6.pos, r3 = [], i3, a3 = 1, o3 = 0, s3 = 0, c3 = 0;
          for (; e6.pos < t5; ) {
            if (o3 <= 0) {
              let t6 = e6.readVarint();
              a3 = 7 & t6, o3 = t6 >> 3;
            }
            if (o3--, a3 === 1 || a3 === 2) s3 += e6.readSVarint(), c3 += e6.readSVarint(), a3 === 1 && (i3 && r3.push(i3), i3 = []), i3 && i3.push(new n3(s3, c3));
            else {
              if (a3 !== 7) throw Error(`unknown command ${a3}`);
              i3 && i3.push(i3[0].clone());
            }
          }
          return i3 && r3.push(i3), r3;
        }
        bbox() {
          let e6 = this._pbf;
          e6.pos = this._geometry;
          let t5 = e6.readVarint() + e6.pos, n4 = 1, r3 = 0, i3 = 0, a3 = 0, o3 = 1 / 0, s3 = -1 / 0, c3 = 1 / 0, l3 = -1 / 0;
          for (; e6.pos < t5; ) {
            if (r3 <= 0) {
              let t6 = e6.readVarint();
              n4 = 7 & t6, r3 = t6 >> 3;
            }
            if (r3--, n4 === 1 || n4 === 2) i3 += e6.readSVarint(), a3 += e6.readSVarint(), i3 < o3 && (o3 = i3), i3 > s3 && (s3 = i3), a3 < c3 && (c3 = a3), a3 > l3 && (l3 = a3);
            else if (n4 !== 7) throw Error(`unknown command ${n4}`);
          }
          return [o3, c3, s3, l3];
        }
        toGeoJSON(e6, t5, n4) {
          let r3 = this.extent * 2 ** n4, i3 = this.extent * e6, a3 = this.extent * t5, o3 = this.loadGeometry();
          function s3(e7) {
            return [360 * (e7.x + i3) / r3 - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (e7.y + a3) / r3) * Math.PI)) - 90];
          }
          function c3(e7) {
            return e7.map(s3);
          }
          let l3;
          if (this.type === 1) {
            let e7 = [];
            for (let t7 of o3) e7.push(t7[0]);
            let t6 = c3(e7);
            l3 = e7.length === 1 ? { type: `Point`, coordinates: t6[0] } : { type: `MultiPoint`, coordinates: t6 };
          } else if (this.type === 2) {
            let e7 = o3.map(c3);
            l3 = e7.length === 1 ? { type: `LineString`, coordinates: e7[0] } : { type: `MultiLineString`, coordinates: e7 };
          } else {
            if (this.type !== 3) throw Error(`unknown feature type`);
            {
              let e7 = (function(e8) {
                let t7 = e8.length;
                if (t7 <= 1) return [e8];
                let n5 = [], r4, i4;
                for (let a4 = 0; a4 < t7; a4++) {
                  let t8 = xl(e8[a4]);
                  t8 !== 0 && (i4 === void 0 && (i4 = t8 < 0), i4 === t8 < 0 ? (r4 && n5.push(r4), r4 = [e8[a4]]) : r4 && r4.push(e8[a4]));
                }
                return r4 && n5.push(r4), n5;
              })(o3), t6 = [];
              for (let n5 of e7) t6.push(n5.map(c3));
              l3 = t6.length === 1 ? { type: `Polygon`, coordinates: t6[0] } : { type: `MultiPolygon`, coordinates: t6 };
            }
          }
          let u3 = { type: `Feature`, geometry: l3, properties: this.properties };
          return this.id != null && (u3.id = this.id), u3;
        }
      }
      function bl(e6, t5, n4) {
        e6 === 1 ? t5.id = n4.readVarint() : e6 === 2 ? (function(e7, t6) {
          let n5 = e7.readVarint() + e7.pos;
          for (; e7.pos < n5; ) {
            let n6 = t6._keys[e7.readVarint()], r3 = t6._values[e7.readVarint()];
            t6.properties[n6] = r3;
          }
        })(n4, t5) : e6 === 3 ? t5.type = n4.readVarint() : e6 === 4 && (t5._geometry = n4.pos);
      }
      function xl(e6) {
        let t5 = 0;
        for (let n4, r3, i3 = 0, a3 = e6.length, o3 = a3 - 1; i3 < a3; o3 = i3++) n4 = e6[i3], r3 = e6[o3], t5 += (r3.x - n4.x) * (n4.y + r3.y);
        return t5;
      }
      yl.types = [`Unknown`, `Point`, `LineString`, `Polygon`];
      class Sl {
        constructor(e6, t5) {
          this.version = 1, this.name = ``, this.extent = 4096, this.length = 0, this._pbf = e6, this._keys = [], this._values = [], this._features = [], e6.readFields(Cl, this, t5), this.length = this._features.length;
        }
        feature(e6) {
          if (e6 < 0 || e6 >= this._features.length) throw Error(`feature index out of bounds`);
          this._pbf.pos = this._features[e6];
          let t5 = this._pbf.readVarint() + this._pbf.pos;
          return new yl(this._pbf, t5, this.extent, this._keys, this._values);
        }
      }
      function Cl(e6, t5, n4) {
        e6 === 15 ? t5.version = n4.readVarint() : e6 === 1 ? t5.name = n4.readString() : e6 === 5 ? t5.extent = n4.readVarint() : e6 === 2 ? t5._features.push(n4.pos) : e6 === 3 ? t5._keys.push(n4.readString()) : e6 === 4 && t5._values.push((function(e7) {
          let t6 = null, n5 = e7.readVarint() + e7.pos;
          for (; e7.pos < n5; ) {
            let n6 = e7.readVarint() >> 3;
            t6 = n6 === 1 ? e7.readString() : n6 === 2 ? e7.readFloat() : n6 === 3 ? e7.readDouble() : n6 === 4 ? e7.readVarint64() : n6 === 5 ? e7.readVarint() : n6 === 6 ? e7.readSVarint() : n6 === 7 ? e7.readBoolean() : null;
          }
          if (t6 == null) throw Error(`unknown feature value`);
          return t6;
        })(n4));
      }
      class wl {
        constructor(e6, t5) {
          this.layers = e6.readFields(Tl, {}, t5);
        }
      }
      function Tl(e6, t5, n4) {
        if (e6 === 3) {
          let e7 = new Sl(n4, n4.readVarint() + n4.pos);
          e7.length && (t5[e7.name] = e7);
        }
      }
      let El = 2 ** 13;
      function Dl(e6, t5, n4, r3, i3, a3, o3, s3) {
        e6.emplaceBack(t5, n4, 2 * Math.floor(r3 * El) + o3, i3 * El * 2, a3 * El * 2, Math.round(s3));
      }
      class Ol {
        constructor(e6) {
          this.zoom = e6.zoom, this.overscaling = e6.overscaling, this.layers = e6.layers, this.layerIds = this.layers.map(((e7) => e7.id)), this.index = e6.index, this.hasDependencies = false, this.layoutVertexArray = new zo(), this.centroidVertexArray = new Io(), this.indexArray = new Yo(), this.programConfigurations = new Ds(e6.layers, e6.zoom), this.segments = new Qo(), this.stateDependentLayerIds = this.layers.filter(((e7) => e7.isStateDependent())).map(((e7) => e7.id));
        }
        populate(e6, t5, n4) {
          this.features = [], this.hasDependencies = Oc(`fill-extrusion`, this.layers, t5);
          for (let { feature: r3, id: i3, index: a3, sourceLayerIndex: o3 } of e6) {
            let e7 = this.layers[0]._featureFilter.needGeometry, s3 = Ns(r3, e7);
            if (!this.layers[0]._featureFilter.filter(new ka(this.zoom), s3, n4)) continue;
            let c3 = { id: i3, sourceLayerIndex: o3, index: a3, geometry: e7 ? s3.geometry : Ms(r3), properties: r3.properties, type: r3.type, patterns: {} };
            this.hasDependencies ? this.features.push(kc(`fill-extrusion`, this.layers, c3, { zoom: this.zoom }, t5)) : this.addFeature(c3, c3.geometry, a3, n4, {}, t5.subdivisionGranularity), t5.featureIndex.insert(r3, c3.geometry, a3, o3, this.index, true);
          }
        }
        addFeatures(e6, t5, n4) {
          for (let r3 of this.features) {
            let { geometry: i3 } = r3;
            this.addFeature(r3, i3, r3.index, t5, n4, e6.subdivisionGranularity);
          }
        }
        update(e6, t5, n4) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e6, t5, this.stateDependentLayers, { imagePositions: n4 });
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e6) {
          this.uploaded || (this.layoutVertexBuffer = e6.createVertexBuffer(this.layoutVertexArray, vl), this.centroidVertexBuffer = e6.createVertexBuffer(this.centroidVertexArray, _l.members, true), this.indexBuffer = e6.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e6), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
        }
        addFeature(e6, t5, n4, r3, i3, a3) {
          for (let n5 of rr(t5, 500)) {
            let t6 = { x: 0, y: 0, sampleCount: 0 }, i4 = this.layoutVertexArray.length;
            this.processPolygon(t6, r3, e6, n5, a3);
            let o3 = this.layoutVertexArray.length - i4, s3 = Math.floor(t6.x / t6.sampleCount), c3 = Math.floor(t6.y / t6.sampleCount);
            for (let e7 = 0; e7 < o3; e7++) this.centroidVertexArray.emplaceBack(s3, c3);
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e6, n4, { imagePositions: i3, canonical: r3 });
        }
        processPolygon(e6, t5, n4, r3, i3) {
          if (r3.length < 1 || jl(r3[0])) return;
          for (let t6 of r3) t6.length !== 0 && kl(e6, t6);
          let a3 = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, o3 = i3.fill.getGranularityForZoomLevel(t5.z), s3 = yl.types[n4.type] === `Polygon`;
          for (let e7 of r3) {
            if (e7.length === 0 || jl(e7)) continue;
            let t6 = sl(e7, o3, s3);
            this._generateSideFaces(t6, a3);
          }
          if (!s3) return;
          let c3 = ol(r3, t5, o3, false), l3 = this.layoutVertexArray;
          ll(((e7, t6) => {
            Dl(l3, e7, t6, 0, 0, 1, 1, 0);
          }), this.segments, this.layoutVertexArray, this.indexArray, c3.verticesFlattened, c3.indicesTriangles);
        }
        _generateSideFaces(e6, t5) {
          let n4 = 0;
          for (let r3 = 1; r3 < e6.length; r3++) {
            let i3 = e6[r3], a3 = e6[r3 - 1];
            if (Al(i3, a3)) continue;
            t5.segment.vertexLength + 4 > Qo.MAX_VERTEX_ARRAY_LENGTH && (t5.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
            let o3 = i3.sub(a3)._perp()._unit(), s3 = a3.dist(i3);
            n4 + s3 > 32768 && (n4 = 0), Dl(this.layoutVertexArray, i3.x, i3.y, o3.x, o3.y, 0, 0, n4), Dl(this.layoutVertexArray, i3.x, i3.y, o3.x, o3.y, 0, 1, n4), n4 += s3, Dl(this.layoutVertexArray, a3.x, a3.y, o3.x, o3.y, 0, 0, n4), Dl(this.layoutVertexArray, a3.x, a3.y, o3.x, o3.y, 0, 1, n4);
            let c3 = t5.segment.vertexLength;
            this.indexArray.emplaceBack(c3, c3 + 2, c3 + 1), this.indexArray.emplaceBack(c3 + 1, c3 + 2, c3 + 3), t5.segment.vertexLength += 4, t5.segment.primitiveLength += 2;
          }
        }
      }
      function kl(e6, t5) {
        for (let n4 = 0; n4 < t5.length; n4++) {
          let r3 = t5[n4];
          n4 === t5.length - 1 && t5[0].x === r3.x && t5[0].y === r3.y || (e6.x += r3.x, e6.y += r3.y, e6.sampleCount++);
        }
      }
      function Al(e6, t5) {
        return e6.x === t5.x && (e6.x < 0 || e6.x > O2) || e6.y === t5.y && (e6.y < 0 || e6.y > O2);
      }
      function jl(e6) {
        return e6.every(((e7) => e7.x < 0)) || e6.every(((e7) => e7.x > O2)) || e6.every(((e7) => e7.y < 0)) || e6.every(((e7) => e7.y > O2));
      }
      let Ml;
      X(`FillExtrusionBucket`, Ol, { omit: [`layers`, `features`] });
      var Nl = { get paint() {
        return Ml || (Ml = new Ha({ "fill-extrusion-opacity": new Q(R2[`paint_fill-extrusion`][`fill-extrusion-opacity`]), "fill-extrusion-color": new $(R2[`paint_fill-extrusion`][`fill-extrusion-color`]), "fill-extrusion-translate": new Q(R2[`paint_fill-extrusion`][`fill-extrusion-translate`]), "fill-extrusion-translate-anchor": new Q(R2[`paint_fill-extrusion`][`fill-extrusion-translate-anchor`]), "fill-extrusion-pattern": new za(R2[`paint_fill-extrusion`][`fill-extrusion-pattern`]), "fill-extrusion-height": new $(R2[`paint_fill-extrusion`][`fill-extrusion-height`]), "fill-extrusion-base": new $(R2[`paint_fill-extrusion`][`fill-extrusion-base`]), "fill-extrusion-vertical-gradient": new Q(R2[`paint_fill-extrusion`][`fill-extrusion-vertical-gradient`]) }));
      } };
      class Pl extends Wa {
        constructor(e6, t5) {
          super(e6, Nl, t5);
        }
        createBucket(e6) {
          return new Ol(e6);
        }
        queryRadius() {
          return Ys(this.paint.get(`fill-extrusion-translate`));
        }
        is3D() {
          return true;
        }
        queryIntersectsFeature({ queryGeometry: e6, feature: t5, featureState: r3, geometry: i3, transform: a3, pixelsToTileUnits: o3, pixelPosMatrix: s3 }) {
          let c3 = Xs(e6, this.paint.get(`fill-extrusion-translate`), this.paint.get(`fill-extrusion-translate-anchor`), -a3.bearingInRadians, o3), l3 = this.paint.get(`fill-extrusion-height`).evaluate(t5, r3), u3 = this.paint.get(`fill-extrusion-base`).evaluate(t5, r3), d3 = (function(e7, t6) {
            let r4 = [];
            for (let i4 of e7) {
              let e8 = [i4.x, i4.y, 0, 1];
              C2(e8, e8, t6), r4.push(new n3(e8[0] / e8[3], e8[1] / e8[3]));
            }
            return r4;
          })(c3, s3), f3 = (function(e7, t6, r4, i4) {
            let a4 = [], o4 = [], s4 = i4[8] * t6, c4 = i4[9] * t6, l4 = i4[10] * t6, u4 = i4[11] * t6, d4 = i4[8] * r4, f4 = i4[9] * r4, p3 = i4[10] * r4, m3 = i4[11] * r4;
            for (let t7 of e7) {
              let e8 = [], r5 = [];
              for (let a5 of t7) {
                let t8 = a5.x, o5 = a5.y, h3 = i4[0] * t8 + i4[4] * o5 + i4[12], g3 = i4[1] * t8 + i4[5] * o5 + i4[13], _3 = i4[2] * t8 + i4[6] * o5 + i4[14], v3 = i4[3] * t8 + i4[7] * o5 + i4[15], y3 = _3 + l4, b3 = v3 + u4, x3 = h3 + d4, S3 = g3 + f4, C3 = _3 + p3, w3 = v3 + m3, T3 = new n3((h3 + s4) / b3, (g3 + c4) / b3);
                T3.z = y3 / b3, e8.push(T3);
                let E3 = new n3(x3 / w3, S3 / w3);
                E3.z = C3 / w3, r5.push(E3);
              }
              a4.push(e8), o4.push(r5);
            }
            return [a4, o4];
          })(i3, u3, l3, s3);
          return (function(e7, t6, n4) {
            let r4 = 1 / 0;
            zs(n4, t6) && (r4 = Il(n4, t6[0]));
            for (let i4 = 0; i4 < t6.length; i4++) {
              let a4 = t6[i4], o4 = e7[i4];
              for (let e8 = 0; e8 < a4.length - 1; e8++) {
                let t7 = a4[e8], i5 = [t7, a4[e8 + 1], o4[e8 + 1], o4[e8], t7];
                Ls(n4, i5) && (r4 = Math.min(r4, Il(n4, i5)));
              }
            }
            return r4 !== 1 / 0 && r4;
          })(f3[0], f3[1], d3);
        }
      }
      function Fl(e6, t5) {
        return e6.x * t5.x + e6.y * t5.y;
      }
      function Il(e6, t5) {
        if (e6.length === 1) {
          let n4 = 0, r3 = t5[n4++], i3;
          for (; !i3 || r3.equals(i3); ) if (i3 = t5[n4++], !i3) return 1 / 0;
          for (; n4 < t5.length; n4++) {
            let a3 = t5[n4], o3 = e6[0], s3 = i3.sub(r3), c3 = a3.sub(r3), l3 = o3.sub(r3), u3 = Fl(s3, s3), d3 = Fl(s3, c3), f3 = Fl(c3, c3), p3 = Fl(l3, s3), m3 = Fl(l3, c3), h3 = u3 * f3 - d3 * d3, g3 = (f3 * p3 - d3 * m3) / h3, _3 = (u3 * m3 - d3 * p3) / h3, v3 = r3.z * (1 - g3 - _3) + i3.z * g3 + a3.z * _3;
            if (isFinite(v3)) return v3;
          }
          return 1 / 0;
        }
        {
          let e7 = 1 / 0;
          for (let n4 of t5) e7 = Math.min(e7, n4.z);
          return e7;
        }
      }
      let { members: Ll } = Za([{ name: `a_pos_normal`, components: 2, type: `Int16` }, { name: `a_data`, components: 4, type: `Uint8` }], 4), { members: Rl } = Za([{ name: `a_uv_x`, components: 1, type: `Float32` }, { name: `a_split_index`, components: 1, type: `Float32` }]), zl = Math.cos(Math.PI / 180 * 37.5), Bl = 2 ** 14 / 0.5;
      class Vl {
        constructor(e6) {
          this.zoom = e6.zoom, this.overscaling = e6.overscaling, this.layers = e6.layers, this.layerIds = this.layers.map(((e7) => e7.id)), this.index = e6.index, this.hasDependencies = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(((e7) => {
            this.gradients[e7.id] = {};
          })), this.layoutVertexArray = new Bo(), this.layoutVertexArray2 = new Vo(), this.indexArray = new Yo(), this.programConfigurations = new Ds(e6.layers, e6.zoom), this.segments = new Qo(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(((e7) => e7.isStateDependent())).map(((e7) => e7.id));
        }
        populate(e6, t5, n4) {
          this.hasDependencies = Oc(`line`, this.layers, t5) || this.hasLineDasharray(this.layers);
          let r3 = this.layers[0].layout.get(`line-sort-key`), i3 = !r3.isConstant(), a3 = [];
          for (let { feature: t6, id: o3, index: s3, sourceLayerIndex: c3 } of e6) {
            let e7 = this.layers[0]._featureFilter.needGeometry, l3 = Ns(t6, e7);
            if (!this.layers[0]._featureFilter.filter(new ka(this.zoom), l3, n4)) continue;
            let u3 = i3 ? r3.evaluate(l3, {}, n4) : void 0, d3 = { id: o3, properties: t6.properties, type: t6.type, sourceLayerIndex: c3, index: s3, geometry: e7 ? l3.geometry : Ms(t6), patterns: {}, dashes: {}, sortKey: u3 };
            a3.push(d3);
          }
          i3 && a3.sort(((e7, t6) => e7.sortKey - t6.sortKey));
          for (let r4 of a3) {
            let { geometry: i4, index: a4, sourceLayerIndex: o3 } = r4;
            this.hasDependencies ? (Oc(`line`, this.layers, t5) ? kc(`line`, this.layers, r4, { zoom: this.zoom }, t5) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, r4, this.zoom, t5), this.patternFeatures.push(r4)) : this.addFeature(r4, i4, a4, n4, {}, {}, t5.subdivisionGranularity), t5.featureIndex.insert(e6[a4].feature, i4, a4, o3, this.index);
          }
        }
        update(e6, t5, n4, r3) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e6, t5, this.stateDependentLayers, { imagePositions: n4, dashPositions: r3 });
        }
        addFeatures(e6, t5, n4, r3) {
          for (let i3 of this.patternFeatures) this.addFeature(i3, i3.geometry, i3.index, t5, n4, r3, e6.subdivisionGranularity);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e6) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = e6.createVertexBuffer(this.layoutVertexArray2, Rl)), this.layoutVertexBuffer = e6.createVertexBuffer(this.layoutVertexArray, Ll), this.indexBuffer = e6.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e6), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(e6) {
          if (e6.properties && Object.prototype.hasOwnProperty.call(e6.properties, `mapbox_clip_start`) && Object.prototype.hasOwnProperty.call(e6.properties, `mapbox_clip_end`)) return { start: +e6.properties.mapbox_clip_start, end: +e6.properties.mapbox_clip_end };
        }
        addFeature(e6, t5, n4, r3, i3, a3, o3) {
          let s3 = this.layers[0].layout, c3 = s3.get(`line-join`).evaluate(e6, {}), l3 = s3.get(`line-cap`), u3 = s3.get(`line-miter-limit`), d3 = s3.get(`line-round-limit`);
          this.lineClips = this.lineFeatureClips(e6);
          for (let n5 of t5) this.addLine(n5, e6, c3, l3, u3, d3, r3, o3);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e6, n4, { imagePositions: i3, dashPositions: a3, canonical: r3 });
        }
        addLine(e6, t5, n4, r3, i3, a3, o3, s3) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, e6 = sl(e6, o3 ? s3.line.getGranularityForZoomLevel(o3.z) : 1), this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let t6 = 0; t6 < e6.length - 1; t6++) this.totalDistance += e6[t6].dist(e6[t6 + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          let c3 = yl.types[t5.type] === `Polygon`, l3 = e6.length;
          for (; l3 >= 2 && e6[l3 - 1].equals(e6[l3 - 2]); ) l3--;
          let u3 = 0;
          for (; u3 < l3 - 1 && e6[u3].equals(e6[u3 + 1]); ) u3++;
          if (l3 < (c3 ? 3 : 2)) return;
          n4 === `bevel` && (i3 = 1.05);
          let d3 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, f3 = this.segments.prepareSegment(10 * l3, this.layoutVertexArray, this.indexArray), p3, m3, h3, g3, _3;
          this.e1 = this.e2 = -1, c3 && (p3 = e6[l3 - 2], _3 = e6[u3].sub(p3)._unit()._perp());
          for (let t6 = u3; t6 < l3; t6++) {
            if (h3 = t6 === l3 - 1 ? c3 ? e6[u3 + 1] : void 0 : e6[t6 + 1], h3 && e6[t6].equals(h3)) continue;
            _3 && (g3 = _3), p3 && (m3 = p3), p3 = e6[t6], _3 = h3 ? h3.sub(p3)._unit()._perp() : g3, g3 || (g3 = _3);
            let o4 = g3.add(_3);
            o4.x === 0 && o4.y === 0 || o4._unit();
            let s4 = g3.x * _3.x + g3.y * _3.y, v3 = o4.x * _3.x + o4.y * _3.y, y3 = v3 === 0 ? 1 / 0 : 1 / v3, b3 = 2 * Math.sqrt(2 - 2 * v3), x3 = v3 < zl && m3 && h3, S3 = g3.x * _3.y - g3.y * _3.x > 0;
            if (x3 && t6 > u3) {
              let e7 = p3.dist(m3);
              if (e7 > 2 * d3) {
                let t7 = p3.sub(p3.sub(m3)._mult(d3 / e7)._round());
                this.updateDistance(m3, t7), this.addCurrentVertex(t7, g3, 0, 0, f3), m3 = t7;
              }
            }
            let C3 = m3 && h3, w3 = C3 ? n4 : c3 ? `butt` : r3;
            if (C3 && w3 === `round` && (y3 < a3 ? w3 = `miter` : y3 <= 2 && (w3 = `fakeround`)), w3 === `miter` && y3 > i3 && (w3 = `bevel`), w3 === `bevel` && (y3 > 2 && (w3 = `flipbevel`), y3 < i3 && (w3 = `miter`)), m3 && this.updateDistance(m3, p3), w3 === `miter`) o4._mult(y3), this.addCurrentVertex(p3, o4, 0, 0, f3);
            else if (w3 === `flipbevel`) {
              if (y3 > 100) o4 = _3.mult(-1);
              else {
                let e7 = y3 * g3.add(_3).mag() / g3.sub(_3).mag();
                o4._perp()._mult(e7 * (S3 ? -1 : 1));
              }
              this.addCurrentVertex(p3, o4, 0, 0, f3), this.addCurrentVertex(p3, o4.mult(-1), 0, 0, f3);
            } else if (w3 === `bevel` || w3 === `fakeround`) {
              let e7 = -Math.sqrt(y3 * y3 - 1), t7 = S3 ? e7 : 0, n5 = S3 ? 0 : e7;
              if (m3 && this.addCurrentVertex(p3, g3, t7, n5, f3), w3 === `fakeround`) {
                let e8 = Math.round(180 * b3 / Math.PI / 20);
                for (let t8 = 1; t8 < e8; t8++) {
                  let n6 = t8 / e8;
                  if (n6 !== 0.5) {
                    let e9 = n6 - 0.5;
                    n6 += n6 * e9 * (n6 - 1) * ((1.0904 + s4 * (s4 * (3.55645 - 1.43519 * s4) - 3.2452)) * e9 * e9 + (0.848013 + s4 * (0.215638 * s4 - 1.06021)));
                  }
                  let r4 = _3.sub(g3)._mult(n6)._add(g3)._unit()._mult(S3 ? -1 : 1);
                  this.addHalfVertex(p3, r4.x, r4.y, false, S3, 0, f3);
                }
              }
              h3 && this.addCurrentVertex(p3, _3, -t7, -n5, f3);
            } else if (w3 === `butt`) this.addCurrentVertex(p3, o4, 0, 0, f3);
            else if (w3 === `square`) {
              let e7 = m3 ? 1 : -1;
              this.addCurrentVertex(p3, o4, e7, e7, f3);
            } else w3 === `round` && (m3 && (this.addCurrentVertex(p3, g3, 0, 0, f3), this.addCurrentVertex(p3, g3, 1, 1, f3, true)), h3 && (this.addCurrentVertex(p3, _3, -1, -1, f3, true), this.addCurrentVertex(p3, _3, 0, 0, f3)));
            if (x3 && t6 < l3 - 1) {
              let e7 = p3.dist(h3);
              if (e7 > 2 * d3) {
                let t7 = p3.add(h3.sub(p3)._mult(d3 / e7)._round());
                this.updateDistance(p3, t7), this.addCurrentVertex(t7, _3, 0, 0, f3), p3 = t7;
              }
            }
          }
        }
        addCurrentVertex(e6, t5, n4, r3, i3, a3 = false) {
          let o3 = t5.y * r3 - t5.x, s3 = -t5.y - t5.x * r3;
          this.addHalfVertex(e6, t5.x + t5.y * n4, t5.y - t5.x * n4, a3, false, n4, i3), this.addHalfVertex(e6, o3, s3, a3, true, -r3, i3), this.distance > Bl / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(e6, t5, n4, r3, i3, a3));
        }
        addHalfVertex({ x: e6, y: t5 }, n4, r3, i3, a3, o3, s3) {
          let c3 = 0.5 * (this.lineClips ? this.scaledDistance * (Bl - 1) : this.scaledDistance);
          this.layoutVertexArray.emplaceBack((e6 << 1) + (i3 ? 1 : 0), (t5 << 1) + (a3 ? 1 : 0), Math.round(63 * n4) + 128, Math.round(63 * r3) + 128, 1 + (o3 === 0 ? 0 : o3 < 0 ? -1 : 1) | (63 & c3) << 2, c3 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
          let l3 = s3.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, l3, this.e2), s3.primitiveLength++), a3 ? this.e2 = l3 : this.e1 = l3;
        }
        updateScaledDistance() {
          this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
        }
        updateDistance(e6, t5) {
          this.distance += e6.dist(t5), this.updateScaledDistance();
        }
        hasLineDasharray(e6) {
          for (let t5 of e6) {
            let e7 = t5.paint.get(`line-dasharray`);
            if (e7 && !e7.isConstant()) return true;
          }
          return false;
        }
        addLineDashDependencies(e6, t5, n4, r3) {
          for (let i3 of e6) {
            let e7 = i3.paint.get(`line-dasharray`);
            if (!e7 || e7.value.kind === `constant`) continue;
            let a3 = i3.layout.get(`line-cap`) === `round`, o3 = { dasharray: e7.value.evaluate({ zoom: n4 - 1 }, t5, {}), round: a3 }, s3 = { dasharray: e7.value.evaluate({ zoom: n4 }, t5, {}), round: a3 }, c3 = { dasharray: e7.value.evaluate({ zoom: n4 + 1 }, t5, {}), round: a3 }, l3 = `${o3.dasharray.join(`,`)},${o3.round}`, u3 = `${s3.dasharray.join(`,`)},${s3.round}`, d3 = `${c3.dasharray.join(`,`)},${c3.round}`;
            r3.dashDependencies[l3] = o3, r3.dashDependencies[u3] = s3, r3.dashDependencies[d3] = c3, t5.dashes[i3.id] = { min: l3, mid: u3, max: d3 };
          }
        }
      }
      let Hl, Ul;
      X(`LineBucket`, Vl, { omit: [`layers`, `patternFeatures`] });
      var Wl = { get paint() {
        return Ul || (Ul = new Ha({ "line-opacity": new $(R2.paint_line[`line-opacity`]), "line-color": new $(R2.paint_line[`line-color`]), "line-translate": new Q(R2.paint_line[`line-translate`]), "line-translate-anchor": new Q(R2.paint_line[`line-translate-anchor`]), "line-width": new $(R2.paint_line[`line-width`]), "line-gap-width": new $(R2.paint_line[`line-gap-width`]), "line-offset": new $(R2.paint_line[`line-offset`]), "line-blur": new $(R2.paint_line[`line-blur`]), "line-dasharray": new za(R2.paint_line[`line-dasharray`]), "line-pattern": new za(R2.paint_line[`line-pattern`]), "line-gradient": new Va(R2.paint_line[`line-gradient`]) }));
      }, get layout() {
        return Hl || (Hl = new Ha({ "line-cap": new Q(R2.layout_line[`line-cap`]), "line-join": new $(R2.layout_line[`line-join`]), "line-miter-limit": new Q(R2.layout_line[`line-miter-limit`]), "line-round-limit": new Q(R2.layout_line[`line-round-limit`]), "line-sort-key": new $(R2.layout_line[`line-sort-key`]) }));
      } };
      class Gl extends $ {
        possiblyEvaluate(e6, t5) {
          return t5 = new ka(Math.floor(t5.zoom), { now: t5.now, fadeDuration: t5.fadeDuration, zoomHistory: t5.zoomHistory, transition: t5.transition }), super.possiblyEvaluate(e6, t5);
        }
        evaluate(e6, t5, n4, r3) {
          return t5 = P2({}, t5, { zoom: Math.floor(t5.zoom) }), super.evaluate(e6, t5, n4, r3);
        }
      }
      let Kl;
      class ql extends Wa {
        constructor(e6, t5) {
          super(e6, Wl, t5), this.gradientVersion = 0, Kl || (Kl = new Gl(Wl.paint.properties[`line-width`].specification), Kl.useIntegerZoom = true);
        }
        _handleSpecialPaintPropertyUpdate(e6) {
          if (e6 === `line-gradient`) {
            let e7 = this.gradientExpression();
            this.stepInterpolant = !!(function(e8) {
              return e8._styleExpression !== void 0;
            })(e7) && e7._styleExpression.expression instanceof dn2, this.gradientVersion = (this.gradientVersion + 1) % (2 ** 53 - 1);
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values[`line-gradient`].value.expression;
        }
        recalculate(e6, t5) {
          super.recalculate(e6, t5), this.paint._values[`line-floorwidth`] = Kl.possiblyEvaluate(this._transitioningPaint._values[`line-width`].value, e6);
        }
        createBucket(e6) {
          return new Vl(e6);
        }
        queryRadius(e6) {
          let t5 = e6, n4 = Jl(Js(`line-width`, this, t5), Js(`line-gap-width`, this, t5)), r3 = Js(`line-offset`, this, t5);
          return n4 / 2 + Math.abs(r3) + Ys(this.paint.get(`line-translate`));
        }
        queryIntersectsFeature({ queryGeometry: e6, feature: t5, featureState: r3, geometry: i3, transform: a3, pixelsToTileUnits: o3 }) {
          let s3 = Xs(e6, this.paint.get(`line-translate`), this.paint.get(`line-translate-anchor`), -a3.bearingInRadians, o3), c3 = o3 / 2 * Jl(this.paint.get(`line-width`).evaluate(t5, r3), this.paint.get(`line-gap-width`).evaluate(t5, r3)), l3 = this.paint.get(`line-offset`).evaluate(t5, r3);
          return l3 && (i3 = (function(e7, t6) {
            let r4 = [];
            for (let i4 = 0; i4 < e7.length; i4++) {
              let a4 = e7[i4], o4 = [];
              for (let e8 = 0; e8 < a4.length; e8++) {
                let r5 = a4[e8 - 1], i5 = a4[e8], s4 = a4[e8 + 1], c4 = e8 === 0 ? new n3(0, 0) : i5.sub(r5)._unit()._perp(), l4 = e8 === a4.length - 1 ? new n3(0, 0) : s4.sub(i5)._unit()._perp(), u3 = c4._add(l4)._unit(), d3 = u3.x * l4.x + u3.y * l4.y;
                d3 !== 0 && u3._mult(1 / d3), o4.push(u3._mult(t6)._add(i5));
              }
              r4.push(o4);
            }
            return r4;
          })(i3, l3 * o3)), (function(e7, t6, n4) {
            for (let r4 = 0; r4 < t6.length; r4++) {
              let i4 = t6[r4];
              if (e7.length >= 3) {
                for (let t7 = 0; t7 < i4.length; t7++) if (Ks(e7, i4[t7])) return true;
              }
              if (Bs(e7, i4, n4)) return true;
            }
            return false;
          })(s3, i3, c3);
        }
        isTileClipped() {
          return true;
        }
      }
      function Jl(e6, t5) {
        return t5 > 0 ? t5 + 2 * e6 : e6;
      }
      let Yl = Za([{ name: `a_pos_offset`, components: 4, type: `Int16` }, { name: `a_data`, components: 4, type: `Uint16` }, { name: `a_pixeloffset`, components: 4, type: `Int16` }], 4), Xl = Za([{ name: `a_projected_pos`, components: 3, type: `Float32` }], 4);
      Za([{ name: `a_fade_opacity`, components: 1, type: `Uint32` }], 4);
      let Zl = Za([{ name: `a_placed`, components: 2, type: `Uint8` }, { name: `a_shift`, components: 2, type: `Float32` }, { name: `a_box_real`, components: 2, type: `Int16` }]);
      Za([{ type: `Int16`, name: `anchorPointX` }, { type: `Int16`, name: `anchorPointY` }, { type: `Int16`, name: `x1` }, { type: `Int16`, name: `y1` }, { type: `Int16`, name: `x2` }, { type: `Int16`, name: `y2` }, { type: `Uint32`, name: `featureIndex` }, { type: `Uint16`, name: `sourceLayerIndex` }, { type: `Uint16`, name: `bucketIndex` }]);
      let Ql = Za([{ name: `a_pos`, components: 2, type: `Int16` }, { name: `a_anchor_pos`, components: 2, type: `Int16` }, { name: `a_extrude`, components: 2, type: `Int16` }], 4), $l = Za([{ name: `a_pos`, components: 2, type: `Float32` }, { name: `a_radius`, components: 1, type: `Float32` }, { name: `a_flags`, components: 2, type: `Int16` }], 4);
      function eu(e6, t5, n4) {
        return e6.sections.forEach(((e7) => {
          e7.text = (function(e8, t6, n5) {
            let r3 = t6.layout.get(`text-transform`).evaluate(n5, {});
            return r3 === `uppercase` ? e8 = e8.toLocaleUpperCase() : r3 === `lowercase` && (e8 = e8.toLocaleLowerCase()), Oa.applyArabicShaping && (e8 = Oa.applyArabicShaping(e8)), e8;
          })(e7.text, t5, n4);
        })), e6;
      }
      Za([{ name: `triangle`, components: 3, type: `Uint16` }]), Za([{ type: `Int16`, name: `anchorX` }, { type: `Int16`, name: `anchorY` }, { type: `Uint16`, name: `glyphStartIndex` }, { type: `Uint16`, name: `numGlyphs` }, { type: `Uint32`, name: `vertexStartIndex` }, { type: `Uint32`, name: `lineStartIndex` }, { type: `Uint32`, name: `lineLength` }, { type: `Uint16`, name: `segment` }, { type: `Uint16`, name: `lowerSize` }, { type: `Uint16`, name: `upperSize` }, { type: `Float32`, name: `lineOffsetX` }, { type: `Float32`, name: `lineOffsetY` }, { type: `Uint8`, name: `writingMode` }, { type: `Uint8`, name: `placedOrientation` }, { type: `Uint8`, name: `hidden` }, { type: `Uint32`, name: `crossTileID` }, { type: `Int16`, name: `associatedIconIndex` }]), Za([{ type: `Int16`, name: `anchorX` }, { type: `Int16`, name: `anchorY` }, { type: `Int16`, name: `rightJustifiedTextSymbolIndex` }, { type: `Int16`, name: `centerJustifiedTextSymbolIndex` }, { type: `Int16`, name: `leftJustifiedTextSymbolIndex` }, { type: `Int16`, name: `verticalPlacedTextSymbolIndex` }, { type: `Int16`, name: `placedIconSymbolIndex` }, { type: `Int16`, name: `verticalPlacedIconSymbolIndex` }, { type: `Uint16`, name: `key` }, { type: `Uint16`, name: `textBoxStartIndex` }, { type: `Uint16`, name: `textBoxEndIndex` }, { type: `Uint16`, name: `verticalTextBoxStartIndex` }, { type: `Uint16`, name: `verticalTextBoxEndIndex` }, { type: `Uint16`, name: `iconBoxStartIndex` }, { type: `Uint16`, name: `iconBoxEndIndex` }, { type: `Uint16`, name: `verticalIconBoxStartIndex` }, { type: `Uint16`, name: `verticalIconBoxEndIndex` }, { type: `Uint16`, name: `featureIndex` }, { type: `Uint16`, name: `numHorizontalGlyphVertices` }, { type: `Uint16`, name: `numVerticalGlyphVertices` }, { type: `Uint16`, name: `numIconVertices` }, { type: `Uint16`, name: `numVerticalIconVertices` }, { type: `Uint16`, name: `useRuntimeCollisionCircles` }, { type: `Uint32`, name: `crossTileID` }, { type: `Float32`, name: `textBoxScale` }, { type: `Float32`, name: `collisionCircleDiameter` }, { type: `Uint16`, name: `textAnchorOffsetStartIndex` }, { type: `Uint16`, name: `textAnchorOffsetEndIndex` }]), Za([{ type: `Float32`, name: `offsetX` }]), Za([{ type: `Int16`, name: `x` }, { type: `Int16`, name: `y` }, { type: `Int16`, name: `tileUnitDistanceFromAnchor` }]), Za([{ type: `Uint16`, name: `textAnchor` }, { type: `Float32`, components: 2, name: `textOffset` }]);
      let tu = { "!": `\uFE15`, "#": `\uFF03`, $: `\uFF04`, "%": `\uFF05`, "&": `\uFF06`, "(": `\uFE35`, ")": `\uFE36`, "*": `\uFF0A`, "+": `\uFF0B`, ",": `\uFE10`, "-": `\uFE32`, ".": `\u30FB`, "/": `\uFF0F`, ":": `\uFE13`, ";": `\uFE14`, "<": `\uFE3F`, "=": `\uFF1D`, ">": `\uFE40`, "?": `\uFE16`, "@": `\uFF20`, "[": `\uFE47`, "\\": `\uFF3C`, "]": `\uFE48`, "^": `\uFF3E`, _: `\uFE33`, "`": `\uFF40`, "{": `\uFE37`, "|": `\u2015`, "}": `\uFE38`, "~": `\uFF5E`, "\xA2": `\uFFE0`, "\xA3": `\uFFE1`, "\xA5": `\uFFE5`, "\xA6": `\uFFE4`, "\xAC": `\uFFE2`, "\xAF": `\uFFE3`, "\u2013": `\uFE32`, "\u2014": `\uFE31`, "\u2018": `\uFE43`, "\u2019": `\uFE44`, "\u201C": `\uFE41`, "\u201D": `\uFE42`, "\u2026": `\uFE19`, "\u2027": `\u30FB`, "\u20A9": `\uFFE6`, "\u3001": `\uFE11`, "\u3002": `\uFE12`, "\u3008": `\uFE3F`, "\u3009": `\uFE40`, "\u300A": `\uFE3D`, "\u300B": `\uFE3E`, "\u300C": `\uFE41`, "\u300D": `\uFE42`, "\u300E": `\uFE43`, "\u300F": `\uFE44`, "\u3010": `\uFE3B`, "\u3011": `\uFE3C`, "\u3014": `\uFE39`, "\u3015": `\uFE3A`, "\u3016": `\uFE17`, "\u3017": `\uFE18`, "\uFF01": `\uFE15`, "\uFF08": `\uFE35`, "\uFF09": `\uFE36`, "\uFF0C": `\uFE10`, "\uFF0D": `\uFE32`, "\uFF0E": `\u30FB`, "\uFF1A": `\uFE13`, "\uFF1B": `\uFE14`, "\uFF1C": `\uFE3F`, "\uFF1E": `\uFE40`, "\uFF1F": `\uFE16`, "\uFF3B": `\uFE47`, "\uFF3D": `\uFE48`, "\uFF3F": `\uFE33`, "\uFF5B": `\uFE37`, "\uFF5C": `\u2015`, "\uFF5D": `\uFE38`, "\uFF5F": `\uFE35`, "\uFF60": `\uFE36`, "\uFF61": `\uFE12`, "\uFF62": `\uFE41`, "\uFF63": `\uFE42` };
      var nu = 24;
      let ru = 4294967296, iu = 1 / ru, au = typeof TextDecoder > `u` ? null : new TextDecoder(`utf-8`);
      class ou {
        constructor(e6 = new Uint8Array(16)) {
          this.buf = ArrayBuffer.isView(e6) ? e6 : new Uint8Array(e6), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        readFields(e6, t5, n4 = this.length) {
          for (; this.pos < n4; ) {
            let n5 = this.readVarint(), r3 = n5 >> 3, i3 = this.pos;
            this.type = 7 & n5, e6(r3, t5, this), this.pos === i3 && this.skip(n5);
          }
          return t5;
        }
        readMessage(e6, t5) {
          return this.readFields(e6, t5, this.readVarint() + this.pos);
        }
        readFixed32() {
          let e6 = this.dataView.getUint32(this.pos, true);
          return this.pos += 4, e6;
        }
        readSFixed32() {
          let e6 = this.dataView.getInt32(this.pos, true);
          return this.pos += 4, e6;
        }
        readFixed64() {
          let e6 = this.dataView.getUint32(this.pos, true) + this.dataView.getUint32(this.pos + 4, true) * ru;
          return this.pos += 8, e6;
        }
        readSFixed64() {
          let e6 = this.dataView.getUint32(this.pos, true) + this.dataView.getInt32(this.pos + 4, true) * ru;
          return this.pos += 8, e6;
        }
        readFloat() {
          let e6 = this.dataView.getFloat32(this.pos, true);
          return this.pos += 4, e6;
        }
        readDouble() {
          let e6 = this.dataView.getFloat64(this.pos, true);
          return this.pos += 8, e6;
        }
        readVarint(e6) {
          let t5 = this.buf, n4, r3;
          return r3 = t5[this.pos++], n4 = 127 & r3, r3 < 128 ? n4 : (r3 = t5[this.pos++], n4 |= (127 & r3) << 7, r3 < 128 ? n4 : (r3 = t5[this.pos++], n4 |= (127 & r3) << 14, r3 < 128 ? n4 : (r3 = t5[this.pos++], n4 |= (127 & r3) << 21, r3 < 128 ? n4 : (r3 = t5[this.pos], n4 |= (15 & r3) << 28, (function(e7, t6, n5) {
            let r4 = n5.buf, i3, a3;
            if (a3 = r4[n5.pos++], i3 = (112 & a3) >> 4, a3 < 128 || (a3 = r4[n5.pos++], i3 |= (127 & a3) << 3, a3 < 128) || (a3 = r4[n5.pos++], i3 |= (127 & a3) << 10, a3 < 128) || (a3 = r4[n5.pos++], i3 |= (127 & a3) << 17, a3 < 128) || (a3 = r4[n5.pos++], i3 |= (127 & a3) << 24, a3 < 128) || (a3 = r4[n5.pos++], i3 |= (1 & a3) << 31, a3 < 128)) return su(e7, i3, t6);
            throw Error(`Expected varint not more than 10 bytes`);
          })(n4, e6, this)))));
        }
        readVarint64() {
          return this.readVarint(true);
        }
        readSVarint() {
          let e6 = this.readVarint();
          return e6 % 2 == 1 ? (e6 + 1) / -2 : e6 / 2;
        }
        readBoolean() {
          return !!this.readVarint();
        }
        readString() {
          let e6 = this.readVarint() + this.pos, t5 = this.pos;
          return this.pos = e6, e6 - t5 >= 12 && au ? au.decode(this.buf.subarray(t5, e6)) : (function(e7, t6, n4) {
            let r3 = ``, i3 = t6;
            for (; i3 < n4; ) {
              let t7 = e7[i3], a3, o3, s3, c3 = null, l3 = t7 > 239 ? 4 : t7 > 223 ? 3 : t7 > 191 ? 2 : 1;
              if (i3 + l3 > n4) break;
              l3 === 1 ? t7 < 128 && (c3 = t7) : l3 === 2 ? (a3 = e7[i3 + 1], (192 & a3) == 128 && (c3 = (31 & t7) << 6 | 63 & a3, c3 <= 127 && (c3 = null))) : l3 === 3 ? (a3 = e7[i3 + 1], o3 = e7[i3 + 2], (192 & a3) == 128 && (192 & o3) == 128 && (c3 = (15 & t7) << 12 | (63 & a3) << 6 | 63 & o3, (c3 <= 2047 || c3 >= 55296 && c3 <= 57343) && (c3 = null))) : l3 === 4 && (a3 = e7[i3 + 1], o3 = e7[i3 + 2], s3 = e7[i3 + 3], (192 & a3) == 128 && (192 & o3) == 128 && (192 & s3) == 128 && (c3 = (15 & t7) << 18 | (63 & a3) << 12 | (63 & o3) << 6 | 63 & s3, (c3 <= 65535 || c3 >= 1114112) && (c3 = null))), c3 === null ? (c3 = 65533, l3 = 1) : c3 > 65535 && (c3 -= 65536, r3 += String.fromCharCode(c3 >>> 10 & 1023 | 55296), c3 = 56320 | 1023 & c3), r3 += String.fromCharCode(c3), i3 += l3;
            }
            return r3;
          })(this.buf, t5, e6);
        }
        readBytes() {
          let e6 = this.readVarint() + this.pos, t5 = this.buf.subarray(this.pos, e6);
          return this.pos = e6, t5;
        }
        readPackedVarint(e6 = [], t5) {
          let n4 = this.readPackedEnd();
          for (; this.pos < n4; ) e6.push(this.readVarint(t5));
          return e6;
        }
        readPackedSVarint(e6 = []) {
          let t5 = this.readPackedEnd();
          for (; this.pos < t5; ) e6.push(this.readSVarint());
          return e6;
        }
        readPackedBoolean(e6 = []) {
          let t5 = this.readPackedEnd();
          for (; this.pos < t5; ) e6.push(this.readBoolean());
          return e6;
        }
        readPackedFloat(e6 = []) {
          let t5 = this.readPackedEnd();
          for (; this.pos < t5; ) e6.push(this.readFloat());
          return e6;
        }
        readPackedDouble(e6 = []) {
          let t5 = this.readPackedEnd();
          for (; this.pos < t5; ) e6.push(this.readDouble());
          return e6;
        }
        readPackedFixed32(e6 = []) {
          let t5 = this.readPackedEnd();
          for (; this.pos < t5; ) e6.push(this.readFixed32());
          return e6;
        }
        readPackedSFixed32(e6 = []) {
          let t5 = this.readPackedEnd();
          for (; this.pos < t5; ) e6.push(this.readSFixed32());
          return e6;
        }
        readPackedFixed64(e6 = []) {
          let t5 = this.readPackedEnd();
          for (; this.pos < t5; ) e6.push(this.readFixed64());
          return e6;
        }
        readPackedSFixed64(e6 = []) {
          let t5 = this.readPackedEnd();
          for (; this.pos < t5; ) e6.push(this.readSFixed64());
          return e6;
        }
        readPackedEnd() {
          return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1;
        }
        skip(e6) {
          let t5 = 7 & e6;
          if (t5 === 0) for (; this.buf[this.pos++] > 127; ) ;
          else if (t5 === 2) this.pos = this.readVarint() + this.pos;
          else if (t5 === 5) this.pos += 4;
          else {
            if (t5 !== 1) throw Error(`Unimplemented type: ${t5}`);
            this.pos += 8;
          }
        }
        writeTag(e6, t5) {
          this.writeVarint(e6 << 3 | t5);
        }
        realloc(e6) {
          let t5 = this.length || 16;
          for (; t5 < this.pos + e6; ) t5 *= 2;
          if (t5 !== this.length) {
            let e7 = new Uint8Array(t5);
            e7.set(this.buf), this.buf = e7, this.dataView = new DataView(e7.buffer), this.length = t5;
          }
        }
        finish() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }
        writeFixed32(e6) {
          this.realloc(4), this.dataView.setInt32(this.pos, e6, true), this.pos += 4;
        }
        writeSFixed32(e6) {
          this.realloc(4), this.dataView.setInt32(this.pos, e6, true), this.pos += 4;
        }
        writeFixed64(e6) {
          this.realloc(8), this.dataView.setInt32(this.pos, -1 & e6, true), this.dataView.setInt32(this.pos + 4, Math.floor(e6 * iu), true), this.pos += 8;
        }
        writeSFixed64(e6) {
          this.realloc(8), this.dataView.setInt32(this.pos, -1 & e6, true), this.dataView.setInt32(this.pos + 4, Math.floor(e6 * iu), true), this.pos += 8;
        }
        writeVarint(e6) {
          (e6 = +e6 || 0) > 268435455 || e6 < 0 ? (function(e7, t5) {
            let n4, r3;
            if (e7 >= 0 ? (n4 = e7 % 4294967296 | 0, r3 = e7 / 4294967296 | 0) : (n4 = ~(-e7 % 4294967296), r3 = ~(-e7 / 4294967296), 4294967295 ^ n4 ? n4 = n4 + 1 | 0 : (n4 = 0, r3 = r3 + 1 | 0)), e7 >= 18446744073709552e3 || e7 < -18446744073709552e3) throw Error(`Given varint doesn't fit into 10 bytes`);
            t5.realloc(10), (function(e8, t6, n5) {
              n5.buf[n5.pos++] = 127 & e8 | 128, e8 >>>= 7, n5.buf[n5.pos++] = 127 & e8 | 128, e8 >>>= 7, n5.buf[n5.pos++] = 127 & e8 | 128, e8 >>>= 7, n5.buf[n5.pos++] = 127 & e8 | 128, n5.buf[n5.pos] = 127 & (e8 >>>= 7);
            })(n4, 0, t5), (function(e8, t6) {
              let n5 = (7 & e8) << 4;
              t6.buf[t6.pos++] |= n5 | ((e8 >>>= 3) ? 128 : 0), e8 && (t6.buf[t6.pos++] = 127 & e8 | ((e8 >>>= 7) ? 128 : 0), e8 && (t6.buf[t6.pos++] = 127 & e8 | ((e8 >>>= 7) ? 128 : 0), e8 && (t6.buf[t6.pos++] = 127 & e8 | ((e8 >>>= 7) ? 128 : 0), e8 && (t6.buf[t6.pos++] = 127 & e8 | ((e8 >>>= 7) ? 128 : 0), e8 && (t6.buf[t6.pos++] = 127 & e8)))));
            })(r3, t5);
          })(e6, this) : (this.realloc(4), this.buf[this.pos++] = 127 & e6 | (e6 > 127 ? 128 : 0), e6 <= 127 || (this.buf[this.pos++] = 127 & (e6 >>>= 7) | (e6 > 127 ? 128 : 0), e6 <= 127 || (this.buf[this.pos++] = 127 & (e6 >>>= 7) | (e6 > 127 ? 128 : 0), e6 <= 127 || (this.buf[this.pos++] = e6 >>> 7 & 127))));
        }
        writeSVarint(e6) {
          this.writeVarint(e6 < 0 ? 2 * -e6 - 1 : 2 * e6);
        }
        writeBoolean(e6) {
          this.writeVarint(+e6);
        }
        writeString(e6) {
          e6 = String(e6), this.realloc(4 * e6.length), this.pos++;
          let t5 = this.pos;
          this.pos = (function(e7, t6, n5) {
            for (let r3, i3, a3 = 0; a3 < t6.length; a3++) {
              if (r3 = t6.charCodeAt(a3), r3 > 55295 && r3 < 57344) {
                if (!i3) {
                  r3 > 56319 || a3 + 1 === t6.length ? (e7[n5++] = 239, e7[n5++] = 191, e7[n5++] = 189) : i3 = r3;
                  continue;
                }
                if (r3 < 56320) {
                  e7[n5++] = 239, e7[n5++] = 191, e7[n5++] = 189, i3 = r3;
                  continue;
                }
                r3 = i3 - 55296 << 10 | r3 - 56320 | 65536, i3 = null;
              } else i3 && (i3 = (e7[n5++] = 239, e7[n5++] = 191, e7[n5++] = 189, null));
              r3 < 128 ? e7[n5++] = r3 : (r3 < 2048 ? e7[n5++] = r3 >> 6 | 192 : (r3 < 65536 ? e7[n5++] = r3 >> 12 | 224 : (e7[n5++] = r3 >> 18 | 240, e7[n5++] = r3 >> 12 & 63 | 128), e7[n5++] = r3 >> 6 & 63 | 128), e7[n5++] = 63 & r3 | 128);
            }
            return n5;
          })(this.buf, e6, this.pos);
          let n4 = this.pos - t5;
          n4 >= 128 && cu(t5, n4, this), this.pos = t5 - 1, this.writeVarint(n4), this.pos += n4;
        }
        writeFloat(e6) {
          this.realloc(4), this.dataView.setFloat32(this.pos, e6, true), this.pos += 4;
        }
        writeDouble(e6) {
          this.realloc(8), this.dataView.setFloat64(this.pos, e6, true), this.pos += 8;
        }
        writeBytes(e6) {
          let t5 = e6.length;
          this.writeVarint(t5), this.realloc(t5);
          for (let n4 = 0; n4 < t5; n4++) this.buf[this.pos++] = e6[n4];
        }
        writeRawMessage(e6, t5) {
          this.pos++;
          let n4 = this.pos;
          e6(t5, this);
          let r3 = this.pos - n4;
          r3 >= 128 && cu(n4, r3, this), this.pos = n4 - 1, this.writeVarint(r3), this.pos += r3;
        }
        writeMessage(e6, t5, n4) {
          this.writeTag(e6, 2), this.writeRawMessage(t5, n4);
        }
        writePackedVarint(e6, t5) {
          t5.length && this.writeMessage(e6, lu, t5);
        }
        writePackedSVarint(e6, t5) {
          t5.length && this.writeMessage(e6, uu, t5);
        }
        writePackedBoolean(e6, t5) {
          t5.length && this.writeMessage(e6, pu, t5);
        }
        writePackedFloat(e6, t5) {
          t5.length && this.writeMessage(e6, du, t5);
        }
        writePackedDouble(e6, t5) {
          t5.length && this.writeMessage(e6, fu, t5);
        }
        writePackedFixed32(e6, t5) {
          t5.length && this.writeMessage(e6, mu, t5);
        }
        writePackedSFixed32(e6, t5) {
          t5.length && this.writeMessage(e6, hu, t5);
        }
        writePackedFixed64(e6, t5) {
          t5.length && this.writeMessage(e6, gu, t5);
        }
        writePackedSFixed64(e6, t5) {
          t5.length && this.writeMessage(e6, _u, t5);
        }
        writeBytesField(e6, t5) {
          this.writeTag(e6, 2), this.writeBytes(t5);
        }
        writeFixed32Field(e6, t5) {
          this.writeTag(e6, 5), this.writeFixed32(t5);
        }
        writeSFixed32Field(e6, t5) {
          this.writeTag(e6, 5), this.writeSFixed32(t5);
        }
        writeFixed64Field(e6, t5) {
          this.writeTag(e6, 1), this.writeFixed64(t5);
        }
        writeSFixed64Field(e6, t5) {
          this.writeTag(e6, 1), this.writeSFixed64(t5);
        }
        writeVarintField(e6, t5) {
          this.writeTag(e6, 0), this.writeVarint(t5);
        }
        writeSVarintField(e6, t5) {
          this.writeTag(e6, 0), this.writeSVarint(t5);
        }
        writeStringField(e6, t5) {
          this.writeTag(e6, 2), this.writeString(t5);
        }
        writeFloatField(e6, t5) {
          this.writeTag(e6, 5), this.writeFloat(t5);
        }
        writeDoubleField(e6, t5) {
          this.writeTag(e6, 1), this.writeDouble(t5);
        }
        writeBooleanField(e6, t5) {
          this.writeVarintField(e6, +t5);
        }
      }
      function su(e6, t5, n4) {
        return n4 ? 4294967296 * t5 + (e6 >>> 0) : 4294967296 * (t5 >>> 0) + (e6 >>> 0);
      }
      function cu(e6, t5, n4) {
        let r3 = t5 <= 16383 ? 1 : t5 <= 2097151 ? 2 : t5 <= 268435455 ? 3 : Math.floor(Math.log(t5) / (7 * Math.LN2));
        n4.realloc(r3);
        for (let t6 = n4.pos - 1; t6 >= e6; t6--) n4.buf[t6 + r3] = n4.buf[t6];
      }
      function lu(e6, t5) {
        for (let n4 = 0; n4 < e6.length; n4++) t5.writeVarint(e6[n4]);
      }
      function uu(e6, t5) {
        for (let n4 = 0; n4 < e6.length; n4++) t5.writeSVarint(e6[n4]);
      }
      function du(e6, t5) {
        for (let n4 = 0; n4 < e6.length; n4++) t5.writeFloat(e6[n4]);
      }
      function fu(e6, t5) {
        for (let n4 = 0; n4 < e6.length; n4++) t5.writeDouble(e6[n4]);
      }
      function pu(e6, t5) {
        for (let n4 = 0; n4 < e6.length; n4++) t5.writeBoolean(e6[n4]);
      }
      function mu(e6, t5) {
        for (let n4 = 0; n4 < e6.length; n4++) t5.writeFixed32(e6[n4]);
      }
      function hu(e6, t5) {
        for (let n4 = 0; n4 < e6.length; n4++) t5.writeSFixed32(e6[n4]);
      }
      function gu(e6, t5) {
        for (let n4 = 0; n4 < e6.length; n4++) t5.writeFixed64(e6[n4]);
      }
      function _u(e6, t5) {
        for (let n4 = 0; n4 < e6.length; n4++) t5.writeSFixed64(e6[n4]);
      }
      function vu(e6, t5, n4) {
        e6 === 1 && n4.readMessage(yu, t5);
      }
      function yu(e6, t5, n4) {
        if (e6 === 3) {
          let { id: e7, bitmap: r3, width: i3, height: a3, left: o3, top: s3, advance: c3 } = n4.readMessage(bu, {});
          t5.push({ id: e7, bitmap: new pc({ width: i3 + 6, height: a3 + 6 }, r3), metrics: { width: i3, height: a3, left: o3, top: s3, advance: c3 } });
        }
      }
      function bu(e6, t5, n4) {
        e6 === 1 ? t5.id = n4.readVarint() : e6 === 2 ? t5.bitmap = n4.readBytes() : e6 === 3 ? t5.width = n4.readVarint() : e6 === 4 ? t5.height = n4.readVarint() : e6 === 5 ? t5.left = n4.readSVarint() : e6 === 6 ? t5.top = n4.readSVarint() : e6 === 7 && (t5.advance = n4.readVarint());
      }
      function xu(e6) {
        let t5 = 0, n4 = 0;
        for (let r4 of e6) t5 += r4.w * r4.h, n4 = Math.max(n4, r4.w);
        e6.sort(((e7, t6) => t6.h - e7.h));
        let r3 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t5 / 0.95)), n4), h: 1 / 0 }], i3 = 0, a3 = 0;
        for (let t6 of e6) for (let e7 = r3.length - 1; e7 >= 0; e7--) {
          let n5 = r3[e7];
          if (!(t6.w > n5.w || t6.h > n5.h)) {
            if (t6.x = n5.x, t6.y = n5.y, a3 = Math.max(a3, t6.y + t6.h), i3 = Math.max(i3, t6.x + t6.w), t6.w === n5.w && t6.h === n5.h) {
              let t7 = r3.pop();
              t7 && e7 < r3.length && (r3[e7] = t7);
            } else t6.h === n5.h ? (n5.x += t6.w, n5.w -= t6.w) : t6.w === n5.w ? (n5.y += t6.h, n5.h -= t6.h) : (r3.push({ x: n5.x + t6.w, y: n5.y, w: n5.w - t6.w, h: t6.h }), n5.y += t6.h, n5.h -= t6.h);
            break;
          }
        }
        return { w: i3, h: a3, fill: t5 / (i3 * a3) || 0 };
      }
      class Su {
        constructor(e6, { pixelRatio: t5, version: n4, stretchX: r3, stretchY: i3, content: a3, textFitWidth: o3, textFitHeight: s3 }) {
          this.paddedRect = e6, this.pixelRatio = t5, this.stretchX = r3, this.stretchY = i3, this.content = a3, this.version = n4, this.textFitWidth = o3, this.textFitHeight = s3;
        }
        get tl() {
          return [this.paddedRect.x + 1, this.paddedRect.y + 1];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
        }
        get tlbr() {
          return this.tl.concat(this.br);
        }
        get displaySize() {
          return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
        }
      }
      class Cu {
        constructor(e6, t5) {
          let n4 = {}, r3 = {};
          this.haveRenderCallbacks = [];
          let i3 = [];
          this.addImages(e6, n4, i3), this.addImages(t5, r3, i3);
          let { w: a3, h: o3 } = xu(i3), s3 = new mc({ width: a3 || 1, height: o3 || 1 });
          for (let t6 in e6) {
            let r4 = e6[t6], i4 = n4[t6].paddedRect;
            mc.copy(r4.data, s3, { x: 0, y: 0 }, { x: i4.x + 1, y: i4.y + 1 }, r4.data);
          }
          for (let e7 in t5) {
            let n5 = t5[e7], i4 = r3[e7].paddedRect, a4 = i4.x + 1, o4 = i4.y + 1, c3 = n5.data.width, l3 = n5.data.height;
            mc.copy(n5.data, s3, { x: 0, y: 0 }, { x: a4, y: o4 }, n5.data), mc.copy(n5.data, s3, { x: 0, y: l3 - 1 }, { x: a4, y: o4 - 1 }, { width: c3, height: 1 }), mc.copy(n5.data, s3, { x: 0, y: 0 }, { x: a4, y: o4 + l3 }, { width: c3, height: 1 }), mc.copy(n5.data, s3, { x: c3 - 1, y: 0 }, { x: a4 - 1, y: o4 }, { width: 1, height: l3 }), mc.copy(n5.data, s3, { x: 0, y: 0 }, { x: a4 + c3, y: o4 }, { width: 1, height: l3 });
          }
          this.image = s3, this.iconPositions = n4, this.patternPositions = r3;
        }
        addImages(e6, t5, n4) {
          for (let r3 in e6) {
            let i3 = e6[r3], a3 = { x: 0, y: 0, w: i3.data.width + 2, h: i3.data.height + 2 };
            n4.push(a3), t5[r3] = new Su(a3, i3), i3.hasRenderCallback && this.haveRenderCallbacks.push(r3);
          }
        }
        patchUpdatedImages(e6, t5) {
          for (let n4 in e6.dispatchRenderCallbacks(this.haveRenderCallbacks), e6.updatedImages) this.patchUpdatedImage(this.iconPositions[n4], e6.getImage(n4), t5), this.patchUpdatedImage(this.patternPositions[n4], e6.getImage(n4), t5);
        }
        patchUpdatedImage(e6, t5, n4) {
          if (!e6 || !t5 || e6.version === t5.version) return;
          e6.version = t5.version;
          let [r3, i3] = e6.tl;
          n4.update(t5.data, void 0, { x: r3, y: i3 });
        }
      }
      var wu;
      X(`ImagePosition`, Su), X(`ImageAtlas`, Cu), e5.as = void 0, (wu = e5.as || (e5.as = {}))[wu.none = 0] = `none`, wu[wu.horizontal = 1] = `horizontal`, wu[wu.vertical = 2] = `vertical`, wu[wu.horizontalOnly = 3] = `horizontalOnly`;
      class Tu {
        constructor() {
          this.scale = 1, this.fontStack = ``, this.imageName = null, this.verticalAlign = `bottom`;
        }
        static forText(e6, t5, n4) {
          let r3 = new Tu();
          return r3.scale = e6 || 1, r3.fontStack = t5, r3.verticalAlign = n4 || `bottom`, r3;
        }
        static forImage(e6, t5) {
          let n4 = new Tu();
          return n4.imageName = e6, n4.verticalAlign = t5 || `bottom`, n4;
        }
      }
      class Eu {
        constructor() {
          this.text = ``, this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(e6, t5) {
          let n4 = new Eu();
          for (let r3 = 0; r3 < e6.sections.length; r3++) {
            let i3 = e6.sections[r3];
            i3.image ? n4.addImageSection(i3) : n4.addTextSection(i3, t5);
          }
          return n4;
        }
        length() {
          return this.text.length;
        }
        getSection(e6) {
          return this.sections[this.sectionIndex[e6]];
        }
        getSectionIndex(e6) {
          return this.sectionIndex[e6];
        }
        getCharCode(e6) {
          return this.text.charCodeAt(e6);
        }
        verticalizePunctuation() {
          this.text = (function(e6) {
            let t5 = ``;
            for (let n4 = 0; n4 < e6.length; n4++) {
              let r3 = e6.charCodeAt(n4 + 1) || null, i3 = e6.charCodeAt(n4 - 1) || null;
              t5 += r3 && Ca(r3) && !tu[e6[n4 + 1]] || i3 && Ca(i3) && !tu[e6[n4 - 1]] || !tu[e6[n4]] ? e6[n4] : tu[e6[n4]];
            }
            return t5;
          })(this.text);
        }
        trim() {
          let e6 = 0;
          for (let t6 = 0; t6 < this.text.length && Ou[this.text.charCodeAt(t6)]; t6++) e6++;
          let t5 = this.text.length;
          for (let n4 = this.text.length - 1; n4 >= 0 && n4 >= e6 && Ou[this.text.charCodeAt(n4)]; n4--) t5--;
          this.text = this.text.substring(e6, t5), this.sectionIndex = this.sectionIndex.slice(e6, t5);
        }
        substring(e6, t5) {
          let n4 = new Eu();
          return n4.text = this.text.substring(e6, t5), n4.sectionIndex = this.sectionIndex.slice(e6, t5), n4.sections = this.sections, n4;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce(((e6, t5) => Math.max(e6, this.sections[t5].scale)), 0);
        }
        getMaxImageSize(e6) {
          let t5 = 0, n4 = 0;
          for (let r3 = 0; r3 < this.length(); r3++) {
            let i3 = this.getSection(r3);
            if (i3.imageName) {
              let r4 = e6[i3.imageName];
              if (!r4) continue;
              let a3 = r4.displaySize;
              t5 = Math.max(t5, a3[0]), n4 = Math.max(n4, a3[1]);
            }
          }
          return { maxImageWidth: t5, maxImageHeight: n4 };
        }
        addTextSection(e6, t5) {
          this.text += e6.text, this.sections.push(Tu.forText(e6.scale, e6.fontStack || t5, e6.verticalAlign));
          let n4 = this.sections.length - 1;
          for (let t6 = 0; t6 < e6.text.length; ++t6) this.sectionIndex.push(n4);
        }
        addImageSection(e6) {
          let t5 = e6.image ? e6.image.name : ``;
          if (t5.length === 0) return void F2(`Can't add FormattedSection with an empty image.`);
          let n4 = this.getNextImageSectionCharCode();
          n4 ? (this.text += String.fromCharCode(n4), this.sections.push(Tu.forImage(t5, e6.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : F2(`Reached maximum number of images 6401`);
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function Du(t5, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3, p3, m3, h3) {
        let g3 = Eu.fromFeature(t5, a3), _3;
        f3 === e5.as.vertical && g3.verticalizePunctuation();
        let { processBidirectionalText: v3, processStyledBidirectionalText: y3 } = Oa;
        if (v3 && g3.sections.length === 1) {
          _3 = [];
          let e6 = v3(g3.toString(), Iu(g3, u3, o3, n4, i3, m3));
          for (let t6 of e6) {
            let e7 = new Eu();
            e7.text = t6, e7.sections = g3.sections;
            for (let n5 = 0; n5 < t6.length; n5++) e7.sectionIndex.push(0);
            _3.push(e7);
          }
        } else if (y3) {
          _3 = [];
          let e6 = y3(g3.text, g3.sectionIndex, Iu(g3, u3, o3, n4, i3, m3));
          for (let t6 of e6) {
            let e7 = new Eu();
            e7.text = t6[0], e7.sectionIndex = t6[1], e7.sections = g3.sections, _3.push(e7);
          }
        } else _3 = (function(e6, t6) {
          let n5 = [], r4 = e6.text, i4 = 0;
          for (let r5 of t6) n5.push(e6.substring(i4, r5)), i4 = r5;
          return i4 < r4.length && n5.push(e6.substring(i4, r4.length)), n5;
        })(g3, Iu(g3, u3, o3, n4, i3, m3));
        let b3 = [], x3 = { positionedLines: b3, text: g3.toString(), top: d3[1], bottom: d3[1], left: d3[0], right: d3[0], writingMode: f3, iconsInText: false, verticalizable: false };
        return (function(e6, t6, n5, r4, i4, a4, o4, s4, c4, l4, u4, d4) {
          let f4 = 0, p4 = 0, m4 = 0, h4 = 0, g4 = s4 === `right` ? 1 : s4 === `left` ? 0 : 0.5, _4 = nu / d4, v4 = 0;
          for (let o5 of i4) {
            o5.trim();
            let i5 = o5.getMaxScale(), s5 = { positionedGlyphs: [], lineOffset: 0 };
            e6.positionedLines[v4] = s5;
            let d5 = s5.positionedGlyphs, y5 = 0;
            if (!o5.length()) {
              p4 += a4, ++v4;
              continue;
            }
            let b5 = Ru(r4, o5, _4);
            for (let a5 = 0; a5 < o5.length(); a5++) {
              let s6 = o5.getSection(a5), m5 = o5.getSectionIndex(a5), h5 = o5.getCharCode(a5), g5 = Bu(c4, u4, h5), v5;
              if (s6.imageName) {
                if (e6.iconsInText = true, s6.scale *= _4, v5 = Hu(s6, g5, i5, b5, r4), !v5) continue;
                y5 = Math.max(y5, v5.imageOffset);
              } else if (v5 = Vu(s6, h5, g5, b5, t6, n5), !v5) continue;
              let { rect: x5, metrics: S3, baselineOffset: C3 } = v5;
              d5.push({ glyph: h5, imageName: s6.imageName, x: f4, y: p4 + C3 + -17, vertical: g5, scale: s6.scale, fontStack: s6.fontStack, sectionIndex: m5, metrics: S3, rect: x5 }), g5 ? (e6.verticalizable = true, f4 += (s6.imageName ? S3.advance : nu) * s6.scale + l4) : f4 += S3.advance * s6.scale + l4;
            }
            d5.length !== 0 && (m4 = Math.max(f4 - l4, m4), Uu(d5, 0, d5.length - 1, g4)), f4 = 0, s5.lineOffset = Math.max(y5, (i5 - 1) * nu);
            let x4 = a4 * i5 + y5;
            p4 += x4, h4 = Math.max(x4, h4), ++v4;
          }
          let { horizontalAlign: y4, verticalAlign: b4 } = Lu(o4);
          (function(e7, t7, n6, r5, i5, a5, o5, s5, c5) {
            let l5 = (t7 - n6) * i5, u5 = 0;
            u5 = a5 === o5 ? -r5 * c5 * o5 + 0.5 * o5 : -s5 * r5 - -17;
            for (let t8 of e7) for (let e8 of t8.positionedGlyphs) e8.x += l5, e8.y += u5;
          })(e6.positionedLines, g4, y4, b4, m4, h4, a4, p4, i4.length), e6.top += -b4 * p4, e6.bottom = e6.top + p4, e6.left += -y4 * m4, e6.right = e6.left + m4;
        })(x3, n4, r3, i3, _3, s3, c3, l3, f3, u3, p3, h3), !(function(e6) {
          for (let t6 of e6) if (t6.positionedGlyphs.length !== 0) return false;
          return true;
        })(b3) && x3;
      }
      let Ou = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, ku = { 10: true, 32: true, 38: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true }, Au = { 40: true };
      function ju(e6, t5, n4, r3, i3, a3) {
        if (t5.imageName) {
          let e7 = r3[t5.imageName];
          return e7 ? e7.displaySize[0] * t5.scale * nu / a3 + i3 : 0;
        }
        {
          let r4 = n4[t5.fontStack], a4 = r4 && r4[e6];
          return a4 ? a4.metrics.advance * t5.scale + i3 : 0;
        }
      }
      function Mu(e6, t5, n4, r3) {
        let i3 = (e6 - t5) ** 2;
        return r3 ? e6 < t5 ? i3 / 2 : 2 * i3 : i3 + Math.abs(n4) * n4;
      }
      function Nu(e6, t5, n4) {
        let r3 = 0;
        return e6 === 10 && (r3 -= 1e4), n4 && (r3 += 150), e6 !== 40 && e6 !== 65288 || (r3 += 50), t5 !== 41 && t5 !== 65289 || (r3 += 50), r3;
      }
      function Pu(e6, t5, n4, r3, i3, a3) {
        let o3 = null, s3 = Mu(t5, n4, i3, a3);
        for (let e7 of r3) {
          let r4 = Mu(t5 - e7.x, n4, i3, a3) + e7.badness;
          r4 <= s3 && (o3 = e7, s3 = r4);
        }
        return { index: e6, x: t5, priorBreak: o3, badness: s3 };
      }
      function Fu(e6) {
        return e6 ? Fu(e6.priorBreak).concat(e6.index) : [];
      }
      function Iu(e6, t5, n4, r3, i3, a3) {
        if (!e6) return [];
        let o3 = [], s3 = (function(e7, t6, n5, r4, i4, a4) {
          let o4 = 0;
          for (let n6 = 0; n6 < e7.length(); n6++) {
            let s4 = e7.getSection(n6);
            o4 += ju(e7.getCharCode(n6), s4, r4, i4, t6, a4);
          }
          return o4 / Math.max(1, Math.ceil(o4 / n5));
        })(e6, t5, n4, r3, i3, a3), c3 = e6.text.indexOf(`\u200B`) >= 0, l3 = 0;
        for (let n5 = 0; n5 < e6.length(); n5++) {
          let d3 = e6.getSection(n5), f3 = e6.getCharCode(n5);
          if (Ou[f3] || (l3 += ju(f3, d3, r3, i3, t5, a3)), n5 < e6.length() - 1) {
            let t6 = !((u3 = f3) < 11904) && (!!Z[`CJK Compatibility Forms`](u3) || !!Z[`CJK Compatibility`](u3) || !!Z[`CJK Strokes`](u3) || !!Z[`CJK Symbols and Punctuation`](u3) || !!Z[`Enclosed CJK Letters and Months`](u3) || !!Z[`Halfwidth and Fullwidth Forms`](u3) || !!Z[`Ideographic Description Characters`](u3) || !!Z[`Vertical Forms`](u3) || xa.test(String.fromCodePoint(u3)));
            (ku[f3] || t6 || d3.imageName || n5 !== e6.length() - 2 && Au[e6.getCharCode(n5 + 1)]) && o3.push(Pu(n5 + 1, l3, s3, o3, Nu(f3, e6.getCharCode(n5 + 1), t6 && c3), false));
          }
        }
        var u3;
        return Fu(Pu(e6.length(), l3, s3, o3, 0, true));
      }
      function Lu(e6) {
        let t5 = 0.5, n4 = 0.5;
        switch (e6) {
          case `right`:
          case `top-right`:
          case `bottom-right`:
            t5 = 1;
            break;
          case `left`:
          case `top-left`:
          case `bottom-left`:
            t5 = 0;
        }
        switch (e6) {
          case `bottom`:
          case `bottom-right`:
          case `bottom-left`:
            n4 = 1;
            break;
          case `top`:
          case `top-right`:
          case `top-left`:
            n4 = 0;
        }
        return { horizontalAlign: t5, verticalAlign: n4 };
      }
      function Ru(e6, t5, n4) {
        let r3 = t5.getMaxScale() * nu, { maxImageWidth: i3, maxImageHeight: a3 } = t5.getMaxImageSize(e6), o3 = Math.max(r3, a3 * n4);
        return { verticalLineContentWidth: Math.max(r3, i3 * n4), horizontalLineContentHeight: o3 };
      }
      function zu(e6) {
        switch (e6) {
          case `top`:
            return 0;
          case `center`:
            return 0.5;
          default:
            return 1;
        }
      }
      function Bu(t5, n4, r3) {
        return !(t5 === e5.as.horizontal || !n4 && !Sa(r3) || n4 && (Ou[r3] || (i3 = r3, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(i3)))));
        var i3;
      }
      function Vu(e6, t5, n4, r3, i3, a3) {
        let o3 = a3[e6.fontStack], s3 = (function(e7, t6, n5, r4) {
          if (e7 && e7.rect) return e7;
          let i4 = t6[n5.fontStack], a4 = i4 && i4[r4];
          return a4 ? { rect: null, metrics: a4.metrics } : null;
        })(o3 && o3[t5], i3, e6, t5);
        if (s3 === null) return null;
        let c3;
        if (n4) c3 = r3.verticalLineContentWidth - e6.scale * nu;
        else {
          let t6 = zu(e6.verticalAlign);
          c3 = (r3.horizontalLineContentHeight - e6.scale * nu) * t6;
        }
        return { rect: s3.rect, metrics: s3.metrics, baselineOffset: c3 };
      }
      function Hu(e6, t5, n4, r3, i3) {
        let a3 = i3[e6.imageName];
        if (!a3) return null;
        let o3 = a3.paddedRect, s3 = a3.displaySize, c3 = { width: s3[0], height: s3[1], left: 1, top: -3, advance: t5 ? s3[1] : s3[0] }, l3;
        if (t5) l3 = r3.verticalLineContentWidth - s3[1] * e6.scale;
        else {
          let t6 = zu(e6.verticalAlign);
          l3 = (r3.horizontalLineContentHeight - s3[1] * e6.scale) * t6;
        }
        return { rect: o3, metrics: c3, baselineOffset: l3, imageOffset: (t5 ? s3[0] : s3[1]) * e6.scale - nu * n4 };
      }
      function Uu(e6, t5, n4, r3) {
        if (r3 === 0) return;
        let i3 = e6[n4], a3 = (e6[n4].x + i3.metrics.advance * i3.scale) * r3;
        for (let r4 = t5; r4 <= n4; r4++) e6[r4].x -= a3;
      }
      function Wu(e6, t5, n4) {
        let { horizontalAlign: r3, verticalAlign: i3 } = Lu(n4), a3 = t5[0] - e6.displaySize[0] * r3, o3 = t5[1] - e6.displaySize[1] * i3;
        return { image: e6, top: o3, bottom: o3 + e6.displaySize[1], left: a3, right: a3 + e6.displaySize[0] };
      }
      function Gu(e6) {
        let t5 = e6.left, n4 = e6.top, r3 = e6.right - t5, i3 = e6.bottom - n4, a3 = e6.image.textFitWidth ?? `stretchOrShrink`, o3 = e6.image.textFitHeight ?? `stretchOrShrink`, s3 = (e6.image.content[2] - e6.image.content[0]) / (e6.image.content[3] - e6.image.content[1]);
        if (o3 === `proportional`) {
          if (a3 === `stretchOnly` && r3 / i3 < s3 || a3 === `proportional`) {
            let e7 = Math.ceil(i3 * s3);
            t5 *= e7 / r3, r3 = e7;
          }
        } else if (a3 === `proportional` && o3 === `stretchOnly` && s3 !== 0 && r3 / i3 > s3) {
          let e7 = Math.ceil(r3 / s3);
          n4 *= e7 / i3, i3 = e7;
        }
        return { x1: t5, y1: n4, x2: t5 + r3, y2: n4 + i3 };
      }
      function Ku(e6, t5, n4, r3, i3, a3) {
        let o3 = e6.image, s3;
        if (o3.content) {
          let e7 = o3.content, t6 = o3.pixelRatio || 1;
          s3 = [e7[0] / t6, e7[1] / t6, o3.displaySize[0] - e7[2] / t6, o3.displaySize[1] - e7[3] / t6];
        }
        let c3 = t5.left * a3, l3 = t5.right * a3, u3, d3, f3, p3;
        n4 === `width` || n4 === `both` ? (p3 = i3[0] + c3 - r3[3], d3 = i3[0] + l3 + r3[1]) : (p3 = i3[0] + (c3 + l3 - o3.displaySize[0]) / 2, d3 = p3 + o3.displaySize[0]);
        let m3 = t5.top * a3, h3 = t5.bottom * a3;
        return n4 === `height` || n4 === `both` ? (u3 = i3[1] + m3 - r3[0], f3 = i3[1] + h3 + r3[2]) : (u3 = i3[1] + (m3 + h3 - o3.displaySize[1]) / 2, f3 = u3 + o3.displaySize[1]), { image: o3, top: u3, right: d3, bottom: f3, left: p3, collisionPadding: s3 };
      }
      let qu = 32640;
      function Ju(e6, t5) {
        let { expression: n4 } = t5;
        if (n4.kind === `constant`) return { kind: `constant`, layoutSize: n4.evaluate(new ka(e6 + 1)) };
        if (n4.kind === `source`) return { kind: `source` };
        {
          let { zoomStops: t6, interpolationType: r3 } = n4, i3 = 0;
          for (; i3 < t6.length && t6[i3] <= e6; ) i3++;
          i3 = Math.max(0, i3 - 1);
          let a3 = i3;
          for (; a3 < t6.length && t6[a3] < e6 + 1; ) a3++;
          a3 = Math.min(t6.length - 1, a3);
          let o3 = t6[i3], s3 = t6[a3];
          return n4.kind === `composite` ? { kind: `composite`, minZoom: o3, maxZoom: s3, interpolationType: r3 } : { kind: `camera`, minZoom: o3, maxZoom: s3, minSize: n4.evaluate(new ka(o3)), maxSize: n4.evaluate(new ka(s3)), interpolationType: r3 };
        }
      }
      function Yu(e6, t5, n4) {
        let r3 = `never`, i3 = e6.get(t5);
        return i3 ? r3 = i3 : e6.get(n4) && (r3 = `always`), r3;
      }
      let Xu = [{ name: `a_fade_opacity`, components: 1, type: `Uint8`, offset: 0 }];
      function Zu(e6, t5, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3) {
        let p3 = s3 ? Math.min(qu, Math.round(s3[0])) : 0, m3 = s3 ? Math.min(qu, Math.round(s3[1])) : 0;
        e6.emplaceBack(t5, n4, Math.round(32 * r3), Math.round(32 * i3), a3, o3, (p3 << 1) + (c3 ? 1 : 0), m3, 16 * l3, 16 * u3, 256 * d3, 256 * f3);
      }
      function Qu(e6, t5, n4) {
        e6.emplaceBack(t5.x, t5.y, n4), e6.emplaceBack(t5.x, t5.y, n4), e6.emplaceBack(t5.x, t5.y, n4), e6.emplaceBack(t5.x, t5.y, n4);
      }
      function $u(e6) {
        for (let t5 of e6.sections) if (Da(t5.text)) return true;
        return false;
      }
      class ed {
        constructor(e6) {
          this.layoutVertexArray = new Wo(), this.indexArray = new Yo(), this.programConfigurations = e6, this.segments = new Qo(), this.dynamicLayoutVertexArray = new Go(), this.opacityVertexArray = new Ko(), this.hasVisibleVertices = false, this.placedSymbolArray = new Do();
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
        }
        upload(e6, t5, n4, r3) {
          this.isEmpty() || (n4 && (this.layoutVertexBuffer = e6.createVertexBuffer(this.layoutVertexArray, Yl.members), this.indexBuffer = e6.createIndexBuffer(this.indexArray, t5), this.dynamicLayoutVertexBuffer = e6.createVertexBuffer(this.dynamicLayoutVertexArray, Xl.members, true), this.opacityVertexBuffer = e6.createVertexBuffer(this.opacityVertexArray, Xu, true), this.opacityVertexBuffer.itemSize = 1), (n4 || r3) && this.programConfigurations.upload(e6));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
        }
      }
      X(`SymbolBuffers`, ed);
      class td {
        constructor(e6, t5, n4) {
          this.layoutVertexArray = new e6(), this.layoutAttributes = t5, this.indexArray = new n4(), this.segments = new Qo(), this.collisionVertexArray = new Jo();
        }
        upload(e6) {
          this.layoutVertexBuffer = e6.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e6.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e6.createVertexBuffer(this.collisionVertexArray, Zl.members, true);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
        }
      }
      X(`CollisionBuffers`, td);
      class nd {
        constructor(t5) {
          this.collisionBoxArray = t5.collisionBoxArray, this.zoom = t5.zoom, this.overscaling = de2(globalThis) ? Math.min(t5.overscaling, 128) : t5.overscaling, this.layers = t5.layers, this.layerIds = this.layers.map(((e6) => e6.id)), this.index = t5.index, this.pixelRatio = t5.pixelRatio, this.sourceLayerIndex = t5.sourceLayerIndex, this.hasDependencies = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [];
          let n4 = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = Ju(this.zoom, n4[`text-size`]), this.iconSizeData = Ju(this.zoom, n4[`icon-size`]);
          let r3 = this.layers[0].layout, i3 = r3.get(`symbol-sort-key`), a3 = r3.get(`symbol-z-order`);
          this.canOverlap = Yu(r3, `text-overlap`, `text-allow-overlap`) !== `never` || Yu(r3, `icon-overlap`, `icon-allow-overlap`) !== `never` || r3.get(`text-ignore-placement`) || r3.get(`icon-ignore-placement`), this.sortFeaturesByKey = a3 !== `viewport-y` && !i3.isConstant(), this.sortFeaturesByY = (a3 === `viewport-y` || a3 === `auto` && !this.sortFeaturesByKey) && this.canOverlap, r3.get(`symbol-placement`) === `point` && (this.writingModes = r3.get(`text-writing-mode`).map(((t6) => e5.as[t6]))), this.stateDependentLayerIds = this.layers.filter(((e6) => e6.isStateDependent())).map(((e6) => e6.id)), this.sourceID = t5.sourceID;
        }
        createArrays() {
          this.text = new ed(new Ds(this.layers, this.zoom, ((e6) => /^text/.test(e6)))), this.icon = new ed(new Ds(this.layers, this.zoom, ((e6) => /^icon/.test(e6)))), this.glyphOffsetArray = new Ao(), this.lineVertexArray = new jo(), this.symbolInstances = new ko(), this.textAnchorOffsets = new No();
        }
        calculateGlyphDependencies(e6, t5, n4, r3, i3) {
          for (let a3 = 0; a3 < e6.length; a3++) if (t5[e6.charCodeAt(a3)] = true, (n4 || r3) && i3) {
            let n5 = tu[e6.charAt(a3)];
            n5 && (t5[n5.charCodeAt(0)] = true);
          }
        }
        populate(t5, n4, r3) {
          let i3 = this.layers[0], a3 = i3.layout, o3 = a3.get(`text-font`), s3 = a3.get(`text-field`), c3 = a3.get(`icon-image`), l3 = (s3.value.kind !== `constant` || s3.value.value instanceof It2 && !s3.value.value.isEmpty() || s3.value.value.toString().length > 0) && (o3.value.kind !== `constant` || o3.value.value.length > 0), u3 = c3.value.kind !== `constant` || !!c3.value.value || Object.keys(c3.parameters).length > 0, d3 = a3.get(`symbol-sort-key`);
          if (this.features = [], !l3 && !u3) return;
          let f3 = n4.iconDependencies, p3 = n4.glyphDependencies, m3 = n4.availableImages, h3 = new ka(this.zoom);
          for (let { feature: n5, id: s4, index: c4, sourceLayerIndex: g3 } of t5) {
            let t6 = i3._featureFilter.needGeometry, _3 = Ns(n5, t6);
            if (!i3._featureFilter.filter(h3, _3, r3)) continue;
            let v3, y3;
            if (t6 || (_3.geometry = Ms(n5)), l3) {
              let e6 = i3.getValueAndResolveTokens(`text-field`, _3, r3, m3), t7 = It2.factory(e6), n6 = this.hasRTLText = this.hasRTLText || $u(t7);
              (!n6 || Oa.getRTLTextPluginStatus() === `unavailable` || n6 && Oa.isParsed()) && (v3 = eu(t7, i3, _3));
            }
            if (u3) {
              let e6 = i3.getValueAndResolveTokens(`icon-image`, _3, r3, m3);
              y3 = e6 instanceof Ut2 ? e6 : Ut2.fromString(e6);
            }
            if (!v3 && !y3) continue;
            let b3 = this.sortFeaturesByKey ? d3.evaluate(_3, {}, r3) : void 0;
            if (this.features.push({ id: s4, text: v3, icon: y3, index: c4, sourceLayerIndex: g3, geometry: _3.geometry, properties: n5.properties, type: yl.types[n5.type], sortKey: b3 }), y3 && (f3[y3.name] = true), v3) {
              let t7 = o3.evaluate(_3, {}, r3).join(`,`), n6 = a3.get(`text-rotation-alignment`) !== `viewport` && a3.get(`symbol-placement`) !== `point`;
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(e5.as.vertical) >= 0;
              for (let e6 of v3.sections) if (e6.image) f3[e6.image.name] = true;
              else {
                let r4 = ga(v3.toString()), i4 = e6.fontStack || t7, a4 = p3[i4] = p3[i4] || {};
                this.calculateGlyphDependencies(e6.text, a4, n6, this.allowVerticalPlacement, r4);
              }
            }
          }
          a3.get(`symbol-placement`) === `line` && (this.features = (function(e6) {
            let t6 = {}, n5 = {}, r4 = [], i4 = 0;
            function a4(t7) {
              r4.push(e6[t7]), i4++;
            }
            function o4(e7, t7, i5) {
              let a5 = n5[e7];
              return delete n5[e7], n5[t7] = a5, r4[a5].geometry[0].pop(), r4[a5].geometry[0] = r4[a5].geometry[0].concat(i5[0]), a5;
            }
            function s4(e7, n6, i5) {
              let a5 = t6[n6];
              return delete t6[n6], t6[e7] = a5, r4[a5].geometry[0].shift(), r4[a5].geometry[0] = i5[0].concat(r4[a5].geometry[0]), a5;
            }
            function c4(e7, t7, n6) {
              let r5 = n6 ? t7[0][t7[0].length - 1] : t7[0][0];
              return `${e7}:${r5.x}:${r5.y}`;
            }
            for (let l4 = 0; l4 < e6.length; l4++) {
              let u4 = e6[l4], d4 = u4.geometry, f4 = u4.text ? u4.text.toString() : null;
              if (!f4) {
                a4(l4);
                continue;
              }
              let p4 = c4(f4, d4), m4 = c4(f4, d4, true);
              if (p4 in n5 && m4 in t6 && n5[p4] !== t6[m4]) {
                let e7 = s4(p4, m4, d4), i5 = o4(p4, m4, r4[e7].geometry);
                delete t6[p4], delete n5[m4], n5[c4(f4, r4[i5].geometry, true)] = i5, r4[e7].geometry = null;
              } else p4 in n5 ? o4(p4, m4, d4) : m4 in t6 ? s4(p4, m4, d4) : (a4(l4), t6[p4] = i4 - 1, n5[m4] = i4 - 1);
            }
            return r4.filter(((e7) => e7.geometry));
          })(this.features)), this.sortFeaturesByKey && this.features.sort(((e6, t6) => e6.sortKey - t6.sortKey));
        }
        update(e6, t5, n4) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(e6, t5, this.layers, { imagePositions: n4 }), this.icon.programConfigurations.updatePaintArrays(e6, t5, this.layers, { imagePositions: n4 }));
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(e6) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e6), this.iconCollisionBox.upload(e6)), this.text.upload(e6, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(e6, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(e6, t5) {
          let n4 = this.lineVertexArray.length;
          if (e6.segment !== void 0) {
            let n5 = e6.dist(t5[e6.segment + 1]), r3 = e6.dist(t5[e6.segment]), i3 = {};
            for (let r4 = e6.segment + 1; r4 < t5.length; r4++) i3[r4] = { x: t5[r4].x, y: t5[r4].y, tileUnitDistanceFromAnchor: n5 }, r4 < t5.length - 1 && (n5 += t5[r4 + 1].dist(t5[r4]));
            for (let n6 = e6.segment || 0; n6 >= 0; n6--) i3[n6] = { x: t5[n6].x, y: t5[n6].y, tileUnitDistanceFromAnchor: r3 }, n6 > 0 && (r3 += t5[n6 - 1].dist(t5[n6]));
            for (let e7 = 0; e7 < t5.length; e7++) {
              let t6 = i3[e7];
              this.lineVertexArray.emplaceBack(t6.x, t6.y, t6.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: n4, lineLength: this.lineVertexArray.length - n4 };
        }
        addSymbols(t5, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3) {
          let p3 = t5.indexArray, m3 = t5.layoutVertexArray, h3 = t5.segments.prepareSegment(4 * n4.length, m3, p3, this.canOverlap ? o3.sortKey : void 0), g3 = this.glyphOffsetArray.length, _3 = h3.vertexLength, v3 = this.allowVerticalPlacement && s3 === e5.as.vertical ? Math.PI / 2 : 0, y3 = o3.text && o3.text.sections;
          for (let e6 = 0; e6 < n4.length; e6++) {
            let { tl: i4, tr: a4, bl: s4, br: l4, tex: u4, pixelOffsetTL: d4, pixelOffsetBR: g4, minFontScaleX: _4, minFontScaleY: b3, glyphOffset: x3, isSDF: S3, sectionIndex: C3 } = n4[e6], w3 = h3.vertexLength, T3 = x3[1];
            Zu(m3, c3.x, c3.y, i4.x, T3 + i4.y, u4.x, u4.y, r3, S3, d4.x, d4.y, _4, b3), Zu(m3, c3.x, c3.y, a4.x, T3 + a4.y, u4.x + u4.w, u4.y, r3, S3, g4.x, d4.y, _4, b3), Zu(m3, c3.x, c3.y, s4.x, T3 + s4.y, u4.x, u4.y + u4.h, r3, S3, d4.x, g4.y, _4, b3), Zu(m3, c3.x, c3.y, l4.x, T3 + l4.y, u4.x + u4.w, u4.y + u4.h, r3, S3, g4.x, g4.y, _4, b3), Qu(t5.dynamicLayoutVertexArray, c3, v3), p3.emplaceBack(w3, w3 + 2, w3 + 1), p3.emplaceBack(w3 + 1, w3 + 2, w3 + 3), h3.vertexLength += 4, h3.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(x3[0]), e6 !== n4.length - 1 && C3 === n4[e6 + 1].sectionIndex || t5.programConfigurations.populatePaintArrays(m3.length, o3, o3.index, { imagePositions: {}, canonical: f3, formattedSection: y3 && y3[C3] });
          }
          t5.placedSymbolArray.emplaceBack(c3.x, c3.y, g3, this.glyphOffsetArray.length - g3, _3, l3, u3, c3.segment, r3 ? r3[0] : 0, r3 ? r3[1] : 0, i3[0], i3[1], s3, 0, false, 0, d3);
        }
        _addCollisionDebugVertex(e6, t5, n4, r3, i3, a3) {
          return t5.emplaceBack(0, 0), e6.emplaceBack(n4.x, n4.y, r3, i3, Math.round(a3.x), Math.round(a3.y));
        }
        addCollisionDebugVertices(e6, t5, r3, i3, a3, o3, s3) {
          let c3 = a3.segments.prepareSegment(4, a3.layoutVertexArray, a3.indexArray), l3 = c3.vertexLength, u3 = a3.layoutVertexArray, d3 = a3.collisionVertexArray, f3 = s3.anchorX, p3 = s3.anchorY;
          this._addCollisionDebugVertex(u3, d3, o3, f3, p3, new n3(e6, t5)), this._addCollisionDebugVertex(u3, d3, o3, f3, p3, new n3(r3, t5)), this._addCollisionDebugVertex(u3, d3, o3, f3, p3, new n3(r3, i3)), this._addCollisionDebugVertex(u3, d3, o3, f3, p3, new n3(e6, i3)), c3.vertexLength += 4;
          let m3 = a3.indexArray;
          m3.emplaceBack(l3, l3 + 1), m3.emplaceBack(l3 + 1, l3 + 2), m3.emplaceBack(l3 + 2, l3 + 3), m3.emplaceBack(l3 + 3, l3), c3.primitiveLength += 4;
        }
        addDebugCollisionBoxes(e6, t5, n4, r3) {
          for (let i3 = e6; i3 < t5; i3++) {
            let e7 = this.collisionBoxArray.get(i3);
            this.addCollisionDebugVertices(e7.x1, e7.y1, e7.x2, e7.y2, r3 ? this.textCollisionBox : this.iconCollisionBox, e7.anchorPoint, n4);
          }
        }
        generateCollisionDebugBuffers() {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new td(qo, Ql.members, Xo), this.iconCollisionBox = new td(qo, Ql.members, Xo);
          for (let e6 = 0; e6 < this.symbolInstances.length; e6++) {
            let t5 = this.symbolInstances.get(e6);
            this.addDebugCollisionBoxes(t5.textBoxStartIndex, t5.textBoxEndIndex, t5, true), this.addDebugCollisionBoxes(t5.verticalTextBoxStartIndex, t5.verticalTextBoxEndIndex, t5, true), this.addDebugCollisionBoxes(t5.iconBoxStartIndex, t5.iconBoxEndIndex, t5, false), this.addDebugCollisionBoxes(t5.verticalIconBoxStartIndex, t5.verticalIconBoxEndIndex, t5, false);
          }
        }
        _deserializeCollisionBoxesForSymbol(e6, t5, n4, r3, i3, a3, o3, s3, c3) {
          let l3 = {};
          for (let r4 = t5; r4 < n4; r4++) {
            let t6 = e6.get(r4);
            l3.textBox = { x1: t6.x1, y1: t6.y1, x2: t6.x2, y2: t6.y2, anchorPointX: t6.anchorPointX, anchorPointY: t6.anchorPointY }, l3.textFeatureIndex = t6.featureIndex;
            break;
          }
          for (let t6 = r3; t6 < i3; t6++) {
            let n5 = e6.get(t6);
            l3.verticalTextBox = { x1: n5.x1, y1: n5.y1, x2: n5.x2, y2: n5.y2, anchorPointX: n5.anchorPointX, anchorPointY: n5.anchorPointY }, l3.verticalTextFeatureIndex = n5.featureIndex;
            break;
          }
          for (let t6 = a3; t6 < o3; t6++) {
            let n5 = e6.get(t6);
            l3.iconBox = { x1: n5.x1, y1: n5.y1, x2: n5.x2, y2: n5.y2, anchorPointX: n5.anchorPointX, anchorPointY: n5.anchorPointY }, l3.iconFeatureIndex = n5.featureIndex;
            break;
          }
          for (let t6 = s3; t6 < c3; t6++) {
            let n5 = e6.get(t6);
            l3.verticalIconBox = { x1: n5.x1, y1: n5.y1, x2: n5.x2, y2: n5.y2, anchorPointX: n5.anchorPointX, anchorPointY: n5.anchorPointY }, l3.verticalIconFeatureIndex = n5.featureIndex;
            break;
          }
          return l3;
        }
        deserializeCollisionBoxes(e6) {
          this.collisionArrays = [];
          for (let t5 = 0; t5 < this.symbolInstances.length; t5++) {
            let n4 = this.symbolInstances.get(t5);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e6, n4.textBoxStartIndex, n4.textBoxEndIndex, n4.verticalTextBoxStartIndex, n4.verticalTextBoxEndIndex, n4.iconBoxStartIndex, n4.iconBoxEndIndex, n4.verticalIconBoxStartIndex, n4.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(e6, t5) {
          let n4 = e6.placedSymbolArray.get(t5), r3 = n4.vertexStartIndex + 4 * n4.numGlyphs;
          for (let t6 = n4.vertexStartIndex; t6 < r3; t6 += 4) e6.indexArray.emplaceBack(t6, t6 + 2, t6 + 1), e6.indexArray.emplaceBack(t6 + 1, t6 + 2, t6 + 3);
        }
        getSortedSymbolIndexes(e6) {
          if (this.sortedAngle === e6 && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
          let t5 = Math.sin(e6), n4 = Math.cos(e6), r3 = [], i3 = [], a3 = [];
          for (let e7 = 0; e7 < this.symbolInstances.length; ++e7) {
            a3.push(e7);
            let o3 = this.symbolInstances.get(e7);
            r3.push(0 | Math.round(t5 * o3.anchorX + n4 * o3.anchorY)), i3.push(o3.featureIndex);
          }
          return a3.sort(((e7, t6) => r3[e7] - r3[t6] || i3[t6] - i3[e7])), a3;
        }
        addToSortKeyRanges(e6, t5) {
          let n4 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          n4 && n4.sortKey === t5 ? n4.symbolInstanceEnd = e6 + 1 : this.sortKeyRanges.push({ sortKey: t5, symbolInstanceStart: e6, symbolInstanceEnd: e6 + 1 });
        }
        sortFeatures(e6) {
          if (this.sortFeaturesByY && this.sortedAngle !== e6 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e6), this.sortedAngle = e6, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (let e7 of this.symbolInstanceIndexes) {
              let t5 = this.symbolInstances.get(e7);
              this.featureSortOrder.push(t5.featureIndex), [t5.rightJustifiedTextSymbolIndex, t5.centerJustifiedTextSymbolIndex, t5.leftJustifiedTextSymbolIndex].forEach(((e8, t6, n4) => {
                e8 >= 0 && n4.indexOf(e8) === t6 && this.addIndicesForPlacedSymbol(this.text, e8);
              })), t5.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, t5.verticalPlacedTextSymbolIndex), t5.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, t5.placedIconSymbolIndex), t5.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, t5.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      let rd, id;
      X(`SymbolBucket`, nd, { omit: [`layers`, `collisionBoxArray`, `features`, `compareText`] }), nd.MAX_GLYPHS = 65535, nd.addDynamicAttributes = Qu;
      var ad = { get paint() {
        return id || (id = new Ha({ "icon-opacity": new $(R2.paint_symbol[`icon-opacity`]), "icon-color": new $(R2.paint_symbol[`icon-color`]), "icon-halo-color": new $(R2.paint_symbol[`icon-halo-color`]), "icon-halo-width": new $(R2.paint_symbol[`icon-halo-width`]), "icon-halo-blur": new $(R2.paint_symbol[`icon-halo-blur`]), "icon-translate": new Q(R2.paint_symbol[`icon-translate`]), "icon-translate-anchor": new Q(R2.paint_symbol[`icon-translate-anchor`]), "text-opacity": new $(R2.paint_symbol[`text-opacity`]), "text-color": new $(R2.paint_symbol[`text-color`], { runtimeType: Ye2, getOverride: (e6) => e6.textColor, hasOverride: (e6) => !!e6.textColor }), "text-halo-color": new $(R2.paint_symbol[`text-halo-color`]), "text-halo-width": new $(R2.paint_symbol[`text-halo-width`]), "text-halo-blur": new $(R2.paint_symbol[`text-halo-blur`]), "text-translate": new Q(R2.paint_symbol[`text-translate`]), "text-translate-anchor": new Q(R2.paint_symbol[`text-translate-anchor`]) }));
      }, get layout() {
        return rd || (rd = new Ha({ "symbol-placement": new Q(R2.layout_symbol[`symbol-placement`]), "symbol-spacing": new Q(R2.layout_symbol[`symbol-spacing`]), "symbol-avoid-edges": new Q(R2.layout_symbol[`symbol-avoid-edges`]), "symbol-sort-key": new $(R2.layout_symbol[`symbol-sort-key`]), "symbol-z-order": new Q(R2.layout_symbol[`symbol-z-order`]), "icon-allow-overlap": new Q(R2.layout_symbol[`icon-allow-overlap`]), "icon-overlap": new Q(R2.layout_symbol[`icon-overlap`]), "icon-ignore-placement": new Q(R2.layout_symbol[`icon-ignore-placement`]), "icon-optional": new Q(R2.layout_symbol[`icon-optional`]), "icon-rotation-alignment": new Q(R2.layout_symbol[`icon-rotation-alignment`]), "icon-size": new $(R2.layout_symbol[`icon-size`]), "icon-text-fit": new Q(R2.layout_symbol[`icon-text-fit`]), "icon-text-fit-padding": new Q(R2.layout_symbol[`icon-text-fit-padding`]), "icon-image": new $(R2.layout_symbol[`icon-image`]), "icon-rotate": new $(R2.layout_symbol[`icon-rotate`]), "icon-padding": new $(R2.layout_symbol[`icon-padding`]), "icon-keep-upright": new Q(R2.layout_symbol[`icon-keep-upright`]), "icon-offset": new $(R2.layout_symbol[`icon-offset`]), "icon-anchor": new $(R2.layout_symbol[`icon-anchor`]), "icon-pitch-alignment": new Q(R2.layout_symbol[`icon-pitch-alignment`]), "text-pitch-alignment": new Q(R2.layout_symbol[`text-pitch-alignment`]), "text-rotation-alignment": new Q(R2.layout_symbol[`text-rotation-alignment`]), "text-field": new $(R2.layout_symbol[`text-field`]), "text-font": new $(R2.layout_symbol[`text-font`]), "text-size": new $(R2.layout_symbol[`text-size`]), "text-max-width": new $(R2.layout_symbol[`text-max-width`]), "text-line-height": new Q(R2.layout_symbol[`text-line-height`]), "text-letter-spacing": new $(R2.layout_symbol[`text-letter-spacing`]), "text-justify": new $(R2.layout_symbol[`text-justify`]), "text-radial-offset": new $(R2.layout_symbol[`text-radial-offset`]), "text-variable-anchor": new Q(R2.layout_symbol[`text-variable-anchor`]), "text-variable-anchor-offset": new $(R2.layout_symbol[`text-variable-anchor-offset`]), "text-anchor": new $(R2.layout_symbol[`text-anchor`]), "text-max-angle": new Q(R2.layout_symbol[`text-max-angle`]), "text-writing-mode": new Q(R2.layout_symbol[`text-writing-mode`]), "text-rotate": new $(R2.layout_symbol[`text-rotate`]), "text-padding": new Q(R2.layout_symbol[`text-padding`]), "text-keep-upright": new Q(R2.layout_symbol[`text-keep-upright`]), "text-transform": new $(R2.layout_symbol[`text-transform`]), "text-offset": new $(R2.layout_symbol[`text-offset`]), "text-allow-overlap": new Q(R2.layout_symbol[`text-allow-overlap`]), "text-overlap": new Q(R2.layout_symbol[`text-overlap`]), "text-ignore-placement": new Q(R2.layout_symbol[`text-ignore-placement`]), "text-optional": new Q(R2.layout_symbol[`text-optional`]) }));
      } };
      class od {
        constructor(e6) {
          if (e6.property.overrides === void 0) throw Error(`overrides must be provided to instantiate FormatSectionOverride class`);
          this.type = e6.property.overrides ? e6.property.overrides.runtimeType : Je2, this.defaultValue = e6;
        }
        evaluate(e6) {
          if (e6.formattedSection) {
            let t5 = this.defaultValue.property.overrides;
            if (t5 && t5.hasOverride(e6.formattedSection)) return t5.getOverride(e6.formattedSection);
          }
          return e6.feature && e6.featureState ? this.defaultValue.evaluate(e6.feature, e6.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(e6) {
          this.defaultValue.isConstant() || e6(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return null;
        }
      }
      X(`FormatSectionOverride`, od, { omit: [`defaultValue`] });
      class sd extends Wa {
        constructor(e6, t5) {
          super(e6, ad, t5);
        }
        recalculate(e6, t5) {
          if (super.recalculate(e6, t5), this.layout.get(`icon-rotation-alignment`) === `auto` && (this.layout._values[`icon-rotation-alignment`] = this.layout.get(`symbol-placement`) === `point` ? `viewport` : `map`), this.layout.get(`text-rotation-alignment`) === `auto` && (this.layout._values[`text-rotation-alignment`] = this.layout.get(`symbol-placement`) === `point` ? `viewport` : `map`), this.layout.get(`text-pitch-alignment`) === `auto` && (this.layout._values[`text-pitch-alignment`] = this.layout.get(`text-rotation-alignment`) === `map` ? `map` : `viewport`), this.layout.get(`icon-pitch-alignment`) === `auto` && (this.layout._values[`icon-pitch-alignment`] = this.layout.get(`icon-rotation-alignment`)), this.layout.get(`symbol-placement`) === `point`) {
            let e7 = this.layout.get(`text-writing-mode`);
            if (e7) {
              let t6 = [];
              for (let n4 of e7) t6.indexOf(n4) < 0 && t6.push(n4);
              this.layout._values[`text-writing-mode`] = t6;
            } else this.layout._values[`text-writing-mode`] = [`horizontal`];
          }
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(e6, t5, n4, r3) {
          let i3 = this.layout.get(e6).evaluate(t5, {}, n4, r3), a3 = this._unevaluatedLayout._values[e6];
          return a3.isDataDriven() || ri(a3.value) || !i3 ? i3 : (function(e7, t6) {
            return t6.replace(/{([^{}]+)}/g, ((t7, n5) => e7 && n5 in e7 ? String(e7[n5]) : ``));
          })(t5.properties, i3);
        }
        createBucket(e6) {
          return new nd(e6);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          throw Error(`Should take a different path in FeatureIndex`);
        }
        _setPaintOverrides() {
          for (let e6 of ad.paint.overridableProperties) {
            if (!sd.hasPaintOverride(this.layout, e6)) continue;
            let t5 = this.paint.get(e6), n4 = new ni(new od(t5), t5.property.specification), r3 = null;
            r3 = t5.value.kind === `constant` || t5.value.kind === `source` ? new ai(`source`, n4) : new oi(`composite`, n4, t5.value.zoomStops), this.paint._values[e6] = new La(t5.property, r3, t5.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(e6, t5, n4) {
          return !(!this.layout || t5.isDataDriven() || n4.isDataDriven()) && sd.hasPaintOverride(this.layout, e6);
        }
        static hasPaintOverride(e6, t5) {
          let n4 = e6.get(`text-field`), r3 = ad.paint.properties[t5], i3 = false, a3 = (e7) => {
            for (let t6 of e7) if (r3.overrides && r3.overrides.hasOverride(t6)) return void (i3 = true);
          };
          if (n4.value.kind === `constant` && n4.value.value instanceof It2) a3(n4.value.value.sections);
          else if (n4.value.kind === `source` || n4.value.kind === `composite`) {
            let e7 = (t7) => {
              i3 || (t7 instanceof Yt2 && qt2(t7.value) === $e2 ? a3(t7.value.sections) : t7 instanceof jn ? a3(t7.sections) : t7.eachChild(e7));
            }, t6 = n4.value;
            t6._styleExpression && e7(t6._styleExpression.expression);
          }
          return i3;
        }
      }
      let cd;
      var ld = { get paint() {
        return cd || (cd = new Ha({ "background-color": new Q(R2.paint_background[`background-color`]), "background-pattern": new Ba(R2.paint_background[`background-pattern`]), "background-opacity": new Q(R2.paint_background[`background-opacity`]) }));
      } };
      class ud extends Wa {
        constructor(e6, t5) {
          super(e6, ld, t5);
        }
      }
      class dd extends Wa {
        constructor(e6, t5) {
          super(e6, {}, t5), this.onAdd = (e7) => {
            this.implementation.onAdd && this.implementation.onAdd(e7, e7.painter.context.gl);
          }, this.onRemove = (e7) => {
            this.implementation.onRemove && this.implementation.onRemove(e7, e7.painter.context.gl);
          }, this.implementation = e6;
        }
        is3D() {
          return this.implementation.renderingMode === `3d`;
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== void 0;
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return false;
        }
        serialize() {
          throw Error(`Custom layers cannot be serialized`);
        }
      }
      class fd {
        constructor(e6) {
          this._methodToThrottle = e6, this._triggered = false, typeof MessageChannel < `u` && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = false, this._methodToThrottle();
          });
        }
        trigger() {
          this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout((() => {
            this._triggered = false, this._methodToThrottle();
          }), 0));
        }
        remove() {
          delete this._channel, this._methodToThrottle = () => {
          };
        }
      }
      let pd = { once: true }, md = 63710088e-1;
      class hd {
        constructor(e6, t5) {
          if (isNaN(e6) || isNaN(t5)) throw Error(`Invalid LngLat object: (${e6}, ${t5})`);
          if (this.lng = +e6, this.lat = +t5, this.lat > 90 || this.lat < -90) throw Error(`Invalid LngLat latitude value: must be between -90 and 90`);
        }
        wrap() {
          return new hd(ne2(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(e6) {
          let t5 = Math.PI / 180, n4 = this.lat * t5, r3 = e6.lat * t5, i3 = Math.sin(n4) * Math.sin(r3) + Math.cos(n4) * Math.cos(r3) * Math.cos((e6.lng - this.lng) * t5);
          return md * Math.acos(Math.min(i3, 1));
        }
        static convert(e6) {
          if (e6 instanceof hd) return e6;
          if (Array.isArray(e6) && (e6.length === 2 || e6.length === 3)) return new hd(Number(e6[0]), Number(e6[1]));
          if (!Array.isArray(e6) && typeof e6 == `object` && e6) return new hd(Number(`lng` in e6 ? e6.lng : e6.lon), Number(e6.lat));
          throw Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      let gd = 2 * Math.PI * md;
      function _d2(e6) {
        return gd * Math.cos(e6 * Math.PI / 180);
      }
      function vd(e6) {
        return (180 + e6) / 360;
      }
      function yd(e6) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e6 * Math.PI / 360))) / 360;
      }
      function bd(e6, t5) {
        return e6 / _d2(t5);
      }
      function xd(e6) {
        return 360 * e6 - 180;
      }
      function Sd(e6) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * e6) * Math.PI / 180)) - 90;
      }
      function Cd(e6, t5) {
        return e6 * _d2(Sd(t5));
      }
      class wd {
        constructor(e6, t5, n4 = 0) {
          this.x = +e6, this.y = +t5, this.z = +n4;
        }
        static fromLngLat(e6, t5 = 0) {
          let n4 = hd.convert(e6);
          return new wd(vd(n4.lng), yd(n4.lat), bd(t5, n4.lat));
        }
        toLngLat() {
          return new hd(xd(this.x), Sd(this.y));
        }
        toAltitude() {
          return Cd(this.z, this.y);
        }
        meterInMercatorCoordinateUnits() {
          return 1 / gd * (e6 = Sd(this.y), 1 / Math.cos(e6 * Math.PI / 180));
          var e6;
        }
      }
      function Td(e6, t5, n4) {
        var r3 = 2 * Math.PI * 6378137 / 256 / 2 ** n4;
        return [e6 * r3 - 2 * Math.PI * 6378137 / 2, t5 * r3 - 2 * Math.PI * 6378137 / 2];
      }
      class Ed {
        constructor(e6, t5, n4) {
          if (!(function(e7, t6, n5) {
            return !(e7 < 0 || e7 > 25 || n5 < 0 || n5 >= 2 ** e7 || t6 < 0 || t6 >= 2 ** e7);
          })(e6, t5, n4)) throw Error(`x=${t5}, y=${n4}, z=${e6} outside of bounds. 0<=x<${2 ** e6}, 0<=y<${2 ** e6} 0<=z<=25 `);
          this.z = e6, this.x = t5, this.y = n4, this.key = kd(0, e6, e6, t5, n4);
        }
        equals(e6) {
          return this.z === e6.z && this.x === e6.x && this.y === e6.y;
        }
        url(e6, t5, n4) {
          let r3 = (a3 = this.y, o3 = this.z, s3 = Td(256 * (i3 = this.x), 256 * (a3 = 2 ** o3 - a3 - 1), o3), c3 = Td(256 * (i3 + 1), 256 * (a3 + 1), o3), s3[0] + `,` + s3[1] + `,` + c3[0] + `,` + c3[1]);
          var i3, a3, o3, s3, c3;
          let l3 = (function(e7, t6, n5) {
            let r4, i4 = ``;
            for (let a4 = e7; a4 > 0; a4--) r4 = 1 << a4 - 1, i4 += (t6 & r4 ? 1 : 0) + (n5 & r4 ? 2 : 0);
            return i4;
          })(this.z, this.x, this.y);
          return e6[(this.x + this.y) % e6.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(n4 === `tms` ? 2 ** this.z - this.y - 1 : this.y)).replace(/{ratio}/g, t5 > 1 ? `@2x` : ``).replace(/{quadkey}/g, l3).replace(/{bbox-epsg-3857}/g, r3);
        }
        isChildOf(e6) {
          let t5 = this.z - e6.z;
          return t5 > 0 && e6.x === this.x >> t5 && e6.y === this.y >> t5;
        }
        getTilePoint(e6) {
          let t5 = 2 ** this.z;
          return new n3((e6.x * t5 - this.x) * O2, (e6.y * t5 - this.y) * O2);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class Dd {
        constructor(e6, t5) {
          this.wrap = e6, this.canonical = t5, this.key = kd(e6, t5.z, t5.z, t5.x, t5.y);
        }
      }
      class Od {
        constructor(e6, t5, n4, r3, i3) {
          if (this.terrainRttPosMatrix32f = null, e6 < n4) throw Error(`overscaledZ should be >= z; overscaledZ = ${e6}; z = ${n4}`);
          this.overscaledZ = e6, this.wrap = t5, this.canonical = new Ed(n4, +r3, +i3), this.key = kd(t5, e6, n4, r3, i3);
        }
        clone() {
          return new Od(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        equals(e6) {
          return this.overscaledZ === e6.overscaledZ && this.wrap === e6.wrap && this.canonical.equals(e6.canonical);
        }
        scaledTo(e6) {
          if (e6 > this.overscaledZ) throw Error(`targetZ > this.overscaledZ; targetZ = ${e6}; overscaledZ = ${this.overscaledZ}`);
          let t5 = this.canonical.z - e6;
          return e6 > this.canonical.z ? new Od(e6, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Od(e6, this.wrap, e6, this.canonical.x >> t5, this.canonical.y >> t5);
        }
        isOverscaled() {
          return this.overscaledZ > this.canonical.z;
        }
        calculateScaledKey(e6, t5) {
          if (e6 > this.overscaledZ) throw Error(`targetZ > this.overscaledZ; targetZ = ${e6}; overscaledZ = ${this.overscaledZ}`);
          let n4 = this.canonical.z - e6;
          return e6 > this.canonical.z ? kd(this.wrap * +t5, e6, this.canonical.z, this.canonical.x, this.canonical.y) : kd(this.wrap * +t5, e6, e6, this.canonical.x >> n4, this.canonical.y >> n4);
        }
        isChildOf(e6) {
          if (e6.wrap !== this.wrap || this.overscaledZ - e6.overscaledZ <= 0) return false;
          if (e6.overscaledZ === 0) return this.overscaledZ > 0;
          let t5 = this.canonical.z - e6.canonical.z;
          return !(t5 < 0) && e6.canonical.x === this.canonical.x >> t5 && e6.canonical.y === this.canonical.y >> t5;
        }
        children(e6) {
          if (this.overscaledZ >= e6) return [new Od(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          let t5 = this.canonical.z + 1, n4 = 2 * this.canonical.x, r3 = 2 * this.canonical.y;
          return [new Od(t5, this.wrap, t5, n4, r3), new Od(t5, this.wrap, t5, n4 + 1, r3), new Od(t5, this.wrap, t5, n4, r3 + 1), new Od(t5, this.wrap, t5, n4 + 1, r3 + 1)];
        }
        isLessThan(e6) {
          return this.wrap < e6.wrap || !(this.wrap > e6.wrap) && (this.overscaledZ < e6.overscaledZ || !(this.overscaledZ > e6.overscaledZ) && (this.canonical.x < e6.canonical.x || !(this.canonical.x > e6.canonical.x) && this.canonical.y < e6.canonical.y));
        }
        wrapped() {
          return new Od(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(e6) {
          return new Od(this.overscaledZ, e6, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return 2 ** (this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new Dd(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
        getTilePoint(e6) {
          return this.canonical.getTilePoint(new wd(e6.x - this.wrap, e6.y));
        }
      }
      function kd(e6, t5, n4, r3, i3) {
        (e6 *= 2) < 0 && (e6 = -1 * e6 - 1);
        let a3 = 1 << n4;
        return (a3 * a3 * e6 + a3 * i3 + r3).toString(36) + n4.toString(36) + t5.toString(36);
      }
      function Ad(e6, t5) {
        return t5 ? e6.properties[t5] : e6.id;
      }
      X(`CanonicalTileID`, Ed), X(`OverscaledTileID`, Od, { omit: [`terrainRttPosMatrix32f`] });
      class jd {
        constructor() {
          this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0;
        }
        extend(e6) {
          return this.minX = Math.min(this.minX, e6.x), this.minY = Math.min(this.minY, e6.y), this.maxX = Math.max(this.maxX, e6.x), this.maxY = Math.max(this.maxY, e6.y), this;
        }
        expandBy(e6) {
          return this.minX -= e6, this.minY -= e6, this.maxX += e6, this.maxY += e6, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this;
        }
        shrinkBy(e6) {
          return this.expandBy(-e6);
        }
        map(e6) {
          let t5 = new jd();
          return t5.extend(e6(new n3(this.minX, this.minY))), t5.extend(e6(new n3(this.maxX, this.minY))), t5.extend(e6(new n3(this.minX, this.maxY))), t5.extend(e6(new n3(this.maxX, this.maxY))), t5;
        }
        static fromPoints(e6) {
          let t5 = new jd();
          for (let n4 of e6) t5.extend(n4);
          return t5;
        }
        contains(e6) {
          return e6.x >= this.minX && e6.x <= this.maxX && e6.y >= this.minY && e6.y <= this.maxY;
        }
        empty() {
          return this.minX > this.maxX;
        }
        width() {
          return this.maxX - this.minX;
        }
        height() {
          return this.maxY - this.minY;
        }
        covers(e6) {
          return !this.empty() && !e6.empty() && e6.minX >= this.minX && e6.maxX <= this.maxX && e6.minY >= this.minY && e6.maxY <= this.maxY;
        }
        intersects(e6) {
          return !this.empty() && !e6.empty() && e6.minX <= this.maxX && e6.maxX >= this.minX && e6.minY <= this.maxY && e6.maxY >= this.minY;
        }
      }
      class Md {
        constructor(e6) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let t5 = 0; t5 < e6.length; t5++) {
            let n4 = e6[t5];
            this._stringToNumber[n4] = t5, this._numberToString[t5] = n4;
          }
        }
        encode(e6) {
          return this._stringToNumber[e6];
        }
        decode(e6) {
          if (e6 >= this._numberToString.length) throw Error(`Out of bounds. Index requested n=${e6} can't be >= this._numberToString.length ${this._numberToString.length}`);
          return this._numberToString[e6];
        }
      }
      class Nd {
        constructor(e6, t5, n4, r3, i3) {
          this.type = `Feature`, this._vectorTileFeature = e6, e6._z = t5, e6._x = n4, e6._y = r3, this.properties = e6.properties, this.id = i3;
        }
        get geometry() {
          return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
        }
        set geometry(e6) {
          this._geometry = e6;
        }
        toJSON() {
          let e6 = { geometry: this.geometry };
          for (let t5 in this) t5 !== `_geometry` && t5 !== `_vectorTileFeature` && (e6[t5] = this[t5]);
          return e6;
        }
      }
      class Pd {
        constructor(e6, t5) {
          this.tileID = e6, this.x = e6.canonical.x, this.y = e6.canonical.y, this.z = e6.canonical.z, this.grid = new ca(O2, 16, 0), this.grid3D = new ca(O2, 16, 0), this.featureIndexArray = new Fo(), this.promoteId = t5;
        }
        insert(e6, t5, n4, r3, i3, a3) {
          let o3 = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(n4, r3, i3);
          let s3 = a3 ? this.grid3D : this.grid;
          for (let e7 = 0; e7 < t5.length; e7++) {
            let n5 = t5[e7], r4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let e8 = 0; e8 < n5.length; e8++) {
              let t6 = n5[e8];
              r4[0] = Math.min(r4[0], t6.x), r4[1] = Math.min(r4[1], t6.y), r4[2] = Math.max(r4[2], t6.x), r4[3] = Math.max(r4[3], t6.y);
            }
            r4[0] < O2 && r4[1] < O2 && r4[2] >= 0 && r4[3] >= 0 && s3.insert(o3, r4[0], r4[1], r4[2], r4[3]);
          }
        }
        loadVTLayers() {
          return this.vtLayers || (this.vtLayers = new wl(new ou(this.rawTileData)).layers, this.sourceLayerCoder = new Md(this.vtLayers ? Object.keys(this.vtLayers).sort() : [`_geojsonTileLayer`])), this.vtLayers;
        }
        query(e6, t5, r3, i3) {
          this.loadVTLayers();
          let a3 = e6.params, o3 = O2 / e6.tileSize / e6.scale, s3 = mi(a3.filter, a3.globalState), c3 = e6.queryGeometry, l3 = e6.queryPadding * o3, u3 = jd.fromPoints(c3), d3 = this.grid.query(u3.minX - l3, u3.minY - l3, u3.maxX + l3, u3.maxY + l3), f3 = jd.fromPoints(e6.cameraQueryGeometry).expandBy(l3), p3 = this.grid3D.query(f3.minX, f3.minY, f3.maxX, f3.maxY, ((t6, r4, i4, a4) => (function(e7, t7, r5, i5, a5) {
            for (let n4 of e7) if (t7 <= n4.x && r5 <= n4.y && i5 >= n4.x && a5 >= n4.y) return true;
            let o4 = [new n3(t7, r5), new n3(t7, a5), new n3(i5, a5), new n3(i5, r5)];
            if (e7.length > 2) {
              for (let t8 of o4) if (Ks(e7, t8)) return true;
            }
            for (let t8 = 0; t8 < e7.length - 1; t8++) if (qs(e7[t8], e7[t8 + 1], o4)) return true;
            return false;
          })(e6.cameraQueryGeometry, t6 - l3, r4 - l3, i4 + l3, a4 + l3)));
          for (let e7 of p3) d3.push(e7);
          d3.sort(Id);
          let m3 = {}, h3;
          for (let n4 = 0; n4 < d3.length; n4++) {
            let l4 = d3[n4];
            if (l4 === h3) continue;
            h3 = l4;
            let u4 = this.featureIndexArray.get(l4), f4 = null;
            this.loadMatchingFeature(m3, u4.bucketIndex, u4.sourceLayerIndex, u4.featureIndex, s3, a3.layers, a3.availableImages, t5, r3, i3, ((t6, n5, r4) => (f4 || (f4 = Ms(t6)), n5.queryIntersectsFeature({ queryGeometry: c3, feature: t6, featureState: r4, geometry: f4, zoom: this.z, transform: e6.transform, pixelsToTileUnits: o3, pixelPosMatrix: e6.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: e6.getElevation }))));
          }
          return m3;
        }
        loadMatchingFeature(e6, t5, n4, r3, i3, a3, o3, s3, c3, l3, u3) {
          let d3 = this.bucketLayerIDs[t5];
          if (a3 && !d3.some(((e7) => a3.has(e7)))) return;
          let f3 = this.sourceLayerCoder.decode(n4), p3 = this.vtLayers[f3].feature(r3);
          if (i3.needGeometry) {
            let e7 = Ns(p3, true);
            if (!i3.filter(new ka(this.tileID.overscaledZ), e7, this.tileID.canonical)) return;
          } else if (!i3.filter(new ka(this.tileID.overscaledZ), p3)) return;
          let m3 = this.getId(p3, f3);
          for (let t6 = 0; t6 < d3.length; t6++) {
            let n5 = d3[t6];
            if (a3 && !a3.has(n5)) continue;
            let i4 = s3[n5];
            if (!i4) continue;
            let f4 = {};
            m3 && l3 && (f4 = l3.getState(i4.sourceLayer || `_geojsonTileLayer`, m3));
            let h3 = P2({}, c3[n5]);
            h3.paint = Fd(h3.paint, i4.paint, p3, f4, o3), h3.layout = Fd(h3.layout, i4.layout, p3, f4, o3);
            let g3 = !u3 || u3(p3, i4, f4);
            if (!g3) continue;
            let _3 = new Nd(p3, this.z, this.x, this.y, m3);
            _3.layer = h3;
            let v3 = e6[n5];
            v3 === void 0 && (v3 = e6[n5] = []), v3.push({ featureIndex: r3, feature: _3, intersectionZ: g3 });
          }
        }
        lookupSymbolFeatures(e6, t5, n4, r3, i3, a3, o3, s3) {
          let c3 = {};
          this.loadVTLayers();
          let l3 = mi(i3.filterSpec, i3.globalState);
          for (let i4 of e6) this.loadMatchingFeature(c3, n4, r3, i4, l3, a3, o3, s3, t5);
          return c3;
        }
        hasLayer(e6) {
          for (let t5 of this.bucketLayerIDs) for (let n4 of t5) if (e6 === n4) return true;
          return false;
        }
        getId(e6, t5) {
          var n4;
          let r3 = e6.id;
          return this.promoteId && (r3 = e6.properties[typeof this.promoteId == `string` ? this.promoteId : this.promoteId[t5]], typeof r3 == `boolean` && (r3 = Number(r3)), r3 === void 0 && (n4 = e6.properties) != null && n4.cluster && this.promoteId && (r3 = Number(e6.properties.cluster_id))), r3;
        }
      }
      function Fd(e6, t5, n4, r3, i3) {
        return ie2(e6, ((e7, a3) => {
          let o3 = t5 instanceof Ra ? t5.get(a3) : null;
          return o3 && o3.evaluate ? o3.evaluate(n4, r3, i3) : o3;
        }));
      }
      function Id(e6, t5) {
        return t5 - e6;
      }
      function Ld(e6, t5, r3, i3, a3) {
        let o3 = [];
        for (let s3 = 0; s3 < e6.length; s3++) {
          let c3 = e6[s3], l3;
          for (let e7 = 0; e7 < c3.length - 1; e7++) {
            let s4 = c3[e7], u3 = c3[e7 + 1];
            s4.x < t5 && u3.x < t5 || (s4.x < t5 ? s4 = new n3(t5, s4.y + (t5 - s4.x) / (u3.x - s4.x) * (u3.y - s4.y))._round() : u3.x < t5 && (u3 = new n3(t5, s4.y + (t5 - s4.x) / (u3.x - s4.x) * (u3.y - s4.y))._round()), s4.y < r3 && u3.y < r3 || (s4.y < r3 ? s4 = new n3(s4.x + (r3 - s4.y) / (u3.y - s4.y) * (u3.x - s4.x), r3)._round() : u3.y < r3 && (u3 = new n3(s4.x + (r3 - s4.y) / (u3.y - s4.y) * (u3.x - s4.x), r3)._round()), s4.x >= i3 && u3.x >= i3 || (s4.x >= i3 ? s4 = new n3(i3, s4.y + (i3 - s4.x) / (u3.x - s4.x) * (u3.y - s4.y))._round() : u3.x >= i3 && (u3 = new n3(i3, s4.y + (i3 - s4.x) / (u3.x - s4.x) * (u3.y - s4.y))._round()), s4.y >= a3 && u3.y >= a3 || (s4.y >= a3 ? s4 = new n3(s4.x + (a3 - s4.y) / (u3.y - s4.y) * (u3.x - s4.x), a3)._round() : u3.y >= a3 && (u3 = new n3(s4.x + (a3 - s4.y) / (u3.y - s4.y) * (u3.x - s4.x), a3)._round()), l3 && s4.equals(l3[l3.length - 1]) || (l3 = [s4], o3.push(l3)), l3.push(u3)))));
          }
        }
        return o3;
      }
      X(`FeatureIndex`, Pd, { omit: [`rawTileData`, `sourceLayerCoder`] });
      class Rd extends n3 {
        constructor(e6, t5, n4, r3) {
          super(e6, t5), this.angle = n4, r3 !== void 0 && (this.segment = r3);
        }
        clone() {
          return new Rd(this.x, this.y, this.angle, this.segment);
        }
      }
      function zd(e6, t5, n4, r3, i3) {
        if (t5.segment === void 0 || n4 === 0) return true;
        let a3 = t5, o3 = t5.segment + 1, s3 = 0;
        for (; s3 > -n4 / 2; ) {
          if (o3--, o3 < 0) return false;
          s3 -= e6[o3].dist(a3), a3 = e6[o3];
        }
        s3 += e6[o3].dist(e6[o3 + 1]), o3++;
        let c3 = [], l3 = 0;
        for (; s3 < n4 / 2; ) {
          let t6 = e6[o3], n5 = e6[o3 + 1];
          if (!n5) return false;
          let a4 = e6[o3 - 1].angleTo(t6) - t6.angleTo(n5);
          for (a4 = Math.abs((a4 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), c3.push({ distance: s3, angleDelta: a4 }), l3 += a4; s3 - c3[0].distance > r3; ) l3 -= c3.shift().angleDelta;
          if (l3 > i3) return false;
          o3++, s3 += t6.dist(n5);
        }
        return true;
      }
      function Bd(e6) {
        let t5 = 0;
        for (let n4 = 0; n4 < e6.length - 1; n4++) t5 += e6[n4].dist(e6[n4 + 1]);
        return t5;
      }
      function Vd(e6, t5, n4) {
        return e6 ? 0.6 * t5 * n4 : 0;
      }
      function Hd(e6, t5) {
        return Math.max(e6 ? e6.right - e6.left : 0, t5 ? t5.right - t5.left : 0);
      }
      function Ud(e6, t5, n4, r3, i3, a3) {
        let o3 = Vd(n4, i3, a3), s3 = Hd(n4, r3) * a3, c3 = 0, l3 = Bd(e6) / 2;
        for (let n5 = 0; n5 < e6.length - 1; n5++) {
          let r4 = e6[n5], i4 = e6[n5 + 1], a4 = r4.dist(i4);
          if (c3 + a4 > l3) {
            let u3 = (l3 - c3) / a4, d3 = new Rd(vn.number(r4.x, i4.x, u3), vn.number(r4.y, i4.y, u3), i4.angleTo(r4), n5);
            return d3._round(), !o3 || zd(e6, d3, s3, o3, t5) ? d3 : void 0;
          }
          c3 += a4;
        }
      }
      function Wd(e6, t5, n4, r3, i3, a3, o3, s3, c3) {
        let l3 = Vd(r3, a3, o3), u3 = Hd(r3, i3), d3 = u3 * o3, f3 = e6[0].x === 0 || e6[0].x === c3 || e6[0].y === 0 || e6[0].y === c3;
        return t5 - d3 < t5 / 4 && (t5 = d3 + t5 / 4), Gd(e6, f3 ? t5 / 2 * s3 % t5 : (u3 / 2 + 2 * a3) * o3 * s3 % t5, t5, l3, n4, d3, f3, false, c3);
      }
      function Gd(e6, t5, n4, r3, i3, a3, o3, s3, c3) {
        let l3 = a3 / 2, u3 = Bd(e6), d3 = 0, f3 = t5 - n4, p3 = [];
        for (let t6 = 0; t6 < e6.length - 1; t6++) {
          let o4 = e6[t6], s4 = e6[t6 + 1], m3 = o4.dist(s4), h3 = s4.angleTo(o4);
          for (; f3 + n4 < d3 + m3; ) {
            f3 += n4;
            let g3 = (f3 - d3) / m3, _3 = vn.number(o4.x, s4.x, g3), v3 = vn.number(o4.y, s4.y, g3);
            if (_3 >= 0 && _3 < c3 && v3 >= 0 && v3 < c3 && f3 - l3 >= 0 && f3 + l3 <= u3) {
              let n5 = new Rd(_3, v3, h3, t6);
              n5._round(), r3 && !zd(e6, n5, a3, r3, i3) || p3.push(n5);
            }
          }
          d3 += m3;
        }
        return s3 || p3.length || o3 || (p3 = Gd(e6, d3 / 2, n4, r3, i3, a3, o3, true, c3)), p3;
      }
      function Kd(e6, t5, r3, i3) {
        let a3 = [], o3 = e6.image, s3 = o3.pixelRatio, c3 = o3.paddedRect.w - 2, l3 = o3.paddedRect.h - 2, u3 = { x1: e6.left, y1: e6.top, x2: e6.right, y2: e6.bottom }, d3 = o3.stretchX || [[0, c3]], f3 = o3.stretchY || [[0, l3]], p3 = (e7, t6) => e7 + t6[1] - t6[0], m3 = d3.reduce(p3, 0), h3 = f3.reduce(p3, 0), g3 = c3 - m3, _3 = l3 - h3, v3 = 0, y3 = m3, b3 = 0, x3 = h3, S3 = 0, C3 = g3, w3 = 0, T3 = _3;
        if (o3.content && i3) {
          let t6 = o3.content, n4 = t6[2] - t6[0], r4 = t6[3] - t6[1];
          (o3.textFitWidth || o3.textFitHeight) && (u3 = Gu(e6)), v3 = qd(d3, 0, t6[0]), b3 = qd(f3, 0, t6[1]), y3 = qd(d3, t6[0], t6[2]), x3 = qd(f3, t6[1], t6[3]), S3 = t6[0] - v3, w3 = t6[1] - b3, C3 = n4 - y3, T3 = r4 - x3;
        }
        let E3 = u3.x1, D3 = u3.y1, O3 = u3.x2 - E3, k3 = u3.y2 - D3, A3 = (e7, i4, a4, c4) => {
          let l4 = Yd(e7.stretch - v3, y3, O3, E3), u4 = Xd(e7.fixed - S3, C3, e7.stretch, m3), d4 = Yd(i4.stretch - b3, x3, k3, D3), f4 = Xd(i4.fixed - w3, T3, i4.stretch, h3), p4 = Yd(a4.stretch - v3, y3, O3, E3), g4 = Xd(a4.fixed - S3, C3, a4.stretch, m3), _4 = Yd(c4.stretch - b3, x3, k3, D3), A4 = Xd(c4.fixed - w3, T3, c4.stretch, h3), ee3 = new n3(l4, d4), j3 = new n3(p4, d4), M3 = new n3(p4, _4), te3 = new n3(l4, _4), N3 = new n3(u4 / s3, f4 / s3), ne3 = new n3(g4 / s3, A4 / s3), P3 = t5 * Math.PI / 180;
          if (P3) {
            let e8 = Math.sin(P3), t6 = Math.cos(P3), n4 = [t6, -e8, e8, t6];
            ee3._matMult(n4), j3._matMult(n4), te3._matMult(n4), M3._matMult(n4);
          }
          let re3 = e7.stretch + e7.fixed, ie3 = i4.stretch + i4.fixed;
          return { tl: ee3, tr: j3, bl: te3, br: M3, tex: { x: o3.paddedRect.x + 1 + re3, y: o3.paddedRect.y + 1 + ie3, w: a4.stretch + a4.fixed - re3, h: c4.stretch + c4.fixed - ie3 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: N3, pixelOffsetBR: ne3, minFontScaleX: C3 / s3 / O3, minFontScaleY: T3 / s3 / k3, isSDF: r3 };
        };
        if (i3 && (o3.stretchX || o3.stretchY)) {
          let e7 = Jd(d3, g3, m3), t6 = Jd(f3, _3, h3);
          for (let n4 = 0; n4 < e7.length - 1; n4++) {
            let r4 = e7[n4], i4 = e7[n4 + 1];
            for (let e8 = 0; e8 < t6.length - 1; e8++) a3.push(A3(r4, t6[e8], i4, t6[e8 + 1]));
          }
        } else a3.push(A3({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: c3 + 1 }, { fixed: 0, stretch: l3 + 1 }));
        return a3;
      }
      function qd(e6, t5, n4) {
        let r3 = 0;
        for (let i3 of e6) r3 += Math.max(t5, Math.min(n4, i3[1])) - Math.max(t5, Math.min(n4, i3[0]));
        return r3;
      }
      function Jd(e6, t5, n4) {
        let r3 = [{ fixed: -1, stretch: 0 }];
        for (let [t6, n5] of e6) {
          let e7 = r3[r3.length - 1];
          r3.push({ fixed: t6 - e7.stretch, stretch: e7.stretch }), r3.push({ fixed: t6 - e7.stretch, stretch: e7.stretch + (n5 - t6) });
        }
        return r3.push({ fixed: t5 + 1, stretch: n4 }), r3;
      }
      function Yd(e6, t5, n4, r3) {
        return e6 / t5 * n4 + r3;
      }
      function Xd(e6, t5, n4, r3) {
        return e6 - t5 * n4 / r3;
      }
      X(`Anchor`, Rd);
      class Zd {
        constructor(e6, t5, r3, i3, a3, o3, s3, c3, l3, u3) {
          var _a3;
          if (this.boxStartIndex = e6.length, l3) {
            let e7 = o3.top, t6 = o3.bottom, n4 = o3.collisionPadding;
            n4 && (e7 -= n4[1], t6 += n4[3]);
            let r4 = t6 - e7;
            r4 > 0 && (r4 = Math.max(10, r4), this.circleDiameter = r4);
          } else {
            let l4 = ((_a3 = o3.image) == null ? void 0 : _a3.content) && (o3.image.textFitWidth || o3.image.textFitHeight) ? Gu(o3) : { x1: o3.left, y1: o3.top, x2: o3.right, y2: o3.bottom };
            l4.y1 = l4.y1 * s3 - c3[0], l4.y2 = l4.y2 * s3 + c3[2], l4.x1 = l4.x1 * s3 - c3[3], l4.x2 = l4.x2 * s3 + c3[1];
            let d3 = o3.collisionPadding;
            if (d3 && (l4.x1 -= d3[0] * s3, l4.y1 -= d3[1] * s3, l4.x2 += d3[2] * s3, l4.y2 += d3[3] * s3), u3) {
              let e7 = new n3(l4.x1, l4.y1), t6 = new n3(l4.x2, l4.y1), r4 = new n3(l4.x1, l4.y2), i4 = new n3(l4.x2, l4.y2), a4 = u3 * Math.PI / 180;
              e7._rotate(a4), t6._rotate(a4), r4._rotate(a4), i4._rotate(a4), l4.x1 = Math.min(e7.x, t6.x, r4.x, i4.x), l4.x2 = Math.max(e7.x, t6.x, r4.x, i4.x), l4.y1 = Math.min(e7.y, t6.y, r4.y, i4.y), l4.y2 = Math.max(e7.y, t6.y, r4.y, i4.y);
            }
            e6.emplaceBack(t5.x, t5.y, l4.x1, l4.y1, l4.x2, l4.y2, r3, i3, a3);
          }
          this.boxEndIndex = e6.length;
        }
      }
      class Qd {
        constructor(e6 = [], t5 = (e7, t6) => e7 < t6 ? -1 : e7 > t6 ? 1 : 0) {
          if (this.data = e6, this.length = this.data.length, this.compare = t5, this.length > 0) for (let e7 = (this.length >> 1) - 1; e7 >= 0; e7--) this._down(e7);
        }
        push(e6) {
          this.data.push(e6), this._up(this.length++);
        }
        pop() {
          if (this.length === 0) return;
          let e6 = this.data[0], t5 = this.data.pop();
          return --this.length > 0 && (this.data[0] = t5, this._down(0)), e6;
        }
        peek() {
          return this.data[0];
        }
        _up(e6) {
          let { data: t5, compare: n4 } = this, r3 = t5[e6];
          for (; e6 > 0; ) {
            let i3 = e6 - 1 >> 1, a3 = t5[i3];
            if (n4(r3, a3) >= 0) break;
            t5[e6] = a3, e6 = i3;
          }
          t5[e6] = r3;
        }
        _down(e6) {
          let { data: t5, compare: n4 } = this, r3 = this.length >> 1, i3 = t5[e6];
          for (; e6 < r3; ) {
            let r4 = 1 + (e6 << 1), a3 = r4 + 1;
            if (a3 < this.length && n4(t5[a3], t5[r4]) < 0 && (r4 = a3), n4(t5[r4], i3) >= 0) break;
            t5[e6] = t5[r4], e6 = r4;
          }
          t5[e6] = i3;
        }
      }
      function $d(e6, t5 = 1, r3 = false) {
        let i3 = jd.fromPoints(e6[0]), a3 = Math.min(i3.width(), i3.height()), o3 = a3 / 2, s3 = new Qd([], ef), { minX: c3, minY: l3, maxX: u3, maxY: d3 } = i3;
        if (a3 === 0) return new n3(c3, l3);
        for (let t6 = c3; t6 < u3; t6 += a3) for (let n4 = l3; n4 < d3; n4 += a3) s3.push(new tf(t6 + o3, n4 + o3, o3, e6));
        let f3 = (function(e7) {
          let t6 = 0, n4 = 0, r4 = 0, i4 = e7[0];
          for (let e8 = 0, a4 = i4.length, o4 = a4 - 1; e8 < a4; o4 = e8++) {
            let a5 = i4[e8], s4 = i4[o4], c4 = a5.x * s4.y - s4.x * a5.y;
            n4 += (a5.x + s4.x) * c4, r4 += (a5.y + s4.y) * c4, t6 += 3 * c4;
          }
          return new tf(n4 / t6, r4 / t6, 0, e7);
        })(e6), p3 = s3.length;
        for (; s3.length; ) {
          let n4 = s3.pop();
          (n4.d > f3.d || !f3.d) && (f3 = n4, r3 && console.log(`found best %d after %d probes`, Math.round(1e4 * n4.d) / 1e4, p3)), n4.max - f3.d <= t5 || (o3 = n4.h / 2, s3.push(new tf(n4.p.x - o3, n4.p.y - o3, o3, e6)), s3.push(new tf(n4.p.x + o3, n4.p.y - o3, o3, e6)), s3.push(new tf(n4.p.x - o3, n4.p.y + o3, o3, e6)), s3.push(new tf(n4.p.x + o3, n4.p.y + o3, o3, e6)), p3 += 4);
        }
        return r3 && (console.log(`num probes: ${p3}`), console.log(`best distance: ${f3.d}`)), f3.p;
      }
      function ef(e6, t5) {
        return t5.max - e6.max;
      }
      function tf(e6, t5, r3, i3) {
        this.p = new n3(e6, t5), this.h = r3, this.d = (function(e7, t6) {
          let n4 = false, r4 = 1 / 0;
          for (let i4 = 0; i4 < t6.length; i4++) {
            let a3 = t6[i4];
            for (let t7 = 0, i5 = a3.length, o3 = i5 - 1; t7 < i5; o3 = t7++) {
              let i6 = a3[t7], s3 = a3[o3];
              i6.y > e7.y != s3.y > e7.y && e7.x < (s3.x - i6.x) * (e7.y - i6.y) / (s3.y - i6.y) + i6.x && (n4 = !n4), r4 = Math.min(r4, Ws(e7, i6, s3));
            }
          }
          return (n4 ? 1 : -1) * Math.sqrt(r4);
        })(this.p, i3), this.max = this.d + this.h * Math.SQRT2;
      }
      var nf;
      e5.aI = void 0, (nf = e5.aI || (e5.aI = {}))[nf.center = 1] = `center`, nf[nf.left = 2] = `left`, nf[nf.right = 3] = `right`, nf[nf.top = 4] = `top`, nf[nf.bottom = 5] = `bottom`, nf[nf[`top-left`] = 6] = `top-left`, nf[nf[`top-right`] = 7] = `top-right`, nf[nf[`bottom-left`] = 8] = `bottom-left`, nf[nf[`bottom-right`] = 9] = `bottom-right`;
      let rf = 1 / 0;
      function af(e6, t5) {
        return t5[1] === rf ? (function(e7, t6) {
          let n4 = 0, r3 = 0;
          t6 < 0 && (t6 = 0);
          let i3 = t6 / Math.SQRT2;
          switch (e7) {
            case `top-right`:
            case `top-left`:
              r3 = i3 - 7;
              break;
            case `bottom-right`:
            case `bottom-left`:
              r3 = 7 - i3;
              break;
            case `bottom`:
              r3 = 7 - t6;
              break;
            case `top`:
              r3 = t6 - 7;
          }
          switch (e7) {
            case `top-right`:
            case `bottom-right`:
              n4 = -i3;
              break;
            case `top-left`:
            case `bottom-left`:
              n4 = i3;
              break;
            case `left`:
              n4 = t6;
              break;
            case `right`:
              n4 = -t6;
          }
          return [n4, r3];
        })(e6, t5[0]) : (function(e7, t6, n4) {
          let r3 = 0, i3 = 0;
          switch (t6 = Math.abs(t6), n4 = Math.abs(n4), e7) {
            case `top-right`:
            case `top-left`:
            case `top`:
              i3 = n4 - 7;
              break;
            case `bottom-right`:
            case `bottom-left`:
            case `bottom`:
              i3 = 7 - n4;
          }
          switch (e7) {
            case `top-right`:
            case `bottom-right`:
            case `right`:
              r3 = -t6;
              break;
            case `top-left`:
            case `bottom-left`:
            case `left`:
              r3 = t6;
          }
          return [r3, i3];
        })(e6, t5[0], t5[1]);
      }
      function of(e6, t5, n4) {
        var _a3;
        let r3 = e6.layout, i3 = (_a3 = r3.get(`text-variable-anchor-offset`)) == null ? void 0 : _a3.evaluate(t5, {}, n4);
        if (i3) {
          let e7 = i3.values, t6 = [];
          for (let n5 = 0; n5 < e7.length; n5 += 2) {
            let r4 = t6[n5] = e7[n5], i4 = e7[n5 + 1].map(((e8) => e8 * nu));
            r4.startsWith(`top`) ? i4[1] -= 7 : r4.startsWith(`bottom`) && (i4[1] += 7), t6[n5 + 1] = i4;
          }
          return new Ht2(t6);
        }
        let a3 = r3.get(`text-variable-anchor`);
        if (a3) {
          let i4;
          i4 = e6._unevaluatedLayout.getValue(`text-radial-offset`) === void 0 ? r3.get(`text-offset`).evaluate(t5, {}, n4).map(((e7) => e7 * nu)) : [r3.get(`text-radial-offset`).evaluate(t5, {}, n4) * nu, rf];
          let o3 = [];
          for (let e7 of a3) o3.push(e7, af(e7, i4));
          return new Ht2(o3);
        }
        return null;
      }
      function sf(e6) {
        switch (e6) {
          case `right`:
          case `top-right`:
          case `bottom-right`:
            return `right`;
          case `left`:
          case `top-left`:
          case `bottom-left`:
            return `left`;
        }
        return `center`;
      }
      function cf(t5, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3) {
        let p3 = o3.textMaxSize.evaluate(n4, {});
        p3 === void 0 && (p3 = s3);
        let m3 = t5.layers[0].layout, h3 = m3.get(`icon-offset`).evaluate(n4, {}, d3), g3 = uf(r3.horizontal), _3 = s3 / 24, v3 = t5.tilePixelRatio * _3, y3 = t5.tilePixelRatio * p3 / 24, b3 = t5.tilePixelRatio * c3, x3 = t5.tilePixelRatio * m3.get(`symbol-spacing`), S3 = m3.get(`text-padding`) * t5.tilePixelRatio, C3 = (function(e6, t6, n5, r4 = 1) {
          let i4 = e6.get(`icon-padding`).evaluate(t6, {}, n5), a4 = i4 && i4.values;
          return [a4[0] * r4, a4[1] * r4, a4[2] * r4, a4[3] * r4];
        })(m3, n4, d3, t5.tilePixelRatio), w3 = m3.get(`text-max-angle`) / 180 * Math.PI, T3 = m3.get(`text-rotation-alignment`) !== `viewport` && m3.get(`symbol-placement`) !== `point`, E3 = m3.get(`icon-rotation-alignment`) === `map` && m3.get(`symbol-placement`) !== `point`, D3 = m3.get(`symbol-placement`), k3 = x3 / 2, A3 = m3.get(`icon-text-fit`), ee3;
        i3 && A3 !== `none` && (t5.allowVerticalPlacement && r3.vertical && (ee3 = Ku(i3, r3.vertical, A3, m3.get(`icon-text-fit-padding`), h3, _3)), g3 && (i3 = Ku(i3, g3, A3, m3.get(`icon-text-fit-padding`), h3, _3)));
        let j3 = d3 ? f3.line.getGranularityForZoomLevel(d3.z) : 1, M3 = (c4, f4) => {
          f4.x < 0 || f4.x >= O2 || f4.y < 0 || f4.y >= O2 || (function(t6, n5, r4, i4, a4, o4, s4, c5, l4, u4, d4, f5, p4, m4, h4, g4, _4, v4, y4, b4, x4, S4, C4, w4, T4) {
            let E4 = t6.addToLineVertexArray(n5, r4), D4, O3, k4, A4, ee4 = 0, j4 = 0, M4 = 0, te3 = 0, N3 = -1, ne3 = -1, P3 = {}, re3 = cs(``);
            if (t6.allowVerticalPlacement && i4.vertical) {
              let e6 = c5.layout.get(`text-rotate`).evaluate(x4, {}, w4) + 90;
              k4 = new Zd(l4, n5, u4, d4, f5, i4.vertical, p4, m4, h4, e6), s4 && (A4 = new Zd(l4, n5, u4, d4, f5, s4, _4, v4, h4, e6));
            }
            if (a4) {
              let r5 = c5.layout.get(`icon-rotate`).evaluate(x4, {}), i5 = c5.layout.get(`icon-text-fit`) !== `none`, o5 = Kd(a4, r5, C4, i5), p5 = s4 ? Kd(s4, r5, C4, i5) : void 0;
              O3 = new Zd(l4, n5, u4, d4, f5, a4, _4, v4, false, r5), ee4 = 4 * o5.length;
              let m5 = t6.iconSizeData, h5 = null;
              m5.kind === `source` ? (h5 = [128 * c5.layout.get(`icon-size`).evaluate(x4, {})], h5[0] > qu && F2(`${t6.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : m5.kind === `composite` && (h5 = [128 * S4.compositeIconSizes[0].evaluate(x4, {}, w4), 128 * S4.compositeIconSizes[1].evaluate(x4, {}, w4)], (h5[0] > qu || h5[1] > qu) && F2(`${t6.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), t6.addSymbols(t6.icon, o5, h5, b4, y4, x4, e5.as.none, n5, E4.lineStartIndex, E4.lineLength, -1, w4), N3 = t6.icon.placedSymbolArray.length - 1, p5 && (j4 = 4 * p5.length, t6.addSymbols(t6.icon, p5, h5, b4, y4, x4, e5.as.vertical, n5, E4.lineStartIndex, E4.lineLength, -1, w4), ne3 = t6.icon.placedSymbolArray.length - 1);
            }
            let ie3 = Object.keys(i4.horizontal);
            for (let r5 of ie3) {
              let a5 = i4.horizontal[r5];
              D4 || (D4 = (re3 = cs(a5.text), new Zd(l4, n5, u4, d4, f5, a5, p4, m4, h4, c5.layout.get(`text-rotate`).evaluate(x4, {}, w4))));
              let s5 = a5.positionedLines.length === 1;
              if (M4 += lf(t6, n5, a5, o4, c5, h4, x4, g4, E4, i4.vertical ? e5.as.horizontal : e5.as.horizontalOnly, s5 ? ie3 : [r5], P3, N3, S4, w4), s5) break;
            }
            i4.vertical && (te3 += lf(t6, n5, i4.vertical, o4, c5, h4, x4, g4, E4, e5.as.vertical, [`vertical`], P3, ne3, S4, w4));
            let ae3 = D4 ? D4.boxStartIndex : t6.collisionBoxArray.length, oe3 = D4 ? D4.boxEndIndex : t6.collisionBoxArray.length, se3 = k4 ? k4.boxStartIndex : t6.collisionBoxArray.length, ce3 = k4 ? k4.boxEndIndex : t6.collisionBoxArray.length, le3 = O3 ? O3.boxStartIndex : t6.collisionBoxArray.length, ue3 = O3 ? O3.boxEndIndex : t6.collisionBoxArray.length, de3 = A4 ? A4.boxStartIndex : t6.collisionBoxArray.length, fe3 = A4 ? A4.boxEndIndex : t6.collisionBoxArray.length, pe3 = -1, I3 = (e6, t7) => e6 && e6.circleDiameter ? Math.max(e6.circleDiameter, t7) : t7;
            pe3 = I3(D4, pe3), pe3 = I3(k4, pe3), pe3 = I3(O3, pe3), pe3 = I3(A4, pe3);
            let me3 = pe3 > -1 ? 1 : 0;
            me3 && (pe3 *= T4 / nu), t6.glyphOffsetArray.length >= nd.MAX_GLYPHS && F2(`Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907`), x4.sortKey !== void 0 && t6.addToSortKeyRanges(t6.symbolInstances.length, x4.sortKey);
            let he3 = of(c5, x4, w4), [ge3, _e3] = (function(t7, n6) {
              let r5 = t7.length, i5 = n6 == null ? void 0 : n6.values;
              if ((i5 == null ? void 0 : i5.length) > 0) for (let n7 = 0; n7 < i5.length; n7 += 2) {
                let r6 = i5[n7 + 1];
                t7.emplaceBack(e5.aI[i5[n7]], r6[0], r6[1]);
              }
              return [r5, t7.length];
            })(t6.textAnchorOffsets, he3);
            t6.symbolInstances.emplaceBack(n5.x, n5.y, P3.right >= 0 ? P3.right : -1, P3.center >= 0 ? P3.center : -1, P3.left >= 0 ? P3.left : -1, P3.vertical || -1, N3, ne3, re3, ae3, oe3, se3, ce3, le3, ue3, de3, fe3, u4, M4, te3, ee4, j4, me3, 0, p4, pe3, ge3, _e3);
          })(t5, f4, c4, r3, i3, a3, ee3, t5.layers[0], t5.collisionBoxArray, n4.index, n4.sourceLayerIndex, t5.index, v3, [S3, S3, S3, S3], T3, l3, b3, C3, E3, h3, n4, o3, u3, d3, s3);
        };
        if (D3 === `line`) for (let e6 of Ld(n4.geometry, 0, 0, O2, O2)) {
          let n5 = sl(e6, j3), a4 = Wd(n5, x3, w3, r3.vertical || g3, i3, 24, y3, t5.overscaling, O2);
          for (let e7 of a4) g3 && df(t5, g3.text, k3, e7) || M3(n5, e7);
        }
        else if (D3 === `line-center`) {
          for (let e6 of n4.geometry) if (e6.length > 1) {
            let t6 = sl(e6, j3), n5 = Ud(t6, w3, r3.vertical || g3, i3, 24, y3);
            n5 && M3(t6, n5);
          }
        } else if (n4.type === `Polygon`) for (let e6 of rr(n4.geometry, 0)) {
          let t6 = $d(e6, 16);
          M3(sl(e6[0], j3, true), new Rd(t6.x, t6.y, 0));
        }
        else if (n4.type === `LineString`) for (let e6 of n4.geometry) {
          let t6 = sl(e6, j3);
          M3(t6, new Rd(t6[0].x, t6[0].y, 0));
        }
        else if (n4.type === `Point`) for (let e6 of n4.geometry) for (let t6 of e6) M3([t6], new Rd(t6.x, t6.y, 0));
      }
      function lf(e6, t5, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3, p3, m3, h3) {
        let g3 = (function(e7, t6, r4, i4, a4, o4, s4, c4) {
          let l4 = i4.layout.get(`text-rotate`).evaluate(o4, {}) * Math.PI / 180, u4 = [];
          for (let e8 of t6.positionedLines) for (let i5 of e8.positionedGlyphs) {
            if (!i5.rect) continue;
            let o5 = i5.rect || {}, d4 = 4, f4 = true, p4 = 1, m4 = 0, h4 = (a4 || c4) && i5.vertical, g4 = i5.metrics.advance * i5.scale / 2;
            if (c4 && t6.verticalizable && (m4 = e8.lineOffset / 2 - (i5.imageName ? -(nu - i5.metrics.width * i5.scale) / 2 : (i5.scale - 1) * nu)), i5.imageName) {
              let e9 = s4[i5.imageName];
              f4 = e9.sdf, p4 = e9.pixelRatio, d4 = 1 / p4;
            }
            let _4 = a4 ? [i5.x + g4, i5.y] : [0, 0], v4 = a4 ? [0, 0] : [i5.x + g4 + r4[0], i5.y + r4[1] - m4], y3 = [0, 0];
            h4 && (y3 = v4, v4 = [0, 0]);
            let b3 = i5.metrics.isDoubleResolution ? 2 : 1, x3 = (i5.metrics.left - d4) * i5.scale - g4 + v4[0], S3 = (-i5.metrics.top - d4) * i5.scale + v4[1], C3 = x3 + o5.w / b3 * i5.scale / p4, w3 = S3 + o5.h / b3 * i5.scale / p4, T3 = new n3(x3, S3), E3 = new n3(C3, S3), D3 = new n3(x3, w3), O3 = new n3(C3, w3);
            if (h4) {
              let e9 = new n3(-g4, g4 - -17), t7 = -Math.PI / 2, r5 = 12 - g4, a5 = new n3(22 - r5, -(i5.imageName ? r5 : 0)), o6 = new n3(...y3);
              T3._rotateAround(t7, e9)._add(a5)._add(o6), E3._rotateAround(t7, e9)._add(a5)._add(o6), D3._rotateAround(t7, e9)._add(a5)._add(o6), O3._rotateAround(t7, e9)._add(a5)._add(o6);
            }
            if (l4) {
              let e9 = Math.sin(l4), t7 = Math.cos(l4), n4 = [t7, -e9, e9, t7];
              T3._matMult(n4), E3._matMult(n4), D3._matMult(n4), O3._matMult(n4);
            }
            let k3 = new n3(0, 0), A3 = new n3(0, 0);
            u4.push({ tl: T3, tr: E3, bl: D3, br: O3, tex: o5, writingMode: t6.writingMode, glyphOffset: _4, sectionIndex: i5.sectionIndex, isSDF: f4, pixelOffsetTL: k3, pixelOffsetBR: A3, minFontScaleX: 0, minFontScaleY: 0 });
          }
          return u4;
        })(0, r3, c3, a3, o3, s3, i3, e6.allowVerticalPlacement), _3 = e6.textSizeData, v3 = null;
        _3.kind === `source` ? (v3 = [128 * a3.layout.get(`text-size`).evaluate(s3, {})], v3[0] > qu && F2(`${e6.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : _3.kind === `composite` && (v3 = [128 * m3.compositeTextSizes[0].evaluate(s3, {}, h3), 128 * m3.compositeTextSizes[1].evaluate(s3, {}, h3)], (v3[0] > qu || v3[1] > qu) && F2(`${e6.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), e6.addSymbols(e6.text, g3, v3, c3, o3, s3, u3, t5, l3.lineStartIndex, l3.lineLength, p3, h3);
        for (let t6 of d3) f3[t6] = e6.text.placedSymbolArray.length - 1;
        return 4 * g3.length;
      }
      function uf(e6) {
        for (let t5 in e6) return e6[t5];
        return null;
      }
      function df(e6, t5, n4, r3) {
        let i3 = e6.compareText;
        if (t5 in i3) {
          let e7 = i3[t5];
          for (let t6 = e7.length - 1; t6 >= 0; t6--) if (r3.dist(e7[t6]) < n4) return true;
        } else i3[t5] = [];
        return i3[t5].push(r3), false;
      }
      let ff = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      class pf {
        static from(e6) {
          if (!(e6 instanceof ArrayBuffer)) throw Error(`Data must be an instance of ArrayBuffer.`);
          let [t5, n4] = new Uint8Array(e6, 0, 2);
          if (t5 !== 219) throw Error(`Data does not appear to be in a KDBush format.`);
          let r3 = n4 >> 4;
          if (r3 !== 1) throw Error(`Got v${r3} data when expected v1.`);
          let i3 = ff[15 & n4];
          if (!i3) throw Error(`Unrecognized array type.`);
          let [a3] = new Uint16Array(e6, 2, 1), [o3] = new Uint32Array(e6, 4, 1);
          return new pf(o3, a3, i3, e6);
        }
        constructor(e6, t5 = 64, n4 = Float64Array, r3) {
          if (isNaN(e6) || e6 < 0) throw Error(`Unpexpected numItems value: ${e6}.`);
          this.numItems = +e6, this.nodeSize = Math.min(Math.max(+t5, 2), 65535), this.ArrayType = n4, this.IndexArrayType = e6 < 65536 ? Uint16Array : Uint32Array;
          let i3 = ff.indexOf(this.ArrayType), a3 = 2 * e6 * this.ArrayType.BYTES_PER_ELEMENT, o3 = e6 * this.IndexArrayType.BYTES_PER_ELEMENT, s3 = (8 - o3 % 8) % 8;
          if (i3 < 0) throw Error(`Unexpected typed array class: ${n4}.`);
          r3 && r3 instanceof ArrayBuffer ? (this.data = r3, this.ids = new this.IndexArrayType(this.data, 8, e6), this.coords = new this.ArrayType(this.data, 8 + o3 + s3, 2 * e6), this._pos = 2 * e6, this._finished = true) : (this.data = new ArrayBuffer(8 + a3 + o3 + s3), this.ids = new this.IndexArrayType(this.data, 8, e6), this.coords = new this.ArrayType(this.data, 8 + o3 + s3, 2 * e6), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i3]), new Uint16Array(this.data, 2, 1)[0] = t5, new Uint32Array(this.data, 4, 1)[0] = e6);
        }
        add(e6, t5) {
          let n4 = this._pos >> 1;
          return this.ids[n4] = n4, this.coords[this._pos++] = e6, this.coords[this._pos++] = t5, n4;
        }
        finish() {
          let e6 = this._pos >> 1;
          if (e6 !== this.numItems) throw Error(`Added ${e6} items when expected ${this.numItems}.`);
          return mf(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
        }
        range(e6, t5, n4, r3) {
          if (!this._finished) throw Error(`Data not yet indexed - call index.finish().`);
          let { ids: i3, coords: a3, nodeSize: o3 } = this, s3 = [0, i3.length - 1, 0], c3 = [];
          for (; s3.length; ) {
            let l3 = s3.pop() || 0, u3 = s3.pop() || 0, d3 = s3.pop() || 0;
            if (u3 - d3 <= o3) {
              for (let o4 = d3; o4 <= u3; o4++) {
                let s4 = a3[2 * o4], l4 = a3[2 * o4 + 1];
                s4 >= e6 && s4 <= n4 && l4 >= t5 && l4 <= r3 && c3.push(i3[o4]);
              }
              continue;
            }
            let f3 = d3 + u3 >> 1, p3 = a3[2 * f3], m3 = a3[2 * f3 + 1];
            p3 >= e6 && p3 <= n4 && m3 >= t5 && m3 <= r3 && c3.push(i3[f3]), (l3 === 0 ? e6 <= p3 : t5 <= m3) && (s3.push(d3), s3.push(f3 - 1), s3.push(1 - l3)), (l3 === 0 ? n4 >= p3 : r3 >= m3) && (s3.push(f3 + 1), s3.push(u3), s3.push(1 - l3));
          }
          return c3;
        }
        within(e6, t5, n4) {
          if (!this._finished) throw Error(`Data not yet indexed - call index.finish().`);
          let { ids: r3, coords: i3, nodeSize: a3 } = this, o3 = [0, r3.length - 1, 0], s3 = [], c3 = n4 * n4;
          for (; o3.length; ) {
            let l3 = o3.pop() || 0, u3 = o3.pop() || 0, d3 = o3.pop() || 0;
            if (u3 - d3 <= a3) {
              for (let n5 = d3; n5 <= u3; n5++) vf(i3[2 * n5], i3[2 * n5 + 1], e6, t5) <= c3 && s3.push(r3[n5]);
              continue;
            }
            let f3 = d3 + u3 >> 1, p3 = i3[2 * f3], m3 = i3[2 * f3 + 1];
            vf(p3, m3, e6, t5) <= c3 && s3.push(r3[f3]), (l3 === 0 ? e6 - n4 <= p3 : t5 - n4 <= m3) && (o3.push(d3), o3.push(f3 - 1), o3.push(1 - l3)), (l3 === 0 ? e6 + n4 >= p3 : t5 + n4 >= m3) && (o3.push(f3 + 1), o3.push(u3), o3.push(1 - l3));
          }
          return s3;
        }
      }
      function mf(e6, t5, n4, r3, i3, a3) {
        if (i3 - r3 <= n4) return;
        let o3 = r3 + i3 >> 1;
        hf(e6, t5, o3, r3, i3, a3), mf(e6, t5, n4, r3, o3 - 1, 1 - a3), mf(e6, t5, n4, o3 + 1, i3, 1 - a3);
      }
      function hf(e6, t5, n4, r3, i3, a3) {
        for (; i3 > r3; ) {
          if (i3 - r3 > 600) {
            let o4 = i3 - r3 + 1, s4 = n4 - r3 + 1, c4 = Math.log(o4), l3 = 0.5 * Math.exp(2 * c4 / 3), u3 = 0.5 * Math.sqrt(c4 * l3 * (o4 - l3) / o4) * (s4 - o4 / 2 < 0 ? -1 : 1);
            hf(e6, t5, n4, Math.max(r3, Math.floor(n4 - s4 * l3 / o4 + u3)), Math.min(i3, Math.floor(n4 + (o4 - s4) * l3 / o4 + u3)), a3);
          }
          let o3 = t5[2 * n4 + a3], s3 = r3, c3 = i3;
          for (gf(e6, t5, r3, n4), t5[2 * i3 + a3] > o3 && gf(e6, t5, r3, i3); s3 < c3; ) {
            for (gf(e6, t5, s3, c3), s3++, c3--; t5[2 * s3 + a3] < o3; ) s3++;
            for (; t5[2 * c3 + a3] > o3; ) c3--;
          }
          t5[2 * r3 + a3] === o3 ? gf(e6, t5, r3, c3) : (c3++, gf(e6, t5, c3, i3)), c3 <= n4 && (r3 = c3 + 1), n4 <= c3 && (i3 = c3 - 1);
        }
      }
      function gf(e6, t5, n4, r3) {
        _f(e6, n4, r3), _f(t5, 2 * n4, 2 * r3), _f(t5, 2 * n4 + 1, 2 * r3 + 1);
      }
      function _f(e6, t5, n4) {
        let r3 = e6[t5];
        e6[t5] = e6[n4], e6[n4] = r3;
      }
      function vf(e6, t5, n4, r3) {
        let i3 = e6 - n4, a3 = t5 - r3;
        return i3 * i3 + a3 * a3;
      }
      var yf;
      e5.cA = void 0, (yf = e5.cA || (e5.cA = {})).create = `create`, yf.load = `load`, yf.fullLoad = `fullLoad`;
      let bf = null, xf = [], Sf = 1e3 / 60, Cf = `loadTime`, wf = `fullLoadTime`;
      e5.$ = I2, e5.A = f2, e5.B = na, e5.C = function([e6, t5, n4]) {
        return t5 += 90, t5 *= Math.PI / 180, n4 *= Math.PI / 180, { x: e6 * Math.cos(t5) * Math.sin(n4), y: e6 * Math.sin(t5) * Math.sin(n4), z: e6 * Math.cos(n4) };
      }, e5.D = Q, e5.E = Ne2, e5.F = vn, e5.G = ka, e5.H = ia, e5.I = Su, e5.J = de2, e5.K = class {
        constructor(e6, t5) {
          this.target = e6, this.mapId = t5, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new fd((() => this.process())), this.subscription = ge2(this.target, `message`, ((e7) => this.receive(e7)), false), this.globalScope = le2(self) ? e6 : window;
        }
        registerMessageHandler(e6, t5) {
          this.messageHandlers[e6] = t5;
        }
        sendAsync(e6, t5) {
          return new Promise(((n4, r3) => {
            let i3 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), a3 = t5 ? ge2(t5.signal, `abort`, (() => {
              a3 == null ? void 0 : a3.unsubscribe(), delete this.resolveRejects[i3];
              let t6 = { id: i3, type: `<cancel>`, origin: location.origin, targetMapId: e6.targetMapId, sourceMapId: this.mapId };
              this.target.postMessage(t6);
            }), pd) : null;
            this.resolveRejects[i3] = { resolve: (e7) => {
              a3 == null ? void 0 : a3.unsubscribe(), n4(e7);
            }, reject: (e7) => {
              a3 == null ? void 0 : a3.unsubscribe(), r3(e7);
            } };
            let o3 = [], s3 = Object.assign(Object.assign({}, e6), { id: i3, sourceMapId: this.mapId, origin: location.origin, data: pa(e6.data, o3) });
            this.target.postMessage(s3, { transfer: o3 });
          }));
        }
        receive(e6) {
          let t5 = e6.data, n4 = t5.id;
          if (!(t5.origin !== `file://` && location.origin !== `file://` && t5.origin !== `resource://android` && location.origin !== `resource://android` && t5.origin !== location.origin || t5.targetMapId && this.mapId !== t5.targetMapId)) {
            if (t5.type === `<cancel>`) {
              delete this.tasks[n4];
              let e7 = this.abortControllers[n4];
              delete this.abortControllers[n4], e7 && e7.abort();
              return;
            }
            if (le2(self) || t5.mustQueue) return this.tasks[n4] = t5, this.taskQueue.push(n4), void this.invoker.trigger();
            this.processTask(n4, t5);
          }
        }
        process() {
          if (this.taskQueue.length === 0) return;
          let e6 = this.taskQueue.shift(), t5 = this.tasks[e6];
          delete this.tasks[e6], this.taskQueue.length > 0 && this.invoker.trigger(), t5 && this.processTask(e6, t5);
        }
        processTask(e6, n4) {
          return t4(this, void 0, void 0, (function* () {
            if (n4.type === `<response>`) {
              let t6 = this.resolveRejects[e6];
              if (delete this.resolveRejects[e6], !t6) return;
              n4.error ? t6.reject(ma(n4.error)) : t6.resolve(ma(n4.data));
              return;
            }
            if (!this.messageHandlers[n4.type]) return void this.completeTask(e6, Error(`Could not find a registered handler for ${n4.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(`, `)}`));
            let t5 = ma(n4.data), r3 = new AbortController();
            this.abortControllers[e6] = r3;
            try {
              let i3 = yield this.messageHandlers[n4.type](n4.sourceMapId, t5, r3);
              this.completeTask(e6, null, i3);
            } catch (t6) {
              this.completeTask(e6, t6);
            }
          }));
        }
        completeTask(e6, t5, n4) {
          let r3 = [];
          delete this.abortControllers[e6];
          let i3 = { id: e6, type: `<response>`, sourceMapId: this.mapId, origin: location.origin, error: t5 ? pa(t5) : null, data: pa(n4, r3) };
          this.target.postMessage(i3, { transfer: r3 });
        }
        remove() {
          this.invoker.remove(), this.subscription.unsubscribe();
        }
      }, e5.L = we2, e5.M = function() {
        var e6 = new f2(16);
        return f2 != Float32Array && (e6[1] = 0, e6[2] = 0, e6[3] = 0, e6[4] = 0, e6[6] = 0, e6[7] = 0, e6[8] = 0, e6[9] = 0, e6[11] = 0, e6[12] = 0, e6[13] = 0, e6[14] = 0), e6[0] = 1, e6[5] = 1, e6[10] = 1, e6[15] = 1, e6;
      }, e5.N = function(e6, t5, n4) {
        var r3, i3, a3, o3, s3, c3, l3, u3, d3, f3, p3, m3, h3 = n4[0], g3 = n4[1], _3 = n4[2];
        return t5 === e6 ? (e6[12] = t5[0] * h3 + t5[4] * g3 + t5[8] * _3 + t5[12], e6[13] = t5[1] * h3 + t5[5] * g3 + t5[9] * _3 + t5[13], e6[14] = t5[2] * h3 + t5[6] * g3 + t5[10] * _3 + t5[14], e6[15] = t5[3] * h3 + t5[7] * g3 + t5[11] * _3 + t5[15]) : (i3 = t5[1], a3 = t5[2], o3 = t5[3], s3 = t5[4], c3 = t5[5], l3 = t5[6], u3 = t5[7], d3 = t5[8], f3 = t5[9], p3 = t5[10], m3 = t5[11], e6[0] = r3 = t5[0], e6[1] = i3, e6[2] = a3, e6[3] = o3, e6[4] = s3, e6[5] = c3, e6[6] = l3, e6[7] = u3, e6[8] = d3, e6[9] = f3, e6[10] = p3, e6[11] = m3, e6[12] = r3 * h3 + s3 * g3 + d3 * _3 + t5[12], e6[13] = i3 * h3 + c3 * g3 + f3 * _3 + t5[13], e6[14] = a3 * h3 + l3 * g3 + p3 * _3 + t5[14], e6[15] = o3 * h3 + u3 * g3 + m3 * _3 + t5[15]), e6;
      }, e5.O = function(e6, t5, n4) {
        var r3 = n4[0], i3 = n4[1], a3 = n4[2];
        return e6[0] = t5[0] * r3, e6[1] = t5[1] * r3, e6[2] = t5[2] * r3, e6[3] = t5[3] * r3, e6[4] = t5[4] * i3, e6[5] = t5[5] * i3, e6[6] = t5[6] * i3, e6[7] = t5[7] * i3, e6[8] = t5[8] * a3, e6[9] = t5[9] * a3, e6[10] = t5[10] * a3, e6[11] = t5[11] * a3, e6[12] = t5[12], e6[13] = t5[13], e6[14] = t5[14], e6[15] = t5[15], e6;
      }, e5.P = n3, e5.Q = function(e6, t5, n4) {
        var r3 = t5[0], i3 = t5[1], a3 = t5[2], o3 = t5[3], s3 = t5[4], c3 = t5[5], l3 = t5[6], u3 = t5[7], d3 = t5[8], f3 = t5[9], p3 = t5[10], m3 = t5[11], h3 = t5[12], g3 = t5[13], _3 = t5[14], v3 = t5[15], y3 = n4[0], b3 = n4[1], x3 = n4[2], S3 = n4[3];
        return e6[0] = y3 * r3 + b3 * s3 + x3 * d3 + S3 * h3, e6[1] = y3 * i3 + b3 * c3 + x3 * f3 + S3 * g3, e6[2] = y3 * a3 + b3 * l3 + x3 * p3 + S3 * _3, e6[3] = y3 * o3 + b3 * u3 + x3 * m3 + S3 * v3, e6[4] = (y3 = n4[4]) * r3 + (b3 = n4[5]) * s3 + (x3 = n4[6]) * d3 + (S3 = n4[7]) * h3, e6[5] = y3 * i3 + b3 * c3 + x3 * f3 + S3 * g3, e6[6] = y3 * a3 + b3 * l3 + x3 * p3 + S3 * _3, e6[7] = y3 * o3 + b3 * u3 + x3 * m3 + S3 * v3, e6[8] = (y3 = n4[8]) * r3 + (b3 = n4[9]) * s3 + (x3 = n4[10]) * d3 + (S3 = n4[11]) * h3, e6[9] = y3 * i3 + b3 * c3 + x3 * f3 + S3 * g3, e6[10] = y3 * a3 + b3 * l3 + x3 * p3 + S3 * _3, e6[11] = y3 * o3 + b3 * u3 + x3 * m3 + S3 * v3, e6[12] = (y3 = n4[12]) * r3 + (b3 = n4[13]) * s3 + (x3 = n4[14]) * d3 + (S3 = n4[15]) * h3, e6[13] = y3 * i3 + b3 * c3 + x3 * f3 + S3 * g3, e6[14] = y3 * a3 + b3 * l3 + x3 * p3 + S3 * _3, e6[15] = y3 * o3 + b3 * u3 + x3 * m3 + S3 * v3, e6;
      }, e5.R = mc, e5.S = function(e6, t5) {
        let n4 = {};
        for (let r3 = 0; r3 < t5.length; r3++) {
          let i3 = t5[r3];
          i3 in e6 && (n4[i3] = e6[i3]);
        }
        return n4;
      }, e5.T = Cc, e5.U = hd, e5.V = ne2, e5.W = yd, e5.X = vd, e5.Y = l2, e5.Z = u2, e5._ = t4, e5.a = Se2, e5.a$ = function(e6, t5, n4) {
        return e6[0] = t5[0] * n4[0], e6[1] = t5[1] * n4[1], e6[2] = t5[2] * n4[2], e6[3] = t5[3] * n4[3], e6;
      }, e5.a0 = Od, e5.a1 = xd, e5.a2 = Sd, e5.a3 = O2, e5.a4 = function(e6, t5) {
        var _a3;
        if (!e6) return t5 ?? {};
        if (!t5) return e6;
        let n4 = Object.assign({}, e6);
        if (t5.removeAll && (n4 = { removeAll: true }), t5.remove) {
          let r3 = new Set(t5.remove);
          n4.add && (n4.add = n4.add.filter(((e7) => !r3.has(e7.id)))), n4.update && (n4.update = n4.update.filter(((e7) => !r3.has(e7.id))));
          let i3 = new Set((e6.add ?? []).map(((e7) => e7.id)));
          t5.remove = t5.remove.filter(((e7) => !i3.has(e7)));
        }
        if (t5.remove) {
          let e7 = new Set(n4.remove ? n4.remove.concat(t5.remove) : t5.remove);
          n4.remove = Array.from(e7.values());
        }
        if (t5.add) {
          let e7 = n4.add ? n4.add.concat(t5.add) : t5.add, r3 = new Map(e7.map(((e8) => [e8.id, e8])));
          n4.add = Array.from(r3.values());
        }
        if (t5.update) {
          let e7 = new Map((_a3 = n4.update) == null ? void 0 : _a3.map(((e8) => [e8.id, e8])));
          for (let n5 of t5.update) {
            let t6 = e7.get(n5.id) ?? { id: n5.id };
            n5.newGeometry && (t6.newGeometry = n5.newGeometry), n5.addOrUpdateProperties && (t6.addOrUpdateProperties = (t6.addOrUpdateProperties ?? []).concat(n5.addOrUpdateProperties)), n5.removeProperties && (t6.removeProperties = (t6.removeProperties ?? []).concat(n5.removeProperties)), n5.removeAllProperties && (t6.removeAllProperties = true), e7.set(n5.id, t6);
          }
          n4.update = Array.from(e7.values());
        }
        return n4.remove && n4.add && (n4.remove = n4.remove.filter(((e7) => n4.add.findIndex(((t6) => t6.id === e7)) === -1))), n4;
      }, e5.a5 = wd, e5.a6 = jd, e5.a7 = 25, e5.a8 = Ed, e5.a9 = (e6) => {
        let t5 = window.document.createElement(`video`);
        return t5.muted = true, new Promise(((n4) => {
          t5.onloadstart = () => {
            n4(t5);
          };
          for (let n5 of e6) {
            let e7 = window.document.createElement(`source`);
            Oe2(n5) || (t5.crossOrigin = `Anonymous`), e7.src = n5, t5.appendChild(e7);
          }
        }));
      }, e5.aA = C2, e5.aB = function(e6, t5, r3, i3) {
        let a3 = t5.y - e6.y, o3 = t5.x - e6.x, s3 = i3.y - r3.y, c3 = i3.x - r3.x, l3 = s3 * o3 - c3 * a3;
        if (l3 === 0) return null;
        let u3 = (c3 * (e6.y - r3.y) - s3 * (e6.x - r3.x)) / l3;
        return new n3(e6.x + u3 * o3, e6.y + u3 * a3);
      }, e5.aC = Ld, e5.aD = Ls, e5.aE = function(e6) {
        let t5 = 1 / 0, n4 = 1 / 0, r3 = -1 / 0, i3 = -1 / 0;
        for (let a3 of e6) t5 = Math.min(t5, a3.x), n4 = Math.min(n4, a3.y), r3 = Math.max(r3, a3.x), i3 = Math.max(i3, a3.y);
        return [t5, n4, r3, i3];
      }, e5.aF = nu, e5.aG = k2, e5.aH = function(e6, t5, n4, r3, i3 = false) {
        if (!n4[0] && !n4[1]) return [0, 0];
        let a3 = i3 ? r3 === `map` ? -e6.bearingInRadians : 0 : r3 === `viewport` ? e6.bearingInRadians : 0;
        if (a3) {
          let e7 = Math.sin(a3), t6 = Math.cos(a3);
          n4 = [n4[0] * t6 - n4[1] * e7, n4[0] * e7 + n4[1] * t6];
        }
        return [i3 ? n4[0] : k2(t5, n4[0], e6.zoom), i3 ? n4[1] : k2(t5, n4[1], e6.zoom)];
      }, e5.aJ = Yu, e5.aK = sf, e5.aL = Lu, e5.aM = pf, e5.aN = Za, e5.aO = nl, e5.aP = Io, e5.aQ = Qo, e5.aR = Yo, e5.aS = ve2, e5.aT = Cd, e5.aU = y2, e5.aV = v2, e5.aW = function(e6) {
        var t5 = new f2(3);
        return t5[0] = e6[0], t5[1] = e6[1], t5[2] = e6[2], t5;
      }, e5.aX = function(e6, t5, n4) {
        return e6[0] = t5[0] - n4[0], e6[1] = t5[1] - n4[1], e6[2] = t5[2] - n4[2], e6;
      }, e5.aY = function(e6, t5) {
        var n4 = t5[0], r3 = t5[1], i3 = t5[2], a3 = n4 * n4 + r3 * r3 + i3 * i3;
        return a3 > 0 && (a3 = 1 / Math.sqrt(a3)), e6[0] = t5[0] * a3, e6[1] = t5[1] * a3, e6[2] = t5[2] * a3, e6;
      }, e5.aZ = b2, e5.a_ = function(e6, t5) {
        return e6[0] * t5[0] + e6[1] * t5[1] + e6[2] * t5[2];
      }, e5.aa = z2, e5.ab = function() {
        return re2++;
      }, e5.ac = To, e5.ad = nd, e5.ae = mi, e5.af = Ns, e5.ag = Nd, e5.ah = function(e6) {
        let t5 = {};
        if (e6.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((e7, n4, r3, i3) => {
          let a3 = r3 || i3;
          return t5[n4] = !a3 || a3.toLowerCase(), ``;
        })), t5[`max-age`]) {
          let e7 = parseInt(t5[`max-age`], 10);
          isNaN(e7) ? delete t5[`max-age`] : t5[`max-age`] = e7;
        }
        return t5;
      }, e5.ai = N2, e5.aj = 85.051129, e5.ak = _e2, e5.al = function(e6) {
        return 2 ** e6;
      }, e5.am = m2, e5.an = bd, e5.ao = function(e6) {
        return Math.log(e6) / Math.LN2;
      }, e5.ap = function(e6) {
        var t5 = e6[0], n4 = e6[1];
        return t5 * t5 + n4 * n4;
      }, e5.aq = function(e6) {
        if (!e6.length) return /* @__PURE__ */ new Set();
        let t5 = Math.max(...e6.map(((e7) => e7.canonical.z))), n4 = 1 / 0, r3 = -1 / 0, i3 = 1 / 0, a3 = -1 / 0, o3 = [];
        for (let s4 of e6) {
          let { x: e7, y: c3, z: l3 } = s4.canonical, u3 = 2 ** (t5 - l3), d3 = e7 * u3, f3 = c3 * u3;
          o3.push({ id: s4, x: d3, y: f3 }), d3 < n4 && (n4 = d3), d3 > r3 && (r3 = d3), f3 < i3 && (i3 = f3), f3 > a3 && (a3 = f3);
        }
        let s3 = /* @__PURE__ */ new Set();
        for (let e7 of o3) e7.x !== n4 && e7.x !== r3 && e7.y !== i3 && e7.y !== a3 || s3.add(e7.id);
        return s3;
      }, e5.ar = function(e6, t5) {
        let n4 = 0, r3 = 0;
        if (e6.kind === `constant`) r3 = e6.layoutSize;
        else if (e6.kind !== `source`) {
          let { interpolationType: i3, minZoom: a3, maxZoom: o3 } = e6, s3 = i3 ? N2(gn.interpolationFactor(i3, t5, a3, o3), 0, 1) : 0;
          e6.kind === `camera` ? r3 = vn.number(e6.minSize, e6.maxSize, s3) : n4 = s3;
        }
        return { uSizeT: n4, uSize: r3 };
      }, e5.at = function(e6, { uSize: t5, uSizeT: n4 }, { lowerSize: r3, upperSize: i3 }) {
        return e6.kind === `source` ? r3 / 128 : e6.kind === `composite` ? vn.number(r3 / 128, i3 / 128, n4) : t5;
      }, e5.au = function(e6, t5) {
        var n4 = t5[0], r3 = t5[1], i3 = t5[2], a3 = t5[3], o3 = t5[4], s3 = t5[5], c3 = t5[6], l3 = t5[7], u3 = t5[8], d3 = t5[9], f3 = t5[10], p3 = t5[11], m3 = t5[12], h3 = t5[13], g3 = t5[14], _3 = t5[15], v3 = n4 * s3 - r3 * o3, y3 = n4 * c3 - i3 * o3, b3 = n4 * l3 - a3 * o3, x3 = r3 * c3 - i3 * s3, S3 = r3 * l3 - a3 * s3, C3 = i3 * l3 - a3 * c3, w3 = u3 * h3 - d3 * m3, T3 = u3 * g3 - f3 * m3, E3 = u3 * _3 - p3 * m3, D3 = d3 * g3 - f3 * h3, O3 = d3 * _3 - p3 * h3, k3 = f3 * _3 - p3 * g3, A3 = v3 * k3 - y3 * O3 + b3 * D3 + x3 * E3 - S3 * T3 + C3 * w3;
        return A3 ? (e6[0] = (s3 * k3 - c3 * O3 + l3 * D3) * (A3 = 1 / A3), e6[1] = (i3 * O3 - r3 * k3 - a3 * D3) * A3, e6[2] = (h3 * C3 - g3 * S3 + _3 * x3) * A3, e6[3] = (f3 * S3 - d3 * C3 - p3 * x3) * A3, e6[4] = (c3 * E3 - o3 * k3 - l3 * T3) * A3, e6[5] = (n4 * k3 - i3 * E3 + a3 * T3) * A3, e6[6] = (g3 * b3 - m3 * C3 - _3 * y3) * A3, e6[7] = (u3 * C3 - f3 * b3 + p3 * y3) * A3, e6[8] = (o3 * O3 - s3 * E3 + l3 * w3) * A3, e6[9] = (r3 * E3 - n4 * O3 - a3 * w3) * A3, e6[10] = (m3 * S3 - h3 * b3 + _3 * v3) * A3, e6[11] = (d3 * b3 - u3 * S3 - p3 * v3) * A3, e6[12] = (s3 * T3 - o3 * D3 - c3 * w3) * A3, e6[13] = (n4 * D3 - r3 * T3 + i3 * w3) * A3, e6[14] = (h3 * y3 - m3 * x3 - g3 * v3) * A3, e6[15] = (u3 * x3 - d3 * y3 + f3 * v3) * A3, e6) : null;
      }, e5.av = E2, e5.aw = function(e6) {
        var t5 = e6[0], n4 = e6[1];
        return Math.sqrt(t5 * t5 + n4 * n4);
      }, e5.ax = function(e6) {
        return e6[0] = 0, e6[1] = 0, e6;
      }, e5.ay = function(e6, t5, n4) {
        return e6[0] = t5[0] * n4, e6[1] = t5[1] * n4, e6;
      }, e5.az = Qu, e5.b = fe2, e5.b$ = function(e6, t5, n4) {
        var r3 = t5[0], i3 = t5[1], a3 = t5[2];
        return e6[0] = r3 * n4[0] + i3 * n4[3] + a3 * n4[6], e6[1] = r3 * n4[1] + i3 * n4[4] + a3 * n4[7], e6[2] = r3 * n4[2] + i3 * n4[5] + a3 * n4[8], e6;
      }, e5.b0 = g2, e5.b1 = function(e6, t5, n4) {
        let r3 = t5[0] * n4[0] + t5[1] * n4[1] + t5[2] * n4[2];
        return r3 === 0 ? null : (-(e6[0] * n4[0] + e6[1] * n4[1] + e6[2] * n4[2]) - n4[3]) / r3;
      }, e5.b2 = S2, e5.b3 = function(e6, t5, n4) {
        return e6[0] = t5[0] * n4, e6[1] = t5[1] * n4, e6[2] = t5[2] * n4, e6[3] = t5[3] * n4, e6;
      }, e5.b4 = function(e6, t5) {
        return e6[0] * t5[0] + e6[1] * t5[1] + e6[2] * t5[2] + e6[3];
      }, e5.b5 = Dd, e5.b6 = kd, e5.b7 = function(e6, t5, n4, r3, i3) {
        var a3 = 1 / Math.tan(t5 / 2);
        if (e6[0] = a3 / n4, e6[1] = 0, e6[2] = 0, e6[3] = 0, e6[4] = 0, e6[5] = a3, e6[6] = 0, e6[7] = 0, e6[8] = 0, e6[9] = 0, e6[11] = -1, e6[12] = 0, e6[13] = 0, e6[15] = 0, i3 != null && i3 !== 1 / 0) {
          var o3 = 1 / (r3 - i3);
          e6[10] = (i3 + r3) * o3, e6[14] = 2 * i3 * r3 * o3;
        } else e6[10] = -1, e6[14] = -2 * r3;
        return e6;
      }, e5.b8 = function(e6) {
        var t5 = new f2(16);
        return t5[0] = e6[0], t5[1] = e6[1], t5[2] = e6[2], t5[3] = e6[3], t5[4] = e6[4], t5[5] = e6[5], t5[6] = e6[6], t5[7] = e6[7], t5[8] = e6[8], t5[9] = e6[9], t5[10] = e6[10], t5[11] = e6[11], t5[12] = e6[12], t5[13] = e6[13], t5[14] = e6[14], t5[15] = e6[15], t5;
      }, e5.b9 = function(e6, t5, n4) {
        var r3 = Math.sin(n4), i3 = Math.cos(n4), a3 = t5[0], o3 = t5[1], s3 = t5[2], c3 = t5[3], l3 = t5[4], u3 = t5[5], d3 = t5[6], f3 = t5[7];
        return t5 !== e6 && (e6[8] = t5[8], e6[9] = t5[9], e6[10] = t5[10], e6[11] = t5[11], e6[12] = t5[12], e6[13] = t5[13], e6[14] = t5[14], e6[15] = t5[15]), e6[0] = a3 * i3 + l3 * r3, e6[1] = o3 * i3 + u3 * r3, e6[2] = s3 * i3 + d3 * r3, e6[3] = c3 * i3 + f3 * r3, e6[4] = l3 * i3 - a3 * r3, e6[5] = u3 * i3 - o3 * r3, e6[6] = d3 * i3 - s3 * r3, e6[7] = f3 * i3 - c3 * r3, e6;
      }, e5.bA = function(e6, t5, n4, r3) {
        var i3 = [], a3 = [];
        return i3[0] = t5[0] - n4[0], i3[1] = t5[1] - n4[1], i3[2] = t5[2] - n4[2], a3[0] = i3[0], a3[1] = i3[1] * Math.cos(r3) - i3[2] * Math.sin(r3), a3[2] = i3[1] * Math.sin(r3) + i3[2] * Math.cos(r3), e6[0] = a3[0] + n4[0], e6[1] = a3[1] + n4[1], e6[2] = a3[2] + n4[2], e6;
      }, e5.bB = function(e6, t5, n4, r3) {
        var i3 = [], a3 = [];
        return i3[0] = t5[0] - n4[0], i3[1] = t5[1] - n4[1], i3[2] = t5[2] - n4[2], a3[0] = i3[2] * Math.sin(r3) + i3[0] * Math.cos(r3), a3[1] = i3[1], a3[2] = i3[2] * Math.cos(r3) - i3[0] * Math.sin(r3), e6[0] = a3[0] + n4[0], e6[1] = a3[1] + n4[1], e6[2] = a3[2] + n4[2], e6;
      }, e5.bC = function(e6, t5, n4) {
        var r3 = Math.sin(n4), i3 = Math.cos(n4), a3 = t5[0], o3 = t5[1], s3 = t5[2], c3 = t5[3], l3 = t5[8], u3 = t5[9], d3 = t5[10], f3 = t5[11];
        return t5 !== e6 && (e6[4] = t5[4], e6[5] = t5[5], e6[6] = t5[6], e6[7] = t5[7], e6[12] = t5[12], e6[13] = t5[13], e6[14] = t5[14], e6[15] = t5[15]), e6[0] = a3 * i3 - l3 * r3, e6[1] = o3 * i3 - u3 * r3, e6[2] = s3 * i3 - d3 * r3, e6[3] = c3 * i3 - f3 * r3, e6[8] = a3 * r3 + l3 * i3, e6[9] = o3 * r3 + u3 * i3, e6[10] = s3 * r3 + d3 * i3, e6[11] = c3 * r3 + f3 * i3, e6;
      }, e5.bD = function(e6, t5) {
        let n4 = A2(e6, 360), r3 = A2(t5, 360), i3 = r3 - n4, a3 = r3 > n4 ? i3 - 360 : i3 + 360;
        return Math.abs(i3) < Math.abs(a3) ? i3 : a3;
      }, e5.bE = function(e6) {
        return e6[0] = 0, e6[1] = 0, e6[2] = 0, e6;
      }, e5.bF = function(e6, t5, n4, r3) {
        let i3 = Math.sqrt(e6 * e6 + t5 * t5), a3 = Math.sqrt(n4 * n4 + r3 * r3);
        e6 /= i3, t5 /= i3, n4 /= a3, r3 /= a3;
        let o3 = Math.acos(e6 * n4 + t5 * r3);
        return -t5 * n4 + e6 * r3 > 0 ? o3 : -o3;
      }, e5.bG = function(e6, t5) {
        let n4 = A2(e6, 2 * Math.PI), r3 = A2(t5, 2 * Math.PI);
        return Math.min(Math.abs(n4 - r3), Math.abs(n4 - r3 + 2 * Math.PI), Math.abs(n4 - r3 - 2 * Math.PI));
      }, e5.bH = function() {
        let e6 = {}, t5 = R2.$version;
        for (let n4 in R2.$root) {
          let r3 = R2.$root[n4];
          if (r3.required) {
            let i3 = null;
            i3 = n4 === `version` ? t5 : r3.type === `array` ? [] : {}, i3 != null && (e6[n4] = i3);
          }
        }
        return e6;
      }, e5.bI = ha, e5.bJ = Ee2, e5.bK = function e6(t5, n4) {
        if (Array.isArray(t5)) {
          if (!Array.isArray(n4) || t5.length !== n4.length) return false;
          for (let r3 = 0; r3 < t5.length; r3++) if (!e6(t5[r3], n4[r3])) return false;
          return true;
        }
        if (typeof t5 == `object` && t5 && n4 !== null) {
          if (typeof n4 != `object` || Object.keys(t5).length !== Object.keys(n4).length) return false;
          for (let r3 in t5) if (!e6(t5[r3], n4[r3])) return false;
          return true;
        }
        return t5 === n4;
      }, e5.bL = function(e6) {
        e6 = e6.slice();
        let t5 = /* @__PURE__ */ Object.create(null);
        for (let n4 = 0; n4 < e6.length; n4++) t5[e6[n4].id] = e6[n4];
        for (let n4 = 0; n4 < e6.length; n4++) `ref` in e6[n4] && (e6[n4] = Fe2(e6[n4], t5[e6[n4].ref]));
        return e6;
      }, e5.bM = function(e6, t5) {
        if (e6.type === `custom`) return new dd(e6, t5);
        switch (e6.type) {
          case `background`:
            return new ud(e6, t5);
          case `circle`:
            return new oc(e6, t5);
          case `color-relief`:
            return new Ec(e6, t5);
          case `fill`:
            return new hl(e6, t5);
          case `fill-extrusion`:
            return new Pl(e6, t5);
          case `heatmap`:
            return new _c2(e6, t5);
          case `hillshade`:
            return new bc(e6, t5);
          case `line`:
            return new ql(e6, t5);
          case `raster`:
            return new qa(e6, t5);
          case `symbol`:
            return new sd(e6, t5);
        }
      }, e5.bN = (e6) => e6.type === `raster`, e5.bO = oe2, e5.bP = function(e6, t5) {
        if (!e6) return [{ command: `setStyle`, args: [t5] }];
        let n4 = [];
        try {
          if (!Ie2(e6.version, t5.version)) return [{ command: `setStyle`, args: [t5] }];
          Ie2(e6.center, t5.center) || n4.push({ command: `setCenter`, args: [t5.center] }), Ie2(e6.state, t5.state) || n4.push({ command: `setGlobalState`, args: [t5.state] }), Ie2(e6.centerAltitude, t5.centerAltitude) || n4.push({ command: `setCenterAltitude`, args: [t5.centerAltitude] }), Ie2(e6.zoom, t5.zoom) || n4.push({ command: `setZoom`, args: [t5.zoom] }), Ie2(e6.bearing, t5.bearing) || n4.push({ command: `setBearing`, args: [t5.bearing] }), Ie2(e6.pitch, t5.pitch) || n4.push({ command: `setPitch`, args: [t5.pitch] }), Ie2(e6.roll, t5.roll) || n4.push({ command: `setRoll`, args: [t5.roll] }), Ie2(e6.sprite, t5.sprite) || n4.push({ command: `setSprite`, args: [t5.sprite] }), Ie2(e6.glyphs, t5.glyphs) || n4.push({ command: `setGlyphs`, args: [t5.glyphs] }), Ie2(e6.transition, t5.transition) || n4.push({ command: `setTransition`, args: [t5.transition] }), Ie2(e6.light, t5.light) || n4.push({ command: `setLight`, args: [t5.light] }), Ie2(e6.terrain, t5.terrain) || n4.push({ command: `setTerrain`, args: [t5.terrain] }), Ie2(e6.sky, t5.sky) || n4.push({ command: `setSky`, args: [t5.sky] }), Ie2(e6.projection, t5.projection) || n4.push({ command: `setProjection`, args: [t5.projection] });
          let r3 = {}, i3 = [];
          (function(e7, t6, n5, r4) {
            let i4;
            for (i4 in t6 || (t6 = {}), e7 || (e7 = {})) Object.prototype.hasOwnProperty.call(e7, i4) && (Object.prototype.hasOwnProperty.call(t6, i4) || ze2(i4, n5, r4));
            for (i4 in t6) Object.prototype.hasOwnProperty.call(t6, i4) && (Object.prototype.hasOwnProperty.call(e7, i4) ? Ie2(e7[i4], t6[i4]) || (e7[i4].type === `geojson` && t6[i4].type === `geojson` && Ve2(e7, t6, i4) ? Le2(n5, { command: `setGeoJSONSourceData`, args: [i4, t6[i4].data] }) : Be2(i4, t6, n5, r4)) : Re2(i4, t6, n5));
          })(e6.sources, t5.sources, i3, r3);
          let a3 = [];
          e6.layers && e6.layers.forEach(((e7) => {
            `source` in e7 && r3[e7.source] ? n4.push({ command: `removeLayer`, args: [e7.id] }) : a3.push(e7);
          })), n4 = n4.concat(i3), (function(e7, t6, n5) {
            t6 || (t6 = []);
            let r4 = (e7 || (e7 = [])).map(Ue2), i4 = t6.map(Ue2), a4 = e7.reduce(We2, {}), o3 = t6.reduce(We2, {}), s3 = r4.slice(), c3 = /* @__PURE__ */ Object.create(null), l3, u3, d3, f3, p3;
            for (let e8 = 0, t7 = 0; e8 < r4.length; e8++) l3 = r4[e8], Object.prototype.hasOwnProperty.call(o3, l3) ? t7++ : (Le2(n5, { command: `removeLayer`, args: [l3] }), s3.splice(s3.indexOf(l3, t7), 1));
            for (let e8 = 0, t7 = 0; e8 < i4.length; e8++) l3 = i4[i4.length - 1 - e8], s3[s3.length - 1 - e8] !== l3 && (Object.prototype.hasOwnProperty.call(a4, l3) ? (Le2(n5, { command: `removeLayer`, args: [l3] }), s3.splice(s3.lastIndexOf(l3, s3.length - t7), 1)) : t7++, f3 = s3[s3.length - e8], Le2(n5, { command: `addLayer`, args: [o3[l3], f3] }), s3.splice(s3.length - e8, 0, l3), c3[l3] = true);
            for (let e8 = 0; e8 < i4.length; e8++) if (l3 = i4[e8], u3 = a4[l3], d3 = o3[l3], !c3[l3] && !Ie2(u3, d3)) if (Ie2(u3.source, d3.source) && Ie2(u3[`source-layer`], d3[`source-layer`]) && Ie2(u3.type, d3.type)) {
              for (p3 in He2(u3.layout, d3.layout, n5, l3, null, `setLayoutProperty`), He2(u3.paint, d3.paint, n5, l3, null, `setPaintProperty`), Ie2(u3.filter, d3.filter) || Le2(n5, { command: `setFilter`, args: [l3, d3.filter] }), Ie2(u3.minzoom, d3.minzoom) && Ie2(u3.maxzoom, d3.maxzoom) || Le2(n5, { command: `setLayerZoomRange`, args: [l3, d3.minzoom, d3.maxzoom] }), u3) Object.prototype.hasOwnProperty.call(u3, p3) && p3 !== `layout` && p3 !== `paint` && p3 !== `filter` && p3 !== `metadata` && p3 !== `minzoom` && p3 !== `maxzoom` && (p3.indexOf(`paint.`) === 0 ? He2(u3[p3], d3[p3], n5, l3, p3.slice(6), `setPaintProperty`) : Ie2(u3[p3], d3[p3]) || Le2(n5, { command: `setLayerProperty`, args: [l3, p3, d3[p3]] }));
              for (p3 in d3) Object.prototype.hasOwnProperty.call(d3, p3) && !Object.prototype.hasOwnProperty.call(u3, p3) && p3 !== `layout` && p3 !== `paint` && p3 !== `filter` && p3 !== `metadata` && p3 !== `minzoom` && p3 !== `maxzoom` && (p3.indexOf(`paint.`) === 0 ? He2(u3[p3], d3[p3], n5, l3, p3.slice(6), `setPaintProperty`) : Ie2(u3[p3], d3[p3]) || Le2(n5, { command: `setLayerProperty`, args: [l3, p3, d3[p3]] }));
            } else Le2(n5, { command: `removeLayer`, args: [l3] }), f3 = s3[s3.lastIndexOf(l3) + 1], Le2(n5, { command: `addLayer`, args: [d3, f3] });
          })(a3, t5.layers, n4);
        } catch (e7) {
          console.warn(`Unable to compute style diff:`, e7), n4 = [{ command: `setStyle`, args: [t5] }];
        }
        return n4;
      }, e5.bQ = function(e6) {
        let t5 = [], n4 = e6.id;
        return n4 === void 0 && t5.push({ message: `layers.${n4}: missing required property "id"` }), e6.render === void 0 && t5.push({ message: `layers.${n4}: missing required method "render"` }), e6.renderingMode && e6.renderingMode !== `2d` && e6.renderingMode !== `3d` && t5.push({ message: `layers.${n4}: property "renderingMode" must be either "2d" or "3d"` }), t5;
      }, e5.bR = ie2, e5.bS = ae2, e5.bT = class extends ps {
        constructor(e6, t5) {
          super(e6, t5), this.current = 0;
        }
        set(e6) {
          this.current !== e6 && (this.current = e6, this.gl.uniform1i(this.location, e6));
        }
      }, e5.bU = gs, e5.bV = class extends ps {
        constructor(e6, t5) {
          super(e6, t5), this.current = _s;
        }
        set(e6) {
          if (e6[12] !== this.current[12] || e6[0] !== this.current[0]) return this.current = e6, void this.gl.uniformMatrix4fv(this.location, false, e6);
          for (let t5 = 1; t5 < 16; t5++) if (e6[t5] !== this.current[t5]) {
            this.current = e6, this.gl.uniformMatrix4fv(this.location, false, e6);
            break;
          }
        }
      }, e5.bW = hs, e5.bX = class extends ps {
        constructor(e6, t5) {
          super(e6, t5), this.current = [0, 0, 0];
        }
        set(e6) {
          e6[0] === this.current[0] && e6[1] === this.current[1] && e6[2] === this.current[2] || (this.current = e6, this.gl.uniform3f(this.location, e6[0], e6[1], e6[2]));
        }
      }, e5.bY = class extends ps {
        constructor(e6, t5) {
          super(e6, t5), this.current = [0, 0];
        }
        set(e6) {
          e6[0] === this.current[0] && e6[1] === this.current[1] || (this.current = e6, this.gl.uniform2f(this.location, e6[0], e6[1]));
        }
      }, e5.bZ = p2, e5.b_ = function(e6, t5) {
        var n4 = Math.sin(t5), r3 = Math.cos(t5);
        return e6[0] = r3, e6[1] = n4, e6[2] = 0, e6[3] = -n4, e6[4] = r3, e6[5] = 0, e6[6] = 0, e6[7] = 0, e6[8] = 1, e6;
      }, e5.ba = function(e6, t5, n4) {
        var r3 = Math.sin(n4), i3 = Math.cos(n4), a3 = t5[4], o3 = t5[5], s3 = t5[6], c3 = t5[7], l3 = t5[8], u3 = t5[9], d3 = t5[10], f3 = t5[11];
        return t5 !== e6 && (e6[0] = t5[0], e6[1] = t5[1], e6[2] = t5[2], e6[3] = t5[3], e6[12] = t5[12], e6[13] = t5[13], e6[14] = t5[14], e6[15] = t5[15]), e6[4] = a3 * i3 + l3 * r3, e6[5] = o3 * i3 + u3 * r3, e6[6] = s3 * i3 + d3 * r3, e6[7] = c3 * i3 + f3 * r3, e6[8] = l3 * i3 - a3 * r3, e6[9] = u3 * i3 - o3 * r3, e6[10] = d3 * i3 - s3 * r3, e6[11] = f3 * i3 - c3 * r3, e6;
      }, e5.bb = function() {
        let e6 = new Float32Array(16);
        return m2(e6), e6;
      }, e5.bc = function() {
        let e6 = new Float64Array(16);
        return m2(e6), e6;
      }, e5.bd = function() {
        return new Float64Array(16);
      }, e5.be = function(e6, t5, n4) {
        let r3 = new Float64Array(4);
        return T2(r3, e6, t5 - 90, n4), r3;
      }, e5.bf = function(e6, t5, n4, r3) {
        var i3, a3, o3, s3, c3, l3 = t5[0], u3 = t5[1], f3 = t5[2], p3 = t5[3], m3 = n4[0], h3 = n4[1], g3 = n4[2], _3 = n4[3];
        return (a3 = l3 * m3 + u3 * h3 + f3 * g3 + p3 * _3) < 0 && (a3 = -a3, m3 = -m3, h3 = -h3, g3 = -g3, _3 = -_3), 1 - a3 > d2 ? (i3 = Math.acos(a3), o3 = Math.sin(i3), s3 = Math.sin((1 - r3) * i3) / o3, c3 = Math.sin(r3 * i3) / o3) : (s3 = 1 - r3, c3 = r3), e6[0] = s3 * l3 + c3 * m3, e6[1] = s3 * u3 + c3 * h3, e6[2] = s3 * f3 + c3 * g3, e6[3] = s3 * p3 + c3 * _3, e6;
      }, e5.bg = function(e6) {
        let t5 = new Float64Array(9);
        var n4, r3, i3, a3, o3, s3, c3, l3, u3, d3 = (i3 = (r3 = e6)[0]) * (c3 = i3 + i3), f3 = (a3 = r3[1]) * c3, p3, m3 = (o3 = r3[2]) * c3, h3 = o3 * (l3 = a3 + a3), g3, _3 = (s3 = r3[3]) * c3, v3 = s3 * l3, y3 = s3 * (u3 = o3 + o3);
        (n4 = t5)[0] = 1 - (p3 = a3 * l3) - (g3 = o3 * u3), n4[3] = f3 - y3, n4[6] = m3 + v3, n4[1] = f3 + y3, n4[4] = 1 - d3 - g3, n4[7] = h3 - _3, n4[2] = m3 - v3, n4[5] = h3 + _3, n4[8] = 1 - d3 - p3;
        let b3 = ve2(-Math.asin(N2(t5[2], -1, 1))), x3, S3;
        return Math.hypot(t5[5], t5[8]) < 1e-3 ? (x3 = 0, S3 = -ve2(Math.atan2(t5[3], t5[4]))) : (x3 = ve2(t5[5] === 0 && t5[8] === 0 ? 0 : Math.atan2(t5[5], t5[8])), S3 = ve2(t5[1] === 0 && t5[0] === 0 ? 0 : Math.atan2(t5[1], t5[0]))), { roll: x3, pitch: b3 + 90, bearing: S3 };
      }, e5.bh = function(e6, t5) {
        return e6.roll == t5.roll && e6.pitch == t5.pitch && e6.bearing == t5.bearing;
      }, e5.bi = K2, e5.bj = ms, e5.bk = rl, e5.bl = il, e5.bm = tl, e5.bn = ee2, e5.bo = j2, e5.bp = Wt2, e5.bq = function(e6, t5, n4, r3, i3) {
        return ee2(r3, i3, N2((e6 - t5) / (n4 - t5), 0, 1));
      }, e5.br = A2, e5.bs = function() {
        return new Float64Array(3);
      }, e5.bt = function(e6, t5, n4, r3) {
        return e6[0] = t5[0] + n4[0] * r3, e6[1] = t5[1] + n4[1] * r3, e6[2] = t5[2] + n4[2] * r3, e6;
      }, e5.bu = T2, e5.bv = function(e6, t5, n4) {
        var r3 = n4[0], i3 = n4[1], a3 = n4[2], o3 = n4[3], s3 = t5[0], c3 = t5[1], l3 = t5[2], u3 = i3 * l3 - a3 * c3, d3 = a3 * s3 - r3 * l3, f3 = r3 * c3 - i3 * s3;
        return e6[0] = s3 + o3 * (u3 += u3) + i3 * (f3 += f3) - a3 * (d3 += d3), e6[1] = c3 + o3 * d3 + a3 * u3 - r3 * f3, e6[2] = l3 + o3 * f3 + r3 * d3 - i3 * u3, e6;
      }, e5.bw = function(e6, t5, n4) {
        let r3 = (i3 = [e6[0], e6[1], e6[2], t5[0], t5[1], t5[2], n4[0], n4[1], n4[2]])[0] * ((u3 = i3[8]) * (o3 = i3[4]) - (s3 = i3[5]) * (l3 = i3[7])) + i3[1] * (-u3 * (a3 = i3[3]) + s3 * (c3 = i3[6])) + i3[2] * (l3 * a3 - o3 * c3);
        var i3, a3, o3, s3, c3, l3, u3;
        if (r3 === 0) return null;
        let d3 = b2([], [t5[0], t5[1], t5[2]], [n4[0], n4[1], n4[2]]), f3 = b2([], [n4[0], n4[1], n4[2]], [e6[0], e6[1], e6[2]]), p3 = b2([], [e6[0], e6[1], e6[2]], [t5[0], t5[1], t5[2]]), m3 = y2([], d3, -e6[3]);
        return v2(m3, m3, y2([], f3, -t5[3])), v2(m3, m3, y2([], p3, -n4[3])), y2(m3, m3, 1 / r3), m3;
      }, e5.bx = md, e5.by = function() {
        return new Float64Array(4);
      }, e5.bz = function(e6, t5, n4, r3) {
        var i3 = [], a3 = [];
        return i3[0] = t5[0] - n4[0], i3[1] = t5[1] - n4[1], i3[2] = t5[2] - n4[2], a3[0] = i3[0] * Math.cos(r3) - i3[1] * Math.sin(r3), a3[1] = i3[0] * Math.sin(r3) + i3[1] * Math.cos(r3), a3[2] = i3[2], e6[0] = a3[0] + n4[0], e6[1] = a3[1] + n4[1], e6[2] = a3[2] + n4[2], e6;
      }, e5.c = xe2, e5.c0 = function(e6, t5, n4, r3, i3, a3, o3) {
        var s3 = 1 / (t5 - n4), c3 = 1 / (r3 - i3), l3 = 1 / (a3 - o3);
        return e6[0] = -2 * s3, e6[1] = 0, e6[2] = 0, e6[3] = 0, e6[4] = 0, e6[5] = -2 * c3, e6[6] = 0, e6[7] = 0, e6[8] = 0, e6[9] = 0, e6[10] = 2 * l3, e6[11] = 0, e6[12] = (t5 + n4) * s3, e6[13] = (i3 + r3) * c3, e6[14] = (o3 + a3) * l3, e6[15] = 1, e6;
      }, e5.c1 = class extends ps {
        constructor(e6, t5) {
          super(e6, t5), this.current = [];
        }
        set(e6) {
          if (e6 != this.current) {
            this.current = e6;
            let t5 = new Float32Array(4 * e6.length);
            for (let n4 = 0; n4 < e6.length; n4++) t5[4 * n4] = e6[n4].r, t5[4 * n4 + 1] = e6[n4].g, t5[4 * n4 + 2] = e6[n4].b, t5[4 * n4 + 3] = e6[n4].a;
            this.gl.uniform4fv(this.location, t5);
          }
        }
      }, e5.c2 = class extends ps {
        constructor(e6, t5) {
          super(e6, t5), this.current = [];
        }
        set(e6) {
          if (e6 != this.current) {
            this.current = e6;
            let t5 = new Float32Array(e6);
            this.gl.uniform1fv(this.location, t5);
          }
        }
      }, e5.c3 = class extends po {
      }, e5.c4 = $l, e5.c5 = class extends ho {
      }, e5.c6 = gc, e5.c7 = function(e6) {
        return e6 <= 1 ? 1 : 2 ** Math.ceil(Math.log(e6) / Math.LN2);
      }, e5.c8 = hc, e5.c9 = function(e6, t5, n4) {
        var r3 = t5[0], i3 = t5[1], a3 = t5[2], o3 = n4[3] * r3 + n4[7] * i3 + n4[11] * a3 + n4[15];
        return e6[0] = (n4[0] * r3 + n4[4] * i3 + n4[8] * a3 + n4[12]) / (o3 || (o3 = 1)), e6[1] = (n4[1] * r3 + n4[5] * i3 + n4[9] * a3 + n4[13]) / o3, e6[2] = (n4[2] * r3 + n4[6] * i3 + n4[10] * a3 + n4[14]) / o3, e6;
      }, e5.cB = function(e6) {
        return e6.message === be2;
      }, e5.cC = Te2, e5.cD = function(e6, t5) {
        Se2.REGISTERED_PROTOCOLS[e6] = t5;
      }, e5.cE = function(e6) {
        delete Se2.REGISTERED_PROTOCOLS[e6];
      }, e5.cF = function(e6, t5) {
        let n4 = {};
        for (let r4 = 0; r4 < e6.length; r4++) {
          let i3 = t5 && t5[e6[r4].id] || Ci(e6[r4]);
          t5 && (t5[e6[r4].id] = i3);
          let a3 = n4[i3];
          a3 || (a3 = n4[i3] = []), a3.push(e6[r4]);
        }
        let r3 = [];
        for (let e7 in n4) r3.push(n4[e7]);
        return r3;
      }, e5.cG = X, e5.cH = Md, e5.cI = Pd, e5.cJ = Cu, e5.cK = function(t5) {
        t5.bucket.createArrays(), t5.bucket.tilePixelRatio = O2 / (512 * t5.bucket.overscaling), t5.bucket.compareText = {}, t5.bucket.iconsNeedLinear = false;
        let n4 = t5.bucket.layers[0], r3 = n4.layout, i3 = n4._unevaluatedLayout._values, a3 = { layoutIconSize: i3[`icon-size`].possiblyEvaluate(new ka(t5.bucket.zoom + 1), t5.canonical), layoutTextSize: i3[`text-size`].possiblyEvaluate(new ka(t5.bucket.zoom + 1), t5.canonical), textMaxSize: i3[`text-size`].possiblyEvaluate(new ka(18)) };
        if (t5.bucket.textSizeData.kind === `composite`) {
          let { minZoom: e6, maxZoom: n5 } = t5.bucket.textSizeData;
          a3.compositeTextSizes = [i3[`text-size`].possiblyEvaluate(new ka(e6), t5.canonical), i3[`text-size`].possiblyEvaluate(new ka(n5), t5.canonical)];
        }
        if (t5.bucket.iconSizeData.kind === `composite`) {
          let { minZoom: e6, maxZoom: n5 } = t5.bucket.iconSizeData;
          a3.compositeIconSizes = [i3[`icon-size`].possiblyEvaluate(new ka(e6), t5.canonical), i3[`icon-size`].possiblyEvaluate(new ka(n5), t5.canonical)];
        }
        let o3 = r3.get(`text-line-height`) * nu, s3 = r3.get(`text-rotation-alignment`) !== `viewport` && r3.get(`symbol-placement`) !== `point`, c3 = r3.get(`text-keep-upright`), l3 = r3.get(`text-size`);
        for (let i4 of t5.bucket.features) {
          let u3 = r3.get(`text-font`).evaluate(i4, {}, t5.canonical).join(`,`), d3 = l3.evaluate(i4, {}, t5.canonical), f3 = a3.layoutTextSize.evaluate(i4, {}, t5.canonical), p3 = a3.layoutIconSize.evaluate(i4, {}, t5.canonical), m3 = { horizontal: {}, vertical: void 0 }, h3 = i4.text, g3, _3 = [0, 0];
          if (h3) {
            let a4 = h3.toString(), l4 = r3.get(`text-letter-spacing`).evaluate(i4, {}, t5.canonical) * nu, p4 = _a2(a4) ? l4 : 0, g4 = r3.get(`text-anchor`).evaluate(i4, {}, t5.canonical), v4 = of(n4, i4, t5.canonical);
            if (!v4) {
              let e6 = r3.get(`text-radial-offset`).evaluate(i4, {}, t5.canonical);
              _3 = e6 ? af(g4, [e6 * nu, rf]) : r3.get(`text-offset`).evaluate(i4, {}, t5.canonical).map(((e7) => e7 * nu));
            }
            let y4 = s3 ? `center` : r3.get(`text-justify`).evaluate(i4, {}, t5.canonical), b3 = r3.get(`symbol-placement`) === `point` ? r3.get(`text-max-width`).evaluate(i4, {}, t5.canonical) * nu : 1 / 0, x3 = () => {
              t5.bucket.allowVerticalPlacement && ga(a4) && (m3.vertical = Du(h3, t5.glyphMap, t5.glyphPositions, t5.imagePositions, u3, b3, o3, g4, `left`, p4, _3, e5.as.vertical, true, f3, d3));
            };
            if (!s3 && v4) {
              let n5 = /* @__PURE__ */ new Set();
              if (y4 === `auto`) for (let e6 = 0; e6 < v4.values.length; e6 += 2) n5.add(sf(v4.values[e6]));
              else n5.add(y4);
              let r4 = false;
              for (let i5 of n5) if (!m3.horizontal[i5]) if (r4) m3.horizontal[i5] = m3.horizontal[0];
              else {
                let n6 = Du(h3, t5.glyphMap, t5.glyphPositions, t5.imagePositions, u3, b3, o3, `center`, i5, p4, _3, e5.as.horizontal, false, f3, d3);
                n6 && (m3.horizontal[i5] = n6, r4 = n6.positionedLines.length === 1);
              }
              x3();
            } else {
              y4 === `auto` && (y4 = sf(g4));
              let n5 = Du(h3, t5.glyphMap, t5.glyphPositions, t5.imagePositions, u3, b3, o3, g4, y4, p4, _3, e5.as.horizontal, false, f3, d3);
              n5 && (m3.horizontal[y4] = n5), x3(), ga(a4) && s3 && c3 && (m3.vertical = Du(h3, t5.glyphMap, t5.glyphPositions, t5.imagePositions, u3, b3, o3, g4, y4, p4, _3, e5.as.vertical, false, f3, d3));
            }
          }
          let v3 = false;
          if (i4.icon && i4.icon.name) {
            let e6 = t5.imageMap[i4.icon.name];
            e6 && (g3 = Wu(t5.imagePositions[i4.icon.name], r3.get(`icon-offset`).evaluate(i4, {}, t5.canonical), r3.get(`icon-anchor`).evaluate(i4, {}, t5.canonical)), v3 = !!e6.sdf, t5.bucket.sdfIcons === void 0 ? t5.bucket.sdfIcons = v3 : t5.bucket.sdfIcons !== v3 && F2(`Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer`), (e6.pixelRatio !== t5.bucket.pixelRatio || r3.get(`icon-rotate`).constantOr(1) !== 0) && (t5.bucket.iconsNeedLinear = true));
          }
          let y3 = uf(m3.horizontal) || m3.vertical;
          t5.bucket.iconsInText = !!y3 && y3.iconsInText, (y3 || g3) && cf(t5.bucket, i4, m3, g3, t5.imageMap, a3, f3, p3, _3, v3, t5.canonical, t5.subdivisionGranularity);
        }
        t5.showCollisionBoxes && t5.bucket.generateCollisionDebugBuffers();
      }, e5.cL = dl, e5.cM = Ol, e5.cN = Vl, e5.cO = wl, e5.cP = ou, e5.cQ = class {
        constructor(e6) {
          this._marks = { start: [e6.url, `start`].join(`#`), end: [e6.url, `end`].join(`#`), measure: e6.url.toString() }, performance.mark(this._marks.start);
        }
        finish() {
          performance.mark(this._marks.end);
          let e6 = performance.getEntriesByName(this._marks.measure);
          return e6.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), e6 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), e6;
        }
      }, e5.cR = function(e6, n4, r3, i3, a3) {
        return t4(this, void 0, void 0, (function* () {
          if (u2()) try {
            return yield I2(e6, n4, r3, i3, a3);
          } catch {
          }
          return (function(e7, t5, n5, r4, i4) {
            let a4 = e7.width, o3 = e7.height;
            me2 && he2 || (me2 = new OffscreenCanvas(a4, o3), he2 = me2.getContext(`2d`, { willReadFrequently: true })), me2.width = a4, me2.height = o3, he2.drawImage(e7, 0, 0, a4, o3);
            let s3 = he2.getImageData(t5, n5, r4, i4);
            return he2.clearRect(0, 0, a4, o3), s3.data;
          })(e6, n4, r3, i3, a3);
        }));
      }, e5.cS = wc, e5.cT = r2, e5.cU = Sl, e5.cV = yl, e5.cW = ii, e5.cX = function(e6, t5) {
        let n4 = /* @__PURE__ */ new Map();
        if (e6 != null) if (e6.type === `Feature`) n4.set(Ad(e6, t5), e6);
        else for (let r3 of e6.features) n4.set(Ad(r3, t5), r3);
        return n4;
      }, e5.cY = function(e6, t5) {
        if (e6 == null) return true;
        if (e6.type === `Feature`) return Ad(e6, t5) != null;
        if (e6.type === `FeatureCollection`) {
          let n4 = /* @__PURE__ */ new Set();
          for (let r3 of e6.features) {
            let e7 = Ad(r3, t5);
            if (e7 == null || n4.has(e7)) return false;
            n4.add(e7);
          }
          return true;
        }
        return false;
      }, e5.cZ = function(e6, t5, n4) {
        var _a3, _b2, _c3, _d3;
        if (t5.removeAll && e6.clear(), t5.remove) for (let n5 of t5.remove) e6.delete(n5);
        if (t5.add) for (let r3 of t5.add) {
          let t6 = Ad(r3, n4);
          t6 != null && e6.set(t6, r3);
        }
        if (t5.update) for (let n5 of t5.update) {
          let t6 = e6.get(n5.id);
          if (t6 == null) continue;
          let r3 = !n5.removeAllProperties && (((_a3 = n5.removeProperties) == null ? void 0 : _a3.length) > 0 || ((_b2 = n5.addOrUpdateProperties) == null ? void 0 : _b2.length) > 0);
          if ((n5.newGeometry || n5.removeAllProperties || r3) && (t6 = Object.assign({}, t6), e6.set(n5.id, t6), r3 && (t6.properties = Object.assign({}, t6.properties))), n5.newGeometry && (t6.geometry = n5.newGeometry), n5.removeAllProperties) t6.properties = {};
          else if (((_c3 = n5.removeProperties) == null ? void 0 : _c3.length) > 0) for (let e7 of n5.removeProperties) Object.prototype.hasOwnProperty.call(t6.properties, e7) && delete t6.properties[e7];
          if (((_d3 = n5.addOrUpdateProperties) == null ? void 0 : _d3.length) > 0) for (let { key: e7, value: r4 } of n5.addOrUpdateProperties) t6.properties[e7] = r4;
        }
      }, e5.c_ = Oa, e5.ca = class extends to {
      }, e5.cb = class extends So {
      }, e5.cc = function(e6, t5) {
        return e6[0] === t5[0] && e6[1] === t5[1] && e6[2] === t5[2] && e6[3] === t5[3] && e6[4] === t5[4] && e6[5] === t5[5] && e6[6] === t5[6] && e6[7] === t5[7] && e6[8] === t5[8] && e6[9] === t5[9] && e6[10] === t5[10] && e6[11] === t5[11] && e6[12] === t5[12] && e6[13] === t5[13] && e6[14] === t5[14] && e6[15] === t5[15];
      }, e5.cd = function(e6, t5) {
        var n4 = e6[0], r3 = e6[1], i3 = e6[2], a3 = e6[3], o3 = e6[4], s3 = e6[5], c3 = e6[6], l3 = e6[7], u3 = e6[8], f3 = e6[9], p3 = e6[10], m3 = e6[11], h3 = e6[12], g3 = e6[13], _3 = e6[14], v3 = e6[15], y3 = t5[0], b3 = t5[1], x3 = t5[2], S3 = t5[3], C3 = t5[4], w3 = t5[5], T3 = t5[6], E3 = t5[7], D3 = t5[8], O3 = t5[9], k3 = t5[10], A3 = t5[11], ee3 = t5[12], j3 = t5[13], M3 = t5[14], te3 = t5[15];
        return Math.abs(n4 - y3) <= d2 * Math.max(1, Math.abs(n4), Math.abs(y3)) && Math.abs(r3 - b3) <= d2 * Math.max(1, Math.abs(r3), Math.abs(b3)) && Math.abs(i3 - x3) <= d2 * Math.max(1, Math.abs(i3), Math.abs(x3)) && Math.abs(a3 - S3) <= d2 * Math.max(1, Math.abs(a3), Math.abs(S3)) && Math.abs(o3 - C3) <= d2 * Math.max(1, Math.abs(o3), Math.abs(C3)) && Math.abs(s3 - w3) <= d2 * Math.max(1, Math.abs(s3), Math.abs(w3)) && Math.abs(c3 - T3) <= d2 * Math.max(1, Math.abs(c3), Math.abs(T3)) && Math.abs(l3 - E3) <= d2 * Math.max(1, Math.abs(l3), Math.abs(E3)) && Math.abs(u3 - D3) <= d2 * Math.max(1, Math.abs(u3), Math.abs(D3)) && Math.abs(f3 - O3) <= d2 * Math.max(1, Math.abs(f3), Math.abs(O3)) && Math.abs(p3 - k3) <= d2 * Math.max(1, Math.abs(p3), Math.abs(k3)) && Math.abs(m3 - A3) <= d2 * Math.max(1, Math.abs(m3), Math.abs(A3)) && Math.abs(h3 - ee3) <= d2 * Math.max(1, Math.abs(h3), Math.abs(ee3)) && Math.abs(g3 - j3) <= d2 * Math.max(1, Math.abs(g3), Math.abs(j3)) && Math.abs(_3 - M3) <= d2 * Math.max(1, Math.abs(_3), Math.abs(M3)) && Math.abs(v3 - te3) <= d2 * Math.max(1, Math.abs(v3), Math.abs(te3));
      }, e5.ce = function(e6, t5) {
        return e6[0] = t5[0], e6[1] = t5[1], e6[2] = t5[2], e6[3] = t5[3], e6[4] = t5[4], e6[5] = t5[5], e6[6] = t5[6], e6[7] = t5[7], e6[8] = t5[8], e6[9] = t5[9], e6[10] = t5[10], e6[11] = t5[11], e6[12] = t5[12], e6[13] = t5[13], e6[14] = t5[14], e6[15] = t5[15], e6;
      }, e5.cf = (e6) => e6.type === `symbol`, e5.cg = (e6) => e6.type === `circle`, e5.ch = (e6) => e6.type === `heatmap`, e5.ci = (e6) => e6.type === `line`, e5.cj = (e6) => e6.type === `fill`, e5.ck = (e6) => e6.type === `fill-extrusion`, e5.cl = (e6) => e6.type === `hillshade`, e5.cm = (e6) => e6.type === `color-relief`, e5.cn = (e6) => e6.type === `background`, e5.co = (e6) => e6.type === `custom`, e5.cp = M2, e5.cq = function(e6, t5, n4) {
        let r3 = D2(t5.x - n4.x, t5.y - n4.y), i3 = D2(e6.x - n4.x, e6.y - n4.y);
        var a3, o3;
        return ve2(Math.atan2(r3[0] * i3[1] - r3[1] * i3[0], (a3 = r3)[0] * (o3 = i3)[0] + a3[1] * o3[1]));
      }, e5.cr = te2, e5.cs = function(e6, t5) {
        return ye2[t5] && (e6 instanceof MouseEvent || e6 instanceof WheelEvent);
      }, e5.ct = function(e6, t5) {
        return L2[t5] && `touches` in e6;
      }, e5.cu = function(e6) {
        return L2[e6] || ye2[e6];
      }, e5.cv = function(e6, t5, n4) {
        var r3 = t5[0], i3 = t5[1];
        return e6[0] = n4[0] * r3 + n4[4] * i3 + n4[12], e6[1] = n4[1] * r3 + n4[5] * i3 + n4[13], e6;
      }, e5.cw = function(e6, t5) {
        let { x: n4, y: r3 } = wd.fromLngLat(t5);
        return !(e6 < 0 || e6 > 25 || r3 < 0 || r3 >= 1 || n4 < 0 || n4 >= 1);
      }, e5.cx = function(e6, t5) {
        return e6[0] = t5[0], e6[1] = 0, e6[2] = 0, e6[3] = 0, e6[4] = 0, e6[5] = t5[1], e6[6] = 0, e6[7] = 0, e6[8] = 0, e6[9] = 0, e6[10] = t5[2], e6[11] = 0, e6[12] = 0, e6[13] = 0, e6[14] = 0, e6[15] = 1, e6;
      }, e5.cy = class extends eo {
      }, e5.cz = { mark(e6) {
        performance.mark(e6);
      }, frame(e6) {
        let t5 = e6;
        bf != null && xf.push(t5 - bf), bf = t5;
      }, clearMetrics() {
        for (let t5 in bf = null, xf = [], performance.clearMeasures(Cf), performance.clearMeasures(wf), e5.cA) performance.clearMarks(e5.cA[t5]);
      }, getPerformanceMetrics() {
        performance.measure(Cf, e5.cA.create, e5.cA.load), performance.measure(wf, e5.cA.create, e5.cA.fullLoad);
        let t5 = performance.getEntriesByName(Cf)[0].duration, n4 = performance.getEntriesByName(wf)[0].duration, r3 = xf.length, i3 = 1 / (xf.reduce(((e6, t6) => e6 + t6), 0) / r3 / 1e3), a3 = xf.filter(((e6) => e6 > Sf)).reduce(((e6, t6) => e6 + (t6 - Sf) / Sf), 0);
        return { loadTime: t5, fullLoadTime: n4, fps: i3, percentDroppedFrames: a3 / (r3 + a3) * 100, totalFrames: r3 };
      } }, e5.d = Oe2, e5.e = P2, e5.f = (e6) => t4(void 0, void 0, void 0, (function* () {
        if (e6.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
        let t5 = new Blob([new Uint8Array(e6)], { type: `image/png` });
        try {
          return createImageBitmap(t5);
        } catch (e7) {
          throw Error(`Could not load image because of ${e7.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
        }
      })), e5.g = Ce2, e5.h = (e6) => new Promise(((t5, n4) => {
        let r3 = new Image();
        r3.onload = () => {
          t5(r3), URL.revokeObjectURL(r3.src), r3.onload = null, window.requestAnimationFrame((() => {
            r3.src = pe2;
          }));
        }, r3.onerror = () => n4(Error(`Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
        let i3 = new Blob([new Uint8Array(e6)], { type: `image/png` });
        r3.src = e6.byteLength ? URL.createObjectURL(i3) : pe2;
      })), e5.i = le2, e5.j = (e6, t5) => De2(P2(e6, { type: `json` }), t5), e5.k = Me2, e5.l = je2, e5.m = De2, e5.n = (e6, t5) => De2(P2(e6, { type: `arrayBuffer` }), t5), e5.o = function(e6) {
        return new ou(e6).readFields(vu, []);
      }, e5.p = xu, e5.q = pc, e5.r = Ha, e5.s = ge2, e5.t = R2, e5.u = Z, e5.v = ta, e5.w = F2, e5.x = Na, e5.y = ra, e5.z = sa;
    })), n2(`worker`, [`./shared`], (function(e5) {
      class t4 {
        constructor(e6, t5) {
          this.keyCache = {}, e6 && this.replace(e6, t5);
        }
        replace(e6, t5) {
          this._layerConfigs = {}, this._layers = {}, this.update(e6, [], t5);
        }
        update(t5, n4, r3) {
          for (let n5 of t5) {
            this._layerConfigs[n5.id] = n5;
            let t6 = this._layers[n5.id] = e5.bM(n5, r3);
            t6._featureFilter = e5.ae(t6.filter, r3), this.keyCache[n5.id] && delete this.keyCache[n5.id];
          }
          for (let e6 of n4) delete this.keyCache[e6], delete this._layerConfigs[e6], delete this._layers[e6];
          this.familiesBySource = {};
          let i3 = e5.cF(Object.values(this._layerConfigs), this.keyCache);
          for (let e6 of i3) {
            let t6 = e6.map(((e7) => this._layers[e7.id])), n5 = t6[0];
            if (n5.visibility === `none`) continue;
            let r4 = n5.source || ``, i4 = this.familiesBySource[r4];
            i4 || (i4 = this.familiesBySource[r4] = {});
            let a3 = n5.sourceLayer || `_geojsonTileLayer`, o3 = i4[a3];
            o3 || (o3 = i4[a3] = []), o3.push(t6);
          }
        }
      }
      class n3 {
        constructor(t5) {
          let n4 = {}, r3 = [];
          for (let e6 in t5) {
            let i4 = t5[e6], a4 = n4[e6] = {};
            for (let e7 in i4) {
              let t6 = i4[+e7];
              if (!t6 || t6.bitmap.width === 0 || t6.bitmap.height === 0) continue;
              let n5 = { x: 0, y: 0, w: t6.bitmap.width + 2, h: t6.bitmap.height + 2 };
              r3.push(n5), a4[e7] = { rect: n5, metrics: t6.metrics };
            }
          }
          let { w: i3, h: a3 } = e5.p(r3), o3 = new e5.q({ width: i3 || 1, height: a3 || 1 });
          for (let r4 in t5) {
            let i4 = t5[r4];
            for (let t6 in i4) {
              let a4 = i4[+t6];
              if (!a4 || a4.bitmap.width === 0 || a4.bitmap.height === 0) continue;
              let s3 = n4[r4][t6].rect;
              e5.q.copy(a4.bitmap, o3, { x: 0, y: 0 }, { x: s3.x + 1, y: s3.y + 1 }, a4.bitmap);
            }
          }
          this.image = o3, this.positions = n4;
        }
      }
      e5.cG(`GlyphAtlas`, n3);
      class r2 {
        constructor(t5) {
          this.tileID = new e5.a0(t5.tileID.overscaledZ, t5.tileID.wrap, t5.tileID.canonical.z, t5.tileID.canonical.x, t5.tileID.canonical.y), this.uid = t5.uid, this.zoom = t5.zoom, this.pixelRatio = t5.pixelRatio, this.tileSize = t5.tileSize, this.source = t5.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t5.showCollisionBoxes, this.collectResourceTiming = !!t5.collectResourceTiming, this.returnDependencies = !!t5.returnDependencies, this.promoteId = t5.promoteId, this.inFlightDependencies = [];
        }
        parse(t5, r3, a3, o3, s3) {
          return e5._(this, void 0, void 0, (function* () {
            this.status = `parsing`, this.data = t5, this.collisionBoxArray = new e5.ac();
            let c3 = new e5.cH(Object.keys(t5.layers).sort()), l3 = new e5.cI(this.tileID, this.promoteId);
            l3.bucketLayerIDs = [];
            let u3 = {}, d3 = { featureIndex: l3, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, dashDependencies: {}, availableImages: a3, subdivisionGranularity: s3 }, f3 = r3.familiesBySource[this.source];
            for (let n4 in f3) {
              let r4 = t5.layers[n4];
              if (!r4) continue;
              r4.version === 1 && e5.w(`Vector tile source "${this.source}" layer "${n4}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              let o4 = c3.encode(n4), s4 = [];
              for (let e6 = 0; e6 < r4.length; e6++) {
                let t6 = r4.feature(e6), i3 = l3.getId(t6, n4);
                s4.push({ feature: t6, id: i3, index: e6, sourceLayerIndex: o4 });
              }
              for (let t6 of f3[n4]) {
                let n5 = t6[0];
                n5.source !== this.source && e5.w(`layer.source = ${n5.source} does not equal this.source = ${this.source}`), n5.isHidden(this.zoom, true) || (i2(t6, this.zoom, a3), (u3[n5.id] = n5.createBucket({ index: l3.bucketLayerIDs.length, layers: t6, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: o4, sourceID: this.source })).populate(s4, d3, this.tileID.canonical), l3.bucketLayerIDs.push(t6.map(((e6) => e6.id))));
              }
            }
            let p3 = e5.bR(d3.glyphDependencies, ((e6) => Object.keys(e6).map(Number)));
            this.inFlightDependencies.forEach(((e6) => e6 == null ? void 0 : e6.abort())), this.inFlightDependencies = [];
            let m3 = Promise.resolve({});
            if (Object.keys(p3).length) {
              let e6 = new AbortController();
              this.inFlightDependencies.push(e6), m3 = o3.sendAsync({ type: `GG`, data: { stacks: p3, source: this.source, tileID: this.tileID, type: `glyphs` } }, e6);
            }
            let h3 = Object.keys(d3.iconDependencies), g3 = Promise.resolve({});
            if (h3.length) {
              let e6 = new AbortController();
              this.inFlightDependencies.push(e6), g3 = o3.sendAsync({ type: `GI`, data: { icons: h3, source: this.source, tileID: this.tileID, type: `icons` } }, e6);
            }
            let _3 = Object.keys(d3.patternDependencies), v3 = Promise.resolve({});
            if (_3.length) {
              let e6 = new AbortController();
              this.inFlightDependencies.push(e6), v3 = o3.sendAsync({ type: `GI`, data: { icons: _3, source: this.source, tileID: this.tileID, type: `patterns` } }, e6);
            }
            let y3 = d3.dashDependencies, b3 = Promise.resolve({});
            if (Object.keys(y3).length) {
              let e6 = new AbortController();
              this.inFlightDependencies.push(e6), b3 = o3.sendAsync({ type: `GDA`, data: { dashes: y3 } }, e6);
            }
            let [x3, S3, C3, w3] = yield Promise.all([m3, g3, v3, b3]), T3 = new n3(x3), E3 = new e5.cJ(S3, C3);
            for (let t6 in u3) {
              let n4 = u3[t6];
              n4 instanceof e5.ad ? (i2(n4.layers, this.zoom, a3), e5.cK({ bucket: n4, glyphMap: x3, glyphPositions: T3.positions, imageMap: S3, imagePositions: E3.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: d3.subdivisionGranularity })) : n4.hasDependencies && (n4 instanceof e5.cL || n4 instanceof e5.cM || n4 instanceof e5.cN) && (i2(n4.layers, this.zoom, a3), n4.addFeatures(d3, this.tileID.canonical, E3.patternPositions, w3));
            }
            return this.status = `done`, { buckets: Object.values(u3).filter(((e6) => !e6.isEmpty())), featureIndex: l3, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: T3.image, imageAtlas: E3, dashPositions: w3, glyphMap: this.returnDependencies ? x3 : null, iconMap: this.returnDependencies ? S3 : null, glyphPositions: this.returnDependencies ? T3.positions : null };
          }));
        }
      }
      function i2(t5, n4, r3) {
        let i3 = new e5.G(n4);
        for (let e6 of t5) e6.recalculate(i3, r3);
      }
      class a2 {
        constructor(e6, t5, n4) {
          this.actor = e6, this.layerIndex = t5, this.availableImages = n4, this.fetching = {}, this.loading = {}, this.loaded = {};
        }
        loadVectorTile(t5, n4) {
          return e5._(this, void 0, void 0, (function* () {
            let r3 = yield e5.n(t5.request, n4);
            try {
              return { vectorTile: new e5.cO(new e5.cP(r3.data)), rawData: r3.data, cacheControl: r3.cacheControl, expires: r3.expires };
            } catch (e6) {
              let n5 = new Uint8Array(r3.data), i3 = `Unable to parse the tile at ${t5.request.url}, `;
              throw i3 += n5[0] === 31 && n5[1] === 139 ? `please make sure the data is not gzipped and that you have configured the relevant header in the server` : `got error: ${e6.message}`, Error(i3);
            }
          }));
        }
        loadTile(t5) {
          return e5._(this, void 0, void 0, (function* () {
            let n4 = t5.uid, i3 = !!(t5 && t5.request && t5.request.collectResourceTiming) && new e5.cQ(t5.request), a3 = new r2(t5);
            this.loading[n4] = a3;
            let o3 = new AbortController();
            a3.abort = o3;
            try {
              let r3 = yield this.loadVectorTile(t5, o3);
              if (delete this.loading[n4], !r3) return null;
              let s3 = r3.rawData, c3 = {};
              r3.expires && (c3.expires = r3.expires), r3.cacheControl && (c3.cacheControl = r3.cacheControl);
              let l3 = {};
              if (i3) {
                let e6 = i3.finish();
                e6 && (l3.resourceTiming = JSON.parse(JSON.stringify(e6)));
              }
              a3.vectorTile = r3.vectorTile;
              let u3 = a3.parse(r3.vectorTile, this.layerIndex, this.availableImages, this.actor, t5.subdivisionGranularity);
              this.loaded[n4] = a3, this.fetching[n4] = { rawTileData: s3, cacheControl: c3, resourceTiming: l3 };
              try {
                let t6 = yield u3;
                return e5.e({ rawTileData: s3.slice(0) }, t6, c3, l3);
              } finally {
                delete this.fetching[n4];
              }
            } catch (e6) {
              throw delete this.loading[n4], a3.status = `done`, this.loaded[n4] = a3, e6;
            }
          }));
        }
        reloadTile(t5) {
          return e5._(this, void 0, void 0, (function* () {
            let n4 = t5.uid;
            if (!this.loaded || !this.loaded[n4]) throw Error(`Should not be trying to reload a tile that was never loaded or has been removed`);
            let r3 = this.loaded[n4];
            if (r3.showCollisionBoxes = t5.showCollisionBoxes, r3.status === `parsing`) {
              let i3 = yield r3.parse(r3.vectorTile, this.layerIndex, this.availableImages, this.actor, t5.subdivisionGranularity), a3;
              if (this.fetching[n4]) {
                let { rawTileData: t6, cacheControl: r4, resourceTiming: o3 } = this.fetching[n4];
                delete this.fetching[n4], a3 = e5.e({ rawTileData: t6.slice(0) }, i3, r4, o3);
              } else a3 = i3;
              return a3;
            }
            if (r3.status === `done` && r3.vectorTile) return r3.parse(r3.vectorTile, this.layerIndex, this.availableImages, this.actor, t5.subdivisionGranularity);
          }));
        }
        abortTile(t5) {
          return e5._(this, void 0, void 0, (function* () {
            let e6 = this.loading, n4 = t5.uid;
            e6 && e6[n4] && e6[n4].abort && (e6[n4].abort.abort(), delete e6[n4]);
          }));
        }
        removeTile(t5) {
          return e5._(this, void 0, void 0, (function* () {
            this.loaded && this.loaded[t5.uid] && delete this.loaded[t5.uid];
          }));
        }
      }
      class o2 {
        constructor() {
          this.loaded = {};
        }
        loadTile(t5) {
          return e5._(this, void 0, void 0, (function* () {
            let { uid: n4, encoding: r3, rawImageData: i3, redFactor: a3, greenFactor: o3, blueFactor: s3, baseShift: c3 } = t5, l3 = i3.width + 2, u3 = i3.height + 2, d3 = e5.b(i3) ? new e5.R({ width: l3, height: u3 }, yield e5.cR(i3, -1, -1, l3, u3)) : i3, f3 = new e5.cS(n4, d3, r3, a3, o3, s3, c3);
            return this.loaded = this.loaded || {}, this.loaded[n4] = f3, f3;
          }));
        }
        removeTile(e6) {
          let t5 = this.loaded, n4 = e6.uid;
          t5 && t5[n4] && delete t5[n4];
        }
      }
      var s2, c2, l2 = (function() {
        if (c2) return s2;
        function e6(e7, n4) {
          if (e7.length !== 0) {
            t5(e7[0], n4);
            for (var r3 = 1; r3 < e7.length; r3++) t5(e7[r3], !n4);
          }
        }
        function t5(e7, t6) {
          for (var n4 = 0, r3 = 0, i3 = 0, a3 = e7.length, o3 = a3 - 1; i3 < a3; o3 = i3++) {
            var s3 = (e7[i3][0] - e7[o3][0]) * (e7[o3][1] + e7[i3][1]), c3 = n4 + s3;
            r3 += Math.abs(n4) >= Math.abs(s3) ? n4 - c3 + s3 : s3 - c3 + n4, n4 = c3;
          }
          n4 + r3 >= 0 != !!t6 && e7.reverse();
        }
        return c2 = 1, s2 = function t6(n4, r3) {
          var i3, a3 = n4 && n4.type;
          if (a3 === `FeatureCollection`) for (i3 = 0; i3 < n4.features.length; i3++) t6(n4.features[i3], r3);
          else if (a3 === `GeometryCollection`) for (i3 = 0; i3 < n4.geometries.length; i3++) t6(n4.geometries[i3], r3);
          else if (a3 === `Feature`) t6(n4.geometry, r3);
          else if (a3 === `Polygon`) e6(n4.coordinates, r3);
          else if (a3 === `MultiPolygon`) for (i3 = 0; i3 < n4.coordinates.length; i3++) e6(n4.coordinates[i3], r3);
          return n4;
        };
      })(), u2 = e5.cT(l2);
      class d2 extends e5.cV {
        constructor(t5, n4) {
          super(new e5.cP(), 0, n4, [], []), this.feature = t5, this.type = t5.type, this.properties = t5.tags ? t5.tags : {}, `id` in t5 && (typeof t5.id == `string` ? this.id = parseInt(t5.id, 10) : typeof t5.id != `number` || isNaN(t5.id) || (this.id = t5.id));
        }
        loadGeometry() {
          let t5 = [], n4 = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
          for (let r3 of n4) {
            let n5 = [];
            for (let t6 of r3) n5.push(new e5.P(t6[0], t6[1]));
            t5.push(n5);
          }
          return t5;
        }
      }
      class f2 extends e5.cU {
        constructor(t5, n4) {
          super(new e5.cP()), this.layers = { _geojsonTileLayer: this }, this.name = `_geojsonTileLayer`, this.version = n4 ? n4.version : 1, this.extent = n4 ? n4.extent : 4096, this.length = t5.length, this.features = t5;
        }
        feature(e6) {
          return new d2(this.features[e6], this.extent);
        }
      }
      function p2(e6, t5) {
        t5.writeVarintField(15, e6.version || 1), t5.writeStringField(1, e6.name || ``), t5.writeVarintField(5, e6.extent || 4096);
        let n4 = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (let r4 = 0; r4 < e6.length; r4++) n4.feature = e6.feature(r4), t5.writeMessage(2, m2, n4);
        let r3 = n4.keys;
        for (let e7 of r3) t5.writeStringField(3, e7);
        let i3 = n4.values;
        for (let e7 of i3) t5.writeMessage(4, y2, e7);
      }
      function m2(e6, t5) {
        if (!e6.feature) return;
        let n4 = e6.feature;
        n4.id !== void 0 && t5.writeVarintField(1, n4.id), t5.writeMessage(2, h2, e6), t5.writeVarintField(3, n4.type), t5.writeMessage(4, v2, n4);
      }
      function h2(e6, t5) {
        var _a2;
        for (let n4 in (_a2 = e6.feature) == null ? void 0 : _a2.properties) {
          let r3 = e6.feature.properties[n4], i3 = e6.keycache[n4];
          if (r3 === null) continue;
          i3 === void 0 && (e6.keys.push(n4), i3 = e6.keys.length - 1, e6.keycache[n4] = i3), t5.writeVarint(i3), typeof r3 != `string` && typeof r3 != `boolean` && typeof r3 != `number` && (r3 = JSON.stringify(r3));
          let a3 = typeof r3 + `:` + r3, o3 = e6.valuecache[a3];
          o3 === void 0 && (e6.values.push(r3), o3 = e6.values.length - 1, e6.valuecache[a3] = o3), t5.writeVarint(o3);
        }
      }
      function g2(e6, t5) {
        return (t5 << 3) + (7 & e6);
      }
      function _2(e6) {
        return e6 << 1 ^ e6 >> 31;
      }
      function v2(e6, t5) {
        let n4 = e6.loadGeometry(), r3 = e6.type, i3 = 0, a3 = 0;
        for (let o3 of n4) {
          let n5 = 1;
          r3 === 1 && (n5 = o3.length), t5.writeVarint(g2(1, n5));
          let s3 = r3 === 3 ? o3.length - 1 : o3.length;
          for (let e7 = 0; e7 < s3; e7++) {
            e7 === 1 && r3 !== 1 && t5.writeVarint(g2(2, s3 - 1));
            let n6 = o3[e7].x - i3, c3 = o3[e7].y - a3;
            t5.writeVarint(_2(n6)), t5.writeVarint(_2(c3)), i3 += n6, a3 += c3;
          }
          e6.type === 3 && t5.writeVarint(g2(7, 1));
        }
      }
      function y2(e6, t5) {
        let n4 = typeof e6;
        n4 === `string` ? t5.writeStringField(1, e6) : n4 === `boolean` ? t5.writeBooleanField(7, e6) : n4 === `number` && (e6 % 1 == 0 ? e6 < 0 ? t5.writeSVarintField(6, e6) : t5.writeVarintField(5, e6) : t5.writeDoubleField(3, e6));
      }
      let b2 = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e6) => e6 }, x2 = Math.fround || (S2 = new Float32Array(1), (e6) => (S2[0] = +e6, S2[0]));
      var S2;
      class C2 {
        constructor(e6) {
          this.options = Object.assign(Object.create(b2), e6), this.trees = Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(e6) {
          let { log: t5, minZoom: n4, maxZoom: r3 } = this.options;
          t5 && console.time(`total time`);
          let i3 = `prepare ${e6.length} points`;
          t5 && console.time(i3), this.points = e6;
          let a3 = [];
          for (let t6 = 0; t6 < e6.length; t6++) {
            let n5 = e6[t6];
            if (!n5.geometry) continue;
            let [r4, i4] = n5.geometry.coordinates, o4 = x2(E2(r4)), s3 = x2(D2(i4));
            a3.push(o4, s3, 1 / 0, t6, -1, 1), this.options.reduce && a3.push(0);
          }
          let o3 = this.trees[r3 + 1] = this._createTree(a3);
          t5 && console.timeEnd(i3);
          for (let e7 = r3; e7 >= n4; e7--) {
            let n5 = +Date.now();
            o3 = this.trees[e7] = this._createTree(this._cluster(o3, e7)), t5 && console.log(`z%d: %d clusters in %dms`, e7, o3.numItems, +Date.now() - n5);
          }
          return t5 && console.timeEnd(`total time`), this;
        }
        getClusters(e6, t5) {
          let n4 = ((e6[0] + 180) % 360 + 360) % 360 - 180, r3 = Math.max(-90, Math.min(90, e6[1])), i3 = e6[2] === 180 ? 180 : ((e6[2] + 180) % 360 + 360) % 360 - 180, a3 = Math.max(-90, Math.min(90, e6[3]));
          if (e6[2] - e6[0] >= 360) n4 = -180, i3 = 180;
          else if (n4 > i3) {
            let e7 = this.getClusters([n4, r3, 180, a3], t5), o4 = this.getClusters([-180, r3, i3, a3], t5);
            return e7.concat(o4);
          }
          let o3 = this.trees[this._limitZoom(t5)], s3 = o3.range(E2(n4), D2(a3), E2(i3), D2(r3)), c3 = o3.data, l3 = [];
          for (let e7 of s3) {
            let t6 = this.stride * e7;
            l3.push(c3[t6 + 5] > 1 ? w2(c3, t6, this.clusterProps) : this.points[c3[t6 + 3]]);
          }
          return l3;
        }
        getChildren(e6) {
          let t5 = this._getOriginId(e6), n4 = this._getOriginZoom(e6), r3 = `No cluster with the specified id.`, i3 = this.trees[n4];
          if (!i3) throw Error(r3);
          let a3 = i3.data;
          if (t5 * this.stride >= a3.length) throw Error(r3);
          let o3 = this.options.radius / (this.options.extent * 2 ** (n4 - 1)), s3 = i3.within(a3[t5 * this.stride], a3[t5 * this.stride + 1], o3), c3 = [];
          for (let t6 of s3) {
            let n5 = t6 * this.stride;
            a3[n5 + 4] === e6 && c3.push(a3[n5 + 5] > 1 ? w2(a3, n5, this.clusterProps) : this.points[a3[n5 + 3]]);
          }
          if (c3.length === 0) throw Error(r3);
          return c3;
        }
        getLeaves(e6, t5, n4) {
          let r3 = [];
          return this._appendLeaves(r3, e6, t5 || (t5 = 10), n4 || (n4 = 0), 0), r3;
        }
        getTile(e6, t5, n4) {
          let r3 = this.trees[this._limitZoom(e6)], i3 = 2 ** e6, { extent: a3, radius: o3 } = this.options, s3 = o3 / a3, c3 = (n4 - s3) / i3, l3 = (n4 + 1 + s3) / i3, u3 = { features: [] };
          return this._addTileFeatures(r3.range((t5 - s3) / i3, c3, (t5 + 1 + s3) / i3, l3), r3.data, t5, n4, i3, u3), t5 === 0 && this._addTileFeatures(r3.range(1 - s3 / i3, c3, 1, l3), r3.data, i3, n4, i3, u3), t5 === i3 - 1 && this._addTileFeatures(r3.range(0, c3, s3 / i3, l3), r3.data, -1, n4, i3, u3), u3.features.length ? u3 : null;
        }
        getClusterExpansionZoom(e6) {
          let t5 = this._getOriginZoom(e6) - 1;
          for (; t5 <= this.options.maxZoom; ) {
            let n4 = this.getChildren(e6);
            if (t5++, n4.length !== 1) break;
            e6 = n4[0].properties.cluster_id;
          }
          return t5;
        }
        _appendLeaves(e6, t5, n4, r3, i3) {
          let a3 = this.getChildren(t5);
          for (let t6 of a3) {
            let a4 = t6.properties;
            if (a4 && a4.cluster ? i3 + a4.point_count <= r3 ? i3 += a4.point_count : i3 = this._appendLeaves(e6, a4.cluster_id, n4, r3, i3) : i3 < r3 ? i3++ : e6.push(t6), e6.length === n4) break;
          }
          return i3;
        }
        _createTree(t5) {
          let n4 = new e5.aM(t5.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let e6 = 0; e6 < t5.length; e6 += this.stride) n4.add(t5[e6], t5[e6 + 1]);
          return n4.finish(), n4.data = t5, n4;
        }
        _addTileFeatures(e6, t5, n4, r3, i3, a3) {
          for (let o3 of e6) {
            let e7 = o3 * this.stride, s3 = t5[e7 + 5] > 1, c3, l3, u3;
            if (s3) c3 = T2(t5, e7, this.clusterProps), l3 = t5[e7], u3 = t5[e7 + 1];
            else {
              let n5 = this.points[t5[e7 + 3]];
              c3 = n5.properties;
              let [r4, i4] = n5.geometry.coordinates;
              l3 = E2(r4), u3 = D2(i4);
            }
            let d3 = { type: 1, geometry: [[Math.round(this.options.extent * (l3 * i3 - n4)), Math.round(this.options.extent * (u3 * i3 - r3))]], tags: c3 }, f3;
            f3 = s3 || this.options.generateId ? t5[e7 + 3] : this.points[t5[e7 + 3]].id, f3 !== void 0 && (d3.id = f3), a3.features.push(d3);
          }
        }
        _limitZoom(e6) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+e6), this.options.maxZoom + 1));
        }
        _cluster(e6, t5) {
          let { radius: n4, extent: r3, reduce: i3, minPoints: a3 } = this.options, o3 = n4 / (r3 * 2 ** t5), s3 = e6.data, c3 = [], l3 = this.stride;
          for (let n5 = 0; n5 < s3.length; n5 += l3) {
            if (s3[n5 + 2] <= t5) continue;
            s3[n5 + 2] = t5;
            let r4 = s3[n5], u3 = s3[n5 + 1], d3 = e6.within(s3[n5], s3[n5 + 1], o3), f3 = s3[n5 + 5], p3 = f3;
            for (let e7 of d3) {
              let n6 = e7 * l3;
              s3[n6 + 2] > t5 && (p3 += s3[n6 + 5]);
            }
            if (p3 > f3 && p3 >= a3) {
              let e7, a4 = r4 * f3, o4 = u3 * f3, m3 = -1, h3 = (n5 / l3 << 5) + (t5 + 1) + this.points.length;
              for (let r5 of d3) {
                let c4 = r5 * l3;
                if (s3[c4 + 2] <= t5) continue;
                s3[c4 + 2] = t5;
                let u4 = s3[c4 + 5];
                a4 += s3[c4] * u4, o4 += s3[c4 + 1] * u4, s3[c4 + 4] = h3, i3 && (e7 || (e7 = this._map(s3, n5, true), m3 = this.clusterProps.length, this.clusterProps.push(e7)), i3(e7, this._map(s3, c4)));
              }
              s3[n5 + 4] = h3, c3.push(a4 / p3, o4 / p3, 1 / 0, h3, -1, p3), i3 && c3.push(m3);
            } else {
              for (let e7 = 0; e7 < l3; e7++) c3.push(s3[n5 + e7]);
              if (p3 > 1) for (let e7 of d3) {
                let n6 = e7 * l3;
                if (!(s3[n6 + 2] <= t5)) {
                  s3[n6 + 2] = t5;
                  for (let e8 = 0; e8 < l3; e8++) c3.push(s3[n6 + e8]);
                }
              }
            }
          }
          return c3;
        }
        _getOriginId(e6) {
          return e6 - this.points.length >> 5;
        }
        _getOriginZoom(e6) {
          return (e6 - this.points.length) % 32;
        }
        _map(e6, t5, n4) {
          if (e6[t5 + 5] > 1) {
            let r4 = this.clusterProps[e6[t5 + 6]];
            return n4 ? Object.assign({}, r4) : r4;
          }
          let r3 = this.points[e6[t5 + 3]].properties, i3 = this.options.map(r3);
          return n4 && i3 === r3 ? Object.assign({}, i3) : i3;
        }
      }
      function w2(e6, t5, n4) {
        return { type: `Feature`, id: e6[t5 + 3], properties: T2(e6, t5, n4), geometry: { type: `Point`, coordinates: [(r3 = e6[t5], 360 * (r3 - 0.5)), O2(e6[t5 + 1])] } };
        var r3;
      }
      function T2(e6, t5, n4) {
        let r3 = e6[t5 + 5], i3 = r3 >= 1e4 ? `${Math.round(r3 / 1e3)}k` : r3 >= 1e3 ? Math.round(r3 / 100) / 10 + `k` : r3, a3 = e6[t5 + 6], o3 = a3 === -1 ? {} : Object.assign({}, n4[a3]);
        return Object.assign(o3, { cluster: true, cluster_id: e6[t5 + 3], point_count: r3, point_count_abbreviated: i3 });
      }
      function E2(e6) {
        return e6 / 360 + 0.5;
      }
      function D2(e6) {
        let t5 = Math.sin(e6 * Math.PI / 180), n4 = 0.5 - 0.25 * Math.log((1 + t5) / (1 - t5)) / Math.PI;
        return n4 < 0 ? 0 : n4 > 1 ? 1 : n4;
      }
      function O2(e6) {
        let t5 = (180 - 360 * e6) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(t5)) / Math.PI - 90;
      }
      function k2(e6, t5, n4, r3) {
        let i3 = r3, a3 = t5 + (n4 - t5 >> 1), o3, s3 = n4 - t5, c3 = e6[t5], l3 = e6[t5 + 1], u3 = e6[n4], d3 = e6[n4 + 1];
        for (let r4 = t5 + 3; r4 < n4; r4 += 3) {
          let t6 = A2(e6[r4], e6[r4 + 1], c3, l3, u3, d3);
          if (t6 > i3) o3 = r4, i3 = t6;
          else if (t6 === i3) {
            let e7 = Math.abs(r4 - a3);
            e7 < s3 && (o3 = r4, s3 = e7);
          }
        }
        i3 > r3 && (o3 - t5 > 3 && k2(e6, t5, o3, r3), e6[o3 + 2] = i3, n4 - o3 > 3 && k2(e6, o3, n4, r3));
      }
      function A2(e6, t5, n4, r3, i3, a3) {
        let o3 = i3 - n4, s3 = a3 - r3;
        if (o3 !== 0 || s3 !== 0) {
          let c3 = ((e6 - n4) * o3 + (t5 - r3) * s3) / (o3 * o3 + s3 * s3);
          c3 > 1 ? (n4 = i3, r3 = a3) : c3 > 0 && (n4 += o3 * c3, r3 += s3 * c3);
        }
        return o3 = e6 - n4, s3 = t5 - r3, o3 * o3 + s3 * s3;
      }
      function ee2(e6, t5, n4, r3) {
        let i3 = { id: e6 ?? null, type: t5, geometry: n4, tags: r3, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        if (t5 === `Point` || t5 === `MultiPoint` || t5 === `LineString`) j2(i3, n4);
        else if (t5 === `Polygon`) j2(i3, n4[0]);
        else if (t5 === `MultiLineString`) for (let e7 of n4) j2(i3, e7);
        else if (t5 === `MultiPolygon`) for (let e7 of n4) j2(i3, e7[0]);
        return i3;
      }
      function j2(e6, t5) {
        for (let n4 = 0; n4 < t5.length; n4 += 3) e6.minX = Math.min(e6.minX, t5[n4]), e6.minY = Math.min(e6.minY, t5[n4 + 1]), e6.maxX = Math.max(e6.maxX, t5[n4]), e6.maxY = Math.max(e6.maxY, t5[n4 + 1]);
      }
      function M2(e6, t5, n4, r3) {
        if (!t5.geometry) return;
        let i3 = t5.geometry.coordinates;
        if (i3 && i3.length === 0) return;
        let a3 = t5.geometry.type, o3 = (n4.tolerance / ((1 << n4.maxZoom) * n4.extent)) ** 2, s3 = [], c3 = t5.id;
        if (n4.promoteId ? c3 = t5.properties[n4.promoteId] : n4.generateId && (c3 = r3 || 0), a3 === `Point`) te2(i3, s3);
        else if (a3 === `MultiPoint`) for (let e7 of i3) te2(e7, s3);
        else if (a3 === `LineString`) N2(i3, s3, o3, false);
        else if (a3 === `MultiLineString`) {
          if (n4.lineMetrics) {
            for (let n5 of i3) s3 = [], N2(n5, s3, o3, false), e6.push(ee2(c3, `LineString`, s3, t5.properties));
            return;
          }
          ne2(i3, s3, o3, false);
        } else if (a3 === `Polygon`) ne2(i3, s3, o3, true);
        else {
          if (a3 !== `MultiPolygon`) {
            if (a3 === `GeometryCollection`) {
              for (let i4 of t5.geometry.geometries) M2(e6, { id: c3, geometry: i4, properties: t5.properties }, n4, r3);
              return;
            }
            throw Error(`Input data is not a valid GeoJSON object.`);
          }
          for (let e7 of i3) {
            let t6 = [];
            ne2(e7, t6, o3, true), s3.push(t6);
          }
        }
        e6.push(ee2(c3, a3, s3, t5.properties));
      }
      function te2(e6, t5) {
        t5.push(P2(e6[0]), re2(e6[1]), 0);
      }
      function N2(e6, t5, n4, r3) {
        let i3, a3, o3 = 0;
        for (let n5 = 0; n5 < e6.length; n5++) {
          let s4 = P2(e6[n5][0]), c3 = re2(e6[n5][1]);
          t5.push(s4, c3, 0), n5 > 0 && (o3 += r3 ? (i3 * c3 - s4 * a3) / 2 : Math.sqrt((s4 - i3) ** 2 + (c3 - a3) ** 2)), i3 = s4, a3 = c3;
        }
        let s3 = t5.length - 3;
        t5[2] = 1, k2(t5, 0, s3, n4), t5[s3 + 2] = 1, t5.size = Math.abs(o3), t5.start = 0, t5.end = t5.size;
      }
      function ne2(e6, t5, n4, r3) {
        for (let i3 = 0; i3 < e6.length; i3++) {
          let a3 = [];
          N2(e6[i3], a3, n4, r3), t5.push(a3);
        }
      }
      function P2(e6) {
        return e6 / 360 + 0.5;
      }
      function re2(e6) {
        let t5 = Math.sin(e6 * Math.PI / 180), n4 = 0.5 - 0.25 * Math.log((1 + t5) / (1 - t5)) / Math.PI;
        return n4 < 0 ? 0 : n4 > 1 ? 1 : n4;
      }
      function ie2(e6, t5, n4, r3, i3, a3, o3, s3) {
        if (r3 /= t5, a3 >= (n4 /= t5) && o3 < r3) return e6;
        if (o3 < n4 || a3 >= r3) return null;
        let c3 = [];
        for (let t6 of e6) {
          let e7 = t6.geometry, a4 = t6.type, o4 = i3 === 0 ? t6.minX : t6.minY, l3 = i3 === 0 ? t6.maxX : t6.maxY;
          if (o4 >= n4 && l3 < r3) {
            c3.push(t6);
            continue;
          }
          if (l3 < n4 || o4 >= r3) continue;
          let u3 = [];
          if (a4 === `Point` || a4 === `MultiPoint`) ae2(e7, u3, n4, r3, i3);
          else if (a4 === `LineString`) oe2(e7, u3, n4, r3, i3, false, s3.lineMetrics);
          else if (a4 === `MultiLineString`) F2(e7, u3, n4, r3, i3, false);
          else if (a4 === `Polygon`) F2(e7, u3, n4, r3, i3, true);
          else if (a4 === `MultiPolygon`) for (let t7 of e7) {
            let e8 = [];
            F2(t7, e8, n4, r3, i3, true), e8.length && u3.push(e8);
          }
          if (u3.length) {
            if (s3.lineMetrics && a4 === `LineString`) {
              for (let e8 of u3) c3.push(ee2(t6.id, a4, e8, t6.tags));
              continue;
            }
            a4 !== `LineString` && a4 !== `MultiLineString` || (u3.length === 1 ? (a4 = `LineString`, u3 = u3[0]) : a4 = `MultiLineString`), a4 !== `Point` && a4 !== `MultiPoint` || (a4 = u3.length === 3 ? `Point` : `MultiPoint`), c3.push(ee2(t6.id, a4, u3, t6.tags));
          }
        }
        return c3.length ? c3 : null;
      }
      function ae2(e6, t5, n4, r3, i3) {
        for (let a3 = 0; a3 < e6.length; a3 += 3) {
          let o3 = e6[a3 + i3];
          o3 >= n4 && o3 <= r3 && ce2(t5, e6[a3], e6[a3 + 1], e6[a3 + 2]);
        }
      }
      function oe2(e6, t5, n4, r3, i3, a3, o3) {
        let s3 = se2(e6), c3 = i3 === 0 ? le2 : ue2, l3, u3, d3 = e6.start;
        for (let f4 = 0; f4 < e6.length - 3; f4 += 3) {
          let p4 = e6[f4], m4 = e6[f4 + 1], h4 = e6[f4 + 2], g3 = e6[f4 + 3], _3 = e6[f4 + 4], v3 = i3 === 0 ? p4 : m4, y3 = i3 === 0 ? g3 : _3, b3 = false;
          o3 && (l3 = Math.sqrt((p4 - g3) ** 2 + (m4 - _3) ** 2)), v3 < n4 ? y3 > n4 && (u3 = c3(s3, p4, m4, g3, _3, n4), o3 && (s3.start = d3 + l3 * u3)) : v3 > r3 ? y3 < r3 && (u3 = c3(s3, p4, m4, g3, _3, r3), o3 && (s3.start = d3 + l3 * u3)) : ce2(s3, p4, m4, h4), y3 < n4 && v3 >= n4 && (u3 = c3(s3, p4, m4, g3, _3, n4), b3 = true), y3 > r3 && v3 <= r3 && (u3 = c3(s3, p4, m4, g3, _3, r3), b3 = true), !a3 && b3 && (o3 && (s3.end = d3 + l3 * u3), t5.push(s3), s3 = se2(e6)), o3 && (d3 += l3);
        }
        let f3 = e6.length - 3, p3 = e6[f3], m3 = e6[f3 + 1], h3 = i3 === 0 ? p3 : m3;
        h3 >= n4 && h3 <= r3 && ce2(s3, p3, m3, e6[f3 + 2]), f3 = s3.length - 3, a3 && f3 >= 3 && (s3[f3] !== s3[0] || s3[f3 + 1] !== s3[1]) && ce2(s3, s3[0], s3[1], s3[2]), s3.length && t5.push(s3);
      }
      function se2(e6) {
        let t5 = [];
        return t5.size = e6.size, t5.start = e6.start, t5.end = e6.end, t5;
      }
      function F2(e6, t5, n4, r3, i3, a3) {
        for (let o3 of e6) oe2(o3, t5, n4, r3, i3, a3, false);
      }
      function ce2(e6, t5, n4, r3) {
        e6.push(t5, n4, r3);
      }
      function le2(e6, t5, n4, r3, i3, a3) {
        let o3 = (a3 - t5) / (r3 - t5);
        return ce2(e6, a3, n4 + (i3 - n4) * o3, 1), o3;
      }
      function ue2(e6, t5, n4, r3, i3, a3) {
        let o3 = (a3 - n4) / (i3 - n4);
        return ce2(e6, t5 + (r3 - t5) * o3, a3, 1), o3;
      }
      function de2(e6, t5) {
        let n4 = [];
        for (let r3 = 0; r3 < e6.length; r3++) {
          let i3 = e6[r3], a3 = i3.type, o3;
          if (a3 === `Point` || a3 === `MultiPoint` || a3 === `LineString`) o3 = fe2(i3.geometry, t5);
          else if (a3 === `MultiLineString` || a3 === `Polygon`) {
            o3 = [];
            for (let e7 of i3.geometry) o3.push(fe2(e7, t5));
          } else if (a3 === `MultiPolygon`) {
            o3 = [];
            for (let e7 of i3.geometry) {
              let n5 = [];
              for (let r4 of e7) n5.push(fe2(r4, t5));
              o3.push(n5);
            }
          }
          n4.push(ee2(i3.id, a3, o3, i3.tags));
        }
        return n4;
      }
      function fe2(e6, t5) {
        let n4 = [];
        n4.size = e6.size, e6.start !== void 0 && (n4.start = e6.start, n4.end = e6.end);
        for (let r3 = 0; r3 < e6.length; r3 += 3) n4.push(e6[r3] + t5, e6[r3 + 1], e6[r3 + 2]);
        return n4;
      }
      function pe2(e6, t5) {
        if (e6.transformed) return e6;
        let n4 = 1 << e6.z, r3 = e6.x, i3 = e6.y;
        for (let a3 of e6.features) {
          let e7 = a3.geometry, o3 = a3.type;
          if (a3.geometry = [], o3 === 1) for (let o4 = 0; o4 < e7.length; o4 += 2) a3.geometry.push(I2(e7[o4], e7[o4 + 1], t5, n4, r3, i3));
          else for (let o4 = 0; o4 < e7.length; o4++) {
            let s3 = [];
            for (let a4 = 0; a4 < e7[o4].length; a4 += 2) s3.push(I2(e7[o4][a4], e7[o4][a4 + 1], t5, n4, r3, i3));
            a3.geometry.push(s3);
          }
        }
        return e6.transformed = true, e6;
      }
      function I2(e6, t5, n4, r3, i3, a3) {
        return [Math.round(n4 * (e6 * r3 - i3)), Math.round(n4 * (t5 * r3 - a3))];
      }
      function me2(e6, t5, n4, r3, i3) {
        let a3 = t5 === i3.maxZoom ? 0 : i3.tolerance / ((1 << t5) * i3.extent), o3 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: e6.length, source: null, x: n4, y: r3, z: t5, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 };
        for (let t6 of e6) he2(o3, t6, a3, i3);
        return o3;
      }
      function he2(e6, t5, n4, r3) {
        let i3 = t5.geometry, a3 = t5.type, o3 = [];
        if (e6.minX = Math.min(e6.minX, t5.minX), e6.minY = Math.min(e6.minY, t5.minY), e6.maxX = Math.max(e6.maxX, t5.maxX), e6.maxY = Math.max(e6.maxY, t5.maxY), a3 === `Point` || a3 === `MultiPoint`) for (let t6 = 0; t6 < i3.length; t6 += 3) o3.push(i3[t6], i3[t6 + 1]), e6.numPoints++, e6.numSimplified++;
        else if (a3 === `LineString`) ge2(o3, i3, e6, n4, false, false);
        else if (a3 === `MultiLineString` || a3 === `Polygon`) for (let t6 = 0; t6 < i3.length; t6++) ge2(o3, i3[t6], e6, n4, a3 === `Polygon`, t6 === 0);
        else if (a3 === `MultiPolygon`) for (let t6 = 0; t6 < i3.length; t6++) {
          let r4 = i3[t6];
          for (let t7 = 0; t7 < r4.length; t7++) ge2(o3, r4[t7], e6, n4, true, t7 === 0);
        }
        if (o3.length) {
          let n5 = t5.tags || null;
          if (a3 === `LineString` && r3.lineMetrics) {
            for (let e7 in n5 = {}, t5.tags) n5[e7] = t5.tags[e7];
            n5.mapbox_clip_start = i3.start / i3.size, n5.mapbox_clip_end = i3.end / i3.size;
          }
          let s3 = { geometry: o3, type: a3 === `Polygon` || a3 === `MultiPolygon` ? 3 : a3 === `LineString` || a3 === `MultiLineString` ? 2 : 1, tags: n5 };
          t5.id !== null && (s3.id = t5.id), e6.features.push(s3);
        }
      }
      function ge2(e6, t5, n4, r3, i3, a3) {
        let o3 = r3 * r3;
        if (r3 > 0 && t5.size < (i3 ? o3 : r3)) return void (n4.numPoints += t5.length / 3);
        let s3 = [];
        for (let e7 = 0; e7 < t5.length; e7 += 3) (r3 === 0 || t5[e7 + 2] > o3) && (n4.numSimplified++, s3.push(t5[e7], t5[e7 + 1])), n4.numPoints++;
        i3 && (function(e7, t6) {
          let n5 = 0;
          for (let t7 = 0, r4 = e7.length, i4 = r4 - 2; t7 < r4; i4 = t7, t7 += 2) n5 += (e7[t7] - e7[i4]) * (e7[t7 + 1] + e7[i4 + 1]);
          if (n5 > 0 === t6) for (let t7 = 0, n6 = e7.length; t7 < n6 / 2; t7 += 2) {
            let r4 = e7[t7], i4 = e7[t7 + 1];
            e7[t7] = e7[n6 - 2 - t7], e7[t7 + 1] = e7[n6 - 1 - t7], e7[n6 - 2 - t7] = r4, e7[n6 - 1 - t7] = i4;
          }
        })(s3, a3), e6.push(s3);
      }
      let _e2 = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 };
      class ve2 {
        constructor(e6, t5) {
          let n4 = (t5 = this.options = (function(e7, t6) {
            for (let n5 in t6) e7[n5] = t6[n5];
            return e7;
          })(Object.create(_e2), t5)).debug;
          if (n4 && console.time(`preprocess data`), t5.maxZoom < 0 || t5.maxZoom > 24) throw Error(`maxZoom should be in the 0-24 range`);
          if (t5.promoteId && t5.generateId) throw Error(`promoteId and generateId cannot be used together.`);
          let r3 = (function(e7, t6) {
            let n5 = [];
            if (e7.type === `FeatureCollection`) for (let r4 = 0; r4 < e7.features.length; r4++) M2(n5, e7.features[r4], t6, r4);
            else M2(n5, e7.type === `Feature` ? e7 : { geometry: e7 }, t6);
            return n5;
          })(e6, t5);
          this.tiles = {}, this.tileCoords = [], n4 && (console.timeEnd(`preprocess data`), console.log(`index: maxZoom: %d, maxPoints: %d`, t5.indexMaxZoom, t5.indexMaxPoints), console.time(`generate tiles`), this.stats = {}, this.total = 0), r3 = (function(e7, t6) {
            let n5 = t6.buffer / t6.extent, r4 = e7, i3 = ie2(e7, 1, -1 - n5, n5, 0, -1, 2, t6), a3 = ie2(e7, 1, 1 - n5, 2 + n5, 0, -1, 2, t6);
            return (i3 || a3) && (r4 = ie2(e7, 1, -n5, 1 + n5, 0, -1, 2, t6) || [], i3 && (r4 = de2(i3, 1).concat(r4)), a3 && (r4 = r4.concat(de2(a3, -1)))), r4;
          })(r3, t5), r3.length && this.splitTile(r3, 0, 0, 0), n4 && (r3.length && console.log(`features: %d, points: %d`, this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd(`generate tiles`), console.log(`tiles generated:`, this.total, JSON.stringify(this.stats)));
        }
        splitTile(e6, t5, n4, r3, i3, a3, o3) {
          let s3 = [e6, t5, n4, r3], c3 = this.options, l3 = c3.debug;
          for (; s3.length; ) {
            r3 = s3.pop(), n4 = s3.pop(), t5 = s3.pop(), e6 = s3.pop();
            let u3 = 1 << t5, d3 = L2(t5, n4, r3), f3 = this.tiles[d3];
            if (!f3 && (l3 > 1 && console.time(`creation`), f3 = this.tiles[d3] = me2(e6, t5, n4, r3, c3), this.tileCoords.push({ z: t5, x: n4, y: r3 }), l3)) {
              l3 > 1 && (console.log(`tile z%d-%d-%d (features: %d, points: %d, simplified: %d)`, t5, n4, r3, f3.numFeatures, f3.numPoints, f3.numSimplified), console.timeEnd(`creation`));
              let e7 = `z${t5}`;
              this.stats[e7] = (this.stats[e7] || 0) + 1, this.total++;
            }
            if (f3.source = e6, i3 == null) {
              if (t5 === c3.indexMaxZoom || f3.numPoints <= c3.indexMaxPoints) continue;
            } else {
              if (t5 === c3.maxZoom || t5 === i3) continue;
              if (i3 != null) {
                let e7 = i3 - t5;
                if (n4 !== a3 >> e7 || r3 !== o3 >> e7) continue;
              }
            }
            if (f3.source = null, e6.length === 0) continue;
            l3 > 1 && console.time(`clipping`);
            let p3 = 0.5 * c3.buffer / c3.extent, m3 = 0.5 - p3, h3 = 0.5 + p3, g3 = 1 + p3, _3 = null, v3 = null, y3 = null, b3 = null, x3 = ie2(e6, u3, n4 - p3, n4 + h3, 0, f3.minX, f3.maxX, c3), S3 = ie2(e6, u3, n4 + m3, n4 + g3, 0, f3.minX, f3.maxX, c3);
            e6 = null, x3 && (x3 = (_3 = ie2(x3, u3, r3 - p3, r3 + h3, 1, f3.minY, f3.maxY, c3), v3 = ie2(x3, u3, r3 + m3, r3 + g3, 1, f3.minY, f3.maxY, c3), null)), S3 && (S3 = (y3 = ie2(S3, u3, r3 - p3, r3 + h3, 1, f3.minY, f3.maxY, c3), b3 = ie2(S3, u3, r3 + m3, r3 + g3, 1, f3.minY, f3.maxY, c3), null)), l3 > 1 && console.timeEnd(`clipping`), s3.push(_3 || [], t5 + 1, 2 * n4, 2 * r3), s3.push(v3 || [], t5 + 1, 2 * n4, 2 * r3 + 1), s3.push(y3 || [], t5 + 1, 2 * n4 + 1, 2 * r3), s3.push(b3 || [], t5 + 1, 2 * n4 + 1, 2 * r3 + 1);
          }
        }
        getTile(e6, t5, n4) {
          e6 = +e6, t5 = +t5, n4 = +n4;
          let { extent: r3, debug: i3 } = this.options;
          if (e6 < 0 || e6 > 24) return null;
          let a3 = 1 << e6, o3 = L2(e6, t5 = t5 + a3 & a3 - 1, n4);
          if (this.tiles[o3]) return pe2(this.tiles[o3], r3);
          i3 > 1 && console.log(`drilling down to z%d-%d-%d`, e6, t5, n4);
          let s3, c3 = e6, l3 = t5, u3 = n4;
          for (; !s3 && c3 > 0; ) c3--, l3 >>= 1, u3 >>= 1, s3 = this.tiles[L2(c3, l3, u3)];
          return s3 && s3.source ? (i3 > 1 && (console.log(`found parent tile z%d-%d-%d`, c3, l3, u3), console.time(`drilling down`)), this.splitTile(s3.source, c3, l3, u3, e6, t5, n4), i3 > 1 && console.timeEnd(`drilling down`), this.tiles[o3] ? pe2(this.tiles[o3], r3) : null) : null;
        }
      }
      function L2(e6, t5, n4) {
        return 32 * ((1 << e6) * n4 + t5) + e6;
      }
      class ye2 extends a2 {
        constructor(e6, t5, n4, r3 = be2) {
          super(e6, t5, n4), this._dataUpdateable = /* @__PURE__ */ new Map(), this._createGeoJSONIndex = r3;
        }
        loadVectorTile(t5, n4) {
          return e5._(this, void 0, void 0, (function* () {
            let n5 = t5.tileID.canonical;
            if (!this._geoJSONIndex) throw Error(`Unable to parse the data into a cluster or geojson`);
            let r3 = this._geoJSONIndex.getTile(n5.z, n5.x, n5.y);
            if (!r3) return null;
            let i3 = new f2(r3.features, { version: 2, extent: e5.a3 }), a3 = (function(t6) {
              let n6 = new e5.cP();
              return (function(e6, t7) {
                for (let n7 in e6.layers) t7.writeMessage(3, p2, e6.layers[n7]);
              })(t6, n6), n6.finish();
            })(i3);
            return a3.byteOffset === 0 && a3.byteLength === a3.buffer.byteLength || (a3 = new Uint8Array(a3)), { vectorTile: i3, rawData: a3.buffer };
          }));
        }
        loadData(t5) {
          return e5._(this, void 0, void 0, (function* () {
            var n4;
            (n4 = this._pendingRequest) == null || n4.abort();
            let r3 = !!(t5 && t5.request && t5.request.collectResourceTiming) && new e5.cQ(t5.request);
            this._pendingRequest = new AbortController();
            try {
              (!this._pendingData || t5.request || t5.data || t5.dataDiff) && (this._pendingData = this.loadAndProcessGeoJSON(t5, this._pendingRequest));
              let e6 = yield this._pendingData;
              this._geoJSONIndex = this._createGeoJSONIndex(e6, t5), this.loaded = {};
              let n5 = { data: e6 };
              if (r3) {
                let e7 = r3.finish();
                e7 && (n5.resourceTiming = {}, n5.resourceTiming[t5.source] = JSON.parse(JSON.stringify(e7)));
              }
              return n5;
            } catch (t6) {
              if (delete this._pendingRequest, e5.cB(t6)) return { abandoned: true };
              throw t6;
            }
          }));
        }
        getData() {
          return e5._(this, void 0, void 0, (function* () {
            return this._pendingData;
          }));
        }
        reloadTile(e6) {
          let t5 = this.loaded;
          return t5 && t5[e6.uid] ? super.reloadTile(e6) : this.loadTile(e6);
        }
        loadAndProcessGeoJSON(t5, n4) {
          return e5._(this, void 0, void 0, (function* () {
            let r3 = yield this.loadGeoJSON(t5, n4);
            if (delete this._pendingRequest, typeof r3 != `object`) throw Error(`Input data given to '${t5.source}' is not a valid GeoJSON object.`);
            if (u2(r3, true), t5.filter) {
              let n5 = e5.cW(t5.filter, { type: `boolean`, "property-type": `data-driven`, overridable: false, transition: false });
              if (n5.result === `error`) throw Error(n5.value.map(((e6) => `${e6.key}: ${e6.message}`)).join(`, `));
              r3 = { type: `FeatureCollection`, features: r3.features.filter(((e6) => n5.value.evaluate({ zoom: 0 }, e6))) };
            }
            return r3;
          }));
        }
        loadGeoJSON(t5, n4) {
          return e5._(this, void 0, void 0, (function* () {
            let { promoteId: r3 } = t5;
            if (t5.request) {
              let i3 = yield e5.j(t5.request, n4);
              return this._dataUpdateable = e5.cY(i3.data, r3) ? e5.cX(i3.data, r3) : void 0, i3.data;
            }
            if (typeof t5.data == `string`) try {
              let n5 = JSON.parse(t5.data);
              return this._dataUpdateable = e5.cY(n5, r3) ? e5.cX(n5, r3) : void 0, n5;
            } catch {
              throw Error(`Input data given to '${t5.source}' is not a valid GeoJSON object.`);
            }
            if (!t5.dataDiff) throw Error(`Input data given to '${t5.source}' is not a valid GeoJSON object.`);
            if (!this._dataUpdateable) throw Error(`Cannot update existing geojson data in ${t5.source}`);
            return e5.cZ(this._dataUpdateable, t5.dataDiff, r3), { type: `FeatureCollection`, features: Array.from(this._dataUpdateable.values()) };
          }));
        }
        removeSource(t5) {
          return e5._(this, void 0, void 0, (function* () {
            this._pendingRequest && this._pendingRequest.abort();
          }));
        }
        getClusterExpansionZoom(e6) {
          return this._geoJSONIndex.getClusterExpansionZoom(e6.clusterId);
        }
        getClusterChildren(e6) {
          return this._geoJSONIndex.getChildren(e6.clusterId);
        }
        getClusterLeaves(e6) {
          return this._geoJSONIndex.getLeaves(e6.clusterId, e6.limit, e6.offset);
        }
      }
      function be2(t5, n4) {
        return n4.cluster ? new C2((function({ superclusterOptions: t6, clusterProperties: n5 }) {
          if (!n5 || !t6) return t6;
          let r3 = {}, i3 = {}, a3 = { accumulated: null, zoom: 0 }, o3 = { properties: null }, s3 = Object.keys(n5);
          for (let t7 of s3) {
            let [a4, o4] = n5[t7], s4 = e5.cW(o4), c3 = e5.cW(typeof a4 == `string` ? [a4, [`accumulated`], [`get`, t7]] : a4);
            r3[t7] = s4.value, i3[t7] = c3.value;
          }
          return t6.map = (e6) => {
            o3.properties = e6;
            let t7 = {};
            for (let e7 of s3) t7[e7] = r3[e7].evaluate(a3, o3);
            return t7;
          }, t6.reduce = (e6, t7) => {
            o3.properties = t7;
            for (let t8 of s3) a3.accumulated = e6[t8], e6[t8] = i3[t8].evaluate(a3, o3);
          }, t6;
        })(n4)).load(t5.features) : (function(e6, t6) {
          return new ve2(e6, t6);
        })(t5, n4.geojsonVtOptions);
      }
      class xe2 {
        constructor(t5) {
          this.self = t5, this.actor = new e5.K(t5), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = /* @__PURE__ */ new Map(), this.self.registerWorkerSource = (e6, t6) => {
            if (this.externalWorkerSourceTypes[e6]) throw Error(`Worker source with name "${e6}" already registered.`);
            this.externalWorkerSourceTypes[e6] = t6;
          }, this.self.addProtocol = e5.cD, this.self.removeProtocol = e5.cE, this.self.registerRTLTextPlugin = (t6) => {
            e5.c_.setMethods(t6);
          }, this.actor.registerMessageHandler(`LDT`, ((e6, t6) => this._getDEMWorkerSource(e6, t6.source).loadTile(t6))), this.actor.registerMessageHandler(`RDT`, ((t6, n4) => e5._(this, void 0, void 0, (function* () {
            this._getDEMWorkerSource(t6, n4.source).removeTile(n4);
          })))), this.actor.registerMessageHandler(`GCEZ`, ((t6, n4) => e5._(this, void 0, void 0, (function* () {
            return this._getWorkerSource(t6, n4.type, n4.source).getClusterExpansionZoom(n4);
          })))), this.actor.registerMessageHandler(`GCC`, ((t6, n4) => e5._(this, void 0, void 0, (function* () {
            return this._getWorkerSource(t6, n4.type, n4.source).getClusterChildren(n4);
          })))), this.actor.registerMessageHandler(`GCL`, ((t6, n4) => e5._(this, void 0, void 0, (function* () {
            return this._getWorkerSource(t6, n4.type, n4.source).getClusterLeaves(n4);
          })))), this.actor.registerMessageHandler(`LD`, ((e6, t6) => this._getWorkerSource(e6, t6.type, t6.source).loadData(t6))), this.actor.registerMessageHandler(`GD`, ((e6, t6) => this._getWorkerSource(e6, t6.type, t6.source).getData())), this.actor.registerMessageHandler(`LT`, ((e6, t6) => this._getWorkerSource(e6, t6.type, t6.source).loadTile(t6))), this.actor.registerMessageHandler(`RT`, ((e6, t6) => this._getWorkerSource(e6, t6.type, t6.source).reloadTile(t6))), this.actor.registerMessageHandler(`AT`, ((e6, t6) => this._getWorkerSource(e6, t6.type, t6.source).abortTile(t6))), this.actor.registerMessageHandler(`RMT`, ((e6, t6) => this._getWorkerSource(e6, t6.type, t6.source).removeTile(t6))), this.actor.registerMessageHandler(`RS`, ((t6, n4) => e5._(this, void 0, void 0, (function* () {
            if (!this.workerSources[t6] || !this.workerSources[t6][n4.type] || !this.workerSources[t6][n4.type][n4.source]) return;
            let e6 = this.workerSources[t6][n4.type][n4.source];
            delete this.workerSources[t6][n4.type][n4.source], e6.removeSource !== void 0 && e6.removeSource(n4);
          })))), this.actor.registerMessageHandler(`RM`, ((t6) => e5._(this, void 0, void 0, (function* () {
            delete this.layerIndexes[t6], delete this.availableImages[t6], delete this.workerSources[t6], delete this.demWorkerSources[t6], this.globalStates.delete(t6);
          })))), this.actor.registerMessageHandler(`SR`, ((t6, n4) => e5._(this, void 0, void 0, (function* () {
            this.referrer = n4;
          })))), this.actor.registerMessageHandler(`SRPS`, ((e6, t6) => this._syncRTLPluginState(e6, t6))), this.actor.registerMessageHandler(`IS`, ((t6, n4) => e5._(this, void 0, void 0, (function* () {
            this.self.importScripts(n4);
          })))), this.actor.registerMessageHandler(`SI`, ((e6, t6) => this._setImages(e6, t6))), this.actor.registerMessageHandler(`UL`, ((t6, n4) => e5._(this, void 0, void 0, (function* () {
            this._getLayerIndex(t6).update(n4.layers, n4.removedIds, this._getGlobalState(t6));
          })))), this.actor.registerMessageHandler(`UGS`, ((t6, n4) => e5._(this, void 0, void 0, (function* () {
            let e6 = this._getGlobalState(t6);
            for (let t7 in n4) e6[t7] = n4[t7];
          })))), this.actor.registerMessageHandler(`SL`, ((t6, n4) => e5._(this, void 0, void 0, (function* () {
            this._getLayerIndex(t6).replace(n4, this._getGlobalState(t6));
          }))));
        }
        _getGlobalState(e6) {
          let t5 = this.globalStates.get(e6);
          return t5 || (t5 = {}, this.globalStates.set(e6, t5)), t5;
        }
        _setImages(t5, n4) {
          return e5._(this, void 0, void 0, (function* () {
            for (let e6 in this.availableImages[t5] = n4, this.workerSources[t5]) {
              let r3 = this.workerSources[t5][e6];
              for (let e7 in r3) r3[e7].availableImages = n4;
            }
          }));
        }
        _syncRTLPluginState(t5, n4) {
          return e5._(this, void 0, void 0, (function* () {
            return yield e5.c_.syncState(n4, this.self.importScripts);
          }));
        }
        _getAvailableImages(e6) {
          let t5 = this.availableImages[e6];
          return t5 || (t5 = []), t5;
        }
        _getLayerIndex(e6) {
          let n4 = this.layerIndexes[e6];
          return n4 || (n4 = this.layerIndexes[e6] = new t4()), n4;
        }
        _getWorkerSource(e6, t5, n4) {
          if (this.workerSources[e6] || (this.workerSources[e6] = {}), this.workerSources[e6][t5] || (this.workerSources[e6][t5] = {}), !this.workerSources[e6][t5][n4]) {
            let r3 = { sendAsync: (t6, n5) => (t6.targetMapId = e6, this.actor.sendAsync(t6, n5)) };
            switch (t5) {
              case `vector`:
                this.workerSources[e6][t5][n4] = new a2(r3, this._getLayerIndex(e6), this._getAvailableImages(e6));
                break;
              case `geojson`:
                this.workerSources[e6][t5][n4] = new ye2(r3, this._getLayerIndex(e6), this._getAvailableImages(e6));
                break;
              default:
                this.workerSources[e6][t5][n4] = new this.externalWorkerSourceTypes[t5](r3, this._getLayerIndex(e6), this._getAvailableImages(e6));
            }
          }
          return this.workerSources[e6][t5][n4];
        }
        _getDEMWorkerSource(e6, t5) {
          return this.demWorkerSources[e6] || (this.demWorkerSources[e6] = {}), this.demWorkerSources[e6][t5] || (this.demWorkerSources[e6][t5] = new o2()), this.demWorkerSources[e6][t5];
        }
      }
      return e5.i(self) && (self.worker = new xe2(self)), xe2;
    })), n2(`index`, [`exports`, `./shared`], (function(e5, t4) {
      var n3 = `5.11.0`;
      function r2() {
        var e6 = new t4.A(4);
        return t4.A != Float32Array && (e6[1] = 0, e6[2] = 0), e6[0] = 1, e6[3] = 1, e6;
      }
      let i2, a2, o2 = { frame(e6, n4, r3) {
        let i3 = requestAnimationFrame(((e7) => {
          a3(), n4(e7);
        })), { unsubscribe: a3 } = t4.s(e6.signal, `abort`, (() => {
          a3(), cancelAnimationFrame(i3), r3(t4.c());
        }), false);
      }, frameAsync(e6) {
        return new Promise(((t5, n4) => {
          this.frame(e6, t5, n4);
        }));
      }, getImageData(e6, t5 = 0) {
        return this.getImageCanvasContext(e6).getImageData(-t5, -t5, e6.width + 2 * t5, e6.height + 2 * t5);
      }, getImageCanvasContext(e6) {
        let t5 = window.document.createElement(`canvas`), n4 = t5.getContext(`2d`, { willReadFrequently: true });
        if (!n4) throw Error(`failed to create canvas 2d context`);
        return t5.width = e6.width, t5.height = e6.height, n4.drawImage(e6, 0, 0, e6.width, e6.height), n4;
      }, resolveURL: (e6) => (i2 || (i2 = document.createElement(`a`)), i2.href = e6, i2.href), hardwareConcurrency: typeof navigator < `u` && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
        return !!matchMedia && (a2 ?? (a2 = matchMedia(`(prefers-reduced-motion: reduce)`)), a2.matches);
      } }, s2 = new class {
        constructor() {
          this._realTime = typeof performance < `u` && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), this._frozenAt = null;
        }
        getCurrentTime() {
          return this._frozenAt === null ? this._realTime() : this._frozenAt;
        }
        setNow(e6) {
          this._frozenAt = e6;
        }
        restoreNow() {
          this._frozenAt = null;
        }
        isFrozen() {
          return this._frozenAt !== null;
        }
      }();
      function c2() {
        return s2.getCurrentTime();
      }
      class l2 {
        static testProp(e6) {
          if (!l2.docStyle) return e6[0];
          for (let t5 = 0; t5 < e6.length; t5++) if (e6[t5] in l2.docStyle) return e6[t5];
          return e6[0];
        }
        static create(e6, t5, n4) {
          let r3 = window.document.createElement(e6);
          return t5 !== void 0 && (r3.className = t5), n4 && n4.appendChild(r3), r3;
        }
        static createNS(e6, t5) {
          return window.document.createElementNS(e6, t5);
        }
        static disableDrag() {
          l2.docStyle && l2.selectProp && (l2.userSelect = l2.docStyle[l2.selectProp], l2.docStyle[l2.selectProp] = `none`);
        }
        static enableDrag() {
          l2.docStyle && l2.selectProp && (l2.docStyle[l2.selectProp] = l2.userSelect);
        }
        static setTransform(e6, t5) {
          e6.style[l2.transformProp] = t5;
        }
        static addEventListener(e6, t5, n4, r3 = {}) {
          e6.addEventListener(t5, n4, `passive` in r3 ? r3 : r3.capture);
        }
        static removeEventListener(e6, t5, n4, r3 = {}) {
          e6.removeEventListener(t5, n4, `passive` in r3 ? r3 : r3.capture);
        }
        static suppressClickInternal(e6) {
          e6.preventDefault(), e6.stopPropagation(), window.removeEventListener(`click`, l2.suppressClickInternal, true);
        }
        static suppressClick() {
          window.addEventListener(`click`, l2.suppressClickInternal, true), window.setTimeout((() => {
            window.removeEventListener(`click`, l2.suppressClickInternal, true);
          }), 0);
        }
        static getScale(e6) {
          let t5 = e6.getBoundingClientRect();
          return { x: t5.width / e6.offsetWidth || 1, y: t5.height / e6.offsetHeight || 1, boundingClientRect: t5 };
        }
        static getPoint(e6, n4, r3) {
          let i3 = n4.boundingClientRect;
          return new t4.P((r3.clientX - i3.left) / n4.x - e6.clientLeft, (r3.clientY - i3.top) / n4.y - e6.clientTop);
        }
        static mousePos(e6, t5) {
          let n4 = l2.getScale(e6);
          return l2.getPoint(e6, n4, t5);
        }
        static touchPos(e6, t5) {
          let n4 = [], r3 = l2.getScale(e6);
          for (let i3 = 0; i3 < t5.length; i3++) n4.push(l2.getPoint(e6, r3, t5[i3]));
          return n4;
        }
        static mouseButton(e6) {
          return e6.button;
        }
        static remove(e6) {
          e6.parentNode && e6.parentNode.removeChild(e6);
        }
        static sanitize(e6) {
          let t5 = new DOMParser().parseFromString(e6, `text/html`).body || document.createElement(`body`), n4 = t5.querySelectorAll(`script`);
          for (let e7 of n4) e7.remove();
          return l2.clean(t5), t5.innerHTML;
        }
        static isPossiblyDangerous(e6, t5) {
          let n4 = t5.replace(/\s+/g, ``).toLowerCase();
          return !(![`src`, `href`, `xlink:href`].includes(e6) || !n4.includes(`javascript:`) && !n4.includes(`data:`)) || !!e6.startsWith(`on`) || void 0;
        }
        static clean(e6) {
          let t5 = e6.children;
          for (let e7 of t5) l2.removeAttributes(e7), l2.clean(e7);
        }
        static removeAttributes(e6) {
          for (let { name: t5, value: n4 } of e6.attributes) l2.isPossiblyDangerous(t5, n4) && e6.removeAttribute(t5);
        }
      }
      l2.docStyle = typeof window < `u` && window.document && window.document.documentElement.style, l2.selectProp = l2.testProp([`userSelect`, `MozUserSelect`, `WebkitUserSelect`, `msUserSelect`]), l2.transformProp = l2.testProp([`transform`, `WebkitTransform`]);
      let u2 = { supported: false, testSupport: function(e6) {
        !p2 && f2 && (m2 ? h2(e6) : d2 = e6);
      } }, d2, f2, p2 = false, m2 = false;
      function h2(e6) {
        let t5 = e6.createTexture();
        e6.bindTexture(e6.TEXTURE_2D, t5);
        try {
          if (e6.texImage2D(e6.TEXTURE_2D, 0, e6.RGBA, e6.RGBA, e6.UNSIGNED_BYTE, f2), e6.isContextLost()) return;
          u2.supported = true;
        } catch {
        }
        e6.deleteTexture(t5), p2 = true;
      }
      var g2;
      typeof document < `u` && (f2 = document.createElement(`img`), f2.onload = () => {
        d2 && h2(d2), d2 = null, m2 = true;
      }, f2.onerror = () => {
        p2 = true, d2 = null;
      }, f2.src = `data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=`), (function(e6) {
        let n4, r3, i3, a3;
        e6.resetRequestQueue = () => {
          n4 = [], r3 = 0, i3 = 0, a3 = {};
        }, e6.addThrottleControl = (e7) => {
          let t5 = i3++;
          return a3[t5] = e7, t5;
        }, e6.removeThrottleControl = (e7) => {
          delete a3[e7], s3();
        }, e6.getImage = (e7, r4, i4 = true) => new Promise(((a4, o4) => {
          u2.supported && (e7.headers || (e7.headers = {}), e7.headers.accept = `image/webp,*/*`), t4.e(e7, { type: `image` }), n4.push({ abortController: r4, requestParameters: e7, supportImageRefresh: i4, state: `queued`, onError: (e8) => {
            o4(e8);
          }, onSuccess: (e8) => {
            a4(e8);
          } }), s3();
        }));
        let o3 = (e7) => t4._(this, void 0, void 0, (function* () {
          e7.state = `running`;
          let { requestParameters: n5, supportImageRefresh: i4, onError: a4, onSuccess: o4, abortController: l3 } = e7, u3 = false === i4 && !t4.i(self) && !t4.g(n5.url) && (!n5.headers || Object.keys(n5.headers).reduce(((e8, t5) => e8 && t5 === `accept`), true));
          r3++;
          let d3 = u3 ? c3(n5, l3) : t4.m(n5, l3);
          try {
            let n6 = yield d3;
            delete e7.abortController, e7.state = `completed`, n6.data instanceof HTMLImageElement || t4.b(n6.data) ? o4(n6) : n6.data && o4({ data: yield (f3 = n6.data, typeof createImageBitmap == `function` ? t4.f(f3) : t4.h(f3)), cacheControl: n6.cacheControl, expires: n6.expires });
          } catch (t5) {
            delete e7.abortController, a4(t5);
          } finally {
            r3--, s3();
          }
          var f3;
        })), s3 = () => {
          let e7 = (() => {
            for (let e8 of Object.keys(a3)) if (a3[e8]()) return true;
            return false;
          })() ? t4.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : t4.a.MAX_PARALLEL_IMAGE_REQUESTS;
          for (let t5 = r3; t5 < e7 && n4.length > 0; t5++) {
            let e8 = n4.shift();
            e8.abortController.signal.aborted ? t5-- : o3(e8);
          }
        }, c3 = (e7, n5) => new Promise(((r4, i4) => {
          let a4 = new Image(), o4 = e7.url, s4 = e7.credentials;
          s4 && s4 === `include` ? a4.crossOrigin = `use-credentials` : (s4 && s4 === `same-origin` || !t4.d(o4)) && (a4.crossOrigin = `anonymous`), n5.signal.addEventListener(`abort`, (() => {
            a4.src = ``, i4(t4.c());
          })), a4.fetchPriority = `high`, a4.onload = () => {
            a4.onerror = a4.onload = null, r4({ data: a4 });
          }, a4.onerror = () => {
            a4.onerror = a4.onload = null, n5.signal.aborted || i4(Error(`Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
          }, a4.src = o4;
        }));
      })(g2 || (g2 = {})), g2.resetRequestQueue();
      class _2 {
        constructor(e6) {
          this._transformRequestFn = e6 ?? null;
        }
        transformRequest(e6, t5) {
          return this._transformRequestFn && this._transformRequestFn(e6, t5) || { url: e6 };
        }
        setTransformRequest(e6) {
          this._transformRequestFn = e6;
        }
      }
      function v2(e6) {
        let t5 = [];
        if (typeof e6 == `string`) t5.push({ id: `default`, url: e6 });
        else if (e6 && e6.length > 0) {
          let n4 = [];
          for (let { id: r3, url: i3 } of e6) {
            let e7 = `${r3}${i3}`;
            n4.indexOf(e7) === -1 && (n4.push(e7), t5.push({ id: r3, url: i3 }));
          }
        }
        return t5;
      }
      function y2(e6, t5, n4) {
        try {
          let r3 = new URL(e6);
          return r3.pathname += `${t5}${n4}`, r3.toString();
        } catch {
          throw Error(`Invalid sprite URL "${e6}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
        }
      }
      function b2(e6) {
        let { userImage: t5 } = e6;
        return !!(t5 && t5.render && t5.render()) && (e6.data.replace(new Uint8Array(t5.data.buffer)), true);
      }
      class x2 extends t4.E {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new t4.R({ width: 1, height: 1 }), this.dirty = true;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(e6) {
          if (this.loaded !== e6 && (this.loaded = e6, e6)) {
            for (let { ids: e7, promiseResolve: t5 } of this.requestors) t5(this._getImagesForIds(e7));
            this.requestors = [];
          }
        }
        getImage(e6) {
          let n4 = this.images[e6];
          if (n4 && !n4.data && n4.spriteData) {
            let e7 = n4.spriteData;
            n4.data = new t4.R({ width: e7.width, height: e7.height }, e7.context.getImageData(e7.x, e7.y, e7.width, e7.height).data), n4.spriteData = null;
          }
          return n4;
        }
        addImage(e6, t5) {
          if (this.images[e6]) throw Error(`Image id ${e6} already exist, use updateImage instead`);
          this._validate(e6, t5) && (this.images[e6] = t5);
        }
        _validate(e6, n4) {
          let r3 = true, i3 = n4.data || n4.spriteData;
          return this._validateStretch(n4.stretchX, i3 && i3.width) || (this.fire(new t4.k(Error(`Image "${e6}" has invalid "stretchX" value`))), r3 = false), this._validateStretch(n4.stretchY, i3 && i3.height) || (this.fire(new t4.k(Error(`Image "${e6}" has invalid "stretchY" value`))), r3 = false), this._validateContent(n4.content, n4) || (this.fire(new t4.k(Error(`Image "${e6}" has invalid "content" value`))), r3 = false), r3;
        }
        _validateStretch(e6, t5) {
          if (!e6) return true;
          let n4 = 0;
          for (let r3 of e6) {
            if (r3[0] < n4 || r3[1] < r3[0] || t5 < r3[1]) return false;
            n4 = r3[1];
          }
          return true;
        }
        _validateContent(e6, t5) {
          if (!e6) return true;
          if (e6.length !== 4) return false;
          let n4 = t5.spriteData, r3 = n4 && n4.width || t5.data.width, i3 = n4 && n4.height || t5.data.height;
          return !(e6[0] < 0 || r3 < e6[0] || e6[1] < 0 || i3 < e6[1] || e6[2] < 0 || r3 < e6[2] || e6[3] < 0 || i3 < e6[3] || e6[2] < e6[0] || e6[3] < e6[1]);
        }
        updateImage(e6, t5, n4 = true) {
          let r3 = this.getImage(e6);
          if (n4 && (r3.data.width !== t5.data.width || r3.data.height !== t5.data.height)) throw Error(`size mismatch between old image (${r3.data.width}x${r3.data.height}) and new image (${t5.data.width}x${t5.data.height}).`);
          t5.version = r3.version + 1, this.images[e6] = t5, this.updatedImages[e6] = true;
        }
        removeImage(e6) {
          let t5 = this.images[e6];
          delete this.images[e6], delete this.patterns[e6], t5.userImage && t5.userImage.onRemove && t5.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(e6) {
          return new Promise(((t5, n4) => {
            let r3 = true;
            if (!this.isLoaded()) for (let t6 of e6) this.images[t6] || (r3 = false);
            this.isLoaded() || r3 ? t5(this._getImagesForIds(e6)) : this.requestors.push({ ids: e6, promiseResolve: t5 });
          }));
        }
        _getImagesForIds(e6) {
          let n4 = {};
          for (let r3 of e6) {
            let e7 = this.getImage(r3);
            e7 || (e7 = (this.fire(new t4.l(`styleimagemissing`, { id: r3 })), this.getImage(r3))), e7 ? n4[r3] = { data: e7.data.clone(), pixelRatio: e7.pixelRatio, sdf: e7.sdf, version: e7.version, stretchX: e7.stretchX, stretchY: e7.stretchY, content: e7.content, textFitWidth: e7.textFitWidth, textFitHeight: e7.textFitHeight, hasRenderCallback: !!(e7.userImage && e7.userImage.render) } : t4.w(`Image "${r3}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          return n4;
        }
        getPixelSize() {
          let { width: e6, height: t5 } = this.atlasImage;
          return { width: e6, height: t5 };
        }
        getPattern(e6) {
          let n4 = this.patterns[e6], r3 = this.getImage(e6);
          if (!r3) return null;
          if (n4 && n4.position.version === r3.version) return n4.position;
          if (n4) n4.position.version = r3.version;
          else {
            let n5 = { w: r3.data.width + 2, h: r3.data.height + 2, x: 0, y: 0 }, i3 = new t4.I(n5, r3);
            this.patterns[e6] = { bin: n5, position: i3 };
          }
          return this._updatePatternAtlas(), this.patterns[e6].position;
        }
        bind(e6) {
          let n4 = e6.gl;
          this.atlasTexture ? this.dirty && (this.dirty = (this.atlasTexture.update(this.atlasImage), false)) : this.atlasTexture = new t4.T(e6, this.atlasImage, n4.RGBA), this.atlasTexture.bind(n4.LINEAR, n4.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          let e6 = [];
          for (let t5 in this.patterns) e6.push(this.patterns[t5].bin);
          let { w: n4, h: r3 } = t4.p(e6), i3 = this.atlasImage;
          for (let e7 in i3.resize({ width: n4 || 1, height: r3 || 1 }), this.patterns) {
            let { bin: n5 } = this.patterns[e7], r4 = n5.x + 1, a3 = n5.y + 1, o3 = this.getImage(e7).data, s3 = o3.width, c3 = o3.height;
            t4.R.copy(o3, i3, { x: 0, y: 0 }, { x: r4, y: a3 }, { width: s3, height: c3 }), t4.R.copy(o3, i3, { x: 0, y: c3 - 1 }, { x: r4, y: a3 - 1 }, { width: s3, height: 1 }), t4.R.copy(o3, i3, { x: 0, y: 0 }, { x: r4, y: a3 + c3 }, { width: s3, height: 1 }), t4.R.copy(o3, i3, { x: s3 - 1, y: 0 }, { x: r4 - 1, y: a3 }, { width: 1, height: c3 }), t4.R.copy(o3, i3, { x: 0, y: 0 }, { x: r4 + s3, y: a3 }, { width: 1, height: c3 });
          }
          this.dirty = true;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(e6) {
          for (let n4 of e6) {
            if (this.callbackDispatchedThisFrame[n4]) continue;
            this.callbackDispatchedThisFrame[n4] = true;
            let e7 = this.getImage(n4);
            e7 || t4.w(`Image with ID: "${n4}" was not found`), b2(e7) && this.updateImage(n4, e7);
          }
        }
      }
      let S2 = 1e20;
      function C2(e6, t5, n4, r3, i3, a3, o3, s3, c3) {
        for (let l3 = t5; l3 < t5 + r3; l3++) w2(e6, n4 * a3 + l3, a3, i3, o3, s3, c3);
        for (let l3 = n4; l3 < n4 + i3; l3++) w2(e6, l3 * a3 + t5, 1, r3, o3, s3, c3);
      }
      function w2(e6, t5, n4, r3, i3, a3, o3) {
        a3[0] = 0, o3[0] = -S2, o3[1] = S2, i3[0] = e6[t5];
        for (let s3 = 1, c3 = 0, l3 = 0; s3 < r3; s3++) {
          i3[s3] = e6[t5 + s3 * n4];
          let r4 = s3 * s3;
          do {
            let e7 = a3[c3];
            l3 = (i3[s3] - i3[e7] + r4 - e7 * e7) / (s3 - e7) / 2;
          } while (l3 <= o3[c3] && --c3 > -1);
          c3++, a3[c3] = s3, o3[c3] = l3, o3[c3 + 1] = S2;
        }
        for (let s3 = 0, c3 = 0; s3 < r3; s3++) {
          for (; o3[c3 + 1] < s3; ) c3++;
          let r4 = a3[c3], l3 = s3 - r4;
          e6[t5 + s3 * n4] = i3[r4] + l3 * l3;
        }
      }
      let T2 = t4.v.layout_symbol[`text-font`].default.join(`,`);
      class E2 {
        constructor(e6, t5, n4) {
          this.requestManager = e6, this.localIdeographFontFamily = t5, this.entries = {}, this.lang = n4;
        }
        setURL(e6) {
          this.url = e6;
        }
        getGlyphs(e6) {
          return t4._(this, void 0, void 0, (function* () {
            let t5 = [];
            for (let n5 in e6) for (let r4 of e6[n5]) t5.push(this._getAndCacheGlyphsPromise(n5, r4));
            let n4 = yield Promise.all(t5), r3 = {};
            for (let { stack: e7, id: t6, glyph: i3 } of n4) r3[e7] || (r3[e7] = {}), r3[e7][t6] = i3 && { id: i3.id, bitmap: i3.bitmap.clone(), metrics: i3.metrics };
            return r3;
          }));
        }
        _getAndCacheGlyphsPromise(e6, n4) {
          return t4._(this, void 0, void 0, (function* () {
            let t5 = this.entries[e6];
            t5 || (t5 = this.entries[e6] = { glyphs: {}, requests: {}, ranges: {} });
            let r3 = t5.glyphs[n4];
            return r3 === void 0 ? !this.url || this._charUsesLocalIdeographFontFamily(n4) ? (r3 = t5.glyphs[n4] = this._drawGlyph(t5, e6, n4), { stack: e6, id: n4, glyph: r3 }) : yield this._downloadAndCacheRangePromise(e6, n4) : { stack: e6, id: n4, glyph: r3 };
          }));
        }
        _downloadAndCacheRangePromise(e6, n4) {
          return t4._(this, void 0, void 0, (function* () {
            let t5 = Math.floor(n4 / 256);
            if (256 * t5 > 65535) throw Error(`glyphs > 65535 not supported`);
            let r3 = this.entries[e6];
            if (r3.ranges[t5]) return { stack: e6, id: n4, glyph: null };
            if (!r3.requests[t5]) {
              let n5 = E2.loadGlyphRange(e6, t5, this.url, this.requestManager);
              r3.requests[t5] = n5;
            }
            try {
              let i3 = yield r3.requests[t5];
              for (let e7 in i3) r3.glyphs[+e7] = i3[+e7];
              return r3.ranges[t5] = true, { stack: e6, id: n4, glyph: i3[n4] || null };
            } catch (i3) {
              let a3 = r3.glyphs[n4] = this._drawGlyph(r3, e6, n4);
              return this._warnOnMissingGlyphRange(a3, t5, n4, i3), { stack: e6, id: n4, glyph: a3 };
            }
          }));
        }
        _warnOnMissingGlyphRange(e6, n4, r3, i3) {
          let a3 = 256 * n4, o3 = a3 + 255, s3 = r3.toString(16).padStart(4, `0`).toUpperCase();
          t4.w(`Unable to load glyph range ${n4}, ${a3}-${o3}. Rendering codepoint U+${s3} locally instead. ${i3}`);
        }
        _charUsesLocalIdeographFontFamily(e6) {
          return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e6)) || t4.u[`CJK Unified Ideographs`](e6) || t4.u[`Hangul Syllables`](e6) || t4.u.Hiragana(e6) || t4.u.Katakana(e6) || t4.u[`CJK Symbols and Punctuation`](e6) || t4.u[`Halfwidth and Fullwidth Forms`](e6));
        }
        _drawGlyph(e6, n4, r3) {
          let i3 = n4 === T2 && this.localIdeographFontFamily !== `` && this._charUsesLocalIdeographFontFamily(r3), a3 = i3 ? `ideographTinySDF` : `tinySDF`;
          e6[a3] || (e6[a3] = this._createTinySDF(i3 ? this.localIdeographFontFamily : n4));
          let o3 = e6[a3].draw(String.fromCharCode(r3));
          return { id: r3, bitmap: new t4.q({ width: o3.width || 60, height: o3.height || 60 }, o3.data), metrics: { width: o3.glyphWidth / 2 || 24, height: o3.glyphHeight / 2 || 24, left: o3.glyphLeft / 2 + 0.5 || 0, top: o3.glyphTop / 2 - 27.5 || -8, advance: o3.glyphAdvance / 2 || 24, isDoubleResolution: true } };
        }
        _createTinySDF(e6) {
          let t5 = e6 ? e6.split(`,`) : [];
          t5.push(`sans-serif`);
          let n4 = t5.map(((e7) => /[-\w]+/.test(e7) ? e7 : `'${CSS.escape(e7)}'`)).join(`,`);
          return new E2.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: n4, fontWeight: this._fontWeight(t5[0]), fontStyle: this._fontStyle(t5[0]), lang: this.lang });
        }
        _fontStyle(e6) {
          return /italic/i.test(e6) ? `italic` : /oblique/i.test(e6) ? `oblique` : `normal`;
        }
        _fontWeight(e6) {
          let t5 = { thin: 100, hairline: 100, "extra light": 200, "ultra light": 200, light: 300, normal: 400, regular: 400, medium: 500, semibold: 600, demibold: 600, bold: 700, "extra bold": 800, "ultra bold": 800, black: 900, heavy: 900, "extra black": 950, "ultra black": 950 }, n4;
          for (let [r3, i3] of Object.entries(t5)) RegExp(`\\b${r3}\\b`, `i`).test(e6) && (n4 = `${i3}`);
          return n4;
        }
      }
      E2.loadGlyphRange = function(e6, n4, r3, i3) {
        return t4._(this, void 0, void 0, (function* () {
          let a3 = 256 * n4, o3 = a3 + 255, s3 = i3.transformRequest(r3.replace(`{fontstack}`, e6).replace(`{range}`, `${a3}-${o3}`), `Glyphs`), c3 = yield t4.n(s3, new AbortController());
          if (!c3 || !c3.data) throw Error(`Could not load glyph range. range: ${n4}, ${a3}-${o3}`);
          let l3 = {};
          for (let e7 of t4.o(c3.data)) l3[e7.id] = e7;
          return l3;
        }));
      }, E2.TinySDF = class {
        constructor({ fontSize: e6 = 24, buffer: t5 = 3, radius: n4 = 8, cutoff: r3 = 0.25, fontFamily: i3 = `sans-serif`, fontWeight: a3 = `normal`, fontStyle: o3 = `normal`, lang: s3 = null } = {}) {
          this.buffer = t5, this.cutoff = r3, this.radius = n4, this.lang = s3;
          let c3 = this.size = e6 + 4 * t5, l3 = this.ctx = this._createCanvas(c3).getContext(`2d`, { willReadFrequently: true });
          l3.font = `${o3} ${a3} ${e6}px ${i3}`, l3.textBaseline = `alphabetic`, l3.textAlign = `left`, l3.fillStyle = `black`, this.gridOuter = new Float64Array(c3 * c3), this.gridInner = new Float64Array(c3 * c3), this.f = new Float64Array(c3), this.z = new Float64Array(c3 + 1), this.v = new Uint16Array(c3);
        }
        _createCanvas(e6) {
          let t5 = document.createElement(`canvas`);
          return t5.width = t5.height = e6, t5;
        }
        draw(e6) {
          let { width: t5, actualBoundingBoxAscent: n4, actualBoundingBoxDescent: r3, actualBoundingBoxLeft: i3, actualBoundingBoxRight: a3 } = this.ctx.measureText(e6), o3 = Math.ceil(n4), s3 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(a3 - i3))), c3 = Math.min(this.size - this.buffer, o3 + Math.ceil(r3)), l3 = s3 + 2 * this.buffer, u3 = c3 + 2 * this.buffer, d3 = Math.max(l3 * u3, 0), f3 = new Uint8ClampedArray(d3), p3 = { data: f3, width: l3, height: u3, glyphWidth: s3, glyphHeight: c3, glyphTop: o3, glyphLeft: 0, glyphAdvance: t5 };
          if (s3 === 0 || c3 === 0) return p3;
          let { ctx: m3, buffer: h3, gridInner: g3, gridOuter: _3 } = this;
          this.lang && (m3.lang = this.lang), m3.clearRect(h3, h3, s3, c3), m3.fillText(e6, h3, h3 + o3);
          let v3 = m3.getImageData(h3, h3, s3, c3);
          _3.fill(S2, 0, d3), g3.fill(0, 0, d3);
          for (let e7 = 0; e7 < c3; e7++) for (let t6 = 0; t6 < s3; t6++) {
            let n5 = v3.data[4 * (e7 * s3 + t6) + 3] / 255;
            if (n5 === 0) continue;
            let r4 = (e7 + h3) * l3 + t6 + h3;
            if (n5 === 1) _3[r4] = 0, g3[r4] = S2;
            else {
              let e8 = 0.5 - n5;
              _3[r4] = e8 > 0 ? e8 * e8 : 0, g3[r4] = e8 < 0 ? e8 * e8 : 0;
            }
          }
          C2(_3, 0, 0, l3, u3, l3, this.f, this.v, this.z), C2(g3, h3, h3, s3, c3, l3, this.f, this.v, this.z);
          for (let e7 = 0; e7 < d3; e7++) {
            let t6 = Math.sqrt(_3[e7]) - Math.sqrt(g3[e7]);
            f3[e7] = Math.round(255 - 255 * (t6 / this.radius + this.cutoff));
          }
          return p3;
        }
      };
      class D2 {
        constructor() {
          this.specification = t4.t.light.position;
        }
        possiblyEvaluate(e6, n4) {
          return t4.C(e6.expression.evaluate(n4));
        }
        interpolate(e6, n4, r3) {
          return { x: t4.F.number(e6.x, n4.x, r3), y: t4.F.number(e6.y, n4.y, r3), z: t4.F.number(e6.z, n4.z, r3) };
        }
      }
      let O2;
      class k2 extends t4.E {
        constructor(e6) {
          super(), O2 || (O2 = new t4.r({ anchor: new t4.D(t4.t.light.anchor), position: new D2(), color: new t4.D(t4.t.light.color), intensity: new t4.D(t4.t.light.intensity) })), this._transitionable = new t4.x(O2, void 0), this.setLight(e6), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(e6, n4 = {}) {
          if (!this._validate(t4.y, e6, n4)) for (let t5 in e6) {
            let n5 = e6[t5];
            t5.endsWith(`-transition`) ? this._transitionable.setTransition(t5.slice(0, -11), n5) : this._transitionable.setValue(t5, n5);
          }
        }
        updateTransitions(e6) {
          this._transitioning = this._transitionable.transitioned(e6, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e6) {
          this.properties = this._transitioning.possiblyEvaluate(e6);
        }
        _validate(e6, n4, r3) {
          return (!r3 || false !== r3.validate) && t4.z(this, e6.call(t4.B, { value: n4, style: { glyphs: true, sprite: true }, styleSpec: t4.t }));
        }
      }
      let A2 = new t4.r({ "sky-color": new t4.D(t4.t.sky[`sky-color`]), "horizon-color": new t4.D(t4.t.sky[`horizon-color`]), "fog-color": new t4.D(t4.t.sky[`fog-color`]), "fog-ground-blend": new t4.D(t4.t.sky[`fog-ground-blend`]), "horizon-fog-blend": new t4.D(t4.t.sky[`horizon-fog-blend`]), "sky-horizon-blend": new t4.D(t4.t.sky[`sky-horizon-blend`]), "atmosphere-blend": new t4.D(t4.t.sky[`atmosphere-blend`]) });
      class ee2 extends t4.E {
        constructor(e6) {
          super(), this._transitionable = new t4.x(A2, void 0), this.setSky(e6), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t4.G(0));
        }
        setSky(e6, n4 = {}) {
          if (!this._validate(t4.H, e6, n4)) for (let t5 in e6 || (e6 = { "sky-color": `transparent`, "horizon-color": `transparent`, "fog-color": `transparent`, "fog-ground-blend": 1, "atmosphere-blend": 0 }), e6) {
            let n5 = e6[t5];
            t5.endsWith(`-transition`) ? this._transitionable.setTransition(t5.slice(0, -11), n5) : this._transitionable.setValue(t5, n5);
          }
        }
        getSky() {
          return this._transitionable.serialize();
        }
        updateTransitions(e6) {
          this._transitioning = this._transitionable.transitioned(e6, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e6) {
          this.properties = this._transitioning.possiblyEvaluate(e6);
        }
        _validate(e6, n4, r3 = {}) {
          return false !== (r3 == null ? void 0 : r3.validate) && t4.z(this, e6.call(t4.B, t4.e({ value: n4, style: { glyphs: true, sprite: true }, styleSpec: t4.t })));
        }
        calculateFogBlendOpacity(e6) {
          return e6 < 60 ? 0 : e6 < 70 ? (e6 - 60) / 10 : 1;
        }
      }
      class j2 {
        constructor(e6, t5) {
          this.width = e6, this.height = t5, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
        }
        getDash(e6, t5) {
          let n4 = e6.join(`,`) + String(t5);
          return this.dashEntry[n4] || (this.dashEntry[n4] = this.addDash(e6, t5)), this.dashEntry[n4];
        }
        getDashRanges(e6, t5, n4) {
          let r3 = [], i3 = e6.length % 2 == 1 ? -e6[e6.length - 1] * n4 : 0, a3 = e6[0] * n4, o3 = true;
          r3.push({ left: i3, right: a3, isDash: o3, zeroLength: e6[0] === 0 });
          let s3 = e6[0];
          for (let t6 = 1; t6 < e6.length; t6++) {
            o3 = !o3;
            let c3 = e6[t6];
            i3 = s3 * n4, s3 += c3, a3 = s3 * n4, r3.push({ left: i3, right: a3, isDash: o3, zeroLength: c3 === 0 });
          }
          return r3;
        }
        addRoundDash(e6, t5, n4) {
          let r3 = t5 / 2;
          for (let t6 = -n4; t6 <= n4; t6++) {
            let i3 = this.width * (this.nextRow + n4 + t6), a3 = 0, o3 = e6[a3];
            for (let s3 = 0; s3 < this.width; s3++) {
              s3 / o3.right > 1 && (o3 = e6[++a3]);
              let c3 = Math.abs(s3 - o3.left), l3 = Math.abs(s3 - o3.right), u3 = Math.min(c3, l3), d3, f3 = t6 / n4 * (r3 + 1);
              if (o3.isDash) {
                let e7 = r3 - Math.abs(f3);
                d3 = Math.sqrt(u3 * u3 + e7 * e7);
              } else d3 = r3 - Math.sqrt(u3 * u3 + f3 * f3);
              this.data[i3 + s3] = Math.max(0, Math.min(255, d3 + 128));
            }
          }
        }
        addRegularDash(e6) {
          for (let t6 = e6.length - 1; t6 >= 0; --t6) {
            let n5 = e6[t6], r4 = e6[t6 + 1];
            n5.zeroLength ? e6.splice(t6, 1) : r4 && r4.isDash === n5.isDash && (r4.left = n5.left, e6.splice(t6, 1));
          }
          let t5 = e6[0], n4 = e6[e6.length - 1];
          t5.isDash === n4.isDash && (t5.left = n4.left - this.width, n4.right = t5.right + this.width);
          let r3 = this.width * this.nextRow, i3 = 0, a3 = e6[i3];
          for (let t6 = 0; t6 < this.width; t6++) {
            t6 / a3.right > 1 && (a3 = e6[++i3]);
            let n5 = Math.abs(t6 - a3.left), o3 = Math.abs(t6 - a3.right), s3 = Math.min(n5, o3);
            this.data[r3 + t6] = Math.max(0, Math.min(255, (a3.isDash ? s3 : -s3) + 128));
          }
        }
        addDash(e6, n4) {
          let r3 = n4 ? 7 : 0, i3 = 2 * r3 + 1;
          if (this.nextRow + i3 > this.height) return t4.w(`LineAtlas out of space`), null;
          let a3 = 0;
          for (let t5 = 0; t5 < e6.length; t5++) a3 += e6[t5];
          if (a3 !== 0) {
            let t5 = this.width / a3, i4 = this.getDashRanges(e6, this.width, t5);
            n4 ? this.addRoundDash(i4, t5, r3) : this.addRegularDash(i4);
          }
          let o3 = { y: this.nextRow + r3, height: 2 * r3, width: a3 };
          return this.nextRow += i3, this.dirty = true, o3;
        }
        bind(e6) {
          let t5 = e6.gl;
          this.texture ? (t5.bindTexture(t5.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, t5.texSubImage2D(t5.TEXTURE_2D, 0, 0, 0, this.width, this.height, t5.ALPHA, t5.UNSIGNED_BYTE, this.data))) : (this.texture = t5.createTexture(), t5.bindTexture(t5.TEXTURE_2D, this.texture), t5.texParameteri(t5.TEXTURE_2D, t5.TEXTURE_WRAP_S, t5.REPEAT), t5.texParameteri(t5.TEXTURE_2D, t5.TEXTURE_WRAP_T, t5.REPEAT), t5.texParameteri(t5.TEXTURE_2D, t5.TEXTURE_MIN_FILTER, t5.LINEAR), t5.texParameteri(t5.TEXTURE_2D, t5.TEXTURE_MAG_FILTER, t5.LINEAR), t5.texImage2D(t5.TEXTURE_2D, 0, t5.ALPHA, this.width, this.height, 0, t5.ALPHA, t5.UNSIGNED_BYTE, this.data));
        }
      }
      let M2 = `maplibre_preloaded_worker_pool`;
      class te2 {
        constructor() {
          this.active = {};
        }
        acquire(e6) {
          if (!this.workers) for (this.workers = []; this.workers.length < te2.workerCount; ) this.workers.push(new Worker(t4.a.WORKER_URL));
          return this.active[e6] = true, this.workers.slice();
        }
        release(e6) {
          delete this.active[e6], this.numActive() === 0 && (this.workers.forEach(((e7) => {
            e7.terminate();
          })), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[M2];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      let N2 = Math.floor(o2.hardwareConcurrency / 2), ne2, P2;
      function re2() {
        return ne2 || (ne2 = new te2()), ne2;
      }
      te2.workerCount = t4.J(globalThis) ? Math.max(Math.min(N2, 3), 1) : 1;
      class ie2 {
        constructor(e6, n4) {
          this.workerPool = e6, this.actors = [], this.currentActor = 0, this.id = n4;
          let r3 = this.workerPool.acquire(n4);
          for (let e7 = 0; e7 < r3.length; e7++) {
            let i3 = new t4.K(r3[e7], n4);
            i3.name = `Worker ${e7}`, this.actors.push(i3);
          }
          if (!this.actors.length) throw Error(`No actors found`);
        }
        broadcast(e6, t5) {
          let n4 = [];
          for (let r3 of this.actors) n4.push(r3.sendAsync({ type: e6, data: t5 }));
          return Promise.all(n4);
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove(e6 = true) {
          this.actors.forEach(((e7) => {
            e7.remove();
          })), this.actors = [], e6 && this.workerPool.release(this.id);
        }
        registerMessageHandler(e6, t5) {
          for (let n4 of this.actors) n4.registerMessageHandler(e6, t5);
        }
      }
      function ae2() {
        return P2 || (P2 = new ie2(re2(), t4.L), P2.registerMessageHandler(`GR`, ((e6, n4, r3) => t4.m(n4, r3)))), P2;
      }
      function oe2(e6, n4) {
        let r3 = t4.M();
        return t4.N(r3, r3, [1, 1, 0]), t4.O(r3, r3, [0.5 * e6.width, 0.5 * e6.height, 1]), e6.calculatePosMatrix ? t4.Q(r3, r3, e6.calculatePosMatrix(n4.toUnwrapped())) : r3;
      }
      function se2(e6, t5, n4, r3, i3, a3, o3) {
        let s3 = (function(e7, t6, n5) {
          if (e7) for (let r4 of e7) {
            let e8 = t6[r4];
            if (e8 && e8.source === n5 && e8.type === `fill-extrusion`) return true;
          }
          else for (let e8 in t6) {
            let r4 = t6[e8];
            if (r4.source === n5 && r4.type === `fill-extrusion`) return true;
          }
          return false;
        })((i3 == null ? void 0 : i3.layers) ?? null, t5, e6.id), c3 = a3.maxPitchScaleFactor(), l3 = e6.tilesIn(r3, c3, s3);
        l3.sort(F2);
        let u3 = [];
        for (let r4 of l3) u3.push({ wrappedTileID: r4.tileID.wrapped().key, queryResults: r4.tile.queryRenderedFeatures(t5, n4, e6.getState(), r4.queryGeometry, r4.cameraQueryGeometry, r4.scale, i3, a3, c3, oe2(a3, r4.tileID), o3 ? (e7, t6) => o3(r4.tileID, e7, t6) : void 0) });
        return (function(e7, t6) {
          for (let n5 in e7) for (let r4 of e7[n5]) ce2(r4, t6);
          return e7;
        })((function(e7) {
          let t6 = {}, n5 = {};
          for (let r4 of e7) {
            let e8 = r4.queryResults, i4 = r4.wrappedTileID, a4 = n5[i4] = n5[i4] || {};
            for (let n6 in e8) {
              let r5 = e8[n6], i5 = a4[n6] = a4[n6] || {}, o4 = t6[n6] = t6[n6] || [];
              for (let e9 of r5) i5[e9.featureIndex] || (i5[e9.featureIndex] = true, o4.push(e9));
            }
          }
          return t6;
        })(u3), e6);
      }
      function F2(e6, t5) {
        let n4 = e6.tileID, r3 = t5.tileID;
        return n4.overscaledZ - r3.overscaledZ || n4.canonical.y - r3.canonical.y || n4.wrap - r3.wrap || n4.canonical.x - r3.canonical.x;
      }
      function ce2(e6, t5) {
        let n4 = e6.feature, r3 = t5.getFeatureState(n4.layer[`source-layer`], n4.id);
        n4.source = n4.layer.source, n4.layer[`source-layer`] && (n4.sourceLayer = n4.layer[`source-layer`]), n4.state = r3;
      }
      function le2(e6, n4, r3) {
        return t4._(this, void 0, void 0, (function* () {
          let i3 = e6;
          if (e6.url ? i3 = (yield t4.j(n4.transformRequest(e6.url, `Source`), r3)).data : yield o2.frameAsync(r3), !i3) return null;
          let a3 = t4.S(t4.e(i3, e6), [`tiles`, `minzoom`, `maxzoom`, `attribution`, `bounds`, `scheme`, `tileSize`, `encoding`]);
          return `vector_layers` in i3 && i3.vector_layers && (a3.vectorLayerIds = i3.vector_layers.map(((e7) => e7.id))), a3;
        }));
      }
      class ue2 {
        constructor(e6, t5) {
          e6 && (t5 ? this.setSouthWest(e6).setNorthEast(t5) : Array.isArray(e6) && (e6.length === 4 ? this.setSouthWest([e6[0], e6[1]]).setNorthEast([e6[2], e6[3]]) : this.setSouthWest(e6[0]).setNorthEast(e6[1])));
        }
        setNorthEast(e6) {
          return this._ne = e6 instanceof t4.U ? new t4.U(e6.lng, e6.lat) : t4.U.convert(e6), this;
        }
        setSouthWest(e6) {
          return this._sw = e6 instanceof t4.U ? new t4.U(e6.lng, e6.lat) : t4.U.convert(e6), this;
        }
        extend(e6) {
          let n4 = this._sw, r3 = this._ne, i3, a3;
          if (e6 instanceof t4.U) i3 = e6, a3 = e6;
          else {
            if (!(e6 instanceof ue2)) return Array.isArray(e6) ? e6.length === 4 || e6.every(Array.isArray) ? this.extend(ue2.convert(e6)) : this.extend(t4.U.convert(e6)) : e6 && (`lng` in e6 || `lon` in e6) && `lat` in e6 ? this.extend(t4.U.convert(e6)) : this;
            if (i3 = e6._sw, a3 = e6._ne, !i3 || !a3) return this;
          }
          return n4 || r3 ? (n4.lng = Math.min(i3.lng, n4.lng), n4.lat = Math.min(i3.lat, n4.lat), r3.lng = Math.max(a3.lng, r3.lng), r3.lat = Math.max(a3.lat, r3.lat)) : (this._sw = new t4.U(i3.lng, i3.lat), this._ne = new t4.U(a3.lng, a3.lat)), this;
        }
        getCenter() {
          return new t4.U((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new t4.U(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new t4.U(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(e6) {
          let { lng: n4, lat: r3 } = t4.U.convert(e6), i3 = this._sw.lng <= n4 && n4 <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (i3 = this._sw.lng >= n4 && n4 >= this._ne.lng), this._sw.lat <= r3 && r3 <= this._ne.lat && i3;
        }
        intersects(e6) {
          if ((e6 = ue2.convert(e6)).getNorth() < this.getSouth() || e6.getSouth() > this.getNorth()) return false;
          let n4 = t4.V(this.getWest(), -180, 180), r3 = t4.V(this.getEast(), -180, 180), i3 = t4.V(e6.getWest(), -180, 180), a3 = t4.V(e6.getEast(), -180, 180), o3 = n4 > r3, s3 = i3 > a3;
          return !(!o3 || !s3) || (o3 ? a3 >= n4 || i3 <= r3 : s3 ? r3 >= i3 || n4 <= a3 : !(i3 > r3 || a3 < n4));
        }
        static convert(e6) {
          return e6 instanceof ue2 ? e6 : e6 && new ue2(e6);
        }
        static fromLngLat(e6, n4 = 0) {
          let r3 = 360 * n4 / 40075017, i3 = r3 / Math.cos(Math.PI / 180 * e6.lat);
          return new ue2(new t4.U(e6.lng - i3, e6.lat - r3), new t4.U(e6.lng + i3, e6.lat + r3));
        }
        adjustAntiMeridian() {
          let e6 = new t4.U(this._sw.lng, this._sw.lat), n4 = new t4.U(this._ne.lng, this._ne.lat);
          return new ue2(e6, e6.lng > n4.lng ? new t4.U(n4.lng + 360, n4.lat) : n4);
        }
      }
      class de2 {
        constructor(e6, t5, n4) {
          this.bounds = ue2.convert(this.validateBounds(e6)), this.minzoom = t5 || 0, this.maxzoom = n4 || 24;
        }
        validateBounds(e6) {
          return Array.isArray(e6) && e6.length === 4 ? [Math.max(-180, e6[0]), Math.max(-90, e6[1]), Math.min(180, e6[2]), Math.min(90, e6[3])] : [-180, -90, 180, 90];
        }
        contains(e6) {
          let n4 = 2 ** e6.z, r3 = Math.floor(t4.X(this.bounds.getWest()) * n4), i3 = Math.floor(t4.W(this.bounds.getNorth()) * n4), a3 = Math.ceil(t4.X(this.bounds.getEast()) * n4), o3 = Math.ceil(t4.W(this.bounds.getSouth()) * n4);
          return e6.x >= r3 && e6.x < a3 && e6.y >= i3 && e6.y < o3;
        }
      }
      class fe2 extends t4.E {
        constructor(e6, n4, r3, i3) {
          if (super(), this.id = e6, this.dispatcher = r3, this.type = `vector`, this.minzoom = 0, this.maxzoom = 22, this.scheme = `xyz`, this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, t4.e(this, t4.S(n4, [`url`, `scheme`, `tileSize`, `promoteId`])), this._options = t4.e({ type: `vector` }, n4), this._collectResourceTiming = n4.collectResourceTiming, this.tileSize !== 512) throw Error(`vector tile sources must have a tileSize of 512`);
          this.setEventedParent(i3);
        }
        load() {
          return t4._(this, void 0, void 0, (function* () {
            this._loaded = false, this.fire(new t4.l(`dataloading`, { dataType: `source` })), this._tileJSONRequest = new AbortController();
            try {
              let e6 = yield le2(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = true, this.map.style.tileManagers[this.id].clearTiles(), e6 && (t4.e(this, e6), e6.bounds && (this.tileBounds = new de2(e6.bounds, this.minzoom, this.maxzoom)), this.fire(new t4.l(`data`, { dataType: `source`, sourceDataType: `metadata` })), this.fire(new t4.l(`data`, { dataType: `source`, sourceDataType: `content` })));
            } catch (e6) {
              this._tileJSONRequest = null, this._loaded = true, this.fire(new t4.k(e6));
            }
          }));
        }
        loaded() {
          return this._loaded;
        }
        hasTile(e6) {
          return !this.tileBounds || this.tileBounds.contains(e6.canonical);
        }
        onAdd(e6) {
          this.map = e6, this.load();
        }
        setSourceProperty(e6) {
          this._tileJSONRequest && this._tileJSONRequest.abort(), e6(), this.load();
        }
        setTiles(e6) {
          return this.setSourceProperty((() => {
            this._options.tiles = e6;
          })), this;
        }
        setUrl(e6) {
          return this.setSourceProperty((() => {
            this.url = e6, this._options.url = e6;
          })), this;
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest = (this._tileJSONRequest.abort(), null));
        }
        serialize() {
          return t4.e({}, this._options);
        }
        loadTile(e6) {
          return t4._(this, void 0, void 0, (function* () {
            let t5 = e6.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), n4 = { request: this.map._requestManager.transformRequest(t5, `Tile`), uid: e6.uid, tileID: e6.tileID, zoom: e6.tileID.overscaledZ, tileSize: this.tileSize * e6.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
            n4.request.collectResourceTiming = this._collectResourceTiming;
            let r3 = `RT`;
            if (e6.actor && e6.state !== `expired`) {
              if (e6.state === `loading`) return new Promise(((t6, n5) => {
                e6.reloadPromise = { resolve: t6, reject: n5 };
              }));
            } else e6.actor = this.dispatcher.getActor(), r3 = `LT`;
            e6.abortController = new AbortController();
            try {
              let t6 = yield e6.actor.sendAsync({ type: r3, data: n4 }, e6.abortController);
              if (delete e6.abortController, e6.aborted) return;
              this._afterTileLoadWorkerResponse(e6, t6);
            } catch (t6) {
              if (delete e6.abortController, e6.aborted) return;
              if (t6 && t6.status !== 404) throw t6;
              this._afterTileLoadWorkerResponse(e6, null);
            }
          }));
        }
        _afterTileLoadWorkerResponse(e6, t5) {
          if (t5 && t5.resourceTiming && (e6.resourceTiming = t5.resourceTiming), t5 && this.map._refreshExpiredTiles && e6.setExpiryData(t5), e6.loadVectorData(t5, this.map.painter), e6.reloadPromise) {
            let t6 = e6.reloadPromise;
            e6.reloadPromise = null, this.loadTile(e6).then(t6.resolve).catch(t6.reject);
          }
        }
        abortTile(e6) {
          return t4._(this, void 0, void 0, (function* () {
            e6.abortController && (e6.abortController.abort(), delete e6.abortController), e6.actor && (yield e6.actor.sendAsync({ type: `AT`, data: { uid: e6.uid, type: this.type, source: this.id } }));
          }));
        }
        unloadTile(e6) {
          return t4._(this, void 0, void 0, (function* () {
            e6.unloadVectorData(), e6.actor && (yield e6.actor.sendAsync({ type: `RMT`, data: { uid: e6.uid, type: this.type, source: this.id } }));
          }));
        }
        hasTransition() {
          return false;
        }
      }
      class pe2 extends t4.E {
        constructor(e6, n4, r3, i3) {
          super(), this.id = e6, this.dispatcher = r3, this.setEventedParent(i3), this.type = `raster`, this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = `xyz`, this.tileSize = 512, this._loaded = false, this._options = t4.e({ type: `raster` }, n4), t4.e(this, t4.S(n4, [`url`, `scheme`, `tileSize`]));
        }
        load() {
          return t4._(this, arguments, void 0, (function* (e6 = false) {
            this._loaded = false, this.fire(new t4.l(`dataloading`, { dataType: `source` })), this._tileJSONRequest = new AbortController();
            try {
              let n4 = yield le2(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = true, n4 && (t4.e(this, n4), n4.bounds && (this.tileBounds = new de2(n4.bounds, this.minzoom, this.maxzoom)), this.fire(new t4.l(`data`, { dataType: `source`, sourceDataType: `metadata` })), this.fire(new t4.l(`data`, { dataType: `source`, sourceDataType: `content`, sourceDataChanged: e6 })));
            } catch (e7) {
              this._tileJSONRequest = null, this._loaded = true, this.fire(new t4.k(e7));
            }
          }));
        }
        loaded() {
          return this._loaded;
        }
        onAdd(e6) {
          this.map = e6, this.load();
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest = (this._tileJSONRequest.abort(), null));
        }
        setSourceProperty(e6) {
          this._tileJSONRequest && (this._tileJSONRequest = (this._tileJSONRequest.abort(), null)), e6(), this.load(true);
        }
        setTiles(e6) {
          return this.setSourceProperty((() => {
            this._options.tiles = e6;
          })), this;
        }
        setUrl(e6) {
          return this.setSourceProperty((() => {
            this.url = e6, this._options.url = e6;
          })), this;
        }
        serialize() {
          return t4.e({}, this._options);
        }
        hasTile(e6) {
          return !this.tileBounds || this.tileBounds.contains(e6.canonical);
        }
        loadTile(e6) {
          return t4._(this, void 0, void 0, (function* () {
            let n4 = e6.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            e6.abortController = new AbortController();
            try {
              let r3 = yield g2.getImage(this.map._requestManager.transformRequest(n4, `Tile`), e6.abortController, this.map._refreshExpiredTiles);
              if (delete e6.abortController, e6.aborted) return void (e6.state = `unloaded`);
              if (r3 && r3.data) {
                this.map._refreshExpiredTiles && (r3.cacheControl || r3.expires) && e6.setExpiryData({ cacheControl: r3.cacheControl, expires: r3.expires });
                let n5 = this.map.painter.context, i3 = n5.gl, a3 = r3.data;
                e6.texture = this.map.painter.getTileTexture(a3.width), e6.texture ? e6.texture.update(a3, { useMipmap: true }) : (e6.texture = new t4.T(n5, a3, i3.RGBA, { useMipmap: true }), e6.texture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE, i3.LINEAR_MIPMAP_NEAREST)), e6.state = `loaded`;
              }
            } catch (t5) {
              if (delete e6.abortController, e6.aborted) e6.state = `unloaded`;
              else if (t5) throw e6.state = `errored`, t5;
            }
          }));
        }
        abortTile(e6) {
          return t4._(this, void 0, void 0, (function* () {
            e6.abortController && (e6.abortController.abort(), delete e6.abortController);
          }));
        }
        unloadTile(e6) {
          return t4._(this, void 0, void 0, (function* () {
            e6.texture && this.map.painter.saveTileTexture(e6.texture);
          }));
        }
        hasTransition() {
          return false;
        }
      }
      class I2 extends pe2 {
        constructor(e6, n4, r3, i3) {
          super(e6, n4, r3, i3), this.type = `raster-dem`, this.maxzoom = 22, this._options = t4.e({ type: `raster-dem` }, n4), this.encoding = n4.encoding || `mapbox`, this.redFactor = n4.redFactor, this.greenFactor = n4.greenFactor, this.blueFactor = n4.blueFactor, this.baseShift = n4.baseShift;
        }
        loadTile(e6) {
          return t4._(this, void 0, void 0, (function* () {
            let n4 = e6.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), r3 = this.map._requestManager.transformRequest(n4, `Tile`);
            e6.neighboringTiles = this._getNeighboringTiles(e6.tileID), e6.abortController = new AbortController();
            try {
              let n5 = yield g2.getImage(r3, e6.abortController, this.map._refreshExpiredTiles);
              if (delete e6.abortController, e6.aborted) return void (e6.state = `unloaded`);
              if (n5 && n5.data) {
                let r4 = n5.data;
                this.map._refreshExpiredTiles && (n5.cacheControl || n5.expires) && e6.setExpiryData({ cacheControl: n5.cacheControl, expires: n5.expires });
                let i3 = t4.b(r4) && t4.Y() ? r4 : yield this.readImageNow(r4), a3 = { type: this.type, uid: e6.uid, source: this.id, rawImageData: i3, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                (!e6.actor || e6.state === `expired`) && (e6.actor = this.dispatcher.getActor(), e6.dem = yield e6.actor.sendAsync({ type: `LDT`, data: a3 }), e6.needsHillshadePrepare = true, e6.needsTerrainPrepare = true, e6.state = `loaded`);
              }
            } catch (t5) {
              if (delete e6.abortController, e6.aborted) e6.state = `unloaded`;
              else if (t5) throw e6.state = `errored`, t5;
            }
          }));
        }
        readImageNow(e6) {
          return t4._(this, void 0, void 0, (function* () {
            if (typeof VideoFrame < `u` && t4.Z()) {
              let n4 = e6.width + 2, r3 = e6.height + 2;
              try {
                return new t4.R({ width: n4, height: r3 }, yield t4.$(e6, -1, -1, n4, r3));
              } catch {
              }
            }
            return o2.getImageData(e6, 1);
          }));
        }
        _getNeighboringTiles(e6) {
          let n4 = e6.canonical, r3 = 2 ** n4.z, i3 = (n4.x - 1 + r3) % r3, a3 = n4.x === 0 ? e6.wrap - 1 : e6.wrap, o3 = (n4.x + 1 + r3) % r3, s3 = n4.x + 1 === r3 ? e6.wrap + 1 : e6.wrap, c3 = {};
          return c3[new t4.a0(e6.overscaledZ, a3, n4.z, i3, n4.y).key] = { backfilled: false }, c3[new t4.a0(e6.overscaledZ, s3, n4.z, o3, n4.y).key] = { backfilled: false }, n4.y > 0 && (c3[new t4.a0(e6.overscaledZ, a3, n4.z, i3, n4.y - 1).key] = { backfilled: false }, c3[new t4.a0(e6.overscaledZ, e6.wrap, n4.z, n4.x, n4.y - 1).key] = { backfilled: false }, c3[new t4.a0(e6.overscaledZ, s3, n4.z, o3, n4.y - 1).key] = { backfilled: false }), n4.y + 1 < r3 && (c3[new t4.a0(e6.overscaledZ, a3, n4.z, i3, n4.y + 1).key] = { backfilled: false }, c3[new t4.a0(e6.overscaledZ, e6.wrap, n4.z, n4.x, n4.y + 1).key] = { backfilled: false }, c3[new t4.a0(e6.overscaledZ, s3, n4.z, o3, n4.y + 1).key] = { backfilled: false }), c3;
        }
        unloadTile(e6) {
          return t4._(this, void 0, void 0, (function* () {
            e6.demTexture && this.map.painter.saveTileTexture(e6.demTexture), e6.fbo && (e6.fbo.destroy(), delete e6.fbo), e6.dem && delete e6.dem, delete e6.neighboringTiles, e6.state = `unloaded`, e6.actor && (yield e6.actor.sendAsync({ type: `RDT`, data: { type: this.type, uid: e6.uid, source: this.id } }));
          }));
        }
      }
      function me2(e6) {
        return e6.type === `GeometryCollection` ? e6.geometries.map(((e7) => e7.coordinates)).flat(1 / 0) : e6.coordinates.flat(1 / 0);
      }
      function he2(e6) {
        let t5 = new ue2(), n4;
        switch (e6.type) {
          case `FeatureCollection`:
            n4 = e6.features.map(((e7) => me2(e7.geometry))).flat(1 / 0);
            break;
          case `Feature`:
            n4 = me2(e6.geometry);
            break;
          default:
            n4 = me2(e6);
        }
        if (n4.length == 0) return t5;
        for (let e7 = 0; e7 < n4.length - 1; e7 += 2) t5.extend([n4[e7], n4[e7 + 1]]);
        return t5;
      }
      class ge2 extends t4.E {
        constructor(e6, n4, r3, i3) {
          super(), this.id = e6, this.type = `geojson`, this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._isUpdatingWorker = false, this._pendingWorkerUpdate = { data: n4.data }, this.actor = r3.getActor(), this.setEventedParent(i3), this._data = n4.data, this._options = t4.e({}, n4), this._collectResourceTiming = n4.collectResourceTiming, n4.maxzoom !== void 0 && (this.maxzoom = n4.maxzoom), n4.type && (this.type = n4.type), n4.attribution && (this.attribution = n4.attribution), this.promoteId = n4.promoteId, n4.clusterMaxZoom !== void 0 && this.maxzoom <= n4.clusterMaxZoom && t4.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${n4.clusterMaxZoom}".`), this.workerOptions = t4.e({ source: this.id, cluster: n4.cluster || false, geojsonVtOptions: { buffer: this._pixelsToTileUnits(n4.buffer === void 0 ? 128 : n4.buffer), tolerance: this._pixelsToTileUnits(n4.tolerance === void 0 ? 0.375 : n4.tolerance), extent: t4.a3, maxZoom: this.maxzoom, lineMetrics: n4.lineMetrics || false, generateId: n4.generateId || false }, superclusterOptions: { maxZoom: this._getClusterMaxZoom(n4.clusterMaxZoom), minPoints: Math.max(2, n4.clusterMinPoints || 2), extent: t4.a3, radius: this._pixelsToTileUnits(n4.clusterRadius || 50), log: false, generateId: n4.generateId || false }, clusterProperties: n4.clusterProperties, filter: n4.filter }, n4.workerOptions), typeof this.promoteId == `string` && (this.workerOptions.promoteId = this.promoteId);
        }
        _hasPendingWorkerUpdate() {
          return this._pendingWorkerUpdate.data !== void 0 || this._pendingWorkerUpdate.diff !== void 0 || this._pendingWorkerUpdate.optionsChanged;
        }
        _pixelsToTileUnits(e6) {
          return e6 * (t4.a3 / this.tileSize);
        }
        _getClusterMaxZoom(e6) {
          let n4 = e6 ? Math.round(e6) : this.maxzoom - 1;
          return Number.isInteger(e6) || e6 === void 0 || t4.w(`Integer expected for option 'clusterMaxZoom': provided value "${e6}" rounded to "${n4}"`), n4;
        }
        load() {
          return t4._(this, void 0, void 0, (function* () {
            yield this._updateWorkerData();
          }));
        }
        onAdd(e6) {
          this.map = e6, this.load();
        }
        setData(e6) {
          return this._data = e6, this._pendingWorkerUpdate = { data: e6 }, this._updateWorkerData(), this;
        }
        updateData(e6) {
          return this._pendingWorkerUpdate.diff = t4.a4(this._pendingWorkerUpdate.diff, e6), this._updateWorkerData(), this;
        }
        getData() {
          return t4._(this, void 0, void 0, (function* () {
            let e6 = t4.e({ type: this.type }, this.workerOptions);
            return this.actor.sendAsync({ type: `GD`, data: e6 });
          }));
        }
        getBounds() {
          return t4._(this, void 0, void 0, (function* () {
            return he2(yield this.getData());
          }));
        }
        setClusterOptions(e6) {
          return this.workerOptions.cluster = e6.cluster, e6.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e6.clusterRadius)), e6.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e6.clusterMaxZoom)), this._pendingWorkerUpdate.optionsChanged = true, this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(e6) {
          return this.actor.sendAsync({ type: `GCEZ`, data: { type: this.type, clusterId: e6, source: this.id } });
        }
        getClusterChildren(e6) {
          return this.actor.sendAsync({ type: `GCC`, data: { type: this.type, clusterId: e6, source: this.id } });
        }
        getClusterLeaves(e6, t5, n4) {
          return this.actor.sendAsync({ type: `GCL`, data: { type: this.type, source: this.id, clusterId: e6, limit: t5, offset: n4 } });
        }
        _updateWorkerData() {
          return t4._(this, void 0, void 0, (function* () {
            if (this._isUpdatingWorker) return;
            if (!this._hasPendingWorkerUpdate()) return void t4.w(`No pending worker updates for GeoJSONSource ${this.id}.`);
            let { data: e6, diff: n4 } = this._pendingWorkerUpdate, r3 = t4.e({ type: this.type }, this.workerOptions);
            e6 ? (typeof e6 == `string` ? (r3.request = this.map._requestManager.transformRequest(o2.resolveURL(e6), `Source`), r3.request.collectResourceTiming = this._collectResourceTiming) : r3.data = JSON.stringify(e6), this._pendingWorkerUpdate.data = void 0) : n4 && (r3.dataDiff = n4, this._pendingWorkerUpdate.diff = void 0), this._pendingWorkerUpdate.optionsChanged = void 0, this._isUpdatingWorker = true, this.fire(new t4.l(`dataloading`, { dataType: `source` }));
            try {
              let e7 = yield this.actor.sendAsync({ type: `LD`, data: r3 });
              if (this._isUpdatingWorker = false, this._removed || e7.abandoned) return void this.fire(new t4.l(`dataabort`, { dataType: `source` }));
              this._data = e7.data;
              let i3 = null;
              e7.resourceTiming && e7.resourceTiming[this.id] && (i3 = e7.resourceTiming[this.id].slice(0));
              let a3 = { dataType: `source` };
              this._collectResourceTiming && i3 && i3.length > 0 && t4.e(a3, { resourceTiming: i3 }), this.fire(new t4.l(`data`, Object.assign(Object.assign({}, a3), { sourceDataType: `metadata` }))), this.fire(new t4.l(`data`, Object.assign(Object.assign({}, a3), { sourceDataType: `content`, shouldReloadTileOptions: this._getShouldReloadTileOptions(n4) })));
            } catch (e7) {
              if (this._isUpdatingWorker = false, this._removed) return void this.fire(new t4.l(`dataabort`, { dataType: `source` }));
              this.fire(new t4.k(e7));
            } finally {
              this._hasPendingWorkerUpdate() && this._updateWorkerData();
            }
          }));
        }
        _getShouldReloadTileOptions(e6) {
          if (!e6 || e6.removeAll) return;
          let { add: t5 = [], update: n4 = [], remove: r3 = [] } = e6 || {}, i3 = /* @__PURE__ */ new Set([...n4.map(((e7) => e7.id)), ...r3]);
          return { nextBounds: [...n4.map(((e7) => e7.newGeometry)), ...t5.map(((e7) => e7.geometry))].map(((e7) => he2(e7))), prevIds: i3 };
        }
        shouldReloadTile(e6, { nextBounds: n4, prevIds: r3 }) {
          let i3 = e6.latestFeatureIndex.loadVTLayers();
          for (let t5 = 0; t5 < e6.latestFeatureIndex.featureIndexArray.length; t5++) {
            let n5 = e6.latestFeatureIndex.featureIndexArray.get(t5), a4 = i3._geojsonTileLayer.feature(n5.featureIndex);
            if (r3.has(a4.id)) return true;
          }
          let { buffer: a3, extent: o3 } = this.workerOptions.geojsonVtOptions, s3 = (function({ x: e7, y: n5, z: r4 }, i4 = 0) {
            let a4 = t4.a1((e7 - i4) / 2 ** r4), o4 = t4.a2((n5 + 1 + i4) / 2 ** r4), s4 = t4.a1((e7 + 1 + i4) / 2 ** r4), c3 = t4.a2((n5 - i4) / 2 ** r4);
            return new ue2([a4, o4], [s4, c3]);
          })(e6.tileID.canonical, a3 / o3);
          for (let e7 of n4) if (s3.intersects(e7)) return true;
          return false;
        }
        loaded() {
          return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate();
        }
        loadTile(e6) {
          return t4._(this, void 0, void 0, (function* () {
            let t5 = e6.actor ? `RT` : `LT`;
            e6.actor = this.actor;
            let n4 = { type: this.type, uid: e6.uid, tileID: e6.tileID, zoom: e6.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
            e6.abortController = new AbortController();
            let r3 = yield this.actor.sendAsync({ type: t5, data: n4 }, e6.abortController);
            delete e6.abortController, e6.unloadVectorData(), e6.aborted || e6.loadVectorData(r3, this.map.painter, t5 === `RT`);
          }));
        }
        abortTile(e6) {
          return t4._(this, void 0, void 0, (function* () {
            e6.abortController && (e6.abortController.abort(), delete e6.abortController), e6.aborted = true;
          }));
        }
        unloadTile(e6) {
          return t4._(this, void 0, void 0, (function* () {
            e6.unloadVectorData(), yield this.actor.sendAsync({ type: `RMT`, data: { uid: e6.uid, type: this.type, source: this.id } });
          }));
        }
        onRemove() {
          this._removed = true, this.actor.sendAsync({ type: `RS`, data: { type: this.type, source: this.id } });
        }
        serialize() {
          return t4.e({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return false;
        }
      }
      class _e2 extends t4.E {
        constructor(e6, t5, n4, r3) {
          super(), this.flippedWindingOrder = false, this.id = e6, this.dispatcher = n4, this.coordinates = t5.coordinates, this.type = `image`, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(r3), this.options = t5;
        }
        load(e6) {
          return t4._(this, void 0, void 0, (function* () {
            this._loaded = false, this.fire(new t4.l(`dataloading`, { dataType: `source` })), this.url = this.options.url, this._request = new AbortController();
            try {
              let t5 = yield g2.getImage(this.map._requestManager.transformRequest(this.url, `Image`), this._request);
              this._request = null, this._loaded = true, t5 && t5.data && (this.image = t5.data, e6 && (this.coordinates = e6), this._finishLoading());
            } catch (e7) {
              this._request = null, this._loaded = true, this.fire(new t4.k(e7));
            }
          }));
        }
        loaded() {
          return this._loaded;
        }
        updateImage(e6) {
          return e6.url ? (this._request && (this._request = (this._request.abort(), null)), this.options.url = e6.url, this.load(e6.coordinates).finally((() => {
            this.texture = null;
          })), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new t4.l(`data`, { dataType: `source`, sourceDataType: `metadata` })));
        }
        onAdd(e6) {
          this.map = e6, this.load();
        }
        onRemove() {
          this._request && (this._request = (this._request.abort(), null));
        }
        setCoordinates(e6) {
          this.coordinates = e6;
          let n4 = e6.map(t4.a5.fromLngLat);
          var r3;
          return this.tileID = (function(e7) {
            let n5 = t4.a6.fromPoints(e7), r4 = n5.width(), i3 = n5.height(), a3 = Math.max(r4, i3), o3 = Math.max(0, Math.floor(-Math.log(a3) / Math.LN2)), s3 = 2 ** o3;
            return new t4.a8(o3, Math.floor((n5.minX + n5.maxX) / 2 * s3), Math.floor((n5.minY + n5.maxY) / 2 * s3));
          })(n4), this.terrainTileRanges = this._getOverlappingTileRanges(n4), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = n4.map(((e7) => this.tileID.getTilePoint(e7)._round())), this.flippedWindingOrder = ((r3 = this.tileCoords)[1].x - r3[0].x) * (r3[2].y - r3[0].y) - (r3[1].y - r3[0].y) * (r3[2].x - r3[0].x) < 0, this.fire(new t4.l(`data`, { dataType: `source`, sourceDataType: `content` })), this;
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || !this.image) return;
          let e6 = this.map.painter.context, n4 = e6.gl;
          this.texture || (this.texture = new t4.T(e6, this.image, n4.RGBA), this.texture.bind(n4.LINEAR, n4.CLAMP_TO_EDGE));
          let r3 = false;
          for (let e7 in this.tiles) {
            let t5 = this.tiles[e7];
            t5.state !== `loaded` && (t5.state = `loaded`, t5.texture = this.texture, r3 = true);
          }
          r3 && this.fire(new t4.l(`data`, { dataType: `source`, sourceDataType: `idle`, sourceId: this.id }));
        }
        loadTile(e6) {
          return t4._(this, void 0, void 0, (function* () {
            this.tileID && this.tileID.equals(e6.tileID.canonical) ? (this.tiles[String(e6.tileID.wrap)] = e6, e6.buckets = {}) : e6.state = `errored`;
          }));
        }
        serialize() {
          return { type: `image`, url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return false;
        }
        _getOverlappingTileRanges(e6) {
          let { minX: n4, minY: r3, maxX: i3, maxY: a3 } = t4.a6.fromPoints(e6), o3 = {};
          for (let e7 = 0; e7 <= t4.a7; e7++) {
            let t5 = 2 ** e7;
            o3[e7] = { minTileX: Math.floor(n4 * t5), minTileY: Math.floor(r3 * t5), maxTileX: Math.floor(i3 * t5), maxTileY: Math.floor(a3 * t5) };
          }
          return o3;
        }
      }
      class ve2 extends _e2 {
        constructor(e6, t5, n4, r3) {
          super(e6, t5, n4, r3), this.roundZoom = true, this.type = `video`, this.options = t5;
        }
        load() {
          return t4._(this, void 0, void 0, (function* () {
            this._loaded = false;
            let e6 = this.options;
            this.urls = [];
            for (let t5 of e6.urls) this.urls.push(this.map._requestManager.transformRequest(t5, `Source`).url);
            try {
              let e7 = yield t4.a9(this.urls);
              if (this._loaded = true, !e7) return;
              this.video = e7, this.video.loop = true, this.video.addEventListener(`playing`, (() => {
                this.map.triggerRepaint();
              })), this.map && this.video.play(), this._finishLoading();
            } catch (e7) {
              this.fire(new t4.k(e7));
            }
          }));
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(e6) {
          if (this.video) {
            let n4 = this.video.seekable;
            e6 < n4.start(0) || e6 > n4.end(0) ? this.fire(new t4.k(new t4.aa(`sources.${this.id}`, null, `Playback for this video can be set only between the ${n4.start(0)} and ${n4.end(0)}-second mark.`))) : this.video.currentTime = e6;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(e6) {
          this.map || (this.map = e6, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
          let e6 = this.map.painter.context, n4 = e6.gl;
          this.texture ? this.video.paused || (this.texture.bind(n4.LINEAR, n4.CLAMP_TO_EDGE), n4.texSubImage2D(n4.TEXTURE_2D, 0, 0, 0, n4.RGBA, n4.UNSIGNED_BYTE, this.video)) : (this.texture = new t4.T(e6, this.video, n4.RGBA), this.texture.bind(n4.LINEAR, n4.CLAMP_TO_EDGE));
          let r3 = false;
          for (let e7 in this.tiles) {
            let t5 = this.tiles[e7];
            t5.state !== `loaded` && (t5.state = `loaded`, t5.texture = this.texture, r3 = true);
          }
          r3 && this.fire(new t4.l(`data`, { dataType: `source`, sourceDataType: `idle`, sourceId: this.id }));
        }
        serialize() {
          return { type: `video`, urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }
      class L2 extends _e2 {
        constructor(e6, n4, r3, i3) {
          super(e6, n4, r3, i3), n4.coordinates ? Array.isArray(n4.coordinates) && n4.coordinates.length === 4 && !n4.coordinates.some(((e7) => !Array.isArray(e7) || e7.length !== 2 || e7.some(((e8) => typeof e8 != `number`)))) || this.fire(new t4.k(new t4.aa(`sources.${e6}`, null, `"coordinates" property must be an array of 4 longitude/latitude array pairs`))) : this.fire(new t4.k(new t4.aa(`sources.${e6}`, null, `missing required property "coordinates"`))), n4.animate && typeof n4.animate != `boolean` && this.fire(new t4.k(new t4.aa(`sources.${e6}`, null, `optional "animate" property must be a boolean value`))), n4.canvas ? typeof n4.canvas == `string` || n4.canvas instanceof HTMLCanvasElement || this.fire(new t4.k(new t4.aa(`sources.${e6}`, null, `"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance`))) : this.fire(new t4.k(new t4.aa(`sources.${e6}`, null, `missing required property "canvas"`))), this.options = n4, this.animate = n4.animate === void 0 || n4.animate;
        }
        load() {
          return t4._(this, void 0, void 0, (function* () {
            this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t4.k(Error(`Canvas dimensions cannot be less than or equal to zero.`))) : (this.play = function() {
              this._playing = true, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this._playing = (this.prepare(), false));
            }, this._finishLoading());
          }));
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(e6) {
          this.map = e6, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let e6 = false;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, e6 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e6 = true), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
          let n4 = this.map.painter.context, r3 = n4.gl;
          this.texture ? (e6 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new t4.T(n4, this.canvas, r3.RGBA, { premultiply: true });
          let i3 = false;
          for (let e7 in this.tiles) {
            let t5 = this.tiles[e7];
            t5.state !== `loaded` && (t5.state = `loaded`, t5.texture = this.texture, i3 = true);
          }
          i3 && this.fire(new t4.l(`data`, { dataType: `source`, sourceDataType: `idle`, sourceId: this.id }));
        }
        serialize() {
          return { type: `canvas`, coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (let e6 of [this.canvas.width, this.canvas.height]) if (isNaN(e6) || e6 <= 0) return true;
          return false;
        }
      }
      let ye2 = {}, be2 = (e6) => {
        switch (e6) {
          case `geojson`:
            return ge2;
          case `image`:
            return _e2;
          case `raster`:
            return pe2;
          case `raster-dem`:
            return I2;
          case `vector`:
            return fe2;
          case `video`:
            return ve2;
          case `canvas`:
            return L2;
        }
        return ye2[e6];
      }, xe2 = `RTLPluginLoaded`;
      class Se2 extends t4.E {
        constructor() {
          super(...arguments), this.status = `unavailable`, this.url = null, this.dispatcher = ae2();
        }
        _syncState(e6) {
          return this.status = e6, this.dispatcher.broadcast(`SRPS`, { pluginStatus: e6, pluginURL: this.url }).catch(((e7) => {
            throw this.status = `error`, e7;
          }));
        }
        getRTLTextPluginStatus() {
          return this.status;
        }
        clearRTLTextPlugin() {
          this.status = `unavailable`, this.url = null;
        }
        setRTLTextPlugin(e6) {
          return t4._(this, arguments, void 0, (function* (e7, t5 = false) {
            if (this.url) throw Error(`setRTLTextPlugin cannot be called multiple times.`);
            if (this.url = o2.resolveURL(e7), !this.url) throw Error(`requested url ${e7} is invalid`);
            if (this.status === `unavailable`) {
              if (!t5) return this._requestImport();
              this.status = `deferred`, this._syncState(this.status);
            } else if (this.status === `requested`) return this._requestImport();
          }));
        }
        _requestImport() {
          return t4._(this, void 0, void 0, (function* () {
            yield this._syncState(`loading`), this.status = `loaded`, this.fire(new t4.l(xe2));
          }));
        }
        lazyLoad() {
          this.status === `unavailable` ? this.status = `requested` : this.status === `deferred` && this._requestImport();
        }
      }
      let Ce2 = null;
      function we2() {
        return Ce2 || (Ce2 = new Se2()), Ce2;
      }
      var Te2, Ee2;
      (function(e6) {
        e6[e6.Base = 0] = `Base`, e6[e6.Parent = 1] = `Parent`;
      })(Te2 || (Te2 = {})), (function(e6) {
        e6[e6.Departing = 0] = `Departing`, e6[e6.Incoming = 1] = `Incoming`;
      })(Ee2 || (Ee2 = {}));
      class De2 {
        constructor(e6, n4) {
          this.timeAdded = 0, this.fadeEndTime = 0, this.fadeOpacity = 1, this.tileID = e6, this.uid = t4.ab(), this.uses = 0, this.tileSize = n4, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = `loading`;
        }
        isRenderable(e6) {
          return this.hasData() && (!this.fadeEndTime || this.fadeOpacity > 0) && (e6 || !this.holdingForSymbolFade());
        }
        setCrossFadeLogic({ fadingRole: e6, fadingDirection: t5, fadingParentID: n4, fadeEndTime: r3 }) {
          this.resetFadeLogic(), this.fadingRole = e6, this.fadingDirection = t5, this.fadingParentID = n4, this.fadeEndTime = r3;
        }
        setSelfFadeLogic(e6) {
          this.resetFadeLogic(), this.selfFading = true, this.fadeEndTime = e6;
        }
        resetFadeLogic() {
          this.fadingRole = null, this.fadingDirection = null, this.fadingParentID = null, this.selfFading = false, this.timeAdded = c2(), this.fadeEndTime = 0, this.fadeOpacity = 1;
        }
        wasRequested() {
          return this.state === `errored` || this.state === `loaded` || this.state === `reloading`;
        }
        clearTextures(e6) {
          this.demTexture && e6.saveTileTexture(this.demTexture), this.demTexture = null;
        }
        loadVectorData(e6, n4, r3) {
          if (this.hasData() && this.unloadVectorData(), this.state = `loaded`, e6) {
            for (let i3 in e6.featureIndex && (this.latestFeatureIndex = e6.featureIndex, e6.rawTileData ? (this.latestRawTileData = e6.rawTileData, this.latestFeatureIndex.rawTileData = e6.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e6.collisionBoxArray, this.buckets = (function(e7, t5) {
              let n5 = {};
              if (!t5) return n5;
              for (let r4 of e7) {
                let e8 = r4.layerIds.map(((e9) => t5.getLayer(e9))).filter(Boolean);
                if (e8.length !== 0) {
                  r4.layers = e8, r4.stateDependentLayerIds && (r4.stateDependentLayers = r4.stateDependentLayerIds.map(((t6) => e8.filter(((e9) => e9.id === t6))[0])));
                  for (let t6 of e8) n5[t6.id] = r4;
                }
              }
              return n5;
            })(e6.buckets, n4 == null ? void 0 : n4.style), this.hasSymbolBuckets = false, this.buckets) {
              let e7 = this.buckets[i3];
              if (e7 instanceof t4.ad) {
                if (this.hasSymbolBuckets = true, !r3) break;
                e7.justReloaded = true;
              }
            }
            if (this.hasRTLText = false, this.hasSymbolBuckets) for (let e7 in this.buckets) {
              let n5 = this.buckets[e7];
              if (n5 instanceof t4.ad && n5.hasRTLText) {
                this.hasRTLText = true, we2().lazyLoad();
                break;
              }
            }
            for (let e7 in this.queryPadding = 0, this.buckets) {
              let t5 = this.buckets[e7];
              this.queryPadding = Math.max(this.queryPadding, n4.style.getLayer(e7).queryRadius(t5));
            }
            e6.imageAtlas && (this.imageAtlas = e6.imageAtlas), e6.glyphAtlasImage && (this.glyphAtlasImage = e6.glyphAtlasImage), this.dashPositions = e6.dashPositions;
          } else this.collisionBoxArray = new t4.ac();
        }
        unloadVectorData() {
          for (let e6 in this.buckets) this.buckets[e6].destroy();
          this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = `unloaded`;
        }
        getBucket(e6) {
          return this.buckets[e6.id];
        }
        upload(e6) {
          for (let t5 in this.buckets) {
            let n5 = this.buckets[t5];
            n5.uploadPending() && n5.upload(e6);
          }
          let n4 = e6.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new t4.T(e6, this.imageAtlas.image, n4.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasImage = (this.glyphAtlasTexture = new t4.T(e6, this.glyphAtlasImage, n4.ALPHA), null));
        }
        prepare(e6) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(e6, this.imageAtlasTexture);
        }
        queryRenderedFeatures(e6, t5, n4, r3, i3, a3, o3, s3, c3, l3, u3) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: r3, cameraQueryGeometry: i3, scale: a3, tileSize: this.tileSize, pixelPosMatrix: l3, transform: s3, params: o3, queryPadding: this.queryPadding * c3, getElevation: u3 }, e6, t5, n4) : {};
        }
        querySourceFeatures(e6, n4) {
          let r3 = this.latestFeatureIndex;
          if (!r3 || !r3.rawTileData) return;
          let i3 = r3.loadVTLayers(), a3 = n4 && n4.sourceLayer ? n4.sourceLayer : ``, o3 = i3._geojsonTileLayer || i3[a3];
          if (!o3) return;
          let s3 = t4.ae(n4 == null ? void 0 : n4.filter, n4 == null ? void 0 : n4.globalState), { z: c3, x: l3, y: u3 } = this.tileID.canonical, d3 = { z: c3, x: l3, y: u3 };
          for (let n5 = 0; n5 < o3.length; n5++) {
            let i4 = o3.feature(n5);
            if (s3.needGeometry) {
              let e7 = t4.af(i4, true);
              if (!s3.filter(new t4.G(this.tileID.overscaledZ), e7, this.tileID.canonical)) continue;
            } else if (!s3.filter(new t4.G(this.tileID.overscaledZ), i4)) continue;
            let f3 = r3.getId(i4, a3), p3 = new t4.ag(i4, c3, l3, u3, f3);
            p3.tile = d3, e6.push(p3);
          }
        }
        hasData() {
          return this.state === `loaded` || this.state === `reloading` || this.state === `expired`;
        }
        patternsLoaded() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(e6) {
          let n4 = this.expirationTime;
          if (e6.cacheControl) {
            let n5 = t4.ah(e6.cacheControl);
            n5[`max-age`] && (this.expirationTime = Date.now() + 1e3 * n5[`max-age`]);
          } else e6.expires && (this.expirationTime = new Date(e6.expires).getTime());
          if (this.expirationTime) {
            let e7 = Date.now(), t5 = false;
            if (this.expirationTime > e7) t5 = false;
            else if (n4) if (this.expirationTime < n4) t5 = true;
            else {
              let r3 = this.expirationTime - n4;
              r3 ? this.expirationTime = e7 + Math.max(r3, 3e4) : t5 = true;
            }
            else t5 = true;
            t5 ? (this.expiredRequestCount++, this.state = `expired`) : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), 2 ** 31 - 1);
        }
        setFeatureState(e6, t5) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e6).length === 0) return;
          let n4 = this.latestFeatureIndex.loadVTLayers();
          for (let r3 in this.buckets) {
            if (!t5.style.hasLayer(r3)) continue;
            let i3 = this.buckets[r3], a3 = i3.layers[0].sourceLayer || `_geojsonTileLayer`, o3 = n4[a3], s3 = e6[a3];
            if (!o3 || !s3 || Object.keys(s3).length === 0) continue;
            i3.update(s3, o3, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
            let c3 = t5 && t5.style && t5.style.getLayer(r3);
            c3 && (this.queryPadding = Math.max(this.queryPadding, c3.queryRadius(i3)));
          }
        }
        holdingForSymbolFade() {
          return this.symbolFadeHoldUntil !== void 0;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < c2();
        }
        clearSymbolFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setSymbolHoldDuration(e6) {
          this.symbolFadeHoldUntil = c2() + e6;
        }
        setDependencies(e6, t5) {
          let n4 = {};
          for (let e7 of t5) n4[e7] = true;
          this.dependencies[e6] = n4;
        }
        hasDependency(e6, t5) {
          for (let n4 of e6) {
            let e7 = this.dependencies[n4];
            if (e7) {
              for (let n5 of t5) if (e7[n5]) return true;
            }
          }
          return false;
        }
      }
      class Oe2 {
        constructor(e6, t5) {
          this.max = e6, this.onRemove = t5, this.reset();
        }
        reset() {
          for (let e6 in this.data) for (let t5 of this.data[e6]) t5.timeout && clearTimeout(t5.timeout), this.onRemove(t5.value);
          return this.data = {}, this.order = [], this;
        }
        add(e6, t5, n4) {
          let r3 = e6.wrapped().key;
          this.data[r3] === void 0 && (this.data[r3] = []);
          let i3 = { value: t5, timeout: void 0 };
          if (n4 !== void 0 && (i3.timeout = setTimeout((() => {
            this.remove(e6, i3);
          }), n4)), this.data[r3].push(i3), this.order.push(r3), this.order.length > this.max) {
            let e7 = this._getAndRemoveByKey(this.order[0]);
            e7 && this.onRemove(e7);
          }
          return this;
        }
        has(e6) {
          return e6.wrapped().key in this.data;
        }
        getAndRemove(e6) {
          return this.has(e6) ? this._getAndRemoveByKey(e6.wrapped().key) : null;
        }
        _getAndRemoveByKey(e6) {
          let t5 = this.data[e6].shift();
          return t5.timeout && clearTimeout(t5.timeout), this.data[e6].length === 0 && delete this.data[e6], this.order.splice(this.order.indexOf(e6), 1), t5.value;
        }
        getByKey(e6) {
          let t5 = this.data[e6];
          return t5 ? t5[0].value : null;
        }
        get(e6) {
          return this.has(e6) ? this.data[e6.wrapped().key][0].value : null;
        }
        remove(e6, t5) {
          if (!this.has(e6)) return this;
          let n4 = e6.wrapped().key, r3 = t5 === void 0 ? 0 : this.data[n4].indexOf(t5), i3 = this.data[n4][r3];
          return this.data[n4].splice(r3, 1), i3.timeout && clearTimeout(i3.timeout), this.data[n4].length === 0 && delete this.data[n4], this.onRemove(i3.value), this.order.splice(this.order.indexOf(n4), 1), this;
        }
        setMaxSize(e6) {
          for (this.max = e6; this.order.length > this.max; ) {
            let e7 = this._getAndRemoveByKey(this.order[0]);
            e7 && this.onRemove(e7);
          }
          return this;
        }
        filter(e6) {
          let t5 = [];
          for (let n4 in this.data) for (let r3 of this.data[n4]) e6(r3.value) || t5.push(r3);
          for (let e7 of t5) this.remove(e7.value.tileID, e7);
        }
      }
      class ke2 {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(e6, n4, r3) {
          let i3 = String(n4);
          if (this.stateChanges[e6] = this.stateChanges[e6] || {}, this.stateChanges[e6][i3] = this.stateChanges[e6][i3] || {}, t4.e(this.stateChanges[e6][i3], r3), this.deletedStates[e6] === null) for (let t5 in this.deletedStates[e6] = {}, this.state[e6]) t5 !== i3 && (this.deletedStates[e6][t5] = null);
          else if (this.deletedStates[e6] && this.deletedStates[e6][i3] === null) for (let t5 in this.deletedStates[e6][i3] = {}, this.state[e6][i3]) r3[t5] || (this.deletedStates[e6][i3][t5] = null);
          else for (let t5 in r3) this.deletedStates[e6] && this.deletedStates[e6][i3] && this.deletedStates[e6][i3][t5] === null && delete this.deletedStates[e6][i3][t5];
        }
        removeFeatureState(e6, t5, n4) {
          if (this.deletedStates[e6] === null) return;
          let r3 = String(t5);
          if (this.deletedStates[e6] = this.deletedStates[e6] || {}, n4 && t5 !== void 0) this.deletedStates[e6][r3] !== null && (this.deletedStates[e6][r3] = this.deletedStates[e6][r3] || {}, this.deletedStates[e6][r3][n4] = null);
          else if (t5 !== void 0) if (this.stateChanges[e6] && this.stateChanges[e6][r3]) for (n4 in this.deletedStates[e6][r3] = {}, this.stateChanges[e6][r3]) this.deletedStates[e6][r3][n4] = null;
          else this.deletedStates[e6][r3] = null;
          else this.deletedStates[e6] = null;
        }
        getState(e6, n4) {
          let r3 = String(n4), i3 = t4.e({}, (this.state[e6] || {})[r3], (this.stateChanges[e6] || {})[r3]);
          if (this.deletedStates[e6] === null) return {};
          if (this.deletedStates[e6]) {
            let t5 = this.deletedStates[e6][n4];
            if (t5 === null) return {};
            for (let e7 in t5) delete i3[e7];
          }
          return i3;
        }
        initializeTileState(e6, t5) {
          e6.setFeatureState(this.state, t5);
        }
        coalesceChanges(e6, n4) {
          let r3 = {};
          for (let e7 in this.stateChanges) {
            this.state[e7] = this.state[e7] || {};
            let n5 = {};
            for (let r4 in this.stateChanges[e7]) this.state[e7][r4] || (this.state[e7][r4] = {}), t4.e(this.state[e7][r4], this.stateChanges[e7][r4]), n5[r4] = this.state[e7][r4];
            r3[e7] = n5;
          }
          for (let e7 in this.deletedStates) {
            this.state[e7] = this.state[e7] || {};
            let n5 = {};
            if (this.deletedStates[e7] === null) for (let t5 in this.state[e7]) n5[t5] = {}, this.state[e7][t5] = {};
            else for (let t5 in this.deletedStates[e7]) {
              if (this.deletedStates[e7][t5] === null) this.state[e7][t5] = {};
              else for (let n6 of Object.keys(this.deletedStates[e7][t5])) delete this.state[e7][t5][n6];
              n5[t5] = this.state[e7][t5];
            }
            r3[e7] = r3[e7] || {}, t4.e(r3[e7], n5);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(r3).length !== 0) for (let t5 in e6) e6[t5].setFeatureState(r3, n4);
        }
      }
      let Ae2 = 89.25;
      function je2(e6, n4) {
        let r3 = t4.ai(n4.lat, -t4.aj, t4.aj);
        return new t4.P(t4.X(n4.lng) * e6, t4.W(r3) * e6);
      }
      function Me2(e6, n4) {
        return new t4.a5(n4.x / e6, n4.y / e6).toLngLat();
      }
      function Ne2(e6) {
        return e6.cameraToCenterDistance * Math.min(0.85 * Math.tan(t4.ak(90 - e6.pitch)), Math.tan(t4.ak(Ae2 - e6.pitch)));
      }
      function R2(e6, n4) {
        let r3 = e6.canonical, i3 = n4 / t4.al(r3.z), a3 = r3.x + 2 ** r3.z * e6.wrap, o3 = t4.am(new Float64Array(16));
        return t4.N(o3, o3, [a3 * i3, r3.y * i3, 0]), t4.O(o3, o3, [i3 / t4.a3, i3 / t4.a3, 1]), o3;
      }
      function Pe2(e6, n4, r3, i3, a3) {
        let o3 = t4.a5.fromLngLat(e6, n4), s3 = a3 * t4.an(1, e6.lat), c3 = s3 * Math.cos(t4.ak(r3)), l3 = Math.sqrt(s3 * s3 - c3 * c3), u3 = l3 * Math.sin(t4.ak(-i3)), d3 = l3 * Math.cos(t4.ak(-i3));
        return new t4.a5(o3.x + u3, o3.y + d3, o3.z + c3);
      }
      function Fe2(e6, t5, n4) {
        let r3 = t5.intersectsFrustum(e6);
        if (!n4 || r3 === 0) return r3;
        let i3 = t5.intersectsPlane(n4);
        return i3 === 0 ? 0 : r3 === 2 && i3 === 2 ? 2 : 1;
      }
      function Ie2(e6, t5, n4) {
        let r3 = 0, i3 = (n4 - t5) / 10;
        for (let a3 = 0; a3 < 10; a3++) r3 += i3 * Math.cos(t5 + (a3 + 0.5) / 10 * (n4 - t5)) ** +e6;
        return r3;
      }
      function Le2(e6, n4) {
        return function(r3, i3, a3, o3, s3) {
          let c3 = 2 * ((e6 - 1) / t4.ao(Math.cos(t4.ak(Ae2 - s3)) / Math.cos(t4.ak(Ae2))) - 1), l3 = Math.acos(a3 / o3), u3 = 2 * Ie2(c3 - 1, 0, t4.ak(s3 / 2)), d3 = Math.min(t4.ak(Ae2), l3 + t4.ak(s3 / 2)), f3 = Ie2(c3 - 1, Math.min(d3, l3 - t4.ak(s3 / 2)), d3), p3 = Math.atan(i3 / a3), m3 = Math.hypot(i3, a3), h3 = r3;
          return h3 += t4.ao(o3 / m3 / Math.max(0.5, Math.cos(t4.ak(s3 / 2)))), h3 += c3 * t4.ao(Math.cos(p3)) / 2, h3 -= t4.ao(Math.max(1, f3 / u3 / n4)) / 2, h3;
        };
      }
      let Re2 = Le2(9.314, 3);
      function ze2(e6, n4) {
        let r3 = (n4.roundZoom ? Math.round : Math.floor)(e6.zoom + t4.ao(e6.tileSize / n4.tileSize));
        return Math.max(0, r3);
      }
      function Be2(e6, n4) {
        let r3 = e6.getCameraFrustum(), i3 = e6.getClippingPlane(), a3 = e6.screenPointToMercatorCoordinate(e6.getCameraPoint()), o3 = t4.a5.fromLngLat(e6.center, e6.elevation);
        a3.z = o3.z + Math.cos(e6.pitchInRadians) * e6.cameraToCenterDistance / e6.worldSize;
        let s3 = e6.getCoveringTilesDetailsProvider(), c3 = s3.allowVariableZoom(e6, n4), l3 = ze2(e6, n4), u3 = n4.minzoom || 0, d3 = n4.maxzoom === void 0 ? e6.maxZoom : n4.maxzoom, f3 = Math.min(Math.max(0, l3), d3), p3 = 2 ** f3, m3 = [p3 * a3.x, p3 * a3.y, 0], h3 = [p3 * o3.x, p3 * o3.y, 0], g3 = Math.hypot(o3.x - a3.x, o3.y - a3.y), _3 = Math.abs(o3.z - a3.z), v3 = Math.hypot(g3, _3), y3 = (e7) => ({ zoom: 0, x: 0, y: 0, wrap: e7, fullyVisible: false }), b3 = [], x3 = [];
        if (e6.renderWorldCopies && s3.allowWorldCopies()) for (let e7 = 1; e7 <= 3; e7++) b3.push(y3(-e7)), b3.push(y3(e7));
        for (b3.push(y3(0)); b3.length > 0; ) {
          let p4 = b3.pop(), g4 = p4.x, y4 = p4.y, S3 = p4.fullyVisible, C3 = { x: g4, y: y4, z: p4.zoom }, w3 = s3.getTileBoundingVolume(C3, p4.wrap, e6.elevation, n4);
          if (!S3) {
            let e7 = Fe2(r3, w3, i3);
            if (e7 === 0) continue;
            S3 = e7 === 2;
          }
          let T3 = s3.distanceToTile2d(a3.x, a3.y, C3, w3), E3 = l3;
          c3 && (E3 = (n4.calculateTileZoom || Re2)(e6.zoom + t4.ao(e6.tileSize / n4.tileSize), T3, _3, v3, e6.fov)), E3 = (n4.roundZoom ? Math.round : Math.floor)(E3), E3 = Math.max(0, E3);
          let D3 = Math.min(E3, d3);
          if (p4.wrap = s3.getWrap(o3, C3, p4.wrap), p4.zoom >= D3) {
            if (p4.zoom < u3) continue;
            let e7 = f3 - p4.zoom, r4 = m3[0] - 0.5 - (g4 << e7), i4 = m3[1] - 0.5 - (y4 << e7), a4 = n4.reparseOverscaled ? Math.max(p4.zoom, E3) : p4.zoom;
            x3.push({ tileID: new t4.a0(p4.zoom === d3 ? a4 : p4.zoom, p4.wrap, p4.zoom, g4, y4), distanceSq: t4.ap([h3[0] - 0.5 - g4, h3[1] - 0.5 - y4]), tileDistanceToCamera: Math.sqrt(r4 * r4 + i4 * i4) });
          } else for (let e7 = 0; e7 < 4; e7++) b3.push({ zoom: p4.zoom + 1, x: (g4 << 1) + e7 % 2, y: (y4 << 1) + (e7 >> 1), wrap: p4.wrap, fullyVisible: S3 });
        }
        return x3.sort(((e7, t5) => e7.distanceSq - t5.distanceSq)).map(((e7) => e7.tileID));
      }
      let Ve2 = t4.a6.fromPoints([new t4.P(0, 0), new t4.P(t4.a3, t4.a3)]);
      class He2 extends t4.E {
        constructor(e6, t5, n4) {
          super(), this.id = e6, this.dispatcher = n4, this.on(`data`, ((e7) => this._dataHandler(e7))), this.on(`dataloading`, (() => {
            this._sourceErrored = false;
          })), this.on(`error`, (() => {
            this._sourceErrored = this._source.loaded();
          })), this._source = ((e7, t6, n5, r3) => {
            let i3 = new (be2(t6.type))(e7, t6, n5, r3);
            if (i3.id !== e7) throw Error(`Expected Source id to be ${e7} instead of ${i3.id}`);
            return i3;
          })(e6, t5, n4, this), this._tiles = {}, this._cache = new Oe2(0, ((e7) => this._unloadTile(e7))), this._timers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._rasterFadeDuration = 0, this._maxFadingAncestorLevels = 5, this._state = new ke2(), this._didEmitContent = false, this._updated = false;
        }
        onAdd(e6) {
          this.map = e6, this._maxTileCacheSize = e6 ? e6._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e6 ? e6._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e6);
        }
        onRemove(e6) {
          this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e6);
        }
        loaded() {
          if (this._sourceErrored) return true;
          if (!this._sourceLoaded || !this._source.loaded()) return false;
          if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return true;
          if (!this._updated) return false;
          for (let e6 in this._tiles) {
            let t5 = this._tiles[e6];
            if (t5.state !== `loaded` && t5.state !== `errored`) return false;
          }
          return true;
        }
        getSource() {
          return this._source;
        }
        getState() {
          return this._state;
        }
        pause() {
          this._paused = true;
        }
        resume() {
          if (!this._paused) return;
          let e6 = this._shouldReloadOnResume;
          this._paused = false, this._shouldReloadOnResume = false, e6 && this.reload(), this.transform && this.update(this.transform, this.terrain);
        }
        _loadTile(e6, n4, r3) {
          return t4._(this, void 0, void 0, (function* () {
            try {
              yield this._source.loadTile(e6), this._tileLoaded(e6, n4, r3);
            } catch (n5) {
              e6.state = `errored`, n5.status === 404 ? this.update(this.transform, this.terrain) : this._source.fire(new t4.k(n5, { tile: e6 }));
            }
          }));
        }
        _unloadTile(e6) {
          this._source.unloadTile && this._source.unloadTile(e6);
        }
        _abortTile(e6) {
          this._source.abortTile && this._source.abortTile(e6), this._source.fire(new t4.l(`dataabort`, { tile: e6, coord: e6.tileID, dataType: `source` }));
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(e6) {
          for (let t5 in this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null), this._tiles) {
            let n4 = this._tiles[t5];
            n4.upload(e6), n4.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return Object.values(this._tiles).map(((e6) => e6.tileID)).sort(Ue2).map(((e6) => e6.key));
        }
        getRenderableIds(e6) {
          let n4 = [];
          for (let t5 in this._tiles) this._isIdRenderable(t5, e6) && n4.push(this._tiles[t5]);
          return e6 ? n4.sort(((e7, n5) => {
            let r3 = e7.tileID, i3 = n5.tileID, a3 = new t4.P(r3.canonical.x, r3.canonical.y)._rotate(-this.transform.bearingInRadians), o3 = new t4.P(i3.canonical.x, i3.canonical.y)._rotate(-this.transform.bearingInRadians);
            return r3.overscaledZ - i3.overscaledZ || o3.y - a3.y || o3.x - a3.x;
          })).map(((e7) => e7.tileID.key)) : n4.map(((e7) => e7.tileID)).sort(Ue2).map(((e7) => e7.key));
        }
        hasRenderableParent(e6) {
          let t5 = e6.overscaledZ - 1;
          if (t5 >= this._source.minzoom) {
            let n4 = this.getLoadedTile(e6.scaledTo(t5));
            if (n4) return this._isIdRenderable(n4.tileID.key);
          }
          return false;
        }
        _isIdRenderable(e6, t5 = false) {
          var _a3;
          return (_a3 = this._tiles[e6]) == null ? void 0 : _a3.isRenderable(t5);
        }
        reload(e6, t5 = void 0) {
          if (this._paused) this._shouldReloadOnResume = true;
          else for (let n4 in this._cache.reset(), this._tiles) t5 && this._source.shouldReloadTile && !this._source.shouldReloadTile(this._tiles[n4], t5) || (e6 ? this._reloadTile(n4, `expired`) : this._tiles[n4].state !== `errored` && this._reloadTile(n4, `reloading`));
        }
        _reloadTile(e6, n4) {
          return t4._(this, void 0, void 0, (function* () {
            let t5 = this._tiles[e6];
            t5 && (t5.state !== `loading` && (t5.state = n4), yield this._loadTile(t5, e6, n4));
          }));
        }
        _tileLoaded(e6, n4, r3) {
          e6.timeAdded = c2(), e6.selfFading && (e6.fadeEndTime = e6.timeAdded + this._rasterFadeDuration), r3 === `expired` && (e6.refreshedUponExpiration = true), this._setTileReloadTimer(n4, e6), this.getSource().type === `raster-dem` && e6.dem && this._backfillDEM(e6), this._state.initializeTileState(e6, this.map ? this.map.painter : null), e6.aborted || this._source.fire(new t4.l(`data`, { dataType: `source`, tile: e6, coord: e6.tileID }));
        }
        _backfillDEM(e6) {
          let t5 = this.getRenderableIds();
          for (let r3 = 0; r3 < t5.length; r3++) {
            let i3 = t5[r3];
            if (e6.neighboringTiles && e6.neighboringTiles[i3]) {
              let t6 = this.getTileByID(i3);
              n4(e6, t6), n4(t6, e6);
            }
          }
          function n4(e7, t6) {
            e7.needsHillshadePrepare = true, e7.needsTerrainPrepare = true;
            let n5 = t6.tileID.canonical.x - e7.tileID.canonical.x, r3 = t6.tileID.canonical.y - e7.tileID.canonical.y, i3 = 2 ** e7.tileID.canonical.z, a3 = t6.tileID.key;
            n5 === 0 && r3 === 0 || Math.abs(r3) > 1 || (Math.abs(n5) > 1 && (Math.abs(n5 + i3) === 1 ? n5 += i3 : Math.abs(n5 - i3) === 1 && (n5 -= i3)), t6.dem && e7.dem && (e7.dem.backfillBorder(t6.dem, n5, r3), e7.neighboringTiles && e7.neighboringTiles[a3] && (e7.neighboringTiles[a3].backfilled = true)));
          }
        }
        getTile(e6) {
          return this.getTileByID(e6.key);
        }
        getTileByID(e6) {
          return this._tiles[e6];
        }
        _retainLoadedChildren(e6, t5) {
          let n4 = Object.values(e6), r3 = this._getLoadedDescendents(n4), i3 = {};
          for (let e7 of n4) {
            let n5 = r3[e7.key];
            if (!(n5 == null ? void 0 : n5.length)) {
              i3[e7.key] = e7;
              continue;
            }
            let a3 = e7.overscaledZ + He2.maxUnderzooming, o3 = n5.filter(((e8) => e8.tileID.overscaledZ <= a3));
            if (!o3.length) {
              i3[e7.key] = e7;
              continue;
            }
            let s3 = Math.min(...o3.map(((e8) => e8.tileID.overscaledZ))), c3 = o3.filter(((e8) => e8.tileID.overscaledZ === s3)).map(((e8) => e8.tileID));
            for (let e8 of c3) t5[e8.key] = e8;
            this._areDescendentsComplete(c3, s3, e7.overscaledZ) || (i3[e7.key] = e7);
          }
          return i3;
        }
        _getLoadedDescendents(e6) {
          var t5;
          let n4 = {};
          for (let r3 in this._tiles) {
            let i3 = this._tiles[r3];
            if (i3.hasData()) for (let r4 of e6) i3.tileID.isChildOf(r4) && (n4[t5 = r4.key] || (n4[t5] = [])).push(i3);
          }
          return n4;
        }
        _areDescendentsComplete(e6, t5, n4) {
          return e6.length === 1 && e6[0].isOverscaled() ? e6[0].overscaledZ === t5 : 4 ** (t5 - n4) === e6.length;
        }
        getLoadedTile(e6) {
          let t5 = this._tiles[e6.key];
          return (t5 == null ? void 0 : t5.hasData()) ? t5 : null;
        }
        updateCacheSize(e6) {
          let n4 = Math.ceil(e6.width / this._source.tileSize) + 1, r3 = Math.ceil(e6.height / this._source.tileSize) + 1, i3 = Math.floor(n4 * r3 * (this._maxTileCacheZoomLevels === null ? t4.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), a3 = typeof this._maxTileCacheSize == `number` ? Math.min(this._maxTileCacheSize, i3) : i3;
          this._cache.setMaxSize(a3);
        }
        handleWrapJump(e6) {
          let t5 = Math.round((e6 - (this._prevLng === void 0 ? e6 : this._prevLng)) / 360);
          if (this._prevLng = e6, t5) {
            let e7 = {};
            for (let n4 in this._tiles) {
              let r3 = this._tiles[n4];
              r3.tileID = r3.tileID.unwrapTo(r3.tileID.wrap + t5), e7[r3.tileID.key] = r3;
            }
            this._tiles = e7, this._resetTileReloadTimers();
          }
        }
        update(e6, n4) {
          if (!this._sourceLoaded || this._paused) return;
          let r3;
          this.transform = e6, this.terrain = n4, this.updateCacheSize(e6), this.handleWrapJump(this.transform.center.lng), this.used || this.usedForTerrain ? this._source.tileID ? r3 = e6.getVisibleUnwrappedCoordinates(this._source.tileID).map(((e7) => new t4.a0(e7.canonical.z, e7.wrap, e7.canonical.z, e7.canonical.x, e7.canonical.y))) : (r3 = Be2(e6, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: n4, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (r3 = r3.filter(((e7) => this._source.hasTile(e7))))) : r3 = [], this.usedForTerrain && (r3 = this._addTerrainIdealTiles(r3));
          let i3 = r3.length === 0 && !this._updated && this._didEmitContent;
          this._updated = true, i3 && this.fire(new t4.l(`data`, { sourceDataType: `idle`, dataType: `source`, sourceId: this.id }));
          let a3 = ze2(e6, this._source), o3 = this._updateRetainedTiles(r3, a3), s3 = We2(this._source.type);
          s3 && this._rasterFadeDuration > 0 && !n4 && this._updateFadingTiles(r3, o3), s3 ? this._cleanUpRasterTiles(o3) : this._cleanUpVectorTiles(o3);
        }
        _cleanUpRasterTiles(e6) {
          for (let t5 in this._tiles) e6[t5] || this._removeTile(t5);
        }
        _cleanUpVectorTiles(e6) {
          for (let t5 in this._tiles) {
            let n4 = this._tiles[t5];
            e6[t5] ? n4.clearSymbolFadeHold() : n4.hasSymbolBuckets ? n4.holdingForSymbolFade() ? n4.symbolFadeFinished() && this._removeTile(t5) : n4.setSymbolHoldDuration(this.map._fadeDuration) : this._removeTile(t5);
          }
        }
        _addTerrainIdealTiles(e6) {
          let t5 = [];
          for (let n4 of e6) if (n4.canonical.z > this._source.minzoom) {
            let e7 = n4.scaledTo(n4.canonical.z - 1);
            t5.push(e7);
            let r3 = n4.scaledTo(Math.max(this._source.minzoom, Math.min(n4.canonical.z, 5)));
            t5.push(r3);
          }
          return e6.concat(t5);
        }
        releaseSymbolFadeTiles() {
          for (let e6 in this._tiles) this._tiles[e6].holdingForSymbolFade() && this._removeTile(e6);
        }
        _updateRetainedTiles(e6, t5) {
          var _a3;
          let n4 = {}, r3 = {}, i3 = Math.max(t5 - He2.maxOverzooming, this._source.minzoom), a3 = {};
          for (let t6 of e6) {
            let e7 = this._addTile(t6);
            n4[t6.key] = t6, e7.hasData() || (a3[t6.key] = t6);
          }
          for (let e7 in a3 = this._retainLoadedChildren(a3, n4), a3) {
            let t6 = a3[e7], o3 = this._tiles[e7], s3 = o3 == null ? void 0 : o3.wasRequested();
            for (let e8 = t6.overscaledZ - 1; e8 >= i3; --e8) {
              let i4 = t6.scaledTo(e8);
              if (r3[i4.key]) break;
              if (r3[i4.key] = true, o3 = this.getTile(i4), !o3 && s3 && (o3 = this._addTile(i4)), o3) {
                let e9 = o3.hasData();
                if ((e9 || !((_a3 = this.map) == null ? void 0 : _a3.cancelPendingTileRequestsWhileZooming) || s3) && (n4[i4.key] = i4), s3 = o3.wasRequested(), e9) break;
              }
            }
          }
          return n4;
        }
        _updateFadingTiles(e6, n4) {
          let r3 = c2(), i3 = t4.aq(e6);
          for (let t5 of e6) {
            let e7 = this._tiles[t5.key];
            e7.fadingDirection !== Ee2.Departing && e7.fadeOpacity !== 0 || e7.resetFadeLogic(), this._updateFadingAncestor(e7, n4, r3) || this._updateFadingDescendents(e7, n4, r3) || this._updateFadingEdge(e7, i3, r3) || e7.resetFadeLogic();
          }
        }
        _updateFadingAncestor(e6, t5, n4) {
          if (!e6.hasData()) return false;
          let { tileID: r3, fadingRole: i3, fadingDirection: a3, fadingParentID: o3 } = e6;
          if (i3 === Te2.Base && a3 === Ee2.Incoming && o3) return t5[o3.key] = o3, true;
          let s3 = Math.max(r3.overscaledZ - this._maxFadingAncestorLevels, this._source.minzoom);
          for (let i4 = r3.overscaledZ - 1; i4 >= s3; i4--) {
            let a4 = r3.scaledTo(i4), o4 = this.getLoadedTile(a4);
            if (o4) return e6.setCrossFadeLogic({ fadingRole: Te2.Base, fadingDirection: Ee2.Incoming, fadingParentID: o4.tileID, fadeEndTime: n4 + this._rasterFadeDuration }), o4.setCrossFadeLogic({ fadingRole: Te2.Parent, fadingDirection: Ee2.Departing, fadeEndTime: n4 + this._rasterFadeDuration }), t5[a4.key] = a4, true;
          }
          return false;
        }
        _updateFadingDescendents(e6, t5, n4) {
          if (!e6.hasData()) return false;
          let r3 = e6.tileID.children(this._source.maxzoom), i3 = this._updateFadingChildren(e6, r3, t5, n4);
          if (i3) return true;
          for (let a3 of r3) {
            let r4 = a3.children(this._source.maxzoom);
            this._updateFadingChildren(e6, r4, t5, n4) && (i3 = true);
          }
          return i3;
        }
        _updateFadingChildren(e6, t5, n4, r3) {
          if (t5[0].overscaledZ >= this._source.maxzoom) return false;
          let i3 = false;
          for (let a3 of t5) {
            let t6 = this.getLoadedTile(a3);
            if (!t6) continue;
            let { fadingRole: o3, fadingDirection: s3, fadingParentID: c3 } = t6;
            o3 === Te2.Base && s3 === Ee2.Departing && c3 || (t6.setCrossFadeLogic({ fadingRole: Te2.Base, fadingDirection: Ee2.Departing, fadingParentID: e6.tileID, fadeEndTime: r3 + this._rasterFadeDuration }), e6.setCrossFadeLogic({ fadingRole: Te2.Parent, fadingDirection: Ee2.Incoming, fadeEndTime: r3 + this._rasterFadeDuration })), n4[a3.key] = a3, i3 = true;
          }
          return i3;
        }
        _updateFadingEdge(e6, t5, n4) {
          let r3 = e6.tileID;
          return !!e6.selfFading || !e6.hasData() && !!t5.has(r3) && (e6.setSelfFadeLogic(n4 + this._rasterFadeDuration), true);
        }
        _addTile(e6) {
          let n4 = this._tiles[e6.key];
          if (n4) return n4;
          n4 = this._cache.getAndRemove(e6), n4 && (n4.resetFadeLogic(), this._setTileReloadTimer(e6.key, n4), n4.tileID = e6, this._state.initializeTileState(n4, this.map ? this.map.painter : null));
          let r3 = n4;
          return n4 || (n4 = new De2(e6, this._source.tileSize * e6.overscaleFactor()), this._loadTile(n4, e6.key, n4.state)), n4.uses++, this._tiles[e6.key] = n4, r3 || this._source.fire(new t4.l(`dataloading`, { tile: n4, coord: n4.tileID, dataType: `source` })), n4;
        }
        _setTileReloadTimer(e6, t5) {
          this._clearTileReloadTimer(e6);
          let n4 = t5.getExpiryTimeout();
          n4 && (this._timers[e6] = setTimeout((() => {
            this._reloadTile(e6, `expired`), delete this._timers[e6];
          }), n4));
        }
        _clearTileReloadTimer(e6) {
          let t5 = this._timers[e6];
          t5 && (clearTimeout(t5), delete this._timers[e6]);
        }
        _resetTileReloadTimers() {
          for (let e6 in this._timers) clearTimeout(this._timers[e6]), delete this._timers[e6];
          for (let e6 in this._tiles) this._setTileReloadTimer(e6, this._tiles[e6]);
        }
        refreshTiles(e6) {
          for (let t5 in this._tiles) (this._isIdRenderable(t5) || this._tiles[t5].state == `errored`) && e6.some(((e7) => e7.equals(this._tiles[t5].tileID.canonical))) && this._reloadTile(t5, `expired`);
        }
        _removeTile(e6) {
          let t5 = this._tiles[e6];
          t5 && (t5.uses--, delete this._tiles[e6], this._clearTileReloadTimer(e6), t5.uses > 0 || (t5.hasData() && t5.state !== `reloading` ? this._cache.add(t5.tileID, t5, t5.getExpiryTimeout()) : (t5.aborted = true, this._abortTile(t5), this._unloadTile(t5))));
        }
        _dataHandler(e6) {
          e6.dataType === `source` && (e6.sourceDataType === `metadata` ? this._sourceLoaded = true : e6.sourceDataType === `content` && this._sourceLoaded && !this._paused && (this.reload(e6.sourceDataChanged, e6.shouldReloadTileOptions), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true));
        }
        clearTiles() {
          for (let e6 in this._shouldReloadOnResume = false, this._paused = false, this._tiles) this._removeTile(e6);
          this._cache.reset();
        }
        tilesIn(e6, n4, r3) {
          let i3 = [], a3 = this.transform;
          if (!a3) return i3;
          let o3 = a3.getCoveringTilesDetailsProvider().allowWorldCopies(), s3 = r3 ? a3.getCameraQueryGeometry(e6) : e6, c3 = (e7) => a3.screenPointToMercatorCoordinate(e7, this.terrain), l3 = this.transformBbox(e6, c3, !o3), u3 = this.transformBbox(s3, c3, !o3), d3 = this.getIds(), f3 = t4.a6.fromPoints(u3);
          for (let e7 = 0; e7 < d3.length; e7++) {
            let r4 = this._tiles[d3[e7]];
            if (r4.holdingForSymbolFade()) continue;
            let s4 = o3 ? [r4.tileID] : [r4.tileID.unwrapTo(-1), r4.tileID.unwrapTo(0)], c4 = 2 ** (a3.zoom - r4.tileID.overscaledZ), p3 = n4 * r4.queryPadding * t4.a3 / r4.tileSize / c4;
            for (let e8 of s4) {
              let n5 = f3.map(((n6) => e8.getTilePoint(new t4.a5(n6.x, n6.y))));
              if (n5.expandBy(p3), n5.intersects(Ve2)) {
                let t5 = l3.map(((t6) => e8.getTilePoint(t6))), n6 = u3.map(((t6) => e8.getTilePoint(t6)));
                i3.push({ tile: r4, tileID: o3 ? e8 : e8.unwrapTo(0), queryGeometry: t5, cameraQueryGeometry: n6, scale: c4 });
              }
            }
          }
          return i3;
        }
        transformBbox(e6, n4, r3) {
          let i3 = e6.map(n4);
          if (r3) {
            let r4 = t4.a6.fromPoints(e6);
            r4.shrinkBy(1e-3 * Math.min(r4.width(), r4.height()));
            let a3 = r4.map(n4);
            t4.a6.fromPoints(i3).covers(a3) || (i3 = i3.map(((e7) => e7.x > 0.5 ? new t4.a5(e7.x - 1, e7.y, e7.z) : e7)));
          }
          return i3;
        }
        getVisibleCoordinates(e6) {
          let t5 = this.getRenderableIds(e6).map(((e7) => this._tiles[e7].tileID));
          return this.transform && this.transform.populateCache(t5), t5;
        }
        hasTransition() {
          if (this._source.hasTransition()) return true;
          if (We2(this._source.type) && this._rasterFadeDuration > 0) {
            let e6 = c2();
            for (let t5 in this._tiles) if (this._tiles[t5].fadeEndTime >= e6) return true;
          }
          return false;
        }
        setRasterFadeDuration(e6) {
          this._rasterFadeDuration = e6;
        }
        setFeatureState(e6, t5, n4) {
          this._state.updateState(e6 || (e6 = `_geojsonTileLayer`), t5, n4);
        }
        removeFeatureState(e6, t5, n4) {
          this._state.removeFeatureState(e6 || (e6 = `_geojsonTileLayer`), t5, n4);
        }
        getFeatureState(e6, t5) {
          return this._state.getState(e6 || (e6 = `_geojsonTileLayer`), t5);
        }
        setDependencies(e6, t5, n4) {
          let r3 = this._tiles[e6];
          r3 && r3.setDependencies(t5, n4);
        }
        reloadTilesForDependencies(e6, t5) {
          for (let n4 in this._tiles) this._tiles[n4].hasDependency(e6, t5) && this._reloadTile(n4, `reloading`);
          this._cache.filter(((n4) => !n4.hasDependency(e6, t5)));
        }
      }
      function Ue2(e6, t5) {
        let n4 = Math.abs(2 * e6.wrap) - +(e6.wrap < 0), r3 = Math.abs(2 * t5.wrap) - +(t5.wrap < 0);
        return e6.overscaledZ - t5.overscaledZ || r3 - n4 || t5.canonical.y - e6.canonical.y || t5.canonical.x - e6.canonical.x;
      }
      function We2(e6) {
        return e6 === `raster` || e6 === `image` || e6 === `video`;
      }
      He2.maxOverzooming = 10, He2.maxUnderzooming = 3;
      class z2 {
        constructor(e6, t5) {
          this.reset(e6, t5);
        }
        reset(e6, t5) {
          this.points = e6 || [], this._distances = [0];
          for (let e7 = 1; e7 < this.points.length; e7++) this._distances[e7] = this._distances[e7 - 1] + this.points[e7].dist(this.points[e7 - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t5 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(e6) {
          if (this.points.length === 1) return this.points[0];
          e6 = t4.ai(e6, 0, 1);
          let n4 = 1, r3 = this._distances[n4], i3 = e6 * this.paddedLength + this.padding;
          for (; r3 < i3 && n4 < this._distances.length; ) r3 = this._distances[++n4];
          let a3 = n4 - 1, o3 = this._distances[a3], s3 = r3 - o3, c3 = s3 > 0 ? (i3 - o3) / s3 : 0;
          return this.points[a3].mult(1 - c3).add(this.points[n4].mult(c3));
        }
      }
      function Ge2(e6, t5) {
        let n4 = true;
        return e6 === `always` || e6 !== `never` && t5 !== `never` || (n4 = false), n4;
      }
      class Ke2 {
        constructor(e6, t5, n4) {
          let r3 = this.boxCells = [], i3 = this.circleCells = [];
          this.xCellCount = Math.ceil(e6 / n4), this.yCellCount = Math.ceil(t5 / n4);
          for (let e7 = 0; e7 < this.xCellCount * this.yCellCount; e7++) r3.push([]), i3.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e6, this.height = t5, this.xScale = this.xCellCount / e6, this.yScale = this.yCellCount / t5, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(e6, t5, n4, r3, i3) {
          this._forEachCell(t5, n4, r3, i3, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e6), this.bboxes.push(t5), this.bboxes.push(n4), this.bboxes.push(r3), this.bboxes.push(i3);
        }
        insertCircle(e6, t5, n4, r3) {
          this._forEachCell(t5 - r3, n4 - r3, t5 + r3, n4 + r3, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e6), this.circles.push(t5), this.circles.push(n4), this.circles.push(r3);
        }
        _insertBoxCell(e6, t5, n4, r3, i3, a3) {
          this.boxCells[i3].push(a3);
        }
        _insertCircleCell(e6, t5, n4, r3, i3, a3) {
          this.circleCells[i3].push(a3);
        }
        _query(e6, t5, n4, r3, i3, a3, o3) {
          if (n4 < 0 || e6 > this.width || r3 < 0 || t5 > this.height) return [];
          let s3 = [];
          if (e6 <= 0 && t5 <= 0 && this.width <= n4 && this.height <= r3) {
            if (i3) return [{ key: null, x1: e6, y1: t5, x2: n4, y2: r3 }];
            for (let e7 = 0; e7 < this.boxKeys.length; e7++) s3.push({ key: this.boxKeys[e7], x1: this.bboxes[4 * e7], y1: this.bboxes[4 * e7 + 1], x2: this.bboxes[4 * e7 + 2], y2: this.bboxes[4 * e7 + 3] });
            for (let e7 = 0; e7 < this.circleKeys.length; e7++) {
              let t6 = this.circles[3 * e7], n5 = this.circles[3 * e7 + 1], r4 = this.circles[3 * e7 + 2];
              s3.push({ key: this.circleKeys[e7], x1: t6 - r4, y1: n5 - r4, x2: t6 + r4, y2: n5 + r4 });
            }
          } else this._forEachCell(e6, t5, n4, r3, this._queryCell, s3, { hitTest: i3, overlapMode: a3, seenUids: { box: {}, circle: {} } }, o3);
          return s3;
        }
        query(e6, t5, n4, r3) {
          return this._query(e6, t5, n4, r3, false, null);
        }
        hitTest(e6, t5, n4, r3, i3, a3) {
          return this._query(e6, t5, n4, r3, true, i3, a3).length > 0;
        }
        hitTestCircle(e6, t5, n4, r3, i3) {
          let a3 = e6 - n4, o3 = e6 + n4, s3 = t5 - n4, c3 = t5 + n4;
          if (o3 < 0 || a3 > this.width || c3 < 0 || s3 > this.height) return false;
          let l3 = [];
          return this._forEachCell(a3, s3, o3, c3, this._queryCellCircle, l3, { hitTest: true, overlapMode: r3, circle: { x: e6, y: t5, radius: n4 }, seenUids: { box: {}, circle: {} } }, i3), l3.length > 0;
        }
        _queryCell(e6, t5, n4, r3, i3, a3, o3, s3) {
          let { seenUids: c3, hitTest: l3, overlapMode: u3 } = o3, d3 = this.boxCells[i3];
          if (d3 !== null) {
            let i4 = this.bboxes;
            for (let o4 of d3) if (!c3.box[o4]) {
              c3.box[o4] = true;
              let d4 = 4 * o4, f4 = this.boxKeys[o4];
              if (e6 <= i4[d4 + 2] && t5 <= i4[d4 + 3] && n4 >= i4[d4 + 0] && r3 >= i4[d4 + 1] && (!s3 || s3(f4)) && (!l3 || !Ge2(u3, f4.overlapMode)) && (a3.push({ key: f4, x1: i4[d4], y1: i4[d4 + 1], x2: i4[d4 + 2], y2: i4[d4 + 3] }), l3)) return true;
            }
          }
          let f3 = this.circleCells[i3];
          if (f3 !== null) {
            let i4 = this.circles;
            for (let o4 of f3) if (!c3.circle[o4]) {
              c3.circle[o4] = true;
              let d4 = 3 * o4, f4 = this.circleKeys[o4];
              if (this._circleAndRectCollide(i4[d4], i4[d4 + 1], i4[d4 + 2], e6, t5, n4, r3) && (!s3 || s3(f4)) && (!l3 || !Ge2(u3, f4.overlapMode))) {
                let e7 = i4[d4], t6 = i4[d4 + 1], n5 = i4[d4 + 2];
                if (a3.push({ key: f4, x1: e7 - n5, y1: t6 - n5, x2: e7 + n5, y2: t6 + n5 }), l3) return true;
              }
            }
          }
          return false;
        }
        _queryCellCircle(e6, t5, n4, r3, i3, a3, o3, s3) {
          let { circle: c3, seenUids: l3, overlapMode: u3 } = o3, d3 = this.boxCells[i3];
          if (d3 !== null) {
            let e7 = this.bboxes;
            for (let t6 of d3) if (!l3.box[t6]) {
              l3.box[t6] = true;
              let n5 = 4 * t6, r4 = this.boxKeys[t6];
              if (this._circleAndRectCollide(c3.x, c3.y, c3.radius, e7[n5 + 0], e7[n5 + 1], e7[n5 + 2], e7[n5 + 3]) && (!s3 || s3(r4)) && !Ge2(u3, r4.overlapMode)) return a3.push(true), true;
            }
          }
          let f3 = this.circleCells[i3];
          if (f3 !== null) {
            let e7 = this.circles;
            for (let t6 of f3) if (!l3.circle[t6]) {
              l3.circle[t6] = true;
              let n5 = 3 * t6, r4 = this.circleKeys[t6];
              if (this._circlesCollide(e7[n5], e7[n5 + 1], e7[n5 + 2], c3.x, c3.y, c3.radius) && (!s3 || s3(r4)) && !Ge2(u3, r4.overlapMode)) return a3.push(true), true;
            }
          }
        }
        _forEachCell(e6, t5, n4, r3, i3, a3, o3, s3) {
          let c3 = this._convertToXCellCoord(e6), l3 = this._convertToYCellCoord(t5), u3 = this._convertToXCellCoord(n4), d3 = this._convertToYCellCoord(r3);
          for (let f3 = c3; f3 <= u3; f3++) for (let c4 = l3; c4 <= d3; c4++) if (i3.call(this, e6, t5, n4, r3, this.xCellCount * c4 + f3, a3, o3, s3)) return;
        }
        _convertToXCellCoord(e6) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e6 * this.xScale)));
        }
        _convertToYCellCoord(e6) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e6 * this.yScale)));
        }
        _circlesCollide(e6, t5, n4, r3, i3, a3) {
          let o3 = r3 - e6, s3 = i3 - t5, c3 = n4 + a3;
          return c3 * c3 > o3 * o3 + s3 * s3;
        }
        _circleAndRectCollide(e6, t5, n4, r3, i3, a3, o3) {
          let s3 = (a3 - r3) / 2, c3 = Math.abs(e6 - (r3 + s3));
          if (c3 > s3 + n4) return false;
          let l3 = (o3 - i3) / 2, u3 = Math.abs(t5 - (i3 + l3));
          if (u3 > l3 + n4) return false;
          if (c3 <= s3 || u3 <= l3) return true;
          let d3 = c3 - s3, f3 = u3 - l3;
          return d3 * d3 + f3 * f3 <= n4 * n4;
        }
      }
      function qe2(e6, n4, i3) {
        let a3 = t4.M();
        if (!e6) {
          let { vecSouth: e7, vecEast: t5 } = B2(n4), i4 = r2();
          i4[0] = t5[0], i4[1] = t5[1], i4[2] = e7[0], i4[3] = e7[1], o3 = i4, (f3 = (c3 = (s3 = i4)[0]) * (d3 = s3[3]) - (u3 = s3[2]) * (l3 = s3[1])) && (o3[0] = d3 * (f3 = 1 / f3), o3[1] = -l3 * f3, o3[2] = -u3 * f3, o3[3] = c3 * f3), a3[0] = i4[0], a3[1] = i4[1], a3[4] = i4[2], a3[5] = i4[3];
        }
        var o3, s3, c3, l3, u3, d3, f3;
        return t4.O(a3, a3, [1 / i3, 1 / i3, 1]), a3;
      }
      function Je2(e6, n4, r3, i3) {
        if (e6) {
          let e7 = t4.M();
          if (!n4) {
            let { vecSouth: t5, vecEast: n5 } = B2(r3);
            e7[0] = n5[0], e7[1] = n5[1], e7[4] = t5[0], e7[5] = t5[1];
          }
          return t4.O(e7, e7, [i3, i3, 1]), e7;
        }
        return r3.pixelsToClipSpaceMatrix;
      }
      function B2(e6) {
        let n4 = Math.cos(e6.rollInRadians), r3 = Math.sin(e6.rollInRadians), i3 = Math.cos(e6.pitchInRadians), a3 = Math.cos(e6.bearingInRadians), o3 = Math.sin(e6.bearingInRadians), s3 = t4.av();
        s3[0] = -a3 * i3 * r3 - o3 * n4, s3[1] = -o3 * i3 * r3 + a3 * n4;
        let c3 = t4.aw(s3);
        c3 < 1e-9 ? t4.ax(s3) : t4.ay(s3, s3, 1 / c3);
        let l3 = t4.av();
        l3[0] = a3 * i3 * n4 - o3 * r3, l3[1] = o3 * i3 * n4 + a3 * r3;
        let u3 = t4.aw(l3);
        return u3 < 1e-9 ? t4.ax(l3) : t4.ay(l3, l3, 1 / u3), { vecEast: l3, vecSouth: s3 };
      }
      function V2(e6, n4, r3, i3) {
        let a3;
        i3 ? (a3 = [e6, n4, i3(e6, n4), 1], t4.aA(a3, a3, r3)) : (a3 = [e6, n4, 0, 1], ct2(a3, a3, r3));
        let o3 = a3[3];
        return { point: new t4.P(a3[0] / o3, a3[1] / o3), signedDistanceFromCamera: o3, isOccluded: false };
      }
      function H2(e6, t5) {
        return 0.5 + e6 / t5 * 0.5;
      }
      function Ye2(e6, t5) {
        return e6.x >= -t5[0] && e6.x <= t5[0] && e6.y >= -t5[1] && e6.y <= t5[1];
      }
      function Xe2(e6, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3, p3) {
        let m3 = r3 ? e6.textSizeData : e6.iconSizeData, h3 = t4.ar(m3, n4.transform.zoom), g3 = [256 / n4.width * 2 + 1, 256 / n4.height * 2 + 1], _3 = r3 ? e6.text.dynamicLayoutVertexArray : e6.icon.dynamicLayoutVertexArray;
        _3.clear();
        let v3 = e6.lineVertexArray, y3 = r3 ? e6.text.placedSymbolArray : e6.icon.placedSymbolArray, b3 = n4.transform.width / n4.transform.height, x3 = false;
        for (let r4 = 0; r4 < y3.length; r4++) {
          let S3 = y3.get(r4);
          if (S3.hidden || S3.writingMode === t4.as.vertical && !x3) {
            st2(S3.numGlyphs, _3);
            continue;
          }
          x3 = false;
          let C3 = new t4.P(S3.anchorX, S3.anchorY), w3 = { getElevation: p3, pitchedLabelPlaneMatrix: i3, lineVertexArray: v3, pitchWithMap: o3, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: n4.transform, tileAnchorPoint: C3, unwrappedTileID: l3, width: u3, height: d3, translation: f3 }, T3 = rt2(S3.anchorX, S3.anchorY, w3);
          if (!Ye2(T3.point, g3)) {
            st2(S3.numGlyphs, _3);
            continue;
          }
          let E3 = H2(n4.transform.cameraToCenterDistance, T3.signedDistanceFromCamera), D3 = t4.at(m3, h3, S3), O3 = o3 ? D3 * n4.transform.getPitchedTextCorrection(S3.anchorX, S3.anchorY, l3) / E3 : D3 * E3, k3 = Qe2({ projectionContext: w3, pitchedLabelPlaneMatrixInverse: a3, symbol: S3, fontSize: O3, flip: false, keepUpright: s3, glyphOffsetArray: e6.glyphOffsetArray, dynamicLayoutVertexArray: _3, aspectRatio: b3, rotateToLine: c3 });
          x3 = k3.useVertical, (k3.notEnoughRoom || x3 || k3.needsFlipping && Qe2({ projectionContext: w3, pitchedLabelPlaneMatrixInverse: a3, symbol: S3, fontSize: O3, flip: true, keepUpright: s3, glyphOffsetArray: e6.glyphOffsetArray, dynamicLayoutVertexArray: _3, aspectRatio: b3, rotateToLine: c3 }).notEnoughRoom) && st2(S3.numGlyphs, _3);
        }
        r3 ? e6.text.dynamicLayoutVertexBuffer.updateData(_3) : e6.icon.dynamicLayoutVertexBuffer.updateData(_3);
      }
      function Ze2(e6, t5, n4, r3, i3, a3, o3, s3) {
        let c3 = a3.glyphStartIndex + a3.numGlyphs, l3 = a3.lineStartIndex, u3 = a3.lineStartIndex + a3.lineLength, d3 = t5.getoffsetX(a3.glyphStartIndex), f3 = t5.getoffsetX(c3 - 1), p3 = W2(e6 * d3, n4, r3, i3, a3.segment, l3, u3, s3, o3);
        if (!p3) return null;
        let m3 = W2(e6 * f3, n4, r3, i3, a3.segment, l3, u3, s3, o3);
        return m3 ? s3.projectionCache.anyProjectionOccluded ? null : { first: p3, last: m3 } : null;
      }
      function U2(e6, n4, r3, i3) {
        return e6 === t4.as.horizontal && Math.abs(r3.y - n4.y) > Math.abs(r3.x - n4.x) * i3 ? { useVertical: true } : (e6 === t4.as.vertical ? n4.y < r3.y : n4.x > r3.x) ? { needsFlipping: true } : null;
      }
      function Qe2(e6) {
        let { projectionContext: n4, pitchedLabelPlaneMatrixInverse: r3, symbol: i3, fontSize: a3, flip: o3, keepUpright: s3, glyphOffsetArray: c3, dynamicLayoutVertexArray: l3, aspectRatio: u3, rotateToLine: d3 } = e6, f3 = a3 / 24, p3 = i3.lineOffsetX * f3, m3 = i3.lineOffsetY * f3, h3;
        if (i3.numGlyphs > 1) {
          let e7 = i3.glyphStartIndex + i3.numGlyphs, t5 = i3.lineStartIndex, a4 = i3.lineStartIndex + i3.lineLength, l4 = Ze2(f3, c3, p3, m3, o3, i3, d3, n4);
          if (!l4) return { notEnoughRoom: true };
          let g3 = nt2(l4.first.point.x, l4.first.point.y, n4, r3), _3 = nt2(l4.last.point.x, l4.last.point.y, n4, r3);
          if (s3 && !o3) {
            let e8 = U2(i3.writingMode, g3, _3, u3);
            if (e8) return e8;
          }
          h3 = [l4.first];
          for (let r4 = i3.glyphStartIndex + 1; r4 < e7 - 1; r4++) {
            let e8 = W2(f3 * c3.getoffsetX(r4), p3, m3, o3, i3.segment, t5, a4, n4, d3);
            if (!e8) return { notEnoughRoom: true };
            h3.push(e8);
          }
          h3.push(l4.last);
        } else {
          if (s3 && !o3) {
            let e8 = tt2(n4.tileAnchorPoint.x, n4.tileAnchorPoint.y, n4).point, a4 = i3.lineStartIndex + i3.segment + 1, o4 = new t4.P(n4.lineVertexArray.getx(a4), n4.lineVertexArray.gety(a4)), s4 = tt2(o4.x, o4.y, n4), c4 = s4.signedDistanceFromCamera > 0 ? s4.point : $e2(n4.tileAnchorPoint, o4, e8, 1, n4), l4 = nt2(e8.x, e8.y, n4, r3), d4 = nt2(c4.x, c4.y, n4, r3), f4 = U2(i3.writingMode, l4, d4, u3);
            if (f4) return f4;
          }
          let e7 = W2(f3 * c3.getoffsetX(i3.glyphStartIndex), p3, m3, o3, i3.segment, i3.lineStartIndex, i3.lineStartIndex + i3.lineLength, n4, d3);
          if (!e7 || n4.projectionCache.anyProjectionOccluded) return { notEnoughRoom: true };
          h3 = [e7];
        }
        for (let e7 of h3) t4.az(l3, e7.point, e7.angle);
        return {};
      }
      function $e2(e6, t5, n4, r3, i3) {
        let a3 = e6.add(e6.sub(t5)._unit()), o3 = tt2(a3.x, a3.y, i3).point, s3 = n4.sub(o3);
        return n4.add(s3._mult(r3 / s3.mag()));
      }
      function et2(e6, n4, r3) {
        let i3 = n4.projectionCache;
        if (i3.projections[e6]) return i3.projections[e6];
        let a3 = new t4.P(n4.lineVertexArray.getx(e6), n4.lineVertexArray.gety(e6)), o3 = tt2(a3.x, a3.y, n4);
        if (o3.signedDistanceFromCamera > 0) return i3.projections[e6] = o3.point, i3.anyProjectionOccluded = i3.anyProjectionOccluded || o3.isOccluded, o3.point;
        let s3 = e6 - r3.direction;
        return $e2(r3.distanceFromAnchor === 0 ? n4.tileAnchorPoint : new t4.P(n4.lineVertexArray.getx(s3), n4.lineVertexArray.gety(s3)), a3, r3.previousVertex, r3.absOffsetX - r3.distanceFromAnchor + 1, n4);
      }
      function tt2(e6, t5, n4) {
        let r3 = e6 + n4.translation[0], i3 = t5 + n4.translation[1], a3;
        return n4.pitchWithMap ? (a3 = V2(r3, i3, n4.pitchedLabelPlaneMatrix, n4.getElevation), a3.isOccluded = false) : (a3 = n4.transform.projectTileCoordinates(r3, i3, n4.unwrappedTileID, n4.getElevation), a3.point.x = (0.5 * a3.point.x + 0.5) * n4.width, a3.point.y = (0.5 * -a3.point.y + 0.5) * n4.height), a3;
      }
      function nt2(e6, n4, r3, i3) {
        if (r3.pitchWithMap) {
          let a3 = [e6, n4, 0, 1];
          return t4.aA(a3, a3, i3), r3.transform.projectTileCoordinates(a3[0] / a3[3], a3[1] / a3[3], r3.unwrappedTileID, r3.getElevation).point;
        }
        return { x: e6 / r3.width * 2 - 1, y: 1 - n4 / r3.height * 2 };
      }
      function rt2(e6, t5, n4) {
        return n4.transform.projectTileCoordinates(e6, t5, n4.unwrappedTileID, n4.getElevation);
      }
      function it2(e6, t5, n4) {
        return e6._unit()._perp()._mult(t5 * n4);
      }
      function at2(e6, n4, r3, i3, a3, o3, s3, c3, l3) {
        if (c3.projectionCache.offsets[e6]) return c3.projectionCache.offsets[e6];
        let u3 = r3.add(n4);
        if (e6 + l3.direction < i3 || e6 + l3.direction >= a3) return c3.projectionCache.offsets[e6] = u3, u3;
        let d3 = et2(e6 + l3.direction, c3, l3), f3 = it2(d3.sub(r3), s3, l3.direction), p3 = r3.add(f3), m3 = d3.add(f3);
        return c3.projectionCache.offsets[e6] = t4.aB(o3, u3, p3, m3) || u3, c3.projectionCache.offsets[e6];
      }
      function W2(e6, t5, n4, r3, i3, a3, o3, s3, c3) {
        let l3 = r3 ? e6 - t5 : e6 + t5, u3 = l3 > 0 ? 1 : -1, d3 = 0;
        r3 && (u3 *= -1, d3 = Math.PI), u3 < 0 && (d3 += Math.PI);
        let f3, p3 = u3 > 0 ? a3 + i3 : a3 + i3 + 1;
        s3.projectionCache.cachedAnchorPoint ? f3 = s3.projectionCache.cachedAnchorPoint : (f3 = tt2(s3.tileAnchorPoint.x, s3.tileAnchorPoint.y, s3).point, s3.projectionCache.cachedAnchorPoint = f3);
        let m3, h3, g3 = f3, _3 = f3, v3 = 0, y3 = 0, b3 = Math.abs(l3), x3 = [], S3;
        for (; v3 + y3 <= b3; ) {
          if (p3 += u3, p3 < a3 || p3 >= o3) return null;
          v3 += y3, _3 = g3, h3 = m3;
          let e7 = { absOffsetX: b3, direction: u3, distanceFromAnchor: v3, previousVertex: _3 };
          if (g3 = et2(p3, s3, e7), n4 === 0) x3.push(_3), S3 = g3.sub(_3);
          else {
            let t6, r4 = g3.sub(_3);
            t6 = r4.mag() === 0 ? it2(et2(p3 + u3, s3, e7).sub(g3), n4, u3) : it2(r4, n4, u3), h3 || (h3 = _3.add(t6)), m3 = at2(p3, t6, g3, a3, o3, h3, n4, s3, e7), x3.push(h3), S3 = m3.sub(h3);
          }
          y3 = S3.mag();
        }
        let C3 = S3._mult((b3 - v3) / y3)._add(h3 || _3), w3 = d3 + Math.atan2(g3.y - _3.y, g3.x - _3.x);
        return x3.push(C3), { point: C3, angle: c3 ? w3 : 0, path: x3 };
      }
      let ot2 = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function st2(e6, t5) {
        for (let n4 = 0; n4 < e6; n4++) {
          let e7 = t5.length;
          t5.resize(e7 + 4), t5.float32.set(ot2, 3 * e7);
        }
      }
      function ct2(e6, t5, n4) {
        let r3 = t5[0], i3 = t5[1];
        return e6[0] = n4[0] * r3 + n4[4] * i3 + n4[12], e6[1] = n4[1] * r3 + n4[5] * i3 + n4[13], e6[3] = n4[3] * r3 + n4[7] * i3 + n4[15], e6;
      }
      class lt2 {
        constructor(e6, t5 = new Ke2(e6.width + 200, e6.height + 200, 25), n4 = new Ke2(e6.width + 200, e6.height + 200, 25)) {
          this.transform = e6, this.grid = t5, this.ignoredGrid = n4, this.pitchFactor = Math.cos(e6.pitch * Math.PI / 180) * e6.cameraToCenterDistance, this.screenRightBoundary = e6.width + 100, this.screenBottomBoundary = e6.height + 100, this.gridRightBoundary = e6.width + 200, this.gridBottomBoundary = e6.height + 200, this.perspectiveRatioCutoff = 0.6;
        }
        placeCollisionBox(e6, t5, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3) {
          let f3 = this.projectAndGetPerspectiveRatio(e6.anchorPointX + s3[0], e6.anchorPointY + s3[1], i3, l3, d3), p3 = n4 * f3.perspectiveRatio, m3;
          if (a3 || o3) m3 = this._projectCollisionBox(e6, p3, r3, i3, a3, o3, s3, f3, l3, u3, d3);
          else {
            let t6 = f3.x + (u3 ? u3.x * p3 : 0), n5 = f3.y + (u3 ? u3.y * p3 : 0);
            m3 = { allPointsOccluded: false, box: [t6 + e6.x1 * p3, n5 + e6.y1 * p3, t6 + e6.x2 * p3, n5 + e6.y2 * p3] };
          }
          let [h3, g3, _3, v3] = m3.box, y3 = a3 ? m3.allPointsOccluded : f3.isOccluded, b3 = y3;
          return b3 || (b3 = f3.perspectiveRatio < this.perspectiveRatioCutoff), b3 || (b3 = !this.isInsideGrid(h3, g3, _3, v3)), b3 || t5 !== `always` && this.grid.hitTest(h3, g3, _3, v3, t5, c3) ? { box: [h3, g3, _3, v3], placeable: false, offscreen: false, occluded: y3 } : { box: [h3, g3, _3, v3], placeable: true, offscreen: this.isOffscreen(h3, g3, _3, v3), occluded: y3 };
        }
        placeCollisionCircles(e6, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3, p3, m3) {
          let h3 = [], g3 = new t4.P(n4.anchorX, n4.anchorY), _3 = this.getPerspectiveRatio(g3.x, g3.y, o3, m3), v3 = (l3 ? a3 * this.transform.getPitchedTextCorrection(n4.anchorX, n4.anchorY, o3) / _3 : a3 * _3) / t4.aF, y3 = { getElevation: m3, pitchedLabelPlaneMatrix: s3, lineVertexArray: r3, pitchWithMap: l3, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: this.transform, tileAnchorPoint: g3, unwrappedTileID: o3, width: this.transform.width, height: this.transform.height, translation: p3 }, b3 = Ze2(v3, i3, n4.lineOffsetX * v3, n4.lineOffsetY * v3, false, n4, false, y3), x3 = false, S3 = false, C3 = true;
          if (b3) {
            let n5 = 0.5 * d3 * _3 + f3, r4 = new t4.P(-100, -100), i4 = new t4.P(this.screenRightBoundary, this.screenBottomBoundary), a4 = new z2(), o4 = b3.first, s4 = b3.last, p4 = [];
            for (let e7 = o4.path.length - 1; e7 >= 1; e7--) p4.push(o4.path[e7]);
            for (let e7 = 1; e7 < s4.path.length; e7++) p4.push(s4.path[e7]);
            let m4 = 2.5 * n5;
            if (l3) {
              let e7 = this.projectPathToScreenSpace(p4, y3);
              p4 = e7.some(((e8) => e8.signedDistanceFromCamera <= 0)) ? [] : e7.map(((e8) => e8.point));
            }
            let g4 = [];
            if (p4.length > 0) {
              let e7 = p4[0].clone(), n6 = p4[0].clone();
              for (let t5 = 1; t5 < p4.length; t5++) e7.x = Math.min(e7.x, p4[t5].x), e7.y = Math.min(e7.y, p4[t5].y), n6.x = Math.max(n6.x, p4[t5].x), n6.y = Math.max(n6.y, p4[t5].y);
              g4 = e7.x >= r4.x && n6.x <= i4.x && e7.y >= r4.y && n6.y <= i4.y ? [p4] : n6.x < r4.x || e7.x > i4.x || n6.y < r4.y || e7.y > i4.y ? [] : t4.aC([p4], r4.x, r4.y, i4.x, i4.y);
            }
            for (let t5 of g4) {
              a4.reset(t5, 0.25 * n5);
              let r5 = 0;
              r5 = a4.length <= 0.5 * n5 ? 1 : Math.ceil(a4.paddedLength / m4) + 1;
              for (let t6 = 0; t6 < r5; t6++) {
                let i5 = t6 / Math.max(r5 - 1, 1), o5 = a4.lerp(i5), s5 = o5.x + 100, l4 = o5.y + 100;
                h3.push(s5, l4, n5, 0);
                let d4 = s5 - n5, f4 = l4 - n5, p5 = s5 + n5, m5 = l4 + n5;
                if (C3 && (C3 = this.isOffscreen(d4, f4, p5, m5)), S3 || (S3 = this.isInsideGrid(d4, f4, p5, m5)), e6 !== `always` && this.grid.hitTestCircle(s5, l4, n5, e6, u3) && (x3 = true, !c3)) return { circles: [], offscreen: false, collisionDetected: x3 };
              }
            }
          }
          return { circles: !c3 && x3 || !S3 || _3 < this.perspectiveRatioCutoff ? [] : h3, offscreen: C3, collisionDetected: x3 };
        }
        projectPathToScreenSpace(e6, n4) {
          return (function(e7) {
            let t5 = 0, n5 = 0, r3 = 0, i3 = 0;
            for (let a3 = 0; a3 < e7.length; a3++) e7[a3].isOccluded ? (r3 = a3 + 1, i3 = 0) : (i3++, i3 > n5 && (n5 = i3, t5 = r3));
            return e7.slice(t5, t5 + n5);
          })((function(e7, n5) {
            let r3 = t4.M();
            return t4.au(r3, n5.pitchedLabelPlaneMatrix), e7.map(((e8) => {
              let t5 = V2(e8.x, e8.y, r3, n5.getElevation), i3 = n5.transform.projectTileCoordinates(t5.point.x, t5.point.y, n5.unwrappedTileID, n5.getElevation);
              return i3.point.x = (0.5 * i3.point.x + 0.5) * n5.width, i3.point.y = (0.5 * -i3.point.y + 0.5) * n5.height, i3;
            }));
          })(e6, n4));
        }
        queryRenderedSymbols(e6) {
          if (e6.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
          let n4 = [], r3 = new t4.a6();
          for (let i4 of e6) {
            let e7 = new t4.P(i4.x + 100, i4.y + 100);
            r3.extend(e7), n4.push(e7);
          }
          let { minX: i3, minY: a3, maxX: o3, maxY: s3 } = r3, c3 = this.grid.query(i3, a3, o3, s3).concat(this.ignoredGrid.query(i3, a3, o3, s3)), l3 = {}, u3 = {};
          for (let e7 of c3) {
            let r4 = e7.key;
            if (l3[r4.bucketInstanceId] === void 0 && (l3[r4.bucketInstanceId] = {}), l3[r4.bucketInstanceId][r4.featureIndex]) continue;
            let i4 = [new t4.P(e7.x1, e7.y1), new t4.P(e7.x2, e7.y1), new t4.P(e7.x2, e7.y2), new t4.P(e7.x1, e7.y2)];
            t4.aD(n4, i4) && (l3[r4.bucketInstanceId][r4.featureIndex] = true, u3[r4.bucketInstanceId] === void 0 && (u3[r4.bucketInstanceId] = []), u3[r4.bucketInstanceId].push(r4.featureIndex));
          }
          return u3;
        }
        insertCollisionBox(e6, t5, n4, r3, i3, a3) {
          (n4 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: r3, featureIndex: i3, collisionGroupID: a3, overlapMode: t5 }, e6[0], e6[1], e6[2], e6[3]);
        }
        insertCollisionCircles(e6, t5, n4, r3, i3, a3) {
          let o3 = n4 ? this.ignoredGrid : this.grid, s3 = { bucketInstanceId: r3, featureIndex: i3, collisionGroupID: a3, overlapMode: t5 };
          for (let t6 = 0; t6 < e6.length; t6 += 4) o3.insertCircle(s3, e6[t6], e6[t6 + 1], e6[t6 + 2]);
        }
        projectAndGetPerspectiveRatio(e6, n4, r3, i3, a3) {
          if (a3) {
            let r4;
            i3 ? (r4 = [e6, n4, i3(e6, n4), 1], t4.aA(r4, r4, a3)) : (r4 = [e6, n4, 0, 1], ct2(r4, r4, a3));
            let o3 = r4[3];
            return { x: (r4[0] / o3 + 1) / 2 * this.transform.width + 100, y: (-r4[1] / o3 + 1) / 2 * this.transform.height + 100, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / o3 * 0.5, isOccluded: false, signedDistanceFromCamera: o3 };
          }
          {
            let t5 = this.transform.projectTileCoordinates(e6, n4, r3, i3);
            return { x: (t5.point.x + 1) / 2 * this.transform.width + 100, y: (1 - t5.point.y) / 2 * this.transform.height + 100, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / t5.signedDistanceFromCamera * 0.5, isOccluded: t5.isOccluded, signedDistanceFromCamera: t5.signedDistanceFromCamera };
          }
        }
        getPerspectiveRatio(e6, t5, n4, r3) {
          let i3 = this.transform.projectTileCoordinates(e6, t5, n4, r3);
          return 0.5 + this.transform.cameraToCenterDistance / i3.signedDistanceFromCamera * 0.5;
        }
        isOffscreen(e6, t5, n4, r3) {
          return n4 < 100 || e6 >= this.screenRightBoundary || r3 < 100 || t5 > this.screenBottomBoundary;
        }
        isInsideGrid(e6, t5, n4, r3) {
          return n4 >= 0 && e6 < this.gridRightBoundary && r3 >= 0 && t5 < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          let e6 = t4.am([]);
          return t4.N(e6, e6, [-100, -100, 0]), e6;
        }
        _projectCollisionBox(e6, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3) {
          let f3 = 1, p3 = 0, m3 = 0, h3 = 1, g3 = e6.anchorPointX + s3[0], _3 = e6.anchorPointY + s3[1];
          if (o3 && !a3) {
            let e7 = this.projectAndGetPerspectiveRatio(g3 + 1, _3, i3, l3, d3), t5 = e7.x - c3.x, n5 = Math.atan((e7.y - c3.y) / t5) + (t5 < 0 ? Math.PI : 0), r4 = Math.sin(n5), a4 = Math.cos(n5);
            f3 = a4, p3 = r4, m3 = -r4, h3 = a4;
          } else if (!o3 && a3) {
            let e7 = B2(this.transform);
            f3 = e7.vecEast[0], p3 = e7.vecEast[1], m3 = e7.vecSouth[0], h3 = e7.vecSouth[1];
          }
          let v3 = c3.x, y3 = c3.y, b3 = n4;
          a3 && (v3 = g3, y3 = _3, b3 = 2 ** -(this.transform.zoom - r3.overscaledZ), b3 *= this.transform.getPitchedTextCorrection(g3, _3, i3), u3 || (b3 *= t4.ai(0.5 + c3.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), u3 && (v3 += f3 * u3.x * b3 + m3 * u3.y * b3, y3 += p3 * u3.x * b3 + h3 * u3.y * b3);
          let x3 = e6.x1 * b3, S3 = e6.x2 * b3, C3 = (x3 + S3) / 2, w3 = e6.y1 * b3, T3 = e6.y2 * b3, E3 = (w3 + T3) / 2, D3 = [{ offsetX: x3, offsetY: w3 }, { offsetX: C3, offsetY: w3 }, { offsetX: S3, offsetY: w3 }, { offsetX: S3, offsetY: E3 }, { offsetX: S3, offsetY: T3 }, { offsetX: C3, offsetY: T3 }, { offsetX: x3, offsetY: T3 }, { offsetX: x3, offsetY: E3 }], O3 = [];
          for (let { offsetX: e7, offsetY: n5 } of D3) O3.push(new t4.P(v3 + f3 * e7 + m3 * n5, y3 + p3 * e7 + h3 * n5));
          let k3 = false;
          if (a3) {
            let e7 = O3.map(((e8) => this.projectAndGetPerspectiveRatio(e8.x, e8.y, i3, l3, d3)));
            k3 = e7.some(((e8) => !e8.isOccluded)), O3 = e7.map(((e8) => new t4.P(e8.x, e8.y)));
          } else k3 = true;
          return { box: t4.aE(O3), allPointsOccluded: !k3 };
        }
      }
      class ut2 {
        constructor(e6, t5, n4, r3) {
          this.opacity = e6 ? Math.max(0, Math.min(1, e6.opacity + (e6.placed ? t5 : -t5))) : r3 && n4 ? 1 : 0, this.placed = n4;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }
      class dt2 {
        constructor(e6, t5, n4, r3, i3) {
          this.text = new ut2(e6 ? e6.text : null, t5, n4, i3), this.icon = new ut2(e6 ? e6.icon : null, t5, r3, i3);
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class ft2 {
        constructor(e6, t5, n4) {
          this.text = e6, this.icon = t5, this.skipFade = n4;
        }
      }
      class pt2 {
        constructor(e6, t5, n4, r3, i3) {
          this.bucketInstanceId = e6, this.featureIndex = t5, this.sourceLayerIndex = n4, this.bucketIndex = r3, this.tileID = i3;
        }
      }
      class mt2 {
        constructor(e6) {
          this.crossSourceCollisions = e6, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(e6) {
          if (this.crossSourceCollisions) return { ID: 0, predicate: null };
          if (!this.collisionGroups[e6]) {
            let t5 = ++this.maxGroupID;
            this.collisionGroups[e6] = { ID: t5, predicate: (e7) => e7.collisionGroupID === t5 };
          }
          return this.collisionGroups[e6];
        }
      }
      function ht2(e6, n4, r3, i3, a3) {
        let { horizontalAlign: o3, verticalAlign: s3 } = t4.aL(e6);
        return new t4.P(-(o3 - 0.5) * n4 + i3[0] * a3, -(s3 - 0.5) * r3 + i3[1] * a3);
      }
      class gt2 {
        constructor(e6, t5, n4, r3, i3) {
          this.transform = e6.clone(), this.terrain = t5, this.collisionIndex = new lt2(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = n4, this.retainedQueryData = {}, this.collisionGroups = new mt2(r3), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = i3, i3 && (i3.prevPlacement = void 0), this.placedOrientations = {};
        }
        _getTerrainElevationFunc(e6) {
          let t5 = this.terrain;
          return t5 ? (n4, r3) => t5.getElevation(e6, n4, r3) : null;
        }
        getBucketParts(e6, n4, r3, i3) {
          let a3 = r3.getBucket(n4), o3 = r3.latestFeatureIndex;
          if (!a3 || !o3 || n4.id !== a3.layerIds[0]) return;
          let s3 = r3.collisionBoxArray, c3 = a3.layers[0].layout, l3 = a3.layers[0].paint, u3 = 2 ** (this.transform.zoom - r3.tileID.overscaledZ), d3 = r3.tileSize / t4.a3, f3 = r3.tileID.toUnwrapped(), p3 = c3.get(`text-rotation-alignment`) === `map`, m3 = t4.aG(r3, 1, this.transform.zoom), h3 = t4.aH(this.collisionIndex.transform, r3, l3.get(`text-translate`), l3.get(`text-translate-anchor`)), g3 = t4.aH(this.collisionIndex.transform, r3, l3.get(`icon-translate`), l3.get(`icon-translate-anchor`)), _3 = qe2(p3, this.transform, m3);
          this.retainedQueryData[a3.bucketInstanceId] = new pt2(a3.bucketInstanceId, o3, a3.sourceLayerIndex, a3.index, r3.tileID);
          let v3 = { bucket: a3, layout: c3, translationText: h3, translationIcon: g3, unwrappedTileID: f3, pitchedLabelPlaneMatrix: _3, scale: u3, textPixelRatio: d3, holdingForFade: r3.holdingForSymbolFade(), collisionBoxArray: s3, partiallyEvaluatedTextSize: t4.ar(a3.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(a3.sourceID) };
          if (i3) for (let t5 of a3.sortKeyRanges) {
            let { sortKey: n5, symbolInstanceStart: r4, symbolInstanceEnd: i4 } = t5;
            e6.push({ sortKey: n5, symbolInstanceStart: r4, symbolInstanceEnd: i4, parameters: v3 });
          }
          else e6.push({ symbolInstanceStart: 0, symbolInstanceEnd: a3.symbolInstances.length, parameters: v3 });
        }
        attemptAnchorPlacement(e6, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3, p3, m3, h3, g3, _3, v3, y3, b3) {
          let x3 = t4.aI[e6.textAnchor], S3 = [e6.textOffset0, e6.textOffset1], C3 = ht2(x3, r3, i3, S3, a3), w3 = this.collisionIndex.placeCollisionBox(n4, f3, c3, l3, u3, s3, o3, g3, d3.predicate, y3, C3, b3);
          if ((!v3 || this.collisionIndex.placeCollisionBox(v3, f3, c3, l3, u3, s3, o3, _3, d3.predicate, y3, C3, b3).placeable) && w3.placeable) {
            let e7;
            if (this.prevPlacement && this.prevPlacement.variableOffsets[p3.crossTileID] && this.prevPlacement.placements[p3.crossTileID] && this.prevPlacement.placements[p3.crossTileID].text && (e7 = this.prevPlacement.variableOffsets[p3.crossTileID].anchor), p3.crossTileID === 0) throw Error(`symbolInstance.crossTileID can't be 0`);
            return this.variableOffsets[p3.crossTileID] = { textOffset: S3, width: r3, height: i3, anchor: x3, textBoxScale: a3, prevAnchor: e7 }, this.markUsedJustification(m3, x3, p3, h3), m3.allowVerticalPlacement && (this.markUsedOrientation(m3, h3, p3), this.placedOrientations[p3.crossTileID] = h3), { shift: C3, placedGlyphBoxes: w3 };
          }
        }
        placeLayerBucketPart(e6, n4, r3) {
          let { bucket: i3, layout: a3, translationText: o3, translationIcon: s3, unwrappedTileID: c3, pitchedLabelPlaneMatrix: l3, textPixelRatio: u3, holdingForFade: d3, collisionBoxArray: f3, partiallyEvaluatedTextSize: p3, collisionGroup: m3 } = e6.parameters, h3 = a3.get(`text-optional`), g3 = a3.get(`icon-optional`), _3 = t4.aJ(a3, `text-overlap`, `text-allow-overlap`), v3 = _3 === `always`, y3 = t4.aJ(a3, `icon-overlap`, `icon-allow-overlap`), b3 = y3 === `always`, x3 = a3.get(`text-rotation-alignment`) === `map`, S3 = a3.get(`text-pitch-alignment`) === `map`, C3 = a3.get(`icon-text-fit`) !== `none`, w3 = a3.get(`symbol-z-order`) === `viewport-y`, T3 = v3 && (b3 || !i3.hasIconData() || g3), E3 = b3 && (v3 || !i3.hasTextData() || h3);
          !i3.collisionArrays && f3 && i3.deserializeCollisionBoxes(f3);
          let D3 = this.retainedQueryData[i3.bucketInstanceId].tileID, O3 = this._getTerrainElevationFunc(D3), k3 = this.transform.getFastPathSimpleProjectionMatrix(D3), A3 = (e7, f4, b4) => {
            var _a3, _b2;
            if (n4[e7.crossTileID]) return;
            if (d3) return void (this.placements[e7.crossTileID] = new ft2(false, false, false));
            let w4 = false, A4 = false, ee3 = true, j3 = null, M3 = { box: null, placeable: false, offscreen: null, occluded: false }, te3 = { placeable: false }, N3 = null, ne3 = null, P3 = null, re3 = 0, ie3 = 0, ae3 = 0;
            f4.textFeatureIndex ? re3 = f4.textFeatureIndex : e7.useRuntimeCollisionCircles && (re3 = e7.featureIndex), f4.verticalTextFeatureIndex && (ie3 = f4.verticalTextFeatureIndex);
            let oe3 = f4.textBox;
            if (oe3) {
              let n5 = (n6) => {
                let r4 = t4.as.horizontal;
                if (i3.allowVerticalPlacement && !n6 && this.prevPlacement) {
                  let t5 = this.prevPlacement.placedOrientations[e7.crossTileID];
                  t5 && (this.placedOrientations[e7.crossTileID] = t5, r4 = t5, this.markUsedOrientation(i3, r4, e7));
                }
                return r4;
              }, a4 = (n6, r4) => {
                if (i3.allowVerticalPlacement && e7.numVerticalGlyphVertices > 0 && f4.verticalTextBox) {
                  for (let e8 of i3.writingModes) if (e8 === t4.as.vertical ? (M3 = r4(), te3 = M3) : M3 = n6(), M3 && M3.placeable) break;
                } else M3 = n6();
              }, l4 = e7.textAnchorOffsetStartIndex, d4 = e7.textAnchorOffsetEndIndex;
              if (d4 === l4) {
                let r4 = (t5, n6) => {
                  let r5 = this.collisionIndex.placeCollisionBox(t5, _3, u3, D3, c3, S3, x3, o3, m3.predicate, O3, void 0, k3);
                  return r5 && r5.placeable && (this.markUsedOrientation(i3, n6, e7), this.placedOrientations[e7.crossTileID] = n6), r5;
                };
                a4((() => r4(oe3, t4.as.horizontal)), (() => {
                  let n6 = f4.verticalTextBox;
                  return i3.allowVerticalPlacement && e7.numVerticalGlyphVertices > 0 && n6 ? r4(n6, t4.as.vertical) : { box: null, offscreen: null };
                })), n5(M3 && M3.placeable);
              } else {
                let p4 = t4.aI[(_b2 = (_a3 = this.prevPlacement) == null ? void 0 : _a3.variableOffsets[e7.crossTileID]) == null ? void 0 : _b2.anchor], h4 = (t5, n6, a5) => {
                  let f5 = t5.x2 - t5.x1, h5 = t5.y2 - t5.y1, g5 = e7.textBoxScale, v4 = C3 && y3 === `never` ? n6 : null, b5 = null, T4 = _3 === `never` ? 1 : 2, E4 = `never`;
                  p4 && T4++;
                  for (let n7 = 0; n7 < T4; n7++) {
                    for (let n8 = l4; n8 < d4; n8++) {
                      let r4 = i3.textAnchorOffsets.get(n8);
                      if (p4 && r4.textAnchor !== p4) continue;
                      let l5 = this.attemptAnchorPlacement(r4, t5, f5, h5, g5, x3, S3, u3, D3, c3, m3, E4, e7, i3, a5, o3, s3, v4, O3);
                      if (l5 && (b5 = l5.placedGlyphBoxes, b5 && b5.placeable)) return w4 = true, j3 = l5.shift, b5;
                    }
                    p4 ? p4 = null : E4 = _3;
                  }
                  return r3 && !b5 && (b5 = { box: this.collisionIndex.placeCollisionBox(oe3, `always`, u3, D3, c3, S3, x3, o3, m3.predicate, O3, void 0, k3).box, offscreen: false, placeable: false, occluded: false }), b5;
                };
                a4((() => h4(oe3, f4.iconBox, t4.as.horizontal)), (() => {
                  let n6 = f4.verticalTextBox;
                  return i3.allowVerticalPlacement && (!M3 || !M3.placeable) && e7.numVerticalGlyphVertices > 0 && n6 ? h4(n6, f4.verticalIconBox, t4.as.vertical) : { box: null, occluded: true, offscreen: null };
                })), M3 && (w4 = M3.placeable, ee3 = M3.offscreen);
                let g4 = n5(M3 && M3.placeable);
                if (!w4 && this.prevPlacement) {
                  let t5 = this.prevPlacement.variableOffsets[e7.crossTileID];
                  t5 && (this.variableOffsets[e7.crossTileID] = t5, this.markUsedJustification(i3, t5.anchor, e7, g4));
                }
              }
            }
            if (N3 = M3, w4 = N3 && N3.placeable, ee3 = N3 && N3.offscreen, e7.useRuntimeCollisionCircles && e7.centerJustifiedTextSymbolIndex >= 0) {
              let n5 = i3.text.placedSymbolArray.get(e7.centerJustifiedTextSymbolIndex), s4 = t4.at(i3.textSizeData, p3, n5), u4 = a3.get(`text-padding`);
              ne3 = this.collisionIndex.placeCollisionCircles(_3, n5, i3.lineVertexArray, i3.glyphOffsetArray, s4, c3, l3, r3, S3, m3.predicate, e7.collisionCircleDiameter, u4, o3, O3), ne3.circles.length && ne3.collisionDetected && !r3 && t4.w(`Collisions detected, but collision boxes are not shown`), w4 = v3 || ne3.circles.length > 0 && !ne3.collisionDetected, ee3 && (ee3 = ne3.offscreen);
            }
            if (f4.iconFeatureIndex && (ae3 = f4.iconFeatureIndex), f4.iconBox) {
              let e8 = (e9) => this.collisionIndex.placeCollisionBox(e9, y3, u3, D3, c3, S3, x3, s3, m3.predicate, O3, C3 && j3 ? j3 : void 0, k3);
              te3 && te3.placeable && f4.verticalIconBox ? (P3 = e8(f4.verticalIconBox), A4 = P3.placeable) : (P3 = e8(f4.iconBox), A4 = P3.placeable), ee3 && (ee3 = P3.offscreen);
            }
            let se3 = h3 || e7.numHorizontalGlyphVertices === 0 && e7.numVerticalGlyphVertices === 0, F3 = g3 || e7.numIconVertices === 0;
            se3 || F3 ? F3 ? se3 || A4 && (A4 = w4) : w4 = A4 && w4 : A4 = w4 = A4 && w4;
            let ce3 = A4 && P3.placeable;
            if (w4 && N3.placeable && this.collisionIndex.insertCollisionBox(N3.box, _3, a3.get(`text-ignore-placement`), i3.bucketInstanceId, te3 && te3.placeable && ie3 ? ie3 : re3, m3.ID), ce3 && this.collisionIndex.insertCollisionBox(P3.box, y3, a3.get(`icon-ignore-placement`), i3.bucketInstanceId, ae3, m3.ID), ne3 && w4 && this.collisionIndex.insertCollisionCircles(ne3.circles, _3, a3.get(`text-ignore-placement`), i3.bucketInstanceId, re3, m3.ID), r3 && this.storeCollisionData(i3.bucketInstanceId, b4, f4, N3, P3, ne3), e7.crossTileID === 0) throw Error(`symbolInstance.crossTileID can't be 0`);
            if (i3.bucketInstanceId === 0) throw Error(`bucket.bucketInstanceId can't be 0`);
            this.placements[e7.crossTileID] = new ft2((w4 || T3) && !(N3 == null ? void 0 : N3.occluded), (A4 || E3) && !(P3 == null ? void 0 : P3.occluded), ee3 || i3.justReloaded), n4[e7.crossTileID] = true;
          };
          if (w3) {
            if (e6.symbolInstanceStart !== 0) throw Error(`bucket.bucketInstanceId should be 0`);
            let t5 = i3.getSortedSymbolIndexes(-this.transform.bearingInRadians);
            for (let e7 = t5.length - 1; e7 >= 0; --e7) {
              let n5 = t5[e7];
              A3(i3.symbolInstances.get(n5), i3.collisionArrays[n5], n5);
            }
          } else for (let t5 = e6.symbolInstanceStart; t5 < e6.symbolInstanceEnd; t5++) A3(i3.symbolInstances.get(t5), i3.collisionArrays[t5], t5);
          i3.justReloaded = false;
        }
        storeCollisionData(e6, t5, n4, r3, i3, a3) {
          if (n4.textBox || n4.iconBox) {
            let a4, o3;
            this.collisionBoxArrays.has(e6) ? a4 = this.collisionBoxArrays.get(e6) : (a4 = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e6, a4)), a4.has(t5) ? o3 = a4.get(t5) : (o3 = { text: null, icon: null }, a4.set(t5, o3)), n4.textBox && (o3.text = r3.box), n4.iconBox && (o3.icon = i3.box);
          }
          if (a3) {
            let t6 = this.collisionCircleArrays[e6];
            t6 === void 0 && (t6 = this.collisionCircleArrays[e6] = []);
            for (let e7 = 0; e7 < a3.circles.length; e7 += 4) t6.push(a3.circles[e7 + 0] - 100), t6.push(a3.circles[e7 + 1] - 100), t6.push(a3.circles[e7 + 2]), t6.push(a3.collisionDetected ? 1 : 0);
          }
        }
        markUsedJustification(e6, n4, r3, i3) {
          let a3;
          a3 = i3 === t4.as.vertical ? r3.verticalPlacedTextSymbolIndex : { left: r3.leftJustifiedTextSymbolIndex, center: r3.centerJustifiedTextSymbolIndex, right: r3.rightJustifiedTextSymbolIndex }[t4.aK(n4)];
          let o3 = [r3.leftJustifiedTextSymbolIndex, r3.centerJustifiedTextSymbolIndex, r3.rightJustifiedTextSymbolIndex, r3.verticalPlacedTextSymbolIndex];
          for (let t5 of o3) t5 >= 0 && (e6.text.placedSymbolArray.get(t5).crossTileID = a3 >= 0 && t5 !== a3 ? 0 : r3.crossTileID);
        }
        markUsedOrientation(e6, n4, r3) {
          let i3 = n4 === t4.as.horizontal || n4 === t4.as.horizontalOnly ? n4 : 0, a3 = n4 === t4.as.vertical ? n4 : 0, o3 = [r3.leftJustifiedTextSymbolIndex, r3.centerJustifiedTextSymbolIndex, r3.rightJustifiedTextSymbolIndex];
          for (let t5 of o3) e6.text.placedSymbolArray.get(t5).placedOrientation = i3;
          r3.verticalPlacedTextSymbolIndex && (e6.text.placedSymbolArray.get(r3.verticalPlacedTextSymbolIndex).placedOrientation = a3);
        }
        commit(e6) {
          this.commitTime = e6, this.zoomAtLastRecencyCheck = this.transform.zoom;
          let t5 = this.prevPlacement, n4 = false;
          this.prevZoomAdjustment = t5 ? t5.zoomAdjustment(this.transform.zoom) : 0;
          let r3 = t5 ? t5.symbolFadeChange(e6) : 1, i3 = t5 ? t5.opacities : {}, a3 = t5 ? t5.variableOffsets : {}, o3 = t5 ? t5.placedOrientations : {};
          for (let e7 in this.placements) {
            let t6 = this.placements[e7], a4 = i3[e7];
            a4 ? (this.opacities[e7] = new dt2(a4, r3, t6.text, t6.icon), n4 = n4 || t6.text !== a4.text.placed || t6.icon !== a4.icon.placed) : (this.opacities[e7] = new dt2(null, r3, t6.text, t6.icon, t6.skipFade), n4 = n4 || t6.text || t6.icon);
          }
          for (let e7 in i3) {
            let t6 = i3[e7];
            if (!this.opacities[e7]) {
              let i4 = new dt2(t6, r3, false, false);
              i4.isHidden() || (this.opacities[e7] = i4, n4 = n4 || t6.text.placed || t6.icon.placed);
            }
          }
          for (let e7 in a3) this.variableOffsets[e7] || !this.opacities[e7] || this.opacities[e7].isHidden() || (this.variableOffsets[e7] = a3[e7]);
          for (let e7 in o3) this.placedOrientations[e7] || !this.opacities[e7] || this.opacities[e7].isHidden() || (this.placedOrientations[e7] = o3[e7]);
          if (t5 && t5.lastPlacementChangeTime === void 0) throw Error(`Last placement time for previous placement is not defined`);
          n4 ? this.lastPlacementChangeTime = e6 : typeof this.lastPlacementChangeTime != `number` && (this.lastPlacementChangeTime = t5 ? t5.lastPlacementChangeTime : e6);
        }
        updateLayerOpacities(e6, t5) {
          let n4 = {};
          for (let r3 of t5) {
            let t6 = r3.getBucket(e6);
            t6 && r3.latestFeatureIndex && e6.id === t6.layerIds[0] && this.updateBucketOpacities(t6, r3.tileID, n4, r3.collisionBoxArray);
          }
        }
        updateBucketOpacities(e6, n4, r3, i3) {
          e6.hasTextData() && (e6.text.opacityVertexArray.clear(), e6.text.hasVisibleVertices = false), e6.hasIconData() && (e6.icon.opacityVertexArray.clear(), e6.icon.hasVisibleVertices = false), e6.hasIconCollisionBoxData() && e6.iconCollisionBox.collisionVertexArray.clear(), e6.hasTextCollisionBoxData() && e6.textCollisionBox.collisionVertexArray.clear();
          let a3 = e6.layers[0], o3 = a3.layout, s3 = new dt2(null, 0, false, false, true), c3 = o3.get(`text-allow-overlap`), l3 = o3.get(`icon-allow-overlap`), u3 = a3._unevaluatedLayout.hasValue(`text-variable-anchor`) || a3._unevaluatedLayout.hasValue(`text-variable-anchor-offset`), d3 = o3.get(`text-rotation-alignment`) === `map`, f3 = o3.get(`text-pitch-alignment`) === `map`, p3 = o3.get(`icon-text-fit`) !== `none`, m3 = new dt2(null, 0, c3 && (l3 || !e6.hasIconData() || o3.get(`icon-optional`)), l3 && (c3 || !e6.hasTextData() || o3.get(`text-optional`)), true);
          !e6.collisionArrays && i3 && (e6.hasIconCollisionBoxData() || e6.hasTextCollisionBoxData()) && e6.deserializeCollisionBoxes(i3);
          let h3 = (e7, t5, n5) => {
            for (let r4 = 0; r4 < t5 / 4; r4++) e7.opacityVertexArray.emplaceBack(n5);
            e7.hasVisibleVertices = e7.hasVisibleVertices || n5 !== Ct2;
          }, g3 = this.collisionBoxArrays.get(e6.bucketInstanceId);
          for (let n5 = 0; n5 < e6.symbolInstances.length; n5++) {
            let i4 = e6.symbolInstances.get(n5), { numHorizontalGlyphVertices: a4, numVerticalGlyphVertices: o4, crossTileID: c4 } = i4, l4 = this.opacities[c4];
            r3[c4] ? l4 = s3 : l4 || (l4 = m3, this.opacities[c4] = l4), r3[c4] = true;
            let _3 = i4.numIconVertices > 0, v3 = this.placedOrientations[i4.crossTileID], y3 = v3 === t4.as.vertical, b3 = v3 === t4.as.horizontal || v3 === t4.as.horizontalOnly;
            if (a4 > 0 || o4 > 0) {
              let t5 = St2(l4.text);
              h3(e6.text, a4, y3 ? Ct2 : t5), h3(e6.text, o4, b3 ? Ct2 : t5);
              let n6 = l4.text.isHidden();
              [i4.rightJustifiedTextSymbolIndex, i4.centerJustifiedTextSymbolIndex, i4.leftJustifiedTextSymbolIndex].forEach(((t6) => {
                t6 >= 0 && (e6.text.placedSymbolArray.get(t6).hidden = n6 || y3 ? 1 : 0);
              })), i4.verticalPlacedTextSymbolIndex >= 0 && (e6.text.placedSymbolArray.get(i4.verticalPlacedTextSymbolIndex).hidden = n6 || b3 ? 1 : 0);
              let r4 = this.variableOffsets[i4.crossTileID];
              r4 && this.markUsedJustification(e6, r4.anchor, i4, v3);
              let s4 = this.placedOrientations[i4.crossTileID];
              s4 && (this.markUsedJustification(e6, `left`, i4, s4), this.markUsedOrientation(e6, s4, i4));
            }
            if (_3) {
              let t5 = St2(l4.icon), n6 = !(p3 && i4.verticalPlacedIconSymbolIndex && y3);
              i4.placedIconSymbolIndex >= 0 && (h3(e6.icon, i4.numIconVertices, n6 ? t5 : Ct2), e6.icon.placedSymbolArray.get(i4.placedIconSymbolIndex).hidden = l4.icon.isHidden()), i4.verticalPlacedIconSymbolIndex >= 0 && (h3(e6.icon, i4.numVerticalIconVertices, n6 ? Ct2 : t5), e6.icon.placedSymbolArray.get(i4.verticalPlacedIconSymbolIndex).hidden = l4.icon.isHidden());
            }
            let x3 = g3 && g3.has(n5) ? g3.get(n5) : { text: null, icon: null };
            if (e6.hasIconCollisionBoxData() || e6.hasTextCollisionBoxData()) {
              let r4 = e6.collisionArrays[n5];
              if (r4) {
                let n6 = new t4.P(0, 0);
                if (r4.textBox || r4.verticalTextBox) {
                  let t5 = true;
                  if (u3) {
                    let e7 = this.variableOffsets[c4];
                    e7 ? (n6 = ht2(e7.anchor, e7.width, e7.height, e7.textOffset, e7.textBoxScale), d3 && n6._rotate(f3 ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : t5 = false;
                  }
                  if (r4.textBox || r4.verticalTextBox) {
                    let i5;
                    r4.textBox && (i5 = y3), r4.verticalTextBox && (i5 = b3), _t2(e6.textCollisionBox.collisionVertexArray, l4.text.placed, !t5 || i5, x3.text, n6.x, n6.y);
                  }
                }
                if (r4.iconBox || r4.verticalIconBox) {
                  let t5 = !!(!b3 && r4.verticalIconBox), i5;
                  r4.iconBox && (i5 = t5), r4.verticalIconBox && (i5 = !t5), _t2(e6.iconCollisionBox.collisionVertexArray, l4.icon.placed, i5, x3.icon, p3 ? n6.x : 0, p3 ? n6.y : 0);
                }
              }
            }
          }
          if (e6.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e6.bucketInstanceId] && (this.retainedQueryData[e6.bucketInstanceId].featureSortOrder = e6.featureSortOrder), e6.hasTextData() && e6.text.opacityVertexBuffer && e6.text.opacityVertexBuffer.updateData(e6.text.opacityVertexArray), e6.hasIconData() && e6.icon.opacityVertexBuffer && e6.icon.opacityVertexBuffer.updateData(e6.icon.opacityVertexArray), e6.hasIconCollisionBoxData() && e6.iconCollisionBox.collisionVertexBuffer && e6.iconCollisionBox.collisionVertexBuffer.updateData(e6.iconCollisionBox.collisionVertexArray), e6.hasTextCollisionBoxData() && e6.textCollisionBox.collisionVertexBuffer && e6.textCollisionBox.collisionVertexBuffer.updateData(e6.textCollisionBox.collisionVertexArray), e6.text.opacityVertexArray.length !== e6.text.layoutVertexArray.length / 4) throw Error(`bucket.text.opacityVertexArray.length (= ${e6.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e6.text.layoutVertexArray.length}) / 4`);
          if (e6.icon.opacityVertexArray.length !== e6.icon.layoutVertexArray.length / 4) throw Error(`bucket.icon.opacityVertexArray.length (= ${e6.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e6.icon.layoutVertexArray.length}) / 4`);
          e6.bucketInstanceId in this.collisionCircleArrays && (e6.collisionCircleArray = this.collisionCircleArrays[e6.bucketInstanceId], delete this.collisionCircleArrays[e6.bucketInstanceId]);
        }
        symbolFadeChange(e6) {
          return this.fadeDuration === 0 ? 1 : (e6 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(e6) {
          return Math.max(0, (this.transform.zoom - e6) / 1.5);
        }
        hasTransitions(e6) {
          return this.stale || e6 - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(e6, t5) {
          let n4 = this.zoomAtLastRecencyCheck === t5 ? 1 - this.zoomAdjustment(t5) : 1;
          return this.zoomAtLastRecencyCheck = t5, this.commitTime + this.fadeDuration * n4 > e6;
        }
        setStale() {
          this.stale = true;
        }
      }
      function _t2(e6, t5, n4, r3, i3, a3) {
        r3 && r3.length !== 0 || (r3 = [0, 0, 0, 0]);
        let o3 = r3[0] - 100, s3 = r3[1] - 100, c3 = r3[2] - 100, l3 = r3[3] - 100;
        e6.emplaceBack(t5 ? 1 : 0, n4 ? 1 : 0, i3 || 0, a3 || 0, o3, s3), e6.emplaceBack(t5 ? 1 : 0, n4 ? 1 : 0, i3 || 0, a3 || 0, c3, s3), e6.emplaceBack(t5 ? 1 : 0, n4 ? 1 : 0, i3 || 0, a3 || 0, c3, l3), e6.emplaceBack(t5 ? 1 : 0, n4 ? 1 : 0, i3 || 0, a3 || 0, o3, l3);
      }
      let vt2 = 2 ** 25, yt2 = 2 ** 24, bt2 = 2 ** 17, xt2 = 2 ** 16;
      function St2(e6) {
        if (e6.opacity === 0 && !e6.placed) return 0;
        if (e6.opacity === 1 && e6.placed) return 4294967295;
        let t5 = e6.placed ? 1 : 0, n4 = Math.floor(127 * e6.opacity);
        return n4 * vt2 + t5 * yt2 + n4 * bt2 + t5 * xt2 + n4 * 512 + t5 * 256 + n4 * 2 + t5;
      }
      let Ct2 = 0;
      class wt2 {
        constructor(e6) {
          this._sortAcrossTiles = e6.layout.get(`symbol-z-order`) !== `viewport-y` && !e6.layout.get(`symbol-sort-key`).isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        }
        continuePlacement(e6, t5, n4, r3, i3) {
          let a3 = this._bucketParts;
          for (; this._currentTileIndex < e6.length; ) if (t5.getBucketParts(a3, r3, e6[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, i3()) return true;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = false, a3.sort(((e7, t6) => e7.sortKey - t6.sortKey))); this._currentPartIndex < a3.length; ) if (t5.placeLayerBucketPart(a3[this._currentPartIndex], this._seenCrossTileIDs, n4), this._currentPartIndex++, i3()) return true;
          return false;
        }
      }
      class Tt2 {
        constructor(e6, t5, n4, r3, i3, a3, o3, s3) {
          this.placement = new gt2(e6, t5, a3, o3, s3), this._currentPlacementIndex = n4.length - 1, this._forceFullPlacement = r3, this._showCollisionBoxes = i3, this._done = false;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(e6, t5, n4) {
          let r3 = c2(), i3 = () => !this._forceFullPlacement && c2() - r3 > 2;
          for (; this._currentPlacementIndex >= 0; ) {
            let r4 = t5[e6[this._currentPlacementIndex]], a3 = this.placement.collisionIndex.transform.zoom;
            if (r4.type === `symbol` && (!r4.minzoom || r4.minzoom <= a3) && (!r4.maxzoom || r4.maxzoom > a3)) {
              if (this._inProgressLayer || (this._inProgressLayer = new wt2(r4)), this._inProgressLayer.continuePlacement(n4[r4.source], this.placement, this._showCollisionBoxes, r4, i3)) return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = true;
        }
        commit(e6) {
          return this.placement.commit(e6), this.placement;
        }
      }
      let Et2 = 512 / t4.a3 / 2;
      class Dt2 {
        constructor(e6, n4, r3) {
          this.tileID = e6, this.bucketInstanceId = r3, this._symbolsByKey = {};
          let i3 = /* @__PURE__ */ new Map();
          for (let e7 = 0; e7 < n4.length; e7++) {
            let t5 = n4.get(e7), r4 = t5.key, a3 = i3.get(r4);
            a3 ? a3.push(t5) : i3.set(r4, [t5]);
          }
          for (let [e7, n5] of i3) {
            let r4 = { positions: n5.map(((e8) => ({ x: Math.floor(e8.anchorX * Et2), y: Math.floor(e8.anchorY * Et2) }))), crossTileIDs: n5.map(((e8) => e8.crossTileID)) };
            if (r4.positions.length > 128) {
              let e8 = new t4.aM(r4.positions.length, 16, Uint16Array);
              for (let { x: t5, y: n6 } of r4.positions) e8.add(t5, n6);
              e8.finish(), delete r4.positions, r4.index = e8;
            }
            this._symbolsByKey[e7] = r4;
          }
        }
        getScaledCoordinates(e6, n4) {
          let { x: r3, y: i3, z: a3 } = this.tileID.canonical, { x: o3, y: s3, z: c3 } = n4.canonical, l3 = Et2 / 2 ** (c3 - a3), u3 = (s3 * t4.a3 + e6.anchorY) * l3, d3 = i3 * t4.a3 * Et2;
          return { x: Math.floor((o3 * t4.a3 + e6.anchorX) * l3 - r3 * t4.a3 * Et2), y: Math.floor(u3 - d3) };
        }
        findMatches(e6, t5, n4) {
          let r3 = this.tileID.canonical.z < t5.canonical.z ? 1 : 2 ** (this.tileID.canonical.z - t5.canonical.z);
          for (let i3 = 0; i3 < e6.length; i3++) {
            let a3 = e6.get(i3);
            if (a3.crossTileID) continue;
            let o3 = this._symbolsByKey[a3.key];
            if (!o3) continue;
            let s3 = this.getScaledCoordinates(a3, t5);
            if (o3.index) {
              let e7 = o3.index.range(s3.x - r3, s3.y - r3, s3.x + r3, s3.y + r3).sort();
              for (let t6 of e7) {
                let e8 = o3.crossTileIDs[t6];
                if (!n4[e8]) {
                  n4[e8] = true, a3.crossTileID = e8;
                  break;
                }
              }
            } else if (o3.positions) for (let e7 = 0; e7 < o3.positions.length; e7++) {
              let t6 = o3.positions[e7], i4 = o3.crossTileIDs[e7];
              if (Math.abs(t6.x - s3.x) <= r3 && Math.abs(t6.y - s3.y) <= r3 && !n4[i4]) {
                n4[i4] = true, a3.crossTileID = i4;
                break;
              }
            }
          }
        }
        getCrossTileIDsLists() {
          return Object.values(this._symbolsByKey).map((({ crossTileIDs: e6 }) => e6));
        }
      }
      class Ot2 {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class kt2 {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(e6) {
          let t5 = Math.round((e6 - this.lng) / 360);
          if (t5 !== 0) for (let e7 in this.indexes) {
            let n4 = this.indexes[e7], r3 = {};
            for (let e8 in n4) {
              let i3 = n4[e8];
              i3.tileID = i3.tileID.unwrapTo(i3.tileID.wrap + t5), r3[i3.tileID.key] = i3;
            }
            this.indexes[e7] = r3;
          }
          this.lng = e6;
        }
        addBucket(e6, t5, n4) {
          if (this.indexes[e6.overscaledZ] && this.indexes[e6.overscaledZ][e6.key]) {
            if (this.indexes[e6.overscaledZ][e6.key].bucketInstanceId === t5.bucketInstanceId) return false;
            this.removeBucketCrossTileIDs(e6.overscaledZ, this.indexes[e6.overscaledZ][e6.key]);
          }
          for (let e7 = 0; e7 < t5.symbolInstances.length; e7++) t5.symbolInstances.get(e7).crossTileID = 0;
          this.usedCrossTileIDs[e6.overscaledZ] || (this.usedCrossTileIDs[e6.overscaledZ] = {});
          let r3 = this.usedCrossTileIDs[e6.overscaledZ];
          for (let n5 in this.indexes) {
            let i3 = this.indexes[n5];
            if (Number(n5) > e6.overscaledZ) for (let n6 in i3) {
              let a3 = i3[n6];
              a3.tileID.isChildOf(e6) && a3.findMatches(t5.symbolInstances, e6, r3);
            }
            else {
              let a3 = i3[e6.scaledTo(Number(n5)).key];
              a3 && a3.findMatches(t5.symbolInstances, e6, r3);
            }
          }
          for (let e7 = 0; e7 < t5.symbolInstances.length; e7++) {
            let i3 = t5.symbolInstances.get(e7);
            i3.crossTileID || (i3.crossTileID = n4.generate(), r3[i3.crossTileID] = true);
          }
          return this.indexes[e6.overscaledZ] === void 0 && (this.indexes[e6.overscaledZ] = {}), this.indexes[e6.overscaledZ][e6.key] = new Dt2(e6, t5.symbolInstances, t5.bucketInstanceId), true;
        }
        removeBucketCrossTileIDs(e6, t5) {
          for (let n4 of t5.getCrossTileIDsLists()) for (let t6 of n4) delete this.usedCrossTileIDs[e6][t6];
        }
        removeStaleBuckets(e6) {
          let t5 = false;
          for (let n4 in this.indexes) {
            let r3 = this.indexes[n4];
            for (let i3 in r3) e6[r3[i3].bucketInstanceId] || (this.removeBucketCrossTileIDs(n4, r3[i3]), delete r3[i3], t5 = true);
          }
          return t5;
        }
      }
      class At2 {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new Ot2(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(e6, t5, n4) {
          let r3 = this.layerIndexes[e6.id];
          r3 === void 0 && (r3 = this.layerIndexes[e6.id] = new kt2());
          let i3 = false, a3 = {};
          r3.handleWrapJump(n4);
          for (let n5 of t5) {
            let t6 = n5.getBucket(e6);
            t6 && e6.id === t6.layerIds[0] && (t6.bucketInstanceId || (t6.bucketInstanceId = ++this.maxBucketInstanceId), r3.addBucket(n5.tileID, t6, this.crossTileIDs) && (i3 = true), a3[t6.bucketInstanceId] = true);
          }
          return r3.removeStaleBuckets(a3) && (i3 = true), i3;
        }
        pruneUnusedLayers(e6) {
          let t5 = {};
          for (let n4 in e6.forEach(((e7) => {
            t5[e7] = true;
          })), this.layerIndexes) t5[n4] || delete this.layerIndexes[n4];
        }
      }
      var jt2 = `void main() {fragColor=vec4(1.0);}`;
      let Mt2 = { prelude: G2(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: G2(``, `float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}`), projectionGlobe: G2(``, `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: G2(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}`), backgroundPattern: G2(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}`), circle: G2(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: G2(jt2, `in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}`), heatmap: G2(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: G2(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}`), collisionBox: G2(`in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}`, `in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}`), collisionCircle: G2(`in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}`, `in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}`), colorRelief: G2(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}`), debug: G2(`uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}`, `in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}`), depth: G2(jt2, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: G2(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: G2(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: G2(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: G2(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: G2(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: G2(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: G2(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}`), hillshade: G2(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}`), line: G2(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: G2(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: G2(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: G2(`uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`), lineGradientSDF: G2(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`), raster: G2(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: G2(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: G2(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: G2(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: G2(`uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}`, `in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}`), terrainDepth: G2(`in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}`, `in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}`), terrainCoords: G2(`precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}`, `in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}`), projectionErrorMeasurement: G2(`in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}`, `in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}`), atmosphere: G2(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, `in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}`), sky: G2(`uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}`, `in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}`) };
      function G2(e6, t5) {
        let n4 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, r3 = t5.match(/in ([\w]+) ([\w]+)/g), i3 = e6.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), a3 = t5.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o3 = a3 ? a3.concat(i3) : i3, s3 = {};
        return { fragmentSource: e6 = e6.replace(n4, ((e7, t6, n5, r4, i4) => (s3[i4] = true, t6 === `define` ? `
#ifndef HAS_UNIFORM_u_${i4}
in ${n5} ${r4} ${i4};
#else
uniform ${n5} ${r4} u_${i4};
#endif
` : `
#ifdef HAS_UNIFORM_u_${i4}
    ${n5} ${r4} ${i4} = u_${i4};
#endif
`))), vertexSource: t5 = t5.replace(n4, ((e7, t6, n5, r4, i4) => {
          let a4 = r4 === `float` ? `vec2` : `vec4`, o4 = i4.match(/color/) ? `color` : a4;
          return s3[i4] ? t6 === `define` ? `
#ifndef HAS_UNIFORM_u_${i4}
uniform lowp float u_${i4}_t;
in ${n5} ${a4} a_${i4};
out ${n5} ${r4} ${i4};
#else
uniform ${n5} ${r4} u_${i4};
#endif
` : o4 === `vec4` ? `
#ifndef HAS_UNIFORM_u_${i4}
    ${i4} = a_${i4};
#else
    ${n5} ${r4} ${i4} = u_${i4};
#endif
` : `
#ifndef HAS_UNIFORM_u_${i4}
    ${i4} = unpack_mix_${o4}(a_${i4}, u_${i4}_t);
#else
    ${n5} ${r4} ${i4} = u_${i4};
#endif
` : t6 === `define` ? `
#ifndef HAS_UNIFORM_u_${i4}
uniform lowp float u_${i4}_t;
in ${n5} ${a4} a_${i4};
#else
uniform ${n5} ${r4} u_${i4};
#endif
` : o4 === `vec4` ? `
#ifndef HAS_UNIFORM_u_${i4}
    ${n5} ${r4} ${i4} = a_${i4};
#else
    ${n5} ${r4} ${i4} = u_${i4};
#endif
` : `
#ifndef HAS_UNIFORM_u_${i4}
    ${n5} ${r4} ${i4} = unpack_mix_${o4}(a_${i4}, u_${i4}_t);
#else
    ${n5} ${r4} ${i4} = u_${i4};
#endif
`;
        })), staticAttributes: r3, staticUniforms: o3 };
      }
      class K2 {
        constructor(e6, t5, n4) {
          this.vertexBuffer = e6, this.indexBuffer = t5, this.segments = n4;
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
        }
      }
      var Nt2 = t4.aN([{ name: `a_pos`, type: `Int16`, components: 2 }]);
      let Pt2 = `#define PROJECTION_MERCATOR`, Ft2 = `mercator`;
      class It2 {
        constructor() {
          this._cachedMesh = null;
        }
        get name() {
          return `mercator`;
        }
        get useSubdivision() {
          return false;
        }
        get shaderVariantName() {
          return Ft2;
        }
        get shaderDefine() {
          return Pt2;
        }
        get shaderPreludeCode() {
          return Mt2.projectionMercator;
        }
        get vertexShaderPreludeCode() {
          return Mt2.projectionMercator.vertexSource;
        }
        get subdivisionGranularity() {
          return t4.aO.noSubdivision;
        }
        get useGlobeControls() {
          return false;
        }
        get transitionState() {
          return 0;
        }
        get latitudeErrorCorrectionRadians() {
          return 0;
        }
        destroy() {
        }
        updateGPUdependent(e6) {
        }
        getMeshFromTileID(e6, n4, r3, i3, a3) {
          if (this._cachedMesh) return this._cachedMesh;
          let o3 = new t4.aP();
          o3.emplaceBack(0, 0), o3.emplaceBack(t4.a3, 0), o3.emplaceBack(0, t4.a3), o3.emplaceBack(t4.a3, t4.a3);
          let s3 = e6.createVertexBuffer(o3, Nt2.members), c3 = t4.aQ.simpleSegment(0, 0, 4, 2), l3 = new t4.aR();
          return l3.emplaceBack(1, 0, 2), l3.emplaceBack(1, 2, 3), this._cachedMesh = new K2(s3, e6.createIndexBuffer(l3), c3), this._cachedMesh;
        }
        recalculate() {
        }
        hasTransition() {
          return false;
        }
        setErrorQueryLatitudeDegrees(e6) {
        }
      }
      class Lt2 {
        constructor(e6 = 0, t5 = 0, n4 = 0, r3 = 0) {
          if (isNaN(e6) || e6 < 0 || isNaN(t5) || t5 < 0 || isNaN(n4) || n4 < 0 || isNaN(r3) || r3 < 0) throw Error(`Invalid value for edge-insets, top, bottom, left and right must all be numbers`);
          this.top = e6, this.bottom = t5, this.left = n4, this.right = r3;
        }
        interpolate(e6, n4, r3) {
          return n4.top != null && e6.top != null && (this.top = t4.F.number(e6.top, n4.top, r3)), n4.bottom != null && e6.bottom != null && (this.bottom = t4.F.number(e6.bottom, n4.bottom, r3)), n4.left != null && e6.left != null && (this.left = t4.F.number(e6.left, n4.left, r3)), n4.right != null && e6.right != null && (this.right = t4.F.number(e6.right, n4.right, r3)), this;
        }
        getCenter(e6, n4) {
          let r3 = t4.ai((this.left + e6 - this.right) / 2, 0, e6), i3 = t4.ai((this.top + n4 - this.bottom) / 2, 0, n4);
          return new t4.P(r3, i3);
        }
        equals(e6) {
          return this.top === e6.top && this.bottom === e6.bottom && this.left === e6.left && this.right === e6.right;
        }
        clone() {
          return new Lt2(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      function Rt2(e6, t5) {
        if (!e6.renderWorldCopies || e6.lngRange) return;
        let n4 = t5.lng - e6.center.lng;
        t5.lng += n4 > 180 ? -360 : n4 < -180 ? 360 : 0;
      }
      function zt2(e6) {
        return Math.max(0, Math.floor(e6));
      }
      class Bt2 {
        constructor(e6, n4) {
          this._callbacks = e6, this._tileSize = 512, this._renderWorldCopies = (n4 == null ? void 0 : n4.renderWorldCopies) === void 0 || !!(n4 == null ? void 0 : n4.renderWorldCopies), this._minZoom = (n4 == null ? void 0 : n4.minZoom) || 0, this._maxZoom = (n4 == null ? void 0 : n4.maxZoom) || 22, this._minPitch = (n4 == null ? void 0 : n4.minPitch) == null ? 0 : n4 == null ? void 0 : n4.minPitch, this._maxPitch = (n4 == null ? void 0 : n4.maxPitch) == null ? 60 : n4 == null ? void 0 : n4.maxPitch, this._constrain = (n4 == null ? void 0 : n4.constrain) ?? this._callbacks.constrain, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new t4.U(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = zt2(this._zoom), this._scale = t4.al(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = true, this._edgeInsets = new Lt2(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = true;
        }
        apply(e6, n4, r3) {
          this._latRange = e6.latRange, this._lngRange = e6.lngRange, this._width = e6.width, this._height = e6.height, this._center = e6.center, this._elevation = e6.elevation, this._minElevationForCurrentTile = e6.minElevationForCurrentTile, this._zoom = e6.zoom, this._tileZoom = zt2(this._zoom), this._scale = t4.al(this._zoom), this._bearingInRadians = e6.bearingInRadians, this._fovInRadians = e6.fovInRadians, this._pitchInRadians = e6.pitchInRadians, this._rollInRadians = e6.rollInRadians, this._unmodified = e6.unmodified, this._edgeInsets = new Lt2(e6.padding.top, e6.padding.bottom, e6.padding.left, e6.padding.right), this._minZoom = e6.minZoom, this._maxZoom = e6.maxZoom, this._minPitch = e6.minPitch, this._maxPitch = e6.maxPitch, this._renderWorldCopies = e6.renderWorldCopies, this._cameraToCenterDistance = e6.cameraToCenterDistance, this._nearZ = e6.nearZ, this._farZ = e6.farZ, this._autoCalculateNearFarZ = !r3 && e6.autoCalculateNearFarZ, n4 && this.constrainInternal(), this._calcMatrices();
        }
        get pixelsToClipSpaceMatrix() {
          return this._pixelsToClipSpaceMatrix;
        }
        get clipSpaceToPixelsMatrix() {
          return this._clipSpaceToPixelsMatrix;
        }
        get minElevationForCurrentTile() {
          return this._minElevationForCurrentTile;
        }
        setMinElevationForCurrentTile(e6) {
          this._minElevationForCurrentTile = e6;
        }
        get tileSize() {
          return this._tileSize;
        }
        get tileZoom() {
          return this._tileZoom;
        }
        get scale() {
          return this._scale;
        }
        get width() {
          return this._width;
        }
        get height() {
          return this._height;
        }
        get bearingInRadians() {
          return this._bearingInRadians;
        }
        get lngRange() {
          return this._lngRange;
        }
        get latRange() {
          return this._latRange;
        }
        get pixelsToGLUnits() {
          return this._pixelsToGLUnits;
        }
        get minZoom() {
          return this._minZoom;
        }
        setMinZoom(e6) {
          this._minZoom !== e6 && (this._minZoom = e6, this.setZoom(this.constrain(this._center, this.zoom).zoom));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        setMaxZoom(e6) {
          this._maxZoom !== e6 && (this._maxZoom = e6, this.setZoom(this.constrain(this._center, this.zoom).zoom));
        }
        get minPitch() {
          return this._minPitch;
        }
        setMinPitch(e6) {
          this._minPitch !== e6 && (this._minPitch = e6, this.setPitch(Math.max(this.pitch, e6)));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        setMaxPitch(e6) {
          this._maxPitch !== e6 && (this._maxPitch = e6, this.setPitch(Math.min(this.pitch, e6)));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies;
        }
        setRenderWorldCopies(e6) {
          e6 === void 0 ? e6 = true : e6 === null && (e6 = false), this._renderWorldCopies = e6;
        }
        get constrain() {
          return this._constrain;
        }
        setConstrain(e6) {
          e6 || (e6 = this._callbacks.constrain), this._constrain = e6, this.constrainInternal(), this._calcMatrices();
        }
        get worldSize() {
          return this._tileSize * this._scale;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new t4.P(this._width, this._height);
        }
        get bearing() {
          return this._bearingInRadians / Math.PI * 180;
        }
        setBearing(e6) {
          let n4 = t4.V(e6, -180, 180) * Math.PI / 180;
          var i3, a3, o3, s3, c3, l3, u3, d3, f3;
          this._bearingInRadians !== n4 && (this._unmodified = false, this._bearingInRadians = n4, this._calcMatrices(), this._rotationMatrix = r2(), i3 = this._rotationMatrix, o3 = -this._bearingInRadians, s3 = (a3 = this._rotationMatrix)[0], c3 = a3[1], l3 = a3[2], u3 = a3[3], d3 = Math.sin(o3), f3 = Math.cos(o3), i3[0] = s3 * f3 + l3 * d3, i3[1] = c3 * f3 + u3 * d3, i3[2] = s3 * -d3 + l3 * f3, i3[3] = c3 * -d3 + u3 * f3);
        }
        get rotationMatrix() {
          return this._rotationMatrix;
        }
        get pitchInRadians() {
          return this._pitchInRadians;
        }
        get pitch() {
          return this._pitchInRadians / Math.PI * 180;
        }
        setPitch(e6) {
          let n4 = t4.ai(e6, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitchInRadians !== n4 && (this._unmodified = false, this._pitchInRadians = n4, this._calcMatrices());
        }
        get rollInRadians() {
          return this._rollInRadians;
        }
        get roll() {
          return this._rollInRadians / Math.PI * 180;
        }
        setRoll(e6) {
          let t5 = e6 / 180 * Math.PI;
          this._rollInRadians !== t5 && (this._unmodified = false, this._rollInRadians = t5, this._calcMatrices());
        }
        get fovInRadians() {
          return this._fovInRadians;
        }
        get fov() {
          return t4.aS(this._fovInRadians);
        }
        setFov(e6) {
          e6 = t4.ai(e6, 0.1, 150), this.fov !== e6 && (this._unmodified = false, this._fovInRadians = t4.ak(e6), this._calcMatrices());
        }
        get zoom() {
          return this._zoom;
        }
        setZoom(e6) {
          let n4 = this.constrain(this._center, e6).zoom;
          this._zoom !== n4 && (this._unmodified = false, this._zoom = n4, this._tileZoom = Math.max(0, Math.floor(n4)), this._scale = t4.al(n4), this.constrainInternal(), this._calcMatrices());
        }
        get center() {
          return this._center;
        }
        setCenter(e6) {
          e6.lat === this._center.lat && e6.lng === this._center.lng || (this._unmodified = false, this._center = e6, this.constrainInternal(), this._calcMatrices());
        }
        get elevation() {
          return this._elevation;
        }
        setElevation(e6) {
          e6 !== this._elevation && (this._elevation = e6, this.constrainInternal(), this._calcMatrices());
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        setPadding(e6) {
          this._edgeInsets.equals(e6) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e6, 1), this._calcMatrices());
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this._width, this._height);
        }
        get pixelsPerMeter() {
          return this._pixelPerMeter;
        }
        get unmodified() {
          return this._unmodified;
        }
        get cameraToCenterDistance() {
          return this._cameraToCenterDistance;
        }
        get nearZ() {
          return this._nearZ;
        }
        get farZ() {
          return this._farZ;
        }
        get autoCalculateNearFarZ() {
          return this._autoCalculateNearFarZ;
        }
        overrideNearFarZ(e6, t5) {
          this._autoCalculateNearFarZ = false, this._nearZ = e6, this._farZ = t5, this._calcMatrices();
        }
        clearNearFarZOverride() {
          this._autoCalculateNearFarZ = true, this._calcMatrices();
        }
        isPaddingEqual(e6) {
          return this._edgeInsets.equals(e6);
        }
        interpolatePadding(e6, t5, n4) {
          this._unmodified = false, this._edgeInsets.interpolate(e6, t5, n4), this.constrainInternal(), this._calcMatrices();
        }
        resize(e6, t5, n4 = true) {
          this._width = e6, this._height = t5, n4 && this.constrainInternal(), this._calcMatrices();
        }
        getMaxBounds() {
          return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new ue2([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
        }
        setMaxBounds(e6) {
          e6 ? (this._lngRange = [e6.getWest(), e6.getEast()], this._latRange = [e6.getSouth(), e6.getNorth()], this.constrainInternal()) : (this._lngRange = null, this._latRange = [-t4.aj, t4.aj]);
        }
        getCameraQueryGeometry(e6, n4) {
          if (n4.length === 1) return [n4[0], e6];
          {
            let { minX: r3, minY: i3, maxX: a3, maxY: o3 } = t4.a6.fromPoints(n4).extend(e6);
            return [new t4.P(r3, i3), new t4.P(a3, i3), new t4.P(a3, o3), new t4.P(r3, o3), new t4.P(r3, i3)];
          }
        }
        constrainInternal() {
          if (!this.center || !this._width || !this._height || this._constraining) return;
          this._constraining = true;
          let e6 = this._unmodified, { center: t5, zoom: n4 } = this.constrain(this.center, this.zoom);
          this.setCenter(t5), this.setZoom(n4), this._unmodified = e6, this._constraining = false;
        }
        _calcMatrices() {
          if (this._width && this._height) {
            this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
            let e6 = t4.am(new Float64Array(16));
            t4.O(e6, e6, [this._width / 2, -this._height / 2, 1]), t4.N(e6, e6, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e6, e6 = t4.am(new Float64Array(16)), t4.O(e6, e6, [1, -1, 1]), t4.N(e6, e6, [-1, -1, 0]), t4.O(e6, e6, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e6, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
          }
          this._callbacks.calcMatrices();
        }
        calculateCenterFromCameraLngLatAlt(e6, n4, r3, i3) {
          let a3 = r3 === void 0 ? this.bearing : r3, o3 = i3 = i3 === void 0 ? this.pitch : i3, s3 = t4.a5.fromLngLat(e6, n4), c3 = -Math.cos(t4.ak(o3)), l3 = Math.sin(t4.ak(o3)), u3 = l3 * Math.sin(t4.ak(a3)), d3 = -l3 * Math.cos(t4.ak(a3)), f3 = this.elevation, p3 = n4 - f3, m3;
          c3 * p3 >= 0 || Math.abs(c3) < 0.1 ? (m3 = 1e4, f3 = n4 + m3 * c3) : m3 = -p3 / c3;
          let h3, g3, _3 = t4.aT(1, s3.y), v3 = 0;
          do {
            if (v3 += 1, v3 > 10) break;
            g3 = m3 / _3, h3 = new t4.a5(s3.x + u3 * g3, s3.y + d3 * g3), _3 = 1 / h3.meterInMercatorCoordinateUnits();
          } while (Math.abs(m3 - g3 * _3) > 1e-12);
          return { center: h3.toLngLat(), elevation: f3, zoom: t4.ao(this.height / 2 / Math.tan(this.fovInRadians / 2) / g3 / this.tileSize) };
        }
        recalculateZoomAndCenter(e6) {
          if (this.elevation - e6 == 0) return;
          let n4 = t4.an(1, this.center.lat) * this.worldSize, r3 = this.cameraToCenterDistance / n4, i3 = t4.a5.fromLngLat(this.center, this.elevation), a3 = Pe2(this.center, this.elevation, this.pitch, this.bearing, r3);
          this._elevation = e6;
          let o3 = this.calculateCenterFromCameraLngLatAlt(a3.toLngLat(), t4.aT(a3.z, i3.y), this.bearing, this.pitch);
          this._elevation = o3.elevation, this._center = o3.center, this.setZoom(o3.zoom);
        }
        getCameraPoint() {
          let e6 = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new t4.P(e6 * Math.sin(this.rollInRadians), e6 * Math.cos(this.rollInRadians)));
        }
        getCameraAltitude() {
          return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
        }
        getCameraLngLat() {
          let e6 = t4.an(1, this.center.lat) * this.worldSize;
          return Pe2(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e6).toLngLat();
        }
        getMercatorTileCoordinates(e6) {
          if (!e6) return [0, 0, 1, 1];
          let n4 = e6.canonical.z >= 0 ? 1 << e6.canonical.z : 2 ** e6.canonical.z;
          return [e6.canonical.x / n4, e6.canonical.y / n4, 1 / n4 / t4.a3, 1 / n4 / t4.a3];
        }
      }
      class Vt2 {
        constructor(e6, n4) {
          this.min = e6, this.max = n4, this.center = t4.aU([], t4.aV([], this.min, this.max), 0.5);
        }
        quadrant(e6) {
          let n4 = [e6 % 2 == 0, e6 < 2], r3 = t4.aW(this.min), i3 = t4.aW(this.max);
          for (let e7 = 0; e7 < n4.length; e7++) r3[e7] = n4[e7] ? this.min[e7] : this.center[e7], i3[e7] = n4[e7] ? this.center[e7] : this.max[e7];
          return i3[2] = this.max[2], new Vt2(r3, i3);
        }
        distanceX(e6) {
          return Math.max(Math.min(this.max[0], e6[0]), this.min[0]) - e6[0];
        }
        distanceY(e6) {
          return Math.max(Math.min(this.max[1], e6[1]), this.min[1]) - e6[1];
        }
        intersectsFrustum(e6) {
          let t5 = true;
          for (let n4 = 0; n4 < e6.planes.length; n4++) {
            let r3 = this.intersectsPlane(e6.planes[n4]);
            if (r3 === 0) return 0;
            r3 === 1 && (t5 = false);
          }
          return t5 ? 2 : e6.aabb.min[0] > this.max[0] || e6.aabb.min[1] > this.max[1] || e6.aabb.min[2] > this.max[2] || e6.aabb.max[0] < this.min[0] || e6.aabb.max[1] < this.min[1] || e6.aabb.max[2] < this.min[2] ? 0 : 1;
        }
        intersectsPlane(e6) {
          let t5 = e6[3], n4 = e6[3];
          for (let r3 = 0; r3 < 3; r3++) e6[r3] > 0 ? (t5 += e6[r3] * this.min[r3], n4 += e6[r3] * this.max[r3]) : (n4 += e6[r3] * this.min[r3], t5 += e6[r3] * this.max[r3]);
          return t5 >= 0 ? 2 : n4 < 0 ? 0 : 1;
        }
      }
      class Ht2 {
        distanceToTile2d(e6, t5, n4, r3) {
          let i3 = r3.distanceX([e6, t5]), a3 = r3.distanceY([e6, t5]);
          return Math.hypot(i3, a3);
        }
        getWrap(e6, t5, n4) {
          return n4;
        }
        getTileBoundingVolume(e6, n4, r3, i3) {
          let a3 = 0, o3 = 0;
          if (i3 == null ? void 0 : i3.terrain) {
            let s4 = new t4.a0(e6.z, n4, e6.z, e6.x, e6.y), c3 = i3.terrain.getMinMaxElevation(s4);
            a3 = c3.minElevation ?? Math.min(0, r3), o3 = c3.maxElevation ?? Math.max(0, r3);
          }
          let s3 = 1 << e6.z;
          return new Vt2([n4 + e6.x / s3, e6.y / s3, a3], [n4 + (e6.x + 1) / s3, (e6.y + 1) / s3, o3]);
        }
        allowVariableZoom(e6, n4) {
          let r3 = e6.fov * (Math.abs(Math.cos(e6.rollInRadians)) * e6.height + Math.abs(Math.sin(e6.rollInRadians)) * e6.width) / e6.height, i3 = t4.ai(78.5 - r3 / 2, 0, 60);
          return !!n4.terrain || e6.pitch > i3;
        }
        allowWorldCopies() {
          return true;
        }
        prepareNextFrame() {
        }
      }
      class Ut2 {
        constructor(e6, t5, n4) {
          this.points = e6, this.planes = t5, this.aabb = n4;
        }
        static fromInvProjectionMatrix(e6, n4 = 1, r3 = 0, i3, a3) {
          let o3 = a3 ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]], s3 = 2 ** r3, c3 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(((r4) => (function(e7, n5, r5, i4) {
            let a4 = t4.aA([], e7, n5), o4 = 1 / a4[3] / r5 * i4;
            return t4.a$(a4, a4, [o4, o4, 1 / a4[3], o4]);
          })(r4, e6, n4, s3)));
          i3 && (function(e7, n5, r4, i4) {
            let a4 = i4 ? 4 : 0, o4 = i4 ? 0 : 4, s4 = 0, c4 = [], l4 = [];
            for (let n6 = 0; n6 < 4; n6++) {
              let r5 = t4.aX([], e7[n6 + o4], e7[n6 + a4]), i5 = t4.b0(r5);
              t4.aU(r5, r5, 1 / i5), c4.push(i5), l4.push(r5);
            }
            for (let n6 = 0; n6 < 4; n6++) {
              let i5 = t4.b1(e7[n6 + a4], l4[n6], r4);
              s4 = i5 !== null && i5 >= 0 ? Math.max(s4, i5) : Math.max(s4, c4[n6]);
            }
            let u4 = (function(e8, n6) {
              let r5 = t4.aX([], e8[n6[0]], e8[n6[1]]), i5 = t4.aX([], e8[n6[2]], e8[n6[1]]), a5 = [0, 0, 0, 0];
              return t4.aY(a5, t4.aZ([], r5, i5)), a5[3] = -t4.a_(a5, e8[n6[0]]), a5;
            })(e7, n5), d4 = (function(e8, n6) {
              let r5 = t4.b2(e8), i5 = t4.b3([], e8, 1 / r5), a5 = t4.aX([], n6, t4.aU([], i5, t4.a_(n6, i5))), o5 = t4.b2(a5);
              if (o5 > 0) {
                let e9 = Math.sqrt(1 - i5[3] * i5[3]), r6 = t4.aU([], i5, -i5[3]), s5 = t4.aV([], r6, t4.aU([], a5, e9 / o5));
                return t4.b4(n6, s5);
              }
              return null;
            })(r4, u4);
            if (d4 !== null) {
              let e8 = d4 / t4.a_(l4[0], u4);
              s4 = Math.min(s4, e8);
            }
            for (let t5 = 0; t5 < 4; t5++) {
              let n6 = Math.min(s4, c4[t5]);
              e7[t5 + o4] = [e7[t5 + a4][0] + l4[t5][0] * n6, e7[t5 + a4][1] + l4[t5][1] * n6, e7[t5 + a4][2] + l4[t5][2] * n6, 1];
            }
          })(c3, o3[0], i3, a3);
          let l3 = o3.map(((e7) => {
            let n5 = t4.aX([], c3[e7[0]], c3[e7[1]]), r4 = t4.aX([], c3[e7[2]], c3[e7[1]]), i4 = t4.aY([], t4.aZ([], n5, r4)), a4 = -t4.a_(i4, c3[e7[1]]);
            return i4.concat(a4);
          })), u3 = [1 / 0, 1 / 0, 1 / 0], d3 = [-1 / 0, -1 / 0, -1 / 0];
          for (let e7 of c3) for (let t5 = 0; t5 < 3; t5++) u3[t5] = Math.min(u3[t5], e7[t5]), d3[t5] = Math.max(d3[t5], e7[t5]);
          return new Ut2(c3, l3, new Vt2(u3, d3));
        }
      }
      class Wt2 {
        get pixelsToClipSpaceMatrix() {
          return this._helper.pixelsToClipSpaceMatrix;
        }
        get clipSpaceToPixelsMatrix() {
          return this._helper.clipSpaceToPixelsMatrix;
        }
        get pixelsToGLUnits() {
          return this._helper.pixelsToGLUnits;
        }
        get centerOffset() {
          return this._helper.centerOffset;
        }
        get size() {
          return this._helper.size;
        }
        get rotationMatrix() {
          return this._helper.rotationMatrix;
        }
        get centerPoint() {
          return this._helper.centerPoint;
        }
        get pixelsPerMeter() {
          return this._helper.pixelsPerMeter;
        }
        setMinZoom(e6) {
          this._helper.setMinZoom(e6);
        }
        setMaxZoom(e6) {
          this._helper.setMaxZoom(e6);
        }
        setMinPitch(e6) {
          this._helper.setMinPitch(e6);
        }
        setMaxPitch(e6) {
          this._helper.setMaxPitch(e6);
        }
        setRenderWorldCopies(e6) {
          this._helper.setRenderWorldCopies(e6);
        }
        setBearing(e6) {
          this._helper.setBearing(e6);
        }
        setPitch(e6) {
          this._helper.setPitch(e6);
        }
        setRoll(e6) {
          this._helper.setRoll(e6);
        }
        setFov(e6) {
          this._helper.setFov(e6);
        }
        setZoom(e6) {
          this._helper.setZoom(e6);
        }
        setCenter(e6) {
          this._helper.setCenter(e6);
        }
        setElevation(e6) {
          this._helper.setElevation(e6);
        }
        setMinElevationForCurrentTile(e6) {
          this._helper.setMinElevationForCurrentTile(e6);
        }
        setPadding(e6) {
          this._helper.setPadding(e6);
        }
        interpolatePadding(e6, t5, n4) {
          return this._helper.interpolatePadding(e6, t5, n4);
        }
        isPaddingEqual(e6) {
          return this._helper.isPaddingEqual(e6);
        }
        resize(e6, t5, n4 = true) {
          this._helper.resize(e6, t5, n4);
        }
        getMaxBounds() {
          return this._helper.getMaxBounds();
        }
        setMaxBounds(e6) {
          this._helper.setMaxBounds(e6);
        }
        setConstrain(e6) {
          this._helper.setConstrain(e6);
        }
        overrideNearFarZ(e6, t5) {
          this._helper.overrideNearFarZ(e6, t5);
        }
        clearNearFarZOverride() {
          this._helper.clearNearFarZOverride();
        }
        getCameraQueryGeometry(e6) {
          return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e6);
        }
        get tileSize() {
          return this._helper.tileSize;
        }
        get tileZoom() {
          return this._helper.tileZoom;
        }
        get scale() {
          return this._helper.scale;
        }
        get worldSize() {
          return this._helper.worldSize;
        }
        get width() {
          return this._helper.width;
        }
        get height() {
          return this._helper.height;
        }
        get lngRange() {
          return this._helper.lngRange;
        }
        get latRange() {
          return this._helper.latRange;
        }
        get minZoom() {
          return this._helper.minZoom;
        }
        get maxZoom() {
          return this._helper.maxZoom;
        }
        get zoom() {
          return this._helper.zoom;
        }
        get center() {
          return this._helper.center;
        }
        get minPitch() {
          return this._helper.minPitch;
        }
        get maxPitch() {
          return this._helper.maxPitch;
        }
        get pitch() {
          return this._helper.pitch;
        }
        get pitchInRadians() {
          return this._helper.pitchInRadians;
        }
        get roll() {
          return this._helper.roll;
        }
        get rollInRadians() {
          return this._helper.rollInRadians;
        }
        get bearing() {
          return this._helper.bearing;
        }
        get bearingInRadians() {
          return this._helper.bearingInRadians;
        }
        get fov() {
          return this._helper.fov;
        }
        get fovInRadians() {
          return this._helper.fovInRadians;
        }
        get elevation() {
          return this._helper.elevation;
        }
        get minElevationForCurrentTile() {
          return this._helper.minElevationForCurrentTile;
        }
        get padding() {
          return this._helper.padding;
        }
        get unmodified() {
          return this._helper.unmodified;
        }
        get renderWorldCopies() {
          return this._helper.renderWorldCopies;
        }
        get cameraToCenterDistance() {
          return this._helper.cameraToCenterDistance;
        }
        get constrain() {
          return this._helper.constrain;
        }
        get nearZ() {
          return this._helper.nearZ;
        }
        get farZ() {
          return this._helper.farZ;
        }
        get autoCalculateNearFarZ() {
          return this._helper.autoCalculateNearFarZ;
        }
        setTransitionState(e6, t5) {
        }
        constructor(e6) {
          this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this.defaultConstrain = (e7, n4) => {
            n4 = t4.ai(+n4, this.minZoom, this.maxZoom);
            let r3 = { center: new t4.U(e7.lng, e7.lat), zoom: n4 }, i3 = this._helper._lngRange;
            if (!this._helper._renderWorldCopies && i3 === null) {
              let e8 = 179.9999999999;
              i3 = [-e8, e8];
            }
            let a3 = this.tileSize * t4.al(r3.zoom), o3 = 0, s3 = a3, c3 = 0, l3 = a3, u3 = 0, d3 = 0, { x: f3, y: p3 } = this.size;
            if (this._helper._latRange) {
              let e8 = this._helper._latRange;
              o3 = t4.W(e8[1]) * a3, s3 = t4.W(e8[0]) * a3, s3 - o3 < p3 && (u3 = p3 / (s3 - o3));
            }
            i3 && (c3 = t4.V(t4.X(i3[0]) * a3, 0, a3), l3 = t4.V(t4.X(i3[1]) * a3, 0, a3), l3 < c3 && (l3 += a3), l3 - c3 < f3 && (d3 = f3 / (l3 - c3)));
            let { x: m3, y: h3 } = je2(a3, e7), g3, _3, v3 = Math.max(d3 || 0, u3 || 0);
            if (v3) return r3.center = Me2(a3, new t4.P(d3 ? (l3 + c3) / 2 : m3, u3 ? (s3 + o3) / 2 : h3)).wrap(), r3.zoom += t4.ao(v3), r3;
            if (this._helper._latRange) {
              let e8 = p3 / 2;
              h3 - e8 < o3 && (_3 = o3 + e8), h3 + e8 > s3 && (_3 = s3 - e8);
            }
            if (i3) {
              let e8 = (c3 + l3) / 2, n5 = m3;
              this._helper._renderWorldCopies && (n5 = t4.V(m3, e8 - a3 / 2, e8 + a3 / 2));
              let r4 = f3 / 2;
              n5 - r4 < c3 && (g3 = c3 + r4), n5 + r4 > l3 && (g3 = l3 - r4);
            }
            return (g3 !== void 0 || _3 !== void 0) && (r3.center = Me2(a3, new t4.P(g3 ?? m3, _3 ?? h3)).wrap()), r3;
          }, this._helper = new Bt2({ calcMatrices: () => {
            this._calcMatrices();
          }, constrain: (e7, t5) => this.defaultConstrain(e7, t5) }, e6), this._coveringTilesDetailsProvider = new Ht2();
        }
        clone() {
          let e6 = new Wt2();
          return e6.apply(this), e6;
        }
        apply(e6, t5, n4) {
          this._helper.apply(e6, t5, n4);
        }
        get cameraPosition() {
          return this._cameraPosition;
        }
        get projectionMatrix() {
          return this._projectionMatrix;
        }
        get modelViewProjectionMatrix() {
          return this._viewProjMatrix;
        }
        get inverseProjectionMatrix() {
          return this._invProjMatrix;
        }
        get mercatorMatrix() {
          return this._mercatorMatrix;
        }
        getVisibleUnwrappedCoordinates(e6) {
          let n4 = [new t4.b5(0, e6)];
          if (this._helper._renderWorldCopies) {
            let r3 = this.screenPointToMercatorCoordinate(new t4.P(0, 0)), i3 = this.screenPointToMercatorCoordinate(new t4.P(this._helper._width, 0)), a3 = this.screenPointToMercatorCoordinate(new t4.P(this._helper._width, this._helper._height)), o3 = this.screenPointToMercatorCoordinate(new t4.P(0, this._helper._height)), s3 = Math.floor(Math.min(r3.x, i3.x, a3.x, o3.x)), c3 = Math.floor(Math.max(r3.x, i3.x, a3.x, o3.x));
            for (let r4 = s3 - 1; r4 <= c3 + 1; r4++) r4 !== 0 && n4.push(new t4.b5(r4, e6));
          }
          return n4;
        }
        getCameraFrustum() {
          return Ut2.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
        }
        getClippingPlane() {
          return null;
        }
        getCoveringTilesDetailsProvider() {
          return this._coveringTilesDetailsProvider;
        }
        recalculateZoomAndCenter(e6) {
          let t5 = this.screenPointToLocation(this.centerPoint, e6), n4 = e6 ? e6.getElevationForLngLatZoom(t5, this._helper._tileZoom) : 0;
          this._helper.recalculateZoomAndCenter(n4);
        }
        setLocationAtPoint(e6, n4) {
          let r3 = t4.an(this.elevation, this.center.lat), i3 = this.screenPointToMercatorCoordinateAtZ(n4, r3), a3 = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, r3), o3 = t4.a5.fromLngLat(e6), s3 = new t4.a5(o3.x - (i3.x - a3.x), o3.y - (i3.y - a3.y));
          this.setCenter(s3 == null ? void 0 : s3.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
        }
        locationToScreenPoint(e6, n4) {
          return n4 ? this.coordinatePoint(t4.a5.fromLngLat(e6), n4.getElevationForLngLatZoom(e6, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(t4.a5.fromLngLat(e6));
        }
        screenPointToLocation(e6, t5) {
          var _a3;
          return (_a3 = this.screenPointToMercatorCoordinate(e6, t5)) == null ? void 0 : _a3.toLngLat();
        }
        screenPointToMercatorCoordinate(e6, t5) {
          if (t5) {
            let n4 = t5.pointCoordinate(e6);
            if (n4 != null) return n4;
          }
          return this.screenPointToMercatorCoordinateAtZ(e6);
        }
        screenPointToMercatorCoordinateAtZ(e6, n4) {
          let r3 = n4 || 0, i3 = [e6.x, e6.y, 0, 1], a3 = [e6.x, e6.y, 1, 1];
          t4.aA(i3, i3, this._pixelMatrixInverse), t4.aA(a3, a3, this._pixelMatrixInverse);
          let o3 = i3[3], s3 = a3[3], c3 = i3[1] / o3, l3 = a3[1] / s3, u3 = i3[2] / o3, d3 = a3[2] / s3, f3 = u3 === d3 ? 0 : (r3 - u3) / (d3 - u3);
          return new t4.a5(t4.F.number(i3[0] / o3, a3[0] / s3, f3) / this.worldSize, t4.F.number(c3, l3, f3) / this.worldSize, r3);
        }
        coordinatePoint(e6, n4 = 0, r3 = this._pixelMatrix) {
          let i3 = [e6.x * this.worldSize, e6.y * this.worldSize, n4, 1];
          return t4.aA(i3, i3, r3), new t4.P(i3[0] / i3[3], i3[1] / i3[3]);
        }
        getBounds() {
          let e6 = Math.max(0, this._helper._height / 2 - Ne2(this));
          return new ue2().extend(this.screenPointToLocation(new t4.P(0, e6))).extend(this.screenPointToLocation(new t4.P(this._helper._width, e6))).extend(this.screenPointToLocation(new t4.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new t4.P(0, this._helper._height)));
        }
        isPointOnMapSurface(e6, t5) {
          return t5 ? t5.pointCoordinate(e6) != null : e6.y > this.height / 2 - Ne2(this);
        }
        calculatePosMatrix(e6, n4 = false, r3) {
          let i3 = e6.key ?? t4.b6(e6.wrap, e6.canonical.z, e6.canonical.z, e6.canonical.x, e6.canonical.y), a3 = n4 ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (a3.has(i3)) {
            let e7 = a3.get(i3);
            return r3 ? e7.f32 : e7.f64;
          }
          let o3 = R2(e6, this.worldSize);
          t4.Q(o3, n4 ? this._alignedProjMatrix : this._viewProjMatrix, o3);
          let s3 = { f64: o3, f32: new Float32Array(o3) };
          return a3.set(i3, s3), r3 ? s3.f32 : s3.f64;
        }
        calculateFogMatrix(e6) {
          let n4 = e6.key, r3 = this._fogMatrixCacheF32;
          if (r3.has(n4)) return r3.get(n4);
          let i3 = R2(e6, this.worldSize);
          return t4.Q(i3, this._fogMatrix, i3), r3.set(n4, new Float32Array(i3)), r3.get(n4);
        }
        calculateCenterFromCameraLngLatAlt(e6, t5, n4, r3) {
          return this._helper.calculateCenterFromCameraLngLatAlt(e6, t5, n4, r3);
        }
        _calculateNearFarZIfNeeded(e6, n4, r3) {
          if (!this._helper.autoCalculateNearFarZ) return;
          let i3 = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), a3 = e6 - i3 * this._helper._pixelPerMeter / Math.cos(n4), o3 = i3 < 0 ? a3 : e6, s3 = Math.PI / 2 + this.pitchInRadians, c3 = t4.ak(this.fov) * (Math.abs(Math.cos(t4.ak(this.roll))) * this.height + Math.abs(Math.sin(t4.ak(this.roll))) * this.width) / this.height * (0.5 + r3.y / this.height), l3 = Math.sin(c3) * o3 / Math.sin(t4.ai(Math.PI - s3 - c3, 0.01, Math.PI - 0.01)), u3 = Ne2(this), d3 = Math.atan(u3 / this._helper.cameraToCenterDistance), f3 = t4.ak(0.75), p3 = d3 > f3 ? 2 * d3 * (0.5 + r3.y / (2 * u3)) : f3, m3 = Math.sin(p3) * o3 / Math.sin(t4.ai(Math.PI - s3 - p3, 0.01, Math.PI - 0.01)), h3 = Math.min(l3, m3);
          this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - n4) * h3 + o3), this._helper._nearZ = this._helper._height / 50;
        }
        _calcMatrices() {
          if (!this._helper._height) return;
          let e6 = this.centerOffset, n4 = je2(this.worldSize, this.center), r3 = n4.x, i3 = n4.y;
          this._helper._pixelPerMeter = t4.an(1, this.center.lat) * this.worldSize;
          let a3 = t4.ak(Math.min(this.pitch, Ae2)), o3 = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(a3)), s3;
          this._calculateNearFarZIfNeeded(o3, a3, e6), s3 = new Float64Array(16), t4.b7(s3, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), t4.au(this._invProjMatrix, s3), s3[8] = 2 * -e6.x / this._helper._width, s3[9] = 2 * e6.y / this._helper._height, this._projectionMatrix = t4.b8(s3), t4.O(s3, s3, [1, -1, 1]), t4.N(s3, s3, [0, 0, -this._helper.cameraToCenterDistance]), t4.b9(s3, s3, -this.rollInRadians), t4.ba(s3, s3, this.pitchInRadians), t4.b9(s3, s3, -this.bearingInRadians), t4.N(s3, s3, [-r3, -i3, 0]), this._mercatorMatrix = t4.O([], s3, [this.worldSize, this.worldSize, this.worldSize]), t4.O(s3, s3, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = t4.Q(new Float64Array(16), this.clipSpaceToPixelsMatrix, s3), t4.N(s3, s3, [0, 0, -this.elevation]), this._viewProjMatrix = s3, this._invViewProjMatrix = t4.au([], s3);
          let c3 = [0, 0, -1, 1];
          t4.aA(c3, c3, this._invViewProjMatrix), this._cameraPosition = [c3[0] / c3[3], c3[1] / c3[3], c3[2] / c3[3]], this._fogMatrix = new Float64Array(16), t4.b7(this._fogMatrix, this.fovInRadians, this.width / this.height, o3, this._helper._farZ), this._fogMatrix[8] = 2 * -e6.x / this.width, this._fogMatrix[9] = 2 * e6.y / this.height, t4.O(this._fogMatrix, this._fogMatrix, [1, -1, 1]), t4.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), t4.b9(this._fogMatrix, this._fogMatrix, -this.rollInRadians), t4.ba(this._fogMatrix, this._fogMatrix, this.pitchInRadians), t4.b9(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), t4.N(this._fogMatrix, this._fogMatrix, [-r3, -i3, 0]), t4.O(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), t4.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = t4.Q(new Float64Array(16), this.clipSpaceToPixelsMatrix, s3);
          let l3 = this._helper._width % 2 / 2, u3 = this._helper._height % 2 / 2, d3 = Math.cos(this.bearingInRadians), f3 = Math.sin(-this.bearingInRadians), p3 = r3 - Math.round(r3) + d3 * l3 + f3 * u3, m3 = i3 - Math.round(i3) + d3 * u3 + f3 * l3, h3 = new Float64Array(s3);
          if (t4.N(h3, h3, [p3 > 0.5 ? p3 - 1 : p3, m3 > 0.5 ? m3 - 1 : m3, 0]), this._alignedProjMatrix = h3, s3 = t4.au(new Float64Array(16), this._pixelMatrix), !s3) throw Error(`failed to invert matrix`);
          this._pixelMatrixInverse = s3, this._clearMatrixCaches();
        }
        _clearMatrixCaches() {
          this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
        }
        maxPitchScaleFactor() {
          if (!this._pixelMatrixInverse) return 1;
          let e6 = this.screenPointToMercatorCoordinate(new t4.P(0, 0)), n4 = [e6.x * this.worldSize, e6.y * this.worldSize, 0, 1];
          return t4.aA(n4, n4, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
        }
        getCameraPoint() {
          return this._helper.getCameraPoint();
        }
        getCameraAltitude() {
          return this._helper.getCameraAltitude();
        }
        getCameraLngLat() {
          let e6 = t4.an(1, this.center.lat) * this.worldSize;
          return Pe2(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e6).toLngLat();
        }
        lngLatToCameraDepth(e6, n4) {
          let r3 = t4.a5.fromLngLat(e6), i3 = [r3.x * this.worldSize, r3.y * this.worldSize, n4, 1];
          return t4.aA(i3, i3, this._viewProjMatrix), i3[2] / i3[3];
        }
        getProjectionData(e6) {
          let { overscaledTileID: n4, aligned: r3, applyTerrainMatrix: i3 } = e6, a3 = this._helper.getMercatorTileCoordinates(n4), o3 = n4 ? this.calculatePosMatrix(n4, r3, true) : null, s3;
          return s3 = n4 && n4.terrainRttPosMatrix32f && i3 ? n4.terrainRttPosMatrix32f : o3 || t4.bb(), { mainMatrix: s3, tileMercatorCoords: a3, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: s3 };
        }
        isLocationOccluded(e6) {
          return false;
        }
        getPixelScale() {
          return 1;
        }
        getCircleRadiusCorrection() {
          return 1;
        }
        getPitchedTextCorrection(e6, t5, n4) {
          return 1;
        }
        transformLightDirection(e6) {
          return t4.aW(e6);
        }
        getRayDirectionFromPixel(e6) {
          throw Error(`Not implemented.`);
        }
        projectTileCoordinates(e6, n4, r3, i3) {
          let a3 = this.calculatePosMatrix(r3), o3;
          i3 ? (o3 = [e6, n4, i3(e6, n4), 1], t4.aA(o3, o3, a3)) : (o3 = [e6, n4, 0, 1], ct2(o3, o3, a3));
          let s3 = o3[3];
          return { point: new t4.P(o3[0] / s3, o3[1] / s3), signedDistanceFromCamera: s3, isOccluded: false };
        }
        populateCache(e6) {
          for (let t5 of e6) this.calculatePosMatrix(t5);
        }
        getMatrixForModel(e6, n4) {
          let r3 = t4.a5.fromLngLat(e6, n4), i3 = r3.meterInMercatorCoordinateUnits(), a3 = t4.bc();
          return t4.N(a3, a3, [r3.x, r3.y, r3.z]), t4.b9(a3, a3, Math.PI), t4.ba(a3, a3, Math.PI / 2), t4.O(a3, a3, [-i3, i3, i3]), a3;
        }
        getProjectionDataForCustomLayer(e6 = true) {
          let n4 = new t4.a0(0, 0, 0, 0, 0), r3 = this.getProjectionData({ overscaledTileID: n4, applyGlobeMatrix: e6 }), i3 = R2(n4, this.worldSize);
          t4.Q(i3, this._viewProjMatrix, i3), r3.tileMercatorCoords = [0, 0, 1, 1];
          let a3 = [t4.a3, t4.a3, this.worldSize / this._helper.pixelsPerMeter], o3 = t4.bd();
          return t4.O(o3, i3, a3), r3.fallbackMatrix = o3, r3.mainMatrix = o3, r3;
        }
        getFastPathSimpleProjectionMatrix(e6) {
          return this.calculatePosMatrix(e6);
        }
      }
      function Gt2() {
        t4.w(`Map cannot fit within canvas with the given bounds, padding, and/or offset.`);
      }
      function Kt2(e6) {
        if (e6.useSlerp) if (e6.k < 1) {
          let n4 = t4.be(e6.startEulerAngles.roll, e6.startEulerAngles.pitch, e6.startEulerAngles.bearing), r3 = t4.be(e6.endEulerAngles.roll, e6.endEulerAngles.pitch, e6.endEulerAngles.bearing), i3 = new Float64Array(4);
          t4.bf(i3, n4, r3, e6.k);
          let a3 = t4.bg(i3);
          e6.tr.setRoll(a3.roll), e6.tr.setPitch(a3.pitch), e6.tr.setBearing(a3.bearing);
        } else e6.tr.setRoll(e6.endEulerAngles.roll), e6.tr.setPitch(e6.endEulerAngles.pitch), e6.tr.setBearing(e6.endEulerAngles.bearing);
        else e6.tr.setRoll(t4.F.number(e6.startEulerAngles.roll, e6.endEulerAngles.roll, e6.k)), e6.tr.setPitch(t4.F.number(e6.startEulerAngles.pitch, e6.endEulerAngles.pitch, e6.k)), e6.tr.setBearing(t4.F.number(e6.startEulerAngles.bearing, e6.endEulerAngles.bearing, e6.k));
      }
      function qt2(e6, n4, r3, i3, a3) {
        let o3 = a3.padding, s3 = je2(a3.worldSize, r3.getNorthWest()), c3 = je2(a3.worldSize, r3.getNorthEast()), l3 = je2(a3.worldSize, r3.getSouthEast()), u3 = je2(a3.worldSize, r3.getSouthWest()), d3 = t4.ak(-i3), f3 = s3.rotate(d3), p3 = c3.rotate(d3), m3 = l3.rotate(d3), h3 = u3.rotate(d3), g3 = new t4.P(Math.max(f3.x, p3.x, h3.x, m3.x), Math.max(f3.y, p3.y, h3.y, m3.y)), _3 = new t4.P(Math.min(f3.x, p3.x, h3.x, m3.x), Math.min(f3.y, p3.y, h3.y, m3.y)), v3 = g3.sub(_3), y3 = (a3.width - (o3.left + o3.right + n4.left + n4.right)) / v3.x, b3 = (a3.height - (o3.top + o3.bottom + n4.top + n4.bottom)) / v3.y;
        if (b3 < 0 || y3 < 0) return void Gt2();
        let x3 = Math.min(t4.ao(a3.scale * Math.min(y3, b3)), e6.maxZoom), S3 = t4.P.convert(e6.offset), C3 = new t4.P((n4.left - n4.right) / 2, (n4.top - n4.bottom) / 2).rotate(t4.ak(i3)), w3 = S3.add(C3).mult(a3.scale / t4.al(x3));
        return { center: Me2(a3.worldSize, s3.add(l3).div(2).sub(w3)), zoom: x3, bearing: i3 };
      }
      class Jt2 {
        get useGlobeControls() {
          return false;
        }
        handlePanInertia(e6, t5) {
          let n4 = e6.mag(), r3 = Math.abs(Ne2(t5));
          return { easingOffset: e6.mult(Math.min(0.75 * r3 / n4, 1)), easingCenter: t5.center };
        }
        handleMapControlsRollPitchBearingZoom(e6, t5) {
          e6.bearingDelta && t5.setBearing(t5.bearing + e6.bearingDelta), e6.pitchDelta && t5.setPitch(t5.pitch + e6.pitchDelta), e6.rollDelta && t5.setRoll(t5.roll + e6.rollDelta), e6.zoomDelta && t5.setZoom(t5.zoom + e6.zoomDelta);
        }
        handleMapControlsPan(e6, t5, n4) {
          e6.around.distSqr(t5.centerPoint) < 0.01 || t5.setLocationAtPoint(n4, e6.around);
        }
        cameraForBoxAndBearing(e6, t5, n4, r3, i3) {
          return qt2(e6, t5, n4, r3, i3);
        }
        handleJumpToCenterZoom(e6, n4) {
          e6.zoom !== (n4.zoom === void 0 ? e6.zoom : +n4.zoom) && e6.setZoom(+n4.zoom), n4.center !== void 0 && e6.setCenter(t4.U.convert(n4.center));
        }
        handleEaseTo(e6, n4) {
          let r3 = e6.zoom, i3 = e6.padding, a3 = { roll: e6.roll, pitch: e6.pitch, bearing: e6.bearing }, o3 = { roll: n4.roll === void 0 ? e6.roll : n4.roll, pitch: n4.pitch === void 0 ? e6.pitch : n4.pitch, bearing: n4.bearing === void 0 ? e6.bearing : n4.bearing }, s3 = n4.zoom !== void 0, c3 = !e6.isPaddingEqual(n4.padding), l3 = false, u3 = s3 ? +n4.zoom : e6.zoom, d3 = e6.centerPoint.add(n4.offsetAsPoint), f3 = e6.screenPointToLocation(d3), { center: p3, zoom: m3 } = e6.constrain(t4.U.convert(n4.center || f3), u3 ?? r3);
          Rt2(e6, p3);
          let h3 = je2(e6.worldSize, f3), g3 = je2(e6.worldSize, p3).sub(h3), _3 = t4.al(m3 - r3);
          return l3 = m3 !== r3, { easeFunc: (s4) => {
            if (l3 && e6.setZoom(t4.F.number(r3, m3, s4)), t4.bh(a3, o3) || Kt2({ startEulerAngles: a3, endEulerAngles: o3, tr: e6, k: s4, useSlerp: a3.roll != o3.roll }), c3 && (e6.interpolatePadding(i3, n4.padding, s4), d3 = e6.centerPoint.add(n4.offsetAsPoint)), n4.around) e6.setLocationAtPoint(n4.around, n4.aroundPoint);
            else {
              let n5 = t4.al(e6.zoom - r3), i4 = (m3 > r3 ? Math.min(2, _3) : Math.max(0.5, _3)) ** (1 - s4), a4 = Me2(e6.worldSize, h3.add(g3.mult(s4 * i4)).mult(n5));
              e6.setLocationAtPoint(e6.renderWorldCopies ? a4.wrap() : a4, d3);
            }
          }, isZooming: l3, elevationCenter: p3 };
        }
        handleFlyTo(e6, n4) {
          let r3 = n4.zoom !== void 0, i3 = e6.zoom, a3 = e6.constrain(t4.U.convert(n4.center || n4.locationAtOffset), r3 ? +n4.zoom : i3), o3 = a3.center, s3 = a3.zoom;
          Rt2(e6, o3);
          let c3 = je2(e6.worldSize, n4.locationAtOffset), l3 = je2(e6.worldSize, o3).sub(c3), u3 = l3.mag(), d3 = t4.al(s3 - i3), f3;
          if (n4.minZoom !== void 0) {
            let r4 = Math.min(+n4.minZoom, i3, s3), a4 = e6.constrain(o3, r4).zoom;
            f3 = t4.al(a4 - i3);
          }
          return { easeFunc: (n5, r4, a4, u4) => {
            e6.setZoom(n5 === 1 ? s3 : i3 + t4.ao(r4));
            let d4 = n5 === 1 ? o3 : Me2(e6.worldSize, c3.add(l3.mult(a4)).mult(r4));
            e6.setLocationAtPoint(e6.renderWorldCopies ? d4.wrap() : d4, u4);
          }, scaleOfZoom: d3, targetCenter: o3, scaleOfMinZoom: f3, pixelPathLength: u3 };
        }
      }
      class Yt2 {
        constructor(e6, t5, n4) {
          this.blendFunction = e6, this.blendColor = t5, this.mask = n4;
        }
      }
      Yt2.Replace = [1, 0], Yt2.disabled = new Yt2(Yt2.Replace, t4.bi.transparent, [false, false, false, false]), Yt2.unblended = new Yt2(Yt2.Replace, t4.bi.transparent, [true, true, true, true]), Yt2.alphaBlended = new Yt2([1, 771], t4.bi.transparent, [true, true, true, true]);
      let Xt2 = 2305;
      class q2 {
        constructor(e6, t5, n4) {
          this.enable = e6, this.mode = t5, this.frontFace = n4;
        }
      }
      q2.disabled = new q2(false, 1029, Xt2), q2.backCCW = new q2(true, 1029, Xt2), q2.frontCCW = new q2(true, 1028, Xt2);
      class J2 {
        constructor(e6, t5, n4) {
          this.func = e6, this.mask = t5, this.range = n4;
        }
      }
      J2.ReadOnly = false, J2.ReadWrite = true, J2.disabled = new J2(519, J2.ReadOnly, [0, 1]);
      let Zt2 = 7680;
      class Qt2 {
        constructor(e6, t5, n4, r3, i3, a3) {
          this.test = e6, this.ref = t5, this.mask = n4, this.fail = r3, this.depthFail = i3, this.pass = a3;
        }
      }
      Qt2.disabled = new Qt2({ func: 519, mask: 0 }, 0, 0, Zt2, Zt2, Zt2);
      let $t2 = /* @__PURE__ */ new WeakMap();
      function en2(e6) {
        var _a3;
        if ($t2.has(e6)) return $t2.get(e6);
        {
          let t5 = (_a3 = e6.getParameter(e6.VERSION)) == null ? void 0 : _a3.startsWith(`WebGL 2.0`);
          return $t2.set(e6, t5), t5;
        }
      }
      class tn2 {
        get awaitingQuery() {
          return !!this._readbackQueue;
        }
        constructor(e6) {
          this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e6;
          let n4 = e6.context, r3 = n4.gl;
          this._texFormat = r3.RGBA, this._texType = r3.UNSIGNED_BYTE;
          let i3 = new t4.aP();
          i3.emplaceBack(-1, -1), i3.emplaceBack(2, -1), i3.emplaceBack(-1, 2);
          let a3 = new t4.aR();
          a3.emplaceBack(0, 1, 2), this._fullscreenTriangle = new K2(n4.createVertexBuffer(i3, Nt2.members), n4.createIndexBuffer(a3), t4.aQ.simpleSegment(0, 0, i3.length, a3.length)), this._resultBuffer = new Uint8Array(4), n4.activeTexture.set(r3.TEXTURE1);
          let o3 = r3.createTexture();
          r3.bindTexture(r3.TEXTURE_2D, o3), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_WRAP_S, r3.CLAMP_TO_EDGE), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_WRAP_T, r3.CLAMP_TO_EDGE), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_MIN_FILTER, r3.NEAREST), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_MAG_FILTER, r3.NEAREST), r3.texImage2D(r3.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = n4.createFramebuffer(this._texWidth, this._texHeight, false, false), this._fbo.colorAttachment.set(o3), en2(r3) && (this._pbo = r3.createBuffer(), r3.bindBuffer(r3.PIXEL_PACK_BUFFER, this._pbo), r3.bufferData(r3.PIXEL_PACK_BUFFER, 4, r3.STREAM_READ), r3.bindBuffer(r3.PIXEL_PACK_BUFFER, null));
        }
        destroy() {
          let e6 = this._cachedRenderContext.context.gl;
          this._fullscreenTriangle.destroy(), this._fbo.destroy(), e6.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
        }
        updateErrorLoop(e6, t5) {
          let n4 = this._updateCount;
          return this._readbackQueue ? n4 >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : n4 >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e6, t5), this._updateCount++, this._measuredError;
        }
        _bindFramebuffer() {
          let e6 = this._cachedRenderContext.context, t5 = e6.gl;
          e6.activeTexture.set(t5.TEXTURE1), t5.bindTexture(t5.TEXTURE_2D, this._fbo.colorAttachment.get()), e6.bindFramebuffer.set(this._fbo.framebuffer);
        }
        _renderErrorTexture(e6, n4) {
          let r3 = this._cachedRenderContext.context, i3 = r3.gl;
          if (this._bindFramebuffer(), r3.viewport.set([0, 0, this._texWidth, this._texHeight]), r3.clear({ color: t4.bi.transparent }), this._cachedRenderContext.useProgram(`projectionErrorMeasurement`).draw(r3, i3.TRIANGLES, J2.disabled, Qt2.disabled, Yt2.unblended, q2.disabled, /* @__PURE__ */ ((e7, t5) => ({ u_input: e7, u_output_expected: t5 }))(e6, n4), null, null, `$clipping`, this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && en2(i3)) {
            i3.bindBuffer(i3.PIXEL_PACK_BUFFER, this._pbo), i3.readBuffer(i3.COLOR_ATTACHMENT0), i3.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), i3.bindBuffer(i3.PIXEL_PACK_BUFFER, null);
            let e7 = i3.fenceSync(i3.SYNC_GPU_COMMANDS_COMPLETE, 0);
            i3.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: e7 };
          } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
        }
        _tryReadback() {
          let e6 = this._cachedRenderContext.context.gl;
          if (this._pbo && this._readbackQueue && en2(e6)) {
            let n4 = e6.clientWaitSync(this._readbackQueue.sync, 0, 0);
            if (n4 === e6.WAIT_FAILED) return t4.w(`WebGL2 clientWaitSync failed.`), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
            if (n4 === e6.TIMEOUT_EXPIRED) return;
            e6.bindBuffer(e6.PIXEL_PACK_BUFFER, this._pbo), e6.getBufferSubData(e6.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e6.bindBuffer(e6.PIXEL_PACK_BUFFER, null);
          } else this._bindFramebuffer(), e6.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
          this._readbackQueue = null, this._measuredError = tn2._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
        }
        static _parseRGBA8float(e6) {
          let t5 = 0;
          return t5 += e6[0] / 256, t5 += e6[1] / 65536, t5 += e6[2] / 16777216, e6[3] < 127 && (t5 = -t5), t5 / 128;
        }
      }
      let nn2 = t4.a3 / 128;
      function rn2(e6, n4) {
        let r3 = e6.granularity === void 0 ? 1 : Math.max(e6.granularity, 1), i3 = r3 + (e6.generateBorders ? 2 : 0), a3 = r3 + (e6.extendToNorthPole || e6.generateBorders ? 1 : 0) + (e6.extendToSouthPole || e6.generateBorders ? 1 : 0), o3 = i3 + 1, s3 = a3 + 1, c3 = e6.generateBorders ? -1 : 0, l3 = e6.generateBorders || e6.extendToNorthPole ? -1 : 0, u3 = r3 + (e6.generateBorders ? 1 : 0), d3 = r3 + (e6.generateBorders || e6.extendToSouthPole ? 1 : 0), f3 = o3 * s3, p3 = i3 * a3 * 6, m3 = o3 * s3 > 65536;
        if (m3 && n4 === `16bit`) throw Error(`Granularity is too large and meshes would not fit inside 16 bit vertex indices.`);
        let h3 = m3 || n4 === `32bit`, g3 = new Int16Array(2 * f3), _3 = 0;
        for (let n5 = l3; n5 <= d3; n5++) for (let i4 = c3; i4 <= u3; i4++) {
          let a4 = i4 / r3 * t4.a3;
          i4 === -1 && (a4 = -nn2), i4 === r3 + 1 && (a4 = t4.a3 + nn2);
          let o4 = n5 / r3 * t4.a3;
          n5 === -1 && (o4 = e6.extendToNorthPole ? t4.bk : -nn2), n5 === r3 + 1 && (o4 = e6.extendToSouthPole ? t4.bl : t4.a3 + nn2), g3[_3++] = a4, g3[_3++] = o4;
        }
        let v3 = h3 ? new Uint32Array(p3) : new Uint16Array(p3), y3 = 0;
        for (let e7 = 0; e7 < a3; e7++) for (let t5 = 0; t5 < i3; t5++) {
          let n5 = t5 + 1 + e7 * o3, r4 = t5 + (e7 + 1) * o3, i4 = t5 + 1 + (e7 + 1) * o3;
          v3[y3++] = t5 + e7 * o3, v3[y3++] = r4, v3[y3++] = n5, v3[y3++] = n5, v3[y3++] = r4, v3[y3++] = i4;
        }
        return { vertices: g3.buffer.slice(0), indices: v3.buffer.slice(0), uses32bitIndices: h3 };
      }
      let an2 = new t4.aO({ fill: new t4.bm(128, 2), line: new t4.bm(512, 0), tile: new t4.bm(128, 32), stencil: new t4.bm(128, 1), circle: 3 });
      class on2 {
        constructor() {
          this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
        }
        get name() {
          return `vertical-perspective`;
        }
        get transitionState() {
          return 1;
        }
        get useSubdivision() {
          return true;
        }
        get shaderVariantName() {
          return `globe`;
        }
        get shaderDefine() {
          return `#define GLOBE`;
        }
        get shaderPreludeCode() {
          return Mt2.projectionGlobe;
        }
        get vertexShaderPreludeCode() {
          return Mt2.projectionMercator.vertexSource;
        }
        get subdivisionGranularity() {
          return an2;
        }
        get useGlobeControls() {
          return true;
        }
        get latitudeErrorCorrectionRadians() {
          return this._errorCorrectionUsable;
        }
        destroy() {
          this._errorMeasurement && this._errorMeasurement.destroy();
        }
        updateGPUdependent(e6) {
          this._errorMeasurement || (this._errorMeasurement = new tn2(e6));
          let n4 = t4.W(this._errorQueryLatitudeDegrees), r3 = 2 * Math.atan(Math.exp(Math.PI - n4 * Math.PI * 2)) - 0.5 * Math.PI, i3 = this._errorMeasurement.updateErrorLoop(n4, r3), a3 = c2();
          i3 !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = i3, this._errorMeasurementLastChangeTime = a3);
          let o3 = Math.min(Math.max((a3 - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
          this._errorCorrectionUsable = t4.bn(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, t4.bo(o3));
        }
        _getMeshKey(e6) {
          return `${e6.granularity.toString(36)}_${e6.generateBorders ? `b` : ``}${e6.extendToNorthPole ? `n` : ``}${e6.extendToSouthPole ? `s` : ``}`;
        }
        getMeshFromTileID(e6, t5, n4, r3, i3) {
          let a3 = (i3 === `stencil` ? an2.stencil : an2.tile).getGranularityForZoomLevel(t5.z);
          return this._getMesh(e6, { granularity: a3, generateBorders: n4, extendToNorthPole: t5.y === 0 && r3, extendToSouthPole: t5.y === (1 << t5.z) - 1 && r3 });
        }
        _getMesh(e6, n4) {
          let r3 = this._getMeshKey(n4);
          if (r3 in this._tileMeshCache) return this._tileMeshCache[r3];
          let i3 = (function(e7, n5) {
            let r4 = rn2(n5, `16bit`), i4 = t4.aP.deserialize({ arrayBuffer: r4.vertices, length: r4.vertices.byteLength / 2 / 2 }), a3 = t4.aR.deserialize({ arrayBuffer: r4.indices, length: r4.indices.byteLength / 2 / 3 });
            return new K2(e7.createVertexBuffer(i4, Nt2.members), e7.createIndexBuffer(a3), t4.aQ.simpleSegment(0, 0, i4.length, a3.length));
          })(e6, n4);
          return this._tileMeshCache[r3] = i3, i3;
        }
        recalculate(e6) {
        }
        hasTransition() {
          let e6 = c2(), t5 = false;
          return t5 || (t5 = (e6 - this._errorMeasurementLastChangeTime) / 1e3 < 0.7), t5 || (t5 = this._errorMeasurement && this._errorMeasurement.awaitingQuery), t5;
        }
        setErrorQueryLatitudeDegrees(e6) {
          this._errorQueryLatitudeDegrees = e6;
        }
      }
      let sn2 = new t4.r({ type: new t4.D(t4.t.projection.type) });
      class cn2 extends t4.E {
        constructor(e6) {
          super(), this._transitionable = new t4.x(sn2, void 0), this.setProjection(e6), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t4.G(0)), this._mercatorProjection = new It2(), this._verticalPerspectiveProjection = new on2();
        }
        get transitionState() {
          let e6 = this.properties.get(`type`);
          if (typeof e6 == `string` && e6 === `mercator`) return 0;
          if (typeof e6 == `string` && e6 === `vertical-perspective`) return 1;
          if (e6 instanceof t4.bp) {
            if (e6.from === `vertical-perspective` && e6.to === `mercator`) return 1 - e6.transition;
            if (e6.from === `mercator` && e6.to === `vertical-perspective`) return e6.transition;
          }
          return 1;
        }
        get useGlobeRendering() {
          return this.transitionState > 0;
        }
        get latitudeErrorCorrectionRadians() {
          return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
        }
        get currentProjection() {
          return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
        }
        get name() {
          return `globe`;
        }
        get useSubdivision() {
          return this.currentProjection.useSubdivision;
        }
        get shaderVariantName() {
          return this.currentProjection.shaderVariantName;
        }
        get shaderDefine() {
          return this.currentProjection.shaderDefine;
        }
        get shaderPreludeCode() {
          return this.currentProjection.shaderPreludeCode;
        }
        get vertexShaderPreludeCode() {
          return this.currentProjection.vertexShaderPreludeCode;
        }
        get subdivisionGranularity() {
          return this.currentProjection.subdivisionGranularity;
        }
        get useGlobeControls() {
          return this.transitionState > 0;
        }
        destroy() {
          this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
        }
        updateGPUdependent(e6) {
          this._mercatorProjection.updateGPUdependent(e6), this._verticalPerspectiveProjection.updateGPUdependent(e6);
        }
        getMeshFromTileID(e6, t5, n4, r3, i3) {
          return this.currentProjection.getMeshFromTileID(e6, t5, n4, r3, i3);
        }
        setProjection(e6) {
          this._transitionable.setValue(`type`, (e6 == null ? void 0 : e6.type) || `mercator`);
        }
        updateTransitions(e6) {
          this._transitioning = this._transitionable.transitioned(e6, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
        }
        recalculate(e6) {
          this.properties = this._transitioning.possiblyEvaluate(e6);
        }
        setErrorQueryLatitudeDegrees(e6) {
          this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e6), this._mercatorProjection.setErrorQueryLatitudeDegrees(e6);
        }
      }
      function ln2(e6) {
        let t5 = fn2(e6.worldSize, e6.center.lat);
        return 2 * Math.PI * t5;
      }
      function un2(e6, n4, r3, i3, a3) {
        let o3 = 1 / (1 << a3), s3 = n4 / t4.a3 * o3 + i3 * o3, c3 = t4.br((e6 / t4.a3 * o3 + r3 * o3) * Math.PI * 2 + Math.PI, 2 * Math.PI), l3 = 2 * Math.atan(Math.exp(Math.PI - s3 * Math.PI * 2)) - 0.5 * Math.PI, u3 = Math.cos(l3), d3 = new Float64Array(3);
        return d3[0] = Math.sin(c3) * u3, d3[1] = Math.sin(l3), d3[2] = Math.cos(c3) * u3, d3;
      }
      function dn2(e6) {
        return (function(e7, t5) {
          let n4 = Math.cos(t5), r3 = new Float64Array(3);
          return r3[0] = Math.sin(e7) * n4, r3[1] = Math.sin(t5), r3[2] = Math.cos(e7) * n4, r3;
        })(e6.lng * Math.PI / 180, e6.lat * Math.PI / 180);
      }
      function fn2(e6, t5) {
        return e6 / (2 * Math.PI) / Math.cos(t5 * Math.PI / 180);
      }
      function pn2(e6) {
        let n4 = Math.asin(e6[1]) / Math.PI * 180, r3 = Math.sqrt(e6[0] * e6[0] + e6[2] * e6[2]);
        if (r3 > 1e-6) {
          let i3 = e6[0] / r3, a3 = Math.acos(e6[2] / r3), o3 = (i3 > 0 ? a3 : -a3) / Math.PI * 180;
          return new t4.U(t4.V(o3, -180, 180), n4);
        }
        return new t4.U(0, n4);
      }
      function mn(e6) {
        return Math.cos(e6 * Math.PI / 180);
      }
      function hn(e6, n4) {
        let r3 = mn(e6), i3 = mn(n4);
        return t4.ao(i3 / r3);
      }
      function gn(e6, n4) {
        let r3 = e6.rotate(n4.bearingInRadians), i3 = n4.zoom + hn(n4.center.lat, 0), a3 = t4.bn(1 / mn(n4.center.lat), 1 / mn(Math.min(Math.abs(n4.center.lat), 60)), t4.bq(i3, 7, 3, 0, 1)), o3 = 360 / ln2({ worldSize: n4.worldSize, center: { lat: n4.center.lat } });
        return new t4.U(n4.center.lng - r3.x * o3 * a3, t4.ai(n4.center.lat + r3.y * o3, -t4.aj, t4.aj));
      }
      function _n(e6) {
        let t5 = 0.5 * e6, n4 = Math.sin(t5), r3 = Math.cos(t5);
        return Math.log(n4 + r3) - Math.log(r3 - n4);
      }
      function vn(e6, n4, r3, i3) {
        let a3 = e6.lat + r3 * i3;
        if (Math.abs(r3) > 1) {
          let o3 = (Math.sign(e6.lat + r3) === Math.sign(e6.lat) ? Math.abs(e6.lat) : -Math.abs(e6.lat)) * Math.PI / 180, s3 = Math.abs(e6.lat + r3) * Math.PI / 180, c3 = _n(o3 + i3 * (s3 - o3)), l3 = _n(o3), u3 = _n(s3);
          return new t4.U(e6.lng + n4 * ((c3 - l3) / (u3 - l3)), a3);
        }
        return new t4.U(e6.lng + n4 * i3, a3);
      }
      class yn {
        constructor(e6) {
          this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = false, this._boundingVolumeFactory = e6;
        }
        swapBuffers() {
          if (!this._hadAnyChanges) return;
          let e6 = this._cachePrevious;
          this._cachePrevious = this._cache, this._cache = e6, this._cache.clear(), this._hadAnyChanges = false;
        }
        getTileBoundingVolume(e6, t5, n4, r3) {
          let i3 = `${e6.z}_${e6.x}_${e6.y}_${(r3 == null ? void 0 : r3.terrain) ? `t` : ``}`, a3 = this._cache.get(i3);
          if (a3) return a3;
          let o3 = this._cachePrevious.get(i3);
          if (o3) return this._cache.set(i3, o3), o3;
          let s3 = this._boundingVolumeFactory(e6, t5, n4, r3);
          return this._cache.set(i3, s3), this._hadAnyChanges = true, s3;
        }
      }
      class bn {
        constructor(e6, t5, n4, r3) {
          this.min = n4, this.max = r3, this.points = e6, this.planes = t5;
        }
        static fromAabb(e6, t5) {
          let n4 = [];
          for (let r3 = 0; r3 < 8; r3++) n4.push([1 & ~r3 ? e6[0] : t5[0], (r3 >> 1 & 1) == 1 ? t5[1] : e6[1], (r3 >> 2 & 1) == 1 ? t5[2] : e6[2]]);
          return new bn(n4, [[-1, 0, 0, t5[0]], [1, 0, 0, -e6[0]], [0, -1, 0, t5[1]], [0, 1, 0, -e6[1]], [0, 0, -1, t5[2]], [0, 0, 1, -e6[2]]], e6, t5);
        }
        static fromCenterSizeAngles(e6, n4, r3) {
          let i3 = t4.bu([], r3[0], r3[1], r3[2]), a3 = t4.bv([], [n4[0], 0, 0], i3), o3 = t4.bv([], [0, n4[1], 0], i3), s3 = t4.bv([], [0, 0, n4[2]], i3), c3 = [...e6], l3 = [...e6];
          for (let t5 = 0; t5 < 8; t5++) for (let n5 = 0; n5 < 3; n5++) {
            let r4 = e6[n5] + a3[n5] * (1 & ~t5 ? -1 : 1) + o3[n5] * ((t5 >> 1 & 1) == 1 ? 1 : -1) + s3[n5] * ((t5 >> 2 & 1) == 1 ? 1 : -1);
            c3[n5] = Math.min(c3[n5], r4), l3[n5] = Math.max(l3[n5], r4);
          }
          let u3 = [];
          for (let n5 = 0; n5 < 8; n5++) {
            let r4 = [...e6];
            t4.aV(r4, r4, t4.aU([], a3, 1 & ~n5 ? -1 : 1)), t4.aV(r4, r4, t4.aU([], o3, (n5 >> 1 & 1) == 1 ? 1 : -1)), t4.aV(r4, r4, t4.aU([], s3, (n5 >> 2 & 1) == 1 ? 1 : -1)), u3.push(r4);
          }
          return new bn(u3, [[...a3, -t4.a_(a3, u3[0])], [...o3, -t4.a_(o3, u3[0])], [...s3, -t4.a_(s3, u3[0])], [-a3[0], -a3[1], -a3[2], -t4.a_(a3, u3[7])], [-o3[0], -o3[1], -o3[2], -t4.a_(o3, u3[7])], [-s3[0], -s3[1], -s3[2], -t4.a_(s3, u3[7])]], c3, l3);
        }
        intersectsFrustum(e6) {
          let t5 = true, n4 = this.points.length, r3 = this.planes.length, i3 = e6.planes.length, a3 = e6.points.length;
          for (let r4 = 0; r4 < i3; r4++) {
            let i4 = e6.planes[r4], a4 = 0;
            for (let e7 = 0; e7 < n4; e7++) {
              let t6 = this.points[e7];
              i4[0] * t6[0] + i4[1] * t6[1] + i4[2] * t6[2] + i4[3] >= 0 && a4++;
            }
            if (a4 === 0) return 0;
            a4 < n4 && (t5 = false);
          }
          if (t5) return 2;
          for (let t6 = 0; t6 < r3; t6++) {
            let n5 = this.planes[t6], r4 = 0;
            for (let t7 = 0; t7 < a3; t7++) {
              let i4 = e6.points[t7];
              n5[0] * i4[0] + n5[1] * i4[1] + n5[2] * i4[2] + n5[3] >= 0 && r4++;
            }
            if (r4 === 0) return 0;
          }
          return 1;
        }
        intersectsPlane(e6) {
          let t5 = this.points.length, n4 = 0;
          for (let r3 = 0; r3 < t5; r3++) {
            let t6 = this.points[r3];
            e6[0] * t6[0] + e6[1] * t6[1] + e6[2] * t6[2] + e6[3] >= 0 && n4++;
          }
          return n4 === t5 ? 2 : n4 === 0 ? 0 : 1;
        }
      }
      function xn(e6, t5, n4) {
        let r3 = e6 - t5;
        return r3 < 0 ? -r3 : Math.max(0, r3 - n4);
      }
      function Sn(e6, t5, n4, r3, i3) {
        let a3 = e6 - n4, o3;
        return o3 = a3 < 0 ? Math.min(-a3, 1 + a3 - i3) : a3 > 1 ? Math.min(Math.max(a3 - i3, 0), 1 - a3) : 0, Math.max(o3, xn(t5, r3, i3));
      }
      class Cn {
        constructor() {
          this._boundingVolumeCache = new yn(this._computeTileBoundingVolume);
        }
        prepareNextFrame() {
          this._boundingVolumeCache.swapBuffers();
        }
        distanceToTile2d(e6, t5, n4, r3) {
          let i3 = 1 << n4.z, a3 = 1 / i3, o3 = n4.x / i3, s3 = n4.y / i3, c3 = 2;
          return c3 = Math.min(c3, Sn(e6, t5, o3, s3, a3)), c3 = Math.min(c3, Sn(e6, t5, o3 + 0.5, -s3 - a3, a3)), c3 = Math.min(c3, Sn(e6, t5, o3 + 0.5, 2 - s3 - a3, a3)), c3;
        }
        getWrap(e6, t5, n4) {
          let r3 = 1 << t5.z, i3 = 1 / r3, a3 = t5.x / r3, o3 = xn(e6.x, a3, i3), s3 = xn(e6.x, a3 - 1, i3), c3 = xn(e6.x, a3 + 1, i3), l3 = Math.min(o3, s3, c3);
          return l3 === c3 ? 1 : l3 === s3 ? -1 : 0;
        }
        allowVariableZoom(e6, t5) {
          return ze2(e6, t5) > 4;
        }
        allowWorldCopies() {
          return false;
        }
        getTileBoundingVolume(e6, t5, n4, r3) {
          return this._boundingVolumeCache.getTileBoundingVolume(e6, t5, n4, r3);
        }
        _computeTileBoundingVolume(e6, n4, r3, i3) {
          let a3 = 0, o3 = 0;
          if (i3 == null ? void 0 : i3.terrain) {
            let s3 = new t4.a0(e6.z, n4, e6.z, e6.x, e6.y), c3 = i3.terrain.getMinMaxElevation(s3);
            a3 = c3.minElevation ?? Math.min(0, r3), o3 = c3.maxElevation ?? Math.max(0, r3);
          }
          if (a3 /= t4.bx, o3 /= t4.bx, a3 += 1, o3 += 1, e6.z <= 0) return bn.fromAabb([-o3, -o3, -o3], [o3, o3, o3]);
          if (e6.z === 1) return bn.fromAabb([e6.x === 0 ? -o3 : 0, e6.y === 0 ? 0 : -o3, -o3], [e6.x === 0 ? 0 : o3, e6.y === 0 ? o3 : 0, o3]);
          {
            let n5 = [un2(0, 0, e6.x, e6.y, e6.z), un2(t4.a3, 0, e6.x, e6.y, e6.z), un2(t4.a3, t4.a3, e6.x, e6.y, e6.z), un2(0, t4.a3, e6.x, e6.y, e6.z)], r4 = [];
            for (let e7 of n5) r4.push(t4.aU([], e7, o3));
            if (o3 !== a3) for (let e7 of n5) r4.push(t4.aU([], e7, a3));
            e6.y === 0 && r4.push([0, 1, 0]), e6.y === (1 << e6.z) - 1 && r4.push([0, -1, 0]);
            let i4 = [1, 1, 1], s3 = [-1, -1, -1];
            for (let e7 of r4) for (let t5 = 0; t5 < 3; t5++) i4[t5] = Math.min(i4[t5], e7[t5]), s3[t5] = Math.max(s3[t5], e7[t5]);
            let c3 = un2(t4.a3 / 2, t4.a3 / 2, e6.x, e6.y, e6.z), l3 = t4.aZ([], [0, 1, 0], c3);
            t4.aY(l3, l3);
            let u3 = t4.aZ([], c3, l3);
            t4.aY(u3, u3);
            let d3 = t4.aZ([], n5[2], n5[1]);
            t4.aY(d3, d3);
            let f3 = t4.aZ([], n5[0], n5[3]);
            t4.aY(f3, f3), r4.push(t4.aU([], c3, o3)), e6.y >= (1 << e6.z) / 2 && r4.push(t4.aU([], un2(t4.a3 / 2, 0, e6.x, e6.y, e6.z), o3)), e6.y < (1 << e6.z) / 2 && r4.push(t4.aU([], un2(t4.a3 / 2, t4.a3, e6.x, e6.y, e6.z), o3));
            let p3 = wn(c3, r4), m3 = wn(u3, r4), h3 = [-c3[0], -c3[1], -c3[2], p3.max], g3 = [c3[0], c3[1], c3[2], -p3.min], _3 = [-u3[0], -u3[1], -u3[2], m3.max], v3 = [u3[0], u3[1], u3[2], -m3.min], y3 = [...d3, 0], b3 = [...f3, 0], x3 = [];
            return e6.y === 0 ? x3.push(t4.bw(b3, y3, h3), t4.bw(b3, y3, g3)) : x3.push(t4.bw(_3, y3, h3), t4.bw(_3, y3, g3), t4.bw(_3, b3, h3), t4.bw(_3, b3, g3)), e6.y === (1 << e6.z) - 1 ? x3.push(t4.bw(b3, y3, h3), t4.bw(b3, y3, g3)) : x3.push(t4.bw(v3, y3, h3), t4.bw(v3, y3, g3), t4.bw(v3, b3, h3), t4.bw(v3, b3, g3)), new bn(x3, [h3, g3, _3, v3, y3, b3], i4, s3);
          }
        }
      }
      function wn(e6, n4) {
        let r3 = 1 / 0, i3 = -1 / 0;
        for (let a3 of n4) {
          let n5 = t4.a_(e6, a3);
          r3 = Math.min(r3, n5), i3 = Math.max(i3, n5);
        }
        return { min: r3, max: i3 };
      }
      class Tn {
        get pixelsToClipSpaceMatrix() {
          return this._helper.pixelsToClipSpaceMatrix;
        }
        get clipSpaceToPixelsMatrix() {
          return this._helper.clipSpaceToPixelsMatrix;
        }
        get pixelsToGLUnits() {
          return this._helper.pixelsToGLUnits;
        }
        get centerOffset() {
          return this._helper.centerOffset;
        }
        get size() {
          return this._helper.size;
        }
        get rotationMatrix() {
          return this._helper.rotationMatrix;
        }
        get centerPoint() {
          return this._helper.centerPoint;
        }
        get pixelsPerMeter() {
          return this._helper.pixelsPerMeter;
        }
        setMinZoom(e6) {
          this._helper.setMinZoom(e6);
        }
        setMaxZoom(e6) {
          this._helper.setMaxZoom(e6);
        }
        setMinPitch(e6) {
          this._helper.setMinPitch(e6);
        }
        setMaxPitch(e6) {
          this._helper.setMaxPitch(e6);
        }
        setRenderWorldCopies(e6) {
          this._helper.setRenderWorldCopies(e6);
        }
        setBearing(e6) {
          this._helper.setBearing(e6);
        }
        setPitch(e6) {
          this._helper.setPitch(e6);
        }
        setRoll(e6) {
          this._helper.setRoll(e6);
        }
        setFov(e6) {
          this._helper.setFov(e6);
        }
        setZoom(e6) {
          this._helper.setZoom(e6);
        }
        setCenter(e6) {
          this._helper.setCenter(e6);
        }
        setElevation(e6) {
          this._helper.setElevation(e6);
        }
        setMinElevationForCurrentTile(e6) {
          this._helper.setMinElevationForCurrentTile(e6);
        }
        setPadding(e6) {
          this._helper.setPadding(e6);
        }
        interpolatePadding(e6, t5, n4) {
          return this._helper.interpolatePadding(e6, t5, n4);
        }
        isPaddingEqual(e6) {
          return this._helper.isPaddingEqual(e6);
        }
        resize(e6, t5) {
          this._helper.resize(e6, t5);
        }
        getMaxBounds() {
          return this._helper.getMaxBounds();
        }
        setMaxBounds(e6) {
          this._helper.setMaxBounds(e6);
        }
        setConstrain(e6) {
          this._helper.setConstrain(e6);
        }
        overrideNearFarZ(e6, t5) {
          this._helper.overrideNearFarZ(e6, t5);
        }
        clearNearFarZOverride() {
          this._helper.clearNearFarZOverride();
        }
        getCameraQueryGeometry(e6) {
          return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e6);
        }
        get tileSize() {
          return this._helper.tileSize;
        }
        get tileZoom() {
          return this._helper.tileZoom;
        }
        get scale() {
          return this._helper.scale;
        }
        get worldSize() {
          return this._helper.worldSize;
        }
        get width() {
          return this._helper.width;
        }
        get height() {
          return this._helper.height;
        }
        get lngRange() {
          return this._helper.lngRange;
        }
        get latRange() {
          return this._helper.latRange;
        }
        get minZoom() {
          return this._helper.minZoom;
        }
        get maxZoom() {
          return this._helper.maxZoom;
        }
        get zoom() {
          return this._helper.zoom;
        }
        get center() {
          return this._helper.center;
        }
        get minPitch() {
          return this._helper.minPitch;
        }
        get maxPitch() {
          return this._helper.maxPitch;
        }
        get pitch() {
          return this._helper.pitch;
        }
        get pitchInRadians() {
          return this._helper.pitchInRadians;
        }
        get roll() {
          return this._helper.roll;
        }
        get rollInRadians() {
          return this._helper.rollInRadians;
        }
        get bearing() {
          return this._helper.bearing;
        }
        get bearingInRadians() {
          return this._helper.bearingInRadians;
        }
        get fov() {
          return this._helper.fov;
        }
        get fovInRadians() {
          return this._helper.fovInRadians;
        }
        get elevation() {
          return this._helper.elevation;
        }
        get minElevationForCurrentTile() {
          return this._helper.minElevationForCurrentTile;
        }
        get padding() {
          return this._helper.padding;
        }
        get unmodified() {
          return this._helper.unmodified;
        }
        get renderWorldCopies() {
          return this._helper.renderWorldCopies;
        }
        get constrain() {
          return this._helper.constrain;
        }
        get nearZ() {
          return this._helper.nearZ;
        }
        get farZ() {
          return this._helper.farZ;
        }
        get autoCalculateNearFarZ() {
          return this._helper.autoCalculateNearFarZ;
        }
        setTransitionState(e6) {
        }
        constructor(e6) {
          this._cachedClippingPlane = t4.by(), this._projectionMatrix = t4.bc(), this._globeViewProjMatrix32f = t4.bb(), this._globeViewProjMatrixNoCorrection = t4.bc(), this._globeViewProjMatrixNoCorrectionInverted = t4.bc(), this._globeProjMatrixInverted = t4.bc(), this._cameraPosition = t4.bs(), this._globeLatitudeErrorCorrectionRadians = 0, this.defaultConstrain = (e7, n4) => {
            let r3 = t4.ai(e7.lat, -t4.aj, t4.aj), i3 = t4.ai(+n4, this.minZoom + hn(0, r3), this.maxZoom);
            return { center: new t4.U(e7.lng, r3), zoom: i3 };
          }, this._helper = new Bt2({ calcMatrices: () => {
            this._calcMatrices();
          }, constrain: (e7, t5) => this.defaultConstrain(e7, t5) }, e6), this._coveringTilesDetailsProvider = new Cn();
        }
        clone() {
          let e6 = new Tn();
          return e6.apply(this), e6;
        }
        apply(e6, t5) {
          this._globeLatitudeErrorCorrectionRadians = t5 || 0, this._helper.apply(e6);
        }
        get projectionMatrix() {
          return this._projectionMatrix;
        }
        get modelViewProjectionMatrix() {
          return this._globeViewProjMatrixNoCorrection;
        }
        get inverseProjectionMatrix() {
          return this._globeProjMatrixInverted;
        }
        get cameraPosition() {
          let e6 = t4.bs();
          return e6[0] = this._cameraPosition[0], e6[1] = this._cameraPosition[1], e6[2] = this._cameraPosition[2], e6;
        }
        get cameraToCenterDistance() {
          return this._helper.cameraToCenterDistance;
        }
        getProjectionData(e6) {
          let { overscaledTileID: t5, applyGlobeMatrix: n4 } = e6, r3 = this._helper.getMercatorTileCoordinates(t5);
          return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: r3, clippingPlane: this._cachedClippingPlane, projectionTransition: n4 ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
        }
        _computeClippingPlane(e6) {
          let n4 = this.pitchInRadians, r3 = this.cameraToCenterDistance / e6, i3 = Math.sin(n4) * r3, a3 = Math.cos(n4) * r3 + 1, o3 = 1 / Math.sqrt(i3 * i3 + a3 * a3) * 1, s3 = -i3, c3 = a3, l3 = Math.sqrt(s3 * s3 + c3 * c3);
          s3 /= l3, c3 /= l3;
          let u3 = [0, s3, c3];
          t4.bz(u3, u3, [0, 0, 0], -this.bearingInRadians), t4.bA(u3, u3, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), t4.bB(u3, u3, [0, 0, 0], this.center.lng * Math.PI / 180);
          let d3 = 1 / t4.b0(u3);
          return t4.aU(u3, u3, d3), [...u3, -o3 * d3];
        }
        isLocationOccluded(e6) {
          return !this.isSurfacePointVisible(dn2(e6));
        }
        transformLightDirection(e6) {
          let n4 = this._helper._center.lng * Math.PI / 180, r3 = this._helper._center.lat * Math.PI / 180, i3 = Math.cos(r3), a3 = [Math.sin(n4) * i3, Math.sin(r3), Math.cos(n4) * i3], o3 = [a3[2], 0, -a3[0]], s3 = [0, 0, 0];
          t4.aZ(s3, o3, a3), t4.aY(o3, o3), t4.aY(s3, s3);
          let c3 = [0, 0, 0];
          return t4.aY(c3, [o3[0] * e6[0] + s3[0] * e6[1] + a3[0] * e6[2], o3[1] * e6[0] + s3[1] * e6[1] + a3[1] * e6[2], o3[2] * e6[0] + s3[2] * e6[1] + a3[2] * e6[2]]), c3;
        }
        getPixelScale() {
          return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
        }
        getCircleRadiusCorrection() {
          return Math.cos(this._helper._center.lat * Math.PI / 180);
        }
        getPitchedTextCorrection(e6, n4, r3) {
          let i3 = (function(e7, n5, r4) {
            let i4 = 1 / (1 << r4.z);
            return new t4.a5(e7 / t4.a3 * i4 + r4.x * i4, n5 / t4.a3 * i4 + r4.y * i4);
          })(e6, n4, r3.canonical), a3 = (o3 = i3.y, [t4.br(i3.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - o3 * Math.PI * 2)) - 0.5 * Math.PI]);
          var o3;
          return this.getCircleRadiusCorrection() / Math.cos(a3[1]);
        }
        projectTileCoordinates(e6, n4, r3, i3) {
          let a3 = r3.canonical, o3 = un2(e6, n4, a3.x, a3.y, a3.z), s3 = 1 + (i3 ? i3(e6, n4) : 0) / t4.bx, c3 = [o3[0] * s3, o3[1] * s3, o3[2] * s3, 1];
          t4.aA(c3, c3, this._globeViewProjMatrixNoCorrection);
          let l3 = this._cachedClippingPlane, u3 = l3[0] * o3[0] + l3[1] * o3[1] + l3[2] * o3[2] + l3[3] < 0;
          return { point: new t4.P(c3[0] / c3[3], c3[1] / c3[3]), signedDistanceFromCamera: c3[3], isOccluded: u3 };
        }
        _calcMatrices() {
          if (!this._helper._width || !this._helper._height) return;
          let e6 = fn2(this.worldSize, this.center.lat), n4 = t4.bd(), r3 = t4.bd();
          this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * e6), t4.b7(n4, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
          let i3 = this.centerOffset;
          n4[8] = 2 * -i3.x / this._helper._width, n4[9] = 2 * i3.y / this._helper._height, this._projectionMatrix = t4.b8(n4), this._globeProjMatrixInverted = t4.bd(), t4.au(this._globeProjMatrixInverted, n4), t4.N(n4, n4, [0, 0, -this.cameraToCenterDistance]), t4.b9(n4, n4, this.rollInRadians), t4.ba(n4, n4, -this.pitchInRadians), t4.b9(n4, n4, this.bearingInRadians), t4.N(n4, n4, [0, 0, -e6]);
          let a3 = t4.bs();
          a3[0] = e6, a3[1] = e6, a3[2] = e6, t4.ba(r3, n4, this.center.lat * Math.PI / 180), t4.bC(r3, r3, -this.center.lng * Math.PI / 180), t4.O(r3, r3, a3), this._globeViewProjMatrixNoCorrection = r3, t4.ba(n4, n4, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), t4.bC(n4, n4, -this.center.lng * Math.PI / 180), t4.O(n4, n4, a3), this._globeViewProjMatrix32f = new Float32Array(n4), this._globeViewProjMatrixNoCorrectionInverted = t4.bd(), t4.au(this._globeViewProjMatrixNoCorrectionInverted, r3);
          let o3 = t4.bs();
          this._cameraPosition = t4.bs(), this._cameraPosition[2] = this.cameraToCenterDistance / e6, t4.bz(this._cameraPosition, this._cameraPosition, o3, -this.rollInRadians), t4.bA(this._cameraPosition, this._cameraPosition, o3, this.pitchInRadians), t4.bz(this._cameraPosition, this._cameraPosition, o3, -this.bearingInRadians), t4.aV(this._cameraPosition, this._cameraPosition, [0, 0, 1]), t4.bA(this._cameraPosition, this._cameraPosition, o3, -this.center.lat * Math.PI / 180), t4.bB(this._cameraPosition, this._cameraPosition, o3, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e6);
          let s3 = t4.b8(this._globeViewProjMatrixNoCorrectionInverted);
          t4.O(s3, s3, [1, 1, -1]), this._cachedFrustum = Ut2.fromInvProjectionMatrix(s3, 1, 0, this._cachedClippingPlane, true);
        }
        calculateFogMatrix(e6) {
          t4.w(`calculateFogMatrix is not supported on globe projection.`);
          let n4 = t4.bd();
          return t4.am(n4), n4;
        }
        getVisibleUnwrappedCoordinates(e6) {
          return [new t4.b5(0, e6)];
        }
        getCameraFrustum() {
          return this._cachedFrustum;
        }
        getClippingPlane() {
          return this._cachedClippingPlane;
        }
        getCoveringTilesDetailsProvider() {
          return this._coveringTilesDetailsProvider;
        }
        recalculateZoomAndCenter(e6) {
          e6 && t4.w(`terrain is not fully supported on vertical perspective projection.`), this._helper.recalculateZoomAndCenter(0);
        }
        maxPitchScaleFactor() {
          return 1;
        }
        getCameraPoint() {
          return this._helper.getCameraPoint();
        }
        getCameraAltitude() {
          return this._helper.getCameraAltitude();
        }
        getCameraLngLat() {
          return this._helper.getCameraLngLat();
        }
        lngLatToCameraDepth(e6, n4) {
          if (!this._globeViewProjMatrixNoCorrection) return 1;
          let r3 = dn2(e6);
          t4.aU(r3, r3, 1 + n4 / t4.bx);
          let i3 = t4.by();
          return t4.aA(i3, [r3[0], r3[1], r3[2], 1], this._globeViewProjMatrixNoCorrection), i3[2] / i3[3];
        }
        populateCache(e6) {
        }
        getBounds() {
          let e6 = 0.5 * this.width, n4 = 0.5 * this.height, r3 = [new t4.P(0, 0), new t4.P(e6, 0), new t4.P(this.width, 0), new t4.P(this.width, n4), new t4.P(this.width, this.height), new t4.P(e6, this.height), new t4.P(0, this.height), new t4.P(0, n4)], i3 = [];
          for (let e7 of r3) i3.push(this.unprojectScreenPoint(e7));
          let a3 = 0, o3 = 0, s3 = 0, c3 = 0, l3 = this.center;
          for (let e7 of i3) {
            let n5 = t4.bD(l3.lng, e7.lng), r4 = t4.bD(l3.lat, e7.lat);
            n5 < o3 && (o3 = n5), n5 > a3 && (a3 = n5), r4 < c3 && (c3 = r4), r4 > s3 && (s3 = r4);
          }
          let u3 = [l3.lng + o3, l3.lat + c3, l3.lng + a3, l3.lat + s3];
          return this.isSurfacePointOnScreen([0, 1, 0]) && (u3[3] = 90, u3[0] = -180, u3[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (u3[1] = -90, u3[0] = -180, u3[2] = 180), new ue2(u3);
        }
        calculateCenterFromCameraLngLatAlt(e6, t5, n4, r3) {
          return this._helper.calculateCenterFromCameraLngLatAlt(e6, t5, n4, r3);
        }
        setLocationAtPoint(e6, n4) {
          let r3 = dn2(this.unprojectScreenPoint(n4)), i3 = dn2(e6), a3 = t4.bs();
          t4.bE(a3);
          let o3 = t4.bs();
          t4.bB(o3, r3, a3, -this.center.lng * Math.PI / 180), t4.bA(o3, o3, a3, this.center.lat * Math.PI / 180);
          let s3 = i3[0] * i3[0] + i3[2] * i3[2], c3 = o3[0] * o3[0];
          if (s3 < c3) return;
          let l3 = Math.sqrt(s3 - c3), u3 = -l3, d3 = t4.bF(i3[0], i3[2], o3[0], l3), f3 = t4.bF(i3[0], i3[2], o3[0], u3), p3 = t4.bs();
          t4.bB(p3, i3, a3, -d3);
          let m3 = t4.bF(p3[1], p3[2], o3[1], o3[2]), h3 = t4.bs();
          t4.bB(h3, i3, a3, -f3);
          let g3 = t4.bF(h3[1], h3[2], o3[1], o3[2]), _3 = 0.5 * Math.PI, v3 = m3 >= -_3 && m3 <= _3, y3 = g3 >= -_3 && g3 <= _3, b3, x3;
          if (v3 && y3) {
            let e7 = this.center.lng * Math.PI / 180, n5 = this.center.lat * Math.PI / 180;
            t4.bG(d3, e7) + t4.bG(m3, n5) < t4.bG(f3, e7) + t4.bG(g3, n5) ? (b3 = d3, x3 = m3) : (b3 = f3, x3 = g3);
          } else if (v3) b3 = d3, x3 = m3;
          else {
            if (!y3) return;
            b3 = f3, x3 = g3;
          }
          let S3 = b3 / Math.PI * 180, C3 = x3 / Math.PI * 180, w3 = this.center.lat;
          this.setCenter(new t4.U(S3, t4.ai(C3, -90, 90))), this.setZoom(this.zoom + hn(w3, this.center.lat));
        }
        locationToScreenPoint(e6, n4) {
          let r3 = dn2(e6);
          if (n4) {
            let i3 = n4.getElevationForLngLatZoom(e6, this._helper._tileZoom);
            t4.aU(r3, r3, 1 + i3 / t4.bx);
          }
          return this._projectSurfacePointToScreen(r3);
        }
        _projectSurfacePointToScreen(e6) {
          let n4 = t4.by();
          return t4.aA(n4, [...e6, 1], this._globeViewProjMatrixNoCorrection), n4[0] /= n4[3], n4[1] /= n4[3], new t4.P((0.5 * n4[0] + 0.5) * this.width, (0.5 * -n4[1] + 0.5) * this.height);
        }
        screenPointToMercatorCoordinate(e6, n4) {
          if (n4) {
            let t5 = n4.pointCoordinate(e6);
            if (t5) return t5;
          }
          return t4.a5.fromLngLat(this.unprojectScreenPoint(e6));
        }
        screenPointToLocation(e6, t5) {
          var _a3;
          return (_a3 = this.screenPointToMercatorCoordinate(e6, t5)) == null ? void 0 : _a3.toLngLat();
        }
        isPointOnMapSurface(e6, t5) {
          let n4 = this._cameraPosition, r3 = this.getRayDirectionFromPixel(e6);
          return !!this.rayPlanetIntersection(n4, r3);
        }
        getRayDirectionFromPixel(e6) {
          let n4 = t4.by();
          n4[0] = e6.x / this.width * 2 - 1, n4[1] = -1 * (e6.y / this.height * 2 - 1), n4[2] = 1, n4[3] = 1, t4.aA(n4, n4, this._globeViewProjMatrixNoCorrectionInverted), n4[0] /= n4[3], n4[1] /= n4[3], n4[2] /= n4[3];
          let r3 = t4.bs();
          r3[0] = n4[0] - this._cameraPosition[0], r3[1] = n4[1] - this._cameraPosition[1], r3[2] = n4[2] - this._cameraPosition[2];
          let i3 = t4.bs();
          return t4.aY(i3, r3), i3;
        }
        isSurfacePointVisible(e6) {
          let t5 = this._cachedClippingPlane;
          return t5[0] * e6[0] + t5[1] * e6[1] + t5[2] * e6[2] + t5[3] >= 0;
        }
        isSurfacePointOnScreen(e6) {
          if (!this.isSurfacePointVisible(e6)) return false;
          let n4 = t4.by();
          return t4.aA(n4, [...e6, 1], this._globeViewProjMatrixNoCorrection), n4[0] /= n4[3], n4[1] /= n4[3], n4[2] /= n4[3], n4[0] > -1 && n4[0] < 1 && n4[1] > -1 && n4[1] < 1 && n4[2] > -1 && n4[2] < 1;
        }
        rayPlanetIntersection(e6, n4) {
          let r3 = t4.a_(e6, n4), i3 = t4.bs(), a3 = t4.bs();
          t4.aU(a3, n4, r3), t4.aX(i3, e6, a3);
          let o3 = 1 - t4.a_(i3, i3);
          if (o3 < 0) return null;
          let s3 = t4.a_(e6, e6) - 1, c3 = -r3 + (r3 < 0 ? 1 : -1) * Math.sqrt(o3), l3 = s3 / c3, u3 = c3;
          return { tMin: Math.min(l3, u3), tMax: Math.max(l3, u3) };
        }
        unprojectScreenPoint(e6) {
          let n4 = this._cameraPosition, r3 = this.getRayDirectionFromPixel(e6), i3 = this.rayPlanetIntersection(n4, r3);
          if (i3) {
            let e7 = t4.bs();
            t4.aV(e7, n4, [r3[0] * i3.tMin, r3[1] * i3.tMin, r3[2] * i3.tMin]);
            let a4 = t4.bs();
            return t4.aY(a4, e7), pn2(a4);
          }
          let a3 = this._cachedClippingPlane, o3 = a3[0] * r3[0] + a3[1] * r3[1] + a3[2] * r3[2], s3 = -t4.b4(a3, n4) / o3, c3 = t4.bs();
          if (s3 > 0) t4.aV(c3, n4, [r3[0] * s3, r3[1] * s3, r3[2] * s3]);
          else {
            let e7 = t4.bs();
            t4.aV(e7, n4, [2 * r3[0], 2 * r3[1], 2 * r3[2]]);
            let i4 = t4.b4(this._cachedClippingPlane, e7);
            t4.aX(c3, e7, [this._cachedClippingPlane[0] * i4, this._cachedClippingPlane[1] * i4, this._cachedClippingPlane[2] * i4]);
          }
          let l3 = (function(e7) {
            let n5 = t4.bs();
            return n5[0] = e7[0] * -e7[3], n5[1] = e7[1] * -e7[3], n5[2] = e7[2] * -e7[3], { center: n5, radius: Math.sqrt(1 - e7[3] * e7[3]) };
          })(a3);
          return pn2((function(e7, n5, r4) {
            let i4 = t4.bs();
            t4.aX(i4, r4, e7);
            let a4 = t4.bs();
            return t4.bt(a4, e7, i4, n5 / t4.b2(i4)), a4;
          })(l3.center, l3.radius, c3));
        }
        getMatrixForModel(e6, n4) {
          let r3 = t4.U.convert(e6), i3 = 1 / t4.bx, a3 = t4.bc();
          return t4.bC(a3, a3, r3.lng / 180 * Math.PI), t4.ba(a3, a3, -r3.lat / 180 * Math.PI), t4.N(a3, a3, [0, 0, 1 + n4 / t4.bx]), t4.ba(a3, a3, 0.5 * Math.PI), t4.O(a3, a3, [i3, i3, i3]), a3;
        }
        getProjectionDataForCustomLayer(e6 = true) {
          let n4 = this.getProjectionData({ overscaledTileID: new t4.a0(0, 0, 0, 0, 0), applyGlobeMatrix: e6 });
          return n4.tileMercatorCoords = [0, 0, 1, 1], n4;
        }
        getFastPathSimpleProjectionMatrix(e6) {
        }
      }
      class En {
        get pixelsToClipSpaceMatrix() {
          return this._helper.pixelsToClipSpaceMatrix;
        }
        get clipSpaceToPixelsMatrix() {
          return this._helper.clipSpaceToPixelsMatrix;
        }
        get pixelsToGLUnits() {
          return this._helper.pixelsToGLUnits;
        }
        get centerOffset() {
          return this._helper.centerOffset;
        }
        get size() {
          return this._helper.size;
        }
        get rotationMatrix() {
          return this._helper.rotationMatrix;
        }
        get centerPoint() {
          return this._helper.centerPoint;
        }
        get pixelsPerMeter() {
          return this._helper.pixelsPerMeter;
        }
        setMinZoom(e6) {
          this._helper.setMinZoom(e6);
        }
        setMaxZoom(e6) {
          this._helper.setMaxZoom(e6);
        }
        setMinPitch(e6) {
          this._helper.setMinPitch(e6);
        }
        setMaxPitch(e6) {
          this._helper.setMaxPitch(e6);
        }
        setRenderWorldCopies(e6) {
          this._helper.setRenderWorldCopies(e6);
        }
        setBearing(e6) {
          this._helper.setBearing(e6);
        }
        setPitch(e6) {
          this._helper.setPitch(e6);
        }
        setRoll(e6) {
          this._helper.setRoll(e6);
        }
        setFov(e6) {
          this._helper.setFov(e6);
        }
        setZoom(e6) {
          this._helper.setZoom(e6);
        }
        setCenter(e6) {
          this._helper.setCenter(e6);
        }
        setElevation(e6) {
          this._helper.setElevation(e6);
        }
        setMinElevationForCurrentTile(e6) {
          this._helper.setMinElevationForCurrentTile(e6);
        }
        setPadding(e6) {
          this._helper.setPadding(e6);
        }
        interpolatePadding(e6, t5, n4) {
          return this._helper.interpolatePadding(e6, t5, n4);
        }
        isPaddingEqual(e6) {
          return this._helper.isPaddingEqual(e6);
        }
        resize(e6, t5, n4 = true) {
          this._helper.resize(e6, t5, n4);
        }
        getMaxBounds() {
          return this._helper.getMaxBounds();
        }
        setMaxBounds(e6) {
          this._helper.setMaxBounds(e6);
        }
        setConstrain(e6) {
          this._helper.setConstrain(e6);
        }
        overrideNearFarZ(e6, t5) {
          this._helper.overrideNearFarZ(e6, t5);
        }
        clearNearFarZOverride() {
          this._helper.clearNearFarZOverride();
        }
        getCameraQueryGeometry(e6) {
          return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e6);
        }
        get tileSize() {
          return this._helper.tileSize;
        }
        get tileZoom() {
          return this._helper.tileZoom;
        }
        get scale() {
          return this._helper.scale;
        }
        get worldSize() {
          return this._helper.worldSize;
        }
        get width() {
          return this._helper.width;
        }
        get height() {
          return this._helper.height;
        }
        get lngRange() {
          return this._helper.lngRange;
        }
        get latRange() {
          return this._helper.latRange;
        }
        get minZoom() {
          return this._helper.minZoom;
        }
        get maxZoom() {
          return this._helper.maxZoom;
        }
        get zoom() {
          return this._helper.zoom;
        }
        get center() {
          return this._helper.center;
        }
        get minPitch() {
          return this._helper.minPitch;
        }
        get maxPitch() {
          return this._helper.maxPitch;
        }
        get pitch() {
          return this._helper.pitch;
        }
        get pitchInRadians() {
          return this._helper.pitchInRadians;
        }
        get roll() {
          return this._helper.roll;
        }
        get rollInRadians() {
          return this._helper.rollInRadians;
        }
        get bearing() {
          return this._helper.bearing;
        }
        get bearingInRadians() {
          return this._helper.bearingInRadians;
        }
        get fov() {
          return this._helper.fov;
        }
        get fovInRadians() {
          return this._helper.fovInRadians;
        }
        get elevation() {
          return this._helper.elevation;
        }
        get minElevationForCurrentTile() {
          return this._helper.minElevationForCurrentTile;
        }
        get padding() {
          return this._helper.padding;
        }
        get unmodified() {
          return this._helper.unmodified;
        }
        get renderWorldCopies() {
          return this._helper.renderWorldCopies;
        }
        get cameraToCenterDistance() {
          return this._helper.cameraToCenterDistance;
        }
        get constrain() {
          return this._helper.constrain;
        }
        get nearZ() {
          return this._helper.nearZ;
        }
        get farZ() {
          return this._helper.farZ;
        }
        get autoCalculateNearFarZ() {
          return this._helper.autoCalculateNearFarZ;
        }
        get isGlobeRendering() {
          return this._globeness > 0;
        }
        setTransitionState(e6, t5) {
          this._globeness = e6, this._globeLatitudeErrorCorrectionRadians = t5, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
        }
        get currentTransform() {
          return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
        }
        constructor(e6) {
          this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this.defaultConstrain = (e7, t5) => this.currentTransform.defaultConstrain(e7, t5), this._helper = new Bt2({ calcMatrices: () => {
            this._calcMatrices();
          }, constrain: (e7, t5) => this.defaultConstrain(e7, t5) }, e6), this._globeness = 1, this._mercatorTransform = new Wt2(), this._verticalPerspectiveTransform = new Tn();
        }
        clone() {
          let e6 = new En();
          return e6._globeness = this._globeness, e6._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e6.apply(this), e6;
        }
        apply(e6) {
          this._helper.apply(e6), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
        }
        get projectionMatrix() {
          return this.currentTransform.projectionMatrix;
        }
        get modelViewProjectionMatrix() {
          return this.currentTransform.modelViewProjectionMatrix;
        }
        get inverseProjectionMatrix() {
          return this.currentTransform.inverseProjectionMatrix;
        }
        get cameraPosition() {
          return this.currentTransform.cameraPosition;
        }
        getProjectionData(e6) {
          let t5 = this._mercatorTransform.getProjectionData(e6), n4 = this._verticalPerspectiveTransform.getProjectionData(e6);
          return { mainMatrix: this.isGlobeRendering ? n4.mainMatrix : t5.mainMatrix, clippingPlane: n4.clippingPlane, tileMercatorCoords: n4.tileMercatorCoords, projectionTransition: e6.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: t5.fallbackMatrix };
        }
        isLocationOccluded(e6) {
          return this.currentTransform.isLocationOccluded(e6);
        }
        transformLightDirection(e6) {
          return this.currentTransform.transformLightDirection(e6);
        }
        getPixelScale() {
          return t4.bn(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
        }
        getCircleRadiusCorrection() {
          return t4.bn(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
        }
        getPitchedTextCorrection(e6, n4, r3) {
          let i3 = this._mercatorTransform.getPitchedTextCorrection(e6, n4, r3), a3 = this._verticalPerspectiveTransform.getPitchedTextCorrection(e6, n4, r3);
          return t4.bn(i3, a3, this._globeness);
        }
        projectTileCoordinates(e6, t5, n4, r3) {
          return this.currentTransform.projectTileCoordinates(e6, t5, n4, r3);
        }
        _calcMatrices() {
          this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, true, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
        }
        calculateFogMatrix(e6) {
          return this.currentTransform.calculateFogMatrix(e6);
        }
        getVisibleUnwrappedCoordinates(e6) {
          return this.currentTransform.getVisibleUnwrappedCoordinates(e6);
        }
        getCameraFrustum() {
          return this.currentTransform.getCameraFrustum();
        }
        getClippingPlane() {
          return this.currentTransform.getClippingPlane();
        }
        getCoveringTilesDetailsProvider() {
          return this.currentTransform.getCoveringTilesDetailsProvider();
        }
        recalculateZoomAndCenter(e6) {
          this._mercatorTransform.recalculateZoomAndCenter(e6), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e6);
        }
        maxPitchScaleFactor() {
          return this._mercatorTransform.maxPitchScaleFactor();
        }
        getCameraPoint() {
          return this._helper.getCameraPoint();
        }
        getCameraAltitude() {
          return this._helper.getCameraAltitude();
        }
        getCameraLngLat() {
          return this._helper.getCameraLngLat();
        }
        lngLatToCameraDepth(e6, t5) {
          return this.currentTransform.lngLatToCameraDepth(e6, t5);
        }
        populateCache(e6) {
          this._mercatorTransform.populateCache(e6), this._verticalPerspectiveTransform.populateCache(e6);
        }
        getBounds() {
          return this.currentTransform.getBounds();
        }
        calculateCenterFromCameraLngLatAlt(e6, t5, n4, r3) {
          return this._helper.calculateCenterFromCameraLngLatAlt(e6, t5, n4, r3);
        }
        setLocationAtPoint(e6, t5) {
          if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e6, t5), void this.apply(this._mercatorTransform);
          this._verticalPerspectiveTransform.setLocationAtPoint(e6, t5), this.apply(this._verticalPerspectiveTransform);
        }
        locationToScreenPoint(e6, t5) {
          return this.currentTransform.locationToScreenPoint(e6, t5);
        }
        screenPointToMercatorCoordinate(e6, t5) {
          return this.currentTransform.screenPointToMercatorCoordinate(e6, t5);
        }
        screenPointToLocation(e6, t5) {
          return this.currentTransform.screenPointToLocation(e6, t5);
        }
        isPointOnMapSurface(e6, t5) {
          return this.currentTransform.isPointOnMapSurface(e6, t5);
        }
        getRayDirectionFromPixel(e6) {
          return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e6);
        }
        getMatrixForModel(e6, t5) {
          return this.currentTransform.getMatrixForModel(e6, t5);
        }
        getProjectionDataForCustomLayer(e6 = true) {
          let t5 = this._mercatorTransform.getProjectionDataForCustomLayer(e6);
          if (!this.isGlobeRendering) return t5;
          let n4 = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e6);
          return n4.fallbackMatrix = t5.mainMatrix, n4;
        }
        getFastPathSimpleProjectionMatrix(e6) {
          return this.currentTransform.getFastPathSimpleProjectionMatrix(e6);
        }
      }
      class Dn {
        get useGlobeControls() {
          return true;
        }
        handlePanInertia(e6, n4) {
          let r3 = gn(e6, n4);
          return Math.abs(r3.lng - n4.center.lng) > 180 && (r3.lng = n4.center.lng + 179.5 * Math.sign(r3.lng - n4.center.lng)), { easingCenter: r3, easingOffset: new t4.P(0, 0) };
        }
        handleMapControlsRollPitchBearingZoom(e6, n4) {
          let r3 = e6.around, i3 = n4.screenPointToLocation(r3);
          e6.bearingDelta && n4.setBearing(n4.bearing + e6.bearingDelta), e6.pitchDelta && n4.setPitch(n4.pitch + e6.pitchDelta), e6.rollDelta && n4.setRoll(n4.roll + e6.rollDelta);
          let a3 = n4.zoom;
          e6.zoomDelta && n4.setZoom(n4.zoom + e6.zoomDelta);
          let o3 = n4.zoom - a3;
          if (o3 === 0) return;
          let s3 = t4.bD(n4.center.lng, i3.lng), c3 = s3 / (Math.abs(s3 / 180) + 1), l3 = t4.bD(n4.center.lat, i3.lat), u3 = n4.getRayDirectionFromPixel(r3), d3 = n4.cameraPosition, f3 = -1 * t4.a_(d3, u3), p3 = t4.bs();
          t4.aV(p3, d3, [u3[0] * f3, u3[1] * f3, u3[2] * f3]);
          let m3 = t4.b0(p3) - 1, h3 = Math.exp(0.5 * -Math.max(m3 - 0.3, 0)), g3 = fn2(n4.worldSize, n4.center.lat) / Math.min(n4.width, n4.height), _3 = t4.bq(g3, 0.9, 0.5, 1, 0.25), v3 = (1 - t4.al(-o3)) * Math.min(h3, _3), y3 = n4.center.lat, b3 = n4.zoom, x3 = new t4.U(n4.center.lng + c3 * v3, t4.ai(n4.center.lat + l3 * v3, -t4.aj, t4.aj));
          n4.setLocationAtPoint(i3, r3);
          let S3 = n4.center, C3 = t4.bq(Math.abs(s3), 45, 85, 0, 1), w3 = t4.bq(g3, 0.75, 0.35, 0, 1), T3 = Math.max(C3, w3) ** 0.25, E3 = t4.bD(S3.lng, x3.lng), D3 = t4.bD(S3.lat, x3.lat);
          n4.setCenter(new t4.U(S3.lng + E3 * T3, S3.lat + D3 * T3).wrap()), n4.setZoom(b3 + hn(y3, n4.center.lat));
        }
        handleMapControlsPan(e6, t5, n4) {
          if (!e6.panDelta) return;
          let r3 = t5.center.lat, i3 = t5.zoom;
          t5.setCenter(gn(e6.panDelta, t5).wrap()), t5.setZoom(i3 + hn(r3, t5.center.lat));
        }
        cameraForBoxAndBearing(e6, n4, r3, i3, a3) {
          let o3 = qt2(e6, n4, r3, i3, a3), s3 = n4.left / a3.width * 2 - 1, c3 = (a3.width - n4.right) / a3.width * 2 - 1, l3 = n4.top / a3.height * -2 + 1, u3 = (a3.height - n4.bottom) / a3.height * -2 + 1, d3 = t4.bD(r3.getWest(), r3.getEast()) < 0, f3 = d3 ? r3.getEast() : r3.getWest(), p3 = d3 ? r3.getWest() : r3.getEast(), m3 = Math.max(r3.getNorth(), r3.getSouth()), h3 = Math.min(r3.getNorth(), r3.getSouth()), g3 = f3 + 0.5 * t4.bD(f3, p3), _3 = m3 + 0.5 * t4.bD(m3, h3), v3 = a3.clone();
          v3.setCenter(o3.center), v3.setBearing(o3.bearing), v3.setPitch(0), v3.setRoll(0), v3.setZoom(o3.zoom);
          let y3 = v3.modelViewProjectionMatrix, b3 = [dn2(r3.getNorthWest()), dn2(r3.getNorthEast()), dn2(r3.getSouthWest()), dn2(r3.getSouthEast()), dn2(new t4.U(p3, _3)), dn2(new t4.U(f3, _3)), dn2(new t4.U(g3, m3)), dn2(new t4.U(g3, h3))], x3 = dn2(o3.center), S3 = 1 / 0;
          for (let e7 of b3) s3 < 0 && (S3 = Dn.getLesserNonNegativeNonNull(S3, Dn.solveVectorScale(e7, x3, y3, `x`, s3))), c3 > 0 && (S3 = Dn.getLesserNonNegativeNonNull(S3, Dn.solveVectorScale(e7, x3, y3, `x`, c3))), l3 > 0 && (S3 = Dn.getLesserNonNegativeNonNull(S3, Dn.solveVectorScale(e7, x3, y3, `y`, l3))), u3 < 0 && (S3 = Dn.getLesserNonNegativeNonNull(S3, Dn.solveVectorScale(e7, x3, y3, `y`, u3)));
          if (Number.isFinite(S3) && S3 !== 0) return o3.zoom = v3.zoom + t4.ao(S3), o3;
          Gt2();
        }
        handleJumpToCenterZoom(e6, n4) {
          let r3 = e6.center.lat, i3 = e6.constrain(n4.center ? t4.U.convert(n4.center) : e6.center, e6.zoom).center;
          e6.setCenter(i3.wrap());
          let a3 = n4.zoom === void 0 ? e6.zoom + hn(r3, i3.lat) : +n4.zoom;
          e6.zoom !== a3 && e6.setZoom(a3);
        }
        handleEaseTo(e6, n4) {
          let r3 = e6.zoom, i3 = e6.center, a3 = e6.padding, o3 = { roll: e6.roll, pitch: e6.pitch, bearing: e6.bearing }, s3 = { roll: n4.roll === void 0 ? e6.roll : n4.roll, pitch: n4.pitch === void 0 ? e6.pitch : n4.pitch, bearing: n4.bearing === void 0 ? e6.bearing : n4.bearing }, c3 = n4.zoom !== void 0, l3 = !e6.isPaddingEqual(n4.padding), u3 = false, d3 = n4.center ? t4.U.convert(n4.center) : i3, f3 = e6.constrain(d3, r3).center;
          Rt2(e6, f3);
          let p3 = e6.clone();
          p3.setCenter(f3), p3.setZoom(c3 ? +n4.zoom : r3 + hn(i3.lat, d3.lat)), p3.setBearing(n4.bearing);
          let m3 = new t4.P(t4.ai(e6.centerPoint.x + n4.offsetAsPoint.x, 0, e6.width), t4.ai(e6.centerPoint.y + n4.offsetAsPoint.y, 0, e6.height));
          p3.setLocationAtPoint(f3, m3);
          let h3 = (n4.offset && n4.offsetAsPoint.mag()) > 0 ? p3.center : f3, g3 = c3 ? +n4.zoom : r3 + hn(i3.lat, h3.lat), _3 = r3 + hn(i3.lat, 0), v3 = g3 + hn(h3.lat, 0), y3 = t4.bD(i3.lng, h3.lng), b3 = t4.bD(i3.lat, h3.lat), x3 = t4.al(v3 - _3);
          return u3 = g3 !== r3, { easeFunc: (r4) => {
            if (t4.bh(o3, s3) || Kt2({ startEulerAngles: o3, endEulerAngles: s3, tr: e6, k: r4, useSlerp: o3.roll != s3.roll }), l3 && e6.interpolatePadding(a3, n4.padding, r4), n4.around) t4.w(`Easing around a point is not supported under globe projection.`), e6.setLocationAtPoint(n4.around, n4.aroundPoint);
            else {
              let t5 = vn(i3, y3, b3, r4 * (v3 > _3 ? Math.min(2, x3) : Math.max(0.5, x3)) ** (1 - r4));
              e6.setCenter(t5.wrap());
            }
            if (u3) {
              let n5 = t4.F.number(_3, v3, r4) + hn(0, e6.center.lat);
              e6.setZoom(n5);
            }
          }, isZooming: u3, elevationCenter: h3 };
        }
        handleFlyTo(e6, n4) {
          let r3 = n4.zoom !== void 0, i3 = e6.center, a3 = e6.zoom, o3 = e6.padding, s3 = !e6.isPaddingEqual(n4.padding), c3 = e6.constrain(t4.U.convert(n4.center || n4.locationAtOffset), a3).center, l3 = r3 ? +n4.zoom : e6.zoom + hn(e6.center.lat, c3.lat), u3 = e6.clone();
          u3.setCenter(c3), u3.setZoom(l3), u3.setBearing(n4.bearing);
          let d3 = new t4.P(t4.ai(e6.centerPoint.x + n4.offsetAsPoint.x, 0, e6.width), t4.ai(e6.centerPoint.y + n4.offsetAsPoint.y, 0, e6.height));
          u3.setLocationAtPoint(c3, d3);
          let f3 = u3.center;
          Rt2(e6, f3);
          let p3 = (function(e7, n5, r4) {
            let i4 = dn2(n5), a4 = dn2(r4), o4 = t4.a_(i4, a4), s4 = Math.acos(o4), c4 = ln2(e7);
            return s4 / (2 * Math.PI) * c4;
          })(e6, i3, f3), m3 = a3 + hn(i3.lat, 0), h3 = l3 + hn(f3.lat, 0), g3 = t4.al(h3 - m3), _3;
          if (typeof n4.minZoom == `number`) {
            let r4 = +n4.minZoom + hn(f3.lat, 0), i4 = Math.min(r4, m3, h3) + hn(0, f3.lat), a4 = e6.constrain(f3, i4).zoom + hn(f3.lat, 0);
            _3 = t4.al(a4 - m3);
          }
          let v3 = t4.bD(i3.lng, f3.lng), y3 = t4.bD(i3.lat, f3.lat);
          return { easeFunc: (r4, a4, c4, u4) => {
            let d4 = vn(i3, v3, y3, c4);
            s3 && e6.interpolatePadding(o3, n4.padding, r4);
            let p4 = r4 === 1 ? f3 : d4;
            e6.setCenter(p4.wrap());
            let h4 = m3 + t4.ao(a4);
            e6.setZoom(r4 === 1 ? l3 : h4 + hn(0, p4.lat));
          }, scaleOfZoom: g3, targetCenter: f3, scaleOfMinZoom: _3, pixelPathLength: p3 };
        }
        static solveVectorScale(e6, t5, n4, r3, i3) {
          let a3 = r3 === `x` ? [n4[0], n4[4], n4[8], n4[12]] : [n4[1], n4[5], n4[9], n4[13]], o3 = [n4[3], n4[7], n4[11], n4[15]], s3 = e6[0] * a3[0] + e6[1] * a3[1] + e6[2] * a3[2], c3 = e6[0] * o3[0] + e6[1] * o3[1] + e6[2] * o3[2], l3 = t5[0] * a3[0] + t5[1] * a3[1] + t5[2] * a3[2], u3 = t5[0] * o3[0] + t5[1] * o3[1] + t5[2] * o3[2];
          return l3 + i3 * c3 === s3 + i3 * u3 || o3[3] * (s3 - l3) + a3[3] * (u3 - c3) + s3 * u3 == l3 * c3 ? null : (l3 + a3[3] - i3 * u3 - i3 * o3[3]) / (l3 - s3 - i3 * u3 + i3 * c3);
        }
        static getLesserNonNegativeNonNull(e6, t5) {
          return t5 !== null && t5 >= 0 && t5 < e6 ? t5 : e6;
        }
      }
      class On {
        constructor(e6) {
          this._globe = e6, this._mercatorCameraHelper = new Jt2(), this._verticalPerspectiveCameraHelper = new Dn();
        }
        get useGlobeControls() {
          return this._globe.useGlobeRendering;
        }
        get currentHelper() {
          return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
        }
        handlePanInertia(e6, t5) {
          return this.currentHelper.handlePanInertia(e6, t5);
        }
        handleMapControlsRollPitchBearingZoom(e6, t5) {
          return this.currentHelper.handleMapControlsRollPitchBearingZoom(e6, t5);
        }
        handleMapControlsPan(e6, t5, n4) {
          this.currentHelper.handleMapControlsPan(e6, t5, n4);
        }
        cameraForBoxAndBearing(e6, t5, n4, r3, i3) {
          return this.currentHelper.cameraForBoxAndBearing(e6, t5, n4, r3, i3);
        }
        handleJumpToCenterZoom(e6, t5) {
          this.currentHelper.handleJumpToCenterZoom(e6, t5);
        }
        handleEaseTo(e6, t5) {
          return this.currentHelper.handleEaseTo(e6, t5);
        }
        handleFlyTo(e6, t5) {
          return this.currentHelper.handleFlyTo(e6, t5);
        }
      }
      let kn = (e6, n4) => t4.z(e6, n4 && n4.filter(((e7) => e7.identifier !== `source.canvas`))), An = t4.bH();
      class jn extends t4.E {
        constructor(e6, n4 = {}) {
          var _a3, _b2;
          super(), this._rtlPluginLoaded = () => {
            for (let e7 in this.tileManagers) {
              let t5 = this.tileManagers[e7].getSource().type;
              t5 !== `vector` && t5 !== `geojson` || this.tileManagers[e7].reload();
            }
          }, this.map = e6, this.dispatcher = new ie2(re2(), e6._getMapId()), this.dispatcher.registerMessageHandler(`GG`, ((e7, t5) => this.getGlyphs(e7, t5))), this.dispatcher.registerMessageHandler(`GI`, ((e7, t5) => this.getImages(e7, t5))), this.dispatcher.registerMessageHandler(`GDA`, ((e7, t5) => this.getDashes(e7, t5))), this.imageManager = new x2(), this.imageManager.setEventedParent(this);
          let r3 = ((_a3 = e6._container) == null ? void 0 : _a3.lang) || typeof document < `u` && ((_b2 = document.documentElement) == null ? void 0 : _b2.lang) || void 0;
          this.glyphManager = new E2(e6._requestManager, n4.localIdeographFontFamily, r3), this.lineAtlas = new j2(256, 512), this.crossTileSymbolIndex = new At2(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.tileManagers = {}, this.zoomHistory = new t4.bI(), this._loaded = false, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast(`SR`, t4.bJ()), we2().on(xe2, this._rtlPluginLoaded), this.on(`data`, ((e7) => {
            if (e7.dataType !== `source` || e7.sourceDataType !== `metadata`) return;
            let t5 = this.tileManagers[e7.sourceId];
            if (!t5) return;
            let n5 = t5.getSource();
            if (n5 && n5.vectorLayerIds) for (let e8 in this._layers) {
              let t6 = this._layers[e8];
              t6.source === n5.id && this._validateLayer(t6);
            }
          }));
        }
        setGlobalStateProperty(e6, n4) {
          var _a3, _b2;
          this._checkLoaded();
          let r3 = n4 === null ? ((_b2 = (_a3 = this.stylesheet.state) == null ? void 0 : _a3[e6]) == null ? void 0 : _b2.default) ?? null : n4;
          if (t4.bK(r3, this._globalState[e6])) return this;
          this._globalState[e6] = r3, this._applyGlobalStateChanges([e6]);
        }
        getGlobalState() {
          return this._globalState;
        }
        setGlobalState(e6) {
          this._checkLoaded();
          let n4 = [];
          for (let r3 in e6) !t4.bK(this._globalState[r3], e6[r3].default) && (n4.push(r3), this._globalState[r3] = e6[r3].default);
          this._applyGlobalStateChanges(n4);
        }
        _applyGlobalStateChanges(e6) {
          if (e6.length === 0) return;
          let t5 = /* @__PURE__ */ new Set(), n4 = {};
          for (let r3 of e6) for (let e7 in n4[r3] = this._globalState[r3], this._layers) {
            let n5 = this._layers[e7], i3 = n5.getLayoutAffectingGlobalStateRefs(), a3 = n5.getPaintAffectingGlobalStateRefs();
            if (i3.has(r3) && t5.add(n5.source), a3.has(r3)) for (let { name: e8, value: t6 } of a3.get(r3)) this._updatePaintProperty(n5, e8, t6);
          }
          for (let e7 in this.dispatcher.broadcast(`UGS`, n4), this.tileManagers) t5.has(e7) && (this._reloadSource(e7), this._changed = true);
        }
        loadURL(e6, n4 = {}, r3) {
          this.fire(new t4.l(`dataloading`, { dataType: `style` })), n4.validate = typeof n4.validate != `boolean` || n4.validate;
          let i3 = this.map._requestManager.transformRequest(e6, `Style`);
          this._loadStyleRequest = new AbortController();
          let a3 = this._loadStyleRequest;
          t4.j(i3, this._loadStyleRequest).then(((e7) => {
            this._loadStyleRequest = null, this._load(e7.data, n4, r3);
          })).catch(((e7) => {
            this._loadStyleRequest = null, e7 && !a3.signal.aborted && this.fire(new t4.k(e7));
          }));
        }
        loadJSON(e6, n4 = {}, r3) {
          this.fire(new t4.l(`dataloading`, { dataType: `style` })), this._frameRequest = new AbortController(), o2.frameAsync(this._frameRequest).then((() => {
            this._frameRequest = null, n4.validate = false !== n4.validate, this._load(e6, n4, r3);
          })).catch((() => {
          }));
        }
        loadEmpty() {
          this.fire(new t4.l(`dataloading`, { dataType: `style` })), this._load(An, { validate: false });
        }
        _load(e6, n4, r3) {
          var _a3;
          let i3 = n4.transformStyle ? n4.transformStyle(r3, e6) : e6;
          if (!n4.validate || !kn(this, t4.B(i3))) {
            for (let e7 in i3 = Object.assign({}, i3), this._loaded = true, this.stylesheet = i3, i3.sources) this.addSource(e7, i3.sources[e7], { validate: false });
            i3.sprite ? this._loadSprite(i3.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(i3.glyphs), this._createLayers(), this.light = new k2(this.stylesheet.light), this._setProjectionInternal(((_a3 = this.stylesheet.projection) == null ? void 0 : _a3.type) || `mercator`), this.sky = new ee2(this.stylesheet.sky), this.map.setTerrain(this.stylesheet.terrain ?? null), this.fire(new t4.l(`data`, { dataType: `style` })), this.fire(new t4.l(`style.load`));
          }
        }
        _createLayers() {
          var _a3;
          let e6 = t4.bL(this.stylesheet.layers);
          this.setGlobalState(this.stylesheet.state ?? null), this.dispatcher.broadcast(`SL`, e6), this._order = e6.map(((e7) => e7.id)), this._layers = {}, this._serializedLayers = null;
          for (let n4 of e6) {
            let e7 = t4.bM(n4, this._globalState);
            if (e7.setEventedParent(this, { layer: { id: n4.id } }), this._layers[n4.id] = e7, t4.bN(e7) && this.tileManagers[e7.source]) {
              let t5 = ((_a3 = n4.paint) == null ? void 0 : _a3[`raster-fade-duration`]) ?? e7.paint.get(`raster-fade-duration`);
              this.tileManagers[e7.source].setRasterFadeDuration(t5);
            }
          }
        }
        _loadSprite(e6, n4 = false, r3 = void 0) {
          let i3;
          this.imageManager.setLoaded(false), this._spriteRequest = new AbortController(), (function(e7, n5, r4, i4) {
            return t4._(this, void 0, void 0, (function* () {
              let a3 = v2(e7), s3 = r4 > 1 ? `@2x` : ``, c3 = {}, l3 = {};
              for (let { id: e8, url: r5 } of a3) {
                let a4 = n5.transformRequest(y2(r5, s3, `.json`), `SpriteJSON`);
                c3[e8] = t4.j(a4, i4);
                let o3 = n5.transformRequest(y2(r5, s3, `.png`), `SpriteImage`);
                l3[e8] = g2.getImage(o3, i4);
              }
              return yield Promise.all([...Object.values(c3), ...Object.values(l3)]), (function(e8, n6) {
                return t4._(this, void 0, void 0, (function* () {
                  let t5 = {};
                  for (let r5 in e8) {
                    t5[r5] = {};
                    let i5 = o2.getImageCanvasContext((yield n6[r5]).data), a4 = (yield e8[r5]).data;
                    for (let e9 in a4) {
                      let { width: n7, height: o3, x: s4, y: c4, sdf: l4, pixelRatio: u3, stretchX: d3, stretchY: f3, content: p3, textFitWidth: m3, textFitHeight: h3 } = a4[e9];
                      t5[r5][e9] = { data: null, pixelRatio: u3, sdf: l4, stretchX: d3, stretchY: f3, content: p3, textFitWidth: m3, textFitHeight: h3, spriteData: { width: n7, height: o3, x: s4, y: c4, context: i5 } };
                    }
                  }
                  return t5;
                }));
              })(c3, l3);
            }));
          })(e6, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(((e7) => {
            if (this._spriteRequest = null, e7) for (let t5 in e7) {
              this._spritesImagesIds[t5] = [];
              let r4 = this._spritesImagesIds[t5] ? this._spritesImagesIds[t5].filter(((t6) => !(t6 in e7))) : [];
              for (let e8 of r4) this.imageManager.removeImage(e8), this._changedImages[e8] = true;
              for (let r5 in e7[t5]) {
                let i4 = t5 === `default` ? r5 : `${t5}:${r5}`;
                this._spritesImagesIds[t5].push(i4), i4 in this.imageManager.images ? this.imageManager.updateImage(i4, e7[t5][r5], false) : this.imageManager.addImage(i4, e7[t5][r5]), n4 && (this._changedImages[i4] = true);
              }
            }
          })).catch(((e7) => {
            this._spriteRequest = null, i3 = e7, this.fire(new t4.k(i3));
          })).finally((() => {
            this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), n4 && (this._changed = true), this.dispatcher.broadcast(`SI`, this._availableImages), this.fire(new t4.l(`data`, { dataType: `style` })), r3 && r3(i3);
          }));
        }
        _unloadSprite() {
          for (let e6 of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e6), this._changedImages[e6] = true;
          this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast(`SI`, this._availableImages), this.fire(new t4.l(`data`, { dataType: `style` }));
        }
        _validateLayer(e6) {
          let n4 = this.tileManagers[e6.source];
          if (!n4) return;
          let r3 = e6.sourceLayer;
          if (!r3) return;
          let i3 = n4.getSource();
          (i3.type === `geojson` || i3.vectorLayerIds && i3.vectorLayerIds.indexOf(r3) === -1) && this.fire(new t4.k(Error(`Source layer "${r3}" does not exist on source "${i3.id}" as specified by style layer "${e6.id}".`)));
        }
        loaded() {
          if (!this._loaded || Object.keys(this._updatedSources).length) return false;
          for (let e6 in this.tileManagers) if (!this.tileManagers[e6].loaded()) return false;
          return !!this.imageManager.isLoaded();
        }
        _serializeByIds(e6, n4 = false) {
          let r3 = this._serializedAllLayers();
          if (!e6 || e6.length === 0) return Object.values(n4 ? t4.bO(r3) : r3);
          let i3 = [];
          for (let a3 of e6) if (r3[a3]) {
            let e7 = n4 ? t4.bO(r3[a3]) : r3[a3];
            i3.push(e7);
          }
          return i3;
        }
        _serializedAllLayers() {
          let e6 = this._serializedLayers;
          if (e6) return e6;
          e6 = this._serializedLayers = {};
          let t5 = Object.keys(this._layers);
          for (let n4 of t5) {
            let t6 = this._layers[n4];
            t6.type !== `custom` && (e6[n4] = t6.serialize());
          }
          return e6;
        }
        hasTransitions() {
          var _a3, _b2, _c2;
          if (((_a3 = this.light) == null ? void 0 : _a3.hasTransition()) || ((_b2 = this.sky) == null ? void 0 : _b2.hasTransition()) || ((_c2 = this.projection) == null ? void 0 : _c2.hasTransition())) return true;
          for (let e6 in this.tileManagers) if (this.tileManagers[e6].hasTransition()) return true;
          for (let e6 in this._layers) if (this._layers[e6].hasTransition()) return true;
          return false;
        }
        _checkLoaded() {
          if (!this._loaded) throw Error(`Style is not done loading.`);
        }
        update(e6) {
          if (!this._loaded) return;
          let n4 = this._changed;
          if (n4) {
            let t5 = Object.keys(this._updatedLayers), n5 = Object.keys(this._removedLayers);
            for (let e7 in (t5.length || n5.length) && this._updateWorkerLayers(t5, n5), this._updatedSources) {
              let t6 = this._updatedSources[e7];
              if (t6 === `reload`) this._reloadSource(e7);
              else {
                if (t6 !== `clear`) throw Error(`Invalid action ${t6}`);
                this._clearSource(e7);
              }
            }
            for (let t6 in this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs(), this._updatedPaintProps) this._layers[t6].updateTransitions(e6);
            this.light.updateTransitions(e6), this.sky.updateTransitions(e6), this._resetUpdates();
          }
          let r3 = {};
          for (let e7 in this.tileManagers) {
            let t5 = this.tileManagers[e7];
            r3[e7] = t5.used, t5.used = false;
          }
          for (let t5 of this._order) {
            let n5 = this._layers[t5];
            n5.recalculate(e6, this._availableImages), !n5.isHidden(e6.zoom) && n5.source && (this.tileManagers[n5.source].used = true);
          }
          for (let e7 in r3) {
            let n5 = this.tileManagers[e7];
            !!r3[e7] != !!n5.used && n5.fire(new t4.l(`data`, { sourceDataType: `visibility`, dataType: `source`, sourceId: e7 }));
          }
          this.light.recalculate(e6), this.sky.recalculate(e6), this.projection.recalculate(e6), this.z = e6.zoom, n4 && this.fire(new t4.l(`data`, { dataType: `style` }));
        }
        _updateTilesForChangedImages() {
          let e6 = Object.keys(this._changedImages);
          if (e6.length) {
            for (let t5 in this.tileManagers) this.tileManagers[t5].reloadTilesForDependencies([`icons`, `patterns`], e6);
            this._changedImages = {};
          }
        }
        _updateTilesForChangedGlyphs() {
          if (this._glyphsDidChange) {
            for (let e6 in this.tileManagers) this.tileManagers[e6].reloadTilesForDependencies([`glyphs`], [``]);
            this._glyphsDidChange = false;
          }
        }
        _updateWorkerLayers(e6, t5) {
          this.dispatcher.broadcast(`UL`, { layers: this._serializeByIds(e6, false), removedIds: t5 });
        }
        _resetUpdates() {
          this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
        }
        setState(e6, n4 = {}) {
          var r3;
          this._checkLoaded();
          let i3 = this.serialize();
          if (e6 = n4.transformStyle ? n4.transformStyle(i3, e6) : e6, ((r3 = n4.validate) == null || r3) && kn(this, t4.B(e6))) return false;
          (e6 = t4.bO(e6)).layers = t4.bL(e6.layers);
          let a3 = t4.bP(i3, e6), o3 = this._getOperationsToPerform(a3);
          if (o3.unimplemented.length > 0) throw Error(`Unimplemented: ${o3.unimplemented.join(`, `)}.`);
          if (o3.operations.length === 0) return false;
          for (let e7 of o3.operations) e7();
          return this.stylesheet = e6, this._serializedLayers = null, true;
        }
        _getOperationsToPerform(e6) {
          let t5 = [], n4 = [];
          for (let r3 of e6) switch (r3.command) {
            case `setCenter`:
            case `setZoom`:
            case `setBearing`:
            case `setPitch`:
            case `setRoll`:
              continue;
            case `addLayer`:
              t5.push((() => this.addLayer.apply(this, r3.args)));
              break;
            case `removeLayer`:
              t5.push((() => this.removeLayer.apply(this, r3.args)));
              break;
            case `setPaintProperty`:
              t5.push((() => this.setPaintProperty.apply(this, r3.args)));
              break;
            case `setLayoutProperty`:
              t5.push((() => this.setLayoutProperty.apply(this, r3.args)));
              break;
            case `setFilter`:
              t5.push((() => this.setFilter.apply(this, r3.args)));
              break;
            case `addSource`:
              t5.push((() => this.addSource.apply(this, r3.args)));
              break;
            case `removeSource`:
              t5.push((() => this.removeSource.apply(this, r3.args)));
              break;
            case `setLayerZoomRange`:
              t5.push((() => this.setLayerZoomRange.apply(this, r3.args)));
              break;
            case `setLight`:
              t5.push((() => this.setLight.apply(this, r3.args)));
              break;
            case `setGeoJSONSourceData`:
              t5.push((() => this.setGeoJSONSourceData.apply(this, r3.args)));
              break;
            case `setGlyphs`:
              t5.push((() => this.setGlyphs.apply(this, r3.args)));
              break;
            case `setSprite`:
              t5.push((() => this.setSprite.apply(this, r3.args)));
              break;
            case `setTerrain`:
              t5.push((() => this.map.setTerrain.apply(this, r3.args)));
              break;
            case `setSky`:
              t5.push((() => this.setSky.apply(this, r3.args)));
              break;
            case `setProjection`:
              this.setProjection.apply(this, r3.args);
              break;
            case `setGlobalState`:
              t5.push((() => this.setGlobalState.apply(this, r3.args)));
              break;
            case `setTransition`:
              t5.push((() => {
              }));
              break;
            default:
              n4.push(r3.command);
          }
          return { operations: t5, unimplemented: n4 };
        }
        addImage(e6, n4) {
          if (this.getImage(e6)) return this.fire(new t4.k(Error(`An image named "${e6}" already exists.`)));
          this.imageManager.addImage(e6, n4), this._afterImageUpdated(e6);
        }
        updateImage(e6, t5) {
          this.imageManager.updateImage(e6, t5);
        }
        getImage(e6) {
          return this.imageManager.getImage(e6);
        }
        removeImage(e6) {
          if (!this.getImage(e6)) return this.fire(new t4.k(Error(`An image named "${e6}" does not exist.`)));
          this.imageManager.removeImage(e6), this._afterImageUpdated(e6);
        }
        _afterImageUpdated(e6) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[e6] = true, this._changed = true, this.dispatcher.broadcast(`SI`, this._availableImages), this.fire(new t4.l(`data`, { dataType: `style` }));
        }
        listImages() {
          return this._checkLoaded(), this.imageManager.listImages();
        }
        addSource(e6, n4, r3 = {}) {
          if (this._checkLoaded(), this.tileManagers[e6] !== void 0) throw Error(`Source "${e6}" already exists.`);
          if (!n4.type) throw Error(`The type property must be defined, but only the following properties were given: ${Object.keys(n4).join(`, `)}.`);
          if ([`vector`, `raster`, `geojson`, `video`, `image`].indexOf(n4.type) >= 0 && this._validate(t4.B.source, `sources.${e6}`, n4, null, r3)) return;
          this.map && this.map._collectResourceTiming && (n4.collectResourceTiming = true);
          let i3 = this.tileManagers[e6] = new He2(e6, n4, this.dispatcher);
          i3.style = this, i3.setEventedParent(this, (() => ({ isSourceLoaded: i3.loaded(), source: i3.serialize(), sourceId: e6 }))), i3.onAdd(this.map), this._changed = true;
        }
        removeSource(e6) {
          if (this._checkLoaded(), this.tileManagers[e6] === void 0) throw Error(`There is no source with this ID`);
          for (let n5 in this._layers) if (this._layers[n5].source === e6) return this.fire(new t4.k(Error(`Source "${e6}" cannot be removed while layer "${n5}" is using it.`)));
          let n4 = this.tileManagers[e6];
          delete this.tileManagers[e6], delete this._updatedSources[e6], n4.fire(new t4.l(`data`, { sourceDataType: `metadata`, dataType: `source`, sourceId: e6 })), n4.setEventedParent(null), n4.onRemove(this.map), this._changed = true;
        }
        setGeoJSONSourceData(e6, t5) {
          if (this._checkLoaded(), this.tileManagers[e6] === void 0) throw Error(`There is no source with this ID=${e6}`);
          let n4 = this.tileManagers[e6].getSource();
          if (n4.type !== `geojson`) throw Error(`geojsonSource.type is ${n4.type}, which is !== 'geojson`);
          n4.setData(t5), this._changed = true;
        }
        getSource(e6) {
          return this.tileManagers[e6] && this.tileManagers[e6].getSource();
        }
        addLayer(e6, n4, r3 = {}) {
          this._checkLoaded();
          let i3 = e6.id;
          if (this.getLayer(i3)) return void this.fire(new t4.k(Error(`Layer "${i3}" already exists on this map.`)));
          let a3;
          if (e6.type === `custom`) {
            if (kn(this, t4.bQ(e6))) return;
            a3 = t4.bM(e6, this._globalState);
          } else {
            if (`source` in e6 && typeof e6.source == `object` && (this.addSource(i3, e6.source), e6 = t4.bO(e6), e6 = t4.e(e6, { source: i3 })), this._validate(t4.B.layer, `layers.${i3}`, e6, { arrayIndex: -1 }, r3)) return;
            a3 = t4.bM(e6, this._globalState), this._validateLayer(a3), a3.setEventedParent(this, { layer: { id: i3 } });
          }
          let o3 = n4 ? this._order.indexOf(n4) : this._order.length;
          if (n4 && o3 === -1) this.fire(new t4.k(Error(`Cannot add layer "${i3}" before non-existing layer "${n4}".`)));
          else {
            if (this._order.splice(o3, 0, i3), this._layerOrderChanged = true, this._layers[i3] = a3, this._removedLayers[i3] && a3.source && a3.type !== `custom`) {
              let e7 = this._removedLayers[i3];
              delete this._removedLayers[i3], e7.type === a3.type ? (this._updatedSources[a3.source] = `reload`, this.tileManagers[a3.source].pause()) : this._updatedSources[a3.source] = `clear`;
            }
            this._updateLayer(a3), a3.onAdd && a3.onAdd(this.map);
          }
        }
        moveLayer(e6, n4) {
          if (this._checkLoaded(), this._changed = true, !this._layers[e6]) return void this.fire(new t4.k(Error(`The layer '${e6}' does not exist in the map's style and cannot be moved.`)));
          if (e6 === n4) return;
          let r3 = this._order.indexOf(e6);
          this._order.splice(r3, 1);
          let i3 = n4 ? this._order.indexOf(n4) : this._order.length;
          n4 && i3 === -1 ? this.fire(new t4.k(Error(`Cannot move layer "${e6}" before non-existing layer "${n4}".`))) : (this._order.splice(i3, 0, e6), this._layerOrderChanged = true);
        }
        removeLayer(e6) {
          this._checkLoaded();
          let n4 = this._layers[e6];
          if (!n4) return void this.fire(new t4.k(Error(`Cannot remove non-existing layer "${e6}".`)));
          n4.setEventedParent(null);
          let r3 = this._order.indexOf(e6);
          this._order.splice(r3, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e6] = n4, delete this._layers[e6], this._serializedLayers && delete this._serializedLayers[e6], delete this._updatedLayers[e6], delete this._updatedPaintProps[e6], n4.onRemove && n4.onRemove(this.map);
        }
        getLayer(e6) {
          return this._layers[e6];
        }
        getLayersOrder() {
          return [...this._order];
        }
        hasLayer(e6) {
          return e6 in this._layers;
        }
        setLayerZoomRange(e6, n4, r3) {
          this._checkLoaded();
          let i3 = this.getLayer(e6);
          i3 ? i3.minzoom === n4 && i3.maxzoom === r3 || (n4 != null && (i3.minzoom = n4), r3 != null && (i3.maxzoom = r3), this._updateLayer(i3)) : this.fire(new t4.k(Error(`Cannot set the zoom range of non-existing layer "${e6}".`)));
        }
        setFilter(e6, n4, r3 = {}) {
          this._checkLoaded();
          let i3 = this.getLayer(e6);
          if (i3) {
            if (!t4.bK(i3.filter, n4)) return n4 == null ? (i3.setFilter(void 0), void this._updateLayer(i3)) : void (this._validate(t4.B.filter, `layers.${i3.id}.filter`, n4, null, r3) || (i3.setFilter(t4.bO(n4)), this._updateLayer(i3)));
          } else this.fire(new t4.k(Error(`Cannot filter non-existing layer "${e6}".`)));
        }
        getFilter(e6) {
          return t4.bO(this.getLayer(e6).filter);
        }
        setLayoutProperty(e6, n4, r3, i3 = {}) {
          this._checkLoaded();
          let a3 = this.getLayer(e6);
          a3 ? t4.bK(a3.getLayoutProperty(n4), r3) || (a3.setLayoutProperty(n4, r3, i3), this._updateLayer(a3)) : this.fire(new t4.k(Error(`Cannot style non-existing layer "${e6}".`)));
        }
        getLayoutProperty(e6, n4) {
          let r3 = this.getLayer(e6);
          if (r3) return r3.getLayoutProperty(n4);
          this.fire(new t4.k(Error(`Cannot get style of non-existing layer "${e6}".`)));
        }
        setPaintProperty(e6, n4, r3, i3 = {}) {
          this._checkLoaded();
          let a3 = this.getLayer(e6);
          a3 ? t4.bK(a3.getPaintProperty(n4), r3) || this._updatePaintProperty(a3, n4, r3, i3) : this.fire(new t4.k(Error(`Cannot style non-existing layer "${e6}".`)));
        }
        _updatePaintProperty(e6, n4, r3, i3 = {}) {
          e6.setPaintProperty(n4, r3, i3) && this._updateLayer(e6), t4.bN(e6) && n4 === `raster-fade-duration` && this.tileManagers[e6.source].setRasterFadeDuration(r3), this._changed = true, this._updatedPaintProps[e6.id] = true, this._serializedLayers = null;
        }
        getPaintProperty(e6, t5) {
          return this.getLayer(e6).getPaintProperty(t5);
        }
        setFeatureState(e6, n4) {
          this._checkLoaded();
          let r3 = e6.source, i3 = e6.sourceLayer, a3 = this.tileManagers[r3];
          if (a3 === void 0) return void this.fire(new t4.k(Error(`The source '${r3}' does not exist in the map's style.`)));
          let o3 = a3.getSource().type;
          o3 === `geojson` && i3 ? this.fire(new t4.k(Error(`GeoJSON sources cannot have a sourceLayer parameter.`))) : o3 !== `vector` || i3 ? (e6.id === void 0 && this.fire(new t4.k(Error(`The feature id parameter must be provided.`))), a3.setFeatureState(i3, e6.id, n4)) : this.fire(new t4.k(Error(`The sourceLayer parameter must be provided for vector source types.`)));
        }
        removeFeatureState(e6, n4) {
          this._checkLoaded();
          let r3 = e6.source, i3 = this.tileManagers[r3];
          if (i3 === void 0) return void this.fire(new t4.k(Error(`The source '${r3}' does not exist in the map's style.`)));
          let a3 = i3.getSource().type, o3 = a3 === `vector` ? e6.sourceLayer : void 0;
          a3 !== `vector` || o3 ? n4 && typeof e6.id != `string` && typeof e6.id != `number` ? this.fire(new t4.k(Error(`A feature id is required to remove its specific state property.`))) : i3.removeFeatureState(o3, e6.id, n4) : this.fire(new t4.k(Error(`The sourceLayer parameter must be provided for vector source types.`)));
        }
        getFeatureState(e6) {
          this._checkLoaded();
          let n4 = e6.source, r3 = e6.sourceLayer, i3 = this.tileManagers[n4];
          if (i3 !== void 0) return i3.getSource().type !== `vector` || r3 ? (e6.id === void 0 && this.fire(new t4.k(Error(`The feature id parameter must be provided.`))), i3.getFeatureState(r3, e6.id)) : void this.fire(new t4.k(Error(`The sourceLayer parameter must be provided for vector source types.`)));
          this.fire(new t4.k(Error(`The source '${n4}' does not exist in the map's style.`)));
        }
        getTransition() {
          return t4.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          if (!this._loaded) return;
          let e6 = t4.bR(this.tileManagers, ((e7) => e7.serialize())), n4 = this._serializeByIds(this._order, true), r3 = this.map.getTerrain() || void 0, i3 = this.stylesheet;
          return t4.bS({ version: i3.version, name: i3.name, metadata: i3.metadata, light: i3.light, sky: i3.sky, center: i3.center, zoom: i3.zoom, bearing: i3.bearing, pitch: i3.pitch, sprite: i3.sprite, glyphs: i3.glyphs, transition: i3.transition, projection: i3.projection, sources: e6, layers: n4, terrain: r3 }, ((e7) => e7 !== void 0));
        }
        _updateLayer(e6) {
          this._updatedLayers[e6.id] = true, e6.source && !this._updatedSources[e6.source] && this.tileManagers[e6.source].getSource().type !== `raster` && (this._updatedSources[e6.source] = `reload`, this.tileManagers[e6.source].pause()), this._serializedLayers = null, this._changed = true;
        }
        _flattenAndSortRenderedFeatures(e6) {
          let t5 = (e7) => this._layers[e7].type === `fill-extrusion`, n4 = {}, r3 = [];
          for (let i4 = this._order.length - 1; i4 >= 0; i4--) {
            let a3 = this._order[i4];
            if (t5(a3)) {
              n4[a3] = i4;
              for (let t6 of e6) {
                let e7 = t6[a3];
                if (e7) for (let t7 of e7) r3.push(t7);
              }
            }
          }
          r3.sort(((e7, t6) => t6.intersectionZ - e7.intersectionZ));
          let i3 = [];
          for (let a3 = this._order.length - 1; a3 >= 0; a3--) {
            let o3 = this._order[a3];
            if (t5(o3)) for (let e7 = r3.length - 1; e7 >= 0; e7--) {
              let t6 = r3[e7].feature;
              if (n4[t6.layer.id] < a3) break;
              i3.push(t6), r3.pop();
            }
            else for (let t6 of e6) {
              let e7 = t6[o3];
              if (e7) for (let t7 of e7) i3.push(t7.feature);
            }
          }
          return i3;
        }
        queryRenderedFeatures(e6, n4, r3) {
          n4 && n4.filter && this._validate(t4.B.filter, `queryRenderedFeatures.filter`, n4.filter, null, n4);
          let i3 = {};
          if (n4 && n4.layers) {
            if (!(Array.isArray(n4.layers) || n4.layers instanceof Set)) return this.fire(new t4.k(Error(`parameters.layers must be an Array or a Set of strings`))), [];
            for (let e7 of n4.layers) {
              let n5 = this._layers[e7];
              if (!n5) return this.fire(new t4.k(Error(`The layer '${e7}' does not exist in the map's style and cannot be queried for features.`))), [];
              i3[n5.source] = true;
            }
          }
          let a3 = [];
          n4.availableImages = this._availableImages;
          let o3 = this._serializedAllLayers(), s3 = n4.layers instanceof Set ? n4.layers : Array.isArray(n4.layers) ? new Set(n4.layers) : null, c3 = Object.assign(Object.assign({}, n4), { layers: s3, globalState: this._globalState });
          for (let t5 in this.tileManagers) n4.layers && !i3[t5] || a3.push(se2(this.tileManagers[t5], this._layers, o3, e6, c3, r3, this.map.terrain ? (e7, t6, n5) => this.map.terrain.getElevation(e7, t6, n5) : void 0));
          return this.placement && a3.push((function(e7, t5, n5, r4, i4, a4, o4) {
            let s4 = {}, c4 = a4.queryRenderedSymbols(r4), l3 = [];
            for (let e8 of Object.keys(c4).map(Number)) l3.push(o4[e8]);
            l3.sort(F2);
            for (let n6 of l3) {
              let r5 = n6.featureIndex.lookupSymbolFeatures(c4[n6.bucketInstanceId], t5, n6.bucketIndex, n6.sourceLayerIndex, { filterSpec: i4.filter, globalState: i4.globalState }, i4.layers, i4.availableImages, e7);
              for (let e8 in r5) {
                let t6 = s4[e8] = s4[e8] || [], i5 = r5[e8];
                i5.sort(((e9, t7) => {
                  let r6 = n6.featureSortOrder;
                  if (r6) {
                    let n7 = r6.indexOf(e9.featureIndex);
                    return r6.indexOf(t7.featureIndex) - n7;
                  }
                  return t7.featureIndex - e9.featureIndex;
                }));
                for (let e9 of i5) t6.push(e9);
              }
            }
            return (function(e8, t6, n6) {
              for (let r5 in e8) for (let i5 of e8[r5]) ce2(i5, n6[t6[r5].source]);
              return e8;
            })(s4, e7, n5);
          })(this._layers, o3, this.tileManagers, e6, c3, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(a3);
        }
        querySourceFeatures(e6, n4) {
          n4 != null && n4.filter && this._validate(t4.B.filter, `querySourceFeatures.filter`, n4.filter, null, n4);
          let r3 = this.tileManagers[e6];
          return r3 ? (function(e7, t5) {
            let n5 = e7.getRenderableIds().map(((t6) => e7.getTileByID(t6))), r4 = [], i3 = {};
            for (let e8 = 0; e8 < n5.length; e8++) {
              let a3 = n5[e8], o3 = a3.tileID.canonical.key;
              i3[o3] || (i3[o3] = true, a3.querySourceFeatures(r4, t5));
            }
            return r4;
          })(r3, n4 ? Object.assign(Object.assign({}, n4), { globalState: this._globalState }) : { globalState: this._globalState }) : [];
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(e6, n4 = {}) {
          this._checkLoaded();
          let r3 = this.light.getLight(), i3 = false;
          for (let n5 in e6) if (!t4.bK(e6[n5], r3[n5])) {
            i3 = true;
            break;
          }
          if (!i3) return;
          let a3 = { now: c2(), transition: t4.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.light.setLight(e6, n4), this.light.updateTransitions(a3);
        }
        getProjection() {
          var _a3;
          return (_a3 = this.stylesheet) == null ? void 0 : _a3.projection;
        }
        setProjection(e6) {
          if (this._checkLoaded(), this.projection) {
            if (this.projection.name === e6.type) return;
            this.projection.destroy(), delete this.projection;
          }
          this.stylesheet.projection = e6, this._setProjectionInternal(e6.type);
        }
        getSky() {
          var _a3;
          return (_a3 = this.stylesheet) == null ? void 0 : _a3.sky;
        }
        setSky(e6, n4 = {}) {
          this._checkLoaded();
          let r3 = this.getSky(), i3 = false;
          if (!e6 && !r3) return;
          if (e6 && !r3) i3 = true;
          else if (!e6 && r3) i3 = true;
          else for (let n5 in e6) if (!t4.bK(e6[n5], r3[n5])) {
            i3 = true;
            break;
          }
          if (!i3) return;
          let a3 = { now: c2(), transition: t4.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.stylesheet.sky = e6, this.sky.setSky(e6, n4), this.sky.updateTransitions(a3);
        }
        _setProjectionInternal(e6) {
          let n4 = (function(e7, n5) {
            let r3 = { constrain: n5 };
            if (Array.isArray(e7)) {
              let t5 = new cn2({ type: e7 });
              return { projection: t5, transform: new En(r3), cameraHelper: new On(t5) };
            }
            switch (e7) {
              case `mercator`:
                return { projection: new It2(), transform: new Wt2(r3), cameraHelper: new Jt2() };
              case `globe`: {
                let e8 = new cn2({ type: [`interpolate`, [`linear`], [`zoom`], 11, `vertical-perspective`, 12, `mercator`] });
                return { projection: e8, transform: new En(r3), cameraHelper: new On(e8) };
              }
              case `vertical-perspective`:
                return { projection: new on2(), transform: new Tn(r3), cameraHelper: new Dn() };
              default:
                return t4.w(`Unknown projection name: ${e7}. Falling back to mercator projection.`), { projection: new It2(), transform: new Wt2(r3), cameraHelper: new Jt2() };
            }
          })(e6, this.map.transformConstrain);
          for (let e7 in this.projection = n4.projection, this.map.migrateProjection(n4.transform, n4.cameraHelper), this.tileManagers) this.tileManagers[e7].reload();
        }
        _validate(e6, n4, r3, i3, a3 = {}) {
          return (!a3 || false !== a3.validate) && kn(this, e6.call(t4.B, t4.e({ key: n4, style: this.serialize(), value: r3, styleSpec: t4.t }, i3)));
        }
        _remove(e6 = true) {
          for (let e7 in this._frameRequest && (this._frameRequest = (this._frameRequest.abort(), null)), this._loadStyleRequest && (this._loadStyleRequest = (this._loadStyleRequest.abort(), null)), this._spriteRequest && (this._spriteRequest = (this._spriteRequest.abort(), null)), we2().off(xe2, this._rtlPluginLoaded), this._layers) this._layers[e7].setEventedParent(null);
          for (let e7 in this.tileManagers) {
            let t5 = this.tileManagers[e7];
            t5.setEventedParent(null), t5.onRemove(this.map);
          }
          this.imageManager.setEventedParent(null), this.setEventedParent(null), e6 && this.dispatcher.broadcast(`RM`, void 0), this.dispatcher.remove(e6);
        }
        _clearSource(e6) {
          this.tileManagers[e6].clearTiles();
        }
        _reloadSource(e6) {
          this.tileManagers[e6].resume(), this.tileManagers[e6].reload();
        }
        _updateSources(e6) {
          for (let t5 in this.tileManagers) this.tileManagers[t5].update(e6, this.map.terrain);
        }
        _generateCollisionBoxes() {
          for (let e6 in this.tileManagers) this._reloadSource(e6);
        }
        _updatePlacement(e6, t5, n4, r3, i3 = false) {
          let a3 = false, o3 = false, s3 = {};
          for (let t6 of this._order) {
            let n5 = this._layers[t6];
            if (n5.type !== `symbol`) continue;
            if (!s3[n5.source]) {
              let e7 = this.tileManagers[n5.source];
              s3[n5.source] = e7.getRenderableIds(true).map(((t7) => e7.getTileByID(t7))).sort(((e8, t7) => t7.tileID.overscaledZ - e8.tileID.overscaledZ || (e8.tileID.isLessThan(t7.tileID) ? -1 : 1)));
            }
            let r4 = this.crossTileSymbolIndex.addLayer(n5, s3[n5.source], e6.center.lng);
            a3 || (a3 = r4);
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((i3 = i3 || this._layerOrderChanged || n4 === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(c2(), e6.zoom)) && (this.pauseablePlacement = new Tt2(e6, this.map.terrain, this._order, i3, t5, n4, r3, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, s3), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(c2()), o3 = true), a3 && this.pauseablePlacement.placement.setStale()), o3 || a3) for (let e7 of this._order) {
            let t6 = this._layers[e7];
            t6.type === `symbol` && this.placement.updateLayerOpacities(t6, s3[t6.source]);
          }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(c2());
        }
        _releaseSymbolFadeTiles() {
          for (let e6 in this.tileManagers) this.tileManagers[e6].releaseSymbolFadeTiles();
        }
        getImages(e6, n4) {
          return t4._(this, void 0, void 0, (function* () {
            let e7 = yield this.imageManager.getImages(n4.icons);
            this._updateTilesForChangedImages();
            let t5 = this.tileManagers[n4.source];
            return t5 && t5.setDependencies(n4.tileID.key, n4.type, n4.icons), e7;
          }));
        }
        getGlyphs(e6, n4) {
          return t4._(this, void 0, void 0, (function* () {
            let e7 = yield this.glyphManager.getGlyphs(n4.stacks), t5 = this.tileManagers[n4.source];
            return t5 && t5.setDependencies(n4.tileID.key, n4.type, [``]), e7;
          }));
        }
        getGlyphsUrl() {
          return this.stylesheet.glyphs || null;
        }
        setGlyphs(e6, n4 = {}) {
          this._checkLoaded(), e6 && this._validate(t4.B.glyphs, `glyphs`, e6, null, n4) || (this._glyphsDidChange = true, this.stylesheet.glyphs = e6, this.glyphManager.entries = {}, this.glyphManager.setURL(e6));
        }
        getDashes(e6, n4) {
          return t4._(this, void 0, void 0, (function* () {
            let e7 = {};
            for (let [t5, r3] of Object.entries(n4.dashes)) e7[t5] = this.lineAtlas.getDash(r3.dasharray, r3.round);
            return e7;
          }));
        }
        addSprite(e6, n4, r3 = {}, i3) {
          this._checkLoaded();
          let a3 = [{ id: e6, url: n4 }], o3 = [...v2(this.stylesheet.sprite), ...a3];
          this._validate(t4.B.sprite, `sprite`, o3, null, r3) || (this.stylesheet.sprite = o3, this._loadSprite(a3, true, i3));
        }
        removeSprite(e6) {
          this._checkLoaded();
          let n4 = v2(this.stylesheet.sprite);
          if (n4.find(((t5) => t5.id === e6))) {
            if (this._spritesImagesIds[e6]) for (let t5 of this._spritesImagesIds[e6]) this.imageManager.removeImage(t5), this._changedImages[t5] = true;
            n4.splice(n4.findIndex(((t5) => t5.id === e6)), 1), this.stylesheet.sprite = n4.length > 0 ? n4 : void 0, delete this._spritesImagesIds[e6], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast(`SI`, this._availableImages), this.fire(new t4.l(`data`, { dataType: `style` }));
          } else this.fire(new t4.k(Error(`Sprite "${e6}" doesn't exists on this map.`)));
        }
        getSprite() {
          return v2(this.stylesheet.sprite);
        }
        setSprite(e6, n4 = {}, r3) {
          this._checkLoaded(), e6 && this._validate(t4.B.sprite, `sprite`, e6, null, n4) || (this.stylesheet.sprite = e6, e6 ? this._loadSprite(e6, true, r3) : (this._unloadSprite(), r3 && r3(null)));
        }
      }
      var Mn = t4.aN([{ name: `a_pos`, type: `Int16`, components: 2 }, { name: `a_texture_pos`, type: `Int16`, components: 2 }]);
      class Nn {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
        }
        bind(e6, t5, n4, r3, i3, a3, o3, s3, c3) {
          this.context = e6;
          let l3 = this.boundPaintVertexBuffers.length !== r3.length;
          for (let e7 = 0; !l3 && e7 < r3.length; e7++) this.boundPaintVertexBuffers[e7] !== r3[e7] && (l3 = true);
          !this.vao || this.boundProgram !== t5 || this.boundLayoutVertexBuffer !== n4 || l3 || this.boundIndexBuffer !== i3 || this.boundVertexOffset !== a3 || this.boundDynamicVertexBuffer !== o3 || this.boundDynamicVertexBuffer2 !== s3 || this.boundDynamicVertexBuffer3 !== c3 ? this.freshBind(t5, n4, r3, i3, a3, o3, s3, c3) : (e6.bindVertexArray.set(this.vao), o3 && o3.bind(), i3 && i3.dynamicDraw && i3.bind(), s3 && s3.bind(), c3 && c3.bind());
        }
        freshBind(e6, t5, n4, r3, i3, a3, o3, s3) {
          let c3 = e6.numAttributes, l3 = this.context, u3 = l3.gl;
          this.vao && this.destroy(), this.vao = l3.createVertexArray(), l3.bindVertexArray.set(this.vao), this.boundProgram = e6, this.boundLayoutVertexBuffer = t5, this.boundPaintVertexBuffers = n4, this.boundIndexBuffer = r3, this.boundVertexOffset = i3, this.boundDynamicVertexBuffer = a3, this.boundDynamicVertexBuffer2 = o3, this.boundDynamicVertexBuffer3 = s3, t5.enableAttributes(u3, e6);
          for (let t6 of n4) t6.enableAttributes(u3, e6);
          a3 && a3.enableAttributes(u3, e6), o3 && o3.enableAttributes(u3, e6), s3 && s3.enableAttributes(u3, e6), t5.bind(), t5.setVertexAttribPointers(u3, e6, i3);
          for (let t6 of n4) t6.bind(), t6.setVertexAttribPointers(u3, e6, i3);
          a3 && (a3.bind(), a3.setVertexAttribPointers(u3, e6, i3)), r3 && r3.bind(), o3 && (o3.bind(), o3.setVertexAttribPointers(u3, e6, i3)), s3 && (s3.bind(), s3.setVertexAttribPointers(u3, e6, i3)), l3.currentNumAttributes = c3;
        }
        destroy() {
          this.vao && (this.vao = (this.context.deleteVertexArray(this.vao), null));
        }
      }
      let Pn = (e6, n4, r3, i3, a3) => ({ u_texture: 0, u_ele_delta: e6, u_fog_matrix: n4, u_fog_color: r3 ? r3.properties.get(`fog-color`) : t4.bi.white, u_fog_ground_blend: r3 ? r3.properties.get(`fog-ground-blend`) : 1, u_fog_ground_blend_opacity: a3 ? 0 : r3 ? r3.calculateFogBlendOpacity(i3) : 0, u_horizon_color: r3 ? r3.properties.get(`horizon-color`) : t4.bi.white, u_horizon_fog_blend: r3 ? r3.properties.get(`horizon-fog-blend`) : 1, u_is_globe_mode: a3 ? 1 : 0 }), Fn = { mainMatrix: `u_projection_matrix`, tileMercatorCoords: `u_projection_tile_mercator_coords`, clippingPlane: `u_projection_clipping_plane`, projectionTransition: `u_projection_transition`, fallbackMatrix: `u_projection_fallback_matrix` };
      function In(e6) {
        let t5 = [];
        for (let n4 = 0; n4 < e6.length; n4++) {
          if (e6[n4] === null) continue;
          let r3 = e6[n4].split(` `);
          t5.push(r3.pop());
        }
        return t5;
      }
      class Ln {
        constructor(e6, n4, r3, i3, a3, o3, s3, c3, l3 = []) {
          let u3 = e6.gl;
          this.program = u3.createProgram();
          let d3 = In(n4.staticAttributes), f3 = r3 ? r3.getBinderAttributes() : [], p3 = d3.concat(f3), m3 = Mt2.prelude.staticUniforms ? In(Mt2.prelude.staticUniforms) : [], h3 = s3.staticUniforms ? In(s3.staticUniforms) : [], g3 = n4.staticUniforms ? In(n4.staticUniforms) : [], _3 = r3 ? r3.getBinderUniforms() : [], v3 = m3.concat(h3).concat(g3).concat(_3), y3 = [];
          for (let e7 of v3) y3.indexOf(e7) < 0 && y3.push(e7);
          let b3 = r3 ? r3.defines() : [];
          en2(u3) && b3.unshift(`#version 300 es`), a3 && b3.push(`#define OVERDRAW_INSPECTOR;`), o3 && b3.push(`#define TERRAIN3D;`), c3 && b3.push(c3), l3 && b3.push(...l3);
          let x3 = b3.concat(Mt2.prelude.fragmentSource, s3.fragmentSource, n4.fragmentSource).join(`
`), S3 = b3.concat(Mt2.prelude.vertexSource, s3.vertexSource, n4.vertexSource).join(`
`);
          en2(u3) || (x3 = (function(e7) {
            return e7.replace(/\bin\s/g, `varying `).replace(`out highp vec4 fragColor;`, ``).replace(/fragColor/g, `gl_FragColor`).replace(/texture\(/g, `texture2D(`);
          })(x3), S3 = (function(e7) {
            return e7.replace(/\bin\s/g, `attribute `).replace(/\bout\s/g, `varying `).replace(/texture\(/g, `texture2D(`);
          })(S3));
          let C3 = u3.createShader(u3.FRAGMENT_SHADER);
          if (u3.isContextLost()) return void (this.failedToCreate = true);
          if (u3.shaderSource(C3, x3), u3.compileShader(C3), !u3.getShaderParameter(C3, u3.COMPILE_STATUS)) throw Error(`Could not compile fragment shader: ${u3.getShaderInfoLog(C3)}`);
          u3.attachShader(this.program, C3);
          let w3 = u3.createShader(u3.VERTEX_SHADER);
          if (u3.isContextLost()) return void (this.failedToCreate = true);
          if (u3.shaderSource(w3, S3), u3.compileShader(w3), !u3.getShaderParameter(w3, u3.COMPILE_STATUS)) throw Error(`Could not compile vertex shader: ${u3.getShaderInfoLog(w3)}`);
          u3.attachShader(this.program, w3), this.attributes = {};
          let T3 = {};
          this.numAttributes = p3.length;
          for (let e7 = 0; e7 < this.numAttributes; e7++) p3[e7] && (u3.bindAttribLocation(this.program, e7, p3[e7]), this.attributes[p3[e7]] = e7);
          if (u3.linkProgram(this.program), !u3.getProgramParameter(this.program, u3.LINK_STATUS)) throw Error(`Program failed to link: ${u3.getProgramInfoLog(this.program)}`);
          u3.deleteShader(w3), u3.deleteShader(C3);
          for (let e7 = 0; e7 < y3.length; e7++) {
            let t5 = y3[e7];
            if (t5 && !T3[t5]) {
              let e8 = u3.getUniformLocation(this.program, t5);
              e8 && (T3[t5] = e8);
            }
          }
          this.fixedUniforms = i3(e6, T3), this.terrainUniforms = ((e7, n5) => ({ u_depth: new t4.bT(e7, n5.u_depth), u_terrain: new t4.bT(e7, n5.u_terrain), u_terrain_dim: new t4.bj(e7, n5.u_terrain_dim), u_terrain_matrix: new t4.bV(e7, n5.u_terrain_matrix), u_terrain_unpack: new t4.bW(e7, n5.u_terrain_unpack), u_terrain_exaggeration: new t4.bj(e7, n5.u_terrain_exaggeration) }))(e6, T3), this.projectionUniforms = ((e7, n5) => ({ u_projection_matrix: new t4.bV(e7, n5.u_projection_matrix), u_projection_tile_mercator_coords: new t4.bW(e7, n5.u_projection_tile_mercator_coords), u_projection_clipping_plane: new t4.bW(e7, n5.u_projection_clipping_plane), u_projection_transition: new t4.bj(e7, n5.u_projection_transition), u_projection_fallback_matrix: new t4.bV(e7, n5.u_projection_fallback_matrix) }))(e6, T3), this.binderUniforms = r3 ? r3.getUniforms(e6, T3) : [];
        }
        draw(e6, t5, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3, p3, m3, h3, g3, _3, v3) {
          let y3 = e6.gl;
          if (this.failedToCreate) return;
          if (e6.program.set(this.program), e6.setDepthMode(n4), e6.setStencilMode(r3), e6.setColorMode(i3), e6.setCullFace(a3), s3) for (let t6 in e6.activeTexture.set(y3.TEXTURE2), y3.bindTexture(y3.TEXTURE_2D, s3.depthTexture), e6.activeTexture.set(y3.TEXTURE3), y3.bindTexture(y3.TEXTURE_2D, s3.texture), this.terrainUniforms) this.terrainUniforms[t6].set(s3[t6]);
          if (c3) for (let e7 in c3) this.projectionUniforms[Fn[e7]].set(c3[e7]);
          if (o3) for (let e7 in this.fixedUniforms) this.fixedUniforms[e7].set(o3[e7]);
          h3 && h3.setUniforms(e6, this.binderUniforms, p3, { zoom: m3 });
          let b3 = 0;
          switch (t5) {
            case y3.LINES:
              b3 = 2;
              break;
            case y3.TRIANGLES:
              b3 = 3;
              break;
            case y3.LINE_STRIP:
              b3 = 1;
          }
          for (let n5 of f3.get()) {
            let r4 = n5.vaos || (n5.vaos = {});
            (r4[l3] || (r4[l3] = new Nn())).bind(e6, this, u3, h3 ? h3.getPaintVertexBuffers() : [], d3, n5.vertexOffset, g3, _3, v3), y3.drawElements(t5, n5.primitiveLength * b3, y3.UNSIGNED_SHORT, n5.primitiveOffset * b3 * 2);
          }
        }
      }
      function Rn(e6, n4, r3) {
        let i3 = 1 / t4.aG(r3, 1, n4.transform.tileZoom), a3 = 2 ** r3.tileID.overscaledZ, o3 = r3.tileSize * 2 ** n4.transform.tileZoom / a3, s3 = o3 * (r3.tileID.canonical.x + r3.tileID.wrap * a3), c3 = o3 * r3.tileID.canonical.y;
        return { u_image: 0, u_texsize: r3.imageAtlasTexture.size, u_scale: [i3, e6.fromScale, e6.toScale], u_fade: e6.t, u_pixel_coord_upper: [s3 >> 16, c3 >> 16], u_pixel_coord_lower: [65535 & s3, 65535 & c3] };
      }
      let zn = (e6, n4, r3, i3) => {
        let a3 = e6.style.light, o3 = a3.properties.get(`position`), s3 = [o3.x, o3.y, o3.z], c3 = t4.bZ();
        a3.properties.get(`anchor`) === `viewport` && t4.b_(c3, e6.transform.bearingInRadians), t4.b$(s3, s3, c3);
        let l3 = e6.transform.transformLightDirection(s3), u3 = a3.properties.get(`color`);
        return { u_lightpos: s3, u_lightpos_globe: l3, u_lightintensity: a3.properties.get(`intensity`), u_lightcolor: [u3.r, u3.g, u3.b], u_vertical_gradient: +n4, u_opacity: r3, u_fill_translate: i3 };
      }, Bn = (e6, n4, r3, i3, a3, o3, s3) => t4.e(zn(e6, n4, r3, i3), Rn(o3, e6, s3), { u_height_factor: -(2 ** a3.overscaledZ) / s3.tileSize / 8 }), Vn = (e6, n4, r3, i3) => t4.e(Rn(n4, e6, r3), { u_fill_translate: i3 }), Hn = (e6, t5) => ({ u_world: e6, u_fill_translate: t5 }), Un = (e6, n4, r3, i3, a3) => t4.e(Vn(e6, n4, r3, a3), { u_world: i3 }), Wn = (e6, n4, r3, i3, a3) => {
        let o3 = e6.transform, s3, c3, l3 = 0;
        if (r3.paint.get(`circle-pitch-alignment`) === `map`) {
          let e7 = t4.aG(n4, 1, o3.zoom);
          s3 = true, c3 = [e7, e7], l3 = e7 / (t4.a3 * 2 ** n4.tileID.overscaledZ) * 2 * Math.PI * a3;
        } else s3 = false, c3 = o3.pixelsToGLUnits;
        return { u_camera_to_center_distance: o3.cameraToCenterDistance, u_scale_with_map: +(r3.paint.get(`circle-pitch-scale`) === `map`), u_pitch_with_map: +s3, u_device_pixel_ratio: e6.pixelRatio, u_extrude_scale: c3, u_globe_extrude_scale: l3, u_translate: i3 };
      }, Gn = (e6) => ({ u_pixel_extrude_scale: [1 / e6.width, 1 / e6.height] }), Kn = (e6) => ({ u_viewport_size: [e6.width, e6.height] }), qn = (e6, t5 = 1) => ({ u_color: e6, u_overlay: 0, u_overlay_scale: t5 }), Jn = (e6, n4, r3, i3) => {
        let a3 = t4.aG(e6, 1, n4) / (t4.a3 * 2 ** e6.tileID.overscaledZ) * 2 * Math.PI * i3;
        return { u_extrude_scale: t4.aG(e6, 1, n4), u_intensity: r3, u_globe_extrude_scale: a3 };
      }, Yn = (e6, n4, r3, i3) => {
        let a3 = t4.M();
        t4.c0(a3, 0, e6.width, e6.height, 0, 0, 1);
        let o3 = e6.context.gl;
        return { u_matrix: a3, u_world: [o3.drawingBufferWidth, o3.drawingBufferHeight], u_image: r3, u_color_ramp: i3, u_opacity: n4.paint.get(`heatmap-opacity`) };
      }, Xn = (e6, t5, n4) => {
        let r3 = n4.paint.get(`hillshade-accent-color`), i3;
        switch (n4.paint.get(`hillshade-method`)) {
          case `basic`:
            i3 = 4;
            break;
          case `combined`:
            i3 = 1;
            break;
          case `igor`:
            i3 = 2;
            break;
          case `multidirectional`:
            i3 = 3;
            break;
          default:
            i3 = 0;
        }
        let a3 = n4.getIlluminationProperties();
        for (let t6 = 0; t6 < a3.directionRadians.length; t6++) n4.paint.get(`hillshade-illumination-anchor`) === `viewport` && (a3.directionRadians[t6] += e6.transform.bearingInRadians);
        return { u_image: 0, u_latrange: Qn(0, t5.tileID), u_exaggeration: n4.paint.get(`hillshade-exaggeration`), u_altitudes: a3.altitudeRadians, u_azimuths: a3.directionRadians, u_accent: r3, u_method: i3, u_highlights: a3.highlightColor, u_shadows: a3.shadowColor };
      }, Zn = (e6, n4) => {
        let r3 = n4.stride, i3 = t4.M();
        return t4.c0(i3, 0, t4.a3, -t4.a3, 0, 0, 1), t4.N(i3, i3, [0, -t4.a3, 0]), { u_matrix: i3, u_image: 1, u_dimension: [r3, r3], u_zoom: e6.overscaledZ, u_unpack: n4.getUnpackVector() };
      };
      function Qn(e6, n4) {
        let r3 = 2 ** n4.canonical.z, i3 = n4.canonical.y;
        return [new t4.a5(0, i3 / r3).toLngLat().lat, new t4.a5(0, (i3 + 1) / r3).toLngLat().lat];
      }
      let $n = (e6, t5, n4 = 0) => ({ u_image: 0, u_unpack: t5.getUnpackVector(), u_dimension: [t5.stride, t5.stride], u_elevation_stops: 1, u_color_stops: 4, u_color_ramp_size: n4, u_opacity: e6.paint.get(`color-relief-opacity`) }), er = (e6, n4, r3, i3) => {
        let a3 = e6.transform;
        return { u_translation: or(e6, n4, r3), u_ratio: i3 / t4.aG(n4, 1, a3.zoom), u_device_pixel_ratio: e6.pixelRatio, u_units_to_pixels: [1 / a3.pixelsToGLUnits[0], 1 / a3.pixelsToGLUnits[1]] };
      }, tr = (e6, n4, r3, i3, a3) => t4.e(er(e6, n4, r3, i3), { u_image: 0, u_image_height: a3 }), nr = (e6, n4, r3, i3, a3) => {
        let o3 = e6.transform, s3 = ar(n4, o3);
        return { u_translation: or(e6, n4, r3), u_texsize: n4.imageAtlasTexture.size, u_ratio: i3 / t4.aG(n4, 1, o3.zoom), u_device_pixel_ratio: e6.pixelRatio, u_image: 0, u_scale: [s3, a3.fromScale, a3.toScale], u_fade: a3.t, u_units_to_pixels: [1 / o3.pixelsToGLUnits[0], 1 / o3.pixelsToGLUnits[1]] };
      }, rr = (e6, n4, r3, i3, a3) => {
        let o3 = ar(n4, e6.transform);
        return t4.e(er(e6, n4, r3, i3), { u_tileratio: o3, u_crossfade_from: a3.fromScale, u_crossfade_to: a3.toScale, u_image: 0, u_mix: a3.t, u_lineatlas_width: e6.lineAtlas.width, u_lineatlas_height: e6.lineAtlas.height });
      }, ir = (e6, n4, r3, i3, a3, o3) => {
        let s3 = ar(n4, e6.transform);
        return t4.e(er(e6, n4, r3, i3), { u_image: 0, u_image_height: o3, u_tileratio: s3, u_crossfade_from: a3.fromScale, u_crossfade_to: a3.toScale, u_image_dash: 1, u_mix: a3.t, u_lineatlas_width: e6.lineAtlas.width, u_lineatlas_height: e6.lineAtlas.height });
      };
      function ar(e6, n4) {
        return 1 / t4.aG(e6, 1, n4.tileZoom);
      }
      function or(e6, n4, r3) {
        return t4.aH(e6.transform, n4, r3.paint.get(`line-translate`), r3.paint.get(`line-translate-anchor`));
      }
      let sr = (e6, t5, n4, r3, i3) => {
        return { u_tl_parent: e6, u_scale_parent: t5, u_buffer_scale: 1, u_fade_t: n4.mix, u_opacity: n4.opacity * r3.paint.get(`raster-opacity`), u_image0: 0, u_image1: 1, u_brightness_low: r3.paint.get(`raster-brightness-min`), u_brightness_high: r3.paint.get(`raster-brightness-max`), u_saturation_factor: (o3 = r3.paint.get(`raster-saturation`), o3 > 0 ? 1 - 1 / (1.001 - o3) : -o3), u_contrast_factor: (a3 = r3.paint.get(`raster-contrast`), a3 > 0 ? 1 / (1 - a3) : 1 + a3), u_spin_weights: cr(r3.paint.get(`raster-hue-rotate`)), u_coords_top: [i3[0].x, i3[0].y, i3[1].x, i3[1].y], u_coords_bottom: [i3[3].x, i3[3].y, i3[2].x, i3[2].y] };
        var a3, o3;
      };
      function cr(e6) {
        e6 *= Math.PI / 180;
        let t5 = Math.sin(e6), n4 = Math.cos(e6);
        return [(2 * n4 + 1) / 3, (-Math.sqrt(3) * t5 - n4 + 1) / 3, (Math.sqrt(3) * t5 - n4 + 1) / 3];
      }
      let lr = (e6, t5, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3) => {
        let p3 = o3.transform;
        return { u_is_size_zoom_constant: +(e6 === `constant` || e6 === `source`), u_is_size_feature_constant: +(e6 === `constant` || e6 === `camera`), u_size_t: t5 ? t5.uSizeT : 0, u_size: t5 ? t5.uSize : 0, u_camera_to_center_distance: p3.cameraToCenterDistance, u_pitch: p3.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +n4, u_aspect_ratio: p3.width / p3.height, u_fade_change: o3.options.fadeDuration ? o3.symbolFadeChange : 1, u_label_plane_matrix: s3, u_coord_matrix: c3, u_is_text: +u3, u_pitch_with_map: +r3, u_is_along_line: i3, u_is_variable_anchor: a3, u_texsize: d3, u_texture: 0, u_translation: l3, u_pitched_scale: f3 };
      }, ur = (e6, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3, p3, m3) => {
        let h3 = s3.transform;
        return t4.e(lr(e6, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3, m3), { u_gamma_scale: i3 ? Math.cos(h3.pitch * Math.PI / 180) * h3.cameraToCenterDistance : 1, u_device_pixel_ratio: s3.pixelRatio, u_is_halo: 1 });
      }, dr = (e6, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3, p3) => t4.e(ur(e6, n4, r3, i3, a3, o3, s3, c3, l3, u3, true, d3, 0, p3), { u_texsize_icon: f3, u_texture_icon: 1 }), fr = (e6, t5) => ({ u_opacity: e6, u_color: t5 }), pr = (e6, n4, r3, i3, a3) => t4.e((function(e7, n5, r4, i4) {
        let a4 = r4.imageManager.getPattern(e7.from.toString()), o3 = r4.imageManager.getPattern(e7.to.toString()), { width: s3, height: c3 } = r4.imageManager.getPixelSize(), l3 = 2 ** i4.tileID.overscaledZ, u3 = i4.tileSize * 2 ** r4.transform.tileZoom / l3, d3 = u3 * (i4.tileID.canonical.x + i4.tileID.wrap * l3), f3 = u3 * i4.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl_a: a4.tl, u_pattern_br_a: a4.br, u_pattern_tl_b: o3.tl, u_pattern_br_b: o3.br, u_texsize: [s3, c3], u_mix: n5.t, u_pattern_size_a: a4.displaySize, u_pattern_size_b: o3.displaySize, u_scale_a: n5.fromScale, u_scale_b: n5.toScale, u_tile_units_to_pixels: 1 / t4.aG(i4, 1, r4.transform.tileZoom), u_pixel_coord_upper: [d3 >> 16, f3 >> 16], u_pixel_coord_lower: [65535 & d3, 65535 & f3] };
      })(r3, a3, n4, i3), { u_opacity: e6 }), mr = (e6, t5) => {
      }, hr = { fillExtrusion: (e6, n4) => ({ u_lightpos: new t4.bX(e6, n4.u_lightpos), u_lightpos_globe: new t4.bX(e6, n4.u_lightpos_globe), u_lightintensity: new t4.bj(e6, n4.u_lightintensity), u_lightcolor: new t4.bX(e6, n4.u_lightcolor), u_vertical_gradient: new t4.bj(e6, n4.u_vertical_gradient), u_opacity: new t4.bj(e6, n4.u_opacity), u_fill_translate: new t4.bY(e6, n4.u_fill_translate) }), fillExtrusionPattern: (e6, n4) => ({ u_lightpos: new t4.bX(e6, n4.u_lightpos), u_lightpos_globe: new t4.bX(e6, n4.u_lightpos_globe), u_lightintensity: new t4.bj(e6, n4.u_lightintensity), u_lightcolor: new t4.bX(e6, n4.u_lightcolor), u_vertical_gradient: new t4.bj(e6, n4.u_vertical_gradient), u_height_factor: new t4.bj(e6, n4.u_height_factor), u_opacity: new t4.bj(e6, n4.u_opacity), u_fill_translate: new t4.bY(e6, n4.u_fill_translate), u_image: new t4.bT(e6, n4.u_image), u_texsize: new t4.bY(e6, n4.u_texsize), u_pixel_coord_upper: new t4.bY(e6, n4.u_pixel_coord_upper), u_pixel_coord_lower: new t4.bY(e6, n4.u_pixel_coord_lower), u_scale: new t4.bX(e6, n4.u_scale), u_fade: new t4.bj(e6, n4.u_fade) }), fill: (e6, n4) => ({ u_fill_translate: new t4.bY(e6, n4.u_fill_translate) }), fillPattern: (e6, n4) => ({ u_image: new t4.bT(e6, n4.u_image), u_texsize: new t4.bY(e6, n4.u_texsize), u_pixel_coord_upper: new t4.bY(e6, n4.u_pixel_coord_upper), u_pixel_coord_lower: new t4.bY(e6, n4.u_pixel_coord_lower), u_scale: new t4.bX(e6, n4.u_scale), u_fade: new t4.bj(e6, n4.u_fade), u_fill_translate: new t4.bY(e6, n4.u_fill_translate) }), fillOutline: (e6, n4) => ({ u_world: new t4.bY(e6, n4.u_world), u_fill_translate: new t4.bY(e6, n4.u_fill_translate) }), fillOutlinePattern: (e6, n4) => ({ u_world: new t4.bY(e6, n4.u_world), u_image: new t4.bT(e6, n4.u_image), u_texsize: new t4.bY(e6, n4.u_texsize), u_pixel_coord_upper: new t4.bY(e6, n4.u_pixel_coord_upper), u_pixel_coord_lower: new t4.bY(e6, n4.u_pixel_coord_lower), u_scale: new t4.bX(e6, n4.u_scale), u_fade: new t4.bj(e6, n4.u_fade), u_fill_translate: new t4.bY(e6, n4.u_fill_translate) }), circle: (e6, n4) => ({ u_camera_to_center_distance: new t4.bj(e6, n4.u_camera_to_center_distance), u_scale_with_map: new t4.bT(e6, n4.u_scale_with_map), u_pitch_with_map: new t4.bT(e6, n4.u_pitch_with_map), u_extrude_scale: new t4.bY(e6, n4.u_extrude_scale), u_device_pixel_ratio: new t4.bj(e6, n4.u_device_pixel_ratio), u_globe_extrude_scale: new t4.bj(e6, n4.u_globe_extrude_scale), u_translate: new t4.bY(e6, n4.u_translate) }), collisionBox: (e6, n4) => ({ u_pixel_extrude_scale: new t4.bY(e6, n4.u_pixel_extrude_scale) }), collisionCircle: (e6, n4) => ({ u_viewport_size: new t4.bY(e6, n4.u_viewport_size) }), debug: (e6, n4) => ({ u_color: new t4.bU(e6, n4.u_color), u_overlay: new t4.bT(e6, n4.u_overlay), u_overlay_scale: new t4.bj(e6, n4.u_overlay_scale) }), depth: mr, clippingMask: mr, heatmap: (e6, n4) => ({ u_extrude_scale: new t4.bj(e6, n4.u_extrude_scale), u_intensity: new t4.bj(e6, n4.u_intensity), u_globe_extrude_scale: new t4.bj(e6, n4.u_globe_extrude_scale) }), heatmapTexture: (e6, n4) => ({ u_matrix: new t4.bV(e6, n4.u_matrix), u_world: new t4.bY(e6, n4.u_world), u_image: new t4.bT(e6, n4.u_image), u_color_ramp: new t4.bT(e6, n4.u_color_ramp), u_opacity: new t4.bj(e6, n4.u_opacity) }), hillshade: (e6, n4) => ({ u_image: new t4.bT(e6, n4.u_image), u_latrange: new t4.bY(e6, n4.u_latrange), u_exaggeration: new t4.bj(e6, n4.u_exaggeration), u_altitudes: new t4.c2(e6, n4.u_altitudes), u_azimuths: new t4.c2(e6, n4.u_azimuths), u_accent: new t4.bU(e6, n4.u_accent), u_method: new t4.bT(e6, n4.u_method), u_shadows: new t4.c1(e6, n4.u_shadows), u_highlights: new t4.c1(e6, n4.u_highlights) }), hillshadePrepare: (e6, n4) => ({ u_matrix: new t4.bV(e6, n4.u_matrix), u_image: new t4.bT(e6, n4.u_image), u_dimension: new t4.bY(e6, n4.u_dimension), u_zoom: new t4.bj(e6, n4.u_zoom), u_unpack: new t4.bW(e6, n4.u_unpack) }), colorRelief: (e6, n4) => ({ u_image: new t4.bT(e6, n4.u_image), u_unpack: new t4.bW(e6, n4.u_unpack), u_dimension: new t4.bY(e6, n4.u_dimension), u_elevation_stops: new t4.bT(e6, n4.u_elevation_stops), u_color_stops: new t4.bT(e6, n4.u_color_stops), u_color_ramp_size: new t4.bT(e6, n4.u_color_ramp_size), u_opacity: new t4.bj(e6, n4.u_opacity) }), line: (e6, n4) => ({ u_translation: new t4.bY(e6, n4.u_translation), u_ratio: new t4.bj(e6, n4.u_ratio), u_device_pixel_ratio: new t4.bj(e6, n4.u_device_pixel_ratio), u_units_to_pixels: new t4.bY(e6, n4.u_units_to_pixels) }), lineGradient: (e6, n4) => ({ u_translation: new t4.bY(e6, n4.u_translation), u_ratio: new t4.bj(e6, n4.u_ratio), u_device_pixel_ratio: new t4.bj(e6, n4.u_device_pixel_ratio), u_units_to_pixels: new t4.bY(e6, n4.u_units_to_pixels), u_image: new t4.bT(e6, n4.u_image), u_image_height: new t4.bj(e6, n4.u_image_height) }), linePattern: (e6, n4) => ({ u_translation: new t4.bY(e6, n4.u_translation), u_texsize: new t4.bY(e6, n4.u_texsize), u_ratio: new t4.bj(e6, n4.u_ratio), u_device_pixel_ratio: new t4.bj(e6, n4.u_device_pixel_ratio), u_image: new t4.bT(e6, n4.u_image), u_units_to_pixels: new t4.bY(e6, n4.u_units_to_pixels), u_scale: new t4.bX(e6, n4.u_scale), u_fade: new t4.bj(e6, n4.u_fade) }), lineSDF: (e6, n4) => ({ u_translation: new t4.bY(e6, n4.u_translation), u_ratio: new t4.bj(e6, n4.u_ratio), u_device_pixel_ratio: new t4.bj(e6, n4.u_device_pixel_ratio), u_units_to_pixels: new t4.bY(e6, n4.u_units_to_pixels), u_image: new t4.bT(e6, n4.u_image), u_mix: new t4.bj(e6, n4.u_mix), u_tileratio: new t4.bj(e6, n4.u_tileratio), u_crossfade_from: new t4.bj(e6, n4.u_crossfade_from), u_crossfade_to: new t4.bj(e6, n4.u_crossfade_to), u_lineatlas_width: new t4.bj(e6, n4.u_lineatlas_width), u_lineatlas_height: new t4.bj(e6, n4.u_lineatlas_height) }), lineGradientSDF: (e6, n4) => ({ u_translation: new t4.bY(e6, n4.u_translation), u_ratio: new t4.bj(e6, n4.u_ratio), u_device_pixel_ratio: new t4.bj(e6, n4.u_device_pixel_ratio), u_units_to_pixels: new t4.bY(e6, n4.u_units_to_pixels), u_image: new t4.bT(e6, n4.u_image), u_image_height: new t4.bj(e6, n4.u_image_height), u_tileratio: new t4.bj(e6, n4.u_tileratio), u_crossfade_from: new t4.bj(e6, n4.u_crossfade_from), u_crossfade_to: new t4.bj(e6, n4.u_crossfade_to), u_image_dash: new t4.bT(e6, n4.u_image_dash), u_mix: new t4.bj(e6, n4.u_mix), u_lineatlas_width: new t4.bj(e6, n4.u_lineatlas_width), u_lineatlas_height: new t4.bj(e6, n4.u_lineatlas_height) }), raster: (e6, n4) => ({ u_tl_parent: new t4.bY(e6, n4.u_tl_parent), u_scale_parent: new t4.bj(e6, n4.u_scale_parent), u_buffer_scale: new t4.bj(e6, n4.u_buffer_scale), u_fade_t: new t4.bj(e6, n4.u_fade_t), u_opacity: new t4.bj(e6, n4.u_opacity), u_image0: new t4.bT(e6, n4.u_image0), u_image1: new t4.bT(e6, n4.u_image1), u_brightness_low: new t4.bj(e6, n4.u_brightness_low), u_brightness_high: new t4.bj(e6, n4.u_brightness_high), u_saturation_factor: new t4.bj(e6, n4.u_saturation_factor), u_contrast_factor: new t4.bj(e6, n4.u_contrast_factor), u_spin_weights: new t4.bX(e6, n4.u_spin_weights), u_coords_top: new t4.bW(e6, n4.u_coords_top), u_coords_bottom: new t4.bW(e6, n4.u_coords_bottom) }), symbolIcon: (e6, n4) => ({ u_is_size_zoom_constant: new t4.bT(e6, n4.u_is_size_zoom_constant), u_is_size_feature_constant: new t4.bT(e6, n4.u_is_size_feature_constant), u_size_t: new t4.bj(e6, n4.u_size_t), u_size: new t4.bj(e6, n4.u_size), u_camera_to_center_distance: new t4.bj(e6, n4.u_camera_to_center_distance), u_pitch: new t4.bj(e6, n4.u_pitch), u_rotate_symbol: new t4.bT(e6, n4.u_rotate_symbol), u_aspect_ratio: new t4.bj(e6, n4.u_aspect_ratio), u_fade_change: new t4.bj(e6, n4.u_fade_change), u_label_plane_matrix: new t4.bV(e6, n4.u_label_plane_matrix), u_coord_matrix: new t4.bV(e6, n4.u_coord_matrix), u_is_text: new t4.bT(e6, n4.u_is_text), u_pitch_with_map: new t4.bT(e6, n4.u_pitch_with_map), u_is_along_line: new t4.bT(e6, n4.u_is_along_line), u_is_variable_anchor: new t4.bT(e6, n4.u_is_variable_anchor), u_texsize: new t4.bY(e6, n4.u_texsize), u_texture: new t4.bT(e6, n4.u_texture), u_translation: new t4.bY(e6, n4.u_translation), u_pitched_scale: new t4.bj(e6, n4.u_pitched_scale) }), symbolSDF: (e6, n4) => ({ u_is_size_zoom_constant: new t4.bT(e6, n4.u_is_size_zoom_constant), u_is_size_feature_constant: new t4.bT(e6, n4.u_is_size_feature_constant), u_size_t: new t4.bj(e6, n4.u_size_t), u_size: new t4.bj(e6, n4.u_size), u_camera_to_center_distance: new t4.bj(e6, n4.u_camera_to_center_distance), u_pitch: new t4.bj(e6, n4.u_pitch), u_rotate_symbol: new t4.bT(e6, n4.u_rotate_symbol), u_aspect_ratio: new t4.bj(e6, n4.u_aspect_ratio), u_fade_change: new t4.bj(e6, n4.u_fade_change), u_label_plane_matrix: new t4.bV(e6, n4.u_label_plane_matrix), u_coord_matrix: new t4.bV(e6, n4.u_coord_matrix), u_is_text: new t4.bT(e6, n4.u_is_text), u_pitch_with_map: new t4.bT(e6, n4.u_pitch_with_map), u_is_along_line: new t4.bT(e6, n4.u_is_along_line), u_is_variable_anchor: new t4.bT(e6, n4.u_is_variable_anchor), u_texsize: new t4.bY(e6, n4.u_texsize), u_texture: new t4.bT(e6, n4.u_texture), u_gamma_scale: new t4.bj(e6, n4.u_gamma_scale), u_device_pixel_ratio: new t4.bj(e6, n4.u_device_pixel_ratio), u_is_halo: new t4.bT(e6, n4.u_is_halo), u_translation: new t4.bY(e6, n4.u_translation), u_pitched_scale: new t4.bj(e6, n4.u_pitched_scale) }), symbolTextAndIcon: (e6, n4) => ({ u_is_size_zoom_constant: new t4.bT(e6, n4.u_is_size_zoom_constant), u_is_size_feature_constant: new t4.bT(e6, n4.u_is_size_feature_constant), u_size_t: new t4.bj(e6, n4.u_size_t), u_size: new t4.bj(e6, n4.u_size), u_camera_to_center_distance: new t4.bj(e6, n4.u_camera_to_center_distance), u_pitch: new t4.bj(e6, n4.u_pitch), u_rotate_symbol: new t4.bT(e6, n4.u_rotate_symbol), u_aspect_ratio: new t4.bj(e6, n4.u_aspect_ratio), u_fade_change: new t4.bj(e6, n4.u_fade_change), u_label_plane_matrix: new t4.bV(e6, n4.u_label_plane_matrix), u_coord_matrix: new t4.bV(e6, n4.u_coord_matrix), u_is_text: new t4.bT(e6, n4.u_is_text), u_pitch_with_map: new t4.bT(e6, n4.u_pitch_with_map), u_is_along_line: new t4.bT(e6, n4.u_is_along_line), u_is_variable_anchor: new t4.bT(e6, n4.u_is_variable_anchor), u_texsize: new t4.bY(e6, n4.u_texsize), u_texsize_icon: new t4.bY(e6, n4.u_texsize_icon), u_texture: new t4.bT(e6, n4.u_texture), u_texture_icon: new t4.bT(e6, n4.u_texture_icon), u_gamma_scale: new t4.bj(e6, n4.u_gamma_scale), u_device_pixel_ratio: new t4.bj(e6, n4.u_device_pixel_ratio), u_is_halo: new t4.bT(e6, n4.u_is_halo), u_translation: new t4.bY(e6, n4.u_translation), u_pitched_scale: new t4.bj(e6, n4.u_pitched_scale) }), background: (e6, n4) => ({ u_opacity: new t4.bj(e6, n4.u_opacity), u_color: new t4.bU(e6, n4.u_color) }), backgroundPattern: (e6, n4) => ({ u_opacity: new t4.bj(e6, n4.u_opacity), u_image: new t4.bT(e6, n4.u_image), u_pattern_tl_a: new t4.bY(e6, n4.u_pattern_tl_a), u_pattern_br_a: new t4.bY(e6, n4.u_pattern_br_a), u_pattern_tl_b: new t4.bY(e6, n4.u_pattern_tl_b), u_pattern_br_b: new t4.bY(e6, n4.u_pattern_br_b), u_texsize: new t4.bY(e6, n4.u_texsize), u_mix: new t4.bj(e6, n4.u_mix), u_pattern_size_a: new t4.bY(e6, n4.u_pattern_size_a), u_pattern_size_b: new t4.bY(e6, n4.u_pattern_size_b), u_scale_a: new t4.bj(e6, n4.u_scale_a), u_scale_b: new t4.bj(e6, n4.u_scale_b), u_pixel_coord_upper: new t4.bY(e6, n4.u_pixel_coord_upper), u_pixel_coord_lower: new t4.bY(e6, n4.u_pixel_coord_lower), u_tile_units_to_pixels: new t4.bj(e6, n4.u_tile_units_to_pixels) }), terrain: (e6, n4) => ({ u_texture: new t4.bT(e6, n4.u_texture), u_ele_delta: new t4.bj(e6, n4.u_ele_delta), u_fog_matrix: new t4.bV(e6, n4.u_fog_matrix), u_fog_color: new t4.bU(e6, n4.u_fog_color), u_fog_ground_blend: new t4.bj(e6, n4.u_fog_ground_blend), u_fog_ground_blend_opacity: new t4.bj(e6, n4.u_fog_ground_blend_opacity), u_horizon_color: new t4.bU(e6, n4.u_horizon_color), u_horizon_fog_blend: new t4.bj(e6, n4.u_horizon_fog_blend), u_is_globe_mode: new t4.bj(e6, n4.u_is_globe_mode) }), terrainDepth: (e6, n4) => ({ u_ele_delta: new t4.bj(e6, n4.u_ele_delta) }), terrainCoords: (e6, n4) => ({ u_texture: new t4.bT(e6, n4.u_texture), u_terrain_coords_id: new t4.bj(e6, n4.u_terrain_coords_id), u_ele_delta: new t4.bj(e6, n4.u_ele_delta) }), projectionErrorMeasurement: (e6, n4) => ({ u_input: new t4.bj(e6, n4.u_input), u_output_expected: new t4.bj(e6, n4.u_output_expected) }), atmosphere: (e6, n4) => ({ u_sun_pos: new t4.bX(e6, n4.u_sun_pos), u_atmosphere_blend: new t4.bj(e6, n4.u_atmosphere_blend), u_globe_position: new t4.bX(e6, n4.u_globe_position), u_globe_radius: new t4.bj(e6, n4.u_globe_radius), u_inv_proj_matrix: new t4.bV(e6, n4.u_inv_proj_matrix) }), sky: (e6, n4) => ({ u_sky_color: new t4.bU(e6, n4.u_sky_color), u_horizon_color: new t4.bU(e6, n4.u_horizon_color), u_horizon: new t4.bY(e6, n4.u_horizon), u_horizon_normal: new t4.bY(e6, n4.u_horizon_normal), u_sky_horizon_blend: new t4.bj(e6, n4.u_sky_horizon_blend), u_sky_blend: new t4.bj(e6, n4.u_sky_blend) }) };
      class gr {
        constructor(e6, t5, n4) {
          this.context = e6;
          let r3 = e6.gl;
          this.buffer = r3.createBuffer(), this.dynamicDraw = !!n4, this.context.unbindVAO(), e6.bindElementBuffer.set(this.buffer), r3.bufferData(r3.ELEMENT_ARRAY_BUFFER, t5.arrayBuffer, this.dynamicDraw ? r3.DYNAMIC_DRAW : r3.STATIC_DRAW), this.dynamicDraw || delete t5.arrayBuffer;
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(e6) {
          let t5 = this.context.gl;
          if (!this.dynamicDraw) throw Error(`Attempted to update data while not in dynamic mode.`);
          this.context.unbindVAO(), this.bind(), t5.bufferSubData(t5.ELEMENT_ARRAY_BUFFER, 0, e6.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      let _r = { Int8: `BYTE`, Uint8: `UNSIGNED_BYTE`, Int16: `SHORT`, Uint16: `UNSIGNED_SHORT`, Int32: `INT`, Uint32: `UNSIGNED_INT`, Float32: `FLOAT` };
      class vr {
        constructor(e6, t5, n4, r3) {
          this.length = t5.length, this.attributes = n4, this.itemSize = t5.bytesPerElement, this.dynamicDraw = r3, this.context = e6;
          let i3 = e6.gl;
          this.buffer = i3.createBuffer(), e6.bindVertexBuffer.set(this.buffer), i3.bufferData(i3.ARRAY_BUFFER, t5.arrayBuffer, this.dynamicDraw ? i3.DYNAMIC_DRAW : i3.STATIC_DRAW), this.dynamicDraw || delete t5.arrayBuffer;
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(e6) {
          if (e6.length !== this.length) throw Error(`Length of new data is ${e6.length}, which doesn't match current length of ${this.length}`);
          let t5 = this.context.gl;
          this.bind(), t5.bufferSubData(t5.ARRAY_BUFFER, 0, e6.arrayBuffer);
        }
        enableAttributes(e6, t5) {
          for (let n4 = 0; n4 < this.attributes.length; n4++) {
            let r3 = t5.attributes[this.attributes[n4].name];
            r3 !== void 0 && e6.enableVertexAttribArray(r3);
          }
        }
        setVertexAttribPointers(e6, t5, n4) {
          for (let r3 = 0; r3 < this.attributes.length; r3++) {
            let i3 = this.attributes[r3], a3 = t5.attributes[i3.name];
            a3 !== void 0 && e6.vertexAttribPointer(a3, i3.components, e6[_r[i3.type]], false, this.itemSize, i3.offset + this.itemSize * (n4 || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      class yr {
        constructor(e6) {
          this.gl = e6.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
        }
        get() {
          return this.current;
        }
        set(e6) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class br extends yr {
        getDefault() {
          return t4.bi.transparent;
        }
        set(e6) {
          let t5 = this.current;
          (e6.r !== t5.r || e6.g !== t5.g || e6.b !== t5.b || e6.a !== t5.a || this.dirty) && (this.gl.clearColor(e6.r, e6.g, e6.b, e6.a), this.current = e6, this.dirty = false);
        }
      }
      class xr extends yr {
        getDefault() {
          return 1;
        }
        set(e6) {
          (e6 !== this.current || this.dirty) && (this.gl.clearDepth(e6), this.current = e6, this.dirty = false);
        }
      }
      class Sr extends yr {
        getDefault() {
          return 0;
        }
        set(e6) {
          (e6 !== this.current || this.dirty) && (this.gl.clearStencil(e6), this.current = e6, this.dirty = false);
        }
      }
      class Cr extends yr {
        getDefault() {
          return [true, true, true, true];
        }
        set(e6) {
          let t5 = this.current;
          (e6[0] !== t5[0] || e6[1] !== t5[1] || e6[2] !== t5[2] || e6[3] !== t5[3] || this.dirty) && (this.gl.colorMask(e6[0], e6[1], e6[2], e6[3]), this.current = e6, this.dirty = false);
        }
      }
      class wr extends yr {
        getDefault() {
          return true;
        }
        set(e6) {
          (e6 !== this.current || this.dirty) && (this.gl.depthMask(e6), this.current = e6, this.dirty = false);
        }
      }
      class Tr extends yr {
        getDefault() {
          return 255;
        }
        set(e6) {
          (e6 !== this.current || this.dirty) && (this.gl.stencilMask(e6), this.current = e6, this.dirty = false);
        }
      }
      class Er extends yr {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(e6) {
          let t5 = this.current;
          (e6.func !== t5.func || e6.ref !== t5.ref || e6.mask !== t5.mask || this.dirty) && (this.gl.stencilFunc(e6.func, e6.ref, e6.mask), this.current = e6, this.dirty = false);
        }
      }
      class Dr extends yr {
        getDefault() {
          let e6 = this.gl;
          return [e6.KEEP, e6.KEEP, e6.KEEP];
        }
        set(e6) {
          let t5 = this.current;
          (e6[0] !== t5[0] || e6[1] !== t5[1] || e6[2] !== t5[2] || this.dirty) && (this.gl.stencilOp(e6[0], e6[1], e6[2]), this.current = e6, this.dirty = false);
        }
      }
      class Or extends yr {
        getDefault() {
          return false;
        }
        set(e6) {
          if (e6 === this.current && !this.dirty) return;
          let t5 = this.gl;
          e6 ? t5.enable(t5.STENCIL_TEST) : t5.disable(t5.STENCIL_TEST), this.current = e6, this.dirty = false;
        }
      }
      class kr extends yr {
        getDefault() {
          return [0, 1];
        }
        set(e6) {
          let t5 = this.current;
          (e6[0] !== t5[0] || e6[1] !== t5[1] || this.dirty) && (this.gl.depthRange(e6[0], e6[1]), this.current = e6, this.dirty = false);
        }
      }
      class Ar extends yr {
        getDefault() {
          return false;
        }
        set(e6) {
          if (e6 === this.current && !this.dirty) return;
          let t5 = this.gl;
          e6 ? t5.enable(t5.DEPTH_TEST) : t5.disable(t5.DEPTH_TEST), this.current = e6, this.dirty = false;
        }
      }
      class jr extends yr {
        getDefault() {
          return this.gl.LESS;
        }
        set(e6) {
          (e6 !== this.current || this.dirty) && (this.gl.depthFunc(e6), this.current = e6, this.dirty = false);
        }
      }
      class Mr extends yr {
        getDefault() {
          return false;
        }
        set(e6) {
          if (e6 === this.current && !this.dirty) return;
          let t5 = this.gl;
          e6 ? t5.enable(t5.BLEND) : t5.disable(t5.BLEND), this.current = e6, this.dirty = false;
        }
      }
      class Nr extends yr {
        getDefault() {
          let e6 = this.gl;
          return [e6.ONE, e6.ZERO];
        }
        set(e6) {
          let t5 = this.current;
          (e6[0] !== t5[0] || e6[1] !== t5[1] || this.dirty) && (this.gl.blendFunc(e6[0], e6[1]), this.current = e6, this.dirty = false);
        }
      }
      class Pr extends yr {
        getDefault() {
          return t4.bi.transparent;
        }
        set(e6) {
          let t5 = this.current;
          (e6.r !== t5.r || e6.g !== t5.g || e6.b !== t5.b || e6.a !== t5.a || this.dirty) && (this.gl.blendColor(e6.r, e6.g, e6.b, e6.a), this.current = e6, this.dirty = false);
        }
      }
      class Fr extends yr {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(e6) {
          (e6 !== this.current || this.dirty) && (this.gl.blendEquation(e6), this.current = e6, this.dirty = false);
        }
      }
      class Ir extends yr {
        getDefault() {
          return false;
        }
        set(e6) {
          if (e6 === this.current && !this.dirty) return;
          let t5 = this.gl;
          e6 ? t5.enable(t5.CULL_FACE) : t5.disable(t5.CULL_FACE), this.current = e6, this.dirty = false;
        }
      }
      class Lr extends yr {
        getDefault() {
          return this.gl.BACK;
        }
        set(e6) {
          (e6 !== this.current || this.dirty) && (this.gl.cullFace(e6), this.current = e6, this.dirty = false);
        }
      }
      class Rr extends yr {
        getDefault() {
          return this.gl.CCW;
        }
        set(e6) {
          (e6 !== this.current || this.dirty) && (this.gl.frontFace(e6), this.current = e6, this.dirty = false);
        }
      }
      class zr extends yr {
        getDefault() {
          return null;
        }
        set(e6) {
          (e6 !== this.current || this.dirty) && (this.gl.useProgram(e6), this.current = e6, this.dirty = false);
        }
      }
      class Br extends yr {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(e6) {
          (e6 !== this.current || this.dirty) && (this.gl.activeTexture(e6), this.current = e6, this.dirty = false);
        }
      }
      class Vr extends yr {
        getDefault() {
          let e6 = this.gl;
          return [0, 0, e6.drawingBufferWidth, e6.drawingBufferHeight];
        }
        set(e6) {
          let t5 = this.current;
          (e6[0] !== t5[0] || e6[1] !== t5[1] || e6[2] !== t5[2] || e6[3] !== t5[3] || this.dirty) && (this.gl.viewport(e6[0], e6[1], e6[2], e6[3]), this.current = e6, this.dirty = false);
        }
      }
      class Hr extends yr {
        getDefault() {
          return null;
        }
        set(e6) {
          if (e6 === this.current && !this.dirty) return;
          let t5 = this.gl;
          t5.bindFramebuffer(t5.FRAMEBUFFER, e6), this.current = e6, this.dirty = false;
        }
      }
      class Ur extends yr {
        getDefault() {
          return null;
        }
        set(e6) {
          if (e6 === this.current && !this.dirty) return;
          let t5 = this.gl;
          t5.bindRenderbuffer(t5.RENDERBUFFER, e6), this.current = e6, this.dirty = false;
        }
      }
      class Wr extends yr {
        getDefault() {
          return null;
        }
        set(e6) {
          if (e6 === this.current && !this.dirty) return;
          let t5 = this.gl;
          t5.bindTexture(t5.TEXTURE_2D, e6), this.current = e6, this.dirty = false;
        }
      }
      class Gr extends yr {
        getDefault() {
          return null;
        }
        set(e6) {
          if (e6 === this.current && !this.dirty) return;
          let t5 = this.gl;
          t5.bindBuffer(t5.ARRAY_BUFFER, e6), this.current = e6, this.dirty = false;
        }
      }
      class Kr extends yr {
        getDefault() {
          return null;
        }
        set(e6) {
          let t5 = this.gl;
          t5.bindBuffer(t5.ELEMENT_ARRAY_BUFFER, e6), this.current = e6, this.dirty = false;
        }
      }
      class qr extends yr {
        getDefault() {
          return null;
        }
        set(e6) {
          var t5;
          if (e6 === this.current && !this.dirty) return;
          let n4 = this.gl;
          en2(n4) ? n4.bindVertexArray(e6) : (t5 = n4.getExtension(`OES_vertex_array_object`)) == null || t5.bindVertexArrayOES(e6), this.current = e6, this.dirty = false;
        }
      }
      class Y extends yr {
        getDefault() {
          return 4;
        }
        set(e6) {
          if (e6 === this.current && !this.dirty) return;
          let t5 = this.gl;
          t5.pixelStorei(t5.UNPACK_ALIGNMENT, e6), this.current = e6, this.dirty = false;
        }
      }
      class Jr extends yr {
        getDefault() {
          return false;
        }
        set(e6) {
          if (e6 === this.current && !this.dirty) return;
          let t5 = this.gl;
          t5.pixelStorei(t5.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e6), this.current = e6, this.dirty = false;
        }
      }
      class Yr extends yr {
        getDefault() {
          return false;
        }
        set(e6) {
          if (e6 === this.current && !this.dirty) return;
          let t5 = this.gl;
          t5.pixelStorei(t5.UNPACK_FLIP_Y_WEBGL, e6), this.current = e6, this.dirty = false;
        }
      }
      class Xr extends yr {
        constructor(e6, t5) {
          super(e6), this.context = e6, this.parent = t5;
        }
        getDefault() {
          return null;
        }
      }
      class Zr extends Xr {
        setDirty() {
          this.dirty = true;
        }
        set(e6) {
          if (e6 === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          let t5 = this.gl;
          t5.framebufferTexture2D(t5.FRAMEBUFFER, t5.COLOR_ATTACHMENT0, t5.TEXTURE_2D, e6, 0), this.current = e6, this.dirty = false;
        }
      }
      class Qr extends Xr {
        set(e6) {
          if (e6 === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          let t5 = this.gl;
          t5.framebufferRenderbuffer(t5.FRAMEBUFFER, t5.DEPTH_ATTACHMENT, t5.RENDERBUFFER, e6), this.current = e6, this.dirty = false;
        }
      }
      class $r extends Xr {
        set(e6) {
          if (e6 === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          let t5 = this.gl;
          t5.framebufferRenderbuffer(t5.FRAMEBUFFER, t5.DEPTH_STENCIL_ATTACHMENT, t5.RENDERBUFFER, e6), this.current = e6, this.dirty = false;
        }
      }
      let ei = `Framebuffer is not complete`;
      class ti {
        constructor(e6, t5, n4, r3, i3) {
          this.context = e6, this.width = t5, this.height = n4;
          let a3 = e6.gl, o3 = this.framebuffer = a3.createFramebuffer();
          if (this.colorAttachment = new Zr(e6, o3), r3) this.depthAttachment = i3 ? new $r(e6, o3) : new Qr(e6, o3);
          else if (i3) throw Error(`Stencil cannot be set without depth`);
          if (a3.checkFramebufferStatus(a3.FRAMEBUFFER) !== a3.FRAMEBUFFER_COMPLETE) throw Error(ei);
        }
        destroy() {
          let e6 = this.context.gl, t5 = this.colorAttachment.get();
          if (t5 && e6.deleteTexture(t5), this.depthAttachment) {
            let t6 = this.depthAttachment.get();
            t6 && e6.deleteRenderbuffer(t6);
          }
          e6.deleteFramebuffer(this.framebuffer);
        }
      }
      class ni {
        constructor(e6) {
          var _a3;
          if (this.gl = e6, this.clearColor = new br(this), this.clearDepth = new xr(this), this.clearStencil = new Sr(this), this.colorMask = new Cr(this), this.depthMask = new wr(this), this.stencilMask = new Tr(this), this.stencilFunc = new Er(this), this.stencilOp = new Dr(this), this.stencilTest = new Or(this), this.depthRange = new kr(this), this.depthTest = new Ar(this), this.depthFunc = new jr(this), this.blend = new Mr(this), this.blendFunc = new Nr(this), this.blendColor = new Pr(this), this.blendEquation = new Fr(this), this.cullFace = new Ir(this), this.cullFaceSide = new Lr(this), this.frontFace = new Rr(this), this.program = new zr(this), this.activeTexture = new Br(this), this.viewport = new Vr(this), this.bindFramebuffer = new Hr(this), this.bindRenderbuffer = new Ur(this), this.bindTexture = new Wr(this), this.bindVertexBuffer = new Gr(this), this.bindElementBuffer = new Kr(this), this.bindVertexArray = new qr(this), this.pixelStoreUnpack = new Y(this), this.pixelStoreUnpackPremultiplyAlpha = new Jr(this), this.pixelStoreUnpackFlipY = new Yr(this), this.extTextureFilterAnisotropic = e6.getExtension(`EXT_texture_filter_anisotropic`) || e6.getExtension(`MOZ_EXT_texture_filter_anisotropic`) || e6.getExtension(`WEBKIT_EXT_texture_filter_anisotropic`), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e6.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e6.getParameter(e6.MAX_TEXTURE_SIZE), en2(e6)) {
            this.HALF_FLOAT = e6.HALF_FLOAT;
            let t5 = e6.getExtension(`EXT_color_buffer_half_float`);
            this.RGBA16F = e6.RGBA16F ?? (t5 == null ? void 0 : t5.RGBA16F_EXT), this.RGB16F = e6.RGB16F ?? (t5 == null ? void 0 : t5.RGB16F_EXT), e6.getExtension(`EXT_color_buffer_float`);
          } else e6.getExtension(`EXT_color_buffer_half_float`), e6.getExtension(`OES_texture_half_float_linear`), this.HALF_FLOAT = (_a3 = e6.getExtension(`OES_texture_half_float`)) == null ? void 0 : _a3.HALF_FLOAT_OES;
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
        }
        createIndexBuffer(e6, t5) {
          return new gr(this, e6, t5);
        }
        createVertexBuffer(e6, t5, n4) {
          return new vr(this, e6, t5, n4);
        }
        createRenderbuffer(e6, t5, n4) {
          let r3 = this.gl, i3 = r3.createRenderbuffer();
          return this.bindRenderbuffer.set(i3), r3.renderbufferStorage(r3.RENDERBUFFER, e6, t5, n4), this.bindRenderbuffer.set(null), i3;
        }
        createFramebuffer(e6, t5, n4, r3) {
          return new ti(this, e6, t5, n4, r3);
        }
        clear({ color: e6, depth: t5, stencil: n4 }) {
          let r3 = this.gl, i3 = 0;
          e6 && (i3 |= r3.COLOR_BUFFER_BIT, this.clearColor.set(e6), this.colorMask.set([true, true, true, true])), t5 !== void 0 && (i3 |= r3.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t5), this.depthMask.set(true)), n4 !== void 0 && (i3 |= r3.STENCIL_BUFFER_BIT, this.clearStencil.set(n4), this.stencilMask.set(255)), r3.clear(i3);
        }
        setCullFace(e6) {
          false === e6.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e6.mode), this.frontFace.set(e6.frontFace));
        }
        setDepthMode(e6) {
          e6.func !== this.gl.ALWAYS || e6.mask ? (this.depthTest.set(true), this.depthFunc.set(e6.func), this.depthMask.set(e6.mask), this.depthRange.set(e6.range)) : this.depthTest.set(false);
        }
        setStencilMode(e6) {
          e6.test.func !== this.gl.ALWAYS || e6.mask ? (this.stencilTest.set(true), this.stencilMask.set(e6.mask), this.stencilOp.set([e6.fail, e6.depthFail, e6.pass]), this.stencilFunc.set({ func: e6.test.func, ref: e6.ref, mask: e6.test.mask })) : this.stencilTest.set(false);
        }
        setColorMode(e6) {
          t4.bK(e6.blendFunction, Yt2.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e6.blendFunction), this.blendColor.set(e6.blendColor)), this.colorMask.set(e6.mask);
        }
        createVertexArray() {
          var _a3;
          return en2(this.gl) ? this.gl.createVertexArray() : (_a3 = this.gl.getExtension(`OES_vertex_array_object`)) == null ? void 0 : _a3.createVertexArrayOES();
        }
        deleteVertexArray(e6) {
          var _a3;
          return en2(this.gl) ? this.gl.deleteVertexArray(e6) : (_a3 = this.gl.getExtension(`OES_vertex_array_object`)) == null ? void 0 : _a3.deleteVertexArrayOES(e6);
        }
        unbindVAO() {
          this.bindVertexArray.set(null);
        }
      }
      let ri;
      function ii(e6, n4, r3, i3, a3) {
        let o3 = e6.context, s3 = e6.transform, c3 = o3.gl, l3 = e6.useProgram(`collisionBox`), u3 = [], d3 = 0, f3 = 0;
        for (let t5 = 0; t5 < i3.length; t5++) {
          let p4 = i3[t5], m4 = n4.getTile(p4).getBucket(r3);
          if (!m4) continue;
          let h4 = a3 ? m4.textCollisionBox : m4.iconCollisionBox, g4 = m4.collisionCircleArray;
          g4.length > 0 && (u3.push({ circleArray: g4, circleOffset: f3, coord: p4 }), d3 += g4.length / 4, f3 = d3), h4 && l3.draw(o3, c3.LINES, J2.disabled, Qt2.disabled, e6.colorModeForRenderPass(), q2.disabled, Gn(e6.transform), e6.style.map.terrain && e6.style.map.terrain.getTerrainData(p4), s3.getProjectionData({ overscaledTileID: p4, applyGlobeMatrix: true, applyTerrainMatrix: true }), r3.id, h4.layoutVertexBuffer, h4.indexBuffer, h4.segments, null, e6.transform.zoom, null, null, h4.collisionVertexBuffer);
        }
        if (!a3 || !u3.length) return;
        let p3 = e6.useProgram(`collisionCircle`), m3 = new t4.c3();
        m3.resize(4 * d3), m3._trim();
        let h3 = 0;
        for (let e7 of u3) for (let t5 = 0; t5 < e7.circleArray.length / 4; t5++) {
          let n5 = 4 * t5, r4 = e7.circleArray[n5 + 0], i4 = e7.circleArray[n5 + 1], a4 = e7.circleArray[n5 + 2], o4 = e7.circleArray[n5 + 3];
          m3.emplace(h3++, r4, i4, a4, o4, 0), m3.emplace(h3++, r4, i4, a4, o4, 1), m3.emplace(h3++, r4, i4, a4, o4, 2), m3.emplace(h3++, r4, i4, a4, o4, 3);
        }
        (!ri || ri.length < 2 * d3) && (ri = (function(e7) {
          let n5 = 2 * e7, r4 = new t4.c5();
          r4.resize(n5), r4._trim();
          for (let e8 = 0; e8 < n5; e8++) {
            let t5 = 6 * e8;
            r4.uint16[t5 + 0] = 4 * e8 + 0, r4.uint16[t5 + 1] = 4 * e8 + 1, r4.uint16[t5 + 2] = 4 * e8 + 2, r4.uint16[t5 + 3] = 4 * e8 + 2, r4.uint16[t5 + 4] = 4 * e8 + 3, r4.uint16[t5 + 5] = 4 * e8 + 0;
          }
          return r4;
        })(d3));
        let g3 = o3.createIndexBuffer(ri, true), _3 = o3.createVertexBuffer(m3, t4.c4.members, true);
        for (let n5 of u3) {
          let i4 = Kn(e6.transform);
          p3.draw(o3, c3.TRIANGLES, J2.disabled, Qt2.disabled, e6.colorModeForRenderPass(), q2.disabled, i4, e6.style.map.terrain && e6.style.map.terrain.getTerrainData(n5.coord), null, r3.id, _3, g3, t4.aQ.simpleSegment(0, 2 * n5.circleOffset, n5.circleArray.length, n5.circleArray.length / 2), null, e6.transform.zoom, null, null, null);
        }
        _3.destroy(), g3.destroy();
      }
      let ai = t4.am(new Float32Array(16));
      function oi(e6, n4, r3, i3, a3, o3) {
        let { horizontalAlign: s3, verticalAlign: c3 } = t4.aL(e6);
        return new t4.P((-(s3 - 0.5) * n4 / a3 + i3[0]) * o3, (-(c3 - 0.5) * r3 / a3 + i3[1]) * o3);
      }
      function si(e6, n4, r3, i3, a3, o3) {
        let s3 = n4.tileAnchorPoint.add(new t4.P(n4.translation[0], n4.translation[1]));
        if (n4.pitchWithMap) {
          let e7 = i3.mult(o3);
          r3 || (e7 = e7.rotate(-a3));
          let t5 = s3.add(e7);
          return V2(t5.x, t5.y, n4.pitchedLabelPlaneMatrix, n4.getElevation).point;
        }
        if (r3) {
          let t5 = tt2(n4.tileAnchorPoint.x + 1, n4.tileAnchorPoint.y, n4).point.sub(e6), r4 = Math.atan(t5.y / t5.x) + (t5.x < 0 ? Math.PI : 0);
          return e6.add(i3.rotate(r4));
        }
        return e6.add(i3);
      }
      function ci(e6, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3) {
        let p3 = e6.text.placedSymbolArray, m3 = e6.text.dynamicLayoutVertexArray, h3 = e6.icon.dynamicLayoutVertexArray, g3 = {};
        m3.clear();
        for (let h4 = 0; h4 < p3.length; h4++) {
          let _3 = p3.get(h4), v3 = _3.hidden || !_3.crossTileID || e6.allowVerticalPlacement && !_3.placedOrientation ? null : i3[_3.crossTileID];
          if (v3) {
            let i4 = new t4.P(_3.anchorX, _3.anchorY), p4 = { getElevation: f3, width: a3.width, height: a3.height, pitchedLabelPlaneMatrix: o3, pitchWithMap: r3, transform: a3, tileAnchorPoint: i4, translation: u3, unwrappedTileID: d3 }, h5 = r3 ? rt2(i4.x, i4.y, p4) : tt2(i4.x, i4.y, p4), y3 = H2(a3.cameraToCenterDistance, h5.signedDistanceFromCamera), b3 = t4.at(e6.textSizeData, c3, _3) * y3 / t4.aF;
            r3 && (b3 *= e6.tilePixelRatio / s3);
            let { width: x3, height: S3, anchor: C3, textOffset: w3, textBoxScale: T3 } = v3, E3 = oi(C3, x3, S3, w3, T3, b3), D3 = a3.getPitchedTextCorrection(i4.x + u3[0], i4.y + u3[1], d3), O3 = si(h5.point, p4, n4, E3, -a3.bearingInRadians, D3), k3 = e6.allowVerticalPlacement && _3.placedOrientation === t4.as.vertical ? Math.PI / 2 : 0;
            for (let e7 = 0; e7 < _3.numGlyphs; e7++) t4.az(m3, O3, k3);
            l3 && _3.associatedIconIndex >= 0 && (g3[_3.associatedIconIndex] = { shiftedAnchor: O3, angle: k3 });
          } else st2(_3.numGlyphs, m3);
        }
        if (l3) {
          h3.clear();
          let n5 = e6.icon.placedSymbolArray;
          for (let e7 = 0; e7 < n5.length; e7++) {
            let r4 = n5.get(e7);
            if (r4.hidden) st2(r4.numGlyphs, h3);
            else {
              let n6 = g3[e7];
              if (n6) for (let e8 = 0; e8 < r4.numGlyphs; e8++) t4.az(h3, n6.shiftedAnchor, n6.angle);
              else st2(r4.numGlyphs, h3);
            }
          }
          e6.icon.dynamicLayoutVertexBuffer.updateData(h3);
        }
        e6.text.dynamicLayoutVertexBuffer.updateData(m3);
      }
      function li(e6, t5, n4) {
        return n4.iconsInText && t5 ? `symbolTextAndIcon` : e6 ? `symbolSDF` : `symbolIcon`;
      }
      function ui(e6, n4, r3, i3, a3, o3, s3, c3, l3, u3, d3, f3, p3) {
        let m3 = e6.context, h3 = m3.gl, g3 = e6.transform, _3 = c3 === `map`, v3 = l3 === `map`, y3 = c3 !== `viewport` && r3.layout.get(`symbol-placement`) !== `point`, b3 = _3 && !v3 && !y3, x3 = !r3.layout.get(`symbol-sort-key`).isConstant(), S3 = false, C3 = e6.getDepthModeForSublayer(0, J2.ReadOnly), w3 = r3._unevaluatedLayout.hasValue(`text-variable-anchor`) || r3._unevaluatedLayout.hasValue(`text-variable-anchor-offset`), T3 = [], E3 = g3.getCircleRadiusCorrection();
        for (let c4 of i3) {
          let i4 = n4.getTile(c4), l4 = i4.getBucket(r3);
          if (!l4) continue;
          let d4 = a3 ? l4.text : l4.icon;
          if (!d4 || !d4.segments.get().length || !d4.hasVisibleVertices) continue;
          let f4 = d4.programConfigurations.get(r3.id), m4 = a3 || l4.sdfIcons, C4 = a3 ? l4.textSizeData : l4.iconSizeData, D3 = v3 || g3.pitch !== 0, O3 = e6.useProgram(li(m4, a3, l4), f4), k3 = t4.ar(C4, g3.zoom), A3 = e6.style.map.terrain && e6.style.map.terrain.getTerrainData(c4), ee3, j3, M3, te3, N3 = [0, 0], ne3 = null;
          if (a3) j3 = i4.glyphAtlasTexture, M3 = h3.LINEAR, ee3 = i4.glyphAtlasTexture.size, l4.iconsInText && (N3 = i4.imageAtlasTexture.size, ne3 = i4.imageAtlasTexture, te3 = D3 || e6.options.rotating || e6.options.zooming || C4.kind === `composite` || C4.kind === `camera` ? h3.LINEAR : h3.NEAREST);
          else {
            let t5 = r3.layout.get(`icon-size`).constantOr(0) !== 1 || l4.iconsNeedLinear;
            j3 = i4.imageAtlasTexture, M3 = m4 || e6.options.rotating || e6.options.zooming || t5 || D3 ? h3.LINEAR : h3.NEAREST, ee3 = i4.imageAtlasTexture.size;
          }
          let P3 = t4.aG(i4, 1, e6.transform.zoom), re3 = qe2(_3, e6.transform, P3), ie3 = t4.M();
          t4.au(ie3, re3);
          let ae3 = Je2(v3, _3, e6.transform, P3), oe3 = t4.aH(g3, i4, o3, s3), se3 = g3.getProjectionData({ overscaledTileID: c4, applyGlobeMatrix: !p3, applyTerrainMatrix: true }), F3 = w3 && l4.hasTextData(), ce3 = r3.layout.get(`icon-text-fit`) !== `none` && F3 && l4.hasIconData();
          if (y3) {
            let t5 = e6.style.map.terrain ? (t6, n5) => e6.style.map.terrain.getElevation(c4, t6, n5) : null;
            Xe2(l4, e6, a3, re3, ie3, v3, u3, r3.layout.get(`text-rotation-alignment`) === `map`, c4.toUnwrapped(), g3.width, g3.height, oe3, t5);
          }
          let le3 = a3 && w3 || ce3, ue3 = y3 || le3 ? ai : v3 ? re3 : e6.transform.clipSpaceToPixelsMatrix, de3 = m4 && r3.paint.get(a3 ? `text-halo-width` : `icon-halo-width`).constantOr(1) !== 0, fe3;
          fe3 = m4 ? l4.iconsInText ? dr(C4.kind, k3, b3, v3, y3, le3, e6, ue3, ae3, oe3, ee3, N3, E3) : ur(C4.kind, k3, b3, v3, y3, le3, e6, ue3, ae3, oe3, a3, ee3, 0, E3) : lr(C4.kind, k3, b3, v3, y3, le3, e6, ue3, ae3, oe3, a3, ee3, E3);
          let pe3 = { program: O3, buffers: d4, uniformValues: fe3, projectionData: se3, atlasTexture: j3, atlasTextureIcon: ne3, atlasInterpolation: M3, atlasInterpolationIcon: te3, isSDF: m4, hasHalo: de3 };
          if (x3 && l4.canOverlap) {
            S3 = true;
            let e7 = d4.segments.get();
            for (let n5 of e7) T3.push({ segments: new t4.aQ([n5]), sortKey: n5.sortKey, state: pe3, terrainData: A3 });
          } else T3.push({ segments: d4.segments, sortKey: 0, state: pe3, terrainData: A3 });
        }
        S3 && T3.sort(((e7, t5) => e7.sortKey - t5.sortKey));
        for (let t5 of T3) {
          let n5 = t5.state;
          if (m3.activeTexture.set(h3.TEXTURE0), n5.atlasTexture.bind(n5.atlasInterpolation, h3.CLAMP_TO_EDGE), n5.atlasTextureIcon && (m3.activeTexture.set(h3.TEXTURE1), n5.atlasTextureIcon && n5.atlasTextureIcon.bind(n5.atlasInterpolationIcon, h3.CLAMP_TO_EDGE)), n5.isSDF) {
            let i4 = n5.uniformValues;
            n5.hasHalo && (i4.u_is_halo = 1, di(n5.buffers, t5.segments, r3, e6, n5.program, C3, d3, f3, i4, n5.projectionData, t5.terrainData)), i4.u_is_halo = 0;
          }
          di(n5.buffers, t5.segments, r3, e6, n5.program, C3, d3, f3, n5.uniformValues, n5.projectionData, t5.terrainData);
        }
      }
      function di(e6, t5, n4, r3, i3, a3, o3, s3, c3, l3, u3) {
        let d3 = r3.context;
        i3.draw(d3, d3.gl.TRIANGLES, a3, o3, s3, q2.backCCW, c3, u3, l3, n4.id, e6.layoutVertexBuffer, e6.indexBuffer, t5, n4.paint, r3.transform.zoom, e6.programConfigurations.get(n4.id), e6.dynamicLayoutVertexBuffer, e6.opacityVertexBuffer);
      }
      function fi(e6, n4, r3, i3, a3) {
        let o3 = e6.context, s3 = o3.gl, c3 = Qt2.disabled, l3 = new Yt2([s3.ONE, s3.ONE], t4.bi.transparent, [true, true, true, true]), u3 = n4.getBucket(r3);
        if (!u3) return;
        let d3 = i3.key, f3 = r3.heatmapFbos.get(d3);
        f3 || (f3 = mi(o3, n4.tileSize, n4.tileSize), r3.heatmapFbos.set(d3, f3)), o3.bindFramebuffer.set(f3.framebuffer), o3.viewport.set([0, 0, n4.tileSize, n4.tileSize]), o3.clear({ color: t4.bi.transparent });
        let p3 = u3.programConfigurations.get(r3.id), m3 = e6.useProgram(`heatmap`, p3, !a3), h3 = e6.transform.getProjectionData({ overscaledTileID: n4.tileID, applyGlobeMatrix: true, applyTerrainMatrix: true }), g3 = e6.style.map.terrain.getTerrainData(i3);
        m3.draw(o3, s3.TRIANGLES, J2.disabled, c3, l3, q2.disabled, Jn(n4, e6.transform.zoom, r3.paint.get(`heatmap-intensity`), 1), g3, h3, r3.id, u3.layoutVertexBuffer, u3.indexBuffer, u3.segments, r3.paint, e6.transform.zoom, p3);
      }
      function pi(e6, t5, n4, r3, i3) {
        let a3 = e6.context, o3 = a3.gl, s3 = e6.transform;
        a3.setColorMode(e6.colorModeForRenderPass());
        let c3 = hi(a3, t5), l3 = n4.key, u3 = t5.heatmapFbos.get(l3);
        if (!u3) return;
        a3.activeTexture.set(o3.TEXTURE0), o3.bindTexture(o3.TEXTURE_2D, u3.colorAttachment.get()), a3.activeTexture.set(o3.TEXTURE1), c3.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
        let d3 = s3.getProjectionData({ overscaledTileID: n4, applyTerrainMatrix: i3, applyGlobeMatrix: !r3 });
        e6.useProgram(`heatmapTexture`).draw(a3, o3.TRIANGLES, J2.disabled, Qt2.disabled, e6.colorModeForRenderPass(), q2.disabled, Yn(e6, t5, 0, 1), null, d3, t5.id, e6.rasterBoundsBuffer, e6.quadTriangleIndexBuffer, e6.rasterBoundsSegments, t5.paint, s3.zoom), u3.destroy(), t5.heatmapFbos.delete(l3);
      }
      function mi(e6, t5, n4) {
        let r3 = e6.gl, i3 = r3.createTexture();
        r3.bindTexture(r3.TEXTURE_2D, i3), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_WRAP_S, r3.CLAMP_TO_EDGE), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_WRAP_T, r3.CLAMP_TO_EDGE), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_MIN_FILTER, r3.LINEAR), r3.texParameteri(r3.TEXTURE_2D, r3.TEXTURE_MAG_FILTER, r3.LINEAR);
        let a3 = e6.HALF_FLOAT ?? r3.UNSIGNED_BYTE, o3 = e6.RGBA16F ?? r3.RGBA;
        r3.texImage2D(r3.TEXTURE_2D, 0, o3, t5, n4, 0, r3.RGBA, a3, null);
        let s3 = e6.createFramebuffer(t5, n4, false, false);
        return s3.colorAttachment.set(i3), s3;
      }
      function hi(e6, n4) {
        return n4.colorRampTexture || (n4.colorRampTexture = new t4.T(e6, n4.colorRamp, e6.gl.RGBA)), n4.colorRampTexture;
      }
      function gi(e6, n4, r3, i3, a3, o3, s3, c3) {
        let l3 = 256;
        if (a3.stepInterpolant) {
          let i4 = n4.getSource().maxzoom, a4 = s3.canonical.z === i4 ? Math.ceil(1 << e6.transform.maxZoom - s3.canonical.z) : 1;
          l3 = t4.ai(t4.c7(o3.maxLineLength / t4.a3 * 1024 * a4), 256, r3.maxTextureSize);
        }
        return c3.gradient = t4.c8({ expression: a3.gradientExpression(), evaluationKey: `lineProgress`, resolution: l3, image: c3.gradient || void 0, clips: o3.lineClipsArray }), c3.texture ? c3.texture.update(c3.gradient) : c3.texture = new t4.T(r3, c3.gradient, i3.RGBA), c3.version = a3.gradientVersion, c3.texture;
      }
      function _i(e6, t5, n4, r3, i3) {
        e6.activeTexture.set(t5.TEXTURE0), n4.imageAtlasTexture.bind(t5.LINEAR, t5.CLAMP_TO_EDGE), r3.updatePaintBuffers(i3);
      }
      function vi(e6, t5, n4, r3, i3, a3) {
        (i3 || e6.lineAtlas.dirty) && (t5.activeTexture.set(n4.TEXTURE0), e6.lineAtlas.bind(t5)), r3.updatePaintBuffers(a3);
      }
      function yi(e6, t5, n4, r3, i3, a3, o3) {
        let s3 = a3.gradients[i3.id], c3 = s3.texture;
        i3.gradientVersion !== s3.version && (c3 = gi(e6, t5, n4, r3, i3, a3, o3, s3)), n4.activeTexture.set(r3.TEXTURE0), c3.bind(i3.stepInterpolant ? r3.NEAREST : r3.LINEAR, r3.CLAMP_TO_EDGE);
      }
      function bi(e6, t5, n4, r3, i3, a3, o3, s3, c3) {
        let l3 = a3.gradients[i3.id], u3 = l3.texture;
        i3.gradientVersion !== l3.version && (u3 = gi(e6, t5, n4, r3, i3, a3, o3, l3)), n4.activeTexture.set(r3.TEXTURE0), u3.bind(i3.stepInterpolant ? r3.NEAREST : r3.LINEAR, r3.CLAMP_TO_EDGE), n4.activeTexture.set(r3.TEXTURE1), e6.lineAtlas.bind(n4), s3.updatePaintBuffers(c3);
      }
      function xi(e6, t5, n4, r3, i3) {
        if (!n4 || !r3 || !r3.imageAtlas) return;
        let a3 = r3.imageAtlas.patternPositions, o3 = a3[n4.to.toString()], s3 = a3[n4.from.toString()];
        if (!o3 && s3 && (o3 = s3), !s3 && o3 && (s3 = o3), !o3 || !s3) {
          let e7 = i3.getPaintProperty(t5);
          o3 = a3[e7], s3 = a3[e7];
        }
        o3 && s3 && e6.setConstantPatternPositions(o3, s3);
      }
      function Si(e6, n4, r3, i3, a3, o3, s3, c3) {
        let l3 = e6.context.gl, u3 = `fill-pattern`, d3 = r3.paint.get(u3), f3 = d3 && d3.constantOr(1), p3 = r3.getCrossfadeParameters(), m3, h3, g3, _3, v3, y3 = e6.transform, b3 = r3.paint.get(`fill-translate`), x3 = r3.paint.get(`fill-translate-anchor`);
        s3 ? (h3 = f3 && !r3.getPaintProperty(`fill-outline-color`) ? `fillOutlinePattern` : `fillOutline`, m3 = l3.LINES) : (h3 = f3 ? `fillPattern` : `fill`, m3 = l3.TRIANGLES);
        let S3 = d3.constantOr(null);
        for (let d4 of i3) {
          let i4 = n4.getTile(d4);
          if (f3 && !i4.patternsLoaded()) continue;
          let C3 = i4.getBucket(r3);
          if (!C3) continue;
          let w3 = C3.programConfigurations.get(r3.id), T3 = e6.useProgram(h3, w3), E3 = e6.style.map.terrain && e6.style.map.terrain.getTerrainData(d4);
          f3 && (e6.context.activeTexture.set(l3.TEXTURE0), i4.imageAtlasTexture.bind(l3.LINEAR, l3.CLAMP_TO_EDGE), w3.updatePaintBuffers(p3)), xi(w3, u3, S3, i4, r3);
          let D3 = y3.getProjectionData({ overscaledTileID: d4, applyGlobeMatrix: !c3, applyTerrainMatrix: true }), O3 = t4.aH(y3, i4, b3, x3);
          if (s3) {
            _3 = C3.indexBuffer2, v3 = C3.segments2;
            let t5 = [l3.drawingBufferWidth, l3.drawingBufferHeight];
            g3 = h3 === `fillOutlinePattern` && f3 ? Un(e6, p3, i4, t5, O3) : Hn(t5, O3);
          } else _3 = C3.indexBuffer, v3 = C3.segments, g3 = f3 ? Vn(e6, p3, i4, O3) : { u_fill_translate: O3 };
          let k3 = e6.stencilModeForClipping(d4);
          T3.draw(e6.context, m3, a3, k3, o3, q2.backCCW, g3, E3, D3, r3.id, C3.layoutVertexBuffer, _3, v3, r3.paint, e6.transform.zoom, w3);
        }
      }
      function Ci(e6, n4, r3, i3, a3, o3, s3, c3) {
        let l3 = e6.context, u3 = l3.gl, d3 = `fill-extrusion-pattern`, f3 = r3.paint.get(d3), p3 = f3.constantOr(1), m3 = r3.getCrossfadeParameters(), h3 = r3.paint.get(`fill-extrusion-opacity`), g3 = f3.constantOr(null), _3 = e6.transform;
        for (let f4 of i3) {
          let i4 = n4.getTile(f4), v3 = i4.getBucket(r3);
          if (!v3) continue;
          let y3 = e6.style.map.terrain && e6.style.map.terrain.getTerrainData(f4), b3 = v3.programConfigurations.get(r3.id), x3 = e6.useProgram(p3 ? `fillExtrusionPattern` : `fillExtrusion`, b3);
          p3 && (e6.context.activeTexture.set(u3.TEXTURE0), i4.imageAtlasTexture.bind(u3.LINEAR, u3.CLAMP_TO_EDGE), b3.updatePaintBuffers(m3));
          let S3 = _3.getProjectionData({ overscaledTileID: f4, applyGlobeMatrix: !c3, applyTerrainMatrix: true });
          xi(b3, d3, g3, i4, r3);
          let C3 = t4.aH(_3, i4, r3.paint.get(`fill-extrusion-translate`), r3.paint.get(`fill-extrusion-translate-anchor`)), w3 = r3.paint.get(`fill-extrusion-vertical-gradient`), T3 = p3 ? Bn(e6, w3, h3, C3, f4, m3, i4) : zn(e6, w3, h3, C3);
          x3.draw(l3, l3.gl.TRIANGLES, a3, o3, s3, q2.backCCW, T3, y3, S3, r3.id, v3.layoutVertexBuffer, v3.indexBuffer, v3.segments, r3.paint, e6.transform.zoom, b3, e6.style.map.terrain && v3.centroidVertexBuffer);
        }
      }
      function wi(e6, t5, n4, r3, i3, a3, o3, s3, c3) {
        var _a3;
        let l3 = e6.style.projection, u3 = e6.context, d3 = e6.transform, f3 = u3.gl, p3 = [`#define NUM_ILLUMINATION_SOURCES ${n4.paint.get(`hillshade-highlight-color`).values.length}`], m3 = e6.useProgram(`hillshade`, null, false, p3), h3 = !e6.options.moving;
        for (let p4 of r3) {
          let r4 = t5.getTile(p4), g3 = r4.fbo;
          if (!g3) continue;
          let _3 = l3.getMeshFromTileID(u3, p4.canonical, s3, true, `raster`), v3 = (_a3 = e6.style.map.terrain) == null ? void 0 : _a3.getTerrainData(p4);
          u3.activeTexture.set(f3.TEXTURE0), f3.bindTexture(f3.TEXTURE_2D, g3.colorAttachment.get());
          let y3 = d3.getProjectionData({ overscaledTileID: p4, aligned: h3, applyGlobeMatrix: !c3, applyTerrainMatrix: true });
          m3.draw(u3, f3.TRIANGLES, a3, i3[p4.overscaledZ], o3, q2.backCCW, Xn(e6, r4, n4), v3, y3, n4.id, _3.vertexBuffer, _3.indexBuffer, _3.segments);
        }
      }
      function Ti(e6, n4, r3, i3, a3, o3, s3, c3, l3) {
        var _a3;
        let u3 = e6.style.projection, d3 = e6.context, f3 = e6.transform, p3 = d3.gl, m3 = e6.useProgram(`colorRelief`), h3 = !e6.options.moving, g3 = true, _3 = 0;
        for (let v3 of i3) {
          let i4 = n4.getTile(v3), y3 = i4.dem;
          if (g3) {
            let e7 = p3.getParameter(p3.MAX_TEXTURE_SIZE), { elevationTexture: t5, colorTexture: n5 } = r3.getColorRampTextures(d3, e7, y3.getUnpackVector());
            d3.activeTexture.set(p3.TEXTURE1), t5.bind(p3.NEAREST, p3.CLAMP_TO_EDGE), d3.activeTexture.set(p3.TEXTURE4), n5.bind(p3.LINEAR, p3.CLAMP_TO_EDGE), g3 = false, _3 = t5.size[0];
          }
          if (!y3 || !y3.data) continue;
          let b3 = y3.stride, x3 = y3.getPixels();
          if (d3.activeTexture.set(p3.TEXTURE0), d3.pixelStoreUnpackPremultiplyAlpha.set(false), i4.demTexture = i4.demTexture || e6.getTileTexture(b3), i4.demTexture) {
            let e7 = i4.demTexture;
            e7.update(x3, { premultiply: false }), e7.bind(p3.LINEAR, p3.CLAMP_TO_EDGE);
          } else i4.demTexture = new t4.T(d3, x3, p3.RGBA, { premultiply: false }), i4.demTexture.bind(p3.LINEAR, p3.CLAMP_TO_EDGE);
          let S3 = u3.getMeshFromTileID(d3, v3.canonical, c3, true, `raster`), C3 = (_a3 = e6.style.map.terrain) == null ? void 0 : _a3.getTerrainData(v3), w3 = f3.getProjectionData({ overscaledTileID: v3, aligned: h3, applyGlobeMatrix: !l3, applyTerrainMatrix: true });
          m3.draw(d3, p3.TRIANGLES, o3, a3[v3.overscaledZ], s3, q2.backCCW, $n(r3, i4.dem, _3), C3, w3, r3.id, S3.vertexBuffer, S3.indexBuffer, S3.segments);
        }
      }
      let Ei = [new t4.P(0, 0), new t4.P(t4.a3, 0), new t4.P(t4.a3, t4.a3), new t4.P(0, t4.a3)];
      function Di(e6, t5, n4, r3, i3, a3, o3, s3, c3 = false, l3 = false) {
        let u3 = r3[r3.length - 1].overscaledZ, d3 = e6.context, f3 = d3.gl, p3 = e6.useProgram(`raster`), m3 = e6.transform, h3 = e6.style.projection, g3 = e6.colorModeForRenderPass(), _3 = !e6.options.moving, v3 = n4.paint.get(`raster-opacity`), y3 = n4.paint.get(`raster-resampling`), b3 = n4.paint.get(`raster-fade-duration`), x3 = !!e6.style.map.terrain;
        for (let S3 of r3) {
          let r4 = e6.getDepthModeForSublayer(S3.overscaledZ - u3, v3 === 1 ? J2.ReadWrite : J2.ReadOnly, f3.LESS), C3 = t5.getTile(S3), w3 = y3 === `nearest` ? f3.NEAREST : f3.LINEAR;
          d3.activeTexture.set(f3.TEXTURE0), C3.texture.bind(w3, f3.CLAMP_TO_EDGE, f3.LINEAR_MIPMAP_NEAREST), d3.activeTexture.set(f3.TEXTURE1);
          let { parentTile: T3, parentScaleBy: E3, parentTopLeft: D3, fadeValues: O3 } = Oi(C3, t5, b3, x3);
          C3.fadeOpacity = O3.tileOpacity, T3 ? (T3.fadeOpacity = O3.parentTileOpacity, T3.texture.bind(w3, f3.CLAMP_TO_EDGE, f3.LINEAR_MIPMAP_NEAREST)) : C3.texture.bind(w3, f3.CLAMP_TO_EDGE, f3.LINEAR_MIPMAP_NEAREST), C3.texture.useMipmap && d3.extTextureFilterAnisotropic && e6.transform.pitch > 20 && f3.texParameterf(f3.TEXTURE_2D, d3.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, d3.extTextureFilterAnisotropicMax);
          let k3 = e6.style.map.terrain && e6.style.map.terrain.getTerrainData(S3), A3 = m3.getProjectionData({ overscaledTileID: S3, aligned: _3, applyGlobeMatrix: !l3, applyTerrainMatrix: true }), ee3 = sr(D3, E3, O3.fadeMix, n4, s3), j3 = h3.getMeshFromTileID(d3, S3.canonical, a3, o3, `raster`);
          p3.draw(d3, f3.TRIANGLES, r4, i3 ? i3[S3.overscaledZ] : Qt2.disabled, g3, c3 ? q2.frontCCW : q2.backCCW, ee3, k3, A3, n4.id, j3.vertexBuffer, j3.indexBuffer, j3.segments);
        }
      }
      function Oi(e6, n4, r3, i3) {
        let a3 = { parentTile: null, parentScaleBy: 1, parentTopLeft: [0, 0], fadeValues: { tileOpacity: 1, parentTileOpacity: 1, fadeMix: { opacity: 1, mix: 0 } } };
        if (r3 === 0 || i3) return a3;
        if (e6.fadingParentID) {
          let i4 = n4.getLoadedTile(e6.fadingParentID);
          if (!i4) return a3;
          let o3 = 2 ** (i4.tileID.overscaledZ - e6.tileID.overscaledZ);
          return { parentTile: i4, parentScaleBy: o3, parentTopLeft: [e6.tileID.canonical.x * o3 % 1, e6.tileID.canonical.y * o3 % 1], fadeValues: (function(e7, n5, r4) {
            let i5 = c2(), a4 = (i5 - n5.timeAdded) / r4, o4 = e7.fadingDirection === Ee2.Incoming, s3 = t4.ai((i5 - e7.timeAdded) / r4, 0, 1), l3 = t4.ai(1 - a4, 0, 1), u3 = o4 ? s3 : l3;
            return { tileOpacity: u3, parentTileOpacity: o4 ? l3 : s3, fadeMix: { opacity: 1, mix: 1 - u3 } };
          })(e6, i4, r3) };
        }
        return e6.selfFading ? { parentTile: null, parentScaleBy: 1, parentTopLeft: [0, 0], fadeValues: (function(e7, n5) {
          let r4 = (c2() - e7.timeAdded) / n5, i4 = t4.ai(r4, 0, 1);
          return { tileOpacity: i4, fadeMix: { opacity: i4, mix: 0 } };
        })(e6, r3) } : a3;
      }
      let ki = new t4.bi(1, 0, 0, 1), Ai = new t4.bi(0, 1, 0, 1), ji = new t4.bi(0, 0, 1, 1), Mi = new t4.bi(1, 0, 1, 1), Ni = new t4.bi(0, 1, 1, 1);
      function Pi(e6, t5, n4, r3) {
        Ii(e6, 0, t5 + n4 / 2, e6.transform.width, n4, r3);
      }
      function Fi(e6, t5, n4, r3) {
        Ii(e6, t5 - n4 / 2, 0, n4, e6.transform.height, r3);
      }
      function Ii(e6, t5, n4, r3, i3, a3) {
        let o3 = e6.context, s3 = o3.gl;
        s3.enable(s3.SCISSOR_TEST), s3.scissor(t5 * e6.pixelRatio, n4 * e6.pixelRatio, r3 * e6.pixelRatio, i3 * e6.pixelRatio), o3.clear({ color: a3 }), s3.disable(s3.SCISSOR_TEST);
      }
      function Li(e6, n4, r3) {
        let i3 = e6.context, a3 = i3.gl, o3 = e6.useProgram(`debug`), s3 = J2.disabled, c3 = Qt2.disabled, l3 = e6.colorModeForRenderPass(), u3 = `$debug`, d3 = e6.style.map.terrain && e6.style.map.terrain.getTerrainData(r3);
        i3.activeTexture.set(a3.TEXTURE0);
        let f3 = n4.getTileByID(r3.key).latestRawTileData, p3 = Math.floor((f3 && f3.byteLength || 0) / 1024), m3 = n4.getTile(r3).tileSize, h3 = 512 / Math.min(m3, 512) * (r3.overscaledZ / e6.transform.zoom) * 0.5, g3 = r3.canonical.toString();
        r3.overscaledZ !== r3.canonical.z && (g3 += ` => ${r3.overscaledZ}`), (function(e7, t5) {
          e7.initDebugOverlayCanvas();
          let n5 = e7.debugOverlayCanvas, r4 = e7.context.gl, i4 = e7.debugOverlayCanvas.getContext(`2d`);
          i4.clearRect(0, 0, n5.width, n5.height), i4.shadowColor = `white`, i4.shadowBlur = 2, i4.lineWidth = 1.5, i4.strokeStyle = `white`, i4.textBaseline = `top`, i4.font = `bold 36px Open Sans, sans-serif`, i4.fillText(t5, 5, 5), i4.strokeText(t5, 5, 5), e7.debugOverlayTexture.update(n5), e7.debugOverlayTexture.bind(r4.LINEAR, r4.CLAMP_TO_EDGE);
        })(e6, `${g3} ${p3}kB`);
        let _3 = e6.transform.getProjectionData({ overscaledTileID: r3, applyGlobeMatrix: true, applyTerrainMatrix: true });
        o3.draw(i3, a3.TRIANGLES, s3, c3, Yt2.alphaBlended, q2.disabled, qn(t4.bi.transparent, h3), null, _3, u3, e6.debugBuffer, e6.quadTriangleIndexBuffer, e6.debugSegments), o3.draw(i3, a3.LINE_STRIP, s3, c3, l3, q2.disabled, qn(t4.bi.red), d3, _3, u3, e6.debugBuffer, e6.tileBorderIndexBuffer, e6.debugSegments);
      }
      function Ri(e6, t5, n4, r3) {
        let { isRenderingGlobe: i3 } = r3, a3 = e6.context, o3 = a3.gl, s3 = e6.transform, c3 = e6.colorModeForRenderPass(), l3 = e6.getDepthModeFor3D(), u3 = e6.useProgram(`terrain`);
        a3.bindFramebuffer.set(null), a3.viewport.set([0, 0, e6.width, e6.height]);
        for (let r4 of n4) {
          let n5 = t5.getTerrainMesh(r4.tileID), d3 = e6.renderToTexture.getTexture(r4), f3 = t5.getTerrainData(r4.tileID);
          a3.activeTexture.set(o3.TEXTURE0), o3.bindTexture(o3.TEXTURE_2D, d3.texture);
          let p3 = Pn(t5.getMeshFrameDelta(s3.zoom), s3.calculateFogMatrix(r4.tileID.toUnwrapped()), e6.style.sky, s3.pitch, i3), m3 = s3.getProjectionData({ overscaledTileID: r4.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
          u3.draw(a3, o3.TRIANGLES, l3, Qt2.disabled, c3, q2.backCCW, p3, f3, m3, `terrain`, n5.vertexBuffer, n5.indexBuffer, n5.segments);
        }
      }
      function zi(e6, n4) {
        if (!n4.mesh) {
          let r3 = new t4.aP();
          r3.emplaceBack(-1, -1), r3.emplaceBack(1, -1), r3.emplaceBack(1, 1), r3.emplaceBack(-1, 1);
          let i3 = new t4.aR();
          i3.emplaceBack(0, 1, 2), i3.emplaceBack(0, 2, 3), n4.mesh = new K2(e6.createVertexBuffer(r3, Nt2.members), e6.createIndexBuffer(i3), t4.aQ.simpleSegment(0, 0, r3.length, i3.length));
        }
        return n4.mesh;
      }
      class Bi {
        constructor(e6, n4) {
          this.context = new ni(e6), this.transform = n4, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: t4.am(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = He2.maxUnderzooming + He2.maxOverzooming + 1, this.depthEpsilon = 1 / 2 ** 16, this.crossTileSymbolIndex = new At2();
        }
        resize(e6, t5, n4) {
          if (this.width = Math.floor(e6 * n4), this.height = Math.floor(t5 * n4), this.pixelRatio = n4, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (let e7 of this.style._order) this.style._layers[e7].resize();
        }
        setup() {
          let e6 = this.context, n4 = new t4.aP();
          n4.emplaceBack(0, 0), n4.emplaceBack(t4.a3, 0), n4.emplaceBack(0, t4.a3), n4.emplaceBack(t4.a3, t4.a3), this.tileExtentBuffer = e6.createVertexBuffer(n4, Nt2.members), this.tileExtentSegments = t4.aQ.simpleSegment(0, 0, 4, 2);
          let r3 = new t4.aP();
          r3.emplaceBack(0, 0), r3.emplaceBack(t4.a3, 0), r3.emplaceBack(0, t4.a3), r3.emplaceBack(t4.a3, t4.a3), this.debugBuffer = e6.createVertexBuffer(r3, Nt2.members), this.debugSegments = t4.aQ.simpleSegment(0, 0, 4, 5);
          let i3 = new t4.ca();
          i3.emplaceBack(0, 0, 0, 0), i3.emplaceBack(t4.a3, 0, t4.a3, 0), i3.emplaceBack(0, t4.a3, 0, t4.a3), i3.emplaceBack(t4.a3, t4.a3, t4.a3, t4.a3), this.rasterBoundsBuffer = e6.createVertexBuffer(i3, Mn.members), this.rasterBoundsSegments = t4.aQ.simpleSegment(0, 0, 4, 2);
          let a3 = new t4.aP();
          a3.emplaceBack(0, 0), a3.emplaceBack(t4.a3, 0), a3.emplaceBack(0, t4.a3), a3.emplaceBack(t4.a3, t4.a3), this.rasterBoundsBufferPosOnly = e6.createVertexBuffer(a3, Nt2.members), this.rasterBoundsSegmentsPosOnly = t4.aQ.simpleSegment(0, 0, 4, 5);
          let o3 = new t4.aP();
          o3.emplaceBack(0, 0), o3.emplaceBack(1, 0), o3.emplaceBack(0, 1), o3.emplaceBack(1, 1), this.viewportBuffer = e6.createVertexBuffer(o3, Nt2.members), this.viewportSegments = t4.aQ.simpleSegment(0, 0, 4, 2);
          let s3 = new t4.cb();
          s3.emplaceBack(0), s3.emplaceBack(1), s3.emplaceBack(3), s3.emplaceBack(2), s3.emplaceBack(0), this.tileBorderIndexBuffer = e6.createIndexBuffer(s3);
          let c3 = new t4.aR();
          c3.emplaceBack(1, 0, 2), c3.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e6.createIndexBuffer(c3);
          let l3 = this.context.gl;
          this.stencilClearMode = new Qt2({ func: l3.ALWAYS, mask: 0 }, 0, 255, l3.ZERO, l3.ZERO, l3.ZERO), this.tileExtentMesh = new K2(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
        }
        clearStencil() {
          let e6 = this.context, n4 = e6.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0;
          let r3 = t4.M();
          t4.c0(r3, 0, this.width, this.height, 0, 0, 1), t4.O(r3, r3, [n4.drawingBufferWidth, n4.drawingBufferHeight, 0]);
          let i3 = { mainMatrix: r3, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: r3 };
          this.useProgram(`clippingMask`, null, true).draw(e6, n4.TRIANGLES, J2.disabled, this.stencilClearMode, Yt2.disabled, q2.disabled, null, null, i3, `$clipping`, this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        _renderTileClippingMasks(e6, t5, n4) {
          if (this.currentStencilSource === e6.source || !e6.isTileClipped() || !t5 || !t5.length) return;
          this.currentStencilSource = e6.source, this.nextStencilID + t5.length > 256 && this.clearStencil();
          let r3 = this.context;
          r3.setColorMode(Yt2.disabled), r3.setDepthMode(J2.disabled);
          let i3 = {};
          for (let e7 of t5) i3[e7.key] = this.nextStencilID++;
          this._renderTileMasks(i3, t5, n4, true), this._renderTileMasks(i3, t5, n4, false), this._tileClippingMaskIDs = i3;
        }
        _renderTileMasks(e6, t5, n4, r3) {
          let i3 = this.context, a3 = i3.gl, o3 = this.style.projection, s3 = this.transform, c3 = this.useProgram(`clippingMask`);
          for (let l3 of t5) {
            let t6 = e6[l3.key], u3 = this.style.map.terrain && this.style.map.terrain.getTerrainData(l3), d3 = o3.getMeshFromTileID(this.context, l3.canonical, r3, true, `stencil`), f3 = s3.getProjectionData({ overscaledTileID: l3, applyGlobeMatrix: !n4, applyTerrainMatrix: true });
            c3.draw(i3, a3.TRIANGLES, J2.disabled, new Qt2({ func: a3.ALWAYS, mask: 0 }, t6, 255, a3.KEEP, a3.KEEP, a3.REPLACE), Yt2.disabled, n4 ? q2.disabled : q2.backCCW, null, u3, f3, `$clipping`, d3.vertexBuffer, d3.indexBuffer, d3.segments);
          }
        }
        _renderTilesDepthBuffer() {
          let e6 = this.context, t5 = e6.gl, n4 = this.style.projection, r3 = this.transform, i3 = this.useProgram(`depth`), a3 = this.getDepthModeFor3D(), o3 = Be2(r3, { tileSize: r3.tileSize });
          for (let s3 of o3) {
            let o4 = this.style.map.terrain && this.style.map.terrain.getTerrainData(s3), c3 = n4.getMeshFromTileID(this.context, s3.canonical, true, true, `raster`), l3 = r3.getProjectionData({ overscaledTileID: s3, applyGlobeMatrix: true, applyTerrainMatrix: true });
            i3.draw(e6, t5.TRIANGLES, a3, Qt2.disabled, Yt2.disabled, q2.backCCW, null, o4, l3, `$clipping`, c3.vertexBuffer, c3.indexBuffer, c3.segments);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          let e6 = this.nextStencilID++, t5 = this.context.gl;
          return new Qt2({ func: t5.NOTEQUAL, mask: 255 }, e6, 255, t5.KEEP, t5.KEEP, t5.REPLACE);
        }
        stencilModeForClipping(e6) {
          let t5 = this.context.gl;
          return new Qt2({ func: t5.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e6.key], 0, t5.KEEP, t5.KEEP, t5.REPLACE);
        }
        getStencilConfigForOverlapAndUpdateStencilID(e6) {
          let t5 = this.context.gl, n4 = e6.sort(((e7, t6) => t6.overscaledZ - e7.overscaledZ)), r3 = n4[n4.length - 1].overscaledZ, i3 = n4[0].overscaledZ - r3 + 1;
          if (i3 > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + i3 > 256 && this.clearStencil();
            let e7 = {};
            for (let n5 = 0; n5 < i3; n5++) e7[n5 + r3] = new Qt2({ func: t5.GEQUAL, mask: 255 }, n5 + this.nextStencilID, 255, t5.KEEP, t5.KEEP, t5.REPLACE);
            return this.nextStencilID += i3, [e7, n4];
          }
          return [{ [r3]: Qt2.disabled }, n4];
        }
        stencilConfigForOverlapTwoPass(e6) {
          let t5 = this.context.gl, n4 = e6.sort(((e7, t6) => t6.overscaledZ - e7.overscaledZ)), r3 = n4[n4.length - 1].overscaledZ, i3 = n4[0].overscaledZ - r3 + 1;
          if (this.clearStencil(), i3 > 1) {
            let e7 = {}, a3 = {};
            for (let n5 = 0; n5 < i3; n5++) e7[n5 + r3] = new Qt2({ func: t5.GREATER, mask: 255 }, i3 + 1 + n5, 255, t5.KEEP, t5.KEEP, t5.REPLACE), a3[n5 + r3] = new Qt2({ func: t5.GREATER, mask: 255 }, 1 + n5, 255, t5.KEEP, t5.KEEP, t5.REPLACE);
            return this.nextStencilID = 2 * i3 + 1, [e7, a3, n4];
          }
          return this.nextStencilID = 3, [{ [r3]: new Qt2({ func: t5.GREATER, mask: 255 }, 2, 255, t5.KEEP, t5.KEEP, t5.REPLACE) }, { [r3]: new Qt2({ func: t5.GREATER, mask: 255 }, 1, 255, t5.KEEP, t5.KEEP, t5.REPLACE) }, n4];
        }
        colorModeForRenderPass() {
          let e6 = this.context.gl;
          if (this._showOverdrawInspector) {
            let n4 = 1 / 8;
            return new Yt2([e6.CONSTANT_COLOR, e6.ONE], new t4.bi(n4, n4, n4, 0), [true, true, true, true]);
          }
          return this.renderPass === `opaque` ? Yt2.unblended : Yt2.alphaBlended;
        }
        getDepthModeForSublayer(e6, t5, n4) {
          if (!this.opaquePassEnabledForLayer()) return J2.disabled;
          let r3 = 1 - ((1 + this.currentLayer) * this.numSublayers + e6) * this.depthEpsilon;
          return new J2(n4 || this.context.gl.LEQUAL, t5, [r3, r3]);
        }
        getDepthModeFor3D() {
          return new J2(this.context.gl.LEQUAL, J2.ReadWrite, this.depthRangeFor3D);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(e6, n4) {
          var _a3;
          var r3;
          this.style = e6, this.options = n4, this.lineAtlas = e6.lineAtlas, this.imageManager = e6.imageManager, this.glyphManager = e6.glyphManager, this.symbolFadeChange = e6.placement.symbolFadeChange(c2()), this.imageManager.beginFrame();
          let i3 = this.style._order, a3 = this.style.tileManagers, o3 = {}, s3 = {}, l3 = {}, u3 = { isRenderingToTexture: false, isRenderingGlobe: ((_a3 = e6.projection) == null ? void 0 : _a3.transitionState) > 0 };
          for (let e7 in a3) {
            let t5 = a3[e7];
            t5.used && t5.prepare(this.context), o3[e7] = t5.getVisibleCoordinates(false), s3[e7] = o3[e7].slice().reverse(), l3[e7] = t5.getVisibleCoordinates(true).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let e7 = 0; e7 < i3.length; e7++) if (this.style._layers[i3[e7]].is3D()) {
            this.opaquePassCutoff = e7;
            break;
          }
          this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = `offscreen`;
          for (let e7 of i3) {
            let t5 = this.style._layers[e7];
            if (!t5.hasOffscreenPass() || t5.isHidden(this.transform.zoom)) continue;
            let n5 = s3[t5.source];
            (t5.type === `custom` || n5.length) && this.renderLayer(this, a3[t5.source], t5, n5, u3);
          }
          if ((r3 = this.style.projection) == null || r3.updateGPUdependent({ context: this.context, useProgram: (e7) => this.useProgram(e7) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: n4.showOverdrawInspector ? t4.bi.black : t4.bi.transparent, depth: 1 }), this.clearStencil(), this.style.sky && (function(e7, t5) {
            let n5 = e7.context, r4 = n5.gl, i4 = ((e8, t6, n6) => {
              let r5 = Math.cos(t6.rollInRadians), i5 = Math.sin(t6.rollInRadians), a5 = Ne2(t6), o5 = t6.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }).projectionTransition;
              return { u_sky_color: e8.properties.get(`sky-color`), u_horizon_color: e8.properties.get(`horizon-color`), u_horizon: [(t6.width / 2 - a5 * i5) * n6, (t6.height / 2 + a5 * r5) * n6], u_horizon_normal: [-i5, r5], u_sky_horizon_blend: e8.properties.get(`sky-horizon-blend`) * t6.height / 2 * n6, u_sky_blend: o5 };
            })(t5, e7.style.map.transform, e7.pixelRatio), a4 = new J2(r4.LEQUAL, J2.ReadWrite, [0, 1]), o4 = Qt2.disabled, s4 = e7.colorModeForRenderPass(), c3 = e7.useProgram(`sky`), l4 = zi(n5, t5);
            c3.draw(n5, r4.TRIANGLES, a4, o4, s4, q2.disabled, i4, null, void 0, `sky`, l4.vertexBuffer, l4.indexBuffer, l4.segments);
          })(this, this.style.sky), this._showOverdrawInspector = n4.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e6._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = `opaque`, this.currentLayer = i3.length - 1; this.currentLayer >= 0; this.currentLayer--) {
            let e7 = this.style._layers[i3[this.currentLayer]], t5 = a3[e7.source], n5 = o3[e7.source];
            this._renderTileClippingMasks(e7, n5, false), this.renderLayer(this, t5, e7, n5, u3);
          }
          this.renderPass = `translucent`;
          let d3 = false;
          for (this.currentLayer = 0; this.currentLayer < i3.length; this.currentLayer++) {
            let e7 = this.style._layers[i3[this.currentLayer]], t5 = a3[e7.source];
            if (this.renderToTexture && this.renderToTexture.renderLayer(e7, u3)) continue;
            this.opaquePassEnabledForLayer() || d3 || (d3 = true, u3.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
            let n5 = (e7.type === `symbol` ? l3 : s3)[e7.source];
            this._renderTileClippingMasks(e7, o3[e7.source], !!this.renderToTexture), this.renderLayer(this, t5, e7, n5, u3);
          }
          if (u3.isRenderingGlobe && (function(e7, n5, r4) {
            let i4 = e7.context, a4 = i4.gl, o4 = e7.useProgram(`atmosphere`), s4 = new J2(a4.LEQUAL, J2.ReadOnly, [0, 1]), c3 = e7.transform, l4 = (function(e8, n6) {
              let r5 = e8.properties.get(`position`), i5 = [-r5.x, -r5.y, -r5.z], a5 = t4.am(new Float64Array(16));
              return e8.properties.get(`anchor`) === `map` && (t4.b9(a5, a5, n6.rollInRadians), t4.ba(a5, a5, -n6.pitchInRadians), t4.b9(a5, a5, n6.bearingInRadians), t4.ba(a5, a5, n6.center.lat * Math.PI / 180), t4.bC(a5, a5, -n6.center.lng * Math.PI / 180)), t4.c9(i5, i5, a5), i5;
            })(r4, e7.transform), u4 = c3.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }), d4 = n5.properties.get(`atmosphere-blend`) * u4.projectionTransition;
            if (d4 === 0) return;
            let f3 = fn2(c3.worldSize, c3.center.lat), p3 = c3.inverseProjectionMatrix, m3 = new Float64Array(4);
            m3[3] = 1, t4.aA(m3, m3, c3.modelViewProjectionMatrix), m3[0] /= m3[3], m3[1] /= m3[3], m3[2] /= m3[3], m3[3] = 1, t4.aA(m3, m3, p3), m3[0] /= m3[3], m3[1] /= m3[3], m3[2] /= m3[3], m3[3] = 1;
            let h3 = /* @__PURE__ */ ((e8, t5, n6, r5, i5) => ({ u_sun_pos: e8, u_atmosphere_blend: t5, u_globe_position: n6, u_globe_radius: r5, u_inv_proj_matrix: i5 }))(l4, d4, [m3[0], m3[1], m3[2]], f3, p3), g3 = zi(i4, n5);
            o4.draw(i4, a4.TRIANGLES, s4, Qt2.disabled, Yt2.alphaBlended, q2.disabled, h3, null, null, `atmosphere`, g3.vertexBuffer, g3.indexBuffer, g3.segments);
          })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
            let e7 = (function(e8, t5) {
              let n5 = null, r4 = Object.values(e8._layers).flatMap(((n6) => n6.source && !n6.isHidden(t5) ? [e8.tileManagers[n6.source]] : [])), i4 = r4.filter(((e9) => e9.getSource().type === `vector`)), a4 = r4.filter(((e9) => e9.getSource().type !== `vector`)), o4 = (e9) => {
                (!n5 || n5.getSource().maxzoom < e9.getSource().maxzoom) && (n5 = e9);
              };
              return i4.forEach(((e9) => o4(e9))), n5 || a4.forEach(((e9) => o4(e9))), n5;
            })(this.style, this.transform.zoom);
            e7 && (function(e8, t5, n5) {
              for (let r4 = 0; r4 < n5.length; r4++) Li(e8, t5, n5[r4]);
            })(this, e7, e7.getVisibleCoordinates());
          }
          this.options.showPadding && (function(e7) {
            let t5 = e7.transform.padding;
            Pi(e7, e7.transform.height - (t5.top || 0), 3, ki), Pi(e7, t5.bottom || 0, 3, Ai), Fi(e7, t5.left || 0, 3, ji), Fi(e7, e7.transform.width - (t5.right || 0), 3, Mi);
            let n5 = e7.transform.centerPoint;
            (function(e8, t6, n6, r4) {
              Ii(e8, t6 - 1, n6 - 10, 2, 20, r4), Ii(e8, t6 - 10, n6 - 1, 20, 2, r4);
            })(e7, n5.x, e7.transform.height - n5.y, Ni);
          })(this), this.context.setDefault();
        }
        maybeDrawDepthAndCoords(e6) {
          if (!this.style || !this.style.map || !this.style.map.terrain) return;
          let n4 = this.terrainFacilitator.matrix, r3 = this.transform.modelViewProjectionMatrix, i3 = this.terrainFacilitator.dirty;
          i3 || (i3 = e6 ? !t4.cc(n4, r3) : !t4.cd(n4, r3)), i3 || (i3 = this.style.map.terrain.tileManager.anyTilesAfterTime(this.terrainFacilitator.renderTime)), i3 && (t4.ce(n4, r3), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, (function(e7, n5) {
            let r4 = e7.context, i4 = r4.gl, a3 = e7.transform, o3 = Yt2.unblended, s3 = new J2(i4.LEQUAL, J2.ReadWrite, [0, 1]), c3 = n5.tileManager.getRenderableTiles(), l3 = e7.useProgram(`terrainDepth`);
            r4.bindFramebuffer.set(n5.getFramebuffer(`depth`).framebuffer), r4.viewport.set([0, 0, e7.width / devicePixelRatio, e7.height / devicePixelRatio]), r4.clear({ color: t4.bi.transparent, depth: 1 });
            for (let e8 of c3) {
              let t5 = n5.getTerrainMesh(e8.tileID), c4 = n5.getTerrainData(e8.tileID), u3 = a3.getProjectionData({ overscaledTileID: e8.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true }), d3 = { u_ele_delta: n5.getMeshFrameDelta(a3.zoom) };
              l3.draw(r4, i4.TRIANGLES, s3, Qt2.disabled, o3, q2.backCCW, d3, c4, u3, `terrain`, t5.vertexBuffer, t5.indexBuffer, t5.segments);
            }
            r4.bindFramebuffer.set(null), r4.viewport.set([0, 0, e7.width, e7.height]);
          })(this, this.style.map.terrain), (function(e7, n5) {
            let r4 = e7.context, i4 = r4.gl, a3 = e7.transform, o3 = Yt2.unblended, s3 = new J2(i4.LEQUAL, J2.ReadWrite, [0, 1]), c3 = n5.getCoordsTexture(), l3 = n5.tileManager.getRenderableTiles(), u3 = e7.useProgram(`terrainCoords`);
            r4.bindFramebuffer.set(n5.getFramebuffer(`coords`).framebuffer), r4.viewport.set([0, 0, e7.width / devicePixelRatio, e7.height / devicePixelRatio]), r4.clear({ color: t4.bi.transparent, depth: 1 }), n5.coordsIndex = [];
            for (let e8 of l3) {
              let t5 = n5.getTerrainMesh(e8.tileID), l4 = n5.getTerrainData(e8.tileID);
              r4.activeTexture.set(i4.TEXTURE0), i4.bindTexture(i4.TEXTURE_2D, c3.texture);
              let d3 = { u_terrain_coords_id: (255 - n5.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: n5.getMeshFrameDelta(a3.zoom) }, f3 = a3.getProjectionData({ overscaledTileID: e8.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
              u3.draw(r4, i4.TRIANGLES, s3, Qt2.disabled, o3, q2.backCCW, d3, l4, f3, `terrain`, t5.vertexBuffer, t5.indexBuffer, t5.segments), n5.coordsIndex.push(e8.tileID.key);
            }
            r4.bindFramebuffer.set(null), r4.viewport.set([0, 0, e7.width, e7.height]);
          })(this, this.style.map.terrain));
        }
        renderLayer(e6, n4, r3, i3, a3) {
          r3.isHidden(this.transform.zoom) || (r3.type === `background` || r3.type === `custom` || (i3 || []).length) && (this.id = r3.id, t4.cf(r3) ? (function(e7, n5, r4, i4, a4, o3) {
            if (e7.renderPass !== `translucent`) return;
            let { isRenderingToTexture: s3 } = o3, c3 = Qt2.disabled, l3 = e7.colorModeForRenderPass();
            (r4._unevaluatedLayout.hasValue(`text-variable-anchor`) || r4._unevaluatedLayout.hasValue(`text-variable-anchor-offset`)) && (function(e8, n6, r5, i5, a5, o4, s4, c4, l4) {
              let u3 = n6.transform, d3 = n6.style.map.terrain, f3 = a5 === `map`, p3 = o4 === `map`;
              for (let a6 of e8) {
                let e9 = i5.getTile(a6), o5 = e9.getBucket(r5);
                if (!o5 || !o5.text || !o5.text.segments.get().length) continue;
                let m3 = t4.ar(o5.textSizeData, u3.zoom), h3 = t4.aG(e9, 1, n6.transform.zoom), g3 = qe2(f3, n6.transform, h3), _3 = r5.layout.get(`icon-text-fit`) !== `none` && o5.hasIconData();
                if (m3) {
                  let n7 = 2 ** (u3.zoom - e9.tileID.overscaledZ), r6 = d3 ? (e10, t5) => d3.getElevation(a6, e10, t5) : null;
                  ci(o5, f3, p3, l4, u3, g3, n7, m3, _3, t4.aH(u3, e9, s4, c4), a6.toUnwrapped(), r6);
                }
              }
            })(i4, e7, r4, n5, r4.layout.get(`text-rotation-alignment`), r4.layout.get(`text-pitch-alignment`), r4.paint.get(`text-translate`), r4.paint.get(`text-translate-anchor`), a4), r4.paint.get(`icon-opacity`).constantOr(1) !== 0 && ui(e7, n5, r4, i4, false, r4.paint.get(`icon-translate`), r4.paint.get(`icon-translate-anchor`), r4.layout.get(`icon-rotation-alignment`), r4.layout.get(`icon-pitch-alignment`), r4.layout.get(`icon-keep-upright`), c3, l3, s3), r4.paint.get(`text-opacity`).constantOr(1) !== 0 && ui(e7, n5, r4, i4, true, r4.paint.get(`text-translate`), r4.paint.get(`text-translate-anchor`), r4.layout.get(`text-rotation-alignment`), r4.layout.get(`text-pitch-alignment`), r4.layout.get(`text-keep-upright`), c3, l3, s3), n5.map.showCollisionBoxes && (ii(e7, n5, r4, i4, true), ii(e7, n5, r4, i4, false));
          })(e6, n4, r3, i3, this.style.placement.variableOffsets, a3) : t4.cg(r3) ? (function(e7, n5, r4, i4, a4) {
            if (e7.renderPass !== `translucent`) return;
            let { isRenderingToTexture: o3 } = a4, s3 = r4.paint.get(`circle-opacity`), c3 = r4.paint.get(`circle-stroke-width`), l3 = r4.paint.get(`circle-stroke-opacity`), u3 = !r4.layout.get(`circle-sort-key`).isConstant();
            if (s3.constantOr(1) === 0 && (c3.constantOr(1) === 0 || l3.constantOr(1) === 0)) return;
            let d3 = e7.context, f3 = d3.gl, p3 = e7.transform, m3 = e7.getDepthModeForSublayer(0, J2.ReadOnly), h3 = Qt2.disabled, g3 = e7.colorModeForRenderPass(), _3 = [], v3 = p3.getCircleRadiusCorrection();
            for (let a5 = 0; a5 < i4.length; a5++) {
              let s4 = i4[a5], c4 = n5.getTile(s4), l4 = c4.getBucket(r4);
              if (!l4) continue;
              let d4 = r4.paint.get(`circle-translate`), f4 = r4.paint.get(`circle-translate-anchor`), m4 = t4.aH(p3, c4, d4, f4), h4 = l4.programConfigurations.get(r4.id), g4 = e7.useProgram(`circle`, h4), y3 = l4.layoutVertexBuffer, b3 = l4.indexBuffer, x3 = e7.style.map.terrain && e7.style.map.terrain.getTerrainData(s4), S3 = { programConfiguration: h4, program: g4, layoutVertexBuffer: y3, indexBuffer: b3, uniformValues: Wn(e7, c4, r4, m4, v3), terrainData: x3, projectionData: p3.getProjectionData({ overscaledTileID: s4, applyGlobeMatrix: !o3, applyTerrainMatrix: true }) };
              if (u3) {
                let e8 = l4.segments.get();
                for (let n6 of e8) _3.push({ segments: new t4.aQ([n6]), sortKey: n6.sortKey, state: S3 });
              } else _3.push({ segments: l4.segments, sortKey: 0, state: S3 });
            }
            u3 && _3.sort(((e8, t5) => e8.sortKey - t5.sortKey));
            for (let t5 of _3) {
              let { programConfiguration: n6, program: i5, layoutVertexBuffer: a5, indexBuffer: o4, uniformValues: s4, terrainData: c4, projectionData: l4 } = t5.state;
              i5.draw(d3, f3.TRIANGLES, m3, h3, g3, q2.backCCW, s4, c4, l4, r4.id, a5, o4, t5.segments, r4.paint, e7.transform.zoom, n6);
            }
          })(e6, n4, r3, i3, a3) : t4.ch(r3) ? (function(e7, n5, r4, i4, a4) {
            if (r4.paint.get(`heatmap-opacity`) === 0) return;
            let o3 = e7.context, { isRenderingToTexture: s3, isRenderingGlobe: c3 } = a4;
            if (e7.style.map.terrain) {
              for (let t5 of i4) {
                let i5 = n5.getTile(t5);
                n5.hasRenderableParent(t5) || (e7.renderPass === `offscreen` ? fi(e7, i5, r4, t5, c3) : e7.renderPass === `translucent` && pi(e7, r4, t5, s3, c3));
              }
              o3.viewport.set([0, 0, e7.width, e7.height]);
            } else e7.renderPass === `offscreen` ? (function(e8, n6, r5, i5) {
              let a5 = e8.context, o4 = a5.gl, s4 = e8.transform, c4 = Qt2.disabled, l3 = new Yt2([o4.ONE, o4.ONE], t4.bi.transparent, [true, true, true, true]);
              (function(e9, n7, r6) {
                let i6 = e9.gl;
                e9.activeTexture.set(i6.TEXTURE1), e9.viewport.set([0, 0, n7.width / 4, n7.height / 4]);
                let a6 = r6.heatmapFbos.get(t4.c6);
                a6 ? (i6.bindTexture(i6.TEXTURE_2D, a6.colorAttachment.get()), e9.bindFramebuffer.set(a6.framebuffer)) : (a6 = mi(e9, n7.width / 4, n7.height / 4), r6.heatmapFbos.set(t4.c6, a6));
              })(a5, e8, r5), a5.clear({ color: t4.bi.transparent });
              for (let t5 = 0; t5 < i5.length; t5++) {
                let u3 = i5[t5];
                if (n6.hasRenderableParent(u3)) continue;
                let d3 = n6.getTile(u3), f3 = d3.getBucket(r5);
                if (!f3) continue;
                let p3 = f3.programConfigurations.get(r5.id), m3 = e8.useProgram(`heatmap`, p3), h3 = s4.getProjectionData({ overscaledTileID: u3, applyGlobeMatrix: true, applyTerrainMatrix: false }), g3 = s4.getCircleRadiusCorrection();
                m3.draw(a5, o4.TRIANGLES, J2.disabled, c4, l3, q2.backCCW, Jn(d3, s4.zoom, r5.paint.get(`heatmap-intensity`), g3), null, h3, r5.id, f3.layoutVertexBuffer, f3.indexBuffer, f3.segments, r5.paint, s4.zoom, p3);
              }
              a5.viewport.set([0, 0, e8.width, e8.height]);
            })(e7, n5, r4, i4) : e7.renderPass === `translucent` && (function(e8, n6) {
              let r5 = e8.context, i5 = r5.gl;
              r5.setColorMode(e8.colorModeForRenderPass());
              let a5 = n6.heatmapFbos.get(t4.c6);
              a5 && (r5.activeTexture.set(i5.TEXTURE0), i5.bindTexture(i5.TEXTURE_2D, a5.colorAttachment.get()), r5.activeTexture.set(i5.TEXTURE1), hi(r5, n6).bind(i5.LINEAR, i5.CLAMP_TO_EDGE), e8.useProgram(`heatmapTexture`).draw(r5, i5.TRIANGLES, J2.disabled, Qt2.disabled, e8.colorModeForRenderPass(), q2.disabled, Yn(e8, n6, 0, 1), null, null, n6.id, e8.viewportBuffer, e8.quadTriangleIndexBuffer, e8.viewportSegments, n6.paint, e8.transform.zoom));
            })(e7, r4);
          })(e6, n4, r3, i3, a3) : t4.ci(r3) ? (function(e7, t5, n5, r4, i4) {
            if (e7.renderPass !== `translucent`) return;
            let { isRenderingToTexture: a4 } = i4, o3 = n5.paint.get(`line-opacity`), s3 = n5.paint.get(`line-width`);
            if (o3.constantOr(1) === 0 || s3.constantOr(1) === 0) return;
            let c3 = e7.getDepthModeForSublayer(0, J2.ReadOnly), l3 = e7.colorModeForRenderPass(), u3 = n5.paint.get(`line-dasharray`), d3 = u3.constantOr(1), f3 = n5.paint.get(`line-pattern`), p3 = f3.constantOr(1), m3 = n5.paint.get(`line-gradient`), h3 = n5.getCrossfadeParameters(), g3;
            g3 = p3 ? `linePattern` : d3 && m3 ? `lineGradientSDF` : d3 ? `lineSDF` : m3 ? `lineGradient` : `line`;
            let _3 = e7.context, v3 = _3.gl, y3 = e7.transform, b3 = true;
            for (let i5 of r4) {
              let r5 = t5.getTile(i5);
              if (p3 && !r5.patternsLoaded()) continue;
              let o4 = r5.getBucket(n5);
              if (!o4) continue;
              let s4 = o4.programConfigurations.get(n5.id), x3 = e7.context.program.get(), S3 = e7.useProgram(g3, s4), C3 = b3 || S3.program !== x3, w3 = e7.style.map.terrain && e7.style.map.terrain.getTerrainData(i5), T3 = f3.constantOr(null), E3 = u3 && u3.constantOr(null);
              if (T3 && r5.imageAtlas) {
                let e8 = r5.imageAtlas, t6 = e8.patternPositions[T3.to.toString()], n6 = e8.patternPositions[T3.from.toString()];
                t6 && n6 && s4.setConstantPatternPositions(t6, n6);
              } else if (E3) {
                let t6 = n5.layout.get(`line-cap`) === `round`, r6 = e7.lineAtlas.getDash(E3.to, t6), i6 = e7.lineAtlas.getDash(E3.from, t6);
                s4.setConstantDashPositions(r6, i6);
              }
              let D3 = y3.getProjectionData({ overscaledTileID: i5, applyGlobeMatrix: !a4, applyTerrainMatrix: true }), O3 = y3.getPixelScale(), k3;
              p3 ? (k3 = nr(e7, r5, n5, O3, h3), _i(_3, v3, r5, s4, h3)) : d3 && m3 ? (k3 = ir(e7, r5, n5, O3, h3, o4.lineClipsArray.length), bi(e7, t5, _3, v3, n5, o4, i5, s4, h3)) : d3 ? (k3 = rr(e7, r5, n5, O3, h3), vi(e7, _3, v3, s4, C3, h3)) : m3 ? (k3 = tr(e7, r5, n5, O3, o4.lineClipsArray.length), yi(e7, t5, _3, v3, n5, o4, i5)) : k3 = er(e7, r5, n5, O3);
              let A3 = e7.stencilModeForClipping(i5);
              S3.draw(_3, v3.TRIANGLES, c3, A3, l3, q2.disabled, k3, w3, D3, n5.id, o4.layoutVertexBuffer, o4.indexBuffer, o4.segments, n5.paint, e7.transform.zoom, s4, o4.layoutVertexBuffer2), b3 = false;
            }
          })(e6, n4, r3, i3, a3) : t4.cj(r3) ? (function(e7, n5, r4, i4, a4) {
            let o3 = r4.paint.get(`fill-color`), s3 = r4.paint.get(`fill-opacity`);
            if (s3.constantOr(1) === 0) return;
            let { isRenderingToTexture: c3 } = a4, l3 = e7.colorModeForRenderPass(), u3 = r4.paint.get(`fill-pattern`), d3 = e7.opaquePassEnabledForLayer() && !u3.constantOr(1) && o3.constantOr(t4.bi.transparent).a === 1 && s3.constantOr(0) === 1 ? `opaque` : `translucent`;
            e7.renderPass === d3 && Si(e7, n5, r4, i4, e7.getDepthModeForSublayer(1, e7.renderPass === `opaque` ? J2.ReadWrite : J2.ReadOnly), l3, false, c3), e7.renderPass === `translucent` && r4.paint.get(`fill-antialias`) && Si(e7, n5, r4, i4, e7.getDepthModeForSublayer(r4.getPaintProperty(`fill-outline-color`) ? 2 : 0, J2.ReadOnly), l3, true, c3);
          })(e6, n4, r3, i3, a3) : t4.ck(r3) ? (function(e7, t5, n5, r4, i4) {
            let a4 = n5.paint.get(`fill-extrusion-opacity`);
            if (a4 === 0) return;
            let { isRenderingToTexture: o3 } = i4;
            if (e7.renderPass === `translucent`) {
              let i5 = new J2(e7.context.gl.LEQUAL, J2.ReadWrite, e7.depthRangeFor3D);
              if (a4 !== 1 || n5.paint.get(`fill-extrusion-pattern`).constantOr(1)) Ci(e7, t5, n5, r4, i5, Qt2.disabled, Yt2.disabled, o3), Ci(e7, t5, n5, r4, i5, e7.stencilModeFor3D(), e7.colorModeForRenderPass(), o3);
              else {
                let a5 = e7.colorModeForRenderPass();
                Ci(e7, t5, n5, r4, i5, Qt2.disabled, a5, o3);
              }
            }
          })(e6, n4, r3, i3, a3) : t4.cl(r3) ? (function(e7, n5, r4, i4, a4) {
            if (e7.renderPass !== `offscreen` && e7.renderPass !== `translucent`) return;
            let { isRenderingToTexture: o3 } = a4, s3 = e7.context, c3 = e7.style.projection.useSubdivision, l3 = e7.getDepthModeForSublayer(0, J2.ReadOnly), u3 = e7.colorModeForRenderPass();
            if (e7.renderPass === `offscreen`) (function(e8, n6, r5, i5, a5, o4, s4) {
              let c4 = e8.context, l4 = c4.gl;
              for (let u4 of r5) {
                let r6 = n6.getTile(u4), d3 = r6.dem;
                if (!d3 || !d3.data || !r6.needsHillshadePrepare) continue;
                let f3 = d3.dim, p3 = d3.stride, m3 = d3.getPixels();
                if (c4.activeTexture.set(l4.TEXTURE1), c4.pixelStoreUnpackPremultiplyAlpha.set(false), r6.demTexture = r6.demTexture || e8.getTileTexture(p3), r6.demTexture) {
                  let e9 = r6.demTexture;
                  e9.update(m3, { premultiply: false }), e9.bind(l4.NEAREST, l4.CLAMP_TO_EDGE);
                } else r6.demTexture = new t4.T(c4, m3, l4.RGBA, { premultiply: false }), r6.demTexture.bind(l4.NEAREST, l4.CLAMP_TO_EDGE);
                c4.activeTexture.set(l4.TEXTURE0);
                let h3 = r6.fbo;
                if (!h3) {
                  let e9 = new t4.T(c4, { width: f3, height: f3, data: null }, l4.RGBA);
                  e9.bind(l4.LINEAR, l4.CLAMP_TO_EDGE), h3 = r6.fbo = c4.createFramebuffer(f3, f3, true, false), h3.colorAttachment.set(e9.texture);
                }
                c4.bindFramebuffer.set(h3.framebuffer), c4.viewport.set([0, 0, f3, f3]), e8.useProgram(`hillshadePrepare`).draw(c4, l4.TRIANGLES, a5, o4, s4, q2.disabled, Zn(r6.tileID, d3), null, null, i5.id, e8.rasterBoundsBuffer, e8.quadTriangleIndexBuffer, e8.rasterBoundsSegments), r6.needsHillshadePrepare = false;
              }
            })(e7, n5, i4, r4, l3, Qt2.disabled, u3), s3.viewport.set([0, 0, e7.width, e7.height]);
            else if (e7.renderPass === `translucent`) if (c3) {
              let [t5, a5, s4] = e7.stencilConfigForOverlapTwoPass(i4);
              wi(e7, n5, r4, s4, t5, l3, u3, false, o3), wi(e7, n5, r4, s4, a5, l3, u3, true, o3);
            } else {
              let [t5, a5] = e7.getStencilConfigForOverlapAndUpdateStencilID(i4);
              wi(e7, n5, r4, a5, t5, l3, u3, false, o3);
            }
          })(e6, n4, r3, i3, a3) : t4.cm(r3) ? (function(e7, t5, n5, r4, i4) {
            if (e7.renderPass !== `translucent` || !r4.length) return;
            let { isRenderingToTexture: a4 } = i4, o3 = e7.style.projection.useSubdivision, s3 = e7.getDepthModeForSublayer(0, J2.ReadOnly), c3 = e7.colorModeForRenderPass();
            if (o3) {
              let [i5, o4, l3] = e7.stencilConfigForOverlapTwoPass(r4);
              Ti(e7, t5, n5, l3, i5, s3, c3, false, a4), Ti(e7, t5, n5, l3, o4, s3, c3, true, a4);
            } else {
              let [i5, o4] = e7.getStencilConfigForOverlapAndUpdateStencilID(r4);
              Ti(e7, t5, n5, o4, i5, s3, c3, false, a4);
            }
          })(e6, n4, r3, i3, a3) : t4.bN(r3) ? (function(e7, t5, n5, r4, i4) {
            if (e7.renderPass !== `translucent` || n5.paint.get(`raster-opacity`) === 0 || !r4.length) return;
            let { isRenderingToTexture: a4 } = i4, o3 = t5.getSource(), s3 = e7.style.projection.useSubdivision;
            if (o3 instanceof _e2) Di(e7, t5, n5, r4, null, false, false, o3.tileCoords, o3.flippedWindingOrder, a4);
            else if (s3) {
              let [i5, o4, s4] = e7.stencilConfigForOverlapTwoPass(r4);
              Di(e7, t5, n5, s4, i5, false, true, Ei, false, a4), Di(e7, t5, n5, s4, o4, true, true, Ei, false, a4);
            } else {
              let [i5, o4] = e7.getStencilConfigForOverlapAndUpdateStencilID(r4);
              Di(e7, t5, n5, o4, i5, false, true, Ei, false, a4);
            }
          })(e6, n4, r3, i3, a3) : t4.cn(r3) ? (function(e7, t5, n5, r4, i4) {
            let a4 = n5.paint.get(`background-color`), o3 = n5.paint.get(`background-opacity`);
            if (o3 === 0) return;
            let { isRenderingToTexture: s3 } = i4, c3 = e7.context, l3 = c3.gl, u3 = e7.style.projection, d3 = e7.transform, f3 = d3.tileSize, p3 = n5.paint.get(`background-pattern`);
            if (e7.isPatternMissing(p3)) return;
            let m3 = !p3 && a4.a === 1 && o3 === 1 && e7.opaquePassEnabledForLayer() ? `opaque` : `translucent`;
            if (e7.renderPass !== m3) return;
            let h3 = Qt2.disabled, g3 = e7.getDepthModeForSublayer(0, m3 === `opaque` ? J2.ReadWrite : J2.ReadOnly), _3 = e7.colorModeForRenderPass(), v3 = e7.useProgram(p3 ? `backgroundPattern` : `background`), y3 = r4 || Be2(d3, { tileSize: f3, terrain: e7.style.map.terrain });
            p3 && (c3.activeTexture.set(l3.TEXTURE0), e7.imageManager.bind(e7.context));
            let b3 = n5.getCrossfadeParameters();
            for (let t6 of y3) {
              let r5 = d3.getProjectionData({ overscaledTileID: t6, applyGlobeMatrix: !s3, applyTerrainMatrix: true }), i5 = p3 ? pr(o3, e7, p3, { tileID: t6, tileSize: f3 }, b3) : fr(o3, a4), m4 = e7.style.map.terrain && e7.style.map.terrain.getTerrainData(t6), y4 = u3.getMeshFromTileID(c3, t6.canonical, false, true, `raster`);
              v3.draw(c3, l3.TRIANGLES, g3, h3, _3, q2.backCCW, i5, m4, r5, n5.id, y4.vertexBuffer, y4.indexBuffer, y4.segments);
            }
          })(e6, 0, r3, i3, a3) : t4.co(r3) && (function(e7, t5, n5, r4) {
            let { isRenderingGlobe: i4 } = r4, a4 = e7.context, o3 = n5.implementation, s3 = e7.style.projection, c3 = e7.transform, l3 = c3.getProjectionDataForCustomLayer(i4), u3 = { farZ: c3.farZ, nearZ: c3.nearZ, fov: c3.fov * Math.PI / 180, modelViewProjectionMatrix: c3.modelViewProjectionMatrix, projectionMatrix: c3.projectionMatrix, shaderData: { variantName: s3.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${s3.shaderPreludeCode.vertexSource}`, define: s3.shaderDefine }, defaultProjectionData: l3 }, d3 = o3.renderingMode ? o3.renderingMode : `2d`;
            if (e7.renderPass === `offscreen`) {
              let t6 = o3.prerender;
              t6 && (e7.setCustomLayerDefaults(), a4.setColorMode(e7.colorModeForRenderPass()), t6.call(o3, a4.gl, u3), a4.setDirty(), e7.setBaseState());
            } else if (e7.renderPass === `translucent`) {
              e7.setCustomLayerDefaults(), a4.setColorMode(e7.colorModeForRenderPass()), a4.setStencilMode(Qt2.disabled);
              let t6 = d3 === `3d` ? e7.getDepthModeFor3D() : e7.getDepthModeForSublayer(0, J2.ReadOnly);
              a4.setDepthMode(t6), o3.render(a4.gl, u3), a4.setDirty(), e7.setBaseState(), a4.bindFramebuffer.set(null);
            }
          })(e6, 0, r3, a3));
        }
        saveTileTexture(e6) {
          let t5 = this._tileTextures[e6.size[0]];
          t5 ? t5.push(e6) : this._tileTextures[e6.size[0]] = [e6];
        }
        getTileTexture(e6) {
          let t5 = this._tileTextures[e6];
          return t5 && t5.length > 0 ? t5.pop() : null;
        }
        isPatternMissing(e6) {
          if (!e6) return false;
          if (!e6.from || !e6.to) return true;
          let t5 = this.imageManager.getPattern(e6.from.toString()), n4 = this.imageManager.getPattern(e6.to.toString());
          return !t5 || !n4;
        }
        useProgram(e6, t5, n4 = false, r3 = []) {
          this.cache = this.cache || {};
          let i3 = !!this.style.map.terrain, a3 = this.style.projection, o3 = n4 ? Mt2.projectionMercator : a3.shaderPreludeCode, s3 = n4 ? Pt2 : a3.shaderDefine, c3 = e6 + (t5 ? t5.cacheKey : ``) + `/${n4 ? Ft2 : a3.shaderVariantName}` + (this._showOverdrawInspector ? `/overdraw` : ``) + (i3 ? `/terrain` : ``) + (r3 ? `/${r3.join(`/`)}` : ``);
          return this.cache[c3] || (this.cache[c3] = new Ln(this.context, Mt2[e6], t5, hr[e6], this._showOverdrawInspector, i3, o3, s3, r3)), this.cache[c3];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          let e6 = this.context.gl;
          this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e6.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas ?? (this.debugOverlayCanvas = document.createElement(`canvas`), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new t4.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this.debugOverlayTexture && this.debugOverlayTexture.destroy();
        }
        overLimit() {
          let { drawingBufferWidth: e6, drawingBufferHeight: t5 } = this.context.gl;
          return this.width !== e6 || this.height !== t5;
        }
      }
      function Vi(e6, t5) {
        let n4, r3 = false, i3 = null, a3 = null, o3 = () => {
          i3 = null, r3 && (r3 = (e6.apply(a3, n4), i3 = setTimeout(o3, t5), false));
        };
        return (...e7) => (r3 = true, a3 = this, n4 = e7, i3 || o3(), i3);
      }
      class Hi {
        constructor(e6) {
          this._getCurrentHash = () => {
            let e7 = window.location.hash.replace(`#`, ``);
            if (this._hashName) {
              let t5;
              return e7.split(`&`).map(((e8) => e8.split(`=`))).forEach(((e8) => {
                e8[0] === this._hashName && (t5 = e8);
              })), (t5 && t5[1] || ``).split(`/`);
            }
            return e7.split(`/`);
          }, this._onHashChange = () => {
            let e7 = this._getCurrentHash();
            if (!this._isValidHash(e7)) return false;
            let t5 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e7[3] || 0) : this._map.getBearing();
            return this._map.jumpTo({ center: [+e7[2], +e7[1]], zoom: +e7[0], bearing: t5, pitch: +(e7[4] || 0) }), true;
          }, this._updateHashUnthrottled = () => {
            let e7 = window.location.href.replace(/(#.*)?$/, this.getHashString());
            window.history.replaceState(window.history.state, null, e7);
          }, this._removeHash = () => {
            let e7 = this._getCurrentHash();
            if (e7.length === 0) return;
            let t5 = e7.join(`/`), n4 = t5;
            n4.split(`&`).length > 0 && (n4 = n4.split(`&`)[0]), this._hashName && (n4 = `${this._hashName}=${t5}`);
            let r3 = window.location.hash.replace(n4, ``);
            r3.startsWith(`#&`) ? r3 = r3.slice(0, 1) + r3.slice(2) : r3 === `#` && (r3 = ``);
            let i3 = window.location.href.replace(/(#.+)?$/, r3);
            i3 = i3.replace(`&&`, `&`), window.history.replaceState(window.history.state, null, i3);
          }, this._updateHash = Vi(this._updateHashUnthrottled, 300), this._hashName = e6 && encodeURIComponent(e6);
        }
        addTo(e6) {
          return this._map = e6, addEventListener(`hashchange`, this._onHashChange, false), this._map.on(`moveend`, this._updateHash), this;
        }
        remove() {
          return removeEventListener(`hashchange`, this._onHashChange, false), this._map.off(`moveend`, this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
        }
        getHashString(e6) {
          let t5 = this._map.getCenter(), n4 = Math.round(100 * this._map.getZoom()) / 100, r3 = 10 ** Math.ceil((n4 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), i3 = Math.round(t5.lng * r3) / r3, a3 = Math.round(t5.lat * r3) / r3, o3 = this._map.getBearing(), s3 = this._map.getPitch(), c3 = ``;
          if (c3 += e6 ? `/${i3}/${a3}/${n4}` : `${n4}/${a3}/${i3}`, (o3 || s3) && (c3 += `/` + Math.round(10 * o3) / 10), s3 && (c3 += `/${Math.round(s3)}`), this._hashName) {
            let e7 = this._hashName, t6 = false, n5 = window.location.hash.slice(1).split(`&`).map(((n6) => {
              let r4 = n6.split(`=`)[0];
              return r4 === e7 ? (t6 = true, `${r4}=${c3}`) : n6;
            })).filter(((e8) => e8));
            return t6 || n5.push(`${e7}=${c3}`), `#${n5.join(`&`)}`;
          }
          return `#${c3}`;
        }
        _isValidHash(e6) {
          if (e6.length < 3 || e6.some(isNaN)) return false;
          try {
            new t4.U(+e6[2], +e6[1]);
          } catch {
            return false;
          }
          let n4 = +e6[0], r3 = +(e6[3] || 0), i3 = +(e6[4] || 0);
          return n4 >= this._map.getMinZoom() && n4 <= this._map.getMaxZoom() && r3 >= -180 && r3 <= 180 && i3 >= this._map.getMinPitch() && i3 <= this._map.getMaxPitch();
        }
      }
      let Ui = { linearity: 0.3, easing: t4.cp(0, 0, 0.3, 1) }, Wi = t4.e({ deceleration: 2500, maxSpeed: 1400 }, Ui), Gi = t4.e({ deceleration: 20, maxSpeed: 1400 }, Ui), Ki = t4.e({ deceleration: 1e3, maxSpeed: 360 }, Ui), qi = t4.e({ deceleration: 1e3, maxSpeed: 90 }, Ui), Ji = t4.e({ deceleration: 1e3, maxSpeed: 360 }, Ui);
      class Yi {
        constructor(e6) {
          this._map = e6, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(e6) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: c2(), settings: e6 });
        }
        _drainInertiaBuffer() {
          let e6 = this._inertiaBuffer, t5 = c2();
          for (; e6.length > 0 && t5 - e6[0].time > 160; ) e6.shift();
        }
        _onMoveEnd(e6) {
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
          let n4 = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new t4.P(0, 0), pinchAround: void 0, around: void 0 };
          for (let { settings: e7 } of this._inertiaBuffer) n4.zoom += e7.zoomDelta || 0, n4.bearing += e7.bearingDelta || 0, n4.pitch += e7.pitchDelta || 0, n4.roll += e7.rollDelta || 0, e7.panDelta && n4.pan._add(e7.panDelta), e7.around && (n4.around = e7.around), e7.pinchAround && (n4.pinchAround = e7.pinchAround);
          let r3 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, i3 = {};
          if (n4.pan.mag()) {
            let a3 = Zi(n4.pan.mag(), r3, t4.e({}, Wi, e6 || {})), o3 = n4.pan.mult(a3.amount / n4.pan.mag()), s3 = this._map.cameraHelper.handlePanInertia(o3, this._map.transform);
            i3.center = s3.easingCenter, i3.offset = s3.easingOffset, Xi(i3, a3);
          }
          if (n4.zoom) {
            let e7 = Zi(n4.zoom, r3, Gi);
            i3.zoom = this._map.transform.zoom + e7.amount, Xi(i3, e7);
          }
          if (n4.bearing) {
            let e7 = Zi(n4.bearing, r3, Ki);
            i3.bearing = this._map.transform.bearing + t4.ai(e7.amount, -179, 179), Xi(i3, e7);
          }
          if (n4.pitch) {
            let e7 = Zi(n4.pitch, r3, qi);
            i3.pitch = this._map.transform.pitch + e7.amount, Xi(i3, e7);
          }
          if (n4.roll) {
            let e7 = Zi(n4.roll, r3, Ji);
            i3.roll = this._map.transform.roll + t4.ai(e7.amount, -179, 179), Xi(i3, e7);
          }
          if (i3.zoom || i3.bearing) {
            let e7 = n4.pinchAround === void 0 ? n4.around : n4.pinchAround;
            i3.around = e7 ? this._map.unproject(e7) : this._map.getCenter();
          }
          return this.clear(), t4.e(i3, { noMoveStart: true });
        }
      }
      function Xi(e6, t5) {
        (!e6.duration || e6.duration < t5.duration) && (e6.duration = t5.duration, e6.easing = t5.easing);
      }
      function Zi(e6, n4, r3) {
        let { maxSpeed: i3, linearity: a3, deceleration: o3 } = r3, s3 = t4.ai(e6 * a3 / (n4 / 1e3), -i3, i3), c3 = Math.abs(s3) / (o3 * a3);
        return { easing: r3.easing, duration: 1e3 * c3, amount: c3 / 2 * s3 };
      }
      class Qi extends t4.l {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e6, n4, r3, i3 = {}) {
          r3 = r3 instanceof MouseEvent ? r3 : new MouseEvent(e6, r3);
          let a3 = l2.mousePos(n4.getCanvas(), r3), o3 = n4.unproject(a3);
          super(e6, t4.e({ point: a3, lngLat: o3, originalEvent: r3 }, i3)), this._defaultPrevented = false, this.target = n4;
        }
      }
      class $i extends t4.l {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e6, n4, r3) {
          let i3 = e6 === `touchend` ? r3.changedTouches : r3.touches, a3 = l2.touchPos(n4.getCanvasContainer(), i3), o3 = a3.map(((e7) => n4.unproject(e7))), s3 = a3.reduce(((e7, t5, n5, r4) => e7.add(t5.div(r4.length))), new t4.P(0, 0));
          super(e6, { points: a3, point: s3, lngLats: o3, lngLat: n4.unproject(s3), originalEvent: r3 }), this._defaultPrevented = false;
        }
      }
      class ea extends t4.l {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e6, t5, n4) {
          super(e6, { originalEvent: n4 }), this._defaultPrevented = false;
        }
      }
      class ta {
        constructor(e6, t5) {
          this._map = e6, this._clickTolerance = t5.clickTolerance;
        }
        reset() {
          delete this._mousedownPos;
        }
        wheel(e6) {
          return this._firePreventable(new ea(e6.type, this._map, e6));
        }
        mousedown(e6, t5) {
          return this._mousedownPos = t5, this._firePreventable(new Qi(e6.type, this._map, e6));
        }
        mouseup(e6) {
          this._map.fire(new Qi(e6.type, this._map, e6));
        }
        click(e6, t5) {
          this._mousedownPos && this._mousedownPos.dist(t5) >= this._clickTolerance || this._map.fire(new Qi(e6.type, this._map, e6));
        }
        dblclick(e6) {
          return this._firePreventable(new Qi(e6.type, this._map, e6));
        }
        mouseover(e6) {
          this._map.fire(new Qi(e6.type, this._map, e6));
        }
        mouseout(e6) {
          this._map.fire(new Qi(e6.type, this._map, e6));
        }
        touchstart(e6) {
          return this._firePreventable(new $i(e6.type, this._map, e6));
        }
        touchmove(e6) {
          this._map.fire(new $i(e6.type, this._map, e6));
        }
        touchend(e6) {
          this._map.fire(new $i(e6.type, this._map, e6));
        }
        touchcancel(e6) {
          this._map.fire(new $i(e6.type, this._map, e6));
        }
        _firePreventable(e6) {
          if (this._map.fire(e6), e6.defaultPrevented) return {};
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }
      class na {
        constructor(e6) {
          this._map = e6;
        }
        reset() {
          this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
        }
        mousemove(e6) {
          this._map.fire(new Qi(e6.type, this._map, e6));
        }
        mousedown() {
          this._delayContextMenu = true, this._ignoreContextMenu = false;
        }
        mouseup() {
          this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new Qi(`contextmenu`, this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(e6) {
          this._delayContextMenu ? this._contextMenuEvent = e6 : this._ignoreContextMenu || this._map.fire(new Qi(e6.type, this._map, e6)), this._map.listens(`contextmenu`) && e6.preventDefault();
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }
      class ra {
        constructor(e6) {
          this._map = e6;
        }
        get transform() {
          return this._map._requestedCameraState || this._map.transform;
        }
        get center() {
          return { lng: this.transform.center.lng, lat: this.transform.center.lat };
        }
        get zoom() {
          return this.transform.zoom;
        }
        get pitch() {
          return this.transform.pitch;
        }
        get bearing() {
          return this.transform.bearing;
        }
        unproject(e6) {
          return this.transform.screenPointToLocation(t4.P.convert(e6), this._map.terrain);
        }
      }
      class ia {
        constructor(e6, t5) {
          this._map = e6, this._tr = new ra(e6), this._el = e6.getCanvasContainer(), this._container = e6.getContainer(), this._clickTolerance = t5.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = true);
        }
        disable() {
          this.isEnabled() && (this._enabled = false);
        }
        mousedown(e6, t5) {
          this.isEnabled() && e6.shiftKey && e6.button === 0 && (l2.disableDrag(), this._startPos = this._lastPos = t5, this._active = true);
        }
        mousemoveWindow(e6, t5) {
          if (!this._active) return;
          let n4 = t5;
          if (this._lastPos.equals(n4) || !this._box && n4.dist(this._startPos) < this._clickTolerance) return;
          let r3 = this._startPos;
          this._lastPos = n4, this._box || (this._box = l2.create(`div`, `maplibregl-boxzoom`, this._container), this._container.classList.add(`maplibregl-crosshair`), this._fireEvent(`boxzoomstart`, e6));
          let i3 = Math.min(r3.x, n4.x), a3 = Math.max(r3.x, n4.x), o3 = Math.min(r3.y, n4.y), s3 = Math.max(r3.y, n4.y);
          l2.setTransform(this._box, `translate(${i3}px,${o3}px)`), this._box.style.width = a3 - i3 + `px`, this._box.style.height = s3 - o3 + `px`;
        }
        mouseupWindow(e6, n4) {
          if (!this._active || e6.button !== 0) return;
          let r3 = this._startPos, i3 = n4;
          if (this.reset(), l2.suppressClick(), r3.x !== i3.x || r3.y !== i3.y) return this._map.fire(new t4.l(`boxzoomend`, { originalEvent: e6 })), { cameraAnimation: (e7) => e7.fitScreenCoordinates(r3, i3, this._tr.bearing, { linear: true }) };
          this._fireEvent(`boxzoomcancel`, e6);
        }
        keydown(e6) {
          this._active && e6.keyCode === 27 && (this.reset(), this._fireEvent(`boxzoomcancel`, e6));
        }
        reset() {
          this._active = false, this._container.classList.remove(`maplibregl-crosshair`), this._box && (this._box = (l2.remove(this._box), null)), l2.enableDrag(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(e6, n4) {
          return this._map.fire(new t4.l(e6, { originalEvent: n4 }));
        }
      }
      function aa(e6, t5) {
        if (e6.length !== t5.length) throw Error(`The number of touches and points are not equal - touches ${e6.length}, points ${t5.length}`);
        let n4 = {};
        for (let r3 = 0; r3 < e6.length; r3++) n4[e6[r3].identifier] = t5[r3];
        return n4;
      }
      class oa {
        constructor(e6) {
          this.reset(), this.numTouches = e6.numTouches;
        }
        reset() {
          delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
        }
        touchstart(e6, n4, r3) {
          (this.centroid || r3.length > this.numTouches) && (this.aborted = true), this.aborted || (this.startTime === void 0 && (this.startTime = e6.timeStamp), r3.length === this.numTouches && (this.centroid = (function(e7) {
            let n5 = new t4.P(0, 0);
            for (let t5 of e7) n5._add(t5);
            return n5.div(e7.length);
          })(n4), this.touches = aa(r3, n4)));
        }
        touchmove(e6, t5, n4) {
          if (this.aborted || !this.centroid) return;
          let r3 = aa(n4, t5);
          for (let e7 in this.touches) {
            let t6 = r3[e7];
            (!t6 || t6.dist(this.touches[e7]) > 30) && (this.aborted = true);
          }
        }
        touchend(e6, t5, n4) {
          if ((!this.centroid || e6.timeStamp - this.startTime > 500) && (this.aborted = true), n4.length === 0) {
            let e7 = !this.aborted && this.centroid;
            if (this.reset(), e7) return e7;
          }
        }
      }
      class sa {
        constructor(e6) {
          this.singleTap = new oa(e6), this.numTaps = e6.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
        }
        touchstart(e6, t5, n4) {
          this.singleTap.touchstart(e6, t5, n4);
        }
        touchmove(e6, t5, n4) {
          this.singleTap.touchmove(e6, t5, n4);
        }
        touchend(e6, t5, n4) {
          let r3 = this.singleTap.touchend(e6, t5, n4);
          if (r3) {
            let t6 = e6.timeStamp - this.lastTime < 500, n5 = !this.lastTap || this.lastTap.dist(r3) < 30;
            if (t6 && n5 || this.reset(), this.count++, this.lastTime = e6.timeStamp, this.lastTap = r3, this.count === this.numTaps) return this.reset(), r3;
          }
        }
      }
      class ca {
        constructor(e6) {
          this._tr = new ra(e6), this._zoomIn = new sa({ numTouches: 1, numTaps: 2 }), this._zoomOut = new sa({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(e6, t5, n4) {
          this._zoomIn.touchstart(e6, t5, n4), this._zoomOut.touchstart(e6, t5, n4);
        }
        touchmove(e6, t5, n4) {
          this._zoomIn.touchmove(e6, t5, n4), this._zoomOut.touchmove(e6, t5, n4);
        }
        touchend(e6, t5, n4) {
          let r3 = this._zoomIn.touchend(e6, t5, n4), i3 = this._zoomOut.touchend(e6, t5, n4), a3 = this._tr;
          return r3 ? (this._active = true, e6.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (t6) => t6.easeTo({ duration: 300, zoom: a3.zoom + 1, around: a3.unproject(r3) }, { originalEvent: e6 }) }) : i3 ? (this._active = true, e6.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (t6) => t6.easeTo({ duration: 300, zoom: a3.zoom - 1, around: a3.unproject(i3) }, { originalEvent: e6 }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class la {
        constructor(e6) {
          this._enabled = !!e6.enable, this._moveStateManager = e6.moveStateManager, this._clickTolerance = e6.clickTolerance || 1, this._moveFunction = e6.move, this._activateOnStart = !!e6.activateOnStart, e6.assignEvents(this), this.reset();
        }
        reset(e6) {
          this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(e6);
        }
        _move(...e6) {
          let t5 = this._moveFunction(...e6);
          if (t5.bearingDelta || t5.pitchDelta || t5.rollDelta || t5.around || t5.panDelta) return this._active = true, t5;
        }
        dragStart(e6, t5) {
          this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e6) && (this._moveStateManager.startMove(e6), this._lastPoint = Array.isArray(t5) ? t5[0] : t5, this._activateOnStart && this._lastPoint && (this._active = true));
        }
        dragMove(e6, t5) {
          if (!this.isEnabled()) return;
          let n4 = this._lastPoint;
          if (!n4) return;
          if (e6.preventDefault(), !this._moveStateManager.isValidMoveEvent(e6)) return void this.reset(e6);
          let r3 = Array.isArray(t5) ? t5[0] : t5;
          return !this._moved && r3.dist(n4) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = r3, this._move(n4, r3));
        }
        dragEnd(e6) {
          this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e6) && (this._moved && l2.suppressClick(), this.reset(e6));
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        getClickTolerance() {
          return this._clickTolerance;
        }
      }
      let X = { 0: 1, 2: 2 };
      class ua {
        constructor(e6) {
          this._correctEvent = e6.checkCorrectEvent;
        }
        startMove(e6) {
          this._eventButton = l2.mouseButton(e6);
        }
        endMove(e6) {
          delete this._eventButton;
        }
        isValidStartEvent(e6) {
          return this._correctEvent(e6);
        }
        isValidMoveEvent(e6) {
          return !(function(e7, t5) {
            let n4 = X[t5];
            return e7.buttons === void 0 || (e7.buttons & n4) !== n4;
          })(e6, this._eventButton);
        }
        isValidEndEvent(e6) {
          return l2.mouseButton(e6) === this._eventButton;
        }
      }
      class da {
        constructor() {
          this._firstTouch = void 0;
        }
        _isOneFingerTouch(e6) {
          return e6.targetTouches.length === 1;
        }
        _isSameTouchEvent(e6) {
          return e6.targetTouches[0].identifier === this._firstTouch;
        }
        startMove(e6) {
          this._firstTouch = e6.targetTouches[0].identifier;
        }
        endMove(e6) {
          delete this._firstTouch;
        }
        isValidStartEvent(e6) {
          return this._isOneFingerTouch(e6);
        }
        isValidMoveEvent(e6) {
          return this._isOneFingerTouch(e6) && this._isSameTouchEvent(e6);
        }
        isValidEndEvent(e6) {
          return this._isOneFingerTouch(e6) && this._isSameTouchEvent(e6);
        }
      }
      class fa {
        constructor(e6 = new ua({ checkCorrectEvent: () => true }), t5 = new da()) {
          this.mouseMoveStateManager = e6, this.oneFingerTouchMoveStateManager = t5;
        }
        _executeRelevantHandler(e6, t5, n4) {
          return e6 instanceof MouseEvent ? t5(e6) : typeof TouchEvent < `u` && e6 instanceof TouchEvent ? n4(e6) : void 0;
        }
        startMove(e6) {
          this._executeRelevantHandler(e6, ((e7) => this.mouseMoveStateManager.startMove(e7)), ((e7) => this.oneFingerTouchMoveStateManager.startMove(e7)));
        }
        endMove(e6) {
          this._executeRelevantHandler(e6, ((e7) => this.mouseMoveStateManager.endMove(e7)), ((e7) => this.oneFingerTouchMoveStateManager.endMove(e7)));
        }
        isValidStartEvent(e6) {
          return this._executeRelevantHandler(e6, ((e7) => this.mouseMoveStateManager.isValidStartEvent(e7)), ((e7) => this.oneFingerTouchMoveStateManager.isValidStartEvent(e7)));
        }
        isValidMoveEvent(e6) {
          return this._executeRelevantHandler(e6, ((e7) => this.mouseMoveStateManager.isValidMoveEvent(e7)), ((e7) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(e7)));
        }
        isValidEndEvent(e6) {
          return this._executeRelevantHandler(e6, ((e7) => this.mouseMoveStateManager.isValidEndEvent(e7)), ((e7) => this.oneFingerTouchMoveStateManager.isValidEndEvent(e7)));
        }
      }
      let pa = (e6) => {
        e6.mousedown = e6.dragStart, e6.mousemoveWindow = e6.dragMove, e6.mouseup = e6.dragEnd, e6.contextmenu = (e7) => {
          e7.preventDefault();
        };
      };
      class ma {
        constructor(e6, t5) {
          this._clickTolerance = e6.clickTolerance || 1, this._map = t5, this.reset();
        }
        reset() {
          this._active = false, this._touches = {}, this._sum = new t4.P(0, 0);
        }
        _shouldBePrevented(e6) {
          return e6 < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
        }
        touchstart(e6, t5, n4) {
          return this._calculateTransform(e6, t5, n4);
        }
        touchmove(e6, t5, n4) {
          if (this._active) {
            if (!this._shouldBePrevented(n4.length)) return e6.preventDefault(), this._calculateTransform(e6, t5, n4);
            this._map.cooperativeGestures.notifyGestureBlocked(`touch_pan`, e6);
          }
        }
        touchend(e6, t5, n4) {
          this._calculateTransform(e6, t5, n4), this._active && this._shouldBePrevented(n4.length) && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(e6, n4, r3) {
          r3.length > 0 && (this._active = true);
          let i3 = aa(r3, n4), a3 = new t4.P(0, 0), o3 = new t4.P(0, 0), s3 = 0;
          for (let e7 in i3) {
            let t5 = i3[e7], n5 = this._touches[e7];
            n5 && (a3._add(t5), o3._add(t5.sub(n5)), s3++, i3[e7] = t5);
          }
          if (this._touches = i3, this._shouldBePrevented(s3) || !o3.mag()) return;
          let c3 = o3.div(s3);
          return this._sum._add(c3), this._sum.mag() < this._clickTolerance ? void 0 : { around: a3.div(s3), panDelta: c3 };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class ha {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false, delete this._firstTwoTouches;
        }
        touchstart(e6, t5, n4) {
          this._firstTwoTouches || n4.length < 2 || (this._firstTwoTouches = [n4[0].identifier, n4[1].identifier], this._start([t5[0], t5[1]]));
        }
        touchmove(e6, t5, n4) {
          if (!this._firstTwoTouches) return;
          e6.preventDefault();
          let [r3, i3] = this._firstTwoTouches, a3 = Z(n4, t5, r3), o3 = Z(n4, t5, i3);
          if (!a3 || !o3) return;
          let s3 = this._aroundCenter ? null : a3.add(o3).div(2);
          return this._move([a3, o3], s3, e6);
        }
        touchend(e6, t5, n4) {
          if (!this._firstTwoTouches) return;
          let [r3, i3] = this._firstTwoTouches, a3 = Z(n4, t5, r3), o3 = Z(n4, t5, i3);
          a3 && o3 || (this._active && l2.suppressClick(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(e6) {
          this._enabled = true, this._aroundCenter = !!e6 && e6.around === `center`;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
      }
      function Z(e6, t5, n4) {
        for (let r3 = 0; r3 < e6.length; r3++) if (e6[r3].identifier === n4) return t5[r3];
      }
      function ga(e6, t5) {
        return Math.log(e6 / t5) / Math.LN2;
      }
      class _a2 extends ha {
        reset() {
          super.reset(), delete this._distance, delete this._startDistance;
        }
        _start(e6) {
          this._startDistance = this._distance = e6[0].dist(e6[1]);
        }
        _move(e6, t5) {
          let n4 = this._distance;
          if (this._distance = e6[0].dist(e6[1]), this._active || !(Math.abs(ga(this._distance, this._startDistance)) < 0.1)) return this._active = true, { zoomDelta: ga(this._distance, n4), pinchAround: t5 };
        }
      }
      function va(e6, t5) {
        return 180 * e6.angleWith(t5) / Math.PI;
      }
      class ya extends ha {
        reset() {
          super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
        }
        _start(e6) {
          this._startVector = this._vector = e6[0].sub(e6[1]), this._minDiameter = e6[0].dist(e6[1]);
        }
        _move(e6, t5, n4) {
          let r3 = this._vector;
          if (this._vector = e6[0].sub(e6[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = true, { bearingDelta: va(this._vector, r3), pinchAround: t5 };
        }
        _isBelowThreshold(e6) {
          this._minDiameter = Math.min(this._minDiameter, e6.mag());
          let t5 = 25 / (Math.PI * this._minDiameter) * 360, n4 = va(e6, this._startVector);
          return Math.abs(n4) < t5;
        }
      }
      function ba(e6) {
        return Math.abs(e6.y) > Math.abs(e6.x);
      }
      class xa extends ha {
        constructor(e6) {
          super(), this._currentTouchCount = 0, this._map = e6;
        }
        reset() {
          super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
        }
        touchstart(e6, t5, n4) {
          super.touchstart(e6, t5, n4), this._currentTouchCount = n4.length;
        }
        _start(e6) {
          this._lastPoints = e6, ba(e6[0].sub(e6[1])) && (this._valid = false);
        }
        _move(e6, t5, n4) {
          if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
          let r3 = e6[0].sub(this._lastPoints[0]), i3 = e6[1].sub(this._lastPoints[1]);
          return this._valid = this.gestureBeginsVertically(r3, i3, n4.timeStamp), this._valid ? (this._lastPoints = e6, this._active = true, { pitchDelta: (r3.y + i3.y) / 2 * -0.5 }) : void 0;
        }
        gestureBeginsVertically(e6, t5, n4) {
          if (this._valid !== void 0) return this._valid;
          let r3 = e6.mag() >= 2, i3 = t5.mag() >= 2;
          if (!r3 && !i3) return;
          if (!r3 || !i3) return this._firstMove === void 0 && (this._firstMove = n4), n4 - this._firstMove < 100 && void 0;
          let a3 = e6.y > 0 == t5.y > 0;
          return ba(e6) && ba(t5) && a3;
        }
      }
      let Sa = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class Ca {
        constructor(e6) {
          this._tr = new ra(e6);
          let t5 = Sa;
          this._panStep = t5.panStep, this._bearingStep = t5.bearingStep, this._pitchStep = t5.pitchStep, this._rotationDisabled = false;
        }
        reset() {
          this._active = false;
        }
        keydown(e6) {
          if (e6.altKey || e6.ctrlKey || e6.metaKey) return;
          let t5 = 0, n4 = 0, r3 = 0, i3 = 0, a3 = 0;
          switch (e6.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              t5 = 1;
              break;
            case 189:
            case 109:
            case 173:
              t5 = -1;
              break;
            case 37:
              e6.shiftKey ? n4 = -1 : (e6.preventDefault(), i3 = -1);
              break;
            case 39:
              e6.shiftKey ? n4 = 1 : (e6.preventDefault(), i3 = 1);
              break;
            case 38:
              e6.shiftKey ? r3 = 1 : (e6.preventDefault(), a3 = -1);
              break;
            case 40:
              e6.shiftKey ? r3 = -1 : (e6.preventDefault(), a3 = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (n4 = 0, r3 = 0), { cameraAnimation: (o3) => {
            let s3 = this._tr;
            o3.easeTo({ duration: 300, easeId: `keyboardHandler`, easing: wa, zoom: t5 ? Math.round(s3.zoom) + t5 * (e6.shiftKey ? 2 : 1) : s3.zoom, bearing: s3.bearing + n4 * this._bearingStep, pitch: s3.pitch + r3 * this._pitchStep, offset: [-i3 * this._panStep, -a3 * this._panStep], center: s3.center }, { originalEvent: e6 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = true;
        }
        enableRotation() {
          this._rotationDisabled = false;
        }
      }
      function wa(e6) {
        return e6 * (2 - e6);
      }
      let Ta = 4.000244140625;
      class Ea {
        constructor(e6, t5) {
          this._onTimeout = (e7) => {
            this._type = `wheel`, this._delta -= this._lastValue, this._active || this._start(e7);
          }, this._map = e6, this._tr = new ra(e6), this._triggerRenderFrame = t5, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
        }
        setZoomRate(e6) {
          this._defaultZoomRate = e6;
        }
        setWheelZoomRate(e6) {
          this._wheelZoomRate = e6;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active || this._finishTimeout !== void 0;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(e6) {
          this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e6 && e6.around === `center`);
        }
        disable() {
          this.isEnabled() && (this._enabled = false);
        }
        _shouldBePrevented(e6) {
          return !!this._map.cooperativeGestures.isEnabled() && !(e6.ctrlKey || this._map.cooperativeGestures.isBypassed(e6));
        }
        wheel(e6) {
          if (!this.isEnabled()) return;
          if (this._shouldBePrevented(e6)) return void this._map.cooperativeGestures.notifyGestureBlocked(`wheel_zoom`, e6);
          let t5 = e6.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e6.deltaY : e6.deltaY, n4 = c2(), r3 = n4 - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = n4, t5 !== 0 && t5 % Ta == 0 ? this._type = `wheel` : t5 !== 0 && Math.abs(t5) < 4 ? this._type = `trackpad` : r3 > 400 ? (this._type = null, this._lastValue = t5, this._timeout = setTimeout(this._onTimeout, 40, e6)) : this._type || (this._type = Math.abs(r3 * t5) < 200 ? `trackpad` : `wheel`, this._timeout && (clearTimeout(this._timeout), this._timeout = null, t5 += this._lastValue)), e6.shiftKey && t5 && (t5 /= 4), this._type && (this._lastWheelEvent = e6, this._delta -= t5, this._active || this._start(e6)), e6.preventDefault();
        }
        _start(e6) {
          if (!this._delta) return;
          this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          let n4 = l2.mousePos(this._map.getCanvas(), e6), r3 = this._tr;
          this._aroundPoint = this._aroundCenter ? r3.transform.locationToScreenPoint(t4.U.convert(r3.center)) : n4, this._frameId || (this._frameId = true, this._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId || (this._frameId = null, !this.isActive())) return;
          let e6 = this._tr.transform;
          if (typeof this._lastExpectedZoom == `number`) {
            let t5 = e6.zoom - this._lastExpectedZoom;
            typeof this._startZoom == `number` && (this._startZoom += t5), typeof this._targetZoom == `number` && (this._targetZoom += t5);
          }
          if (this._delta !== 0) {
            let n5 = this._type === `wheel` && Math.abs(this._delta) > Ta ? this._wheelZoomRate : this._defaultZoomRate, r4 = 2 / (1 + Math.exp(-Math.abs(this._delta * n5)));
            this._delta < 0 && r4 !== 0 && (r4 = 1 / r4);
            let i4 = typeof this._targetZoom == `number` ? t4.al(this._targetZoom) : e6.scale;
            this._targetZoom = e6.constrain(e6.getCameraLngLat(), t4.ao(i4 * r4)).zoom, this._type === `wheel` && (this._startZoom = e6.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          let n4 = typeof this._targetZoom == `number` ? this._targetZoom : e6.zoom, r3 = this._startZoom, i3 = this._easing, a3, o3 = false;
          if (this._type === `wheel` && r3 && i3) {
            let e7 = c2() - this._lastWheelEventTime, s3 = Math.min((e7 + 5) / 200, 1), l3 = i3(s3);
            a3 = t4.F.number(r3, n4, l3), s3 < 1 ? this._frameId || (this._frameId = true) : o3 = true;
          } else a3 = n4, o3 = true;
          return this._active = true, o3 && (this._active = false, this._finishTimeout = setTimeout((() => {
            this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
          }), 200)), this._lastExpectedZoom = a3, { noInertia: true, needsRenderFrame: !o3, zoomDelta: a3 - e6.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(e6) {
          let n4 = t4.cr;
          if (this._prevEase) {
            let e7 = this._prevEase, r3 = (c2() - e7.start) / e7.duration, i3 = e7.easing(r3 + 0.01) - e7.easing(r3), a3 = 0.27 / Math.sqrt(i3 * i3 + 1e-4) * 0.01, o3 = Math.sqrt(0.0729 - a3 * a3);
            n4 = t4.cp(a3, o3, 0.25, 1);
          }
          return this._prevEase = { start: c2(), duration: e6, easing: n4 }, n4;
        }
        reset() {
          this._active = false, this._zooming = false, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
        }
      }
      class Da {
        constructor(e6, t5) {
          this._clickZoom = e6, this._tapZoom = t5;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class Oa {
        constructor(e6) {
          this._tr = new ra(e6), this.reset();
        }
        reset() {
          this._active = false;
        }
        dblclick(e6, t5) {
          return e6.preventDefault(), { cameraAnimation: (n4) => {
            n4.easeTo({ duration: 300, zoom: this._tr.zoom + (e6.shiftKey ? -1 : 1), around: this._tr.unproject(t5) }, { originalEvent: e6 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class ka {
        constructor() {
          this._tap = new sa({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
        }
        touchstart(e6, t5, n4) {
          if (!this._swipePoint) if (this._tapTime) {
            let r3 = t5[0], i3 = e6.timeStamp - this._tapTime < 500, a3 = this._tapPoint.dist(r3) < 30;
            i3 && a3 ? n4.length > 0 && (this._swipePoint = r3, this._swipeTouch = n4[0].identifier) : this.reset();
          } else this._tap.touchstart(e6, t5, n4);
        }
        touchmove(e6, t5, n4) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (n4[0].identifier !== this._swipeTouch) return;
              let r3 = t5[0], i3 = r3.y - this._swipePoint.y;
              return this._swipePoint = r3, e6.preventDefault(), this._active = true, { zoomDelta: i3 / 128 };
            }
          } else this._tap.touchmove(e6, t5, n4);
        }
        touchend(e6, t5, n4) {
          if (this._tapTime) this._swipePoint && n4.length === 0 && this.reset();
          else {
            let r3 = this._tap.touchend(e6, t5, n4);
            r3 && (this._tapTime = e6.timeStamp, this._tapPoint = r3);
          }
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Aa {
        constructor(e6, t5, n4) {
          this._el = e6, this._mousePan = t5, this._touchPan = n4;
        }
        enable(e6) {
          this._inertiaOptions = e6 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add(`maplibregl-touch-drag-pan`);
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove(`maplibregl-touch-drag-pan`);
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class ja {
        constructor(e6, t5, n4, r3) {
          this._pitchWithRotate = e6.pitchWithRotate, this._rollEnabled = e6.rollEnabled, this._mouseRotate = t5, this._mousePitch = n4, this._mouseRoll = r3;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
        }
      }
      class Ma {
        constructor(e6, t5, n4, r3) {
          this._el = e6, this._touchZoom = t5, this._touchRotate = n4, this._tapDragZoom = r3, this._rotationDisabled = false, this._enabled = true;
        }
        enable(e6) {
          this._touchZoom.enable(e6), this._rotationDisabled || this._touchRotate.enable(e6), this._tapDragZoom.enable(), this._el.classList.add(`maplibregl-touch-zoom-rotate`);
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove(`maplibregl-touch-zoom-rotate`);
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = true, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      class Na {
        constructor(e6, t5) {
          this._bypassKey = navigator.userAgent.indexOf(`Mac`) === -1 ? `ctrlKey` : `metaKey`, this._map = e6, this._options = t5, this._enabled = false;
        }
        isActive() {
          return false;
        }
        reset() {
        }
        _setupUI() {
          if (this._container) return;
          let e6 = this._map.getCanvasContainer();
          e6.classList.add(`maplibregl-cooperative-gestures`), this._container = l2.create(`div`, `maplibregl-cooperative-gesture-screen`, e6);
          let t5 = this._map._getUIString(`CooperativeGesturesHandler.WindowsHelpText`);
          this._bypassKey === `metaKey` && (t5 = this._map._getUIString(`CooperativeGesturesHandler.MacHelpText`));
          let n4 = this._map._getUIString(`CooperativeGesturesHandler.MobileHelpText`), r3 = document.createElement(`div`);
          r3.className = `maplibregl-desktop-message`, r3.textContent = t5, this._container.appendChild(r3);
          let i3 = document.createElement(`div`);
          i3.className = `maplibregl-mobile-message`, i3.textContent = n4, this._container.appendChild(i3), this._container.setAttribute(`aria-hidden`, `true`);
        }
        _destroyUI() {
          this._container && (l2.remove(this._container), this._map.getCanvasContainer().classList.remove(`maplibregl-cooperative-gestures`)), delete this._container;
        }
        enable() {
          this._setupUI(), this._enabled = true;
        }
        disable() {
          this._enabled = false, this._destroyUI();
        }
        isEnabled() {
          return this._enabled;
        }
        isBypassed(e6) {
          return e6[this._bypassKey];
        }
        notifyGestureBlocked(e6, n4) {
          this._enabled && (this._map.fire(new t4.l(`cooperativegestureprevented`, { gestureType: e6, originalEvent: n4 })), this._container.classList.add(`maplibregl-show`), setTimeout((() => {
            this._container.classList.remove(`maplibregl-show`);
          }), 100));
        }
      }
      let Pa = (e6) => e6.zoom || e6.drag || e6.roll || e6.pitch || e6.rotate;
      class Fa extends t4.l {
      }
      function Ia(e6) {
        return e6.panDelta && e6.panDelta.mag() || e6.zoomDelta || e6.bearingDelta || e6.pitchDelta || e6.rollDelta;
      }
      class La {
        constructor(e6, n4) {
          this.handleWindowEvent = (e7) => {
            this.handleEvent(e7, `${e7.type}Window`);
          }, this.handleEvent = (e7, n5) => {
            if (e7.type === `blur`) return void this.stop(true);
            this._updatingCamera = true;
            let r4 = e7.type === `renderFrame` ? void 0 : e7, i3 = { needsRenderFrame: false }, a3 = {}, o3 = {};
            for (let { handlerName: s4, handler: c4, allowed: u3 } of this._handlers) {
              if (!c4.isEnabled()) continue;
              let d3;
              if (this._blockedByActive(o3, u3, s4)) c4.reset();
              else if (c4[n5 || e7.type]) {
                if (t4.cs(e7, n5 || e7.type)) {
                  let t5 = l2.mousePos(this._map.getCanvas(), e7);
                  d3 = c4[n5 || e7.type](e7, t5);
                } else if (t4.ct(e7, n5 || e7.type)) {
                  let t5 = this._getMapTouches(e7.touches), r5 = l2.touchPos(this._map.getCanvas(), t5);
                  d3 = c4[n5 || e7.type](e7, r5, t5);
                } else t4.cu(n5 || e7.type) || (d3 = c4[n5 || e7.type](e7));
                this.mergeHandlerResult(i3, a3, d3, s4, r4), d3 && d3.needsRenderFrame && this._triggerRenderFrame();
              }
              (d3 || c4.isActive()) && (o3[s4] = c4);
            }
            let s3 = {};
            for (let e8 in this._previousActiveHandlers) o3[e8] || (s3[e8] = r4);
            this._previousActiveHandlers = o3, (Object.keys(s3).length || Ia(i3)) && (this._changes.push([i3, a3, s3]), this._triggerRenderFrame()), (Object.keys(o3).length || Ia(i3)) && this._map._stop(true), this._updatingCamera = false;
            let { cameraAnimation: c3 } = i3;
            c3 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], c3(this._map));
          }, this._map = e6, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Yi(e6), this._bearingSnap = n4.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(n4);
          let r3 = this._el;
          this._listeners = [[r3, `touchstart`, { passive: true }], [r3, `touchmove`, { passive: false }], [r3, `touchend`, void 0], [r3, `touchcancel`, void 0], [r3, `mousedown`, void 0], [r3, `mousemove`, void 0], [r3, `mouseup`, void 0], [document, `mousemove`, { capture: true }], [document, `mouseup`, void 0], [r3, `mouseover`, void 0], [r3, `mouseout`, void 0], [r3, `dblclick`, void 0], [r3, `click`, void 0], [r3, `keydown`, { capture: false }], [r3, `keyup`, void 0], [r3, `wheel`, { passive: false }], [r3, `contextmenu`, void 0], [window, `blur`, void 0]];
          for (let [e7, t5, n5] of this._listeners) l2.addEventListener(e7, t5, e7 === document ? this.handleWindowEvent : this.handleEvent, n5);
        }
        destroy() {
          for (let [e6, t5, n4] of this._listeners) l2.removeEventListener(e6, t5, e6 === document ? this.handleWindowEvent : this.handleEvent, n4);
        }
        _addDefaultHandlers(e6) {
          let n4 = this._map, r3 = n4.getCanvasContainer();
          this._add(`mapEvent`, new ta(n4, e6));
          let i3 = n4.boxZoom = new ia(n4, e6);
          this._add(`boxZoom`, i3), e6.interactive && e6.boxZoom && i3.enable();
          let a3 = n4.cooperativeGestures = new Na(n4, e6.cooperativeGestures);
          this._add(`cooperativeGestures`, a3), e6.cooperativeGestures && a3.enable();
          let o3 = new ca(n4), s3 = new Oa(n4);
          n4.doubleClickZoom = new Da(s3, o3), this._add(`tapZoom`, o3), this._add(`clickZoom`, s3), e6.interactive && e6.doubleClickZoom && n4.doubleClickZoom.enable();
          let c3 = new ka();
          this._add(`tapDragZoom`, c3);
          let u3 = n4.touchPitch = new xa(n4);
          this._add(`touchPitch`, u3), e6.interactive && e6.touchPitch && n4.touchPitch.enable(e6.touchPitch);
          let d3 = () => n4.project(n4.getCenter()), f3 = (function({ enable: e7, clickTolerance: n5, aroundCenter: r4 = true, minPixelCenterThreshold: i4 = 100, rotateDegreesPerPixelMoved: a4 = 0.8 }, o4) {
            return new la({ clickTolerance: n5, move: (e8, n6) => {
              let s4 = o4();
              if (r4 && Math.abs(s4.y - e8.y) > i4) return { bearingDelta: t4.cq(new t4.P(e8.x, n6.y), n6, s4) };
              let c4 = (n6.x - e8.x) * a4;
              return r4 && n6.y < s4.y && (c4 = -c4), { bearingDelta: c4 };
            }, moveStateManager: new ua({ checkCorrectEvent: (e8) => l2.mouseButton(e8) === 0 && e8.ctrlKey || l2.mouseButton(e8) === 2 && !e8.ctrlKey }), enable: e7, assignEvents: pa });
          })(e6, d3), p3 = (function({ enable: e7, clickTolerance: t5, pitchDegreesPerPixelMoved: n5 = -0.5 }) {
            return new la({ clickTolerance: t5, move: (e8, t6) => ({ pitchDelta: (t6.y - e8.y) * n5 }), moveStateManager: new ua({ checkCorrectEvent: (e8) => l2.mouseButton(e8) === 0 && e8.ctrlKey || l2.mouseButton(e8) === 2 }), enable: e7, assignEvents: pa });
          })(e6), m3 = (function({ enable: e7, clickTolerance: t5, rollDegreesPerPixelMoved: n5 = 0.3 }, r4) {
            return new la({ clickTolerance: t5, move: (e8, t6) => {
              let i4 = r4(), a4 = (t6.x - e8.x) * n5;
              return t6.y < i4.y && (a4 = -a4), { rollDelta: a4 };
            }, moveStateManager: new ua({ checkCorrectEvent: (e8) => l2.mouseButton(e8) === 2 && e8.ctrlKey }), enable: e7, assignEvents: pa });
          })(e6, d3);
          n4.dragRotate = new ja(e6, f3, p3, m3), this._add(`mouseRotate`, f3, [`mousePitch`]), this._add(`mousePitch`, p3, [`mouseRotate`, `mouseRoll`]), this._add(`mouseRoll`, m3, [`mousePitch`]), e6.interactive && e6.dragRotate && n4.dragRotate.enable();
          let h3 = (function({ enable: e7, clickTolerance: t5 }) {
            return new la({ clickTolerance: t5, move: (e8, t6) => ({ around: t6, panDelta: t6.sub(e8) }), activateOnStart: true, moveStateManager: new ua({ checkCorrectEvent: (e8) => l2.mouseButton(e8) === 0 && !e8.ctrlKey }), enable: e7, assignEvents: pa });
          })(e6), g3 = new ma(e6, n4);
          n4.dragPan = new Aa(r3, h3, g3), this._add(`mousePan`, h3), this._add(`touchPan`, g3, [`touchZoom`, `touchRotate`]), e6.interactive && e6.dragPan && n4.dragPan.enable(e6.dragPan);
          let _3 = new ya(), v3 = new _a2();
          n4.touchZoomRotate = new Ma(r3, v3, _3, c3), this._add(`touchRotate`, _3, [`touchPan`, `touchZoom`]), this._add(`touchZoom`, v3, [`touchPan`, `touchRotate`]), e6.interactive && e6.touchZoomRotate && n4.touchZoomRotate.enable(e6.touchZoomRotate), this._add(`blockableMapEvent`, new na(n4));
          let y3 = n4.scrollZoom = new Ea(n4, (() => this._triggerRenderFrame()));
          this._add(`scrollZoom`, y3, [`mousePan`]), e6.interactive && e6.scrollZoom && n4.scrollZoom.enable(e6.scrollZoom);
          let b3 = n4.keyboard = new Ca(n4);
          this._add(`keyboard`, b3), e6.interactive && e6.keyboard && n4.keyboard.enable();
        }
        _add(e6, t5, n4) {
          this._handlers.push({ handlerName: e6, handler: t5, allowed: n4 }), this._handlersById[e6] = t5;
        }
        stop(e6) {
          if (!this._updatingCamera) {
            for (let { handler: e7 } of this._handlers) e7.reset();
            this._inertia.clear(), this._fireEvents({}, {}, e6), this._changes = [];
          }
        }
        isActive() {
          for (let { handler: e6 } of this._handlers) if (e6.isActive()) return true;
          return false;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!Pa(this._eventsInProgress) || this.isZooming();
        }
        _blockedByActive(e6, t5, n4) {
          for (let r3 in e6) if (r3 !== n4 && (!t5 || t5.indexOf(r3) < 0)) return true;
          return false;
        }
        _getMapTouches(e6) {
          let t5 = [];
          for (let n4 of e6) this._el.contains(n4.target) && t5.push(n4);
          return t5;
        }
        mergeHandlerResult(e6, n4, r3, i3, a3) {
          if (!r3) return;
          t4.e(e6, r3);
          let o3 = { handlerName: i3, originalEvent: r3.originalEvent || a3 };
          r3.zoomDelta !== void 0 && (n4.zoom = o3), r3.panDelta !== void 0 && (n4.drag = o3), r3.rollDelta !== void 0 && (n4.roll = o3), r3.pitchDelta !== void 0 && (n4.pitch = o3), r3.bearingDelta !== void 0 && (n4.rotate = o3);
        }
        _applyChanges() {
          let e6 = {}, n4 = {}, r3 = {};
          for (let [i3, a3, o3] of this._changes) i3.panDelta && (e6.panDelta = (e6.panDelta || new t4.P(0, 0))._add(i3.panDelta)), i3.zoomDelta && (e6.zoomDelta = (e6.zoomDelta || 0) + i3.zoomDelta), i3.bearingDelta && (e6.bearingDelta = (e6.bearingDelta || 0) + i3.bearingDelta), i3.pitchDelta && (e6.pitchDelta = (e6.pitchDelta || 0) + i3.pitchDelta), i3.rollDelta && (e6.rollDelta = (e6.rollDelta || 0) + i3.rollDelta), i3.around !== void 0 && (e6.around = i3.around), i3.pinchAround !== void 0 && (e6.pinchAround = i3.pinchAround), i3.noInertia && (e6.noInertia = i3.noInertia), t4.e(n4, a3), t4.e(r3, o3);
          this._updateMapTransform(e6, n4, r3), this._changes = [];
        }
        _updateMapTransform(e6, t5, n4) {
          let r3 = this._map, i3 = r3._getTransformForUpdate(), a3 = r3.terrain;
          if (!(Ia(e6) || a3 && this._terrainMovement)) return this._fireEvents(t5, n4, true);
          r3._stop(true);
          let { panDelta: o3, zoomDelta: s3, bearingDelta: c3, pitchDelta: l3, rollDelta: u3, around: d3, pinchAround: f3 } = e6;
          f3 !== void 0 && (d3 = f3), d3 || (d3 = r3.transform.centerPoint), a3 && !i3.isPointOnMapSurface(d3) && (d3 = i3.centerPoint);
          let p3 = { panDelta: o3, zoomDelta: s3, rollDelta: u3, pitchDelta: l3, bearingDelta: c3, around: d3 };
          this._map.cameraHelper.useGlobeControls && !i3.isPointOnMapSurface(d3) && (d3 = i3.centerPoint);
          let m3 = d3.distSqr(i3.centerPoint) < 0.01 ? i3.center : i3.screenPointToLocation(o3 ? d3.sub(o3) : d3);
          this._handleMapControls({ terrain: a3, tr: i3, deltasForHelper: p3, preZoomAroundLoc: m3, combinedEventsInProgress: t5, panDelta: o3 }), r3._applyUpdatedTransform(i3), this._map._update(), e6.noInertia || this._inertia.record(e6), this._fireEvents(t5, n4, true);
        }
        _handleMapControls({ terrain: e6, tr: t5, deltasForHelper: n4, preZoomAroundLoc: r3, combinedEventsInProgress: i3, panDelta: a3 }) {
          let o3 = this._map.cameraHelper;
          if (o3.handleMapControlsRollPitchBearingZoom(n4, t5), e6) return o3.useGlobeControls ? (this._terrainMovement || !i3.drag && !i3.zoom || (this._terrainMovement = true, this._map._elevationFreeze = true), void o3.handleMapControlsPan(n4, t5, r3)) : this._terrainMovement || !i3.drag && !i3.zoom ? void (i3.drag && this._terrainMovement && a3 ? t5.setCenter(t5.screenPointToLocation(t5.centerPoint.sub(a3))) : o3.handleMapControlsPan(n4, t5, r3)) : (this._terrainMovement = true, this._map._elevationFreeze = true, void o3.handleMapControlsPan(n4, t5, r3));
          o3.handleMapControlsPan(n4, t5, r3);
        }
        _fireEvents(e6, n4, r3) {
          let i3 = Pa(this._eventsInProgress), a3 = Pa(e6), s3 = {};
          for (let t5 in e6) {
            let { originalEvent: n5 } = e6[t5];
            this._eventsInProgress[t5] || (s3[`${t5}start`] = n5), this._eventsInProgress[t5] = e6[t5];
          }
          for (let e7 in !i3 && a3 && this._fireEvent(`movestart`, a3.originalEvent), s3) this._fireEvent(e7, s3[e7]);
          for (let t5 in a3 && this._fireEvent(`move`, a3.originalEvent), e6) {
            let { originalEvent: n5 } = e6[t5];
            this._fireEvent(t5, n5);
          }
          let c3 = {}, l3;
          for (let e7 in this._eventsInProgress) {
            let { handlerName: t5, originalEvent: r4 } = this._eventsInProgress[e7];
            this._handlersById[t5].isActive() || (delete this._eventsInProgress[e7], l3 = n4[t5] || r4, c3[`${e7}end`] = l3);
          }
          for (let e7 in c3) this._fireEvent(e7, c3[e7]);
          let u3 = Pa(this._eventsInProgress), d3 = (i3 || a3) && !u3;
          if (d3 && this._terrainMovement) {
            this._map._elevationFreeze = false, this._terrainMovement = false;
            let e7 = this._map._getTransformForUpdate();
            this._map.getCenterClampedToGround() && e7.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(e7);
          }
          if (r3 && d3) {
            this._updatingCamera = true;
            let e7 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), n5 = (e8) => e8 !== 0 && -this._bearingSnap < e8 && e8 < this._bearingSnap;
            !e7 || !e7.essential && o2.prefersReducedMotion ? (this._map.fire(new t4.l(`moveend`, { originalEvent: l3 })), n5(this._map.getBearing()) && this._map.resetNorth()) : (n5(e7.bearing || this._map.getBearing()) && (e7.bearing = 0), e7.freezeElevation = true, this._map.easeTo(e7, { originalEvent: l3 })), this._updatingCamera = false;
          }
        }
        _fireEvent(e6, n4) {
          this._map.fire(new t4.l(e6, n4 ? { originalEvent: n4 } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add(((e6) => {
            delete this._frameId, this.handleEvent(new Fa(`renderFrame`, { timeStamp: e6 })), this._applyChanges();
          }));
        }
        _triggerRenderFrame() {
          this._frameId === void 0 && (this._frameId = this._requestFrame());
        }
      }
      class Ra extends t4.E {
        constructor(e6, t5, n4) {
          super(), this._renderFrameCallback = () => {
            let e7 = Math.min((c2() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(e7)), e7 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }, this._moving = false, this._zooming = false, this.transform = e6, this._bearingSnap = n4.bearingSnap, this.cameraHelper = t5, this.on(`moveend`, (() => {
            delete this._requestedCameraState;
          }));
        }
        migrateProjection(e6, t5) {
          e6.apply(this.transform), this.transform = e6, this.cameraHelper = t5;
        }
        getCenter() {
          return new t4.U(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(e6, t5) {
          return this.jumpTo({ center: e6 }, t5);
        }
        getCenterElevation() {
          return this.transform.elevation;
        }
        setCenterElevation(e6, t5) {
          return this.jumpTo({ elevation: e6 }, t5), this;
        }
        getCenterClampedToGround() {
          return this._centerClampedToGround;
        }
        setCenterClampedToGround(e6) {
          this._centerClampedToGround = e6;
        }
        panBy(e6, n4, r3) {
          return e6 = t4.P.convert(e6).mult(-1), this.panTo(this.transform.center, t4.e({ offset: e6 }, n4), r3);
        }
        panTo(e6, n4, r3) {
          return this.easeTo(t4.e({ center: e6 }, n4), r3);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(e6, t5) {
          return this.jumpTo({ zoom: e6 }, t5), this;
        }
        zoomTo(e6, n4, r3) {
          return this.easeTo(t4.e({ zoom: e6 }, n4), r3);
        }
        zoomIn(e6, t5) {
          return this.zoomTo(this.getZoom() + 1, e6, t5), this;
        }
        zoomOut(e6, t5) {
          return this.zoomTo(this.getZoom() - 1, e6, t5), this;
        }
        getVerticalFieldOfView() {
          return this.transform.fov;
        }
        setVerticalFieldOfView(e6, n4) {
          return e6 != this.transform.fov && (this.transform.setFov(e6), this.fire(new t4.l(`movestart`, n4)).fire(new t4.l(`move`, n4)).fire(new t4.l(`moveend`, n4))), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(e6, t5) {
          return this.jumpTo({ bearing: e6 }, t5), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(e6, t5) {
          return this.jumpTo({ padding: e6 }, t5), this;
        }
        rotateTo(e6, n4, r3) {
          return this.easeTo(t4.e({ bearing: e6 }, n4), r3);
        }
        resetNorth(e6, n4) {
          return this.rotateTo(0, t4.e({ duration: 1e3 }, e6), n4), this;
        }
        resetNorthPitch(e6, n4) {
          return this.easeTo(t4.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e6), n4), this;
        }
        snapToNorth(e6, t5) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e6, t5) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(e6, t5) {
          return this.jumpTo({ pitch: e6 }, t5), this;
        }
        getRoll() {
          return this.transform.roll;
        }
        setRoll(e6, t5) {
          return this.jumpTo({ roll: e6 }, t5), this;
        }
        cameraForBounds(e6, t5) {
          e6 = ue2.convert(e6).adjustAntiMeridian();
          let n4 = t5 && t5.bearing || 0;
          return this._cameraForBoxAndBearing(e6.getNorthWest(), e6.getSouthEast(), n4, t5);
        }
        _cameraForBoxAndBearing(e6, n4, r3, i3) {
          let a3 = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (i3 = t4.e({ padding: a3, offset: [0, 0], maxZoom: this.transform.maxZoom }, i3)).padding == `number`) {
            let e7 = i3.padding;
            i3.padding = { top: e7, bottom: e7, right: e7, left: e7 };
          }
          let o3 = t4.e(a3, i3.padding);
          i3.padding = o3;
          let s3 = this.transform, c3 = new ue2(e6, n4);
          return this.cameraHelper.cameraForBoxAndBearing(i3, o3, c3, r3, s3);
        }
        fitBounds(e6, t5, n4) {
          return this._fitInternal(this.cameraForBounds(e6, t5), t5, n4);
        }
        fitScreenCoordinates(e6, n4, r3, i3, a3) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(t4.P.convert(e6)), this.transform.screenPointToLocation(t4.P.convert(n4)), r3, i3), i3, a3);
        }
        _fitInternal(e6, n4, r3) {
          return e6 ? (delete (n4 = t4.e(e6, n4)).padding, n4.linear ? this.easeTo(n4, r3) : this.flyTo(n4, r3)) : this;
        }
        jumpTo(e6, n4) {
          this.stop();
          let r3 = this._getTransformForUpdate(), i3 = false, a3 = false, o3 = false, s3 = r3.zoom;
          this.cameraHelper.handleJumpToCenterZoom(r3, e6);
          let c3 = r3.zoom !== s3;
          return `elevation` in e6 && r3.elevation !== +e6.elevation && r3.setElevation(+e6.elevation), `bearing` in e6 && r3.bearing !== +e6.bearing && (i3 = true, r3.setBearing(+e6.bearing)), `pitch` in e6 && r3.pitch !== +e6.pitch && (a3 = true, r3.setPitch(+e6.pitch)), `roll` in e6 && r3.roll !== +e6.roll && (o3 = true, r3.setRoll(+e6.roll)), e6.padding == null || r3.isPaddingEqual(e6.padding) || r3.setPadding(e6.padding), this._applyUpdatedTransform(r3), this.fire(new t4.l(`movestart`, n4)).fire(new t4.l(`move`, n4)), c3 && this.fire(new t4.l(`zoomstart`, n4)).fire(new t4.l(`zoom`, n4)).fire(new t4.l(`zoomend`, n4)), i3 && this.fire(new t4.l(`rotatestart`, n4)).fire(new t4.l(`rotate`, n4)).fire(new t4.l(`rotateend`, n4)), a3 && this.fire(new t4.l(`pitchstart`, n4)).fire(new t4.l(`pitch`, n4)).fire(new t4.l(`pitchend`, n4)), o3 && this.fire(new t4.l(`rollstart`, n4)).fire(new t4.l(`roll`, n4)).fire(new t4.l(`rollend`, n4)), this.fire(new t4.l(`moveend`, n4));
        }
        calculateCameraOptionsFromTo(e6, n4, r3, i3 = 0) {
          let a3 = t4.a5.fromLngLat(e6, n4), o3 = t4.a5.fromLngLat(r3, i3), s3 = o3.x - a3.x, c3 = o3.y - a3.y, l3 = o3.z - a3.z, u3 = Math.hypot(s3, c3, l3);
          if (u3 === 0) throw Error(`Can't calculate camera options with same From and To`);
          let d3 = Math.hypot(s3, c3), f3 = t4.ao(this.transform.cameraToCenterDistance / u3 / this.transform.tileSize), p3 = 180 * Math.atan2(s3, -c3) / Math.PI, m3 = 180 * Math.acos(d3 / u3) / Math.PI;
          return m3 = l3 < 0 ? 90 - m3 : 90 + m3, { center: o3.toLngLat(), elevation: i3, zoom: f3, pitch: m3, bearing: p3 };
        }
        calculateCameraOptionsFromCameraLngLatAltRotation(e6, t5, n4, r3, i3) {
          let a3 = this.transform.calculateCenterFromCameraLngLatAlt(e6, t5, n4, r3);
          return { center: a3.center, elevation: a3.elevation, zoom: a3.zoom, bearing: n4, pitch: r3, roll: i3 };
        }
        easeTo(e6, n4) {
          this._stop(false, e6.easeId), (false === (e6 = t4.e({ offset: [0, 0], duration: 500, easing: t4.cr }, e6)).animate || !e6.essential && o2.prefersReducedMotion) && (e6.duration = 0);
          let r3 = this._getTransformForUpdate(), i3 = this.getBearing(), a3 = r3.pitch, s3 = r3.roll, c3 = `bearing` in e6 ? this._normalizeBearing(e6.bearing, i3) : i3, l3 = `pitch` in e6 ? +e6.pitch : a3, u3 = `roll` in e6 ? this._normalizeBearing(e6.roll, s3) : s3, d3 = `padding` in e6 ? e6.padding : r3.padding, f3 = t4.P.convert(e6.offset), p3, m3;
          e6.around && (p3 = t4.U.convert(e6.around), m3 = r3.locationToScreenPoint(p3));
          let h3 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, g3 = this.cameraHelper.handleEaseTo(r3, { bearing: c3, pitch: l3, roll: u3, padding: d3, around: p3, aroundPoint: m3, offsetAsPoint: f3, offset: e6.offset, zoom: e6.zoom, center: e6.center });
          return this._rotating = this._rotating || i3 !== c3, this._pitching = this._pitching || l3 !== a3, this._rolling = this._rolling || u3 !== s3, this._padding = !r3.isPaddingEqual(d3), this._zooming = this._zooming || g3.isZooming, this._easeId = e6.easeId, this._prepareEase(n4, e6.noMoveStart, h3), this.terrain && this._prepareElevation(g3.elevationCenter), this._ease(((t5) => {
            g3.easeFunc(t5), this.terrain && !e6.freezeElevation && this._updateElevation(t5), this._applyUpdatedTransform(r3), this._fireMoveEvents(n4);
          }), ((t5) => {
            this.terrain && e6.freezeElevation && this._finalizeElevation(), this._afterEase(n4, t5);
          }), e6), this;
        }
        _prepareEase(e6, n4, r3 = {}) {
          this._moving = true, n4 || r3.moving || this.fire(new t4.l(`movestart`, e6)), this._zooming && !r3.zooming && this.fire(new t4.l(`zoomstart`, e6)), this._rotating && !r3.rotating && this.fire(new t4.l(`rotatestart`, e6)), this._pitching && !r3.pitching && this.fire(new t4.l(`pitchstart`, e6)), this._rolling && !r3.rolling && this.fire(new t4.l(`rollstart`, e6));
        }
        _prepareElevation(e6) {
          this._elevationCenter = e6, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e6, this.transform.tileZoom), this._elevationFreeze = true;
        }
        _updateElevation(e6) {
          this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
          let n4 = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          if (e6 < 1 && n4 !== this._elevationTarget) {
            let t5 = this._elevationTarget - this._elevationStart;
            this._elevationStart += e6 * (t5 - (n4 - (t5 * e6 + this._elevationStart)) / (1 - e6)), this._elevationTarget = n4;
          }
          this.transform.setElevation(t4.F.number(this._elevationStart, this._elevationTarget, e6));
        }
        _finalizeElevation() {
          this._elevationFreeze = false, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
        }
        _getTransformForUpdate() {
          return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
        }
        _elevateCameraIfInsideTerrain(e6) {
          if (!this.terrain && e6.elevation >= 0 && e6.pitch <= 90) return {};
          let t5 = e6.getCameraLngLat(), n4 = e6.getCameraAltitude(), r3 = this.terrain ? this.terrain.getElevationForLngLatZoom(t5, e6.zoom) : 0;
          if (n4 < r3) {
            let n5 = this.calculateCameraOptionsFromTo(t5, r3, e6.center, e6.elevation);
            return { pitch: n5.pitch, zoom: n5.zoom };
          }
          return {};
        }
        _applyUpdatedTransform(e6) {
          let t5 = [];
          if (t5.push(((e7) => this._elevateCameraIfInsideTerrain(e7))), this.transformCameraUpdate && t5.push(((e7) => this.transformCameraUpdate(e7))), !t5.length) return;
          let n4 = e6.clone();
          for (let e7 of t5) {
            let t6 = n4.clone(), { center: r3, zoom: i3, roll: a3, pitch: o3, bearing: s3, elevation: c3 } = e7(t6);
            r3 && t6.setCenter(r3), c3 !== void 0 && t6.setElevation(c3), i3 !== void 0 && t6.setZoom(i3), a3 !== void 0 && t6.setRoll(a3), o3 !== void 0 && t6.setPitch(o3), s3 !== void 0 && t6.setBearing(s3), n4.apply(t6);
          }
          this.transform.apply(n4);
        }
        _fireMoveEvents(e6) {
          this.fire(new t4.l(`move`, e6)), this._zooming && this.fire(new t4.l(`zoom`, e6)), this._rotating && this.fire(new t4.l(`rotate`, e6)), this._pitching && this.fire(new t4.l(`pitch`, e6)), this._rolling && this.fire(new t4.l(`roll`, e6));
        }
        _afterEase(e6, n4) {
          if (this._easeId && n4 && this._easeId === n4) return;
          delete this._easeId;
          let r3 = this._zooming, i3 = this._rotating, a3 = this._pitching, o3 = this._rolling;
          this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._rolling = false, this._padding = false, r3 && this.fire(new t4.l(`zoomend`, e6)), i3 && this.fire(new t4.l(`rotateend`, e6)), a3 && this.fire(new t4.l(`pitchend`, e6)), o3 && this.fire(new t4.l(`rollend`, e6)), this.fire(new t4.l(`moveend`, e6));
        }
        flyTo(e6, n4) {
          if (!e6.essential && o2.prefersReducedMotion) {
            let r4 = t4.S(e6, [`center`, `zoom`, `bearing`, `pitch`, `roll`, `elevation`, `padding`]);
            return this.jumpTo(r4, n4);
          }
          this.stop(), e6 = t4.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t4.cr }, e6);
          let r3 = this._getTransformForUpdate(), i3 = r3.bearing, a3 = r3.pitch, s3 = r3.roll, c3 = r3.padding, l3 = `bearing` in e6 ? this._normalizeBearing(e6.bearing, i3) : i3, u3 = `pitch` in e6 ? +e6.pitch : a3, d3 = `roll` in e6 ? this._normalizeBearing(e6.roll, s3) : s3, f3 = `padding` in e6 ? e6.padding : r3.padding, p3 = t4.P.convert(e6.offset), m3 = r3.centerPoint.add(p3), h3 = r3.screenPointToLocation(m3), g3 = this.cameraHelper.handleFlyTo(r3, { bearing: l3, pitch: u3, roll: d3, padding: f3, locationAtOffset: h3, offsetAsPoint: p3, center: e6.center, minZoom: e6.minZoom, zoom: e6.zoom }), _3 = e6.curve, v3 = Math.max(r3.width, r3.height), y3 = v3 / g3.scaleOfZoom, b3 = g3.pixelPathLength;
          typeof g3.scaleOfMinZoom == `number` && (_3 = Math.sqrt(v3 / g3.scaleOfMinZoom / b3 * 2));
          let x3 = _3 * _3;
          function S3(e7) {
            let t5 = (y3 * y3 - v3 * v3 + (e7 ? -1 : 1) * x3 * x3 * b3 * b3) / (2 * (e7 ? y3 : v3) * x3 * b3);
            return Math.log(Math.sqrt(t5 * t5 + 1) - t5);
          }
          function C3(e7) {
            return (Math.exp(e7) - Math.exp(-e7)) / 2;
          }
          function w3(e7) {
            return (Math.exp(e7) + Math.exp(-e7)) / 2;
          }
          let T3 = S3(false), E3 = function(e7) {
            return w3(T3) / w3(T3 + _3 * e7);
          }, D3 = function(e7) {
            return v3 * ((w3(T3) * (C3(t5 = T3 + _3 * e7) / w3(t5)) - C3(T3)) / x3) / b3;
            var t5;
          }, O3 = (S3(true) - T3) / _3;
          if (Math.abs(b3) < 2e-6 || !isFinite(O3)) {
            if (Math.abs(v3 - y3) < 1e-6) return this.easeTo(e6, n4);
            let t5 = y3 < v3 ? -1 : 1;
            O3 = Math.abs(Math.log(y3 / v3)) / _3, D3 = () => 0, E3 = (e7) => Math.exp(t5 * _3 * e7);
          }
          return e6.duration = `duration` in e6 ? +e6.duration : 1e3 * O3 / (`screenSpeed` in e6 ? +e6.screenSpeed / _3 : +e6.speed), e6.maxDuration && e6.duration > e6.maxDuration && (e6.duration = 0), this._zooming = true, this._rotating = i3 !== l3, this._pitching = u3 !== a3, this._rolling = d3 !== s3, this._padding = !r3.isPaddingEqual(f3), this._prepareEase(n4, false), this.terrain && this._prepareElevation(g3.targetCenter), this._ease(((o3) => {
            let h4 = o3 * O3, _4 = 1 / E3(h4), v4 = D3(h4);
            this._rotating && r3.setBearing(t4.F.number(i3, l3, o3)), this._pitching && r3.setPitch(t4.F.number(a3, u3, o3)), this._rolling && r3.setRoll(t4.F.number(s3, d3, o3)), this._padding && (r3.interpolatePadding(c3, f3, o3), m3 = r3.centerPoint.add(p3)), g3.easeFunc(o3, _4, v4, m3), this.terrain && !e6.freezeElevation && this._updateElevation(o3), this._applyUpdatedTransform(r3), this._fireMoveEvents(n4);
          }), (() => {
            this.terrain && e6.freezeElevation && this._finalizeElevation(), this._afterEase(n4);
          }), e6), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(e6, t5) {
          var n4;
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            let e7 = this._onEaseEnd;
            delete this._onEaseEnd, e7.call(this, t5);
          }
          return e6 || (n4 = this.handlers) == null || n4.stop(false), this;
        }
        _ease(e6, t5, n4) {
          false === n4.animate || n4.duration === 0 ? (e6(1), t5()) : (this._easeStart = c2(), this._easeOptions = n4, this._onEaseFrame = e6, this._onEaseEnd = t5, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _normalizeBearing(e6, n4) {
          e6 = t4.V(e6, -180, 180);
          let r3 = Math.abs(e6 - n4);
          return Math.abs(e6 - 360 - n4) < r3 && (e6 -= 360), Math.abs(e6 + 360 - n4) < r3 && (e6 += 360), e6;
        }
        queryTerrainElevation(e6) {
          return this.terrain ? this.terrain.getElevationForLngLatZoom(t4.U.convert(e6), this.transform.tileZoom) : null;
        }
      }
      let Q = { compact: true, customAttribution: `<a href="https://maplibre.org/" target="_blank">MapLibre</a>` };
      class $ {
        constructor(e6 = Q) {
          this._toggleAttribution = () => {
            this._container.classList.contains(`maplibregl-compact`) && (this._container.classList.contains(`maplibregl-compact-show`) ? (this._container.setAttribute(`open`, ``), this._container.classList.remove(`maplibregl-compact-show`)) : (this._container.classList.add(`maplibregl-compact-show`), this._container.removeAttribute(`open`)));
          }, this._updateData = (e7) => {
            !e7 || e7.sourceDataType !== `metadata` && e7.sourceDataType !== `visibility` && e7.dataType !== `style` && e7.type !== `terrain` || this._updateAttributions();
          }, this._updateCompact = () => {
            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false === this._compact ? this._container.setAttribute(`open`, ``) : this._container.classList.contains(`maplibregl-compact`) || this._container.classList.contains(`maplibregl-attrib-empty`) || (this._container.setAttribute(`open`, ``), this._container.classList.add(`maplibregl-compact`, `maplibregl-compact-show`)) : (this._container.setAttribute(`open`, ``), this._container.classList.contains(`maplibregl-compact`) && this._container.classList.remove(`maplibregl-compact`, `maplibregl-compact-show`));
          }, this._updateCompactMinimize = () => {
            this._container.classList.contains(`maplibregl-compact`) && this._container.classList.contains(`maplibregl-compact-show`) && this._container.classList.remove(`maplibregl-compact-show`);
          }, this.options = e6;
        }
        getDefaultPosition() {
          return `bottom-right`;
        }
        onAdd(e6) {
          return this._map = e6, this._compact = this.options.compact, this._container = l2.create(`details`, `maplibregl-ctrl maplibregl-ctrl-attrib`), this._compactButton = l2.create(`summary`, `maplibregl-ctrl-attrib-button`, this._container), this._compactButton.addEventListener(`click`, this._toggleAttribution), this._setElementTitle(this._compactButton, `ToggleAttribution`), this._innerContainer = l2.create(`div`, `maplibregl-ctrl-attrib-inner`, this._container), this._updateAttributions(), this._updateCompact(), this._map.on(`styledata`, this._updateData), this._map.on(`sourcedata`, this._updateData), this._map.on(`terrain`, this._updateData), this._map.on(`resize`, this._updateCompact), this._map.on(`drag`, this._updateCompactMinimize), this._container;
        }
        onRemove() {
          l2.remove(this._container), this._map.off(`styledata`, this._updateData), this._map.off(`sourcedata`, this._updateData), this._map.off(`terrain`, this._updateData), this._map.off(`resize`, this._updateCompact), this._map.off(`drag`, this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
        }
        _setElementTitle(e6, t5) {
          let n4 = this._map._getUIString(`AttributionControl.${t5}`);
          e6.title = n4, e6.setAttribute(`aria-label`, n4);
        }
        _updateAttributions() {
          if (!this._map.style) return;
          let e6 = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e6 = e6.concat(this.options.customAttribution.map(((e7) => typeof e7 == `string` ? e7 : ``))) : typeof this.options.customAttribution == `string` && e6.push(this.options.customAttribution)), this._map.style.stylesheet) {
            let e7 = this._map.style.stylesheet;
            this.styleOwner = e7.owner, this.styleId = e7.id;
          }
          let t5 = this._map.style.tileManagers;
          for (let n5 in t5) {
            let r3 = t5[n5];
            if (r3.used || r3.usedForTerrain) {
              let t6 = r3.getSource();
              t6.attribution && e6.indexOf(t6.attribution) < 0 && e6.push(t6.attribution);
            }
          }
          e6 = e6.filter(((e7) => String(e7).trim())), e6.sort(((e7, t6) => e7.length - t6.length)), e6 = e6.filter(((t6, n5) => {
            for (let r3 = n5 + 1; r3 < e6.length; r3++) if (e6[r3].indexOf(t6) >= 0) return false;
            return true;
          }));
          let n4 = e6.join(` | `);
          n4 !== this._attribHTML && (this._attribHTML = n4, e6.length ? (this._innerContainer.innerHTML = l2.sanitize(n4), this._container.classList.remove(`maplibregl-attrib-empty`)) : this._container.classList.add(`maplibregl-attrib-empty`), this._updateCompact(), this._editLink = null);
        }
      }
      class za {
        constructor(e6 = {}) {
          this._updateCompact = () => {
            let e7 = this._container.children;
            if (e7.length) {
              let t5 = e7[0];
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false !== this._compact && t5.classList.add(`maplibregl-compact`) : t5.classList.remove(`maplibregl-compact`);
            }
          }, this.options = e6;
        }
        getDefaultPosition() {
          return `bottom-left`;
        }
        onAdd(e6) {
          this._map = e6, this._compact = this.options && this.options.compact, this._container = l2.create(`div`, `maplibregl-ctrl`);
          let t5 = l2.create(`a`, `maplibregl-ctrl-logo`);
          return t5.target = `_blank`, t5.rel = `noopener nofollow`, t5.href = `https://maplibre.org/`, t5.setAttribute(`aria-label`, this._map._getUIString(`LogoControl.Title`)), t5.setAttribute(`rel`, `noopener nofollow`), this._container.appendChild(t5), this._container.style.display = `block`, this._map.on(`resize`, this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          l2.remove(this._container), this._map.off(`resize`, this._updateCompact), this._map = void 0, this._compact = void 0;
        }
      }
      class Ba {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
        }
        add(e6) {
          let t5 = ++this._id;
          return this._queue.push({ callback: e6, id: t5, cancelled: false }), t5;
        }
        remove(e6) {
          let t5 = this._currentlyRunning, n4 = t5 ? this._queue.concat(t5) : this._queue;
          for (let t6 of n4) if (t6.id === e6) return void (t6.cancelled = true);
        }
        run(e6 = 0) {
          if (this._currentlyRunning) throw Error(`Attempting to run(), but is already running.`);
          let t5 = this._currentlyRunning = this._queue;
          this._queue = [];
          for (let n4 of t5) if (!n4.cancelled && (n4.callback(e6), this._cleared)) break;
          this._cleared = false, this._currentlyRunning = false;
        }
        clear() {
          this._currentlyRunning && (this._cleared = true), this._queue = [];
        }
      }
      var Va = t4.aN([{ name: `a_pos3d`, type: `Int16`, components: 3 }]);
      class Ha extends t4.E {
        constructor(e6) {
          super(), this._lastTilesetChange = c2(), this.tileManager = e6, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e6._source.tileSize * 2 ** this.deltaZoom, e6.usedForTerrain = true, e6.tileSize = this.tileSize;
        }
        destruct() {
          this.tileManager.usedForTerrain = false, this.tileManager.tileSize = null;
        }
        getSource() {
          return this.tileManager._source;
        }
        update(e6, n4) {
          this.tileManager.update(e6, n4), this._renderableTilesKeys = [];
          let r3 = {};
          for (let i3 of Be2(e6, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: n4, calculateTileZoom: this.tileManager._source.calculateTileZoom })) r3[i3.key] = true, this._renderableTilesKeys.push(i3.key), this._tiles[i3.key] || (i3.terrainRttPosMatrix32f = new Float64Array(16), t4.c0(i3.terrainRttPosMatrix32f, 0, t4.a3, t4.a3, 0, 0, 1), this._tiles[i3.key] = new De2(i3, this.tileSize), this._lastTilesetChange = c2());
          for (let e7 in this._tiles) r3[e7] || delete this._tiles[e7];
        }
        freeRtt(e6) {
          for (let t5 in this._tiles) {
            let n4 = this._tiles[t5];
            (!e6 || n4.tileID.equals(e6) || n4.tileID.isChildOf(e6) || e6.isChildOf(n4.tileID)) && (n4.rtt = []);
          }
        }
        getRenderableTiles() {
          return this._renderableTilesKeys.map(((e6) => this.getTileByID(e6)));
        }
        getTileByID(e6) {
          return this._tiles[e6];
        }
        getTerrainCoords(e6, t5) {
          return t5 ? this._getTerrainCoordsForTileRanges(e6, t5) : this._getTerrainCoordsForRegularTile(e6);
        }
        _getTerrainCoordsForRegularTile(e6) {
          let n4 = {};
          for (let r3 of this._renderableTilesKeys) {
            let i3 = this._tiles[r3].tileID, a3 = e6.clone(), o3 = t4.bd();
            if (i3.canonical.equals(e6.canonical)) t4.c0(o3, 0, t4.a3, t4.a3, 0, 0, 1);
            else if (i3.canonical.isChildOf(e6.canonical)) {
              let n5 = i3.canonical.z - e6.canonical.z, r4 = i3.canonical.x - (i3.canonical.x >> n5 << n5), a4 = i3.canonical.y - (i3.canonical.y >> n5 << n5), s3 = t4.a3 >> n5;
              t4.c0(o3, 0, s3, s3, 0, 0, 1), t4.N(o3, o3, [-r4 * s3, -a4 * s3, 0]);
            } else {
              if (!e6.canonical.isChildOf(i3.canonical)) continue;
              {
                let n5 = e6.canonical.z - i3.canonical.z, r4 = e6.canonical.x - (e6.canonical.x >> n5 << n5), a4 = e6.canonical.y - (e6.canonical.y >> n5 << n5), s3 = t4.a3 >> n5;
                t4.c0(o3, 0, t4.a3, t4.a3, 0, 0, 1), t4.N(o3, o3, [r4 * s3, a4 * s3, 0]), t4.O(o3, o3, [1 / 2 ** n5, 1 / 2 ** n5, 0]);
              }
            }
            a3.terrainRttPosMatrix32f = new Float32Array(o3), n4[r3] = a3;
          }
          return n4;
        }
        _getTerrainCoordsForTileRanges(e6, n4) {
          let r3 = {};
          for (let i3 of this._renderableTilesKeys) {
            let a3 = this._tiles[i3].tileID;
            if (!this._isWithinTileRanges(a3, n4)) continue;
            let o3 = e6.clone(), s3 = t4.bd();
            if (a3.canonical.z === e6.canonical.z) {
              let n5 = e6.canonical.x - a3.canonical.x, r4 = e6.canonical.y - a3.canonical.y;
              t4.c0(s3, 0, t4.a3, t4.a3, 0, 0, 1), t4.N(s3, s3, [n5 * t4.a3, r4 * t4.a3, 0]);
            } else if (a3.canonical.z > e6.canonical.z) {
              let n5 = a3.canonical.z - e6.canonical.z, r4 = a3.canonical.x - (a3.canonical.x >> n5 << n5), i4 = a3.canonical.y - (a3.canonical.y >> n5 << n5), o4 = e6.canonical.x - (a3.canonical.x >> n5), c3 = e6.canonical.y - (a3.canonical.y >> n5), l3 = t4.a3 >> n5;
              t4.c0(s3, 0, l3, l3, 0, 0, 1), t4.N(s3, s3, [-r4 * l3 + o4 * t4.a3, -i4 * l3 + c3 * t4.a3, 0]);
            } else {
              let n5 = e6.canonical.z - a3.canonical.z, r4 = e6.canonical.x - (e6.canonical.x >> n5 << n5), i4 = e6.canonical.y - (e6.canonical.y >> n5 << n5), o4 = (e6.canonical.x >> n5) - a3.canonical.x, c3 = (e6.canonical.y >> n5) - a3.canonical.y, l3 = t4.a3 << n5;
              t4.c0(s3, 0, l3, l3, 0, 0, 1), t4.N(s3, s3, [r4 * t4.a3 + o4 * l3, i4 * t4.a3 + c3 * l3, 0]);
            }
            o3.terrainRttPosMatrix32f = new Float32Array(s3), r3[i3] = o3;
          }
          return r3;
        }
        getSourceTile(e6, t5) {
          let n4 = this.tileManager._source, r3 = e6.overscaledZ - this.deltaZoom;
          if (r3 > n4.maxzoom && (r3 = n4.maxzoom), r3 < n4.minzoom) return null;
          this._sourceTileCache[e6.key] || (this._sourceTileCache[e6.key] = e6.scaledTo(r3).key);
          let i3 = this.tileManager.getTileByID(this._sourceTileCache[e6.key]);
          if ((!i3 || !i3.dem) && t5) for (; r3 >= n4.minzoom && (!i3 || !i3.dem); ) i3 = this.tileManager.getTileByID(e6.scaledTo(r3--).key);
          return i3;
        }
        anyTilesAfterTime(e6 = Date.now()) {
          return this._lastTilesetChange >= e6;
        }
        _isWithinTileRanges(e6, t5) {
          return t5[e6.canonical.z] && e6.canonical.x >= t5[e6.canonical.z].minTileX && e6.canonical.x <= t5[e6.canonical.z].maxTileX && e6.canonical.y >= t5[e6.canonical.z].minTileY && e6.canonical.y <= t5[e6.canonical.z].maxTileY;
        }
      }
      class Ua {
        constructor(e6, t5, n4) {
          this._meshCache = {}, this.painter = e6, this.tileManager = new Ha(t5), this.options = n4, this.exaggeration = typeof n4.exaggeration == `number` ? n4.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
        }
        getDEMElevation(e6, n4, r3, i3 = t4.a3) {
          var _a3;
          if (!(n4 >= 0 && n4 < i3 && r3 >= 0 && r3 < i3)) return 0;
          let a3 = this.getTerrainData(e6), o3 = (_a3 = a3.tile) == null ? void 0 : _a3.dem;
          if (!o3) return 0;
          let s3 = t4.cv([], [n4 / i3 * t4.a3, r3 / i3 * t4.a3], a3.u_terrain_matrix), c3 = [s3[0] * o3.dim, s3[1] * o3.dim], l3 = Math.floor(c3[0]), u3 = Math.floor(c3[1]), d3 = c3[0] - l3, f3 = c3[1] - u3;
          return o3.get(l3, u3) * (1 - d3) * (1 - f3) + o3.get(l3 + 1, u3) * d3 * (1 - f3) + o3.get(l3, u3 + 1) * (1 - d3) * f3 + o3.get(l3 + 1, u3 + 1) * d3 * f3;
        }
        getElevationForLngLatZoom(e6, n4) {
          if (!t4.cw(n4, e6.wrap())) return 0;
          let { tileID: r3, mercatorX: i3, mercatorY: a3 } = this._getOverscaledTileIDFromLngLatZoom(e6, n4);
          return this.getElevation(r3, i3 % t4.a3, a3 % t4.a3, t4.a3);
        }
        getElevation(e6, n4, r3, i3 = t4.a3) {
          return this.getDEMElevation(e6, n4, r3, i3) * this.exaggeration;
        }
        getTerrainData(e6) {
          if (!this._emptyDemTexture) {
            let e7 = this.painter.context, n5 = new t4.R({ width: 1, height: 1 }, new Uint8Array(4));
            this._emptyDepthTexture = new t4.T(e7, n5, e7.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new t4.T(e7, new t4.R({ width: 1, height: 1 }), e7.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(e7.gl.NEAREST, e7.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t4.am([]);
          }
          let n4 = this.tileManager.getSourceTile(e6, true);
          if (n4 && n4.dem && (!n4.demTexture || n4.needsTerrainPrepare)) {
            let e7 = this.painter.context;
            n4.demTexture = this.painter.getTileTexture(n4.dem.stride), n4.demTexture ? n4.demTexture.update(n4.dem.getPixels(), { premultiply: false }) : n4.demTexture = new t4.T(e7, n4.dem.getPixels(), e7.gl.RGBA, { premultiply: false }), n4.demTexture.bind(e7.gl.NEAREST, e7.gl.CLAMP_TO_EDGE), n4.needsTerrainPrepare = false;
          }
          let r3 = n4 && n4 + n4.tileID.key + e6.key;
          if (r3 && !this._demMatrixCache[r3]) {
            let r4 = this.tileManager.getSource().maxzoom, i3 = e6.canonical.z - n4.tileID.canonical.z;
            e6.overscaledZ > e6.canonical.z && (e6.canonical.z >= r4 ? i3 = e6.canonical.z - r4 : t4.w(`cannot calculate elevation if elevation maxzoom > source.maxzoom`));
            let a3 = e6.canonical.x - (e6.canonical.x >> i3 << i3), o3 = e6.canonical.y - (e6.canonical.y >> i3 << i3), s3 = t4.cx(new Float64Array(16), [1 / (t4.a3 << i3), 1 / (t4.a3 << i3), 0]);
            t4.N(s3, s3, [a3 * t4.a3, o3 * t4.a3, 0]), this._demMatrixCache[e6.key] = { matrix: s3, coord: e6 };
          }
          return { u_depth: 2, u_terrain: 3, u_terrain_dim: n4 && n4.dem && n4.dem.dim || 1, u_terrain_matrix: r3 ? this._demMatrixCache[e6.key].matrix : this._emptyDemMatrix, u_terrain_unpack: n4 && n4.dem && n4.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (n4 && n4.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: n4 };
        }
        getFramebuffer(e6) {
          let n4 = this.painter, r3 = n4.width / devicePixelRatio, i3 = n4.height / devicePixelRatio;
          return !this._fbo || this._fbo.width === r3 && this._fbo.height === i3 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new t4.T(n4.context, { width: r3, height: i3, data: null }, n4.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(n4.context.gl.NEAREST, n4.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new t4.T(n4.context, { width: r3, height: i3, data: null }, n4.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(n4.context.gl.NEAREST, n4.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = n4.context.createFramebuffer(r3, i3, true, false), this._fbo.depthAttachment.set(n4.context.createRenderbuffer(n4.context.gl.DEPTH_COMPONENT16, r3, i3))), this._fbo.colorAttachment.set(e6 === `coords` ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
        }
        getCoordsTexture() {
          let e6 = this.painter.context;
          if (this._coordsTexture) return this._coordsTexture;
          let n4 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
          for (let e7 = 0, t5 = 0; e7 < this._coordsTextureSize; e7++) for (let r4 = 0; r4 < this._coordsTextureSize; r4++, t5 += 4) n4[t5 + 0] = 255 & r4, n4[t5 + 1] = 255 & e7, n4[t5 + 2] = r4 >> 8 << 4 | e7 >> 8, n4[t5 + 3] = 0;
          let r3 = new t4.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(n4.buffer)), i3 = new t4.T(e6, r3, e6.gl.RGBA, { premultiply: false });
          return i3.bind(e6.gl.NEAREST, e6.gl.CLAMP_TO_EDGE), this._coordsTexture = i3, i3;
        }
        pointCoordinate(e6) {
          this.painter.maybeDrawDepthAndCoords(true);
          let n4 = new Uint8Array(4), r3 = this.painter.context, i3 = r3.gl, a3 = Math.round(e6.x * this.painter.pixelRatio / devicePixelRatio), o3 = Math.round(e6.y * this.painter.pixelRatio / devicePixelRatio), s3 = Math.round(this.painter.height / devicePixelRatio);
          r3.bindFramebuffer.set(this.getFramebuffer(`coords`).framebuffer), i3.readPixels(a3, s3 - o3 - 1, 1, 1, i3.RGBA, i3.UNSIGNED_BYTE, n4), r3.bindFramebuffer.set(null);
          let c3 = n4[0] + (n4[2] >> 4 << 8), l3 = n4[1] + ((15 & n4[2]) << 8), u3 = this.coordsIndex[255 - n4[3]], d3 = u3 && this.tileManager.getTileByID(u3);
          if (!d3) return null;
          let f3 = this._coordsTextureSize, p3 = (1 << d3.tileID.canonical.z) * f3;
          return new t4.a5((d3.tileID.canonical.x * f3 + c3) / p3 + d3.tileID.wrap, (d3.tileID.canonical.y * f3 + l3) / p3, this.getElevation(d3.tileID, c3, l3, f3));
        }
        depthAtPoint(e6) {
          let t5 = new Uint8Array(4), n4 = this.painter.context, r3 = n4.gl;
          return n4.bindFramebuffer.set(this.getFramebuffer(`depth`).framebuffer), r3.readPixels(e6.x, this.painter.height / devicePixelRatio - e6.y - 1, 1, 1, r3.RGBA, r3.UNSIGNED_BYTE, t5), n4.bindFramebuffer.set(null), (t5[0] / 16777216 + t5[1] / 65536 + t5[2] / 256 + t5[3]) / 256;
        }
        getTerrainMesh(e6) {
          var _a3;
          let n4 = ((_a3 = this.painter.style.projection) == null ? void 0 : _a3.transitionState) > 0, r3 = n4 && e6.canonical.y === 0, i3 = n4 && e6.canonical.y === (1 << e6.canonical.z) - 1, a3 = `m_${r3 ? `n` : ``}_${i3 ? `s` : ``}`;
          if (this._meshCache[a3]) return this._meshCache[a3];
          let o3 = this.painter.context, s3 = new t4.cy(), c3 = new t4.aR(), l3 = this.meshSize, u3 = t4.a3 / l3, d3 = l3 * l3;
          for (let e7 = 0; e7 <= l3; e7++) for (let t5 = 0; t5 <= l3; t5++) s3.emplaceBack(t5 * u3, e7 * u3, 0);
          for (let e7 = 0; e7 < d3; e7 += l3 + 1) for (let t5 = 0; t5 < l3; t5++) c3.emplaceBack(t5 + e7, l3 + t5 + e7 + 1, l3 + t5 + e7 + 2), c3.emplaceBack(t5 + e7, l3 + t5 + e7 + 2, t5 + e7 + 1);
          let f3 = s3.length, p3 = f3 + (l3 + 1), m3 = (l3 + 1) * l3, h3 = r3 ? t4.bk : 0, g3 = r3 ? 0 : 1, _3 = i3 ? t4.bl : t4.a3, v3 = i3 ? 0 : 1;
          for (let e7 = 0; e7 <= l3; e7++) s3.emplaceBack(e7 * u3, h3, g3);
          for (let e7 = 0; e7 <= l3; e7++) s3.emplaceBack(e7 * u3, _3, v3);
          for (let e7 = 0; e7 < l3; e7++) c3.emplaceBack(m3 + e7, p3 + e7, p3 + e7 + 1), c3.emplaceBack(m3 + e7, p3 + e7 + 1, m3 + e7 + 1), c3.emplaceBack(0 + e7, f3 + e7 + 1, f3 + e7), c3.emplaceBack(0 + e7, 0 + e7 + 1, f3 + e7 + 1);
          let y3 = s3.length, b3 = y3 + 2 * (l3 + 1);
          for (let e7 of [0, 1]) for (let n5 = 0; n5 <= l3; n5++) for (let r4 of [0, 1]) s3.emplaceBack(e7 * t4.a3, n5 * u3, r4);
          for (let e7 = 0; e7 < 2 * l3; e7 += 2) c3.emplaceBack(y3 + e7, y3 + e7 + 1, y3 + e7 + 3), c3.emplaceBack(y3 + e7, y3 + e7 + 3, y3 + e7 + 2), c3.emplaceBack(b3 + e7, b3 + e7 + 3, b3 + e7 + 1), c3.emplaceBack(b3 + e7, b3 + e7 + 2, b3 + e7 + 3);
          let x3 = new K2(o3.createVertexBuffer(s3, Va.members), o3.createIndexBuffer(c3), t4.aQ.simpleSegment(0, 0, s3.length, c3.length));
          return this._meshCache[a3] = x3, x3;
        }
        getMeshFrameDelta(e6) {
          return 2 * Math.PI * t4.bx / 2 ** Math.max(e6, 0) / 5;
        }
        getMinTileElevationForLngLatZoom(e6, t5) {
          let { tileID: n4 } = this._getOverscaledTileIDFromLngLatZoom(e6, t5);
          return this.getMinMaxElevation(n4).minElevation ?? 0;
        }
        getMinMaxElevation(e6) {
          let t5 = this.getTerrainData(e6).tile, n4 = { minElevation: null, maxElevation: null };
          return t5 && t5.dem && (n4.minElevation = t5.dem.min * this.exaggeration, n4.maxElevation = t5.dem.max * this.exaggeration), n4;
        }
        _getOverscaledTileIDFromLngLatZoom(e6, n4) {
          let r3 = t4.a5.fromLngLat(e6.wrap()), i3 = (1 << n4) * t4.a3, a3 = r3.x * i3, o3 = r3.y * i3, s3 = Math.floor(a3 / t4.a3), c3 = Math.floor(o3 / t4.a3);
          return { tileID: new t4.a0(n4, 0, n4, s3, c3), mercatorX: a3, mercatorY: o3 };
        }
      }
      class Wa {
        constructor(e6, t5, n4) {
          this._context = e6, this._size = t5, this._tileSize = n4, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
        }
        destruct() {
          for (let e6 of this._objects) e6.texture.destroy(), e6.fbo.destroy();
        }
        _createObject(e6) {
          let n4 = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), r3 = new t4.T(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
          return r3.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), n4.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), n4.colorAttachment.set(r3.texture), { id: e6, fbo: n4, texture: r3, stamp: -1, inUse: false };
        }
        getObjectForId(e6) {
          return this._objects[e6];
        }
        useObject(e6) {
          e6.inUse = true, this._recentlyUsed = this._recentlyUsed.filter(((t5) => e6.id !== t5)), this._recentlyUsed.push(e6.id);
        }
        stampObject(e6) {
          e6.stamp = ++this._stamp;
        }
        getOrCreateFreeObject() {
          for (let e7 of this._recentlyUsed) if (!this._objects[e7].inUse) return this._objects[e7];
          if (this._objects.length >= this._size) throw Error(`No free RenderPool available, call freeAllObjects() required!`);
          let e6 = this._createObject(this._objects.length);
          return this._objects.push(e6), e6;
        }
        freeObject(e6) {
          e6.inUse = false;
        }
        freeAllObjects() {
          for (let e6 of this._objects) this.freeObject(e6);
        }
        isFull() {
          return !(this._objects.length < this._size) && false === this._objects.some(((e6) => !e6.inUse));
        }
      }
      let Ga = { background: true, fill: true, line: true, raster: true, hillshade: true, "color-relief": true };
      class Ka {
        constructor(e6, t5) {
          this.painter = e6, this.terrain = t5, this.pool = new Wa(e6.context, 30, t5.tileManager.tileSize * t5.qualityFactor);
        }
        destruct() {
          this.pool.destruct();
        }
        getTexture(e6) {
          return this.pool.getObjectForId(e6.rtt[this._stacks.length - 1].id).texture;
        }
        prepareForRender(e6, t5) {
          for (let n4 in this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.tileManager.getRenderableTiles(), this._renderableLayerIds = e6._order.filter(((n5) => !e6._layers[n5].isHidden(t5))), this._coordsAscending = {}, e6.tileManagers) {
            this._coordsAscending[n4] = {};
            let t6 = e6.tileManagers[n4].getVisibleCoordinates(), r3 = e6.tileManagers[n4].getSource(), i3 = r3 instanceof _e2 ? r3.terrainTileRanges : null;
            for (let e7 of t6) {
              let t7 = this.terrain.tileManager.getTerrainCoords(e7, i3);
              for (let e8 in t7) this._coordsAscending[n4][e8] || (this._coordsAscending[n4][e8] = []), this._coordsAscending[n4][e8].push(t7[e8]);
            }
          }
          this._coordsAscendingStr = {};
          for (let t6 of e6._order) {
            let n4 = e6._layers[t6], r3 = n4.source;
            if (Ga[n4.type] && !this._coordsAscendingStr[r3]) for (let e7 in this._coordsAscendingStr[r3] = {}, this._coordsAscending[r3]) this._coordsAscendingStr[r3][e7] = this._coordsAscending[r3][e7].map(((e8) => e8.key)).sort().join();
          }
          for (let e7 of this._renderableTiles) for (let t6 in this._coordsAscendingStr) {
            let n4 = this._coordsAscendingStr[t6][e7.tileID.key];
            n4 && n4 !== e7.rttCoords[t6] && (e7.rtt = []);
          }
        }
        renderLayer(e6, n4) {
          if (e6.isHidden(this.painter.transform.zoom)) return false;
          let r3 = Object.assign(Object.assign({}, n4), { isRenderingToTexture: true }), i3 = e6.type, a3 = this.painter, o3 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e6.id;
          if (Ga[i3] && (this._prevType && Ga[this._prevType] || this._stacks.push([]), this._prevType = i3, this._stacks[this._stacks.length - 1].push(e6.id), !o3)) return true;
          if (Ga[this._prevType] || Ga[i3] && o3) {
            this._prevType = i3;
            let e7 = this._stacks.length - 1, n5 = this._stacks[e7] || [];
            for (let i4 of this._renderableTiles) {
              if (this.pool.isFull() && (Ri(this.painter, this.terrain, this._rttTiles, r3), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(i4), i4.rtt[e7]) {
                let t5 = this.pool.getObjectForId(i4.rtt[e7].id);
                if (t5.stamp === i4.rtt[e7].stamp) {
                  this.pool.useObject(t5);
                  continue;
                }
              }
              let o4 = this.pool.getOrCreateFreeObject();
              this.pool.useObject(o4), this.pool.stampObject(o4), i4.rtt[e7] = { id: o4.id, stamp: o4.stamp }, a3.context.bindFramebuffer.set(o4.fbo.framebuffer), a3.context.clear({ color: t4.bi.transparent, stencil: 0 }), a3.currentStencilSource = void 0;
              for (let e8 = 0; e8 < n5.length; e8++) {
                let t5 = a3.style._layers[n5[e8]], s3 = t5.source ? this._coordsAscending[t5.source][i4.tileID.key] : [i4.tileID];
                a3.context.viewport.set([0, 0, o4.fbo.width, o4.fbo.height]), a3._renderTileClippingMasks(t5, s3, true), a3.renderLayer(a3, a3.style.tileManagers[t5.source], t5, s3, r3), t5.source && (i4.rttCoords[t5.source] = this._coordsAscendingStr[t5.source][i4.tileID.key]);
              }
            }
            return Ri(this.painter, this.terrain, this._rttTiles, r3), this._rttTiles = [], this.pool.freeAllObjects(), Ga[i3];
          }
          return false;
        }
      }
      let qa = { "AttributionControl.ToggleAttribution": `Toggle attribution`, "AttributionControl.MapFeedback": `Map feedback`, "FullscreenControl.Enter": `Enter fullscreen`, "FullscreenControl.Exit": `Exit fullscreen`, "GeolocateControl.FindMyLocation": `Find my location`, "GeolocateControl.LocationNotAvailable": `Location not available`, "LogoControl.Title": `MapLibre logo`, "Map.Title": `Map`, "Marker.Title": `Map marker`, "NavigationControl.ResetBearing": `Reset bearing to north`, "NavigationControl.ZoomIn": `Zoom in`, "NavigationControl.ZoomOut": `Zoom out`, "Popup.Close": `Close popup`, "ScaleControl.Feet": `ft`, "ScaleControl.Meters": `m`, "ScaleControl.Kilometers": `km`, "ScaleControl.Miles": `mi`, "ScaleControl.NauticalMiles": `nm`, "GlobeControl.Enable": `Enable globe`, "GlobeControl.Disable": `Disable globe`, "TerrainControl.Enable": `Enable terrain`, "TerrainControl.Disable": `Disable terrain`, "CooperativeGesturesHandler.WindowsHelpText": `Use Ctrl + scroll to zoom the map`, "CooperativeGesturesHandler.MacHelpText": `Use \u2318 + scroll to zoom the map`, "CooperativeGesturesHandler.MobileHelpText": `Use two fingers to move the map` }, Ja = n3, Ya = { hash: false, interactive: true, bearingSnap: 7, attributionControl: Q, maplibreLogo: false, refreshExpiredTiles: true, canvasContextAttributes: { antialias: false, preserveDrawingBuffer: false, powerPreference: `high-performance`, failIfMajorPerformanceCaveat: false, desynchronized: false, contextType: void 0 }, scrollZoom: true, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, trackResize: true, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: true, maxTileCacheSize: null, maxTileCacheZoomLevels: t4.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, transformConstrain: null, fadeDuration: 300, crossSourceCollisions: true, clickTolerance: 3, localIdeographFontFamily: `sans-serif`, pitchWithRotate: true, rollEnabled: false, validateStyle: true, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: true, centerClampedToGround: true }, Xa = { showCompass: true, showZoom: true, visualizePitch: false, visualizeRoll: true };
      class Za {
        constructor(e6, n4, r3 = false) {
          this.mousedown = (e7) => {
            this.startMove(e7, l2.mousePos(this.element, e7)), l2.addEventListener(window, `mousemove`, this.mousemove), l2.addEventListener(window, `mouseup`, this.mouseup);
          }, this.mousemove = (e7) => {
            this.move(e7, l2.mousePos(this.element, e7));
          }, this.mouseup = (e7) => {
            this._rotatePitchHandler.dragEnd(e7), this.offTemp();
          }, this.touchstart = (e7) => {
            e7.targetTouches.length === 1 ? (this._startPos = this._lastPos = l2.touchPos(this.element, e7.targetTouches)[0], this.startMove(e7, this._startPos), l2.addEventListener(window, `touchmove`, this.touchmove, { passive: false }), l2.addEventListener(window, `touchend`, this.touchend)) : this.reset();
          }, this.touchmove = (e7) => {
            e7.targetTouches.length === 1 ? (this._lastPos = l2.touchPos(this.element, e7.targetTouches)[0], this.move(e7, this._lastPos)) : this.reset();
          }, this.touchend = (e7) => {
            e7.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this.reset = () => {
            this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this._clickTolerance = 10, this.element = n4, this._rotatePitchHandler = new la({ clickTolerance: 3, move: (e7, i3) => {
            let a3 = n4.getBoundingClientRect(), o3 = new t4.P((a3.bottom - a3.top) / 2, (a3.right - a3.left) / 2);
            return { bearingDelta: t4.cq(new t4.P(e7.x, i3.y), i3, o3), pitchDelta: r3 ? -0.5 * (i3.y - e7.y) : void 0 };
          }, moveStateManager: new fa(), enable: true, assignEvents: () => {
          } }), this.map = e6, l2.addEventListener(n4, `mousedown`, this.mousedown), l2.addEventListener(n4, `touchstart`, this.touchstart, { passive: false }), l2.addEventListener(n4, `touchcancel`, this.reset);
        }
        startMove(e6, t5) {
          this._rotatePitchHandler.dragStart(e6, t5), l2.disableDrag();
        }
        move(e6, t5) {
          let n4 = this.map, { bearingDelta: r3, pitchDelta: i3 } = this._rotatePitchHandler.dragMove(e6, t5) || {};
          r3 && n4.setBearing(n4.getBearing() + r3), i3 && n4.setPitch(n4.getPitch() + i3);
        }
        off() {
          let e6 = this.element;
          l2.removeEventListener(e6, `mousedown`, this.mousedown), l2.removeEventListener(e6, `touchstart`, this.touchstart, { passive: false }), l2.removeEventListener(window, `touchmove`, this.touchmove, { passive: false }), l2.removeEventListener(window, `touchend`, this.touchend), l2.removeEventListener(e6, `touchcancel`, this.reset), this.offTemp();
        }
        offTemp() {
          l2.enableDrag(), l2.removeEventListener(window, `mousemove`, this.mousemove), l2.removeEventListener(window, `mouseup`, this.mouseup), l2.removeEventListener(window, `touchmove`, this.touchmove, { passive: false }), l2.removeEventListener(window, `touchend`, this.touchend);
        }
      }
      let Qa;
      function $a(e6, n4, r3, i3 = false) {
        if (i3 || !r3.getCoveringTilesDetailsProvider().allowWorldCopies()) return e6 == null ? void 0 : e6.wrap();
        let a3 = new t4.U(e6.lng, e6.lat);
        if (e6 = new t4.U(e6.lng, e6.lat), n4) {
          let i4 = new t4.U(e6.lng - 360, e6.lat), a4 = new t4.U(e6.lng + 360, e6.lat), o3 = r3.locationToScreenPoint(e6).distSqr(n4);
          r3.locationToScreenPoint(i4).distSqr(n4) < o3 ? e6 = i4 : r3.locationToScreenPoint(a4).distSqr(n4) < o3 && (e6 = a4);
        }
        for (; Math.abs(e6.lng - r3.center.lng) > 180; ) {
          let t5 = r3.locationToScreenPoint(e6);
          if (t5.x >= 0 && t5.y >= 0 && t5.x <= r3.width && t5.y <= r3.height) break;
          e6.lng > r3.center.lng ? e6.lng -= 360 : e6.lng += 360;
        }
        return e6.lng !== a3.lng && r3.isPointOnMapSurface(r3.locationToScreenPoint(e6)) ? e6 : a3;
      }
      let eo = { center: `translate(-50%,-50%)`, top: `translate(-50%,0)`, "top-left": `translate(0,0)`, "top-right": `translate(-100%,0)`, bottom: `translate(-50%,-100%)`, "bottom-left": `translate(0,-100%)`, "bottom-right": `translate(-100%,-100%)`, left: `translate(0,-50%)`, right: `translate(-100%,-50%)` };
      function to(e6, t5, n4) {
        let r3 = e6.classList;
        for (let e7 in eo) r3.remove(`maplibregl-${n4}-anchor-${e7}`);
        r3.add(`maplibregl-${n4}-anchor-${t5}`);
      }
      class no extends t4.E {
        constructor(e6) {
          if (super(), this._onKeyPress = (e7) => {
            let t5 = e7.code, n4 = e7.charCode || e7.keyCode;
            t5 !== `Space` && t5 !== `Enter` && n4 !== 32 && n4 !== 13 || this.togglePopup();
          }, this._onMapClick = (e7) => {
            let t5 = e7.originalEvent.target, n4 = this._element;
            this._popup && (t5 === n4 || n4.contains(t5)) && this.togglePopup();
          }, this._update = (e7) => {
            if (!this._map) return;
            let t5 = this._map.loaded() && !this._map.isMoving();
            ((e7 == null ? void 0 : e7.type) === `terrain` || (e7 == null ? void 0 : e7.type) === `render` && !t5) && this._map.once(`render`, this._update), this._lngLat = $a(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
            let n4 = ``;
            this._rotationAlignment === `viewport` || this._rotationAlignment === `auto` ? n4 = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === `map` && (n4 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
            let r3 = ``;
            this._pitchAlignment === `viewport` || this._pitchAlignment === `auto` ? r3 = `rotateX(0deg)` : this._pitchAlignment === `map` && (r3 = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || e7 && e7.type !== `moveend` || (this._pos = this._pos.round()), l2.setTransform(this._element, `${eo[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${r3} ${n4}`), o2.frameAsync(new AbortController()).then((() => {
              this._updateOpacity(e7 && e7.type === `moveend`);
            })).catch((() => {
            }));
          }, this._onMove = (e7) => {
            if (!this._isDragging) {
              let t5 = this._clickTolerance || this._map._clickTolerance;
              this._isDragging = e7.point.dist(this._pointerdownPos) >= t5;
            }
            this._isDragging && (this._pos = e7.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = `none`, this._state === `pending` && (this._state = `active`, this.fire(new t4.l(`dragstart`))), this.fire(new t4.l(`drag`)));
          }, this._onUp = () => {
            this._element.style.pointerEvents = `auto`, this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off(`mousemove`, this._onMove), this._map.off(`touchmove`, this._onMove), this._state === `active` && this.fire(new t4.l(`dragend`)), this._state = `inactive`;
          }, this._addDragHandler = (e7) => {
            this._element.contains(e7.originalEvent.target) && (e7.preventDefault(), this._positionDelta = e7.point.sub(this._pos).add(this._offset), this._pointerdownPos = e7.point, this._state = `pending`, this._map.on(`mousemove`, this._onMove), this._map.on(`touchmove`, this._onMove), this._map.once(`mouseup`, this._onUp), this._map.once(`touchend`, this._onUp));
          }, this._anchor = e6 && e6.anchor || `center`, this._color = e6 && e6.color || `#3FB1CE`, this._scale = e6 && e6.scale || 1, this._draggable = e6 && e6.draggable || false, this._clickTolerance = e6 && e6.clickTolerance || 0, this._subpixelPositioning = e6 && e6.subpixelPositioning || false, this._isDragging = false, this._state = `inactive`, this._rotation = e6 && e6.rotation || 0, this._rotationAlignment = e6 && e6.rotationAlignment || `auto`, this._pitchAlignment = e6 && e6.pitchAlignment && e6.pitchAlignment !== `auto` ? e6.pitchAlignment : this._rotationAlignment, this.setOpacity(e6 == null ? void 0 : e6.opacity, e6 == null ? void 0 : e6.opacityWhenCovered), e6 && e6.element) this._element = e6.element, this._offset = t4.P.convert(e6 && e6.offset || [0, 0]);
          else {
            this._defaultMarker = true, this._element = l2.create(`div`);
            let n4 = l2.createNS(`http://www.w3.org/2000/svg`, `svg`);
            n4.setAttributeNS(null, `display`, `block`), n4.setAttributeNS(null, `height`, `41px`), n4.setAttributeNS(null, `width`, `27px`), n4.setAttributeNS(null, `viewBox`, `0 0 27 41`);
            let r3 = l2.createNS(`http://www.w3.org/2000/svg`, `g`);
            r3.setAttributeNS(null, `stroke`, `none`), r3.setAttributeNS(null, `stroke-width`, `1`), r3.setAttributeNS(null, `fill`, `none`), r3.setAttributeNS(null, `fill-rule`, `evenodd`);
            let i3 = l2.createNS(`http://www.w3.org/2000/svg`, `g`);
            i3.setAttributeNS(null, `fill-rule`, `nonzero`);
            let a3 = l2.createNS(`http://www.w3.org/2000/svg`, `g`);
            a3.setAttributeNS(null, `transform`, `translate(3.0, 29.0)`), a3.setAttributeNS(null, `fill`, `#000000`);
            for (let e7 of [{ rx: `10.5`, ry: `5.25002273` }, { rx: `10.5`, ry: `5.25002273` }, { rx: `9.5`, ry: `4.77275007` }, { rx: `8.5`, ry: `4.29549936` }, { rx: `7.5`, ry: `3.81822308` }, { rx: `6.5`, ry: `3.34094679` }, { rx: `5.5`, ry: `2.86367051` }, { rx: `4.5`, ry: `2.38636864` }]) {
              let t5 = l2.createNS(`http://www.w3.org/2000/svg`, `ellipse`);
              t5.setAttributeNS(null, `opacity`, `0.04`), t5.setAttributeNS(null, `cx`, `10.5`), t5.setAttributeNS(null, `cy`, `5.80029008`), t5.setAttributeNS(null, `rx`, e7.rx), t5.setAttributeNS(null, `ry`, e7.ry), a3.appendChild(t5);
            }
            let o3 = l2.createNS(`http://www.w3.org/2000/svg`, `g`);
            o3.setAttributeNS(null, `fill`, this._color);
            let s3 = l2.createNS(`http://www.w3.org/2000/svg`, `path`);
            s3.setAttributeNS(null, `d`, `M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z`), o3.appendChild(s3);
            let c3 = l2.createNS(`http://www.w3.org/2000/svg`, `g`);
            c3.setAttributeNS(null, `opacity`, `0.25`), c3.setAttributeNS(null, `fill`, `#000000`);
            let u3 = l2.createNS(`http://www.w3.org/2000/svg`, `path`);
            u3.setAttributeNS(null, `d`, `M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z`), c3.appendChild(u3);
            let d3 = l2.createNS(`http://www.w3.org/2000/svg`, `g`);
            d3.setAttributeNS(null, `transform`, `translate(6.0, 7.0)`), d3.setAttributeNS(null, `fill`, `#FFFFFF`);
            let f3 = l2.createNS(`http://www.w3.org/2000/svg`, `g`);
            f3.setAttributeNS(null, `transform`, `translate(8.0, 8.0)`);
            let p3 = l2.createNS(`http://www.w3.org/2000/svg`, `circle`);
            p3.setAttributeNS(null, `fill`, `#000000`), p3.setAttributeNS(null, `opacity`, `0.25`), p3.setAttributeNS(null, `cx`, `5.5`), p3.setAttributeNS(null, `cy`, `5.5`), p3.setAttributeNS(null, `r`, `5.4999962`);
            let m3 = l2.createNS(`http://www.w3.org/2000/svg`, `circle`);
            m3.setAttributeNS(null, `fill`, `#FFFFFF`), m3.setAttributeNS(null, `cx`, `5.5`), m3.setAttributeNS(null, `cy`, `5.5`), m3.setAttributeNS(null, `r`, `5.4999962`), f3.appendChild(p3), f3.appendChild(m3), i3.appendChild(a3), i3.appendChild(o3), i3.appendChild(c3), i3.appendChild(d3), i3.appendChild(f3), n4.appendChild(i3), n4.setAttributeNS(null, `height`, 41 * this._scale + `px`), n4.setAttributeNS(null, `width`, 27 * this._scale + `px`), this._element.appendChild(n4), this._offset = t4.P.convert(e6 && e6.offset || [0, -14]);
          }
          if (this._element.classList.add(`maplibregl-marker`), this._element.addEventListener(`dragstart`, ((e7) => {
            e7.preventDefault();
          })), this._element.addEventListener(`mousedown`, ((e7) => {
            e7.preventDefault();
          })), to(this._element, this._anchor, `marker`), e6 && e6.className) for (let t5 of e6.className.split(` `)) this._element.classList.add(t5);
          this._popup = null;
        }
        addTo(e6) {
          return this.remove(), this._map = e6, this._element.hasAttribute(`aria-label`) || this._element.setAttribute(`aria-label`, e6._getUIString(`Marker.Title`)), this._element.hasAttribute(`role`) || this._element.setAttribute(`role`, `button`), e6.getCanvasContainer().appendChild(this._element), e6.on(`move`, this._update), e6.on(`moveend`, this._update), e6.on(`terrain`, this._update), e6.on(`projectiontransition`, this._update), this.setDraggable(this._draggable), this._update(), this._map.on(`click`, this._onMapClick), this;
        }
        remove() {
          return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off(`click`, this._onMapClick), this._map.off(`move`, this._update), this._map.off(`moveend`, this._update), this._map.off(`terrain`, this._update), this._map.off(`projectiontransition`, this._update), this._map.off(`mousedown`, this._addDragHandler), this._map.off(`touchstart`, this._addDragHandler), this._map.off(`mouseup`, this._onUp), this._map.off(`touchend`, this._onUp), this._map.off(`mousemove`, this._onMove), this._map.off(`touchmove`, this._onMove), delete this._map), l2.remove(this._element), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(e6) {
          return this._lngLat = t4.U.convert(e6), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(e6) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener(`keypress`, this._onKeyPress), this._originalTabIndex || this._element.removeAttribute(`tabindex`)), e6) {
            if (!(`offset` in e6.options)) {
              let t5 = 38.1, n4 = 13.5, r3 = 13.5 / Math.SQRT2;
              e6.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t5], "bottom-left": [r3, -1 * (t5 - n4 + r3)], "bottom-right": [-r3, -1 * (t5 - n4 + r3)], left: [n4, -1 * (t5 - n4)], right: [-n4, -1 * (t5 - n4)] } : this._offset;
            }
            this._popup = e6, this._originalTabIndex = this._element.getAttribute(`tabindex`), this._originalTabIndex || this._element.setAttribute(`tabindex`, `0`), this._element.addEventListener(`keypress`, this._onKeyPress);
          }
          return this;
        }
        setSubpixelPositioning(e6) {
          return this._subpixelPositioning = e6, this;
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          let e6 = this._popup;
          return this._element.style.opacity === this._opacityWhenCovered || e6 && (e6.isOpen() ? e6.remove() : (e6.setLngLat(this._lngLat), e6.addTo(this._map))), this;
        }
        _updateOpacity(e6 = false) {
          var _a3;
          var n4;
          let r3 = (_a3 = this._map) == null ? void 0 : _a3.terrain, i3 = this._map.transform.isLocationOccluded(this._lngLat);
          if (!r3 || i3) {
            let e7 = i3 ? this._opacityWhenCovered : this._opacity;
            this._element.style.opacity !== e7 && (this._element.style.opacity = e7);
            return;
          }
          if (e6) this._opacityTimeout = null;
          else {
            if (this._opacityTimeout) return;
            this._opacityTimeout = setTimeout((() => {
              this._opacityTimeout = null;
            }), 100);
          }
          let a3 = this._map, o3 = a3.terrain.depthAtPoint(this._pos), s3 = a3.terrain.getElevationForLngLatZoom(this._lngLat, a3.transform.tileZoom);
          if (a3.transform.lngLatToCameraDepth(this._lngLat, s3) - o3 < 6e-3) return void (this._element.style.opacity = this._opacity);
          let c3 = -this._offset.y / a3.transform.pixelsPerMeter, l3 = Math.sin(a3.getPitch() * Math.PI / 180) * c3, u3 = a3.terrain.depthAtPoint(new t4.P(this._pos.x, this._pos.y - this._offset.y)), d3 = a3.transform.lngLatToCameraDepth(this._lngLat, s3 + l3) - u3 > 6e-3;
          (n4 = this._popup) != null && n4.isOpen() && d3 && this._popup.remove(), this._element.style.opacity = d3 ? this._opacityWhenCovered : this._opacity;
        }
        getOffset() {
          return this._offset;
        }
        setOffset(e6) {
          return this._offset = t4.P.convert(e6), this._update(), this;
        }
        addClassName(e6) {
          this._element.classList.add(e6);
        }
        removeClassName(e6) {
          this._element.classList.remove(e6);
        }
        toggleClassName(e6) {
          return this._element.classList.toggle(e6);
        }
        setDraggable(e6) {
          return this._draggable = !!e6, this._map && (e6 ? (this._map.on(`mousedown`, this._addDragHandler), this._map.on(`touchstart`, this._addDragHandler)) : (this._map.off(`mousedown`, this._addDragHandler), this._map.off(`touchstart`, this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(e6) {
          return this._rotation = e6 || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(e6) {
          return this._rotationAlignment = e6 || `auto`, this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment;
        }
        setPitchAlignment(e6) {
          return this._pitchAlignment = e6 && e6 !== `auto` ? e6 : this._rotationAlignment, this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment;
        }
        setOpacity(e6, t5) {
          return (this._opacity === void 0 || e6 === void 0 && t5 === void 0) && (this._opacity = `1`, this._opacityWhenCovered = `0.2`), e6 !== void 0 && (this._opacity = e6), t5 !== void 0 && (this._opacityWhenCovered = t5), this._map && this._updateOpacity(true), this;
        }
      }
      let ro = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true }, io = 0, ao = false, oo = { maxWidth: 100, unit: `metric` };
      function so(e6, t5, n4) {
        let r3 = n4 && n4.maxWidth || 100, i3 = e6._container.clientHeight / 2, a3 = e6._container.clientWidth / 2, o3 = e6.unproject([a3 - r3 / 2, i3]), s3 = e6.unproject([a3 + r3 / 2, i3]), c3 = Math.round(e6.project(s3).x - e6.project(o3).x), l3 = Math.min(r3, c3, e6._container.clientWidth), u3 = o3.distanceTo(s3);
        if (n4 && n4.unit === `imperial`) {
          let n5 = 3.2808 * u3;
          n5 > 5280 ? co(t5, l3, n5 / 5280, e6._getUIString(`ScaleControl.Miles`)) : co(t5, l3, n5, e6._getUIString(`ScaleControl.Feet`));
        } else n4 && n4.unit === `nautical` ? co(t5, l3, u3 / 1852, e6._getUIString(`ScaleControl.NauticalMiles`)) : u3 >= 1e3 ? co(t5, l3, u3 / 1e3, e6._getUIString(`ScaleControl.Kilometers`)) : co(t5, l3, u3, e6._getUIString(`ScaleControl.Meters`));
      }
      function co(e6, t5, n4, r3) {
        let i3 = (function(e7) {
          let t6 = 10 ** (`${Math.floor(e7)}`.length - 1), n5 = e7 / t6;
          return n5 = n5 >= 10 ? 10 : n5 >= 5 ? 5 : n5 >= 3 ? 3 : n5 >= 2 ? 2 : n5 >= 1 ? 1 : (function(e8) {
            let t7 = 10 ** Math.ceil(-Math.log(e8) / Math.LN10);
            return Math.round(e8 * t7) / t7;
          })(n5), t6 * n5;
        })(n4);
        e6.style.width = i3 / n4 * t5 + `px`, e6.innerHTML = `${i3}&nbsp;${r3}`;
      }
      let lo = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: ``, maxWidth: `240px`, subpixelPositioning: false, locationOccludedOpacity: void 0 }, uo = [`a[href]`, `[tabindex]:not([tabindex='-1'])`, `[contenteditable]:not([contenteditable='false'])`, `button:not([disabled])`, `input:not([disabled])`, `select:not([disabled])`, `textarea:not([disabled])`].join(`, `);
      function fo(e6) {
        if (e6) {
          if (typeof e6 == `number`) {
            let n4 = Math.round(Math.abs(e6) / Math.SQRT2);
            return { center: new t4.P(0, 0), top: new t4.P(0, e6), "top-left": new t4.P(n4, n4), "top-right": new t4.P(-n4, n4), bottom: new t4.P(0, -e6), "bottom-left": new t4.P(n4, -n4), "bottom-right": new t4.P(-n4, -n4), left: new t4.P(e6, 0), right: new t4.P(-e6, 0) };
          }
          if (e6 instanceof t4.P || Array.isArray(e6)) {
            let n4 = t4.P.convert(e6);
            return { center: n4, top: n4, "top-left": n4, "top-right": n4, bottom: n4, "bottom-left": n4, "bottom-right": n4, left: n4, right: n4 };
          }
          return { center: t4.P.convert(e6.center || [0, 0]), top: t4.P.convert(e6.top || [0, 0]), "top-left": t4.P.convert(e6[`top-left`] || [0, 0]), "top-right": t4.P.convert(e6[`top-right`] || [0, 0]), bottom: t4.P.convert(e6.bottom || [0, 0]), "bottom-left": t4.P.convert(e6[`bottom-left`] || [0, 0]), "bottom-right": t4.P.convert(e6[`bottom-right`] || [0, 0]), left: t4.P.convert(e6.left || [0, 0]), right: t4.P.convert(e6.right || [0, 0]) };
        }
        return fo(new t4.P(0, 0));
      }
      let po = n3;
      e5.AJAXError = t4.cC, e5.Event = t4.l, e5.Evented = t4.E, e5.LngLat = t4.U, e5.MercatorCoordinate = t4.a5, e5.Point = t4.P, e5.addProtocol = t4.cD, e5.config = t4.a, e5.removeProtocol = t4.cE, e5.AttributionControl = $, e5.BoxZoomHandler = ia, e5.CanvasSource = L2, e5.CooperativeGesturesHandler = Na, e5.DoubleClickZoomHandler = Da, e5.DragPanHandler = Aa, e5.DragRotateHandler = ja, e5.EdgeInsets = Lt2, e5.FullscreenControl = class extends t4.E {
        constructor(e6 = {}) {
          super(), this._onFullscreenChange = () => {
            var _a3;
            let e7 = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
            for (; (_a3 = e7 == null ? void 0 : e7.shadowRoot) == null ? void 0 : _a3.fullscreenElement; ) e7 = e7.shadowRoot.fullscreenElement;
            e7 === this._container !== this._fullscreen && this._handleFullscreenChange();
          }, this._onClickFullscreen = () => {
            this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
          }, this._fullscreen = false, e6 && e6.container && (e6.container instanceof HTMLElement ? this._container = e6.container : t4.w(`Full screen control 'container' must be a DOM element.`)), `onfullscreenchange` in document ? this._fullscreenchange = `fullscreenchange` : `onmozfullscreenchange` in document ? this._fullscreenchange = `mozfullscreenchange` : `onwebkitfullscreenchange` in document ? this._fullscreenchange = `webkitfullscreenchange` : `onmsfullscreenchange` in document && (this._fullscreenchange = `MSFullscreenChange`);
        }
        onAdd(e6) {
          return this._map = e6, this._container || (this._container = this._map.getContainer()), this._controlContainer = l2.create(`div`, `maplibregl-ctrl maplibregl-ctrl-group`), this._setupUI(), this._controlContainer;
        }
        onRemove() {
          l2.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _setupUI() {
          let e6 = this._fullscreenButton = l2.create(`button`, `maplibregl-ctrl-fullscreen`, this._controlContainer);
          l2.create(`span`, `maplibregl-ctrl-icon`, e6).setAttribute(`aria-hidden`, `true`), e6.type = `button`, this._updateTitle(), this._fullscreenButton.addEventListener(`click`, this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _updateTitle() {
          let e6 = this._getTitle();
          this._fullscreenButton.setAttribute(`aria-label`, e6), this._fullscreenButton.title = e6;
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? `FullscreenControl.Exit` : `FullscreenControl.Enter`);
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _handleFullscreenChange() {
          this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle(`maplibregl-ctrl-shrink`), this._fullscreenButton.classList.toggle(`maplibregl-ctrl-fullscreen`), this._updateTitle(), this._fullscreen ? (this.fire(new t4.l(`fullscreenstart`)), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new t4.l(`fullscreenend`)), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
        }
        _exitFullscreen() {
          window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
        }
        _requestFullscreen() {
          this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
        }
        _togglePseudoFullScreen() {
          this._container.classList.toggle(`maplibregl-pseudo-fullscreen`), this._handleFullscreenChange(), this._map.resize();
        }
      }, e5.GeoJSONSource = ge2, e5.GeolocateControl = class extends t4.E {
        constructor(e6) {
          super(), this._onSuccess = (e7) => {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(e7)) return this._setErrorState(), this.fire(new t4.l(`outofmaxbounds`, e7)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation) switch (this._lastKnownPosition = e7, this._watchState) {
                case `WAITING_ACTIVE`:
                case `ACTIVE_LOCK`:
                case `ACTIVE_ERROR`:
                  this._watchState = `ACTIVE_LOCK`, this._geolocateButton.classList.remove(`maplibregl-ctrl-geolocate-waiting`), this._geolocateButton.classList.remove(`maplibregl-ctrl-geolocate-active-error`), this._geolocateButton.classList.add(`maplibregl-ctrl-geolocate-active`);
                  break;
                case `BACKGROUND`:
                case `BACKGROUND_ERROR`:
                  this._watchState = `BACKGROUND`, this._geolocateButton.classList.remove(`maplibregl-ctrl-geolocate-waiting`), this._geolocateButton.classList.remove(`maplibregl-ctrl-geolocate-background-error`), this._geolocateButton.classList.add(`maplibregl-ctrl-geolocate-background`);
                  break;
                default:
                  throw Error(`Unexpected watchState ${this._watchState}`);
              }
              this.options.showUserLocation && this._watchState !== `OFF` && this._updateMarker(e7), this.options.trackUserLocation && this._watchState !== `ACTIVE_LOCK` || this._updateCamera(e7), this.options.showUserLocation && this._dotElement.classList.remove(`maplibregl-user-location-dot-stale`), this.fire(new t4.l(`geolocate`, e7)), this._finish();
            }
          }, this._updateCamera = (e7) => {
            let n4 = new t4.U(e7.coords.longitude, e7.coords.latitude), r3 = e7.coords.accuracy, i3 = this._map.getBearing(), a3 = t4.e({ bearing: i3 }, this.options.fitBoundsOptions), o3 = ue2.fromLngLat(n4, r3);
            this._map.fitBounds(o3, a3, { geolocateSource: true });
          }, this._updateMarker = (e7) => {
            if (e7) {
              let n4 = new t4.U(e7.coords.longitude, e7.coords.latitude);
              this._accuracyCircleMarker.setLngLat(n4).addTo(this._map), this._userLocationDotMarker.setLngLat(n4).addTo(this._map), this._accuracy = e7.coords.accuracy, this._updateCircleRadiusIfNeeded();
            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }, this._onUpdate = () => {
            this._updateCircleRadiusIfNeeded();
          }, this._onError = (e7) => {
            if (this._map) {
              if (e7.code === 1) {
                this._watchState = `OFF`, this._geolocateButton.classList.remove(`maplibregl-ctrl-geolocate-waiting`), this._geolocateButton.classList.remove(`maplibregl-ctrl-geolocate-active`), this._geolocateButton.classList.remove(`maplibregl-ctrl-geolocate-active-error`), this._geolocateButton.classList.remove(`maplibregl-ctrl-geolocate-background`), this._geolocateButton.classList.remove(`maplibregl-ctrl-geolocate-background-error`), this._geolocateButton.disabled = true;
                let e8 = this._map._getUIString(`GeolocateControl.LocationNotAvailable`);
                this._geolocateButton.title = e8, this._geolocateButton.setAttribute(`aria-label`, e8), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (e7.code === 3 && ao) return;
                this._setErrorState();
              }
              this._watchState !== `OFF` && this.options.showUserLocation && this._dotElement.classList.add(`maplibregl-user-location-dot-stale`), this.fire(new t4.l(`error`, e7)), this._finish();
            }
          }, this._finish = () => {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }, this._setupUI = () => {
            this._map && (this._container.addEventListener(`contextmenu`, ((e7) => e7.preventDefault())), this._geolocateButton = l2.create(`button`, `maplibregl-ctrl-geolocate`, this._container), l2.create(`span`, `maplibregl-ctrl-icon`, this._geolocateButton).setAttribute(`aria-hidden`, `true`), this._geolocateButton.type = `button`, this._geolocateButton.disabled = true);
          }, this._finishSetupUI = (e7) => {
            if (this._map) {
              if (false === e7) {
                t4.w(`Geolocation support is not available so the GeolocateControl will be disabled.`);
                let e8 = this._map._getUIString(`GeolocateControl.LocationNotAvailable`);
                this._geolocateButton.disabled = true, this._geolocateButton.title = e8, this._geolocateButton.setAttribute(`aria-label`, e8);
              } else {
                let e8 = this._map._getUIString(`GeolocateControl.FindMyLocation`);
                this._geolocateButton.disabled = false, this._geolocateButton.title = e8, this._geolocateButton.setAttribute(`aria-label`, e8);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute(`aria-pressed`, `false`), this._watchState = `OFF`), this.options.showUserLocation && (this._dotElement = l2.create(`div`, `maplibregl-user-location-dot`), this._userLocationDotMarker = new no({ element: this._dotElement }), this._circleElement = l2.create(`div`, `maplibregl-user-location-accuracy-circle`), this._accuracyCircleMarker = new no({ element: this._circleElement, pitchAlignment: `map` }), this.options.trackUserLocation && (this._watchState = `OFF`), this._map.on(`zoom`, this._onUpdate), this._map.on(`move`, this._onUpdate), this._map.on(`rotate`, this._onUpdate), this._map.on(`pitch`, this._onUpdate)), this._geolocateButton.addEventListener(`click`, (() => this.trigger())), this._setup = true, this.options.trackUserLocation && this._map.on(`movestart`, ((e8) => {
                let n4 = (e8 == null ? void 0 : e8[0]) instanceof ResizeObserverEntry;
                e8.geolocateSource || this._watchState !== `ACTIVE_LOCK` || n4 || this._map.isZooming() || (this._watchState = `BACKGROUND`, this._geolocateButton.classList.add(`maplibregl-ctrl-geolocate-background`), this._geolocateButton.classList.remove(`maplibregl-ctrl-geolocate-active`), this.fire(new t4.l(`trackuserlocationend`)), this.fire(new t4.l(`userlocationlostfocus`)));
              }));
            }
          }, this.options = t4.e({}, ro, e6);
        }
        onAdd(e6) {
          return this._map = e6, this._container = l2.create(`div`, `maplibregl-ctrl maplibregl-ctrl-group`), this._setupUI(), (function() {
            return t4._(this, arguments, void 0, (function* (e7 = false) {
              if (Qa !== void 0 && !e7) return Qa;
              if (window.navigator.permissions === void 0) return Qa = !!window.navigator.geolocation, Qa;
              try {
                Qa = (yield window.navigator.permissions.query({ name: `geolocation` })).state !== `denied`;
              } catch {
                Qa = !!window.navigator.geolocation;
              }
              return Qa;
            }));
          })().then(((e7) => this._finishSetupUI(e7))), this._container;
        }
        onRemove() {
          this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), l2.remove(this._container), this._map.off(`zoom`, this._onUpdate), this._map.off(`move`, this._onUpdate), this._map.off(`rotate`, this._onUpdate), this._map.off(`pitch`, this._onUpdate), this._map = void 0, io = 0, ao = false;
        }
        _isOutOfMapMaxBounds(e6) {
          let t5 = this._map.getMaxBounds(), n4 = e6.coords;
          return t5 && (n4.longitude < t5.getWest() || n4.longitude > t5.getEast() || n4.latitude < t5.getSouth() || n4.latitude > t5.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case `WAITING_ACTIVE`:
              this._watchState = `ACTIVE_ERROR`, this._geolocateButton.classList.remove(`maplibregl-ctrl-geolocate-active`), this._geolocateButton.classList.add(`maplibregl-ctrl-geolocate-active-error`);
              break;
            case `ACTIVE_LOCK`:
              this._watchState = `ACTIVE_ERROR`, this._geolocateButton.classList.remove(`maplibregl-ctrl-geolocate-active`), this._geolocateButton.classList.add(`maplibregl-ctrl-geolocate-active-error`), this._geolocateButton.classList.add(`maplibregl-ctrl-geolocate-waiting`);
              break;
            case `BACKGROUND`:
              this._watchState = `BACKGROUND_ERROR`, this._geolocateButton.classList.remove(`maplibregl-ctrl-geolocate-background`), this._geolocateButton.classList.add(`maplibregl-ctrl-geolocate-background-error`), this._geolocateButton.classList.add(`maplibregl-ctrl-geolocate-waiting`);
              break;
            case `ACTIVE_ERROR`:
            case `BACKGROUND_ERROR`:
            case `OFF`:
            case void 0:
              break;
            default:
              throw Error(`Unexpected watchState ${this._watchState}`);
          }
        }
        _updateCircleRadiusIfNeeded() {
          let e6 = this._userLocationDotMarker.getLngLat();
          if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && e6)) return;
          let t5 = this._map.project(e6), n4 = this._map.unproject([t5.x + 100, t5.y]), r3 = e6.distanceTo(n4) / 100, i3 = 2 * this._accuracy / r3;
          this._circleElement.style.width = `${i3.toFixed(2)}px`, this._circleElement.style.height = `${i3.toFixed(2)}px`;
        }
        trigger() {
          if (!this._setup) return t4.w(`Geolocate control triggered before added to a map`), false;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case `OFF`:
                this._watchState = `WAITING_ACTIVE`, this.fire(new t4.l(`trackuserlocationstart`));
                break;
              case `WAITING_ACTIVE`:
              case `ACTIVE_LOCK`:
              case `ACTIVE_ERROR`:
              case `BACKGROUND_ERROR`:
                io--, ao = false, this._watchState = `OFF`, this._geolocateButton.classList.remove(`maplibregl-ctrl-geolocate-waiting`), this._geolocateButton.classList.remove(`maplibregl-ctrl-geolocate-active`), this._geolocateButton.classList.remove(`maplibregl-ctrl-geolocate-active-error`), this._geolocateButton.classList.remove(`maplibregl-ctrl-geolocate-background`), this._geolocateButton.classList.remove(`maplibregl-ctrl-geolocate-background-error`), this.fire(new t4.l(`trackuserlocationend`));
                break;
              case `BACKGROUND`:
                this._watchState = `ACTIVE_LOCK`, this._geolocateButton.classList.remove(`maplibregl-ctrl-geolocate-background`), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t4.l(`trackuserlocationstart`)), this.fire(new t4.l(`userlocationfocus`));
                break;
              default:
                throw Error(`Unexpected watchState ${this._watchState}`);
            }
            switch (this._watchState) {
              case `WAITING_ACTIVE`:
                this._geolocateButton.classList.add(`maplibregl-ctrl-geolocate-waiting`), this._geolocateButton.classList.add(`maplibregl-ctrl-geolocate-active`);
                break;
              case `ACTIVE_LOCK`:
                this._geolocateButton.classList.add(`maplibregl-ctrl-geolocate-active`);
                break;
              case `OFF`:
                break;
              default:
                throw Error(`Unexpected watchState ${this._watchState}`);
            }
            if (this._watchState === `OFF` && this._geolocationWatchID !== void 0) this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              let e6;
              this._geolocateButton.classList.add(`maplibregl-ctrl-geolocate-waiting`), this._geolocateButton.setAttribute(`aria-pressed`, `true`), io++, io > 1 ? (e6 = { maximumAge: 6e5, timeout: 0 }, ao = true) : (e6 = this.options.positionOptions, ao = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e6);
            }
          } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return true;
        }
        _clearWatch() {
          window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove(`maplibregl-ctrl-geolocate-waiting`), this._geolocateButton.setAttribute(`aria-pressed`, `false`), this.options.showUserLocation && this._updateMarker(null);
        }
      }, e5.GlobeControl = class {
        constructor() {
          this._toggleProjection = () => {
            var _a3;
            let e6 = (_a3 = this._map.getProjection()) == null ? void 0 : _a3.type;
            this._map.setProjection(e6 !== `mercator` && e6 ? { type: `mercator` } : { type: `globe` }), this._updateGlobeIcon();
          }, this._updateGlobeIcon = () => {
            var _a3;
            this._globeButton.classList.remove(`maplibregl-ctrl-globe`), this._globeButton.classList.remove(`maplibregl-ctrl-globe-enabled`), ((_a3 = this._map.getProjection()) == null ? void 0 : _a3.type) === `globe` ? (this._globeButton.classList.add(`maplibregl-ctrl-globe-enabled`), this._globeButton.title = this._map._getUIString(`GlobeControl.Disable`)) : (this._globeButton.classList.add(`maplibregl-ctrl-globe`), this._globeButton.title = this._map._getUIString(`GlobeControl.Enable`));
          };
        }
        onAdd(e6) {
          return this._map = e6, this._container = l2.create(`div`, `maplibregl-ctrl maplibregl-ctrl-group`), this._globeButton = l2.create(`button`, `maplibregl-ctrl-globe`, this._container), l2.create(`span`, `maplibregl-ctrl-icon`, this._globeButton).setAttribute(`aria-hidden`, `true`), this._globeButton.type = `button`, this._globeButton.addEventListener(`click`, this._toggleProjection), this._updateGlobeIcon(), this._map.on(`styledata`, this._updateGlobeIcon), this._container;
        }
        onRemove() {
          l2.remove(this._container), this._map.off(`styledata`, this._updateGlobeIcon), this._globeButton.removeEventListener(`click`, this._toggleProjection), this._map = void 0;
        }
      }, e5.Hash = Hi, e5.ImageSource = _e2, e5.KeyboardHandler = Ca, e5.LngLatBounds = ue2, e5.LogoControl = za, e5.Map = class extends Ra {
        constructor(e6) {
          var _a3, _b2;
          t4.cz.mark(t4.cA.create);
          let n4 = Object.assign(Object.assign(Object.assign({}, Ya), e6), { canvasContextAttributes: Object.assign(Object.assign({}, Ya.canvasContextAttributes), e6.canvasContextAttributes) });
          if (n4.minZoom != null && n4.maxZoom != null && n4.minZoom > n4.maxZoom) throw Error(`maxZoom must be greater than or equal to minZoom`);
          if (n4.minPitch != null && n4.maxPitch != null && n4.minPitch > n4.maxPitch) throw Error(`maxPitch must be greater than or equal to minPitch`);
          if (n4.minPitch != null && n4.minPitch < 0) throw Error(`minPitch must be greater than or equal to 0`);
          if (n4.maxPitch != null && n4.maxPitch > 180) throw Error(`maxPitch must be less than or equal to 180`);
          let r3 = new Wt2(), i3 = new Jt2();
          if (n4.minZoom !== void 0 && r3.setMinZoom(n4.minZoom), n4.maxZoom !== void 0 && r3.setMaxZoom(n4.maxZoom), n4.minPitch !== void 0 && r3.setMinPitch(n4.minPitch), n4.maxPitch !== void 0 && r3.setMaxPitch(n4.maxPitch), n4.renderWorldCopies !== void 0 && r3.setRenderWorldCopies(n4.renderWorldCopies), n4.transformConstrain !== null && r3.setConstrain(n4.transformConstrain), super(r3, i3, { bearingSnap: n4.bearingSnap }), this._idleTriggered = false, this._crossFadingFactor = 1, this._renderTaskQueue = new Ba(), this._controls = [], this._mapId = t4.ab(), this._contextLost = (e7) => {
            e7.preventDefault(), this._frameRequest && (this._frameRequest = (this._frameRequest.abort(), null)), this.fire(new t4.l(`webglcontextlost`, { originalEvent: e7 }));
          }, this._contextRestored = (e7) => {
            this._setupPainter(), this.resize(), this._update(), this.fire(new t4.l(`webglcontextrestored`, { originalEvent: e7 }));
          }, this._onMapScroll = (e7) => {
            if (e7.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
          }, this._onWindowOnline = () => {
            this._update();
          }, this._interactive = n4.interactive, this._maxTileCacheSize = n4.maxTileCacheSize, this._maxTileCacheZoomLevels = n4.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, n4.canvasContextAttributes), this._trackResize = true === n4.trackResize, this._bearingSnap = n4.bearingSnap, this._centerClampedToGround = n4.centerClampedToGround, this._refreshExpiredTiles = true === n4.refreshExpiredTiles, this._fadeDuration = n4.fadeDuration, this._crossSourceCollisions = true === n4.crossSourceCollisions, this._collectResourceTiming = true === n4.collectResourceTiming, this._locale = Object.assign(Object.assign({}, qa), n4.locale), this._clickTolerance = n4.clickTolerance, this._overridePixelRatio = n4.pixelRatio, this._maxCanvasSize = n4.maxCanvasSize, this.transformCameraUpdate = n4.transformCameraUpdate, this.transformConstrain = n4.transformConstrain, this.cancelPendingTileRequestsWhileZooming = true === n4.cancelPendingTileRequestsWhileZooming, this._imageQueueHandle = g2.addThrottleControl((() => this.isMoving())), this._requestManager = new _2(n4.transformRequest), typeof n4.container == `string`) {
            if (this._container = document.getElementById(n4.container), !this._container) throw Error(`Container '${n4.container}' not found.`);
          } else {
            if (!(n4.container instanceof HTMLElement)) throw Error(`Invalid type: 'container' must be a String or HTMLElement.`);
            this._container = n4.container;
          }
          if (n4.maxBounds && this.setMaxBounds(n4.maxBounds), this._setupContainer(), this._setupPainter(), this.on(`move`, (() => this._update(false))), this.on(`moveend`, (() => this._update(false))), this.on(`zoom`, (() => this._update(true))), this.on(`terrain`, (() => {
            this.painter.terrainFacilitator.dirty = true, this._update(true);
          })), this.once(`idle`, (() => {
            this._idleTriggered = true;
          })), typeof window < `u`) {
            addEventListener(`online`, this._onWindowOnline, false);
            let e7 = false, t5 = Vi(((e8) => {
              this._trackResize && !this._removed && (this.resize(e8), this.redraw());
            }), 50);
            this._resizeObserver = new ResizeObserver(((n5) => {
              e7 ? t5(n5) : e7 = true;
            })), this._resizeObserver.observe(this._container);
          }
          this.handlers = new La(this, n4), this._hash = n4.hash && new Hi(typeof n4.hash == `string` && n4.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: n4.center, elevation: n4.elevation, zoom: n4.zoom, bearing: n4.bearing, pitch: n4.pitch, roll: n4.roll }), n4.bounds && (this.resize(), this.fitBounds(n4.bounds, t4.e({}, n4.fitBoundsOptions, { duration: 0 }))));
          let a3 = typeof n4.style == `string` || ((_b2 = (_a3 = n4.style) == null ? void 0 : _a3.projection) == null ? void 0 : _b2.type) !== `globe`;
          this.resize(null, a3), this._localIdeographFontFamily = n4.localIdeographFontFamily, this._validateStyle = n4.validateStyle, n4.style && this.setStyle(n4.style, { localIdeographFontFamily: n4.localIdeographFontFamily }), n4.attributionControl && this.addControl(new $(typeof n4.attributionControl == `boolean` ? void 0 : n4.attributionControl)), n4.maplibreLogo && this.addControl(new za(), n4.logoPosition), this.on(`style.load`, (() => {
            if (a3 || this._resizeTransform(), this.transform.unmodified) {
              let e7 = t4.S(this.style.stylesheet, [`center`, `zoom`, `bearing`, `pitch`, `roll`]);
              this.jumpTo(e7);
            }
          })), this.on(`data`, ((e7) => {
            this._update(e7.dataType === `style`), this.fire(new t4.l(`${e7.dataType}data`, e7));
          })), this.on(`dataloading`, ((e7) => {
            this.fire(new t4.l(`${e7.dataType}dataloading`, e7));
          })), this.on(`dataabort`, ((e7) => {
            this.fire(new t4.l(`sourcedataabort`, e7));
          }));
        }
        _getMapId() {
          return this._mapId;
        }
        setGlobalStateProperty(e6, t5) {
          return this.style.setGlobalStateProperty(e6, t5), this._update(true);
        }
        getGlobalState() {
          return this.style.getGlobalState();
        }
        addControl(e6, n4) {
          if (n4 === void 0 && (n4 = e6.getDefaultPosition ? e6.getDefaultPosition() : `top-right`), !e6 || !e6.onAdd) return this.fire(new t4.k(Error(`Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.`)));
          let r3 = e6.onAdd(this);
          this._controls.push(e6);
          let i3 = this._controlPositions[n4];
          return n4.indexOf(`bottom`) === -1 ? i3.appendChild(r3) : i3.insertBefore(r3, i3.firstChild), this;
        }
        removeControl(e6) {
          if (!e6 || !e6.onRemove) return this.fire(new t4.k(Error(`Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.`)));
          let n4 = this._controls.indexOf(e6);
          return n4 > -1 && this._controls.splice(n4, 1), e6.onRemove(this), this;
        }
        hasControl(e6) {
          return this._controls.indexOf(e6) > -1;
        }
        coveringTiles(e6) {
          return Be2(this.transform, e6);
        }
        calculateCameraOptionsFromTo(e6, t5, n4, r3) {
          return r3 == null && this.terrain && (r3 = this.terrain.getElevationForLngLatZoom(n4, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(e6, t5, n4, r3);
        }
        resize(e6, n4 = true) {
          let [r3, i3] = this._containerDimensions(), a3 = this._getClampedPixelRatio(r3, i3);
          if (this._resizeCanvas(r3, i3, a3), this.painter.resize(r3, i3, a3), this.painter.overLimit()) {
            let e7 = this.painter.context.gl;
            this._maxCanvasSize = [e7.drawingBufferWidth, e7.drawingBufferHeight];
            let t5 = this._getClampedPixelRatio(r3, i3);
            this._resizeCanvas(r3, i3, t5), this.painter.resize(r3, i3, t5);
          }
          this._resizeTransform(n4);
          let o3 = !this._moving;
          return o3 && (this.stop(), this.fire(new t4.l(`movestart`, e6)).fire(new t4.l(`move`, e6))), this.fire(new t4.l(`resize`, e6)), o3 && this.fire(new t4.l(`moveend`, e6)), this;
        }
        _resizeTransform(e6 = true) {
          var t5;
          let [n4, r3] = this._containerDimensions();
          this.transform.resize(n4, r3, e6), (t5 = this._requestedCameraState) == null || t5.resize(n4, r3, e6);
        }
        _getClampedPixelRatio(e6, t5) {
          let { 0: n4, 1: r3 } = this._maxCanvasSize, i3 = this.getPixelRatio(), a3 = e6 * i3, o3 = t5 * i3;
          return Math.min(a3 > n4 ? n4 / a3 : 1, o3 > r3 ? r3 / o3 : 1) * i3;
        }
        getPixelRatio() {
          return this._overridePixelRatio ?? devicePixelRatio;
        }
        setPixelRatio(e6) {
          this._overridePixelRatio = e6, this.resize();
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds();
        }
        setMaxBounds(e6) {
          return this.transform.setMaxBounds(ue2.convert(e6)), this._update();
        }
        setMinZoom(e6) {
          if ((e6 ?? (e6 = -2)) >= -2 && e6 <= this.transform.maxZoom) return this.transform.setMinZoom(e6), this._update(), this.getZoom() < e6 && this.setZoom(e6), this;
          throw Error(`minZoom must be between -2 and the current maxZoom, inclusive`);
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(e6) {
          if ((e6 ?? (e6 = 22)) >= this.transform.minZoom) return this.transform.setMaxZoom(e6), this._update(), this.getZoom() > e6 && this.setZoom(e6), this;
          throw Error(`maxZoom must be greater than the current minZoom`);
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(e6) {
          if ((e6 ?? (e6 = 0)) < 0) throw Error(`minPitch must be greater than or equal to 0`);
          if (e6 >= 0 && e6 <= this.transform.maxPitch) return this.transform.setMinPitch(e6), this._update(), this.getPitch() < e6 && this.setPitch(e6), this;
          throw Error(`minPitch must be between 0 and the current maxPitch, inclusive`);
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(e6) {
          if ((e6 ?? (e6 = 60)) > 180) throw Error(`maxPitch must be less than or equal to 180`);
          if (e6 >= this.transform.minPitch) return this.transform.setMaxPitch(e6), this._update(), this.getPitch() > e6 && this.setPitch(e6), this;
          throw Error(`maxPitch must be greater than the current minPitch`);
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(e6) {
          return this.transform.setRenderWorldCopies(e6), this._update();
        }
        setTransformConstrain(e6) {
          return this.transform.setConstrain(e6), this._update();
        }
        project(e6) {
          return this.transform.locationToScreenPoint(t4.U.convert(e6), this.style && this.terrain);
        }
        unproject(e6) {
          return this.transform.screenPointToLocation(t4.P.convert(e6), this.terrain);
        }
        isMoving() {
          var _a3;
          return this._moving || ((_a3 = this.handlers) == null ? void 0 : _a3.isMoving());
        }
        isZooming() {
          var _a3;
          return this._zooming || ((_a3 = this.handlers) == null ? void 0 : _a3.isZooming());
        }
        isRotating() {
          var _a3;
          return this._rotating || ((_a3 = this.handlers) == null ? void 0 : _a3.isRotating());
        }
        _createDelegatedListener(e6, t5, n4) {
          if (e6 === `mouseenter` || e6 === `mouseover`) {
            let r3 = false;
            return { layers: t5, listener: n4, delegates: { mousemove: (i3) => {
              let a3 = t5.filter(((e7) => this.getLayer(e7))), o3 = a3.length === 0 ? [] : this.queryRenderedFeatures(i3.point, { layers: a3 });
              o3.length ? r3 || (r3 = true, n4.call(this, new Qi(e6, this, i3.originalEvent, { features: o3 }))) : r3 = false;
            }, mouseout: () => {
              r3 = false;
            } } };
          }
          if (e6 === `mouseleave` || e6 === `mouseout`) {
            let r3 = false;
            return { layers: t5, listener: n4, delegates: { mousemove: (i3) => {
              let a3 = t5.filter(((e7) => this.getLayer(e7)));
              (a3.length === 0 ? [] : this.queryRenderedFeatures(i3.point, { layers: a3 })).length ? r3 = true : r3 && (r3 = false, n4.call(this, new Qi(e6, this, i3.originalEvent)));
            }, mouseout: (t6) => {
              r3 && (r3 = false, n4.call(this, new Qi(e6, this, t6.originalEvent)));
            } } };
          }
          {
            let r3 = (e7) => {
              let r4 = t5.filter(((e8) => this.getLayer(e8))), i3 = r4.length === 0 ? [] : this.queryRenderedFeatures(e7.point, { layers: r4 });
              i3.length && (e7.features = i3, n4.call(this, e7), delete e7.features);
            };
            return { layers: t5, listener: n4, delegates: { [e6]: r3 } };
          }
        }
        _saveDelegatedListener(e6, t5) {
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e6] = this._delegatedListeners[e6] || [], this._delegatedListeners[e6].push(t5);
        }
        _removeDelegatedListener(e6, t5, n4) {
          if (!this._delegatedListeners || !this._delegatedListeners[e6]) return;
          let r3 = this._delegatedListeners[e6];
          for (let e7 = 0; e7 < r3.length; e7++) {
            let i3 = r3[e7];
            if (i3.listener === n4 && i3.layers.length === t5.length && i3.layers.every(((e8) => t5.includes(e8)))) {
              for (let e8 in i3.delegates) this.off(e8, i3.delegates[e8]);
              r3.splice(e7, 1);
              return;
            }
          }
        }
        on(e6, t5, n4) {
          if (n4 === void 0) return super.on(e6, t5);
          let r3 = typeof t5 == `string` ? [t5] : t5, i3 = this._createDelegatedListener(e6, r3, n4);
          for (let t6 in this._saveDelegatedListener(e6, i3), i3.delegates) this.on(t6, i3.delegates[t6]);
          return { unsubscribe: () => {
            this._removeDelegatedListener(e6, r3, n4);
          } };
        }
        once(e6, t5, n4) {
          if (n4 === void 0) return super.once(e6, t5);
          let r3 = typeof t5 == `string` ? [t5] : t5, i3 = this._createDelegatedListener(e6, r3, n4);
          for (let t6 in i3.delegates) {
            let a3 = i3.delegates[t6];
            i3.delegates[t6] = (...t7) => {
              this._removeDelegatedListener(e6, r3, n4), a3(...t7);
            };
          }
          for (let t6 in this._saveDelegatedListener(e6, i3), i3.delegates) this.once(t6, i3.delegates[t6]);
          return this;
        }
        off(e6, t5, n4) {
          return n4 === void 0 ? super.off(e6, t5) : (this._removeDelegatedListener(e6, typeof t5 == `string` ? [t5] : t5, n4), this);
        }
        queryRenderedFeatures(e6, n4) {
          if (!this.style) return [];
          let r3, i3 = e6 instanceof t4.P || Array.isArray(e6), a3 = i3 ? e6 : [[0, 0], [this.transform.width, this.transform.height]];
          if (n4 = n4 || (i3 ? {} : e6) || {}, a3 instanceof t4.P || typeof a3[0] == `number`) r3 = [t4.P.convert(a3)];
          else {
            let e7 = t4.P.convert(a3[0]), n5 = t4.P.convert(a3[1]);
            r3 = [e7, new t4.P(n5.x, e7.y), n5, new t4.P(e7.x, n5.y), e7];
          }
          return this.style.queryRenderedFeatures(r3, n4, this.transform);
        }
        querySourceFeatures(e6, t5) {
          return this.style.querySourceFeatures(e6, t5);
        }
        setStyle(e6, n4) {
          return false !== (n4 = t4.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, n4)).diff && n4.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e6 ? (this._diffStyle(e6, n4), this) : (this._localIdeographFontFamily = n4.localIdeographFontFamily, this._updateStyle(e6, n4));
        }
        setTransformRequest(e6) {
          return this._requestManager.setTransformRequest(e6), this;
        }
        _getUIString(e6) {
          let t5 = this._locale[e6];
          if (t5 == null) throw Error(`Missing UI string '${e6}'`);
          return t5;
        }
        _updateStyle(e6, t5) {
          var _a3;
          var n4;
          if (t5.transformStyle && this.style && !this.style._loaded) return void this.style.once(`style.load`, (() => this._updateStyle(e6, t5)));
          let r3 = this.style && t5.transformStyle ? this.style.serialize() : void 0;
          return this.style && (this.style.setEventedParent(null), this.style._remove(!e6)), e6 ? (this.style = new jn(this, t5 || {}), this.style.setEventedParent(this, { style: this.style }), typeof e6 == `string` ? this.style.loadURL(e6, t5, r3) : this.style.loadJSON(e6, t5, r3), this) : ((n4 = (_a3 = this.style) == null ? void 0 : _a3.projection) == null || n4.destroy(), delete this.style, this);
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new jn(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(e6, n4) {
          if (typeof e6 == `string`) {
            let r3 = this._requestManager.transformRequest(e6, `Style`);
            t4.j(r3, new AbortController()).then(((e7) => {
              this._updateDiff(e7.data, n4);
            })).catch(((e7) => {
              e7 && this.fire(new t4.k(e7));
            }));
          } else typeof e6 == `object` && this._updateDiff(e6, n4);
        }
        _updateDiff(e6, n4) {
          try {
            this.style.setState(e6, n4) && this._update(true);
          } catch (r3) {
            t4.w(`Unable to perform style diff: ${r3.message || r3.error || r3}.  Rebuilding the style from scratch.`), this._updateStyle(e6, n4);
          }
        }
        getStyle() {
          if (this.style) return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : t4.w(`There is no style added to the map.`);
        }
        addSource(e6, t5) {
          return this._lazyInitEmptyStyle(), this.style.addSource(e6, t5), this._update(true);
        }
        isSourceLoaded(e6) {
          let n4 = this.style && this.style.tileManagers[e6];
          if (n4 !== void 0) return n4.loaded();
          this.fire(new t4.k(Error(`There is no tile manager with ID '${e6}'`)));
        }
        setTerrain(e6) {
          if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off(`data`, this._terrainDataCallback), e6) {
            let n4 = this.style.tileManagers[e6.source];
            if (!n4) throw Error(`cannot load terrain, because there exists no source with ID: ${e6.source}`);
            for (let r3 in this.terrain === null && n4.reload(), this.style._layers) {
              let n5 = this.style._layers[r3];
              n5.type === `hillshade` && n5.source === e6.source && t4.w(`You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.`), n5.type === `color-relief` && n5.source === e6.source && t4.w(`You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.`);
            }
            this.terrain = new Ua(this.painter, n4, e6), this.painter.renderToTexture = new Ka(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (t5) => {
              var _a3;
              t5.dataType === `style` ? this.terrain.tileManager.freeRtt() : t5.dataType === `source` && t5.tile && (t5.sourceId !== e6.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((_a3 = t5.source) == null ? void 0 : _a3.type) === `image` ? this.terrain.tileManager.freeRtt() : this.terrain.tileManager.freeRtt(t5.tile.tileID));
            }, this.style.on(`data`, this._terrainDataCallback);
          } else this.terrain && this.terrain.tileManager.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
          return this.fire(new t4.l(`terrain`, { terrain: e6 })), this;
        }
        getTerrain() {
          var _a3;
          return ((_a3 = this.terrain) == null ? void 0 : _a3.options) ?? null;
        }
        areTilesLoaded() {
          let e6 = this.style && this.style.tileManagers;
          for (let t5 in e6) {
            let n4 = e6[t5]._tiles;
            for (let e7 in n4) {
              let t6 = n4[e7];
              if (t6.state !== `loaded` && t6.state !== `errored`) return false;
            }
          }
          return true;
        }
        removeSource(e6) {
          return this.style.removeSource(e6), this._update(true);
        }
        getSource(e6) {
          return this.style.getSource(e6);
        }
        setSourceTileLodParams(e6, t5, n4) {
          if (n4) {
            let r3 = this.getSource(n4);
            if (!r3) throw Error(`There is no source with ID "${n4}", cannot set LOD parameters`);
            r3.calculateTileZoom = Le2(Math.max(1, e6), Math.max(1, t5));
          } else for (let n5 in this.style.tileManagers) this.style.tileManagers[n5].getSource().calculateTileZoom = Le2(Math.max(1, e6), Math.max(1, t5));
          return this._update(true), this;
        }
        refreshTiles(e6, n4) {
          let r3 = this.style.tileManagers[e6];
          if (!r3) throw Error(`There is no tile manager with ID "${e6}", cannot refresh tile`);
          n4 === void 0 ? r3.reload(true) : r3.refreshTiles(n4.map(((e7) => new t4.a8(e7.z, e7.x, e7.y))));
        }
        addImage(e6, n4, r3 = {}) {
          let { pixelRatio: i3 = 1, sdf: a3 = false, stretchX: s3, stretchY: c3, content: l3, textFitWidth: u3, textFitHeight: d3 } = r3;
          if (this._lazyInitEmptyStyle(), !(n4 instanceof HTMLImageElement || t4.b(n4))) {
            if (n4.width === void 0 || n4.height === void 0) return this.fire(new t4.k(Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            {
              let { width: r4, height: o3, data: f3 } = n4, p3 = n4;
              return this.style.addImage(e6, { data: new t4.R({ width: r4, height: o3 }, new Uint8Array(f3)), pixelRatio: i3, stretchX: s3, stretchY: c3, content: l3, textFitWidth: u3, textFitHeight: d3, sdf: a3, version: 0, userImage: p3 }), p3.onAdd && p3.onAdd(this, e6), this;
            }
          }
          {
            let { width: r4, height: f3, data: p3 } = o2.getImageData(n4);
            this.style.addImage(e6, { data: new t4.R({ width: r4, height: f3 }, p3), pixelRatio: i3, stretchX: s3, stretchY: c3, content: l3, textFitWidth: u3, textFitHeight: d3, sdf: a3, version: 0 });
          }
        }
        updateImage(e6, n4) {
          let r3 = this.style.getImage(e6);
          if (!r3) return this.fire(new t4.k(Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          let { width: i3, height: a3, data: s3 } = n4 instanceof HTMLImageElement || t4.b(n4) ? o2.getImageData(n4) : n4;
          if (i3 === void 0 || a3 === void 0) return this.fire(new t4.k(Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (i3 !== r3.data.width || a3 !== r3.data.height) return this.fire(new t4.k(Error(`The width and height of the updated image must be that same as the previous version of the image`)));
          let c3 = !(n4 instanceof HTMLImageElement || t4.b(n4));
          return r3.data.replace(s3, c3), this.style.updateImage(e6, r3), this;
        }
        getImage(e6) {
          return this.style.getImage(e6);
        }
        hasImage(e6) {
          return e6 ? !!this.style.getImage(e6) : (this.fire(new t4.k(Error(`Missing required image id`))), false);
        }
        removeImage(e6) {
          this.style.removeImage(e6);
        }
        loadImage(e6) {
          return g2.getImage(this._requestManager.transformRequest(e6, `Image`), new AbortController());
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(e6, t5) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(e6, t5), this._update(true);
        }
        moveLayer(e6, t5) {
          return this.style.moveLayer(e6, t5), this._update(true);
        }
        removeLayer(e6) {
          return this.style.removeLayer(e6), this._update(true);
        }
        getLayer(e6) {
          return this.style.getLayer(e6);
        }
        getLayersOrder() {
          return this.style.getLayersOrder();
        }
        setLayerZoomRange(e6, t5, n4) {
          return this.style.setLayerZoomRange(e6, t5, n4), this._update(true);
        }
        setFilter(e6, t5, n4 = {}) {
          return this.style.setFilter(e6, t5, n4), this._update(true);
        }
        getFilter(e6) {
          return this.style.getFilter(e6);
        }
        setPaintProperty(e6, t5, n4, r3 = {}) {
          return this.style.setPaintProperty(e6, t5, n4, r3), this._update(true);
        }
        getPaintProperty(e6, t5) {
          return this.style.getPaintProperty(e6, t5);
        }
        setLayoutProperty(e6, t5, n4, r3 = {}) {
          return this.style.setLayoutProperty(e6, t5, n4, r3), this._update(true);
        }
        getLayoutProperty(e6, t5) {
          return this.style.getLayoutProperty(e6, t5);
        }
        setGlyphs(e6, t5 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setGlyphs(e6, t5), this._update(true);
        }
        getGlyphs() {
          return this.style.getGlyphsUrl();
        }
        addSprite(e6, t5, n4 = {}) {
          return this._lazyInitEmptyStyle(), this.style.addSprite(e6, t5, n4, ((e7) => {
            e7 || this._update(true);
          })), this;
        }
        removeSprite(e6) {
          return this._lazyInitEmptyStyle(), this.style.removeSprite(e6), this._update(true);
        }
        getSprite() {
          return this.style.getSprite();
        }
        setSprite(e6, t5 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setSprite(e6, t5, ((e7) => {
            e7 || this._update(true);
          })), this;
        }
        setLight(e6, t5 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setLight(e6, t5), this._update(true);
        }
        getLight() {
          return this.style.getLight();
        }
        setSky(e6, t5 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setSky(e6, t5), this._update(true);
        }
        getSky() {
          return this.style.getSky();
        }
        setFeatureState(e6, t5) {
          return this.style.setFeatureState(e6, t5), this._update();
        }
        removeFeatureState(e6, t5) {
          return this.style.removeFeatureState(e6, t5), this._update();
        }
        getFeatureState(e6) {
          return this.style.getFeatureState(e6);
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        _containerDimensions() {
          let e6 = 0, t5 = 0;
          return this._container && (e6 = this._container.clientWidth || 400, t5 = this._container.clientHeight || 300), [e6, t5];
        }
        _setupContainer() {
          let e6 = this._container;
          e6.classList.add(`maplibregl-map`);
          let t5 = this._canvasContainer = l2.create(`div`, `maplibregl-canvas-container`, e6);
          this._interactive && t5.classList.add(`maplibregl-interactive`), this._canvas = l2.create(`canvas`, `maplibregl-canvas`, t5), this._canvas.addEventListener(`webglcontextlost`, this._contextLost, false), this._canvas.addEventListener(`webglcontextrestored`, this._contextRestored, false), this._canvas.setAttribute(`tabindex`, this._interactive ? `0` : `-1`), this._canvas.setAttribute(`aria-label`, this._getUIString(`Map.Title`)), this._canvas.setAttribute(`role`, `region`);
          let n4 = this._containerDimensions(), r3 = this._getClampedPixelRatio(n4[0], n4[1]);
          this._resizeCanvas(n4[0], n4[1], r3);
          let i3 = this._controlContainer = l2.create(`div`, `maplibregl-control-container`, e6), a3 = this._controlPositions = {};
          [`top-left`, `top-right`, `bottom-left`, `bottom-right`].forEach(((e7) => {
            a3[e7] = l2.create(`div`, `maplibregl-ctrl-${e7} `, i3);
          })), this._container.addEventListener(`scroll`, this._onMapScroll, false);
        }
        _resizeCanvas(e6, t5, n4) {
          this._canvas.width = Math.floor(n4 * e6), this._canvas.height = Math.floor(n4 * t5), this._canvas.style.width = `${e6}px`, this._canvas.style.height = `${t5}px`;
        }
        _setupPainter() {
          let e6 = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: true, depth: true, stencil: true, premultipliedAlpha: true }), t5 = null;
          this._canvas.addEventListener(`webglcontextcreationerror`, ((n5) => {
            t5 = { requestedAttributes: e6 }, n5 && (t5.statusMessage = n5.statusMessage, t5.type = n5.type);
          }), { once: true });
          let n4 = null;
          if (n4 = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, e6) : this._canvas.getContext(`webgl2`, e6) || this._canvas.getContext(`webgl`, e6), !n4) {
            let e7 = `Failed to initialize WebGL`;
            throw t5 ? (t5.message = e7, Error(JSON.stringify(t5))) : Error(e7);
          }
          this.painter = new Bi(n4, this.transform), u2.testSupport(n4);
        }
        migrateProjection(e6, n4) {
          super.migrateProjection(e6, n4), this.painter.transform = e6, this.fire(new t4.l(`projectiontransition`, { newProjection: this.style.projection.name }));
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(e6) {
          return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || e6, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(e6) {
          return this._update(), this._renderTaskQueue.add(e6);
        }
        _cancelRenderFrame(e6) {
          this._renderTaskQueue.remove(e6);
        }
        _render(e6) {
          var _a3, _b2, _c2, _d2;
          var n4;
          let r3 = this._idleTriggered ? this._fadeDuration : 0, i3 = ((_a3 = this.style.projection) == null ? void 0 : _a3.transitionState) > 0;
          if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e6), this._removed) return;
          let a3 = false;
          if (this.style && this._styleDirty) {
            this._styleDirty = false;
            let e7 = this.transform.zoom, n5 = c2();
            this.style.zoomHistory.update(e7, n5);
            let i4 = new t4.G(e7, { now: n5, fadeDuration: r3, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), o4 = i4.crossFadingFactor();
            o4 === 1 && o4 === this._crossFadingFactor || (a3 = true, this._crossFadingFactor = o4), this.style.update(i4);
          }
          let o3 = ((_b2 = this.style.projection) == null ? void 0 : _b2.transitionState) > 0 !== i3;
          (n4 = this.style.projection) == null || n4.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((_c2 = this.style.projection) == null ? void 0 : _c2.transitionState, (_d2 = this.style.projection) == null ? void 0 : _d2.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || o3) && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.tileManager.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, r3, this._crossSourceCollisions, o3), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: r3, showPadding: this.showPadding }), this.fire(new t4.l(`render`)), this.loaded() && !this._loaded && (this._loaded = true, t4.cz.mark(t4.cA.load), this.fire(new t4.l(`load`))), this.style && (this.style.hasTransitions() || a3) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
          let s3 = this._sourcesDirty || this._styleDirty || this._placementDirty;
          return s3 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t4.l(`idle`)), !this._loaded || this._fullyLoaded || s3 || (this._fullyLoaded = true, t4.cz.mark(t4.cA.fullLoad)), this;
        }
        redraw() {
          return this.style && (this._frameRequest && (this._frameRequest = (this._frameRequest.abort(), null)), this._render(0)), this;
        }
        remove() {
          var e6;
          this._hash && this._hash.remove();
          for (let e7 of this._controls) e7.onRemove(this);
          this._controls = [], this._frameRequest && (this._frameRequest = (this._frameRequest.abort(), null)), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < `u` && removeEventListener(`online`, this._onWindowOnline, false), g2.removeThrottleControl(this._imageQueueHandle), (e6 = this._resizeObserver) == null || e6.disconnect();
          let n4 = this.painter.context.gl.getExtension(`WEBGL_lose_context`);
          n4 != null && n4.loseContext && n4.loseContext(), this._canvas.removeEventListener(`webglcontextrestored`, this._contextRestored, false), this._canvas.removeEventListener(`webglcontextlost`, this._contextLost, false), l2.remove(this._canvasContainer), l2.remove(this._controlContainer), this._container.removeEventListener(`scroll`, this._onMapScroll, false), this._container.classList.remove(`maplibregl-map`), t4.cz.clearMetrics(), this._removed = true, this.fire(new t4.l(`remove`));
        }
        triggerRepaint() {
          this.style && !this._frameRequest && (this._frameRequest = new AbortController(), o2.frame(this._frameRequest, ((e6) => {
            t4.cz.frame(e6), this._frameRequest = null;
            try {
              this._render(e6);
            } catch (e7) {
              if (!t4.cB(e7) && !(function(e8) {
                return e8.message === ei;
              })(e7)) throw e7;
            }
          }), (() => {
          })));
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(e6) {
          this._showTileBoundaries !== e6 && (this._showTileBoundaries = e6, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(e6) {
          this._showPadding !== e6 && (this._showPadding = e6, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(e6) {
          this._showCollisionBoxes !== e6 && (this._showCollisionBoxes = e6, e6 ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(e6) {
          this._showOverdrawInspector !== e6 && (this._showOverdrawInspector = e6, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(e6) {
          this._repaint !== e6 && (this._repaint = e6, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(e6) {
          this._vertices = e6, this._update();
        }
        get version() {
          return Ja;
        }
        getCameraTargetElevation() {
          return this.transform.elevation;
        }
        getProjection() {
          return this.style.getProjection();
        }
        setProjection(e6) {
          return this._lazyInitEmptyStyle(), this.style.setProjection(e6), this._update(true);
        }
      }, e5.MapMouseEvent = Qi, e5.MapTouchEvent = $i, e5.MapWheelEvent = ea, e5.Marker = no, e5.NavigationControl = class {
        constructor(e6) {
          this._updateZoomButtons = () => {
            let e7 = this._map.getZoom(), t5 = e7 === this._map.getMaxZoom(), n4 = e7 === this._map.getMinZoom();
            this._zoomInButton.disabled = t5, this._zoomOutButton.disabled = n4, this._zoomInButton.setAttribute(`aria-disabled`, t5.toString()), this._zoomOutButton.setAttribute(`aria-disabled`, n4.toString());
          }, this._rotateCompassArrow = () => {
            this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.cos(this._map.transform.pitchInRadians) ** 0.5}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.cos(this._map.transform.pitchInRadians) ** 0.5}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
          }, this._setButtonTitle = (e7, t5) => {
            let n4 = this._map._getUIString(`NavigationControl.${t5}`);
            e7.title = n4, e7.setAttribute(`aria-label`, n4);
          }, this.options = t4.e({}, Xa, e6), this._container = l2.create(`div`, `maplibregl-ctrl maplibregl-ctrl-group`), this._container.addEventListener(`contextmenu`, ((e7) => e7.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton(`maplibregl-ctrl-zoom-in`, ((e7) => this._map.zoomIn({}, { originalEvent: e7 }))), l2.create(`span`, `maplibregl-ctrl-icon`, this._zoomInButton).setAttribute(`aria-hidden`, `true`), this._zoomOutButton = this._createButton(`maplibregl-ctrl-zoom-out`, ((e7) => this._map.zoomOut({}, { originalEvent: e7 }))), l2.create(`span`, `maplibregl-ctrl-icon`, this._zoomOutButton).setAttribute(`aria-hidden`, `true`)), this.options.showCompass && (this._compass = this._createButton(`maplibregl-ctrl-compass`, ((e7) => {
            this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e7 }) : this._map.resetNorth({}, { originalEvent: e7 });
          })), this._compassIcon = l2.create(`span`, `maplibregl-ctrl-icon`, this._compass), this._compassIcon.setAttribute(`aria-hidden`, `true`));
        }
        onAdd(e6) {
          return this._map = e6, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, `ZoomIn`), this._setButtonTitle(this._zoomOutButton, `ZoomOut`), this._map.on(`zoom`, this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, `ResetBearing`), this.options.visualizePitch && this._map.on(`pitch`, this._rotateCompassArrow), this.options.visualizeRoll && this._map.on(`roll`, this._rotateCompassArrow), this._map.on(`rotate`, this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Za(this._map, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          l2.remove(this._container), this.options.showZoom && this._map.off(`zoom`, this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off(`pitch`, this._rotateCompassArrow), this.options.visualizeRoll && this._map.off(`roll`, this._rotateCompassArrow), this._map.off(`rotate`, this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
        }
        _createButton(e6, t5) {
          let n4 = l2.create(`button`, e6, this._container);
          return n4.type = `button`, n4.addEventListener(`click`, t5), n4;
        }
      }, e5.Popup = class extends t4.E {
        constructor(e6) {
          super(), this._updateOpacity = () => {
            this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : ``);
          }, this.remove = () => (this._content && l2.remove(this._content), this._container && (l2.remove(this._container), delete this._container), this._map && (this._map.off(`move`, this._update), this._map.off(`move`, this._onClose), this._map.off(`click`, this._onClose), this._map.off(`remove`, this.remove), this._map.off(`mousemove`, this._onMouseMove), this._map.off(`mouseup`, this._onMouseUp), this._map.off(`drag`, this._onDrag), this._map._canvasContainer.classList.remove(`maplibregl-track-pointer`), delete this._map, this.fire(new t4.l(`close`))), this), this._onMouseUp = (e7) => {
            this._update(e7.point);
          }, this._onMouseMove = (e7) => {
            this._update(e7.point);
          }, this._onDrag = (e7) => {
            this._update(e7.point);
          }, this._update = (e7) => {
            if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
            if (!this._container) {
              if (this._container = l2.create(`div`, `maplibregl-popup`, this._map.getContainer()), this._tip = l2.create(`div`, `maplibregl-popup-tip`, this._container), this._container.appendChild(this._content), this.options.className) for (let e8 of this.options.className.split(` `)) this._container.classList.add(e8);
              this._closeButton && this._closeButton.setAttribute(`aria-label`, this._map._getUIString(`Popup.Close`)), this._trackPointer && this._container.classList.add(`maplibregl-popup-track-pointer`);
            }
            if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = $a(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e7) return;
            let t5 = this._flatPos = this._pos = this._trackPointer && e7 ? e7 : this._map.project(this._lngLat);
            this._map.terrain && (this._flatPos = this._trackPointer && e7 ? e7 : this._map.transform.locationToScreenPoint(this._lngLat));
            let n4 = this.options.anchor, r3 = fo(this.options.offset);
            if (!n4) {
              let e8 = this._container.offsetWidth, i4 = this._container.offsetHeight, a3;
              a3 = t5.y + r3.bottom.y < i4 ? [`top`] : t5.y > this._map.transform.height - i4 ? [`bottom`] : [], t5.x < e8 / 2 ? a3.push(`left`) : t5.x > this._map.transform.width - e8 / 2 && a3.push(`right`), n4 = a3.length === 0 ? `bottom` : a3.join(`-`);
            }
            let i3 = t5.add(r3[n4]);
            this.options.subpixelPositioning || (i3 = i3.round()), l2.setTransform(this._container, `${eo[n4]} translate(${i3.x}px,${i3.y}px)`), to(this._container, n4, `popup`), this._updateOpacity();
          }, this._onClose = () => {
            this.remove();
          }, this.options = t4.e(Object.create(lo), e6);
        }
        addTo(e6) {
          return this._map && this.remove(), this._map = e6, this.options.closeOnClick && this._map.on(`click`, this._onClose), this.options.closeOnMove && this._map.on(`move`, this._onClose), this._map.on(`remove`, this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on(`mousemove`, this._onMouseMove), this._map.on(`mouseup`, this._onMouseUp), this._container && this._container.classList.add(`maplibregl-popup-track-pointer`), this._map._canvasContainer.classList.add(`maplibregl-track-pointer`)) : this._map.on(`move`, this._update), this.fire(new t4.l(`open`)), this;
        }
        isOpen() {
          return !!this._map;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(e6) {
          return this._lngLat = t4.U.convert(e6), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on(`move`, this._update), this._map.off(`mousemove`, this._onMouseMove), this._container && this._container.classList.remove(`maplibregl-popup-track-pointer`), this._map._canvasContainer.classList.remove(`maplibregl-track-pointer`)), this;
        }
        trackPointer() {
          return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off(`move`, this._update), this._map.on(`mousemove`, this._onMouseMove), this._map.on(`drag`, this._onDrag), this._container && this._container.classList.add(`maplibregl-popup-track-pointer`), this._map._canvasContainer.classList.add(`maplibregl-track-pointer`)), this;
        }
        getElement() {
          return this._container;
        }
        setText(e6) {
          return this.setDOMContent(document.createTextNode(e6));
        }
        setHTML(e6) {
          let t5 = document.createDocumentFragment(), n4 = document.createElement(`body`), r3;
          for (n4.innerHTML = e6; r3 = n4.firstChild, r3; ) t5.appendChild(r3);
          return this.setDOMContent(t5);
        }
        getMaxWidth() {
          var _a3;
          return (_a3 = this._container) == null ? void 0 : _a3.style.maxWidth;
        }
        setMaxWidth(e6) {
          return this.options.maxWidth = e6, this._update(), this;
        }
        setDOMContent(e6) {
          if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else this._content = l2.create(`div`, `maplibregl-popup-content`, this._container);
          return this._content.appendChild(e6), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }
        addClassName(e6) {
          return this._container && this._container.classList.add(e6), this;
        }
        removeClassName(e6) {
          return this._container && this._container.classList.remove(e6), this;
        }
        setOffset(e6) {
          return this.options.offset = e6, this._update(), this;
        }
        toggleClassName(e6) {
          if (this._container) return this._container.classList.toggle(e6);
        }
        setSubpixelPositioning(e6) {
          this.options.subpixelPositioning = e6;
        }
        _createCloseButton() {
          this.options.closeButton && (this._closeButton = l2.create(`button`, `maplibregl-popup-close-button`, this._content), this._closeButton.type = `button`, this._closeButton.innerHTML = `&#215;`, this._closeButton.addEventListener(`click`, this._onClose));
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container) return;
          let e6 = this._container.querySelector(uo);
          e6 && e6.focus();
        }
      }, e5.RasterDEMTileSource = I2, e5.RasterTileSource = pe2, e5.ScaleControl = class {
        constructor(e6) {
          this._onMove = () => {
            so(this._map, this._container, this.options);
          }, this.setUnit = (e7) => {
            this.options.unit = e7, so(this._map, this._container, this.options);
          }, this.options = Object.assign(Object.assign({}, oo), e6);
        }
        getDefaultPosition() {
          return `bottom-left`;
        }
        onAdd(e6) {
          return this._map = e6, this._container = l2.create(`div`, `maplibregl-ctrl maplibregl-ctrl-scale`, e6.getContainer()), this._map.on(`move`, this._onMove), this._onMove(), this._container;
        }
        onRemove() {
          l2.remove(this._container), this._map.off(`move`, this._onMove), this._map = void 0;
        }
      }, e5.ScrollZoomHandler = Ea, e5.Style = jn, e5.TerrainControl = class {
        constructor(e6) {
          this._toggleTerrain = () => {
            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
          }, this._updateTerrainIcon = () => {
            this._terrainButton.classList.remove(`maplibregl-ctrl-terrain`), this._terrainButton.classList.remove(`maplibregl-ctrl-terrain-enabled`), this._map.terrain ? (this._terrainButton.classList.add(`maplibregl-ctrl-terrain-enabled`), this._terrainButton.title = this._map._getUIString(`TerrainControl.Disable`)) : (this._terrainButton.classList.add(`maplibregl-ctrl-terrain`), this._terrainButton.title = this._map._getUIString(`TerrainControl.Enable`));
          }, this.options = e6;
        }
        onAdd(e6) {
          return this._map = e6, this._container = l2.create(`div`, `maplibregl-ctrl maplibregl-ctrl-group`), this._terrainButton = l2.create(`button`, `maplibregl-ctrl-terrain`, this._container), l2.create(`span`, `maplibregl-ctrl-icon`, this._terrainButton).setAttribute(`aria-hidden`, `true`), this._terrainButton.type = `button`, this._terrainButton.addEventListener(`click`, this._toggleTerrain), this._updateTerrainIcon(), this._map.on(`terrain`, this._updateTerrainIcon), this._container;
        }
        onRemove() {
          l2.remove(this._container), this._map.off(`terrain`, this._updateTerrainIcon), this._map = void 0;
        }
      }, e5.TwoFingersTouchPitchHandler = xa, e5.TwoFingersTouchRotateHandler = ya, e5.TwoFingersTouchZoomHandler = _a2, e5.TwoFingersTouchZoomRotateHandler = Ma, e5.VectorTileSource = fe2, e5.VideoSource = ve2, e5.addSourceType = (e6, n4) => t4._(void 0, void 0, void 0, (function* () {
        if (be2(e6)) throw Error(`A source type called "${e6}" already exists.`);
        ((e7, t5) => {
          ye2[e7] = t5;
        })(e6, n4);
      })), e5.clearPrewarmedResources = function() {
        let e6 = ne2;
        e6 && (e6.isPreloaded() && e6.numActive() === 1 ? (e6.release(M2), ne2 = null) : console.warn(`Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()`));
      }, e5.createTileMesh = rn2, e5.getMaxParallelImageRequests = function() {
        return t4.a.MAX_PARALLEL_IMAGE_REQUESTS;
      }, e5.getRTLTextPluginStatus = function() {
        return we2().getRTLTextPluginStatus();
      }, e5.getVersion = function() {
        return po;
      }, e5.getWorkerCount = function() {
        return te2.workerCount;
      }, e5.getWorkerUrl = function() {
        return t4.a.WORKER_URL;
      }, e5.importScriptInWorkers = function(e6) {
        return ae2().broadcast(`IS`, e6);
      }, e5.isTimeFrozen = function() {
        return s2.isFrozen();
      }, e5.now = c2, e5.prewarm = function() {
        re2().acquire(M2);
      }, e5.restoreNow = function() {
        s2.restoreNow();
      }, e5.setMaxParallelImageRequests = function(e6) {
        t4.a.MAX_PARALLEL_IMAGE_REQUESTS = e6;
      }, e5.setNow = function(e6) {
        s2.setNow(e6);
      }, e5.setRTLTextPlugin = function(e6, t5) {
        return we2().setRTLTextPlugin(e6, t5);
      }, e5.setWorkerCount = function(e6) {
        te2.workerCount = e6;
      }, e5.setWorkerUrl = function(e6) {
        t4.a.WORKER_URL = e6;
      };
    })), e4;
  }));
})), W = at(), ot = Symbol(`map`), st = Symbol(`isLoaded`), ct = Symbol(`isInitialized`), lt = Symbol(`componentId`), ut = Symbol(`sourceId`), dt = Symbol(`sourceLayerRegistry`), ft = Symbol(`marker`), pt = `error.load.idle.remove.render.resize.webglcontextlost.webglcontextrestored.dataloading.data.tiledataloading.sourcedataloading.styledataloading.sourcedata.styledata.styleimagemissing.dataabort.sourcedataabort.boxzoomcancel.boxzoomstart.boxzoomend.touchcancel.touchmove.touchend.touchstart.click.contextmenu.dblclick.mousemove.mouseup.mousedown.mouseout.mouseover.movestart.move.moveend.zoomstart.zoom.zoomend.rotatestart.rotate.rotateend.dragstart.drag.dragend.pitchstart.pitch.pitchend.wheel.terrain.cooperativegestureprevented`.split(`.`);
function mt(e3, t2, n2, r2) {
  return (i2) => n2.emit(r2, { type: i2.type, map: t2, component: e3, event: i2 });
}
function ht(e3, t2) {
  let n2 = W.LngLat.convert(e3), r2 = W.LngLat.convert(t2);
  return n2.lng === r2.lng && n2.lat === r2.lat;
}
var gt = ((e3) => (e3.TOP_LEFT = `top-left`, e3.TOP_RIGHT = `top-right`, e3.BOTTOM_LEFT = `bottom-left`, e3.BOTTOM_RIGHT = `bottom-right`, e3))(gt || {}), _t = Object.values(gt), vt = /* @__PURE__ */ new Map(), yt = Symbol(`default`);
function bt(e3, t2, n2 = yt) {
  var _a2;
  let r2 = vt.get(n2);
  return r2 || (r2 = ee({ isLoaded: false, isMounted: false, language: null }), vt.set(n2, r2)), r2.isLoaded = ((_a2 = t2.value) == null ? void 0 : _a2.loaded()) || false, r2.isMounted = false, r2.component = e3, r2.map = t2.value, r2;
}
var xt = I({ name: `MglMap`, props: { width: { type: [Number, String], default: `100%` }, height: { type: [Number, String], default: `100%` }, attributionControl: { type: [Boolean, Object], default: void 0 }, bearing: { type: Number }, bearingSnap: { type: Number }, bounds: { type: [Array, Object] }, boxZoom: { type: Boolean, default: void 0 }, center: { type: [Array, Object] }, clickTolerance: { type: Number }, collectResourceTiming: { type: Boolean, default: void 0 }, crossSourceCollisions: { type: Boolean, default: void 0 }, dragPan: { type: Boolean, default: void 0 }, dragRotate: { type: Boolean, default: void 0 }, doubleClickZoom: { type: Boolean, default: void 0 }, hash: { type: [Boolean, String], default: void 0 }, fadeDuration: { type: Number }, fitBoundsOptions: { type: Object }, interactive: { type: Boolean, default: void 0 }, keyboard: { type: Boolean, default: void 0 }, locale: { type: Object }, localIdeographFontFamily: { type: String }, logoPosition: { type: [String], validator: (e3) => e3 in gt }, maxBounds: { type: [Array, Object] }, maxPitch: { type: Number }, maxZoom: { type: Number }, minPitch: { type: Number }, minZoom: { type: Number }, pitch: { type: Number }, pitchWithRotate: { type: Boolean, default: void 0 }, canvasContextAttributes: { type: Object }, refreshExpiredTiles: { type: Boolean, default: void 0 }, renderWorldCopies: { type: Boolean, default: void 0 }, scrollZoom: { type: Boolean, default: void 0 }, mapStyle: { type: [String, Object] }, trackResize: { type: Boolean, default: void 0 }, transformRequest: { type: Function }, transformCameraUpdate: { type: Function }, touchZoomRotate: { type: Boolean, default: void 0 }, touchPitch: { type: Boolean, default: void 0 }, zoom: { type: Number }, maxTileCacheSize: { type: Number }, mapKey: { type: [String, Symbol] }, pixelRatio: { type: Number }, validateStyle: { type: Boolean, default: void 0 }, cooperativeGestures: { type: Boolean } }, emits: `map:error.map:load.map:idle.map:remove.map:render.map:resize.map:webglcontextlost.map:webglcontextrestored.map:dataloading.map:data.map:tiledataloading.map:sourcedataloading.map:styledataloading.map:sourcedata.map:styledata.map:styleimagemissing.map:dataabort.map:sourcedataabort.map:boxzoomcancel.map:boxzoomstart.map:boxzoomend.map:touchcancel.map:touchmove.map:touchend.map:touchstart.map:click.map:contextmenu.map:dblclick.map:mousemove.map:mouseup.map:mousedown.map:mouseout.map:mouseover.map:movestart.map:move.map:moveend.map:zoomstart.map:zoom.map:zoomend.map:rotatestart.map:rotate.map:rotateend.map:dragstart.map:drag.map:dragend.map:pitchstart.map:pitch.map:pitchend.map:wheel.map:terrain.map:cooperativegestureprevented.map:projectiontransition.update:center.update:zoom.update:pitch.update:bearing`.split(`.`), slots: Object, setup(e3, t2) {
  let n2 = P(le()), r2 = re(), i2 = re(), a2 = A(false), o2 = A(false), s2 = /* @__PURE__ */ new Map(), c2 = bt(n2, i2, e3.mapKey);
  E(ot, i2), E(st, o2), E(ct, a2), E(lt, n2.uid), E(ut, ``), j(() => e3.bearing, (e4) => {
    var _a2;
    e4 && ((_a2 = i2.value) == null ? void 0 : _a2.setBearing(e4));
  }), j(() => e3.bounds, (t3) => {
    var _a2;
    t3 && ((_a2 = i2.value) == null ? void 0 : _a2.fitBounds(t3, e3.fitBoundsOptions));
  }), j(() => e3.center, (e4) => {
    var _a2, _b2;
    let t3 = (_a2 = i2.value) == null ? void 0 : _a2.getCenter();
    e4 && t3 && !ht(e4, t3) && ((_b2 = i2.value) == null ? void 0 : _b2.setCenter(e4));
  }), j(() => e3.maxBounds, (e4) => {
    var _a2;
    e4 && ((_a2 = i2.value) == null ? void 0 : _a2.setMaxBounds(e4));
  }), j(() => e3.maxPitch, (e4) => {
    var _a2;
    e4 && ((_a2 = i2.value) == null ? void 0 : _a2.setMaxPitch(e4));
  }), j(() => e3.maxZoom, (e4) => {
    var _a2;
    e4 && ((_a2 = i2.value) == null ? void 0 : _a2.setMaxZoom(e4));
  }), j(() => e3.minPitch, (e4) => {
    var _a2;
    e4 && ((_a2 = i2.value) == null ? void 0 : _a2.setMinPitch(e4));
  }), j(() => e3.minZoom, (e4) => {
    var _a2;
    e4 && ((_a2 = i2.value) == null ? void 0 : _a2.setMinZoom(e4));
  }), j(() => e3.pitch, (e4) => {
    var _a2;
    e4 && ((_a2 = i2.value) == null ? void 0 : _a2.setPitch(e4));
  }), j(() => e3.renderWorldCopies, (e4) => {
    var _a2;
    e4 && ((_a2 = i2.value) == null ? void 0 : _a2.setRenderWorldCopies(e4));
  }), j(() => e3.mapStyle, (e4) => {
    var _a2;
    e4 && ((_a2 = i2.value) == null ? void 0 : _a2.setStyle(e4));
  }), j(() => e3.transformRequest, (e4) => {
    var _a2;
    e4 && ((_a2 = i2.value) == null ? void 0 : _a2.setTransformRequest(e4));
  }), j(() => e3.zoom, (e4) => {
    var _a2;
    e4 && ((_a2 = i2.value) == null ? void 0 : _a2.setZoom(e4));
  }), j(() => e3.zoom, (e4) => {
    var _a2;
    e4 && ((_a2 = i2.value) == null ? void 0 : _a2.setZoom(e4));
  });
  function l2() {
    c2.isMounted = true;
    let l3 = { ...e3, style: e3.mapStyle, container: r2.value };
    for (let e4 of Object.keys(l3)) l3[e4] === void 0 && delete l3[e4];
    if (i2.value = P(new W.Map(l3)), c2.map = i2.value, a2.value = true, s2.set(`__load`, () => (o2.value = true, c2.isLoaded = true)), i2.value.on(`load`, s2.get(`__load`)), s2.set(`__moveend`, () => t2.emit(`update:center`, i2.value.getCenter())), i2.value.on(`moveend`, s2.get(`__moveend`)), s2.set(`__zoomend`, () => t2.emit(`update:zoom`, i2.value.getZoom())), i2.value.on(`zoomend`, s2.get(`__zoomend`)), s2.set(`__pitchend`, () => t2.emit(`update:pitch`, i2.value.getPitch())), i2.value.on(`pitchend`, s2.get(`__pitchend`)), s2.set(`__rotateend`, () => t2.emit(`update:bearing`, i2.value.getBearing())), i2.value.on(`rotateend`, s2.get(`__rotateend`)), n2.vnode.props) {
      for (let e4 of pt) if (n2.vnode.props[`onMap:` + e4]) {
        let r3 = `map:${e4}`, a3 = mt(n2, i2.value, t2, r3);
        s2.set(e4, a3), i2.value.on(e4, a3);
      }
    }
    i2.value.getCanvas().addEventListener(`webglcontextlost`, d2);
  }
  async function u2() {
    c2.isMounted = false, c2.isLoaded = false, o2.value = false, i2.value && (i2.value.getCanvas().removeEventListener(`webglcontextlost`, d2), a2.value = false, s2.forEach((e4, t3) => {
      i2.value.off(t3.startsWith(`__`) ? t3.substring(2) : t3, e4);
    }), i2.value.remove());
  }
  function d2() {
    u2(), te(l2);
  }
  return D(l2), N(u2), t2.expose({ map: i2 }), () => [F(`div`, { ref: r2, style: { height: e3.height, width: e3.width } }), a2.value && t2.slots.default ? t2.slots.default({}) : void 0];
}, render() {
  return null;
} });
function St(e3, t2, n2) {
  j(e3, (e4) => {
    var _a2, _b2;
    e4 && _t.indexOf(e4) === -1 || (((_a2 = t2.value) == null ? void 0 : _a2.hasControl(n2)) && t2.value.removeControl(n2), (_b2 = t2.value) == null ? void 0 : _b2.addControl(n2, e4));
  }, { immediate: true });
}
function Ct(e3, t2) {
  let n2 = ye(ot), r2 = ye(ct), i2 = re();
  return i2.value = e3(), St(() => t2.position, n2, i2.value), N(() => {
    var _a2;
    return r2.value && ((_a2 = n2.value) == null ? void 0 : _a2.removeControl(i2.value));
  }), { control: i2, map: n2 };
}
I({ name: `MglAttributionControl`, props: { position: { type: String, validator: (e3) => _t.indexOf(e3) !== -1 }, compact: Boolean, customAttribution: [String, Array] }, setup(e3) {
  Ct(() => new W.AttributionControl({ compact: e3.compact, customAttribution: e3.customAttribution }), e3);
}, render() {
  return null;
} });
var wt = class {
  constructor(e3, t2) {
    __publicField(this, "container");
    this.isAdded = e3, this.container = document.createElement(`div`), this.setClasses(t2);
  }
  getDefaultPosition() {
    return gt.TOP_LEFT;
  }
  onAdd() {
    return te(() => this.isAdded.value = true), this.container;
  }
  onRemove() {
    this.isAdded.value = false, this.container.remove();
  }
  setClasses(e3) {
    this.container.className = e3;
  }
}, Tt = I({ name: `MglCustomControl`, props: { position: { type: String, validator: (e3) => _t.indexOf(e3) !== -1 }, class: { type: String, default: `maplibregl-ctrl maplibregl-ctrl-group` } }, slots: Object, setup(e3, { slots: t2 }) {
  let n2 = A(false), { control: r2 } = Ct(() => new wt(n2, e3.class), e3);
  return j(() => e3.class, () => r2.value.setClasses(e3.class)), () => {
    var _a2;
    return n2.value ? F(he, { to: r2.value.container }, (_a2 = t2.default) == null ? void 0 : _a2.call(t2, {})) : fe(`custom-component`);
  };
}, render() {
  return null;
} }), Et = I({ name: `MglFullscreenControl`, props: { position: { type: String, validator: (e3) => _t.indexOf(e3) !== -1 }, container: { type: Object, default: null } }, setup(e3) {
  let { control: t2, map: n2 } = Ct(() => new W.FullscreenControl({ container: e3.container || void 0 }), e3);
  function r2() {
    te(() => {
      var _a2;
      return (_a2 = n2.value) == null ? void 0 : _a2.resize();
    });
  }
  t2.value.on(`fullscreenstart`, r2), t2.value.on(`fullscreenend`, r2), N(() => {
    t2.value.off(`fullscreenstart`, r2), t2.value.off(`fullscreenend`, r2);
  });
}, render() {
  return null;
} });
I({ name: `MglGeolocateControl`, props: { position: { type: String, default: gt.TOP_RIGHT, validator: (e3) => _t.indexOf(e3) !== -1 }, positionOptions: { type: Object, default: () => ({ enableHighAccuracy: false, timeout: 6e3 }) }, fitBoundsOptions: { type: Object, default: () => ({ maxZoom: 15 }) }, trackUserLocation: { type: Boolean, default: false }, showAccuracyCircle: { type: Boolean, default: true }, showUserLocation: { type: Boolean, default: true } }, emits: [`trackuserlocationstart`, `trackuserlocationend`, `userlocationlostfocus`, `userlocationfocus`, `geolocate`, `error`, `outofmaxbounds`], setup(e3, t2) {
  let { control: n2 } = Ct(() => new W.GeolocateControl({ positionOptions: e3.positionOptions, fitBoundsOptions: e3.fitBoundsOptions, trackUserLocation: e3.trackUserLocation, showAccuracyCircle: e3.showAccuracyCircle, showUserLocation: e3.showUserLocation }), e3);
  function r2(e4) {
    let r3 = (n3) => {
      t2.emit(e4, n3);
    };
    n2.value.on(e4, r3), N(() => {
      n2.value.off(e4, r3);
    });
  }
  r2(`trackuserlocationstart`), r2(`trackuserlocationend`), r2(`userlocationlostfocus`), r2(`userlocationfocus`), r2(`geolocate`), r2(`error`), r2(`outofmaxbounds`);
}, render() {
  return null;
} });
var Dt = I({ name: `MglNavigationControl`, props: { position: { type: String, validator: (e3) => _t.indexOf(e3) !== -1 }, showCompass: { type: Boolean, default: true }, showZoom: { type: Boolean, default: true }, visualizePitch: Boolean }, setup(e3) {
  Ct(() => new W.NavigationControl({ showCompass: e3.showCompass, showZoom: e3.showZoom, visualizePitch: e3.visualizePitch }), e3);
}, render() {
  return null;
} }), Ot = ((e3) => (e3.IMPERIAL = `imperial`, e3.METRIC = `metric`, e3.NAUTICAL = `nautical`, e3))(Ot || {}), kt = Object.values(Ot), At = I({ name: `MglScaleControl`, props: { position: { type: String, validator: (e3) => _t.indexOf(e3) !== -1 }, maxWidth: { type: Number, default: 100 }, unit: { type: String, default: `metric`, validator: (e3) => kt.indexOf(e3) !== -1 } }, setup(e3) {
  Ct(() => new W.ScaleControl({ maxWidth: e3.maxWidth, unit: e3.unit }), e3);
}, render() {
  return null;
} });
I({ name: `MglLogoControl`, props: { position: { type: String, validator: (e3) => _t.indexOf(e3) !== -1 }, compact: { type: Boolean } }, setup(e3) {
  Ct(() => new W.LogoControl({ compact: e3.compact }), e3);
}, render() {
  return null;
} });
var jt = I({ name: `MglMarker`, emits: [`dragstart`, `drag`, `dragend`, `update:coordinates`], props: { coordinates: { type: [Object, Array], required: true }, className: String, offset: [Object, Array], anchor: String, color: String, draggable: Boolean, clickTolerance: Number, rotation: Number, rotationAlignment: String, pitchAlignment: String, scale: Number, opacity: String, opacityWhenCovered: String, subpixelPositioning: { type: Boolean, default: false } }, setup(e3, { slots: t2, emit: n2 }) {
  let r2 = ye(ot), i2 = re(), a2 = A(), o2 = A(false), s2 = /* @__PURE__ */ new Map();
  function c2(e4, t3) {
    let r3 = (r4) => {
      t3 && t3(), n2(e4, r4);
    };
    i2.value.on(e4, r3), s2.set(e4, r3);
  }
  return E(ft, i2), D(() => {
    let s3 = { ...e3 };
    t2.marker && (s3.element = a2.value), i2.value = new W.Marker(s3), i2.value.setLngLat(e3.coordinates).addTo(r2.value), c2(`dragstart`), c2(`drag`, () => {
      var _a2;
      n2(`update:coordinates`, (_a2 = i2.value) == null ? void 0 : _a2.getLngLat());
    }), c2(`dragend`, () => {
      var _a2;
      n2(`update:coordinates`, (_a2 = i2.value) == null ? void 0 : _a2.getLngLat());
    }), o2.value = true;
  }), j(() => e3.coordinates, (e4) => {
    var _a2;
    return (_a2 = i2.value) == null ? void 0 : _a2.setLngLat(e4);
  }, { deep: true }), j(() => e3.draggable, (e4) => {
    var _a2;
    return (_a2 = i2.value) == null ? void 0 : _a2.setDraggable(e4);
  }), j(() => e3.offset, (e4) => {
    var _a2;
    return (_a2 = i2.value) == null ? void 0 : _a2.setOffset(e4 || [0, 0]);
  }), j(() => e3.pitchAlignment, (e4) => {
    var _a2;
    return (_a2 = i2.value) == null ? void 0 : _a2.setPitchAlignment(e4 || `auto`);
  }), j(() => e3.rotation, (e4) => {
    var _a2;
    return (_a2 = i2.value) == null ? void 0 : _a2.setRotation(e4);
  }), j(() => e3.rotationAlignment, (e4) => {
    var _a2;
    return (_a2 = i2.value) == null ? void 0 : _a2.setRotationAlignment(e4 || `auto`);
  }), j(() => e3.opacity, (t3) => {
    var _a2;
    return (_a2 = i2.value) == null ? void 0 : _a2.setOpacity(t3, e3.opacityWhenCovered);
  }), j(() => e3.opacityWhenCovered, (t3) => {
    var _a2;
    return (_a2 = i2.value) == null ? void 0 : _a2.setOpacity(e3.opacity, t3);
  }), j(() => e3.subpixelPositioning, (e4) => {
    var _a2;
    return (_a2 = i2.value) == null ? void 0 : _a2.setSubpixelPositioning(e4);
  }), j(() => e3.className, (e4, t3) => {
    var _a2, _b2;
    t3 && ((_a2 = i2.value) == null ? void 0 : _a2.removeClassName(t3)), e4 && ((_b2 = i2.value) == null ? void 0 : _b2.addClassName(e4));
  }), N(() => {
    var _a2;
    s2.forEach((e4, t3) => {
      var _a3;
      (_a3 = i2.value) == null ? void 0 : _a3.off(t3, e4);
    }), (_a2 = i2.value) == null ? void 0 : _a2.remove();
  }), () => [F(`div`, t2.default && o2.value ? t2.default({}) : void 0), F(`div`, { ref: a2 }, t2.marker ? t2.marker() : void 0)];
}, render() {
  return null;
} });
I({ name: `MglPopup`, emits: [`open`, `close`], props: { coordinates: { type: [Object, Array], required: false }, closeButton: { type: Boolean, required: false, default: true }, closeOnClick: { type: Boolean, required: false, default: true }, closeOnMove: { type: Boolean, required: false, default: false }, focusAfterOpen: { type: Boolean, required: false, default: true }, anchor: { type: String, required: false }, offset: { type: [Number, Object, Array], required: false }, className: { type: String, required: false }, maxWidth: { type: String, default: `240px` }, subpixelPositioning: { type: Boolean, default: false }, text: { type: String, required: false } }, setup(e3, { slots: t2, emit: n2, expose: r2 }) {
  let i2 = ye(ot), a2 = ye(ft, void 0), o2 = A(), s2 = new W.Popup(e3);
  a2 && a2.value ? a2.value.setPopup(s2) : e3.coordinates && i2 && s2.setLngLat(e3.coordinates).addTo(i2.value), e3.text && s2.setText(e3.text);
  function c2(e4) {
    let t3 = () => n2(e4);
    s2.on(e4, t3), N(() => {
      s2.off(e4, t3);
    });
  }
  return c2(`open`), c2(`close`), r2({ remove() {
    s2.remove();
  } }), j(() => e3.coordinates, (e4) => {
    e4 && s2.setLngLat(e4);
  }, { deep: true }), j(() => e3.text, (e4) => s2.setText(e4 || ``)), j(() => e3.offset, (e4) => s2.setOffset(e4)), j(() => e3.maxWidth, (e4) => s2.setMaxWidth(e4)), j(() => e3.className, (e4, t3) => {
    t3 && s2.removeClassName(t3), e4 && s2.addClassName(e4);
  }), j(() => e3.subpixelPositioning, (e4) => s2.setSubpixelPositioning(e4)), D(() => {
    o2.value && !e3.text && s2.setDOMContent(o2.value);
  }), N(() => {
    s2.remove();
  }), () => [F(`div`, { ref: o2 }, t2.default ? t2.default() : void 0)];
}, render() {
  return null;
} }), I({ name: `MglImage`, props: { id: { type: String, required: true }, image: Object, url: String, options: Object }, setup(e3) {
  let t2 = ye(ot);
  if (!e3.url && !e3.image) return k(`${e3.id} image: missing prop url or image`), () => [];
  if (!t2.value.hasImage(e3.id)) return (async () => {
    let n2 = e3.image;
    e3.url && (n2 = (await t2.value.loadImage(e3.url)).data), t2.value.addImage(e3.id, n2, e3.options);
  })(), () => [];
} });
var Mt = class {
  constructor() {
    __publicField(this, "unmountHandlers", /* @__PURE__ */ new Map());
  }
  registerUnmountHandler(e3, t2) {
    this.unmountHandlers.set(e3, t2);
  }
  unregisterUnmountHandler(e3) {
    this.unmountHandlers.delete(e3);
  }
  unmount() {
    this.unmountHandlers.forEach((e3) => e3());
  }
}, G = (_a = class {
  static genSourceOpts(e3) {
    let t2 = { ...e3 };
    for (let e4 of Object.keys(t2)) (t2[e4] === void 0 || e4 === `sourceId`) && delete t2[e4];
    return t2;
  }
  static getSourceRef(t2, n2) {
    let r2 = typeof n2 == `string`, i2 = String(t2) + (r2 ? n2 : ``), a2 = _a.REFS.get(i2);
    return a2 || (a2 = A(r2 ? null : void 0), _a.REFS.set(i2, a2)), a2;
  }
}, __publicField(_a, "REFS", /* @__PURE__ */ new Map()), _a);
function K(e3, t2, n2) {
  let r2 = ye(ot), i2 = ye(st);
  function a2() {
    i2.value && (r2.value.addSource(t2.sourceId, G.genSourceOpts(t2)), e3.value = r2.value.getSource(t2.sourceId));
  }
  return j(i2, a2, { immediate: true }), r2.value.on(`style.load`, a2), N(() => {
    i2.value && (n2.unmount(), r2.value.removeSource(t2.sourceId)), r2.value.off(`style.load`, a2);
  });
}
I({ name: `MglCanvasSource`, props: { sourceId: { type: String, required: true }, coordinates: Array, animate: Boolean, canvas: [Object, String] }, slots: Object, setup(e3, { slots: t2 }) {
  let n2 = ye(lt), r2 = G.getSourceRef(n2, e3.sourceId), i2 = new Mt(), a2 = { ...e3, type: `canvas` };
  return E(ut, e3.sourceId), E(dt, i2), K(r2, a2, i2), j([ne(e3.coordinates) ? e3.coordinates : () => e3.coordinates, r2], ([e4, t3]) => {
    t3 == null ? void 0 : t3.setCoordinates(e4);
  }, { immediate: true }), () => [fe(`Canvas Source`), r2.value && t2.default ? t2.default({}) : void 0];
} });
var Nt = I({ name: `MglGeoJsonSource`, props: { sourceId: { type: String, required: true }, data: { type: [Object, String], required: true }, maxzoom: Number, attribution: String, buffer: Number, tolerance: Number, cluster: Boolean, clusterRadius: Number, clusterMaxZoom: Number, clusterMinPoints: Number, clusterProperties: Object, lineMetrics: Boolean, generateId: Boolean, promoteId: [Object, String], filter: [Array, String, Object] }, slots: Object, setup(e3, { slots: t2 }) {
  let n2 = ye(lt), r2 = G.getSourceRef(n2, e3.sourceId), i2 = new Mt(), a2 = { ...e3, type: `geojson` };
  return E(ut, e3.sourceId), E(dt, i2), K(r2, a2, i2), j([ne(e3.data) ? e3.data : () => e3.data, r2], ([e4, t3]) => {
    t3 == null ? void 0 : t3.setData(e4 || { type: `FeatureCollection`, features: [] });
  }, { immediate: true }), () => [fe(`GeoJSON Source`), r2.value && t2.default ? t2.default({}) : void 0];
} });
I({ name: `MglImageSource`, props: { sourceId: { type: String, required: true }, url: String, coordinates: Array }, slots: Object, setup(e3, { slots: t2 }) {
  let n2 = ye(lt), r2 = G.getSourceRef(n2, e3.sourceId), i2 = new Mt(), a2 = { ...e3, type: `image` };
  return E(ut, e3.sourceId), E(dt, i2), K(r2, a2, i2), j([ne(e3.coordinates) ? e3.coordinates : () => e3.coordinates, r2], ([e4, t3]) => {
    t3 == null ? void 0 : t3.setCoordinates(e4);
  }, { immediate: true }), () => [fe(`Image Source`), r2.value && t2.default ? t2.default({}) : void 0];
} }), I({ name: `MglRasterSource`, props: { sourceId: { type: String, required: true }, url: String, tiles: Array, bounds: Array, minzoom: Number, maxzoom: Number, tileSize: Number, scheme: String, attribution: String, volatile: Boolean }, slots: Object, setup(e3, { slots: t2 }) {
  let n2 = ye(lt), r2 = G.getSourceRef(n2, e3.sourceId), i2 = new Mt(), a2 = { ...e3, type: `raster` };
  return E(ut, e3.sourceId), E(dt, i2), K(r2, a2, i2), () => [fe(`Raster Source`), r2.value && t2.default ? t2.default({}) : void 0];
} }), I({ name: `MglRasterDemSource`, props: { sourceId: { type: String, required: true }, url: String, tiles: Array, bounds: Array, minzoom: Number, maxzoom: Number, tileSize: Number, attribution: String, encoding: String, volatile: Boolean, redFactor: Number, blueFactor: Number, greenFactor: Number, baseShift: Number }, slots: Object, setup(e3, { slots: t2 }) {
  let n2 = ye(lt), r2 = G.getSourceRef(n2, e3.sourceId), i2 = new Mt(), a2 = { ...e3, type: `raster-dem` };
  return E(ut, e3.sourceId), E(dt, i2), K(r2, a2, i2), () => [fe(`RasterDem Source`), r2.value && t2.default ? t2.default({}) : void 0];
} }), I({ name: `MglVectorSource`, props: { sourceId: { type: String, required: true }, url: String, tiles: Array, bounds: { type: Array, validator: function(e3) {
  return e3.length === 4;
} }, scheme: String, minzoom: Number, maxzoom: Number, attribution: String, promoteId: [Object, String], volatile: Boolean }, slots: Object, setup(e3, { slots: t2 }) {
  let n2 = ye(lt), r2 = G.getSourceRef(n2, e3.sourceId), i2 = new Mt(), a2 = { ...e3, type: `vector` };
  return E(ut, e3.sourceId), E(dt, i2), K(r2, a2, i2), j([ne(e3.tiles) ? e3.tiles : () => e3.tiles, r2], ([e4, t3]) => {
    t3 == null ? void 0 : t3.setTiles(e4 || []);
  }, { immediate: true }), j([ne(e3.url) ? e3.url : () => e3.url, r2], ([e4, t3]) => {
    t3 == null ? void 0 : t3.setUrl(e4 || ``);
  }, { immediate: true }), () => [fe(`Vector Source`), r2.value && t2.default ? t2.default({}) : void 0];
} }), I({ name: `MglVideoSource`, props: { sourceId: { type: String, required: true }, urls: Array, coordinates: Array }, slots: Object, setup(e3, { slots: t2 }) {
  let n2 = ye(lt), r2 = G.getSourceRef(n2, e3.sourceId), i2 = new Mt(), a2 = { ...e3, type: `video` };
  return E(ut, e3.sourceId), E(dt, i2), K(r2, a2, i2), j([ne(e3.coordinates) ? e3.coordinates : () => e3.coordinates, r2], ([e4, t3]) => {
    t3 == null ? void 0 : t3.setCoordinates(e4);
  }, { immediate: true }), () => [fe(`Video Source`), r2.value && t2.default ? t2.default({}) : void 0];
} });
var Pt = [`click`, `dblclick`, `mousedown`, `mouseup`, `mousemove`, `mouseenter`, `mouseleave`, `mouseover`, `mouseout`, `contextmenu`, `touchstart`, `touchend`, `touchcancel`];
function Ft() {
  return { layerId: { type: String, required: true }, source: { type: String }, metadata: { type: [Object, Array, String, Number] }, sourceLayer: { type: String }, minzoom: { type: Number }, maxzoom: { type: Number }, filter: { type: Object }, before: { type: String }, layout: { type: Object }, paint: { type: Object } };
}
function It(e3, t2, n2, r2) {
  let i2 = { id: e3, type: t2, source: n2.source || r2, metadata: n2.metadata, minzoom: n2.minzoom, maxzoom: n2.maxzoom, "source-layer": n2.sourceLayer, filter: n2.filter, paint: n2.paint, layout: n2.layout };
  for (let e4 of Object.keys(i2)) i2[e4] === void 0 && delete i2[e4];
  return i2;
}
function Lt(e3, t2, n2) {
  if (n2.props) for (let r2 of Pt) {
    let i2 = `on` + r2.charAt(0).toUpperCase() + r2.substr(1);
    n2.props[i2] && e3.on(r2, t2, n2.props[i2]);
  }
}
function Rt(e3, t2, n2) {
  if (n2.props) for (let r2 of Pt) {
    let i2 = `on` + r2.charAt(0).toUpperCase() + r2.substr(1);
    n2.props[i2] && e3.off(r2, t2, n2.props[i2]);
  }
}
function zt(e3, t2) {
  let n2 = ye(ot), r2 = ye(st), i2 = ye(dt);
  function a2() {
    r2.value && (t2 && Rt(n2.value, e3, t2.vnode), n2.value.getLayer(e3) && n2.value.removeLayer(e3));
  }
  i2.registerUnmountHandler(e3, a2), N(() => {
    i2.unregisterUnmountHandler(e3), a2();
  });
}
I({ name: `MglBackgroundLayer`, props: { layerId: { type: String, required: true }, metadata: [Object, Array, String, Number], minzoom: Number, maxzoom: Number, before: String, layout: Object, paint: Object }, emits: [...Pt], setup(e3) {
  let t2 = ye(ot), n2 = ye(st);
  return zt(e3.layerId), j(() => e3.layout, (n3) => {
    if (n3) for (let [r2, i2] of Object.entries(n3)) t2.value.setLayoutProperty(e3.layerId, r2, i2);
  }), j(() => e3.paint, (n3) => {
    if (n3) for (let [r2, i2] of Object.entries(n3)) t2.value.setPaintProperty(e3.layerId, r2, i2);
  }), j(n2, (n3) => {
    n3 && t2.value.addLayer({ id: e3.layerId, type: `background`, metadata: e3.metadata, minzoom: e3.minzoom, maxzoom: e3.maxzoom, layout: e3.layout, paint: e3.paint }, e3.before || void 0);
  }, { immediate: true }), () => fe(`Background Layer`);
} });
function Bt(e3, t2) {
  let n2 = ye(ut);
  if (!n2 && !t2.source) {
    k(`${e3} Layer: layer must be used inside source tag or source prop must be set`);
    return;
  }
  let r2 = le(), i2 = ye(ot), a2 = ye(st), o2 = ye(lt), s2 = G.getSourceRef(o2, t2.source || n2);
  return zt(t2.layerId, r2), j(() => t2.minzoom, () => i2.value.setLayerZoomRange(t2.layerId, t2.minzoom || 0, t2.maxzoom || 24)), j(() => t2.maxzoom, () => i2.value.setLayerZoomRange(t2.layerId, t2.minzoom || 0, t2.maxzoom || 24)), j(() => t2.layout, (e4) => {
    if (e4) for (let [n3, r3] of Object.entries(e4)) i2.value.setLayoutProperty(t2.layerId, n3, r3);
  }, { deep: true }), j(() => t2.paint, (e4) => {
    if (e4) for (let [n3, r3] of Object.entries(e4)) i2.value.setPaintProperty(t2.layerId, n3, r3);
  }, { deep: true }), j(() => t2.filter, (e4) => i2.value.setFilter(t2.layerId, e4), { deep: true }), j([a2, s2], ([a3, o3]) => {
    a3 && (o3 || o3 === void 0) && (i2.value.addLayer(It(t2.layerId, e3, t2, n2), t2.before || void 0), Lt(i2.value, t2.layerId, r2.vnode));
  }, { immediate: true }), () => fe(`${e3} Layer`);
}
I({ name: `MglCircleLayer`, props: Ft(), emits: [...Pt], setup(e3) {
  return Bt(`circle`, e3);
} }), I({ name: `MglFillLayer`, props: Ft(), emits: [...Pt], setup(e3) {
  return Bt(`fill`, e3);
} }), I({ name: `MglFillExtrusionLayer`, props: Ft(), emits: [...Pt], setup(e3) {
  return Bt(`fill-extrusion`, e3);
} }), I({ name: `MglHeatmapLayer`, props: Ft(), emits: [...Pt], setup(e3) {
  return Bt(`heatmap`, e3);
} }), I({ name: `MglHillshadeLayer`, props: Ft(), emits: [...Pt], setup(e3) {
  return Bt(`hillshade`, e3);
} });
var Vt = I({ name: `MglLineLayer`, props: Ft(), emits: [...Pt], setup(e3) {
  return Bt(`line`, e3);
} });
I({ name: `MglRasterLayer`, props: Ft(), emits: [...Pt], setup(e3) {
  return Bt(`raster`, e3);
} }), I({ name: `MglSymbolLayer`, props: Ft(), emits: [...Pt], setup(e3) {
  return Bt(`symbol`, e3);
} }), Symbol.toStringTag;
var Ht = [];
for (let e3 = 0; e3 < 256; ++e3) Ht.push((e3 + 256).toString(16).slice(1));
function Ut(e3, t2 = 0) {
  return (Ht[e3[t2 + 0]] + Ht[e3[t2 + 1]] + Ht[e3[t2 + 2]] + Ht[e3[t2 + 3]] + `-` + Ht[e3[t2 + 4]] + Ht[e3[t2 + 5]] + `-` + Ht[e3[t2 + 6]] + Ht[e3[t2 + 7]] + `-` + Ht[e3[t2 + 8]] + Ht[e3[t2 + 9]] + `-` + Ht[e3[t2 + 10]] + Ht[e3[t2 + 11]] + Ht[e3[t2 + 12]] + Ht[e3[t2 + 13]] + Ht[e3[t2 + 14]] + Ht[e3[t2 + 15]]).toLowerCase();
}
var Wt, Gt = new Uint8Array(16);
function Kt() {
  if (!Wt) {
    if (typeof crypto > `u` || !crypto.getRandomValues) throw Error(`crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported`);
    Wt = crypto.getRandomValues.bind(crypto);
  }
  return Wt(Gt);
}
var qt = { randomUUID: typeof crypto < `u` && crypto.randomUUID && crypto.randomUUID.bind(crypto) };
function Jt(e3, t2, n2) {
  var _a2;
  if (qt.randomUUID && !t2 && !e3) return qt.randomUUID();
  e3 || (e3 = {});
  let r2 = e3.random ?? ((_a2 = e3.rng) == null ? void 0 : _a2.call(e3)) ?? Kt();
  if (r2.length < 16) throw Error(`Random bytes length must be >= 16`);
  if (r2[6] = r2[6] & 15 | 64, r2[8] = r2[8] & 63 | 128, t2) {
    if (n2 || (n2 = 0), n2 < 0 || n2 + 16 > t2.length) throw RangeError(`UUID byte range ${n2}:${n2 + 15} is out of buffer bounds`);
    for (let e4 = 0; e4 < 16; ++e4) t2[n2 + e4] = r2[e4];
    return t2;
  }
  return Ut(r2);
}
var Yt = Jt;
function Xt() {
  return { name: `Untitled`, description: `A new geographic item`, creation_timestamp: Date.now(), modification_timestamp: Date.now(), created_by: `anonymous`, modified_by: `anonymous`, tags: [] };
}
function q() {
  return { ...Xt(), version: 1, signature: void 0 };
}
var J = class e2 {
  constructor(e3 = Yt(), t2, n2, r2) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "routes");
    __publicField(this, "drafts");
    this.id = e3, this.routes = t2 || { id: Yt(), meta: Xt(), routes: [] }, this.drafts = n2 || { id: Yt(), meta: Xt(), drafts: [] }, this.meta = { ...q(), ...r2 };
  }
  toStorage() {
    return { id: this.id, meta: this.meta, routes: this.routes, drafts: this.drafts };
  }
  static fromStorage(t2) {
    return new e2(t2.id, t2.routes, t2.drafts, t2.meta);
  }
  clone() {
    return e2.fromStorage(this.toStorage());
  }
  updateName(e3) {
    this.meta.name = e3, this.meta.modification_timestamp = Date.now();
  }
  updateDescription(e3) {
    this.meta.description = e3, this.meta.modification_timestamp = Date.now();
  }
  addTag(e3) {
    this.meta.tags.includes(e3) || (this.meta.tags.push(e3), this.meta.modification_timestamp = Date.now());
  }
  removeTag(e3) {
    let t2 = this.meta.tags.indexOf(e3);
    t2 > -1 && (this.meta.tags.splice(t2, 1), this.meta.modification_timestamp = Date.now());
  }
}, Zt = class {
  constructor(e3 = [], t2 = Yt(), n2 = Xt()) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "routesInternal");
    this.id = t2, this.meta = n2 ?? Xt(), this.routesInternal = e3;
  }
  get name() {
    return (this.meta === null || this.meta === void 0) && (this.meta = Xt()), this.meta.name;
  }
  set name(e3) {
    (this.meta === null || this.meta === void 0) && (this.meta = Xt()), this.meta.name = e3;
  }
  get routes() {
    return be(this.routesInternal);
  }
  set routes(e3) {
    this.routesInternal = be(e3);
  }
  findRoute(e3) {
    return this.routesInternal.find((t2) => t2.id === e3);
  }
  existRoute(e3) {
    return this.routesInternal.some((t2) => t2.id === e3);
  }
  addRoute(e3) {
    if (this.existRoute(e3.id)) throw Error(`[CartoSketch.Route] Route ${e3.id} already exist`);
    this.routesInternal.push(be(e3)), this.updateModificationTime();
  }
  updateRoute(e3) {
    let t2 = this.routesInternal.findIndex((t3) => t3.id === e3.id);
    if (t2 === -1) throw Error(`[CartoSketch.Route] Route ${e3.id} not found`);
    this.routesInternal[t2] = be(e3), this.updateModificationTime();
  }
  removeRoute(e3) {
    let t2 = this.routesInternal.findIndex((t3) => t3.id === e3);
    t2 !== -1 && (this.routesInternal.splice(t2, 1), this.updateModificationTime());
  }
  updateModificationTime() {
    this.meta.modification_timestamp = Date.now();
  }
  exportAsGeoJSON() {
    return { type: `FeatureCollection`, features: this.routesInternal.map((e3) => e3.exportAsGeoJSON()), properties: this.meta };
  }
  exportToStorage() {
    return Object.freeze({ id: this.id, meta: this.meta, routes: this.routesInternal.map((e3) => e3.exportToStorage()) });
  }
}, Qt = class {
  constructor(e3 = Yt(), t2 = [], n2 = {}, r2) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "properties");
    __publicField(this, "points");
    this.id = e3, this.meta = { ...Xt(), record_timespan: 0, ...r2 }, this.properties = n2, this.points = t2;
  }
  get name() {
    return (this.meta === null || this.meta === void 0) && (this.meta = Xt()), this.meta.name;
  }
  set name(e3) {
    (this.meta === null || this.meta === void 0) && (this.meta = Xt()), this.meta.name = e3;
  }
  get distance() {
    return this.meta.distance ?? 0;
  }
  set distance(e3) {
    this.meta.distance = e3;
  }
  get recordTimespan() {
    return this.meta.record_timespan ?? 0;
  }
  set recordTimespan(e3) {
    this.meta.record_timespan = e3;
  }
  setPoints(e3) {
    this.points = be(e3), this.updateModificationTime();
  }
  appendPoint(e3) {
    this.points.push(be(e3)), this.updateModificationTime();
  }
  getPoints() {
    return be(this.points);
  }
  setProperties(e3) {
    let t2 = be(e3);
    Object.assign(this.properties, t2), this.updateModificationTime();
  }
  updateModificationTime() {
    this.meta.modification_timestamp = Date.now();
  }
  exportAsGeoJSON() {
    return { type: `Feature`, properties: { ...this.properties, ...this.meta, description: JSON.stringify({ name: this.meta.name, id: this.id }) }, geometry: { type: `LineString`, coordinates: this.points.map((e3) => [e3.longitude, e3.latitude]) } };
  }
  exportToStorage() {
    return be({ id: this.id, meta: this.meta, properties: this.properties, points: this.points });
  }
};
let $t = (function(e3) {
  return e3.MIGRATION_FAILED = `MIGRATION_FAILED`, e3.INVALID_VERSION = `INVALID_VERSION`, e3.UNSUPPORTED_VERSION = `UNSUPPORTED_VERSION`, e3.ROLLBACK_FAILED = `ROLLBACK_FAILED`, e3.VALIDATION_FAILED = `VALIDATION_FAILED`, e3.STRATEGY_NOT_FOUND = `STRATEGY_NOT_FOUND`, e3.DATA_CORRUPTION = `DATA_CORRUPTION`, e3;
})({});
var en = class extends pe {
  constructor(e3, t2 = $t.MIGRATION_FAILED, n2) {
    super(e3, n2);
    __publicField(this, "code");
    __publicField(this, "domain", ce.GENERIC);
    this.code = t2;
  }
}, tn = class extends en {
  constructor(e3, t2 = $t.INVALID_VERSION, n2, r2, i2) {
    super(e3, t2, i2), this.currentVersion = n2, this.targetVersion = r2;
  }
}, nn = class extends en {
  constructor(e3, t2, n2, r2) {
    super(e3, $t.VALIDATION_FAILED, r2), this.field = t2, this.value = n2;
  }
}, rn = class extends en {
  constructor(e3, t2, n2) {
    super(e3, $t.DATA_CORRUPTION, n2), this.corruptedData = t2;
  }
}, an = class extends en {
  constructor(e3, t2, n2, r2) {
    super(e3, $t.ROLLBACK_FAILED, r2), this.originalError = t2, this.rollbackError = n2;
  }
}, on = (_b = class {
  static getCurrentVersion() {
    return this.CURRENT_VERSION;
  }
  static getMinimumSupportedVersion() {
    return this.MIN_SUPPORTED_VERSION;
  }
  static extractVersion(e3) {
    try {
      if (typeof e3 == `object` && e3 && `version` in e3) {
        let t2 = e3.version;
        if (typeof t2 == `number` && t2 >= 0) return xe(t2);
      }
      if (this.isRouteCollectionFormat(e3)) return xe(0);
      if (this.isSketchArrayFormat(e3)) return xe(1);
      throw Error(`Unable to determine data version`);
    } catch (e4) {
      return L(e4 instanceof tn ? e4 : new tn(`Failed to extract version from data: ${String(e4)}`, $t.INVALID_VERSION, void 0, void 0, e4 instanceof Error ? e4 : Error(String(e4))));
    }
  }
  static isRouteCollectionFormat(e3) {
    return typeof e3 == `object` && !!e3 && `routes` in e3 && !(`sketches` in e3) && Array.isArray(e3.routes);
  }
  static isSketchArrayFormat(e3) {
    return Array.isArray(e3) && e3.length > 0 && this.isSketchObject(e3[0]);
  }
  static isSketchObject(e3) {
    return typeof e3 == `object` && !!e3 && `id` in e3 && `meta` in e3 && `routes` in e3 && `drafts` in e3;
  }
  static validateVersion(e3) {
    try {
      if (e3 < this.MIN_SUPPORTED_VERSION) throw new tn(`Version ${e3} is below minimum supported version ${this.MIN_SUPPORTED_VERSION}`, $t.UNSUPPORTED_VERSION, e3);
      if (e3 > this.CURRENT_VERSION) throw new tn(`Version ${e3} is above current version ${this.CURRENT_VERSION}`, $t.UNSUPPORTED_VERSION, e3, this.CURRENT_VERSION);
      return xe(void 0);
    } catch (t2) {
      return L(t2 instanceof tn ? t2 : new tn(`Version validation failed: ${String(t2)}`, $t.INVALID_VERSION, e3, void 0, t2 instanceof Error ? t2 : Error(String(t2))));
    }
  }
  static addVersionMetadata(e3, t2 = this.CURRENT_VERSION) {
    return { ...e3, [this.VERSION_KEY]: { version: t2, timestamp: Date.now(), description: `Version ${t2} data format` } };
  }
  static extractVersionMetadata(e3) {
    try {
      if (typeof e3 == `object` && e3 && this.VERSION_KEY in e3) {
        let t2 = e3[this.VERSION_KEY];
        if (this.isValidVersionInfo(t2)) return xe(t2);
      }
      return xe(null);
    } catch (e4) {
      return L(e4 instanceof tn ? e4 : new tn(`Failed to extract version metadata: ${String(e4)}`, $t.INVALID_VERSION, void 0, void 0, e4 instanceof Error ? e4 : Error(String(e4))));
    }
  }
  static isValidVersionInfo(e3) {
    return typeof e3 == `object` && !!e3 && `version` in e3 && `timestamp` in e3 && typeof e3.version == `number` && typeof e3.timestamp == `number`;
  }
  static determineMigrationPath(e3, t2) {
    try {
      let n2 = this.validateVersion(e3);
      if (n2.isErr()) throw n2.error;
      let r2 = this.validateVersion(t2);
      if (r2.isErr()) throw r2.error;
      if (e3 === t2) return xe([]);
      let i2 = [], a2 = e3 < t2 ? 1 : -1;
      for (let n3 = e3; n3 !== t2; n3 += a2) i2.push(n3 + a2);
      return xe(i2);
    } catch (n2) {
      return L(n2 instanceof tn ? n2 : new tn(`Failed to determine migration path: ${String(n2)}`, $t.INVALID_VERSION, e3, t2, n2 instanceof Error ? n2 : Error(String(n2))));
    }
  }
  static isMigrationNeeded(e3) {
    return this.extractVersion(e3).map((e4) => e4 !== this.CURRENT_VERSION);
  }
}, __publicField(_b, "CURRENT_VERSION", 1), __publicField(_b, "VERSION_KEY", `_data_version`), __publicField(_b, "MIN_SUPPORTED_VERSION", 0), _b), sn = class {
  static validateSketchData(e3) {
    try {
      if (!e3 || typeof e3 != `object`) throw new nn(`Sketch data must be an object`, `data`, e3);
      let t2 = e3;
      for (let e4 of [`id`, `meta`, `routes`, `drafts`]) if (!(e4 in t2)) throw new nn(`Missing required field: ${e4}`, e4, t2[e4]);
      if (typeof t2.id != `string` || !t2.id) throw new nn(`Sketch ID must be a non-empty string`, `id`, t2.id);
      if (!t2.meta || typeof t2.meta != `object`) throw new nn(`Sketch meta must be an object`, `meta`, t2.meta);
      let n2 = this.validateRouteCollectionData(t2.routes);
      if (n2.isErr()) throw n2.error;
      if (!t2.drafts || typeof t2.drafts != `object`) throw new nn(`Sketch drafts must be an object`, `drafts`, t2.drafts);
      return xe(t2);
    } catch (t2) {
      return t2 instanceof nn ? L(t2) : L(new nn(`Unexpected validation error: ${String(t2)}`, void 0, e3, t2 instanceof Error ? t2 : Error(String(t2))));
    }
  }
  static validateRouteCollectionData(e3) {
    try {
      if (!e3 || typeof e3 != `object`) throw new nn(`Route collection data must be an object`, `data`, e3);
      let t2 = e3;
      for (let e4 of [`id`, `meta`, `routes`]) if (!(e4 in t2)) throw new nn(`Missing required field: ${e4}`, e4, t2[e4]);
      if (typeof t2.id != `string` || !t2.id) throw new nn(`Route collection ID must be a non-empty string`, `id`, t2.id);
      if (!t2.meta || typeof t2.meta != `object`) throw new nn(`Route collection meta must be an object`, `meta`, t2.meta);
      if (!Array.isArray(t2.routes)) throw new nn(`Routes must be an array`, `routes`, t2.routes);
      for (let e4 = 0; e4 < t2.routes.length; e4++) {
        let n2 = t2.routes[e4], r2 = this.validateRouteItem(n2);
        if (r2.isErr()) throw new nn(`Invalid route at index ${e4}: ${r2.error.message}`, `routes[${e4}]`, n2, r2.error);
      }
      return xe(t2);
    } catch (t2) {
      return t2 instanceof nn ? L(t2) : L(new nn(`Unexpected validation error: ${String(t2)}`, void 0, e3, t2 instanceof Error ? t2 : Error(String(t2))));
    }
  }
  static validateRouteItem(e3) {
    try {
      if (!e3 || typeof e3 != `object`) throw new nn(`Route item must be an object`, `data`, e3);
      let t2 = e3;
      for (let e4 of [`id`, `meta`, `properties`, `points`]) if (!(e4 in t2)) throw new nn(`Missing required field: ${e4}`, e4, t2[e4]);
      if (typeof t2.id != `string` || !t2.id) throw new nn(`Route item ID must be a non-empty string`, `id`, t2.id);
      if (!Array.isArray(t2.points)) throw new nn(`Route points must be an array`, `points`, t2.points);
      for (let e4 = 0; e4 < t2.points.length; e4++) {
        let n2 = t2.points[e4];
        if (!n2 || typeof n2 != `object`) throw new nn(`Route point at index ${e4} must be an object`, `points[${e4}]`, n2);
        let r2 = n2;
        if (typeof r2.latitude != `number` || typeof r2.longitude != `number`) throw new nn(`Route point at index ${e4} must have numeric latitude and longitude`, `points[${e4}]`, n2);
      }
      return xe(t2);
    } catch (t2) {
      return t2 instanceof nn ? L(t2) : L(new nn(`Unexpected validation error: ${String(t2)}`, void 0, e3, t2 instanceof Error ? t2 : Error(String(t2))));
    }
  }
  static validateSketchArray(e3) {
    try {
      if (!Array.isArray(e3)) throw new nn(`Sketch array must be an array`, `data`, e3);
      if (e3.length === 0) throw new nn(`Sketch array cannot be empty`, `data.length`, e3.length);
      for (let t2 = 0; t2 < e3.length; t2++) {
        let n2 = e3[t2], r2 = this.validateSketchData(n2);
        if (r2.isErr()) throw new nn(`Invalid sketch at index ${t2}: ${r2.error.message}`, `[${t2}]`, n2, r2.error);
      }
      return xe(e3);
    } catch (t2) {
      return t2 instanceof nn ? L(t2) : L(new nn(`Unexpected validation error: ${String(t2)}`, void 0, e3, t2 instanceof Error ? t2 : Error(String(t2))));
    }
  }
  static validateData(e3, t2) {
    switch (t2) {
      case `sketch`:
        return this.validateSketchData(e3);
      case `route-collection`:
        return this.validateRouteCollectionData(e3);
      case `sketch-array`:
        return this.validateSketchArray(e3);
      default:
        return L(new nn(`Unknown expected format: ${String(t2)}`, `expectedFormat`, t2));
    }
  }
  static checkDataIntegrity(e3, t2) {
    try {
      let n2 = this.validateData(e3, t2);
      return n2.isErr() ? L(new rn(`Data validation failed: ${n2.error.message}`, e3, n2.error)) : xe({ isValid: true, errors: [], warnings: [] });
    } catch (t3) {
      return L(new rn(`Data integrity check failed: ${String(t3)}`, e3, t3 instanceof Error ? t3 : Error(String(t3))));
    }
  }
}, cn = class {
  constructor() {
    __publicField(this, "fromVersion", 0);
    __publicField(this, "toVersion", 1);
    __publicField(this, "name", `route-collection-to-sketch`);
  }
  migrate(e3) {
    try {
      let t2 = sn.validateRouteCollectionData(e3);
      if (t2.isErr()) return L(new en(`Invalid route collection data: ${t2.error.message}`, $t.VALIDATION_FAILED, t2.error));
      let n2 = t2.value, r2 = new J();
      return r2.meta.name = n2.meta.name || `Migrated Routes`, r2.meta.description = n2.meta.description || `Migrated from route collection`, r2.meta.creation_timestamp = n2.meta.creation_timestamp, r2.meta.modification_timestamp = Date.now(), r2.routes = n2, xe([r2.toStorage()]);
    } catch (e4) {
      return L(new en(`Route collection to sketch migration failed: ${String(e4)}`, $t.MIGRATION_FAILED, e4 instanceof Error ? e4 : Error(String(e4))));
    }
  }
  rollback(e3) {
    try {
      let t2 = sn.validateSketchArray(e3);
      if (t2.isErr()) return L(new en(`Invalid sketch array data for rollback: ${t2.error.message}`, $t.VALIDATION_FAILED, t2.error));
      let n2 = t2.value;
      if (n2.length === 0) return L(new en(`Cannot rollback: empty sketch array`, $t.MIGRATION_FAILED));
      let r2 = n2[0];
      return xe(r2.routes);
    } catch (e4) {
      return L(new en(`Route collection to sketch rollback failed: ${String(e4)}`, $t.ROLLBACK_FAILED, e4 instanceof Error ? e4 : Error(String(e4))));
    }
  }
  validateBefore(e3) {
    return sn.validateRouteCollectionData(e3).map(() => void 0).mapErr((e4) => new nn(`Pre-migration validation failed: ${e4.message}`, e4.field, e4.value, e4));
  }
  validateAfter(e3) {
    return sn.validateSketchArray(e3).map(() => void 0).mapErr((e4) => new nn(`Post-migration validation failed: ${e4.message}`, e4.field, e4.value, e4));
  }
}, ln = class {
  constructor() {
    __publicField(this, "fromVersion", 1);
    __publicField(this, "toVersion", 2);
    __publicField(this, "name", `sketch-v1-to-v2`);
  }
  migrate() {
    return L(new en(`Sketch V1 to V2 migration not yet implemented`, $t.STRATEGY_NOT_FOUND));
  }
  validateBefore(e3) {
    return sn.validateSketchArray(e3).map(() => void 0).mapErr((e4) => new nn(`Pre-migration validation failed: ${e4.message}`, e4.field, e4.value, e4));
  }
  validateAfter(e3) {
    return L(new nn(`Sketch V2 validation not yet implemented`, void 0, e3));
  }
}, un = (_c = class {
  static register(e3) {
    let t2 = this.getStrategyKey(e3.fromVersion, e3.toVersion);
    this.strategies.set(t2, e3);
  }
  static getStrategy(e3, t2) {
    let n2 = this.getStrategyKey(e3, t2), r2 = this.strategies.get(n2);
    return r2 ? xe(r2) : L(new en(`No migration strategy found for version ${e3} to ${t2}`, $t.STRATEGY_NOT_FOUND));
  }
  static getAllStrategies() {
    return Array.from(this.strategies.values());
  }
  static hasStrategy(e3, t2) {
    let n2 = this.getStrategyKey(e3, t2);
    return this.strategies.has(n2);
  }
  static getStrategyKey(e3, t2) {
    return `${e3}->${t2}`;
  }
}, __publicField(_c, "strategies", /* @__PURE__ */ new Map()), _c.register(new cn()), _c.register(new ln()), _c), dn = class {
  static createStrategy(e3, t2) {
    return un.getStrategy(e3, t2);
  }
  static createStrategiesForPath(e3) {
    try {
      let t2 = [];
      for (let n2 = 0; n2 < e3.length; n2++) {
        let r2 = n2 === 0 ? e3[0] - 1 : e3[n2 - 1], i2 = e3[n2], a2 = this.createStrategy(r2, i2);
        if (a2.isErr()) return L(a2.error);
        t2.push(a2.value);
      }
      return xe(t2);
    } catch (e4) {
      return L(new en(`Failed to create strategies for migration path: ${String(e4)}`, $t.MIGRATION_FAILED, e4 instanceof Error ? e4 : Error(String(e4))));
    }
  }
}, fn = (_d = class {
  static isMigrationNeeded(e3) {
    return on.isMigrationNeeded(e3);
  }
  static getDataVersion(e3) {
    return on.extractVersion(e3);
  }
  static migrateToCurrent(e3, t2 = {}) {
    return this.migrateToVersion(e3, on.getCurrentVersion(), t2);
  }
  static migrateToVersion(e3, t2, n2 = {}) {
    try {
      let r2 = { ...this.DEFAULT_OPTIONS, ...n2 }, i2 = on.extractVersion(e3);
      if (i2.isErr()) return L(new en(`Failed to extract current version: ${i2.error.message}`, $t.INVALID_VERSION, i2.error));
      let a2 = i2.value;
      if (a2 === t2) return xe({ data: e3, fromVersion: a2, toVersion: t2, migratedVersions: [] });
      let o2 = on.determineMigrationPath(a2, t2);
      if (o2.isErr()) return L(new en(`Failed to determine migration path: ${o2.error.message}`, $t.INVALID_VERSION, o2.error));
      let s2 = o2.value, c2 = dn.createStrategiesForPath(s2);
      if (c2.isErr()) return L(c2.error);
      let l2 = c2.value;
      if (r2.validateBefore) {
        let t3 = this.validateDataBeforeMigration(e3, a2);
        if (t3.isErr()) return L(new en(`Pre-migration validation failed: ${t3.error.message}`, $t.VALIDATION_FAILED, t3.error));
      }
      let u2 = r2.enableRollback ? e3 : void 0, d2 = e3, f2 = [];
      for (let e4 of l2) {
        let t3 = this.executeMigrationWithRetry(e4, d2, r2);
        if (t3.isErr()) {
          if (r2.enableRollback && u2) {
            let e5 = this.rollbackToVersion(u2);
            if (e5.isErr()) return L(new an(`Migration failed and rollback also failed: ${e5.error.message}`, t3.error, e5.error));
          }
          return L(t3.error);
        }
        d2 = t3.value, f2.push(e4.toVersion);
      }
      if (r2.validateAfter) {
        let e4 = this.validateDataAfterMigration(d2, t2);
        if (e4.isErr()) return L(new en(`Post-migration validation failed: ${e4.error.message}`, $t.VALIDATION_FAILED, e4.error));
      }
      return xe({ data: d2, fromVersion: a2, toVersion: t2, migratedVersions: f2, rollbackData: r2.enableRollback ? u2 : void 0 });
    } catch (e4) {
      return L(new en(`Migration service error: ${String(e4)}`, $t.MIGRATION_FAILED, e4 instanceof Error ? e4 : Error(String(e4))));
    }
  }
  static executeMigrationWithRetry(e3, t2, n2) {
    let r2 = null;
    for (let i2 = 0; i2 <= (n2.maxRetries || 0); i2++) {
      try {
        let n3 = e3.migrate(t2);
        if (n3.isErr()) {
          r2 = n3.error;
          continue;
        }
        if (e3.validateAfter) {
          let t3 = e3.validateAfter(n3.value);
          if (t3.isErr()) {
            r2 = new en(`Post-migration validation failed: ${t3.error.message}`, $t.VALIDATION_FAILED, t3.error);
            continue;
          }
        }
        return xe(n3.value);
      } catch (e4) {
        r2 = new en(`Migration attempt ${i2 + 1} failed: ${String(e4)}`, $t.MIGRATION_FAILED, e4 instanceof Error ? e4 : Error(String(e4)));
      }
      i2 < (n2.maxRetries || 0) && n2.retryDelay && console.warn(`Migration failed, retrying in ${n2.retryDelay}ms...`);
    }
    return L(r2 || new en(`Migration failed after all retry attempts`, $t.MIGRATION_FAILED));
  }
  static rollbackToVersion(e3) {
    try {
      return xe(e3);
    } catch (e4) {
      return L(new en(`Rollback failed: ${String(e4)}`, $t.ROLLBACK_FAILED, e4 instanceof Error ? e4 : Error(String(e4))));
    }
  }
  static validateDataBeforeMigration(e3, t2) {
    switch (t2) {
      case 0:
        return sn.validateRouteCollectionData(e3).map(() => void 0).mapErr((e4) => new en(`Route collection validation failed: ${e4.message}`, $t.VALIDATION_FAILED, e4));
      case 1:
        return sn.validateSketchArray(e3).map(() => void 0).mapErr((e4) => new en(`Sketch array validation failed: ${e4.message}`, $t.VALIDATION_FAILED, e4));
      default:
        return L(new en(`Unknown version for pre-migration validation: ${t2}`, $t.VALIDATION_FAILED));
    }
  }
  static validateDataAfterMigration(e3, t2) {
    switch (t2) {
      case 1:
        return sn.validateSketchArray(e3).map(() => void 0).mapErr((e4) => new en(`Sketch array validation failed: ${e4.message}`, $t.VALIDATION_FAILED, e4));
      default:
        return L(new en(`Unknown version for post-migration validation: ${t2}`, $t.VALIDATION_FAILED));
    }
  }
  static checkDataIntegrity(e3, t2) {
    return sn.checkDataIntegrity(e3, t2);
  }
}, __publicField(_d, "DEFAULT_OPTIONS", { validateBefore: true, validateAfter: true, enableRollback: true, maxRetries: 3, retryDelay: 1e3 }), _d);
const pn = ae(`sketches`, () => {
  let e3 = A([]), t2 = A(null), n2 = A(null), r2 = me(() => {
    if (!t2.value) return null;
    let n3 = e3.value.find((e4) => e4.id === t2.value);
    return n3 ? new Zt(n3.routes.routes.map((e4) => new Qt(e4.id, e4.points, e4.properties, e4.meta)), n3.routes.id, n3.routes.meta) : null;
  }), i2 = me(() => r2.value ? r2.value.routes.map((e4) => ({ id: e4.id, name: e4.name, points: e4.getPoints(), meta: e4.meta })) : []), a2 = me(() => t2.value && e3.value.find((e4) => e4.id === t2.value) || null), o2 = me(() => a2.value ? a2.value.drafts.drafts : []);
  async function s2() {
    let n3 = await ke(`sketches`);
    if (n3) {
      let r3 = fn.migrateToCurrent(n3, { validateBefore: true, validateAfter: true, enableRollback: true });
      if (r3.isErr()) {
        console.error(`[SketchStore] Data migration failed:`, r3.error), await c2();
        return;
      }
      let i3 = r3.value;
      if (i3.migratedVersions.length > 0 && console.info(`[SketchStore] Successfully migrated data from version ${i3.fromVersion} to ${i3.toVersion}`), Array.isArray(i3.data)) {
        e3.value = i3.data.map((e4) => J.fromStorage(e4));
        let n4 = [];
        e3.value.forEach((e4) => {
          e4.routes.routes.forEach((e5) => {
            e5.points.length > 1 && !e5.meta.distance && n4.push((async () => {
              try {
                e5.meta.distance = await oe(e5.points);
              } catch (t3) {
                console.warn(`Failed to calculate route distance:`, t3), e5.meta.distance = 0;
              }
            })());
          });
        }), await Promise.all(n4), !t2.value && e3.value.length > 0 && (t2.value = e3.value[0].id);
      } else await c2();
    } else await c2();
  }
  async function c2() {
    let n3 = new J();
    n3.meta.name = `Default Sketch`, e3.value = [n3], t2.value = n3.id, await Oe(`sketches`, e3.value.map((e4) => e4.toStorage())), await Ee();
  }
  async function l2(t3 = `New Sketch`) {
    let n3 = new J();
    return n3.meta.name = t3, e3.value.push(n3), await Oe(`sketches`, e3.value.map((e4) => e4.toStorage())), await Ee(), n3;
  }
  async function u2(t3, n3) {
    let r3 = e3.value.find((e4) => e4.id === t3);
    r3 && (n3.name !== void 0 && r3.updateName(n3.name), n3.description !== void 0 && r3.updateDescription(n3.description), n3.tags !== void 0 && (r3.meta.tags.forEach((e4) => {
      r3.removeTag(e4);
    }), n3.tags.forEach((e4) => {
      r3.addTag(e4);
    })), await Oe(`sketches`, e3.value.map((e4) => e4.toStorage())), await Ee());
  }
  async function d2(n3) {
    let r3 = e3.value.findIndex((e4) => e4.id === n3);
    r3 !== -1 && (e3.value.splice(r3, 1), t2.value === n3 && (t2.value = e3.value.length > 0 ? e3.value[0].id : null), await Oe(`sketches`, e3.value.map((e4) => e4.toStorage())), await Ee());
  }
  function f2(e4) {
    t2.value = e4, n2.value = null;
  }
  async function p2(t3, n3 = {}, r3 = {}) {
    a2.value || await c2();
    let i3 = new Qt(void 0, [], n3, r3);
    return i3.meta.name = t3, a2.value && a2.value.routes.routes.push(i3.exportToStorage()), await Oe(`sketches`, e3.value.map((e4) => e4.toStorage())), await Ee(), i3;
  }
  async function m2(t3) {
    if (!a2.value) return;
    let r3 = a2.value.routes.routes.findIndex((e4) => e4.id === t3);
    r3 !== -1 && (a2.value.routes.routes.splice(r3, 1), n2.value === t3 && (n2.value = null), await Oe(`sketches`, e3.value.map((e4) => e4.toStorage())), await Ee());
  }
  async function h2(t3, n3) {
    if (!a2.value) return;
    let r3 = a2.value.routes.routes.find((e4) => e4.id === t3);
    if (r3) {
      if (r3.points.push(n3), r3.meta.modification_timestamp = Date.now(), r3.points.length > 1) try {
        if (r3.meta.distance === void 0) {
          let e4 = await oe(r3.points);
          r3.meta.distance = e4;
        } else {
          let e4 = await oe([r3.points[r3.points.length - 2], n3]);
          r3.meta.distance += e4;
        }
      } catch (e4) {
        console.warn(`Failed to calculate route distance:`, e4), r3.meta.distance === void 0 && (r3.meta.distance = 0);
      }
      await Oe(`sketches`, e3.value.map((e4) => e4.toStorage())), await Ee();
    }
  }
  async function g2(t3, n3) {
    if (!a2.value) return;
    let r3 = a2.value.routes.routes.find((e4) => e4.id === t3);
    r3 && (n3.meta !== void 0 && (r3.meta = { ...r3.meta, ...n3.meta }), n3.properties !== void 0 && (r3.properties = { ...r3.properties, ...n3.properties }), r3.meta.modification_timestamp = Date.now(), await Oe(`sketches`, e3.value.map((e4) => e4.toStorage())), await Ee());
  }
  async function _2(t3) {
    if (!a2.value) return;
    let n3 = a2.value.routes.routes.find((e4) => e4.id === t3);
    n3 && (n3.points = [], n3.meta.modification_timestamp = Date.now(), await Oe(`sketches`, e3.value.map((e4) => e4.toStorage())), await Ee());
  }
  function v2(e4) {
    return a2.value && a2.value.routes.routes.find((t3) => t3.id === e4) || null;
  }
  function y2(e4) {
    n2.value = e4;
  }
  async function b2(t3, n3 = {}, r3 = {}) {
    a2.value || await c2();
    let i3 = { id: crypto.randomUUID(), meta: { ...Xt(), ...r3 }, shape: t3, properties: n3 };
    return a2.value && a2.value.drafts.drafts.push(i3), await Oe(`sketches`, e3.value.map((e4) => e4.toStorage())), await Ee(), i3;
  }
  async function x2(t3, n3) {
    if (!a2.value) return;
    let r3 = a2.value.drafts.drafts.find((e4) => e4.id === t3);
    r3 && (n3.shape !== void 0 && (r3.shape = n3.shape), n3.properties !== void 0 && (r3.properties = { ...r3.properties, ...n3.properties }), n3.meta !== void 0 && (r3.meta = { ...r3.meta, ...n3.meta }, r3.meta.modification_timestamp = Date.now()), await Oe(`sketches`, e3.value.map((e4) => e4.toStorage())), await Ee());
  }
  async function S2(t3) {
    if (!a2.value) return;
    let n3 = a2.value.drafts.drafts.findIndex((e4) => e4.id === t3);
    n3 !== -1 && (a2.value.drafts.drafts.splice(n3, 1), await Oe(`sketches`, e3.value.map((e4) => e4.toStorage())), await Ee());
  }
  function C2(e4) {
    return a2.value && a2.value.drafts.drafts.find((t3) => t3.id === e4) || null;
  }
  return { sketches: e3, currentSketchId: t2, currentRouteId: n2, routeCollection: r2, routes: i2, currentSketch: a2, currentDrafts: o2, init: s2, createSketch: l2, updateSketch: u2, deleteSketch: d2, setCurrentSketchId: f2, addRoute: p2, deleteRoute: m2, addPointToRoute: h2, updateRoute: g2, clearRoutePoints: _2, getRouteById: v2, setCurrentRouteId: y2, addDraft: b2, updateDraft: x2, deleteDraft: S2, getDraftById: C2 };
});
export {
  qe as _,
  Et as a,
  Nt as c,
  it as d,
  rt as f,
  B as g,
  V as h,
  Dt as i,
  xt as l,
  H as m,
  At as n,
  Tt as o,
  nt as p,
  jt as r,
  Vt as s,
  pn as t,
  at as u,
  Ge as v,
  We as y
};
