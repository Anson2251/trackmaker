var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a;
import { E as ap, G as fw, H as pw, I as mw, d as ot, c as $t, o as ct, a as yt, J as Nl, j as Ee, b as Ie, f as Pn, i as ur, L as lh, q as Ht, k as Ri, p as Xr, h as B, m as is, M as gw, N as Ly, t as zt, O as ns, B as Eo, P as Wn, F as Wr, w as bo, Q as wa, R as vw, S as Sg, U as _w, V as Sn, W as yw, T as By, x as Pr, X as bw, Y as l_, Z as Ca, g as xw, $ as os, u as Ns, v as H, a0 as cc, n as Qo, A as Kt, _ as Ni, a1 as Qa, a2 as ww, a3 as Cw, a4 as ji, a5 as Fr, a6 as r0, a7 as Wm, C as gr, y as $e, s as De, z as yr, D as _c, a8 as Sw, a9 as yp, aa as on, ab as Hd, ac as kw, ad as Oy, l as $y, ae as Pw, af as Tw, ag as va, ah as Yu, ai as Ku } from "./index-DVCf_4QJ.js";
import { u as On } from "./vue-i18n-BFEtHe6A.js";
import { bq as Iw, br as jy, bs as Mw, b0 as vi, b3 as Dl, bt as Ny, bu as Vd, bv as Vy, bw as nn, bx as qn, by as bp, bz as Zm, aT as Uy, a4 as ue, a7 as Ge, ac as Sr, bA as yc, b1 as Xd, bB as Sa, a3 as Ze, a6 as Ae, a8 as Yd, a9 as xp, bC as Zn, aj as qr, af as Jt, B as Ew, ag as Vt, ah as ai, aa as Rl, bD as i0, a_ as ui, bE as wp, bF as oi, ai as Cp, bG as uh, ae as Tn, bH as Rw, bI as Aw, bJ as Io, bK as zl, bL as Dw, ab as Sp, bM as zw, bN as u_, b9 as Ot, R as $n, bO as Fw, b7 as c_, bi as n0, bP as Lw, a5 as sp, ap as kp, bQ as Bw, al as o0, am as Pp, ao as a0, an as s0, bR as Gy, T as kg, bS as Ow, bT as Pg, bU as $w, bV as jw, b5 as Ji, bW as ka, bX as Bn, bY as eo, bZ as Tp, b_ as Nw, b$ as qy, c0 as Wy, c1 as Vw, $ as $l, c2 as Uw, c3 as Gw, c4 as qw, c5 as Ww, c6 as ea, r as Yo, c7 as ts, c8 as Fl, c9 as ep, ca as rs, cb as Ds, cc as Bs, cd as lc, ce as Ll, cf as Zy, cg as Tg, ch as Ig, ci as Mg, cj as Ud, ck as Eg, cl as Rg, cm as Ag, cn as lp, co as Hy, cp as Xy, cq as Yy, cr as dc, cs as up, ct as Zw, cu as Ip, cv as Ky, bg as $r, cw as Hw, b6 as cp, b4 as Xw, cx as Yw, cy as Bl, cz as Kw, a$ as Jy, cA as Qy, cB as Jw, a0 as Qw, aq as e3, cC as t3, cD as r3, cE as l0, cF as i3, cG as n3, cH as o3, cI as a3, c as ch, cJ as dp, cK as eb, cL as tb, cM as s3, cN as Ko, cO as l3, cP as u3, cQ as c3, cR as rb, cS as d3, cT as h3, cU as ib, cV as nb, cW as f3, cX as p3, cY as m3, cZ as d_, c_ as g3, X as ob, c$ as v3, d0 as _3, d1 as y3, d2 as b3, d3 as x3, d4 as w3, d5 as C3, d6 as Hm, d7 as S3, d8 as k3, d9 as ab, da as h_, db as P3, aV as f_, dc as sb, dd as go, de as vo, bh as bi, U as Kd, b2 as lb, bd as bc, bc as T3, bm as u0, bo as Gd, bp as ub, bf as Ja, bn as I3, df as Mo, bk as M3, be as cb, dg as E3, dh as R3, di as A3 } from "./platform-DWoe5Ur5.js";
var D3 = /\s/;
function z3(r) {
  for (var i = r.length; i-- && D3.test(r.charAt(i)); ) ;
  return i;
}
var F3 = /^\s+/;
function L3(r) {
  return r && r.slice(0, z3(r) + 1).replace(F3, "");
}
var p_ = NaN, B3 = /^[-+]0x[0-9a-f]+$/i, O3 = /^0b[01]+$/i, $3 = /^0o[0-7]+$/i, j3 = parseInt;
function qd(r) {
  if (typeof r == "number") return r;
  if (Iw(r)) return p_;
  if (ap(r)) {
    var i = typeof r.valueOf == "function" ? r.valueOf() : r;
    r = ap(i) ? i + "" : i;
  }
  if (typeof r != "string") return r === 0 ? r : +r;
  r = L3(r);
  var l = O3.test(r);
  return l || $3.test(r) ? j3(r.slice(2), l ? 2 : 8) : B3.test(r) ? p_ : +r;
}
function N3(r, i, l, d) {
  for (var f = -1, g = r == null ? 0 : r.length; ++f < g; ) l = i(l, r[f], f, r);
  return l;
}
function V3(r) {
  return function(i) {
    return r == null ? void 0 : r[i];
  };
}
var U3 = { \u00C0: "A", \u00C1: "A", \u00C2: "A", \u00C3: "A", \u00C4: "A", \u00C5: "A", \u00E0: "a", \u00E1: "a", \u00E2: "a", \u00E3: "a", \u00E4: "a", \u00E5: "a", \u00C7: "C", \u00E7: "c", \u00D0: "D", \u00F0: "d", \u00C8: "E", \u00C9: "E", \u00CA: "E", \u00CB: "E", \u00E8: "e", \u00E9: "e", \u00EA: "e", \u00EB: "e", \u00CC: "I", \u00CD: "I", \u00CE: "I", \u00CF: "I", \u00EC: "i", \u00ED: "i", \u00EE: "i", \u00EF: "i", \u00D1: "N", \u00F1: "n", \u00D2: "O", \u00D3: "O", \u00D4: "O", \u00D5: "O", \u00D6: "O", \u00D8: "O", \u00F2: "o", \u00F3: "o", \u00F4: "o", \u00F5: "o", \u00F6: "o", \u00F8: "o", \u00D9: "U", \u00DA: "U", \u00DB: "U", \u00DC: "U", \u00F9: "u", \u00FA: "u", \u00FB: "u", \u00FC: "u", \u00DD: "Y", \u00FD: "y", \u00FF: "y", \u00C6: "Ae", \u00E6: "ae", \u00DE: "Th", \u00FE: "th", \u00DF: "ss", \u0100: "A", \u0102: "A", \u0104: "A", \u0101: "a", \u0103: "a", \u0105: "a", \u0106: "C", \u0108: "C", \u010A: "C", \u010C: "C", \u0107: "c", \u0109: "c", \u010B: "c", \u010D: "c", \u010E: "D", \u0110: "D", \u010F: "d", \u0111: "d", \u0112: "E", \u0114: "E", \u0116: "E", \u0118: "E", \u011A: "E", \u0113: "e", \u0115: "e", \u0117: "e", \u0119: "e", \u011B: "e", \u011C: "G", \u011E: "G", \u0120: "G", \u0122: "G", \u011D: "g", \u011F: "g", \u0121: "g", \u0123: "g", \u0124: "H", \u0126: "H", \u0125: "h", \u0127: "h", \u0128: "I", \u012A: "I", \u012C: "I", \u012E: "I", \u0130: "I", \u0129: "i", \u012B: "i", \u012D: "i", \u012F: "i", \u0131: "i", \u0134: "J", \u0135: "j", \u0136: "K", \u0137: "k", \u0138: "k", \u0139: "L", \u013B: "L", \u013D: "L", \u013F: "L", \u0141: "L", \u013A: "l", \u013C: "l", \u013E: "l", \u0140: "l", \u0142: "l", \u0143: "N", \u0145: "N", \u0147: "N", \u014A: "N", \u0144: "n", \u0146: "n", \u0148: "n", \u014B: "n", \u014C: "O", \u014E: "O", \u0150: "O", \u014D: "o", \u014F: "o", \u0151: "o", \u0154: "R", \u0156: "R", \u0158: "R", \u0155: "r", \u0157: "r", \u0159: "r", \u015A: "S", \u015C: "S", \u015E: "S", \u0160: "S", \u015B: "s", \u015D: "s", \u015F: "s", \u0161: "s", \u0162: "T", \u0164: "T", \u0166: "T", \u0163: "t", \u0165: "t", \u0167: "t", \u0168: "U", \u016A: "U", \u016C: "U", \u016E: "U", \u0170: "U", \u0172: "U", \u0169: "u", \u016B: "u", \u016D: "u", \u016F: "u", \u0171: "u", \u0173: "u", \u0174: "W", \u0175: "w", \u0176: "Y", \u0177: "y", \u0178: "Y", \u0179: "Z", \u017B: "Z", \u017D: "Z", \u017A: "z", \u017C: "z", \u017E: "z", \u0132: "IJ", \u0133: "ij", \u0152: "Oe", \u0153: "oe", \u0149: "'n", \u017F: "s" }, G3 = V3(U3), q3 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, W3 = "\\u0300-\\u036f", Z3 = "\\ufe20-\\ufe2f", H3 = "\\u20d0-\\u20ff", X3 = W3 + Z3 + H3, Y3 = "[" + X3 + "]", K3 = RegExp(Y3, "g");
function J3(r) {
  return r = jy(r), r && r.replace(q3, G3).replace(K3, "");
}
var Q3 = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function eC(r) {
  return r.match(Q3) || [];
}
var tC = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function rC(r) {
  return tC.test(r);
}
var db = "\\ud800-\\udfff", iC = "\\u0300-\\u036f", nC = "\\ufe20-\\ufe2f", oC = "\\u20d0-\\u20ff", aC = iC + nC + oC, hb = "\\u2700-\\u27bf", fb = "a-z\\xdf-\\xf6\\xf8-\\xff", sC = "\\xac\\xb1\\xd7\\xf7", lC = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", uC = "\\u2000-\\u206f", cC = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", pb = "A-Z\\xc0-\\xd6\\xd8-\\xde", dC = "\\ufe0e\\ufe0f", mb = sC + lC + uC + cC, gb = "['\u2019]", m_ = "[" + mb + "]", hC = "[" + aC + "]", vb = "\\d+", fC = "[" + hb + "]", _b = "[" + fb + "]", yb = "[^" + db + mb + vb + hb + fb + pb + "]", pC = "\\ud83c[\\udffb-\\udfff]", mC = "(?:" + hC + "|" + pC + ")", gC = "[^" + db + "]", bb = "(?:\\ud83c[\\udde6-\\uddff]){2}", xb = "[\\ud800-\\udbff][\\udc00-\\udfff]", ac = "[" + pb + "]", vC = "\\u200d", g_ = "(?:" + _b + "|" + yb + ")", _C = "(?:" + ac + "|" + yb + ")", v_ = "(?:" + gb + "(?:d|ll|m|re|s|t|ve))?", __ = "(?:" + gb + "(?:D|LL|M|RE|S|T|VE))?", wb = mC + "?", Cb = "[" + dC + "]?", yC = "(?:" + vC + "(?:" + [gC, bb, xb].join("|") + ")" + Cb + wb + ")*", bC = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", xC = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", wC = Cb + wb + yC, CC = "(?:" + [fC, bb, xb].join("|") + ")" + wC, SC = RegExp([ac + "?" + _b + "+" + v_ + "(?=" + [m_, ac, "$"].join("|") + ")", _C + "+" + __ + "(?=" + [m_, ac + g_, "$"].join("|") + ")", ac + "?" + g_ + "+" + v_, ac + "+" + __, xC, bC, vb, CC].join("|"), "g");
function kC(r) {
  return r.match(SC) || [];
}
function PC(r, i, l) {
  return r = jy(r), i = i, i === void 0 ? rC(r) ? kC(r) : eC(r) : r.match(i) || [];
}
var TC = "['\u2019]", IC = RegExp(TC, "g");
function MC(r) {
  return function(i) {
    return N3(PC(J3(i).replace(IC, "")), r, "");
  };
}
function EC(r, i, l) {
  return r === r && (l !== void 0 && (r = r <= l ? r : l), i !== void 0 && (r = r >= i ? r : i)), r;
}
function Dg(r, i, l) {
  return l === void 0 && (l = i, i = void 0), l !== void 0 && (l = qd(l), l = l === l ? l : 0), i !== void 0 && (i = qd(i), i = i === i ? i : 0), EC(qd(r), i, l);
}
var Xm = function() {
  return fw.Date.now();
}, RC = "Expected a function", AC = Math.max, DC = Math.min;
function zC(r, i, l) {
  var d, f, g, p, s, C, P = 0, M = false, D = false, L = true;
  if (typeof r != "function") throw new TypeError(RC);
  i = qd(i) || 0, ap(l) && (M = !!l.leading, D = "maxWait" in l, g = D ? AC(qd(l.maxWait) || 0, i) : g, L = "trailing" in l ? !!l.trailing : L);
  function $(J) {
    var we = d, fe = f;
    return d = f = void 0, P = J, p = r.apply(fe, we), p;
  }
  function z(J) {
    return P = J, s = setTimeout(q, i), M ? $(J) : p;
  }
  function F(J) {
    var we = J - C, fe = J - P, oe = i - we;
    return D ? DC(oe, g - fe) : oe;
  }
  function Z(J) {
    var we = J - C, fe = J - P;
    return C === void 0 || we >= i || we < 0 || D && fe >= g;
  }
  function q() {
    var J = Xm();
    if (Z(J)) return K(J);
    s = setTimeout(q, F(J));
  }
  function K(J) {
    return s = void 0, L && d ? $(J) : (d = f = void 0, p);
  }
  function te() {
    s !== void 0 && clearTimeout(s), P = 0, d = C = f = s = void 0;
  }
  function re() {
    return s === void 0 ? p : K(Xm());
  }
  function ie() {
    var J = Xm(), we = Z(J);
    if (d = arguments, f = this, C = J, we) {
      if (s === void 0) return z(C);
      if (D) return clearTimeout(s), s = setTimeout(q, i), $(C);
    }
    return s === void 0 && (s = setTimeout(q, i)), p;
  }
  return ie.cancel = te, ie.flush = re, ie;
}
var FC = "[object Number]";
function LC(r) {
  return typeof r == "number" || pw(r) && mw(r) == FC;
}
var BC = MC(function(r, i, l) {
  return r + (l ? "-" : "") + i.toLowerCase();
}), OC = "Expected a function";
function $C(r, i, l) {
  var d = true, f = true;
  if (typeof r != "function") throw new TypeError(OC);
  return ap(l) && (d = "leading" in l ? !!l.leading : d, f = "trailing" in l ? !!l.trailing : f), zC(r, i, { leading: d, maxWait: i, trailing: f });
}
const jC = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, NC = ot({ name: "BrandGithub", render: function(i, l) {
  return ct(), $t("svg", jC, l[0] || (l[0] = [yt("path", { d: "M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2c2.8-.3 5.5-1.4 5.5-6a4.6 4.6 0 0 0-1.3-3.2a4.2 4.2 0 0 0-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3 0 0 0-6.2 0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2 0 0 0-.1 3.2A4.6 4.6 0 0 0 4 9.5c0 4.6 2.7 5.7 5.5 6c-.6.6-.6 1.2-.5 2V21", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), VC = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, UC = ot({ name: "BuildingCommunity", render: function(i, l) {
  return ct(), $t("svg", VC, l[0] || (l[0] = [Nl('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 9l5 5v7H8v-4m0 4H3v-7l5-5m1 1V4a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v17h-8"></path><path d="M13 7v.01"></path><path d="M17 7v.01"></path><path d="M17 11v.01"></path><path d="M17 15v.01"></path></g>', 1)]));
} }), GC = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, qC = ot({ name: "Calendar", render: function(i, l) {
  return ct(), $t("svg", GC, l[0] || (l[0] = [Nl('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="5" width="16" height="16" rx="2"></rect><path d="M16 3v4"></path><path d="M8 3v4"></path><path d="M4 11h16"></path><path d="M11 15h1"></path><path d="M12 15v3"></path></g>', 1)]));
} }), WC = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, ZC = ot({ name: "CurrentLocation", render: function(i, l) {
  return ct(), $t("svg", WC, l[0] || (l[0] = [Nl('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><circle cx="12" cy="12" r="8"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="M20 12h2"></path><path d="M2 12h2"></path></g>', 1)]));
} }), HC = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, XC = ot({ name: "DeviceFloppy", render: function(i, l) {
  return ct(), $t("svg", HC, l[0] || (l[0] = [yt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [yt("path", { d: "M6 4h10l4 4v10a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2" }), yt("circle", { cx: "12", cy: "14", r: "2" }), yt("path", { d: "M14 4v4H8V4" })], -1)]));
} }), YC = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, KC = ot({ name: "Edit", render: function(i, l) {
  return ct(), $t("svg", YC, l[0] || (l[0] = [yt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [yt("path", { d: "M9 7H6a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h9a2 2 0 0 0 2-2v-3" }), yt("path", { d: "M9 15h3l8.5-8.5a1.5 1.5 0 0 0-3-3L9 12v3" }), yt("path", { d: "M16 5l3 3" })], -1)]));
} }), JC = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Sb = ot({ name: "FileText", render: function(i, l) {
  return ct(), $t("svg", JC, l[0] || (l[0] = [Nl('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 3v4a1 1 0 0 0 1 1h4"></path><path d="M17 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7l5 5v11a2 2 0 0 1-2 2z"></path><path d="M9 9h1"></path><path d="M9 13h6"></path><path d="M9 17h6"></path></g>', 1)]));
} }), QC = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, eS = ot({ name: "Folder", render: function(i, l) {
  return ct(), $t("svg", QC, l[0] || (l[0] = [yt("path", { d: "M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), tS = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, kb = ot({ name: "HandFinger", render: function(i, l) {
  return ct(), $t("svg", tS, l[0] || (l[0] = [Nl('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 13V4.5a1.5 1.5 0 0 1 3 0V12"></path><path d="M11 11.5v-2a1.5 1.5 0 1 1 3 0V12"></path><path d="M14 10.5a1.5 1.5 0 0 1 3 0V12"></path><path d="M17 11.5a1.5 1.5 0 0 1 3 0V16a6 6 0 0 1-6 6h-2h.208a6 6 0 0 1-5.012-2.7A69.74 69.74 0 0 1 7 19c-.312-.479-1.407-2.388-3.286-5.728a1.5 1.5 0 0 1 .536-2.022a1.867 1.867 0 0 1 2.28.28L8 13"></path></g>', 1)]));
} }), rS = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Pb = ot({ name: "Line", render: function(i, l) {
  return ct(), $t("svg", rS, l[0] || (l[0] = [yt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [yt("circle", { cx: "6", cy: "18", r: "2" }), yt("circle", { cx: "18", cy: "6", r: "2" }), yt("path", { d: "M7.5 16.5l9-9" })], -1)]));
} }), iS = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, y_ = ot({ name: "Link", render: function(i, l) {
  return ct(), $t("svg", iS, l[0] || (l[0] = [yt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [yt("path", { d: "M10 14a3.5 3.5 0 0 0 5 0l4-4a3.5 3.5 0 0 0-5-5l-.5.5" }), yt("path", { d: "M14 10a3.5 3.5 0 0 0-5 0l-4 4a3.5 3.5 0 0 0 5 5l.5-.5" })], -1)]));
} }), nS = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, oS = ot({ name: "Minus", render: function(i, l) {
  return ct(), $t("svg", nS, l[0] || (l[0] = [yt("path", { d: "M5 12h14", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), aS = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, sS = ot({ name: "PlayerRecord", render: function(i, l) {
  return ct(), $t("svg", aS, l[0] || (l[0] = [yt("circle", { cx: "12", cy: "12", r: "7", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), lS = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Jd = ot({ name: "Plus", render: function(i, l) {
  return ct(), $t("svg", lS, l[0] || (l[0] = [yt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [yt("path", { d: "M12 5v14" }), yt("path", { d: "M5 12h14" })], -1)]));
} }), uS = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, c0 = ot({ name: "Route", render: function(i, l) {
  return ct(), $t("svg", uS, l[0] || (l[0] = [yt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [yt("circle", { cx: "6", cy: "19", r: "2" }), yt("circle", { cx: "18", cy: "5", r: "2" }), yt("path", { d: "M12 19h4.5a3.5 3.5 0 0 0 0-7h-8a3.5 3.5 0 0 1 0-7H12" })], -1)]));
} }), cS = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Tb = ot({ name: "Shape", render: function(i, l) {
  return ct(), $t("svg", cS, l[0] || (l[0] = [Nl('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="5" cy="5" r="2"></circle><circle cx="19" cy="5" r="2"></circle><circle cx="5" cy="19" r="2"></circle><circle cx="19" cy="19" r="2"></circle><path d="M5 7v10"></path><path d="M7 5h10"></path><path d="M7 19h10"></path><path d="M19 7v10"></path></g>', 1)]));
} }), dS = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, hS = ot({ name: "Square", render: function(i, l) {
  return ct(), $t("svg", dS, l[0] || (l[0] = [yt("rect", { x: "4", y: "4", width: "16", height: "16", rx: "2", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), fS = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Mp = ot({ name: "Trash", render: function(i, l) {
  return ct(), $t("svg", fS, l[0] || (l[0] = [Nl('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 7h16"></path><path d="M10 11v6"></path><path d="M14 11v6"></path><path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2l1-12"></path><path d="M9 7V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3"></path></g>', 1)]));
} }), pS = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Ib = ot({ name: "Upload", render: function(i, l) {
  return ct(), $t("svg", pS, l[0] || (l[0] = [yt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [yt("path", { d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2" }), yt("path", { d: "M7 9l5-5l5 5" }), yt("path", { d: "M12 4v12" })], -1)]));
} });
function Mb(r) {
  return typeof r == "string" ? document.querySelector(r) : typeof r == "function" ? r() : r;
}
function mS(r) {
  if (typeof r == "number") return { "": r.toString() };
  const i = {};
  return r.split(/ +/).forEach((l) => {
    if (l === "") return;
    const [d, f] = l.split(":");
    f === void 0 ? i[""] = d : i[d] = f;
  }), i;
}
function Ju(r, i) {
  var l;
  if (r == null) return;
  const d = mS(r);
  if (i === void 0) return d[""];
  if (typeof i == "string") return (l = d[i]) !== null && l !== void 0 ? l : d[""];
  if (Array.isArray(i)) {
    for (let f = i.length - 1; f >= 0; --f) {
      const g = i[f];
      if (g in d) return d[g];
    }
    return d[""];
  } else {
    let f, g = -1;
    return Object.keys(d).forEach((p) => {
      const s = Number(p);
      !Number.isNaN(s) && i >= s && s >= g && (g = s, f = d[p]);
    }), f;
  }
}
const gS = { xs: 0, s: 640, m: 1024, l: 1280, xl: 1536, "2xl": 1920 };
function vS(r) {
  return `(min-width: ${r}px)`;
}
const Ad = {};
function _S(r = gS) {
  if (!Mw) return Ee(() => []);
  if (typeof window.matchMedia != "function") return Ee(() => []);
  const i = Ie({}), l = Object.keys(r), d = (f, g) => {
    f.matches ? i.value[g] = true : i.value[g] = false;
  };
  return l.forEach((f) => {
    const g = r[f];
    let p, s;
    Ad[g] === void 0 ? (p = window.matchMedia(vS(g)), p.addEventListener ? p.addEventListener("change", (C) => {
      s.forEach((P) => {
        P(C, f);
      });
    }) : p.addListener && p.addListener((C) => {
      s.forEach((P) => {
        P(C, f);
      });
    }), s = /* @__PURE__ */ new Set(), Ad[g] = { mql: p, cbs: s }) : (p = Ad[g].mql, s = Ad[g].cbs), s.add(d), p.matches && s.forEach((C) => {
      C(p, f);
    });
  }), Pn(() => {
    l.forEach((f) => {
      const { cbs: g } = Ad[r[f]];
      g.has(d) && g.delete(d);
    });
  }), Ee(() => {
    const { value: f } = i;
    return l.filter((g) => f[g]);
  });
}
function yS(r, i, l) {
  var d;
  const f = ur(r, null);
  if (f === null) return;
  const g = (d = lh()) === null || d === void 0 ? void 0 : d.proxy;
  Ht(l, p), p(l.value), Pn(() => {
    p(void 0, l.value);
  });
  function p(P, M) {
    if (!f) return;
    const D = f[i];
    M !== void 0 && s(D, M), P !== void 0 && C(D, P);
  }
  function s(P, M) {
    P[M] || (P[M] = []), P[M].splice(P[M].findIndex((D) => D === g), 1);
  }
  function C(P, M) {
    P[M] || (P[M] = []), ~P[M].findIndex((D) => D === g) || P[M].push(g);
  }
}
function bS(r, i, l) {
  const d = ur(r, null);
  d !== null && (i in d || (d[i] = []), d[i].push(l.value), Ht(l, (f, g) => {
    const p = d[i], s = p.findIndex((C) => C === g);
    ~s && p.splice(s, 1), p.push(f);
  }), Pn(() => {
    const f = d[i], g = f.findIndex((p) => p === l.value);
    ~g && f.splice(g, 1);
  }));
}
function xS(r, i, l) {
  const d = ur(r, null);
  d !== null && (i in d || (d[i] = []), Ri(() => {
    const f = l();
    f && d[i].push(f);
  }), Pn(() => {
    const f = d[i], g = l(), p = f.findIndex((s) => s === g);
    ~p && f.splice(p, 1);
  }));
}
function b_(r) {
  return r & -r;
}
class Eb {
  constructor(i, l) {
    this.l = i, this.min = l;
    const d = new Array(i + 1);
    for (let f = 0; f < i + 1; ++f) d[f] = 0;
    this.ft = d;
  }
  add(i, l) {
    if (l === 0) return;
    const { l: d, ft: f } = this;
    for (i += 1; i <= d; ) f[i] += l, i += b_(i);
  }
  get(i) {
    return this.sum(i + 1) - this.sum(i);
  }
  sum(i) {
    if (i === void 0 && (i = this.l), i <= 0) return 0;
    const { ft: l, min: d, l: f } = this;
    if (i > f) throw new Error("[FinweckTree.sum]: `i` is larger than length.");
    let g = i * d;
    for (; i > 0; ) g += l[i], i -= b_(i);
    return g;
  }
  getBound(i) {
    let l = 0, d = this.l;
    for (; d > l; ) {
      const f = Math.floor((l + d) / 2), g = this.sum(f);
      if (g > i) {
        d = f;
        continue;
      } else if (g < i) {
        if (l === f) return this.sum(l + 1) <= i ? l + 1 : f;
        l = f;
      } else return f;
    }
    return l;
  }
}
let Of;
function wS() {
  return typeof document > "u" ? false : (Of === void 0 && ("matchMedia" in window ? Of = window.matchMedia("(pointer:coarse)").matches : Of = false), Of);
}
let Ym;
function x_() {
  return typeof document > "u" ? 1 : (Ym === void 0 && (Ym = "chrome" in window ? window.devicePixelRatio : 1), Ym);
}
const Rb = "VVirtualListXScroll";
function CS({ columnsRef: r, renderColRef: i, renderItemWithColsRef: l }) {
  const d = Ie(0), f = Ie(0), g = Ee(() => {
    const P = r.value;
    if (P.length === 0) return null;
    const M = new Eb(P.length, 0);
    return P.forEach((D, L) => {
      M.add(L, D.width);
    }), M;
  }), p = vi(() => {
    const P = g.value;
    return P !== null ? Math.max(P.getBound(f.value) - 1, 0) : 0;
  }), s = (P) => {
    const M = g.value;
    return M !== null ? M.sum(P) : 0;
  }, C = vi(() => {
    const P = g.value;
    return P !== null ? Math.min(P.getBound(f.value + d.value) + 1, r.value.length - 1) : 0;
  });
  return Xr(Rb, { startIndexRef: p, endIndexRef: C, columnsRef: r, renderColRef: i, renderItemWithColsRef: l, getLeft: s }), { listWidthRef: d, scrollLeftRef: f };
}
const w_ = ot({ name: "VirtualListRow", props: { index: { type: Number, required: true }, item: { type: Object, required: true } }, setup() {
  const { startIndexRef: r, endIndexRef: i, columnsRef: l, getLeft: d, renderColRef: f, renderItemWithColsRef: g } = ur(Rb);
  return { startIndex: r, endIndex: i, columns: l, renderCol: f, renderItemWithCols: g, getLeft: d };
}, render() {
  const { startIndex: r, endIndex: i, columns: l, renderCol: d, renderItemWithCols: f, getLeft: g, item: p } = this;
  if (f != null) return f({ itemIndex: this.index, startColIndex: r, endColIndex: i, allColumns: l, item: p, getLeft: g });
  if (d != null) {
    const s = [];
    for (let C = r; C <= i; ++C) {
      const P = l[C];
      s.push(d({ column: P, left: g(C), item: p }));
    }
    return s;
  }
  return null;
} }), SS = Vd(".v-vl", { maxHeight: "inherit", height: "100%", overflow: "auto", minWidth: "1px" }, [Vd("&:not(.v-vl--show-scrollbar)", { scrollbarWidth: "none" }, [Vd("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", { width: 0, height: 0, display: "none" })])]), kS = ot({ name: "VirtualList", inheritAttrs: false, props: { showScrollbar: { type: Boolean, default: true }, columns: { type: Array, default: () => [] }, renderCol: Function, renderItemWithCols: Function, items: { type: Array, default: () => [] }, itemSize: { type: Number, required: true }, itemResizable: Boolean, itemsStyle: [String, Object], visibleItemsTag: { type: [String, Object], default: "div" }, visibleItemsProps: Object, ignoreItemResize: Boolean, onScroll: Function, onWheel: Function, onResize: Function, defaultScrollKey: [Number, String], defaultScrollIndex: Number, keyField: { type: String, default: "key" }, paddingTop: { type: [Number, String], default: 0 }, paddingBottom: { type: [Number, String], default: 0 } }, setup(r) {
  const i = Ny();
  SS.mount({ id: "vueuc/virtual-list", head: true, anchorMetaName: Vy, ssr: i }), Ri(() => {
    const { defaultScrollIndex: qe, defaultScrollKey: tt } = r;
    qe != null ? Z({ index: qe }) : tt != null && Z({ key: tt });
  });
  let l = false, d = false;
  gw(() => {
    if (l = false, !d) {
      d = true;
      return;
    }
    Z({ top: $.value, left: p.value });
  }), Ly(() => {
    l = true, d || (d = true);
  });
  const f = vi(() => {
    if (r.renderCol == null && r.renderItemWithCols == null || r.columns.length === 0) return;
    let qe = 0;
    return r.columns.forEach((tt) => {
      qe += tt.width;
    }), qe;
  }), g = Ee(() => {
    const qe = /* @__PURE__ */ new Map(), { keyField: tt } = r;
    return r.items.forEach((ut, mt) => {
      qe.set(ut[tt], mt);
    }), qe;
  }), { scrollLeftRef: p, listWidthRef: s } = CS({ columnsRef: zt(r, "columns"), renderColRef: zt(r, "renderCol"), renderItemWithColsRef: zt(r, "renderItemWithCols") }), C = Ie(null), P = Ie(void 0), M = /* @__PURE__ */ new Map(), D = Ee(() => {
    const { items: qe, itemSize: tt, keyField: ut } = r, mt = new Eb(qe.length, tt);
    return qe.forEach((St, st) => {
      const nt = St[ut], ft = M.get(nt);
      ft !== void 0 && mt.add(st, ft);
    }), mt;
  }), L = Ie(0), $ = Ie(0), z = vi(() => Math.max(D.value.getBound($.value - nn(r.paddingTop)) - 1, 0)), F = Ee(() => {
    const { value: qe } = P;
    if (qe === void 0) return [];
    const { items: tt, itemSize: ut } = r, mt = z.value, St = Math.min(mt + Math.ceil(qe / ut + 1), tt.length - 1), st = [];
    for (let nt = mt; nt <= St; ++nt) st.push(tt[nt]);
    return st;
  }), Z = (qe, tt) => {
    if (typeof qe == "number") {
      re(qe, tt, "auto");
      return;
    }
    const { left: ut, top: mt, index: St, key: st, position: nt, behavior: ft, debounce: Lt = true } = qe;
    if (ut !== void 0 || mt !== void 0) re(ut, mt, ft);
    else if (St !== void 0) te(St, ft, Lt);
    else if (st !== void 0) {
      const pt = g.value.get(st);
      pt !== void 0 && te(pt, ft, Lt);
    } else nt === "bottom" ? re(0, Number.MAX_SAFE_INTEGER, ft) : nt === "top" && re(0, 0, ft);
  };
  let q, K = null;
  function te(qe, tt, ut) {
    const { value: mt } = D, St = mt.sum(qe) + nn(r.paddingTop);
    if (!ut) C.value.scrollTo({ left: 0, top: St, behavior: tt });
    else {
      q = qe, K !== null && window.clearTimeout(K), K = window.setTimeout(() => {
        q = void 0, K = null;
      }, 16);
      const { scrollTop: st, offsetHeight: nt } = C.value;
      if (St > st) {
        const ft = mt.get(qe);
        St + ft <= st + nt || C.value.scrollTo({ left: 0, top: St + ft - nt, behavior: tt });
      } else C.value.scrollTo({ left: 0, top: St, behavior: tt });
    }
  }
  function re(qe, tt, ut) {
    C.value.scrollTo({ left: qe, top: tt, behavior: ut });
  }
  function ie(qe, tt) {
    var ut, mt, St;
    if (l || r.ignoreItemResize || Ue(tt.target)) return;
    const { value: st } = D, nt = g.value.get(qe), ft = st.get(nt), Lt = (St = (mt = (ut = tt.borderBoxSize) === null || ut === void 0 ? void 0 : ut[0]) === null || mt === void 0 ? void 0 : mt.blockSize) !== null && St !== void 0 ? St : tt.contentRect.height;
    if (Lt === ft) return;
    Lt - r.itemSize === 0 ? M.delete(qe) : M.set(qe, Lt - r.itemSize);
    const wt = Lt - ft;
    if (wt === 0) return;
    st.add(nt, wt);
    const Ft = C.value;
    if (Ft != null) {
      if (q === void 0) {
        const tr = st.sum(nt);
        Ft.scrollTop > tr && Ft.scrollBy(0, wt);
      } else if (nt < q) Ft.scrollBy(0, wt);
      else if (nt === q) {
        const tr = st.sum(nt);
        Lt + tr > Ft.scrollTop + Ft.offsetHeight && Ft.scrollBy(0, wt);
      }
      _e();
    }
    L.value++;
  }
  const J = !wS();
  let we = false;
  function fe(qe) {
    var tt;
    (tt = r.onScroll) === null || tt === void 0 || tt.call(r, qe), (!J || !we) && _e();
  }
  function oe(qe) {
    var tt;
    if ((tt = r.onWheel) === null || tt === void 0 || tt.call(r, qe), J) {
      const ut = C.value;
      if (ut != null) {
        if (qe.deltaX === 0 && (ut.scrollTop === 0 && qe.deltaY <= 0 || ut.scrollTop + ut.offsetHeight >= ut.scrollHeight && qe.deltaY >= 0)) return;
        qe.preventDefault(), ut.scrollTop += qe.deltaY / x_(), ut.scrollLeft += qe.deltaX / x_(), _e(), we = true, bp(() => {
          we = false;
        });
      }
    }
  }
  function he(qe) {
    if (l || Ue(qe.target)) return;
    if (r.renderCol == null && r.renderItemWithCols == null) {
      if (qe.contentRect.height === P.value) return;
    } else if (qe.contentRect.height === P.value && qe.contentRect.width === s.value) return;
    P.value = qe.contentRect.height, s.value = qe.contentRect.width;
    const { onResize: tt } = r;
    tt !== void 0 && tt(qe);
  }
  function _e() {
    const { value: qe } = C;
    qe != null && ($.value = qe.scrollTop, p.value = qe.scrollLeft);
  }
  function Ue(qe) {
    let tt = qe;
    for (; tt !== null; ) {
      if (tt.style.display === "none") return true;
      tt = tt.parentElement;
    }
    return false;
  }
  return { listHeight: P, listStyle: { overflow: "auto" }, keyToIndex: g, itemsStyle: Ee(() => {
    const { itemResizable: qe } = r, tt = qn(D.value.sum());
    return L.value, [r.itemsStyle, { boxSizing: "content-box", width: qn(f.value), height: qe ? "" : tt, minHeight: qe ? tt : "", paddingTop: qn(r.paddingTop), paddingBottom: qn(r.paddingBottom) }];
  }), visibleItemsStyle: Ee(() => (L.value, { transform: `translateY(${qn(D.value.sum(z.value))})` })), viewportItems: F, listElRef: C, itemsElRef: Ie(null), scrollTo: Z, handleListResize: he, handleListScroll: fe, handleListWheel: oe, handleItemResize: ie };
}, render() {
  const { itemResizable: r, keyField: i, keyToIndex: l, visibleItemsTag: d } = this;
  return B(Dl, { onResize: this.handleListResize }, { default: () => {
    var f, g;
    return B("div", is(this.$attrs, { class: ["v-vl", this.showScrollbar && "v-vl--show-scrollbar"], onScroll: this.handleListScroll, onWheel: this.handleListWheel, ref: "listElRef" }), [this.items.length !== 0 ? B("div", { ref: "itemsElRef", class: "v-vl-items", style: this.itemsStyle }, [B(d, Object.assign({ class: "v-vl-visible-items", style: this.visibleItemsStyle }, this.visibleItemsProps), { default: () => {
      const { renderCol: p, renderItemWithCols: s } = this;
      return this.viewportItems.map((C) => {
        const P = C[i], M = l.get(P), D = p != null ? B(w_, { index: M, item: C }) : void 0, L = s != null ? B(w_, { index: M, item: C }) : void 0, $ = this.$slots.default({ item: C, renderedCols: D, renderedItemWithCols: L, index: M })[0];
        return r ? B(Dl, { key: P, onResize: (z) => this.handleItemResize(P, z) }, { default: () => $ }) : ($.key = P, $);
      });
    } })]) : (g = (f = this.$slots).empty) === null || g === void 0 ? void 0 : g.call(f)]);
  } });
} }), PS = Vd(".v-x-scroll", { overflow: "auto", scrollbarWidth: "none" }, [Vd("&::-webkit-scrollbar", { width: 0, height: 0 })]), TS = ot({ name: "XScroll", props: { disabled: Boolean, onScroll: Function }, setup() {
  const r = Ie(null);
  function i(f) {
    !(f.currentTarget.offsetWidth < f.currentTarget.scrollWidth) || f.deltaY === 0 || (f.currentTarget.scrollLeft += f.deltaY + f.deltaX, f.preventDefault());
  }
  const l = Ny();
  return PS.mount({ id: "vueuc/x-scroll", head: true, anchorMetaName: Vy, ssr: l }), Object.assign({ selfRef: r, handleWheel: i }, { scrollTo(...f) {
    var g;
    (g = r.value) === null || g === void 0 || g.scrollTo(...f);
  } });
}, render() {
  return B("div", { ref: "selfRef", onScroll: this.onScroll, onWheel: this.disabled ? void 0 : this.handleWheel, class: "v-x-scroll" }, this.$slots);
} });
function Ab(r, i) {
  i && (Ri(() => {
    const { value: l } = r;
    l && Zm.registerHandler(l, i);
  }), Ht(r, (l, d) => {
    d && Zm.unregisterHandler(d);
  }, { deep: false }), Pn(() => {
    const { value: l } = r;
    l && Zm.unregisterHandler(l);
  }));
}
function Db(r, i) {
  if (!r) return;
  const l = document.createElement("a");
  l.href = r, i !== void 0 && (l.download = i), document.body.appendChild(l), l.click(), document.body.removeChild(l);
}
function zg(r) {
  switch (typeof r) {
    case "string":
      return r || void 0;
    case "number":
      return String(r);
    default:
      return;
  }
}
const IS = { tiny: "mini", small: "tiny", medium: "small", large: "medium", huge: "large" };
function MS(r) {
  const i = IS[r];
  if (i === void 0) throw new Error(`${r} has no smaller size.`);
  return i;
}
function Ep(r, i = "default", l = []) {
  const f = r.$slots[i];
  return f === void 0 ? l : f();
}
function ES(r) {
  var i;
  const l = (i = r.dirs) === null || i === void 0 ? void 0 : i.find(({ dir: d }) => d === ns);
  return !!(l && l.value === false);
}
function Km(r) {
  const i = r.filter((l) => l !== void 0);
  if (i.length !== 0) return i.length === 1 ? i[0] : (l) => {
    r.forEach((d) => {
      d && d(l);
    });
  };
}
const RS = { name: "en-US", global: { undo: "Undo", redo: "Redo", confirm: "Confirm", clear: "Clear" }, Popconfirm: { positiveText: "Confirm", negativeText: "Cancel" }, Cascader: { placeholder: "Please Select", loading: "Loading", loadingRequiredMessage: (r) => `Please load all ${r}'s descendants before checking it.` }, Time: { dateFormat: "yyyy-MM-dd", dateTimeFormat: "yyyy-MM-dd HH:mm:ss" }, DatePicker: { yearFormat: "yyyy", monthFormat: "MMM", dayFormat: "eeeeee", yearTypeFormat: "yyyy", monthTypeFormat: "yyyy-MM", dateFormat: "yyyy-MM-dd", dateTimeFormat: "yyyy-MM-dd HH:mm:ss", quarterFormat: "yyyy-qqq", weekFormat: "YYYY-w", clear: "Clear", now: "Now", confirm: "Confirm", selectTime: "Select Time", selectDate: "Select Date", datePlaceholder: "Select Date", datetimePlaceholder: "Select Date and Time", monthPlaceholder: "Select Month", yearPlaceholder: "Select Year", quarterPlaceholder: "Select Quarter", weekPlaceholder: "Select Week", startDatePlaceholder: "Start Date", endDatePlaceholder: "End Date", startDatetimePlaceholder: "Start Date and Time", endDatetimePlaceholder: "End Date and Time", startMonthPlaceholder: "Start Month", endMonthPlaceholder: "End Month", monthBeforeYear: true, firstDayOfWeek: 6, today: "Today" }, DataTable: { checkTableAll: "Select all in the table", uncheckTableAll: "Unselect all in the table", confirm: "Confirm", clear: "Clear" }, LegacyTransfer: { sourceTitle: "Source", targetTitle: "Target" }, Transfer: { selectAll: "Select all", unselectAll: "Unselect all", clearAll: "Clear", total: (r) => `Total ${r} items`, selected: (r) => `${r} items selected` }, Empty: { description: "No Data" }, Select: { placeholder: "Please Select" }, TimePicker: { placeholder: "Select Time", positiveText: "OK", negativeText: "Cancel", now: "Now", clear: "Clear" }, Pagination: { goto: "Goto", selectionSuffix: "page" }, DynamicTags: { add: "Add" }, Log: { loading: "Loading" }, Input: { placeholder: "Please Input" }, InputNumber: { placeholder: "Please Input" }, DynamicInput: { create: "Create" }, ThemeEditor: { title: "Theme Editor", clearAllVars: "Clear All Variables", clearSearch: "Clear Search", filterCompName: "Filter Component Name", filterVarName: "Filter Variable Name", import: "Import", export: "Export", restore: "Reset to Default" }, Image: { tipPrevious: "Previous picture (\u2190)", tipNext: "Next picture (\u2192)", tipCounterclockwise: "Counterclockwise", tipClockwise: "Clockwise", tipZoomOut: "Zoom out", tipZoomIn: "Zoom in", tipDownload: "Download", tipClose: "Close (Esc)", tipOriginalSize: "Zoom to original size" }, Heatmap: { less: "less", more: "more", monthFormat: "MMM", weekdayFormat: "eee" } };
function Jm(r) {
  return (i = {}) => {
    const l = i.width ? String(i.width) : r.defaultWidth;
    return r.formats[l] || r.formats[r.defaultWidth];
  };
}
function Dd(r) {
  return (i, l) => {
    const d = (l == null ? void 0 : l.context) ? String(l.context) : "standalone";
    let f;
    if (d === "formatting" && r.formattingValues) {
      const p = r.defaultFormattingWidth || r.defaultWidth, s = (l == null ? void 0 : l.width) ? String(l.width) : p;
      f = r.formattingValues[s] || r.formattingValues[p];
    } else {
      const p = r.defaultWidth, s = (l == null ? void 0 : l.width) ? String(l.width) : r.defaultWidth;
      f = r.values[s] || r.values[p];
    }
    const g = r.argumentCallback ? r.argumentCallback(i) : i;
    return f[g];
  };
}
function zd(r) {
  return (i, l = {}) => {
    const d = l.width, f = d && r.matchPatterns[d] || r.matchPatterns[r.defaultMatchWidth], g = i.match(f);
    if (!g) return null;
    const p = g[0], s = d && r.parsePatterns[d] || r.parsePatterns[r.defaultParseWidth], C = Array.isArray(s) ? DS(s, (D) => D.test(p)) : AS(s, (D) => D.test(p));
    let P;
    P = r.valueCallback ? r.valueCallback(C) : C, P = l.valueCallback ? l.valueCallback(P) : P;
    const M = i.slice(p.length);
    return { value: P, rest: M };
  };
}
function AS(r, i) {
  for (const l in r) if (Object.prototype.hasOwnProperty.call(r, l) && i(r[l])) return l;
}
function DS(r, i) {
  for (let l = 0; l < r.length; l++) if (i(r[l])) return l;
}
function zS(r) {
  return (i, l = {}) => {
    const d = i.match(r.matchPattern);
    if (!d) return null;
    const f = d[0], g = i.match(r.parsePattern);
    if (!g) return null;
    let p = r.valueCallback ? r.valueCallback(g[0]) : g[0];
    p = l.valueCallback ? l.valueCallback(p) : p;
    const s = i.slice(f.length);
    return { value: p, rest: s };
  };
}
const FS = { lessThanXSeconds: { one: "less than a second", other: "less than {{count}} seconds" }, xSeconds: { one: "1 second", other: "{{count}} seconds" }, halfAMinute: "half a minute", lessThanXMinutes: { one: "less than a minute", other: "less than {{count}} minutes" }, xMinutes: { one: "1 minute", other: "{{count}} minutes" }, aboutXHours: { one: "about 1 hour", other: "about {{count}} hours" }, xHours: { one: "1 hour", other: "{{count}} hours" }, xDays: { one: "1 day", other: "{{count}} days" }, aboutXWeeks: { one: "about 1 week", other: "about {{count}} weeks" }, xWeeks: { one: "1 week", other: "{{count}} weeks" }, aboutXMonths: { one: "about 1 month", other: "about {{count}} months" }, xMonths: { one: "1 month", other: "{{count}} months" }, aboutXYears: { one: "about 1 year", other: "about {{count}} years" }, xYears: { one: "1 year", other: "{{count}} years" }, overXYears: { one: "over 1 year", other: "over {{count}} years" }, almostXYears: { one: "almost 1 year", other: "almost {{count}} years" } }, LS = (r, i, l) => {
  let d;
  const f = FS[r];
  return typeof f == "string" ? d = f : i === 1 ? d = f.one : d = f.other.replace("{{count}}", i.toString()), (l == null ? void 0 : l.addSuffix) ? l.comparison && l.comparison > 0 ? "in " + d : d + " ago" : d;
}, BS = { lastWeek: "'last' eeee 'at' p", yesterday: "'yesterday at' p", today: "'today at' p", tomorrow: "'tomorrow at' p", nextWeek: "eeee 'at' p", other: "P" }, OS = (r, i, l, d) => BS[r], $S = { narrow: ["B", "A"], abbreviated: ["BC", "AD"], wide: ["Before Christ", "Anno Domini"] }, jS = { narrow: ["1", "2", "3", "4"], abbreviated: ["Q1", "Q2", "Q3", "Q4"], wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"] }, NS = { narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, VS = { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, US = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" } }, GS = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" } }, qS = (r, i) => {
  const l = Number(r), d = l % 100;
  if (d > 20 || d < 10) switch (d % 10) {
    case 1:
      return l + "st";
    case 2:
      return l + "nd";
    case 3:
      return l + "rd";
  }
  return l + "th";
}, WS = { ordinalNumber: qS, era: Dd({ values: $S, defaultWidth: "wide" }), quarter: Dd({ values: jS, defaultWidth: "wide", argumentCallback: (r) => r - 1 }), month: Dd({ values: NS, defaultWidth: "wide" }), day: Dd({ values: VS, defaultWidth: "wide" }), dayPeriod: Dd({ values: US, defaultWidth: "wide", formattingValues: GS, defaultFormattingWidth: "wide" }) }, ZS = /^(\d+)(th|st|nd|rd)?/i, HS = /\d+/i, XS = { narrow: /^(b|a)/i, abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i, wide: /^(before christ|before common era|anno domini|common era)/i }, YS = { any: [/^b/i, /^(a|c)/i] }, KS = { narrow: /^[1234]/i, abbreviated: /^q[1234]/i, wide: /^[1234](th|st|nd|rd)? quarter/i }, JS = { any: [/1/i, /2/i, /3/i, /4/i] }, QS = { narrow: /^[jfmasond]/i, abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i, wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i }, ek = { narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i], any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i] }, tk = { narrow: /^[smtwf]/i, short: /^(su|mo|tu|we|th|fr|sa)/i, abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i, wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i }, rk = { narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i], any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i] }, ik = { narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i, any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i }, nk = { any: { am: /^a/i, pm: /^p/i, midnight: /^mi/i, noon: /^no/i, morning: /morning/i, afternoon: /afternoon/i, evening: /evening/i, night: /night/i } }, ok = { ordinalNumber: zS({ matchPattern: ZS, parsePattern: HS, valueCallback: (r) => parseInt(r, 10) }), era: zd({ matchPatterns: XS, defaultMatchWidth: "wide", parsePatterns: YS, defaultParseWidth: "any" }), quarter: zd({ matchPatterns: KS, defaultMatchWidth: "wide", parsePatterns: JS, defaultParseWidth: "any", valueCallback: (r) => r + 1 }), month: zd({ matchPatterns: QS, defaultMatchWidth: "wide", parsePatterns: ek, defaultParseWidth: "any" }), day: zd({ matchPatterns: tk, defaultMatchWidth: "wide", parsePatterns: rk, defaultParseWidth: "any" }), dayPeriod: zd({ matchPatterns: ik, defaultMatchWidth: "any", parsePatterns: nk, defaultParseWidth: "any" }) }, ak = { full: "EEEE, MMMM do, y", long: "MMMM do, y", medium: "MMM d, y", short: "MM/dd/yyyy" }, sk = { full: "h:mm:ss a zzzz", long: "h:mm:ss a z", medium: "h:mm:ss a", short: "h:mm a" }, lk = { full: "{{date}} 'at' {{time}}", long: "{{date}} 'at' {{time}}", medium: "{{date}}, {{time}}", short: "{{date}}, {{time}}" }, uk = { date: Jm({ formats: ak, defaultWidth: "full" }), time: Jm({ formats: sk, defaultWidth: "full" }), dateTime: Jm({ formats: lk, defaultWidth: "full" }) }, ck = { code: "en-US", formatDistance: LS, formatLong: uk, formatRelative: OS, localize: WS, match: ok, options: { weekStartsOn: 0, firstWeekContainsDate: 1 } }, dk = { name: "en-US", locale: ck };
function as(r) {
  const { mergedLocaleRef: i, mergedDateLocaleRef: l } = ur(Uy, null) || {}, d = Ee(() => {
    var g, p;
    return (p = (g = i == null ? void 0 : i.value) === null || g === void 0 ? void 0 : g[r]) !== null && p !== void 0 ? p : RS[r];
  });
  return { dateLocaleRef: Ee(() => {
    var g;
    return (g = l == null ? void 0 : l.value) !== null && g !== void 0 ? g : dk;
  }), localeRef: d };
}
const hk = ue("affix", [Ge("affixed", { position: "fixed" }, [Ge("absolute-positioned", { position: "absolute" })])]);
function fk(r) {
  return r instanceof HTMLElement ? r.scrollTop : window.scrollY;
}
function pk(r) {
  return r instanceof HTMLElement ? r.getBoundingClientRect() : { top: 0, bottom: window.innerHeight };
}
const d0 = { listenTo: [String, Object, Function], top: Number, bottom: Number, triggerTop: Number, triggerBottom: Number, position: { type: String, default: "fixed" }, offsetTop: { type: Number, validator: () => true, default: void 0 }, offsetBottom: { type: Number, validator: () => true, default: void 0 }, target: { type: Function, validator: () => true, default: void 0 } }, mk = Xd(d0), gk = ot({ name: "Affix", props: d0, setup(r) {
  const { mergedClsPrefixRef: i } = Sr(r);
  yc("-affix", hk, i);
  let l = null;
  const d = Ie(false), f = Ie(false), g = Ie(null), p = Ie(null), s = Ee(() => f.value || d.value), C = Ee(() => {
    var Z, q;
    return (q = (Z = r.triggerTop) !== null && Z !== void 0 ? Z : r.offsetTop) !== null && q !== void 0 ? q : r.top;
  }), P = Ee(() => {
    var Z, q;
    return (q = (Z = r.top) !== null && Z !== void 0 ? Z : r.triggerTop) !== null && q !== void 0 ? q : r.offsetTop;
  }), M = Ee(() => {
    var Z, q;
    return (q = (Z = r.bottom) !== null && Z !== void 0 ? Z : r.triggerBottom) !== null && q !== void 0 ? q : r.offsetBottom;
  }), D = Ee(() => {
    var Z, q;
    return (q = (Z = r.triggerBottom) !== null && Z !== void 0 ? Z : r.offsetBottom) !== null && q !== void 0 ? q : r.bottom;
  }), L = Ie(null), $ = () => {
    const { target: Z, listenTo: q } = r;
    Z ? l = Z() : q ? l = Mb(q) : l = document, l && (l.addEventListener("scroll", z), z());
  };
  function z() {
    bp(F);
  }
  function F() {
    const { value: Z } = L;
    if (!l || !Z) return;
    const q = fk(l);
    if (s.value) {
      p.value !== null && q < p.value && (d.value = false, p.value = null), g.value !== null && q > g.value && (f.value = false, g.value = null);
      return;
    }
    const K = pk(l), te = Z.getBoundingClientRect(), re = te.top - K.top, ie = K.bottom - te.bottom, J = C.value, we = D.value;
    J !== void 0 && re <= J ? (d.value = true, p.value = q - (J - re)) : (d.value = false, p.value = null), we !== void 0 && ie <= we ? (f.value = true, g.value = q + we - ie) : (f.value = false, g.value = null);
  }
  return Ri(() => {
    $();
  }), Pn(() => {
    l && l.removeEventListener("scroll", z);
  }), { selfRef: L, affixed: s, mergedClsPrefix: i, mergedstyle: Ee(() => {
    const Z = {};
    return d.value && C.value !== void 0 && P.value !== void 0 && (Z.top = `${P.value}px`), f.value && D.value !== void 0 && M.value !== void 0 && (Z.bottom = `${M.value}px`), Z;
  }) };
}, render() {
  const { mergedClsPrefix: r } = this;
  return B("div", { ref: "selfRef", class: [`${r}-affix`, { [`${r}-affix--affixed`]: this.affixed, [`${r}-affix--absolute-positioned`]: this.position === "absolute" }], style: this.mergedstyle }, this.$slots);
} }), Rp = ot({ name: "Add", render() {
  return B("svg", { width: "512", height: "512", viewBox: "0 0 512 512", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M256 112V400M400 256H112", stroke: "currentColor", "stroke-width": "32", "stroke-linecap": "round", "stroke-linejoin": "round" }));
} }), vk = Sa("attach", () => B("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, B("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, B("g", { fill: "currentColor", "fill-rule": "nonzero" }, B("path", { d: "M3.25735931,8.70710678 L7.85355339,4.1109127 C8.82986412,3.13460197 10.4127766,3.13460197 11.3890873,4.1109127 C12.365398,5.08722343 12.365398,6.67013588 11.3890873,7.64644661 L6.08578644,12.9497475 C5.69526215,13.3402718 5.06209717,13.3402718 4.67157288,12.9497475 C4.28104858,12.5592232 4.28104858,11.9260582 4.67157288,11.5355339 L9.97487373,6.23223305 C10.1701359,6.0369709 10.1701359,5.72038841 9.97487373,5.52512627 C9.77961159,5.32986412 9.4630291,5.32986412 9.26776695,5.52512627 L3.96446609,10.8284271 C3.18341751,11.6094757 3.18341751,12.8758057 3.96446609,13.6568542 C4.74551468,14.4379028 6.01184464,14.4379028 6.79289322,13.6568542 L12.0961941,8.35355339 C13.4630291,6.98671837 13.4630291,4.77064094 12.0961941,3.40380592 C10.7293591,2.0369709 8.51328163,2.0369709 7.14644661,3.40380592 L2.55025253,8 C2.35499039,8.19526215 2.35499039,8.51184464 2.55025253,8.70710678 C2.74551468,8.90236893 3.06209717,8.90236893 3.25735931,8.70710678 Z" }))))), _k = Sa("cancel", () => B("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, B("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, B("g", { fill: "currentColor", "fill-rule": "nonzero" }, B("path", { d: "M2.58859116,2.7156945 L2.64644661,2.64644661 C2.82001296,2.47288026 3.08943736,2.45359511 3.2843055,2.58859116 L3.35355339,2.64644661 L8,7.293 L12.6464466,2.64644661 C12.8417088,2.45118446 13.1582912,2.45118446 13.3535534,2.64644661 C13.5488155,2.84170876 13.5488155,3.15829124 13.3535534,3.35355339 L8.707,8 L13.3535534,12.6464466 C13.5271197,12.820013 13.5464049,13.0894374 13.4114088,13.2843055 L13.3535534,13.3535534 C13.179987,13.5271197 12.9105626,13.5464049 12.7156945,13.4114088 L12.6464466,13.3535534 L8,8.707 L3.35355339,13.3535534 C3.15829124,13.5488155 2.84170876,13.5488155 2.64644661,13.3535534 C2.45118446,13.1582912 2.45118446,12.8417088 2.64644661,12.6464466 L7.293,8 L2.64644661,3.35355339 C2.47288026,3.17998704 2.45359511,2.91056264 2.58859116,2.7156945 L2.64644661,2.64644661 L2.58859116,2.7156945 Z" }))))), yk = ot({ name: "Checkmark", render() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16" }, B("g", { fill: "none" }, B("path", { d: "M14.046 3.486a.75.75 0 0 1-.032 1.06l-7.93 7.474a.85.85 0 0 1-1.188-.022l-2.68-2.72a.75.75 0 1 1 1.068-1.053l2.234 2.267l7.468-7.038a.75.75 0 0 1 1.06.032z", fill: "currentColor" })));
} }), bk = ot({ name: "ChevronDown", render() {
  return B("svg", { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M3.14645 5.64645C3.34171 5.45118 3.65829 5.45118 3.85355 5.64645L8 9.79289L12.1464 5.64645C12.3417 5.45118 12.6583 5.45118 12.8536 5.64645C13.0488 5.84171 13.0488 6.15829 12.8536 6.35355L8.35355 10.8536C8.15829 11.0488 7.84171 11.0488 7.64645 10.8536L3.14645 6.35355C2.95118 6.15829 2.95118 5.84171 3.14645 5.64645Z", fill: "currentColor" }));
} }), xk = ot({ name: "ChevronLeft", render() {
  return B("svg", { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M10.3536 3.14645C10.5488 3.34171 10.5488 3.65829 10.3536 3.85355L6.20711 8L10.3536 12.1464C10.5488 12.3417 10.5488 12.6583 10.3536 12.8536C10.1583 13.0488 9.84171 13.0488 9.64645 12.8536L5.14645 8.35355C4.95118 8.15829 4.95118 7.84171 5.14645 7.64645L9.64645 3.14645C9.84171 2.95118 10.1583 2.95118 10.3536 3.14645Z", fill: "currentColor" }));
} }), wk = Sa("clear", () => B("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, B("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, B("g", { fill: "currentColor", "fill-rule": "nonzero" }, B("path", { d: "M8,2 C11.3137085,2 14,4.6862915 14,8 C14,11.3137085 11.3137085,14 8,14 C4.6862915,14 2,11.3137085 2,8 C2,4.6862915 4.6862915,2 8,2 Z M6.5343055,5.83859116 C6.33943736,5.70359511 6.07001296,5.72288026 5.89644661,5.89644661 L5.89644661,5.89644661 L5.83859116,5.9656945 C5.70359511,6.16056264 5.72288026,6.42998704 5.89644661,6.60355339 L5.89644661,6.60355339 L7.293,8 L5.89644661,9.39644661 L5.83859116,9.4656945 C5.70359511,9.66056264 5.72288026,9.92998704 5.89644661,10.1035534 L5.89644661,10.1035534 L5.9656945,10.1614088 C6.16056264,10.2964049 6.42998704,10.2771197 6.60355339,10.1035534 L6.60355339,10.1035534 L8,8.707 L9.39644661,10.1035534 L9.4656945,10.1614088 C9.66056264,10.2964049 9.92998704,10.2771197 10.1035534,10.1035534 L10.1035534,10.1035534 L10.1614088,10.0343055 C10.2964049,9.83943736 10.2771197,9.57001296 10.1035534,9.39644661 L10.1035534,9.39644661 L8.707,8 L10.1035534,6.60355339 L10.1614088,6.5343055 C10.2964049,6.33943736 10.2771197,6.07001296 10.1035534,5.89644661 L10.1035534,5.89644661 L10.0343055,5.83859116 C9.83943736,5.70359511 9.57001296,5.72288026 9.39644661,5.89644661 L9.39644661,5.89644661 L8,7.293 L6.60355339,5.89644661 Z" }))))), zb = Sa("download", () => B("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, B("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, B("g", { fill: "currentColor", "fill-rule": "nonzero" }, B("path", { d: "M3.5,13 L12.5,13 C12.7761424,13 13,13.2238576 13,13.5 C13,13.7454599 12.8231248,13.9496084 12.5898756,13.9919443 L12.5,14 L3.5,14 C3.22385763,14 3,13.7761424 3,13.5 C3,13.2545401 3.17687516,13.0503916 3.41012437,13.0080557 L3.5,13 L12.5,13 L3.5,13 Z M7.91012437,1.00805567 L8,1 C8.24545989,1 8.44960837,1.17687516 8.49194433,1.41012437 L8.5,1.5 L8.5,10.292 L11.1819805,7.6109127 C11.3555469,7.43734635 11.6249713,7.4180612 11.8198394,7.55305725 L11.8890873,7.6109127 C12.0626536,7.78447906 12.0819388,8.05390346 11.9469427,8.2487716 L11.8890873,8.31801948 L8.35355339,11.8535534 C8.17998704,12.0271197 7.91056264,12.0464049 7.7156945,11.9114088 L7.64644661,11.8535534 L4.1109127,8.31801948 C3.91565056,8.12275734 3.91565056,7.80617485 4.1109127,7.6109127 C4.28447906,7.43734635 4.55390346,7.4180612 4.7487716,7.55305725 L4.81801948,7.6109127 L7.5,10.292 L7.5,1.5 C7.5,1.25454011 7.67687516,1.05039163 7.91012437,1.00805567 L8,1 L7.91012437,1.00805567 Z" }))))), Ck = ot({ name: "Empty", render() {
  return B("svg", { viewBox: "0 0 28 28", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M26 7.5C26 11.0899 23.0899 14 19.5 14C15.9101 14 13 11.0899 13 7.5C13 3.91015 15.9101 1 19.5 1C23.0899 1 26 3.91015 26 7.5ZM16.8536 4.14645C16.6583 3.95118 16.3417 3.95118 16.1464 4.14645C15.9512 4.34171 15.9512 4.65829 16.1464 4.85355L18.7929 7.5L16.1464 10.1464C15.9512 10.3417 15.9512 10.6583 16.1464 10.8536C16.3417 11.0488 16.6583 11.0488 16.8536 10.8536L19.5 8.20711L22.1464 10.8536C22.3417 11.0488 22.6583 11.0488 22.8536 10.8536C23.0488 10.6583 23.0488 10.3417 22.8536 10.1464L20.2071 7.5L22.8536 4.85355C23.0488 4.65829 23.0488 4.34171 22.8536 4.14645C22.6583 3.95118 22.3417 3.95118 22.1464 4.14645L19.5 6.79289L16.8536 4.14645Z", fill: "currentColor" }), B("path", { d: "M25 22.75V12.5991C24.5572 13.0765 24.053 13.4961 23.5 13.8454V16H17.5L17.3982 16.0068C17.0322 16.0565 16.75 16.3703 16.75 16.75C16.75 18.2688 15.5188 19.5 14 19.5C12.4812 19.5 11.25 18.2688 11.25 16.75L11.2432 16.6482C11.1935 16.2822 10.8797 16 10.5 16H4.5V7.25C4.5 6.2835 5.2835 5.5 6.25 5.5H12.2696C12.4146 4.97463 12.6153 4.47237 12.865 4H6.25C4.45507 4 3 5.45507 3 7.25V22.75C3 24.5449 4.45507 26 6.25 26H21.75C23.5449 26 25 24.5449 25 22.75ZM4.5 22.75V17.5H9.81597L9.85751 17.7041C10.2905 19.5919 11.9808 21 14 21L14.215 20.9947C16.2095 20.8953 17.842 19.4209 18.184 17.5H23.5V22.75C23.5 23.7165 22.7165 24.5 21.75 24.5H6.25C5.2835 24.5 4.5 23.7165 4.5 22.75Z", fill: "currentColor" }));
} }), Fb = ot({ name: "Eye", render() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, B("path", { d: "M255.66 112c-77.94 0-157.89 45.11-220.83 135.33a16 16 0 0 0-.27 17.77C82.92 340.8 161.8 400 255.66 400c92.84 0 173.34-59.38 221.79-135.25a16.14 16.14 0 0 0 0-17.47C428.89 172.28 347.8 112 255.66 112z", fill: "none", stroke: "currentColor", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "32" }), B("circle", { cx: "256", cy: "256", r: "80", fill: "none", stroke: "currentColor", "stroke-miterlimit": "10", "stroke-width": "32" }));
} }), Sk = ot({ name: "EyeOff", render() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, B("path", { d: "M432 448a15.92 15.92 0 0 1-11.31-4.69l-352-352a16 16 0 0 1 22.62-22.62l352 352A16 16 0 0 1 432 448z", fill: "currentColor" }), B("path", { d: "M255.66 384c-41.49 0-81.5-12.28-118.92-36.5c-34.07-22-64.74-53.51-88.7-91v-.08c19.94-28.57 41.78-52.73 65.24-72.21a2 2 0 0 0 .14-2.94L93.5 161.38a2 2 0 0 0-2.71-.12c-24.92 21-48.05 46.76-69.08 76.92a31.92 31.92 0 0 0-.64 35.54c26.41 41.33 60.4 76.14 98.28 100.65C162 402 207.9 416 255.66 416a239.13 239.13 0 0 0 75.8-12.58a2 2 0 0 0 .77-3.31l-21.58-21.58a4 4 0 0 0-3.83-1a204.8 204.8 0 0 1-51.16 6.47z", fill: "currentColor" }), B("path", { d: "M490.84 238.6c-26.46-40.92-60.79-75.68-99.27-100.53C349 110.55 302 96 255.66 96a227.34 227.34 0 0 0-74.89 12.83a2 2 0 0 0-.75 3.31l21.55 21.55a4 4 0 0 0 3.88 1a192.82 192.82 0 0 1 50.21-6.69c40.69 0 80.58 12.43 118.55 37c34.71 22.4 65.74 53.88 89.76 91a.13.13 0 0 1 0 .16a310.72 310.72 0 0 1-64.12 72.73a2 2 0 0 0-.15 2.95l19.9 19.89a2 2 0 0 0 2.7.13a343.49 343.49 0 0 0 68.64-78.48a32.2 32.2 0 0 0-.1-34.78z", fill: "currentColor" }), B("path", { d: "M256 160a95.88 95.88 0 0 0-21.37 2.4a2 2 0 0 0-1 3.38l112.59 112.56a2 2 0 0 0 3.38-1A96 96 0 0 0 256 160z", fill: "currentColor" }), B("path", { d: "M165.78 233.66a2 2 0 0 0-3.38 1a96 96 0 0 0 115 115a2 2 0 0 0 1-3.38z", fill: "currentColor" }));
} }), kk = ot({ name: "Remove", render() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, B("line", { x1: "400", y1: "256", x2: "112", y2: "256", style: `
        fill: none;
        stroke: currentColor;
        stroke-linecap: round;
        stroke-linejoin: round;
        stroke-width: 32px;
      ` }));
} }), Pk = ot({ name: "ResizeSmall", render() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20" }, B("g", { fill: "none" }, B("path", { d: "M5.5 4A1.5 1.5 0 0 0 4 5.5v1a.5.5 0 0 1-1 0v-1A2.5 2.5 0 0 1 5.5 3h1a.5.5 0 0 1 0 1h-1zM16 5.5A1.5 1.5 0 0 0 14.5 4h-1a.5.5 0 0 1 0-1h1A2.5 2.5 0 0 1 17 5.5v1a.5.5 0 0 1-1 0v-1zm0 9a1.5 1.5 0 0 1-1.5 1.5h-1a.5.5 0 0 0 0 1h1a2.5 2.5 0 0 0 2.5-2.5v-1a.5.5 0 0 0-1 0v1zm-12 0A1.5 1.5 0 0 0 5.5 16h1.25a.5.5 0 0 1 0 1H5.5A2.5 2.5 0 0 1 3 14.5v-1.25a.5.5 0 0 1 1 0v1.25zM8.5 7A1.5 1.5 0 0 0 7 8.5v3A1.5 1.5 0 0 0 8.5 13h3a1.5 1.5 0 0 0 1.5-1.5v-3A1.5 1.5 0 0 0 11.5 7h-3zM8 8.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3z", fill: "currentColor" })));
} }), Tk = Sa("retry", () => B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, B("path", { d: "M320,146s24.36-12-64-12A160,160,0,1,0,416,294", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-miterlimit: 10; stroke-width: 32px;" }), B("polyline", { points: "256 58 336 138 256 218", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }))), Ik = Sa("rotateClockwise", () => B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M3 10C3 6.13401 6.13401 3 10 3C13.866 3 17 6.13401 17 10C17 12.7916 15.3658 15.2026 13 16.3265V14.5C13 14.2239 12.7761 14 12.5 14C12.2239 14 12 14.2239 12 14.5V17.5C12 17.7761 12.2239 18 12.5 18H15.5C15.7761 18 16 17.7761 16 17.5C16 17.2239 15.7761 17 15.5 17H13.8758C16.3346 15.6357 18 13.0128 18 10C18 5.58172 14.4183 2 10 2C5.58172 2 2 5.58172 2 10C2 10.2761 2.22386 10.5 2.5 10.5C2.77614 10.5 3 10.2761 3 10Z", fill: "currentColor" }), B("path", { d: "M10 12C11.1046 12 12 11.1046 12 10C12 8.89543 11.1046 8 10 8C8.89543 8 8 8.89543 8 10C8 11.1046 8.89543 12 10 12ZM10 11C9.44772 11 9 10.5523 9 10C9 9.44772 9.44772 9 10 9C10.5523 9 11 9.44772 11 10C11 10.5523 10.5523 11 10 11Z", fill: "currentColor" }))), Mk = Sa("rotateClockwise", () => B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M17 10C17 6.13401 13.866 3 10 3C6.13401 3 3 6.13401 3 10C3 12.7916 4.63419 15.2026 7 16.3265V14.5C7 14.2239 7.22386 14 7.5 14C7.77614 14 8 14.2239 8 14.5V17.5C8 17.7761 7.77614 18 7.5 18H4.5C4.22386 18 4 17.7761 4 17.5C4 17.2239 4.22386 17 4.5 17H6.12422C3.66539 15.6357 2 13.0128 2 10C2 5.58172 5.58172 2 10 2C14.4183 2 18 5.58172 18 10C18 10.2761 17.7761 10.5 17.5 10.5C17.2239 10.5 17 10.2761 17 10Z", fill: "currentColor" }), B("path", { d: "M10 12C8.89543 12 8 11.1046 8 10C8 8.89543 8.89543 8 10 8C11.1046 8 12 8.89543 12 10C12 11.1046 11.1046 12 10 12ZM10 11C10.5523 11 11 10.5523 11 10C11 9.44772 10.5523 9 10 9C9.44772 9 9 9.44772 9 10C9 10.5523 9.44772 11 10 11Z", fill: "currentColor" }))), Ek = Sa("trash", () => B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, B("path", { d: "M432,144,403.33,419.74A32,32,0,0,1,371.55,448H140.46a32,32,0,0,1-31.78-28.26L80,144", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), B("rect", { x: "32", y: "64", width: "448", height: "80", rx: "16", ry: "16", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), B("line", { x1: "312", y1: "240", x2: "200", y2: "352", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), B("line", { x1: "312", y1: "352", x2: "200", y2: "240", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }))), Rk = Sa("zoomIn", () => B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M11.5 8.5C11.5 8.22386 11.2761 8 11 8H9V6C9 5.72386 8.77614 5.5 8.5 5.5C8.22386 5.5 8 5.72386 8 6V8H6C5.72386 8 5.5 8.22386 5.5 8.5C5.5 8.77614 5.72386 9 6 9H8V11C8 11.2761 8.22386 11.5 8.5 11.5C8.77614 11.5 9 11.2761 9 11V9H11C11.2761 9 11.5 8.77614 11.5 8.5Z", fill: "currentColor" }), B("path", { d: "M8.5 3C11.5376 3 14 5.46243 14 8.5C14 9.83879 13.5217 11.0659 12.7266 12.0196L16.8536 16.1464C17.0488 16.3417 17.0488 16.6583 16.8536 16.8536C16.68 17.0271 16.4106 17.0464 16.2157 16.9114L16.1464 16.8536L12.0196 12.7266C11.0659 13.5217 9.83879 14 8.5 14C5.46243 14 3 11.5376 3 8.5C3 5.46243 5.46243 3 8.5 3ZM8.5 4C6.01472 4 4 6.01472 4 8.5C4 10.9853 6.01472 13 8.5 13C10.9853 13 13 10.9853 13 8.5C13 6.01472 10.9853 4 8.5 4Z", fill: "currentColor" }))), Ak = Sa("zoomOut", () => B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M11 8C11.2761 8 11.5 8.22386 11.5 8.5C11.5 8.77614 11.2761 9 11 9H6C5.72386 9 5.5 8.77614 5.5 8.5C5.5 8.22386 5.72386 8 6 8H11Z", fill: "currentColor" }), B("path", { d: "M14 8.5C14 5.46243 11.5376 3 8.5 3C5.46243 3 3 5.46243 3 8.5C3 11.5376 5.46243 14 8.5 14C9.83879 14 11.0659 13.5217 12.0196 12.7266L16.1464 16.8536L16.2157 16.9114C16.4106 17.0464 16.68 17.0271 16.8536 16.8536C17.0488 16.6583 17.0488 16.3417 16.8536 16.1464L12.7266 12.0196C13.5217 11.0659 14 9.83879 14 8.5ZM4 8.5C4 6.01472 6.01472 4 8.5 4C10.9853 4 13 6.01472 13 8.5C13 10.9853 10.9853 13 8.5 13C6.01472 13 4 10.9853 4 8.5Z", fill: "currentColor" }))), Dk = ue("base-clear", `
 flex-shrink: 0;
 height: 1em;
 width: 1em;
 position: relative;
`, [Ze(">", [Ae("clear", `
 font-size: var(--n-clear-size);
 height: 1em;
 width: 1em;
 cursor: pointer;
 color: var(--n-clear-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 `, [Ze("&:hover", `
 color: var(--n-clear-color-hover)!important;
 `), Ze("&:active", `
 color: var(--n-clear-color-pressed)!important;
 `)]), Ae("placeholder", `
 display: flex;
 `), Ae("clear, placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [Yd({ originalTransform: "translateX(-50%) translateY(-50%)", left: "50%", top: "50%" })])])]), Fg = ot({ name: "BaseClear", props: { clsPrefix: { type: String, required: true }, show: Boolean, onClear: Function }, setup(r) {
  return yc("-base-clear", Dk, zt(r, "clsPrefix")), { handleMouseDown(i) {
    i.preventDefault();
  } };
}, render() {
  const { clsPrefix: r } = this;
  return B("div", { class: `${r}-base-clear` }, B(xp, null, { default: () => {
    var i, l;
    return this.show ? B("div", { key: "dismiss", class: `${r}-base-clear__clear`, onClick: this.onClear, onMousedown: this.handleMouseDown, "data-clear": true }, Zn(this.$slots.icon, () => [B(qr, { clsPrefix: r }, { default: () => B(wk, null) })])) : B("div", { key: "icon", class: `${r}-base-clear__placeholder` }, (l = (i = this.$slots).placeholder) === null || l === void 0 ? void 0 : l.call(i));
  } }));
} }), zk = ot({ props: { onFocus: Function, onBlur: Function }, setup(r) {
  return () => B("div", { style: "width: 0; height: 0", tabindex: 0, onFocus: r.onFocus, onBlur: r.onBlur });
} }), Fk = ue("empty", `
 display: flex;
 flex-direction: column;
 align-items: center;
 font-size: var(--n-font-size);
`, [Ae("icon", `
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 line-height: var(--n-icon-size);
 color: var(--n-icon-color);
 transition:
 color .3s var(--n-bezier);
 `, [Ze("+", [Ae("description", `
 margin-top: 8px;
 `)])]), Ae("description", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), Ae("extra", `
 text-align: center;
 transition: color .3s var(--n-bezier);
 margin-top: 12px;
 color: var(--n-extra-text-color);
 `)]), Lk = Object.assign(Object.assign({}, Jt.props), { description: String, showDescription: { type: Boolean, default: true }, showIcon: { type: Boolean, default: true }, size: { type: String, default: "medium" }, renderIcon: Function }), Qd = ot({ name: "Empty", props: Lk, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l, mergedComponentPropsRef: d } = Sr(r), f = Jt("Empty", "-empty", Fk, Ew, r, i), { localeRef: g } = as("Empty"), p = Ee(() => {
    var M, D, L;
    return (M = r.description) !== null && M !== void 0 ? M : (L = (D = d == null ? void 0 : d.value) === null || D === void 0 ? void 0 : D.Empty) === null || L === void 0 ? void 0 : L.description;
  }), s = Ee(() => {
    var M, D;
    return ((D = (M = d == null ? void 0 : d.value) === null || M === void 0 ? void 0 : M.Empty) === null || D === void 0 ? void 0 : D.renderIcon) || (() => B(Ck, null));
  }), C = Ee(() => {
    const { size: M } = r, { common: { cubicBezierEaseInOut: D }, self: { [Vt("iconSize", M)]: L, [Vt("fontSize", M)]: $, textColor: z, iconColor: F, extraTextColor: Z } } = f.value;
    return { "--n-icon-size": L, "--n-font-size": $, "--n-bezier": D, "--n-text-color": z, "--n-icon-color": F, "--n-extra-text-color": Z };
  }), P = l ? ai("empty", Ee(() => {
    let M = "";
    const { size: D } = r;
    return M += D[0], M;
  }), C, r) : void 0;
  return { mergedClsPrefix: i, mergedRenderIcon: s, localizedDescription: Ee(() => p.value || g.value.description), cssVars: l ? void 0 : C, themeClass: P == null ? void 0 : P.themeClass, onRender: P == null ? void 0 : P.onRender };
}, render() {
  const { $slots: r, mergedClsPrefix: i, onRender: l } = this;
  return l == null ? void 0 : l(), B("div", { class: [`${i}-empty`, this.themeClass], style: this.cssVars }, this.showIcon ? B("div", { class: `${i}-empty__icon` }, r.icon ? r.icon() : B(qr, { clsPrefix: i }, { default: this.mergedRenderIcon })) : null, this.showDescription ? B("div", { class: `${i}-empty__description` }, r.default ? r.default() : this.localizedDescription) : null, r.extra ? B("div", { class: `${i}-empty__extra` }, r.extra()) : null);
} }), C_ = ot({ name: "NBaseSelectGroupHeader", props: { clsPrefix: { type: String, required: true }, tmNode: { type: Object, required: true } }, setup() {
  const { renderLabelRef: r, renderOptionRef: i, labelFieldRef: l, nodePropsRef: d } = ur(i0);
  return { labelField: l, nodeProps: d, renderLabel: r, renderOption: i };
}, render() {
  const { clsPrefix: r, renderLabel: i, renderOption: l, nodeProps: d, tmNode: { rawNode: f } } = this, g = d == null ? void 0 : d(f), p = i ? i(f, false) : Rl(f[this.labelField], f, false), s = B("div", Object.assign({}, g, { class: [`${r}-base-select-group-header`, g == null ? void 0 : g.class] }), p);
  return f.render ? f.render({ node: s, option: f }) : l ? l({ node: s, option: f, selected: false }) : s;
} });
function Bk(r, i) {
  return B(Eo, { name: "fade-in-scale-up-transition" }, { default: () => r ? B(qr, { clsPrefix: i, class: `${i}-base-select-option__check` }, { default: () => B(yk) }) : null });
}
const S_ = ot({ name: "NBaseSelectOption", props: { clsPrefix: { type: String, required: true }, tmNode: { type: Object, required: true } }, setup(r) {
  const { valueRef: i, pendingTmNodeRef: l, multipleRef: d, valueSetRef: f, renderLabelRef: g, renderOptionRef: p, labelFieldRef: s, valueFieldRef: C, showCheckmarkRef: P, nodePropsRef: M, handleOptionClick: D, handleOptionMouseEnter: L } = ur(i0), $ = vi(() => {
    const { value: q } = l;
    return q ? r.tmNode.key === q.key : false;
  });
  function z(q) {
    const { tmNode: K } = r;
    K.disabled || D(q, K);
  }
  function F(q) {
    const { tmNode: K } = r;
    K.disabled || L(q, K);
  }
  function Z(q) {
    const { tmNode: K } = r, { value: te } = $;
    K.disabled || te || L(q, K);
  }
  return { multiple: d, isGrouped: vi(() => {
    const { tmNode: q } = r, { parent: K } = q;
    return K && K.rawNode.type === "group";
  }), showCheckmark: P, nodeProps: M, isPending: $, isSelected: vi(() => {
    const { value: q } = i, { value: K } = d;
    if (q === null) return false;
    const te = r.tmNode.rawNode[C.value];
    if (K) {
      const { value: re } = f;
      return re.has(te);
    } else return q === te;
  }), labelField: s, renderLabel: g, renderOption: p, handleMouseMove: Z, handleMouseEnter: F, handleClick: z };
}, render() {
  const { clsPrefix: r, tmNode: { rawNode: i }, isSelected: l, isPending: d, isGrouped: f, showCheckmark: g, nodeProps: p, renderOption: s, renderLabel: C, handleClick: P, handleMouseEnter: M, handleMouseMove: D } = this, L = Bk(l, r), $ = C ? [C(i, l), g && L] : [Rl(i[this.labelField], i, l), g && L], z = p == null ? void 0 : p(i), F = B("div", Object.assign({}, z, { class: [`${r}-base-select-option`, i.class, z == null ? void 0 : z.class, { [`${r}-base-select-option--disabled`]: i.disabled, [`${r}-base-select-option--selected`]: l, [`${r}-base-select-option--grouped`]: f, [`${r}-base-select-option--pending`]: d, [`${r}-base-select-option--show-checkmark`]: g }], style: [(z == null ? void 0 : z.style) || "", i.style || ""], onClick: Km([P, z == null ? void 0 : z.onClick]), onMouseenter: Km([M, z == null ? void 0 : z.onMouseenter]), onMousemove: Km([D, z == null ? void 0 : z.onMousemove]) }), B("div", { class: `${r}-base-select-option__content` }, $));
  return i.render ? i.render({ node: F, option: i, selected: l }) : s ? s({ node: F, option: i, selected: l }) : F;
} }), Ok = ue("base-select-menu", `
 line-height: 1.5;
 outline: none;
 z-index: 0;
 position: relative;
 border-radius: var(--n-border-radius);
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-color);
`, [ue("scrollbar", `
 max-height: var(--n-height);
 `), ue("virtual-list", `
 max-height: var(--n-height);
 `), ue("base-select-option", `
 min-height: var(--n-option-height);
 font-size: var(--n-option-font-size);
 display: flex;
 align-items: center;
 `, [Ae("content", `
 z-index: 1;
 white-space: nowrap;
 text-overflow: ellipsis;
 overflow: hidden;
 `)]), ue("base-select-group-header", `
 min-height: var(--n-option-height);
 font-size: .93em;
 display: flex;
 align-items: center;
 `), ue("base-select-menu-option-wrapper", `
 position: relative;
 width: 100%;
 `), Ae("loading, empty", `
 display: flex;
 padding: 12px 32px;
 flex: 1;
 justify-content: center;
 `), Ae("loading", `
 color: var(--n-loading-color);
 font-size: var(--n-loading-size);
 `), Ae("header", `
 padding: 8px var(--n-option-padding-left);
 font-size: var(--n-option-font-size);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), Ae("action", `
 padding: 8px var(--n-option-padding-left);
 font-size: var(--n-option-font-size);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 border-top: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), ue("base-select-group-header", `
 position: relative;
 cursor: default;
 padding: var(--n-option-padding);
 color: var(--n-group-header-text-color);
 `), ue("base-select-option", `
 cursor: pointer;
 position: relative;
 padding: var(--n-option-padding);
 transition:
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 box-sizing: border-box;
 color: var(--n-option-text-color);
 opacity: 1;
 `, [Ge("show-checkmark", `
 padding-right: calc(var(--n-option-padding-right) + 20px);
 `), Ze("&::before", `
 content: "";
 position: absolute;
 left: 4px;
 right: 4px;
 top: 0;
 bottom: 0;
 border-radius: var(--n-border-radius);
 transition: background-color .3s var(--n-bezier);
 `), Ze("&:active", `
 color: var(--n-option-text-color-pressed);
 `), Ge("grouped", `
 padding-left: calc(var(--n-option-padding-left) * 1.5);
 `), Ge("pending", [Ze("&::before", `
 background-color: var(--n-option-color-pending);
 `)]), Ge("selected", `
 color: var(--n-option-text-color-active);
 `, [Ze("&::before", `
 background-color: var(--n-option-color-active);
 `), Ge("pending", [Ze("&::before", `
 background-color: var(--n-option-color-active-pending);
 `)])]), Ge("disabled", `
 cursor: not-allowed;
 `, [ui("selected", `
 color: var(--n-option-text-color-disabled);
 `), Ge("selected", `
 opacity: var(--n-option-opacity-disabled);
 `)]), Ae("check", `
 font-size: 16px;
 position: absolute;
 right: calc(var(--n-option-padding-right) - 4px);
 top: calc(50% - 7px);
 color: var(--n-option-check-color);
 transition: color .3s var(--n-bezier);
 `, [wp({ enterScale: "0.5" })])])]), $k = ot({ name: "InternalSelectMenu", props: Object.assign(Object.assign({}, Jt.props), { clsPrefix: { type: String, required: true }, scrollable: { type: Boolean, default: true }, treeMate: { type: Object, required: true }, multiple: Boolean, size: { type: String, default: "medium" }, value: { type: [String, Number, Array], default: null }, autoPending: Boolean, virtualScroll: { type: Boolean, default: true }, show: { type: Boolean, default: true }, labelField: { type: String, default: "label" }, valueField: { type: String, default: "value" }, loading: Boolean, focusable: Boolean, renderLabel: Function, renderOption: Function, nodeProps: Function, showCheckmark: { type: Boolean, default: true }, onMousedown: Function, onScroll: Function, onFocus: Function, onBlur: Function, onKeyup: Function, onKeydown: Function, onTabOut: Function, onMouseenter: Function, onMouseleave: Function, onResize: Function, resetMenuOnOptionsChange: { type: Boolean, default: true }, inlineThemeDisabled: Boolean, onToggle: Function }), setup(r) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Sr(r), d = Tn("InternalSelectMenu", l, i), f = Jt("InternalSelectMenu", "-internal-select-menu", Ok, Rw, r, zt(r, "clsPrefix")), g = Ie(null), p = Ie(null), s = Ie(null), C = Ee(() => r.treeMate.getFlattenedNodes()), P = Ee(() => Aw(C.value)), M = Ie(null);
  function D() {
    const { treeMate: pt } = r;
    let wt = null;
    const { value: Ft } = r;
    Ft === null ? wt = pt.getFirstAvailableNode() : (r.multiple ? wt = pt.getNode((Ft || [])[(Ft || []).length - 1]) : wt = pt.getNode(Ft), (!wt || wt.disabled) && (wt = pt.getFirstAvailableNode())), tt(wt || null);
  }
  function L() {
    const { value: pt } = M;
    pt && !r.treeMate.getNode(pt.key) && (M.value = null);
  }
  let $;
  Ht(() => r.show, (pt) => {
    pt ? $ = Ht(() => r.treeMate, () => {
      r.resetMenuOnOptionsChange ? (r.autoPending ? D() : L(), Wn(ut)) : L();
    }, { immediate: true }) : $ == null ? void 0 : $();
  }, { immediate: true }), Pn(() => {
    $ == null ? void 0 : $();
  });
  const z = Ee(() => nn(f.value.self[Vt("optionHeight", r.size)])), F = Ee(() => Io(f.value.self[Vt("padding", r.size)])), Z = Ee(() => r.multiple && Array.isArray(r.value) ? new Set(r.value) : /* @__PURE__ */ new Set()), q = Ee(() => {
    const pt = C.value;
    return pt && pt.length === 0;
  });
  function K(pt) {
    const { onToggle: wt } = r;
    wt && wt(pt);
  }
  function te(pt) {
    const { onScroll: wt } = r;
    wt && wt(pt);
  }
  function re(pt) {
    var wt;
    (wt = s.value) === null || wt === void 0 || wt.sync(), te(pt);
  }
  function ie() {
    var pt;
    (pt = s.value) === null || pt === void 0 || pt.sync();
  }
  function J() {
    const { value: pt } = M;
    return pt || null;
  }
  function we(pt, wt) {
    wt.disabled || tt(wt, false);
  }
  function fe(pt, wt) {
    wt.disabled || K(wt);
  }
  function oe(pt) {
    var wt;
    zl(pt, "action") || (wt = r.onKeyup) === null || wt === void 0 || wt.call(r, pt);
  }
  function he(pt) {
    var wt;
    zl(pt, "action") || (wt = r.onKeydown) === null || wt === void 0 || wt.call(r, pt);
  }
  function _e(pt) {
    var wt;
    (wt = r.onMousedown) === null || wt === void 0 || wt.call(r, pt), !r.focusable && pt.preventDefault();
  }
  function Ue() {
    const { value: pt } = M;
    pt && tt(pt.getNext({ loop: true }), true);
  }
  function qe() {
    const { value: pt } = M;
    pt && tt(pt.getPrev({ loop: true }), true);
  }
  function tt(pt, wt = false) {
    M.value = pt, wt && ut();
  }
  function ut() {
    var pt, wt;
    const Ft = M.value;
    if (!Ft) return;
    const tr = P.value(Ft.key);
    tr !== null && (r.virtualScroll ? (pt = p.value) === null || pt === void 0 || pt.scrollTo({ index: tr }) : (wt = s.value) === null || wt === void 0 || wt.scrollTo({ index: tr, elSize: z.value }));
  }
  function mt(pt) {
    var wt, Ft;
    !((wt = g.value) === null || wt === void 0) && wt.contains(pt.target) && ((Ft = r.onFocus) === null || Ft === void 0 || Ft.call(r, pt));
  }
  function St(pt) {
    var wt, Ft;
    !((wt = g.value) === null || wt === void 0) && wt.contains(pt.relatedTarget) || (Ft = r.onBlur) === null || Ft === void 0 || Ft.call(r, pt);
  }
  Xr(i0, { handleOptionMouseEnter: we, handleOptionClick: fe, valueSetRef: Z, pendingTmNodeRef: M, nodePropsRef: zt(r, "nodeProps"), showCheckmarkRef: zt(r, "showCheckmark"), multipleRef: zt(r, "multiple"), valueRef: zt(r, "value"), renderLabelRef: zt(r, "renderLabel"), renderOptionRef: zt(r, "renderOption"), labelFieldRef: zt(r, "labelField"), valueFieldRef: zt(r, "valueField") }), Xr(Dw, g), Ri(() => {
    const { value: pt } = s;
    pt && pt.sync();
  });
  const st = Ee(() => {
    const { size: pt } = r, { common: { cubicBezierEaseInOut: wt }, self: { height: Ft, borderRadius: tr, color: gt, groupHeaderTextColor: Bt, actionDividerColor: Zt, optionTextColorPressed: ir, optionTextColor: Cr, optionTextColorDisabled: Ar, optionTextColorActive: or, optionOpacityDisabled: Tr, optionCheckColor: Xt, actionTextColor: Dr, optionColorPending: nr, optionColorActive: kt, loadingColor: ze, loadingSize: at, optionColorActivePending: Oe, [Vt("optionFontSize", pt)]: Je, [Vt("optionHeight", pt)]: ht, [Vt("optionPadding", pt)]: bt } } = f.value;
    return { "--n-height": Ft, "--n-action-divider-color": Zt, "--n-action-text-color": Dr, "--n-bezier": wt, "--n-border-radius": tr, "--n-color": gt, "--n-option-font-size": Je, "--n-group-header-text-color": Bt, "--n-option-check-color": Xt, "--n-option-color-pending": nr, "--n-option-color-active": kt, "--n-option-color-active-pending": Oe, "--n-option-height": ht, "--n-option-opacity-disabled": Tr, "--n-option-text-color": Cr, "--n-option-text-color-active": or, "--n-option-text-color-disabled": Ar, "--n-option-text-color-pressed": ir, "--n-option-padding": bt, "--n-option-padding-left": Io(bt, "left"), "--n-option-padding-right": Io(bt, "right"), "--n-loading-color": ze, "--n-loading-size": at };
  }), { inlineThemeDisabled: nt } = r, ft = nt ? ai("internal-select-menu", Ee(() => r.size[0]), st, r) : void 0, Lt = { selfRef: g, next: Ue, prev: qe, getPendingTmNode: J };
  return Ab(g, r.onResize), Object.assign({ mergedTheme: f, mergedClsPrefix: i, rtlEnabled: d, virtualListRef: p, scrollbarRef: s, itemSize: z, padding: F, flattenedNodes: C, empty: q, virtualListContainer() {
    const { value: pt } = p;
    return pt == null ? void 0 : pt.listElRef;
  }, virtualListContent() {
    const { value: pt } = p;
    return pt == null ? void 0 : pt.itemsElRef;
  }, doScroll: te, handleFocusin: mt, handleFocusout: St, handleKeyUp: oe, handleKeyDown: he, handleMouseDown: _e, handleVirtualListResize: ie, handleVirtualListScroll: re, cssVars: nt ? void 0 : st, themeClass: ft == null ? void 0 : ft.themeClass, onRender: ft == null ? void 0 : ft.onRender }, Lt);
}, render() {
  const { $slots: r, virtualScroll: i, clsPrefix: l, mergedTheme: d, themeClass: f, onRender: g } = this;
  return g == null ? void 0 : g(), B("div", { ref: "selfRef", tabindex: this.focusable ? 0 : -1, class: [`${l}-base-select-menu`, this.rtlEnabled && `${l}-base-select-menu--rtl`, f, this.multiple && `${l}-base-select-menu--multiple`], style: this.cssVars, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onKeyup: this.handleKeyUp, onKeydown: this.handleKeyDown, onMousedown: this.handleMouseDown, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave }, oi(r.header, (p) => p && B("div", { class: `${l}-base-select-menu__header`, "data-header": true, key: "header" }, p)), this.loading ? B("div", { class: `${l}-base-select-menu__loading` }, B(Cp, { clsPrefix: l, strokeWidth: 20 })) : this.empty ? B("div", { class: `${l}-base-select-menu__empty`, "data-empty": true }, Zn(r.empty, () => [B(Qd, { theme: d.peers.Empty, themeOverrides: d.peerOverrides.Empty, size: this.size })])) : B(uh, { ref: "scrollbarRef", theme: d.peers.Scrollbar, themeOverrides: d.peerOverrides.Scrollbar, scrollable: this.scrollable, container: i ? this.virtualListContainer : void 0, content: i ? this.virtualListContent : void 0, onScroll: i ? void 0 : this.doScroll }, { default: () => i ? B(kS, { ref: "virtualListRef", class: `${l}-virtual-list`, items: this.flattenedNodes, itemSize: this.itemSize, showScrollbar: false, paddingTop: this.padding.top, paddingBottom: this.padding.bottom, onResize: this.handleVirtualListResize, onScroll: this.handleVirtualListScroll, itemResizable: true }, { default: ({ item: p }) => p.isGroup ? B(C_, { key: p.key, clsPrefix: l, tmNode: p }) : p.ignored ? null : B(S_, { clsPrefix: l, key: p.key, tmNode: p }) }) : B("div", { class: `${l}-base-select-menu-option-wrapper`, style: { paddingTop: this.padding.top, paddingBottom: this.padding.bottom } }, this.flattenedNodes.map((p) => p.isGroup ? B(C_, { key: p.key, clsPrefix: l, tmNode: p }) : B(S_, { clsPrefix: l, key: p.key, tmNode: p }))) }), oi(r.action, (p) => p && [B("div", { class: `${l}-base-select-menu__action`, "data-action": true, key: "action" }, p), B(zk, { onFocus: this.onTabOut, key: "focus-detector" })]));
} }), Lb = { color: Object, type: { type: String, default: "default" }, round: Boolean, size: { type: String, default: "medium" }, closable: Boolean, disabled: { type: Boolean, default: void 0 } }, jk = ue("tag", `
 --n-close-margin: var(--n-close-margin-top) var(--n-close-margin-right) var(--n-close-margin-bottom) var(--n-close-margin-left);
 white-space: nowrap;
 position: relative;
 box-sizing: border-box;
 cursor: default;
 display: inline-flex;
 align-items: center;
 flex-wrap: nowrap;
 padding: var(--n-padding);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition: 
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 line-height: 1;
 height: var(--n-height);
 font-size: var(--n-font-size);
`, [Ge("strong", `
 font-weight: var(--n-font-weight-strong);
 `), Ae("border", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 border: var(--n-border);
 transition: border-color .3s var(--n-bezier);
 `), Ae("icon", `
 display: flex;
 margin: 0 4px 0 0;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 font-size: var(--n-avatar-size-override);
 `), Ae("avatar", `
 display: flex;
 margin: 0 6px 0 0;
 `), Ae("close", `
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), Ge("round", `
 padding: 0 calc(var(--n-height) / 3);
 border-radius: calc(var(--n-height) / 2);
 `, [Ae("icon", `
 margin: 0 4px 0 calc((var(--n-height) - 8px) / -2);
 `), Ae("avatar", `
 margin: 0 6px 0 calc((var(--n-height) - 8px) / -2);
 `), Ge("closable", `
 padding: 0 calc(var(--n-height) / 4) 0 calc(var(--n-height) / 3);
 `)]), Ge("icon, avatar", [Ge("round", `
 padding: 0 calc(var(--n-height) / 3) 0 calc(var(--n-height) / 2);
 `)]), Ge("disabled", `
 cursor: not-allowed !important;
 opacity: var(--n-opacity-disabled);
 `), Ge("checkable", `
 cursor: pointer;
 box-shadow: none;
 color: var(--n-text-color-checkable);
 background-color: var(--n-color-checkable);
 `, [ui("disabled", [Ze("&:hover", "background-color: var(--n-color-hover-checkable);", [ui("checked", "color: var(--n-text-color-hover-checkable);")]), Ze("&:active", "background-color: var(--n-color-pressed-checkable);", [ui("checked", "color: var(--n-text-color-pressed-checkable);")])]), Ge("checked", `
 color: var(--n-text-color-checked);
 background-color: var(--n-color-checked);
 `, [ui("disabled", [Ze("&:hover", "background-color: var(--n-color-checked-hover);"), Ze("&:active", "background-color: var(--n-color-checked-pressed);")])])])]), Nk = Object.assign(Object.assign(Object.assign({}, Jt.props), Lb), { bordered: { type: Boolean, default: void 0 }, checked: Boolean, checkable: Boolean, strong: Boolean, triggerClickOnClose: Boolean, onClose: [Array, Function], onMouseenter: Function, onMouseleave: Function, "onUpdate:checked": Function, onUpdateChecked: Function, internalCloseFocusable: { type: Boolean, default: true }, internalCloseIsButtonTag: { type: Boolean, default: true }, onCheckedChange: Function }), Vk = $n("n-tag"), xo = ot({ name: "Tag", props: Nk, slots: Object, setup(r) {
  const i = Ie(null), { mergedBorderedRef: l, mergedClsPrefixRef: d, inlineThemeDisabled: f, mergedRtlRef: g } = Sr(r), p = Jt("Tag", "-tag", jk, zw, r, d);
  Xr(Vk, { roundRef: zt(r, "round") });
  function s() {
    if (!r.disabled && r.checkable) {
      const { checked: $, onCheckedChange: z, onUpdateChecked: F, "onUpdate:checked": Z } = r;
      F && F(!$), Z && Z(!$), z && z(!$);
    }
  }
  function C($) {
    if (r.triggerClickOnClose || $.stopPropagation(), !r.disabled) {
      const { onClose: z } = r;
      z && Ot(z, $);
    }
  }
  const P = { setTextContent($) {
    const { value: z } = i;
    z && (z.textContent = $);
  } }, M = Tn("Tag", g, d), D = Ee(() => {
    const { type: $, size: z, color: { color: F, textColor: Z } = {} } = r, { common: { cubicBezierEaseInOut: q }, self: { padding: K, closeMargin: te, borderRadius: re, opacityDisabled: ie, textColorCheckable: J, textColorHoverCheckable: we, textColorPressedCheckable: fe, textColorChecked: oe, colorCheckable: he, colorHoverCheckable: _e, colorPressedCheckable: Ue, colorChecked: qe, colorCheckedHover: tt, colorCheckedPressed: ut, closeBorderRadius: mt, fontWeightStrong: St, [Vt("colorBordered", $)]: st, [Vt("closeSize", z)]: nt, [Vt("closeIconSize", z)]: ft, [Vt("fontSize", z)]: Lt, [Vt("height", z)]: pt, [Vt("color", $)]: wt, [Vt("textColor", $)]: Ft, [Vt("border", $)]: tr, [Vt("closeIconColor", $)]: gt, [Vt("closeIconColorHover", $)]: Bt, [Vt("closeIconColorPressed", $)]: Zt, [Vt("closeColorHover", $)]: ir, [Vt("closeColorPressed", $)]: Cr } } = p.value, Ar = Io(te);
    return { "--n-font-weight-strong": St, "--n-avatar-size-override": `calc(${pt} - 8px)`, "--n-bezier": q, "--n-border-radius": re, "--n-border": tr, "--n-close-icon-size": ft, "--n-close-color-pressed": Cr, "--n-close-color-hover": ir, "--n-close-border-radius": mt, "--n-close-icon-color": gt, "--n-close-icon-color-hover": Bt, "--n-close-icon-color-pressed": Zt, "--n-close-icon-color-disabled": gt, "--n-close-margin-top": Ar.top, "--n-close-margin-right": Ar.right, "--n-close-margin-bottom": Ar.bottom, "--n-close-margin-left": Ar.left, "--n-close-size": nt, "--n-color": F || (l.value ? st : wt), "--n-color-checkable": he, "--n-color-checked": qe, "--n-color-checked-hover": tt, "--n-color-checked-pressed": ut, "--n-color-hover-checkable": _e, "--n-color-pressed-checkable": Ue, "--n-font-size": Lt, "--n-height": pt, "--n-opacity-disabled": ie, "--n-padding": K, "--n-text-color": Z || Ft, "--n-text-color-checkable": J, "--n-text-color-checked": oe, "--n-text-color-hover-checkable": we, "--n-text-color-pressed-checkable": fe };
  }), L = f ? ai("tag", Ee(() => {
    let $ = "";
    const { type: z, size: F, color: { color: Z, textColor: q } = {} } = r;
    return $ += z[0], $ += F[0], Z && ($ += `a${u_(Z)}`), q && ($ += `b${u_(q)}`), l.value && ($ += "c"), $;
  }), D, r) : void 0;
  return Object.assign(Object.assign({}, P), { rtlEnabled: M, mergedClsPrefix: d, contentRef: i, mergedBordered: l, handleClick: s, handleCloseClick: C, cssVars: f ? void 0 : D, themeClass: L == null ? void 0 : L.themeClass, onRender: L == null ? void 0 : L.onRender });
}, render() {
  var r, i;
  const { mergedClsPrefix: l, rtlEnabled: d, closable: f, color: { borderColor: g } = {}, round: p, onRender: s, $slots: C } = this;
  s == null ? void 0 : s();
  const P = oi(C.avatar, (D) => D && B("div", { class: `${l}-tag__avatar` }, D)), M = oi(C.icon, (D) => D && B("div", { class: `${l}-tag__icon` }, D));
  return B("div", { class: [`${l}-tag`, this.themeClass, { [`${l}-tag--rtl`]: d, [`${l}-tag--strong`]: this.strong, [`${l}-tag--disabled`]: this.disabled, [`${l}-tag--checkable`]: this.checkable, [`${l}-tag--checked`]: this.checkable && this.checked, [`${l}-tag--round`]: p, [`${l}-tag--avatar`]: P, [`${l}-tag--icon`]: M, [`${l}-tag--closable`]: f }], style: this.cssVars, onClick: this.handleClick, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave }, M || P, B("span", { class: `${l}-tag__content`, ref: "contentRef" }, (i = (r = this.$slots).default) === null || i === void 0 ? void 0 : i.call(r)), !this.checkable && f ? B(Sp, { clsPrefix: l, class: `${l}-tag__close`, disabled: this.disabled, onClick: this.handleCloseClick, focusable: this.internalCloseFocusable, round: p, isButtonTag: this.internalCloseIsButtonTag, absolute: true }) : null, !this.checkable && this.mergedBordered ? B("div", { class: `${l}-tag__border`, style: { borderColor: g } }) : null);
} }), Bb = ot({ name: "InternalSelectionSuffix", props: { clsPrefix: { type: String, required: true }, showArrow: { type: Boolean, default: void 0 }, showClear: { type: Boolean, default: void 0 }, loading: { type: Boolean, default: false }, onClear: Function }, setup(r, { slots: i }) {
  return () => {
    const { clsPrefix: l } = r;
    return B(Cp, { clsPrefix: l, class: `${l}-base-suffix`, strokeWidth: 24, scale: 0.85, show: r.loading }, { default: () => r.showArrow ? B(Fg, { clsPrefix: l, show: r.showClear, onClear: r.onClear }, { placeholder: () => B(qr, { clsPrefix: l, class: `${l}-base-suffix__arrow` }, { default: () => Zn(i.default, () => [B(bk, null)]) }) }) : null });
  };
} }), Uk = Ze([ue("base-selection", `
 --n-padding-single: var(--n-padding-single-top) var(--n-padding-single-right) var(--n-padding-single-bottom) var(--n-padding-single-left);
 --n-padding-multiple: var(--n-padding-multiple-top) var(--n-padding-multiple-right) var(--n-padding-multiple-bottom) var(--n-padding-multiple-left);
 position: relative;
 z-index: auto;
 box-shadow: none;
 width: 100%;
 max-width: 100%;
 display: inline-block;
 vertical-align: bottom;
 border-radius: var(--n-border-radius);
 min-height: var(--n-height);
 line-height: 1.5;
 font-size: var(--n-font-size);
 `, [ue("base-loading", `
 color: var(--n-loading-color);
 `), ue("base-selection-tags", "min-height: var(--n-height);"), Ae("border, state-border", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border: var(--n-border);
 border-radius: inherit;
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), Ae("state-border", `
 z-index: 1;
 border-color: #0000;
 `), ue("base-suffix", `
 cursor: pointer;
 position: absolute;
 top: 50%;
 transform: translateY(-50%);
 right: 10px;
 `, [Ae("arrow", `
 font-size: var(--n-arrow-size);
 color: var(--n-arrow-color);
 transition: color .3s var(--n-bezier);
 `)]), ue("base-selection-overlay", `
 display: flex;
 align-items: center;
 white-space: nowrap;
 pointer-events: none;
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 padding: var(--n-padding-single);
 transition: color .3s var(--n-bezier);
 `, [Ae("wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 overflow: hidden;
 text-overflow: ellipsis;
 `)]), ue("base-selection-placeholder", `
 color: var(--n-placeholder-color);
 `, [Ae("inner", `
 max-width: 100%;
 overflow: hidden;
 `)]), ue("base-selection-tags", `
 cursor: pointer;
 outline: none;
 box-sizing: border-box;
 position: relative;
 z-index: auto;
 display: flex;
 padding: var(--n-padding-multiple);
 flex-wrap: wrap;
 align-items: center;
 width: 100%;
 vertical-align: bottom;
 background-color: var(--n-color);
 border-radius: inherit;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), ue("base-selection-label", `
 height: var(--n-height);
 display: inline-flex;
 width: 100%;
 vertical-align: bottom;
 cursor: pointer;
 outline: none;
 z-index: auto;
 box-sizing: border-box;
 position: relative;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: inherit;
 background-color: var(--n-color);
 align-items: center;
 `, [ue("base-selection-input", `
 font-size: inherit;
 line-height: inherit;
 outline: none;
 cursor: pointer;
 box-sizing: border-box;
 border:none;
 width: 100%;
 padding: var(--n-padding-single);
 background-color: #0000;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 caret-color: var(--n-caret-color);
 `, [Ae("content", `
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap; 
 `)]), Ae("render-label", `
 color: var(--n-text-color);
 `)]), ui("disabled", [Ze("&:hover", [Ae("state-border", `
 box-shadow: var(--n-box-shadow-hover);
 border: var(--n-border-hover);
 `)]), Ge("focus", [Ae("state-border", `
 box-shadow: var(--n-box-shadow-focus);
 border: var(--n-border-focus);
 `)]), Ge("active", [Ae("state-border", `
 box-shadow: var(--n-box-shadow-active);
 border: var(--n-border-active);
 `), ue("base-selection-label", "background-color: var(--n-color-active);"), ue("base-selection-tags", "background-color: var(--n-color-active);")])]), Ge("disabled", "cursor: not-allowed;", [Ae("arrow", `
 color: var(--n-arrow-color-disabled);
 `), ue("base-selection-label", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [ue("base-selection-input", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 `), Ae("render-label", `
 color: var(--n-text-color-disabled);
 `)]), ue("base-selection-tags", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `), ue("base-selection-placeholder", `
 cursor: not-allowed;
 color: var(--n-placeholder-color-disabled);
 `)]), ue("base-selection-input-tag", `
 height: calc(var(--n-height) - 6px);
 line-height: calc(var(--n-height) - 6px);
 outline: none;
 display: none;
 position: relative;
 margin-bottom: 3px;
 max-width: 100%;
 vertical-align: bottom;
 `, [Ae("input", `
 font-size: inherit;
 font-family: inherit;
 min-width: 1px;
 padding: 0;
 background-color: #0000;
 outline: none;
 border: none;
 max-width: 100%;
 overflow: hidden;
 width: 1em;
 line-height: inherit;
 cursor: pointer;
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 `), Ae("mirror", `
 position: absolute;
 left: 0;
 top: 0;
 white-space: pre;
 visibility: hidden;
 user-select: none;
 -webkit-user-select: none;
 opacity: 0;
 `)]), ["warning", "error"].map((r) => Ge(`${r}-status`, [Ae("state-border", `border: var(--n-border-${r});`), ui("disabled", [Ze("&:hover", [Ae("state-border", `
 box-shadow: var(--n-box-shadow-hover-${r});
 border: var(--n-border-hover-${r});
 `)]), Ge("active", [Ae("state-border", `
 box-shadow: var(--n-box-shadow-active-${r});
 border: var(--n-border-active-${r});
 `), ue("base-selection-label", `background-color: var(--n-color-active-${r});`), ue("base-selection-tags", `background-color: var(--n-color-active-${r});`)]), Ge("focus", [Ae("state-border", `
 box-shadow: var(--n-box-shadow-focus-${r});
 border: var(--n-border-focus-${r});
 `)])])]))]), ue("base-selection-popover", `
 margin-bottom: -3px;
 display: flex;
 flex-wrap: wrap;
 margin-right: -8px;
 `), ue("base-selection-tag-wrapper", `
 max-width: 100%;
 display: inline-flex;
 padding: 0 7px 3px 0;
 `, [Ze("&:last-child", "padding-right: 0;"), ue("tag", `
 font-size: 14px;
 max-width: 100%;
 `, [Ae("content", `
 line-height: 1.25;
 text-overflow: ellipsis;
 overflow: hidden;
 `)])])]), Gk = ot({ name: "InternalSelection", props: Object.assign(Object.assign({}, Jt.props), { clsPrefix: { type: String, required: true }, bordered: { type: Boolean, default: void 0 }, active: Boolean, pattern: { type: String, default: "" }, placeholder: String, selectedOption: { type: Object, default: null }, selectedOptions: { type: Array, default: null }, labelField: { type: String, default: "label" }, valueField: { type: String, default: "value" }, multiple: Boolean, filterable: Boolean, clearable: Boolean, disabled: Boolean, size: { type: String, default: "medium" }, loading: Boolean, autofocus: Boolean, showArrow: { type: Boolean, default: true }, inputProps: Object, focused: Boolean, renderTag: Function, onKeydown: Function, onClick: Function, onBlur: Function, onFocus: Function, onDeleteOption: Function, maxTagCount: [String, Number], ellipsisTagPopoverProps: Object, onClear: Function, onPatternInput: Function, onPatternFocus: Function, onPatternBlur: Function, renderLabel: Function, status: String, inlineThemeDisabled: Boolean, ignoreComposition: { type: Boolean, default: true }, onResize: Function }), setup(r) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Sr(r), d = Tn("InternalSelection", l, i), f = Ie(null), g = Ie(null), p = Ie(null), s = Ie(null), C = Ie(null), P = Ie(null), M = Ie(null), D = Ie(null), L = Ie(null), $ = Ie(null), z = Ie(false), F = Ie(false), Z = Ie(false), q = Jt("InternalSelection", "-internal-selection", Uk, Lw, r, zt(r, "clsPrefix")), K = Ee(() => r.clearable && !r.disabled && (Z.value || r.active)), te = Ee(() => r.selectedOption ? r.renderTag ? r.renderTag({ option: r.selectedOption, handleClose: () => {
  } }) : r.renderLabel ? r.renderLabel(r.selectedOption, true) : Rl(r.selectedOption[r.labelField], r.selectedOption, true) : r.placeholder), re = Ee(() => {
    const rt = r.selectedOption;
    if (rt) return rt[r.labelField];
  }), ie = Ee(() => r.multiple ? !!(Array.isArray(r.selectedOptions) && r.selectedOptions.length) : r.selectedOption !== null);
  function J() {
    var rt;
    const { value: vt } = f;
    if (vt) {
      const { value: Wt } = g;
      Wt && (Wt.style.width = `${vt.offsetWidth}px`, r.maxTagCount !== "responsive" && ((rt = L.value) === null || rt === void 0 || rt.sync({ showAllItemsBeforeCalculate: false })));
    }
  }
  function we() {
    const { value: rt } = $;
    rt && (rt.style.display = "none");
  }
  function fe() {
    const { value: rt } = $;
    rt && (rt.style.display = "inline-block");
  }
  Ht(zt(r, "active"), (rt) => {
    rt || we();
  }), Ht(zt(r, "pattern"), () => {
    r.multiple && Wn(J);
  });
  function oe(rt) {
    const { onFocus: vt } = r;
    vt && vt(rt);
  }
  function he(rt) {
    const { onBlur: vt } = r;
    vt && vt(rt);
  }
  function _e(rt) {
    const { onDeleteOption: vt } = r;
    vt && vt(rt);
  }
  function Ue(rt) {
    const { onClear: vt } = r;
    vt && vt(rt);
  }
  function qe(rt) {
    const { onPatternInput: vt } = r;
    vt && vt(rt);
  }
  function tt(rt) {
    var vt;
    (!rt.relatedTarget || !(!((vt = p.value) === null || vt === void 0) && vt.contains(rt.relatedTarget))) && oe(rt);
  }
  function ut(rt) {
    var vt;
    !((vt = p.value) === null || vt === void 0) && vt.contains(rt.relatedTarget) || he(rt);
  }
  function mt(rt) {
    Ue(rt);
  }
  function St() {
    Z.value = true;
  }
  function st() {
    Z.value = false;
  }
  function nt(rt) {
    !r.active || !r.filterable || rt.target !== g.value && rt.preventDefault();
  }
  function ft(rt) {
    _e(rt);
  }
  const Lt = Ie(false);
  function pt(rt) {
    if (rt.key === "Backspace" && !Lt.value && !r.pattern.length) {
      const { selectedOptions: vt } = r;
      (vt == null ? void 0 : vt.length) && ft(vt[vt.length - 1]);
    }
  }
  let wt = null;
  function Ft(rt) {
    const { value: vt } = f;
    if (vt) {
      const Wt = rt.target.value;
      vt.textContent = Wt, J();
    }
    r.ignoreComposition && Lt.value ? wt = rt : qe(rt);
  }
  function tr() {
    Lt.value = true;
  }
  function gt() {
    Lt.value = false, r.ignoreComposition && qe(wt), wt = null;
  }
  function Bt(rt) {
    var vt;
    F.value = true, (vt = r.onPatternFocus) === null || vt === void 0 || vt.call(r, rt);
  }
  function Zt(rt) {
    var vt;
    F.value = false, (vt = r.onPatternBlur) === null || vt === void 0 || vt.call(r, rt);
  }
  function ir() {
    var rt, vt;
    if (r.filterable) F.value = false, (rt = P.value) === null || rt === void 0 || rt.blur(), (vt = g.value) === null || vt === void 0 || vt.blur();
    else if (r.multiple) {
      const { value: Wt } = s;
      Wt == null ? void 0 : Wt.blur();
    } else {
      const { value: Wt } = C;
      Wt == null ? void 0 : Wt.blur();
    }
  }
  function Cr() {
    var rt, vt, Wt;
    r.filterable ? (F.value = false, (rt = P.value) === null || rt === void 0 || rt.focus()) : r.multiple ? (vt = s.value) === null || vt === void 0 || vt.focus() : (Wt = C.value) === null || Wt === void 0 || Wt.focus();
  }
  function Ar() {
    const { value: rt } = g;
    rt && (fe(), rt.focus());
  }
  function or() {
    const { value: rt } = g;
    rt && rt.blur();
  }
  function Tr(rt) {
    const { value: vt } = M;
    vt && vt.setTextContent(`+${rt}`);
  }
  function Xt() {
    const { value: rt } = D;
    return rt;
  }
  function Dr() {
    return g.value;
  }
  let nr = null;
  function kt() {
    nr !== null && window.clearTimeout(nr);
  }
  function ze() {
    r.active || (kt(), nr = window.setTimeout(() => {
      ie.value && (z.value = true);
    }, 100));
  }
  function at() {
    kt();
  }
  function Oe(rt) {
    rt || (kt(), z.value = false);
  }
  Ht(ie, (rt) => {
    rt || (z.value = false);
  }), Ri(() => {
    bo(() => {
      const rt = P.value;
      rt && (r.disabled ? rt.removeAttribute("tabindex") : rt.tabIndex = F.value ? -1 : 0);
    });
  }), Ab(p, r.onResize);
  const { inlineThemeDisabled: Je } = r, ht = Ee(() => {
    const { size: rt } = r, { common: { cubicBezierEaseInOut: vt }, self: { fontWeight: Wt, borderRadius: ci, color: Ai, placeholderColor: sn, textColor: Fe, paddingSingle: X, paddingMultiple: Y, caretColor: ne, colorDisabled: ve, textColorDisabled: Ce, placeholderColorDisabled: ae, colorActive: Pe, boxShadowFocus: xe, boxShadowActive: Ve, boxShadowHover: et, border: We, borderFocus: xt, borderHover: Le, borderActive: rr, arrowColor: Zr, arrowColorDisabled: Ut, loadingColor: dr, colorActiveWarning: Er, boxShadowFocusWarning: jr, boxShadowActiveWarning: di, boxShadowHoverWarning: Hr, borderWarning: Jr, borderFocusWarning: Lr, borderHoverWarning: Ne, borderActiveWarning: Te, colorActiveError: jt, boxShadowFocusError: _r, boxShadowActiveError: Nr, boxShadowHoverError: mr, borderError: Ct, borderFocusError: ar, borderHoverError: lr, borderActiveError: Bi, clearColor: jn, clearColorHover: In, clearColorPressed: hr, clearSize: Ao, arrowSize: no, [Vt("height", rt)]: Mn, [Vt("fontSize", rt)]: Hn } } = q.value, Xn = Io(X), En = Io(Y);
    return { "--n-bezier": vt, "--n-border": We, "--n-border-active": rr, "--n-border-focus": xt, "--n-border-hover": Le, "--n-border-radius": ci, "--n-box-shadow-active": Ve, "--n-box-shadow-focus": xe, "--n-box-shadow-hover": et, "--n-caret-color": ne, "--n-color": Ai, "--n-color-active": Pe, "--n-color-disabled": ve, "--n-font-size": Hn, "--n-height": Mn, "--n-padding-single-top": Xn.top, "--n-padding-multiple-top": En.top, "--n-padding-single-right": Xn.right, "--n-padding-multiple-right": En.right, "--n-padding-single-left": Xn.left, "--n-padding-multiple-left": En.left, "--n-padding-single-bottom": Xn.bottom, "--n-padding-multiple-bottom": En.bottom, "--n-placeholder-color": sn, "--n-placeholder-color-disabled": ae, "--n-text-color": Fe, "--n-text-color-disabled": Ce, "--n-arrow-color": Zr, "--n-arrow-color-disabled": Ut, "--n-loading-color": dr, "--n-color-active-warning": Er, "--n-box-shadow-focus-warning": jr, "--n-box-shadow-active-warning": di, "--n-box-shadow-hover-warning": Hr, "--n-border-warning": Jr, "--n-border-focus-warning": Lr, "--n-border-hover-warning": Ne, "--n-border-active-warning": Te, "--n-color-active-error": jt, "--n-box-shadow-focus-error": _r, "--n-box-shadow-active-error": Nr, "--n-box-shadow-hover-error": mr, "--n-border-error": Ct, "--n-border-focus-error": ar, "--n-border-hover-error": lr, "--n-border-active-error": Bi, "--n-clear-size": Ao, "--n-clear-color": jn, "--n-clear-color-hover": In, "--n-clear-color-pressed": hr, "--n-arrow-size": no, "--n-font-weight": Wt };
  }), bt = Je ? ai("internal-selection", Ee(() => r.size[0]), ht, r) : void 0;
  return { mergedTheme: q, mergedClearable: K, mergedClsPrefix: i, rtlEnabled: d, patternInputFocused: F, filterablePlaceholder: te, label: re, selected: ie, showTagsPanel: z, isComposing: Lt, counterRef: M, counterWrapperRef: D, patternInputMirrorRef: f, patternInputRef: g, selfRef: p, multipleElRef: s, singleElRef: C, patternInputWrapperRef: P, overflowRef: L, inputTagElRef: $, handleMouseDown: nt, handleFocusin: tt, handleClear: mt, handleMouseEnter: St, handleMouseLeave: st, handleDeleteOption: ft, handlePatternKeyDown: pt, handlePatternInputInput: Ft, handlePatternInputBlur: Zt, handlePatternInputFocus: Bt, handleMouseEnterCounter: ze, handleMouseLeaveCounter: at, handleFocusout: ut, handleCompositionEnd: gt, handleCompositionStart: tr, onPopoverUpdateShow: Oe, focus: Cr, focusInput: Ar, blur: ir, blurInput: or, updateCounter: Tr, getCounter: Xt, getTail: Dr, renderLabel: r.renderLabel, cssVars: Je ? void 0 : ht, themeClass: bt == null ? void 0 : bt.themeClass, onRender: bt == null ? void 0 : bt.onRender };
}, render() {
  const { status: r, multiple: i, size: l, disabled: d, filterable: f, maxTagCount: g, bordered: p, clsPrefix: s, ellipsisTagPopoverProps: C, onRender: P, renderTag: M, renderLabel: D } = this;
  P == null ? void 0 : P();
  const L = g === "responsive", $ = typeof g == "number", z = L || $, F = B(Fw, null, { default: () => B(Bb, { clsPrefix: s, loading: this.loading, showArrow: this.showArrow, showClear: this.mergedClearable && this.selected, onClear: this.handleClear }, { default: () => {
    var q, K;
    return (K = (q = this.$slots).arrow) === null || K === void 0 ? void 0 : K.call(q);
  } }) });
  let Z;
  if (i) {
    const { labelField: q } = this, K = (qe) => B("div", { class: `${s}-base-selection-tag-wrapper`, key: qe.value }, M ? M({ option: qe, handleClose: () => {
      this.handleDeleteOption(qe);
    } }) : B(xo, { size: l, closable: !qe.disabled, disabled: d, onClose: () => {
      this.handleDeleteOption(qe);
    }, internalCloseIsButtonTag: false, internalCloseFocusable: false }, { default: () => D ? D(qe, true) : Rl(qe[q], qe, true) })), te = () => ($ ? this.selectedOptions.slice(0, g) : this.selectedOptions).map(K), re = f ? B("div", { class: `${s}-base-selection-input-tag`, ref: "inputTagElRef", key: "__input-tag__" }, B("input", Object.assign({}, this.inputProps, { ref: "patternInputRef", tabindex: -1, disabled: d, value: this.pattern, autofocus: this.autofocus, class: `${s}-base-selection-input-tag__input`, onBlur: this.handlePatternInputBlur, onFocus: this.handlePatternInputFocus, onKeydown: this.handlePatternKeyDown, onInput: this.handlePatternInputInput, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd })), B("span", { ref: "patternInputMirrorRef", class: `${s}-base-selection-input-tag__mirror` }, this.pattern)) : null, ie = L ? () => B("div", { class: `${s}-base-selection-tag-wrapper`, ref: "counterWrapperRef" }, B(xo, { size: l, ref: "counterRef", onMouseenter: this.handleMouseEnterCounter, onMouseleave: this.handleMouseLeaveCounter, disabled: d })) : void 0;
    let J;
    if ($) {
      const qe = this.selectedOptions.length - g;
      qe > 0 && (J = B("div", { class: `${s}-base-selection-tag-wrapper`, key: "__counter__" }, B(xo, { size: l, ref: "counterRef", onMouseenter: this.handleMouseEnterCounter, disabled: d }, { default: () => `+${qe}` })));
    }
    const we = L ? f ? B(c_, { ref: "overflowRef", updateCounter: this.updateCounter, getCounter: this.getCounter, getTail: this.getTail, style: { width: "100%", display: "flex", overflow: "hidden" } }, { default: te, counter: ie, tail: () => re }) : B(c_, { ref: "overflowRef", updateCounter: this.updateCounter, getCounter: this.getCounter, style: { width: "100%", display: "flex", overflow: "hidden" } }, { default: te, counter: ie }) : $ && J ? te().concat(J) : te(), fe = z ? () => B("div", { class: `${s}-base-selection-popover` }, L ? te() : this.selectedOptions.map(K)) : void 0, oe = z ? Object.assign({ show: this.showTagsPanel, trigger: "hover", overlap: true, placement: "top", width: "trigger", onUpdateShow: this.onPopoverUpdateShow, theme: this.mergedTheme.peers.Popover, themeOverrides: this.mergedTheme.peerOverrides.Popover }, C) : null, _e = (this.selected ? false : this.active ? !this.pattern && !this.isComposing : true) ? B("div", { class: `${s}-base-selection-placeholder ${s}-base-selection-overlay` }, B("div", { class: `${s}-base-selection-placeholder__inner` }, this.placeholder)) : null, Ue = f ? B("div", { ref: "patternInputWrapperRef", class: `${s}-base-selection-tags` }, we, L ? null : re, F) : B("div", { ref: "multipleElRef", class: `${s}-base-selection-tags`, tabindex: d ? void 0 : 0 }, we, F);
    Z = B(Wr, null, z ? B(n0, Object.assign({}, oe, { scrollable: true, style: "max-height: calc(var(--v-target-height) * 6.6);" }), { trigger: () => Ue, default: fe }) : Ue, _e);
  } else if (f) {
    const q = this.pattern || this.isComposing, K = this.active ? !q : !this.selected, te = this.active ? false : this.selected;
    Z = B("div", { ref: "patternInputWrapperRef", class: `${s}-base-selection-label`, title: this.patternInputFocused ? void 0 : zg(this.label) }, B("input", Object.assign({}, this.inputProps, { ref: "patternInputRef", class: `${s}-base-selection-input`, value: this.active ? this.pattern : "", placeholder: "", readonly: d, disabled: d, tabindex: -1, autofocus: this.autofocus, onFocus: this.handlePatternInputFocus, onBlur: this.handlePatternInputBlur, onInput: this.handlePatternInputInput, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd })), te ? B("div", { class: `${s}-base-selection-label__render-label ${s}-base-selection-overlay`, key: "input" }, B("div", { class: `${s}-base-selection-overlay__wrapper` }, M ? M({ option: this.selectedOption, handleClose: () => {
    } }) : D ? D(this.selectedOption, true) : Rl(this.label, this.selectedOption, true))) : null, K ? B("div", { class: `${s}-base-selection-placeholder ${s}-base-selection-overlay`, key: "placeholder" }, B("div", { class: `${s}-base-selection-overlay__wrapper` }, this.filterablePlaceholder)) : null, F);
  } else Z = B("div", { ref: "singleElRef", class: `${s}-base-selection-label`, tabindex: this.disabled ? void 0 : 0 }, this.label !== void 0 ? B("div", { class: `${s}-base-selection-input`, title: zg(this.label), key: "input" }, B("div", { class: `${s}-base-selection-input__content` }, M ? M({ option: this.selectedOption, handleClose: () => {
  } }) : D ? D(this.selectedOption, true) : Rl(this.label, this.selectedOption, true))) : B("div", { class: `${s}-base-selection-placeholder ${s}-base-selection-overlay`, key: "placeholder" }, B("div", { class: `${s}-base-selection-placeholder__inner` }, this.placeholder)), F);
  return B("div", { ref: "selfRef", class: [`${s}-base-selection`, this.rtlEnabled && `${s}-base-selection--rtl`, this.themeClass, r && `${s}-base-selection--${r}-status`, { [`${s}-base-selection--active`]: this.active, [`${s}-base-selection--selected`]: this.selected || this.active && this.pattern, [`${s}-base-selection--disabled`]: this.disabled, [`${s}-base-selection--multiple`]: this.multiple, [`${s}-base-selection--focus`]: this.focused }], style: this.cssVars, onClick: this.onClick, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onKeydown: this.onKeydown, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onMousedown: this.handleMouseDown }, Z, p ? B("div", { class: `${s}-base-selection__border` }) : null, p ? B("div", { class: `${s}-base-selection__state-border` }) : null);
} }), qk = ue("alert", `
 line-height: var(--n-line-height);
 border-radius: var(--n-border-radius);
 position: relative;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-color);
 text-align: start;
 word-break: break-word;
`, [Ae("border", `
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 transition: border-color .3s var(--n-bezier);
 border: var(--n-border);
 pointer-events: none;
 `), Ge("closable", [ue("alert-body", [Ae("title", `
 padding-right: 24px;
 `)])]), Ae("icon", { color: "var(--n-icon-color)" }), ue("alert-body", { padding: "var(--n-padding)" }, [Ae("title", { color: "var(--n-title-text-color)" }), Ae("content", { color: "var(--n-content-text-color)" })]), sp({ originalTransition: "transform .3s var(--n-bezier)", enterToProps: { transform: "scale(1)" }, leaveToProps: { transform: "scale(0.9)" } }), Ae("icon", `
 position: absolute;
 left: 0;
 top: 0;
 align-items: center;
 justify-content: center;
 display: flex;
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 margin: var(--n-icon-margin);
 `), Ae("close", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 position: absolute;
 right: 0;
 top: 0;
 margin: var(--n-close-margin);
 `), Ge("show-icon", [ue("alert-body", { paddingLeft: "calc(var(--n-icon-margin-left) + var(--n-icon-size) + var(--n-icon-margin-right))" })]), Ge("right-adjust", [ue("alert-body", { paddingRight: "calc(var(--n-close-size) + var(--n-padding) + 2px)" })]), ue("alert-body", `
 border-radius: var(--n-border-radius);
 transition: border-color .3s var(--n-bezier);
 `, [Ae("title", `
 transition: color .3s var(--n-bezier);
 font-size: 16px;
 line-height: 19px;
 font-weight: var(--n-title-font-weight);
 `, [Ze("& +", [Ae("content", { marginTop: "9px" })])]), Ae("content", { transition: "color .3s var(--n-bezier)", fontSize: "var(--n-font-size)" })]), Ae("icon", { transition: "color .3s var(--n-bezier)" })]), Wk = Object.assign(Object.assign({}, Jt.props), { title: String, showIcon: { type: Boolean, default: true }, type: { type: String, default: "default" }, bordered: { type: Boolean, default: true }, closable: Boolean, onClose: Function, onAfterLeave: Function, onAfterHide: Function }), Lg = ot({ name: "Alert", inheritAttrs: false, props: Wk, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, mergedBorderedRef: l, inlineThemeDisabled: d, mergedRtlRef: f } = Sr(r), g = Jt("Alert", "-alert", qk, Bw, r, i), p = Tn("Alert", f, i), s = Ee(() => {
    const { common: { cubicBezierEaseInOut: $ }, self: z } = g.value, { fontSize: F, borderRadius: Z, titleFontWeight: q, lineHeight: K, iconSize: te, iconMargin: re, iconMarginRtl: ie, closeIconSize: J, closeBorderRadius: we, closeSize: fe, closeMargin: oe, closeMarginRtl: he, padding: _e } = z, { type: Ue } = r, { left: qe, right: tt } = Io(re);
    return { "--n-bezier": $, "--n-color": z[Vt("color", Ue)], "--n-close-icon-size": J, "--n-close-border-radius": we, "--n-close-color-hover": z[Vt("closeColorHover", Ue)], "--n-close-color-pressed": z[Vt("closeColorPressed", Ue)], "--n-close-icon-color": z[Vt("closeIconColor", Ue)], "--n-close-icon-color-hover": z[Vt("closeIconColorHover", Ue)], "--n-close-icon-color-pressed": z[Vt("closeIconColorPressed", Ue)], "--n-icon-color": z[Vt("iconColor", Ue)], "--n-border": z[Vt("border", Ue)], "--n-title-text-color": z[Vt("titleTextColor", Ue)], "--n-content-text-color": z[Vt("contentTextColor", Ue)], "--n-line-height": K, "--n-border-radius": Z, "--n-font-size": F, "--n-title-font-weight": q, "--n-icon-size": te, "--n-icon-margin": re, "--n-icon-margin-rtl": ie, "--n-close-size": fe, "--n-close-margin": oe, "--n-close-margin-rtl": he, "--n-padding": _e, "--n-icon-margin-left": qe, "--n-icon-margin-right": tt };
  }), C = d ? ai("alert", Ee(() => r.type[0]), s, r) : void 0, P = Ie(true), M = () => {
    const { onAfterLeave: $, onAfterHide: z } = r;
    $ && $(), z && z();
  };
  return { rtlEnabled: p, mergedClsPrefix: i, mergedBordered: l, visible: P, handleCloseClick: () => {
    var $;
    Promise.resolve(($ = r.onClose) === null || $ === void 0 ? void 0 : $.call(r)).then((z) => {
      z !== false && (P.value = false);
    });
  }, handleAfterLeave: () => {
    M();
  }, mergedTheme: g, cssVars: d ? void 0 : s, themeClass: C == null ? void 0 : C.themeClass, onRender: C == null ? void 0 : C.onRender };
}, render() {
  var r;
  return (r = this.onRender) === null || r === void 0 || r.call(this), B(kp, { onAfterLeave: this.handleAfterLeave }, { default: () => {
    const { mergedClsPrefix: i, $slots: l } = this, d = { class: [`${i}-alert`, this.themeClass, this.closable && `${i}-alert--closable`, this.showIcon && `${i}-alert--show-icon`, !this.title && this.closable && `${i}-alert--right-adjust`, this.rtlEnabled && `${i}-alert--rtl`], style: this.cssVars, role: "alert" };
    return this.visible ? B("div", Object.assign({}, is(this.$attrs, d)), this.closable && B(Sp, { clsPrefix: i, class: `${i}-alert__close`, onClick: this.handleCloseClick }), this.bordered && B("div", { class: `${i}-alert__border` }), this.showIcon && B("div", { class: `${i}-alert__icon`, "aria-hidden": "true" }, Zn(l.icon, () => [B(qr, { clsPrefix: i }, { default: () => {
      switch (this.type) {
        case "success":
          return B(s0, null);
        case "info":
          return B(a0, null);
        case "warning":
          return B(Pp, null);
        case "error":
          return B(o0, null);
        default:
          return null;
      }
    } })])), B("div", { class: [`${i}-alert-body`, this.mergedBordered && `${i}-alert-body--bordered`] }, oi(l.header, (f) => {
      const g = f || this.title;
      return g ? B("div", { class: `${i}-alert-body__title` }, g) : null;
    }), l.default && B("div", { class: `${i}-alert-body__content` }, l))) : null;
  } });
} }), tp = $n("n-anchor"), Zk = { title: String, href: String }, rp = ot({ name: "AnchorLink", props: Zk, slots: Object, setup(r, { slots: i }) {
  const l = Ie(null), d = ur(tp), f = zt(r, "href"), g = vi(() => f.value && f.value === d.activeHref.value);
  bS(tp, "collectedLinkHrefs", f), xS(tp, "titleEls", () => l.value), Ht(g, (s) => {
    s && l.value && d.updateBarPosition(l.value);
  });
  function p() {
    r.href !== void 0 && d.setActiveHref(r.href);
  }
  return () => {
    var s;
    const { value: C } = d.mergedClsPrefix;
    return B("div", { class: [`${C}-anchor-link`, g.value && `${C}-anchor-link--active`] }, B("a", { ref: l, class: [`${C}-anchor-link__title`], href: r.href, title: zg(r.title), onClick: p }, { default: () => Zn(i.title, () => [r.title]) }), (s = i.default) === null || s === void 0 ? void 0 : s.call(i));
  };
} });
function Hk(r, i) {
  const { top: l, height: d } = r.getBoundingClientRect(), f = i instanceof HTMLElement ? i.getBoundingClientRect().top : 0;
  return { top: l - f, height: d };
}
const h0 = { type: { type: String, default: "rail" }, showRail: { type: Boolean, default: true }, showBackground: { type: Boolean, default: true }, bound: { type: Number, default: 12 }, internalScrollable: Boolean, ignoreGap: Boolean, offsetTarget: [String, Object, Function] }, Xk = Xd(h0), Yk = ot({ name: "BaseAnchor", props: Object.assign(Object.assign({}, h0), { mergedClsPrefix: { type: String, required: true } }), setup(r) {
  const i = [], l = [], d = Ie(null), f = Ie(null), g = Ie(null), p = Ie(null);
  let s = false;
  const C = Ee(() => r.type === "block"), P = Ee(() => !C.value && r.showRail);
  function M() {
    const { value: K } = g, { value: te } = f;
    K && (K.style.transition = "none"), te && (te.style.transition = "none"), l && l.forEach((re) => {
      re.style.transition = "none";
    }), Wn(() => {
      const { value: re } = g, { value: ie } = f;
      re && (re.offsetWidth, re.style.transition = ""), ie && (ie.offsetWidth, ie.style.transition = ""), l && l.forEach((J) => {
        J.offsetWidth, J.style.transition = "";
      });
    });
  }
  function D(K, te = true) {
    const { value: re } = g, { value: ie } = f, { value: J } = p;
    if (!J || !re) return;
    te || (re.style.transition = "none", ie && (ie.style.transition = "none"));
    const { offsetHeight: we, offsetWidth: fe } = K, { top: oe, left: he } = K.getBoundingClientRect(), { top: _e, left: Ue } = J.getBoundingClientRect(), qe = oe - _e, tt = he - Ue;
    re.style.top = `${qe}px`, re.style.height = `${we}px`, ie && (ie.style.top = `${qe}px`, ie.style.height = `${we}px`, ie.style.maxWidth = `${fe + tt}px`), re.offsetHeight, ie && ie.offsetHeight, te || (re.style.transition = "", ie && (ie.style.transition = ""));
  }
  let L, $ = false, z = false;
  const F = () => {
    if (z) $ = true;
    else {
      if (s) return;
      q(true), z = true, clearTimeout(L), L = setTimeout(() => {
        z = false, $ && ($ = false, F());
      }, 128);
    }
  };
  function Z(K, te = true) {
    const re = /^#([^#]+)$/.exec(K);
    if (!re) return;
    const ie = document.getElementById(re[1]);
    ie && (s = true, d.value = K, ie.scrollIntoView(), te || M(), $ = false, setTimeout(() => {
      s = false;
    }, 0));
  }
  function q(K = true) {
    var te;
    const re = [], ie = Mb((te = r.offsetTarget) !== null && te !== void 0 ? te : document);
    i.forEach((he) => {
      const _e = /#([^#]+)$/.exec(he);
      if (!_e) return;
      const Ue = document.getElementById(_e[1]);
      if (Ue && ie) {
        const { top: qe, height: tt } = Hk(Ue, ie);
        re.push({ top: qe, height: tt, href: he });
      }
    }), re.sort((he, _e) => he.top > _e.top ? 1 : (he.top === _e.top && he.height < _e.height, -1));
    const J = d.value, { bound: we, ignoreGap: fe } = r, oe = re.reduce((he, _e) => _e.top + _e.height < 0 ? fe ? _e : he : _e.top <= we ? he === null ? _e : _e.top === he.top ? _e.href === J ? _e : he : _e.top > he.top ? _e : he : he, null);
    K || M(), oe ? d.value = oe.href : d.value = null;
  }
  return Xr(tp, { activeHref: d, mergedClsPrefix: zt(r, "mergedClsPrefix"), updateBarPosition: D, setActiveHref: Z, collectedLinkHrefs: i, titleEls: l }), Ri(() => {
    document.addEventListener("scroll", F, true), Z(window.location.hash), q(false);
  }), Gy(() => {
    Z(window.location.hash), q(false);
  }), Pn(() => {
    clearTimeout(L), document.removeEventListener("scroll", F, true);
  }), Ht(d, (K) => {
    if (K === null) {
      const { value: te } = f;
      te && !C.value && (te.style.maxWidth = "0");
    }
  }), { selfRef: p, barRef: g, slotRef: f, setActiveHref: Z, activeHref: d, isBlockType: C, mergedShowRail: P };
}, render() {
  var r;
  const { mergedClsPrefix: i, mergedShowRail: l, isBlockType: d, $slots: f } = this, g = B("div", { class: [`${i}-anchor`, d && `${i}-anchor--block`, l && `${i}-anchor--show-rail`], ref: "selfRef" }, l && this.showBackground ? B("div", { ref: "slotRef", class: `${i}-anchor-link-background` }) : null, l ? B("div", { class: `${i}-anchor-rail` }, B("div", { ref: "barRef", class: [`${i}-anchor-rail__bar`, this.activeHref !== null && `${i}-anchor-rail__bar--active`] })) : null, (r = f.default) === null || r === void 0 ? void 0 : r.call(f));
  return this.internalScrollable ? B(uh, null, { default: () => g }) : g;
} }), Kk = ue("anchor", `
 position: relative;
`, [ui("block", `
 padding-left: var(--n-rail-width);
 `, [ue("anchor-link", [Ze("+, >", [ue("anchor-link", `
 margin-top: .5em;
 `)])]), ue("anchor-link-background", `
 max-width: 0;
 border-top-right-radius: 10.5px;
 border-bottom-right-radius: 10.5px;
 `), ui("show-rail", [Ze(">", [ue("anchor-link", "padding-left: 0;")])])]), Ge("block", [ue("anchor-link", `
 margin-bottom: 4px;
 padding: 2px 8px;
 transition: background-color .3s var(--n-bezier);
 background-color: transparent;
 border-radius: var(--n-link-border-radius);
 `, [Ge("active", `
 background-color: var(--n-link-color);
 `)])]), ue("anchor-link-background", `
 position: absolute;
 left: calc(var(--n-rail-width) / 2);
 width: 100%;
 background-color: var(--n-link-color);
 transition:
 top .15s var(--n-bezier),
 max-width .15s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), ue("anchor-rail", `
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 width: var(--n-rail-width);
 border-radius: calc(var(--n-rail-width) / 2);
 overflow: hidden;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [Ae("bar", `
 position: absolute;
 left: 0;
 width: var(--n-rail-width);
 height: 21px;
 background-color: #0000;
 transition: 
 top .15s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [Ge("active", { backgroundColor: "var(--n-rail-color-active)" })])]), ue("anchor-link", `
 padding: var(--n-link-padding);
 position: relative;
 line-height: 1.5;
 font-size: var(--n-link-font-size);
 min-height: 1.5em;
 display: flex;
 flex-direction: column;
 `, [Ge("active", [Ze(">", [Ae("title", `
 color: var(--n-link-text-color-active);
 `)])]), Ae("title", `
 outline: none;
 max-width: 100%;
 text-decoration: none;
 white-space: nowrap;
 text-overflow: ellipsis;
 overflow: hidden;
 cursor: pointer;
 display: inline-block;
 padding-right: 16px;
 transition: color .3s var(--n-bezier);
 color: var(--n-link-text-color);
 `, [Ze("&:hover, &:focus", `
 color: var(--n-link-text-color-hover);
 `), Ze("&:active", `
 color: var(--n-link-text-color-pressed);
 `)])])]), Jk = Object.assign(Object.assign(Object.assign(Object.assign({}, Jt.props), { affix: Boolean }), d0), h0), Ob = ot({ name: "Anchor", props: Jk, setup(r, { slots: i }) {
  const { mergedClsPrefixRef: l, inlineThemeDisabled: d } = Sr(r), f = Jt("Anchor", "-anchor", Kk, Ow, r, l), g = Ie(null), p = Ee(() => {
    const { self: { railColor: C, linkColor: P, railColorActive: M, linkTextColor: D, linkTextColorHover: L, linkTextColorPressed: $, linkTextColorActive: z, linkFontSize: F, railWidth: Z, linkPadding: q, borderRadius: K }, common: { cubicBezierEaseInOut: te } } = f.value;
    return { "--n-link-border-radius": K, "--n-link-color": P, "--n-link-font-size": F, "--n-link-text-color": D, "--n-link-text-color-hover": L, "--n-link-text-color-active": z, "--n-link-text-color-pressed": $, "--n-link-padding": q, "--n-bezier": te, "--n-rail-color": C, "--n-rail-color-active": M, "--n-rail-width": Z };
  }), s = d ? ai("anchor", void 0, p, r) : void 0;
  return { scrollTo(C) {
    var P;
    (P = g.value) === null || P === void 0 || P.setActiveHref(C);
  }, renderAnchor: () => (s == null ? void 0 : s.onRender(), B(Yk, Object.assign({ ref: g, style: d ? void 0 : p.value, class: s == null ? void 0 : s.themeClass.value }, kg(r, Xk), { mergedClsPrefix: l.value }), i)) };
}, render() {
  return this.affix ? B(gk, Object.assign({}, kg(this, mk)), { default: this.renderAnchor }) : this.renderAnchor();
} }), $b = $n("n-input"), Qk = ue("input", `
 max-width: 100%;
 cursor: text;
 line-height: 1.5;
 z-index: auto;
 outline: none;
 box-sizing: border-box;
 position: relative;
 display: inline-flex;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color .3s var(--n-bezier);
 font-size: var(--n-font-size);
 font-weight: var(--n-font-weight);
 --n-padding-vertical: calc((var(--n-height) - 1.5 * var(--n-font-size)) / 2);
`, [Ae("input, textarea", `
 overflow: hidden;
 flex-grow: 1;
 position: relative;
 `), Ae("input-el, textarea-el, input-mirror, textarea-mirror, separator, placeholder", `
 box-sizing: border-box;
 font-size: inherit;
 line-height: 1.5;
 font-family: inherit;
 border: none;
 outline: none;
 background-color: #0000;
 text-align: inherit;
 transition:
 -webkit-text-fill-color .3s var(--n-bezier),
 caret-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 `), Ae("input-el, textarea-el", `
 -webkit-appearance: none;
 scrollbar-width: none;
 width: 100%;
 min-width: 0;
 text-decoration-color: var(--n-text-decoration-color);
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 background-color: transparent;
 `, [Ze("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), Ze("&::placeholder", `
 color: #0000;
 -webkit-text-fill-color: transparent !important;
 `), Ze("&:-webkit-autofill ~", [Ae("placeholder", "display: none;")])]), Ge("round", [ui("textarea", "border-radius: calc(var(--n-height) / 2);")]), Ae("placeholder", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: hidden;
 color: var(--n-placeholder-color);
 `, [Ze("span", `
 width: 100%;
 display: inline-block;
 `)]), Ge("textarea", [Ae("placeholder", "overflow: visible;")]), ui("autosize", "width: 100%;"), Ge("autosize", [Ae("textarea-el, input-el", `
 position: absolute;
 top: 0;
 left: 0;
 height: 100%;
 `)]), ue("input-wrapper", `
 overflow: hidden;
 display: inline-flex;
 flex-grow: 1;
 position: relative;
 padding-left: var(--n-padding-left);
 padding-right: var(--n-padding-right);
 `), Ae("input-mirror", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre;
 pointer-events: none;
 `), Ae("input-el", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [Ze("&[type=password]::-ms-reveal", "display: none;"), Ze("+", [Ae("placeholder", `
 display: flex;
 align-items: center; 
 `)])]), ui("textarea", [Ae("placeholder", "white-space: nowrap;")]), Ae("eye", `
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `), Ge("textarea", "width: 100%;", [ue("input-word-count", `
 position: absolute;
 right: var(--n-padding-right);
 bottom: var(--n-padding-vertical);
 `), Ge("resizable", [ue("input-wrapper", `
 resize: vertical;
 min-height: var(--n-height);
 `)]), Ae("textarea-el, textarea-mirror, placeholder", `
 height: 100%;
 padding-left: 0;
 padding-right: 0;
 padding-top: var(--n-padding-vertical);
 padding-bottom: var(--n-padding-vertical);
 word-break: break-word;
 display: inline-block;
 vertical-align: bottom;
 box-sizing: border-box;
 line-height: var(--n-line-height-textarea);
 margin: 0;
 resize: none;
 white-space: pre-wrap;
 scroll-padding-block-end: var(--n-padding-vertical);
 `), Ae("textarea-mirror", `
 width: 100%;
 pointer-events: none;
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre-wrap;
 overflow-wrap: break-word;
 `)]), Ge("pair", [Ae("input-el, placeholder", "text-align: center;"), Ae("separator", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 white-space: nowrap;
 `, [ue("icon", `
 color: var(--n-icon-color);
 `), ue("base-icon", `
 color: var(--n-icon-color);
 `)])]), Ge("disabled", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [Ae("border", "border: var(--n-border-disabled);"), Ae("input-el, textarea-el", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 text-decoration-color: var(--n-text-color-disabled);
 `), Ae("placeholder", "color: var(--n-placeholder-color-disabled);"), Ae("separator", "color: var(--n-text-color-disabled);", [ue("icon", `
 color: var(--n-icon-color-disabled);
 `), ue("base-icon", `
 color: var(--n-icon-color-disabled);
 `)]), ue("input-word-count", `
 color: var(--n-count-text-color-disabled);
 `), Ae("suffix, prefix", "color: var(--n-text-color-disabled);", [ue("icon", `
 color: var(--n-icon-color-disabled);
 `), ue("internal-icon", `
 color: var(--n-icon-color-disabled);
 `)])]), ui("disabled", [Ae("eye", `
 color: var(--n-icon-color);
 cursor: pointer;
 `, [Ze("&:hover", `
 color: var(--n-icon-color-hover);
 `), Ze("&:active", `
 color: var(--n-icon-color-pressed);
 `)]), Ze("&:hover", [Ae("state-border", "border: var(--n-border-hover);")]), Ge("focus", "background-color: var(--n-color-focus);", [Ae("state-border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), Ae("border, state-border", `
 box-sizing: border-box;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border-radius: inherit;
 border: var(--n-border);
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), Ae("state-border", `
 border-color: #0000;
 z-index: 1;
 `), Ae("prefix", "margin-right: 4px;"), Ae("suffix", `
 margin-left: 4px;
 `), Ae("suffix, prefix", `
 transition: color .3s var(--n-bezier);
 flex-wrap: nowrap;
 flex-shrink: 0;
 line-height: var(--n-height);
 white-space: nowrap;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 color: var(--n-suffix-text-color);
 `, [ue("base-loading", `
 font-size: var(--n-icon-size);
 margin: 0 2px;
 color: var(--n-loading-color);
 `), ue("base-clear", `
 font-size: var(--n-icon-size);
 `, [Ae("placeholder", [ue("base-icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)])]), Ze(">", [ue("icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)]), ue("base-icon", `
 font-size: var(--n-icon-size);
 `)]), ue("input-word-count", `
 pointer-events: none;
 line-height: 1.5;
 font-size: .85em;
 color: var(--n-count-text-color);
 transition: color .3s var(--n-bezier);
 margin-left: 4px;
 font-variant: tabular-nums;
 `), ["warning", "error"].map((r) => Ge(`${r}-status`, [ui("disabled", [ue("base-loading", `
 color: var(--n-loading-color-${r})
 `), Ae("input-el, textarea-el", `
 caret-color: var(--n-caret-color-${r});
 `), Ae("state-border", `
 border: var(--n-border-${r});
 `), Ze("&:hover", [Ae("state-border", `
 border: var(--n-border-hover-${r});
 `)]), Ze("&:focus", `
 background-color: var(--n-color-focus-${r});
 `, [Ae("state-border", `
 box-shadow: var(--n-box-shadow-focus-${r});
 border: var(--n-border-focus-${r});
 `)]), Ge("focus", `
 background-color: var(--n-color-focus-${r});
 `, [Ae("state-border", `
 box-shadow: var(--n-box-shadow-focus-${r});
 border: var(--n-border-focus-${r});
 `)])])]))]), eP = ue("input", [Ge("disabled", [Ae("input-el, textarea-el", `
 -webkit-text-fill-color: var(--n-text-color-disabled);
 `)])]);
function tP(r) {
  let i = 0;
  for (const l of r) i++;
  return i;
}
function $f(r) {
  return r === "" || r == null;
}
function rP(r) {
  const i = Ie(null);
  function l() {
    const { value: g } = r;
    if (!(g == null ? void 0 : g.focus)) {
      f();
      return;
    }
    const { selectionStart: p, selectionEnd: s, value: C } = g;
    if (p == null || s == null) {
      f();
      return;
    }
    i.value = { start: p, end: s, beforeText: C.slice(0, p), afterText: C.slice(s) };
  }
  function d() {
    var g;
    const { value: p } = i, { value: s } = r;
    if (!p || !s) return;
    const { value: C } = s, { start: P, beforeText: M, afterText: D } = p;
    let L = C.length;
    if (C.endsWith(D)) L = C.length - D.length;
    else if (C.startsWith(M)) L = M.length;
    else {
      const $ = M[P - 1], z = C.indexOf($, P - 1);
      z !== -1 && (L = z + 1);
    }
    (g = s.setSelectionRange) === null || g === void 0 || g.call(s, L, L);
  }
  function f() {
    i.value = null;
  }
  return Ht(r, f), { recordCursor: l, restoreCursor: d };
}
const k_ = ot({ name: "InputWordCount", setup(r, { slots: i }) {
  const { mergedValueRef: l, maxlengthRef: d, mergedClsPrefixRef: f, countGraphemesRef: g } = ur($b), p = Ee(() => {
    const { value: s } = l;
    return s === null || Array.isArray(s) ? 0 : (g.value || tP)(s);
  });
  return () => {
    const { value: s } = d, { value: C } = l;
    return B("span", { class: `${f.value}-input-word-count` }, Pg(i.default, { value: C === null || Array.isArray(C) ? "" : C }, () => [s === void 0 ? p.value : `${p.value} / ${s}`]));
  };
} }), iP = Object.assign(Object.assign({}, Jt.props), { bordered: { type: Boolean, default: void 0 }, type: { type: String, default: "text" }, placeholder: [Array, String], defaultValue: { type: [String, Array], default: null }, value: [String, Array], disabled: { type: Boolean, default: void 0 }, size: String, rows: { type: [Number, String], default: 3 }, round: Boolean, minlength: [String, Number], maxlength: [String, Number], clearable: Boolean, autosize: { type: [Boolean, Object], default: false }, pair: Boolean, separator: String, readonly: { type: [String, Boolean], default: false }, passivelyActivated: Boolean, showPasswordOn: String, stateful: { type: Boolean, default: true }, autofocus: Boolean, inputProps: Object, resizable: { type: Boolean, default: true }, showCount: Boolean, loading: { type: Boolean, default: void 0 }, allowInput: Function, renderCount: Function, onMousedown: Function, onKeydown: Function, onKeyup: [Function, Array], onInput: [Function, Array], onFocus: [Function, Array], onBlur: [Function, Array], onClick: [Function, Array], onChange: [Function, Array], onClear: [Function, Array], countGraphemes: Function, status: String, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], textDecoration: [String, Array], attrSize: { type: Number, default: 20 }, onInputBlur: [Function, Array], onInputFocus: [Function, Array], onDeactivate: [Function, Array], onActivate: [Function, Array], onWrapperFocus: [Function, Array], onWrapperBlur: [Function, Array], internalDeactivateOnEnter: Boolean, internalForceFocus: Boolean, internalLoadingBeforeSuffix: { type: Boolean, default: true }, showPasswordToggle: Boolean }), _o = ot({ name: "Input", props: iP, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, mergedBorderedRef: l, inlineThemeDisabled: d, mergedRtlRef: f } = Sr(r), g = Jt("Input", "-input", Qk, $w, r, i);
  jw && yc("-input-safari", eP, i);
  const p = Ie(null), s = Ie(null), C = Ie(null), P = Ie(null), M = Ie(null), D = Ie(null), L = Ie(null), $ = rP(L), z = Ie(null), { localeRef: F } = as("Input"), Z = Ie(r.defaultValue), q = zt(r, "value"), K = Ji(q, Z), te = ka(r), { mergedSizeRef: re, mergedDisabledRef: ie, mergedStatusRef: J } = te, we = Ie(false), fe = Ie(false), oe = Ie(false), he = Ie(false);
  let _e = null;
  const Ue = Ee(() => {
    const { placeholder: Ne, pair: Te } = r;
    return Te ? Array.isArray(Ne) ? Ne : Ne === void 0 ? ["", ""] : [Ne, Ne] : Ne === void 0 ? [F.value.placeholder] : [Ne];
  }), qe = Ee(() => {
    const { value: Ne } = oe, { value: Te } = K, { value: jt } = Ue;
    return !Ne && ($f(Te) || Array.isArray(Te) && $f(Te[0])) && jt[0];
  }), tt = Ee(() => {
    const { value: Ne } = oe, { value: Te } = K, { value: jt } = Ue;
    return !Ne && jt[1] && ($f(Te) || Array.isArray(Te) && $f(Te[1]));
  }), ut = vi(() => r.internalForceFocus || we.value), mt = vi(() => {
    if (ie.value || r.readonly || !r.clearable || !ut.value && !fe.value) return false;
    const { value: Ne } = K, { value: Te } = ut;
    return r.pair ? !!(Array.isArray(Ne) && (Ne[0] || Ne[1])) && (fe.value || Te) : !!Ne && (fe.value || Te);
  }), St = Ee(() => {
    const { showPasswordOn: Ne } = r;
    if (Ne) return Ne;
    if (r.showPasswordToggle) return "click";
  }), st = Ie(false), nt = Ee(() => {
    const { textDecoration: Ne } = r;
    return Ne ? Array.isArray(Ne) ? Ne.map((Te) => ({ textDecoration: Te })) : [{ textDecoration: Ne }] : ["", ""];
  }), ft = Ie(void 0), Lt = () => {
    var Ne, Te;
    if (r.type === "textarea") {
      const { autosize: jt } = r;
      if (jt && (ft.value = (Te = (Ne = z.value) === null || Ne === void 0 ? void 0 : Ne.$el) === null || Te === void 0 ? void 0 : Te.offsetWidth), !s.value || typeof jt == "boolean") return;
      const { paddingTop: _r, paddingBottom: Nr, lineHeight: mr } = window.getComputedStyle(s.value), Ct = Number(_r.slice(0, -2)), ar = Number(Nr.slice(0, -2)), lr = Number(mr.slice(0, -2)), { value: Bi } = C;
      if (!Bi) return;
      if (jt.minRows) {
        const jn = Math.max(jt.minRows, 1), In = `${Ct + ar + lr * jn}px`;
        Bi.style.minHeight = In;
      }
      if (jt.maxRows) {
        const jn = `${Ct + ar + lr * jt.maxRows}px`;
        Bi.style.maxHeight = jn;
      }
    }
  }, pt = Ee(() => {
    const { maxlength: Ne } = r;
    return Ne === void 0 ? void 0 : Number(Ne);
  });
  Ri(() => {
    const { value: Ne } = K;
    Array.isArray(Ne) || rr(Ne);
  });
  const wt = lh().proxy;
  function Ft(Ne, Te) {
    const { onUpdateValue: jt, "onUpdate:value": _r, onInput: Nr } = r, { nTriggerFormInput: mr } = te;
    jt && Ot(jt, Ne, Te), _r && Ot(_r, Ne, Te), Nr && Ot(Nr, Ne, Te), Z.value = Ne, mr();
  }
  function tr(Ne, Te) {
    const { onChange: jt } = r, { nTriggerFormChange: _r } = te;
    jt && Ot(jt, Ne, Te), Z.value = Ne, _r();
  }
  function gt(Ne) {
    const { onBlur: Te } = r, { nTriggerFormBlur: jt } = te;
    Te && Ot(Te, Ne), jt();
  }
  function Bt(Ne) {
    const { onFocus: Te } = r, { nTriggerFormFocus: jt } = te;
    Te && Ot(Te, Ne), jt();
  }
  function Zt(Ne) {
    const { onClear: Te } = r;
    Te && Ot(Te, Ne);
  }
  function ir(Ne) {
    const { onInputBlur: Te } = r;
    Te && Ot(Te, Ne);
  }
  function Cr(Ne) {
    const { onInputFocus: Te } = r;
    Te && Ot(Te, Ne);
  }
  function Ar() {
    const { onDeactivate: Ne } = r;
    Ne && Ot(Ne);
  }
  function or() {
    const { onActivate: Ne } = r;
    Ne && Ot(Ne);
  }
  function Tr(Ne) {
    const { onClick: Te } = r;
    Te && Ot(Te, Ne);
  }
  function Xt(Ne) {
    const { onWrapperFocus: Te } = r;
    Te && Ot(Te, Ne);
  }
  function Dr(Ne) {
    const { onWrapperBlur: Te } = r;
    Te && Ot(Te, Ne);
  }
  function nr() {
    oe.value = true;
  }
  function kt(Ne) {
    oe.value = false, Ne.target === D.value ? ze(Ne, 1) : ze(Ne, 0);
  }
  function ze(Ne, Te = 0, jt = "input") {
    const _r = Ne.target.value;
    if (rr(_r), Ne instanceof InputEvent && !Ne.isComposing && (oe.value = false), r.type === "textarea") {
      const { value: mr } = z;
      mr && mr.syncUnifiedContainer();
    }
    if (_e = _r, oe.value) return;
    $.recordCursor();
    const Nr = at(_r);
    if (Nr) if (!r.pair) jt === "input" ? Ft(_r, { source: Te }) : tr(_r, { source: Te });
    else {
      let { value: mr } = K;
      Array.isArray(mr) ? mr = [mr[0], mr[1]] : mr = ["", ""], mr[Te] = _r, jt === "input" ? Ft(mr, { source: Te }) : tr(mr, { source: Te });
    }
    wt.$forceUpdate(), Nr || Wn($.restoreCursor);
  }
  function at(Ne) {
    const { countGraphemes: Te, maxlength: jt, minlength: _r } = r;
    if (Te) {
      let mr;
      if (jt !== void 0 && (mr === void 0 && (mr = Te(Ne)), mr > Number(jt)) || _r !== void 0 && (mr === void 0 && (mr = Te(Ne)), mr < Number(jt))) return false;
    }
    const { allowInput: Nr } = r;
    return typeof Nr == "function" ? Nr(Ne) : true;
  }
  function Oe(Ne) {
    ir(Ne), Ne.relatedTarget === p.value && Ar(), Ne.relatedTarget !== null && (Ne.relatedTarget === M.value || Ne.relatedTarget === D.value || Ne.relatedTarget === s.value) || (he.value = false), rt(Ne, "blur"), L.value = null;
  }
  function Je(Ne, Te) {
    Cr(Ne), we.value = true, he.value = true, or(), rt(Ne, "focus"), Te === 0 ? L.value = M.value : Te === 1 ? L.value = D.value : Te === 2 && (L.value = s.value);
  }
  function ht(Ne) {
    r.passivelyActivated && (Dr(Ne), rt(Ne, "blur"));
  }
  function bt(Ne) {
    r.passivelyActivated && (we.value = true, Xt(Ne), rt(Ne, "focus"));
  }
  function rt(Ne, Te) {
    Ne.relatedTarget !== null && (Ne.relatedTarget === M.value || Ne.relatedTarget === D.value || Ne.relatedTarget === s.value || Ne.relatedTarget === p.value) || (Te === "focus" ? (Bt(Ne), we.value = true) : Te === "blur" && (gt(Ne), we.value = false));
  }
  function vt(Ne, Te) {
    ze(Ne, Te, "change");
  }
  function Wt(Ne) {
    Tr(Ne);
  }
  function ci(Ne) {
    Zt(Ne), Ai();
  }
  function Ai() {
    r.pair ? (Ft(["", ""], { source: "clear" }), tr(["", ""], { source: "clear" })) : (Ft("", { source: "clear" }), tr("", { source: "clear" }));
  }
  function sn(Ne) {
    const { onMousedown: Te } = r;
    Te && Te(Ne);
    const { tagName: jt } = Ne.target;
    if (jt !== "INPUT" && jt !== "TEXTAREA") {
      if (r.resizable) {
        const { value: _r } = p;
        if (_r) {
          const { left: Nr, top: mr, width: Ct, height: ar } = _r.getBoundingClientRect(), lr = 14;
          if (Nr + Ct - lr < Ne.clientX && Ne.clientX < Nr + Ct && mr + ar - lr < Ne.clientY && Ne.clientY < mr + ar) return;
        }
      }
      Ne.preventDefault(), we.value || xe();
    }
  }
  function Fe() {
    var Ne;
    fe.value = true, r.type === "textarea" && ((Ne = z.value) === null || Ne === void 0 || Ne.handleMouseEnterWrapper());
  }
  function X() {
    var Ne;
    fe.value = false, r.type === "textarea" && ((Ne = z.value) === null || Ne === void 0 || Ne.handleMouseLeaveWrapper());
  }
  function Y() {
    ie.value || St.value === "click" && (st.value = !st.value);
  }
  function ne(Ne) {
    if (ie.value) return;
    Ne.preventDefault();
    const Te = (_r) => {
      _r.preventDefault(), eo("mouseup", document, Te);
    };
    if (Bn("mouseup", document, Te), St.value !== "mousedown") return;
    st.value = true;
    const jt = () => {
      st.value = false, eo("mouseup", document, jt);
    };
    Bn("mouseup", document, jt);
  }
  function ve(Ne) {
    r.onKeyup && Ot(r.onKeyup, Ne);
  }
  function Ce(Ne) {
    switch (r.onKeydown && Ot(r.onKeydown, Ne), Ne.key) {
      case "Escape":
        Pe();
        break;
      case "Enter":
        ae(Ne);
        break;
    }
  }
  function ae(Ne) {
    var Te, jt;
    if (r.passivelyActivated) {
      const { value: _r } = he;
      if (_r) {
        r.internalDeactivateOnEnter && Pe();
        return;
      }
      Ne.preventDefault(), r.type === "textarea" ? (Te = s.value) === null || Te === void 0 || Te.focus() : (jt = M.value) === null || jt === void 0 || jt.focus();
    }
  }
  function Pe() {
    r.passivelyActivated && (he.value = false, Wn(() => {
      var Ne;
      (Ne = p.value) === null || Ne === void 0 || Ne.focus();
    }));
  }
  function xe() {
    var Ne, Te, jt;
    ie.value || (r.passivelyActivated ? (Ne = p.value) === null || Ne === void 0 || Ne.focus() : ((Te = s.value) === null || Te === void 0 || Te.focus(), (jt = M.value) === null || jt === void 0 || jt.focus()));
  }
  function Ve() {
    var Ne;
    !((Ne = p.value) === null || Ne === void 0) && Ne.contains(document.activeElement) && document.activeElement.blur();
  }
  function et() {
    var Ne, Te;
    (Ne = s.value) === null || Ne === void 0 || Ne.select(), (Te = M.value) === null || Te === void 0 || Te.select();
  }
  function We() {
    ie.value || (s.value ? s.value.focus() : M.value && M.value.focus());
  }
  function xt() {
    const { value: Ne } = p;
    (Ne == null ? void 0 : Ne.contains(document.activeElement)) && Ne !== document.activeElement && Pe();
  }
  function Le(Ne) {
    if (r.type === "textarea") {
      const { value: Te } = s;
      Te == null ? void 0 : Te.scrollTo(Ne);
    } else {
      const { value: Te } = M;
      Te == null ? void 0 : Te.scrollTo(Ne);
    }
  }
  function rr(Ne) {
    const { type: Te, pair: jt, autosize: _r } = r;
    if (!jt && _r) if (Te === "textarea") {
      const { value: Nr } = C;
      Nr && (Nr.textContent = `${Ne ?? ""}\r
`);
    } else {
      const { value: Nr } = P;
      Nr && (Ne ? Nr.textContent = Ne : Nr.innerHTML = "&nbsp;");
    }
  }
  function Zr() {
    Lt();
  }
  const Ut = Ie({ top: "0" });
  function dr(Ne) {
    var Te;
    const { scrollTop: jt } = Ne.target;
    Ut.value.top = `${-jt}px`, (Te = z.value) === null || Te === void 0 || Te.syncUnifiedContainer();
  }
  let Er = null;
  bo(() => {
    const { autosize: Ne, type: Te } = r;
    Ne && Te === "textarea" ? Er = Ht(K, (jt) => {
      !Array.isArray(jt) && jt !== _e && rr(jt);
    }) : Er == null ? void 0 : Er();
  });
  let jr = null;
  bo(() => {
    r.type === "textarea" ? jr = Ht(K, (Ne) => {
      var Te;
      !Array.isArray(Ne) && Ne !== _e && ((Te = z.value) === null || Te === void 0 || Te.syncUnifiedContainer());
    }) : jr == null ? void 0 : jr();
  }), Xr($b, { mergedValueRef: K, maxlengthRef: pt, mergedClsPrefixRef: i, countGraphemesRef: zt(r, "countGraphemes") });
  const di = { wrapperElRef: p, inputElRef: M, textareaElRef: s, isCompositing: oe, clear: Ai, focus: xe, blur: Ve, select: et, deactivate: xt, activate: We, scrollTo: Le }, Hr = Tn("Input", f, i), Jr = Ee(() => {
    const { value: Ne } = re, { common: { cubicBezierEaseInOut: Te }, self: { color: jt, borderRadius: _r, textColor: Nr, caretColor: mr, caretColorError: Ct, caretColorWarning: ar, textDecorationColor: lr, border: Bi, borderDisabled: jn, borderHover: In, borderFocus: hr, placeholderColor: Ao, placeholderColorDisabled: no, lineHeightTextarea: Mn, colorDisabled: Hn, colorFocus: Xn, textColorDisabled: En, boxShadowFocus: ls, iconSize: Vi, colorFocusWarning: ti, boxShadowFocusWarning: ia, borderWarning: Do, borderFocusWarning: xi, borderHoverWarning: zo, colorFocusError: oo, boxShadowFocusError: na, borderError: Gs, borderFocusError: Ul, borderHoverError: oa, clearSize: qs, clearColor: Cc, clearColorHover: Gl, clearColorPressed: Sc, iconColor: ql, iconColorDisabled: Wl, suffixTextColor: Ws, countTextColor: Zs, countTextColorDisabled: Zl, iconColorHover: Hs, iconColorPressed: us, loadingColor: Ia, loadingColorError: Ma, loadingColorWarning: cs, fontWeight: aa, [Vt("padding", Ne)]: sa, [Vt("fontSize", Ne)]: Hl, [Vt("height", Ne)]: kc } } = g.value, { left: ao, right: Fo } = Io(sa);
    return { "--n-bezier": Te, "--n-count-text-color": Zs, "--n-count-text-color-disabled": Zl, "--n-color": jt, "--n-font-size": Hl, "--n-font-weight": aa, "--n-border-radius": _r, "--n-height": kc, "--n-padding-left": ao, "--n-padding-right": Fo, "--n-text-color": Nr, "--n-caret-color": mr, "--n-text-decoration-color": lr, "--n-border": Bi, "--n-border-disabled": jn, "--n-border-hover": In, "--n-border-focus": hr, "--n-placeholder-color": Ao, "--n-placeholder-color-disabled": no, "--n-icon-size": Vi, "--n-line-height-textarea": Mn, "--n-color-disabled": Hn, "--n-color-focus": Xn, "--n-text-color-disabled": En, "--n-box-shadow-focus": ls, "--n-loading-color": Ia, "--n-caret-color-warning": ar, "--n-color-focus-warning": ti, "--n-box-shadow-focus-warning": ia, "--n-border-warning": Do, "--n-border-focus-warning": xi, "--n-border-hover-warning": zo, "--n-loading-color-warning": cs, "--n-caret-color-error": Ct, "--n-color-focus-error": oo, "--n-box-shadow-focus-error": na, "--n-border-error": Gs, "--n-border-focus-error": Ul, "--n-border-hover-error": oa, "--n-loading-color-error": Ma, "--n-clear-color": Cc, "--n-clear-size": qs, "--n-clear-color-hover": Gl, "--n-clear-color-pressed": Sc, "--n-icon-color": ql, "--n-icon-color-hover": Hs, "--n-icon-color-pressed": us, "--n-icon-color-disabled": Wl, "--n-suffix-text-color": Ws };
  }), Lr = d ? ai("input", Ee(() => {
    const { value: Ne } = re;
    return Ne[0];
  }), Jr, r) : void 0;
  return Object.assign(Object.assign({}, di), { wrapperElRef: p, inputElRef: M, inputMirrorElRef: P, inputEl2Ref: D, textareaElRef: s, textareaMirrorElRef: C, textareaScrollbarInstRef: z, rtlEnabled: Hr, uncontrolledValue: Z, mergedValue: K, passwordVisible: st, mergedPlaceholder: Ue, showPlaceholder1: qe, showPlaceholder2: tt, mergedFocus: ut, isComposing: oe, activated: he, showClearButton: mt, mergedSize: re, mergedDisabled: ie, textDecorationStyle: nt, mergedClsPrefix: i, mergedBordered: l, mergedShowPasswordOn: St, placeholderStyle: Ut, mergedStatus: J, textAreaScrollContainerWidth: ft, handleTextAreaScroll: dr, handleCompositionStart: nr, handleCompositionEnd: kt, handleInput: ze, handleInputBlur: Oe, handleInputFocus: Je, handleWrapperBlur: ht, handleWrapperFocus: bt, handleMouseEnter: Fe, handleMouseLeave: X, handleMouseDown: sn, handleChange: vt, handleClick: Wt, handleClear: ci, handlePasswordToggleClick: Y, handlePasswordToggleMousedown: ne, handleWrapperKeydown: Ce, handleWrapperKeyup: ve, handleTextAreaMirrorResize: Zr, getTextareaScrollContainer: () => s.value, mergedTheme: g, cssVars: d ? void 0 : Jr, themeClass: Lr == null ? void 0 : Lr.themeClass, onRender: Lr == null ? void 0 : Lr.onRender });
}, render() {
  var r, i, l, d, f, g, p;
  const { mergedClsPrefix: s, mergedStatus: C, themeClass: P, type: M, countGraphemes: D, onRender: L } = this, $ = this.$slots;
  return L == null ? void 0 : L(), B("div", { ref: "wrapperElRef", class: [`${s}-input`, P, C && `${s}-input--${C}-status`, { [`${s}-input--rtl`]: this.rtlEnabled, [`${s}-input--disabled`]: this.mergedDisabled, [`${s}-input--textarea`]: M === "textarea", [`${s}-input--resizable`]: this.resizable && !this.autosize, [`${s}-input--autosize`]: this.autosize, [`${s}-input--round`]: this.round && M !== "textarea", [`${s}-input--pair`]: this.pair, [`${s}-input--focus`]: this.mergedFocus, [`${s}-input--stateful`]: this.stateful }], style: this.cssVars, tabindex: !this.mergedDisabled && this.passivelyActivated && !this.activated ? 0 : void 0, onFocus: this.handleWrapperFocus, onBlur: this.handleWrapperBlur, onClick: this.handleClick, onMousedown: this.handleMouseDown, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd, onKeyup: this.handleWrapperKeyup, onKeydown: this.handleWrapperKeydown }, B("div", { class: `${s}-input-wrapper` }, oi($.prefix, (z) => z && B("div", { class: `${s}-input__prefix` }, z)), M === "textarea" ? B(uh, { ref: "textareaScrollbarInstRef", class: `${s}-input__textarea`, container: this.getTextareaScrollContainer, theme: (i = (r = this.theme) === null || r === void 0 ? void 0 : r.peers) === null || i === void 0 ? void 0 : i.Scrollbar, themeOverrides: (d = (l = this.themeOverrides) === null || l === void 0 ? void 0 : l.peers) === null || d === void 0 ? void 0 : d.Scrollbar, triggerDisplayManually: true, useUnifiedContainer: true, internalHoistYRail: true }, { default: () => {
    var z, F;
    const { textAreaScrollContainerWidth: Z } = this, q = { width: this.autosize && Z && `${Z}px` };
    return B(Wr, null, B("textarea", Object.assign({}, this.inputProps, { ref: "textareaElRef", class: [`${s}-input__textarea-el`, (z = this.inputProps) === null || z === void 0 ? void 0 : z.class], autofocus: this.autofocus, rows: Number(this.rows), placeholder: this.placeholder, value: this.mergedValue, disabled: this.mergedDisabled, maxlength: D ? void 0 : this.maxlength, minlength: D ? void 0 : this.minlength, readonly: this.readonly, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, style: [this.textDecorationStyle[0], (F = this.inputProps) === null || F === void 0 ? void 0 : F.style, q], onBlur: this.handleInputBlur, onFocus: (K) => {
      this.handleInputFocus(K, 2);
    }, onInput: this.handleInput, onChange: this.handleChange, onScroll: this.handleTextAreaScroll })), this.showPlaceholder1 ? B("div", { class: `${s}-input__placeholder`, style: [this.placeholderStyle, q], key: "placeholder" }, this.mergedPlaceholder[0]) : null, this.autosize ? B(Dl, { onResize: this.handleTextAreaMirrorResize }, { default: () => B("div", { ref: "textareaMirrorElRef", class: `${s}-input__textarea-mirror`, key: "mirror" }) }) : null);
  } }) : B("div", { class: `${s}-input__input` }, B("input", Object.assign({ type: M === "password" && this.mergedShowPasswordOn && this.passwordVisible ? "text" : M }, this.inputProps, { ref: "inputElRef", class: [`${s}-input__input-el`, (f = this.inputProps) === null || f === void 0 ? void 0 : f.class], style: [this.textDecorationStyle[0], (g = this.inputProps) === null || g === void 0 ? void 0 : g.style], tabindex: this.passivelyActivated && !this.activated ? -1 : (p = this.inputProps) === null || p === void 0 ? void 0 : p.tabindex, placeholder: this.mergedPlaceholder[0], disabled: this.mergedDisabled, maxlength: D ? void 0 : this.maxlength, minlength: D ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[0] : this.mergedValue, readonly: this.readonly, autofocus: this.autofocus, size: this.attrSize, onBlur: this.handleInputBlur, onFocus: (z) => {
    this.handleInputFocus(z, 0);
  }, onInput: (z) => {
    this.handleInput(z, 0);
  }, onChange: (z) => {
    this.handleChange(z, 0);
  } })), this.showPlaceholder1 ? B("div", { class: `${s}-input__placeholder` }, B("span", null, this.mergedPlaceholder[0])) : null, this.autosize ? B("div", { class: `${s}-input__input-mirror`, key: "mirror", ref: "inputMirrorElRef" }, "\xA0") : null), !this.pair && oi($.suffix, (z) => z || this.clearable || this.showCount || this.mergedShowPasswordOn || this.loading !== void 0 ? B("div", { class: `${s}-input__suffix` }, [oi($["clear-icon-placeholder"], (F) => (this.clearable || F) && B(Fg, { clsPrefix: s, show: this.showClearButton, onClear: this.handleClear }, { placeholder: () => F, icon: () => {
    var Z, q;
    return (q = (Z = this.$slots)["clear-icon"]) === null || q === void 0 ? void 0 : q.call(Z);
  } })), this.internalLoadingBeforeSuffix ? null : z, this.loading !== void 0 ? B(Bb, { clsPrefix: s, loading: this.loading, showArrow: false, showClear: false, style: this.cssVars }) : null, this.internalLoadingBeforeSuffix ? z : null, this.showCount && this.type !== "textarea" ? B(k_, null, { default: (F) => {
    var Z;
    const { renderCount: q } = this;
    return q ? q(F) : (Z = $.count) === null || Z === void 0 ? void 0 : Z.call($, F);
  } }) : null, this.mergedShowPasswordOn && this.type === "password" ? B("div", { class: `${s}-input__eye`, onMousedown: this.handlePasswordToggleMousedown, onClick: this.handlePasswordToggleClick }, this.passwordVisible ? Zn($["password-visible-icon"], () => [B(qr, { clsPrefix: s }, { default: () => B(Fb, null) })]) : Zn($["password-invisible-icon"], () => [B(qr, { clsPrefix: s }, { default: () => B(Sk, null) })])) : null]) : null)), this.pair ? B("span", { class: `${s}-input__separator` }, Zn($.separator, () => [this.separator])) : null, this.pair ? B("div", { class: `${s}-input-wrapper` }, B("div", { class: `${s}-input__input` }, B("input", { ref: "inputEl2Ref", type: this.type, class: `${s}-input__input-el`, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, placeholder: this.mergedPlaceholder[1], disabled: this.mergedDisabled, maxlength: D ? void 0 : this.maxlength, minlength: D ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[1] : void 0, readonly: this.readonly, style: this.textDecorationStyle[1], onBlur: this.handleInputBlur, onFocus: (z) => {
    this.handleInputFocus(z, 1);
  }, onInput: (z) => {
    this.handleInput(z, 1);
  }, onChange: (z) => {
    this.handleChange(z, 1);
  } }), this.showPlaceholder2 ? B("div", { class: `${s}-input__placeholder` }, B("span", null, this.mergedPlaceholder[1])) : null), oi($.suffix, (z) => (this.clearable || z) && B("div", { class: `${s}-input__suffix` }, [this.clearable && B(Fg, { clsPrefix: s, show: this.showClearButton, onClear: this.handleClear }, { icon: () => {
    var F;
    return (F = $["clear-icon"]) === null || F === void 0 ? void 0 : F.call($);
  }, placeholder: () => {
    var F;
    return (F = $["clear-icon-placeholder"]) === null || F === void 0 ? void 0 : F.call($);
  } }), z]))) : null, this.mergedBordered ? B("div", { class: `${s}-input__border` }) : null, this.mergedBordered ? B("div", { class: `${s}-input__state-border` }) : null, this.showCount && M === "textarea" ? B(k_, null, { default: (z) => {
    var F;
    const { renderCount: Z } = this;
    return Z ? Z(z) : (F = $.count) === null || F === void 0 ? void 0 : F.call($, z);
  } }) : null);
} }), nP = ue("input-group", `
 display: inline-flex;
 width: 100%;
 flex-wrap: nowrap;
 vertical-align: bottom;
`, [Ze(">", [ue("input", [Ze("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), Ze("&:not(:first-child)", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 margin-left: -1px!important;
 `)]), ue("button", [Ze("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `, [Ae("state-border, border", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `)]), Ze("&:not(:first-child)", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `, [Ae("state-border, border", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `)])]), Ze("*", [Ze("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `, [Ze(">", [ue("input", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), ue("base-selection", [ue("base-selection-label", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), ue("base-selection-tags", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), Ae("box-shadow, border, state-border", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `)])])]), Ze("&:not(:first-child)", `
 margin-left: -1px!important;
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `, [Ze(">", [ue("input", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), ue("base-selection", [ue("base-selection-label", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), ue("base-selection-tags", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), Ae("box-shadow, border, state-border", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `)])])])])])]), oP = {}, aP = ot({ name: "InputGroup", props: oP, setup(r) {
  const { mergedClsPrefixRef: i } = Sr(r);
  return yc("-input-group", nP, i), { mergedClsPrefix: i };
}, render() {
  const { mergedClsPrefix: r } = this;
  return B("div", { class: `${r}-input-group` }, this.$slots);
} });
function hp(r) {
  return r.type === "group";
}
function jb(r) {
  return r.type === "ignored";
}
function Qm(r, i) {
  try {
    return !!(1 + i.toString().toLowerCase().indexOf(r.trim().toLowerCase()));
  } catch {
    return false;
  }
}
function sP(r, i) {
  return { getIsGroup: hp, getIgnored: jb, getKey(d) {
    return hp(d) ? d.name || d.key || "key-required" : d[r];
  }, getChildren(d) {
    return d[i];
  } };
}
function lP(r, i, l, d) {
  if (!i) return r;
  function f(g) {
    if (!Array.isArray(g)) return [];
    const p = [];
    for (const s of g) if (hp(s)) {
      const C = f(s[d]);
      C.length && p.push(Object.assign({}, s, { [d]: C }));
    } else {
      if (jb(s)) continue;
      i(l, s) && p.push(s);
    }
    return p;
  }
  return f(r);
}
function uP(r, i, l) {
  const d = /* @__PURE__ */ new Map();
  return r.forEach((f) => {
    hp(f) ? f[l].forEach((g) => {
      d.set(g[i], g);
    }) : d.set(f[i], f);
  }), d;
}
const cP = Tp && "loading" in document.createElement("img");
function dP(r = {}) {
  var i;
  const { root: l = null } = r;
  return { hash: `${r.rootMargin || "0px 0px 0px 0px"}-${Array.isArray(r.threshold) ? r.threshold.join(",") : (i = r.threshold) !== null && i !== void 0 ? i : "0"}`, options: Object.assign(Object.assign({}, r), { root: (typeof l == "string" ? document.querySelector(l) : l) || document.documentElement }) };
}
const eg = /* @__PURE__ */ new WeakMap(), tg = /* @__PURE__ */ new WeakMap(), rg = /* @__PURE__ */ new WeakMap(), hP = (r, i, l) => {
  if (!r) return () => {
  };
  const d = dP(i), { root: f } = d.options;
  let g;
  const p = eg.get(f);
  p ? g = p : (g = /* @__PURE__ */ new Map(), eg.set(f, g));
  let s, C;
  g.has(d.hash) ? (C = g.get(d.hash), C[1].has(r) || (s = C[0], C[1].add(r), s.observe(r))) : (s = new IntersectionObserver((D) => {
    D.forEach((L) => {
      if (L.isIntersecting) {
        const $ = tg.get(L.target), z = rg.get(L.target);
        $ && $(), z && (z.value = true);
      }
    });
  }, d.options), s.observe(r), C = [s, /* @__PURE__ */ new Set([r])], g.set(d.hash, C));
  let P = false;
  const M = () => {
    P || (tg.delete(r), rg.delete(r), P = true, C[1].has(r) && (C[0].unobserve(r), C[1].delete(r)), C[1].size <= 0 && g.delete(d.hash), g.size || eg.delete(f));
  };
  return tg.set(r, M), rg.set(r, l), M;
}, Ei = "0!important", Nb = "-1px!important";
function Qu(r) {
  return Ge(`${r}-type`, [Ze("& +", [ue("button", {}, [Ge(`${r}-type`, [Ae("border", { borderLeftWidth: Ei }), Ae("state-border", { left: Nb })])])])]);
}
function ec(r) {
  return Ge(`${r}-type`, [Ze("& +", [ue("button", [Ge(`${r}-type`, [Ae("border", { borderTopWidth: Ei }), Ae("state-border", { top: Nb })])])])]);
}
const fP = ue("button-group", `
 flex-wrap: nowrap;
 display: inline-flex;
 position: relative;
`, [ui("vertical", { flexDirection: "row" }, [ui("rtl", [ue("button", [Ze("&:first-child:not(:last-child)", `
 margin-right: ${Ei};
 border-top-right-radius: ${Ei};
 border-bottom-right-radius: ${Ei};
 `), Ze("&:last-child:not(:first-child)", `
 margin-left: ${Ei};
 border-top-left-radius: ${Ei};
 border-bottom-left-radius: ${Ei};
 `), Ze("&:not(:first-child):not(:last-child)", `
 margin-left: ${Ei};
 margin-right: ${Ei};
 border-radius: ${Ei};
 `), Qu("default"), Ge("ghost", [Qu("primary"), Qu("info"), Qu("success"), Qu("warning"), Qu("error")])])])]), Ge("vertical", { flexDirection: "column" }, [ue("button", [Ze("&:first-child:not(:last-child)", `
 margin-bottom: ${Ei};
 margin-left: ${Ei};
 margin-right: ${Ei};
 border-bottom-left-radius: ${Ei};
 border-bottom-right-radius: ${Ei};
 `), Ze("&:last-child:not(:first-child)", `
 margin-top: ${Ei};
 margin-left: ${Ei};
 margin-right: ${Ei};
 border-top-left-radius: ${Ei};
 border-top-right-radius: ${Ei};
 `), Ze("&:not(:first-child):not(:last-child)", `
 margin: ${Ei};
 border-radius: ${Ei};
 `), ec("default"), Ge("ghost", [ec("primary"), ec("info"), ec("success"), ec("warning"), ec("error")])])])]), pP = { size: { type: String, default: void 0 }, vertical: Boolean }, mP = ot({ name: "ButtonGroup", props: pP, setup(r) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Sr(r);
  return yc("-button-group", fP, i), Xr(Nw, r), { rtlEnabled: Tn("ButtonGroup", l, i), mergedClsPrefix: i };
}, render() {
  const { mergedClsPrefix: r } = this;
  return B("div", { class: [`${r}-button-group`, this.rtlEnabled && `${r}-button-group--rtl`, this.vertical && `${r}-button-group--vertical`], role: "group" }, this.$slots);
} }), gP = $n("n-checkbox-group"), vP = () => B("svg", { viewBox: "0 0 64 64", class: "check-icon" }, B("path", { d: "M50.42,16.76L22.34,39.45l-8.1-11.46c-1.12-1.58-3.3-1.96-4.88-0.84c-1.58,1.12-1.95,3.3-0.84,4.88l10.26,14.51  c0.56,0.79,1.42,1.31,2.38,1.45c0.16,0.02,0.32,0.03,0.48,0.03c0.8,0,1.57-0.27,2.2-0.78l30.99-25.03c1.5-1.21,1.74-3.42,0.52-4.92  C54.13,15.78,51.93,15.55,50.42,16.76z" })), _P = () => B("svg", { viewBox: "0 0 100 100", class: "line-icon" }, B("path", { d: "M80.2,55.5H21.4c-2.8,0-5.1-2.5-5.1-5.5l0,0c0-3,2.3-5.5,5.1-5.5h58.7c2.8,0,5.1,2.5,5.1,5.5l0,0C85.2,53.1,82.9,55.5,80.2,55.5z" })), yP = Ze([ue("checkbox", `
 font-size: var(--n-font-size);
 outline: none;
 cursor: pointer;
 display: inline-flex;
 flex-wrap: nowrap;
 align-items: flex-start;
 word-break: break-word;
 line-height: var(--n-size);
 --n-merged-color-table: var(--n-color-table);
 `, [Ge("show-label", "line-height: var(--n-label-line-height);"), Ze("&:hover", [ue("checkbox-box", [Ae("border", "border: var(--n-border-checked);")])]), Ze("&:focus:not(:active)", [ue("checkbox-box", [Ae("border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), Ge("inside-table", [ue("checkbox-box", `
 background-color: var(--n-merged-color-table);
 `)]), Ge("checked", [ue("checkbox-box", `
 background-color: var(--n-color-checked);
 `, [ue("checkbox-icon", [Ze(".check-icon", `
 opacity: 1;
 transform: scale(1);
 `)])])]), Ge("indeterminate", [ue("checkbox-box", [ue("checkbox-icon", [Ze(".check-icon", `
 opacity: 0;
 transform: scale(.5);
 `), Ze(".line-icon", `
 opacity: 1;
 transform: scale(1);
 `)])])]), Ge("checked, indeterminate", [Ze("&:focus:not(:active)", [ue("checkbox-box", [Ae("border", `
 border: var(--n-border-checked);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), ue("checkbox-box", `
 background-color: var(--n-color-checked);
 border-left: 0;
 border-top: 0;
 `, [Ae("border", { border: "var(--n-border-checked)" })])]), Ge("disabled", { cursor: "not-allowed" }, [Ge("checked", [ue("checkbox-box", `
 background-color: var(--n-color-disabled-checked);
 `, [Ae("border", { border: "var(--n-border-disabled-checked)" }), ue("checkbox-icon", [Ze(".check-icon, .line-icon", { fill: "var(--n-check-mark-color-disabled-checked)" })])])]), ue("checkbox-box", `
 background-color: var(--n-color-disabled);
 `, [Ae("border", `
 border: var(--n-border-disabled);
 `), ue("checkbox-icon", [Ze(".check-icon, .line-icon", `
 fill: var(--n-check-mark-color-disabled);
 `)])]), Ae("label", `
 color: var(--n-text-color-disabled);
 `)]), ue("checkbox-box-wrapper", `
 position: relative;
 width: var(--n-size);
 flex-shrink: 0;
 flex-grow: 0;
 user-select: none;
 -webkit-user-select: none;
 `), ue("checkbox-box", `
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 height: var(--n-size);
 width: var(--n-size);
 display: inline-block;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color 0.3s var(--n-bezier);
 `, [Ae("border", `
 transition:
 border-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border: var(--n-border);
 `), ue("checkbox-icon", `
 display: flex;
 align-items: center;
 justify-content: center;
 position: absolute;
 left: 1px;
 right: 1px;
 top: 1px;
 bottom: 1px;
 `, [Ze(".check-icon, .line-icon", `
 width: 100%;
 fill: var(--n-check-mark-color);
 opacity: 0;
 transform: scale(0.5);
 transform-origin: center;
 transition:
 fill 0.3s var(--n-bezier),
 transform 0.3s var(--n-bezier),
 opacity 0.3s var(--n-bezier),
 border-color 0.3s var(--n-bezier);
 `), Yd({ left: "1px", top: "1px" })])]), Ae("label", `
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 user-select: none;
 -webkit-user-select: none;
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 `, [Ze("&:empty", { display: "none" })])]), qy(ue("checkbox", `
 --n-merged-color-table: var(--n-color-table-modal);
 `)), Wy(ue("checkbox", `
 --n-merged-color-table: var(--n-color-table-popover);
 `))]), bP = Object.assign(Object.assign({}, Jt.props), { size: String, checked: { type: [Boolean, String, Number], default: void 0 }, defaultChecked: { type: [Boolean, String, Number], default: false }, value: [String, Number], disabled: { type: Boolean, default: void 0 }, indeterminate: Boolean, label: String, focusable: { type: Boolean, default: true }, checkedValue: { type: [Boolean, String, Number], default: true }, uncheckedValue: { type: [Boolean, String, Number], default: false }, "onUpdate:checked": [Function, Array], onUpdateChecked: [Function, Array], privateInsideTable: Boolean, onChange: [Function, Array] }), xP = ot({ name: "Checkbox", props: bP, setup(r) {
  const i = ur(gP, null), l = Ie(null), { mergedClsPrefixRef: d, inlineThemeDisabled: f, mergedRtlRef: g } = Sr(r), p = Ie(r.defaultChecked), s = zt(r, "checked"), C = Ji(s, p), P = vi(() => {
    if (i) {
      const J = i.valueSetRef.value;
      return J && r.value !== void 0 ? J.has(r.value) : false;
    } else return C.value === r.checkedValue;
  }), M = ka(r, { mergedSize(J) {
    const { size: we } = r;
    if (we !== void 0) return we;
    if (i) {
      const { value: fe } = i.mergedSizeRef;
      if (fe !== void 0) return fe;
    }
    if (J) {
      const { mergedSize: fe } = J;
      if (fe !== void 0) return fe.value;
    }
    return "medium";
  }, mergedDisabled(J) {
    const { disabled: we } = r;
    if (we !== void 0) return we;
    if (i) {
      if (i.disabledRef.value) return true;
      const { maxRef: { value: fe }, checkedCountRef: oe } = i;
      if (fe !== void 0 && oe.value >= fe && !P.value) return true;
      const { minRef: { value: he } } = i;
      if (he !== void 0 && oe.value <= he && P.value) return true;
    }
    return J ? J.disabled.value : false;
  } }), { mergedDisabledRef: D, mergedSizeRef: L } = M, $ = Jt("Checkbox", "-checkbox", yP, Vw, r, d);
  function z(J) {
    if (i && r.value !== void 0) i.toggleCheckbox(!P.value, r.value);
    else {
      const { onChange: we, "onUpdate:checked": fe, onUpdateChecked: oe } = r, { nTriggerFormInput: he, nTriggerFormChange: _e } = M, Ue = P.value ? r.uncheckedValue : r.checkedValue;
      fe && Ot(fe, Ue, J), oe && Ot(oe, Ue, J), we && Ot(we, Ue, J), he(), _e(), p.value = Ue;
    }
  }
  function F(J) {
    D.value || z(J);
  }
  function Z(J) {
    if (!D.value) switch (J.key) {
      case " ":
      case "Enter":
        z(J);
    }
  }
  function q(J) {
    switch (J.key) {
      case " ":
        J.preventDefault();
    }
  }
  const K = { focus: () => {
    var J;
    (J = l.value) === null || J === void 0 || J.focus();
  }, blur: () => {
    var J;
    (J = l.value) === null || J === void 0 || J.blur();
  } }, te = Tn("Checkbox", g, d), re = Ee(() => {
    const { value: J } = L, { common: { cubicBezierEaseInOut: we }, self: { borderRadius: fe, color: oe, colorChecked: he, colorDisabled: _e, colorTableHeader: Ue, colorTableHeaderModal: qe, colorTableHeaderPopover: tt, checkMarkColor: ut, checkMarkColorDisabled: mt, border: St, borderFocus: st, borderDisabled: nt, borderChecked: ft, boxShadowFocus: Lt, textColor: pt, textColorDisabled: wt, checkMarkColorDisabledChecked: Ft, colorDisabledChecked: tr, borderDisabledChecked: gt, labelPadding: Bt, labelLineHeight: Zt, labelFontWeight: ir, [Vt("fontSize", J)]: Cr, [Vt("size", J)]: Ar } } = $.value;
    return { "--n-label-line-height": Zt, "--n-label-font-weight": ir, "--n-size": Ar, "--n-bezier": we, "--n-border-radius": fe, "--n-border": St, "--n-border-checked": ft, "--n-border-focus": st, "--n-border-disabled": nt, "--n-border-disabled-checked": gt, "--n-box-shadow-focus": Lt, "--n-color": oe, "--n-color-checked": he, "--n-color-table": Ue, "--n-color-table-modal": qe, "--n-color-table-popover": tt, "--n-color-disabled": _e, "--n-color-disabled-checked": tr, "--n-text-color": pt, "--n-text-color-disabled": wt, "--n-check-mark-color": ut, "--n-check-mark-color-disabled": mt, "--n-check-mark-color-disabled-checked": Ft, "--n-font-size": Cr, "--n-label-padding": Bt };
  }), ie = f ? ai("checkbox", Ee(() => L.value[0]), re, r) : void 0;
  return Object.assign(M, K, { rtlEnabled: te, selfRef: l, mergedClsPrefix: d, mergedDisabled: D, renderedChecked: P, mergedTheme: $, labelId: $l(), handleClick: F, handleKeyUp: Z, handleKeyDown: q, cssVars: f ? void 0 : re, themeClass: ie == null ? void 0 : ie.themeClass, onRender: ie == null ? void 0 : ie.onRender });
}, render() {
  var r;
  const { $slots: i, renderedChecked: l, mergedDisabled: d, indeterminate: f, privateInsideTable: g, cssVars: p, labelId: s, label: C, mergedClsPrefix: P, focusable: M, handleKeyUp: D, handleKeyDown: L, handleClick: $ } = this;
  (r = this.onRender) === null || r === void 0 || r.call(this);
  const z = oi(i.default, (F) => C || F ? B("span", { class: `${P}-checkbox__label`, id: s }, C || F) : null);
  return B("div", { ref: "selfRef", class: [`${P}-checkbox`, this.themeClass, this.rtlEnabled && `${P}-checkbox--rtl`, l && `${P}-checkbox--checked`, d && `${P}-checkbox--disabled`, f && `${P}-checkbox--indeterminate`, g && `${P}-checkbox--inside-table`, z && `${P}-checkbox--show-label`], tabindex: d || !M ? void 0 : 0, role: "checkbox", "aria-checked": f ? "mixed" : l, "aria-labelledby": s, style: p, onKeyup: D, onKeydown: L, onClick: $, onMousedown: () => {
    Bn("selectstart", window, (F) => {
      F.preventDefault();
    }, { once: true });
  } }, B("div", { class: `${P}-checkbox-box-wrapper` }, "\xA0", B("div", { class: `${P}-checkbox-box` }, B(xp, null, { default: () => this.indeterminate ? B("div", { key: "indeterminate", class: `${P}-checkbox-icon` }, _P()) : B("div", { key: "check", class: `${P}-checkbox-icon` }, vP()) }), B("div", { class: `${P}-checkbox-box__border` }))), z);
} }), wP = ue("collapse", "width: 100%;", [ue("collapse-item", `
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 margin: var(--n-item-margin);
 `, [Ge("disabled", [Ae("header", "cursor: not-allowed;", [Ae("header-main", `
 color: var(--n-title-text-color-disabled);
 `), ue("collapse-item-arrow", `
 color: var(--n-arrow-color-disabled);
 `)])]), ue("collapse-item", "margin-left: 32px;"), Ze("&:first-child", "margin-top: 0;"), Ze("&:first-child >", [Ae("header", "padding-top: 0;")]), Ge("left-arrow-placement", [Ae("header", [ue("collapse-item-arrow", "margin-right: 4px;")])]), Ge("right-arrow-placement", [Ae("header", [ue("collapse-item-arrow", "margin-left: 4px;")])]), Ae("content-wrapper", [Ae("content-inner", "padding-top: 16px;"), sp({ duration: "0.15s" })]), Ge("active", [Ae("header", [Ge("active", [ue("collapse-item-arrow", "transform: rotate(90deg);")])])]), Ze("&:not(:first-child)", "border-top: 1px solid var(--n-divider-color);"), ui("disabled", [Ge("trigger-area-main", [Ae("header", [Ae("header-main", "cursor: pointer;"), ue("collapse-item-arrow", "cursor: default;")])]), Ge("trigger-area-arrow", [Ae("header", [ue("collapse-item-arrow", "cursor: pointer;")])]), Ge("trigger-area-extra", [Ae("header", [Ae("header-extra", "cursor: pointer;")])])]), Ae("header", `
 font-size: var(--n-title-font-size);
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition: color .3s var(--n-bezier);
 position: relative;
 padding: var(--n-title-padding);
 color: var(--n-title-text-color);
 `, [Ae("header-main", `
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 flex: 1;
 color: var(--n-title-text-color);
 `), Ae("header-extra", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), ue("collapse-item-arrow", `
 display: flex;
 transition:
 transform .15s var(--n-bezier),
 color .3s var(--n-bezier);
 font-size: 18px;
 color: var(--n-arrow-color);
 `)])])]), CP = Object.assign(Object.assign({}, Jt.props), { defaultExpandedNames: { type: [Array, String], default: null }, expandedNames: [Array, String], arrowPlacement: { type: String, default: "left" }, accordion: { type: Boolean, default: false }, displayDirective: { type: String, default: "if" }, triggerAreas: { type: Array, default: () => ["main", "extra", "arrow"] }, onItemHeaderClick: [Function, Array], "onUpdate:expandedNames": [Function, Array], onUpdateExpandedNames: [Function, Array], onExpandedNamesChange: { type: [Function, Array], validator: () => true, default: void 0 } }), Vb = $n("n-collapse"), P_ = ot({ name: "Collapse", props: CP, slots: Object, setup(r, { slots: i }) {
  const { mergedClsPrefixRef: l, inlineThemeDisabled: d, mergedRtlRef: f } = Sr(r), g = Ie(r.defaultExpandedNames), p = Ee(() => r.expandedNames), s = Ji(p, g), C = Jt("Collapse", "-collapse", wP, Uw, r, l);
  function P(F) {
    const { "onUpdate:expandedNames": Z, onUpdateExpandedNames: q, onExpandedNamesChange: K } = r;
    q && Ot(q, F), Z && Ot(Z, F), K && Ot(K, F), g.value = F;
  }
  function M(F) {
    const { onItemHeaderClick: Z } = r;
    Z && Ot(Z, F);
  }
  function D(F, Z, q) {
    const { accordion: K } = r, { value: te } = s;
    if (K) F ? (P([Z]), M({ name: Z, expanded: true, event: q })) : (P([]), M({ name: Z, expanded: false, event: q }));
    else if (!Array.isArray(te)) P([Z]), M({ name: Z, expanded: true, event: q });
    else {
      const re = te.slice(), ie = re.findIndex((J) => Z === J);
      ~ie ? (re.splice(ie, 1), P(re), M({ name: Z, expanded: false, event: q })) : (re.push(Z), P(re), M({ name: Z, expanded: true, event: q }));
    }
  }
  Xr(Vb, { props: r, mergedClsPrefixRef: l, expandedNamesRef: s, slots: i, toggleItem: D });
  const L = Tn("Collapse", f, l), $ = Ee(() => {
    const { common: { cubicBezierEaseInOut: F }, self: { titleFontWeight: Z, dividerColor: q, titlePadding: K, titleTextColor: te, titleTextColorDisabled: re, textColor: ie, arrowColor: J, fontSize: we, titleFontSize: fe, arrowColorDisabled: oe, itemMargin: he } } = C.value;
    return { "--n-font-size": we, "--n-bezier": F, "--n-text-color": ie, "--n-divider-color": q, "--n-title-padding": K, "--n-title-font-size": fe, "--n-title-text-color": te, "--n-title-text-color-disabled": re, "--n-title-font-weight": Z, "--n-arrow-color": J, "--n-arrow-color-disabled": oe, "--n-item-margin": he };
  }), z = d ? ai("collapse", void 0, $, r) : void 0;
  return { rtlEnabled: L, mergedTheme: C, mergedClsPrefix: l, cssVars: d ? void 0 : $, themeClass: z == null ? void 0 : z.themeClass, onRender: z == null ? void 0 : z.onRender };
}, render() {
  var r;
  return (r = this.onRender) === null || r === void 0 || r.call(this), B("div", { class: [`${this.mergedClsPrefix}-collapse`, this.rtlEnabled && `${this.mergedClsPrefix}-collapse--rtl`, this.themeClass], style: this.cssVars }, this.$slots);
} }), SP = ot({ name: "CollapseItemContent", props: { displayDirective: { type: String, required: true }, show: Boolean, clsPrefix: { type: String, required: true } }, setup(r) {
  return { onceTrue: Gw(zt(r, "show")) };
}, render() {
  return B(kp, null, { default: () => {
    const { show: r, displayDirective: i, onceTrue: l, clsPrefix: d } = this, f = i === "show" && l, g = B("div", { class: `${d}-collapse-item__content-wrapper` }, B("div", { class: `${d}-collapse-item__content-inner` }, this.$slots));
    return f ? wa(g, [[ns, r]]) : r ? g : null;
  } });
} }), kP = { title: String, name: [String, Number], disabled: Boolean, displayDirective: String }, T_ = ot({ name: "CollapseItem", props: kP, setup(r) {
  const { mergedRtlRef: i } = Sr(r), l = $l(), d = vi(() => {
    var D;
    return (D = r.name) !== null && D !== void 0 ? D : l;
  }), f = ur(Vb);
  f || ea("collapse-item", "`n-collapse-item` must be placed inside `n-collapse`.");
  const { expandedNamesRef: g, props: p, mergedClsPrefixRef: s, slots: C } = f, P = Ee(() => {
    const { value: D } = g;
    if (Array.isArray(D)) {
      const { value: L } = d;
      return !~D.findIndex(($) => $ === L);
    } else if (D) {
      const { value: L } = d;
      return L !== D;
    }
    return true;
  });
  return { rtlEnabled: Tn("Collapse", i, s), collapseSlots: C, randomName: l, mergedClsPrefix: s, collapsed: P, triggerAreas: zt(p, "triggerAreas"), mergedDisplayDirective: Ee(() => {
    const { displayDirective: D } = r;
    return D || p.displayDirective;
  }), arrowPlacement: Ee(() => p.arrowPlacement), handleClick(D) {
    let L = "main";
    zl(D, "arrow") && (L = "arrow"), zl(D, "extra") && (L = "extra"), p.triggerAreas.includes(L) && f && !r.disabled && f.toggleItem(P.value, d.value, D);
  } };
}, render() {
  const { collapseSlots: r, $slots: i, arrowPlacement: l, collapsed: d, mergedDisplayDirective: f, mergedClsPrefix: g, disabled: p, triggerAreas: s } = this, C = Pg(i.header, { collapsed: d }, () => [this.title]), P = i["header-extra"] || r["header-extra"], M = i.arrow || r.arrow;
  return B("div", { class: [`${g}-collapse-item`, `${g}-collapse-item--${l}-arrow-placement`, p && `${g}-collapse-item--disabled`, !d && `${g}-collapse-item--active`, s.map((D) => `${g}-collapse-item--trigger-area-${D}`)] }, B("div", { class: [`${g}-collapse-item__header`, !d && `${g}-collapse-item__header--active`] }, B("div", { class: `${g}-collapse-item__header-main`, onClick: this.handleClick }, l === "right" && C, B("div", { class: `${g}-collapse-item-arrow`, key: this.rtlEnabled ? 0 : 1, "data-arrow": true }, Pg(M, { collapsed: d }, () => [B(qr, { clsPrefix: g }, { default: () => this.rtlEnabled ? B(xk, null) : B(qw, null) })])), l === "left" && C), Ww(P, { collapsed: d }, (D) => B("div", { class: `${g}-collapse-item__header-extra`, onClick: this.handleClick, "data-extra": true }, D))), B(SP, { clsPrefix: g, displayDirective: f, show: !d }, i));
} });
function PP(r, i) {
  switch (r[0]) {
    case "hex":
      return i ? "#000000FF" : "#000000";
    case "rgb":
      return i ? "rgba(0, 0, 0, 1)" : "rgb(0, 0, 0)";
    case "hsl":
      return i ? "hsla(0, 0%, 0%, 1)" : "hsl(0, 0%, 0%)";
    case "hsv":
      return i ? "hsva(0, 0%, 0%, 1)" : "hsv(0, 0%, 0%)";
  }
  return "#000000";
}
function eh(r) {
  return r === null ? null : /^ *#/.test(r) ? "hex" : r.includes("rgb") ? "rgb" : r.includes("hsl") ? "hsl" : r.includes("hsv") ? "hsv" : null;
}
function TP(r, i = [255, 255, 255], l = "AA") {
  const [d, f, g, p] = Yo(ts(r));
  if (p === 1) {
    const $ = jf([d, f, g]), z = jf(i);
    return (Math.max($, z) + 0.05) / (Math.min($, z) + 0.05) >= (l === "AA" ? 4.5 : 7);
  }
  const s = Math.round(d * p + i[0] * (1 - p)), C = Math.round(f * p + i[1] * (1 - p)), P = Math.round(g * p + i[2] * (1 - p)), M = jf([s, C, P]), D = jf(i);
  return (Math.max(M, D) + 0.05) / (Math.min(M, D) + 0.05) >= (l === "AA" ? 4.5 : 7);
}
function jf(r) {
  const [i, l, d] = r.map((f) => (f /= 255, f <= 0.03928 ? f / 12.92 : Math.pow((f + 0.055) / 1.055, 2.4)));
  return 0.2126 * i + 0.7152 * l + 0.0722 * d;
}
function IP(r) {
  return r = Math.round(r), r >= 360 ? 359 : r < 0 ? 0 : r;
}
function MP(r) {
  return r = Math.round(r * 100) / 100, r > 1 ? 1 : r < 0 ? 0 : r;
}
const EP = { rgb: { hex(r) {
  return Bs(Yo(r));
}, hsl(r) {
  const [i, l, d, f] = Yo(r);
  return ts([...Mg(i, l, d), f]);
}, hsv(r) {
  const [i, l, d, f] = Yo(r);
  return Ll([...Ig(i, l, d), f]);
} }, hex: { rgb(r) {
  return rs(Yo(r));
}, hsl(r) {
  const [i, l, d, f] = Yo(r);
  return ts([...Mg(i, l, d), f]);
}, hsv(r) {
  const [i, l, d, f] = Yo(r);
  return Ll([...Ig(i, l, d), f]);
} }, hsl: { hex(r) {
  const [i, l, d, f] = lc(r);
  return Bs([...Tg(i, l, d), f]);
}, rgb(r) {
  const [i, l, d, f] = lc(r);
  return rs([...Tg(i, l, d), f]);
}, hsv(r) {
  const [i, l, d, f] = lc(r);
  return Ll([...Zy(i, l, d), f]);
} }, hsv: { hex(r) {
  const [i, l, d, f] = Fl(r);
  return Bs([...Ds(i, l, d), f]);
}, rgb(r) {
  const [i, l, d, f] = Fl(r);
  return rs([...Ds(i, l, d), f]);
}, hsl(r) {
  const [i, l, d, f] = Fl(r);
  return ts([...ep(i, l, d), f]);
} } };
function Ub(r, i, l) {
  return l = l || eh(r), l ? l === i ? r : EP[l][i](r) : null;
}
const Fd = "12px", RP = 12, Tl = "6px", AP = ot({ name: "AlphaSlider", props: { clsPrefix: { type: String, required: true }, rgba: { type: Array, default: null }, alpha: { type: Number, default: 0 }, onUpdateAlpha: { type: Function, required: true }, onComplete: Function }, setup(r) {
  const i = Ie(null);
  function l(g) {
    !i.value || !r.rgba || (Bn("mousemove", document, d), Bn("mouseup", document, f), d(g));
  }
  function d(g) {
    const { value: p } = i;
    if (!p) return;
    const { width: s, left: C } = p.getBoundingClientRect(), P = (g.clientX - C) / (s - RP);
    r.onUpdateAlpha(MP(P));
  }
  function f() {
    var g;
    eo("mousemove", document, d), eo("mouseup", document, f), (g = r.onComplete) === null || g === void 0 || g.call(r);
  }
  return { railRef: i, railBackgroundImage: Ee(() => {
    const { rgba: g } = r;
    return g ? `linear-gradient(to right, rgba(${g[0]}, ${g[1]}, ${g[2]}, 0) 0%, rgba(${g[0]}, ${g[1]}, ${g[2]}, 1) 100%)` : "";
  }), handleMouseDown: l };
}, render() {
  const { clsPrefix: r } = this;
  return B("div", { class: `${r}-color-picker-slider`, ref: "railRef", style: { height: Fd, borderRadius: Tl }, onMousedown: this.handleMouseDown }, B("div", { style: { borderRadius: Tl, position: "absolute", left: 0, right: 0, top: 0, bottom: 0, overflow: "hidden" } }, B("div", { class: `${r}-color-picker-checkboard` }), B("div", { class: `${r}-color-picker-slider__image`, style: { backgroundImage: this.railBackgroundImage } })), this.rgba && B("div", { style: { position: "absolute", left: Tl, right: Tl, top: 0, bottom: 0 } }, B("div", { class: `${r}-color-picker-handle`, style: { left: `calc(${this.alpha * 100}% - ${Tl})`, borderRadius: Tl, width: Fd, height: Fd } }, B("div", { class: `${r}-color-picker-handle__fill`, style: { backgroundColor: rs(this.rgba), borderRadius: Tl, width: Fd, height: Fd } }))));
} }), f0 = $n("n-color-picker");
function DP(r) {
  return /^\d{1,3}\.?\d*$/.test(r.trim()) ? Math.max(0, Math.min(Number.parseInt(r), 255)) : false;
}
function zP(r) {
  return /^\d{1,3}\.?\d*$/.test(r.trim()) ? Math.max(0, Math.min(Number.parseInt(r), 360)) : false;
}
function FP(r) {
  return /^\d{1,3}\.?\d*$/.test(r.trim()) ? Math.max(0, Math.min(Number.parseInt(r), 100)) : false;
}
function LP(r) {
  const i = r.trim();
  return /^#[0-9a-fA-F]+$/.test(i) ? [4, 5, 7, 9].includes(i.length) : false;
}
function BP(r) {
  return /^\d{1,3}\.?\d*%$/.test(r.trim()) ? Math.max(0, Math.min(Number.parseInt(r) / 100, 100)) : false;
}
const OP = { paddingSmall: "0 4px" }, I_ = ot({ name: "ColorInputUnit", props: { label: { type: String, required: true }, value: { type: [Number, String], default: null }, showAlpha: Boolean, onUpdateValue: { type: Function, required: true } }, setup(r) {
  const i = Ie(""), { themeRef: l } = ur(f0, null);
  bo(() => {
    i.value = d();
  });
  function d() {
    const { value: p } = r;
    if (p === null) return "";
    const { label: s } = r;
    return s === "HEX" ? p : s === "A" ? `${Math.floor(p * 100)}%` : String(Math.floor(p));
  }
  function f(p) {
    i.value = p;
  }
  function g(p) {
    let s, C;
    switch (r.label) {
      case "HEX":
        C = LP(p), C && r.onUpdateValue(p), i.value = d();
        break;
      case "H":
        s = zP(p), s === false ? i.value = d() : r.onUpdateValue(s);
        break;
      case "S":
      case "L":
      case "V":
        s = FP(p), s === false ? i.value = d() : r.onUpdateValue(s);
        break;
      case "A":
        s = BP(p), s === false ? i.value = d() : r.onUpdateValue(s);
        break;
      case "R":
      case "G":
      case "B":
        s = DP(p), s === false ? i.value = d() : r.onUpdateValue(s);
        break;
    }
  }
  return { mergedTheme: l, inputValue: i, handleInputChange: g, handleInputUpdateValue: f };
}, render() {
  const { mergedTheme: r } = this;
  return B(_o, { size: "small", placeholder: this.label, theme: r.peers.Input, themeOverrides: r.peerOverrides.Input, builtinThemeOverrides: OP, value: this.inputValue, onUpdateValue: this.handleInputUpdateValue, onChange: this.handleInputChange, style: this.label === "A" ? "flex-grow: 1.25;" : "" });
} }), $P = ot({ name: "ColorInput", props: { clsPrefix: { type: String, required: true }, mode: { type: String, required: true }, modes: { type: Array, required: true }, showAlpha: { type: Boolean, required: true }, value: { type: String, default: null }, valueArr: { type: Array, default: null }, onUpdateValue: { type: Function, required: true }, onUpdateMode: { type: Function, required: true } }, setup(r) {
  return { handleUnitUpdateValue(i, l) {
    const { showAlpha: d } = r;
    if (r.mode === "hex") {
      r.onUpdateValue((d ? Bs : Ud)(l));
      return;
    }
    let f;
    switch (r.valueArr === null ? f = [0, 0, 0, 0] : f = Array.from(r.valueArr), r.mode) {
      case "hsv":
        f[i] = l, r.onUpdateValue((d ? Ll : Ag)(f));
        break;
      case "rgb":
        f[i] = l, r.onUpdateValue((d ? rs : Rg)(f));
        break;
      case "hsl":
        f[i] = l, r.onUpdateValue((d ? ts : Eg)(f));
        break;
    }
  } };
}, render() {
  const { clsPrefix: r, modes: i } = this;
  return B("div", { class: `${r}-color-picker-input` }, B("div", { class: `${r}-color-picker-input__mode`, onClick: this.onUpdateMode, style: { cursor: i.length === 1 ? "" : "pointer" } }, this.mode.toUpperCase() + (this.showAlpha ? "A" : "")), B(aP, null, { default: () => {
    const { mode: l, valueArr: d, showAlpha: f } = this;
    if (l === "hex") {
      let g = null;
      try {
        g = d === null ? null : (f ? Bs : Ud)(d);
      } catch {
      }
      return B(I_, { label: "HEX", showAlpha: f, value: g, onUpdateValue: (p) => {
        this.handleUnitUpdateValue(0, p);
      } });
    }
    return (l + (f ? "a" : "")).split("").map((g, p) => B(I_, { label: g.toUpperCase(), value: d === null ? null : d[p], onUpdateValue: (s) => {
      this.handleUnitUpdateValue(p, s);
    } }));
  } }));
} });
function jP(r, i) {
  if (i === "hsv") {
    const [l, d, f, g] = Fl(r);
    return rs([...Ds(l, d, f), g]);
  }
  return r;
}
function NP(r) {
  const i = document.createElement("canvas").getContext("2d");
  return i ? (i.fillStyle = r, i.fillStyle) : "#000000";
}
const VP = ot({ name: "ColorPickerSwatches", props: { clsPrefix: { type: String, required: true }, mode: { type: String, required: true }, swatches: { type: Array, required: true }, onUpdateColor: { type: Function, required: true } }, setup(r) {
  const i = Ee(() => r.swatches.map((g) => {
    const p = eh(g);
    return { value: g, mode: p, legalValue: jP(g, p) };
  }));
  function l(g) {
    const { mode: p } = r;
    let { value: s, mode: C } = g;
    return C || (C = "hex", /^[a-zA-Z]+$/.test(s) ? s = NP(s) : (lp("color-picker", `color ${s} in swatches is invalid.`), s = "#000000")), C === p ? s : Ub(s, p, C);
  }
  function d(g) {
    r.onUpdateColor(l(g));
  }
  function f(g, p) {
    g.key === "Enter" && d(p);
  }
  return { parsedSwatchesRef: i, handleSwatchSelect: d, handleSwatchKeyDown: f };
}, render() {
  const { clsPrefix: r } = this;
  return B("div", { class: `${r}-color-picker-swatches` }, this.parsedSwatchesRef.map((i) => B("div", { class: `${r}-color-picker-swatch`, tabindex: 0, onClick: () => {
    this.handleSwatchSelect(i);
  }, onKeydown: (l) => {
    this.handleSwatchKeyDown(l, i);
  } }, B("div", { class: `${r}-color-picker-swatch__fill`, style: { background: i.legalValue } }))));
} }), UP = ot({ name: "ColorPickerTrigger", slots: Object, props: { clsPrefix: { type: String, required: true }, value: { type: String, default: null }, hsla: { type: Array, default: null }, disabled: Boolean, onClick: Function }, setup(r) {
  const { colorPickerSlots: i, renderLabelRef: l } = ur(f0, null);
  return () => {
    const { hsla: d, value: f, clsPrefix: g, onClick: p, disabled: s } = r, C = i.label || l.value;
    return B("div", { class: [`${g}-color-picker-trigger`, s && `${g}-color-picker-trigger--disabled`], onClick: s ? void 0 : p }, B("div", { class: `${g}-color-picker-trigger__fill` }, B("div", { class: `${g}-color-picker-checkboard` }), B("div", { style: { position: "absolute", left: 0, right: 0, top: 0, bottom: 0, backgroundColor: d ? ts(d) : "" } }), f && d ? B("div", { class: `${g}-color-picker-trigger__value`, style: { color: TP(d) ? "white" : "black" } }, C ? C(f) : f) : null));
  };
} }), GP = ot({ name: "ColorPreview", props: { clsPrefix: { type: String, required: true }, mode: { type: String, required: true }, color: { type: String, default: null, validator: (r) => {
  const i = eh(r);
  return !!(!r || i && i !== "hsv");
} }, onUpdateColor: { type: Function, required: true } }, setup(r) {
  function i(l) {
    var d;
    const f = l.target.value;
    (d = r.onUpdateColor) === null || d === void 0 || d.call(r, Ub(f.toUpperCase(), r.mode, "hex")), l.stopPropagation();
  }
  return { handleChange: i };
}, render() {
  const { clsPrefix: r } = this;
  return B("div", { class: `${r}-color-picker-preview__preview` }, B("span", { class: `${r}-color-picker-preview__fill`, style: { background: this.color || "#000000" } }), B("input", { class: `${r}-color-picker-preview__input`, type: "color", value: this.color, onChange: this.handleChange }));
} }), tc = "12px", qP = 12, Il = "6px", WP = 6, ZP = "linear-gradient(90deg,red,#ff0 16.66%,#0f0 33.33%,#0ff 50%,#00f 66.66%,#f0f 83.33%,red)", HP = ot({ name: "HueSlider", props: { clsPrefix: { type: String, required: true }, hue: { type: Number, required: true }, onUpdateHue: { type: Function, required: true }, onComplete: Function }, setup(r) {
  const i = Ie(null);
  function l(g) {
    i.value && (Bn("mousemove", document, d), Bn("mouseup", document, f), d(g));
  }
  function d(g) {
    const { value: p } = i;
    if (!p) return;
    const { width: s, left: C } = p.getBoundingClientRect(), P = IP((g.clientX - C - WP) / (s - qP) * 360);
    r.onUpdateHue(P);
  }
  function f() {
    var g;
    eo("mousemove", document, d), eo("mouseup", document, f), (g = r.onComplete) === null || g === void 0 || g.call(r);
  }
  return { railRef: i, handleMouseDown: l };
}, render() {
  const { clsPrefix: r } = this;
  return B("div", { class: `${r}-color-picker-slider`, style: { height: tc, borderRadius: Il } }, B("div", { ref: "railRef", style: { boxShadow: "inset 0 0 2px 0 rgba(0, 0, 0, .24)", boxSizing: "border-box", backgroundImage: ZP, height: tc, borderRadius: Il, position: "relative" }, onMousedown: this.handleMouseDown }, B("div", { style: { position: "absolute", left: Il, right: Il, top: 0, bottom: 0 } }, B("div", { class: `${r}-color-picker-handle`, style: { left: `calc((${this.hue}%) / 359 * 100 - ${Il})`, borderRadius: Il, width: tc, height: tc } }, B("div", { class: `${r}-color-picker-handle__fill`, style: { backgroundColor: `hsl(${this.hue}, 100%, 50%)`, borderRadius: Il, width: tc, height: tc } })))));
} }), Nf = "12px", Vf = "6px", XP = ot({ name: "Pallete", props: { clsPrefix: { type: String, required: true }, rgba: { type: Array, default: null }, displayedHue: { type: Number, required: true }, displayedSv: { type: Array, required: true }, onUpdateSV: { type: Function, required: true }, onComplete: Function }, setup(r) {
  const i = Ie(null);
  function l(g) {
    i.value && (Bn("mousemove", document, d), Bn("mouseup", document, f), d(g));
  }
  function d(g) {
    const { value: p } = i;
    if (!p) return;
    const { width: s, height: C, left: P, bottom: M } = p.getBoundingClientRect(), D = (M - g.clientY) / C, L = (g.clientX - P) / s, $ = 100 * (L > 1 ? 1 : L < 0 ? 0 : L), z = 100 * (D > 1 ? 1 : D < 0 ? 0 : D);
    r.onUpdateSV($, z);
  }
  function f() {
    var g;
    eo("mousemove", document, d), eo("mouseup", document, f), (g = r.onComplete) === null || g === void 0 || g.call(r);
  }
  return { palleteRef: i, handleColor: Ee(() => {
    const { rgba: g } = r;
    return g ? `rgb(${g[0]}, ${g[1]}, ${g[2]})` : "";
  }), handleMouseDown: l };
}, render() {
  const { clsPrefix: r } = this;
  return B("div", { class: `${r}-color-picker-pallete`, onMousedown: this.handleMouseDown, ref: "palleteRef" }, B("div", { class: `${r}-color-picker-pallete__layer`, style: { backgroundImage: `linear-gradient(90deg, white, hsl(${this.displayedHue}, 100%, 50%))` } }), B("div", { class: `${r}-color-picker-pallete__layer ${r}-color-picker-pallete__layer--shadowed`, style: { backgroundImage: "linear-gradient(180deg, rgba(0, 0, 0, 0%), rgba(0, 0, 0, 100%))" } }), this.rgba && B("div", { class: `${r}-color-picker-handle`, style: { width: Nf, height: Nf, borderRadius: Vf, left: `calc(${this.displayedSv[0]}% - ${Vf})`, bottom: `calc(${this.displayedSv[1]}% - ${Vf})` } }, B("div", { class: `${r}-color-picker-handle__fill`, style: { backgroundColor: this.handleColor, borderRadius: Vf, width: Nf, height: Nf } })));
} }), YP = Ze([ue("color-picker", `
 display: inline-block;
 box-sizing: border-box;
 height: var(--n-height);
 font-size: var(--n-font-size);
 width: 100%;
 position: relative;
 `), ue("color-picker-panel", `
 margin: 4px 0;
 width: 240px;
 font-size: var(--n-panel-font-size);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 `, [wp(), ue("input", `
 text-align: center;
 `)]), ue("color-picker-checkboard", `
 background: white; 
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [Ze("&::after", `
 background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
 background-size: 12px 12px;
 background-position: 0 0, 0 6px, 6px -6px, -6px 0px;
 background-repeat: repeat;
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), ue("color-picker-slider", `
 margin-bottom: 8px;
 position: relative;
 box-sizing: border-box;
 `, [Ae("image", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `), Ze("&::after", `
 content: "";
 position: absolute;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
 pointer-events: none;
 `)]), ue("color-picker-handle", `
 z-index: 1;
 box-shadow: 0 0 2px 0 rgba(0, 0, 0, .45);
 position: absolute;
 background-color: white;
 overflow: hidden;
 `, [Ae("fill", `
 box-sizing: border-box;
 border: 2px solid white;
 `)]), ue("color-picker-pallete", `
 height: 180px;
 position: relative;
 margin-bottom: 8px;
 cursor: crosshair;
 `, [Ae("layer", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [Ge("shadowed", `
 box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
 `)])]), ue("color-picker-preview", `
 display: flex;
 `, [Ae("sliders", `
 flex: 1 0 auto;
 `), Ae("preview", `
 position: relative;
 height: 30px;
 width: 30px;
 margin: 0 0 8px 6px;
 border-radius: 50%;
 box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
 overflow: hidden;
 `), Ae("fill", `
 display: block;
 width: 30px;
 height: 30px;
 `), Ae("input", `
 position: absolute;
 top: 0;
 left: 0;
 width: 30px;
 height: 30px;
 opacity: 0;
 z-index: 1;
 `)]), ue("color-picker-input", `
 display: flex;
 align-items: center;
 `, [ue("input", `
 flex-grow: 1;
 flex-basis: 0;
 `), Ae("mode", `
 width: 72px;
 text-align: center;
 `)]), ue("color-picker-control", `
 padding: 12px;
 `), ue("color-picker-action", `
 display: flex;
 margin-top: -4px;
 border-top: 1px solid var(--n-divider-color);
 padding: 8px 12px;
 justify-content: flex-end;
 `, [ue("button", "margin-left: 8px;")]), ue("color-picker-trigger", `
 border: var(--n-border);
 height: 100%;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 transition: border-color .3s var(--n-bezier);
 cursor: pointer;
 `, [Ae("value", `
 white-space: nowrap;
 position: relative;
 `), Ae("fill", `
 border-radius: var(--n-border-radius);
 position: absolute;
 display: flex;
 align-items: center;
 justify-content: center;
 left: 4px;
 right: 4px;
 top: 4px;
 bottom: 4px;
 `), Ge("disabled", "cursor: not-allowed"), ue("color-picker-checkboard", `
 border-radius: var(--n-border-radius);
 `, [Ze("&::after", `
 --n-block-size: calc((var(--n-height) - 8px) / 3);
 background-size: calc(var(--n-block-size) * 2) calc(var(--n-block-size) * 2);
 background-position: 0 0, 0 var(--n-block-size), var(--n-block-size) calc(-1 * var(--n-block-size)), calc(-1 * var(--n-block-size)) 0px; 
 `)])]), ue("color-picker-swatches", `
 display: grid;
 grid-gap: 8px;
 flex-wrap: wrap;
 position: relative;
 grid-template-columns: repeat(auto-fill, 18px);
 margin-top: 10px;
 `, [ue("color-picker-swatch", `
 width: 18px;
 height: 18px;
 background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
 background-size: 8px 8px;
 background-position: 0px 0, 0px 4px, 4px -4px, -4px 0px;
 background-repeat: repeat;
 `, [Ae("fill", `
 position: relative;
 width: 100%;
 height: 100%;
 border-radius: 3px;
 box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
 cursor: pointer;
 `), Ze("&:focus", `
 outline: none;
 `, [Ae("fill", [Ze("&::after", `
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 background: inherit;
 filter: blur(2px);
 content: "";
 `)])])])])]), KP = Object.assign(Object.assign({}, Jt.props), { value: String, show: { type: Boolean, default: void 0 }, defaultShow: Boolean, defaultValue: String, modes: { type: Array, default: () => ["rgb", "hex", "hsl"] }, placement: { type: String, default: "bottom-start" }, to: dc.propTo, showAlpha: { type: Boolean, default: true }, showPreview: Boolean, swatches: Array, disabled: { type: Boolean, default: void 0 }, actions: { type: Array, default: null }, internalActions: Array, size: String, renderLabel: Function, onComplete: Function, onConfirm: Function, onClear: Function, "onUpdate:show": [Function, Array], onUpdateShow: [Function, Array], "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array] }), ig = ot({ name: "ColorPicker", props: KP, slots: Object, setup(r, { slots: i }) {
  const l = Ie(null);
  let d = null;
  const f = ka(r), { mergedSizeRef: g, mergedDisabledRef: p } = f, { localeRef: s } = as("global"), { mergedClsPrefixRef: C, namespaceRef: P, inlineThemeDisabled: M } = Sr(r), D = Jt("ColorPicker", "-color-picker", YP, Zw, r, C);
  Xr(f0, { themeRef: D, renderLabelRef: zt(r, "renderLabel"), colorPickerSlots: i });
  const L = Ie(r.defaultShow), $ = Ji(zt(r, "show"), L);
  function z(ze) {
    const { onUpdateShow: at, "onUpdate:show": Oe } = r;
    at && Ot(at, ze), Oe && Ot(Oe, ze), L.value = ze;
  }
  const { defaultValue: F } = r, Z = Ie(F === void 0 ? PP(r.modes, r.showAlpha) : F), q = Ji(zt(r, "value"), Z), K = Ie([q.value]), te = Ie(0), re = Ee(() => eh(q.value)), { modes: ie } = r, J = Ie(eh(q.value) || ie[0] || "rgb");
  function we() {
    const { modes: ze } = r, { value: at } = J, Oe = ze.findIndex((Je) => Je === at);
    ~Oe ? J.value = ze[(Oe + 1) % ze.length] : J.value = "rgb";
  }
  let fe, oe, he, _e, Ue, qe, tt, ut;
  const mt = Ee(() => {
    const { value: ze } = q;
    if (!ze) return null;
    switch (re.value) {
      case "hsv":
        return Fl(ze);
      case "hsl":
        return [fe, oe, he, ut] = lc(ze), [...Zy(fe, oe, he), ut];
      case "rgb":
      case "hex":
        return [Ue, qe, tt, ut] = Yo(ze), [...Ig(Ue, qe, tt), ut];
    }
  }), St = Ee(() => {
    const { value: ze } = q;
    if (!ze) return null;
    switch (re.value) {
      case "rgb":
      case "hex":
        return Yo(ze);
      case "hsv":
        return [fe, oe, _e, ut] = Fl(ze), [...Ds(fe, oe, _e), ut];
      case "hsl":
        return [fe, oe, he, ut] = lc(ze), [...Tg(fe, oe, he), ut];
    }
  }), st = Ee(() => {
    const { value: ze } = q;
    if (!ze) return null;
    switch (re.value) {
      case "hsl":
        return lc(ze);
      case "hsv":
        return [fe, oe, _e, ut] = Fl(ze), [...ep(fe, oe, _e), ut];
      case "rgb":
      case "hex":
        return [Ue, qe, tt, ut] = Yo(ze), [...Mg(Ue, qe, tt), ut];
    }
  }), nt = Ee(() => {
    switch (J.value) {
      case "rgb":
      case "hex":
        return St.value;
      case "hsv":
        return mt.value;
      case "hsl":
        return st.value;
    }
  }), ft = Ie(0), Lt = Ie(1), pt = Ie([0, 0]);
  function wt(ze, at) {
    const { value: Oe } = mt, Je = ft.value, ht = Oe ? Oe[3] : 1;
    pt.value = [ze, at];
    const { showAlpha: bt } = r;
    switch (J.value) {
      case "hsv":
        gt((bt ? Ll : Ag)([Je, ze, at, ht]), "cursor");
        break;
      case "hsl":
        gt((bt ? ts : Eg)([...ep(Je, ze, at), ht]), "cursor");
        break;
      case "rgb":
        gt((bt ? rs : Rg)([...Ds(Je, ze, at), ht]), "cursor");
        break;
      case "hex":
        gt((bt ? Bs : Ud)([...Ds(Je, ze, at), ht]), "cursor");
        break;
    }
  }
  function Ft(ze) {
    ft.value = ze;
    const { value: at } = mt;
    if (!at) return;
    const [, Oe, Je, ht] = at, { showAlpha: bt } = r;
    switch (J.value) {
      case "hsv":
        gt((bt ? Ll : Ag)([ze, Oe, Je, ht]), "cursor");
        break;
      case "rgb":
        gt((bt ? rs : Rg)([...Ds(ze, Oe, Je), ht]), "cursor");
        break;
      case "hex":
        gt((bt ? Bs : Ud)([...Ds(ze, Oe, Je), ht]), "cursor");
        break;
      case "hsl":
        gt((bt ? ts : Eg)([...ep(ze, Oe, Je), ht]), "cursor");
        break;
    }
  }
  function tr(ze) {
    switch (J.value) {
      case "hsv":
        [fe, oe, _e] = mt.value, gt(Ll([fe, oe, _e, ze]), "cursor");
        break;
      case "rgb":
        [Ue, qe, tt] = St.value, gt(rs([Ue, qe, tt, ze]), "cursor");
        break;
      case "hex":
        [Ue, qe, tt] = St.value, gt(Bs([Ue, qe, tt, ze]), "cursor");
        break;
      case "hsl":
        [fe, oe, he] = st.value, gt(ts([fe, oe, he, ze]), "cursor");
        break;
    }
    Lt.value = ze;
  }
  function gt(ze, at) {
    at === "cursor" ? d = ze : d = null;
    const { nTriggerFormChange: Oe, nTriggerFormInput: Je } = f, { onUpdateValue: ht, "onUpdate:value": bt } = r;
    ht && Ot(ht, ze), bt && Ot(bt, ze), Oe(), Je(), Z.value = ze;
  }
  function Bt(ze) {
    gt(ze, "input"), Wn(Zt);
  }
  function Zt(ze = true) {
    const { value: at } = q;
    if (at) {
      const { nTriggerFormChange: Oe, nTriggerFormInput: Je } = f, { onComplete: ht } = r;
      ht && ht(at);
      const { value: bt } = K, { value: rt } = te;
      ze && (bt.splice(rt + 1, bt.length, at), te.value = rt + 1), Oe(), Je();
    }
  }
  function ir() {
    const { value: ze } = te;
    ze - 1 < 0 || (gt(K.value[ze - 1], "input"), Zt(false), te.value = ze - 1);
  }
  function Cr() {
    const { value: ze } = te;
    ze < 0 || ze + 1 >= K.value.length || (gt(K.value[ze + 1], "input"), Zt(false), te.value = ze + 1);
  }
  function Ar() {
    gt(null, "input");
    const { onClear: ze } = r;
    ze && ze(), z(false);
  }
  function or() {
    const { value: ze } = q, { onConfirm: at } = r;
    at && at(ze), z(false);
  }
  const Tr = Ee(() => te.value >= 1), Xt = Ee(() => {
    const { value: ze } = K;
    return ze.length > 1 && te.value < ze.length - 1;
  });
  Ht($, (ze) => {
    ze || (K.value = [q.value], te.value = 0);
  }), bo(() => {
    if (!(d && d === q.value)) {
      const { value: ze } = mt;
      ze && (ft.value = ze[0], Lt.value = ze[3], pt.value = [ze[1], ze[2]]);
    }
    d = null;
  });
  const Dr = Ee(() => {
    const { value: ze } = g, { common: { cubicBezierEaseInOut: at }, self: { textColor: Oe, color: Je, panelFontSize: ht, boxShadow: bt, border: rt, borderRadius: vt, dividerColor: Wt, [Vt("height", ze)]: ci, [Vt("fontSize", ze)]: Ai } } = D.value;
    return { "--n-bezier": at, "--n-text-color": Oe, "--n-color": Je, "--n-panel-font-size": ht, "--n-font-size": Ai, "--n-box-shadow": bt, "--n-border": rt, "--n-border-radius": vt, "--n-height": ci, "--n-divider-color": Wt };
  }), nr = M ? ai("color-picker", Ee(() => g.value[0]), Dr, r) : void 0;
  function kt() {
    var ze;
    const { value: at } = St, { value: Oe } = ft, { internalActions: Je, modes: ht, actions: bt } = r, { value: rt } = D, { value: vt } = C;
    return B("div", { class: [`${vt}-color-picker-panel`, nr == null ? void 0 : nr.themeClass.value], onDragstart: (Wt) => {
      Wt.preventDefault();
    }, style: M ? void 0 : Dr.value }, B("div", { class: `${vt}-color-picker-control` }, B(XP, { clsPrefix: vt, rgba: at, displayedHue: Oe, displayedSv: pt.value, onUpdateSV: wt, onComplete: Zt }), B("div", { class: `${vt}-color-picker-preview` }, B("div", { class: `${vt}-color-picker-preview__sliders` }, B(HP, { clsPrefix: vt, hue: Oe, onUpdateHue: Ft, onComplete: Zt }), r.showAlpha ? B(AP, { clsPrefix: vt, rgba: at, alpha: Lt.value, onUpdateAlpha: tr, onComplete: Zt }) : null), r.showPreview ? B(GP, { clsPrefix: vt, mode: J.value, color: St.value && Ud(St.value), onUpdateColor: (Wt) => {
      gt(Wt, "input");
    } }) : null), B($P, { clsPrefix: vt, showAlpha: r.showAlpha, mode: J.value, modes: ht, onUpdateMode: we, value: q.value, valueArr: nt.value, onUpdateValue: Bt }), ((ze = r.swatches) === null || ze === void 0 ? void 0 : ze.length) && B(VP, { clsPrefix: vt, mode: J.value, swatches: r.swatches, onUpdateColor: (Wt) => {
      gt(Wt, "input");
    } })), (bt == null ? void 0 : bt.length) ? B("div", { class: `${vt}-color-picker-action` }, bt.includes("confirm") && B($r, { size: "small", onClick: or, theme: rt.peers.Button, themeOverrides: rt.peerOverrides.Button }, { default: () => s.value.confirm }), bt.includes("clear") && B($r, { size: "small", onClick: Ar, disabled: !q.value, theme: rt.peers.Button, themeOverrides: rt.peerOverrides.Button }, { default: () => s.value.clear })) : null, i.action ? B("div", { class: `${vt}-color-picker-action` }, { default: i.action }) : Je ? B("div", { class: `${vt}-color-picker-action` }, Je.includes("undo") && B($r, { size: "small", onClick: ir, disabled: !Tr.value, theme: rt.peers.Button, themeOverrides: rt.peerOverrides.Button }, { default: () => s.value.undo }), Je.includes("redo") && B($r, { size: "small", onClick: Cr, disabled: !Xt.value, theme: rt.peers.Button, themeOverrides: rt.peerOverrides.Button }, { default: () => s.value.redo })) : null);
  }
  return { mergedClsPrefix: C, namespace: P, selfRef: l, hsla: st, rgba: St, mergedShow: $, mergedDisabled: p, isMounted: Ip(), adjustedTo: dc(r), mergedValue: q, handleTriggerClick() {
    z(true);
  }, handleClickOutside(ze) {
    var at;
    !((at = l.value) === null || at === void 0) && at.contains(Ky(ze)) || z(false);
  }, renderPanel: kt, cssVars: M ? void 0 : Dr, themeClass: nr == null ? void 0 : nr.themeClass, onRender: nr == null ? void 0 : nr.onRender };
}, render() {
  const { mergedClsPrefix: r, onRender: i } = this;
  return i == null ? void 0 : i(), B("div", { class: [this.themeClass, `${r}-color-picker`], ref: "selfRef", style: this.cssVars }, B(Hy, null, { default: () => [B(Xy, null, { default: () => B(UP, { clsPrefix: r, value: this.mergedValue, hsla: this.hsla, disabled: this.mergedDisabled, onClick: this.handleTriggerClick }) }), B(Yy, { placement: this.placement, show: this.mergedShow, containerClass: this.namespace, teleportDisabled: this.adjustedTo === dc.tdkey, to: this.adjustedTo }, { default: () => B(Eo, { name: "fade-in-scale-up-transition", appear: this.isMounted }, { default: () => this.mergedShow ? wa(this.renderPanel(), [[up, this.handleClickOutside, void 0, { capture: true }]]) : null }) })] }));
} }), JP = Ze([ue("select", `
 z-index: auto;
 outline: none;
 width: 100%;
 position: relative;
 font-weight: var(--n-font-weight);
 `), ue("select-menu", `
 margin: 4px 0;
 box-shadow: var(--n-menu-box-shadow);
 `, [wp({ originalTransition: "background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)" })])]), QP = Object.assign(Object.assign({}, Jt.props), { to: dc.propTo, bordered: { type: Boolean, default: void 0 }, clearable: Boolean, clearFilterAfterSelect: { type: Boolean, default: true }, options: { type: Array, default: () => [] }, defaultValue: { type: [String, Number, Array], default: null }, keyboard: { type: Boolean, default: true }, value: [String, Number, Array], placeholder: String, menuProps: Object, multiple: Boolean, size: String, menuSize: { type: String }, filterable: Boolean, disabled: { type: Boolean, default: void 0 }, remote: Boolean, loading: Boolean, filter: Function, placement: { type: String, default: "bottom-start" }, widthMode: { type: String, default: "trigger" }, tag: Boolean, onCreate: Function, fallbackOption: { type: [Function, Boolean], default: void 0 }, show: { type: Boolean, default: void 0 }, showArrow: { type: Boolean, default: true }, maxTagCount: [Number, String], ellipsisTagPopoverProps: Object, consistentMenuWidth: { type: Boolean, default: true }, virtualScroll: { type: Boolean, default: true }, labelField: { type: String, default: "label" }, valueField: { type: String, default: "value" }, childrenField: { type: String, default: "children" }, renderLabel: Function, renderOption: Function, renderTag: Function, "onUpdate:value": [Function, Array], inputProps: Object, nodeProps: Function, ignoreComposition: { type: Boolean, default: true }, showOnFocus: Boolean, onUpdateValue: [Function, Array], onBlur: [Function, Array], onClear: [Function, Array], onFocus: [Function, Array], onScroll: [Function, Array], onSearch: [Function, Array], onUpdateShow: [Function, Array], "onUpdate:show": [Function, Array], displayDirective: { type: String, default: "show" }, resetMenuOnOptionsChange: { type: Boolean, default: true }, status: String, showCheckmark: { type: Boolean, default: true }, onChange: [Function, Array], items: Array }), Bg = ot({ name: "Select", props: QP, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, mergedBorderedRef: l, namespaceRef: d, inlineThemeDisabled: f } = Sr(r), g = Jt("Select", "-select", JP, Hw, r, i), p = Ie(r.defaultValue), s = zt(r, "value"), C = Ji(s, p), P = Ie(false), M = Ie(""), D = cp(r, ["items", "options"]), L = Ie([]), $ = Ie([]), z = Ee(() => $.value.concat(L.value).concat(D.value)), F = Ee(() => {
    const { filter: ae } = r;
    if (ae) return ae;
    const { labelField: Pe, valueField: xe } = r;
    return (Ve, et) => {
      if (!et) return false;
      const We = et[Pe];
      if (typeof We == "string") return Qm(Ve, We);
      const xt = et[xe];
      return typeof xt == "string" ? Qm(Ve, xt) : typeof xt == "number" ? Qm(Ve, String(xt)) : false;
    };
  }), Z = Ee(() => {
    if (r.remote) return D.value;
    {
      const { value: ae } = z, { value: Pe } = M;
      return !Pe.length || !r.filterable ? ae : lP(ae, F.value, Pe, r.childrenField);
    }
  }), q = Ee(() => {
    const { valueField: ae, childrenField: Pe } = r, xe = sP(ae, Pe);
    return Xw(Z.value, xe);
  }), K = Ee(() => uP(z.value, r.valueField, r.childrenField)), te = Ie(false), re = Ji(zt(r, "show"), te), ie = Ie(null), J = Ie(null), we = Ie(null), { localeRef: fe } = as("Select"), oe = Ee(() => {
    var ae;
    return (ae = r.placeholder) !== null && ae !== void 0 ? ae : fe.value.placeholder;
  }), he = [], _e = Ie(/* @__PURE__ */ new Map()), Ue = Ee(() => {
    const { fallbackOption: ae } = r;
    if (ae === void 0) {
      const { labelField: Pe, valueField: xe } = r;
      return (Ve) => ({ [Pe]: String(Ve), [xe]: Ve });
    }
    return ae === false ? false : (Pe) => Object.assign(ae(Pe), { value: Pe });
  });
  function qe(ae) {
    const Pe = r.remote, { value: xe } = _e, { value: Ve } = K, { value: et } = Ue, We = [];
    return ae.forEach((xt) => {
      if (Ve.has(xt)) We.push(Ve.get(xt));
      else if (Pe && xe.has(xt)) We.push(xe.get(xt));
      else if (et) {
        const Le = et(xt);
        Le && We.push(Le);
      }
    }), We;
  }
  const tt = Ee(() => {
    if (r.multiple) {
      const { value: ae } = C;
      return Array.isArray(ae) ? qe(ae) : [];
    }
    return null;
  }), ut = Ee(() => {
    const { value: ae } = C;
    return !r.multiple && !Array.isArray(ae) ? ae === null ? null : qe([ae])[0] || null : null;
  }), mt = ka(r), { mergedSizeRef: St, mergedDisabledRef: st, mergedStatusRef: nt } = mt;
  function ft(ae, Pe) {
    const { onChange: xe, "onUpdate:value": Ve, onUpdateValue: et } = r, { nTriggerFormChange: We, nTriggerFormInput: xt } = mt;
    xe && Ot(xe, ae, Pe), et && Ot(et, ae, Pe), Ve && Ot(Ve, ae, Pe), p.value = ae, We(), xt();
  }
  function Lt(ae) {
    const { onBlur: Pe } = r, { nTriggerFormBlur: xe } = mt;
    Pe && Ot(Pe, ae), xe();
  }
  function pt() {
    const { onClear: ae } = r;
    ae && Ot(ae);
  }
  function wt(ae) {
    const { onFocus: Pe, showOnFocus: xe } = r, { nTriggerFormFocus: Ve } = mt;
    Pe && Ot(Pe, ae), Ve(), xe && Zt();
  }
  function Ft(ae) {
    const { onSearch: Pe } = r;
    Pe && Ot(Pe, ae);
  }
  function tr(ae) {
    const { onScroll: Pe } = r;
    Pe && Ot(Pe, ae);
  }
  function gt() {
    var ae;
    const { remote: Pe, multiple: xe } = r;
    if (Pe) {
      const { value: Ve } = _e;
      if (xe) {
        const { valueField: et } = r;
        (ae = tt.value) === null || ae === void 0 || ae.forEach((We) => {
          Ve.set(We[et], We);
        });
      } else {
        const et = ut.value;
        et && Ve.set(et[r.valueField], et);
      }
    }
  }
  function Bt(ae) {
    const { onUpdateShow: Pe, "onUpdate:show": xe } = r;
    Pe && Ot(Pe, ae), xe && Ot(xe, ae), te.value = ae;
  }
  function Zt() {
    st.value || (Bt(true), te.value = true, r.filterable && X());
  }
  function ir() {
    Bt(false);
  }
  function Cr() {
    M.value = "", $.value = he;
  }
  const Ar = Ie(false);
  function or() {
    r.filterable && (Ar.value = true);
  }
  function Tr() {
    r.filterable && (Ar.value = false, re.value || Cr());
  }
  function Xt() {
    st.value || (re.value ? r.filterable ? X() : ir() : Zt());
  }
  function Dr(ae) {
    var Pe, xe;
    !((xe = (Pe = we.value) === null || Pe === void 0 ? void 0 : Pe.selfRef) === null || xe === void 0) && xe.contains(ae.relatedTarget) || (P.value = false, Lt(ae), ir());
  }
  function nr(ae) {
    wt(ae), P.value = true;
  }
  function kt() {
    P.value = true;
  }
  function ze(ae) {
    var Pe;
    !((Pe = ie.value) === null || Pe === void 0) && Pe.$el.contains(ae.relatedTarget) || (P.value = false, Lt(ae), ir());
  }
  function at() {
    var ae;
    (ae = ie.value) === null || ae === void 0 || ae.focus(), ir();
  }
  function Oe(ae) {
    var Pe;
    re.value && (!((Pe = ie.value) === null || Pe === void 0) && Pe.$el.contains(Ky(ae)) || ir());
  }
  function Je(ae) {
    if (!Array.isArray(ae)) return [];
    if (Ue.value) return Array.from(ae);
    {
      const { remote: Pe } = r, { value: xe } = K;
      if (Pe) {
        const { value: Ve } = _e;
        return ae.filter((et) => xe.has(et) || Ve.has(et));
      } else return ae.filter((Ve) => xe.has(Ve));
    }
  }
  function ht(ae) {
    bt(ae.rawNode);
  }
  function bt(ae) {
    if (st.value) return;
    const { tag: Pe, remote: xe, clearFilterAfterSelect: Ve, valueField: et } = r;
    if (Pe && !xe) {
      const { value: We } = $, xt = We[0] || null;
      if (xt) {
        const Le = L.value;
        Le.length ? Le.push(xt) : L.value = [xt], $.value = he;
      }
    }
    if (xe && _e.value.set(ae[et], ae), r.multiple) {
      const We = Je(C.value), xt = We.findIndex((Le) => Le === ae[et]);
      if (~xt) {
        if (We.splice(xt, 1), Pe && !xe) {
          const Le = rt(ae[et]);
          ~Le && (L.value.splice(Le, 1), Ve && (M.value = ""));
        }
      } else We.push(ae[et]), Ve && (M.value = "");
      ft(We, qe(We));
    } else {
      if (Pe && !xe) {
        const We = rt(ae[et]);
        ~We ? L.value = [L.value[We]] : L.value = he;
      }
      Fe(), ir(), ft(ae[et], ae);
    }
  }
  function rt(ae) {
    return L.value.findIndex((xe) => xe[r.valueField] === ae);
  }
  function vt(ae) {
    re.value || Zt();
    const { value: Pe } = ae.target;
    M.value = Pe;
    const { tag: xe, remote: Ve } = r;
    if (Ft(Pe), xe && !Ve) {
      if (!Pe) {
        $.value = he;
        return;
      }
      const { onCreate: et } = r, We = et ? et(Pe) : { [r.labelField]: Pe, [r.valueField]: Pe }, { valueField: xt, labelField: Le } = r;
      D.value.some((rr) => rr[xt] === We[xt] || rr[Le] === We[Le]) || L.value.some((rr) => rr[xt] === We[xt] || rr[Le] === We[Le]) ? $.value = he : $.value = [We];
    }
  }
  function Wt(ae) {
    ae.stopPropagation();
    const { multiple: Pe } = r;
    !Pe && r.filterable && ir(), pt(), Pe ? ft([], []) : ft(null, null);
  }
  function ci(ae) {
    !zl(ae, "action") && !zl(ae, "empty") && !zl(ae, "header") && ae.preventDefault();
  }
  function Ai(ae) {
    tr(ae);
  }
  function sn(ae) {
    var Pe, xe, Ve, et, We;
    if (!r.keyboard) {
      ae.preventDefault();
      return;
    }
    switch (ae.key) {
      case " ":
        if (r.filterable) break;
        ae.preventDefault();
      case "Enter":
        if (!(!((Pe = ie.value) === null || Pe === void 0) && Pe.isComposing)) {
          if (re.value) {
            const xt = (xe = we.value) === null || xe === void 0 ? void 0 : xe.getPendingTmNode();
            xt ? ht(xt) : r.filterable || (ir(), Fe());
          } else if (Zt(), r.tag && Ar.value) {
            const xt = $.value[0];
            if (xt) {
              const Le = xt[r.valueField], { value: rr } = C;
              r.multiple && Array.isArray(rr) && rr.includes(Le) || bt(xt);
            }
          }
        }
        ae.preventDefault();
        break;
      case "ArrowUp":
        if (ae.preventDefault(), r.loading) return;
        re.value && ((Ve = we.value) === null || Ve === void 0 || Ve.prev());
        break;
      case "ArrowDown":
        if (ae.preventDefault(), r.loading) return;
        re.value ? (et = we.value) === null || et === void 0 || et.next() : Zt();
        break;
      case "Escape":
        re.value && (Yw(ae), ir()), (We = ie.value) === null || We === void 0 || We.focus();
        break;
    }
  }
  function Fe() {
    var ae;
    (ae = ie.value) === null || ae === void 0 || ae.focus();
  }
  function X() {
    var ae;
    (ae = ie.value) === null || ae === void 0 || ae.focusInput();
  }
  function Y() {
    var ae;
    re.value && ((ae = J.value) === null || ae === void 0 || ae.syncPosition());
  }
  gt(), Ht(zt(r, "options"), gt);
  const ne = { focus: () => {
    var ae;
    (ae = ie.value) === null || ae === void 0 || ae.focus();
  }, focusInput: () => {
    var ae;
    (ae = ie.value) === null || ae === void 0 || ae.focusInput();
  }, blur: () => {
    var ae;
    (ae = ie.value) === null || ae === void 0 || ae.blur();
  }, blurInput: () => {
    var ae;
    (ae = ie.value) === null || ae === void 0 || ae.blurInput();
  } }, ve = Ee(() => {
    const { self: { menuBoxShadow: ae } } = g.value;
    return { "--n-menu-box-shadow": ae };
  }), Ce = f ? ai("select", void 0, ve, r) : void 0;
  return Object.assign(Object.assign({}, ne), { mergedStatus: nt, mergedClsPrefix: i, mergedBordered: l, namespace: d, treeMate: q, isMounted: Ip(), triggerRef: ie, menuRef: we, pattern: M, uncontrolledShow: te, mergedShow: re, adjustedTo: dc(r), uncontrolledValue: p, mergedValue: C, followerRef: J, localizedPlaceholder: oe, selectedOption: ut, selectedOptions: tt, mergedSize: St, mergedDisabled: st, focused: P, activeWithoutMenuOpen: Ar, inlineThemeDisabled: f, onTriggerInputFocus: or, onTriggerInputBlur: Tr, handleTriggerOrMenuResize: Y, handleMenuFocus: kt, handleMenuBlur: ze, handleMenuTabOut: at, handleTriggerClick: Xt, handleToggle: ht, handleDeleteOption: bt, handlePatternInput: vt, handleClear: Wt, handleTriggerBlur: Dr, handleTriggerFocus: nr, handleKeydown: sn, handleMenuAfterLeave: Cr, handleMenuClickOutside: Oe, handleMenuScroll: Ai, handleMenuKeydown: sn, handleMenuMousedown: ci, mergedTheme: g, cssVars: f ? void 0 : ve, themeClass: Ce == null ? void 0 : Ce.themeClass, onRender: Ce == null ? void 0 : Ce.onRender });
}, render() {
  return B("div", { class: `${this.mergedClsPrefix}-select` }, B(Hy, null, { default: () => [B(Xy, null, { default: () => B(Gk, { ref: "triggerRef", inlineThemeDisabled: this.inlineThemeDisabled, status: this.mergedStatus, inputProps: this.inputProps, clsPrefix: this.mergedClsPrefix, showArrow: this.showArrow, maxTagCount: this.maxTagCount, ellipsisTagPopoverProps: this.ellipsisTagPopoverProps, bordered: this.mergedBordered, active: this.activeWithoutMenuOpen || this.mergedShow, pattern: this.pattern, placeholder: this.localizedPlaceholder, selectedOption: this.selectedOption, selectedOptions: this.selectedOptions, multiple: this.multiple, renderTag: this.renderTag, renderLabel: this.renderLabel, filterable: this.filterable, clearable: this.clearable, disabled: this.mergedDisabled, size: this.mergedSize, theme: this.mergedTheme.peers.InternalSelection, labelField: this.labelField, valueField: this.valueField, themeOverrides: this.mergedTheme.peerOverrides.InternalSelection, loading: this.loading, focused: this.focused, onClick: this.handleTriggerClick, onDeleteOption: this.handleDeleteOption, onPatternInput: this.handlePatternInput, onClear: this.handleClear, onBlur: this.handleTriggerBlur, onFocus: this.handleTriggerFocus, onKeydown: this.handleKeydown, onPatternBlur: this.onTriggerInputBlur, onPatternFocus: this.onTriggerInputFocus, onResize: this.handleTriggerOrMenuResize, ignoreComposition: this.ignoreComposition }, { arrow: () => {
    var r, i;
    return [(i = (r = this.$slots).arrow) === null || i === void 0 ? void 0 : i.call(r)];
  } }) }), B(Yy, { ref: "followerRef", show: this.mergedShow, to: this.adjustedTo, teleportDisabled: this.adjustedTo === dc.tdkey, containerClass: this.namespace, width: this.consistentMenuWidth ? "target" : void 0, minWidth: "target", placement: this.placement }, { default: () => B(Eo, { name: "fade-in-scale-up-transition", appear: this.isMounted, onAfterLeave: this.handleMenuAfterLeave }, { default: () => {
    var r, i, l;
    return this.mergedShow || this.displayDirective === "show" ? ((r = this.onRender) === null || r === void 0 || r.call(this), wa(B($k, Object.assign({}, this.menuProps, { ref: "menuRef", onResize: this.handleTriggerOrMenuResize, inlineThemeDisabled: this.inlineThemeDisabled, virtualScroll: this.consistentMenuWidth && this.virtualScroll, class: [`${this.mergedClsPrefix}-select-menu`, this.themeClass, (i = this.menuProps) === null || i === void 0 ? void 0 : i.class], clsPrefix: this.mergedClsPrefix, focusable: true, labelField: this.labelField, valueField: this.valueField, autoPending: true, nodeProps: this.nodeProps, theme: this.mergedTheme.peers.InternalSelectMenu, themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu, treeMate: this.treeMate, multiple: this.multiple, size: this.menuSize, renderOption: this.renderOption, renderLabel: this.renderLabel, value: this.mergedValue, style: [(l = this.menuProps) === null || l === void 0 ? void 0 : l.style, this.cssVars], onToggle: this.handleToggle, onScroll: this.handleMenuScroll, onFocus: this.handleMenuFocus, onBlur: this.handleMenuBlur, onKeydown: this.handleMenuKeydown, onTabOut: this.handleMenuTabOut, onMousedown: this.handleMenuMousedown, show: this.mergedShow, showCheckmark: this.showCheckmark, resetMenuOnOptionsChange: this.resetMenuOnOptionsChange }), { empty: () => {
      var d, f;
      return [(f = (d = this.$slots).empty) === null || f === void 0 ? void 0 : f.call(d)];
    }, header: () => {
      var d, f;
      return [(f = (d = this.$slots).header) === null || f === void 0 ? void 0 : f.call(d)];
    }, action: () => {
      var d, f;
      return [(f = (d = this.$slots).action) === null || f === void 0 ? void 0 : f.call(d)];
    } }), this.displayDirective === "show" ? [[ns, this.mergedShow], [up, this.handleMenuClickOutside, void 0, { capture: true }]] : [[up, this.handleMenuClickOutside, void 0, { capture: true }]])) : null;
  } }) })] }));
} }), e5 = { name: String, value: { type: [String, Number, Boolean], default: "on" }, checked: { type: Boolean, default: void 0 }, defaultChecked: Boolean, disabled: { type: Boolean, default: void 0 }, label: String, size: String, onUpdateChecked: [Function, Array], "onUpdate:checked": [Function, Array], checkedValue: { type: Boolean, default: void 0 } }, Gb = $n("n-radio-group");
function t5(r) {
  const i = ur(Gb, null), l = ka(r, { mergedSize(K) {
    const { size: te } = r;
    if (te !== void 0) return te;
    if (i) {
      const { mergedSizeRef: { value: re } } = i;
      if (re !== void 0) return re;
    }
    return K ? K.mergedSize.value : "medium";
  }, mergedDisabled(K) {
    return !!(r.disabled || (i == null ? void 0 : i.disabledRef.value) || (K == null ? void 0 : K.disabled.value));
  } }), { mergedSizeRef: d, mergedDisabledRef: f } = l, g = Ie(null), p = Ie(null), s = Ie(r.defaultChecked), C = zt(r, "checked"), P = Ji(C, s), M = vi(() => i ? i.valueRef.value === r.value : P.value), D = vi(() => {
    const { name: K } = r;
    if (K !== void 0) return K;
    if (i) return i.nameRef.value;
  }), L = Ie(false);
  function $() {
    if (i) {
      const { doUpdateValue: K } = i, { value: te } = r;
      Ot(K, te);
    } else {
      const { onUpdateChecked: K, "onUpdate:checked": te } = r, { nTriggerFormInput: re, nTriggerFormChange: ie } = l;
      K && Ot(K, true), te && Ot(te, true), re(), ie(), s.value = true;
    }
  }
  function z() {
    f.value || M.value || $();
  }
  function F() {
    z(), g.value && (g.value.checked = M.value);
  }
  function Z() {
    L.value = false;
  }
  function q() {
    L.value = true;
  }
  return { mergedClsPrefix: i ? i.mergedClsPrefixRef : Sr(r).mergedClsPrefixRef, inputRef: g, labelRef: p, mergedName: D, mergedDisabled: f, renderSafeChecked: M, focus: L, mergedSize: d, handleRadioInputChange: F, handleRadioInputBlur: Z, handleRadioInputFocus: q };
}
const r5 = ot({ name: "RadioButton", props: e5, setup: t5, render() {
  const { mergedClsPrefix: r } = this;
  return B("label", { class: [`${r}-radio-button`, this.mergedDisabled && `${r}-radio-button--disabled`, this.renderSafeChecked && `${r}-radio-button--checked`, this.focus && [`${r}-radio-button--focus`]] }, B("input", { ref: "inputRef", type: "radio", class: `${r}-radio-input`, value: this.value, name: this.mergedName, checked: this.renderSafeChecked, disabled: this.mergedDisabled, onChange: this.handleRadioInputChange, onFocus: this.handleRadioInputFocus, onBlur: this.handleRadioInputBlur }), B("div", { class: `${r}-radio-button__state-border` }), oi(this.$slots.default, (i) => !i && !this.label ? null : B("div", { ref: "labelRef", class: `${r}-radio__label` }, i || this.label)));
} }), i5 = ue("radio-group", `
 display: inline-block;
 font-size: var(--n-font-size);
`, [Ae("splitor", `
 display: inline-block;
 vertical-align: bottom;
 width: 1px;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 background: var(--n-button-border-color);
 `, [Ge("checked", { backgroundColor: "var(--n-button-border-color-active)" }), Ge("disabled", { opacity: "var(--n-opacity-disabled)" })]), Ge("button-group", `
 white-space: nowrap;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [ue("radio-button", { height: "var(--n-height)", lineHeight: "var(--n-height)" }), Ae("splitor", { height: "var(--n-height)" })]), ue("radio-button", `
 vertical-align: bottom;
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-block;
 box-sizing: border-box;
 padding-left: 14px;
 padding-right: 14px;
 white-space: nowrap;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background: var(--n-button-color);
 color: var(--n-button-text-color);
 border-top: 1px solid var(--n-button-border-color);
 border-bottom: 1px solid var(--n-button-border-color);
 `, [ue("radio-input", `
 pointer-events: none;
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 `), Ae("state-border", `
 z-index: 1;
 pointer-events: none;
 position: absolute;
 box-shadow: var(--n-button-box-shadow);
 transition: box-shadow .3s var(--n-bezier);
 left: -1px;
 bottom: -1px;
 right: -1px;
 top: -1px;
 `), Ze("&:first-child", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 border-left: 1px solid var(--n-button-border-color);
 `, [Ae("state-border", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 `)]), Ze("&:last-child", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 border-right: 1px solid var(--n-button-border-color);
 `, [Ae("state-border", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 `)]), ui("disabled", `
 cursor: pointer;
 `, [Ze("&:hover", [Ae("state-border", `
 transition: box-shadow .3s var(--n-bezier);
 box-shadow: var(--n-button-box-shadow-hover);
 `), ui("checked", { color: "var(--n-button-text-color-hover)" })]), Ge("focus", [Ze("&:not(:active)", [Ae("state-border", { boxShadow: "var(--n-button-box-shadow-focus)" })])])]), Ge("checked", `
 background: var(--n-button-color-active);
 color: var(--n-button-text-color-active);
 border-color: var(--n-button-border-color-active);
 `), Ge("disabled", `
 cursor: not-allowed;
 opacity: var(--n-opacity-disabled);
 `)])]);
function n5(r, i, l) {
  var d;
  const f = [];
  let g = false;
  for (let p = 0; p < r.length; ++p) {
    const s = r[p], C = (d = s.type) === null || d === void 0 ? void 0 : d.name;
    C === "RadioButton" && (g = true);
    const P = s.props;
    if (C !== "RadioButton") {
      f.push(s);
      continue;
    }
    if (p === 0) f.push(s);
    else {
      const M = f[f.length - 1].props, D = i === M.value, L = M.disabled, $ = i === P.value, z = P.disabled, F = (D ? 2 : 0) + (L ? 0 : 1), Z = ($ ? 2 : 0) + (z ? 0 : 1), q = { [`${l}-radio-group__splitor--disabled`]: L, [`${l}-radio-group__splitor--checked`]: D }, K = { [`${l}-radio-group__splitor--disabled`]: z, [`${l}-radio-group__splitor--checked`]: $ }, te = F < Z ? K : q;
      f.push(B("div", { class: [`${l}-radio-group__splitor`, te] }), s);
    }
  }
  return { children: f, isButtonGroup: g };
}
const o5 = Object.assign(Object.assign({}, Jt.props), { name: String, value: [String, Number, Boolean], defaultValue: { type: [String, Number, Boolean], default: null }, size: String, disabled: { type: Boolean, default: void 0 }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array] }), a5 = ot({ name: "RadioGroup", props: o5, setup(r) {
  const i = Ie(null), { mergedSizeRef: l, mergedDisabledRef: d, nTriggerFormChange: f, nTriggerFormInput: g, nTriggerFormBlur: p, nTriggerFormFocus: s } = ka(r), { mergedClsPrefixRef: C, inlineThemeDisabled: P, mergedRtlRef: M } = Sr(r), D = Jt("Radio", "-radio-group", i5, Kw, r, C), L = Ie(r.defaultValue), $ = zt(r, "value"), z = Ji($, L);
  function F(ie) {
    const { onUpdateValue: J, "onUpdate:value": we } = r;
    J && Ot(J, ie), we && Ot(we, ie), L.value = ie, f(), g();
  }
  function Z(ie) {
    const { value: J } = i;
    J && (J.contains(ie.relatedTarget) || s());
  }
  function q(ie) {
    const { value: J } = i;
    J && (J.contains(ie.relatedTarget) || p());
  }
  Xr(Gb, { mergedClsPrefixRef: C, nameRef: zt(r, "name"), valueRef: z, disabledRef: d, mergedSizeRef: l, doUpdateValue: F });
  const K = Tn("Radio", M, C), te = Ee(() => {
    const { value: ie } = l, { common: { cubicBezierEaseInOut: J }, self: { buttonBorderColor: we, buttonBorderColorActive: fe, buttonBorderRadius: oe, buttonBoxShadow: he, buttonBoxShadowFocus: _e, buttonBoxShadowHover: Ue, buttonColor: qe, buttonColorActive: tt, buttonTextColor: ut, buttonTextColorActive: mt, buttonTextColorHover: St, opacityDisabled: st, [Vt("buttonHeight", ie)]: nt, [Vt("fontSize", ie)]: ft } } = D.value;
    return { "--n-font-size": ft, "--n-bezier": J, "--n-button-border-color": we, "--n-button-border-color-active": fe, "--n-button-border-radius": oe, "--n-button-box-shadow": he, "--n-button-box-shadow-focus": _e, "--n-button-box-shadow-hover": Ue, "--n-button-color": qe, "--n-button-color-active": tt, "--n-button-text-color": ut, "--n-button-text-color-hover": St, "--n-button-text-color-active": mt, "--n-height": nt, "--n-opacity-disabled": st };
  }), re = P ? ai("radio-group", Ee(() => l.value[0]), te, r) : void 0;
  return { selfElRef: i, rtlEnabled: K, mergedClsPrefix: C, mergedValue: z, handleFocusout: q, handleFocusin: Z, cssVars: P ? void 0 : te, themeClass: re == null ? void 0 : re.themeClass, onRender: re == null ? void 0 : re.onRender };
}, render() {
  var r;
  const { mergedValue: i, mergedClsPrefix: l, handleFocusin: d, handleFocusout: f } = this, { children: g, isButtonGroup: p } = n5(Bl(Ep(this)), i, l);
  return (r = this.onRender) === null || r === void 0 || r.call(this), B("div", { onFocusin: d, onFocusout: f, ref: "selfElRef", class: [`${l}-radio-group`, this.rtlEnabled && `${l}-radio-group--rtl`, this.themeClass, p && `${l}-radio-group--button-group`], style: this.cssVars }, g);
} }), qb = ue("ellipsis", { overflow: "hidden" }, [ui("line-clamp", `
 white-space: nowrap;
 display: inline-block;
 vertical-align: bottom;
 max-width: 100%;
 `), Ge("line-clamp", `
 display: -webkit-inline-box;
 -webkit-box-orient: vertical;
 `), Ge("cursor-pointer", `
 cursor: pointer;
 `)]);
function Og(r) {
  return `${r}-ellipsis--line-clamp`;
}
function $g(r, i) {
  return `${r}-ellipsis--cursor-${i}`;
}
const Wb = Object.assign(Object.assign({}, Jt.props), { expandTrigger: String, lineClamp: [Number, String], tooltip: { type: [Boolean, Object], default: true } }), s5 = ot({ name: "Ellipsis", inheritAttrs: false, props: Wb, slots: Object, setup(r, { slots: i, attrs: l }) {
  const d = Qy(), f = Jt("Ellipsis", "-ellipsis", qb, Jw, r, d), g = Ie(null), p = Ie(null), s = Ie(null), C = Ie(false), P = Ee(() => {
    const { lineClamp: Z } = r, { value: q } = C;
    return Z !== void 0 ? { textOverflow: "", "-webkit-line-clamp": q ? "" : Z } : { textOverflow: q ? "" : "ellipsis", "-webkit-line-clamp": "" };
  });
  function M() {
    let Z = false;
    const { value: q } = C;
    if (q) return true;
    const { value: K } = g;
    if (K) {
      const { lineClamp: te } = r;
      if ($(K), te !== void 0) Z = K.scrollHeight <= K.offsetHeight;
      else {
        const { value: re } = p;
        re && (Z = re.getBoundingClientRect().width <= K.getBoundingClientRect().width);
      }
      z(K, Z);
    }
    return Z;
  }
  const D = Ee(() => r.expandTrigger === "click" ? () => {
    var Z;
    const { value: q } = C;
    q && ((Z = s.value) === null || Z === void 0 || Z.setShow(false)), C.value = !q;
  } : void 0);
  Ly(() => {
    var Z;
    r.tooltip && ((Z = s.value) === null || Z === void 0 || Z.setShow(false));
  });
  const L = () => B("span", Object.assign({}, is(l, { class: [`${d.value}-ellipsis`, r.lineClamp !== void 0 ? Og(d.value) : void 0, r.expandTrigger === "click" ? $g(d.value, "pointer") : void 0], style: P.value }), { ref: "triggerRef", onClick: D.value, onMouseenter: r.expandTrigger === "click" ? M : void 0 }), r.lineClamp ? i : B("span", { ref: "triggerInnerRef" }, i));
  function $(Z) {
    if (!Z) return;
    const q = P.value, K = Og(d.value);
    r.lineClamp !== void 0 ? F(Z, K, "add") : F(Z, K, "remove");
    for (const te in q) Z.style[te] !== q[te] && (Z.style[te] = q[te]);
  }
  function z(Z, q) {
    const K = $g(d.value, "pointer");
    r.expandTrigger === "click" && !q ? F(Z, K, "add") : F(Z, K, "remove");
  }
  function F(Z, q, K) {
    K === "add" ? Z.classList.contains(q) || Z.classList.add(q) : Z.classList.contains(q) && Z.classList.remove(q);
  }
  return { mergedTheme: f, triggerRef: g, triggerInnerRef: p, tooltipRef: s, handleClick: D, renderTrigger: L, getTooltipDisabled: M };
}, render() {
  var r;
  const { tooltip: i, renderTrigger: l, $slots: d } = this;
  if (i) {
    const { mergedTheme: f } = this;
    return B(Jy, Object.assign({ ref: "tooltipRef", placement: "top" }, i, { getDisabled: this.getTooltipDisabled, theme: f.peers.Tooltip, themeOverrides: f.peerOverrides.Tooltip }), { trigger: l, default: (r = d.tooltip) !== null && r !== void 0 ? r : d.default });
  } else return l();
} }), Zb = ot({ name: "PerformantEllipsis", props: Wb, inheritAttrs: false, setup(r, { attrs: i, slots: l }) {
  const d = Ie(false), f = Qy();
  return yc("-ellipsis", qb, f), { mouseEntered: d, renderTrigger: () => {
    const { lineClamp: p } = r, s = f.value;
    return B("span", Object.assign({}, is(i, { class: [`${s}-ellipsis`, p !== void 0 ? Og(s) : void 0, r.expandTrigger === "click" ? $g(s, "pointer") : void 0], style: p === void 0 ? { textOverflow: "ellipsis" } : { "-webkit-line-clamp": p } }), { onMouseenter: () => {
      d.value = true;
    } }), p ? l : B("span", null, l));
  } };
}, render() {
  return this.mouseEntered ? B(s5, is({}, this.$attrs, this.$props), this.$slots) : this.renderTrigger();
} });
function Hb() {
  const r = ur(Qw, null);
  return r === null && ea("use-dialog", "No outer <n-dialog-provider /> founded."), r;
}
function Ap() {
  const r = ur(e3, null);
  return r === null && ea("use-message", "No outer <n-message-provider /> founded. See prerequisite in https://www.naiveui.com/en-US/os-theme/components/message for more details. If you want to use `useMessage` outside setup, please check https://www.naiveui.com/zh-CN/os-theme/components/message#Q-&-A."), r;
}
const l5 = ue("divider", `
 position: relative;
 display: flex;
 width: 100%;
 box-sizing: border-box;
 font-size: 16px;
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
`, [ui("vertical", `
 margin-top: 24px;
 margin-bottom: 24px;
 `, [ui("no-title", `
 display: flex;
 align-items: center;
 `)]), Ae("title", `
 display: flex;
 align-items: center;
 margin-left: 12px;
 margin-right: 12px;
 white-space: nowrap;
 font-weight: var(--n-font-weight);
 `), Ge("title-position-left", [Ae("line", [Ge("left", { width: "28px" })])]), Ge("title-position-right", [Ae("line", [Ge("right", { width: "28px" })])]), Ge("dashed", [Ae("line", `
 background-color: #0000;
 height: 0px;
 width: 100%;
 border-style: dashed;
 border-width: 1px 0 0;
 `)]), Ge("vertical", `
 display: inline-block;
 height: 1em;
 margin: 0 8px;
 vertical-align: middle;
 width: 1px;
 `), Ae("line", `
 border: none;
 transition: background-color .3s var(--n-bezier), border-color .3s var(--n-bezier);
 height: 1px;
 width: 100%;
 margin: 0;
 `), ui("dashed", [Ae("line", { backgroundColor: "var(--n-color)" })]), Ge("dashed", [Ae("line", { borderColor: "var(--n-color)" })]), Ge("vertical", { backgroundColor: "var(--n-color)" })]), u5 = Object.assign(Object.assign({}, Jt.props), { titlePlacement: { type: String, default: "center" }, dashed: Boolean, vertical: Boolean }), Xb = ot({ name: "Divider", props: u5, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Sr(r), d = Jt("Divider", "-divider", l5, t3, r, i), f = Ee(() => {
    const { common: { cubicBezierEaseInOut: p }, self: { color: s, textColor: C, fontWeight: P } } = d.value;
    return { "--n-bezier": p, "--n-color": s, "--n-text-color": C, "--n-font-weight": P };
  }), g = l ? ai("divider", void 0, f, r) : void 0;
  return { mergedClsPrefix: i, cssVars: l ? void 0 : f, themeClass: g == null ? void 0 : g.themeClass, onRender: g == null ? void 0 : g.onRender };
}, render() {
  var r;
  const { $slots: i, titlePlacement: l, vertical: d, dashed: f, cssVars: g, mergedClsPrefix: p } = this;
  return (r = this.onRender) === null || r === void 0 || r.call(this), B("div", { role: "separator", class: [`${p}-divider`, this.themeClass, { [`${p}-divider--vertical`]: d, [`${p}-divider--no-title`]: !i.default, [`${p}-divider--dashed`]: f, [`${p}-divider--title-position-${l}`]: i.default && l }], style: g }, d ? null : B("div", { class: `${p}-divider__line ${p}-divider__line--left` }), !d && i.default ? B(Wr, null, B("div", { class: `${p}-divider__title` }, this.$slots), B("div", { class: `${p}-divider__line ${p}-divider__line--right` })) : null);
} }), c5 = ot({ name: "NDrawerContent", inheritAttrs: false, props: { blockScroll: Boolean, show: { type: Boolean, default: void 0 }, displayDirective: { type: String, required: true }, placement: { type: String, required: true }, contentClass: String, contentStyle: [Object, String], nativeScrollbar: { type: Boolean, required: true }, scrollbarProps: Object, trapFocus: { type: Boolean, default: true }, autoFocus: { type: Boolean, default: true }, showMask: { type: [Boolean, String], required: true }, maxWidth: Number, maxHeight: Number, minWidth: Number, minHeight: Number, resizable: Boolean, onClickoutside: Function, onAfterLeave: Function, onAfterEnter: Function, onEsc: Function }, setup(r) {
  const i = Ie(!!r.show), l = Ie(null), d = ur(l0);
  let f = 0, g = "", p = null;
  const s = Ie(false), C = Ie(false), P = Ee(() => r.placement === "top" || r.placement === "bottom"), { mergedClsPrefixRef: M, mergedRtlRef: D } = Sr(r), L = Tn("Drawer", D, M), $ = J, z = (oe) => {
    C.value = true, f = P.value ? oe.clientY : oe.clientX, g = document.body.style.cursor, document.body.style.cursor = P.value ? "ns-resize" : "ew-resize", document.body.addEventListener("mousemove", ie), document.body.addEventListener("mouseleave", $), document.body.addEventListener("mouseup", J);
  }, F = () => {
    p !== null && (window.clearTimeout(p), p = null), C.value ? s.value = true : p = window.setTimeout(() => {
      s.value = true;
    }, 300);
  }, Z = () => {
    p !== null && (window.clearTimeout(p), p = null), s.value = false;
  }, { doUpdateHeight: q, doUpdateWidth: K } = d, te = (oe) => {
    const { maxWidth: he } = r;
    if (he && oe > he) return he;
    const { minWidth: _e } = r;
    return _e && oe < _e ? _e : oe;
  }, re = (oe) => {
    const { maxHeight: he } = r;
    if (he && oe > he) return he;
    const { minHeight: _e } = r;
    return _e && oe < _e ? _e : oe;
  };
  function ie(oe) {
    var he, _e;
    if (C.value) if (P.value) {
      let Ue = ((he = l.value) === null || he === void 0 ? void 0 : he.offsetHeight) || 0;
      const qe = f - oe.clientY;
      Ue += r.placement === "bottom" ? qe : -qe, Ue = re(Ue), q(Ue), f = oe.clientY;
    } else {
      let Ue = ((_e = l.value) === null || _e === void 0 ? void 0 : _e.offsetWidth) || 0;
      const qe = f - oe.clientX;
      Ue += r.placement === "right" ? qe : -qe, Ue = te(Ue), K(Ue), f = oe.clientX;
    }
  }
  function J() {
    C.value && (f = 0, C.value = false, document.body.style.cursor = g, document.body.removeEventListener("mousemove", ie), document.body.removeEventListener("mouseup", J), document.body.removeEventListener("mouseleave", $));
  }
  bo(() => {
    r.show && (i.value = true);
  }), Ht(() => r.show, (oe) => {
    oe || J();
  }), Pn(() => {
    J();
  });
  const we = Ee(() => {
    const { show: oe } = r, he = [[ns, oe]];
    return r.showMask || he.push([up, r.onClickoutside, void 0, { capture: true }]), he;
  });
  function fe() {
    var oe;
    i.value = false, (oe = r.onAfterLeave) === null || oe === void 0 || oe.call(r);
  }
  return i3(Ee(() => r.blockScroll && i.value)), Xr(n3, l), Xr(o3, null), Xr(a3, null), { bodyRef: l, rtlEnabled: L, mergedClsPrefix: d.mergedClsPrefixRef, isMounted: d.isMountedRef, mergedTheme: d.mergedThemeRef, displayed: i, transitionName: Ee(() => ({ right: "slide-in-from-right-transition", left: "slide-in-from-left-transition", top: "slide-in-from-top-transition", bottom: "slide-in-from-bottom-transition" })[r.placement]), handleAfterLeave: fe, bodyDirectives: we, handleMousedownResizeTrigger: z, handleMouseenterResizeTrigger: F, handleMouseleaveResizeTrigger: Z, isDragging: C, isHoverOnResizeTrigger: s };
}, render() {
  const { $slots: r, mergedClsPrefix: i } = this;
  return this.displayDirective === "show" || this.displayed || this.show ? wa(B("div", { role: "none" }, B(r3, { disabled: !this.showMask || !this.trapFocus, active: this.show, autoFocus: this.autoFocus, onEsc: this.onEsc }, { default: () => B(Eo, { name: this.transitionName, appear: this.isMounted, onAfterEnter: this.onAfterEnter, onAfterLeave: this.handleAfterLeave }, { default: () => wa(B("div", is(this.$attrs, { role: "dialog", ref: "bodyRef", "aria-modal": "true", class: [`${i}-drawer`, this.rtlEnabled && `${i}-drawer--rtl`, `${i}-drawer--${this.placement}-placement`, this.isDragging && `${i}-drawer--unselectable`, this.nativeScrollbar && `${i}-drawer--native-scrollbar`] }), [this.resizable ? B("div", { class: [`${i}-drawer__resize-trigger`, (this.isDragging || this.isHoverOnResizeTrigger) && `${i}-drawer__resize-trigger--hover`], onMouseenter: this.handleMouseenterResizeTrigger, onMouseleave: this.handleMouseleaveResizeTrigger, onMousedown: this.handleMousedownResizeTrigger }) : null, this.nativeScrollbar ? B("div", { class: [`${i}-drawer-content-wrapper`, this.contentClass], style: this.contentStyle, role: "none" }, r) : B(uh, Object.assign({}, this.scrollbarProps, { contentStyle: this.contentStyle, contentClass: [`${i}-drawer-content-wrapper`, this.contentClass], theme: this.mergedTheme.peers.Scrollbar, themeOverrides: this.mergedTheme.peerOverrides.Scrollbar }), r)]), this.bodyDirectives) }) })), [[ns, this.displayDirective === "if" || this.displayed || this.show]]) : null;
} }), { cubicBezierEaseIn: d5, cubicBezierEaseOut: h5 } = ch;
function f5({ duration: r = "0.3s", leaveDuration: i = "0.2s", name: l = "slide-in-from-bottom" } = {}) {
  return [Ze(`&.${l}-transition-leave-active`, { transition: `transform ${i} ${d5}` }), Ze(`&.${l}-transition-enter-active`, { transition: `transform ${r} ${h5}` }), Ze(`&.${l}-transition-enter-to`, { transform: "translateY(0)" }), Ze(`&.${l}-transition-enter-from`, { transform: "translateY(100%)" }), Ze(`&.${l}-transition-leave-from`, { transform: "translateY(0)" }), Ze(`&.${l}-transition-leave-to`, { transform: "translateY(100%)" })];
}
const { cubicBezierEaseIn: p5, cubicBezierEaseOut: m5 } = ch;
function g5({ duration: r = "0.3s", leaveDuration: i = "0.2s", name: l = "slide-in-from-left" } = {}) {
  return [Ze(`&.${l}-transition-leave-active`, { transition: `transform ${i} ${p5}` }), Ze(`&.${l}-transition-enter-active`, { transition: `transform ${r} ${m5}` }), Ze(`&.${l}-transition-enter-to`, { transform: "translateX(0)" }), Ze(`&.${l}-transition-enter-from`, { transform: "translateX(-100%)" }), Ze(`&.${l}-transition-leave-from`, { transform: "translateX(0)" }), Ze(`&.${l}-transition-leave-to`, { transform: "translateX(-100%)" })];
}
const { cubicBezierEaseIn: v5, cubicBezierEaseOut: _5 } = ch;
function y5({ duration: r = "0.3s", leaveDuration: i = "0.2s", name: l = "slide-in-from-right" } = {}) {
  return [Ze(`&.${l}-transition-leave-active`, { transition: `transform ${i} ${v5}` }), Ze(`&.${l}-transition-enter-active`, { transition: `transform ${r} ${_5}` }), Ze(`&.${l}-transition-enter-to`, { transform: "translateX(0)" }), Ze(`&.${l}-transition-enter-from`, { transform: "translateX(100%)" }), Ze(`&.${l}-transition-leave-from`, { transform: "translateX(0)" }), Ze(`&.${l}-transition-leave-to`, { transform: "translateX(100%)" })];
}
const { cubicBezierEaseIn: b5, cubicBezierEaseOut: x5 } = ch;
function w5({ duration: r = "0.3s", leaveDuration: i = "0.2s", name: l = "slide-in-from-top" } = {}) {
  return [Ze(`&.${l}-transition-leave-active`, { transition: `transform ${i} ${b5}` }), Ze(`&.${l}-transition-enter-active`, { transition: `transform ${r} ${x5}` }), Ze(`&.${l}-transition-enter-to`, { transform: "translateY(0)" }), Ze(`&.${l}-transition-enter-from`, { transform: "translateY(-100%)" }), Ze(`&.${l}-transition-leave-from`, { transform: "translateY(0)" }), Ze(`&.${l}-transition-leave-to`, { transform: "translateY(-100%)" })];
}
const C5 = Ze([ue("drawer", `
 word-break: break-word;
 line-height: var(--n-line-height);
 position: absolute;
 pointer-events: all;
 box-shadow: var(--n-box-shadow);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background-color: var(--n-color);
 color: var(--n-text-color);
 box-sizing: border-box;
 `, [y5(), g5(), w5(), f5(), Ge("unselectable", `
 user-select: none; 
 -webkit-user-select: none;
 `), Ge("native-scrollbar", [ue("drawer-content-wrapper", `
 overflow: auto;
 height: 100%;
 `)]), Ae("resize-trigger", `
 position: absolute;
 background-color: #0000;
 transition: background-color .3s var(--n-bezier);
 `, [Ge("hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `)]), ue("drawer-content-wrapper", `
 box-sizing: border-box;
 `), ue("drawer-content", `
 height: 100%;
 display: flex;
 flex-direction: column;
 `, [Ge("native-scrollbar", [ue("drawer-body-content-wrapper", `
 height: 100%;
 overflow: auto;
 `)]), ue("drawer-body", `
 flex: 1 0 0;
 overflow: hidden;
 `), ue("drawer-body-content-wrapper", `
 box-sizing: border-box;
 padding: var(--n-body-padding);
 `), ue("drawer-header", `
 font-weight: var(--n-title-font-weight);
 line-height: 1;
 font-size: var(--n-title-font-size);
 color: var(--n-title-text-color);
 padding: var(--n-header-padding);
 transition: border .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-divider-color);
 border-bottom: var(--n-header-border-bottom);
 display: flex;
 justify-content: space-between;
 align-items: center;
 `, [Ae("main", `
 flex: 1;
 `), Ae("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), ue("drawer-footer", `
 display: flex;
 justify-content: flex-end;
 border-top: var(--n-footer-border-top);
 transition: border .3s var(--n-bezier);
 padding: var(--n-footer-padding);
 `)]), Ge("right-placement", `
 top: 0;
 bottom: 0;
 right: 0;
 border-top-left-radius: var(--n-border-radius);
 border-bottom-left-radius: var(--n-border-radius);
 `, [Ae("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 left: 0;
 transform: translateX(-1.5px);
 cursor: ew-resize;
 `)]), Ge("left-placement", `
 top: 0;
 bottom: 0;
 left: 0;
 border-top-right-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [Ae("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 right: 0;
 transform: translateX(1.5px);
 cursor: ew-resize;
 `)]), Ge("top-placement", `
 top: 0;
 left: 0;
 right: 0;
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [Ae("resize-trigger", `
 width: 100%;
 height: 3px;
 bottom: 0;
 left: 0;
 transform: translateY(1.5px);
 cursor: ns-resize;
 `)]), Ge("bottom-placement", `
 left: 0;
 bottom: 0;
 right: 0;
 border-top-left-radius: var(--n-border-radius);
 border-top-right-radius: var(--n-border-radius);
 `, [Ae("resize-trigger", `
 width: 100%;
 height: 3px;
 top: 0;
 left: 0;
 transform: translateY(-1.5px);
 cursor: ns-resize;
 `)])]), Ze("body", [Ze(">", [ue("drawer-container", `
 position: fixed;
 `)])]), ue("drawer-container", `
 position: relative;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 `, [Ze("> *", `
 pointer-events: all;
 `)]), ue("drawer-mask", `
 background-color: rgba(0, 0, 0, .3);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [Ge("invisible", `
 background-color: rgba(0, 0, 0, 0)
 `), dp({ enterDuration: "0.2s", leaveDuration: "0.2s", enterCubicBezier: "var(--n-bezier-in)", leaveCubicBezier: "var(--n-bezier-out)" })])]), S5 = Object.assign(Object.assign({}, Jt.props), { show: Boolean, width: [Number, String], height: [Number, String], placement: { type: String, default: "right" }, maskClosable: { type: Boolean, default: true }, showMask: { type: [Boolean, String], default: true }, to: [String, Object], displayDirective: { type: String, default: "if" }, nativeScrollbar: { type: Boolean, default: true }, zIndex: Number, onMaskClick: Function, scrollbarProps: Object, contentClass: String, contentStyle: [Object, String], trapFocus: { type: Boolean, default: true }, onEsc: Function, autoFocus: { type: Boolean, default: true }, closeOnEsc: { type: Boolean, default: true }, blockScroll: { type: Boolean, default: true }, maxWidth: Number, maxHeight: Number, minWidth: Number, minHeight: Number, resizable: Boolean, defaultWidth: { type: [Number, String], default: 251 }, defaultHeight: { type: [Number, String], default: 251 }, onUpdateWidth: [Function, Array], onUpdateHeight: [Function, Array], "onUpdate:width": [Function, Array], "onUpdate:height": [Function, Array], "onUpdate:show": [Function, Array], onUpdateShow: [Function, Array], onAfterEnter: Function, onAfterLeave: Function, drawerStyle: [String, Object], drawerClass: String, target: null, onShow: Function, onHide: Function }), Yb = ot({ name: "Drawer", inheritAttrs: false, props: S5, setup(r) {
  const { mergedClsPrefixRef: i, namespaceRef: l, inlineThemeDisabled: d } = Sr(r), f = Ip(), g = Jt("Drawer", "-drawer", C5, s3, r, i), p = Ie(r.defaultWidth), s = Ie(r.defaultHeight), C = Ji(zt(r, "width"), p), P = Ji(zt(r, "height"), s), M = Ee(() => {
    const { placement: J } = r;
    return J === "top" || J === "bottom" ? "" : Ko(C.value);
  }), D = Ee(() => {
    const { placement: J } = r;
    return J === "left" || J === "right" ? "" : Ko(P.value);
  }), L = (J) => {
    const { onUpdateWidth: we, "onUpdate:width": fe } = r;
    we && Ot(we, J), fe && Ot(fe, J), p.value = J;
  }, $ = (J) => {
    const { onUpdateHeight: we, "onUpdate:width": fe } = r;
    we && Ot(we, J), fe && Ot(fe, J), s.value = J;
  }, z = Ee(() => [{ width: M.value, height: D.value }, r.drawerStyle || ""]);
  function F(J) {
    const { onMaskClick: we, maskClosable: fe } = r;
    fe && te(false), we && we(J);
  }
  function Z(J) {
    F(J);
  }
  const q = l3();
  function K(J) {
    var we;
    (we = r.onEsc) === null || we === void 0 || we.call(r), r.show && r.closeOnEsc && u3(J) && (q.value || te(false));
  }
  function te(J) {
    const { onHide: we, onUpdateShow: fe, "onUpdate:show": oe } = r;
    fe && Ot(fe, J), oe && Ot(oe, J), we && !J && Ot(we, J);
  }
  Xr(l0, { isMountedRef: f, mergedThemeRef: g, mergedClsPrefixRef: i, doUpdateShow: te, doUpdateHeight: $, doUpdateWidth: L });
  const re = Ee(() => {
    const { common: { cubicBezierEaseInOut: J, cubicBezierEaseIn: we, cubicBezierEaseOut: fe }, self: { color: oe, textColor: he, boxShadow: _e, lineHeight: Ue, headerPadding: qe, footerPadding: tt, borderRadius: ut, bodyPadding: mt, titleFontSize: St, titleTextColor: st, titleFontWeight: nt, headerBorderBottom: ft, footerBorderTop: Lt, closeIconColor: pt, closeIconColorHover: wt, closeIconColorPressed: Ft, closeColorHover: tr, closeColorPressed: gt, closeIconSize: Bt, closeSize: Zt, closeBorderRadius: ir, resizableTriggerColorHover: Cr } } = g.value;
    return { "--n-line-height": Ue, "--n-color": oe, "--n-border-radius": ut, "--n-text-color": he, "--n-box-shadow": _e, "--n-bezier": J, "--n-bezier-out": fe, "--n-bezier-in": we, "--n-header-padding": qe, "--n-body-padding": mt, "--n-footer-padding": tt, "--n-title-text-color": st, "--n-title-font-size": St, "--n-title-font-weight": nt, "--n-header-border-bottom": ft, "--n-footer-border-top": Lt, "--n-close-icon-color": pt, "--n-close-icon-color-hover": wt, "--n-close-icon-color-pressed": Ft, "--n-close-size": Zt, "--n-close-color-hover": tr, "--n-close-color-pressed": gt, "--n-close-icon-size": Bt, "--n-close-border-radius": ir, "--n-resize-trigger-color-hover": Cr };
  }), ie = d ? ai("drawer", void 0, re, r) : void 0;
  return { mergedClsPrefix: i, namespace: l, mergedBodyStyle: z, handleOutsideClick: Z, handleMaskClick: F, handleEsc: K, mergedTheme: g, cssVars: d ? void 0 : re, themeClass: ie == null ? void 0 : ie.themeClass, onRender: ie == null ? void 0 : ie.onRender, isMounted: f };
}, render() {
  const { mergedClsPrefix: r } = this;
  return B(tb, { to: this.to, show: this.show }, { default: () => {
    var i;
    return (i = this.onRender) === null || i === void 0 || i.call(this), wa(B("div", { class: [`${r}-drawer-container`, this.namespace, this.themeClass], style: this.cssVars, role: "none" }, this.showMask ? B(Eo, { name: "fade-in-transition", appear: this.isMounted }, { default: () => this.show ? B("div", { "aria-hidden": true, class: [`${r}-drawer-mask`, this.showMask === "transparent" && `${r}-drawer-mask--invisible`], onClick: this.handleMaskClick }) : null }) : null, B(c5, Object.assign({}, this.$attrs, { class: [this.drawerClass, this.$attrs.class], style: [this.mergedBodyStyle, this.$attrs.style], blockScroll: this.blockScroll, contentStyle: this.contentStyle, contentClass: this.contentClass, placement: this.placement, scrollbarProps: this.scrollbarProps, show: this.show, displayDirective: this.displayDirective, nativeScrollbar: this.nativeScrollbar, onAfterEnter: this.onAfterEnter, onAfterLeave: this.onAfterLeave, trapFocus: this.trapFocus, autoFocus: this.autoFocus, resizable: this.resizable, maxHeight: this.maxHeight, minHeight: this.minHeight, maxWidth: this.maxWidth, minWidth: this.minWidth, showMask: this.showMask, onEsc: this.handleEsc, onClickoutside: this.handleOutsideClick }), this.$slots)), [[eb, { zIndex: this.zIndex, enabled: this.show }]]);
  } });
} }), k5 = { title: String, headerClass: String, headerStyle: [Object, String], footerClass: String, footerStyle: [Object, String], bodyClass: String, bodyStyle: [Object, String], bodyContentClass: String, bodyContentStyle: [Object, String], nativeScrollbar: { type: Boolean, default: true }, scrollbarProps: Object, closable: Boolean }, Kb = ot({ name: "DrawerContent", props: k5, slots: Object, setup() {
  const r = ur(l0, null);
  r || ea("drawer-content", "`n-drawer-content` must be placed inside `n-drawer`.");
  const { doUpdateShow: i } = r;
  function l() {
    i(false);
  }
  return { handleCloseClick: l, mergedTheme: r.mergedThemeRef, mergedClsPrefix: r.mergedClsPrefixRef };
}, render() {
  const { title: r, mergedClsPrefix: i, nativeScrollbar: l, mergedTheme: d, bodyClass: f, bodyStyle: g, bodyContentClass: p, bodyContentStyle: s, headerClass: C, headerStyle: P, footerClass: M, footerStyle: D, scrollbarProps: L, closable: $, $slots: z } = this;
  return B("div", { role: "none", class: [`${i}-drawer-content`, l && `${i}-drawer-content--native-scrollbar`] }, z.header || r || $ ? B("div", { class: [`${i}-drawer-header`, C], style: P, role: "none" }, B("div", { class: `${i}-drawer-header__main`, role: "heading", "aria-level": "1" }, z.header !== void 0 ? z.header() : r), $ && B(Sp, { onClick: this.handleCloseClick, clsPrefix: i, class: `${i}-drawer-header__close`, absolute: true })) : null, l ? B("div", { class: [`${i}-drawer-body`, f], style: g, role: "none" }, B("div", { class: [`${i}-drawer-body-content-wrapper`, p], style: s, role: "none" }, z)) : B(uh, Object.assign({ themeOverrides: d.peerOverrides.Scrollbar, theme: d.peers.Scrollbar }, L, { class: `${i}-drawer-body`, contentClass: [`${i}-drawer-body-content-wrapper`, p], contentStyle: s }), z), z.footer ? B("div", { class: [`${i}-drawer-footer`, M], style: D, role: "none" }, z.footer()) : null);
} });
let ng;
function P5() {
  if (!Tp) return true;
  if (ng === void 0) {
    const r = document.createElement("div");
    r.style.display = "flex", r.style.flexDirection = "column", r.style.rowGap = "1px", r.appendChild(document.createElement("div")), r.appendChild(document.createElement("div")), document.body.appendChild(r);
    const i = r.scrollHeight === 1;
    return document.body.removeChild(r), ng = i;
  }
  return ng;
}
const T5 = Object.assign(Object.assign({}, Jt.props), { align: String, justify: { type: String, default: "start" }, inline: Boolean, vertical: Boolean, reverse: Boolean, size: { type: [String, Number, Array], default: "medium" }, wrapItem: { type: Boolean, default: true }, itemClass: String, itemStyle: [String, Object], wrap: { type: Boolean, default: true }, internalUseGap: { type: Boolean, default: void 0 } }), Fs = ot({ name: "Space", props: T5, setup(r) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Sr(r), d = Jt("Space", "-space", void 0, c3, r, i), f = Tn("Space", l, i);
  return { useGap: P5(), rtlEnabled: f, mergedClsPrefix: i, margin: Ee(() => {
    const { size: g } = r;
    if (Array.isArray(g)) return { horizontal: g[0], vertical: g[1] };
    if (typeof g == "number") return { horizontal: g, vertical: g };
    const { self: { [Vt("gap", g)]: p } } = d.value, { row: s, col: C } = rb(p);
    return { horizontal: nn(C), vertical: nn(s) };
  }) };
}, render() {
  const { vertical: r, reverse: i, align: l, inline: d, justify: f, itemClass: g, itemStyle: p, margin: s, wrap: C, mergedClsPrefix: P, rtlEnabled: M, useGap: D, wrapItem: L, internalUseGap: $ } = this, z = Bl(Ep(this), false);
  if (!z.length) return null;
  const F = `${s.horizontal}px`, Z = `${s.horizontal / 2}px`, q = `${s.vertical}px`, K = `${s.vertical / 2}px`, te = z.length - 1, re = f.startsWith("space-");
  return B("div", { role: "none", class: [`${P}-space`, M && `${P}-space--rtl`], style: { display: d ? "inline-flex" : "flex", flexDirection: r && !i ? "column" : r && i ? "column-reverse" : !r && i ? "row-reverse" : "row", justifyContent: ["start", "end"].includes(f) ? `flex-${f}` : f, flexWrap: !C || r ? "nowrap" : "wrap", marginTop: D || r ? "" : `-${K}`, marginBottom: D || r ? "" : `-${K}`, alignItems: l, gap: D ? `${s.vertical}px ${s.horizontal}px` : "" } }, !L && (D || $) ? z : z.map((ie, J) => ie.type === vw ? ie : B("div", { role: "none", class: g, style: [p, { maxWidth: "100%" }, D ? "" : r ? { marginBottom: J !== te ? q : "" } : M ? { marginLeft: re ? f === "space-between" && J === te ? "" : Z : J !== te ? F : "", marginRight: re ? f === "space-between" && J === 0 ? "" : Z : "", paddingTop: K, paddingBottom: K } : { marginRight: re ? f === "space-between" && J === te ? "" : Z : J !== te ? F : "", marginLeft: re ? f === "space-between" && J === 0 ? "" : Z : "", paddingTop: K, paddingBottom: K }] }, ie)));
} }), I5 = ue("dynamic-tags", [ue("input", { minWidth: "var(--n-input-width)" })]), M5 = Object.assign(Object.assign(Object.assign({}, Jt.props), Lb), { size: { type: String, default: "medium" }, closable: { type: Boolean, default: true }, defaultValue: { type: Array, default: () => [] }, value: Array, inputClass: String, inputStyle: [String, Object], inputProps: Object, max: Number, tagClass: String, tagStyle: [String, Object], renderTag: Function, onCreate: { type: Function, default: (r) => r }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onChange: [Function, Array] }), E5 = ot({ name: "DynamicTags", props: M5, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Sr(r), { localeRef: d } = as("DynamicTags"), f = ka(r), { mergedDisabledRef: g } = f, p = Ie(""), s = Ie(false), C = Ie(true), P = Ie(null), M = Jt("DynamicTags", "-dynamic-tags", I5, d3, r, i), D = Ie(r.defaultValue), L = zt(r, "value"), $ = Ji(L, D), z = Ee(() => d.value.add), F = Ee(() => MS(r.size)), Z = Ee(() => g.value || !!r.max && $.value.length >= r.max);
  function q(oe) {
    const { onChange: he, "onUpdate:value": _e, onUpdateValue: Ue } = r, { nTriggerFormInput: qe, nTriggerFormChange: tt } = f;
    he && Ot(he, oe), Ue && Ot(Ue, oe), _e && Ot(_e, oe), D.value = oe, qe(), tt();
  }
  function K(oe) {
    const he = $.value.slice(0);
    he.splice(oe, 1), q(he);
  }
  function te(oe) {
    switch (oe.key) {
      case "Enter":
        re();
    }
  }
  function re(oe) {
    const he = oe ?? p.value;
    if (he) {
      const _e = $.value.slice(0);
      _e.push(r.onCreate(he)), q(_e);
    }
    s.value = false, C.value = true, p.value = "";
  }
  function ie() {
    re();
  }
  function J() {
    s.value = true, Wn(() => {
      var oe;
      (oe = P.value) === null || oe === void 0 || oe.focus(), C.value = false;
    });
  }
  const we = Ee(() => {
    const { self: { inputWidth: oe } } = M.value;
    return { "--n-input-width": oe };
  }), fe = l ? ai("dynamic-tags", void 0, we, r) : void 0;
  return { mergedClsPrefix: i, inputInstRef: P, localizedAdd: z, inputSize: F, inputValue: p, showInput: s, inputForceFocused: C, mergedValue: $, mergedDisabled: g, triggerDisabled: Z, handleInputKeyDown: te, handleAddClick: J, handleInputBlur: ie, handleCloseClick: K, handleInputConfirm: re, mergedTheme: M, cssVars: l ? void 0 : we, themeClass: fe == null ? void 0 : fe.themeClass, onRender: fe == null ? void 0 : fe.onRender };
}, render() {
  const { mergedTheme: r, cssVars: i, mergedClsPrefix: l, onRender: d, renderTag: f } = this;
  return d == null ? void 0 : d(), B(Fs, { class: [`${l}-dynamic-tags`, this.themeClass], size: "small", style: i, theme: r.peers.Space, themeOverrides: r.peerOverrides.Space, itemStyle: "display: flex;" }, { default: () => {
    const { mergedTheme: g, tagClass: p, tagStyle: s, type: C, round: P, size: M, color: D, closable: L, mergedDisabled: $, showInput: z, inputValue: F, inputClass: Z, inputStyle: q, inputSize: K, inputForceFocused: te, triggerDisabled: re, handleInputKeyDown: ie, handleInputBlur: J, handleAddClick: we, handleCloseClick: fe, handleInputConfirm: oe, $slots: he } = this;
    return this.mergedValue.map((_e, Ue) => f ? f(_e, Ue) : B(xo, { key: Ue, theme: g.peers.Tag, themeOverrides: g.peerOverrides.Tag, class: p, style: s, type: C, round: P, size: M, color: D, closable: L, disabled: $, onClose: () => {
      fe(Ue);
    } }, { default: () => typeof _e == "string" ? _e : _e.label })).concat(z ? he.input ? he.input({ submit: oe, deactivate: J }) : B(_o, Object.assign({ placeholder: "", size: K, style: q, class: Z, autosize: true }, this.inputProps, { ref: "inputInstRef", value: F, onUpdateValue: (_e) => {
      this.inputValue = _e;
    }, theme: g.peers.Input, themeOverrides: g.peerOverrides.Input, onKeydown: ie, onBlur: J, internalForceFocus: te })) : he.trigger ? he.trigger({ activate: we, disabled: re }) : B($r, { dashed: true, disabled: re, theme: g.peers.Button, themeOverrides: g.peerOverrides.Button, size: K, onClick: we }, { icon: () => B(qr, { clsPrefix: l }, { default: () => B(Rp, null) }) }));
  } });
} }), R5 = Object.assign(Object.assign({}, Jt.props), { align: String, justify: { type: String, default: "start" }, inline: Boolean, vertical: Boolean, reverse: Boolean, size: { type: [String, Number, Array], default: "medium" }, wrap: { type: Boolean, default: true } }), M_ = ot({ name: "Flex", props: R5, setup(r) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Sr(r), d = Jt("Flex", "-flex", void 0, h3, r, i);
  return { rtlEnabled: Tn("Flex", l, i), mergedClsPrefix: i, margin: Ee(() => {
    const { size: g } = r;
    if (Array.isArray(g)) return { horizontal: g[0], vertical: g[1] };
    if (typeof g == "number") return { horizontal: g, vertical: g };
    const { self: { [Vt("gap", g)]: p } } = d.value, { row: s, col: C } = rb(p);
    return { horizontal: nn(C), vertical: nn(s) };
  }) };
}, render() {
  const { vertical: r, reverse: i, align: l, inline: d, justify: f, margin: g, wrap: p, mergedClsPrefix: s, rtlEnabled: C } = this, P = Bl(Ep(this), false);
  return P.length ? B("div", { role: "none", class: [`${s}-flex`, C && `${s}-flex--rtl`], style: { display: d ? "inline-flex" : "flex", flexDirection: r && !i ? "column" : r && i ? "column-reverse" : !r && i ? "row-reverse" : "row", justifyContent: f, flexWrap: !p || r ? "nowrap" : "wrap", alignItems: l, gap: `${g.vertical}px ${g.horizontal}px` } }, P) : null;
} }), dh = $n("n-form"), Jb = $n("n-form-item-insts"), A5 = ue("form", [Ge("inline", `
 width: 100%;
 display: inline-flex;
 align-items: flex-start;
 align-content: space-around;
 `, [ue("form-item", { width: "auto", marginRight: "18px" }, [Ze("&:last-child", { marginRight: 0 })])])]);
var D5 = function(r, i, l, d) {
  function f(g) {
    return g instanceof l ? g : new l(function(p) {
      p(g);
    });
  }
  return new (l || (l = Promise))(function(g, p) {
    function s(M) {
      try {
        P(d.next(M));
      } catch (D) {
        p(D);
      }
    }
    function C(M) {
      try {
        P(d.throw(M));
      } catch (D) {
        p(D);
      }
    }
    function P(M) {
      M.done ? g(M.value) : f(M.value).then(s, C);
    }
    P((d = d.apply(r, i || [])).next());
  });
};
const z5 = Object.assign(Object.assign({}, Jt.props), { inline: Boolean, labelWidth: [Number, String], labelAlign: String, labelPlacement: { type: String, default: "top" }, model: { type: Object, default: () => {
} }, rules: Object, disabled: Boolean, size: String, showRequireMark: { type: Boolean, default: void 0 }, requireMarkPlacement: String, showFeedback: { type: Boolean, default: true }, onSubmit: { type: Function, default: (r) => {
  r.preventDefault();
} }, showLabel: { type: Boolean, default: void 0 }, validateMessages: Object }), th = ot({ name: "Form", props: z5, setup(r) {
  const { mergedClsPrefixRef: i } = Sr(r);
  Jt("Form", "-form", A5, ib, r, i);
  const l = {}, d = Ie(void 0), f = (C) => {
    const P = d.value;
    (P === void 0 || C >= P) && (d.value = C);
  };
  function g(C) {
    return D5(this, arguments, void 0, function* (P, M = () => true) {
      return yield new Promise((D, L) => {
        const $ = [];
        for (const z of Xd(l)) {
          const F = l[z];
          for (const Z of F) Z.path && $.push(Z.internalValidate(null, M));
        }
        Promise.all($).then((z) => {
          const F = z.some((K) => !K.valid), Z = [], q = [];
          z.forEach((K) => {
            var te, re;
            !((te = K.errors) === null || te === void 0) && te.length && Z.push(K.errors), !((re = K.warnings) === null || re === void 0) && re.length && q.push(K.warnings);
          }), P && P(Z.length ? Z : void 0, { warnings: q.length ? q : void 0 }), F ? L(Z.length ? Z : void 0) : D({ warnings: q.length ? q : void 0 });
        });
      });
    });
  }
  function p() {
    for (const C of Xd(l)) {
      const P = l[C];
      for (const M of P) M.restoreValidation();
    }
  }
  return Xr(dh, { props: r, maxChildLabelWidthRef: d, deriveMaxChildLabelWidth: f }), Xr(Jb, { formItems: l }), Object.assign({ validate: g, restoreValidation: p }, { mergedClsPrefix: i });
}, render() {
  const { mergedClsPrefix: r } = this;
  return B("form", { class: [`${r}-form`, this.inline && `${r}-form--inline`], onSubmit: this.onSubmit }, this.$slots);
} });
function Al() {
  return Al = Object.assign ? Object.assign.bind() : function(r) {
    for (var i = 1; i < arguments.length; i++) {
      var l = arguments[i];
      for (var d in l) Object.prototype.hasOwnProperty.call(l, d) && (r[d] = l[d]);
    }
    return r;
  }, Al.apply(this, arguments);
}
function F5(r, i) {
  r.prototype = Object.create(i.prototype), r.prototype.constructor = r, rh(r, i);
}
function jg(r) {
  return jg = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
    return l.__proto__ || Object.getPrototypeOf(l);
  }, jg(r);
}
function rh(r, i) {
  return rh = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, f) {
    return d.__proto__ = f, d;
  }, rh(r, i);
}
function L5() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return false;
  if (typeof Proxy == "function") return true;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), true;
  } catch {
    return false;
  }
}
function ip(r, i, l) {
  return L5() ? ip = Reflect.construct.bind() : ip = function(f, g, p) {
    var s = [null];
    s.push.apply(s, g);
    var C = Function.bind.apply(f, s), P = new C();
    return p && rh(P, p.prototype), P;
  }, ip.apply(null, arguments);
}
function B5(r) {
  return Function.toString.call(r).indexOf("[native code]") !== -1;
}
function Ng(r) {
  var i = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return Ng = function(d) {
    if (d === null || !B5(d)) return d;
    if (typeof d != "function") throw new TypeError("Super expression must either be null or a function");
    if (typeof i < "u") {
      if (i.has(d)) return i.get(d);
      i.set(d, f);
    }
    function f() {
      return ip(d, arguments, jg(this).constructor);
    }
    return f.prototype = Object.create(d.prototype, { constructor: { value: f, enumerable: false, writable: true, configurable: true } }), rh(f, d);
  }, Ng(r);
}
var O5 = /%[sdj%]/g, $5 = function() {
};
function Vg(r) {
  if (!r || !r.length) return null;
  var i = {};
  return r.forEach(function(l) {
    var d = l.field;
    i[d] = i[d] || [], i[d].push(l);
  }), i;
}
function yo(r) {
  for (var i = arguments.length, l = new Array(i > 1 ? i - 1 : 0), d = 1; d < i; d++) l[d - 1] = arguments[d];
  var f = 0, g = l.length;
  if (typeof r == "function") return r.apply(null, l);
  if (typeof r == "string") {
    var p = r.replace(O5, function(s) {
      if (s === "%%") return "%";
      if (f >= g) return s;
      switch (s) {
        case "%s":
          return String(l[f++]);
        case "%d":
          return Number(l[f++]);
        case "%j":
          try {
            return JSON.stringify(l[f++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return s;
      }
    });
    return p;
  }
  return r;
}
function j5(r) {
  return r === "string" || r === "url" || r === "hex" || r === "email" || r === "date" || r === "pattern";
}
function an(r, i) {
  return !!(r == null || i === "array" && Array.isArray(r) && !r.length || j5(i) && typeof r == "string" && !r);
}
function N5(r, i, l) {
  var d = [], f = 0, g = r.length;
  function p(s) {
    d.push.apply(d, s || []), f++, f === g && l(d);
  }
  r.forEach(function(s) {
    i(s, p);
  });
}
function E_(r, i, l) {
  var d = 0, f = r.length;
  function g(p) {
    if (p && p.length) {
      l(p);
      return;
    }
    var s = d;
    d = d + 1, s < f ? i(r[s], g) : l([]);
  }
  g([]);
}
function V5(r) {
  var i = [];
  return Object.keys(r).forEach(function(l) {
    i.push.apply(i, r[l] || []);
  }), i;
}
var R_ = (function(r) {
  F5(i, r);
  function i(l, d) {
    var f;
    return f = r.call(this, "Async Validation Error") || this, f.errors = l, f.fields = d, f;
  }
  return i;
})(Ng(Error));
function U5(r, i, l, d, f) {
  if (i.first) {
    var g = new Promise(function(L, $) {
      var z = function(q) {
        return d(q), q.length ? $(new R_(q, Vg(q))) : L(f);
      }, F = V5(r);
      E_(F, l, z);
    });
    return g.catch(function(L) {
      return L;
    }), g;
  }
  var p = i.firstFields === true ? Object.keys(r) : i.firstFields || [], s = Object.keys(r), C = s.length, P = 0, M = [], D = new Promise(function(L, $) {
    var z = function(Z) {
      if (M.push.apply(M, Z), P++, P === C) return d(M), M.length ? $(new R_(M, Vg(M))) : L(f);
    };
    s.length || (d(M), L(f)), s.forEach(function(F) {
      var Z = r[F];
      p.indexOf(F) !== -1 ? E_(Z, l, z) : N5(Z, l, z);
    });
  });
  return D.catch(function(L) {
    return L;
  }), D;
}
function G5(r) {
  return !!(r && r.message !== void 0);
}
function q5(r, i) {
  for (var l = r, d = 0; d < i.length; d++) {
    if (l == null) return l;
    l = l[i[d]];
  }
  return l;
}
function A_(r, i) {
  return function(l) {
    var d;
    return r.fullFields ? d = q5(i, r.fullFields) : d = i[l.field || r.fullField], G5(l) ? (l.field = l.field || r.fullField, l.fieldValue = d, l) : { message: typeof l == "function" ? l() : l, fieldValue: d, field: l.field || r.fullField };
  };
}
function D_(r, i) {
  if (i) {
    for (var l in i) if (i.hasOwnProperty(l)) {
      var d = i[l];
      typeof d == "object" && typeof r[l] == "object" ? r[l] = Al({}, r[l], d) : r[l] = d;
    }
  }
  return r;
}
var Qb = function(i, l, d, f, g, p) {
  i.required && (!d.hasOwnProperty(i.field) || an(l, p || i.type)) && f.push(yo(g.messages.required, i.fullField));
}, W5 = function(i, l, d, f, g) {
  (/^\s+$/.test(l) || l === "") && f.push(yo(g.messages.whitespace, i.fullField));
}, Uf, Z5 = (function() {
  if (Uf) return Uf;
  var r = "[a-fA-F\\d:]", i = function(re) {
    return re && re.includeBoundaries ? "(?:(?<=\\s|^)(?=" + r + ")|(?<=" + r + ")(?=\\s|$))" : "";
  }, l = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", d = "[a-fA-F\\d]{1,4}", f = (`
(?:
(?:` + d + ":){7}(?:" + d + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + d + ":){6}(?:" + l + "|:" + d + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + d + ":){5}(?::" + l + "|(?::" + d + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + d + ":){4}(?:(?::" + d + "){0,1}:" + l + "|(?::" + d + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + d + ":){3}(?:(?::" + d + "){0,2}:" + l + "|(?::" + d + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + d + ":){2}(?:(?::" + d + "){0,3}:" + l + "|(?::" + d + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + d + ":){1}(?:(?::" + d + "){0,4}:" + l + "|(?::" + d + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + d + "){0,5}:" + l + "|(?::" + d + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), g = new RegExp("(?:^" + l + "$)|(?:^" + f + "$)"), p = new RegExp("^" + l + "$"), s = new RegExp("^" + f + "$"), C = function(re) {
    return re && re.exact ? g : new RegExp("(?:" + i(re) + l + i(re) + ")|(?:" + i(re) + f + i(re) + ")", "g");
  };
  C.v4 = function(te) {
    return te && te.exact ? p : new RegExp("" + i(te) + l + i(te), "g");
  }, C.v6 = function(te) {
    return te && te.exact ? s : new RegExp("" + i(te) + f + i(te), "g");
  };
  var P = "(?:(?:[a-z]+:)?//)", M = "(?:\\S+(?::\\S*)?@)?", D = C.v4().source, L = C.v6().source, $ = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", z = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", F = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", Z = "(?::\\d{2,5})?", q = '(?:[/?#][^\\s"]*)?', K = "(?:" + P + "|www\\.)" + M + "(?:localhost|" + D + "|" + L + "|" + $ + z + F + ")" + Z + q;
  return Uf = new RegExp("(?:^" + K + "$)", "i"), Uf;
}), z_ = { email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/, hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i }, $d = { integer: function(i) {
  return $d.number(i) && parseInt(i, 10) === i;
}, float: function(i) {
  return $d.number(i) && !$d.integer(i);
}, array: function(i) {
  return Array.isArray(i);
}, regexp: function(i) {
  if (i instanceof RegExp) return true;
  try {
    return !!new RegExp(i);
  } catch {
    return false;
  }
}, date: function(i) {
  return typeof i.getTime == "function" && typeof i.getMonth == "function" && typeof i.getYear == "function" && !isNaN(i.getTime());
}, number: function(i) {
  return isNaN(i) ? false : typeof i == "number";
}, object: function(i) {
  return typeof i == "object" && !$d.array(i);
}, method: function(i) {
  return typeof i == "function";
}, email: function(i) {
  return typeof i == "string" && i.length <= 320 && !!i.match(z_.email);
}, url: function(i) {
  return typeof i == "string" && i.length <= 2048 && !!i.match(Z5());
}, hex: function(i) {
  return typeof i == "string" && !!i.match(z_.hex);
} }, H5 = function(i, l, d, f, g) {
  if (i.required && l === void 0) {
    Qb(i, l, d, f, g);
    return;
  }
  var p = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], s = i.type;
  p.indexOf(s) > -1 ? $d[s](l) || f.push(yo(g.messages.types[s], i.fullField, i.type)) : s && typeof l !== i.type && f.push(yo(g.messages.types[s], i.fullField, i.type));
}, X5 = function(i, l, d, f, g) {
  var p = typeof i.len == "number", s = typeof i.min == "number", C = typeof i.max == "number", P = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, M = l, D = null, L = typeof l == "number", $ = typeof l == "string", z = Array.isArray(l);
  if (L ? D = "number" : $ ? D = "string" : z && (D = "array"), !D) return false;
  z && (M = l.length), $ && (M = l.replace(P, "_").length), p ? M !== i.len && f.push(yo(g.messages[D].len, i.fullField, i.len)) : s && !C && M < i.min ? f.push(yo(g.messages[D].min, i.fullField, i.min)) : C && !s && M > i.max ? f.push(yo(g.messages[D].max, i.fullField, i.max)) : s && C && (M < i.min || M > i.max) && f.push(yo(g.messages[D].range, i.fullField, i.min, i.max));
}, rc = "enum", Y5 = function(i, l, d, f, g) {
  i[rc] = Array.isArray(i[rc]) ? i[rc] : [], i[rc].indexOf(l) === -1 && f.push(yo(g.messages[rc], i.fullField, i[rc].join(", ")));
}, K5 = function(i, l, d, f, g) {
  if (i.pattern) {
    if (i.pattern instanceof RegExp) i.pattern.lastIndex = 0, i.pattern.test(l) || f.push(yo(g.messages.pattern.mismatch, i.fullField, l, i.pattern));
    else if (typeof i.pattern == "string") {
      var p = new RegExp(i.pattern);
      p.test(l) || f.push(yo(g.messages.pattern.mismatch, i.fullField, l, i.pattern));
    }
  }
}, Br = { required: Qb, whitespace: W5, type: H5, range: X5, enum: Y5, pattern: K5 }, J5 = function(i, l, d, f, g) {
  var p = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (an(l, "string") && !i.required) return d();
    Br.required(i, l, f, p, g, "string"), an(l, "string") || (Br.type(i, l, f, p, g), Br.range(i, l, f, p, g), Br.pattern(i, l, f, p, g), i.whitespace === true && Br.whitespace(i, l, f, p, g));
  }
  d(p);
}, Q5 = function(i, l, d, f, g) {
  var p = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (an(l) && !i.required) return d();
    Br.required(i, l, f, p, g), l !== void 0 && Br.type(i, l, f, p, g);
  }
  d(p);
}, eT = function(i, l, d, f, g) {
  var p = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (l === "" && (l = void 0), an(l) && !i.required) return d();
    Br.required(i, l, f, p, g), l !== void 0 && (Br.type(i, l, f, p, g), Br.range(i, l, f, p, g));
  }
  d(p);
}, tT = function(i, l, d, f, g) {
  var p = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (an(l) && !i.required) return d();
    Br.required(i, l, f, p, g), l !== void 0 && Br.type(i, l, f, p, g);
  }
  d(p);
}, rT = function(i, l, d, f, g) {
  var p = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (an(l) && !i.required) return d();
    Br.required(i, l, f, p, g), an(l) || Br.type(i, l, f, p, g);
  }
  d(p);
}, iT = function(i, l, d, f, g) {
  var p = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (an(l) && !i.required) return d();
    Br.required(i, l, f, p, g), l !== void 0 && (Br.type(i, l, f, p, g), Br.range(i, l, f, p, g));
  }
  d(p);
}, nT = function(i, l, d, f, g) {
  var p = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (an(l) && !i.required) return d();
    Br.required(i, l, f, p, g), l !== void 0 && (Br.type(i, l, f, p, g), Br.range(i, l, f, p, g));
  }
  d(p);
}, oT = function(i, l, d, f, g) {
  var p = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (l == null && !i.required) return d();
    Br.required(i, l, f, p, g, "array"), l != null && (Br.type(i, l, f, p, g), Br.range(i, l, f, p, g));
  }
  d(p);
}, aT = function(i, l, d, f, g) {
  var p = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (an(l) && !i.required) return d();
    Br.required(i, l, f, p, g), l !== void 0 && Br.type(i, l, f, p, g);
  }
  d(p);
}, sT = "enum", lT = function(i, l, d, f, g) {
  var p = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (an(l) && !i.required) return d();
    Br.required(i, l, f, p, g), l !== void 0 && Br[sT](i, l, f, p, g);
  }
  d(p);
}, uT = function(i, l, d, f, g) {
  var p = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (an(l, "string") && !i.required) return d();
    Br.required(i, l, f, p, g), an(l, "string") || Br.pattern(i, l, f, p, g);
  }
  d(p);
}, cT = function(i, l, d, f, g) {
  var p = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (an(l, "date") && !i.required) return d();
    if (Br.required(i, l, f, p, g), !an(l, "date")) {
      var C;
      l instanceof Date ? C = l : C = new Date(l), Br.type(i, C, f, p, g), C && Br.range(i, C.getTime(), f, p, g);
    }
  }
  d(p);
}, dT = function(i, l, d, f, g) {
  var p = [], s = Array.isArray(l) ? "array" : typeof l;
  Br.required(i, l, f, p, g, s), d(p);
}, og = function(i, l, d, f, g) {
  var p = i.type, s = [], C = i.required || !i.required && f.hasOwnProperty(i.field);
  if (C) {
    if (an(l, p) && !i.required) return d();
    Br.required(i, l, f, s, g, p), an(l, p) || Br.type(i, l, f, s, g);
  }
  d(s);
}, hT = function(i, l, d, f, g) {
  var p = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (an(l) && !i.required) return d();
    Br.required(i, l, f, p, g);
  }
  d(p);
}, Wd = { string: J5, method: Q5, number: eT, boolean: tT, regexp: rT, integer: iT, float: nT, array: oT, object: aT, enum: lT, pattern: uT, date: cT, url: og, hex: og, email: og, required: dT, any: hT };
function Ug() {
  return { default: "Validation error on field %s", required: "%s is required", enum: "%s must be one of %s", whitespace: "%s cannot be empty", date: { format: "%s date %s is invalid for format %s", parse: "%s date could not be parsed, %s is invalid ", invalid: "%s date %s is invalid" }, types: { string: "%s is not a %s", method: "%s is not a %s (function)", array: "%s is not an %s", object: "%s is not an %s", number: "%s is not a %s", date: "%s is not a %s", boolean: "%s is not a %s", integer: "%s is not an %s", float: "%s is not a %s", regexp: "%s is not a valid %s", email: "%s is not a valid %s", url: "%s is not a valid %s", hex: "%s is not a valid %s" }, string: { len: "%s must be exactly %s characters", min: "%s must be at least %s characters", max: "%s cannot be longer than %s characters", range: "%s must be between %s and %s characters" }, number: { len: "%s must equal %s", min: "%s cannot be less than %s", max: "%s cannot be greater than %s", range: "%s must be between %s and %s" }, array: { len: "%s must be exactly %s in length", min: "%s cannot be less than %s in length", max: "%s cannot be greater than %s in length", range: "%s must be between %s and %s in length" }, pattern: { mismatch: "%s value %s does not match pattern %s" }, clone: function() {
    var i = JSON.parse(JSON.stringify(this));
    return i.clone = this.clone, i;
  } };
}
var Gg = Ug(), hc = (function() {
  function r(l) {
    this.rules = null, this._messages = Gg, this.define(l);
  }
  var i = r.prototype;
  return i.define = function(d) {
    var f = this;
    if (!d) throw new Error("Cannot configure a schema with no rules");
    if (typeof d != "object" || Array.isArray(d)) throw new Error("Rules must be an object");
    this.rules = {}, Object.keys(d).forEach(function(g) {
      var p = d[g];
      f.rules[g] = Array.isArray(p) ? p : [p];
    });
  }, i.messages = function(d) {
    return d && (this._messages = D_(Ug(), d)), this._messages;
  }, i.validate = function(d, f, g) {
    var p = this;
    f === void 0 && (f = {}), g === void 0 && (g = function() {
    });
    var s = d, C = f, P = g;
    if (typeof C == "function" && (P = C, C = {}), !this.rules || Object.keys(this.rules).length === 0) return P && P(null, s), Promise.resolve(s);
    function M(F) {
      var Z = [], q = {};
      function K(re) {
        if (Array.isArray(re)) {
          var ie;
          Z = (ie = Z).concat.apply(ie, re);
        } else Z.push(re);
      }
      for (var te = 0; te < F.length; te++) K(F[te]);
      Z.length ? (q = Vg(Z), P(Z, q)) : P(null, s);
    }
    if (C.messages) {
      var D = this.messages();
      D === Gg && (D = Ug()), D_(D, C.messages), C.messages = D;
    } else C.messages = this.messages();
    var L = {}, $ = C.keys || Object.keys(this.rules);
    $.forEach(function(F) {
      var Z = p.rules[F], q = s[F];
      Z.forEach(function(K) {
        var te = K;
        typeof te.transform == "function" && (s === d && (s = Al({}, s)), q = s[F] = te.transform(q)), typeof te == "function" ? te = { validator: te } : te = Al({}, te), te.validator = p.getValidationMethod(te), te.validator && (te.field = F, te.fullField = te.fullField || F, te.type = p.getType(te), L[F] = L[F] || [], L[F].push({ rule: te, value: q, source: s, field: F }));
      });
    });
    var z = {};
    return U5(L, C, function(F, Z) {
      var _a3;
      var q = F.rule, K = (q.type === "object" || q.type === "array") && (typeof q.fields == "object" || typeof q.defaultField == "object");
      K = K && (q.required || !q.required && F.value), q.field = F.field;
      function te(J, we) {
        return Al({}, we, { fullField: q.fullField + "." + J, fullFields: q.fullFields ? [].concat(q.fullFields, [J]) : [J] });
      }
      function re(J) {
        J === void 0 && (J = []);
        var we = Array.isArray(J) ? J : [J];
        !C.suppressWarning && we.length && r.warning("async-validator:", we), we.length && q.message !== void 0 && (we = [].concat(q.message));
        var fe = we.map(A_(q, s));
        if (C.first && fe.length) return z[q.field] = 1, Z(fe);
        if (!K) Z(fe);
        else {
          if (q.required && !F.value) return q.message !== void 0 ? fe = [].concat(q.message).map(A_(q, s)) : C.error && (fe = [C.error(q, yo(C.messages.required, q.field))]), Z(fe);
          var oe = {};
          q.defaultField && Object.keys(F.value).map(function(Ue) {
            oe[Ue] = q.defaultField;
          }), oe = Al({}, oe, F.rule.fields);
          var he = {};
          Object.keys(oe).forEach(function(Ue) {
            var qe = oe[Ue], tt = Array.isArray(qe) ? qe : [qe];
            he[Ue] = tt.map(te.bind(null, Ue));
          });
          var _e = new r(he);
          _e.messages(C.messages), F.rule.options && (F.rule.options.messages = C.messages, F.rule.options.error = C.error), _e.validate(F.value, F.rule.options || C, function(Ue) {
            var qe = [];
            fe && fe.length && qe.push.apply(qe, fe), Ue && Ue.length && qe.push.apply(qe, Ue), Z(qe.length ? qe : null);
          });
        }
      }
      var ie;
      if (q.asyncValidator) ie = q.asyncValidator(q, F.value, re, F.source, C);
      else if (q.validator) {
        try {
          ie = q.validator(q, F.value, re, F.source, C);
        } catch (J) {
          (_a3 = console.error) == null ? void 0 : _a3.call(console, J), C.suppressValidatorError || setTimeout(function() {
            throw J;
          }, 0), re(J.message);
        }
        ie === true ? re() : ie === false ? re(typeof q.message == "function" ? q.message(q.fullField || q.field) : q.message || (q.fullField || q.field) + " fails") : ie instanceof Array ? re(ie) : ie instanceof Error && re(ie.message);
      }
      ie && ie.then && ie.then(function() {
        return re();
      }, function(J) {
        return re(J);
      });
    }, function(F) {
      M(F);
    }, s);
  }, i.getType = function(d) {
    if (d.type === void 0 && d.pattern instanceof RegExp && (d.type = "pattern"), typeof d.validator != "function" && d.type && !Wd.hasOwnProperty(d.type)) throw new Error(yo("Unknown rule type %s", d.type));
    return d.type || "string";
  }, i.getValidationMethod = function(d) {
    if (typeof d.validator == "function") return d.validator;
    var f = Object.keys(d), g = f.indexOf("message");
    return g !== -1 && f.splice(g, 1), f.length === 1 && f[0] === "required" ? Wd.required : Wd[this.getType(d)] || void 0;
  }, r;
})();
hc.register = function(i, l) {
  if (typeof l != "function") throw new Error("Cannot register a validator by type, validator is not a function");
  Wd[i] = l;
};
hc.warning = $5;
hc.messages = Gg;
hc.validators = Wd;
const { cubicBezierEaseInOut: F_ } = ch;
function fT({ name: r = "fade-down", fromOffset: i = "-4px", enterDuration: l = ".3s", leaveDuration: d = ".3s", enterCubicBezier: f = F_, leaveCubicBezier: g = F_ } = {}) {
  return [Ze(`&.${r}-transition-enter-from, &.${r}-transition-leave-to`, { opacity: 0, transform: `translateY(${i})` }), Ze(`&.${r}-transition-enter-to, &.${r}-transition-leave-from`, { opacity: 1, transform: "translateY(0)" }), Ze(`&.${r}-transition-leave-active`, { transition: `opacity ${d} ${g}, transform ${d} ${g}` }), Ze(`&.${r}-transition-enter-active`, { transition: `opacity ${l} ${f}, transform ${l} ${f}` })];
}
const pT = ue("form-item", `
 display: grid;
 line-height: var(--n-line-height);
`, [ue("form-item-label", `
 grid-area: label;
 align-items: center;
 line-height: 1.25;
 text-align: var(--n-label-text-align);
 font-size: var(--n-label-font-size);
 min-height: var(--n-label-height);
 padding: var(--n-label-padding);
 color: var(--n-label-text-color);
 transition: color .3s var(--n-bezier);
 box-sizing: border-box;
 font-weight: var(--n-label-font-weight);
 `, [Ae("asterisk", `
 white-space: nowrap;
 user-select: none;
 -webkit-user-select: none;
 color: var(--n-asterisk-color);
 transition: color .3s var(--n-bezier);
 `), Ae("asterisk-placeholder", `
 grid-area: mark;
 user-select: none;
 -webkit-user-select: none;
 visibility: hidden; 
 `)]), ue("form-item-blank", `
 grid-area: blank;
 min-height: var(--n-blank-height);
 `), Ge("auto-label-width", [ue("form-item-label", "white-space: nowrap;")]), Ge("left-labelled", `
 grid-template-areas:
 "label blank"
 "label feedback";
 grid-template-columns: auto minmax(0, 1fr);
 grid-template-rows: auto 1fr;
 align-items: flex-start;
 `, [ue("form-item-label", `
 display: grid;
 grid-template-columns: 1fr auto;
 min-height: var(--n-blank-height);
 height: auto;
 box-sizing: border-box;
 flex-shrink: 0;
 flex-grow: 0;
 `, [Ge("reverse-columns-space", `
 grid-template-columns: auto 1fr;
 `), Ge("left-mark", `
 grid-template-areas:
 "mark text"
 ". text";
 `), Ge("right-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), Ge("right-hanging-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), Ae("text", `
 grid-area: text; 
 `), Ae("asterisk", `
 grid-area: mark; 
 align-self: end;
 `)])]), Ge("top-labelled", `
 grid-template-areas:
 "label"
 "blank"
 "feedback";
 grid-template-rows: minmax(var(--n-label-height), auto) 1fr;
 grid-template-columns: minmax(0, 100%);
 `, [Ge("no-label", `
 grid-template-areas:
 "blank"
 "feedback";
 grid-template-rows: 1fr;
 `), ue("form-item-label", `
 display: flex;
 align-items: flex-start;
 justify-content: var(--n-label-text-align);
 `)]), ue("form-item-blank", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 position: relative;
 `), ue("form-item-feedback-wrapper", `
 grid-area: feedback;
 box-sizing: border-box;
 min-height: var(--n-feedback-height);
 font-size: var(--n-feedback-font-size);
 line-height: 1.25;
 transform-origin: top left;
 `, [Ze("&:not(:empty)", `
 padding: var(--n-feedback-padding);
 `), ue("form-item-feedback", { transition: "color .3s var(--n-bezier)", color: "var(--n-feedback-text-color)" }, [Ge("warning", { color: "var(--n-feedback-text-color-warning)" }), Ge("error", { color: "var(--n-feedback-text-color-error)" }), fT({ fromOffset: "-3px", enterDuration: ".3s", leaveDuration: ".2s" })])])]);
function mT(r) {
  const i = ur(dh, null);
  return { mergedSize: Ee(() => r.size !== void 0 ? r.size : (i == null ? void 0 : i.props.size) !== void 0 ? i.props.size : "medium") };
}
function gT(r) {
  const i = ur(dh, null), l = Ee(() => {
    const { labelPlacement: z } = r;
    return z !== void 0 ? z : (i == null ? void 0 : i.props.labelPlacement) ? i.props.labelPlacement : "top";
  }), d = Ee(() => l.value === "left" && (r.labelWidth === "auto" || (i == null ? void 0 : i.props.labelWidth) === "auto")), f = Ee(() => {
    if (l.value === "top") return;
    const { labelWidth: z } = r;
    if (z !== void 0 && z !== "auto") return Ko(z);
    if (d.value) {
      const F = i == null ? void 0 : i.maxChildLabelWidthRef.value;
      return F !== void 0 ? Ko(F) : void 0;
    }
    if ((i == null ? void 0 : i.props.labelWidth) !== void 0) return Ko(i.props.labelWidth);
  }), g = Ee(() => {
    const { labelAlign: z } = r;
    if (z) return z;
    if (i == null ? void 0 : i.props.labelAlign) return i.props.labelAlign;
  }), p = Ee(() => {
    var z;
    return [(z = r.labelProps) === null || z === void 0 ? void 0 : z.style, r.labelStyle, { width: f.value }];
  }), s = Ee(() => {
    const { showRequireMark: z } = r;
    return z !== void 0 ? z : i == null ? void 0 : i.props.showRequireMark;
  }), C = Ee(() => {
    const { requireMarkPlacement: z } = r;
    return z !== void 0 ? z : (i == null ? void 0 : i.props.requireMarkPlacement) || "right";
  }), P = Ie(false), M = Ie(false), D = Ee(() => {
    const { validationStatus: z } = r;
    if (z !== void 0) return z;
    if (P.value) return "error";
    if (M.value) return "warning";
  }), L = Ee(() => {
    const { showFeedback: z } = r;
    return z !== void 0 ? z : (i == null ? void 0 : i.props.showFeedback) !== void 0 ? i.props.showFeedback : true;
  }), $ = Ee(() => {
    const { showLabel: z } = r;
    return z !== void 0 ? z : (i == null ? void 0 : i.props.showLabel) !== void 0 ? i.props.showLabel : true;
  });
  return { validationErrored: P, validationWarned: M, mergedLabelStyle: p, mergedLabelPlacement: l, mergedLabelAlign: g, mergedShowRequireMark: s, mergedRequireMarkPlacement: C, mergedValidationStatus: D, mergedShowFeedback: L, mergedShowLabel: $, isAutoLabelWidth: d };
}
function vT(r) {
  const i = ur(dh, null), l = Ee(() => {
    const { rulePath: p } = r;
    if (p !== void 0) return p;
    const { path: s } = r;
    if (s !== void 0) return s;
  }), d = Ee(() => {
    const p = [], { rule: s } = r;
    if (s !== void 0 && (Array.isArray(s) ? p.push(...s) : p.push(s)), i) {
      const { rules: C } = i.props, { value: P } = l;
      if (C !== void 0 && P !== void 0) {
        const M = nb(C, P);
        M !== void 0 && (Array.isArray(M) ? p.push(...M) : p.push(M));
      }
    }
    return p;
  }), f = Ee(() => d.value.some((p) => p.required)), g = Ee(() => f.value || r.required);
  return { mergedRules: d, mergedRequired: g };
}
var L_ = function(r, i, l, d) {
  function f(g) {
    return g instanceof l ? g : new l(function(p) {
      p(g);
    });
  }
  return new (l || (l = Promise))(function(g, p) {
    function s(M) {
      try {
        P(d.next(M));
      } catch (D) {
        p(D);
      }
    }
    function C(M) {
      try {
        P(d.throw(M));
      } catch (D) {
        p(D);
      }
    }
    function P(M) {
      M.done ? g(M.value) : f(M.value).then(s, C);
    }
    P((d = d.apply(r, i || [])).next());
  });
};
const _T = Object.assign(Object.assign({}, Jt.props), { label: String, labelWidth: [Number, String], labelStyle: [String, Object], labelAlign: String, labelPlacement: String, path: String, first: Boolean, rulePath: String, required: Boolean, showRequireMark: { type: Boolean, default: void 0 }, requireMarkPlacement: String, showFeedback: { type: Boolean, default: void 0 }, rule: [Object, Array], size: String, ignorePathChange: Boolean, validationStatus: String, feedback: String, feedbackClass: String, feedbackStyle: [String, Object], showLabel: { type: Boolean, default: void 0 }, labelProps: Object, contentClass: String, contentStyle: [String, Object] });
function B_(r, i) {
  return (...l) => {
    try {
      const d = r(...l);
      return !i && (typeof d == "boolean" || d instanceof Error || Array.isArray(d)) || (d == null ? void 0 : d.then) ? d : (d === void 0 || lp("form-item/validate", `You return a ${typeof d} typed value in the validator method, which is not recommended. Please use ${i ? "`Promise`" : "`boolean`, `Error` or `Promise`"} typed value instead.`), true);
    } catch (d) {
      lp("form-item/validate", "An error is catched in the validation, so the validation won't be done. Your callback in `validate` method of `n-form` or `n-form-item` won't be called in this validation."), console.error(d);
      return;
    }
  };
}
const Cn = ot({ name: "FormItem", props: _T, setup(r) {
  yS(Jb, "formItems", zt(r, "path"));
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Sr(r), d = ur(dh, null), f = mT(r), g = gT(r), { validationErrored: p, validationWarned: s } = g, { mergedRequired: C, mergedRules: P } = vT(r), { mergedSize: M } = f, { mergedLabelPlacement: D, mergedLabelAlign: L, mergedRequireMarkPlacement: $ } = g, z = Ie([]), F = Ie($l()), Z = d ? zt(d.props, "disabled") : Ie(false), q = Jt("Form", "-form-item", pT, ib, r, i);
  Ht(zt(r, "path"), () => {
    r.ignorePathChange || K();
  });
  function K() {
    z.value = [], p.value = false, s.value = false, r.feedback && (F.value = $l());
  }
  const te = (...tt) => L_(this, [...tt], void 0, function* (ut = null, mt = () => true, St = { suppressWarning: true }) {
    const { path: st } = r;
    St ? St.first || (St.first = r.first) : St = {};
    const { value: nt } = P, ft = d ? nb(d.props.model, st || "") : void 0, Lt = {}, pt = {}, wt = (ut ? nt.filter((or) => Array.isArray(or.trigger) ? or.trigger.includes(ut) : or.trigger === ut) : nt).filter(mt).map((or, Tr) => {
      const Xt = Object.assign({}, or);
      if (Xt.validator && (Xt.validator = B_(Xt.validator, false)), Xt.asyncValidator && (Xt.asyncValidator = B_(Xt.asyncValidator, true)), Xt.renderMessage) {
        const Dr = `__renderMessage__${Tr}`;
        pt[Dr] = Xt.message, Xt.message = Dr, Lt[Dr] = Xt.renderMessage;
      }
      return Xt;
    }), Ft = wt.filter((or) => or.level !== "warning"), tr = wt.filter((or) => or.level === "warning"), gt = { valid: true, errors: void 0, warnings: void 0 };
    if (!wt.length) return gt;
    const Bt = st ?? "__n_no_path__", Zt = new hc({ [Bt]: Ft }), ir = new hc({ [Bt]: tr }), { validateMessages: Cr } = (d == null ? void 0 : d.props) || {};
    Cr && (Zt.messages(Cr), ir.messages(Cr));
    const Ar = (or) => {
      z.value = or.map((Tr) => {
        const Xt = (Tr == null ? void 0 : Tr.message) || "";
        return { key: Xt, render: () => Xt.startsWith("__renderMessage__") ? Lt[Xt]() : Xt };
      }), or.forEach((Tr) => {
        var Xt;
        !((Xt = Tr.message) === null || Xt === void 0) && Xt.startsWith("__renderMessage__") && (Tr.message = pt[Tr.message]);
      });
    };
    if (Ft.length) {
      const or = yield new Promise((Tr) => {
        Zt.validate({ [Bt]: ft }, St, Tr);
      });
      (or == null ? void 0 : or.length) && (gt.valid = false, gt.errors = or, Ar(or));
    }
    if (tr.length && !gt.errors) {
      const or = yield new Promise((Tr) => {
        ir.validate({ [Bt]: ft }, St, Tr);
      });
      (or == null ? void 0 : or.length) && (Ar(or), gt.warnings = or);
    }
    return !gt.errors && !gt.warnings ? K() : (p.value = !!gt.errors, s.value = !!gt.warnings), gt;
  });
  function re() {
    te("blur");
  }
  function ie() {
    te("change");
  }
  function J() {
    te("focus");
  }
  function we() {
    te("input");
  }
  function fe(tt, ut) {
    return L_(this, void 0, void 0, function* () {
      let mt, St, st, nt;
      return typeof tt == "string" ? (mt = tt, St = ut) : tt !== null && typeof tt == "object" && (mt = tt.trigger, St = tt.callback, st = tt.shouldRuleBeApplied, nt = tt.options), yield new Promise((ft, Lt) => {
        te(mt, st, nt).then(({ valid: pt, errors: wt, warnings: Ft }) => {
          pt ? (St && St(void 0, { warnings: Ft }), ft({ warnings: Ft })) : (St && St(wt, { warnings: Ft }), Lt(wt));
        });
      });
    });
  }
  Xr(f3, { path: zt(r, "path"), disabled: Z, mergedSize: f.mergedSize, mergedValidationStatus: g.mergedValidationStatus, restoreValidation: K, handleContentBlur: re, handleContentChange: ie, handleContentFocus: J, handleContentInput: we });
  const oe = { validate: fe, restoreValidation: K, internalValidate: te }, he = Ie(null);
  Ri(() => {
    if (!g.isAutoLabelWidth.value) return;
    const tt = he.value;
    if (tt !== null) {
      const ut = tt.style.whiteSpace;
      tt.style.whiteSpace = "nowrap", tt.style.width = "", d == null ? void 0 : d.deriveMaxChildLabelWidth(Number(getComputedStyle(tt).width.slice(0, -2))), tt.style.whiteSpace = ut;
    }
  });
  const _e = Ee(() => {
    var tt;
    const { value: ut } = M, { value: mt } = D, St = mt === "top" ? "vertical" : "horizontal", { common: { cubicBezierEaseInOut: st }, self: { labelTextColor: nt, asteriskColor: ft, lineHeight: Lt, feedbackTextColor: pt, feedbackTextColorWarning: wt, feedbackTextColorError: Ft, feedbackPadding: tr, labelFontWeight: gt, [Vt("labelHeight", ut)]: Bt, [Vt("blankHeight", ut)]: Zt, [Vt("feedbackFontSize", ut)]: ir, [Vt("feedbackHeight", ut)]: Cr, [Vt("labelPadding", St)]: Ar, [Vt("labelTextAlign", St)]: or, [Vt(Vt("labelFontSize", mt), ut)]: Tr } } = q.value;
    let Xt = (tt = L.value) !== null && tt !== void 0 ? tt : or;
    return mt === "top" && (Xt = Xt === "right" ? "flex-end" : "flex-start"), { "--n-bezier": st, "--n-line-height": Lt, "--n-blank-height": Zt, "--n-label-font-size": Tr, "--n-label-text-align": Xt, "--n-label-height": Bt, "--n-label-padding": Ar, "--n-label-font-weight": gt, "--n-asterisk-color": ft, "--n-label-text-color": nt, "--n-feedback-padding": tr, "--n-feedback-font-size": ir, "--n-feedback-height": Cr, "--n-feedback-text-color": pt, "--n-feedback-text-color-warning": wt, "--n-feedback-text-color-error": Ft };
  }), Ue = l ? ai("form-item", Ee(() => {
    var tt;
    return `${M.value[0]}${D.value[0]}${((tt = L.value) === null || tt === void 0 ? void 0 : tt[0]) || ""}`;
  }), _e, r) : void 0, qe = Ee(() => D.value === "left" && $.value === "left" && L.value === "left");
  return Object.assign(Object.assign(Object.assign(Object.assign({ labelElementRef: he, mergedClsPrefix: i, mergedRequired: C, feedbackId: F, renderExplains: z, reverseColSpace: qe }, g), f), oe), { cssVars: l ? void 0 : _e, themeClass: Ue == null ? void 0 : Ue.themeClass, onRender: Ue == null ? void 0 : Ue.onRender });
}, render() {
  const { $slots: r, mergedClsPrefix: i, mergedShowLabel: l, mergedShowRequireMark: d, mergedRequireMarkPlacement: f, onRender: g } = this, p = d !== void 0 ? d : this.mergedRequired;
  g == null ? void 0 : g();
  const s = () => {
    const C = this.$slots.label ? this.$slots.label() : this.label;
    if (!C) return null;
    const P = B("span", { class: `${i}-form-item-label__text` }, C), M = p ? B("span", { class: `${i}-form-item-label__asterisk` }, f !== "left" ? "\xA0*" : "*\xA0") : f === "right-hanging" && B("span", { class: `${i}-form-item-label__asterisk-placeholder` }, "\xA0*"), { labelProps: D } = this;
    return B("label", Object.assign({}, D, { class: [D == null ? void 0 : D.class, `${i}-form-item-label`, `${i}-form-item-label--${f}-mark`, this.reverseColSpace && `${i}-form-item-label--reverse-columns-space`], style: this.mergedLabelStyle, ref: "labelElementRef" }), f === "left" ? [M, P] : [P, M]);
  };
  return B("div", { class: [`${i}-form-item`, this.themeClass, `${i}-form-item--${this.mergedSize}-size`, `${i}-form-item--${this.mergedLabelPlacement}-labelled`, this.isAutoLabelWidth && `${i}-form-item--auto-label-width`, !l && `${i}-form-item--no-label`], style: this.cssVars }, l && s(), B("div", { class: [`${i}-form-item-blank`, this.contentClass, this.mergedValidationStatus && `${i}-form-item-blank--${this.mergedValidationStatus}`], style: this.contentStyle }, r), this.mergedShowFeedback ? B("div", { key: this.feedbackId, style: this.feedbackStyle, class: [`${i}-form-item-feedback-wrapper`, this.feedbackClass] }, B(Eo, { name: "fade-down-transition", mode: "out-in" }, { default: () => {
    const { mergedValidationStatus: C } = this;
    return oi(r.feedback, (P) => {
      var M;
      const { feedback: D } = this, L = P || D ? B("div", { key: "__feedback__", class: `${i}-form-item-feedback__line` }, P || D) : this.renderExplains.length ? (M = this.renderExplains) === null || M === void 0 ? void 0 : M.map(({ key: $, render: z }) => B("div", { key: $, class: `${i}-form-item-feedback__line` }, z())) : null;
      return L ? C === "warning" ? B("div", { key: "controlled-warning", class: `${i}-form-item-feedback ${i}-form-item-feedback--warning` }, L) : C === "error" ? B("div", { key: "controlled-error", class: `${i}-form-item-feedback ${i}-form-item-feedback--error` }, L) : C === "success" ? B("div", { key: "controlled-success", class: `${i}-form-item-feedback ${i}-form-item-feedback--success` }, L) : B("div", { key: "controlled-default", class: `${i}-form-item-feedback` }, L) : null;
    });
  } })) : null);
} }), O_ = 1, e1 = $n("n-grid"), t1 = 1, yT = { span: { type: [Number, String], default: t1 }, offset: { type: [Number, String], default: 0 }, suffix: Boolean, privateOffset: Number, privateSpan: Number, privateColStart: Number, privateShow: { type: Boolean, default: true } }, bT = ot({ __GRID_ITEM__: true, name: "GridItem", alias: ["Gi"], props: yT, setup() {
  const { isSsrRef: r, xGapRef: i, itemStyleRef: l, overflowRef: d, layoutShiftDisabledRef: f } = ur(e1), g = lh();
  return { overflow: d, itemStyle: l, layoutShiftDisabled: f, mergedXGap: Ee(() => qn(i.value || 0)), deriveStyle: () => {
    r.value;
    const { privateSpan: p = t1, privateShow: s = true, privateColStart: C = void 0, privateOffset: P = 0 } = g.vnode.props, { value: M } = i, D = qn(M || 0);
    return { display: s ? "" : "none", gridColumn: `${C ?? `span ${p}`} / span ${p}`, marginLeft: P ? `calc((100% - (${p} - 1) * ${D}) / ${p} * ${P} + ${D} * ${P})` : "" };
  } };
}, render() {
  var r, i;
  if (this.layoutShiftDisabled) {
    const { span: l, offset: d, mergedXGap: f } = this;
    return B("div", { style: { gridColumn: `span ${l} / span ${l}`, marginLeft: d ? `calc((100% - (${l} - 1) * ${f}) / ${l} * ${d} + ${f} * ${d})` : "" } }, this.$slots);
  }
  return B("div", { style: [this.itemStyle, this.deriveStyle()] }, (i = (r = this.$slots).default) === null || i === void 0 ? void 0 : i.call(r, { overflow: this.overflow }));
} }), xT = { xs: 0, s: 640, m: 1024, l: 1280, xl: 1536, xxl: 1920 }, r1 = 24, ag = "__ssr__", wT = { layoutShiftDisabled: Boolean, responsive: { type: [String, Boolean], default: "self" }, cols: { type: [Number, String], default: r1 }, itemResponsive: Boolean, collapsed: Boolean, collapsedRows: { type: Number, default: 1 }, itemStyle: [Object, String], xGap: { type: [Number, String], default: 0 }, yGap: { type: [Number, String], default: 0 } }, CT = ot({ name: "Grid", inheritAttrs: false, props: wT, setup(r) {
  const { mergedClsPrefixRef: i, mergedBreakpointsRef: l } = Sr(r), d = /^\d+$/, f = Ie(void 0), g = _S((l == null ? void 0 : l.value) || xT), p = vi(() => !!(r.itemResponsive || !d.test(r.cols.toString()) || !d.test(r.xGap.toString()) || !d.test(r.yGap.toString()))), s = Ee(() => {
    if (p.value) return r.responsive === "self" ? f.value : g.value;
  }), C = vi(() => {
    var q;
    return (q = Number(Ju(r.cols.toString(), s.value))) !== null && q !== void 0 ? q : r1;
  }), P = vi(() => Ju(r.xGap.toString(), s.value)), M = vi(() => Ju(r.yGap.toString(), s.value)), D = (q) => {
    f.value = q.contentRect.width;
  }, L = (q) => {
    bp(D, q);
  }, $ = Ie(false), z = Ee(() => {
    if (r.responsive === "self") return L;
  }), F = Ie(false), Z = Ie();
  return Ri(() => {
    const { value: q } = Z;
    q && q.hasAttribute(ag) && (q.removeAttribute(ag), F.value = true);
  }), Xr(e1, { layoutShiftDisabledRef: zt(r, "layoutShiftDisabled"), isSsrRef: F, itemStyleRef: zt(r, "itemStyle"), xGapRef: P, overflowRef: $ }), { isSsr: !Tp, contentEl: Z, mergedClsPrefix: i, style: Ee(() => r.layoutShiftDisabled ? { width: "100%", display: "grid", gridTemplateColumns: `repeat(${r.cols}, minmax(0, 1fr))`, columnGap: qn(r.xGap), rowGap: qn(r.yGap) } : { width: "100%", display: "grid", gridTemplateColumns: `repeat(${C.value}, minmax(0, 1fr))`, columnGap: qn(P.value), rowGap: qn(M.value) }), isResponsive: p, responsiveQuery: s, responsiveCols: C, handleResize: z, overflow: $ };
}, render() {
  if (this.layoutShiftDisabled) return B("div", is({ ref: "contentEl", class: `${this.mergedClsPrefix}-grid`, style: this.style }, this.$attrs), this.$slots);
  const r = () => {
    var i, l, d, f, g, p, s;
    this.overflow = false;
    const C = Bl(Ep(this)), P = [], { collapsed: M, collapsedRows: D, responsiveCols: L, responsiveQuery: $ } = this;
    C.forEach((K) => {
      var te, re, ie, J, we;
      if (((te = K == null ? void 0 : K.type) === null || te === void 0 ? void 0 : te.__GRID_ITEM__) !== true) return;
      if (ES(K)) {
        const he = Sg(K);
        he.props ? he.props.privateShow = false : he.props = { privateShow: false }, P.push({ child: he, rawChildSpan: 0 });
        return;
      }
      K.dirs = ((re = K.dirs) === null || re === void 0 ? void 0 : re.filter(({ dir: he }) => he !== ns)) || null, ((ie = K.dirs) === null || ie === void 0 ? void 0 : ie.length) === 0 && (K.dirs = null);
      const fe = Sg(K), oe = Number((we = Ju((J = fe.props) === null || J === void 0 ? void 0 : J.span, $)) !== null && we !== void 0 ? we : O_);
      oe !== 0 && P.push({ child: fe, rawChildSpan: oe });
    });
    let z = 0;
    const F = (i = P[P.length - 1]) === null || i === void 0 ? void 0 : i.child;
    if (F == null ? void 0 : F.props) {
      const K = (l = F.props) === null || l === void 0 ? void 0 : l.suffix;
      K !== void 0 && K !== false && (z = Number((f = Ju((d = F.props) === null || d === void 0 ? void 0 : d.span, $)) !== null && f !== void 0 ? f : O_), F.props.privateSpan = z, F.props.privateColStart = L + 1 - z, F.props.privateShow = (g = F.props.privateShow) !== null && g !== void 0 ? g : true);
    }
    let Z = 0, q = false;
    for (const { child: K, rawChildSpan: te } of P) {
      if (q && (this.overflow = true), !q) {
        const re = Number((s = Ju((p = K.props) === null || p === void 0 ? void 0 : p.offset, $)) !== null && s !== void 0 ? s : 0), ie = Math.min(te + re, L);
        if (K.props ? (K.props.privateSpan = ie, K.props.privateOffset = re) : K.props = { privateSpan: ie, privateOffset: re }, M) {
          const J = Z % L;
          ie + J > L && (Z += L - J), ie + Z + z > D * L ? q = true : Z += ie;
        }
      }
      q && (K.props ? K.props.privateShow !== true && (K.props.privateShow = false) : K.props = { privateShow: false });
    }
    return B("div", is({ ref: "contentEl", class: `${this.mergedClsPrefix}-grid`, style: this.style, [ag]: this.isSsr || void 0 }, this.$attrs), P.map(({ child: K }) => K));
  };
  return this.isResponsive && this.responsive === "self" ? B(Dl, { onResize: this.handleResize }, { default: r }) : r();
} });
function ST() {
  return B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M6 5C5.75454 5 5.55039 5.17688 5.50806 5.41012L5.5 5.5V14.5C5.5 14.7761 5.72386 15 6 15C6.24546 15 6.44961 14.8231 6.49194 14.5899L6.5 14.5V5.5C6.5 5.22386 6.27614 5 6 5ZM13.8536 5.14645C13.68 4.97288 13.4106 4.9536 13.2157 5.08859L13.1464 5.14645L8.64645 9.64645C8.47288 9.82001 8.4536 10.0894 8.58859 10.2843L8.64645 10.3536L13.1464 14.8536C13.3417 15.0488 13.6583 15.0488 13.8536 14.8536C14.0271 14.68 14.0464 14.4106 13.9114 14.2157L13.8536 14.1464L9.70711 10L13.8536 5.85355C14.0488 5.65829 14.0488 5.34171 13.8536 5.14645Z", fill: "currentColor" }));
}
function kT() {
  return B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M13.5 5C13.7455 5 13.9496 5.17688 13.9919 5.41012L14 5.5V14.5C14 14.7761 13.7761 15 13.5 15C13.2545 15 13.0504 14.8231 13.0081 14.5899L13 14.5V5.5C13 5.22386 13.2239 5 13.5 5ZM5.64645 5.14645C5.82001 4.97288 6.08944 4.9536 6.28431 5.08859L6.35355 5.14645L10.8536 9.64645C11.0271 9.82001 11.0464 10.0894 10.9114 10.2843L10.8536 10.3536L6.35355 14.8536C6.15829 15.0488 5.84171 15.0488 5.64645 14.8536C5.47288 14.68 5.4536 14.4106 5.58859 14.2157L5.64645 14.1464L9.79289 10L5.64645 5.85355C5.45118 5.65829 5.45118 5.34171 5.64645 5.14645Z", fill: "currentColor" }));
}
function PT() {
  return B("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, B("path", { d: "M4.089 4.216l.057-.07a.5.5 0 0 1 .638-.057l.07.057L10 9.293l5.146-5.147a.5.5 0 0 1 .638-.057l.07.057a.5.5 0 0 1 .057.638l-.057.07L10.707 10l5.147 5.146a.5.5 0 0 1 .057.638l-.057.07a.5.5 0 0 1-.638.057l-.07-.057L10 10.707l-5.146 5.147a.5.5 0 0 1-.638.057l-.07-.057a.5.5 0 0 1-.057-.638l.057-.07L9.293 10L4.146 4.854a.5.5 0 0 1-.057-.638l.057-.07l-.057.07z", fill: "currentColor" }));
}
const p0 = Object.assign(Object.assign({}, Jt.props), { onPreviewPrev: Function, onPreviewNext: Function, showToolbar: { type: Boolean, default: true }, showToolbarTooltip: Boolean, renderToolbar: Function }), i1 = $n("n-image"), TT = Ze([Ze("body >", [ue("image-container", "position: fixed;")]), ue("image-preview-container", `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 `), ue("image-preview-overlay", `
 z-index: -1;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 background: rgba(0, 0, 0, .3);
 `, [dp()]), ue("image-preview-toolbar", `
 z-index: 1;
 position: absolute;
 left: 50%;
 transform: translateX(-50%);
 border-radius: var(--n-toolbar-border-radius);
 height: 48px;
 bottom: 40px;
 padding: 0 12px;
 background: var(--n-toolbar-color);
 box-shadow: var(--n-toolbar-box-shadow);
 color: var(--n-toolbar-icon-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [ue("base-icon", `
 padding: 0 8px;
 font-size: 28px;
 cursor: pointer;
 `), dp()]), ue("image-preview-wrapper", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 pointer-events: none;
 `, [wp()]), ue("image-preview", `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: all;
 margin: auto;
 max-height: calc(100vh - 32px);
 max-width: calc(100vw - 32px);
 transition: transform .3s var(--n-bezier);
 `), ue("image", `
 display: inline-flex;
 max-height: 100%;
 max-width: 100%;
 `, [ui("preview-disabled", `
 cursor: pointer;
 `), Ze("img", `
 border-radius: inherit;
 `)])]), Gf = 32, IT = Object.assign(Object.assign({}, p0), { src: String, show: { type: Boolean, default: void 0 }, defaultShow: Boolean, "onUpdate:show": [Function, Array], onUpdateShow: [Function, Array], onNext: Function, onPrev: Function, onClose: [Function, Array] }), n1 = ot({ name: "ImagePreview", props: IT, setup(r) {
  const { src: i } = _w(r), { mergedClsPrefixRef: l } = Sr(r), d = Jt("Image", "-image", TT, p3, r, l);
  let f = null;
  const g = Ie(null), p = Ie(null), s = Ie(false), { localeRef: C } = as("Image"), P = Ie(r.defaultShow), M = zt(r, "show"), D = Ji(M, P);
  function L() {
    const { value: ze } = p;
    if (!f || !ze) return;
    const { style: at } = ze, Oe = f.getBoundingClientRect(), Je = Oe.left + Oe.width / 2, ht = Oe.top + Oe.height / 2;
    at.transformOrigin = `${Je}px ${ht}px`;
  }
  function $(ze) {
    var at, Oe;
    switch (ze.key) {
      case " ":
        ze.preventDefault();
        break;
      case "ArrowLeft":
        (at = r.onPrev) === null || at === void 0 || at.call(r);
        break;
      case "ArrowRight":
        (Oe = r.onNext) === null || Oe === void 0 || Oe.call(r);
        break;
      case "ArrowUp":
        ze.preventDefault(), gt();
        break;
      case "ArrowDown":
        ze.preventDefault(), Bt();
        break;
      case "Escape":
        Cr();
        break;
    }
  }
  function z(ze) {
    const { onUpdateShow: at, "onUpdate:show": Oe } = r;
    at && Ot(at, ze), Oe && Ot(Oe, ze), P.value = ze, s.value = true;
  }
  Ht(D, (ze) => {
    ze ? Bn("keydown", document, $) : eo("keydown", document, $);
  }), Pn(() => {
    eo("keydown", document, $);
  });
  let F = 0, Z = 0, q = 0, K = 0, te = 0, re = 0, ie = 0, J = 0, we = false;
  function fe(ze) {
    const { clientX: at, clientY: Oe } = ze;
    q = at - F, K = Oe - Z, bp(ir);
  }
  function oe(ze) {
    const { mouseUpClientX: at, mouseUpClientY: Oe, mouseDownClientX: Je, mouseDownClientY: ht } = ze, bt = Je - at, rt = ht - Oe, vt = `vertical${rt > 0 ? "Top" : "Bottom"}`, Wt = `horizontal${bt > 0 ? "Left" : "Right"}`;
    return { moveVerticalDirection: vt, moveHorizontalDirection: Wt, deltaHorizontal: bt, deltaVertical: rt };
  }
  function he(ze) {
    const { value: at } = g;
    if (!at) return { offsetX: 0, offsetY: 0 };
    const Oe = at.getBoundingClientRect(), { moveVerticalDirection: Je, moveHorizontalDirection: ht, deltaHorizontal: bt, deltaVertical: rt } = ze || {};
    let vt = 0, Wt = 0;
    return Oe.width <= window.innerWidth ? vt = 0 : Oe.left > 0 ? vt = (Oe.width - window.innerWidth) / 2 : Oe.right < window.innerWidth ? vt = -(Oe.width - window.innerWidth) / 2 : ht === "horizontalRight" ? vt = Math.min((Oe.width - window.innerWidth) / 2, te - (bt ?? 0)) : vt = Math.max(-((Oe.width - window.innerWidth) / 2), te - (bt ?? 0)), Oe.height <= window.innerHeight ? Wt = 0 : Oe.top > 0 ? Wt = (Oe.height - window.innerHeight) / 2 : Oe.bottom < window.innerHeight ? Wt = -(Oe.height - window.innerHeight) / 2 : Je === "verticalBottom" ? Wt = Math.min((Oe.height - window.innerHeight) / 2, re - (rt ?? 0)) : Wt = Math.max(-((Oe.height - window.innerHeight) / 2), re - (rt ?? 0)), { offsetX: vt, offsetY: Wt };
  }
  function _e(ze) {
    eo("mousemove", document, fe), eo("mouseup", document, _e);
    const { clientX: at, clientY: Oe } = ze;
    we = false;
    const Je = oe({ mouseUpClientX: at, mouseUpClientY: Oe, mouseDownClientX: ie, mouseDownClientY: J }), ht = he(Je);
    q = ht.offsetX, K = ht.offsetY, ir();
  }
  const Ue = ur(i1, null);
  function qe(ze) {
    var at, Oe;
    if ((Oe = (at = Ue == null ? void 0 : Ue.previewedImgPropsRef.value) === null || at === void 0 ? void 0 : at.onMousedown) === null || Oe === void 0 || Oe.call(at, ze), ze.button !== 0) return;
    const { clientX: Je, clientY: ht } = ze;
    we = true, F = Je - q, Z = ht - K, te = q, re = K, ie = Je, J = ht, ir(), Bn("mousemove", document, fe), Bn("mouseup", document, _e);
  }
  const tt = 1.5;
  let ut = 0, mt = 1, St = 0;
  function st(ze) {
    var at, Oe;
    (Oe = (at = Ue == null ? void 0 : Ue.previewedImgPropsRef.value) === null || at === void 0 ? void 0 : at.onDblclick) === null || Oe === void 0 || Oe.call(at, ze);
    const Je = tr();
    mt = mt === Je ? 1 : Je, ir();
  }
  function nt() {
    mt = 1, ut = 0;
  }
  function ft() {
    var ze;
    nt(), St = 0, (ze = r.onPrev) === null || ze === void 0 || ze.call(r);
  }
  function Lt() {
    var ze;
    nt(), St = 0, (ze = r.onNext) === null || ze === void 0 || ze.call(r);
  }
  function pt() {
    St -= 90, ir();
  }
  function wt() {
    St += 90, ir();
  }
  function Ft() {
    const { value: ze } = g;
    if (!ze) return 1;
    const { innerWidth: at, innerHeight: Oe } = window, Je = Math.max(1, ze.naturalHeight / (Oe - Gf)), ht = Math.max(1, ze.naturalWidth / (at - Gf));
    return Math.max(3, Je * 2, ht * 2);
  }
  function tr() {
    const { value: ze } = g;
    if (!ze) return 1;
    const { innerWidth: at, innerHeight: Oe } = window, Je = ze.naturalHeight / (Oe - Gf), ht = ze.naturalWidth / (at - Gf);
    return Je < 1 && ht < 1 ? 1 : Math.max(Je, ht);
  }
  function gt() {
    const ze = Ft();
    mt < ze && (ut += 1, mt = Math.min(ze, Math.pow(tt, ut)), ir());
  }
  function Bt() {
    if (mt > 0.5) {
      const ze = mt;
      ut -= 1, mt = Math.max(0.5, Math.pow(tt, ut));
      const at = ze - mt;
      ir(false);
      const Oe = he();
      mt += at, ir(false), mt -= at, q = Oe.offsetX, K = Oe.offsetY, ir();
    }
  }
  function Zt() {
    const ze = i.value;
    ze && Db(ze, void 0);
  }
  function ir(ze = true) {
    var at;
    const { value: Oe } = g;
    if (!Oe) return;
    const { style: Je } = Oe, ht = Sn((at = Ue == null ? void 0 : Ue.previewedImgPropsRef.value) === null || at === void 0 ? void 0 : at.style);
    let bt = "";
    if (typeof ht == "string") bt = `${ht};`;
    else for (const vt in ht) bt += `${BC(vt)}: ${ht[vt]};`;
    const rt = `transform-origin: center; transform: translateX(${q}px) translateY(${K}px) rotate(${St}deg) scale(${mt});`;
    we ? Je.cssText = `${bt}cursor: grabbing; transition: none;${rt}` : Je.cssText = `${bt}cursor: grab;${rt}${ze ? "" : "transition: none;"}`, ze || Oe.offsetHeight;
  }
  function Cr() {
    if (D.value) {
      const { onClose: ze } = r;
      ze && Ot(ze), z(false), P.value = false;
    }
  }
  function Ar() {
    mt = tr(), ut = Math.ceil(Math.log(mt) / Math.log(tt)), q = 0, K = 0, ir();
  }
  const or = { setThumbnailEl: (ze) => {
    f = ze;
  } };
  function Tr(ze, at) {
    if (r.showToolbarTooltip) {
      const { value: Oe } = d;
      return B(Jy, { to: false, theme: Oe.peers.Tooltip, themeOverrides: Oe.peerOverrides.Tooltip, keepAliveOnHover: false }, { default: () => C.value[at], trigger: () => ze });
    } else return ze;
  }
  const Xt = Ee(() => {
    const { common: { cubicBezierEaseInOut: ze }, self: { toolbarIconColor: at, toolbarBorderRadius: Oe, toolbarBoxShadow: Je, toolbarColor: ht } } = d.value;
    return { "--n-bezier": ze, "--n-toolbar-icon-color": at, "--n-toolbar-color": ht, "--n-toolbar-border-radius": Oe, "--n-toolbar-box-shadow": Je };
  }), { inlineThemeDisabled: Dr } = Sr(), nr = Dr ? ai("image-preview", void 0, Xt, r) : void 0;
  function kt(ze) {
    ze.preventDefault();
  }
  return Object.assign({ clsPrefix: l, previewRef: g, previewWrapperRef: p, previewSrc: i, mergedShow: D, appear: Ip(), displayed: s, previewedImgProps: Ue == null ? void 0 : Ue.previewedImgPropsRef, handleWheel: kt, handlePreviewMousedown: qe, handlePreviewDblclick: st, syncTransformOrigin: L, handleAfterLeave: () => {
    nt(), St = 0, s.value = false;
  }, handleDragStart: (ze) => {
    var at, Oe;
    (Oe = (at = Ue == null ? void 0 : Ue.previewedImgPropsRef.value) === null || at === void 0 ? void 0 : at.onDragstart) === null || Oe === void 0 || Oe.call(at, ze), ze.preventDefault();
  }, zoomIn: gt, zoomOut: Bt, handleDownloadClick: Zt, rotateCounterclockwise: pt, rotateClockwise: wt, handleSwitchPrev: ft, handleSwitchNext: Lt, withTooltip: Tr, resizeToOrignalImageSize: Ar, cssVars: Dr ? void 0 : Xt, themeClass: nr == null ? void 0 : nr.themeClass, onRender: nr == null ? void 0 : nr.onRender, doUpdateShow: z, close: Cr }, or);
}, render() {
  var r, i;
  const { clsPrefix: l, renderToolbar: d, withTooltip: f } = this, g = f(B(qr, { clsPrefix: l, onClick: this.handleSwitchPrev }, { default: ST }), "tipPrevious"), p = f(B(qr, { clsPrefix: l, onClick: this.handleSwitchNext }, { default: kT }), "tipNext"), s = f(B(qr, { clsPrefix: l, onClick: this.rotateCounterclockwise }, { default: () => B(Mk, null) }), "tipCounterclockwise"), C = f(B(qr, { clsPrefix: l, onClick: this.rotateClockwise }, { default: () => B(Ik, null) }), "tipClockwise"), P = f(B(qr, { clsPrefix: l, onClick: this.resizeToOrignalImageSize }, { default: () => B(Pk, null) }), "tipOriginalSize"), M = f(B(qr, { clsPrefix: l, onClick: this.zoomOut }, { default: () => B(Ak, null) }), "tipZoomOut"), D = f(B(qr, { clsPrefix: l, onClick: this.handleDownloadClick }, { default: () => B(zb, null) }), "tipDownload"), L = f(B(qr, { clsPrefix: l, onClick: () => this.close() }, { default: PT }), "tipClose"), $ = f(B(qr, { clsPrefix: l, onClick: this.zoomIn }, { default: () => B(Rk, null) }), "tipZoomIn");
  return B(Wr, null, (i = (r = this.$slots).default) === null || i === void 0 ? void 0 : i.call(r), B(tb, { show: this.mergedShow }, { default: () => {
    var z;
    return this.mergedShow || this.displayed ? ((z = this.onRender) === null || z === void 0 || z.call(this), wa(B("div", { ref: "containerRef", class: [`${l}-image-preview-container`, this.themeClass], style: this.cssVars, onWheel: this.handleWheel }, B(Eo, { name: "fade-in-transition", appear: this.appear }, { default: () => this.mergedShow ? B("div", { class: `${l}-image-preview-overlay`, onClick: () => this.close() }) : null }), this.showToolbar ? B(Eo, { name: "fade-in-transition", appear: this.appear }, { default: () => this.mergedShow ? B("div", { class: `${l}-image-preview-toolbar` }, d ? d({ nodes: { prev: g, next: p, rotateCounterclockwise: s, rotateClockwise: C, resizeToOriginalSize: P, zoomOut: M, zoomIn: $, download: D, close: L } }) : B(Wr, null, this.onPrev ? B(Wr, null, g, p) : null, s, C, P, M, $, D, L)) : null }) : null, B(Eo, { name: "fade-in-scale-up-transition", onAfterLeave: this.handleAfterLeave, appear: this.appear, onEnter: this.syncTransformOrigin, onBeforeLeave: this.syncTransformOrigin }, { default: () => {
      const { previewedImgProps: F = {} } = this;
      return wa(B("div", { class: `${l}-image-preview-wrapper`, ref: "previewWrapperRef" }, B("img", Object.assign({}, F, { draggable: false, onMousedown: this.handlePreviewMousedown, onDblclick: this.handlePreviewDblclick, class: [`${l}-image-preview`, F.class], key: this.previewSrc, src: this.previewSrc, ref: "previewRef", onDragstart: this.handleDragStart }))), [[ns, this.mergedShow]]);
    } })), [[eb, { enabled: this.mergedShow }]])) : null;
  } }));
} }), o1 = $n("n-image-group"), MT = Object.assign(Object.assign({}, p0), { srcList: Array, current: Number, defaultCurrent: { type: Number, default: 0 }, show: { type: Boolean, default: void 0 }, defaultShow: Boolean, onUpdateShow: [Function, Array], "onUpdate:show": [Function, Array], onUpdateCurrent: [Function, Array], "onUpdate:current": [Function, Array] }), ET = ot({ name: "ImageGroup", props: MT, setup(r) {
  const { mergedClsPrefixRef: i } = Sr(r), l = `c${$l()}`, d = Ie(null), f = Ie(r.defaultShow), g = zt(r, "show"), p = Ji(g, f), s = Ie(/* @__PURE__ */ new Map()), C = Ee(() => {
    if (r.srcList) {
      const fe = /* @__PURE__ */ new Map();
      return r.srcList.forEach((oe, he) => {
        fe.set(`p${he}`, oe);
      }), fe;
    }
    return s.value;
  }), P = Ee(() => Array.from(C.value.keys())), M = () => P.value.length;
  function D(fe, oe) {
    r.srcList && ea("image-group", "`n-image` can't be placed inside `n-image-group` when image group's `src-list` prop is set.");
    const he = `r${fe}`;
    return s.value.has(`r${he}`) || s.value.set(he, oe), function() {
      s.value.has(he) || s.value.delete(he);
    };
  }
  const L = Ie(r.defaultCurrent), $ = zt(r, "current"), z = Ji($, L), F = (fe) => {
    if (fe !== z.value) {
      const { onUpdateCurrent: oe, "onUpdate:current": he } = r;
      oe && Ot(oe, fe), he && Ot(he, fe), L.value = fe;
    }
  }, Z = Ee(() => P.value[z.value]), q = (fe) => {
    const oe = P.value.indexOf(fe);
    oe !== z.value && F(oe);
  }, K = Ee(() => C.value.get(Z.value));
  function te(fe) {
    const { onUpdateShow: oe, "onUpdate:show": he } = r;
    oe && Ot(oe, fe), he && Ot(he, fe), f.value = fe;
  }
  function re() {
    te(false);
  }
  const ie = Ee(() => {
    const fe = (he, _e) => {
      for (let Ue = he; Ue <= _e; Ue++) {
        const qe = P.value[Ue];
        if (C.value.get(qe)) return Ue;
      }
    }, oe = fe(z.value + 1, M() - 1);
    return oe === void 0 ? fe(0, z.value - 1) : oe;
  }), J = Ee(() => {
    const fe = (he, _e) => {
      for (let Ue = he; Ue >= _e; Ue--) {
        const qe = P.value[Ue];
        if (C.value.get(qe)) return Ue;
      }
    }, oe = fe(z.value - 1, 0);
    return oe === void 0 ? fe(M() - 1, z.value + 1) : oe;
  });
  function we(fe) {
    var oe, he;
    fe === 1 ? (J.value !== void 0 && F(ie.value), (oe = r.onPreviewNext) === null || oe === void 0 || oe.call(r)) : (ie.value !== void 0 && F(J.value), (he = r.onPreviewPrev) === null || he === void 0 || he.call(r));
  }
  return Xr(o1, { mergedClsPrefixRef: i, registerImageUrl: D, setThumbnailEl: (fe) => {
    var oe;
    (oe = d.value) === null || oe === void 0 || oe.setThumbnailEl(fe);
  }, toggleShow: (fe) => {
    te(true), q(fe);
  }, groupId: l, renderToolbarRef: zt(r, "renderToolbar") }), { mergedClsPrefix: i, previewInstRef: d, mergedShow: p, src: K, onClose: re, next: () => {
    we(1);
  }, prev: () => {
    we(-1);
  } };
}, render() {
  return B(n1, { theme: this.theme, themeOverrides: this.themeOverrides, ref: "previewInstRef", onPrev: this.prev, onNext: this.next, src: this.src, show: this.mergedShow, showToolbar: this.showToolbar, showToolbarTooltip: this.showToolbarTooltip, renderToolbar: this.renderToolbar, onClose: this.onClose }, this.$slots);
} }), RT = Object.assign({ alt: String, height: [String, Number], imgProps: Object, previewedImgProps: Object, lazy: Boolean, intersectionObserverOptions: Object, objectFit: { type: String, default: "fill" }, previewSrc: String, fallbackSrc: String, width: [String, Number], src: String, previewDisabled: Boolean, loadDescription: String, onError: Function, onLoad: Function }, p0);
let AT = 0;
const a1 = ot({ name: "Image", props: RT, slots: Object, inheritAttrs: false, setup(r) {
  const i = Ie(null), l = Ie(false), d = Ie(null), f = ur(o1, null), { mergedClsPrefixRef: g } = f || Sr(r), p = Ee(() => r.previewSrc || r.src), s = Ie(false), C = AT++, P = () => {
    if (r.previewDisabled || l.value) return;
    if (f) {
      f.setThumbnailEl(i.value), f.toggleShow(`r${C}`);
      return;
    }
    const { value: F } = d;
    F && (F.setThumbnailEl(i.value), s.value = true);
  }, M = { click: () => {
    P();
  }, showPreview: P }, D = Ie(!r.lazy);
  Ri(() => {
    var F;
    (F = i.value) === null || F === void 0 || F.setAttribute("data-group-id", (f == null ? void 0 : f.groupId) || "");
  }), Ri(() => {
    if (r.lazy && r.intersectionObserverOptions) {
      let F;
      const Z = bo(() => {
        F == null ? void 0 : F(), F = void 0, F = hP(i.value, r.intersectionObserverOptions, D);
      });
      Pn(() => {
        Z(), F == null ? void 0 : F();
      });
    }
  }), bo(() => {
    var F;
    r.src || ((F = r.imgProps) === null || F === void 0 || F.src), l.value = false;
  }), bo((F) => {
    var Z;
    const q = (Z = f == null ? void 0 : f.registerImageUrl) === null || Z === void 0 ? void 0 : Z.call(f, C, p.value || "");
    F(() => {
      q == null ? void 0 : q();
    });
  });
  function L(F) {
    var Z, q;
    M.showPreview(), (q = (Z = r.imgProps) === null || Z === void 0 ? void 0 : Z.onClick) === null || q === void 0 || q.call(Z, F);
  }
  function $() {
    s.value = false;
  }
  const z = Ie(false);
  return Xr(i1, { previewedImgPropsRef: zt(r, "previewedImgProps") }), Object.assign({ mergedClsPrefix: g, groupId: f == null ? void 0 : f.groupId, previewInstRef: d, imageRef: i, mergedPreviewSrc: p, showError: l, shouldStartLoading: D, loaded: z, mergedOnClick: (F) => {
    L(F);
  }, onPreviewClose: $, mergedOnError: (F) => {
    if (!D.value) return;
    l.value = true;
    const { onError: Z, imgProps: { onError: q } = {} } = r;
    Z == null ? void 0 : Z(F), q == null ? void 0 : q(F);
  }, mergedOnLoad: (F) => {
    const { onLoad: Z, imgProps: { onLoad: q } = {} } = r;
    Z == null ? void 0 : Z(F), q == null ? void 0 : q(F), z.value = true;
  }, previewShow: s }, M);
}, render() {
  var r, i;
  const { mergedClsPrefix: l, imgProps: d = {}, loaded: f, $attrs: g, lazy: p } = this, s = Zn(this.$slots.error, () => []), C = (i = (r = this.$slots).placeholder) === null || i === void 0 ? void 0 : i.call(r), P = this.src || d.src, M = this.showError && s.length ? s : B("img", Object.assign(Object.assign({}, d), { ref: "imageRef", width: this.width || d.width, height: this.height || d.height, src: this.showError ? this.fallbackSrc : p && this.intersectionObserverOptions ? this.shouldStartLoading ? P : void 0 : P, alt: this.alt || d.alt, "aria-label": this.alt || d.alt, onClick: this.mergedOnClick, onError: this.mergedOnError, onLoad: this.mergedOnLoad, loading: cP && p && !this.intersectionObserverOptions ? "lazy" : "eager", style: [d.style || "", C && !f ? { height: "0", width: "0", visibility: "hidden" } : "", { objectFit: this.objectFit }], "data-error": this.showError, "data-preview-src": this.previewSrc || this.src }));
  return B("div", Object.assign({}, g, { role: "none", class: [g.class, `${l}-image`, (this.previewDisabled || this.showError) && `${l}-image--preview-disabled`] }), this.groupId ? M : B(n1, { theme: this.theme, themeOverrides: this.themeOverrides, ref: "previewInstRef", showToolbar: this.showToolbar, showToolbarTooltip: this.showToolbarTooltip, renderToolbar: this.renderToolbar, src: this.mergedPreviewSrc, show: !this.previewDisabled && this.previewShow, onClose: this.onPreviewClose }, { default: () => M }), !f && C);
} }), DT = Ze([ue("input-number-suffix", `
 display: inline-block;
 margin-right: 10px;
 `), ue("input-number-prefix", `
 display: inline-block;
 margin-left: 10px;
 `)]);
function zT(r) {
  return r == null || typeof r == "string" && r.trim() === "" ? null : Number(r);
}
function FT(r) {
  return r.includes(".") && (/^(-)?\d+.*(\.|0)$/.test(r) || /^-?\d*$/.test(r)) || r === "-" || r === "-0";
}
function sg(r) {
  return r == null ? true : !Number.isNaN(r);
}
function $_(r, i) {
  return typeof r != "number" ? "" : i === void 0 ? String(r) : r.toFixed(i);
}
function lg(r) {
  if (r === null) return null;
  if (typeof r == "number") return r;
  {
    const i = Number(r);
    return Number.isNaN(i) ? null : i;
  }
}
const j_ = 800, N_ = 100, LT = Object.assign(Object.assign({}, Jt.props), { autofocus: Boolean, loading: { type: Boolean, default: void 0 }, placeholder: String, defaultValue: { type: Number, default: null }, value: Number, step: { type: [Number, String], default: 1 }, min: [Number, String], max: [Number, String], size: String, disabled: { type: Boolean, default: void 0 }, validator: Function, bordered: { type: Boolean, default: void 0 }, showButton: { type: Boolean, default: true }, buttonPlacement: { type: String, default: "right" }, inputProps: Object, readonly: Boolean, clearable: Boolean, keyboard: { type: Object, default: {} }, updateValueOnInput: { type: Boolean, default: true }, round: { type: Boolean, default: void 0 }, parse: Function, format: Function, precision: Number, status: String, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onFocus: [Function, Array], onBlur: [Function, Array], onClear: [Function, Array], onChange: [Function, Array] }), V_ = ot({ name: "InputNumber", props: LT, slots: Object, setup(r) {
  const { mergedBorderedRef: i, mergedClsPrefixRef: l, mergedRtlRef: d } = Sr(r), f = Jt("InputNumber", "-input-number", DT, m3, r, l), { localeRef: g } = as("InputNumber"), p = ka(r), { mergedSizeRef: s, mergedDisabledRef: C, mergedStatusRef: P } = p, M = Ie(null), D = Ie(null), L = Ie(null), $ = Ie(r.defaultValue), z = zt(r, "value"), F = Ji(z, $), Z = Ie(""), q = (kt) => {
    const ze = String(kt).split(".")[1];
    return ze ? ze.length : 0;
  }, K = (kt) => {
    const ze = [r.min, r.max, r.step, kt].map((at) => at === void 0 ? 0 : q(at));
    return Math.max(...ze);
  }, te = vi(() => {
    const { placeholder: kt } = r;
    return kt !== void 0 ? kt : g.value.placeholder;
  }), re = vi(() => {
    const kt = lg(r.step);
    return kt !== null ? kt === 0 ? 1 : Math.abs(kt) : 1;
  }), ie = vi(() => {
    const kt = lg(r.min);
    return kt !== null ? kt : null;
  }), J = vi(() => {
    const kt = lg(r.max);
    return kt !== null ? kt : null;
  }), we = () => {
    const { value: kt } = F;
    if (sg(kt)) {
      const { format: ze, precision: at } = r;
      ze ? Z.value = ze(kt) : kt === null || at === void 0 || q(kt) > at ? Z.value = $_(kt, void 0) : Z.value = $_(kt, at);
    } else Z.value = String(kt);
  };
  we();
  const fe = (kt) => {
    const { value: ze } = F;
    if (kt === ze) {
      we();
      return;
    }
    const { "onUpdate:value": at, onUpdateValue: Oe, onChange: Je } = r, { nTriggerFormInput: ht, nTriggerFormChange: bt } = p;
    Je && Ot(Je, kt), Oe && Ot(Oe, kt), at && Ot(at, kt), $.value = kt, ht(), bt();
  }, oe = ({ offset: kt, doUpdateIfValid: ze, fixPrecision: at, isInputing: Oe }) => {
    const { value: Je } = Z;
    if (Oe && FT(Je)) return false;
    const ht = (r.parse || zT)(Je);
    if (ht === null) return ze && fe(null), null;
    if (sg(ht)) {
      const bt = q(ht), { precision: rt } = r;
      if (rt !== void 0 && rt < bt && !at) return false;
      let vt = Number.parseFloat((ht + kt).toFixed(rt ?? K(ht)));
      if (sg(vt)) {
        const { value: Wt } = J, { value: ci } = ie;
        if (Wt !== null && vt > Wt) {
          if (!ze || Oe) return false;
          vt = Wt;
        }
        if (ci !== null && vt < ci) {
          if (!ze || Oe) return false;
          vt = ci;
        }
        return r.validator && !r.validator(vt) ? false : (ze && fe(vt), vt);
      }
    }
    return false;
  }, he = vi(() => oe({ offset: 0, doUpdateIfValid: false, isInputing: false, fixPrecision: false }) === false), _e = vi(() => {
    const { value: kt } = F;
    if (r.validator && kt === null) return false;
    const { value: ze } = re;
    return oe({ offset: -ze, doUpdateIfValid: false, isInputing: false, fixPrecision: false }) !== false;
  }), Ue = vi(() => {
    const { value: kt } = F;
    if (r.validator && kt === null) return false;
    const { value: ze } = re;
    return oe({ offset: +ze, doUpdateIfValid: false, isInputing: false, fixPrecision: false }) !== false;
  });
  function qe(kt) {
    const { onFocus: ze } = r, { nTriggerFormFocus: at } = p;
    ze && Ot(ze, kt), at();
  }
  function tt(kt) {
    var ze, at;
    if (kt.target === ((ze = M.value) === null || ze === void 0 ? void 0 : ze.wrapperElRef)) return;
    const Oe = oe({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true });
    if (Oe !== false) {
      const bt = (at = M.value) === null || at === void 0 ? void 0 : at.inputElRef;
      bt && (bt.value = String(Oe || "")), F.value === Oe && we();
    } else we();
    const { onBlur: Je } = r, { nTriggerFormBlur: ht } = p;
    Je && Ot(Je, kt), ht(), Wn(() => {
      we();
    });
  }
  function ut(kt) {
    const { onClear: ze } = r;
    ze && Ot(ze, kt);
  }
  function mt() {
    const { value: kt } = Ue;
    if (!kt) {
      Zt();
      return;
    }
    const { value: ze } = F;
    if (ze === null) r.validator || fe(ft());
    else {
      const { value: at } = re;
      oe({ offset: at, doUpdateIfValid: true, isInputing: false, fixPrecision: true });
    }
  }
  function St() {
    const { value: kt } = _e;
    if (!kt) {
      gt();
      return;
    }
    const { value: ze } = F;
    if (ze === null) r.validator || fe(ft());
    else {
      const { value: at } = re;
      oe({ offset: -at, doUpdateIfValid: true, isInputing: false, fixPrecision: true });
    }
  }
  const st = qe, nt = tt;
  function ft() {
    if (r.validator) return null;
    const { value: kt } = ie, { value: ze } = J;
    return kt !== null ? Math.max(0, kt) : ze !== null ? Math.min(0, ze) : 0;
  }
  function Lt(kt) {
    ut(kt), fe(null);
  }
  function pt(kt) {
    var ze, at, Oe;
    !((ze = L.value) === null || ze === void 0) && ze.$el.contains(kt.target) && kt.preventDefault(), !((at = D.value) === null || at === void 0) && at.$el.contains(kt.target) && kt.preventDefault(), (Oe = M.value) === null || Oe === void 0 || Oe.activate();
  }
  let wt = null, Ft = null, tr = null;
  function gt() {
    tr && (window.clearTimeout(tr), tr = null), wt && (window.clearInterval(wt), wt = null);
  }
  let Bt = null;
  function Zt() {
    Bt && (window.clearTimeout(Bt), Bt = null), Ft && (window.clearInterval(Ft), Ft = null);
  }
  function ir() {
    gt(), tr = window.setTimeout(() => {
      wt = window.setInterval(() => {
        St();
      }, N_);
    }, j_), Bn("mouseup", document, gt, { once: true });
  }
  function Cr() {
    Zt(), Bt = window.setTimeout(() => {
      Ft = window.setInterval(() => {
        mt();
      }, N_);
    }, j_), Bn("mouseup", document, Zt, { once: true });
  }
  const Ar = () => {
    Ft || mt();
  }, or = () => {
    wt || St();
  };
  function Tr(kt) {
    var ze, at;
    if (kt.key === "Enter") {
      if (kt.target === ((ze = M.value) === null || ze === void 0 ? void 0 : ze.wrapperElRef)) return;
      oe({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true }) !== false && ((at = M.value) === null || at === void 0 || at.deactivate());
    } else if (kt.key === "ArrowUp") {
      if (!Ue.value || r.keyboard.ArrowUp === false) return;
      kt.preventDefault(), oe({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true }) !== false && mt();
    } else if (kt.key === "ArrowDown") {
      if (!_e.value || r.keyboard.ArrowDown === false) return;
      kt.preventDefault(), oe({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true }) !== false && St();
    }
  }
  function Xt(kt) {
    Z.value = kt, r.updateValueOnInput && !r.format && !r.parse && r.precision === void 0 && oe({ offset: 0, doUpdateIfValid: true, isInputing: true, fixPrecision: false });
  }
  Ht(F, () => {
    we();
  });
  const Dr = { focus: () => {
    var kt;
    return (kt = M.value) === null || kt === void 0 ? void 0 : kt.focus();
  }, blur: () => {
    var kt;
    return (kt = M.value) === null || kt === void 0 ? void 0 : kt.blur();
  }, select: () => {
    var kt;
    return (kt = M.value) === null || kt === void 0 ? void 0 : kt.select();
  } }, nr = Tn("InputNumber", d, l);
  return Object.assign(Object.assign({}, Dr), { rtlEnabled: nr, inputInstRef: M, minusButtonInstRef: D, addButtonInstRef: L, mergedClsPrefix: l, mergedBordered: i, uncontrolledValue: $, mergedValue: F, mergedPlaceholder: te, displayedValueInvalid: he, mergedSize: s, mergedDisabled: C, displayedValue: Z, addable: Ue, minusable: _e, mergedStatus: P, handleFocus: st, handleBlur: nt, handleClear: Lt, handleMouseDown: pt, handleAddClick: Ar, handleMinusClick: or, handleAddMousedown: Cr, handleMinusMousedown: ir, handleKeyDown: Tr, handleUpdateDisplayedValue: Xt, mergedTheme: f, inputThemeOverrides: { paddingSmall: "0 8px 0 10px", paddingMedium: "0 8px 0 12px", paddingLarge: "0 8px 0 14px" }, buttonThemeOverrides: Ee(() => {
    const { self: { iconColorDisabled: kt } } = f.value, [ze, at, Oe, Je] = Yo(kt);
    return { textColorTextDisabled: `rgb(${ze}, ${at}, ${Oe})`, opacityDisabled: `${Je}` };
  }) });
}, render() {
  const { mergedClsPrefix: r, $slots: i } = this, l = () => B(d_, { text: true, disabled: !this.minusable || this.mergedDisabled || this.readonly, focusable: false, theme: this.mergedTheme.peers.Button, themeOverrides: this.mergedTheme.peerOverrides.Button, builtinThemeOverrides: this.buttonThemeOverrides, onClick: this.handleMinusClick, onMousedown: this.handleMinusMousedown, ref: "minusButtonInstRef" }, { icon: () => Zn(i["minus-icon"], () => [B(qr, { clsPrefix: r }, { default: () => B(kk, null) })]) }), d = () => B(d_, { text: true, disabled: !this.addable || this.mergedDisabled || this.readonly, focusable: false, theme: this.mergedTheme.peers.Button, themeOverrides: this.mergedTheme.peerOverrides.Button, builtinThemeOverrides: this.buttonThemeOverrides, onClick: this.handleAddClick, onMousedown: this.handleAddMousedown, ref: "addButtonInstRef" }, { icon: () => Zn(i["add-icon"], () => [B(qr, { clsPrefix: r }, { default: () => B(Rp, null) })]) });
  return B("div", { class: [`${r}-input-number`, this.rtlEnabled && `${r}-input-number--rtl`] }, B(_o, { ref: "inputInstRef", autofocus: this.autofocus, status: this.mergedStatus, bordered: this.mergedBordered, loading: this.loading, value: this.displayedValue, onUpdateValue: this.handleUpdateDisplayedValue, theme: this.mergedTheme.peers.Input, themeOverrides: this.mergedTheme.peerOverrides.Input, builtinThemeOverrides: this.inputThemeOverrides, size: this.mergedSize, placeholder: this.mergedPlaceholder, disabled: this.mergedDisabled, readonly: this.readonly, round: this.round, textDecoration: this.displayedValueInvalid ? "line-through" : void 0, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeydown: this.handleKeyDown, onMousedown: this.handleMouseDown, onClear: this.handleClear, clearable: this.clearable, inputProps: this.inputProps, internalLoadingBeforeSuffix: true }, { prefix: () => {
    var f;
    return this.showButton && this.buttonPlacement === "both" ? [l(), oi(i.prefix, (g) => g ? B("span", { class: `${r}-input-number-prefix` }, g) : null)] : (f = i.prefix) === null || f === void 0 ? void 0 : f.call(i);
  }, suffix: () => {
    var f;
    return this.showButton ? [oi(i.suffix, (g) => g ? B("span", { class: `${r}-input-number-suffix` }, g) : null), this.buttonPlacement === "right" ? l() : null, d()] : (f = i.suffix) === null || f === void 0 ? void 0 : f.call(i);
  } }));
} }), BT = Ze([ue("list", `
 --n-merged-border-color: var(--n-border-color);
 --n-merged-color: var(--n-color);
 --n-merged-color-hover: var(--n-color-hover);
 margin: 0;
 font-size: var(--n-font-size);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 padding: 0;
 list-style-type: none;
 color: var(--n-text-color);
 background-color: var(--n-merged-color);
 `, [Ge("show-divider", [ue("list-item", [Ze("&:not(:last-child)", [Ae("divider", `
 background-color: var(--n-merged-border-color);
 `)])])]), Ge("clickable", [ue("list-item", `
 cursor: pointer;
 `)]), Ge("bordered", `
 border: 1px solid var(--n-merged-border-color);
 border-radius: var(--n-border-radius);
 `), Ge("hoverable", [ue("list-item", `
 border-radius: var(--n-border-radius);
 `, [Ze("&:hover", `
 background-color: var(--n-merged-color-hover);
 `, [Ae("divider", `
 background-color: transparent;
 `)])])]), Ge("bordered, hoverable", [ue("list-item", `
 padding: 12px 20px;
 `), Ae("header, footer", `
 padding: 12px 20px;
 `)]), Ae("header, footer", `
 padding: 12px 0;
 box-sizing: border-box;
 transition: border-color .3s var(--n-bezier);
 `, [Ze("&:not(:last-child)", `
 border-bottom: 1px solid var(--n-merged-border-color);
 `)]), ue("list-item", `
 position: relative;
 padding: 12px 0; 
 box-sizing: border-box;
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [Ae("prefix", `
 margin-right: 20px;
 flex: 0;
 `), Ae("suffix", `
 margin-left: 20px;
 flex: 0;
 `), Ae("main", `
 flex: 1;
 `), Ae("divider", `
 height: 1px;
 position: absolute;
 bottom: 0;
 left: 0;
 right: 0;
 background-color: transparent;
 transition: background-color .3s var(--n-bezier);
 pointer-events: none;
 `)])]), qy(ue("list", `
 --n-merged-color-hover: var(--n-color-hover-modal);
 --n-merged-color: var(--n-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 `)), Wy(ue("list", `
 --n-merged-color-hover: var(--n-color-hover-popover);
 --n-merged-color: var(--n-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 `))]), OT = Object.assign(Object.assign({}, Jt.props), { size: { type: String, default: "medium" }, bordered: Boolean, clickable: Boolean, hoverable: Boolean, showDivider: { type: Boolean, default: true } }), s1 = $n("n-list"), hh = ot({ name: "List", props: OT, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l, mergedRtlRef: d } = Sr(r), f = Tn("List", d, i), g = Jt("List", "-list", BT, g3, r, i);
  Xr(s1, { showDividerRef: zt(r, "showDivider"), mergedClsPrefixRef: i });
  const p = Ee(() => {
    const { common: { cubicBezierEaseInOut: C }, self: { fontSize: P, textColor: M, color: D, colorModal: L, colorPopover: $, borderColor: z, borderColorModal: F, borderColorPopover: Z, borderRadius: q, colorHover: K, colorHoverModal: te, colorHoverPopover: re } } = g.value;
    return { "--n-font-size": P, "--n-bezier": C, "--n-text-color": M, "--n-color": D, "--n-border-radius": q, "--n-border-color": z, "--n-border-color-modal": F, "--n-border-color-popover": Z, "--n-color-modal": L, "--n-color-popover": $, "--n-color-hover": K, "--n-color-hover-modal": te, "--n-color-hover-popover": re };
  }), s = l ? ai("list", void 0, p, r) : void 0;
  return { mergedClsPrefix: i, rtlEnabled: f, cssVars: l ? void 0 : p, themeClass: s == null ? void 0 : s.themeClass, onRender: s == null ? void 0 : s.onRender };
}, render() {
  var r;
  const { $slots: i, mergedClsPrefix: l, onRender: d } = this;
  return d == null ? void 0 : d(), B("ul", { class: [`${l}-list`, this.rtlEnabled && `${l}-list--rtl`, this.bordered && `${l}-list--bordered`, this.showDivider && `${l}-list--show-divider`, this.hoverable && `${l}-list--hoverable`, this.clickable && `${l}-list--clickable`, this.themeClass], style: this.cssVars }, i.header ? B("div", { class: `${l}-list__header` }, i.header()) : null, (r = i.default) === null || r === void 0 ? void 0 : r.call(i), i.footer ? B("div", { class: `${l}-list__footer` }, i.footer()) : null);
} }), fh = ot({ name: "ListItem", slots: Object, setup() {
  const r = ur(s1, null);
  return r || ea("list-item", "`n-list-item` must be placed in `n-list`."), { showDivider: r.showDividerRef, mergedClsPrefix: r.mergedClsPrefixRef };
}, render() {
  const { $slots: r, mergedClsPrefix: i } = this;
  return B("li", { class: `${i}-list-item` }, r.prefix ? B("div", { class: `${i}-list-item__prefix` }, r.prefix()) : null, r.default ? B("div", { class: `${i}-list-item__main` }, r) : null, r.suffix ? B("div", { class: `${i}-list-item__suffix` }, r.suffix()) : null, this.showDivider && B("div", { class: `${i}-list-item__divider` }));
} }), l1 = $n("n-popconfirm"), u1 = { positiveText: String, negativeText: String, showIcon: { type: Boolean, default: true }, onPositiveClick: { type: Function, required: true }, onNegativeClick: { type: Function, required: true } }, U_ = Xd(u1), $T = ot({ name: "NPopconfirmPanel", props: u1, setup(r) {
  const { localeRef: i } = as("Popconfirm"), { inlineThemeDisabled: l } = Sr(), { mergedClsPrefixRef: d, mergedThemeRef: f, props: g } = ur(l1), p = Ee(() => {
    const { common: { cubicBezierEaseInOut: C }, self: { fontSize: P, iconSize: M, iconColor: D } } = f.value;
    return { "--n-bezier": C, "--n-font-size": P, "--n-icon-size": M, "--n-icon-color": D };
  }), s = l ? ai("popconfirm-panel", void 0, p, g) : void 0;
  return Object.assign(Object.assign({}, as("Popconfirm")), { mergedClsPrefix: d, cssVars: l ? void 0 : p, localizedPositiveText: Ee(() => r.positiveText || i.value.positiveText), localizedNegativeText: Ee(() => r.negativeText || i.value.negativeText), positiveButtonProps: zt(g, "positiveButtonProps"), negativeButtonProps: zt(g, "negativeButtonProps"), handlePositiveClick(C) {
    r.onPositiveClick(C);
  }, handleNegativeClick(C) {
    r.onNegativeClick(C);
  }, themeClass: s == null ? void 0 : s.themeClass, onRender: s == null ? void 0 : s.onRender });
}, render() {
  var r;
  const { mergedClsPrefix: i, showIcon: l, $slots: d } = this, f = Zn(d.action, () => this.negativeText === null && this.positiveText === null ? [] : [this.negativeText !== null && B($r, Object.assign({ size: "small", onClick: this.handleNegativeClick }, this.negativeButtonProps), { default: () => this.localizedNegativeText }), this.positiveText !== null && B($r, Object.assign({ size: "small", type: "primary", onClick: this.handlePositiveClick }, this.positiveButtonProps), { default: () => this.localizedPositiveText })]);
  return (r = this.onRender) === null || r === void 0 || r.call(this), B("div", { class: [`${i}-popconfirm__panel`, this.themeClass], style: this.cssVars }, oi(d.default, (g) => l || g ? B("div", { class: `${i}-popconfirm__body` }, l ? B("div", { class: `${i}-popconfirm__icon` }, Zn(d.icon, () => [B(qr, { clsPrefix: i }, { default: () => B(Pp, null) })])) : null, g) : null), f ? B("div", { class: [`${i}-popconfirm__action`] }, f) : null);
} }), jT = ue("popconfirm", [Ae("body", `
 font-size: var(--n-font-size);
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 position: relative;
 `, [Ae("icon", `
 display: flex;
 font-size: var(--n-icon-size);
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 margin: 0 8px 0 0;
 `)]), Ae("action", `
 display: flex;
 justify-content: flex-end;
 `, [Ze("&:not(:first-child)", "margin-top: 8px"), ue("button", [Ze("&:not(:last-child)", "margin-right: 8px;")])])]), NT = Object.assign(Object.assign(Object.assign({}, Jt.props), _3), { positiveText: String, negativeText: String, showIcon: { type: Boolean, default: true }, trigger: { type: String, default: "click" }, positiveButtonProps: Object, negativeButtonProps: Object, onPositiveClick: Function, onNegativeClick: Function }), VT = ot({ name: "Popconfirm", props: NT, slots: Object, __popover__: true, setup(r) {
  const { mergedClsPrefixRef: i } = Sr(), l = Jt("Popconfirm", "-popconfirm", jT, v3, r, i), d = Ie(null);
  function f(s) {
    var C;
    if (!(!((C = d.value) === null || C === void 0) && C.getMergedShow())) return;
    const { onPositiveClick: P, "onUpdate:show": M } = r;
    Promise.resolve(P ? P(s) : true).then((D) => {
      var L;
      D !== false && ((L = d.value) === null || L === void 0 || L.setShow(false), M && Ot(M, false));
    });
  }
  function g(s) {
    var C;
    if (!(!((C = d.value) === null || C === void 0) && C.getMergedShow())) return;
    const { onNegativeClick: P, "onUpdate:show": M } = r;
    Promise.resolve(P ? P(s) : true).then((D) => {
      var L;
      D !== false && ((L = d.value) === null || L === void 0 || L.setShow(false), M && Ot(M, false));
    });
  }
  return Xr(l1, { mergedThemeRef: l, mergedClsPrefixRef: i, props: r }), { setShow(s) {
    var C;
    (C = d.value) === null || C === void 0 || C.setShow(s);
  }, syncPosition() {
    var s;
    (s = d.value) === null || s === void 0 || s.syncPosition();
  }, mergedTheme: l, popoverInstRef: d, handlePositiveClick: f, handleNegativeClick: g };
}, render() {
  const { $slots: r, $props: i, mergedTheme: l } = this;
  return B(n0, Object.assign({}, ob(i, U_), { theme: l.peers.Popover, themeOverrides: l.peerOverrides.Popover, internalExtraClass: ["popconfirm"], ref: "popoverInstRef" }), { trigger: r.trigger, default: () => {
    const d = kg(i, U_);
    return B($T, Object.assign({}, d, { onPositiveClick: this.handlePositiveClick, onNegativeClick: this.handleNegativeClick }), r);
  } });
} }), UT = { success: B(s0, null), error: B(o0, null), warning: B(Pp, null), info: B(a0, null) }, GT = ot({ name: "ProgressCircle", props: { clsPrefix: { type: String, required: true }, status: { type: String, required: true }, strokeWidth: { type: Number, required: true }, fillColor: [String, Object], railColor: String, railStyle: [String, Object], percentage: { type: Number, default: 0 }, offsetDegree: { type: Number, default: 0 }, showIndicator: { type: Boolean, required: true }, indicatorTextColor: String, unit: String, viewBoxWidth: { type: Number, required: true }, gapDegree: { type: Number, required: true }, gapOffsetDegree: { type: Number, default: 0 } }, setup(r, { slots: i }) {
  const l = Ee(() => {
    const g = "gradient", { fillColor: p } = r;
    return typeof p == "object" ? `${g}-${y3(JSON.stringify(p))}` : g;
  });
  function d(g, p, s, C) {
    const { gapDegree: P, viewBoxWidth: M, strokeWidth: D } = r, L = 50, $ = 0, z = L, F = 0, Z = 2 * L, q = 50 + D / 2, K = `M ${q},${q} m ${$},${z}
      a ${L},${L} 0 1 1 ${F},${-Z}
      a ${L},${L} 0 1 1 ${-F},${Z}`, te = Math.PI * 2 * L, re = { stroke: C === "rail" ? s : typeof r.fillColor == "object" ? `url(#${l.value})` : s, strokeDasharray: `${g / 100 * (te - P)}px ${M * 8}px`, strokeDashoffset: `-${P / 2}px`, transformOrigin: p ? "center" : void 0, transform: p ? `rotate(${p}deg)` : void 0 };
    return { pathString: K, pathStyle: re };
  }
  const f = () => {
    const g = typeof r.fillColor == "object", p = g ? r.fillColor.stops[0] : "", s = g ? r.fillColor.stops[1] : "";
    return g && B("defs", null, B("linearGradient", { id: l.value, x1: "0%", y1: "100%", x2: "100%", y2: "0%" }, B("stop", { offset: "0%", "stop-color": p }), B("stop", { offset: "100%", "stop-color": s })));
  };
  return () => {
    const { fillColor: g, railColor: p, strokeWidth: s, offsetDegree: C, status: P, percentage: M, showIndicator: D, indicatorTextColor: L, unit: $, gapOffsetDegree: z, clsPrefix: F } = r, { pathString: Z, pathStyle: q } = d(100, 0, p, "rail"), { pathString: K, pathStyle: te } = d(M, C, g, "fill"), re = 100 + s;
    return B("div", { class: `${F}-progress-content`, role: "none" }, B("div", { class: `${F}-progress-graph`, "aria-hidden": true }, B("div", { class: `${F}-progress-graph-circle`, style: { transform: z ? `rotate(${z}deg)` : void 0 } }, B("svg", { viewBox: `0 0 ${re} ${re}` }, f(), B("g", null, B("path", { class: `${F}-progress-graph-circle-rail`, d: Z, "stroke-width": s, "stroke-linecap": "round", fill: "none", style: q })), B("g", null, B("path", { class: [`${F}-progress-graph-circle-fill`, M === 0 && `${F}-progress-graph-circle-fill--empty`], d: K, "stroke-width": s, "stroke-linecap": "round", fill: "none", style: te }))))), D ? B("div", null, i.default ? B("div", { class: `${F}-progress-custom-content`, role: "none" }, i.default()) : P !== "default" ? B("div", { class: `${F}-progress-icon`, "aria-hidden": true }, B(qr, { clsPrefix: F }, { default: () => UT[P] })) : B("div", { class: `${F}-progress-text`, style: { color: L }, role: "none" }, B("span", { class: `${F}-progress-text__percentage` }, M), B("span", { class: `${F}-progress-text__unit` }, $))) : null);
  };
} }), qT = { success: B(s0, null), error: B(o0, null), warning: B(Pp, null), info: B(a0, null) }, WT = ot({ name: "ProgressLine", props: { clsPrefix: { type: String, required: true }, percentage: { type: Number, default: 0 }, railColor: String, railStyle: [String, Object], fillColor: [String, Object], status: { type: String, required: true }, indicatorPlacement: { type: String, required: true }, indicatorTextColor: String, unit: { type: String, default: "%" }, processing: { type: Boolean, required: true }, showIndicator: { type: Boolean, required: true }, height: [String, Number], railBorderRadius: [String, Number], fillBorderRadius: [String, Number] }, setup(r, { slots: i }) {
  const l = Ee(() => Ko(r.height)), d = Ee(() => {
    var p, s;
    return typeof r.fillColor == "object" ? `linear-gradient(to right, ${(p = r.fillColor) === null || p === void 0 ? void 0 : p.stops[0]} , ${(s = r.fillColor) === null || s === void 0 ? void 0 : s.stops[1]})` : r.fillColor;
  }), f = Ee(() => r.railBorderRadius !== void 0 ? Ko(r.railBorderRadius) : r.height !== void 0 ? Ko(r.height, { c: 0.5 }) : ""), g = Ee(() => r.fillBorderRadius !== void 0 ? Ko(r.fillBorderRadius) : r.railBorderRadius !== void 0 ? Ko(r.railBorderRadius) : r.height !== void 0 ? Ko(r.height, { c: 0.5 }) : "");
  return () => {
    const { indicatorPlacement: p, railColor: s, railStyle: C, percentage: P, unit: M, indicatorTextColor: D, status: L, showIndicator: $, processing: z, clsPrefix: F } = r;
    return B("div", { class: `${F}-progress-content`, role: "none" }, B("div", { class: `${F}-progress-graph`, "aria-hidden": true }, B("div", { class: [`${F}-progress-graph-line`, { [`${F}-progress-graph-line--indicator-${p}`]: true }] }, B("div", { class: `${F}-progress-graph-line-rail`, style: [{ backgroundColor: s, height: l.value, borderRadius: f.value }, C] }, B("div", { class: [`${F}-progress-graph-line-fill`, z && `${F}-progress-graph-line-fill--processing`], style: { maxWidth: `${r.percentage}%`, background: d.value, height: l.value, lineHeight: l.value, borderRadius: g.value } }, p === "inside" ? B("div", { class: `${F}-progress-graph-line-indicator`, style: { color: D } }, i.default ? i.default() : `${P}${M}`) : null)))), $ && p === "outside" ? B("div", null, i.default ? B("div", { class: `${F}-progress-custom-content`, style: { color: D }, role: "none" }, i.default()) : L === "default" ? B("div", { role: "none", class: `${F}-progress-icon ${F}-progress-icon--as-text`, style: { color: D } }, P, M) : B("div", { class: `${F}-progress-icon`, "aria-hidden": true }, B(qr, { clsPrefix: F }, { default: () => qT[L] }))) : null);
  };
} });
function G_(r, i, l = 100) {
  return `m ${l / 2} ${l / 2 - r} a ${r} ${r} 0 1 1 0 ${2 * r} a ${r} ${r} 0 1 1 0 -${2 * r}`;
}
const ZT = ot({ name: "ProgressMultipleCircle", props: { clsPrefix: { type: String, required: true }, viewBoxWidth: { type: Number, required: true }, percentage: { type: Array, default: [0] }, strokeWidth: { type: Number, required: true }, circleGap: { type: Number, required: true }, showIndicator: { type: Boolean, required: true }, fillColor: { type: Array, default: () => [] }, railColor: { type: Array, default: () => [] }, railStyle: { type: Array, default: () => [] } }, setup(r, { slots: i }) {
  const l = Ee(() => r.percentage.map((g, p) => `${Math.PI * g / 100 * (r.viewBoxWidth / 2 - r.strokeWidth / 2 * (1 + 2 * p) - r.circleGap * p) * 2}, ${r.viewBoxWidth * 8}`)), d = (f, g) => {
    const p = r.fillColor[g], s = typeof p == "object" ? p.stops[0] : "", C = typeof p == "object" ? p.stops[1] : "";
    return typeof r.fillColor[g] == "object" && B("linearGradient", { id: `gradient-${g}`, x1: "100%", y1: "0%", x2: "0%", y2: "100%" }, B("stop", { offset: "0%", "stop-color": s }), B("stop", { offset: "100%", "stop-color": C }));
  };
  return () => {
    const { viewBoxWidth: f, strokeWidth: g, circleGap: p, showIndicator: s, fillColor: C, railColor: P, railStyle: M, percentage: D, clsPrefix: L } = r;
    return B("div", { class: `${L}-progress-content`, role: "none" }, B("div", { class: `${L}-progress-graph`, "aria-hidden": true }, B("div", { class: `${L}-progress-graph-circle` }, B("svg", { viewBox: `0 0 ${f} ${f}` }, B("defs", null, D.map(($, z) => d($, z))), D.map(($, z) => B("g", { key: z }, B("path", { class: `${L}-progress-graph-circle-rail`, d: G_(f / 2 - g / 2 * (1 + 2 * z) - p * z, g, f), "stroke-width": g, "stroke-linecap": "round", fill: "none", style: [{ strokeDashoffset: 0, stroke: P[z] }, M[z]] }), B("path", { class: [`${L}-progress-graph-circle-fill`, $ === 0 && `${L}-progress-graph-circle-fill--empty`], d: G_(f / 2 - g / 2 * (1 + 2 * z) - p * z, g, f), "stroke-width": g, "stroke-linecap": "round", fill: "none", style: { strokeDasharray: l.value[z], strokeDashoffset: 0, stroke: typeof C[z] == "object" ? `url(#gradient-${z})` : C[z] } })))))), s && i.default ? B("div", null, B("div", { class: `${L}-progress-text` }, i.default())) : null);
  };
} }), HT = Ze([ue("progress", { display: "inline-block" }, [ue("progress-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 `), Ge("line", `
 width: 100%;
 display: block;
 `, [ue("progress-content", `
 display: flex;
 align-items: center;
 `, [ue("progress-graph", { flex: 1 })]), ue("progress-custom-content", { marginLeft: "14px" }), ue("progress-icon", `
 width: 30px;
 padding-left: 14px;
 height: var(--n-icon-size-line);
 line-height: var(--n-icon-size-line);
 font-size: var(--n-icon-size-line);
 `, [Ge("as-text", `
 color: var(--n-text-color-line-outer);
 text-align: center;
 width: 40px;
 font-size: var(--n-font-size);
 padding-left: 4px;
 transition: color .3s var(--n-bezier);
 `)])]), Ge("circle, dashboard", { width: "120px" }, [ue("progress-custom-content", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `), ue("progress-text", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: inherit;
 font-size: var(--n-font-size-circle);
 color: var(--n-text-color-circle);
 font-weight: var(--n-font-weight-circle);
 transition: color .3s var(--n-bezier);
 white-space: nowrap;
 `), ue("progress-icon", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: var(--n-icon-color);
 font-size: var(--n-icon-size-circle);
 `)]), Ge("multiple-circle", `
 width: 200px;
 color: inherit;
 `, [ue("progress-text", `
 font-weight: var(--n-font-weight-circle);
 color: var(--n-text-color-circle);
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `)]), ue("progress-content", { position: "relative" }), ue("progress-graph", { position: "relative" }, [ue("progress-graph-circle", [Ze("svg", { verticalAlign: "bottom" }), ue("progress-graph-circle-fill", `
 stroke: var(--n-fill-color);
 transition:
 opacity .3s var(--n-bezier),
 stroke .3s var(--n-bezier),
 stroke-dasharray .3s var(--n-bezier);
 `, [Ge("empty", { opacity: 0 })]), ue("progress-graph-circle-rail", `
 transition: stroke .3s var(--n-bezier);
 overflow: hidden;
 stroke: var(--n-rail-color);
 `)]), ue("progress-graph-line", [Ge("indicator-inside", [ue("progress-graph-line-rail", `
 height: 16px;
 line-height: 16px;
 border-radius: 10px;
 `, [ue("progress-graph-line-fill", `
 height: inherit;
 border-radius: 10px;
 `), ue("progress-graph-line-indicator", `
 background: #0000;
 white-space: nowrap;
 text-align: right;
 margin-left: 14px;
 margin-right: 14px;
 height: inherit;
 font-size: 12px;
 color: var(--n-text-color-line-inner);
 transition: color .3s var(--n-bezier);
 `)])]), Ge("indicator-inside-label", `
 height: 16px;
 display: flex;
 align-items: center;
 `, [ue("progress-graph-line-rail", `
 flex: 1;
 transition: background-color .3s var(--n-bezier);
 `), ue("progress-graph-line-indicator", `
 background: var(--n-fill-color);
 font-size: 12px;
 transform: translateZ(0);
 display: flex;
 vertical-align: middle;
 height: 16px;
 line-height: 16px;
 padding: 0 10px;
 border-radius: 10px;
 position: absolute;
 white-space: nowrap;
 color: var(--n-text-color-line-inner);
 transition:
 right .2s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `)]), ue("progress-graph-line-rail", `
 position: relative;
 overflow: hidden;
 height: var(--n-rail-height);
 border-radius: 5px;
 background-color: var(--n-rail-color);
 transition: background-color .3s var(--n-bezier);
 `, [ue("progress-graph-line-fill", `
 background: var(--n-fill-color);
 position: relative;
 border-radius: 5px;
 height: inherit;
 width: 100%;
 max-width: 0%;
 transition:
 background-color .3s var(--n-bezier),
 max-width .2s var(--n-bezier);
 `, [Ge("processing", [Ze("&::after", `
 content: "";
 background-image: var(--n-line-bg-processing);
 animation: progress-processing-animation 2s var(--n-bezier) infinite;
 `)])])])])])]), Ze("@keyframes progress-processing-animation", `
 0% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 100%;
 opacity: 1;
 }
 66% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 100% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 `)]), XT = Object.assign(Object.assign({}, Jt.props), { processing: Boolean, type: { type: String, default: "line" }, gapDegree: Number, gapOffsetDegree: Number, status: { type: String, default: "default" }, railColor: [String, Array], railStyle: [String, Array], color: [String, Array, Object], viewBoxWidth: { type: Number, default: 100 }, strokeWidth: { type: Number, default: 7 }, percentage: [Number, Array], unit: { type: String, default: "%" }, showIndicator: { type: Boolean, default: true }, indicatorPosition: { type: String, default: "outside" }, indicatorPlacement: { type: String, default: "outside" }, indicatorTextColor: String, circleGap: { type: Number, default: 1 }, height: Number, borderRadius: [String, Number], fillBorderRadius: [String, Number], offsetDegree: Number }), YT = ot({ name: "Progress", props: XT, setup(r) {
  const i = Ee(() => r.indicatorPlacement || r.indicatorPosition), l = Ee(() => {
    if (r.gapDegree || r.gapDegree === 0) return r.gapDegree;
    if (r.type === "dashboard") return 75;
  }), { mergedClsPrefixRef: d, inlineThemeDisabled: f } = Sr(r), g = Jt("Progress", "-progress", HT, b3, r, d), p = Ee(() => {
    const { status: C } = r, { common: { cubicBezierEaseInOut: P }, self: { fontSize: M, fontSizeCircle: D, railColor: L, railHeight: $, iconSizeCircle: z, iconSizeLine: F, textColorCircle: Z, textColorLineInner: q, textColorLineOuter: K, lineBgProcessing: te, fontWeightCircle: re, [Vt("iconColor", C)]: ie, [Vt("fillColor", C)]: J } } = g.value;
    return { "--n-bezier": P, "--n-fill-color": J, "--n-font-size": M, "--n-font-size-circle": D, "--n-font-weight-circle": re, "--n-icon-color": ie, "--n-icon-size-circle": z, "--n-icon-size-line": F, "--n-line-bg-processing": te, "--n-rail-color": L, "--n-rail-height": $, "--n-text-color-circle": Z, "--n-text-color-line-inner": q, "--n-text-color-line-outer": K };
  }), s = f ? ai("progress", Ee(() => r.status[0]), p, r) : void 0;
  return { mergedClsPrefix: d, mergedIndicatorPlacement: i, gapDeg: l, cssVars: f ? void 0 : p, themeClass: s == null ? void 0 : s.themeClass, onRender: s == null ? void 0 : s.onRender };
}, render() {
  const { type: r, cssVars: i, indicatorTextColor: l, showIndicator: d, status: f, railColor: g, railStyle: p, color: s, percentage: C, viewBoxWidth: P, strokeWidth: M, mergedIndicatorPlacement: D, unit: L, borderRadius: $, fillBorderRadius: z, height: F, processing: Z, circleGap: q, mergedClsPrefix: K, gapDeg: te, gapOffsetDegree: re, themeClass: ie, $slots: J, onRender: we } = this;
  return we == null ? void 0 : we(), B("div", { class: [ie, `${K}-progress`, `${K}-progress--${r}`, `${K}-progress--${f}`], style: i, "aria-valuemax": 100, "aria-valuemin": 0, "aria-valuenow": C, role: r === "circle" || r === "line" || r === "dashboard" ? "progressbar" : "none" }, r === "circle" || r === "dashboard" ? B(GT, { clsPrefix: K, status: f, showIndicator: d, indicatorTextColor: l, railColor: g, fillColor: s, railStyle: p, offsetDegree: this.offsetDegree, percentage: C, viewBoxWidth: P, strokeWidth: M, gapDegree: te === void 0 ? r === "dashboard" ? 75 : 0 : te, gapOffsetDegree: re, unit: L }, J) : r === "line" ? B(WT, { clsPrefix: K, status: f, showIndicator: d, indicatorTextColor: l, railColor: g, fillColor: s, railStyle: p, percentage: C, processing: Z, indicatorPlacement: D, unit: L, fillBorderRadius: z, railBorderRadius: $, height: F }, J) : r === "multiple-circle" ? B(ZT, { clsPrefix: K, strokeWidth: M, railColor: g, fillColor: s, railStyle: p, viewBoxWidth: P, percentage: C, showIndicator: d, circleGap: q }, J) : null);
} }), KT = Ze([Ze("@keyframes spin-rotate", `
 from {
 transform: rotate(0);
 }
 to {
 transform: rotate(360deg);
 }
 `), ue("spin-container", `
 position: relative;
 `, [ue("spin-body", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [dp()])]), ue("spin-body", `
 display: inline-flex;
 align-items: center;
 justify-content: center;
 flex-direction: column;
 `), ue("spin", `
 display: inline-flex;
 height: var(--n-size);
 width: var(--n-size);
 font-size: var(--n-size);
 color: var(--n-color);
 `, [Ge("rotate", `
 animation: spin-rotate 2s linear infinite;
 `)]), ue("spin-description", `
 display: inline-block;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 margin-top: 8px;
 `), ue("spin-content", `
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 pointer-events: all;
 `, [Ge("spinning", `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: none;
 opacity: var(--n-opacity-spinning);
 `)])]), JT = { small: 20, medium: 18, large: 16 }, QT = Object.assign(Object.assign({}, Jt.props), { contentClass: String, contentStyle: [Object, String], description: String, stroke: String, size: { type: [String, Number], default: "medium" }, show: { type: Boolean, default: true }, strokeWidth: Number, rotate: { type: Boolean, default: true }, spinning: { type: Boolean, validator: () => true, default: void 0 }, delay: Number }), e6 = ot({ name: "Spin", props: QT, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Sr(r), d = Jt("Spin", "-spin", KT, x3, r, i), f = Ee(() => {
    const { size: C } = r, { common: { cubicBezierEaseInOut: P }, self: M } = d.value, { opacitySpinning: D, color: L, textColor: $ } = M, z = typeof C == "number" ? qn(C) : M[Vt("size", C)];
    return { "--n-bezier": P, "--n-opacity-spinning": D, "--n-size": z, "--n-color": L, "--n-text-color": $ };
  }), g = l ? ai("spin", Ee(() => {
    const { size: C } = r;
    return typeof C == "number" ? String(C) : C[0];
  }), f, r) : void 0, p = cp(r, ["spinning", "show"]), s = Ie(false);
  return bo((C) => {
    let P;
    if (p.value) {
      const { delay: M } = r;
      if (M) {
        P = window.setTimeout(() => {
          s.value = true;
        }, M), C(() => {
          clearTimeout(P);
        });
        return;
      }
    }
    s.value = p.value;
  }), { mergedClsPrefix: i, active: s, mergedStrokeWidth: Ee(() => {
    const { strokeWidth: C } = r;
    if (C !== void 0) return C;
    const { size: P } = r;
    return JT[typeof P == "number" ? "medium" : P];
  }), cssVars: l ? void 0 : f, themeClass: g == null ? void 0 : g.themeClass, onRender: g == null ? void 0 : g.onRender };
}, render() {
  var r, i;
  const { $slots: l, mergedClsPrefix: d, description: f } = this, g = l.icon && this.rotate, p = (f || l.description) && B("div", { class: `${d}-spin-description` }, f || ((r = l.description) === null || r === void 0 ? void 0 : r.call(l))), s = l.icon ? B("div", { class: [`${d}-spin-body`, this.themeClass] }, B("div", { class: [`${d}-spin`, g && `${d}-spin--rotate`], style: l.default ? "" : this.cssVars }, l.icon()), p) : B("div", { class: [`${d}-spin-body`, this.themeClass] }, B(Cp, { clsPrefix: d, style: l.default ? "" : this.cssVars, stroke: this.stroke, "stroke-width": this.mergedStrokeWidth, class: `${d}-spin` }), p);
  return (i = this.onRender) === null || i === void 0 || i.call(this), l.default ? B("div", { class: [`${d}-spin-container`, this.themeClass], style: this.cssVars }, B("div", { class: [`${d}-spin-content`, this.active && `${d}-spin-content--spinning`, this.contentClass], style: this.contentStyle }, l), B(Eo, { name: "fade-in-transition" }, { default: () => this.active ? s : null })) : s;
} }), t6 = ue("split", `
 display: flex;
 width: 100%;
 height: 100%;
`, [Ge("horizontal", `
 flex-direction: row;
 `), Ge("vertical", `
 flex-direction: column;
 `), ue("split-pane-1", `
 overflow: hidden;
 `), ue("split-pane-2", `
 overflow: hidden;
 flex: 1;
 `), Ae("resize-trigger", `
 background-color: var(--n-resize-trigger-color);
 transition: background-color .3s var(--n-bezier);
 `, [Ge("hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `), Ze("&:hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `)])]), r6 = Object.assign(Object.assign({}, Jt.props), { direction: { type: String, default: "horizontal" }, resizeTriggerSize: { type: Number, default: 3 }, disabled: Boolean, defaultSize: { type: [String, Number], default: 0.5 }, "onUpdate:size": [Function, Array], onUpdateSize: [Function, Array], size: [String, Number], min: { type: [String, Number], default: 0 }, max: { type: [String, Number], default: 1 }, pane1Class: String, pane1Style: [Object, String], pane2Class: String, pane2Style: [Object, String], onDragStart: Function, onDragMove: Function, onDragEnd: Function, watchProps: Array }), q_ = ot({ name: "Split", props: r6, slots: Object, setup(r) {
  var i;
  const { mergedClsPrefixRef: l, inlineThemeDisabled: d } = Sr(r), f = Jt("Split", "-split", t6, w3, r, l), g = Ee(() => {
    const { common: { cubicBezierEaseInOut: te }, self: { resizableTriggerColor: re, resizableTriggerColorHover: ie } } = f.value;
    return { "--n-bezier": te, "--n-resize-trigger-color": re, "--n-resize-trigger-color-hover": ie };
  }), p = Ie(null), s = Ie(false), C = zt(r, "size"), P = Ie(r.defaultSize);
  !((i = r.watchProps) === null || i === void 0) && i.includes("defaultSize") && bo(() => P.value = r.defaultSize);
  const M = (te) => {
    const re = r["onUpdate:size"];
    r.onUpdateSize && Ot(r.onUpdateSize, te), re && Ot(re, te), P.value = te;
  }, D = Ji(C, P), L = Ee(() => {
    const te = D.value;
    if (typeof te == "string") return { flex: `0 0 ${te}` };
    if (typeof te == "number") {
      const re = te * 100;
      return { flex: `0 0 calc(${re}% - ${r.resizeTriggerSize * re / 100}px)` };
    }
  }), $ = Ee(() => r.direction === "horizontal" ? { width: `${r.resizeTriggerSize}px`, height: "100%" } : { width: "100%", height: `${r.resizeTriggerSize}px` }), z = Ee(() => {
    const te = r.direction === "horizontal";
    return { width: te ? `${r.resizeTriggerSize}px` : "", height: te ? "" : `${r.resizeTriggerSize}px`, cursor: r.direction === "horizontal" ? "col-resize" : "row-resize" };
  });
  let F = 0;
  const Z = (te) => {
    te.preventDefault(), s.value = true, r.onDragStart && r.onDragStart(te);
    const re = "mousemove", ie = "mouseup", J = (oe) => {
      q(oe), r.onDragMove && r.onDragMove(oe);
    }, we = () => {
      eo(re, document, J), eo(ie, document, we), s.value = false, r.onDragEnd && r.onDragEnd(te), document.body.style.cursor = "";
    };
    document.body.style.cursor = z.value.cursor, Bn(re, document, J), Bn(ie, document, we);
    const fe = p.value;
    if (fe) {
      const oe = fe.getBoundingClientRect();
      r.direction === "horizontal" ? F = te.clientX - oe.left : F = oe.top - te.clientY;
    }
    q(te);
  };
  function q(te) {
    var re, ie;
    const J = (ie = (re = p.value) === null || re === void 0 ? void 0 : re.parentElement) === null || ie === void 0 ? void 0 : ie.getBoundingClientRect();
    if (!J) return;
    const { direction: we } = r, fe = J.width - r.resizeTriggerSize, oe = J.height - r.resizeTriggerSize, he = we === "horizontal" ? fe : oe, _e = we === "horizontal" ? te.clientX - J.left - F : te.clientY - J.top + F, { min: Ue, max: qe } = r, tt = typeof Ue == "string" ? nn(Ue) : Ue * he, ut = typeof qe == "string" ? nn(qe) : qe * he;
    let mt = _e;
    mt = Math.max(mt, tt), mt = Math.min(mt, ut, he), typeof D.value == "string" ? M(`${mt}px`) : M(mt / he);
  }
  const K = d ? ai("split", void 0, g, r) : void 0;
  return { themeClass: K == null ? void 0 : K.themeClass, onRender: K == null ? void 0 : K.onRender, cssVars: d ? void 0 : g, resizeTriggerElRef: p, isDragging: s, mergedClsPrefix: l, resizeTriggerWrapperStyle: z, resizeTriggerStyle: $, handleMouseDown: Z, firstPaneStyle: L };
}, render() {
  var r, i, l, d, f;
  return (r = this.onRender) === null || r === void 0 || r.call(this), B("div", { class: [`${this.mergedClsPrefix}-split`, `${this.mergedClsPrefix}-split--${this.direction}`, this.themeClass], style: this.cssVars }, B("div", { class: [`${this.mergedClsPrefix}-split-pane-1`, this.pane1Class], style: [this.firstPaneStyle, this.pane1Style] }, (l = (i = this.$slots)[1]) === null || l === void 0 ? void 0 : l.call(i)), !this.disabled && B("div", { ref: "resizeTriggerElRef", class: `${this.mergedClsPrefix}-split__resize-trigger-wrapper`, style: this.resizeTriggerWrapperStyle, onMousedown: this.handleMouseDown }, Zn(this.$slots["resize-trigger"], () => [B("div", { style: this.resizeTriggerStyle, class: [`${this.mergedClsPrefix}-split__resize-trigger`, this.isDragging && `${this.mergedClsPrefix}-split__resize-trigger--hover`] })])), B("div", { class: [`${this.mergedClsPrefix}-split-pane-2`, this.pane2Class], style: this.pane2Style }, (f = (d = this.$slots)[2]) === null || f === void 0 ? void 0 : f.call(d)));
} }), i6 = ue("statistic", [Ae("label", `
 font-weight: var(--n-label-font-weight);
 transition: .3s color var(--n-bezier);
 font-size: var(--n-label-font-size);
 color: var(--n-label-text-color);
 `), ue("statistic-value", `
 margin-top: 4px;
 font-weight: var(--n-value-font-weight);
 `, [Ae("prefix", `
 margin: 0 4px 0 0;
 font-size: var(--n-value-font-size);
 transition: .3s color var(--n-bezier);
 color: var(--n-value-prefix-text-color);
 `, [ue("icon", { verticalAlign: "-0.125em" })]), Ae("content", `
 font-size: var(--n-value-font-size);
 transition: .3s color var(--n-bezier);
 color: var(--n-value-text-color);
 `), Ae("suffix", `
 margin: 0 0 0 4px;
 font-size: var(--n-value-font-size);
 transition: .3s color var(--n-bezier);
 color: var(--n-value-suffix-text-color);
 `, [ue("icon", { verticalAlign: "-0.125em" })])])]), n6 = Object.assign(Object.assign({}, Jt.props), { tabularNums: Boolean, label: String, value: [String, Number] }), Qn = ot({ name: "Statistic", props: n6, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l, mergedRtlRef: d } = Sr(r), f = Jt("Statistic", "-statistic", i6, C3, r, i), g = Tn("Statistic", d, i), p = Ee(() => {
    const { self: { labelFontWeight: C, valueFontSize: P, valueFontWeight: M, valuePrefixTextColor: D, labelTextColor: L, valueSuffixTextColor: $, valueTextColor: z, labelFontSize: F }, common: { cubicBezierEaseInOut: Z } } = f.value;
    return { "--n-bezier": Z, "--n-label-font-size": F, "--n-label-font-weight": C, "--n-label-text-color": L, "--n-value-font-weight": M, "--n-value-font-size": P, "--n-value-prefix-text-color": D, "--n-value-suffix-text-color": $, "--n-value-text-color": z };
  }), s = l ? ai("statistic", void 0, p, r) : void 0;
  return { rtlEnabled: g, mergedClsPrefix: i, cssVars: l ? void 0 : p, themeClass: s == null ? void 0 : s.themeClass, onRender: s == null ? void 0 : s.onRender };
}, render() {
  var r;
  const { mergedClsPrefix: i, $slots: { default: l, label: d, prefix: f, suffix: g } } = this;
  return (r = this.onRender) === null || r === void 0 || r.call(this), B("div", { class: [`${i}-statistic`, this.themeClass, this.rtlEnabled && `${i}-statistic--rtl`], style: this.cssVars }, oi(d, (p) => B("div", { class: `${i}-statistic__label` }, this.label || p)), B("div", { class: `${i}-statistic-value`, style: { fontVariantNumeric: this.tabularNums ? "tabular-nums" : "" } }, oi(f, (p) => p && B("span", { class: `${i}-statistic-value__prefix` }, p)), this.value !== void 0 ? B("span", { class: `${i}-statistic-value__content` }, this.value) : oi(l, (p) => p && B("span", { class: `${i}-statistic-value__content` }, p)), oi(g, (p) => p && B("span", { class: `${i}-statistic-value__suffix` }, p))));
} }), o6 = ue("switch", `
 height: var(--n-height);
 min-width: var(--n-width);
 vertical-align: middle;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 outline: none;
 justify-content: center;
 align-items: center;
`, [Ae("children-placeholder", `
 height: var(--n-rail-height);
 display: flex;
 flex-direction: column;
 overflow: hidden;
 pointer-events: none;
 visibility: hidden;
 `), Ae("rail-placeholder", `
 display: flex;
 flex-wrap: none;
 `), Ae("button-placeholder", `
 width: calc(1.75 * var(--n-rail-height));
 height: var(--n-rail-height);
 `), ue("base-loading", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 font-size: calc(var(--n-button-width) - 4px);
 color: var(--n-loading-color);
 transition: color .3s var(--n-bezier);
 `, [Yd({ left: "50%", top: "50%", originalTransform: "translateX(-50%) translateY(-50%)" })]), Ae("checked, unchecked", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 box-sizing: border-box;
 position: absolute;
 white-space: nowrap;
 top: 0;
 bottom: 0;
 display: flex;
 align-items: center;
 line-height: 1;
 `), Ae("checked", `
 right: 0;
 padding-right: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), Ae("unchecked", `
 left: 0;
 justify-content: flex-end;
 padding-left: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), Ze("&:focus", [Ae("rail", `
 box-shadow: var(--n-box-shadow-focus);
 `)]), Ge("round", [Ae("rail", "border-radius: calc(var(--n-rail-height) / 2);", [Ae("button", "border-radius: calc(var(--n-button-height) / 2);")])]), ui("disabled", [ui("icon", [Ge("rubber-band", [Ge("pressed", [Ae("rail", [Ae("button", "max-width: var(--n-button-width-pressed);")])]), Ae("rail", [Ze("&:active", [Ae("button", "max-width: var(--n-button-width-pressed);")])]), Ge("active", [Ge("pressed", [Ae("rail", [Ae("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])]), Ae("rail", [Ze("&:active", [Ae("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])])])])])]), Ge("active", [Ae("rail", [Ae("button", "left: calc(100% - var(--n-button-width) - var(--n-offset))")])]), Ae("rail", `
 overflow: hidden;
 height: var(--n-rail-height);
 min-width: var(--n-rail-width);
 border-radius: var(--n-rail-border-radius);
 cursor: pointer;
 position: relative;
 transition:
 opacity .3s var(--n-bezier),
 background .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [Ae("button-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 font-size: calc(var(--n-button-height) - 4px);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 line-height: 1;
 `, [Yd()]), Ae("button", `
 align-items: center; 
 top: var(--n-offset);
 left: var(--n-offset);
 height: var(--n-button-height);
 width: var(--n-button-width-pressed);
 max-width: var(--n-button-width);
 border-radius: var(--n-button-border-radius);
 background-color: var(--n-button-color);
 box-shadow: var(--n-button-box-shadow);
 box-sizing: border-box;
 cursor: inherit;
 content: "";
 position: absolute;
 transition:
 background-color .3s var(--n-bezier),
 left .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 max-width .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `)]), Ge("active", [Ae("rail", "background-color: var(--n-rail-color-active);")]), Ge("loading", [Ae("rail", `
 cursor: wait;
 `)]), Ge("disabled", [Ae("rail", `
 cursor: not-allowed;
 opacity: .5;
 `)])]), a6 = Object.assign(Object.assign({}, Jt.props), { size: { type: String, default: "medium" }, value: { type: [String, Number, Boolean], default: void 0 }, loading: Boolean, defaultValue: { type: [String, Number, Boolean], default: false }, disabled: { type: Boolean, default: void 0 }, round: { type: Boolean, default: true }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], checkedValue: { type: [String, Number, Boolean], default: true }, uncheckedValue: { type: [String, Number, Boolean], default: false }, railStyle: Function, rubberBand: { type: Boolean, default: true }, onChange: [Function, Array] });
let Ld;
const c1 = ot({ name: "Switch", props: a6, slots: Object, setup(r) {
  Ld === void 0 && (typeof CSS < "u" ? typeof CSS.supports < "u" ? Ld = CSS.supports("width", "max(1px)") : Ld = false : Ld = true);
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Sr(r), d = Jt("Switch", "-switch", o6, S3, r, i), f = ka(r), { mergedSizeRef: g, mergedDisabledRef: p } = f, s = Ie(r.defaultValue), C = zt(r, "value"), P = Ji(C, s), M = Ee(() => P.value === r.checkedValue), D = Ie(false), L = Ie(false), $ = Ee(() => {
    const { railStyle: fe } = r;
    if (fe) return fe({ focused: L.value, checked: M.value });
  });
  function z(fe) {
    const { "onUpdate:value": oe, onChange: he, onUpdateValue: _e } = r, { nTriggerFormInput: Ue, nTriggerFormChange: qe } = f;
    oe && Ot(oe, fe), _e && Ot(_e, fe), he && Ot(he, fe), s.value = fe, Ue(), qe();
  }
  function F() {
    const { nTriggerFormFocus: fe } = f;
    fe();
  }
  function Z() {
    const { nTriggerFormBlur: fe } = f;
    fe();
  }
  function q() {
    r.loading || p.value || (P.value !== r.checkedValue ? z(r.checkedValue) : z(r.uncheckedValue));
  }
  function K() {
    L.value = true, F();
  }
  function te() {
    L.value = false, Z(), D.value = false;
  }
  function re(fe) {
    r.loading || p.value || fe.key === " " && (P.value !== r.checkedValue ? z(r.checkedValue) : z(r.uncheckedValue), D.value = false);
  }
  function ie(fe) {
    r.loading || p.value || fe.key === " " && (fe.preventDefault(), D.value = true);
  }
  const J = Ee(() => {
    const { value: fe } = g, { self: { opacityDisabled: oe, railColor: he, railColorActive: _e, buttonBoxShadow: Ue, buttonColor: qe, boxShadowFocus: tt, loadingColor: ut, textColor: mt, iconColor: St, [Vt("buttonHeight", fe)]: st, [Vt("buttonWidth", fe)]: nt, [Vt("buttonWidthPressed", fe)]: ft, [Vt("railHeight", fe)]: Lt, [Vt("railWidth", fe)]: pt, [Vt("railBorderRadius", fe)]: wt, [Vt("buttonBorderRadius", fe)]: Ft }, common: { cubicBezierEaseInOut: tr } } = d.value;
    let gt, Bt, Zt;
    return Ld ? (gt = `calc((${Lt} - ${st}) / 2)`, Bt = `max(${Lt}, ${st})`, Zt = `max(${pt}, calc(${pt} + ${st} - ${Lt}))`) : (gt = qn((nn(Lt) - nn(st)) / 2), Bt = qn(Math.max(nn(Lt), nn(st))), Zt = nn(Lt) > nn(st) ? pt : qn(nn(pt) + nn(st) - nn(Lt))), { "--n-bezier": tr, "--n-button-border-radius": Ft, "--n-button-box-shadow": Ue, "--n-button-color": qe, "--n-button-width": nt, "--n-button-width-pressed": ft, "--n-button-height": st, "--n-height": Bt, "--n-offset": gt, "--n-opacity-disabled": oe, "--n-rail-border-radius": wt, "--n-rail-color": he, "--n-rail-color-active": _e, "--n-rail-height": Lt, "--n-rail-width": pt, "--n-width": Zt, "--n-box-shadow-focus": tt, "--n-loading-color": ut, "--n-text-color": mt, "--n-icon-color": St };
  }), we = l ? ai("switch", Ee(() => g.value[0]), J, r) : void 0;
  return { handleClick: q, handleBlur: te, handleFocus: K, handleKeyup: re, handleKeydown: ie, mergedRailStyle: $, pressed: D, mergedClsPrefix: i, mergedValue: P, checked: M, mergedDisabled: p, cssVars: l ? void 0 : J, themeClass: we == null ? void 0 : we.themeClass, onRender: we == null ? void 0 : we.onRender };
}, render() {
  const { mergedClsPrefix: r, mergedDisabled: i, checked: l, mergedRailStyle: d, onRender: f, $slots: g } = this;
  f == null ? void 0 : f();
  const { checked: p, unchecked: s, icon: C, "checked-icon": P, "unchecked-icon": M } = g, D = !(Hm(C) && Hm(P) && Hm(M));
  return B("div", { role: "switch", "aria-checked": l, class: [`${r}-switch`, this.themeClass, D && `${r}-switch--icon`, l && `${r}-switch--active`, i && `${r}-switch--disabled`, this.round && `${r}-switch--round`, this.loading && `${r}-switch--loading`, this.pressed && `${r}-switch--pressed`, this.rubberBand && `${r}-switch--rubber-band`], tabindex: this.mergedDisabled ? void 0 : 0, style: this.cssVars, onClick: this.handleClick, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyup: this.handleKeyup, onKeydown: this.handleKeydown }, B("div", { class: `${r}-switch__rail`, "aria-hidden": "true", style: d }, oi(p, (L) => oi(s, ($) => L || $ ? B("div", { "aria-hidden": true, class: `${r}-switch__children-placeholder` }, B("div", { class: `${r}-switch__rail-placeholder` }, B("div", { class: `${r}-switch__button-placeholder` }), L), B("div", { class: `${r}-switch__rail-placeholder` }, B("div", { class: `${r}-switch__button-placeholder` }), $)) : null)), B("div", { class: `${r}-switch__button` }, oi(C, (L) => oi(P, ($) => oi(M, (z) => B(xp, null, { default: () => this.loading ? B(Cp, { key: "loading", clsPrefix: r, strokeWidth: 20 }) : this.checked && ($ || L) ? B("div", { class: `${r}-switch__button-icon`, key: $ ? "checked-icon" : "icon" }, $ || L) : !this.checked && (z || L) ? B("div", { class: `${r}-switch__button-icon`, key: z ? "unchecked-icon" : "icon" }, z || L) : null })))), oi(p, (L) => L && B("div", { key: "checked", class: `${r}-switch__checked` }, L)), oi(s, (L) => L && B("div", { key: "unchecked", class: `${r}-switch__unchecked` }, L)))));
} }), m0 = $n("n-tabs"), d1 = { tab: [String, Number, Object, Function], name: { type: [String, Number], required: true }, disabled: Boolean, displayDirective: { type: String, default: "if" }, closable: { type: Boolean, default: void 0 }, tabProps: Object, label: [String, Number, Object, Function] }, W_ = ot({ __TAB_PANE__: true, name: "TabPane", alias: ["TabPanel"], props: d1, slots: Object, setup(r) {
  const i = ur(m0, null);
  return i || ea("tab-pane", "`n-tab-pane` must be placed inside `n-tabs`."), { style: i.paneStyleRef, class: i.paneClassRef, mergedClsPrefix: i.mergedClsPrefixRef };
}, render() {
  return B("div", { class: [`${this.mergedClsPrefix}-tab-pane`, this.class], style: this.style }, this.$slots);
} }), s6 = Object.assign({ internalLeftPadded: Boolean, internalAddable: Boolean, internalCreatedByPane: Boolean }, ob(d1, ["displayDirective"])), qg = ot({ __TAB__: true, inheritAttrs: false, name: "Tab", props: s6, setup(r) {
  const { mergedClsPrefixRef: i, valueRef: l, typeRef: d, closableRef: f, tabStyleRef: g, addTabStyleRef: p, tabClassRef: s, addTabClassRef: C, tabChangeIdRef: P, onBeforeLeaveRef: M, triggerRef: D, handleAdd: L, activateTab: $, handleClose: z } = ur(m0);
  return { trigger: D, mergedClosable: Ee(() => {
    if (r.internalAddable) return false;
    const { closable: F } = r;
    return F === void 0 ? f.value : F;
  }), style: g, addStyle: p, tabClass: s, addTabClass: C, clsPrefix: i, value: l, type: d, handleClose(F) {
    F.stopPropagation(), !r.disabled && z(r.name);
  }, activateTab() {
    if (r.disabled) return;
    if (r.internalAddable) {
      L();
      return;
    }
    const { name: F } = r, Z = ++P.id;
    if (F !== l.value) {
      const { value: q } = M;
      q ? Promise.resolve(q(r.name, l.value)).then((K) => {
        K && P.id === Z && $(F);
      }) : $(F);
    }
  } };
}, render() {
  const { internalAddable: r, clsPrefix: i, name: l, disabled: d, label: f, tab: g, value: p, mergedClosable: s, trigger: C, $slots: { default: P } } = this, M = f ?? g;
  return B("div", { class: `${i}-tabs-tab-wrapper` }, this.internalLeftPadded ? B("div", { class: `${i}-tabs-tab-pad` }) : null, B("div", Object.assign({ key: l, "data-name": l, "data-disabled": d ? true : void 0 }, is({ class: [`${i}-tabs-tab`, p === l && `${i}-tabs-tab--active`, d && `${i}-tabs-tab--disabled`, s && `${i}-tabs-tab--closable`, r && `${i}-tabs-tab--addable`, r ? this.addTabClass : this.tabClass], onClick: C === "click" ? this.activateTab : void 0, onMouseenter: C === "hover" ? this.activateTab : void 0, style: r ? this.addStyle : this.style }, this.internalCreatedByPane ? this.tabProps || {} : this.$attrs)), B("span", { class: `${i}-tabs-tab__label` }, r ? B(Wr, null, B("div", { class: `${i}-tabs-tab__height-placeholder` }, "\xA0"), B(qr, { clsPrefix: i }, { default: () => B(Rp, null) })) : P ? P() : typeof M == "object" ? M : Rl(M ?? l)), s && this.type === "card" ? B(Sp, { clsPrefix: i, class: `${i}-tabs-tab__close`, onClick: this.handleClose, disabled: d }) : null));
} }), l6 = ue("tabs", `
 box-sizing: border-box;
 width: 100%;
 display: flex;
 flex-direction: column;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
`, [Ge("segment-type", [ue("tabs-rail", [Ze("&.transition-disabled", [ue("tabs-capsule", `
 transition: none;
 `)])])]), Ge("top", [ue("tab-pane", `
 padding: var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left);
 `)]), Ge("left", [ue("tab-pane", `
 padding: var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left) var(--n-pane-padding-top);
 `)]), Ge("left, right", `
 flex-direction: row;
 `, [ue("tabs-bar", `
 width: 2px;
 right: 0;
 transition:
 top .2s var(--n-bezier),
 max-height .2s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), ue("tabs-tab", `
 padding: var(--n-tab-padding-vertical); 
 `)]), Ge("right", `
 flex-direction: row-reverse;
 `, [ue("tab-pane", `
 padding: var(--n-pane-padding-left) var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom);
 `), ue("tabs-bar", `
 left: 0;
 `)]), Ge("bottom", `
 flex-direction: column-reverse;
 justify-content: flex-end;
 `, [ue("tab-pane", `
 padding: var(--n-pane-padding-bottom) var(--n-pane-padding-right) var(--n-pane-padding-top) var(--n-pane-padding-left);
 `), ue("tabs-bar", `
 top: 0;
 `)]), ue("tabs-rail", `
 position: relative;
 padding: 3px;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 background-color: var(--n-color-segment);
 transition: background-color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [ue("tabs-capsule", `
 border-radius: var(--n-tab-border-radius);
 position: absolute;
 pointer-events: none;
 background-color: var(--n-tab-color-segment);
 box-shadow: 0 1px 3px 0 rgba(0, 0, 0, .08);
 transition: transform 0.3s var(--n-bezier);
 `), ue("tabs-tab-wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [ue("tabs-tab", `
 overflow: hidden;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [Ge("active", `
 font-weight: var(--n-font-weight-strong);
 color: var(--n-tab-text-color-active);
 `), Ze("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])])]), Ge("flex", [ue("tabs-nav", `
 width: 100%;
 position: relative;
 `, [ue("tabs-wrapper", `
 width: 100%;
 `, [ue("tabs-tab", `
 margin-right: 0;
 `)])])]), ue("tabs-nav", `
 box-sizing: border-box;
 line-height: 1.5;
 display: flex;
 transition: border-color .3s var(--n-bezier);
 `, [Ae("prefix, suffix", `
 display: flex;
 align-items: center;
 `), Ae("prefix", "padding-right: 16px;"), Ae("suffix", "padding-left: 16px;")]), Ge("top, bottom", [Ze(">", [ue("tabs-nav", [ue("tabs-nav-scroll-wrapper", [Ze("&::before", `
 top: 0;
 bottom: 0;
 left: 0;
 width: 20px;
 `), Ze("&::after", `
 top: 0;
 bottom: 0;
 right: 0;
 width: 20px;
 `), Ge("shadow-start", [Ze("&::before", `
 box-shadow: inset 10px 0 8px -8px rgba(0, 0, 0, .12);
 `)]), Ge("shadow-end", [Ze("&::after", `
 box-shadow: inset -10px 0 8px -8px rgba(0, 0, 0, .12);
 `)])])])])]), Ge("left, right", [ue("tabs-nav-scroll-content", `
 flex-direction: column;
 `), Ze(">", [ue("tabs-nav", [ue("tabs-nav-scroll-wrapper", [Ze("&::before", `
 top: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), Ze("&::after", `
 bottom: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), Ge("shadow-start", [Ze("&::before", `
 box-shadow: inset 0 10px 8px -8px rgba(0, 0, 0, .12);
 `)]), Ge("shadow-end", [Ze("&::after", `
 box-shadow: inset 0 -10px 8px -8px rgba(0, 0, 0, .12);
 `)])])])])]), ue("tabs-nav-scroll-wrapper", `
 flex: 1;
 position: relative;
 overflow: hidden;
 `, [ue("tabs-nav-y-scroll", `
 height: 100%;
 width: 100%;
 overflow-y: auto; 
 scrollbar-width: none;
 `, [Ze("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `)]), Ze("&::before, &::after", `
 transition: box-shadow .3s var(--n-bezier);
 pointer-events: none;
 content: "";
 position: absolute;
 z-index: 1;
 `)]), ue("tabs-nav-scroll-content", `
 display: flex;
 position: relative;
 min-width: 100%;
 min-height: 100%;
 width: fit-content;
 box-sizing: border-box;
 `), ue("tabs-wrapper", `
 display: inline-flex;
 flex-wrap: nowrap;
 position: relative;
 `), ue("tabs-tab-wrapper", `
 display: flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 flex-grow: 0;
 `), ue("tabs-tab", `
 cursor: pointer;
 white-space: nowrap;
 flex-wrap: nowrap;
 display: inline-flex;
 align-items: center;
 color: var(--n-tab-text-color);
 font-size: var(--n-tab-font-size);
 background-clip: padding-box;
 padding: var(--n-tab-padding);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [Ge("disabled", { cursor: "not-allowed" }), Ae("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), Ae("label", `
 display: flex;
 align-items: center;
 z-index: 1;
 `)]), ue("tabs-bar", `
 position: absolute;
 bottom: 0;
 height: 2px;
 border-radius: 1px;
 background-color: var(--n-bar-color);
 transition:
 left .2s var(--n-bezier),
 max-width .2s var(--n-bezier),
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [Ze("&.transition-disabled", `
 transition: none;
 `), Ge("disabled", `
 background-color: var(--n-tab-text-color-disabled)
 `)]), ue("tabs-pane-wrapper", `
 position: relative;
 overflow: hidden;
 transition: max-height .2s var(--n-bezier);
 `), ue("tab-pane", `
 color: var(--n-pane-text-color);
 width: 100%;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .2s var(--n-bezier);
 left: 0;
 right: 0;
 top: 0;
 `, [Ze("&.next-transition-leave-active, &.prev-transition-leave-active, &.next-transition-enter-active, &.prev-transition-enter-active", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .2s var(--n-bezier),
 opacity .2s var(--n-bezier);
 `), Ze("&.next-transition-leave-active, &.prev-transition-leave-active", `
 position: absolute;
 `), Ze("&.next-transition-enter-from, &.prev-transition-leave-to", `
 transform: translateX(32px);
 opacity: 0;
 `), Ze("&.next-transition-leave-to, &.prev-transition-enter-from", `
 transform: translateX(-32px);
 opacity: 0;
 `), Ze("&.next-transition-leave-from, &.next-transition-enter-to, &.prev-transition-leave-from, &.prev-transition-enter-to", `
 transform: translateX(0);
 opacity: 1;
 `)]), ue("tabs-tab-pad", `
 box-sizing: border-box;
 width: var(--n-tab-gap);
 flex-grow: 0;
 flex-shrink: 0;
 `), Ge("line-type, bar-type", [ue("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 box-sizing: border-box;
 vertical-align: bottom;
 `, [Ze("&:hover", { color: "var(--n-tab-text-color-hover)" }), Ge("active", `
 color: var(--n-tab-text-color-active);
 font-weight: var(--n-tab-font-weight-active);
 `), Ge("disabled", { color: "var(--n-tab-text-color-disabled)" })])]), ue("tabs-nav", [Ge("line-type", [Ge("top", [Ae("prefix, suffix", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), ue("tabs-nav-scroll-content", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), ue("tabs-bar", `
 bottom: -1px;
 `)]), Ge("left", [Ae("prefix, suffix", `
 border-right: 1px solid var(--n-tab-border-color);
 `), ue("tabs-nav-scroll-content", `
 border-right: 1px solid var(--n-tab-border-color);
 `), ue("tabs-bar", `
 right: -1px;
 `)]), Ge("right", [Ae("prefix, suffix", `
 border-left: 1px solid var(--n-tab-border-color);
 `), ue("tabs-nav-scroll-content", `
 border-left: 1px solid var(--n-tab-border-color);
 `), ue("tabs-bar", `
 left: -1px;
 `)]), Ge("bottom", [Ae("prefix, suffix", `
 border-top: 1px solid var(--n-tab-border-color);
 `), ue("tabs-nav-scroll-content", `
 border-top: 1px solid var(--n-tab-border-color);
 `), ue("tabs-bar", `
 top: -1px;
 `)]), Ae("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 `), ue("tabs-nav-scroll-content", `
 transition: border-color .3s var(--n-bezier);
 `), ue("tabs-bar", `
 border-radius: 0;
 `)]), Ge("card-type", [Ae("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 `), ue("tabs-pad", `
 flex-grow: 1;
 transition: border-color .3s var(--n-bezier);
 `), ue("tabs-tab-pad", `
 transition: border-color .3s var(--n-bezier);
 `), ue("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 border: 1px solid var(--n-tab-border-color);
 background-color: var(--n-tab-color);
 box-sizing: border-box;
 position: relative;
 vertical-align: bottom;
 display: flex;
 justify-content: space-between;
 font-size: var(--n-tab-font-size);
 color: var(--n-tab-text-color);
 `, [Ge("addable", `
 padding-left: 8px;
 padding-right: 8px;
 font-size: 16px;
 justify-content: center;
 `, [Ae("height-placeholder", `
 width: 0;
 font-size: var(--n-tab-font-size);
 `), ui("disabled", [Ze("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])]), Ge("closable", "padding-right: 8px;"), Ge("active", `
 background-color: #0000;
 font-weight: var(--n-tab-font-weight-active);
 color: var(--n-tab-text-color-active);
 `), Ge("disabled", "color: var(--n-tab-text-color-disabled);")])]), Ge("left, right", `
 flex-direction: column; 
 `, [Ae("prefix, suffix", `
 padding: var(--n-tab-padding-vertical);
 `), ue("tabs-wrapper", `
 flex-direction: column;
 `), ue("tabs-tab-wrapper", `
 flex-direction: column;
 `, [ue("tabs-tab-pad", `
 height: var(--n-tab-gap-vertical);
 width: 100%;
 `)])]), Ge("top", [Ge("card-type", [ue("tabs-scroll-padding", "border-bottom: 1px solid var(--n-tab-border-color);"), Ae("prefix, suffix", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), ue("tabs-tab", `
 border-top-left-radius: var(--n-tab-border-radius);
 border-top-right-radius: var(--n-tab-border-radius);
 `, [Ge("active", `
 border-bottom: 1px solid #0000;
 `)]), ue("tabs-tab-pad", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), ue("tabs-pad", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `)])]), Ge("left", [Ge("card-type", [ue("tabs-scroll-padding", "border-right: 1px solid var(--n-tab-border-color);"), Ae("prefix, suffix", `
 border-right: 1px solid var(--n-tab-border-color);
 `), ue("tabs-tab", `
 border-top-left-radius: var(--n-tab-border-radius);
 border-bottom-left-radius: var(--n-tab-border-radius);
 `, [Ge("active", `
 border-right: 1px solid #0000;
 `)]), ue("tabs-tab-pad", `
 border-right: 1px solid var(--n-tab-border-color);
 `), ue("tabs-pad", `
 border-right: 1px solid var(--n-tab-border-color);
 `)])]), Ge("right", [Ge("card-type", [ue("tabs-scroll-padding", "border-left: 1px solid var(--n-tab-border-color);"), Ae("prefix, suffix", `
 border-left: 1px solid var(--n-tab-border-color);
 `), ue("tabs-tab", `
 border-top-right-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [Ge("active", `
 border-left: 1px solid #0000;
 `)]), ue("tabs-tab-pad", `
 border-left: 1px solid var(--n-tab-border-color);
 `), ue("tabs-pad", `
 border-left: 1px solid var(--n-tab-border-color);
 `)])]), Ge("bottom", [Ge("card-type", [ue("tabs-scroll-padding", "border-top: 1px solid var(--n-tab-border-color);"), Ae("prefix, suffix", `
 border-top: 1px solid var(--n-tab-border-color);
 `), ue("tabs-tab", `
 border-bottom-left-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [Ge("active", `
 border-top: 1px solid #0000;
 `)]), ue("tabs-tab-pad", `
 border-top: 1px solid var(--n-tab-border-color);
 `), ue("tabs-pad", `
 border-top: 1px solid var(--n-tab-border-color);
 `)])])])]), ug = $C, u6 = Object.assign(Object.assign({}, Jt.props), { value: [String, Number], defaultValue: [String, Number], trigger: { type: String, default: "click" }, type: { type: String, default: "bar" }, closable: Boolean, justifyContent: String, size: { type: String, default: "medium" }, placement: { type: String, default: "top" }, tabStyle: [String, Object], tabClass: String, addTabStyle: [String, Object], addTabClass: String, barWidth: Number, paneClass: String, paneStyle: [String, Object], paneWrapperClass: String, paneWrapperStyle: [String, Object], addable: [Boolean, Object], tabsPadding: { type: Number, default: 0 }, animated: Boolean, onBeforeLeave: Function, onAdd: Function, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onClose: [Function, Array], labelSize: String, activeName: [String, Number], onActiveNameChange: [Function, Array] }), c6 = ot({ name: "Tabs", props: u6, slots: Object, setup(r, { slots: i }) {
  var l, d, f, g;
  const { mergedClsPrefixRef: p, inlineThemeDisabled: s } = Sr(r), C = Jt("Tabs", "-tabs", l6, k3, r, p), P = Ie(null), M = Ie(null), D = Ie(null), L = Ie(null), $ = Ie(null), z = Ie(null), F = Ie(true), Z = Ie(true), q = cp(r, ["labelSize", "size"]), K = cp(r, ["activeName", "value"]), te = Ie((d = (l = K.value) !== null && l !== void 0 ? l : r.defaultValue) !== null && d !== void 0 ? d : i.default ? (g = (f = Bl(i.default())[0]) === null || f === void 0 ? void 0 : f.props) === null || g === void 0 ? void 0 : g.name : null), re = Ji(K, te), ie = { id: 0 }, J = Ee(() => {
    if (!(!r.justifyContent || r.type === "card")) return { display: "flex", justifyContent: r.justifyContent };
  });
  Ht(re, () => {
    ie.id = 0, _e(), Ue();
  });
  function we() {
    var Oe;
    const { value: Je } = re;
    return Je === null ? null : (Oe = P.value) === null || Oe === void 0 ? void 0 : Oe.querySelector(`[data-name="${Je}"]`);
  }
  function fe(Oe) {
    if (r.type === "card") return;
    const { value: Je } = M;
    if (!Je) return;
    const ht = Je.style.opacity === "0";
    if (Oe) {
      const bt = `${p.value}-tabs-bar--disabled`, { barWidth: rt, placement: vt } = r;
      if (Oe.dataset.disabled === "true" ? Je.classList.add(bt) : Je.classList.remove(bt), ["top", "bottom"].includes(vt)) {
        if (he(["top", "maxHeight", "height"]), typeof rt == "number" && Oe.offsetWidth >= rt) {
          const Wt = Math.floor((Oe.offsetWidth - rt) / 2) + Oe.offsetLeft;
          Je.style.left = `${Wt}px`, Je.style.maxWidth = `${rt}px`;
        } else Je.style.left = `${Oe.offsetLeft}px`, Je.style.maxWidth = `${Oe.offsetWidth}px`;
        Je.style.width = "8192px", ht && (Je.style.transition = "none"), Je.offsetWidth, ht && (Je.style.transition = "", Je.style.opacity = "1");
      } else {
        if (he(["left", "maxWidth", "width"]), typeof rt == "number" && Oe.offsetHeight >= rt) {
          const Wt = Math.floor((Oe.offsetHeight - rt) / 2) + Oe.offsetTop;
          Je.style.top = `${Wt}px`, Je.style.maxHeight = `${rt}px`;
        } else Je.style.top = `${Oe.offsetTop}px`, Je.style.maxHeight = `${Oe.offsetHeight}px`;
        Je.style.height = "8192px", ht && (Je.style.transition = "none"), Je.offsetHeight, ht && (Je.style.transition = "", Je.style.opacity = "1");
      }
    }
  }
  function oe() {
    if (r.type === "card") return;
    const { value: Oe } = M;
    Oe && (Oe.style.opacity = "0");
  }
  function he(Oe) {
    const { value: Je } = M;
    if (Je) for (const ht of Oe) Je.style[ht] = "";
  }
  function _e() {
    if (r.type === "card") return;
    const Oe = we();
    Oe ? fe(Oe) : oe();
  }
  function Ue() {
    var Oe;
    const Je = (Oe = $.value) === null || Oe === void 0 ? void 0 : Oe.$el;
    if (!Je) return;
    const ht = we();
    if (!ht) return;
    const { scrollLeft: bt, offsetWidth: rt } = Je, { offsetLeft: vt, offsetWidth: Wt } = ht;
    bt > vt ? Je.scrollTo({ top: 0, left: vt, behavior: "smooth" }) : vt + Wt > bt + rt && Je.scrollTo({ top: 0, left: vt + Wt - rt, behavior: "smooth" });
  }
  const qe = Ie(null);
  let tt = 0, ut = null;
  function mt(Oe) {
    const Je = qe.value;
    if (Je) {
      tt = Oe.getBoundingClientRect().height;
      const ht = `${tt}px`, bt = () => {
        Je.style.height = ht, Je.style.maxHeight = ht;
      };
      ut ? (bt(), ut(), ut = null) : ut = bt;
    }
  }
  function St(Oe) {
    const Je = qe.value;
    if (Je) {
      const ht = Oe.getBoundingClientRect().height, bt = () => {
        document.body.offsetHeight, Je.style.maxHeight = `${ht}px`, Je.style.height = `${Math.max(tt, ht)}px`;
      };
      ut ? (ut(), ut = null, bt()) : ut = bt;
    }
  }
  function st() {
    const Oe = qe.value;
    if (Oe) {
      Oe.style.maxHeight = "", Oe.style.height = "";
      const { paneWrapperStyle: Je } = r;
      if (typeof Je == "string") Oe.style.cssText = Je;
      else if (Je) {
        const { maxHeight: ht, height: bt } = Je;
        ht !== void 0 && (Oe.style.maxHeight = ht), bt !== void 0 && (Oe.style.height = bt);
      }
    }
  }
  const nt = { value: [] }, ft = Ie("next");
  function Lt(Oe) {
    const Je = re.value;
    let ht = "next";
    for (const bt of nt.value) {
      if (bt === Je) break;
      if (bt === Oe) {
        ht = "prev";
        break;
      }
    }
    ft.value = ht, pt(Oe);
  }
  function pt(Oe) {
    const { onActiveNameChange: Je, onUpdateValue: ht, "onUpdate:value": bt } = r;
    Je && Ot(Je, Oe), ht && Ot(ht, Oe), bt && Ot(bt, Oe), te.value = Oe;
  }
  function wt(Oe) {
    const { onClose: Je } = r;
    Je && Ot(Je, Oe);
  }
  function Ft() {
    const { value: Oe } = M;
    if (!Oe) return;
    const Je = "transition-disabled";
    Oe.classList.add(Je), _e(), Oe.classList.remove(Je);
  }
  const tr = Ie(null);
  function gt({ transitionDisabled: Oe }) {
    const Je = P.value;
    if (!Je) return;
    Oe && Je.classList.add("transition-disabled");
    const ht = we();
    ht && tr.value && (tr.value.style.width = `${ht.offsetWidth}px`, tr.value.style.height = `${ht.offsetHeight}px`, tr.value.style.transform = `translateX(${ht.offsetLeft - nn(getComputedStyle(Je).paddingLeft)}px)`, Oe && tr.value.offsetWidth), Oe && Je.classList.remove("transition-disabled");
  }
  Ht([re], () => {
    r.type === "segment" && Wn(() => {
      gt({ transitionDisabled: false });
    });
  }), Ri(() => {
    r.type === "segment" && gt({ transitionDisabled: true });
  });
  let Bt = 0;
  function Zt(Oe) {
    var Je;
    if (Oe.contentRect.width === 0 && Oe.contentRect.height === 0 || Bt === Oe.contentRect.width) return;
    Bt = Oe.contentRect.width;
    const { type: ht } = r;
    if ((ht === "line" || ht === "bar") && Ft(), ht !== "segment") {
      const { placement: bt } = r;
      Xt((bt === "top" || bt === "bottom" ? (Je = $.value) === null || Je === void 0 ? void 0 : Je.$el : z.value) || null);
    }
  }
  const ir = ug(Zt, 64);
  Ht([() => r.justifyContent, () => r.size], () => {
    Wn(() => {
      const { type: Oe } = r;
      (Oe === "line" || Oe === "bar") && Ft();
    });
  });
  const Cr = Ie(false);
  function Ar(Oe) {
    var Je;
    const { target: ht, contentRect: { width: bt, height: rt } } = Oe, vt = ht.parentElement.parentElement.offsetWidth, Wt = ht.parentElement.parentElement.offsetHeight, { placement: ci } = r;
    if (!Cr.value) ci === "top" || ci === "bottom" ? vt < bt && (Cr.value = true) : Wt < rt && (Cr.value = true);
    else {
      const { value: Ai } = L;
      if (!Ai) return;
      ci === "top" || ci === "bottom" ? vt - bt > Ai.$el.offsetWidth && (Cr.value = false) : Wt - rt > Ai.$el.offsetHeight && (Cr.value = false);
    }
    Xt(((Je = $.value) === null || Je === void 0 ? void 0 : Je.$el) || null);
  }
  const or = ug(Ar, 64);
  function Tr() {
    const { onAdd: Oe } = r;
    Oe && Oe(), Wn(() => {
      const Je = we(), { value: ht } = $;
      !Je || !ht || ht.scrollTo({ left: Je.offsetLeft, top: 0, behavior: "smooth" });
    });
  }
  function Xt(Oe) {
    if (!Oe) return;
    const { placement: Je } = r;
    if (Je === "top" || Je === "bottom") {
      const { scrollLeft: ht, scrollWidth: bt, offsetWidth: rt } = Oe;
      F.value = ht <= 0, Z.value = ht + rt >= bt;
    } else {
      const { scrollTop: ht, scrollHeight: bt, offsetHeight: rt } = Oe;
      F.value = ht <= 0, Z.value = ht + rt >= bt;
    }
  }
  const Dr = ug((Oe) => {
    Xt(Oe.target);
  }, 64);
  Xr(m0, { triggerRef: zt(r, "trigger"), tabStyleRef: zt(r, "tabStyle"), tabClassRef: zt(r, "tabClass"), addTabStyleRef: zt(r, "addTabStyle"), addTabClassRef: zt(r, "addTabClass"), paneClassRef: zt(r, "paneClass"), paneStyleRef: zt(r, "paneStyle"), mergedClsPrefixRef: p, typeRef: zt(r, "type"), closableRef: zt(r, "closable"), valueRef: re, tabChangeIdRef: ie, onBeforeLeaveRef: zt(r, "onBeforeLeave"), activateTab: Lt, handleClose: wt, handleAdd: Tr }), Gy(() => {
    _e(), Ue();
  }), bo(() => {
    const { value: Oe } = D;
    if (!Oe) return;
    const { value: Je } = p, ht = `${Je}-tabs-nav-scroll-wrapper--shadow-start`, bt = `${Je}-tabs-nav-scroll-wrapper--shadow-end`;
    F.value ? Oe.classList.remove(ht) : Oe.classList.add(ht), Z.value ? Oe.classList.remove(bt) : Oe.classList.add(bt);
  });
  const nr = { syncBarPosition: () => {
    _e();
  } }, kt = () => {
    gt({ transitionDisabled: true });
  }, ze = Ee(() => {
    const { value: Oe } = q, { type: Je } = r, ht = { card: "Card", bar: "Bar", line: "Line", segment: "Segment" }[Je], bt = `${Oe}${ht}`, { self: { barColor: rt, closeIconColor: vt, closeIconColorHover: Wt, closeIconColorPressed: ci, tabColor: Ai, tabBorderColor: sn, paneTextColor: Fe, tabFontWeight: X, tabBorderRadius: Y, tabFontWeightActive: ne, colorSegment: ve, fontWeightStrong: Ce, tabColorSegment: ae, closeSize: Pe, closeIconSize: xe, closeColorHover: Ve, closeColorPressed: et, closeBorderRadius: We, [Vt("panePadding", Oe)]: xt, [Vt("tabPadding", bt)]: Le, [Vt("tabPaddingVertical", bt)]: rr, [Vt("tabGap", bt)]: Zr, [Vt("tabGap", `${bt}Vertical`)]: Ut, [Vt("tabTextColor", Je)]: dr, [Vt("tabTextColorActive", Je)]: Er, [Vt("tabTextColorHover", Je)]: jr, [Vt("tabTextColorDisabled", Je)]: di, [Vt("tabFontSize", Oe)]: Hr }, common: { cubicBezierEaseInOut: Jr } } = C.value;
    return { "--n-bezier": Jr, "--n-color-segment": ve, "--n-bar-color": rt, "--n-tab-font-size": Hr, "--n-tab-text-color": dr, "--n-tab-text-color-active": Er, "--n-tab-text-color-disabled": di, "--n-tab-text-color-hover": jr, "--n-pane-text-color": Fe, "--n-tab-border-color": sn, "--n-tab-border-radius": Y, "--n-close-size": Pe, "--n-close-icon-size": xe, "--n-close-color-hover": Ve, "--n-close-color-pressed": et, "--n-close-border-radius": We, "--n-close-icon-color": vt, "--n-close-icon-color-hover": Wt, "--n-close-icon-color-pressed": ci, "--n-tab-color": Ai, "--n-tab-font-weight": X, "--n-tab-font-weight-active": ne, "--n-tab-padding": Le, "--n-tab-padding-vertical": rr, "--n-tab-gap": Zr, "--n-tab-gap-vertical": Ut, "--n-pane-padding-left": Io(xt, "left"), "--n-pane-padding-right": Io(xt, "right"), "--n-pane-padding-top": Io(xt, "top"), "--n-pane-padding-bottom": Io(xt, "bottom"), "--n-font-weight-strong": Ce, "--n-tab-color-segment": ae };
  }), at = s ? ai("tabs", Ee(() => `${q.value[0]}${r.type[0]}`), ze, r) : void 0;
  return Object.assign({ mergedClsPrefix: p, mergedValue: re, renderedNames: /* @__PURE__ */ new Set(), segmentCapsuleElRef: tr, tabsPaneWrapperRef: qe, tabsElRef: P, barElRef: M, addTabInstRef: L, xScrollInstRef: $, scrollWrapperElRef: D, addTabFixed: Cr, tabWrapperStyle: J, handleNavResize: ir, mergedSize: q, handleScroll: Dr, handleTabsResize: or, cssVars: s ? void 0 : ze, themeClass: at == null ? void 0 : at.themeClass, animationDirection: ft, renderNameListRef: nt, yScrollElRef: z, handleSegmentResize: kt, onAnimationBeforeLeave: mt, onAnimationEnter: St, onAnimationAfterEnter: st, onRender: at == null ? void 0 : at.onRender }, nr);
}, render() {
  const { mergedClsPrefix: r, type: i, placement: l, addTabFixed: d, addable: f, mergedSize: g, renderNameListRef: p, onRender: s, paneWrapperClass: C, paneWrapperStyle: P, $slots: { default: M, prefix: D, suffix: L } } = this;
  s == null ? void 0 : s();
  const $ = M ? Bl(M()).filter((ie) => ie.type.__TAB_PANE__ === true) : [], z = M ? Bl(M()).filter((ie) => ie.type.__TAB__ === true) : [], F = !z.length, Z = i === "card", q = i === "segment", K = !Z && !q && this.justifyContent;
  p.value = [];
  const te = () => {
    const ie = B("div", { style: this.tabWrapperStyle, class: `${r}-tabs-wrapper` }, K ? null : B("div", { class: `${r}-tabs-scroll-padding`, style: l === "top" || l === "bottom" ? { width: `${this.tabsPadding}px` } : { height: `${this.tabsPadding}px` } }), F ? $.map((J, we) => (p.value.push(J.props.name), cg(B(qg, Object.assign({}, J.props, { internalCreatedByPane: true, internalLeftPadded: we !== 0 && (!K || K === "center" || K === "start" || K === "end") }), J.children ? { default: J.children.tab } : void 0)))) : z.map((J, we) => (p.value.push(J.props.name), cg(we !== 0 && !K ? X_(J) : J))), !d && f && Z ? H_(f, (F ? $.length : z.length) !== 0) : null, K ? null : B("div", { class: `${r}-tabs-scroll-padding`, style: { width: `${this.tabsPadding}px` } }));
    return B("div", { ref: "tabsElRef", class: `${r}-tabs-nav-scroll-content` }, Z && f ? B(Dl, { onResize: this.handleTabsResize }, { default: () => ie }) : ie, Z ? B("div", { class: `${r}-tabs-pad` }) : null, Z ? null : B("div", { ref: "barElRef", class: `${r}-tabs-bar` }));
  }, re = q ? "top" : l;
  return B("div", { class: [`${r}-tabs`, this.themeClass, `${r}-tabs--${i}-type`, `${r}-tabs--${g}-size`, K && `${r}-tabs--flex`, `${r}-tabs--${re}`], style: this.cssVars }, B("div", { class: [`${r}-tabs-nav--${i}-type`, `${r}-tabs-nav--${re}`, `${r}-tabs-nav`] }, oi(D, (ie) => ie && B("div", { class: `${r}-tabs-nav__prefix` }, ie)), q ? B(Dl, { onResize: this.handleSegmentResize }, { default: () => B("div", { class: `${r}-tabs-rail`, ref: "tabsElRef" }, B("div", { class: `${r}-tabs-capsule`, ref: "segmentCapsuleElRef" }, B("div", { class: `${r}-tabs-wrapper` }, B("div", { class: `${r}-tabs-tab` }))), F ? $.map((ie, J) => (p.value.push(ie.props.name), B(qg, Object.assign({}, ie.props, { internalCreatedByPane: true, internalLeftPadded: J !== 0 }), ie.children ? { default: ie.children.tab } : void 0))) : z.map((ie, J) => (p.value.push(ie.props.name), J === 0 ? ie : X_(ie)))) }) : B(Dl, { onResize: this.handleNavResize }, { default: () => B("div", { class: `${r}-tabs-nav-scroll-wrapper`, ref: "scrollWrapperElRef" }, ["top", "bottom"].includes(re) ? B(TS, { ref: "xScrollInstRef", onScroll: this.handleScroll }, { default: te }) : B("div", { class: `${r}-tabs-nav-y-scroll`, onScroll: this.handleScroll, ref: "yScrollElRef" }, te())) }), d && f && Z ? H_(f, true) : null, oi(L, (ie) => ie && B("div", { class: `${r}-tabs-nav__suffix` }, ie))), F && (this.animated && (re === "top" || re === "bottom") ? B("div", { ref: "tabsPaneWrapperRef", style: P, class: [`${r}-tabs-pane-wrapper`, C] }, Z_($, this.mergedValue, this.renderedNames, this.onAnimationBeforeLeave, this.onAnimationEnter, this.onAnimationAfterEnter, this.animationDirection)) : Z_($, this.mergedValue, this.renderedNames)));
} });
function Z_(r, i, l, d, f, g, p) {
  const s = [];
  return r.forEach((C) => {
    const { name: P, displayDirective: M, "display-directive": D } = C.props, L = (z) => M === z || D === z, $ = i === P;
    if (C.key !== void 0 && (C.key = P), $ || L("show") || L("show:lazy") && l.has(P)) {
      l.has(P) || l.add(P);
      const z = !L("if");
      s.push(z ? wa(C, [[ns, $]]) : C);
    }
  }), p ? B(yw, { name: `${p}-transition`, onBeforeLeave: d, onEnter: f, onAfterEnter: g }, { default: () => s }) : s;
}
function H_(r, i) {
  return B(qg, { ref: "addTabInstRef", key: "__addable", name: "__addable", internalCreatedByPane: true, internalAddable: true, internalLeftPadded: i, disabled: typeof r == "object" && r.disabled });
}
function X_(r) {
  const i = Sg(r);
  return i.props ? i.props.internalLeftPadded = true : i.props = { internalLeftPadded: true }, i;
}
function cg(r) {
  return Array.isArray(r.dynamicProps) ? r.dynamicProps.includes("internalLeftPadded") || r.dynamicProps.push("internalLeftPadded") : r.dynamicProps = ["internalLeftPadded"], r;
}
const d6 = ue("h", `
 font-size: var(--n-font-size);
 font-weight: var(--n-font-weight);
 margin: var(--n-margin);
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
`, [Ze("&:first-child", { marginTop: 0 }), Ge("prefix-bar", { position: "relative", paddingLeft: "var(--n-prefix-width)" }, [Ge("align-text", { paddingLeft: 0 }, [Ze("&::before", { left: "calc(-1 * var(--n-prefix-width))" })]), Ze("&::before", `
 content: "";
 width: var(--n-bar-width);
 border-radius: calc(var(--n-bar-width) / 2);
 transition: background-color .3s var(--n-bezier);
 left: 0;
 top: 0;
 bottom: 0;
 position: absolute;
 `), Ze("&::before", { backgroundColor: "var(--n-bar-color)" })])]), h6 = Object.assign(Object.assign({}, Jt.props), { type: { type: String, default: "default" }, prefix: String, alignText: Boolean }), f6 = (r) => ot({ name: `H${r}`, props: h6, setup(i) {
  const { mergedClsPrefixRef: l, inlineThemeDisabled: d } = Sr(i), f = Jt("Typography", "-h", d6, ab, i, l), g = Ee(() => {
    const { type: s } = i, { common: { cubicBezierEaseInOut: C }, self: { headerFontWeight: P, headerTextColor: M, [Vt("headerPrefixWidth", r)]: D, [Vt("headerFontSize", r)]: L, [Vt("headerMargin", r)]: $, [Vt("headerBarWidth", r)]: z, [Vt("headerBarColor", s)]: F } } = f.value;
    return { "--n-bezier": C, "--n-font-size": L, "--n-margin": $, "--n-bar-color": F, "--n-bar-width": z, "--n-font-weight": P, "--n-text-color": M, "--n-prefix-width": D };
  }), p = d ? ai(`h${r}`, Ee(() => i.type[0]), g, i) : void 0;
  return { mergedClsPrefix: l, cssVars: d ? void 0 : g, themeClass: p == null ? void 0 : p.themeClass, onRender: p == null ? void 0 : p.onRender };
}, render() {
  var i;
  const { prefix: l, alignText: d, mergedClsPrefix: f, cssVars: g, $slots: p } = this;
  return (i = this.onRender) === null || i === void 0 || i.call(this), B(`h${r}`, { class: [`${f}-h`, `${f}-h${r}`, this.themeClass, { [`${f}-h--prefix-bar`]: l, [`${f}-h--align-text`]: d }], style: g }, p);
} }), p6 = f6("1"), m6 = ue("p", `
 box-sizing: border-box;
 transition: color .3s var(--n-bezier);
 margin: var(--n-margin);
 font-size: var(--n-font-size);
 line-height: var(--n-line-height);
 color: var(--n-text-color);
`, [Ze("&:first-child", "margin-top: 0;"), Ze("&:last-child", "margin-bottom: 0;")]), g6 = Object.assign(Object.assign({}, Jt.props), { depth: [String, Number] }), qf = ot({ name: "P", props: g6, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Sr(r), d = Jt("Typography", "-p", m6, ab, r, i), f = Ee(() => {
    const { depth: p } = r, s = p || "1", { common: { cubicBezierEaseInOut: C }, self: { pFontSize: P, pLineHeight: M, pMargin: D, pTextColor: L, [`pTextColor${s}Depth`]: $ } } = d.value;
    return { "--n-bezier": C, "--n-font-size": P, "--n-line-height": M, "--n-margin": D, "--n-text-color": p === void 0 ? L : $ };
  }), g = l ? ai("p", Ee(() => `${r.depth || ""}`), f, r) : void 0;
  return { mergedClsPrefix: i, cssVars: l ? void 0 : f, themeClass: g == null ? void 0 : g.themeClass, onRender: g == null ? void 0 : g.onRender };
}, render() {
  var r;
  return (r = this.onRender) === null || r === void 0 || r.call(this), B("p", { class: [`${this.mergedClsPrefix}-p`, this.themeClass], style: this.cssVars }, this.$slots);
} }), xc = $n("n-upload"), v6 = Ze([ue("upload", "width: 100%;", [Ge("dragger-inside", [ue("upload-trigger", `
 display: block;
 `)]), Ge("drag-over", [ue("upload-dragger", `
 border: var(--n-dragger-border-hover);
 `)])]), ue("upload-dragger", `
 cursor: pointer;
 box-sizing: border-box;
 width: 100%;
 text-align: center;
 border-radius: var(--n-border-radius);
 padding: 24px;
 opacity: 1;
 transition:
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 background-color: var(--n-dragger-color);
 border: var(--n-dragger-border);
 `, [Ze("&:hover", `
 border: var(--n-dragger-border-hover);
 `), Ge("disabled", `
 cursor: not-allowed;
 `)]), ue("upload-trigger", `
 display: inline-block;
 box-sizing: border-box;
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [Ze("+", [ue("upload-file-list", "margin-top: 8px;")]), Ge("disabled", `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `), Ge("image-card", `
 width: 96px;
 height: 96px;
 `, [ue("base-icon", `
 font-size: 24px;
 `), ue("upload-dragger", `
 padding: 0;
 height: 100%;
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `)])]), ue("upload-file-list", `
 line-height: var(--n-line-height);
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [Ze("a, img", "outline: none;"), Ge("disabled", `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `, [ue("upload-file", "cursor: not-allowed;")]), Ge("grid", `
 display: grid;
 grid-template-columns: repeat(auto-fill, 96px);
 grid-gap: 8px;
 margin-top: 0;
 `), ue("upload-file", `
 display: block;
 box-sizing: border-box;
 cursor: default;
 padding: 0px 12px 0 6px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `, [sp(), ue("progress", [sp({ foldPadding: true })]), Ze("&:hover", `
 background-color: var(--n-item-color-hover);
 `, [ue("upload-file-info", [Ae("action", `
 opacity: 1;
 `)])]), Ge("image-type", `
 border-radius: var(--n-border-radius);
 text-decoration: underline;
 text-decoration-color: #0000;
 `, [ue("upload-file-info", `
 padding-top: 0px;
 padding-bottom: 0px;
 width: 100%;
 height: 100%;
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 6px 0;
 `, [ue("progress", `
 padding: 2px 0;
 margin-bottom: 0;
 `), Ae("name", `
 padding: 0 8px;
 `), Ae("thumbnail", `
 width: 32px;
 height: 32px;
 font-size: 28px;
 display: flex;
 justify-content: center;
 align-items: center;
 `, [Ze("img", `
 width: 100%;
 `)])])]), Ge("text-type", [ue("progress", `
 box-sizing: border-box;
 padding-bottom: 6px;
 margin-bottom: 6px;
 `)]), Ge("image-card-type", `
 position: relative;
 width: 96px;
 height: 96px;
 border: var(--n-item-border-image-card);
 border-radius: var(--n-border-radius);
 padding: 0;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: border-color .3s var(--n-bezier), background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 overflow: hidden;
 `, [ue("progress", `
 position: absolute;
 left: 8px;
 bottom: 8px;
 right: 8px;
 width: unset;
 `), ue("upload-file-info", `
 padding: 0;
 width: 100%;
 height: 100%;
 `, [Ae("thumbnail", `
 width: 100%;
 height: 100%;
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 font-size: 36px;
 `, [Ze("img", `
 width: 100%;
 `)])]), Ze("&::before", `
 position: absolute;
 z-index: 1;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 opacity: 0;
 transition: opacity .2s var(--n-bezier);
 content: "";
 `), Ze("&:hover", [Ze("&::before", "opacity: 1;"), ue("upload-file-info", [Ae("thumbnail", "opacity: .12;")])])]), Ge("error-status", [Ze("&:hover", `
 background-color: var(--n-item-color-hover-error);
 `), ue("upload-file-info", [Ae("name", "color: var(--n-item-text-color-error);"), Ae("thumbnail", "color: var(--n-item-text-color-error);")]), Ge("image-card-type", `
 border: var(--n-item-border-image-card-error);
 `)]), Ge("with-url", `
 cursor: pointer;
 `, [ue("upload-file-info", [Ae("name", `
 color: var(--n-item-text-color-success);
 text-decoration-color: var(--n-item-text-color-success);
 `, [Ze("a", `
 text-decoration: underline;
 `)])])]), ue("upload-file-info", `
 position: relative;
 padding-top: 6px;
 padding-bottom: 6px;
 display: flex;
 flex-wrap: nowrap;
 `, [Ae("thumbnail", `
 font-size: 18px;
 opacity: 1;
 transition: opacity .2s var(--n-bezier);
 color: var(--n-item-icon-color);
 `, [ue("base-icon", `
 margin-right: 2px;
 vertical-align: middle;
 transition: color .3s var(--n-bezier);
 `)]), Ae("action", `
 padding-top: inherit;
 padding-bottom: inherit;
 position: absolute;
 right: 0;
 top: 0;
 bottom: 0;
 width: 80px;
 display: flex;
 align-items: center;
 transition: opacity .2s var(--n-bezier);
 justify-content: flex-end;
 opacity: 0;
 `, [ue("button", [Ze("&:not(:last-child)", { marginRight: "4px" }), ue("base-icon", [Ze("svg", [Yd()])])]), Ge("image-type", `
 position: relative;
 max-width: 80px;
 width: auto;
 `), Ge("image-card-type", `
 z-index: 2;
 position: absolute;
 width: 100%;
 height: 100%;
 left: 0;
 right: 0;
 bottom: 0;
 top: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 `)]), Ae("name", `
 color: var(--n-item-text-color);
 flex: 1;
 display: flex;
 justify-content: center;
 text-overflow: ellipsis;
 overflow: hidden;
 flex-direction: column;
 text-decoration-color: #0000;
 font-size: var(--n-font-size);
 transition:
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier); 
 `, [Ze("a", `
 color: inherit;
 text-decoration: underline;
 `)])])])]), ue("upload-file-input", `
 display: none;
 width: 0;
 height: 0;
 opacity: 0;
 `)]), h1 = "__UPLOAD_DRAGGER__", f1 = ot({ name: "UploadDragger", [h1]: true, setup(r, { slots: i }) {
  const l = ur(xc, null);
  return l || ea("upload-dragger", "`n-upload-dragger` must be placed inside `n-upload`."), () => {
    const { mergedClsPrefixRef: { value: d }, mergedDisabledRef: { value: f }, maxReachedRef: { value: g } } = l;
    return B("div", { class: [`${d}-upload-dragger`, (f || g) && `${d}-upload-dragger--disabled`] }, i);
  };
} });
function _6() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 28 28" }, B("g", { fill: "none" }, B("path", { d: "M21.75 3A3.25 3.25 0 0 1 25 6.25v15.5A3.25 3.25 0 0 1 21.75 25H6.25A3.25 3.25 0 0 1 3 21.75V6.25A3.25 3.25 0 0 1 6.25 3h15.5zm.583 20.4l-7.807-7.68a.75.75 0 0 0-.968-.07l-.084.07l-7.808 7.68c.183.065.38.1.584.1h15.5c.204 0 .4-.035.583-.1l-7.807-7.68l7.807 7.68zM21.75 4.5H6.25A1.75 1.75 0 0 0 4.5 6.25v15.5c0 .208.036.408.103.593l7.82-7.692a2.25 2.25 0 0 1 3.026-.117l.129.117l7.82 7.692c.066-.185.102-.385.102-.593V6.25a1.75 1.75 0 0 0-1.75-1.75zm-3.25 3a2.5 2.5 0 1 1 0 5a2.5 2.5 0 0 1 0-5zm0 1.5a1 1 0 1 0 0 2a1 1 0 0 0 0-2z", fill: "currentColor" })));
}
function y6() {
  return B("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 28 28" }, B("g", { fill: "none" }, B("path", { d: "M6.4 2A2.4 2.4 0 0 0 4 4.4v19.2A2.4 2.4 0 0 0 6.4 26h15.2a2.4 2.4 0 0 0 2.4-2.4V11.578c0-.729-.29-1.428-.805-1.944l-6.931-6.931A2.4 2.4 0 0 0 14.567 2H6.4zm-.9 2.4a.9.9 0 0 1 .9-.9H14V10a2 2 0 0 0 2 2h6.5v11.6a.9.9 0 0 1-.9.9H6.4a.9.9 0 0 1-.9-.9V4.4zm16.44 6.1H16a.5.5 0 0 1-.5-.5V4.06l6.44 6.44z", fill: "currentColor" })));
}
const b6 = ot({ name: "UploadProgress", props: { show: Boolean, percentage: { type: Number, required: true }, status: { type: String, required: true } }, setup() {
  return { mergedTheme: ur(xc).mergedThemeRef };
}, render() {
  return B(kp, null, { default: () => this.show ? B(YT, { type: "line", showIndicator: false, percentage: this.percentage, status: this.status, height: 2, theme: this.mergedTheme.peers.Progress, themeOverrides: this.mergedTheme.peerOverrides.Progress }) : null });
} });
var Wg = function(r, i, l, d) {
  function f(g) {
    return g instanceof l ? g : new l(function(p) {
      p(g);
    });
  }
  return new (l || (l = Promise))(function(g, p) {
    function s(M) {
      try {
        P(d.next(M));
      } catch (D) {
        p(D);
      }
    }
    function C(M) {
      try {
        P(d.throw(M));
      } catch (D) {
        p(D);
      }
    }
    function P(M) {
      M.done ? g(M.value) : f(M.value).then(s, C);
    }
    P((d = d.apply(r, i || [])).next());
  });
};
function p1(r) {
  return r.includes("image/");
}
function Y_(r = "") {
  const i = r.split("/"), d = i[i.length - 1].split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(d) || [""])[0];
}
const K_ = /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i, m1 = (r) => {
  if (r.type) return p1(r.type);
  const i = Y_(r.name || "");
  if (K_.test(i)) return true;
  const l = r.thumbnailUrl || r.url || "", d = Y_(l);
  return !!(/^data:image\//.test(l) || K_.test(d));
};
function x6(r) {
  return Wg(this, void 0, void 0, function* () {
    return yield new Promise((i) => {
      if (!r.type || !p1(r.type)) {
        i("");
        return;
      }
      i(window.URL.createObjectURL(r));
    });
  });
}
const w6 = Tp && window.FileReader && window.File;
function C6(r) {
  return r.isDirectory;
}
function S6(r) {
  return r.isFile;
}
function k6(r, i) {
  return Wg(this, void 0, void 0, function* () {
    const l = [];
    function d(f) {
      return Wg(this, void 0, void 0, function* () {
        for (const g of f) if (g) {
          if (i && C6(g)) {
            const p = g.createReader();
            let s = [], C;
            try {
              do
                C = yield new Promise((P, M) => {
                  p.readEntries(P, M);
                }), s = s.concat(C);
              while (C.length > 0);
            } catch (P) {
              h_("upload", "error happens when handling directory upload", P);
            }
            yield d(s);
          } else if (S6(g)) try {
            const p = yield new Promise((s, C) => {
              g.file(s, C);
            });
            l.push({ file: p, entry: g, source: "dnd" });
          } catch (p) {
            h_("upload", "error happens when handling file upload", p);
          }
        }
      });
    }
    return yield d(r), l;
  });
}
function ih(r) {
  const { id: i, name: l, percentage: d, status: f, url: g, file: p, thumbnailUrl: s, type: C, fullPath: P, batchId: M } = r;
  return { id: i, name: l, percentage: d ?? null, status: f, url: g ?? null, file: p ?? null, thumbnailUrl: s ?? null, type: C ?? null, fullPath: P ?? null, batchId: M ?? null };
}
function P6(r, i, l) {
  return r = r.toLowerCase(), i = i.toLocaleLowerCase(), l = l.toLocaleLowerCase(), l.split(",").map((f) => f.trim()).filter(Boolean).some((f) => {
    if (f.startsWith(".")) {
      if (r.endsWith(f)) return true;
    } else if (f.includes("/")) {
      const [g, p] = i.split("/"), [s, C] = f.split("/");
      if ((s === "*" || g && s && s === g) && (C === "*" || p && C && C === p)) return true;
    } else return true;
    return false;
  });
}
var J_ = function(r, i, l, d) {
  function f(g) {
    return g instanceof l ? g : new l(function(p) {
      p(g);
    });
  }
  return new (l || (l = Promise))(function(g, p) {
    function s(M) {
      try {
        P(d.next(M));
      } catch (D) {
        p(D);
      }
    }
    function C(M) {
      try {
        P(d.throw(M));
      } catch (D) {
        p(D);
      }
    }
    function P(M) {
      M.done ? g(M.value) : f(M.value).then(s, C);
    }
    P((d = d.apply(r, i || [])).next());
  });
};
const Wf = { paddingMedium: "0 3px", heightMedium: "24px", iconSizeMedium: "18px" }, T6 = ot({ name: "UploadFile", props: { clsPrefix: { type: String, required: true }, file: { type: Object, required: true }, listType: { type: String, required: true }, index: { type: Number, required: true } }, setup(r) {
  const i = ur(xc), l = Ie(null), d = Ie(""), f = Ee(() => {
    const { file: ie } = r;
    return ie.status === "finished" ? "success" : ie.status === "error" ? "error" : "info";
  }), g = Ee(() => {
    const { file: ie } = r;
    if (ie.status === "error") return "error";
  }), p = Ee(() => {
    const { file: ie } = r;
    return ie.status === "uploading";
  }), s = Ee(() => {
    if (!i.showCancelButtonRef.value) return false;
    const { file: ie } = r;
    return ["uploading", "pending", "error"].includes(ie.status);
  }), C = Ee(() => {
    if (!i.showRemoveButtonRef.value) return false;
    const { file: ie } = r;
    return ["finished"].includes(ie.status);
  }), P = Ee(() => {
    if (!i.showDownloadButtonRef.value) return false;
    const { file: ie } = r;
    return ["finished"].includes(ie.status);
  }), M = Ee(() => {
    if (!i.showRetryButtonRef.value) return false;
    const { file: ie } = r;
    return ["error"].includes(ie.status);
  }), D = vi(() => d.value || r.file.thumbnailUrl || r.file.url), L = Ee(() => {
    if (!i.showPreviewButtonRef.value) return false;
    const { file: { status: ie }, listType: J } = r;
    return ["finished"].includes(ie) && D.value && J === "image-card";
  });
  function $() {
    return J_(this, void 0, void 0, function* () {
      const ie = i.onRetryRef.value;
      ie && (yield ie({ file: r.file })) === false || i.submit(r.file.id);
    });
  }
  function z(ie) {
    ie.preventDefault();
    const { file: J } = r;
    ["finished", "pending", "error"].includes(J.status) ? Z(J) : ["uploading"].includes(J.status) ? K(J) : lp("upload", "The button clicked type is unknown.");
  }
  function F(ie) {
    ie.preventDefault(), q(r.file);
  }
  function Z(ie) {
    const { xhrMap: J, doChange: we, onRemoveRef: { value: fe }, mergedFileListRef: { value: oe } } = i;
    Promise.resolve(fe ? fe({ file: Object.assign({}, ie), fileList: oe, index: r.index }) : true).then((he) => {
      if (he === false) return;
      const _e = Object.assign({}, ie, { status: "removed" });
      J.delete(ie.id), we(_e, void 0, { remove: true });
    });
  }
  function q(ie) {
    const { onDownloadRef: { value: J }, customDownloadRef: { value: we } } = i;
    Promise.resolve(J ? J(Object.assign({}, ie)) : true).then((fe) => {
      fe !== false && (we ? we(Object.assign({}, ie)) : Db(ie.url, ie.name));
    });
  }
  function K(ie) {
    const { xhrMap: J } = i, we = J.get(ie.id);
    we == null ? void 0 : we.abort(), Z(Object.assign({}, ie));
  }
  function te(ie) {
    const { onPreviewRef: { value: J } } = i;
    if (J) J(r.file, { event: ie });
    else if (r.listType === "image-card") {
      const { value: we } = l;
      if (!we) return;
      we.showPreview();
    }
  }
  const re = () => J_(this, void 0, void 0, function* () {
    const { listType: ie } = r;
    ie !== "image" && ie !== "image-card" || i.shouldUseThumbnailUrlRef.value(r.file) && (d.value = yield i.getFileThumbnailUrlResolver(r.file));
  });
  return bo(() => {
    re();
  }), { mergedTheme: i.mergedThemeRef, progressStatus: f, buttonType: g, showProgress: p, disabled: i.mergedDisabledRef, showCancelButton: s, showRemoveButton: C, showDownloadButton: P, showRetryButton: M, showPreviewButton: L, mergedThumbnailUrl: D, shouldUseThumbnailUrl: i.shouldUseThumbnailUrlRef, renderIcon: i.renderIconRef, imageRef: l, handleRemoveOrCancelClick: z, handleDownloadClick: F, handleRetryClick: $, handlePreviewClick: te };
}, render() {
  const { clsPrefix: r, mergedTheme: i, listType: l, file: d, renderIcon: f } = this;
  let g;
  const p = l === "image";
  p || l === "image-card" ? g = !this.shouldUseThumbnailUrl(d) || !this.mergedThumbnailUrl ? B("span", { class: `${r}-upload-file-info__thumbnail` }, f ? f(d) : m1(d) ? B(qr, { clsPrefix: r }, { default: _6 }) : B(qr, { clsPrefix: r }, { default: y6 })) : B("a", { rel: "noopener noreferer", target: "_blank", href: d.url || void 0, class: `${r}-upload-file-info__thumbnail`, onClick: this.handlePreviewClick }, l === "image-card" ? B(a1, { src: this.mergedThumbnailUrl || void 0, previewSrc: d.url || void 0, alt: d.name, ref: "imageRef" }) : B("img", { src: this.mergedThumbnailUrl || void 0, alt: d.name })) : g = B("span", { class: `${r}-upload-file-info__thumbnail` }, f ? f(d) : B(qr, { clsPrefix: r }, { default: () => B(vk, null) }));
  const C = B(b6, { show: this.showProgress, percentage: d.percentage || 0, status: this.progressStatus }), P = l === "text" || l === "image";
  return B("div", { class: [`${r}-upload-file`, `${r}-upload-file--${this.progressStatus}-status`, d.url && d.status !== "error" && l !== "image-card" && `${r}-upload-file--with-url`, `${r}-upload-file--${l}-type`] }, B("div", { class: `${r}-upload-file-info` }, g, B("div", { class: `${r}-upload-file-info__name` }, P && (d.url && d.status !== "error" ? B("a", { rel: "noopener noreferer", target: "_blank", href: d.url || void 0, onClick: this.handlePreviewClick }, d.name) : B("span", { onClick: this.handlePreviewClick }, d.name)), p && C), B("div", { class: [`${r}-upload-file-info__action`, `${r}-upload-file-info__action--${l}-type`] }, this.showPreviewButton ? B($r, { key: "preview", quaternary: true, type: this.buttonType, onClick: this.handlePreviewClick, theme: i.peers.Button, themeOverrides: i.peerOverrides.Button, builtinThemeOverrides: Wf }, { icon: () => B(qr, { clsPrefix: r }, { default: () => B(Fb, null) }) }) : null, (this.showRemoveButton || this.showCancelButton) && !this.disabled && B($r, { key: "cancelOrTrash", theme: i.peers.Button, themeOverrides: i.peerOverrides.Button, quaternary: true, builtinThemeOverrides: Wf, type: this.buttonType, onClick: this.handleRemoveOrCancelClick }, { icon: () => B(xp, null, { default: () => this.showRemoveButton ? B(qr, { clsPrefix: r, key: "trash" }, { default: () => B(Ek, null) }) : B(qr, { clsPrefix: r, key: "cancel" }, { default: () => B(_k, null) }) }) }), this.showRetryButton && !this.disabled && B($r, { key: "retry", quaternary: true, type: this.buttonType, onClick: this.handleRetryClick, theme: i.peers.Button, themeOverrides: i.peerOverrides.Button, builtinThemeOverrides: Wf }, { icon: () => B(qr, { clsPrefix: r }, { default: () => B(Tk, null) }) }), this.showDownloadButton ? B($r, { key: "download", quaternary: true, type: this.buttonType, onClick: this.handleDownloadClick, theme: i.peers.Button, themeOverrides: i.peerOverrides.Button, builtinThemeOverrides: Wf }, { icon: () => B(qr, { clsPrefix: r }, { default: () => B(zb, null) }) }) : null)), !p && C);
} }), g1 = ot({ name: "UploadTrigger", props: { abstract: Boolean }, slots: Object, setup(r, { slots: i }) {
  const l = ur(xc, null);
  l || ea("upload-trigger", "`n-upload-trigger` must be placed inside `n-upload`.");
  const { mergedClsPrefixRef: d, mergedDisabledRef: f, maxReachedRef: g, listTypeRef: p, dragOverRef: s, openOpenFileDialog: C, draggerInsideRef: P, handleFileAddition: M, mergedDirectoryDndRef: D, triggerClassRef: L, triggerStyleRef: $ } = l, z = Ee(() => p.value === "image-card");
  function F() {
    f.value || g.value || C();
  }
  function Z(re) {
    re.preventDefault(), s.value = true;
  }
  function q(re) {
    re.preventDefault(), s.value = true;
  }
  function K(re) {
    re.preventDefault(), s.value = false;
  }
  function te(re) {
    var ie;
    if (re.preventDefault(), !P.value || f.value || g.value) {
      s.value = false;
      return;
    }
    const J = (ie = re.dataTransfer) === null || ie === void 0 ? void 0 : ie.items;
    (J == null ? void 0 : J.length) ? k6(Array.from(J).map((we) => we.webkitGetAsEntry()), D.value).then((we) => {
      M(we);
    }).finally(() => {
      s.value = false;
    }) : s.value = false;
  }
  return () => {
    var re;
    const { value: ie } = d;
    return r.abstract ? (re = i.default) === null || re === void 0 ? void 0 : re.call(i, { handleClick: F, handleDrop: te, handleDragOver: Z, handleDragEnter: q, handleDragLeave: K }) : B("div", { class: [`${ie}-upload-trigger`, (f.value || g.value) && `${ie}-upload-trigger--disabled`, z.value && `${ie}-upload-trigger--image-card`, L.value], style: $.value, onClick: F, onDrop: te, onDragover: Z, onDragenter: q, onDragleave: K }, z.value ? B(f1, null, { default: () => Zn(i.default, () => [B(qr, { clsPrefix: ie }, { default: () => B(Rp, null) })]) }) : i);
  };
} }), I6 = ot({ name: "UploadFileList", setup(r, { slots: i }) {
  const l = ur(xc, null);
  l || ea("upload-file-list", "`n-upload-file-list` must be placed inside `n-upload`.");
  const { abstractRef: d, mergedClsPrefixRef: f, listTypeRef: g, mergedFileListRef: p, fileListClassRef: s, fileListStyleRef: C, cssVarsRef: P, themeClassRef: M, maxReachedRef: D, showTriggerRef: L, imageGroupPropsRef: $ } = l, z = Ee(() => g.value === "image-card"), F = () => p.value.map((q, K) => B(T6, { clsPrefix: f.value, key: q.id, file: q, index: K, listType: g.value })), Z = () => z.value ? B(ET, Object.assign({}, $.value), { default: F }) : B(kp, { group: true }, { default: F });
  return () => {
    const { value: q } = f, { value: K } = d;
    return B("div", { class: [`${q}-upload-file-list`, z.value && `${q}-upload-file-list--grid`, K ? M == null ? void 0 : M.value : void 0, s.value], style: [K && P ? P.value : "", C.value] }, Z(), L.value && !D.value && z.value && B(g1, null, i));
  };
} });
var Q_ = function(r, i, l, d) {
  function f(g) {
    return g instanceof l ? g : new l(function(p) {
      p(g);
    });
  }
  return new (l || (l = Promise))(function(g, p) {
    function s(M) {
      try {
        P(d.next(M));
      } catch (D) {
        p(D);
      }
    }
    function C(M) {
      try {
        P(d.throw(M));
      } catch (D) {
        p(D);
      }
    }
    function P(M) {
      M.done ? g(M.value) : f(M.value).then(s, C);
    }
    P((d = d.apply(r, i || [])).next());
  });
};
function M6(r, i, l) {
  const { doChange: d, xhrMap: f } = r;
  let g = 0;
  function p(C) {
    var P;
    let M = Object.assign({}, i, { status: "error", percentage: g });
    f.delete(i.id), M = ih(((P = r.onError) === null || P === void 0 ? void 0 : P.call(r, { file: M, event: C })) || M), d(M, C);
  }
  function s(C) {
    var P;
    if (r.isErrorState) {
      if (r.isErrorState(l)) {
        p(C);
        return;
      }
    } else if (l.status < 200 || l.status >= 300) {
      p(C);
      return;
    }
    let M = Object.assign({}, i, { status: "finished", percentage: g });
    f.delete(i.id), M = ih(((P = r.onFinish) === null || P === void 0 ? void 0 : P.call(r, { file: M, event: C })) || M), d(M, C);
  }
  return { handleXHRLoad: s, handleXHRError: p, handleXHRAbort(C) {
    const P = Object.assign({}, i, { status: "removed", file: null, percentage: g });
    f.delete(i.id), d(P, C);
  }, handleXHRProgress(C) {
    const P = Object.assign({}, i, { status: "uploading" });
    if (C.lengthComputable) {
      const M = Math.ceil(C.loaded / C.total * 100);
      P.percentage = M, g = M;
    }
    d(P, C);
  } };
}
function E6(r) {
  const { inst: i, file: l, data: d, headers: f, withCredentials: g, action: p, customRequest: s } = r, { doChange: C } = r.inst;
  let P = 0;
  s({ file: l, data: d, headers: f, withCredentials: g, action: p, onProgress(M) {
    const D = Object.assign({}, l, { status: "uploading" }), L = M.percent;
    D.percentage = L, P = L, C(D);
  }, onFinish() {
    var M;
    let D = Object.assign({}, l, { status: "finished", percentage: P });
    D = ih(((M = i.onFinish) === null || M === void 0 ? void 0 : M.call(i, { file: D })) || D), C(D);
  }, onError() {
    var M;
    let D = Object.assign({}, l, { status: "error", percentage: P });
    D = ih(((M = i.onError) === null || M === void 0 ? void 0 : M.call(i, { file: D })) || D), C(D);
  } });
}
function R6(r, i, l) {
  const d = M6(r, i, l);
  l.onabort = d.handleXHRAbort, l.onerror = d.handleXHRError, l.onload = d.handleXHRLoad, l.upload && (l.upload.onprogress = d.handleXHRProgress);
}
function v1(r, i) {
  return typeof r == "function" ? r({ file: i }) : r || {};
}
function A6(r, i, l) {
  const d = v1(i, l);
  d && Object.keys(d).forEach((f) => {
    r.setRequestHeader(f, d[f]);
  });
}
function D6(r, i, l) {
  const d = v1(i, l);
  d && Object.keys(d).forEach((f) => {
    r.append(f, d[f]);
  });
}
function z6(r, i, l, { method: d, action: f, withCredentials: g, responseType: p, headers: s, data: C }) {
  const P = new XMLHttpRequest();
  P.responseType = p, r.xhrMap.set(l.id, P), P.withCredentials = g;
  const M = new FormData();
  if (D6(M, C, l), l.file !== null && M.append(i, l.file), R6(r, l, P), f !== void 0) {
    P.open(d.toUpperCase(), f), A6(P, s, l), P.send(M);
    const D = Object.assign({}, l, { status: "uploading" });
    r.doChange(D);
  }
}
const F6 = Object.assign(Object.assign({}, Jt.props), { name: { type: String, default: "file" }, accept: String, action: String, customRequest: Function, directory: Boolean, directoryDnd: { type: Boolean, default: void 0 }, method: { type: String, default: "POST" }, multiple: Boolean, showFileList: { type: Boolean, default: true }, data: [Object, Function], headers: [Object, Function], withCredentials: Boolean, responseType: { type: String, default: "" }, disabled: { type: Boolean, default: void 0 }, onChange: Function, onRemove: Function, onFinish: Function, onError: Function, onRetry: Function, onBeforeUpload: Function, isErrorState: Function, onDownload: Function, customDownload: Function, defaultUpload: { type: Boolean, default: true }, fileList: Array, "onUpdate:fileList": [Function, Array], onUpdateFileList: [Function, Array], fileListClass: String, fileListStyle: [String, Object], defaultFileList: { type: Array, default: () => [] }, showCancelButton: { type: Boolean, default: true }, showRemoveButton: { type: Boolean, default: true }, showDownloadButton: Boolean, showRetryButton: { type: Boolean, default: true }, showPreviewButton: { type: Boolean, default: true }, listType: { type: String, default: "text" }, onPreview: Function, shouldUseThumbnailUrl: { type: Function, default: (r) => w6 ? m1(r) : false }, createThumbnailUrl: Function, abstract: Boolean, max: Number, showTrigger: { type: Boolean, default: true }, imageGroupProps: Object, inputProps: Object, triggerClass: String, triggerStyle: [String, Object], renderIcon: Function }), L6 = ot({ name: "Upload", props: F6, setup(r) {
  r.abstract && r.listType === "image-card" && ea("upload", "when the list-type is image-card, abstract is not supported.");
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l, mergedRtlRef: d } = Sr(r), f = Jt("Upload", "-upload", v6, P3, r, i), g = Tn("Upload", d, i), p = ka(r), s = Ie(r.defaultFileList), C = zt(r, "fileList"), P = Ie(null), M = { value: false }, D = Ie(false), L = /* @__PURE__ */ new Map(), $ = Ji(C, s), z = Ee(() => $.value.map(ih)), F = Ee(() => {
    const { max: _e } = r;
    return _e !== void 0 ? z.value.length >= _e : false;
  });
  function Z() {
    var _e;
    (_e = P.value) === null || _e === void 0 || _e.click();
  }
  function q(_e) {
    const Ue = _e.target;
    ie(Ue.files ? Array.from(Ue.files).map((qe) => ({ file: qe, entry: null, source: "input" })) : null, _e), Ue.value = "";
  }
  function K(_e) {
    const { "onUpdate:fileList": Ue, onUpdateFileList: qe } = r;
    Ue && Ot(Ue, _e), qe && Ot(qe, _e), s.value = _e;
  }
  const te = Ee(() => r.multiple || r.directory), re = (_e, Ue, qe = { append: false, remove: false }) => {
    const { append: tt, remove: ut } = qe, mt = Array.from(z.value), St = mt.findIndex((st) => st.id === _e.id);
    if (tt || ut || ~St) {
      tt ? mt.push(_e) : ut ? mt.splice(St, 1) : mt.splice(St, 1, _e);
      const { onChange: st } = r;
      st && st({ file: _e, fileList: mt, event: Ue }), K(mt);
    }
  };
  function ie(_e, Ue) {
    if (!_e || _e.length === 0) return;
    const { onBeforeUpload: qe } = r;
    _e = te.value ? _e : [_e[0]];
    const { max: tt, accept: ut } = r;
    _e = _e.filter(({ file: St, source: st }) => st === "dnd" && (ut == null ? void 0 : ut.trim()) ? P6(St.name, St.type, ut) : true), tt && (_e = _e.slice(0, tt - z.value.length));
    const mt = $l();
    Promise.all(_e.map((St) => Q_(this, [St], void 0, function* ({ file: st, entry: nt }) {
      var ft;
      const Lt = { id: $l(), batchId: mt, name: st.name, status: "pending", percentage: 0, file: st, url: null, type: st.type, thumbnailUrl: null, fullPath: (ft = nt == null ? void 0 : nt.fullPath) !== null && ft !== void 0 ? ft : `/${st.webkitRelativePath || st.name}` };
      return !qe || (yield qe({ file: Lt, fileList: z.value })) !== false ? Lt : null;
    }))).then((St) => Q_(this, void 0, void 0, function* () {
      let st = Promise.resolve();
      St.forEach((nt) => {
        st = st.then(Wn).then(() => {
          nt && re(nt, Ue, { append: true });
        });
      }), yield st;
    })).then(() => {
      r.defaultUpload && J();
    });
  }
  function J(_e) {
    const { method: Ue, action: qe, withCredentials: tt, headers: ut, data: mt, name: St } = r, st = _e !== void 0 ? z.value.filter((ft) => ft.id === _e) : z.value, nt = _e !== void 0;
    st.forEach((ft) => {
      const { status: Lt } = ft;
      (Lt === "pending" || Lt === "error" && nt) && (r.customRequest ? E6({ inst: { doChange: re, xhrMap: L, onFinish: r.onFinish, onError: r.onError }, file: ft, action: qe, withCredentials: tt, headers: ut, data: mt, customRequest: r.customRequest }) : z6({ doChange: re, xhrMap: L, onFinish: r.onFinish, onError: r.onError, isErrorState: r.isErrorState }, St, ft, { method: Ue, action: qe, withCredentials: tt, responseType: r.responseType, headers: ut, data: mt }));
    });
  }
  function we(_e) {
    var Ue;
    if (_e.thumbnailUrl) return _e.thumbnailUrl;
    const { createThumbnailUrl: qe } = r;
    return qe ? (Ue = qe(_e.file, _e)) !== null && Ue !== void 0 ? Ue : _e.url || "" : _e.url ? _e.url : _e.file ? x6(_e.file) : "";
  }
  const fe = Ee(() => {
    const { common: { cubicBezierEaseInOut: _e }, self: { draggerColor: Ue, draggerBorder: qe, draggerBorderHover: tt, itemColorHover: ut, itemColorHoverError: mt, itemTextColorError: St, itemTextColorSuccess: st, itemTextColor: nt, itemIconColor: ft, itemDisabledOpacity: Lt, lineHeight: pt, borderRadius: wt, fontSize: Ft, itemBorderImageCardError: tr, itemBorderImageCard: gt } } = f.value;
    return { "--n-bezier": _e, "--n-border-radius": wt, "--n-dragger-border": qe, "--n-dragger-border-hover": tt, "--n-dragger-color": Ue, "--n-font-size": Ft, "--n-item-color-hover": ut, "--n-item-color-hover-error": mt, "--n-item-disabled-opacity": Lt, "--n-item-icon-color": ft, "--n-item-text-color": nt, "--n-item-text-color-error": St, "--n-item-text-color-success": st, "--n-line-height": pt, "--n-item-border-image-card-error": tr, "--n-item-border-image-card": gt };
  }), oe = l ? ai("upload", void 0, fe, r) : void 0;
  Xr(xc, { mergedClsPrefixRef: i, mergedThemeRef: f, showCancelButtonRef: zt(r, "showCancelButton"), showDownloadButtonRef: zt(r, "showDownloadButton"), showRemoveButtonRef: zt(r, "showRemoveButton"), showRetryButtonRef: zt(r, "showRetryButton"), onRemoveRef: zt(r, "onRemove"), onDownloadRef: zt(r, "onDownload"), customDownloadRef: zt(r, "customDownload"), mergedFileListRef: z, triggerClassRef: zt(r, "triggerClass"), triggerStyleRef: zt(r, "triggerStyle"), shouldUseThumbnailUrlRef: zt(r, "shouldUseThumbnailUrl"), renderIconRef: zt(r, "renderIcon"), xhrMap: L, submit: J, doChange: re, showPreviewButtonRef: zt(r, "showPreviewButton"), onPreviewRef: zt(r, "onPreview"), getFileThumbnailUrlResolver: we, listTypeRef: zt(r, "listType"), dragOverRef: D, openOpenFileDialog: Z, draggerInsideRef: M, handleFileAddition: ie, mergedDisabledRef: p.mergedDisabledRef, maxReachedRef: F, fileListClassRef: zt(r, "fileListClass"), fileListStyleRef: zt(r, "fileListStyle"), abstractRef: zt(r, "abstract"), acceptRef: zt(r, "accept"), cssVarsRef: l ? void 0 : fe, themeClassRef: oe == null ? void 0 : oe.themeClass, onRender: oe == null ? void 0 : oe.onRender, showTriggerRef: zt(r, "showTrigger"), imageGroupPropsRef: zt(r, "imageGroupProps"), mergedDirectoryDndRef: Ee(() => {
    var _e;
    return (_e = r.directoryDnd) !== null && _e !== void 0 ? _e : r.directory;
  }), onRetryRef: zt(r, "onRetry") });
  const he = { clear: () => {
    s.value = [];
  }, submit: J, openOpenFileDialog: Z };
  return Object.assign({ mergedClsPrefix: i, draggerInsideRef: M, rtlEnabled: g, inputElRef: P, mergedTheme: f, dragOver: D, mergedMultiple: te, cssVars: l ? void 0 : fe, themeClass: oe == null ? void 0 : oe.themeClass, onRender: oe == null ? void 0 : oe.onRender, handleFileInputChange: q }, he);
}, render() {
  var r, i;
  const { draggerInsideRef: l, mergedClsPrefix: d, $slots: f, directory: g, onRender: p } = this;
  if (f.default && !this.abstract) {
    const C = f.default()[0];
    !((r = C == null ? void 0 : C.type) === null || r === void 0) && r[h1] && (l.value = true);
  }
  const s = B("input", Object.assign({}, this.inputProps, { ref: "inputElRef", type: "file", class: `${d}-upload-file-input`, accept: this.accept, multiple: this.mergedMultiple, onChange: this.handleFileInputChange, webkitdirectory: g || void 0, directory: g || void 0 }));
  return this.abstract ? B(Wr, null, (i = f.default) === null || i === void 0 ? void 0 : i.call(f), B(By, { to: "body" }, s)) : (p == null ? void 0 : p(), B("div", { class: [`${d}-upload`, this.rtlEnabled && `${d}-upload--rtl`, l.value && `${d}-upload--dragger-inside`, this.dragOver && `${d}-upload--drag-over`, this.themeClass], style: this.cssVars }, s, this.showTrigger && this.listType !== "image-card" && B(g1, null, f), this.showFileList && B(I6, null, f)));
} });
function $s() {
  const r = ur(Uy, null);
  return Ee(() => {
    if (r === null) return f_;
    const { mergedThemeRef: { value: i }, mergedThemeOverridesRef: { value: l } } = r, d = (i == null ? void 0 : i.common) || f_;
    return (l == null ? void 0 : l.common) ? Object.assign({}, d, l.common) : d;
  });
}
var np = { exports: {} };
/**
* MapLibre GL JS
* @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.11.0/LICENSE.txt
*/
var B6 = np.exports, ey;
function O6() {
  return ey || (ey = 1, (function(r, i) {
    (function(l, d) {
      r.exports = d();
    })(B6, (function() {
      var l = {}, d = {};
      function f(p, s, C) {
        if (d[p] = C, p === "index") {
          var P = "var sharedModule = {}; (" + d.shared + ")(sharedModule); (" + d.worker + ")(sharedModule);", M = {};
          return d.shared(M), d.index(l, M), typeof window < "u" && l.setWorkerUrl(window.URL.createObjectURL(new Blob([P], { type: "text/javascript" }))), l;
        }
      }
      f("shared", ["exports"], (function(p) {
        function s(o, t, n, u) {
          return new (n || (n = Promise))((function(h, y) {
            function b(I) {
              try {
                S(u.next(I));
              } catch (E) {
                y(E);
              }
            }
            function w(I) {
              try {
                S(u.throw(I));
              } catch (E) {
                y(E);
              }
            }
            function S(I) {
              var E;
              I.done ? h(I.value) : (E = I.value, E instanceof n ? E : new n((function(O) {
                O(E);
              }))).then(b, w);
            }
            S((u = u.apply(o, t || [])).next());
          }));
        }
        function C(o, t) {
          this.x = o, this.y = t;
        }
        function P(o) {
          return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
        }
        var M, D;
        typeof SuppressedError == "function" && SuppressedError, C.prototype = { clone() {
          return new C(this.x, this.y);
        }, add(o) {
          return this.clone()._add(o);
        }, sub(o) {
          return this.clone()._sub(o);
        }, multByPoint(o) {
          return this.clone()._multByPoint(o);
        }, divByPoint(o) {
          return this.clone()._divByPoint(o);
        }, mult(o) {
          return this.clone()._mult(o);
        }, div(o) {
          return this.clone()._div(o);
        }, rotate(o) {
          return this.clone()._rotate(o);
        }, rotateAround(o, t) {
          return this.clone()._rotateAround(o, t);
        }, matMult(o) {
          return this.clone()._matMult(o);
        }, unit() {
          return this.clone()._unit();
        }, perp() {
          return this.clone()._perp();
        }, round() {
          return this.clone()._round();
        }, mag() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals(o) {
          return this.x === o.x && this.y === o.y;
        }, dist(o) {
          return Math.sqrt(this.distSqr(o));
        }, distSqr(o) {
          const t = o.x - this.x, n = o.y - this.y;
          return t * t + n * n;
        }, angle() {
          return Math.atan2(this.y, this.x);
        }, angleTo(o) {
          return Math.atan2(this.y - o.y, this.x - o.x);
        }, angleWith(o) {
          return this.angleWithSep(o.x, o.y);
        }, angleWithSep(o, t) {
          return Math.atan2(this.x * t - this.y * o, this.x * o + this.y * t);
        }, _matMult(o) {
          const t = o[2] * this.x + o[3] * this.y;
          return this.x = o[0] * this.x + o[1] * this.y, this.y = t, this;
        }, _add(o) {
          return this.x += o.x, this.y += o.y, this;
        }, _sub(o) {
          return this.x -= o.x, this.y -= o.y, this;
        }, _mult(o) {
          return this.x *= o, this.y *= o, this;
        }, _div(o) {
          return this.x /= o, this.y /= o, this;
        }, _multByPoint(o) {
          return this.x *= o.x, this.y *= o.y, this;
        }, _divByPoint(o) {
          return this.x /= o.x, this.y /= o.y, this;
        }, _unit() {
          return this._div(this.mag()), this;
        }, _perp() {
          const o = this.y;
          return this.y = this.x, this.x = -o, this;
        }, _rotate(o) {
          const t = Math.cos(o), n = Math.sin(o), u = n * this.x + t * this.y;
          return this.x = t * this.x - n * this.y, this.y = u, this;
        }, _rotateAround(o, t) {
          const n = Math.cos(o), u = Math.sin(o), h = t.y + u * (this.x - t.x) + n * (this.y - t.y);
          return this.x = t.x + n * (this.x - t.x) - u * (this.y - t.y), this.y = h, this;
        }, _round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }, constructor: C }, C.convert = function(o) {
          if (o instanceof C) return o;
          if (Array.isArray(o)) return new C(+o[0], +o[1]);
          if (o.x !== void 0 && o.y !== void 0) return new C(+o.x, +o.y);
          throw new Error("Expected [x, y] or {x, y} point format");
        };
        var L = (function() {
          if (D) return M;
          function o(t, n, u, h) {
            this.cx = 3 * t, this.bx = 3 * (u - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (h - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = u, this.p2y = h;
          }
          return D = 1, M = o, o.prototype = { sampleCurveX: function(t) {
            return ((this.ax * t + this.bx) * t + this.cx) * t;
          }, sampleCurveY: function(t) {
            return ((this.ay * t + this.by) * t + this.cy) * t;
          }, sampleCurveDerivativeX: function(t) {
            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
          }, solveCurveX: function(t, n) {
            if (n === void 0 && (n = 1e-6), t < 0) return 0;
            if (t > 1) return 1;
            for (var u = t, h = 0; h < 8; h++) {
              var y = this.sampleCurveX(u) - t;
              if (Math.abs(y) < n) return u;
              var b = this.sampleCurveDerivativeX(u);
              if (Math.abs(b) < 1e-6) break;
              u -= y / b;
            }
            var w = 0, S = 1;
            for (u = t, h = 0; h < 20 && (y = this.sampleCurveX(u), !(Math.abs(y - t) < n)); h++) t > y ? w = u : S = u, u = 0.5 * (S - w) + w;
            return u;
          }, solve: function(t, n) {
            return this.sampleCurveY(this.solveCurveX(t, n));
          } }, M;
        })(), $ = P(L);
        let z, F;
        function Z() {
          return z == null && (z = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), z;
        }
        function q() {
          if (F == null && (F = false, Z())) {
            const t = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: true });
            if (t) {
              for (let u = 0; u < 25; u++) {
                const h = 4 * u;
                t.fillStyle = `rgb(${h},${h + 1},${h + 2})`, t.fillRect(u % 5, Math.floor(u / 5), 1, 1);
              }
              const n = t.getImageData(0, 0, 5, 5).data;
              for (let u = 0; u < 100; u++) if (u % 4 != 3 && n[u] !== u) {
                F = true;
                break;
              }
            }
          }
          return F || false;
        }
        var K = 1e-6, te = typeof Float32Array < "u" ? Float32Array : Array;
        function re() {
          var o = new te(9);
          return te != Float32Array && (o[1] = 0, o[2] = 0, o[3] = 0, o[5] = 0, o[6] = 0, o[7] = 0), o[0] = 1, o[4] = 1, o[8] = 1, o;
        }
        function ie(o) {
          return o[0] = 1, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = 1, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 1, o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, o;
        }
        function J() {
          var o = new te(3);
          return te != Float32Array && (o[0] = 0, o[1] = 0, o[2] = 0), o;
        }
        function we(o) {
          var t = o[0], n = o[1], u = o[2];
          return Math.sqrt(t * t + n * n + u * u);
        }
        function fe(o, t, n) {
          var u = new te(3);
          return u[0] = o, u[1] = t, u[2] = n, u;
        }
        function oe(o, t, n) {
          return o[0] = t[0] + n[0], o[1] = t[1] + n[1], o[2] = t[2] + n[2], o;
        }
        function he(o, t, n) {
          return o[0] = t[0] * n, o[1] = t[1] * n, o[2] = t[2] * n, o;
        }
        function _e(o, t, n) {
          var u = t[0], h = t[1], y = t[2], b = n[0], w = n[1], S = n[2];
          return o[0] = h * S - y * w, o[1] = y * b - u * S, o[2] = u * w - h * b, o;
        }
        var Ue, qe = we;
        function tt(o, t, n) {
          var u = t[0], h = t[1], y = t[2], b = t[3];
          return o[0] = n[0] * u + n[4] * h + n[8] * y + n[12] * b, o[1] = n[1] * u + n[5] * h + n[9] * y + n[13] * b, o[2] = n[2] * u + n[6] * h + n[10] * y + n[14] * b, o[3] = n[3] * u + n[7] * h + n[11] * y + n[15] * b, o;
        }
        function ut() {
          var o = new te(4);
          return te != Float32Array && (o[0] = 0, o[1] = 0, o[2] = 0), o[3] = 1, o;
        }
        function mt(o, t, n, u) {
          var h = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "zyx", y = Math.PI / 360;
          t *= y, u *= y, n *= y;
          var b = Math.sin(t), w = Math.cos(t), S = Math.sin(n), I = Math.cos(n), E = Math.sin(u), O = Math.cos(u);
          switch (h) {
            case "xyz":
              o[0] = b * I * O + w * S * E, o[1] = w * S * O - b * I * E, o[2] = w * I * E + b * S * O, o[3] = w * I * O - b * S * E;
              break;
            case "xzy":
              o[0] = b * I * O - w * S * E, o[1] = w * S * O - b * I * E, o[2] = w * I * E + b * S * O, o[3] = w * I * O + b * S * E;
              break;
            case "yxz":
              o[0] = b * I * O + w * S * E, o[1] = w * S * O - b * I * E, o[2] = w * I * E - b * S * O, o[3] = w * I * O + b * S * E;
              break;
            case "yzx":
              o[0] = b * I * O + w * S * E, o[1] = w * S * O + b * I * E, o[2] = w * I * E - b * S * O, o[3] = w * I * O - b * S * E;
              break;
            case "zxy":
              o[0] = b * I * O - w * S * E, o[1] = w * S * O + b * I * E, o[2] = w * I * E + b * S * O, o[3] = w * I * O - b * S * E;
              break;
            case "zyx":
              o[0] = b * I * O - w * S * E, o[1] = w * S * O + b * I * E, o[2] = w * I * E - b * S * O, o[3] = w * I * O + b * S * E;
              break;
            default:
              throw new Error("Unknown angle order " + h);
          }
          return o;
        }
        function St() {
          var o = new te(2);
          return te != Float32Array && (o[0] = 0, o[1] = 0), o;
        }
        function st(o, t) {
          var n = new te(2);
          return n[0] = o, n[1] = t, n;
        }
        J(), Ue = new te(4), te != Float32Array && (Ue[0] = 0, Ue[1] = 0, Ue[2] = 0, Ue[3] = 0), J(), fe(1, 0, 0), fe(0, 1, 0), ut(), ut(), re(), St();
        const nt = 8192;
        function ft(o, t, n) {
          return t * (nt / (o.tileSize * Math.pow(2, n - o.tileID.overscaledZ)));
        }
        function Lt(o, t) {
          return (o % t + t) % t;
        }
        function pt(o, t, n) {
          return o * (1 - n) + t * n;
        }
        function wt(o) {
          if (o <= 0) return 0;
          if (o >= 1) return 1;
          const t = o * o, n = t * o;
          return 4 * (o < 0.5 ? n : 3 * (o - t) + n - 0.75);
        }
        function Ft(o, t, n, u) {
          const h = new $(o, t, n, u);
          return (y) => h.solve(y);
        }
        const tr = Ft(0.25, 0.1, 0.25, 1);
        function gt(o, t, n) {
          return Math.min(n, Math.max(t, o));
        }
        function Bt(o, t, n) {
          const u = n - t, h = ((o - t) % u + u) % u + t;
          return h === t ? n : h;
        }
        function Zt(o, ...t) {
          for (const n of t) for (const u in n) o[u] = n[u];
          return o;
        }
        let ir = 1;
        function Cr(o, t, n) {
          const u = {};
          for (const h in o) u[h] = t.call(this, o[h], h, o);
          return u;
        }
        function Ar(o, t, n) {
          const u = {};
          for (const h in o) t.call(this, o[h], h, o) && (u[h] = o[h]);
          return u;
        }
        function or(o) {
          return Array.isArray(o) ? o.map(or) : typeof o == "object" && o ? Cr(o, or) : o;
        }
        const Tr = {};
        function Xt(o) {
          Tr[o] || (typeof console < "u" && console.warn(o), Tr[o] = true);
        }
        function Dr(o, t, n) {
          return (n.y - o.y) * (t.x - o.x) > (t.y - o.y) * (n.x - o.x);
        }
        function nr(o) {
          return typeof WorkerGlobalScope < "u" && o !== void 0 && o instanceof WorkerGlobalScope;
        }
        let kt = null;
        function ze(o) {
          if (kt == null) {
            const t = o.navigator ? o.navigator.userAgent : null;
            kt = !!o.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")));
          }
          return kt;
        }
        function at(o) {
          return typeof ImageBitmap < "u" && o instanceof ImageBitmap;
        }
        const Oe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function Je(o, t, n, u, h) {
          return s(this, void 0, void 0, (function* () {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const y = new VideoFrame(o, { timestamp: 0 });
            try {
              const b = y == null ? void 0 : y.format;
              if (!b || !b.startsWith("BGR") && !b.startsWith("RGB")) throw new Error(`Unrecognized format ${b}`);
              const w = b.startsWith("BGR"), S = new Uint8ClampedArray(u * h * 4);
              if (yield y.copyTo(S, (function(I, E, O, V, U) {
                const W = 4 * Math.max(-E, 0), ee = (Math.max(0, O) - O) * V * 4 + W, se = 4 * V, pe = Math.max(0, E), je = Math.max(0, O);
                return { rect: { x: pe, y: je, width: Math.min(I.width, E + V) - pe, height: Math.min(I.height, O + U) - je }, layout: [{ offset: ee, stride: se }] };
              })(o, t, n, u, h)), w) for (let I = 0; I < S.length; I += 4) {
                const E = S[I];
                S[I] = S[I + 2], S[I + 2] = E;
              }
              return S;
            } finally {
              y.close();
            }
          }));
        }
        let ht, bt;
        function rt(o, t, n, u) {
          return o.addEventListener(t, n, u), { unsubscribe: () => {
            o.removeEventListener(t, n, u);
          } };
        }
        function vt(o) {
          return o * Math.PI / 180;
        }
        function Wt(o) {
          return o / Math.PI * 180;
        }
        const ci = { touchstart: true, touchmove: true, touchmoveWindow: true, touchend: true, touchcancel: true }, Ai = { dblclick: true, click: true, mouseover: true, mouseout: true, mousedown: true, mousemove: true, mousemoveWindow: true, mouseup: true, mouseupWindow: true, contextmenu: true, wheel: true }, sn = "AbortError";
        function Fe() {
          return new Error(sn);
        }
        const X = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function Y(o) {
          return X.REGISTERED_PROTOCOLS[o.substring(0, o.indexOf("://"))];
        }
        const ne = "global-dispatcher";
        class ve extends Error {
          constructor(t, n, u, h) {
            super(`AJAXError: ${n} (${t}): ${u}`), this.status = t, this.statusText = n, this.url = u, this.body = h;
          }
        }
        const Ce = () => nr(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, ae = function(o, t) {
          if (/:\/\//.test(o.url) && !/^https?:|^file:/.test(o.url)) {
            const u = Y(o.url);
            if (u) return u(o, t);
            if (nr(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: o, targetMapId: ne }, t);
          }
          if (!(/^file:/.test(n = o.url) || /^file:/.test(Ce()) && !/^\w+:/.test(n))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(u, h) {
              return s(this, void 0, void 0, (function* () {
                const y = new Request(u.url, { method: u.method || "GET", body: u.body, credentials: u.credentials, headers: u.headers, cache: u.cache, referrer: Ce(), signal: h.signal });
                let b, w;
                u.type !== "json" || y.headers.has("Accept") || y.headers.set("Accept", "application/json");
                try {
                  b = yield fetch(y);
                } catch (I) {
                  throw new ve(0, I.message, u.url, new Blob());
                }
                if (!b.ok) {
                  const I = yield b.blob();
                  throw new ve(b.status, b.statusText, u.url, I);
                }
                w = u.type === "arrayBuffer" || u.type === "image" ? b.arrayBuffer() : u.type === "json" ? b.json() : b.text();
                const S = yield w;
                if (h.signal.aborted) throw Fe();
                return { data: S, cacheControl: b.headers.get("Cache-Control"), expires: b.headers.get("Expires") };
              }));
            })(o, t);
            if (nr(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: o, mustQueue: true, targetMapId: ne }, t);
          }
          var n;
          return (function(u, h) {
            return new Promise(((y, b) => {
              var w;
              const S = new XMLHttpRequest();
              S.open(u.method || "GET", u.url, true), u.type !== "arrayBuffer" && u.type !== "image" || (S.responseType = "arraybuffer");
              for (const I in u.headers) S.setRequestHeader(I, u.headers[I]);
              u.type === "json" && (S.responseType = "text", !((w = u.headers) === null || w === void 0) && w.Accept || S.setRequestHeader("Accept", "application/json")), S.withCredentials = u.credentials === "include", S.onerror = () => {
                b(new Error(S.statusText));
              }, S.onload = () => {
                if (!h.signal.aborted) if ((S.status >= 200 && S.status < 300 || S.status === 0) && S.response !== null) {
                  let I = S.response;
                  if (u.type === "json") try {
                    I = JSON.parse(S.response);
                  } catch (E) {
                    return void b(E);
                  }
                  y({ data: I, cacheControl: S.getResponseHeader("Cache-Control"), expires: S.getResponseHeader("Expires") });
                } else {
                  const I = new Blob([S.response], { type: S.getResponseHeader("Content-Type") });
                  b(new ve(S.status, S.statusText, u.url, I));
                }
              }, h.signal.addEventListener("abort", (() => {
                S.abort(), b(Fe());
              })), S.send(u.body);
            }));
          })(o, t);
        };
        function Pe(o) {
          if (!o || o.indexOf("://") <= 0 || o.indexOf("data:image/") === 0 || o.indexOf("blob:") === 0) return true;
          const t = new URL(o), n = window.location;
          return t.protocol === n.protocol && t.host === n.host;
        }
        function xe(o, t, n) {
          n[o] && n[o].indexOf(t) !== -1 || (n[o] = n[o] || [], n[o].push(t));
        }
        function Ve(o, t, n) {
          if (n && n[o]) {
            const u = n[o].indexOf(t);
            u !== -1 && n[o].splice(u, 1);
          }
        }
        class et {
          constructor(t, n = {}) {
            Zt(this, n), this.type = t;
          }
        }
        class We extends et {
          constructor(t, n = {}) {
            super("error", Zt({ error: t }, n));
          }
        }
        class xt {
          on(t, n) {
            return this._listeners = this._listeners || {}, xe(t, n, this._listeners), { unsubscribe: () => {
              this.off(t, n);
            } };
          }
          off(t, n) {
            return Ve(t, n, this._listeners), Ve(t, n, this._oneTimeListeners), this;
          }
          once(t, n) {
            return n ? (this._oneTimeListeners = this._oneTimeListeners || {}, xe(t, n, this._oneTimeListeners), this) : new Promise(((u) => this.once(t, u)));
          }
          fire(t, n) {
            typeof t == "string" && (t = new et(t, n || {}));
            const u = t.type;
            if (this.listens(u)) {
              t.target = this;
              const h = this._listeners && this._listeners[u] ? this._listeners[u].slice() : [];
              for (const w of h) w.call(this, t);
              const y = this._oneTimeListeners && this._oneTimeListeners[u] ? this._oneTimeListeners[u].slice() : [];
              for (const w of y) Ve(u, w, this._oneTimeListeners), w.call(this, t);
              const b = this._eventedParent;
              b && (Zt(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), b.fire(t));
            } else t instanceof We && console.error(t.error);
            return this;
          }
          listens(t) {
            return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t);
          }
          setEventedParent(t, n) {
            return this._eventedParent = t, this._eventedParentData = n, this;
          }
        }
        var Le = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, "font-faces": { type: "array", value: "fontFaces" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, encoding: { type: "enum", values: { mvt: {}, mlt: {} }, default: "mvt" }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, "color-relief": {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_color-relief": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: false, expression: { interpolated: true, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, "paint_color-relief": { "color-relief-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "color-relief-color": { type: "color", transition: false, expression: { interpolated: true, parameters: ["elevation"] }, "property-type": "color-ramp" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        const rr = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function Zr(o, t) {
          const n = {};
          for (const u in o) u !== "ref" && (n[u] = o[u]);
          return rr.forEach(((u) => {
            u in t && (n[u] = t[u]);
          })), n;
        }
        function Ut(o, t) {
          if (Array.isArray(o)) {
            if (!Array.isArray(t) || o.length !== t.length) return false;
            for (let n = 0; n < o.length; n++) if (!Ut(o[n], t[n])) return false;
            return true;
          }
          if (typeof o == "object" && o !== null && t !== null) {
            if (typeof t != "object" || Object.keys(o).length !== Object.keys(t).length) return false;
            for (const n in o) if (!Ut(o[n], t[n])) return false;
            return true;
          }
          return o === t;
        }
        function dr(o, t) {
          o.push(t);
        }
        function Er(o, t, n) {
          dr(n, { command: "addSource", args: [o, t[o]] });
        }
        function jr(o, t, n) {
          dr(t, { command: "removeSource", args: [o] }), n[o] = true;
        }
        function di(o, t, n, u) {
          jr(o, n, u), Er(o, t, n);
        }
        function Hr(o, t, n) {
          let u;
          for (u in o[n]) if (Object.prototype.hasOwnProperty.call(o[n], u) && u !== "data" && !Ut(o[n][u], t[n][u])) return false;
          for (u in t[n]) if (Object.prototype.hasOwnProperty.call(t[n], u) && u !== "data" && !Ut(o[n][u], t[n][u])) return false;
          return true;
        }
        function Jr(o, t, n, u, h, y) {
          o = o || {}, t = t || {};
          for (const b in o) Object.prototype.hasOwnProperty.call(o, b) && (Ut(o[b], t[b]) || n.push({ command: y, args: [u, b, t[b], h] }));
          for (const b in t) Object.prototype.hasOwnProperty.call(t, b) && !Object.prototype.hasOwnProperty.call(o, b) && (Ut(o[b], t[b]) || n.push({ command: y, args: [u, b, t[b], h] }));
        }
        function Lr(o) {
          return o.id;
        }
        function Ne(o, t) {
          return o[t.id] = t, o;
        }
        class Te {
          constructor(t, n, u, h) {
            this.message = (t ? `${t}: ` : "") + u, h && (this.identifier = h), n != null && n.__line__ && (this.line = n.__line__);
          }
        }
        function jt(o, ...t) {
          for (const n of t) for (const u in n) o[u] = n[u];
          return o;
        }
        class _r extends Error {
          constructor(t, n) {
            super(n), this.message = n, this.key = t;
          }
        }
        class Nr {
          constructor(t, n = []) {
            this.parent = t, this.bindings = {};
            for (const [u, h] of n) this.bindings[u] = h;
          }
          concat(t) {
            return new Nr(this, t);
          }
          get(t) {
            if (this.bindings[t]) return this.bindings[t];
            if (this.parent) return this.parent.get(t);
            throw new Error(`${t} not found in scope.`);
          }
          has(t) {
            return !!this.bindings[t] || !!this.parent && this.parent.has(t);
          }
        }
        const mr = { kind: "null" }, Ct = { kind: "number" }, ar = { kind: "string" }, lr = { kind: "boolean" }, Bi = { kind: "color" }, jn = { kind: "projectionDefinition" }, In = { kind: "object" }, hr = { kind: "value" }, Ao = { kind: "collator" }, no = { kind: "formatted" }, Mn = { kind: "padding" }, Hn = { kind: "colorArray" }, Xn = { kind: "numberArray" }, En = { kind: "resolvedImage" }, ls = { kind: "variableAnchorOffsetCollection" };
        function Vi(o, t) {
          return { kind: "array", itemType: o, N: t };
        }
        function ti(o) {
          if (o.kind === "array") {
            const t = ti(o.itemType);
            return typeof o.N == "number" ? `array<${t}, ${o.N}>` : o.itemType.kind === "value" ? "array" : `array<${t}>`;
          }
          return o.kind;
        }
        const ia = [mr, Ct, ar, lr, Bi, jn, no, In, Vi(hr), Mn, Xn, Hn, En, ls];
        function Do(o, t) {
          if (t.kind === "error") return null;
          if (o.kind === "array") {
            if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !Do(o.itemType, t.itemType)) && (typeof o.N != "number" || o.N === t.N)) return null;
          } else {
            if (o.kind === t.kind) return null;
            if (o.kind === "value") {
              for (const n of ia) if (!Do(n, t)) return null;
            }
          }
          return `Expected ${ti(o)} but found ${ti(t)} instead.`;
        }
        function xi(o, t) {
          return t.some(((n) => n.kind === o.kind));
        }
        function zo(o, t) {
          return t.some(((n) => n === "null" ? o === null : n === "array" ? Array.isArray(o) : n === "object" ? o && !Array.isArray(o) && typeof o == "object" : n === typeof o));
        }
        function oo(o, t) {
          return o.kind === "array" && t.kind === "array" ? o.itemType.kind === t.itemType.kind && typeof o.N == "number" : o.kind === t.kind;
        }
        const na = 0.96422, Gs = 0.82521, Ul = 4 / 29, oa = 6 / 29, qs = 3 * oa * oa, Cc = oa * oa * oa, Gl = Math.PI / 180, Sc = 180 / Math.PI;
        function ql(o) {
          return (o %= 360) < 0 && (o += 360), o;
        }
        function Wl([o, t, n, u]) {
          let h, y;
          const b = Zs((0.2225045 * (o = Ws(o)) + 0.7168786 * (t = Ws(t)) + 0.0606169 * (n = Ws(n))) / 1);
          o === t && t === n ? h = y = b : (h = Zs((0.4360747 * o + 0.3850649 * t + 0.1430804 * n) / na), y = Zs((0.0139322 * o + 0.0971045 * t + 0.7141733 * n) / Gs));
          const w = 116 * b - 16;
          return [w < 0 ? 0 : w, 500 * (h - b), 200 * (b - y), u];
        }
        function Ws(o) {
          return o <= 0.04045 ? o / 12.92 : Math.pow((o + 0.055) / 1.055, 2.4);
        }
        function Zs(o) {
          return o > Cc ? Math.pow(o, 1 / 3) : o / qs + Ul;
        }
        function Zl([o, t, n, u]) {
          let h = (o + 16) / 116, y = isNaN(t) ? h : h + t / 500, b = isNaN(n) ? h : h - n / 200;
          return h = 1 * us(h), y = na * us(y), b = Gs * us(b), [Hs(3.1338561 * y - 1.6168667 * h - 0.4906146 * b), Hs(-0.9787684 * y + 1.9161415 * h + 0.033454 * b), Hs(0.0719453 * y - 0.2289914 * h + 1.4052427 * b), u];
        }
        function Hs(o) {
          return (o = o <= 304e-5 ? 12.92 * o : 1.055 * Math.pow(o, 1 / 2.4) - 0.055) < 0 ? 0 : o > 1 ? 1 : o;
        }
        function us(o) {
          return o > oa ? o * o * o : qs * (o - Ul);
        }
        const Ia = Object.hasOwn || function(o, t) {
          return Object.prototype.hasOwnProperty.call(o, t);
        };
        function Ma(o, t) {
          return Ia(o, t) ? o[t] : void 0;
        }
        function cs(o) {
          return parseInt(o.padEnd(2, o), 16) / 255;
        }
        function aa(o, t) {
          return sa(t ? o / 100 : o, 0, 1);
        }
        function sa(o, t, n) {
          return Math.min(Math.max(t, o), n);
        }
        function Hl(o) {
          return !o.some(Number.isNaN);
        }
        const kc = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        function ao(o, t, n) {
          return o + n * (t - o);
        }
        function Fo(o, t, n) {
          return o.map(((u, h) => ao(u, t[h], n)));
        }
        class fr {
          constructor(t, n, u, h = 1, y = true) {
            this.r = t, this.g = n, this.b = u, this.a = h, y || (this.r *= h, this.g *= h, this.b *= h, h || this.overwriteGetter("rgb", [t, n, u, h]));
          }
          static parse(t) {
            if (t instanceof fr) return t;
            if (typeof t != "string") return;
            const n = (function(u) {
              if ((u = u.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const h = Ma(kc, u);
              if (h) {
                const [b, w, S] = h;
                return [b / 255, w / 255, S / 255, 1];
              }
              if (u.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(u)) {
                const b = u.length < 6 ? 1 : 2;
                let w = 1;
                return [cs(u.slice(w, w += b)), cs(u.slice(w, w += b)), cs(u.slice(w, w += b)), cs(u.slice(w, w + b) || "ff")];
              }
              if (u.startsWith("rgb")) {
                const b = u.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (b) {
                  const [w, S, I, E, O, V, U, W, ee, se, pe, je] = b, be = [E || " ", U || " ", se].join("");
                  if (be === "  " || be === "  /" || be === ",," || be === ",,,") {
                    const Me = [I, V, ee].join(""), Xe = Me === "%%%" ? 100 : Me === "" ? 255 : 0;
                    if (Xe) {
                      const it = [sa(+S / Xe, 0, 1), sa(+O / Xe, 0, 1), sa(+W / Xe, 0, 1), pe ? aa(+pe, je) : 1];
                      if (Hl(it)) return it;
                    }
                  }
                  return;
                }
              }
              const y = u.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (y) {
                const [b, w, S, I, E, O, V, U, W] = y, ee = [S || " ", E || " ", V].join("");
                if (ee === "  " || ee === "  /" || ee === ",," || ee === ",,,") {
                  const se = [+w, sa(+I, 0, 100), sa(+O, 0, 100), U ? aa(+U, W) : 1];
                  if (Hl(se)) return (function([pe, je, be, Me]) {
                    function Xe(it) {
                      const _t = (it + pe / 30) % 12, At = je * Math.min(be, 1 - be);
                      return be - At * Math.max(-1, Math.min(_t - 3, 9 - _t, 1));
                    }
                    return pe = ql(pe), je /= 100, be /= 100, [Xe(0), Xe(8), Xe(4), Me];
                  })(se);
                }
              }
            })(t);
            return n ? new fr(...n, false) : void 0;
          }
          get rgb() {
            const { r: t, g: n, b: u, a: h } = this, y = h || 1 / 0;
            return this.overwriteGetter("rgb", [t / y, n / y, u / y, h]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(t) {
              const [n, u, h, y] = Wl(t), b = Math.sqrt(u * u + h * h);
              return [Math.round(1e4 * b) ? ql(Math.atan2(h, u) * Sc) : NaN, b, n, y];
            })(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", Wl(this.rgb));
          }
          overwriteGetter(t, n) {
            return Object.defineProperty(this, t, { value: n }), n;
          }
          toString() {
            const [t, n, u, h] = this.rgb;
            return `rgba(${[t, n, u].map(((y) => Math.round(255 * y))).join(",")},${h})`;
          }
          static interpolate(t, n, u, h = "rgb") {
            switch (h) {
              case "rgb": {
                const [y, b, w, S] = Fo(t.rgb, n.rgb, u);
                return new fr(y, b, w, S, false);
              }
              case "hcl": {
                const [y, b, w, S] = t.hcl, [I, E, O, V] = n.hcl;
                let U, W;
                if (isNaN(y) || isNaN(I)) isNaN(y) ? isNaN(I) ? U = NaN : (U = I, w !== 1 && w !== 0 || (W = E)) : (U = y, O !== 1 && O !== 0 || (W = b));
                else {
                  let be = I - y;
                  I > y && be > 180 ? be -= 360 : I < y && y - I > 180 && (be += 360), U = y + u * be;
                }
                const [ee, se, pe, je] = (function([be, Me, Xe, it]) {
                  return be = isNaN(be) ? 0 : be * Gl, Zl([Xe, Math.cos(be) * Me, Math.sin(be) * Me, it]);
                })([U, W ?? ao(b, E, u), ao(w, O, u), ao(S, V, u)]);
                return new fr(ee, se, pe, je, false);
              }
              case "lab": {
                const [y, b, w, S] = Zl(Fo(t.lab, n.lab, u));
                return new fr(y, b, w, S, false);
              }
            }
          }
        }
        fr.black = new fr(0, 0, 0, 1), fr.white = new fr(1, 1, 1, 1), fr.transparent = new fr(0, 0, 0, 0), fr.red = new fr(1, 0, 0, 1);
        class Ir {
          constructor(t, n, u) {
            this.sensitivity = t ? n ? "variant" : "case" : n ? "accent" : "base", this.locale = u, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t, n) {
            return this.collator.compare(t, n);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        const ds = ["bottom", "center", "top"];
        class Co {
          constructor(t, n, u, h, y, b) {
            this.text = t, this.image = n, this.scale = u, this.fontStack = h, this.textColor = y, this.verticalAlign = b;
          }
        }
        class Rn {
          constructor(t) {
            this.sections = t;
          }
          static fromString(t) {
            return new Rn([new Co(t, null, null, null, null, null)]);
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some(((t) => t.text.length !== 0 || t.image && t.image.name.length !== 0));
          }
          static factory(t) {
            return t instanceof Rn ? t : Rn.fromString(t);
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map(((t) => t.text)).join("");
          }
        }
        class ln {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof ln) return t;
            if (typeof t == "number") return new ln([t, t, t, t]);
            if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
              for (const n of t) if (typeof n != "number") return;
              switch (t.length) {
                case 1:
                  t = [t[0], t[0], t[0], t[0]];
                  break;
                case 2:
                  t = [t[0], t[1], t[0], t[1]];
                  break;
                case 3:
                  t = [t[0], t[1], t[2], t[1]];
              }
              return new ln(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, u) {
            return new ln(Fo(t.values, n.values, u));
          }
        }
        class Qi {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof Qi) return t;
            if (typeof t == "number") return new Qi([t]);
            if (Array.isArray(t)) {
              for (const n of t) if (typeof n != "number") return;
              return new Qi(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, u) {
            return new Qi(Fo(t.values, n.values, u));
          }
        }
        class Pi {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof Pi) return t;
            if (typeof t == "string") {
              const u = fr.parse(t);
              return u ? new Pi([u]) : void 0;
            }
            if (!Array.isArray(t)) return;
            const n = [];
            for (const u of t) {
              if (typeof u != "string") return;
              const h = fr.parse(u);
              if (!h) return;
              n.push(h);
            }
            return new Pi(n);
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, u, h = "rgb") {
            const y = [];
            if (t.values.length != n.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${n.values.length}), cannot interpolate.`);
            for (let b = 0; b < t.values.length; b++) y.push(fr.interpolate(t.values[b], n.values[b], u, h));
            return new Pi(y);
          }
        }
        class ri extends Error {
          constructor(t) {
            super(t), this.name = "RuntimeError";
          }
          toJSON() {
            return this.message;
          }
        }
        const yh = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class un {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof un) return t;
            if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
              for (let n = 0; n < t.length; n += 2) {
                const u = t[n], h = t[n + 1];
                if (typeof u != "string" || !yh.has(u) || !Array.isArray(h) || h.length !== 2 || typeof h[0] != "number" || typeof h[1] != "number") return;
              }
              return new un(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, u) {
            const h = t.values, y = n.values;
            if (h.length !== y.length) throw new ri(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${n.toString()}`);
            const b = [];
            for (let w = 0; w < h.length; w += 2) {
              if (h[w] !== y[w]) throw new ri(`Cannot interpolate values containing mismatched anchors. from[${w}]: ${h[w]}, to[${w}]: ${y[w]}`);
              b.push(h[w]);
              const [S, I] = h[w + 1], [E, O] = y[w + 1];
              b.push([ao(S, E, u), ao(I, O, u)]);
            }
            return new un(b);
          }
        }
        class gn {
          constructor(t) {
            this.name = t.name, this.available = t.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t) {
            return t ? new gn({ name: t, available: false }) : null;
          }
        }
        class Nn {
          constructor(t, n, u) {
            this.from = t, this.to = n, this.transition = u;
          }
          static interpolate(t, n, u) {
            return new Nn(t, n, u);
          }
          static parse(t) {
            return t instanceof Nn ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new Nn(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new Nn(t.from, t.to, t.transition) : typeof t == "string" ? new Nn(t, t, 1) : void 0;
          }
        }
        function Xs(o, t, n, u) {
          return typeof o == "number" && o >= 0 && o <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof n == "number" && n >= 0 && n <= 255 ? u === void 0 || typeof u == "number" && u >= 0 && u <= 1 ? null : `Invalid rgba value [${[o, t, n, u].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof u == "number" ? [o, t, n, u] : [o, t, n]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function So(o) {
          if (o === null || typeof o == "string" || typeof o == "boolean" || typeof o == "number" || o instanceof Nn || o instanceof fr || o instanceof Ir || o instanceof Rn || o instanceof ln || o instanceof Qi || o instanceof Pi || o instanceof un || o instanceof gn) return true;
          if (Array.isArray(o)) {
            for (const t of o) if (!So(t)) return false;
            return true;
          }
          if (typeof o == "object") {
            for (const t in o) if (!So(o[t])) return false;
            return true;
          }
          return false;
        }
        function wi(o) {
          if (o === null) return mr;
          if (typeof o == "string") return ar;
          if (typeof o == "boolean") return lr;
          if (typeof o == "number") return Ct;
          if (o instanceof fr) return Bi;
          if (o instanceof Nn) return jn;
          if (o instanceof Ir) return Ao;
          if (o instanceof Rn) return no;
          if (o instanceof ln) return Mn;
          if (o instanceof Qi) return Xn;
          if (o instanceof Pi) return Hn;
          if (o instanceof un) return ls;
          if (o instanceof gn) return En;
          if (Array.isArray(o)) {
            const t = o.length;
            let n;
            for (const u of o) {
              const h = wi(u);
              if (n) {
                if (n === h) continue;
                n = hr;
                break;
              }
              n = h;
            }
            return Vi(n || hr, t);
          }
          return In;
        }
        function hs(o) {
          const t = typeof o;
          return o === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(o) : o instanceof fr || o instanceof Nn || o instanceof Rn || o instanceof ln || o instanceof Qi || o instanceof Pi || o instanceof un || o instanceof gn ? o.toString() : JSON.stringify(o);
        }
        class la {
          constructor(t, n) {
            this.type = t, this.value = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (!So(t[1])) return n.error("invalid value");
            const u = t[1];
            let h = wi(u);
            const y = n.expectedType;
            return h.kind !== "array" || h.N !== 0 || !y || y.kind !== "array" || typeof y.N == "number" && y.N !== 0 || (h = y), new la(h, u);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        const Ea = { string: ar, number: Ct, boolean: lr, object: In };
        class zr {
          constructor(t, n) {
            this.type = t, this.args = n;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            let u, h = 1;
            const y = t[0];
            if (y === "array") {
              let w, S;
              if (t.length > 2) {
                const I = t[1];
                if (typeof I != "string" || !(I in Ea) || I === "object") return n.error('The item type argument of "array" must be one of string, number, boolean', 1);
                w = Ea[I], h++;
              } else w = hr;
              if (t.length > 3) {
                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return n.error('The length argument to "array" must be a positive integer literal', 2);
                S = t[2], h++;
              }
              u = Vi(w, S);
            } else {
              if (!Ea[y]) throw new Error(`Types doesn't contain name = ${y}`);
              u = Ea[y];
            }
            const b = [];
            for (; h < t.length; h++) {
              const w = n.parse(t[h], h, hr);
              if (!w) return null;
              b.push(w);
            }
            return new zr(u, b);
          }
          evaluate(t) {
            for (let n = 0; n < this.args.length; n++) {
              const u = this.args[n].evaluate(t);
              if (!Do(this.type, wi(u))) return u;
              if (n === this.args.length - 1) throw new ri(`Expected value to be of type ${ti(this.type)}, but found ${ti(wi(u))} instead.`);
            }
            throw new Error();
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        const Xl = { "to-boolean": lr, "to-color": Bi, "to-number": Ct, "to-string": ar };
        class xr {
          constructor(t, n) {
            this.type = t, this.args = n;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            const u = t[0];
            if (!Xl[u]) throw new Error(`Can't parse ${u} as it is not part of the known types`);
            if ((u === "to-boolean" || u === "to-string") && t.length !== 2) return n.error("Expected one argument.");
            const h = Xl[u], y = [];
            for (let b = 1; b < t.length; b++) {
              const w = n.parse(t[b], b, hr);
              if (!w) return null;
              y.push(w);
            }
            return new xr(h, y);
          }
          evaluate(t) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(t);
              case "color": {
                let n, u;
                for (const h of this.args) {
                  if (n = h.evaluate(t), u = null, n instanceof fr) return n;
                  if (typeof n == "string") {
                    const y = t.parseColor(n);
                    if (y) return y;
                  } else if (Array.isArray(n) && (u = n.length < 3 || n.length > 4 ? `Invalid rgba value ${JSON.stringify(n)}: expected an array containing either three or four numeric values.` : Xs(n[0], n[1], n[2], n[3]), !u)) return new fr(n[0] / 255, n[1] / 255, n[2] / 255, n[3]);
                }
                throw new ri(u || `Could not parse color from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "padding": {
                let n;
                for (const u of this.args) {
                  n = u.evaluate(t);
                  const h = ln.parse(n);
                  if (h) return h;
                }
                throw new ri(`Could not parse padding from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "numberArray": {
                let n;
                for (const u of this.args) {
                  n = u.evaluate(t);
                  const h = Qi.parse(n);
                  if (h) return h;
                }
                throw new ri(`Could not parse numberArray from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "colorArray": {
                let n;
                for (const u of this.args) {
                  n = u.evaluate(t);
                  const h = Pi.parse(n);
                  if (h) return h;
                }
                throw new ri(`Could not parse colorArray from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let n;
                for (const u of this.args) {
                  n = u.evaluate(t);
                  const h = un.parse(n);
                  if (h) return h;
                }
                throw new ri(`Could not parse variableAnchorOffsetCollection from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "number": {
                let n = null;
                for (const u of this.args) {
                  if (n = u.evaluate(t), n === null) return 0;
                  const h = Number(n);
                  if (!isNaN(h)) return h;
                }
                throw new ri(`Could not convert ${JSON.stringify(n)} to number.`);
              }
              case "formatted":
                return Rn.fromString(hs(this.args[0].evaluate(t)));
              case "resolvedImage":
                return gn.fromString(hs(this.args[0].evaluate(t)));
              case "projectionDefinition":
                return this.args[0].evaluate(t);
              default:
                return hs(this.args[0].evaluate(t));
            }
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        const br = ["Unknown", "Point", "LineString", "Polygon"];
        class Yl {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? br[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(t) {
            let n = this._parseColorCache.get(t);
            return n || (n = fr.parse(t), this._parseColorCache.set(t, n)), n;
          }
        }
        class Rr {
          constructor(t, n, u = [], h, y = new Nr(), b = []) {
            this.registry = t, this.path = u, this.key = u.map(((w) => `[${w}]`)).join(""), this.scope = y, this.errors = b, this.expectedType = h, this._isConstant = n;
          }
          parse(t, n, u, h, y = {}) {
            return n ? this.concat(n, u, h)._parse(t, y) : this._parse(t, y);
          }
          _parse(t, n) {
            function u(h, y, b) {
              return b === "assert" ? new zr(y, [h]) : b === "coerce" ? new xr(y, [h]) : h;
            }
            if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
              if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const h = t[0];
              if (typeof h != "string") return this.error(`Expression name must be a string, but found ${typeof h} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const y = this.registry[h];
              if (y) {
                let b = y.parse(t, this);
                if (!b) return null;
                if (this.expectedType) {
                  const w = this.expectedType, S = b.type;
                  if (w.kind !== "string" && w.kind !== "number" && w.kind !== "boolean" && w.kind !== "object" && w.kind !== "array" || S.kind !== "value") {
                    if (w.kind === "projectionDefinition" && ["string", "array"].includes(S.kind) || ["color", "formatted", "resolvedImage"].includes(w.kind) && ["value", "string"].includes(S.kind) || ["padding", "numberArray"].includes(w.kind) && ["value", "number", "array"].includes(S.kind) || w.kind === "colorArray" && ["value", "string", "array"].includes(S.kind) || w.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(S.kind)) b = u(b, w, n.typeAnnotation || "coerce");
                    else if (this.checkSubtype(w, S)) return null;
                  } else b = u(b, w, n.typeAnnotation || "assert");
                }
                if (!(b instanceof la) && b.type.kind !== "resolvedImage" && this._isConstant(b)) {
                  const w = new Yl();
                  try {
                    b = new la(b.type, b.evaluate(w));
                  } catch (S) {
                    return this.error(S.message), null;
                  }
                }
                return b;
              }
              return this.error(`Unknown expression "${h}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);
          }
          concat(t, n, u) {
            const h = typeof t == "number" ? this.path.concat(t) : this.path, y = u ? this.scope.concat(u) : this.scope;
            return new Rr(this.registry, this._isConstant, h, n || null, y, this.errors);
          }
          error(t, ...n) {
            const u = `${this.key}${n.map(((h) => `[${h}]`)).join("")}`;
            this.errors.push(new _r(u, t));
          }
          checkSubtype(t, n) {
            const u = Do(t, n);
            return u && this.error(u), u;
          }
        }
        class fs {
          constructor(t, n) {
            this.type = n.type, this.bindings = [].concat(t), this.result = n;
          }
          evaluate(t) {
            return this.result.evaluate(t);
          }
          eachChild(t) {
            for (const n of this.bindings) t(n[1]);
            t(this.result);
          }
          static parse(t, n) {
            if (t.length < 4) return n.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
            const u = [];
            for (let y = 1; y < t.length - 1; y += 2) {
              const b = t[y];
              if (typeof b != "string") return n.error(`Expected string, but found ${typeof b} instead.`, y);
              if (/[^a-zA-Z0-9_]/.test(b)) return n.error("Variable names must contain only alphanumeric characters or '_'.", y);
              const w = n.parse(t[y + 1], y + 1);
              if (!w) return null;
              u.push([b, w]);
            }
            const h = n.parse(t[t.length - 1], t.length - 1, n.expectedType, u);
            return h ? new fs(u, h) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class Yn {
          constructor(t, n) {
            this.type = n.type, this.name = t, this.boundExpression = n;
          }
          static parse(t, n) {
            if (t.length !== 2 || typeof t[1] != "string") return n.error("'var' expression requires exactly one string literal argument.");
            const u = t[1];
            return n.scope.has(u) ? new Yn(u, n.scope.get(u)) : n.error(`Unknown variable "${u}". Make sure "${u}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t) {
            return this.boundExpression.evaluate(t);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
        }
        class Ys {
          constructor(t, n, u) {
            this.type = t, this.index = n, this.input = u;
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
            const u = n.parse(t[1], 1, Ct), h = n.parse(t[2], 2, Vi(n.expectedType || hr));
            return u && h ? new Ys(h.type.itemType, u, h) : null;
          }
          evaluate(t) {
            const n = this.index.evaluate(t), u = this.input.evaluate(t);
            if (n < 0) throw new ri(`Array index out of bounds: ${n} < 0.`);
            if (n >= u.length) throw new ri(`Array index out of bounds: ${n} > ${u.length - 1}.`);
            if (n !== Math.floor(n)) throw new ri(`Array index must be an integer, but found ${n} instead.`);
            return u[n];
          }
          eachChild(t) {
            t(this.index), t(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class ps {
          constructor(t, n) {
            this.type = lr, this.needle = t, this.haystack = n;
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
            const u = n.parse(t[1], 1, hr), h = n.parse(t[2], 2, hr);
            return u && h ? xi(u.type, [lr, ar, Ct, mr, hr]) ? new ps(u, h) : n.error(`Expected first argument to be of type boolean, string, number or null, but found ${ti(u.type)} instead`) : null;
          }
          evaluate(t) {
            const n = this.needle.evaluate(t), u = this.haystack.evaluate(t);
            if (!u) return false;
            if (!zo(n, ["boolean", "string", "number", "null"])) throw new ri(`Expected first argument to be of type boolean, string, number or null, but found ${ti(wi(n))} instead.`);
            if (!zo(u, ["string", "array"])) throw new ri(`Expected second argument to be of type array or string, but found ${ti(wi(u))} instead.`);
            return u.indexOf(n) >= 0;
          }
          eachChild(t) {
            t(this.needle), t(this.haystack);
          }
          outputDefined() {
            return true;
          }
        }
        class Ks {
          constructor(t, n, u) {
            this.type = Ct, this.needle = t, this.haystack = n, this.fromIndex = u;
          }
          static parse(t, n) {
            if (t.length <= 2 || t.length >= 5) return n.error(`Expected 2 or 3 arguments, but found ${t.length - 1} instead.`);
            const u = n.parse(t[1], 1, hr), h = n.parse(t[2], 2, hr);
            if (!u || !h) return null;
            if (!xi(u.type, [lr, ar, Ct, mr, hr])) return n.error(`Expected first argument to be of type boolean, string, number or null, but found ${ti(u.type)} instead`);
            if (t.length === 4) {
              const y = n.parse(t[3], 3, Ct);
              return y ? new Ks(u, h, y) : null;
            }
            return new Ks(u, h);
          }
          evaluate(t) {
            const n = this.needle.evaluate(t), u = this.haystack.evaluate(t);
            if (!zo(n, ["boolean", "string", "number", "null"])) throw new ri(`Expected first argument to be of type boolean, string, number or null, but found ${ti(wi(n))} instead.`);
            let h;
            if (this.fromIndex && (h = this.fromIndex.evaluate(t)), zo(u, ["string"])) {
              const y = u.indexOf(n, h);
              return y === -1 ? -1 : [...u.slice(0, y)].length;
            }
            if (zo(u, ["array"])) return u.indexOf(n, h);
            throw new ri(`Expected second argument to be of type array or string, but found ${ti(wi(u))} instead.`);
          }
          eachChild(t) {
            t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
        }
        class Js {
          constructor(t, n, u, h, y, b) {
            this.inputType = t, this.type = n, this.input = u, this.cases = h, this.outputs = y, this.otherwise = b;
          }
          static parse(t, n) {
            if (t.length < 5) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if (t.length % 2 != 1) return n.error("Expected an even number of arguments.");
            let u, h;
            n.expectedType && n.expectedType.kind !== "value" && (h = n.expectedType);
            const y = {}, b = [];
            for (let I = 2; I < t.length - 1; I += 2) {
              let E = t[I];
              const O = t[I + 1];
              Array.isArray(E) || (E = [E]);
              const V = n.concat(I);
              if (E.length === 0) return V.error("Expected at least one branch label.");
              for (const W of E) {
                if (typeof W != "number" && typeof W != "string") return V.error("Branch labels must be numbers or strings.");
                if (typeof W == "number" && Math.abs(W) > Number.MAX_SAFE_INTEGER) return V.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof W == "number" && Math.floor(W) !== W) return V.error("Numeric branch labels must be integer values.");
                if (u) {
                  if (V.checkSubtype(u, wi(W))) return null;
                } else u = wi(W);
                if (y[String(W)] !== void 0) return V.error("Branch labels must be unique.");
                y[String(W)] = b.length;
              }
              const U = n.parse(O, I, h);
              if (!U) return null;
              h = h || U.type, b.push(U);
            }
            const w = n.parse(t[1], 1, hr);
            if (!w) return null;
            const S = n.parse(t[t.length - 1], t.length - 1, h);
            return S ? w.type.kind !== "value" && n.concat(1).checkSubtype(u, w.type) ? null : new Js(u, h, w, y, b, S) : null;
          }
          evaluate(t) {
            const n = this.input.evaluate(t);
            return (wi(n) === this.inputType && this.outputs[this.cases[n]] || this.otherwise).evaluate(t);
          }
          eachChild(t) {
            t(this.input), this.outputs.forEach(t), t(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class Kl {
          constructor(t, n, u) {
            this.type = t, this.branches = n, this.otherwise = u;
          }
          static parse(t, n) {
            if (t.length < 4) return n.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
            if (t.length % 2 != 0) return n.error("Expected an odd number of arguments.");
            let u;
            n.expectedType && n.expectedType.kind !== "value" && (u = n.expectedType);
            const h = [];
            for (let b = 1; b < t.length - 1; b += 2) {
              const w = n.parse(t[b], b, lr);
              if (!w) return null;
              const S = n.parse(t[b + 1], b + 1, u);
              if (!S) return null;
              h.push([w, S]), u = u || S.type;
            }
            const y = n.parse(t[t.length - 1], t.length - 1, u);
            if (!y) return null;
            if (!u) throw new Error("Can't infer output type");
            return new Kl(u, h, y);
          }
          evaluate(t) {
            for (const [n, u] of this.branches) if (n.evaluate(t)) return u.evaluate(t);
            return this.otherwise.evaluate(t);
          }
          eachChild(t) {
            for (const [n, u] of this.branches) t(n), t(u);
            t(this.otherwise);
          }
          outputDefined() {
            return this.branches.every((([t, n]) => n.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class Jl {
          constructor(t, n, u, h) {
            this.type = t, this.input = n, this.beginIndex = u, this.endIndex = h;
          }
          static parse(t, n) {
            if (t.length <= 2 || t.length >= 5) return n.error(`Expected 2 or 3 arguments, but found ${t.length - 1} instead.`);
            const u = n.parse(t[1], 1, hr), h = n.parse(t[2], 2, Ct);
            if (!u || !h) return null;
            if (!xi(u.type, [Vi(hr), ar, hr])) return n.error(`Expected first argument to be of type array or string, but found ${ti(u.type)} instead`);
            if (t.length === 4) {
              const y = n.parse(t[3], 3, Ct);
              return y ? new Jl(u.type, u, h, y) : null;
            }
            return new Jl(u.type, u, h);
          }
          evaluate(t) {
            const n = this.input.evaluate(t), u = this.beginIndex.evaluate(t);
            let h;
            if (this.endIndex && (h = this.endIndex.evaluate(t)), zo(n, ["string"])) return [...n].slice(u, h).join("");
            if (zo(n, ["array"])) return n.slice(u, h);
            throw new ri(`Expected first argument to be of type array or string, but found ${ti(wi(n))} instead.`);
          }
          eachChild(t) {
            t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
          }
          outputDefined() {
            return false;
          }
        }
        function Qs(o, t) {
          const n = o.length - 1;
          let u, h, y = 0, b = n, w = 0;
          for (; y <= b; ) if (w = Math.floor((y + b) / 2), u = o[w], h = o[w + 1], u <= t) {
            if (w === n || t < h) return w;
            y = w + 1;
          } else {
            if (!(u > t)) throw new ri("Input is not a number.");
            b = w - 1;
          }
          return 0;
        }
        class ms {
          constructor(t, n, u) {
            this.type = t, this.input = n, this.labels = [], this.outputs = [];
            for (const [h, y] of u) this.labels.push(h), this.outputs.push(y);
          }
          static parse(t, n) {
            if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
            const u = n.parse(t[1], 1, Ct);
            if (!u) return null;
            const h = [];
            let y = null;
            n.expectedType && n.expectedType.kind !== "value" && (y = n.expectedType);
            for (let b = 1; b < t.length; b += 2) {
              const w = b === 1 ? -1 / 0 : t[b], S = t[b + 1], I = b, E = b + 1;
              if (typeof w != "number") return n.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', I);
              if (h.length && h[h.length - 1][0] >= w) return n.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', I);
              const O = n.parse(S, E, y);
              if (!O) return null;
              y = y || O.type, h.push([w, O]);
            }
            return new ms(y, u, h);
          }
          evaluate(t) {
            const n = this.labels, u = this.outputs;
            if (n.length === 1) return u[0].evaluate(t);
            const h = this.input.evaluate(t);
            if (h <= n[0]) return u[0].evaluate(t);
            const y = n.length;
            return h >= n[y - 1] ? u[y - 1].evaluate(t) : u[Qs(n, h)].evaluate(t);
          }
          eachChild(t) {
            t(this.input);
            for (const n of this.outputs) t(n);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined()));
          }
        }
        function ua(o) {
          return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
        }
        var Ui, el, bh = (function() {
          if (el) return Ui;
          function o(t, n, u, h) {
            this.cx = 3 * t, this.bx = 3 * (u - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (h - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = u, this.p2y = h;
          }
          return el = 1, Ui = o, o.prototype = { sampleCurveX: function(t) {
            return ((this.ax * t + this.bx) * t + this.cx) * t;
          }, sampleCurveY: function(t) {
            return ((this.ay * t + this.by) * t + this.cy) * t;
          }, sampleCurveDerivativeX: function(t) {
            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
          }, solveCurveX: function(t, n) {
            if (n === void 0 && (n = 1e-6), t < 0) return 0;
            if (t > 1) return 1;
            for (var u = t, h = 0; h < 8; h++) {
              var y = this.sampleCurveX(u) - t;
              if (Math.abs(y) < n) return u;
              var b = this.sampleCurveDerivativeX(u);
              if (Math.abs(b) < 1e-6) break;
              u -= y / b;
            }
            var w = 0, S = 1;
            for (u = t, h = 0; h < 20 && (y = this.sampleCurveX(u), !(Math.abs(y - t) < n)); h++) t > y ? w = u : S = u, u = 0.5 * (S - w) + w;
            return u;
          }, solve: function(t, n) {
            return this.sampleCurveY(this.solveCurveX(t, n));
          } }, Ui;
        })(), Ql = ua(bh);
        class Vr {
          constructor(t, n, u, h, y) {
            this.type = t, this.operator = n, this.interpolation = u, this.input = h, this.labels = [], this.outputs = [];
            for (const [b, w] of y) this.labels.push(b), this.outputs.push(w);
          }
          static interpolationFactor(t, n, u, h) {
            let y = 0;
            if (t.name === "exponential") y = eu(n, t.base, u, h);
            else if (t.name === "linear") y = eu(n, 1, u, h);
            else if (t.name === "cubic-bezier") {
              const b = t.controlPoints;
              y = new Ql(b[0], b[1], b[2], b[3]).solve(eu(n, 1, u, h));
            }
            return y;
          }
          static parse(t, n) {
            let [u, h, y, ...b] = t;
            if (!Array.isArray(h) || h.length === 0) return n.error("Expected an interpolation type expression.", 1);
            if (h[0] === "linear") h = { name: "linear" };
            else if (h[0] === "exponential") {
              const I = h[1];
              if (typeof I != "number") return n.error("Exponential interpolation requires a numeric base.", 1, 1);
              h = { name: "exponential", base: I };
            } else {
              if (h[0] !== "cubic-bezier") return n.error(`Unknown interpolation type ${String(h[0])}`, 1, 0);
              {
                const I = h.slice(1);
                if (I.length !== 4 || I.some(((E) => typeof E != "number" || E < 0 || E > 1))) return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                h = { name: "cubic-bezier", controlPoints: I };
              }
            }
            if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
            if (y = n.parse(y, 2, Ct), !y) return null;
            const w = [];
            let S = null;
            u !== "interpolate-hcl" && u !== "interpolate-lab" || n.expectedType == Hn ? n.expectedType && n.expectedType.kind !== "value" && (S = n.expectedType) : S = Bi;
            for (let I = 0; I < b.length; I += 2) {
              const E = b[I], O = b[I + 1], V = I + 3, U = I + 4;
              if (typeof E != "number") return n.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', V);
              if (w.length && w[w.length - 1][0] >= E) return n.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', V);
              const W = n.parse(O, U, S);
              if (!W) return null;
              S = S || W.type, w.push([E, W]);
            }
            return oo(S, Ct) || oo(S, jn) || oo(S, Bi) || oo(S, Mn) || oo(S, Xn) || oo(S, Hn) || oo(S, ls) || oo(S, Vi(Ct)) ? new Vr(S, u, h, y, w) : n.error(`Type ${ti(S)} is not interpolatable.`);
          }
          evaluate(t) {
            const n = this.labels, u = this.outputs;
            if (n.length === 1) return u[0].evaluate(t);
            const h = this.input.evaluate(t);
            if (h <= n[0]) return u[0].evaluate(t);
            const y = n.length;
            if (h >= n[y - 1]) return u[y - 1].evaluate(t);
            const b = Qs(n, h), w = Vr.interpolationFactor(this.interpolation, h, n[b], n[b + 1]), S = u[b].evaluate(t), I = u[b + 1].evaluate(t);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return ao(S, I, w);
                  case "color":
                    return fr.interpolate(S, I, w);
                  case "padding":
                    return ln.interpolate(S, I, w);
                  case "colorArray":
                    return Pi.interpolate(S, I, w);
                  case "numberArray":
                    return Qi.interpolate(S, I, w);
                  case "variableAnchorOffsetCollection":
                    return un.interpolate(S, I, w);
                  case "array":
                    return Fo(S, I, w);
                  case "projectionDefinition":
                    return Nn.interpolate(S, I, w);
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return fr.interpolate(S, I, w, "hcl");
                  case "colorArray":
                    return Pi.interpolate(S, I, w, "hcl");
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return fr.interpolate(S, I, w, "lab");
                  case "colorArray":
                    return Pi.interpolate(S, I, w, "lab");
                }
            }
          }
          eachChild(t) {
            t(this.input);
            for (const n of this.outputs) t(n);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined()));
          }
        }
        function eu(o, t, n, u) {
          const h = u - n, y = o - n;
          return h === 0 ? 0 : t === 1 ? y / h : (Math.pow(t, y) - 1) / (Math.pow(t, h) - 1);
        }
        const Kn = { color: fr.interpolate, number: ao, padding: ln.interpolate, numberArray: Qi.interpolate, colorArray: Pi.interpolate, variableAnchorOffsetCollection: un.interpolate, array: Fo };
        class tl {
          constructor(t, n) {
            this.type = t, this.args = n;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            let u = null;
            const h = n.expectedType;
            h && h.kind !== "value" && (u = h);
            const y = [];
            for (const w of t.slice(1)) {
              const S = n.parse(w, 1 + y.length, u, void 0, { typeAnnotation: "omit" });
              if (!S) return null;
              u = u || S.type, y.push(S);
            }
            if (!u) throw new Error("No output type");
            const b = h && y.some(((w) => Do(h, w.type)));
            return new tl(b ? hr : u, y);
          }
          evaluate(t) {
            let n, u = null, h = 0;
            for (const y of this.args) if (h++, u = y.evaluate(t), u && u instanceof gn && !u.available && (n || (n = u.name), u = null, h === this.args.length && (u = n)), u !== null) break;
            return u;
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        function xh(o, t) {
          return o === "==" || o === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value";
        }
        function Ra(o, t, n, u) {
          return u.compare(t, n) === 0;
        }
        function Lo(o, t, n) {
          const u = o !== "==" && o !== "!=";
          return class _1 {
            constructor(y, b, w) {
              this.type = lr, this.lhs = y, this.rhs = b, this.collator = w, this.hasUntypedArgument = y.type.kind === "value" || b.type.kind === "value";
            }
            static parse(y, b) {
              if (y.length !== 3 && y.length !== 4) return b.error("Expected two or three arguments.");
              const w = y[0];
              let S = b.parse(y[1], 1, hr);
              if (!S) return null;
              if (!xh(w, S.type)) return b.concat(1).error(`"${w}" comparisons are not supported for type '${ti(S.type)}'.`);
              let I = b.parse(y[2], 2, hr);
              if (!I) return null;
              if (!xh(w, I.type)) return b.concat(2).error(`"${w}" comparisons are not supported for type '${ti(I.type)}'.`);
              if (S.type.kind !== I.type.kind && S.type.kind !== "value" && I.type.kind !== "value") return b.error(`Cannot compare types '${ti(S.type)}' and '${ti(I.type)}'.`);
              u && (S.type.kind === "value" && I.type.kind !== "value" ? S = new zr(I.type, [S]) : S.type.kind !== "value" && I.type.kind === "value" && (I = new zr(S.type, [I])));
              let E = null;
              if (y.length === 4) {
                if (S.type.kind !== "string" && I.type.kind !== "string" && S.type.kind !== "value" && I.type.kind !== "value") return b.error("Cannot use collator to compare non-string types.");
                if (E = b.parse(y[3], 3, Ao), !E) return null;
              }
              return new _1(S, I, E);
            }
            evaluate(y) {
              const b = this.lhs.evaluate(y), w = this.rhs.evaluate(y);
              if (u && this.hasUntypedArgument) {
                const S = wi(b), I = wi(w);
                if (S.kind !== I.kind || S.kind !== "string" && S.kind !== "number") throw new ri(`Expected arguments for "${o}" to be (string, string) or (number, number), but found (${S.kind}, ${I.kind}) instead.`);
              }
              if (this.collator && !u && this.hasUntypedArgument) {
                const S = wi(b), I = wi(w);
                if (S.kind !== "string" || I.kind !== "string") return t(y, b, w);
              }
              return this.collator ? n(y, b, w, this.collator.evaluate(y)) : t(y, b, w);
            }
            eachChild(y) {
              y(this.lhs), y(this.rhs), this.collator && y(this.collator);
            }
            outputDefined() {
              return true;
            }
          };
        }
        const Pc = Lo("==", (function(o, t, n) {
          return t === n;
        }), Ra), Np = Lo("!=", (function(o, t, n) {
          return t !== n;
        }), (function(o, t, n, u) {
          return !Ra(0, t, n, u);
        })), wh = Lo("<", (function(o, t, n) {
          return t < n;
        }), (function(o, t, n, u) {
          return u.compare(t, n) < 0;
        })), tu = Lo(">", (function(o, t, n) {
          return t > n;
        }), (function(o, t, n, u) {
          return u.compare(t, n) > 0;
        })), ru = Lo("<=", (function(o, t, n) {
          return t <= n;
        }), (function(o, t, n, u) {
          return u.compare(t, n) <= 0;
        })), so = Lo(">=", (function(o, t, n) {
          return t >= n;
        }), (function(o, t, n, u) {
          return u.compare(t, n) >= 0;
        }));
        class rl {
          constructor(t, n, u) {
            this.type = Ao, this.locale = u, this.caseSensitive = t, this.diacriticSensitive = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error("Expected one argument.");
            const u = t[1];
            if (typeof u != "object" || Array.isArray(u)) return n.error("Collator options argument must be an object.");
            const h = n.parse(u["case-sensitive"] !== void 0 && u["case-sensitive"], 1, lr);
            if (!h) return null;
            const y = n.parse(u["diacritic-sensitive"] !== void 0 && u["diacritic-sensitive"], 1, lr);
            if (!y) return null;
            let b = null;
            return u.locale && (b = n.parse(u.locale, 1, ar), !b) ? null : new rl(h, y, b);
          }
          evaluate(t) {
            return new Ir(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
          }
          eachChild(t) {
            t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
          }
          outputDefined() {
            return false;
          }
        }
        class gs {
          constructor(t, n, u, h, y) {
            this.type = ar, this.number = t, this.locale = n, this.currency = u, this.minFractionDigits = h, this.maxFractionDigits = y;
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error("Expected two arguments.");
            const u = n.parse(t[1], 1, Ct);
            if (!u) return null;
            const h = t[2];
            if (typeof h != "object" || Array.isArray(h)) return n.error("NumberFormat options argument must be an object.");
            let y = null;
            if (h.locale && (y = n.parse(h.locale, 1, ar), !y)) return null;
            let b = null;
            if (h.currency && (b = n.parse(h.currency, 1, ar), !b)) return null;
            let w = null;
            if (h["min-fraction-digits"] && (w = n.parse(h["min-fraction-digits"], 1, Ct), !w)) return null;
            let S = null;
            return h["max-fraction-digits"] && (S = n.parse(h["max-fraction-digits"], 1, Ct), !S) ? null : new gs(u, y, b, w, S);
          }
          evaluate(t) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0 }).format(this.number.evaluate(t));
          }
          eachChild(t) {
            t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
        }
        class iu {
          constructor(t) {
            this.type = no, this.sections = t;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            const u = t[1];
            if (!Array.isArray(u) && typeof u == "object") return n.error("First argument must be an image or text section.");
            const h = [];
            let y = false;
            for (let b = 1; b <= t.length - 1; ++b) {
              const w = t[b];
              if (y && typeof w == "object" && !Array.isArray(w)) {
                y = false;
                let S = null;
                if (w["font-scale"] && (S = n.parse(w["font-scale"], 1, Ct), !S)) return null;
                let I = null;
                if (w["text-font"] && (I = n.parse(w["text-font"], 1, Vi(ar)), !I)) return null;
                let E = null;
                if (w["text-color"] && (E = n.parse(w["text-color"], 1, Bi), !E)) return null;
                let O = null;
                if (w["vertical-align"]) {
                  if (typeof w["vertical-align"] == "string" && !ds.includes(w["vertical-align"])) return n.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${w["vertical-align"]}' instead.`);
                  if (O = n.parse(w["vertical-align"], 1, ar), !O) return null;
                }
                const V = h[h.length - 1];
                V.scale = S, V.font = I, V.textColor = E, V.verticalAlign = O;
              } else {
                const S = n.parse(t[b], 1, hr);
                if (!S) return null;
                const I = S.type.kind;
                if (I !== "string" && I !== "value" && I !== "null" && I !== "resolvedImage") return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                y = true, h.push({ content: S, scale: null, font: null, textColor: null, verticalAlign: null });
              }
            }
            return new iu(h);
          }
          evaluate(t) {
            return new Rn(this.sections.map(((n) => {
              const u = n.content.evaluate(t);
              return wi(u) === En ? new Co("", u, null, null, null, n.verticalAlign ? n.verticalAlign.evaluate(t) : null) : new Co(hs(u), null, n.scale ? n.scale.evaluate(t) : null, n.font ? n.font.evaluate(t).join(",") : null, n.textColor ? n.textColor.evaluate(t) : null, n.verticalAlign ? n.verticalAlign.evaluate(t) : null);
            })));
          }
          eachChild(t) {
            for (const n of this.sections) t(n.content), n.scale && t(n.scale), n.font && t(n.font), n.textColor && t(n.textColor), n.verticalAlign && t(n.verticalAlign);
          }
          outputDefined() {
            return false;
          }
        }
        class il {
          constructor(t) {
            this.type = En, this.input = t;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error("Expected two arguments.");
            const u = n.parse(t[1], 1, ar);
            return u ? new il(u) : n.error("No image name provided.");
          }
          evaluate(t) {
            const n = this.input.evaluate(t), u = gn.fromString(n);
            return u && t.availableImages && (u.available = t.availableImages.indexOf(n) > -1), u;
          }
          eachChild(t) {
            t(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class Tc {
          constructor(t) {
            this.type = Ct, this.input = t;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
            const u = n.parse(t[1], 1);
            return u ? u.type.kind !== "array" && u.type.kind !== "string" && u.type.kind !== "value" ? n.error(`Expected argument of type string or array, but found ${ti(u.type)} instead.`) : new Tc(u) : null;
          }
          evaluate(t) {
            const n = this.input.evaluate(t);
            if (typeof n == "string") return [...n].length;
            if (Array.isArray(n)) return n.length;
            throw new ri(`Expected value to be of type string or array, but found ${ti(wi(n))} instead.`);
          }
          eachChild(t) {
            t(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        const ko = 8192;
        function Vp(o, t) {
          const n = (180 + o[0]) / 360, u = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + o[1] * Math.PI / 360))) / 360, h = Math.pow(2, t.z);
          return [Math.round(n * h * ko), Math.round(u * h * ko)];
        }
        function Ic(o, t) {
          const n = Math.pow(2, t.z);
          return [(h = (o[0] / ko + t.x) / n, 360 * h - 180), (u = (o[1] / ko + t.y) / n, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * u) * Math.PI / 180)) - 90)];
          var u, h;
        }
        function ca(o, t) {
          o[0] = Math.min(o[0], t[0]), o[1] = Math.min(o[1], t[1]), o[2] = Math.max(o[2], t[0]), o[3] = Math.max(o[3], t[1]);
        }
        function nl(o, t) {
          return !(o[0] <= t[0] || o[2] >= t[2] || o[1] <= t[1] || o[3] >= t[3]);
        }
        function Ch(o, t, n) {
          const u = o[0] - t[0], h = o[1] - t[1], y = o[0] - n[0], b = o[1] - n[1];
          return u * b - y * h == 0 && u * y <= 0 && h * b <= 0;
        }
        function ol(o, t, n, u) {
          return (h = [u[0] - n[0], u[1] - n[1]])[0] * (y = [t[0] - o[0], t[1] - o[1]])[1] - h[1] * y[0] != 0 && !(!kh(o, t, n, u) || !kh(n, u, o, t));
          var h, y;
        }
        function Up(o, t, n) {
          for (const u of n) for (let h = 0; h < u.length - 1; ++h) if (ol(o, t, u[h], u[h + 1])) return true;
          return false;
        }
        function Aa(o, t, n = false) {
          let u = false;
          for (const w of t) for (let S = 0; S < w.length - 1; S++) {
            if (Ch(o, w[S], w[S + 1])) return n;
            (y = w[S])[1] > (h = o)[1] != (b = w[S + 1])[1] > h[1] && h[0] < (b[0] - y[0]) * (h[1] - y[1]) / (b[1] - y[1]) + y[0] && (u = !u);
          }
          var h, y, b;
          return u;
        }
        function Gp(o, t) {
          for (const n of t) if (Aa(o, n)) return true;
          return false;
        }
        function Sh(o, t) {
          for (const n of o) if (!Aa(n, t)) return false;
          for (let n = 0; n < o.length - 1; ++n) if (Up(o[n], o[n + 1], t)) return false;
          return true;
        }
        function qp(o, t) {
          for (const n of t) if (Sh(o, n)) return true;
          return false;
        }
        function kh(o, t, n, u) {
          const h = u[0] - n[0], y = u[1] - n[1], b = (o[0] - n[0]) * y - h * (o[1] - n[1]), w = (t[0] - n[0]) * y - h * (t[1] - n[1]);
          return b > 0 && w < 0 || b < 0 && w > 0;
        }
        function Mc(o, t, n) {
          const u = [];
          for (let h = 0; h < o.length; h++) {
            const y = [];
            for (let b = 0; b < o[h].length; b++) {
              const w = Vp(o[h][b], n);
              ca(t, w), y.push(w);
            }
            u.push(y);
          }
          return u;
        }
        function Ec(o, t, n) {
          const u = [];
          for (let h = 0; h < o.length; h++) {
            const y = Mc(o[h], t, n);
            u.push(y);
          }
          return u;
        }
        function Rc(o, t, n, u) {
          if (o[0] < n[0] || o[0] > n[2]) {
            const h = 0.5 * u;
            let y = o[0] - n[0] > h ? -u : n[0] - o[0] > h ? u : 0;
            y === 0 && (y = o[0] - n[2] > h ? -u : n[2] - o[0] > h ? u : 0), o[0] += y;
          }
          ca(t, o);
        }
        function Ac(o, t, n, u) {
          const h = Math.pow(2, u.z) * ko, y = [u.x * ko, u.y * ko], b = [];
          for (const w of o) for (const S of w) {
            const I = [S.x + y[0], S.y + y[1]];
            Rc(I, t, n, h), b.push(I);
          }
          return b;
        }
        function Ph(o, t, n, u) {
          const h = Math.pow(2, u.z) * ko, y = [u.x * ko, u.y * ko], b = [];
          for (const S of o) {
            const I = [];
            for (const E of S) {
              const O = [E.x + y[0], E.y + y[1]];
              ca(t, O), I.push(O);
            }
            b.push(I);
          }
          if (t[2] - t[0] <= h / 2) {
            (w = t)[0] = w[1] = 1 / 0, w[2] = w[3] = -1 / 0;
            for (const S of b) for (const I of S) Rc(I, t, n, h);
          }
          var w;
          return b;
        }
        class Da {
          constructor(t, n) {
            this.type = lr, this.geojson = t, this.geometries = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (So(t[1])) {
              const u = t[1];
              if (u.type === "FeatureCollection") {
                const h = [];
                for (const y of u.features) {
                  const { type: b, coordinates: w } = y.geometry;
                  b === "Polygon" && h.push(w), b === "MultiPolygon" && h.push(...w);
                }
                if (h.length) return new Da(u, { type: "MultiPolygon", coordinates: h });
              } else if (u.type === "Feature") {
                const h = u.geometry.type;
                if (h === "Polygon" || h === "MultiPolygon") return new Da(u, u.geometry);
              } else if (u.type === "Polygon" || u.type === "MultiPolygon") return new Da(u, u);
            }
            return n.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(n, u) {
                const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0], y = [1 / 0, 1 / 0, -1 / 0, -1 / 0], b = n.canonicalID();
                if (u.type === "Polygon") {
                  const w = Mc(u.coordinates, y, b), S = Ac(n.geometry(), h, y, b);
                  if (!nl(h, y)) return false;
                  for (const I of S) if (!Aa(I, w)) return false;
                }
                if (u.type === "MultiPolygon") {
                  const w = Ec(u.coordinates, y, b), S = Ac(n.geometry(), h, y, b);
                  if (!nl(h, y)) return false;
                  for (const I of S) if (!Gp(I, w)) return false;
                }
                return true;
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(n, u) {
                const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0], y = [1 / 0, 1 / 0, -1 / 0, -1 / 0], b = n.canonicalID();
                if (u.type === "Polygon") {
                  const w = Mc(u.coordinates, y, b), S = Ph(n.geometry(), h, y, b);
                  if (!nl(h, y)) return false;
                  for (const I of S) if (!Sh(I, w)) return false;
                }
                if (u.type === "MultiPolygon") {
                  const w = Ec(u.coordinates, y, b), S = Ph(n.geometry(), h, y, b);
                  if (!nl(h, y)) return false;
                  for (const I of S) if (!qp(I, w)) return false;
                }
                return true;
              })(t, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        let Th = class {
          constructor(o = [], t = (n, u) => n < u ? -1 : n > u ? 1 : 0) {
            if (this.data = o, this.length = this.data.length, this.compare = t, this.length > 0) for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
          }
          push(o) {
            this.data.push(o), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const o = this.data[0], t = this.data.pop();
            return --this.length > 0 && (this.data[0] = t, this._down(0)), o;
          }
          peek() {
            return this.data[0];
          }
          _up(o) {
            const { data: t, compare: n } = this, u = t[o];
            for (; o > 0; ) {
              const h = o - 1 >> 1, y = t[h];
              if (n(u, y) >= 0) break;
              t[o] = y, o = h;
            }
            t[o] = u;
          }
          _down(o) {
            const { data: t, compare: n } = this, u = this.length >> 1, h = t[o];
            for (; o < u; ) {
              let y = 1 + (o << 1);
              const b = y + 1;
              if (b < this.length && n(t[b], t[y]) < 0 && (y = b), n(t[y], h) >= 0) break;
              t[o] = t[y], o = y;
            }
            t[o] = h;
          }
        };
        function Ih(o, t, n = 0, u = o.length - 1, h = Wp) {
          for (; u > n; ) {
            if (u - n > 600) {
              const S = u - n + 1, I = t - n + 1, E = Math.log(S), O = 0.5 * Math.exp(2 * E / 3), V = 0.5 * Math.sqrt(E * O * (S - O) / S) * (I - S / 2 < 0 ? -1 : 1);
              Ih(o, t, Math.max(n, Math.floor(t - I * O / S + V)), Math.min(u, Math.floor(t + (S - I) * O / S + V)), h);
            }
            const y = o[t];
            let b = n, w = u;
            for (da(o, n, t), h(o[u], y) > 0 && da(o, n, u); b < w; ) {
              for (da(o, b, w), b++, w--; h(o[b], y) < 0; ) b++;
              for (; h(o[w], y) > 0; ) w--;
            }
            h(o[n], y) === 0 ? da(o, n, w) : (w++, da(o, w, u)), w <= t && (n = w + 1), t <= w && (u = w - 1);
          }
        }
        function da(o, t, n) {
          const u = o[t];
          o[t] = o[n], o[n] = u;
        }
        function Wp(o, t) {
          return o < t ? -1 : o > t ? 1 : 0;
        }
        function nu(o, t) {
          if (o.length <= 1) return [o];
          const n = [];
          let u, h;
          for (const y of o) {
            const b = Hp(y);
            b !== 0 && (y.area = Math.abs(b), h === void 0 && (h = b < 0), h === b < 0 ? (u && n.push(u), u = [y]) : u.push(y));
          }
          if (u && n.push(u), t > 1) for (let y = 0; y < n.length; y++) n[y].length <= t || (Ih(n[y], t, 1, n[y].length - 1, Zp), n[y] = n[y].slice(0, t));
          return n;
        }
        function Zp(o, t) {
          return t.area - o.area;
        }
        function Hp(o) {
          let t = 0;
          for (let n, u, h = 0, y = o.length, b = y - 1; h < y; b = h++) n = o[h], u = o[b], t += (u.x - n.x) * (n.y + u.y);
          return t;
        }
        const ou = 1 / 298.257223563, Dc = ou * (2 - ou), Mh = Math.PI / 180;
        class zc {
          constructor(t) {
            const n = 6378.137 * Mh * 1e3, u = Math.cos(t * Mh), h = 1 / (1 - Dc * (1 - u * u)), y = Math.sqrt(h);
            this.kx = n * y * u, this.ky = n * y * h * (1 - Dc);
          }
          distance(t, n) {
            const u = this.wrap(t[0] - n[0]) * this.kx, h = (t[1] - n[1]) * this.ky;
            return Math.sqrt(u * u + h * h);
          }
          pointOnLine(t, n) {
            let u, h, y, b, w = 1 / 0;
            for (let S = 0; S < t.length - 1; S++) {
              let I = t[S][0], E = t[S][1], O = this.wrap(t[S + 1][0] - I) * this.kx, V = (t[S + 1][1] - E) * this.ky, U = 0;
              O === 0 && V === 0 || (U = (this.wrap(n[0] - I) * this.kx * O + (n[1] - E) * this.ky * V) / (O * O + V * V), U > 1 ? (I = t[S + 1][0], E = t[S + 1][1]) : U > 0 && (I += O / this.kx * U, E += V / this.ky * U)), O = this.wrap(n[0] - I) * this.kx, V = (n[1] - E) * this.ky;
              const W = O * O + V * V;
              W < w && (w = W, u = I, h = E, y = S, b = U);
            }
            return { point: [u, h], index: y, t: Math.max(0, Math.min(1, b)) };
          }
          wrap(t) {
            for (; t < -180; ) t += 360;
            for (; t > 180; ) t -= 360;
            return t;
          }
        }
        function Fc(o, t) {
          return t[0] - o[0];
        }
        function al(o) {
          return o[1] - o[0] + 1;
        }
        function Bo(o, t) {
          return o[1] >= o[0] && o[1] < t;
        }
        function Lc(o, t) {
          if (o[0] > o[1]) return [null, null];
          const n = al(o);
          if (t) {
            if (n === 2) return [o, null];
            const h = Math.floor(n / 2);
            return [[o[0], o[0] + h], [o[0] + h, o[1]]];
          }
          if (n === 1) return [o, null];
          const u = Math.floor(n / 2) - 1;
          return [[o[0], o[0] + u], [o[0] + u + 1, o[1]]];
        }
        function Bc(o, t) {
          if (!Bo(t, o.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let u = t[0]; u <= t[1]; ++u) ca(n, o[u]);
          return n;
        }
        function au(o) {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const n of o) for (const u of n) ca(t, u);
          return t;
        }
        function Eh(o) {
          return o[0] !== -1 / 0 && o[1] !== -1 / 0 && o[2] !== 1 / 0 && o[3] !== 1 / 0;
        }
        function Oc(o, t, n) {
          if (!Eh(o) || !Eh(t)) return NaN;
          let u = 0, h = 0;
          return o[2] < t[0] && (u = t[0] - o[2]), o[0] > t[2] && (u = o[0] - t[2]), o[1] > t[3] && (h = o[1] - t[3]), o[3] < t[1] && (h = t[1] - o[3]), n.distance([0, 0], [u, h]);
        }
        function za(o, t, n) {
          const u = n.pointOnLine(t, o);
          return n.distance(o, u.point);
        }
        function $c(o, t, n, u, h) {
          const y = Math.min(za(o, [n, u], h), za(t, [n, u], h)), b = Math.min(za(n, [o, t], h), za(u, [o, t], h));
          return Math.min(y, b);
        }
        function Or(o, t, n, u, h) {
          if (!Bo(t, o.length) || !Bo(u, n.length)) return 1 / 0;
          let y = 1 / 0;
          for (let b = t[0]; b < t[1]; ++b) {
            const w = o[b], S = o[b + 1];
            for (let I = u[0]; I < u[1]; ++I) {
              const E = n[I], O = n[I + 1];
              if (ol(w, S, E, O)) return 0;
              y = Math.min(y, $c(w, S, E, O, h));
            }
          }
          return y;
        }
        function Xp(o, t, n, u, h) {
          if (!Bo(t, o.length) || !Bo(u, n.length)) return NaN;
          let y = 1 / 0;
          for (let b = t[0]; b <= t[1]; ++b) for (let w = u[0]; w <= u[1]; ++w) if (y = Math.min(y, h.distance(o[b], n[w])), y === 0) return y;
          return y;
        }
        function Yp(o, t, n) {
          if (Aa(o, t, true)) return 0;
          let u = 1 / 0;
          for (const h of t) {
            const y = h[0], b = h[h.length - 1];
            if (y !== b && (u = Math.min(u, za(o, [b, y], n)), u === 0)) return u;
            const w = n.pointOnLine(h, o);
            if (u = Math.min(u, n.distance(o, w.point)), u === 0) return u;
          }
          return u;
        }
        function Kp(o, t, n, u) {
          if (!Bo(t, o.length)) return NaN;
          for (let y = t[0]; y <= t[1]; ++y) if (Aa(o[y], n, true)) return 0;
          let h = 1 / 0;
          for (let y = t[0]; y < t[1]; ++y) {
            const b = o[y], w = o[y + 1];
            for (const S of n) for (let I = 0, E = S.length, O = E - 1; I < E; O = I++) {
              const V = S[O], U = S[I];
              if (ol(b, w, V, U)) return 0;
              h = Math.min(h, $c(b, w, V, U, u));
            }
          }
          return h;
        }
        function Rh(o, t) {
          for (const n of o) for (const u of n) if (Aa(u, t, true)) return true;
          return false;
        }
        function Jp(o, t, n, u = 1 / 0) {
          const h = au(o), y = au(t);
          if (u !== 1 / 0 && Oc(h, y, n) >= u) return u;
          if (nl(h, y)) {
            if (Rh(o, t)) return 0;
          } else if (Rh(t, o)) return 0;
          let b = 1 / 0;
          for (const w of o) for (let S = 0, I = w.length, E = I - 1; S < I; E = S++) {
            const O = w[E], V = w[S];
            for (const U of t) for (let W = 0, ee = U.length, se = ee - 1; W < ee; se = W++) {
              const pe = U[se], je = U[W];
              if (ol(O, V, pe, je)) return 0;
              b = Math.min(b, $c(O, V, pe, je, n));
            }
          }
          return b;
        }
        function Ah(o, t, n, u, h, y) {
          if (!y) return;
          const b = Oc(Bc(u, y), h, n);
          b < t && o.push([b, y, [0, 0]]);
        }
        function su(o, t, n, u, h, y, b) {
          if (!y || !b) return;
          const w = Oc(Bc(u, y), Bc(h, b), n);
          w < t && o.push([w, y, b]);
        }
        function lu(o, t, n, u, h = 1 / 0) {
          let y = Math.min(u.distance(o[0], n[0][0]), h);
          if (y === 0) return y;
          const b = new Th([[0, [0, o.length - 1], [0, 0]]], Fc), w = au(n);
          for (; b.length > 0; ) {
            const S = b.pop();
            if (S[0] >= y) continue;
            const I = S[1], E = t ? 50 : 100;
            if (al(I) <= E) {
              if (!Bo(I, o.length)) return NaN;
              if (t) {
                const O = Kp(o, I, n, u);
                if (isNaN(O) || O === 0) return O;
                y = Math.min(y, O);
              } else for (let O = I[0]; O <= I[1]; ++O) {
                const V = Yp(o[O], n, u);
                if (y = Math.min(y, V), y === 0) return 0;
              }
            } else {
              const O = Lc(I, t);
              Ah(b, y, u, o, w, O[0]), Ah(b, y, u, o, w, O[1]);
            }
          }
          return y;
        }
        function uu(o, t, n, u, h, y = 1 / 0) {
          let b = Math.min(y, h.distance(o[0], n[0]));
          if (b === 0) return b;
          const w = new Th([[0, [0, o.length - 1], [0, n.length - 1]]], Fc);
          for (; w.length > 0; ) {
            const S = w.pop();
            if (S[0] >= b) continue;
            const I = S[1], E = S[2], O = t ? 50 : 100, V = u ? 50 : 100;
            if (al(I) <= O && al(E) <= V) {
              if (!Bo(I, o.length) && Bo(E, n.length)) return NaN;
              let U;
              if (t && u) U = Or(o, I, n, E, h), b = Math.min(b, U);
              else if (t && !u) {
                const W = o.slice(I[0], I[1] + 1);
                for (let ee = E[0]; ee <= E[1]; ++ee) if (U = za(n[ee], W, h), b = Math.min(b, U), b === 0) return b;
              } else if (!t && u) {
                const W = n.slice(E[0], E[1] + 1);
                for (let ee = I[0]; ee <= I[1]; ++ee) if (U = za(o[ee], W, h), b = Math.min(b, U), b === 0) return b;
              } else U = Xp(o, I, n, E, h), b = Math.min(b, U);
            } else {
              const U = Lc(I, t), W = Lc(E, u);
              su(w, b, h, o, n, U[0], W[0]), su(w, b, h, o, n, U[0], W[1]), su(w, b, h, o, n, U[1], W[0]), su(w, b, h, o, n, U[1], W[1]);
            }
          }
          return b;
        }
        function jc(o) {
          return o.type === "MultiPolygon" ? o.coordinates.map(((t) => ({ type: "Polygon", coordinates: t }))) : o.type === "MultiLineString" ? o.coordinates.map(((t) => ({ type: "LineString", coordinates: t }))) : o.type === "MultiPoint" ? o.coordinates.map(((t) => ({ type: "Point", coordinates: t }))) : [o];
        }
        class Fa {
          constructor(t, n) {
            this.type = Ct, this.geojson = t, this.geometries = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'distance' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (So(t[1])) {
              const u = t[1];
              if (u.type === "FeatureCollection") return new Fa(u, u.features.map(((h) => jc(h.geometry))).flat());
              if (u.type === "Feature") return new Fa(u, jc(u.geometry));
              if ("type" in u && "coordinates" in u) return new Fa(u, jc(u));
            }
            return n.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(n, u) {
                const h = n.geometry(), y = h.flat().map(((S) => Ic([S.x, S.y], n.canonical)));
                if (h.length === 0) return NaN;
                const b = new zc(y[0][1]);
                let w = 1 / 0;
                for (const S of u) {
                  switch (S.type) {
                    case "Point":
                      w = Math.min(w, uu(y, false, [S.coordinates], false, b, w));
                      break;
                    case "LineString":
                      w = Math.min(w, uu(y, false, S.coordinates, true, b, w));
                      break;
                    case "Polygon":
                      w = Math.min(w, lu(y, false, S.coordinates, b, w));
                  }
                  if (w === 0) return w;
                }
                return w;
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(n, u) {
                const h = n.geometry(), y = h.flat().map(((S) => Ic([S.x, S.y], n.canonical)));
                if (h.length === 0) return NaN;
                const b = new zc(y[0][1]);
                let w = 1 / 0;
                for (const S of u) {
                  switch (S.type) {
                    case "Point":
                      w = Math.min(w, uu(y, true, [S.coordinates], false, b, w));
                      break;
                    case "LineString":
                      w = Math.min(w, uu(y, true, S.coordinates, true, b, w));
                      break;
                    case "Polygon":
                      w = Math.min(w, lu(y, true, S.coordinates, b, w));
                  }
                  if (w === 0) return w;
                }
                return w;
              })(t, this.geometries);
              if (t.geometryType() === "Polygon") return (function(n, u) {
                const h = n.geometry();
                if (h.length === 0 || h[0].length === 0) return NaN;
                const y = nu(h, 0).map(((S) => S.map(((I) => I.map(((E) => Ic([E.x, E.y], n.canonical))))))), b = new zc(y[0][0][0][1]);
                let w = 1 / 0;
                for (const S of u) for (const I of y) {
                  switch (S.type) {
                    case "Point":
                      w = Math.min(w, lu([S.coordinates], false, I, b, w));
                      break;
                    case "LineString":
                      w = Math.min(w, lu(S.coordinates, true, I, b, w));
                      break;
                    case "Polygon":
                      w = Math.min(w, Jp(I, S.coordinates, b, w));
                  }
                  if (w === 0) return w;
                }
                return w;
              })(t, this.geometries);
            }
            return NaN;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        class sl {
          constructor(t) {
            this.type = hr, this.key = t;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
            const u = t[1];
            return u == null ? n.error("Global state property must be defined.") : typeof u != "string" ? n.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new sl(u);
          }
          evaluate(t) {
            var n;
            const u = (n = t.globals) === null || n === void 0 ? void 0 : n.globalState;
            return u && Object.keys(u).length !== 0 ? Ma(u, this.key) : null;
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
        }
        const vs = { "==": Pc, "!=": Np, ">": tu, "<": wh, ">=": so, "<=": ru, array: zr, at: Ys, boolean: zr, case: Kl, coalesce: tl, collator: rl, format: iu, image: il, in: ps, "index-of": Ks, interpolate: Vr, "interpolate-hcl": Vr, "interpolate-lab": Vr, length: Tc, let: fs, literal: la, match: Js, number: zr, "number-format": gs, object: zr, slice: Jl, step: ms, string: zr, "to-boolean": xr, "to-color": xr, "to-number": xr, "to-string": xr, var: Yn, within: Da, distance: Fa, "global-state": sl };
        class Jn {
          constructor(t, n, u, h) {
            this.name = t, this.type = n, this._evaluate = u, this.args = h;
          }
          evaluate(t) {
            return this._evaluate(t, this.args);
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return false;
          }
          static parse(t, n) {
            const u = t[0], h = Jn.definitions[u];
            if (!h) return n.error(`Unknown expression "${u}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const y = Array.isArray(h) ? h[0] : h.type, b = Array.isArray(h) ? [[h[1], h[2]]] : h.overloads, w = b.filter((([I]) => !Array.isArray(I) || I.length === t.length - 1));
            let S = null;
            for (const [I, E] of w) {
              S = new Rr(n.registry, cu, n.path, null, n.scope);
              const O = [];
              let V = false;
              for (let U = 1; U < t.length; U++) {
                const W = t[U], ee = Array.isArray(I) ? I[U - 1] : I.type, se = S.parse(W, 1 + O.length, ee);
                if (!se) {
                  V = true;
                  break;
                }
                O.push(se);
              }
              if (!V) if (Array.isArray(I) && I.length !== O.length) S.error(`Expected ${I.length} arguments, but found ${O.length} instead.`);
              else {
                for (let U = 0; U < O.length; U++) {
                  const W = Array.isArray(I) ? I[U] : I.type, ee = O[U];
                  S.concat(U + 1).checkSubtype(W, ee.type);
                }
                if (S.errors.length === 0) return new Jn(u, y, E, O);
              }
            }
            if (w.length === 1) n.errors.push(...S.errors);
            else {
              const I = (w.length ? w : b).map((([O]) => {
                return V = O, Array.isArray(V) ? `(${V.map(ti).join(", ")})` : `(${ti(V.type)}...)`;
                var V;
              })).join(" | "), E = [];
              for (let O = 1; O < t.length; O++) {
                const V = n.parse(t[O], 1 + E.length);
                if (!V) return null;
                E.push(ti(V.type));
              }
              n.error(`Expected arguments of type ${I}, but found (${E.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t, n) {
            Jn.definitions = n;
            for (const u in n) t[u] = Jn;
          }
        }
        function Dh(o, [t, n, u, h]) {
          t = t.evaluate(o), n = n.evaluate(o), u = u.evaluate(o);
          const y = h ? h.evaluate(o) : 1, b = Xs(t, n, u, y);
          if (b) throw new ri(b);
          return new fr(t / 255, n / 255, u / 255, y, false);
        }
        function zh(o, t) {
          return o in t;
        }
        function Nc(o, t) {
          const n = t[o];
          return n === void 0 ? null : n;
        }
        function La(o) {
          return { type: o };
        }
        function cu(o) {
          if (o instanceof Yn) return cu(o.boundExpression);
          if (o instanceof Jn && o.name === "error" || o instanceof rl || o instanceof Da || o instanceof Fa || o instanceof sl) return false;
          const t = o instanceof xr || o instanceof zr;
          let n = true;
          return o.eachChild(((u) => {
            n = t ? n && cu(u) : n && u instanceof la;
          })), !!n && du(o) && hu(o, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]);
        }
        function du(o) {
          if (o instanceof Jn && (o.name === "get" && o.args.length === 1 || o.name === "feature-state" || o.name === "has" && o.args.length === 1 || o.name === "properties" || o.name === "geometry-type" || o.name === "id" || /^filter-/.test(o.name)) || o instanceof Da || o instanceof Fa) return false;
          let t = true;
          return o.eachChild(((n) => {
            t && !du(n) && (t = false);
          })), t;
        }
        function ll(o) {
          if (o instanceof Jn && o.name === "feature-state") return false;
          let t = true;
          return o.eachChild(((n) => {
            t && !ll(n) && (t = false);
          })), t;
        }
        function hu(o, t) {
          if (o instanceof Jn && t.indexOf(o.name) >= 0) return false;
          let n = true;
          return o.eachChild(((u) => {
            n && !hu(u, t) && (n = false);
          })), n;
        }
        function Fh(o) {
          return { result: "success", value: o };
        }
        function _s(o) {
          return { result: "error", value: o };
        }
        function ys(o) {
          return o["property-type"] === "data-driven" || o["property-type"] === "cross-faded-data-driven";
        }
        function Lh(o) {
          return !!o.expression && o.expression.parameters.indexOf("zoom") > -1;
        }
        function Vc(o) {
          return !!o.expression && o.expression.interpolated;
        }
        function kr(o) {
          return o instanceof Number ? "number" : o instanceof String ? "string" : o instanceof Boolean ? "boolean" : Array.isArray(o) ? "array" : o === null ? "null" : typeof o;
        }
        function fu(o) {
          return typeof o == "object" && o !== null && !Array.isArray(o) && wi(o) === In;
        }
        function Qp(o) {
          return o;
        }
        function Bh(o, t) {
          const n = o.stops && typeof o.stops[0][0] == "object", u = n || !(n || o.property !== void 0), h = o.type || (Vc(t) ? "exponential" : "interval"), y = (function(E) {
            switch (E.type) {
              case "color":
                return fr.parse;
              case "padding":
                return ln.parse;
              case "numberArray":
                return Qi.parse;
              case "colorArray":
                return Pi.parse;
              default:
                return null;
            }
          })(t);
          if (y && ((o = jt({}, o)).stops && (o.stops = o.stops.map(((E) => [E[0], y(E[1])]))), o.default = y(o.default ? o.default : t.default)), o.colorSpace && (b = o.colorSpace) !== "rgb" && b !== "hcl" && b !== "lab") throw new Error(`Unknown color space: "${o.colorSpace}"`);
          var b;
          const w = (function(E) {
            switch (E) {
              case "exponential":
                return Oh;
              case "interval":
                return tm;
              case "categorical":
                return em;
              case "identity":
                return $h;
              default:
                throw new Error(`Unknown function type "${E}"`);
            }
          })(h);
          let S, I;
          if (h === "categorical") {
            S = /* @__PURE__ */ Object.create(null);
            for (const E of o.stops) S[E[0]] = E[1];
            I = typeof o.stops[0][0];
          }
          if (n) {
            const E = {}, O = [];
            for (let W = 0; W < o.stops.length; W++) {
              const ee = o.stops[W], se = ee[0].zoom;
              E[se] === void 0 && (E[se] = { zoom: se, type: o.type, property: o.property, default: o.default, stops: [] }, O.push(se)), E[se].stops.push([ee[0].value, ee[1]]);
            }
            const V = [];
            for (const W of O) V.push([E[W].zoom, Bh(E[W], t)]);
            const U = { name: "linear" };
            return { kind: "composite", interpolationType: U, interpolationFactor: Vr.interpolationFactor.bind(void 0, U), zoomStops: V.map(((W) => W[0])), evaluate: ({ zoom: W }, ee) => Oh({ stops: V, base: o.base }, t, W).evaluate(W, ee) };
          }
          if (u) {
            const E = h === "exponential" ? { name: "exponential", base: o.base !== void 0 ? o.base : 1 } : null;
            return { kind: "camera", interpolationType: E, interpolationFactor: Vr.interpolationFactor.bind(void 0, E), zoomStops: o.stops.map(((O) => O[0])), evaluate: ({ zoom: O }) => w(o, t, O, S, I) };
          }
          return { kind: "source", evaluate(E, O) {
            const V = O && O.properties ? O.properties[o.property] : void 0;
            return V === void 0 ? Ba(o.default, t.default) : w(o, t, V, S, I);
          } };
        }
        function Ba(o, t, n) {
          return o !== void 0 ? o : t !== void 0 ? t : n !== void 0 ? n : void 0;
        }
        function em(o, t, n, u, h) {
          return Ba(typeof n === h ? u[n] : void 0, o.default, t.default);
        }
        function tm(o, t, n) {
          if (kr(n) !== "number") return Ba(o.default, t.default);
          const u = o.stops.length;
          if (u === 1 || n <= o.stops[0][0]) return o.stops[0][1];
          if (n >= o.stops[u - 1][0]) return o.stops[u - 1][1];
          const h = Qs(o.stops.map(((y) => y[0])), n);
          return o.stops[h][1];
        }
        function Oh(o, t, n) {
          const u = o.base !== void 0 ? o.base : 1;
          if (kr(n) !== "number") return Ba(o.default, t.default);
          const h = o.stops.length;
          if (h === 1 || n <= o.stops[0][0]) return o.stops[0][1];
          if (n >= o.stops[h - 1][0]) return o.stops[h - 1][1];
          const y = Qs(o.stops.map(((E) => E[0])), n), b = (function(E, O, V, U) {
            const W = U - V, ee = E - V;
            return W === 0 ? 0 : O === 1 ? ee / W : (Math.pow(O, ee) - 1) / (Math.pow(O, W) - 1);
          })(n, u, o.stops[y][0], o.stops[y + 1][0]), w = o.stops[y][1], S = o.stops[y + 1][1], I = Kn[t.type] || Qp;
          return typeof w.evaluate == "function" ? { evaluate(...E) {
            const O = w.evaluate.apply(void 0, E), V = S.evaluate.apply(void 0, E);
            if (O !== void 0 && V !== void 0) return I(O, V, b, o.colorSpace);
          } } : I(w, S, b, o.colorSpace);
        }
        function $h(o, t, n) {
          switch (t.type) {
            case "color":
              n = fr.parse(n);
              break;
            case "formatted":
              n = Rn.fromString(n.toString());
              break;
            case "resolvedImage":
              n = gn.fromString(n.toString());
              break;
            case "padding":
              n = ln.parse(n);
              break;
            case "colorArray":
              n = Pi.parse(n);
              break;
            case "numberArray":
              n = Qi.parse(n);
              break;
            default:
              kr(n) === t.type || t.type === "enum" && t.values[n] || (n = void 0);
          }
          return Ba(n, o.default, t.default);
        }
        Jn.register(vs, { error: [{ kind: "error" }, [ar], (o, [t]) => {
          throw new ri(t.evaluate(o));
        }], typeof: [ar, [hr], (o, [t]) => ti(wi(t.evaluate(o)))], "to-rgba": [Vi(Ct, 4), [Bi], (o, [t]) => {
          const [n, u, h, y] = t.evaluate(o).rgb;
          return [255 * n, 255 * u, 255 * h, y];
        }], rgb: [Bi, [Ct, Ct, Ct], Dh], rgba: [Bi, [Ct, Ct, Ct, Ct], Dh], has: { type: lr, overloads: [[[ar], (o, [t]) => zh(t.evaluate(o), o.properties())], [[ar, In], (o, [t, n]) => zh(t.evaluate(o), n.evaluate(o))]] }, get: { type: hr, overloads: [[[ar], (o, [t]) => Nc(t.evaluate(o), o.properties())], [[ar, In], (o, [t, n]) => Nc(t.evaluate(o), n.evaluate(o))]] }, "feature-state": [hr, [ar], (o, [t]) => Nc(t.evaluate(o), o.featureState || {})], properties: [In, [], (o) => o.properties()], "geometry-type": [ar, [], (o) => o.geometryType()], id: [hr, [], (o) => o.id()], zoom: [Ct, [], (o) => o.globals.zoom], "heatmap-density": [Ct, [], (o) => o.globals.heatmapDensity || 0], elevation: [Ct, [], (o) => o.globals.elevation || 0], "line-progress": [Ct, [], (o) => o.globals.lineProgress || 0], accumulated: [hr, [], (o) => o.globals.accumulated === void 0 ? null : o.globals.accumulated], "+": [Ct, La(Ct), (o, t) => {
          let n = 0;
          for (const u of t) n += u.evaluate(o);
          return n;
        }], "*": [Ct, La(Ct), (o, t) => {
          let n = 1;
          for (const u of t) n *= u.evaluate(o);
          return n;
        }], "-": { type: Ct, overloads: [[[Ct, Ct], (o, [t, n]) => t.evaluate(o) - n.evaluate(o)], [[Ct], (o, [t]) => -t.evaluate(o)]] }, "/": [Ct, [Ct, Ct], (o, [t, n]) => t.evaluate(o) / n.evaluate(o)], "%": [Ct, [Ct, Ct], (o, [t, n]) => t.evaluate(o) % n.evaluate(o)], ln2: [Ct, [], () => Math.LN2], pi: [Ct, [], () => Math.PI], e: [Ct, [], () => Math.E], "^": [Ct, [Ct, Ct], (o, [t, n]) => Math.pow(t.evaluate(o), n.evaluate(o))], sqrt: [Ct, [Ct], (o, [t]) => Math.sqrt(t.evaluate(o))], log10: [Ct, [Ct], (o, [t]) => Math.log(t.evaluate(o)) / Math.LN10], ln: [Ct, [Ct], (o, [t]) => Math.log(t.evaluate(o))], log2: [Ct, [Ct], (o, [t]) => Math.log(t.evaluate(o)) / Math.LN2], sin: [Ct, [Ct], (o, [t]) => Math.sin(t.evaluate(o))], cos: [Ct, [Ct], (o, [t]) => Math.cos(t.evaluate(o))], tan: [Ct, [Ct], (o, [t]) => Math.tan(t.evaluate(o))], asin: [Ct, [Ct], (o, [t]) => Math.asin(t.evaluate(o))], acos: [Ct, [Ct], (o, [t]) => Math.acos(t.evaluate(o))], atan: [Ct, [Ct], (o, [t]) => Math.atan(t.evaluate(o))], min: [Ct, La(Ct), (o, t) => Math.min(...t.map(((n) => n.evaluate(o))))], max: [Ct, La(Ct), (o, t) => Math.max(...t.map(((n) => n.evaluate(o))))], abs: [Ct, [Ct], (o, [t]) => Math.abs(t.evaluate(o))], round: [Ct, [Ct], (o, [t]) => {
          const n = t.evaluate(o);
          return n < 0 ? -Math.round(-n) : Math.round(n);
        }], floor: [Ct, [Ct], (o, [t]) => Math.floor(t.evaluate(o))], ceil: [Ct, [Ct], (o, [t]) => Math.ceil(t.evaluate(o))], "filter-==": [lr, [ar, hr], (o, [t, n]) => o.properties()[t.value] === n.value], "filter-id-==": [lr, [hr], (o, [t]) => o.id() === t.value], "filter-type-==": [lr, [ar], (o, [t]) => o.geometryType() === t.value], "filter-<": [lr, [ar, hr], (o, [t, n]) => {
          const u = o.properties()[t.value], h = n.value;
          return typeof u == typeof h && u < h;
        }], "filter-id-<": [lr, [hr], (o, [t]) => {
          const n = o.id(), u = t.value;
          return typeof n == typeof u && n < u;
        }], "filter->": [lr, [ar, hr], (o, [t, n]) => {
          const u = o.properties()[t.value], h = n.value;
          return typeof u == typeof h && u > h;
        }], "filter-id->": [lr, [hr], (o, [t]) => {
          const n = o.id(), u = t.value;
          return typeof n == typeof u && n > u;
        }], "filter-<=": [lr, [ar, hr], (o, [t, n]) => {
          const u = o.properties()[t.value], h = n.value;
          return typeof u == typeof h && u <= h;
        }], "filter-id-<=": [lr, [hr], (o, [t]) => {
          const n = o.id(), u = t.value;
          return typeof n == typeof u && n <= u;
        }], "filter->=": [lr, [ar, hr], (o, [t, n]) => {
          const u = o.properties()[t.value], h = n.value;
          return typeof u == typeof h && u >= h;
        }], "filter-id->=": [lr, [hr], (o, [t]) => {
          const n = o.id(), u = t.value;
          return typeof n == typeof u && n >= u;
        }], "filter-has": [lr, [hr], (o, [t]) => t.value in o.properties()], "filter-has-id": [lr, [], (o) => o.id() !== null && o.id() !== void 0], "filter-type-in": [lr, [Vi(ar)], (o, [t]) => t.value.indexOf(o.geometryType()) >= 0], "filter-id-in": [lr, [Vi(hr)], (o, [t]) => t.value.indexOf(o.id()) >= 0], "filter-in-small": [lr, [ar, Vi(hr)], (o, [t, n]) => n.value.indexOf(o.properties()[t.value]) >= 0], "filter-in-large": [lr, [ar, Vi(hr)], (o, [t, n]) => (function(u, h, y, b) {
          for (; y <= b; ) {
            const w = y + b >> 1;
            if (h[w] === u) return true;
            h[w] > u ? b = w - 1 : y = w + 1;
          }
          return false;
        })(o.properties()[t.value], n.value, 0, n.value.length - 1)], all: { type: lr, overloads: [[[lr, lr], (o, [t, n]) => t.evaluate(o) && n.evaluate(o)], [La(lr), (o, t) => {
          for (const n of t) if (!n.evaluate(o)) return false;
          return true;
        }]] }, any: { type: lr, overloads: [[[lr, lr], (o, [t, n]) => t.evaluate(o) || n.evaluate(o)], [La(lr), (o, t) => {
          for (const n of t) if (n.evaluate(o)) return true;
          return false;
        }]] }, "!": [lr, [lr], (o, [t]) => !t.evaluate(o)], "is-supported-script": [lr, [ar], (o, [t]) => {
          const n = o.globals && o.globals.isSupportedScript;
          return !n || n(t.evaluate(o));
        }], upcase: [ar, [ar], (o, [t]) => t.evaluate(o).toUpperCase()], downcase: [ar, [ar], (o, [t]) => t.evaluate(o).toLowerCase()], concat: [ar, La(hr), (o, t) => t.map(((n) => hs(n.evaluate(o)))).join("")], "resolved-locale": [ar, [Ao], (o, [t]) => t.evaluate(o).resolvedLocale()] });
        class Uc {
          constructor(t, n, u) {
            this.expression = t, this._warningHistory = {}, this._evaluator = new Yl(), this._defaultValue = n ? (function(h) {
              if (h.type === "color" && fu(h.default)) return new fr(0, 0, 0, 0);
              switch (h.type) {
                case "color":
                  return fr.parse(h.default) || null;
                case "padding":
                  return ln.parse(h.default) || null;
                case "numberArray":
                  return Qi.parse(h.default) || null;
                case "colorArray":
                  return Pi.parse(h.default) || null;
                case "variableAnchorOffsetCollection":
                  return un.parse(h.default) || null;
                case "projectionDefinition":
                  return Nn.parse(h.default) || null;
                default:
                  return h.default === void 0 ? null : h.default;
              }
            })(n) : null, this._enumValues = n && n.type === "enum" ? n.values : null, this._globalState = u;
          }
          evaluateWithoutErrorHandling(t, n, u, h, y, b) {
            return this._globalState && (t = $a(t, this._globalState)), this._evaluator.globals = t, this._evaluator.feature = n, this._evaluator.featureState = u, this._evaluator.canonical = h, this._evaluator.availableImages = y || null, this._evaluator.formattedSection = b, this.expression.evaluate(this._evaluator);
          }
          evaluate(t, n, u, h, y, b) {
            this._globalState && (t = $a(t, this._globalState)), this._evaluator.globals = t, this._evaluator.feature = n || null, this._evaluator.featureState = u || null, this._evaluator.canonical = h, this._evaluator.availableImages = y || null, this._evaluator.formattedSection = b || null;
            try {
              const w = this.expression.evaluate(this._evaluator);
              if (w == null || typeof w == "number" && w != w) return this._defaultValue;
              if (this._enumValues && !(w in this._enumValues)) throw new ri(`Expected value to be one of ${Object.keys(this._enumValues).map(((S) => JSON.stringify(S))).join(", ")}, but found ${JSON.stringify(w)} instead.`);
              return w;
            } catch (w) {
              return this._warningHistory[w.message] || (this._warningHistory[w.message] = true, typeof console < "u" && console.warn(w.message)), this._defaultValue;
            }
          }
        }
        function pu(o) {
          return Array.isArray(o) && o.length > 0 && typeof o[0] == "string" && o[0] in vs;
        }
        function Oa(o, t, n) {
          const u = new Rr(vs, cu, [], t ? (function(y) {
            const b = { color: Bi, string: ar, number: Ct, enum: ar, boolean: lr, formatted: no, padding: Mn, numberArray: Xn, colorArray: Hn, projectionDefinition: jn, resolvedImage: En, variableAnchorOffsetCollection: ls };
            return y.type === "array" ? Vi(b[y.value] || hr, y.length) : b[y.type];
          })(t) : void 0), h = u.parse(o, void 0, void 0, void 0, t && t.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return h ? Fh(new Uc(h, t, n)) : _s(u.errors);
        }
        class ul {
          constructor(t, n, u) {
            this.kind = t, this._styleExpression = n, this.isStateDependent = t !== "constant" && !ll(n.expression), this.globalStateRefs = vu(n.expression), this._globalState = u;
          }
          evaluateWithoutErrorHandling(t, n, u, h, y, b) {
            return this._globalState && (t = $a(t, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t, n, u, h, y, b);
          }
          evaluate(t, n, u, h, y, b) {
            return this._globalState && (t = $a(t, this._globalState)), this._styleExpression.evaluate(t, n, u, h, y, b);
          }
        }
        class Gc {
          constructor(t, n, u, h, y) {
            this.kind = t, this.zoomStops = u, this._styleExpression = n, this.isStateDependent = t !== "camera" && !ll(n.expression), this.globalStateRefs = vu(n.expression), this.interpolationType = h, this._globalState = y;
          }
          evaluateWithoutErrorHandling(t, n, u, h, y, b) {
            return this._globalState && (t = $a(t, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t, n, u, h, y, b);
          }
          evaluate(t, n, u, h, y, b) {
            return this._globalState && (t = $a(t, this._globalState)), this._styleExpression.evaluate(t, n, u, h, y, b);
          }
          interpolationFactor(t, n, u) {
            return this.interpolationType ? Vr.interpolationFactor(this.interpolationType, t, n, u) : 0;
          }
        }
        function jh(o, t, n) {
          const u = Oa(o, t, n);
          if (u.result === "error") return u;
          const h = u.value.expression, y = du(h);
          if (!y && !ys(t)) return _s([new _r("", "data expressions not supported")]);
          const b = hu(h, ["zoom"]);
          if (!b && !Lh(t)) return _s([new _r("", "zoom expressions not supported")]);
          const w = gu(h);
          return w || b ? w instanceof _r ? _s([w]) : w instanceof Vr && !Vc(t) ? _s([new _r("", '"interpolate" expressions cannot be used with this property')]) : Fh(w ? new Gc(y ? "camera" : "composite", u.value, w.labels, w instanceof Vr ? w.interpolation : void 0, n) : new ul(y ? "constant" : "source", u.value, n)) : _s([new _r("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class mu {
          constructor(t, n) {
            this._parameters = t, this._specification = n, jt(this, Bh(this._parameters, this._specification));
          }
          static deserialize(t) {
            return new mu(t._parameters, t._specification);
          }
          static serialize(t) {
            return { _parameters: t._parameters, _specification: t._specification };
          }
        }
        function gu(o) {
          let t = null;
          if (o instanceof fs) t = gu(o.result);
          else if (o instanceof tl) {
            for (const n of o.args) if (t = gu(n), t) break;
          } else (o instanceof ms || o instanceof Vr) && o.input instanceof Jn && o.input.name === "zoom" && (t = o);
          return t instanceof _r || o.eachChild(((n) => {
            const u = gu(n);
            u instanceof _r ? t = u : !t && u ? t = new _r("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && u && t !== u && (t = new _r("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          })), t;
        }
        function vu(o, t = /* @__PURE__ */ new Set()) {
          return o instanceof sl && t.add(o.key), o.eachChild(((n) => {
            vu(n, t);
          })), t;
        }
        function $a(o, t) {
          const { zoom: n, heatmapDensity: u, elevation: h, lineProgress: y, isSupportedScript: b, accumulated: w } = o ?? {};
          return { zoom: n, heatmapDensity: u, elevation: h, lineProgress: y, isSupportedScript: b, accumulated: w, globalState: t };
        }
        function _u(o) {
          if (o === true || o === false) return true;
          if (!Array.isArray(o) || o.length === 0) return false;
          switch (o[0]) {
            case "has":
              return o.length >= 2 && o[1] !== "$id" && o[1] !== "$type";
            case "in":
              return o.length >= 3 && (typeof o[1] != "string" || Array.isArray(o[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return o.length !== 3 || Array.isArray(o[1]) || Array.isArray(o[2]);
            case "any":
            case "all":
              for (const t of o.slice(1)) if (!_u(t) && typeof t != "boolean") return false;
              return true;
            default:
              return true;
          }
        }
        const rm = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
        function cl(o, t) {
          if (o == null) return { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() };
          _u(o) || (o = dl(o));
          const n = Oa(o, rm, t);
          if (n.result === "error") throw new Error(n.value.map(((u) => `${u.key}: ${u.message}`)).join(", "));
          return { filter: (u, h, y) => n.value.evaluate(u, h, {}, y), needGeometry: qc(o), getGlobalStateRefs: () => vu(n.value.expression) };
        }
        function Nh(o, t) {
          return o < t ? -1 : o > t ? 1 : 0;
        }
        function qc(o) {
          if (!Array.isArray(o)) return false;
          if (o[0] === "within" || o[0] === "distance") return true;
          for (let t = 1; t < o.length; t++) if (qc(o[t])) return true;
          return false;
        }
        function dl(o) {
          if (!o) return true;
          const t = o[0];
          return o.length <= 1 ? t !== "any" : t === "==" ? Wc(o[1], o[2], "==") : t === "!=" ? yu(Wc(o[1], o[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? Wc(o[1], o[2], t) : t === "any" ? (n = o.slice(1), ["any"].concat(n.map(dl))) : t === "all" ? ["all"].concat(o.slice(1).map(dl)) : t === "none" ? ["all"].concat(o.slice(1).map(dl).map(yu)) : t === "in" ? Vh(o[1], o.slice(2)) : t === "!in" ? yu(Vh(o[1], o.slice(2))) : t === "has" ? Uh(o[1]) : t !== "!has" || yu(Uh(o[1]));
          var n;
        }
        function Wc(o, t, n) {
          switch (o) {
            case "$type":
              return [`filter-type-${n}`, t];
            case "$id":
              return [`filter-id-${n}`, t];
            default:
              return [`filter-${n}`, o, t];
          }
        }
        function Vh(o, t) {
          if (t.length === 0) return false;
          switch (o) {
            case "$type":
              return ["filter-type-in", ["literal", t]];
            case "$id":
              return ["filter-id-in", ["literal", t]];
            default:
              return t.length > 200 && !t.some(((n) => typeof n != typeof t[0])) ? ["filter-in-large", o, ["literal", t.sort(Nh)]] : ["filter-in-small", o, ["literal", t]];
          }
        }
        function Uh(o) {
          switch (o) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", o];
          }
        }
        function yu(o) {
          return ["!", o];
        }
        function bu(o) {
          const t = typeof o;
          if (t === "number" || t === "boolean" || t === "string" || o == null) return JSON.stringify(o);
          if (Array.isArray(o)) {
            let h = "[";
            for (const y of o) h += `${bu(y)},`;
            return `${h}]`;
          }
          const n = Object.keys(o).sort();
          let u = "{";
          for (let h = 0; h < n.length; h++) u += `${JSON.stringify(n[h])}:${bu(o[n[h]])},`;
          return `${u}}`;
        }
        function Gh(o) {
          let t = "";
          for (const n of rr) t += `/${bu(o[n])}`;
          return t;
        }
        function xu(o) {
          const t = o.value;
          return t ? [new Te(o.key, t, "constants have been deprecated as of v8")] : [];
        }
        function hi(o) {
          return o instanceof Number || o instanceof String || o instanceof Boolean ? o.valueOf() : o;
        }
        function Oo(o) {
          if (Array.isArray(o)) return o.map(Oo);
          if (o instanceof Object && !(o instanceof Number || o instanceof String || o instanceof Boolean)) {
            const t = {};
            for (const n in o) t[n] = Oo(o[n]);
            return t;
          }
          return hi(o);
        }
        function An(o) {
          const t = o.key, n = o.value, u = o.valueSpec || {}, h = o.objectElementValidators || {}, y = o.style, b = o.styleSpec, w = o.validateSpec;
          let S = [];
          const I = kr(n);
          if (I !== "object") return [new Te(t, n, `object expected, ${I} found`)];
          for (const E in n) {
            const O = E.split(".")[0], V = Ma(u, O) || u["*"];
            let U;
            if (Ma(h, O)) U = h[O];
            else if (Ma(u, O)) U = w;
            else if (h["*"]) U = h["*"];
            else {
              if (!u["*"]) {
                S.push(new Te(t, n[E], `unknown property "${E}"`));
                continue;
              }
              U = w;
            }
            S = S.concat(U({ key: (t && `${t}.`) + E, value: n[E], valueSpec: V, style: y, styleSpec: b, object: n, objectKey: E, validateSpec: w }, n));
          }
          for (const E in u) h[E] || u[E].required && u[E].default === void 0 && n[E] === void 0 && S.push(new Te(t, n, `missing required property "${E}"`));
          return S;
        }
        function bs(o) {
          const t = o.value, n = o.valueSpec, u = o.style, h = o.styleSpec, y = o.key, b = o.arrayElementValidator || o.validateSpec;
          if (kr(t) !== "array") return [new Te(y, t, `array expected, ${kr(t)} found`)];
          if (n.length && t.length !== n.length) return [new Te(y, t, `array length ${n.length} expected, length ${t.length} found`)];
          if (n["min-length"] && t.length < n["min-length"]) return [new Te(y, t, `array length at least ${n["min-length"]} expected, length ${t.length} found`)];
          let w = { type: n.value, values: n.values };
          h.$version < 7 && (w.function = n.function), kr(n.value) === "object" && (w = n.value);
          let S = [];
          for (let I = 0; I < t.length; I++) S = S.concat(b({ array: t, arrayIndex: I, value: t[I], valueSpec: w, validateSpec: o.validateSpec, style: u, styleSpec: h, key: `${y}[${I}]` }));
          return S;
        }
        function wu(o) {
          const t = o.key, n = o.value, u = o.valueSpec;
          let h = kr(n);
          return h === "number" && n != n && (h = "NaN"), h !== "number" ? [new Te(t, n, `number expected, ${h} found`)] : "minimum" in u && n < u.minimum ? [new Te(t, n, `${n} is less than the minimum value ${u.minimum}`)] : "maximum" in u && n > u.maximum ? [new Te(t, n, `${n} is greater than the maximum value ${u.maximum}`)] : [];
        }
        function qh(o) {
          const t = o.valueSpec, n = hi(o.value.type);
          let u, h, y, b = {};
          const w = n !== "categorical" && o.value.property === void 0, S = !w, I = kr(o.value.stops) === "array" && kr(o.value.stops[0]) === "array" && kr(o.value.stops[0][0]) === "object", E = An({ key: o.key, value: o.value, valueSpec: o.styleSpec.function, validateSpec: o.validateSpec, style: o.style, styleSpec: o.styleSpec, objectElementValidators: { stops: function(U) {
            if (n === "identity") return [new Te(U.key, U.value, 'identity function may not have a "stops" property')];
            let W = [];
            const ee = U.value;
            return W = W.concat(bs({ key: U.key, value: ee, valueSpec: U.valueSpec, validateSpec: U.validateSpec, style: U.style, styleSpec: U.styleSpec, arrayElementValidator: O })), kr(ee) === "array" && ee.length === 0 && W.push(new Te(U.key, ee, "array must have at least one stop")), W;
          }, default: function(U) {
            return U.validateSpec({ key: U.key, value: U.value, valueSpec: t, validateSpec: U.validateSpec, style: U.style, styleSpec: U.styleSpec });
          } } });
          return n === "identity" && w && E.push(new Te(o.key, o.value, 'missing required property "property"')), n === "identity" || o.value.stops || E.push(new Te(o.key, o.value, 'missing required property "stops"')), n === "exponential" && o.valueSpec.expression && !Vc(o.valueSpec) && E.push(new Te(o.key, o.value, "exponential functions not supported")), o.styleSpec.$version >= 8 && (S && !ys(o.valueSpec) ? E.push(new Te(o.key, o.value, "property functions not supported")) : w && !Lh(o.valueSpec) && E.push(new Te(o.key, o.value, "zoom functions not supported"))), n !== "categorical" && !I || o.value.property !== void 0 || E.push(new Te(o.key, o.value, '"property" property is required')), E;
          function O(U) {
            let W = [];
            const ee = U.value, se = U.key;
            if (kr(ee) !== "array") return [new Te(se, ee, `array expected, ${kr(ee)} found`)];
            if (ee.length !== 2) return [new Te(se, ee, `array length 2 expected, length ${ee.length} found`)];
            if (I) {
              if (kr(ee[0]) !== "object") return [new Te(se, ee, `object expected, ${kr(ee[0])} found`)];
              if (ee[0].zoom === void 0) return [new Te(se, ee, "object stop key must have zoom")];
              if (ee[0].value === void 0) return [new Te(se, ee, "object stop key must have value")];
              if (y && y > hi(ee[0].zoom)) return [new Te(se, ee[0].zoom, "stop zoom values must appear in ascending order")];
              hi(ee[0].zoom) !== y && (y = hi(ee[0].zoom), h = void 0, b = {}), W = W.concat(An({ key: `${se}[0]`, value: ee[0], valueSpec: { zoom: {} }, validateSpec: U.validateSpec, style: U.style, styleSpec: U.styleSpec, objectElementValidators: { zoom: wu, value: V } }));
            } else W = W.concat(V({ key: `${se}[0]`, value: ee[0], validateSpec: U.validateSpec, style: U.style, styleSpec: U.styleSpec }, ee));
            return pu(Oo(ee[1])) ? W.concat([new Te(`${se}[1]`, ee[1], "expressions are not allowed in function stops.")]) : W.concat(U.validateSpec({ key: `${se}[1]`, value: ee[1], valueSpec: t, validateSpec: U.validateSpec, style: U.style, styleSpec: U.styleSpec }));
          }
          function V(U, W) {
            const ee = kr(U.value), se = hi(U.value), pe = U.value !== null ? U.value : W;
            if (u) {
              if (ee !== u) return [new Te(U.key, pe, `${ee} stop domain type must match previous stop domain type ${u}`)];
            } else u = ee;
            if (ee !== "number" && ee !== "string" && ee !== "boolean") return [new Te(U.key, pe, "stop domain value must be a number, string, or boolean")];
            if (ee !== "number" && n !== "categorical") {
              let je = `number expected, ${ee} found`;
              return ys(t) && n === void 0 && (je += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Te(U.key, pe, je)];
            }
            return n !== "categorical" || ee !== "number" || isFinite(se) && Math.floor(se) === se ? n !== "categorical" && ee === "number" && h !== void 0 && se < h ? [new Te(U.key, pe, "stop domain values must appear in ascending order")] : (h = se, n === "categorical" && se in b ? [new Te(U.key, pe, "stop domain values must be unique")] : (b[se] = true, [])) : [new Te(U.key, pe, `integer expected, found ${se}`)];
          }
        }
        function xs(o) {
          const t = (o.expressionContext === "property" ? jh : Oa)(Oo(o.value), o.valueSpec);
          if (t.result === "error") return t.value.map(((u) => new Te(`${o.key}${u.key}`, o.value, u.message)));
          const n = t.value.expression || t.value._styleExpression.expression;
          if (o.expressionContext === "property" && o.propertyKey === "text-font" && !n.outputDefined()) return [new Te(o.key, o.value, `Invalid data expression for "${o.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (o.expressionContext === "property" && o.propertyType === "layout" && !ll(n)) return [new Te(o.key, o.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (o.expressionContext === "filter" && !ll(n)) return [new Te(o.key, o.value, '"feature-state" data expressions are not supported with filters.')];
          if (o.expressionContext && o.expressionContext.indexOf("cluster") === 0) {
            if (!hu(n, ["zoom", "feature-state"])) return [new Te(o.key, o.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (o.expressionContext === "cluster-initial" && !du(n)) return [new Te(o.key, o.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function Zc(o) {
          const t = o.key, n = o.value, u = kr(n);
          return u !== "string" ? [new Te(t, n, `color expected, ${u} found`)] : fr.parse(String(n)) ? [] : [new Te(t, n, `color expected, "${n}" found`)];
        }
        function hl(o) {
          const t = o.key, n = o.value, u = o.valueSpec, h = [];
          return Array.isArray(u.values) ? u.values.indexOf(hi(n)) === -1 && h.push(new Te(t, n, `expected one of [${u.values.join(", ")}], ${JSON.stringify(n)} found`)) : Object.keys(u.values).indexOf(hi(n)) === -1 && h.push(new Te(t, n, `expected one of [${Object.keys(u.values).join(", ")}], ${JSON.stringify(n)} found`)), h;
        }
        function Hc(o) {
          return _u(Oo(o.value)) ? xs(jt({}, o, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Xc(o);
        }
        function Xc(o) {
          const t = o.value, n = o.key;
          if (kr(t) !== "array") return [new Te(n, t, `array expected, ${kr(t)} found`)];
          const u = o.styleSpec;
          let h, y = [];
          if (t.length < 1) return [new Te(n, t, "filter array must have at least 1 element")];
          switch (y = y.concat(hl({ key: `${n}[0]`, value: t[0], valueSpec: u.filter_operator, style: o.style, styleSpec: o.styleSpec })), hi(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && hi(t[1]) === "$type" && y.push(new Te(n, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && y.push(new Te(n, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (h = kr(t[1]), h !== "string" && y.push(new Te(`${n}[1]`, t[1], `string expected, ${h} found`)));
              for (let b = 2; b < t.length; b++) h = kr(t[b]), hi(t[1]) === "$type" ? y = y.concat(hl({ key: `${n}[${b}]`, value: t[b], valueSpec: u.geometry_type, style: o.style, styleSpec: o.styleSpec })) : h !== "string" && h !== "number" && h !== "boolean" && y.push(new Te(`${n}[${b}]`, t[b], `string, number, or boolean expected, ${h} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let b = 1; b < t.length; b++) y = y.concat(Xc({ key: `${n}[${b}]`, value: t[b], style: o.style, styleSpec: o.styleSpec }));
              break;
            case "has":
            case "!has":
              h = kr(t[1]), t.length !== 2 ? y.push(new Te(n, t, `filter array for "${t[0]}" operator must have 2 elements`)) : h !== "string" && y.push(new Te(`${n}[1]`, t[1], `string expected, ${h} found`));
          }
          return y;
        }
        function Yc(o, t) {
          const n = o.key, u = o.validateSpec, h = o.style, y = o.styleSpec, b = o.value, w = o.objectKey, S = y[`${t}_${o.layerType}`];
          if (!S) return [];
          const I = w.match(/^(.*)-transition$/);
          if (t === "paint" && I && S[I[1]] && S[I[1]].transition) return u({ key: n, value: b, valueSpec: y.transition, style: h, styleSpec: y });
          const E = o.valueSpec || S[w];
          if (!E) return [new Te(n, b, `unknown property "${w}"`)];
          let O;
          if (kr(b) === "string" && ys(E) && !E.tokens && (O = /^{([^}]+)}$/.exec(b))) return [new Te(n, b, `"${w}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(O[1])} }\`.`)];
          const V = [];
          return o.layerType === "symbol" && w === "text-font" && fu(Oo(b)) && hi(b.type) === "identity" && V.push(new Te(n, b, '"text-font" does not support identity functions')), V.concat(u({ key: o.key, value: b, valueSpec: E, style: h, styleSpec: y, expressionContext: "property", propertyType: t, propertyKey: w }));
        }
        function fl(o) {
          return Yc(o, "paint");
        }
        function Wh(o) {
          return Yc(o, "layout");
        }
        function Kc(o) {
          let t = [];
          const n = o.value, u = o.key, h = o.style, y = o.styleSpec;
          if (kr(n) !== "object") return [new Te(u, n, `object expected, ${kr(n)} found`)];
          n.type || n.ref || t.push(new Te(u, n, 'either "type" or "ref" is required'));
          let b = hi(n.type);
          const w = hi(n.ref);
          if (n.id) {
            const S = hi(n.id);
            for (let I = 0; I < o.arrayIndex; I++) {
              const E = h.layers[I];
              hi(E.id) === S && t.push(new Te(u, n.id, `duplicate layer id "${n.id}", previously used at line ${E.id.__line__}`));
            }
          }
          if ("ref" in n) {
            let S;
            ["type", "source", "source-layer", "filter", "layout"].forEach(((I) => {
              I in n && t.push(new Te(u, n[I], `"${I}" is prohibited for ref layers`));
            })), h.layers.forEach(((I) => {
              hi(I.id) === w && (S = I);
            })), S ? S.ref ? t.push(new Te(u, n.ref, "ref cannot reference another ref layer")) : b = hi(S.type) : t.push(new Te(u, n.ref, `ref layer "${w}" not found`));
          } else if (b !== "background") if (n.source) {
            const S = h.sources && h.sources[n.source], I = S && hi(S.type);
            S ? I === "vector" && b === "raster" ? t.push(new Te(u, n.source, `layer "${n.id}" requires a raster source`)) : I !== "raster-dem" && b === "hillshade" || I !== "raster-dem" && b === "color-relief" ? t.push(new Te(u, n.source, `layer "${n.id}" requires a raster-dem source`)) : I === "raster" && b !== "raster" ? t.push(new Te(u, n.source, `layer "${n.id}" requires a vector source`)) : I !== "vector" || n["source-layer"] ? I === "raster-dem" && b !== "hillshade" && b !== "color-relief" ? t.push(new Te(u, n.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : b !== "line" || !n.paint || !n.paint["line-gradient"] || I === "geojson" && S.lineMetrics || t.push(new Te(u, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new Te(u, n, `layer "${n.id}" must specify a "source-layer"`)) : t.push(new Te(u, n.source, `source "${n.source}" not found`));
          } else t.push(new Te(u, n, 'missing required property "source"'));
          return t = t.concat(An({ key: u, value: n, valueSpec: y.layer, style: o.style, styleSpec: o.styleSpec, validateSpec: o.validateSpec, objectElementValidators: { "*": () => [], type: () => o.validateSpec({ key: `${u}.type`, value: n.type, valueSpec: y.layer.type, style: o.style, styleSpec: o.styleSpec, validateSpec: o.validateSpec, object: n, objectKey: "type" }), filter: Hc, layout: (S) => An({ layer: n, key: S.key, value: S.value, style: S.style, styleSpec: S.styleSpec, validateSpec: S.validateSpec, objectElementValidators: { "*": (I) => Wh(jt({ layerType: b }, I)) } }), paint: (S) => An({ layer: n, key: S.key, value: S.value, style: S.style, styleSpec: S.styleSpec, validateSpec: S.validateSpec, objectElementValidators: { "*": (I) => fl(jt({ layerType: b }, I)) } }) } })), t;
        }
        function ha(o) {
          const t = o.value, n = o.key, u = kr(t);
          return u !== "string" ? [new Te(n, t, `string expected, ${u} found`)] : [];
        }
        const Zh = { promoteId: function({ key: o, value: t }) {
          if (kr(t) === "string") return ha({ key: o, value: t });
          {
            const n = [];
            for (const u in t) n.push(...ha({ key: `${o}.${u}`, value: t[u] }));
            return n;
          }
        } };
        function Jc(o) {
          const t = o.value, n = o.key, u = o.styleSpec, h = o.style, y = o.validateSpec;
          if (!t.type) return [new Te(n, t, '"type" is required')];
          const b = hi(t.type);
          let w;
          switch (b) {
            case "vector":
            case "raster":
              return w = An({ key: n, value: t, valueSpec: u[`source_${b.replace("-", "_")}`], style: o.style, styleSpec: u, objectElementValidators: Zh, validateSpec: y }), w;
            case "raster-dem":
              return w = (function(S) {
                var I;
                const E = (I = S.sourceName) !== null && I !== void 0 ? I : "", O = S.value, V = S.styleSpec, U = V.source_raster_dem, W = S.style;
                let ee = [];
                const se = kr(O);
                if (O === void 0) return ee;
                if (se !== "object") return ee.push(new Te("source_raster_dem", O, `object expected, ${se} found`)), ee;
                const pe = hi(O.encoding) === "custom", je = ["redFactor", "greenFactor", "blueFactor", "baseShift"], be = S.value.encoding ? `"${S.value.encoding}"` : "Default";
                for (const Me in O) !pe && je.includes(Me) ? ee.push(new Te(Me, O[Me], `In "${E}": "${Me}" is only valid when "encoding" is set to "custom". ${be} encoding found`)) : U[Me] ? ee = ee.concat(S.validateSpec({ key: Me, value: O[Me], valueSpec: U[Me], validateSpec: S.validateSpec, style: W, styleSpec: V })) : ee.push(new Te(Me, O[Me], `unknown property "${Me}"`));
                return ee;
              })({ sourceName: n, value: t, style: o.style, styleSpec: u, validateSpec: y }), w;
            case "geojson":
              if (w = An({ key: n, value: t, valueSpec: u.source_geojson, style: h, styleSpec: u, validateSpec: y, objectElementValidators: Zh }), t.cluster) for (const S in t.clusterProperties) {
                const [I, E] = t.clusterProperties[S], O = typeof I == "string" ? [I, ["accumulated"], ["get", S]] : I;
                w.push(...xs({ key: `${n}.${S}.map`, value: E, expressionContext: "cluster-map" })), w.push(...xs({ key: `${n}.${S}.reduce`, value: O, expressionContext: "cluster-reduce" }));
              }
              return w;
            case "video":
              return An({ key: n, value: t, valueSpec: u.source_video, style: h, validateSpec: y, styleSpec: u });
            case "image":
              return An({ key: n, value: t, valueSpec: u.source_image, style: h, validateSpec: y, styleSpec: u });
            case "canvas":
              return [new Te(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return hl({ key: `${n}.type`, value: t.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
          }
        }
        function Qc(o) {
          const t = o.value, n = o.styleSpec, u = n.light, h = o.style;
          let y = [];
          const b = kr(t);
          if (t === void 0) return y;
          if (b !== "object") return y = y.concat([new Te("light", t, `object expected, ${b} found`)]), y;
          for (const w in t) {
            const S = w.match(/^(.*)-transition$/);
            y = y.concat(S && u[S[1]] && u[S[1]].transition ? o.validateSpec({ key: w, value: t[w], valueSpec: n.transition, validateSpec: o.validateSpec, style: h, styleSpec: n }) : u[w] ? o.validateSpec({ key: w, value: t[w], valueSpec: u[w], validateSpec: o.validateSpec, style: h, styleSpec: n }) : [new Te(w, t[w], `unknown property "${w}"`)]);
          }
          return y;
        }
        function ws(o) {
          const t = o.value, n = o.styleSpec, u = n.sky, h = o.style, y = kr(t);
          if (t === void 0) return [];
          if (y !== "object") return [new Te("sky", t, `object expected, ${y} found`)];
          let b = [];
          for (const w in t) b = b.concat(u[w] ? o.validateSpec({ key: w, value: t[w], valueSpec: u[w], style: h, styleSpec: n }) : [new Te(w, t[w], `unknown property "${w}"`)]);
          return b;
        }
        function Hh(o) {
          const t = o.value, n = o.styleSpec, u = n.terrain, h = o.style;
          let y = [];
          const b = kr(t);
          if (t === void 0) return y;
          if (b !== "object") return y = y.concat([new Te("terrain", t, `object expected, ${b} found`)]), y;
          for (const w in t) y = y.concat(u[w] ? o.validateSpec({ key: w, value: t[w], valueSpec: u[w], validateSpec: o.validateSpec, style: h, styleSpec: n }) : [new Te(w, t[w], `unknown property "${w}"`)]);
          return y;
        }
        function Xh(o) {
          let t = [];
          const n = o.value, u = o.key;
          if (Array.isArray(n)) {
            const h = [], y = [];
            for (const b in n) n[b].id && h.includes(n[b].id) && t.push(new Te(u, n, `all the sprites' ids must be unique, but ${n[b].id} is duplicated`)), h.push(n[b].id), n[b].url && y.includes(n[b].url) && t.push(new Te(u, n, `all the sprites' URLs must be unique, but ${n[b].url} is duplicated`)), y.push(n[b].url), t = t.concat(An({ key: `${u}[${b}]`, value: n[b], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: o.validateSpec }));
            return t;
          }
          return ha({ key: u, value: n });
        }
        function Yh(o) {
          return t = o.value, t && t.constructor === Object ? [] : [new Te(o.key, o.value, `object expected, ${kr(o.value)} found`)];
          var t;
        }
        const Kh = { "*": () => [], array: bs, boolean: function(o) {
          const t = o.value, n = o.key, u = kr(t);
          return u !== "boolean" ? [new Te(n, t, `boolean expected, ${u} found`)] : [];
        }, number: wu, color: Zc, constants: xu, enum: hl, filter: Hc, function: qh, layer: Kc, object: An, source: Jc, light: Qc, sky: ws, terrain: Hh, projection: function(o) {
          const t = o.value, n = o.styleSpec, u = n.projection, h = o.style, y = kr(t);
          if (t === void 0) return [];
          if (y !== "object") return [new Te("projection", t, `object expected, ${y} found`)];
          let b = [];
          for (const w in t) b = b.concat(u[w] ? o.validateSpec({ key: w, value: t[w], valueSpec: u[w], style: h, styleSpec: n }) : [new Te(w, t[w], `unknown property "${w}"`)]);
          return b;
        }, projectionDefinition: function(o) {
          const t = o.key;
          let n = o.value;
          n = n instanceof String ? n.valueOf() : n;
          const u = kr(n);
          return u !== "array" || (function(h) {
            return Array.isArray(h) && h.length === 3 && typeof h[0] == "string" && typeof h[1] == "string" && typeof h[2] == "number";
          })(n) || (function(h) {
            return !!["interpolate", "step", "literal"].includes(h[0]);
          })(n) ? ["array", "string"].includes(u) ? [] : [new Te(t, n, `projection expected, invalid type "${u}" found`)] : [new Te(t, n, `projection expected, invalid array ${JSON.stringify(n)} found`)];
        }, string: ha, formatted: function(o) {
          return ha(o).length === 0 ? [] : xs(o);
        }, resolvedImage: function(o) {
          return ha(o).length === 0 ? [] : xs(o);
        }, padding: function(o) {
          const t = o.key, n = o.value;
          if (kr(n) === "array") {
            if (n.length < 1 || n.length > 4) return [new Te(t, n, `padding requires 1 to 4 values; ${n.length} values found`)];
            const u = { type: "number" };
            let h = [];
            for (let y = 0; y < n.length; y++) h = h.concat(o.validateSpec({ key: `${t}[${y}]`, value: n[y], validateSpec: o.validateSpec, valueSpec: u }));
            return h;
          }
          return wu({ key: t, value: n, valueSpec: {} });
        }, numberArray: function(o) {
          const t = o.key, n = o.value;
          if (kr(n) === "array") {
            const u = { type: "number" };
            if (n.length < 1) return [new Te(t, n, "array length at least 1 expected, length 0 found")];
            let h = [];
            for (let y = 0; y < n.length; y++) h = h.concat(o.validateSpec({ key: `${t}[${y}]`, value: n[y], validateSpec: o.validateSpec, valueSpec: u }));
            return h;
          }
          return wu({ key: t, value: n, valueSpec: {} });
        }, colorArray: function(o) {
          const t = o.key, n = o.value;
          if (kr(n) === "array") {
            if (n.length < 1) return [new Te(t, n, "array length at least 1 expected, length 0 found")];
            let u = [];
            for (let h = 0; h < n.length; h++) u = u.concat(Zc({ key: `${t}[${h}]`, value: n[h] }));
            return u;
          }
          return Zc({ key: t, value: n });
        }, variableAnchorOffsetCollection: function(o) {
          const t = o.key, n = o.value, u = kr(n), h = o.styleSpec;
          if (u !== "array" || n.length < 1 || n.length % 2 != 0) return [new Te(t, n, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let y = [];
          for (let b = 0; b < n.length; b += 2) y = y.concat(hl({ key: `${t}[${b}]`, value: n[b], valueSpec: h.layout_symbol["text-anchor"] })), y = y.concat(bs({ key: `${t}[${b + 1}]`, value: n[b + 1], valueSpec: { length: 2, value: "number" }, validateSpec: o.validateSpec, style: o.style, styleSpec: h }));
          return y;
        }, sprite: Xh, state: Yh };
        function Cu(o) {
          const t = o.value, n = o.valueSpec, u = o.styleSpec;
          return o.validateSpec = Cu, n.expression && fu(hi(t)) ? qh(o) : n.expression && pu(Oo(t)) ? xs(o) : n.type && Kh[n.type] ? Kh[n.type](o) : An(jt({}, o, { valueSpec: n.type ? u[n.type] : n }));
        }
        function Jh(o) {
          const t = o.value, n = o.key, u = ha(o);
          return u.length || (t.indexOf("{fontstack}") === -1 && u.push(new Te(n, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && u.push(new Te(n, t, '"glyphs" url must include a "{range}" token'))), u;
        }
        function cn(o, t = Le) {
          let n = [];
          return n = n.concat(Cu({ key: "", value: o, valueSpec: t.$root, styleSpec: t, style: o, validateSpec: Cu, objectElementValidators: { glyphs: Jh, "*": () => [] } })), o.constants && (n = n.concat(xu({ key: "constants", value: o.constants }))), Dn(n);
        }
        function vn(o) {
          return function(t) {
            return o(Object.assign({}, t, { validateSpec: Cu }));
          };
        }
        function Dn(o) {
          return [].concat(o).sort(((t, n) => t.line - n.line));
        }
        function _n(o) {
          return function(...t) {
            return Dn(o.apply(this, t));
          };
        }
        cn.source = _n(vn(Jc)), cn.sprite = _n(vn(Xh)), cn.glyphs = _n(vn(Jh)), cn.light = _n(vn(Qc)), cn.sky = _n(vn(ws)), cn.terrain = _n(vn(Hh)), cn.state = _n(vn(Yh)), cn.layer = _n(vn(Kc)), cn.filter = _n(vn(Hc)), cn.paintProperty = _n(vn(fl)), cn.layoutProperty = _n(vn(Wh));
        const Qh = Le, Cs = cn, im = Cs.light, pl = Cs.sky, ef = Cs.paintProperty, ed = Cs.layoutProperty;
        function tf(o, t) {
          let n = false;
          if (t && t.length) for (const u of t) o.fire(new We(new Error(u.message))), n = true;
          return n;
        }
        class ja {
          constructor(t, n, u) {
            const h = this.cells = [];
            if (t instanceof ArrayBuffer) {
              this.arrayBuffer = t;
              const b = new Int32Array(this.arrayBuffer);
              t = b[0], this.d = (n = b[1]) + 2 * (u = b[2]);
              for (let S = 0; S < this.d * this.d; S++) {
                const I = b[3 + S], E = b[3 + S + 1];
                h.push(I === E ? null : b.subarray(I, E));
              }
              const w = b[3 + h.length + 1];
              this.keys = b.subarray(b[3 + h.length], w), this.bboxes = b.subarray(w), this.insert = this._insertReadonly;
            } else {
              this.d = n + 2 * u;
              for (let b = 0; b < this.d * this.d; b++) h.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = n, this.extent = t, this.padding = u, this.scale = n / t, this.uid = 0;
            const y = u / n * t;
            this.min = -y, this.max = t + y;
          }
          insert(t, n, u, h, y) {
            this._forEachCell(n, u, h, y, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(n), this.bboxes.push(u), this.bboxes.push(h), this.bboxes.push(y);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(t, n, u, h, y, b) {
            this.cells[y].push(b);
          }
          query(t, n, u, h, y) {
            const b = this.min, w = this.max;
            if (t <= b && n <= b && w <= u && w <= h && !y) return Array.prototype.slice.call(this.keys);
            {
              const S = [];
              return this._forEachCell(t, n, u, h, this._queryCell, S, {}, y), S;
            }
          }
          _queryCell(t, n, u, h, y, b, w, S) {
            const I = this.cells[y];
            if (I !== null) {
              const E = this.keys, O = this.bboxes;
              for (let V = 0; V < I.length; V++) {
                const U = I[V];
                if (w[U] === void 0) {
                  const W = 4 * U;
                  (S ? S(O[W + 0], O[W + 1], O[W + 2], O[W + 3]) : t <= O[W + 2] && n <= O[W + 3] && u >= O[W + 0] && h >= O[W + 1]) ? (w[U] = true, b.push(E[U])) : w[U] = false;
                }
              }
            }
          }
          _forEachCell(t, n, u, h, y, b, w, S) {
            const I = this._convertToCellCoord(t), E = this._convertToCellCoord(n), O = this._convertToCellCoord(u), V = this._convertToCellCoord(h);
            for (let U = I; U <= O; U++) for (let W = E; W <= V; W++) {
              const ee = this.d * W + U;
              if ((!S || S(this._convertFromCellCoord(U), this._convertFromCellCoord(W), this._convertFromCellCoord(U + 1), this._convertFromCellCoord(W + 1))) && y.call(this, t, n, u, h, ee, b, w, S)) return;
            }
          }
          _convertFromCellCoord(t) {
            return (t - this.padding) / this.scale;
          }
          _convertToCellCoord(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t = this.cells, n = 3 + this.cells.length + 1 + 1;
            let u = 0;
            for (let b = 0; b < this.cells.length; b++) u += this.cells[b].length;
            const h = new Int32Array(n + u + this.keys.length + this.bboxes.length);
            h[0] = this.extent, h[1] = this.n, h[2] = this.padding;
            let y = n;
            for (let b = 0; b < t.length; b++) {
              const w = t[b];
              h[3 + b] = y, h.set(w, y), y += w.length;
            }
            return h[3 + t.length] = y, h.set(this.keys, y), y += this.keys.length, h[3 + t.length + 1] = y, h.set(this.bboxes, y), y += this.bboxes.length, h.buffer;
          }
          static serialize(t, n) {
            const u = t.toArrayBuffer();
            return n && n.push(u), { buffer: u };
          }
          static deserialize(t) {
            return new ja(t.buffer);
          }
        }
        const $o = {};
        function Dt(o, t, n = {}) {
          if ($o[o]) throw new Error(`${o} is already registered.`);
          Object.defineProperty(t, "_classRegistryKey", { value: o, writeable: false }), $o[o] = { klass: t, omit: n.omit || [], shallow: n.shallow || [] };
        }
        Dt("Object", Object), Dt("Set", Set), Dt("TransferableGridIndex", ja), Dt("Color", fr), Dt("Error", Error), Dt("AJAXError", ve), Dt("ResolvedImage", gn), Dt("StylePropertyFunction", mu), Dt("StyleExpression", Uc, { omit: ["_evaluator"] }), Dt("ZoomDependentExpression", Gc), Dt("ZoomConstantExpression", ul), Dt("CompoundExpression", Jn, { omit: ["_evaluate"] });
        for (const o in vs) vs[o]._classRegistryKey || Dt(`Expression_${o}`, vs[o]);
        function rf(o) {
          return o && typeof ArrayBuffer < "u" && (o instanceof ArrayBuffer || o.constructor && o.constructor.name === "ArrayBuffer");
        }
        function td(o) {
          return o.$name || o.constructor._classRegistryKey;
        }
        function nf(o) {
          return !(function(t) {
            if (t === null || typeof t != "object") return false;
            const n = td(t);
            return !(!n || n === "Object");
          })(o) && (o == null || typeof o == "boolean" || typeof o == "number" || typeof o == "string" || o instanceof Boolean || o instanceof Number || o instanceof String || o instanceof Date || o instanceof RegExp || o instanceof Blob || o instanceof Error || rf(o) || at(o) || ArrayBuffer.isView(o) || o instanceof ImageData);
        }
        function jo(o, t) {
          if (nf(o)) return (rf(o) || at(o)) && t && t.push(o), ArrayBuffer.isView(o) && t && t.push(o.buffer), o instanceof ImageData && t && t.push(o.data.buffer), o;
          if (Array.isArray(o)) {
            const y = [];
            for (const b of o) y.push(jo(b, t));
            return y;
          }
          if (typeof o != "object") throw new Error("can't serialize object of type " + typeof o);
          const n = td(o);
          if (!n) throw new Error(`can't serialize object of unregistered class ${o.constructor.name}`);
          if (!$o[n]) throw new Error(`${n} is not registered.`);
          const { klass: u } = $o[n], h = u.serialize ? u.serialize(o, t) : {};
          if (u.serialize) {
            if (t && h === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const y in o) {
              if (!o.hasOwnProperty(y) || $o[n].omit.indexOf(y) >= 0) continue;
              const b = o[y];
              h[y] = $o[n].shallow.indexOf(y) >= 0 ? b : jo(b, t);
            }
            o instanceof Error && (h.message = o.message);
          }
          if (h.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return n !== "Object" && (h.$name = n), h;
        }
        function ml(o) {
          if (nf(o)) return o;
          if (Array.isArray(o)) return o.map(ml);
          if (typeof o != "object") throw new Error("can't deserialize object of type " + typeof o);
          const t = td(o) || "Object";
          if (!$o[t]) throw new Error(`can't deserialize unregistered class ${t}`);
          const { klass: n } = $o[t];
          if (!n) throw new Error(`can't deserialize unregistered class ${t}`);
          if (n.deserialize) return n.deserialize(o);
          const u = Object.create(n.prototype);
          for (const h of Object.keys(o)) {
            if (h === "$name") continue;
            const y = o[h];
            u[h] = $o[t].shallow.indexOf(h) >= 0 ? y : ml(y);
          }
          return u;
        }
        class rd {
          constructor() {
            this.first = true;
          }
          update(t, n) {
            const u = Math.floor(t);
            return this.first ? (this.first = false, this.lastIntegerZoom = u, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = u, true) : (this.lastFloorZoom > u ? (this.lastIntegerZoom = u + 1, this.lastIntegerZoomTime = n) : this.lastFloorZoom < u && (this.lastIntegerZoom = u, this.lastIntegerZoomTime = n), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = u, true));
          }
        }
        const wr = { "Latin-1 Supplement": (o) => o >= 128 && o <= 255, "Hangul Jamo": (o) => o >= 4352 && o <= 4607, Khmer: (o) => o >= 6016 && o <= 6143, "General Punctuation": (o) => o >= 8192 && o <= 8303, "Letterlike Symbols": (o) => o >= 8448 && o <= 8527, "Number Forms": (o) => o >= 8528 && o <= 8591, "Miscellaneous Technical": (o) => o >= 8960 && o <= 9215, "Control Pictures": (o) => o >= 9216 && o <= 9279, "Optical Character Recognition": (o) => o >= 9280 && o <= 9311, "Enclosed Alphanumerics": (o) => o >= 9312 && o <= 9471, "Geometric Shapes": (o) => o >= 9632 && o <= 9727, "Miscellaneous Symbols": (o) => o >= 9728 && o <= 9983, "Miscellaneous Symbols and Arrows": (o) => o >= 11008 && o <= 11263, "Ideographic Description Characters": (o) => o >= 12272 && o <= 12287, "CJK Symbols and Punctuation": (o) => o >= 12288 && o <= 12351, Hiragana: (o) => o >= 12352 && o <= 12447, Katakana: (o) => o >= 12448 && o <= 12543, Kanbun: (o) => o >= 12688 && o <= 12703, "CJK Strokes": (o) => o >= 12736 && o <= 12783, "Enclosed CJK Letters and Months": (o) => o >= 12800 && o <= 13055, "CJK Compatibility": (o) => o >= 13056 && o <= 13311, "Yijing Hexagram Symbols": (o) => o >= 19904 && o <= 19967, "CJK Unified Ideographs": (o) => o >= 19968 && o <= 40959, "Hangul Syllables": (o) => o >= 44032 && o <= 55215, "Private Use Area": (o) => o >= 57344 && o <= 63743, "Vertical Forms": (o) => o >= 65040 && o <= 65055, "CJK Compatibility Forms": (o) => o >= 65072 && o <= 65103, "Small Form Variants": (o) => o >= 65104 && o <= 65135, "Halfwidth and Fullwidth Forms": (o) => o >= 65280 && o <= 65519 };
        function id(o) {
          for (const t of o) if (Su(t.charCodeAt(0))) return true;
          return false;
        }
        function nd(o) {
          for (const t of o) if (!af(t.charCodeAt(0))) return false;
          return true;
        }
        function Ss(o) {
          const t = o.map(((n) => {
            try {
              return new RegExp(`\\p{sc=${n}}`, "u").source;
            } catch {
              return null;
            }
          })).filter(((n) => n));
          return new RegExp(t.join("|"), "u");
        }
        const of = Ss(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
        function af(o) {
          return !of.test(String.fromCodePoint(o));
        }
        const od = Ss(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
        function Su(o) {
          return !(o !== 746 && o !== 747 && (o < 4352 || !(wr["CJK Compatibility Forms"](o) && !(o >= 65097 && o <= 65103) || wr["CJK Compatibility"](o) || wr["CJK Strokes"](o) || !(!wr["CJK Symbols and Punctuation"](o) || o >= 12296 && o <= 12305 || o >= 12308 && o <= 12319 || o === 12336) || wr["Enclosed CJK Letters and Months"](o) || wr["Ideographic Description Characters"](o) || wr.Kanbun(o) || wr.Katakana(o) && o !== 12540 || !(!wr["Halfwidth and Fullwidth Forms"](o) || o === 65288 || o === 65289 || o === 65293 || o >= 65306 && o <= 65310 || o === 65339 || o === 65341 || o === 65343 || o >= 65371 && o <= 65503 || o === 65507 || o >= 65512 && o <= 65519) || !(!wr["Small Form Variants"](o) || o >= 65112 && o <= 65118 || o >= 65123 && o <= 65126) || wr["Vertical Forms"](o) || wr["Yijing Hexagram Symbols"](o) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(o)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(o)) || od.test(String.fromCodePoint(o)))));
        }
        function ku(o) {
          return !(Su(o) || (function(t) {
            return !!(wr["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || wr["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || wr["Letterlike Symbols"](t) || wr["Number Forms"](t) || wr["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || wr["Control Pictures"](t) && t !== 9251 || wr["Optical Character Recognition"](t) || wr["Enclosed Alphanumerics"](t) || wr["Geometric Shapes"](t) || wr["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || wr["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || wr["CJK Symbols and Punctuation"](t) || wr.Katakana(t) || wr["Private Use Area"](t) || wr["CJK Compatibility Forms"](t) || wr["Small Form Variants"](t) || wr["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533);
          })(o));
        }
        const sf = Ss(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
        function lf(o) {
          return sf.test(String.fromCodePoint(o));
        }
        function uf(o, t) {
          return !(!t && lf(o) || o >= 2304 && o <= 3583 || o >= 3840 && o <= 4255 || wr.Khmer(o));
        }
        function nm(o) {
          for (const t of o) if (lf(t.charCodeAt(0))) return true;
          return false;
        }
        const No = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
            };
          }
          setState(o) {
            this.pluginStatus = o.pluginStatus, this.pluginURL = o.pluginURL;
          }
          getState() {
            return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
          }
          setMethods(o) {
            if (No.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = o.applyArabicShaping, this.processBidirectionalText = o.processBidirectionalText, this.processStyledBidirectionalText = o.processStyledBidirectionalText, this.loadScriptResolve();
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
          syncState(o, t) {
            return s(this, void 0, void 0, (function* () {
              if (this.isParsed()) return this.getState();
              if (o.pluginStatus !== "loading") return this.setState(o), o;
              const n = o.pluginURL, u = new Promise(((y) => {
                this.loadScriptResolve = y;
              }));
              t(n);
              const h = new Promise(((y) => setTimeout((() => y()), this.TIMEOUT)));
              if (yield Promise.race([u, h]), this.isParsed()) {
                const y = { pluginStatus: "loaded", pluginURL: n };
                return this.setState(y), y;
              }
              throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${n}`);
            }));
          }
        }();
        class Yr {
          constructor(t, n) {
            this.isSupportedScript = cf, this.zoom = t, n ? (this.now = n.now || 0, this.fadeDuration = n.fadeDuration || 0, this.zoomHistory = n.zoomHistory || new rd(), this.transition = n.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new rd(), this.transition = {});
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const t = this.zoom, n = t - Math.floor(t), u = this.crossFadingFactor();
            return t > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: n + (1 - n) * u } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - u) * n };
          }
        }
        function cf(o) {
          return (function(t, n) {
            for (const u of t) if (!uf(u.charCodeAt(0), n)) return false;
            return true;
          })(o, No.getRTLTextPluginStatus() === "loaded");
        }
        class gl {
          constructor(t, n, u) {
            this.property = t, this.value = n, this.expression = (function(h, y, b) {
              if (fu(h)) return new mu(h, y);
              if (pu(h)) {
                const w = jh(h, y, b);
                if (w.result === "error") throw new Error(w.value.map(((S) => `${S.key}: ${S.message}`)).join(", "));
                return w.value;
              }
              {
                let w = h;
                return y.type === "color" && typeof h == "string" ? w = fr.parse(h) : y.type !== "padding" || typeof h != "number" && !Array.isArray(h) ? y.type !== "numberArray" || typeof h != "number" && !Array.isArray(h) ? y.type !== "colorArray" || typeof h != "string" && !Array.isArray(h) ? y.type === "variableAnchorOffsetCollection" && Array.isArray(h) ? w = un.parse(h) : y.type === "projectionDefinition" && typeof h == "string" && (w = Nn.parse(h)) : w = Pi.parse(h) : w = Qi.parse(h) : w = ln.parse(h), { globalStateRefs: /* @__PURE__ */ new Set(), _globalState: null, kind: "constant", evaluate: () => w };
              }
            })(n === void 0 ? t.specification.default : n, t.specification, u);
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite";
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
          }
          possiblyEvaluate(t, n, u) {
            return this.property.possiblyEvaluate(this, t, n, u);
          }
        }
        class ad {
          constructor(t, n) {
            this.property = t, this.value = new gl(t, void 0, n);
          }
          transitioned(t, n) {
            return new sd(this.property, this.value, n, Zt({}, t.transition, this.transition), t.now);
          }
          untransitioned() {
            return new sd(this.property, this.value, null, {}, 0);
          }
        }
        class df {
          constructor(t, n) {
            this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues), this._globalState = n;
          }
          getValue(t) {
            return or(this._values[t].value.value);
          }
          setValue(t, n) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new ad(this._values[t].property, this._globalState)), this._values[t].value = new gl(this._values[t].property, n === null ? void 0 : or(n), this._globalState);
          }
          getTransition(t) {
            return or(this._values[t].transition);
          }
          setTransition(t, n) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new ad(this._values[t].property, this._globalState)), this._values[t].transition = or(n) || void 0;
          }
          serialize() {
            const t = {};
            for (const n of Object.keys(this._values)) {
              const u = this.getValue(n);
              u !== void 0 && (t[n] = u);
              const h = this.getTransition(n);
              h !== void 0 && (t[`${n}-transition`] = h);
            }
            return t;
          }
          transitioned(t, n) {
            const u = new ld(this._properties);
            for (const h of Object.keys(this._values)) u._values[h] = this._values[h].transitioned(t, n._values[h]);
            return u;
          }
          untransitioned() {
            const t = new ld(this._properties);
            for (const n of Object.keys(this._values)) t._values[n] = this._values[n].untransitioned();
            return t;
          }
        }
        class sd {
          constructor(t, n, u, h, y) {
            this.property = t, this.value = n, this.begin = y + h.delay || 0, this.end = this.begin + h.duration || 0, t.specification.transition && (h.delay || h.duration) && (this.prior = u);
          }
          possiblyEvaluate(t, n, u) {
            const h = t.now || 0, y = this.value.possiblyEvaluate(t, n, u), b = this.prior;
            if (b) {
              if (h > this.end) return this.prior = null, y;
              if (this.value.isDataDriven()) return this.prior = null, y;
              if (h < this.begin) return b.possiblyEvaluate(t, n, u);
              {
                const w = (h - this.begin) / (this.end - this.begin);
                return this.property.interpolate(b.possiblyEvaluate(t, n, u), y, wt(w));
              }
            }
            return y;
          }
        }
        class ld {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t, n, u) {
            const h = new Na(this._properties);
            for (const y of Object.keys(this._values)) h._values[y] = this._values[y].possiblyEvaluate(t, n, u);
            return h;
          }
          hasTransition() {
            for (const t of Object.keys(this._values)) if (this._values[t].prior) return true;
            return false;
          }
        }
        class hf {
          constructor(t, n) {
            this._properties = t, this._values = Object.create(t.defaultPropertyValues), this._globalState = n;
          }
          hasValue(t) {
            return this._values[t].value !== void 0;
          }
          getValue(t) {
            return or(this._values[t].value);
          }
          setValue(t, n) {
            this._values[t] = new gl(this._values[t].property, n === null ? void 0 : or(n), this._globalState);
          }
          serialize() {
            const t = {};
            for (const n of Object.keys(this._values)) {
              const u = this.getValue(n);
              u !== void 0 && (t[n] = u);
            }
            return t;
          }
          possiblyEvaluate(t, n, u) {
            const h = new Na(this._properties);
            for (const y of Object.keys(this._values)) h._values[y] = this._values[y].possiblyEvaluate(t, n, u);
            return h;
          }
        }
        class lo {
          constructor(t, n, u) {
            this.property = t, this.value = n, this.parameters = u;
          }
          isConstant() {
            return this.value.kind === "constant";
          }
          constantOr(t) {
            return this.value.kind === "constant" ? this.value.value : t;
          }
          evaluate(t, n, u, h) {
            return this.property.evaluate(this.value, this.parameters, t, n, u, h);
          }
        }
        class Na {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);
          }
          get(t) {
            return this._values[t];
          }
        }
        class qt {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, n) {
            if (t.isDataDriven()) throw new Error("Value should not be data driven");
            return t.expression.evaluate(n);
          }
          interpolate(t, n, u) {
            const h = Kn[this.specification.type];
            return h ? h(t, n, u) : t;
          }
        }
        class er {
          constructor(t, n) {
            this.specification = t, this.overrides = n;
          }
          possiblyEvaluate(t, n, u, h) {
            return new lo(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? { kind: "constant", value: t.expression.evaluate(n, null, {}, u, h) } : t.expression, n);
          }
          interpolate(t, n, u) {
            if (t.value.kind !== "constant" || n.value.kind !== "constant") return t;
            if (t.value.value === void 0 || n.value.value === void 0) return new lo(this, { kind: "constant", value: void 0 }, t.parameters);
            const h = Kn[this.specification.type];
            if (h) {
              const y = h(t.value.value, n.value.value, u);
              return new lo(this, { kind: "constant", value: y }, t.parameters);
            }
            return t;
          }
          evaluate(t, n, u, h, y, b) {
            return t.kind === "constant" ? t.value : t.evaluate(n, u, h, y, b);
          }
        }
        class vl extends er {
          possiblyEvaluate(t, n, u, h) {
            if (t.value === void 0) return new lo(this, { kind: "constant", value: void 0 }, n);
            if (t.expression.kind === "constant") {
              const y = t.expression.evaluate(n, null, {}, u, h), b = t.property.specification.type === "resolvedImage" && typeof y != "string" ? y.name : y, w = this._calculate(b, b, b, n);
              return new lo(this, { kind: "constant", value: w }, n);
            }
            if (t.expression.kind === "camera") {
              const y = this._calculate(t.expression.evaluate({ zoom: n.zoom - 1 }), t.expression.evaluate({ zoom: n.zoom }), t.expression.evaluate({ zoom: n.zoom + 1 }), n);
              return new lo(this, { kind: "constant", value: y }, n);
            }
            return new lo(this, t.expression, n);
          }
          evaluate(t, n, u, h, y, b) {
            if (t.kind === "source") {
              const w = t.evaluate(n, u, h, y, b);
              return this._calculate(w, w, w, n);
            }
            return t.kind === "composite" ? this._calculate(t.evaluate({ zoom: Math.floor(n.zoom) - 1 }, u, h), t.evaluate({ zoom: Math.floor(n.zoom) }, u, h), t.evaluate({ zoom: Math.floor(n.zoom) + 1 }, u, h), n) : t.value;
          }
          _calculate(t, n, u, h) {
            return h.zoom > h.zoomHistory.lastIntegerZoom ? { from: t, to: n } : { from: u, to: n };
          }
          interpolate(t) {
            return t;
          }
        }
        class ff {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, n, u, h) {
            if (t.value !== void 0) {
              if (t.expression.kind === "constant") {
                const y = t.expression.evaluate(n, null, {}, u, h);
                return this._calculate(y, y, y, n);
              }
              return this._calculate(t.expression.evaluate(new Yr(Math.floor(n.zoom - 1), n)), t.expression.evaluate(new Yr(Math.floor(n.zoom), n)), t.expression.evaluate(new Yr(Math.floor(n.zoom + 1), n)), n);
            }
          }
          _calculate(t, n, u, h) {
            return h.zoom > h.zoomHistory.lastIntegerZoom ? { from: t, to: n } : { from: u, to: n };
          }
          interpolate(t) {
            return t;
          }
        }
        class _l {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, n, u, h) {
            return !!t.expression.evaluate(n, null, {}, u, h);
          }
          interpolate() {
            return false;
          }
        }
        class dn {
          constructor(t) {
            this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const n in t) {
              const u = t[n];
              u.specification.overridable && this.overridableProperties.push(n);
              const h = this.defaultPropertyValues[n] = new gl(u, void 0, void 0), y = this.defaultTransitionablePropertyValues[n] = new ad(u, void 0);
              this.defaultTransitioningPropertyValues[n] = y.untransitioned(), this.defaultPossiblyEvaluatedValues[n] = h.possiblyEvaluate({});
            }
          }
        }
        Dt("DataDrivenProperty", er), Dt("DataConstantProperty", qt), Dt("CrossFadedDataDrivenProperty", vl), Dt("CrossFadedProperty", ff), Dt("ColorRampProperty", _l);
        const ud = "-transition";
        class uo extends xt {
          constructor(t, n, u) {
            if (super(), this.id = t.id, this.type = t.type, this._globalState = u, this._featureFilter = { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter, this._featureFilter = cl(t.filter, u)), n.layout && (this._unevaluatedLayout = new hf(n.layout, u)), n.paint)) {
              this._transitionablePaint = new df(n.paint, u);
              for (const h in t.paint) this.setPaintProperty(h, t.paint[h], { validate: false });
              for (const h in t.layout) this.setLayoutProperty(h, t.layout[h], { validate: false });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Na(n.paint);
            }
          }
          setFilter(t) {
            this.filter = t, this._featureFilter = cl(t, this._globalState);
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(t) {
            return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t);
          }
          getLayoutAffectingGlobalStateRefs() {
            const t = /* @__PURE__ */ new Set();
            if (this._unevaluatedLayout) for (const n in this._unevaluatedLayout._values) {
              const u = this._unevaluatedLayout._values[n];
              for (const h of u.getGlobalStateRefs()) t.add(h);
            }
            for (const n of this._featureFilter.getGlobalStateRefs()) t.add(n);
            return t;
          }
          getPaintAffectingGlobalStateRefs() {
            var t;
            const n = new globalThis.Map();
            if (this._transitionablePaint) for (const u in this._transitionablePaint._values) {
              const h = this._transitionablePaint._values[u].value;
              for (const y of h.getGlobalStateRefs()) {
                const b = (t = n.get(y)) !== null && t !== void 0 ? t : [];
                b.push({ name: u, value: h.value }), n.set(y, b);
              }
            }
            return n;
          }
          setLayoutProperty(t, n, u = {}) {
            n != null && this._validate(ed, `layers.${this.id}.layout.${t}`, t, n, u) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, n) : this.visibility = n);
          }
          getPaintProperty(t) {
            return t.endsWith(ud) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t);
          }
          setPaintProperty(t, n, u = {}) {
            if (n != null && this._validate(ef, `layers.${this.id}.paint.${t}`, t, n, u)) return false;
            if (t.endsWith(ud)) return this._transitionablePaint.setTransition(t.slice(0, -11), n || void 0), false;
            {
              const h = this._transitionablePaint._values[t], y = h.property.specification["property-type"] === "cross-faded-data-driven", b = h.value.isDataDriven(), w = h.value;
              this._transitionablePaint.setValue(t, n), this._handleSpecialPaintPropertyUpdate(t);
              const S = this._transitionablePaint._values[t].value;
              return S.isDataDriven() || b || y || this._handleOverridablePaintPropertyUpdate(t, w, S);
            }
          }
          _handleSpecialPaintPropertyUpdate(t) {
          }
          _handleOverridablePaintPropertyUpdate(t, n, u) {
            return false;
          }
          isHidden(t, n = false) {
            return !!(this.minzoom && t < (n ? Math.floor(this.minzoom) : this.minzoom)) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none";
          }
          updateTransitions(t) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t, n) {
            t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, n)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, n);
          }
          serialize() {
            const t = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), Ar(t, ((n, u) => !(n === void 0 || u === "layout" && !Object.keys(n).length || u === "paint" && !Object.keys(n).length)));
          }
          _validate(t, n, u, h, y = {}) {
            return (!y || y.validate !== false) && tf(this, t.call(Cs, { key: n, layerType: this.type, objectKey: u, value: h, styleSpec: Le, style: { glyphs: true, sprite: true } }));
          }
          is3D() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          resize() {
          }
          isStateDependent() {
            for (const t in this.paint._values) {
              const n = this.paint.get(t);
              if (n instanceof lo && ys(n.property.specification) && (n.value.kind === "source" || n.value.kind === "composite") && n.value.isStateDependent) return true;
            }
            return false;
          }
        }
        let pf;
        var om = { get paint() {
          return pf = pf || new dn({ "raster-opacity": new qt(Le.paint_raster["raster-opacity"]), "raster-hue-rotate": new qt(Le.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new qt(Le.paint_raster["raster-brightness-min"]), "raster-brightness-max": new qt(Le.paint_raster["raster-brightness-max"]), "raster-saturation": new qt(Le.paint_raster["raster-saturation"]), "raster-contrast": new qt(Le.paint_raster["raster-contrast"]), "raster-resampling": new qt(Le.paint_raster["raster-resampling"]), "raster-fade-duration": new qt(Le.paint_raster["raster-fade-duration"]) });
        } };
        class am extends uo {
          constructor(t, n) {
            super(t, om, n);
          }
        }
        const sm = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class Po {
          constructor(t, n) {
            this._structArray = t, this._pos1 = n * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class fi {
          constructor() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          }
          static serialize(t, n) {
            return t._trim(), n && (t.isTransferred = true, n.push(t.arrayBuffer)), { length: t.length, arrayBuffer: t.arrayBuffer };
          }
          static deserialize(t) {
            const n = Object.create(this.prototype);
            return n.arrayBuffer = t.arrayBuffer, n.length = t.length, n.capacity = t.arrayBuffer.byteLength / n.bytesPerElement, n._refreshViews(), n;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t) {
            this.reserve(t), this.length = t;
          }
          reserve(t) {
            if (t > this.capacity) {
              this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const n = this.uint8;
              this._refreshViews(), n && this.uint8.set(n);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function Ci(o, t = 1) {
          let n = 0, u = 0;
          return { members: o.map(((h) => {
            const y = sm[h.type].BYTES_PER_ELEMENT, b = n = mf(n, Math.max(t, y)), w = h.components || 1;
            return u = Math.max(u, y), n += y * w, { name: h.name, type: h.type, components: w, offset: b };
          })), size: mf(n, Math.max(u, t)), alignment: t };
        }
        function mf(o, t) {
          return Math.ceil(o / t) * t;
        }
        class ks extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n);
          }
          emplace(t, n, u) {
            const h = 2 * t;
            return this.int16[h + 0] = n, this.int16[h + 1] = u, t;
          }
        }
        ks.prototype.bytesPerElement = 4, Dt("StructArrayLayout2i4", ks);
        class Pu extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, t, n, u);
          }
          emplace(t, n, u, h) {
            const y = 3 * t;
            return this.int16[y + 0] = n, this.int16[y + 1] = u, this.int16[y + 2] = h, t;
          }
        }
        Pu.prototype.bytesPerElement = 6, Dt("StructArrayLayout3i6", Pu);
        class cd extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, t, n, u, h);
          }
          emplace(t, n, u, h, y) {
            const b = 4 * t;
            return this.int16[b + 0] = n, this.int16[b + 1] = u, this.int16[b + 2] = h, this.int16[b + 3] = y, t;
          }
        }
        cd.prototype.bytesPerElement = 8, Dt("StructArrayLayout4i8", cd);
        class Vo extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y, b) {
            const w = this.length;
            return this.resize(w + 1), this.emplace(w, t, n, u, h, y, b);
          }
          emplace(t, n, u, h, y, b, w) {
            const S = 6 * t;
            return this.int16[S + 0] = n, this.int16[S + 1] = u, this.int16[S + 2] = h, this.int16[S + 3] = y, this.int16[S + 4] = b, this.int16[S + 5] = w, t;
          }
        }
        Vo.prototype.bytesPerElement = 12, Dt("StructArrayLayout2i4i12", Vo);
        class Tu extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y, b) {
            const w = this.length;
            return this.resize(w + 1), this.emplace(w, t, n, u, h, y, b);
          }
          emplace(t, n, u, h, y, b, w) {
            const S = 4 * t, I = 8 * t;
            return this.int16[S + 0] = n, this.int16[S + 1] = u, this.uint8[I + 4] = h, this.uint8[I + 5] = y, this.uint8[I + 6] = b, this.uint8[I + 7] = w, t;
          }
        }
        Tu.prototype.bytesPerElement = 8, Dt("StructArrayLayout2i4ub8", Tu);
        class Va extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n);
          }
          emplace(t, n, u) {
            const h = 2 * t;
            return this.float32[h + 0] = n, this.float32[h + 1] = u, t;
          }
        }
        Va.prototype.bytesPerElement = 8, Dt("StructArrayLayout2f8", Va);
        class Iu extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y, b, w, S, I, E) {
            const O = this.length;
            return this.resize(O + 1), this.emplace(O, t, n, u, h, y, b, w, S, I, E);
          }
          emplace(t, n, u, h, y, b, w, S, I, E, O) {
            const V = 10 * t;
            return this.uint16[V + 0] = n, this.uint16[V + 1] = u, this.uint16[V + 2] = h, this.uint16[V + 3] = y, this.uint16[V + 4] = b, this.uint16[V + 5] = w, this.uint16[V + 6] = S, this.uint16[V + 7] = I, this.uint16[V + 8] = E, this.uint16[V + 9] = O, t;
          }
        }
        Iu.prototype.bytesPerElement = 20, Dt("StructArrayLayout10ui20", Iu);
        class yl extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y, b, w, S) {
            const I = this.length;
            return this.resize(I + 1), this.emplace(I, t, n, u, h, y, b, w, S);
          }
          emplace(t, n, u, h, y, b, w, S, I) {
            const E = 8 * t;
            return this.uint16[E + 0] = n, this.uint16[E + 1] = u, this.uint16[E + 2] = h, this.uint16[E + 3] = y, this.uint16[E + 4] = b, this.uint16[E + 5] = w, this.uint16[E + 6] = S, this.uint16[E + 7] = I, t;
          }
        }
        yl.prototype.bytesPerElement = 16, Dt("StructArrayLayout8ui16", yl);
        class dd extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y, b, w, S, I, E, O, V) {
            const U = this.length;
            return this.resize(U + 1), this.emplace(U, t, n, u, h, y, b, w, S, I, E, O, V);
          }
          emplace(t, n, u, h, y, b, w, S, I, E, O, V, U) {
            const W = 12 * t;
            return this.int16[W + 0] = n, this.int16[W + 1] = u, this.int16[W + 2] = h, this.int16[W + 3] = y, this.uint16[W + 4] = b, this.uint16[W + 5] = w, this.uint16[W + 6] = S, this.uint16[W + 7] = I, this.int16[W + 8] = E, this.int16[W + 9] = O, this.int16[W + 10] = V, this.int16[W + 11] = U, t;
          }
        }
        dd.prototype.bytesPerElement = 24, Dt("StructArrayLayout4i4ui4i24", dd);
        class Ps extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, t, n, u);
          }
          emplace(t, n, u, h) {
            const y = 3 * t;
            return this.float32[y + 0] = n, this.float32[y + 1] = u, this.float32[y + 2] = h, t;
          }
        }
        Ps.prototype.bytesPerElement = 12, Dt("StructArrayLayout3f12", Ps);
        class Ua extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t);
          }
          emplace(t, n) {
            return this.uint32[1 * t + 0] = n, t;
          }
        }
        Ua.prototype.bytesPerElement = 4, Dt("StructArrayLayout1ul4", Ua);
        class hd extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y, b, w, S, I) {
            const E = this.length;
            return this.resize(E + 1), this.emplace(E, t, n, u, h, y, b, w, S, I);
          }
          emplace(t, n, u, h, y, b, w, S, I, E) {
            const O = 10 * t, V = 5 * t;
            return this.int16[O + 0] = n, this.int16[O + 1] = u, this.int16[O + 2] = h, this.int16[O + 3] = y, this.int16[O + 4] = b, this.int16[O + 5] = w, this.uint32[V + 3] = S, this.uint16[O + 8] = I, this.uint16[O + 9] = E, t;
          }
        }
        hd.prototype.bytesPerElement = 20, Dt("StructArrayLayout6i1ul2ui20", hd);
        class Mu extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y, b) {
            const w = this.length;
            return this.resize(w + 1), this.emplace(w, t, n, u, h, y, b);
          }
          emplace(t, n, u, h, y, b, w) {
            const S = 6 * t;
            return this.int16[S + 0] = n, this.int16[S + 1] = u, this.int16[S + 2] = h, this.int16[S + 3] = y, this.int16[S + 4] = b, this.int16[S + 5] = w, t;
          }
        }
        Mu.prototype.bytesPerElement = 12, Dt("StructArrayLayout2i2i2i12", Mu);
        class Ga extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y) {
            const b = this.length;
            return this.resize(b + 1), this.emplace(b, t, n, u, h, y);
          }
          emplace(t, n, u, h, y, b) {
            const w = 4 * t, S = 8 * t;
            return this.float32[w + 0] = n, this.float32[w + 1] = u, this.float32[w + 2] = h, this.int16[S + 6] = y, this.int16[S + 7] = b, t;
          }
        }
        Ga.prototype.bytesPerElement = 16, Dt("StructArrayLayout2f1f2i16", Ga);
        class fd extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y, b) {
            const w = this.length;
            return this.resize(w + 1), this.emplace(w, t, n, u, h, y, b);
          }
          emplace(t, n, u, h, y, b, w) {
            const S = 16 * t, I = 4 * t, E = 8 * t;
            return this.uint8[S + 0] = n, this.uint8[S + 1] = u, this.float32[I + 1] = h, this.float32[I + 2] = y, this.int16[E + 6] = b, this.int16[E + 7] = w, t;
          }
        }
        fd.prototype.bytesPerElement = 16, Dt("StructArrayLayout2ub2f2i16", fd);
        class Eu extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, t, n, u);
          }
          emplace(t, n, u, h) {
            const y = 3 * t;
            return this.uint16[y + 0] = n, this.uint16[y + 1] = u, this.uint16[y + 2] = h, t;
          }
        }
        Eu.prototype.bytesPerElement = 6, Dt("StructArrayLayout3ui6", Eu);
        class Ru extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y, b, w, S, I, E, O, V, U, W, ee, se, pe) {
            const je = this.length;
            return this.resize(je + 1), this.emplace(je, t, n, u, h, y, b, w, S, I, E, O, V, U, W, ee, se, pe);
          }
          emplace(t, n, u, h, y, b, w, S, I, E, O, V, U, W, ee, se, pe, je) {
            const be = 24 * t, Me = 12 * t, Xe = 48 * t;
            return this.int16[be + 0] = n, this.int16[be + 1] = u, this.uint16[be + 2] = h, this.uint16[be + 3] = y, this.uint32[Me + 2] = b, this.uint32[Me + 3] = w, this.uint32[Me + 4] = S, this.uint16[be + 10] = I, this.uint16[be + 11] = E, this.uint16[be + 12] = O, this.float32[Me + 7] = V, this.float32[Me + 8] = U, this.uint8[Xe + 36] = W, this.uint8[Xe + 37] = ee, this.uint8[Xe + 38] = se, this.uint32[Me + 10] = pe, this.int16[be + 22] = je, t;
          }
        }
        Ru.prototype.bytesPerElement = 48, Dt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Ru);
        class pd extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, y, b, w, S, I, E, O, V, U, W, ee, se, pe, je, be, Me, Xe, it, _t, At, It, Et, Yt, Mt) {
            const Rt = this.length;
            return this.resize(Rt + 1), this.emplace(Rt, t, n, u, h, y, b, w, S, I, E, O, V, U, W, ee, se, pe, je, be, Me, Xe, it, _t, At, It, Et, Yt, Mt);
          }
          emplace(t, n, u, h, y, b, w, S, I, E, O, V, U, W, ee, se, pe, je, be, Me, Xe, it, _t, At, It, Et, Yt, Mt, Rt) {
            const lt = 32 * t, sr = 16 * t;
            return this.int16[lt + 0] = n, this.int16[lt + 1] = u, this.int16[lt + 2] = h, this.int16[lt + 3] = y, this.int16[lt + 4] = b, this.int16[lt + 5] = w, this.int16[lt + 6] = S, this.int16[lt + 7] = I, this.uint16[lt + 8] = E, this.uint16[lt + 9] = O, this.uint16[lt + 10] = V, this.uint16[lt + 11] = U, this.uint16[lt + 12] = W, this.uint16[lt + 13] = ee, this.uint16[lt + 14] = se, this.uint16[lt + 15] = pe, this.uint16[lt + 16] = je, this.uint16[lt + 17] = be, this.uint16[lt + 18] = Me, this.uint16[lt + 19] = Xe, this.uint16[lt + 20] = it, this.uint16[lt + 21] = _t, this.uint16[lt + 22] = At, this.uint32[sr + 12] = It, this.float32[sr + 13] = Et, this.float32[sr + 14] = Yt, this.uint16[lt + 30] = Mt, this.uint16[lt + 31] = Rt, t;
          }
        }
        pd.prototype.bytesPerElement = 64, Dt("StructArrayLayout8i15ui1ul2f2ui64", pd);
        class v extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t);
          }
          emplace(t, n) {
            return this.float32[1 * t + 0] = n, t;
          }
        }
        v.prototype.bytesPerElement = 4, Dt("StructArrayLayout1f4", v);
        class e extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, t, n, u);
          }
          emplace(t, n, u, h) {
            const y = 3 * t;
            return this.uint16[6 * t + 0] = n, this.float32[y + 1] = u, this.float32[y + 2] = h, t;
          }
        }
        e.prototype.bytesPerElement = 12, Dt("StructArrayLayout1ui2f12", e);
        class a extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, t, n, u);
          }
          emplace(t, n, u, h) {
            const y = 4 * t;
            return this.uint32[2 * t + 0] = n, this.uint16[y + 2] = u, this.uint16[y + 3] = h, t;
          }
        }
        a.prototype.bytesPerElement = 8, Dt("StructArrayLayout1ul2ui8", a);
        class c extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n);
          }
          emplace(t, n, u) {
            const h = 2 * t;
            return this.uint16[h + 0] = n, this.uint16[h + 1] = u, t;
          }
        }
        c.prototype.bytesPerElement = 4, Dt("StructArrayLayout2ui4", c);
        class m extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t);
          }
          emplace(t, n) {
            return this.uint16[1 * t + 0] = n, t;
          }
        }
        m.prototype.bytesPerElement = 2, Dt("StructArrayLayout1ui2", m);
        class _ extends fi {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, t, n, u, h);
          }
          emplace(t, n, u, h, y) {
            const b = 4 * t;
            return this.float32[b + 0] = n, this.float32[b + 1] = u, this.float32[b + 2] = h, this.float32[b + 3] = y, t;
          }
        }
        _.prototype.bytesPerElement = 16, Dt("StructArrayLayout4f16", _);
        class x extends Po {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new C(this.anchorPointX, this.anchorPointY);
          }
        }
        x.prototype.size = 20;
        class k extends hd {
          get(t) {
            return new x(this, t);
          }
        }
        Dt("CollisionBoxArray", k);
        class T extends Po {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(t) {
            this._structArray.uint8[this._pos1 + 37] = t;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(t) {
            this._structArray.uint8[this._pos1 + 38] = t;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 10] = t;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        T.prototype.size = 48;
        class R extends Ru {
          get(t) {
            return new T(this, t);
          }
        }
        Dt("PlacedSymbolArray", R);
        class A extends Po {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 12] = t;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        A.prototype.size = 64;
        class N extends pd {
          get(t) {
            return new A(this, t);
          }
        }
        Dt("SymbolInstanceArray", N);
        class j extends v {
          getoffsetX(t) {
            return this.float32[1 * t + 0];
          }
        }
        Dt("GlyphOffsetArray", j);
        class G extends Pu {
          getx(t) {
            return this.int16[3 * t + 0];
          }
          gety(t) {
            return this.int16[3 * t + 1];
          }
          gettileUnitDistanceFromAnchor(t) {
            return this.int16[3 * t + 2];
          }
        }
        Dt("SymbolLineVertexArray", G);
        class Q extends Po {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        Q.prototype.size = 12;
        class le extends e {
          get(t) {
            return new Q(this, t);
          }
        }
        Dt("TextAnchorOffsetArray", le);
        class ce extends Po {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        ce.prototype.size = 8;
        class de extends a {
          get(t) {
            return new ce(this, t);
          }
        }
        Dt("FeatureIndexArray", de);
        class ge extends ks {
        }
        class Se extends ks {
        }
        class me extends ks {
        }
        class ke extends Vo {
        }
        class Re extends Tu {
        }
        class ye extends Va {
        }
        class Be extends Iu {
        }
        class Ke extends yl {
        }
        class He extends dd {
        }
        class Ye extends Ps {
        }
        class Qe extends Ua {
        }
        class Pt extends Mu {
        }
        class Tt extends fd {
        }
        class dt extends Eu {
        }
        class Nt extends c {
        }
        const pr = Ci([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ur } = pr;
        class vr {
          constructor(t = []) {
            this._forceNewSegmentOnNextPrepare = false, this.segments = t;
          }
          prepareSegment(t, n, u, h) {
            const y = this.segments[this.segments.length - 1];
            return t > vr.MAX_VERTEX_ARRAY_LENGTH && Xt(`Max vertices per segment is ${vr.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${vr.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !y || y.vertexLength + t > vr.MAX_VERTEX_ARRAY_LENGTH || y.sortKey !== h ? this.createNewSegment(n, u, h) : y;
          }
          createNewSegment(t, n, u) {
            const h = { vertexOffset: t.length, primitiveOffset: n.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
            return u !== void 0 && (h.sortKey = u), this._forceNewSegmentOnNextPrepare = false, this.segments.push(h), h;
          }
          getOrCreateLatestSegment(t, n, u) {
            return this.prepareSegment(0, t, n, u);
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = true;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t of this.segments) for (const n in t.vaos) t.vaos[n].destroy();
          }
          static simpleSegment(t, n, u, h) {
            return new vr([{ vertexOffset: t, primitiveOffset: n, vertexLength: u, primitiveLength: h, vaos: {}, sortKey: 0 }]);
          }
        }
        function Kr(o, t) {
          return 256 * (o = gt(Math.floor(o), 0, 255)) + gt(Math.floor(t), 0, 255);
        }
        vr.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Dt("SegmentVector", vr);
        const pi = Ci([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]), Qr = Ci([{ name: "a_dasharray_from", components: 4, type: "Uint16" }, { name: "a_dasharray_to", components: 4, type: "Uint16" }]);
        var Di, si, Gi, li = { exports: {} }, Ti = { exports: {} }, yn = { exports: {} }, qa = (function() {
          if (Gi) return li.exports;
          Gi = 1;
          var o = (Di || (Di = 1, Ti.exports = function(n, u) {
            var h, y, b, w, S, I, E, O;
            for (y = n.length - (h = 3 & n.length), b = u, S = 3432918353, I = 461845907, O = 0; O < y; ) E = 255 & n.charCodeAt(O) | (255 & n.charCodeAt(++O)) << 8 | (255 & n.charCodeAt(++O)) << 16 | (255 & n.charCodeAt(++O)) << 24, ++O, b = 27492 + (65535 & (w = 5 * (65535 & (b = (b ^= E = (65535 & (E = (E = (65535 & E) * S + (((E >>> 16) * S & 65535) << 16) & 4294967295) << 15 | E >>> 17)) * I + (((E >>> 16) * I & 65535) << 16) & 4294967295) << 13 | b >>> 19)) + ((5 * (b >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (w >>> 16) & 65535) << 16);
            switch (E = 0, h) {
              case 3:
                E ^= (255 & n.charCodeAt(O + 2)) << 16;
              case 2:
                E ^= (255 & n.charCodeAt(O + 1)) << 8;
              case 1:
                b ^= E = (65535 & (E = (E = (65535 & (E ^= 255 & n.charCodeAt(O))) * S + (((E >>> 16) * S & 65535) << 16) & 4294967295) << 15 | E >>> 17)) * I + (((E >>> 16) * I & 65535) << 16) & 4294967295;
            }
            return b ^= n.length, b = 2246822507 * (65535 & (b ^= b >>> 16)) + ((2246822507 * (b >>> 16) & 65535) << 16) & 4294967295, b = 3266489909 * (65535 & (b ^= b >>> 13)) + ((3266489909 * (b >>> 16) & 65535) << 16) & 4294967295, (b ^= b >>> 16) >>> 0;
          }), Ti.exports), t = (si || (si = 1, yn.exports = function(n, u) {
            for (var h, y = n.length, b = u ^ y, w = 0; y >= 4; ) h = 1540483477 * (65535 & (h = 255 & n.charCodeAt(w) | (255 & n.charCodeAt(++w)) << 8 | (255 & n.charCodeAt(++w)) << 16 | (255 & n.charCodeAt(++w)) << 24)) + ((1540483477 * (h >>> 16) & 65535) << 16), b = 1540483477 * (65535 & b) + ((1540483477 * (b >>> 16) & 65535) << 16) ^ (h = 1540483477 * (65535 & (h ^= h >>> 24)) + ((1540483477 * (h >>> 16) & 65535) << 16)), y -= 4, ++w;
            switch (y) {
              case 3:
                b ^= (255 & n.charCodeAt(w + 2)) << 16;
              case 2:
                b ^= (255 & n.charCodeAt(w + 1)) << 8;
              case 1:
                b = 1540483477 * (65535 & (b ^= 255 & n.charCodeAt(w))) + ((1540483477 * (b >>> 16) & 65535) << 16);
            }
            return b = 1540483477 * (65535 & (b ^= b >>> 13)) + ((1540483477 * (b >>> 16) & 65535) << 16), (b ^= b >>> 15) >>> 0;
          }), yn.exports);
          return li.exports = o, li.exports.murmur3 = o, li.exports.murmur2 = t, li.exports;
        })(), Uo = P(qa);
        class To {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = false;
          }
          add(t, n, u, h) {
            this.ids.push(Wa(t)), this.positions.push(n, u, h);
          }
          getPositions(t) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const n = Wa(t);
            let u = 0, h = this.ids.length - 1;
            for (; u < h; ) {
              const b = u + h >> 1;
              this.ids[b] >= n ? h = b : u = b + 1;
            }
            const y = [];
            for (; this.ids[u] === n; ) y.push({ index: this.positions[3 * u], start: this.positions[3 * u + 1], end: this.positions[3 * u + 2] }), u++;
            return y;
          }
          static serialize(t, n) {
            const u = new Float64Array(t.ids), h = new Uint32Array(t.positions);
            return Ts(u, h, 0, u.length - 1), n && n.push(u.buffer, h.buffer), { ids: u, positions: h };
          }
          static deserialize(t) {
            const n = new To();
            return n.ids = t.ids, n.positions = t.positions, n.indexed = true, n;
          }
        }
        function Wa(o) {
          const t = +o;
          return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : Uo(String(o));
        }
        function Ts(o, t, n, u) {
          for (; n < u; ) {
            const h = o[n + u >> 1];
            let y = n - 1, b = u + 1;
            for (; ; ) {
              do
                y++;
              while (o[y] < h);
              do
                b--;
              while (o[b] > h);
              if (y >= b) break;
              Za(o, y, b), Za(t, 3 * y, 3 * b), Za(t, 3 * y + 1, 3 * b + 1), Za(t, 3 * y + 2, 3 * b + 2);
            }
            b - n < u - b ? (Ts(o, t, n, b), n = b + 1) : (Ts(o, t, b + 1, u), u = b);
          }
        }
        function Za(o, t, n) {
          const u = o[t];
          o[t] = o[n], o[n] = u;
        }
        Dt("FeaturePositionMap", To);
        class zn {
          constructor(t, n) {
            this.gl = t.gl, this.location = n;
          }
        }
        class bn extends zn {
          constructor(t, n) {
            super(t, n), this.current = 0;
          }
          set(t) {
            this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t));
          }
        }
        class Go extends zn {
          constructor(t, n) {
            super(t, n), this.current = [0, 0, 0, 0];
          }
          set(t) {
            t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));
          }
        }
        class fa extends zn {
          constructor(t, n) {
            super(t, n), this.current = fr.transparent;
          }
          set(t) {
            t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));
          }
        }
        const bl = new Float32Array(16);
        function Ii(o) {
          return [Kr(255 * o.r, 255 * o.g), Kr(255 * o.b, 255 * o.a)];
        }
        class Si {
          constructor(t, n, u) {
            this.value = t, this.uniformNames = n.map(((h) => `u_${h}`)), this.type = u;
          }
          setUniform(t, n, u) {
            t.set(u.constantOr(this.value));
          }
          getBinding(t, n, u) {
            return this.type === "color" ? new fa(t, n) : new bn(t, n);
          }
        }
        class qi {
          constructor(t, n) {
            this.uniformNames = n.map(((u) => `u_${u}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(t, n) {
            this.pixelRatioFrom = n.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = n.tlbr, this.patternTo = t.tlbr;
          }
          setConstantDashPositions(t, n) {
            this.dashTo = [0, t.y, t.height, t.width], this.dashFrom = [0, n.y, n.height, n.width];
          }
          setUniform(t, n, u, h) {
            let y = null;
            h === "u_pattern_to" ? y = this.patternTo : h === "u_pattern_from" ? y = this.patternFrom : h === "u_dasharray_to" ? y = this.dashTo : h === "u_dasharray_from" ? y = this.dashFrom : h === "u_pixel_ratio_to" ? y = this.pixelRatioTo : h === "u_pixel_ratio_from" && (y = this.pixelRatioFrom), y !== null && t.set(y);
          }
          getBinding(t, n, u) {
            return u.substr(0, 9) === "u_pattern" || u.substr(0, 12) === "u_dasharray_" ? new Go(t, n) : new bn(t, n);
          }
        }
        class ii {
          constructor(t, n, u, h) {
            this.expression = t, this.type = u, this.maxValue = 0, this.paintVertexAttributes = n.map(((y) => ({ name: `a_${y}`, type: "Float32", components: u === "color" ? 2 : 1, offset: 0 }))), this.paintVertexArray = new h();
          }
          populatePaintArray(t, n, u) {
            const h = this.paintVertexArray.length, y = this.expression.evaluate(new Yr(0, u), n, {}, u.canonical, [], u.formattedSection);
            this.paintVertexArray.resize(t), this._setPaintValue(h, t, y);
          }
          updatePaintArray(t, n, u, h, y) {
            const b = this.expression.evaluate(new Yr(0, y), u, h);
            this._setPaintValue(t, n, b);
          }
          _setPaintValue(t, n, u) {
            if (this.type === "color") {
              const h = Ii(u);
              for (let y = t; y < n; y++) this.paintVertexArray.emplace(y, h[0], h[1]);
            } else {
              for (let h = t; h < n; h++) this.paintVertexArray.emplace(h, u);
              this.maxValue = Math.max(this.maxValue, Math.abs(u));
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class co {
          constructor(t, n, u, h, y, b) {
            this.expression = t, this.uniformNames = n.map(((w) => `u_${w}_t`)), this.type = u, this.useIntegerZoom = h, this.zoom = y, this.maxValue = 0, this.paintVertexAttributes = n.map(((w) => ({ name: `a_${w}`, type: "Float32", components: u === "color" ? 4 : 2, offset: 0 }))), this.paintVertexArray = new b();
          }
          populatePaintArray(t, n, u) {
            const h = this.expression.evaluate(new Yr(this.zoom, u), n, {}, u.canonical, [], u.formattedSection), y = this.expression.evaluate(new Yr(this.zoom + 1, u), n, {}, u.canonical, [], u.formattedSection), b = this.paintVertexArray.length;
            this.paintVertexArray.resize(t), this._setPaintValue(b, t, h, y);
          }
          updatePaintArray(t, n, u, h, y) {
            const b = this.expression.evaluate(new Yr(this.zoom, y), u, h), w = this.expression.evaluate(new Yr(this.zoom + 1, y), u, h);
            this._setPaintValue(t, n, b, w);
          }
          _setPaintValue(t, n, u, h) {
            if (this.type === "color") {
              const y = Ii(u), b = Ii(h);
              for (let w = t; w < n; w++) this.paintVertexArray.emplace(w, y[0], y[1], b[0], b[1]);
            } else {
              for (let y = t; y < n; y++) this.paintVertexArray.emplace(y, u, h);
              this.maxValue = Math.max(this.maxValue, Math.abs(u), Math.abs(h));
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t, n) {
            const u = this.useIntegerZoom ? Math.floor(n.zoom) : n.zoom, h = gt(this.expression.interpolationFactor(u, this.zoom, this.zoom + 1), 0, 1);
            t.set(h);
          }
          getBinding(t, n, u) {
            return new bn(t, n);
          }
        }
        class pa {
          constructor(t, n, u, h, y, b) {
            this.expression = t, this.type = n, this.useIntegerZoom = u, this.zoom = h, this.layerId = b, this.zoomInPaintVertexArray = new y(), this.zoomOutPaintVertexArray = new y();
          }
          populatePaintArray(t, n, u) {
            const h = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(h, t, this.getPositionIds(n), u);
          }
          updatePaintArray(t, n, u, h, y) {
            this._setPaintValues(t, n, this.getPositionIds(u), y);
          }
          _setPaintValues(t, n, u, h) {
            const y = this.getPositions(h);
            if (!y || !u) return;
            const b = y[u.min], w = y[u.mid], S = y[u.max];
            if (b && w && S) for (let I = t; I < n; I++) this.emplace(this.zoomInPaintVertexArray, I, w, b), this.emplace(this.zoomOutPaintVertexArray, I, w, S);
          }
          upload(t) {
            if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
              const n = this.getVertexAttributes();
              this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, n, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, n, this.expression.isStateDependent);
            }
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class gf extends pa {
          getPositions(t) {
            return t.imagePositions;
          }
          getPositionIds(t) {
            return t.patterns && t.patterns[this.layerId];
          }
          getVertexAttributes() {
            return pi.members;
          }
          emplace(t, n, u, h) {
            t.emplace(n, u.tlbr[0], u.tlbr[1], u.tlbr[2], u.tlbr[3], h.tlbr[0], h.tlbr[1], h.tlbr[2], h.tlbr[3], u.pixelRatio, h.pixelRatio);
          }
        }
        class vf extends pa {
          getPositions(t) {
            return t.dashPositions;
          }
          getPositionIds(t) {
            return t.dashes && t.dashes[this.layerId];
          }
          getVertexAttributes() {
            return Qr.members;
          }
          emplace(t, n, u, h) {
            t.emplace(n, 0, u.y, u.height, u.width, 0, h.y, h.height, h.width);
          }
        }
        class _f {
          constructor(t, n, u) {
            this.binders = {}, this._buffers = [];
            const h = [];
            for (const y in t.paint._values) {
              if (!u(y)) continue;
              const b = t.paint.get(y);
              if (!(b instanceof lo && ys(b.property.specification))) continue;
              const w = Xa(y, t.type), S = b.value, I = b.property.specification.type, E = b.property.useIntegerZoom, O = b.property.specification["property-type"], V = O === "cross-faded" || O === "cross-faded-data-driven";
              if (S.kind === "constant") this.binders[y] = V ? new qi(S.value, w) : new Si(S.value, w, I), h.push(`/u_${y}`);
              else if (S.kind === "source" || V) {
                const U = md(y, I, "source");
                this.binders[y] = V ? y === "line-dasharray" ? new vf(S, I, E, n, U, t.id) : new gf(S, I, E, n, U, t.id) : new ii(S, w, I, U), h.push(`/a_${y}`);
              } else {
                const U = md(y, I, "composite");
                this.binders[y] = new co(S, w, I, E, n, U), h.push(`/z_${y}`);
              }
            }
            this.cacheKey = h.sort().join("");
          }
          getMaxValue(t) {
            const n = this.binders[t];
            return n instanceof ii || n instanceof co ? n.maxValue : 0;
          }
          populatePaintArrays(t, n, u) {
            for (const h in this.binders) {
              const y = this.binders[h];
              (y instanceof ii || y instanceof co || y instanceof pa) && y.populatePaintArray(t, n, u);
            }
          }
          setConstantPatternPositions(t, n) {
            for (const u in this.binders) {
              const h = this.binders[u];
              h instanceof qi && h.setConstantPatternPositions(t, n);
            }
          }
          setConstantDashPositions(t, n) {
            for (const u in this.binders) {
              const h = this.binders[u];
              h instanceof qi && h.setConstantDashPositions(t, n);
            }
          }
          updatePaintArrays(t, n, u, h, y) {
            let b = false;
            for (const w in t) {
              const S = n.getPositions(w);
              for (const I of S) {
                const E = u.feature(I.index);
                for (const O in this.binders) {
                  const V = this.binders[O];
                  if ((V instanceof ii || V instanceof co || V instanceof pa) && V.expression.isStateDependent === true) {
                    const U = h.paint.get(O);
                    V.expression = U.value, V.updatePaintArray(I.start, I.end, E, t[w], y), b = true;
                  }
                }
              }
            }
            return b;
          }
          defines() {
            const t = [];
            for (const n in this.binders) {
              const u = this.binders[n];
              (u instanceof Si || u instanceof qi) && t.push(...u.uniformNames.map(((h) => `#define HAS_UNIFORM_${h}`)));
            }
            return t;
          }
          getBinderAttributes() {
            const t = [];
            for (const n in this.binders) {
              const u = this.binders[n];
              if (u instanceof ii || u instanceof co) for (let h = 0; h < u.paintVertexAttributes.length; h++) t.push(u.paintVertexAttributes[h].name);
              else if (u instanceof pa) {
                const h = u.getVertexAttributes();
                for (const y of h) t.push(y.name);
              }
            }
            return t;
          }
          getBinderUniforms() {
            const t = [];
            for (const n in this.binders) {
              const u = this.binders[n];
              if (u instanceof Si || u instanceof qi || u instanceof co) for (const h of u.uniformNames) t.push(h);
            }
            return t;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t, n) {
            const u = [];
            for (const h in this.binders) {
              const y = this.binders[h];
              if (y instanceof Si || y instanceof qi || y instanceof co) {
                for (const b of y.uniformNames) if (n[b]) {
                  const w = y.getBinding(t, n[b], b);
                  u.push({ name: b, property: h, binding: w });
                }
              }
            }
            return u;
          }
          setUniforms(t, n, u, h) {
            for (const { name: y, property: b, binding: w } of n) this.binders[b].setUniform(w, h, u.get(b), y);
          }
          updatePaintBuffers(t) {
            this._buffers = [];
            for (const n in this.binders) {
              const u = this.binders[n];
              if (t && u instanceof pa) {
                const h = t.fromScale === 2 ? u.zoomInPaintVertexBuffer : u.zoomOutPaintVertexBuffer;
                h && this._buffers.push(h);
              } else (u instanceof ii || u instanceof co) && u.paintVertexBuffer && this._buffers.push(u.paintVertexBuffer);
            }
          }
          upload(t) {
            for (const n in this.binders) {
              const u = this.binders[n];
              (u instanceof ii || u instanceof co || u instanceof pa) && u.upload(t);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t in this.binders) {
              const n = this.binders[t];
              (n instanceof ii || n instanceof co || n instanceof pa) && n.destroy();
            }
          }
        }
        class Ha {
          constructor(t, n, u = () => true) {
            this.programConfigurations = {};
            for (const h of t) this.programConfigurations[h.id] = new _f(h, n, u);
            this.needsUpload = false, this._featureMap = new To(), this._bufferOffset = 0;
          }
          populatePaintArrays(t, n, u, h) {
            for (const y in this.programConfigurations) this.programConfigurations[y].populatePaintArrays(t, n, h);
            n.id !== void 0 && this._featureMap.add(n.id, u, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = true;
          }
          updatePaintArrays(t, n, u, h) {
            for (const y of u) this.needsUpload = this.programConfigurations[y.id].updatePaintArrays(t, this._featureMap, n, y, h) || this.needsUpload;
          }
          get(t) {
            return this.programConfigurations[t];
          }
          upload(t) {
            if (this.needsUpload) {
              for (const n in this.programConfigurations) this.programConfigurations[n].upload(t);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const t in this.programConfigurations) this.programConfigurations[t].destroy();
          }
        }
        function Xa(o, t) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-dasharray": ["dasharray_to", "dasharray_from"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[o] || [o.replace(`${t}-`, "").replace(/-/g, "_")];
        }
        function md(o, t, n) {
          const u = { color: { source: Va, composite: _ }, number: { source: v, composite: Va } }, h = (function(y) {
            return { "line-pattern": { source: Be, composite: Be }, "fill-pattern": { source: Be, composite: Be }, "fill-extrusion-pattern": { source: Be, composite: Be }, "line-dasharray": { source: Ke, composite: Ke } }[y];
          })(o);
          return h && h[n] || u[t][n];
        }
        Dt("ConstantBinder", Si), Dt("CrossFadedConstantBinder", qi), Dt("SourceExpressionBinder", ii), Dt("CrossFadedPatternBinder", gf), Dt("CrossFadedDasharrayBinder", vf), Dt("CompositeExpressionBinder", co), Dt("ProgramConfiguration", _f, { omit: ["_buffers"] }), Dt("ProgramConfigurationSet", Ha);
        const Au = Math.pow(2, 14) - 1, gd = -Au - 1;
        function qo(o) {
          const t = nt / o.extent, n = o.loadGeometry();
          for (let u = 0; u < n.length; u++) {
            const h = n[u];
            for (let y = 0; y < h.length; y++) {
              const b = h[y], w = Math.round(b.x * t), S = Math.round(b.y * t);
              b.x = gt(w, gd, Au), b.y = gt(S, gd, Au), (w < b.x || w > b.x + 1 || S < b.y || S > b.y + 1) && Xt("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return n;
        }
        function ma(o, t) {
          return { type: o.type, id: o.id, properties: o.properties, geometry: t ? qo(o) : [] };
        }
        const Du = -32768;
        function _x(o, t, n, u, h) {
          o.emplaceBack(Du + 8 * t + u, Du + 8 * n + h);
        }
        class lm {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((n) => n.id)), this.index = t.index, this.hasDependencies = false, this.layoutVertexArray = new Se(), this.indexArray = new dt(), this.segments = new vr(), this.programConfigurations = new Ha(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter(((n) => n.isStateDependent())).map(((n) => n.id));
          }
          populate(t, n, u) {
            const h = this.layers[0], y = [];
            let b = null, w = false, S = h.type === "heatmap";
            if (h.type === "circle") {
              const E = h;
              b = E.layout.get("circle-sort-key"), w = !b.isConstant(), S = S || E.paint.get("circle-pitch-alignment") === "map";
            }
            const I = S ? n.subdivisionGranularity.circle : 1;
            for (const { feature: E, id: O, index: V, sourceLayerIndex: U } of t) {
              const W = this.layers[0]._featureFilter.needGeometry, ee = ma(E, W);
              if (!this.layers[0]._featureFilter.filter(new Yr(this.zoom), ee, u)) continue;
              const se = w ? b.evaluate(ee, {}, u) : void 0, pe = { id: O, properties: E.properties, type: E.type, sourceLayerIndex: U, index: V, geometry: W ? ee.geometry : qo(E), patterns: {}, sortKey: se };
              y.push(pe);
            }
            w && y.sort(((E, O) => E.sortKey - O.sortKey));
            for (const E of y) {
              const { geometry: O, index: V, sourceLayerIndex: U } = E, W = t[V].feature;
              this.addFeature(E, O, V, u, I), n.featureIndex.insert(W, O, V, U, this.index);
            }
          }
          update(t, n, u) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, { imagePositions: u });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ur), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t, n, u, h, y = 1) {
            let b;
            switch (y) {
              case 1:
                b = [0, 7];
                break;
              case 3:
                b = [0, 2, 5, 7];
                break;
              case 5:
                b = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                b = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${y}; valid values are 1, 3, 5, 7.`);
            }
            const w = b.length;
            for (const S of n) for (const I of S) {
              const E = I.x, O = I.y;
              if (E < 0 || E >= nt || O < 0 || O >= nt) continue;
              const V = this.segments.prepareSegment(w * w, this.layoutVertexArray, this.indexArray, t.sortKey), U = V.vertexLength;
              for (let W = 0; W < w; W++) for (let ee = 0; ee < w; ee++) _x(this.layoutVertexArray, E, O, b[ee], b[W]);
              for (let W = 0; W < w - 1; W++) for (let ee = 0; ee < w - 1; ee++) {
                const se = U + W * w + ee, pe = U + (W + 1) * w + ee;
                this.indexArray.emplaceBack(se, pe + 1, se + 1), this.indexArray.emplaceBack(se, pe, pe + 1);
              }
              V.vertexLength += w * w, V.primitiveLength += (w - 1) * (w - 1) * 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, u, { imagePositions: {}, canonical: h });
          }
        }
        function M0(o, t) {
          for (let n = 0; n < o.length; n++) if (zu(t, o[n])) return true;
          for (let n = 0; n < t.length; n++) if (zu(o, t[n])) return true;
          return !!um(o, t);
        }
        function yf(o, t, n) {
          return !!zu(o, t) || !!cm(t, o, n);
        }
        function E0(o, t) {
          if (o.length === 1) return A0(t, o[0]);
          for (let n = 0; n < t.length; n++) {
            const u = t[n];
            for (let h = 0; h < u.length; h++) if (zu(o, u[h])) return true;
          }
          for (let n = 0; n < o.length; n++) if (A0(t, o[n])) return true;
          for (let n = 0; n < t.length; n++) if (um(o, t[n])) return true;
          return false;
        }
        function yx(o, t, n) {
          if (o.length > 1) {
            if (um(o, t)) return true;
            for (let u = 0; u < t.length; u++) if (cm(t[u], o, n)) return true;
          }
          for (let u = 0; u < o.length; u++) if (cm(o[u], t, n)) return true;
          return false;
        }
        function um(o, t) {
          if (o.length === 0 || t.length === 0) return false;
          for (let n = 0; n < o.length - 1; n++) {
            const u = o[n], h = o[n + 1];
            for (let y = 0; y < t.length - 1; y++) if (bx(u, h, t[y], t[y + 1])) return true;
          }
          return false;
        }
        function bx(o, t, n, u) {
          return Dr(o, n, u) !== Dr(t, n, u) && Dr(o, t, n) !== Dr(o, t, u);
        }
        function cm(o, t, n) {
          const u = n * n;
          if (t.length === 1) return o.distSqr(t[0]) < u;
          for (let h = 1; h < t.length; h++) if (R0(o, t[h - 1], t[h]) < u) return true;
          return false;
        }
        function R0(o, t, n) {
          const u = t.distSqr(n);
          if (u === 0) return o.distSqr(t);
          const h = ((o.x - t.x) * (n.x - t.x) + (o.y - t.y) * (n.y - t.y)) / u;
          return o.distSqr(h < 0 ? t : h > 1 ? n : n.sub(t)._mult(h)._add(t));
        }
        function A0(o, t) {
          let n, u, h, y = false;
          for (let b = 0; b < o.length; b++) {
            n = o[b];
            for (let w = 0, S = n.length - 1; w < n.length; S = w++) u = n[w], h = n[S], u.y > t.y != h.y > t.y && t.x < (h.x - u.x) * (t.y - u.y) / (h.y - u.y) + u.x && (y = !y);
          }
          return y;
        }
        function zu(o, t) {
          let n = false;
          for (let u = 0, h = o.length - 1; u < o.length; h = u++) {
            const y = o[u], b = o[h];
            y.y > t.y != b.y > t.y && t.x < (b.x - y.x) * (t.y - y.y) / (b.y - y.y) + y.x && (n = !n);
          }
          return n;
        }
        function xx(o, t, n) {
          const u = n[0], h = n[2];
          if (o.x < u.x && t.x < u.x || o.x > h.x && t.x > h.x || o.y < u.y && t.y < u.y || o.y > h.y && t.y > h.y) return false;
          const y = Dr(o, t, n[0]);
          return y !== Dr(o, t, n[1]) || y !== Dr(o, t, n[2]) || y !== Dr(o, t, n[3]);
        }
        function Fu(o, t, n) {
          const u = t.paint.get(o).value;
          return u.kind === "constant" ? u.value : n.programConfigurations.get(t.id).getMaxValue(o);
        }
        function bf(o) {
          return Math.sqrt(o[0] * o[0] + o[1] * o[1]);
        }
        function xf(o, t, n, u, h) {
          if (!t[0] && !t[1]) return o;
          const y = C.convert(t)._mult(h);
          n === "viewport" && y._rotate(-u);
          const b = [];
          for (let w = 0; w < o.length; w++) b.push(o[w].sub(y));
          return b;
        }
        function wx({ queryGeometry: o, size: t }, n) {
          return yf(o, n, t);
        }
        function Cx({ queryGeometry: o, size: t, transform: n, unwrappedTileID: u, getElevation: h }, y) {
          return yf(o, y, t * (n.projectTileCoordinates(y.x, y.y, u, h).signedDistanceFromCamera / n.cameraToCenterDistance));
        }
        function Sx({ queryGeometry: o, size: t, transform: n, unwrappedTileID: u, getElevation: h }, y) {
          const b = n.projectTileCoordinates(y.x, y.y, u, h).signedDistanceFromCamera, w = t * (n.cameraToCenterDistance / b);
          return yf(o, dm(y, n, u, h), w);
        }
        function kx({ queryGeometry: o, size: t, transform: n, unwrappedTileID: u, getElevation: h }, y) {
          return yf(o, dm(y, n, u, h), t);
        }
        function D0({ queryGeometry: o, size: t, transform: n, unwrappedTileID: u, getElevation: h, pitchAlignment: y = "map", pitchScale: b = "map" }, w) {
          const S = y === "map" ? b === "map" ? wx : Cx : b === "map" ? Sx : kx, I = { queryGeometry: o, size: t, transform: n, unwrappedTileID: u, getElevation: h };
          for (const E of w) for (const O of E) if (S(I, O)) return true;
          return false;
        }
        function dm(o, t, n, u) {
          const h = t.projectTileCoordinates(o.x, o.y, n, u).point;
          return new C((0.5 * h.x + 0.5) * t.width, (0.5 * -h.y + 0.5) * t.height);
        }
        let z0, F0;
        Dt("CircleBucket", lm, { omit: ["layers"] });
        var Px = { get paint() {
          return F0 = F0 || new dn({ "circle-radius": new er(Le.paint_circle["circle-radius"]), "circle-color": new er(Le.paint_circle["circle-color"]), "circle-blur": new er(Le.paint_circle["circle-blur"]), "circle-opacity": new er(Le.paint_circle["circle-opacity"]), "circle-translate": new qt(Le.paint_circle["circle-translate"]), "circle-translate-anchor": new qt(Le.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new qt(Le.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new qt(Le.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new er(Le.paint_circle["circle-stroke-width"]), "circle-stroke-color": new er(Le.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new er(Le.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return z0 = z0 || new dn({ "circle-sort-key": new er(Le.layout_circle["circle-sort-key"]) });
        } };
        class Tx extends uo {
          constructor(t, n) {
            super(t, Px, n);
          }
          createBucket(t) {
            return new lm(t);
          }
          queryRadius(t) {
            const n = t;
            return Fu("circle-radius", this, n) + Fu("circle-stroke-width", this, n) + bf(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: u, geometry: h, transform: y, pixelsToTileUnits: b, unwrappedTileID: w, getElevation: S }) {
            const I = xf(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -y.bearingInRadians, b), E = this.paint.get("circle-radius").evaluate(n, u) + this.paint.get("circle-stroke-width").evaluate(n, u), O = this.paint.get("circle-pitch-scale"), V = this.paint.get("circle-pitch-alignment");
            let U, W;
            return V === "map" ? (U = I, W = E * b) : (U = (function(ee, se, pe, je) {
              return ee.map(((be) => dm(be, se, pe, je)));
            })(I, y, w, S), W = E), D0({ queryGeometry: U, size: W, transform: y, unwrappedTileID: w, getElevation: S, pitchAlignment: V, pitchScale: O }, h);
          }
        }
        class L0 extends lm {
        }
        let B0;
        Dt("HeatmapBucket", L0, { omit: ["layers"] });
        var Ix = { get paint() {
          return B0 = B0 || new dn({ "heatmap-radius": new er(Le.paint_heatmap["heatmap-radius"]), "heatmap-weight": new er(Le.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new qt(Le.paint_heatmap["heatmap-intensity"]), "heatmap-color": new _l(Le.paint_heatmap["heatmap-color"]), "heatmap-opacity": new qt(Le.paint_heatmap["heatmap-opacity"]) });
        } };
        function hm(o, { width: t, height: n }, u, h) {
          if (h) {
            if (h instanceof Uint8ClampedArray) h = new Uint8Array(h.buffer);
            else if (h.length !== t * n * u) throw new RangeError(`mismatched image size. expected: ${h.length} but got: ${t * n * u}`);
          } else h = new Uint8Array(t * n * u);
          return o.width = t, o.height = n, o.data = h, o;
        }
        function O0(o, { width: t, height: n }, u) {
          if (t === o.width && n === o.height) return;
          const h = hm({}, { width: t, height: n }, u);
          fm(o, h, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(o.width, t), height: Math.min(o.height, n) }, u), o.width = t, o.height = n, o.data = h.data;
        }
        function fm(o, t, n, u, h, y) {
          if (h.width === 0 || h.height === 0) return t;
          if (h.width > o.width || h.height > o.height || n.x > o.width - h.width || n.y > o.height - h.height) throw new RangeError("out of range source coordinates for image copy");
          if (h.width > t.width || h.height > t.height || u.x > t.width - h.width || u.y > t.height - h.height) throw new RangeError("out of range destination coordinates for image copy");
          const b = o.data, w = t.data;
          if (b === w) throw new Error("srcData equals dstData, so image is already copied");
          for (let S = 0; S < h.height; S++) {
            const I = ((n.y + S) * o.width + n.x) * y, E = ((u.y + S) * t.width + u.x) * y;
            for (let O = 0; O < h.width * y; O++) w[E + O] = b[I + O];
          }
          return t;
        }
        class vd {
          constructor(t, n) {
            hm(this, t, 1, n);
          }
          resize(t) {
            O0(this, t, 1);
          }
          clone() {
            return new vd({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t, n, u, h, y) {
            fm(t, n, u, h, y, 1);
          }
        }
        class Vn {
          constructor(t, n) {
            hm(this, t, 4, n);
          }
          resize(t) {
            O0(this, t, 4);
          }
          replace(t, n) {
            n ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;
          }
          clone() {
            return new Vn({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t, n, u, h, y) {
            fm(t, n, u, h, y, 4);
          }
          setPixel(t, n, u) {
            const h = 4 * (t * this.width + n);
            this.data[h + 0] = Math.round(255 * u.r / u.a), this.data[h + 1] = Math.round(255 * u.g / u.a), this.data[h + 2] = Math.round(255 * u.b / u.a), this.data[h + 3] = Math.round(255 * u.a);
          }
        }
        function $0(o) {
          const t = {}, n = o.resolution || 256, u = o.clips ? o.clips.length : 1, h = o.image || new Vn({ width: n, height: u });
          if (Math.log(n) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${n}`);
          const y = (b, w, S) => {
            t[o.evaluationKey] = S;
            const I = o.expression.evaluate(t);
            h.setPixel(b / 4 / n, w / 4, I);
          };
          if (o.clips) for (let b = 0, w = 0; b < u; ++b, w += 4 * n) for (let S = 0, I = 0; S < n; S++, I += 4) {
            const E = S / (n - 1), { start: O, end: V } = o.clips[b];
            y(w, I, O * (1 - E) + V * E);
          }
          else for (let b = 0, w = 0; b < n; b++, w += 4) y(0, w, b / (n - 1));
          return h;
        }
        Dt("AlphaImage", vd), Dt("RGBAImage", Vn);
        const pm = "big-fb";
        class Mx extends uo {
          createBucket(t) {
            return new L0(t);
          }
          constructor(t, n) {
            super(t, Ix, n), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t) {
            t === "heatmap-color" && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = $0({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbos.has(pm) && this.heatmapFbos.delete(pm);
          }
          queryRadius(t) {
            return Fu("heatmap-radius", this, t);
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: u, geometry: h, transform: y, pixelsToTileUnits: b, unwrappedTileID: w, getElevation: S }) {
            return D0({ queryGeometry: t, size: this.paint.get("heatmap-radius").evaluate(n, u) * b, transform: y, unwrappedTileID: w, getElevation: S }, h);
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
          }
        }
        let j0;
        var Ex = { get paint() {
          return j0 = j0 || new dn({ "hillshade-illumination-direction": new qt(Le.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new qt(Le.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new qt(Le.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new qt(Le.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new qt(Le.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new qt(Le.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new qt(Le.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new qt(Le.paint_hillshade["hillshade-method"]) });
        } };
        class Rx extends uo {
          constructor(t, n) {
            super(t, Ex, n), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
          }
          getIlluminationProperties() {
            let t = this.paint.get("hillshade-illumination-direction").values, n = this.paint.get("hillshade-illumination-altitude").values, u = this.paint.get("hillshade-highlight-color").values, h = this.paint.get("hillshade-shadow-color").values;
            const y = Math.max(t.length, n.length, u.length, h.length);
            t = t.concat(Array(y - t.length).fill(t.at(-1))), n = n.concat(Array(y - n.length).fill(n.at(-1))), u = u.concat(Array(y - u.length).fill(u.at(-1))), h = h.concat(Array(y - h.length).fill(h.at(-1)));
            const b = n.map(vt);
            return { directionRadians: t.map(vt), altitudeRadians: b, shadowColor: h, highlightColor: u };
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
          }
        }
        let N0;
        var Ax = { get paint() {
          return N0 = N0 || new dn({ "color-relief-opacity": new qt(Le["paint_color-relief"]["color-relief-opacity"]), "color-relief-color": new _l(Le["paint_color-relief"]["color-relief-color"]) });
        } };
        class mm {
          constructor(t, n, u, h) {
            this.context = t, this.format = u, this.texture = t.gl.createTexture(), this.update(n, h);
          }
          update(t, n, u) {
            const { width: h, height: y } = t, b = !(this.size && this.size[0] === h && this.size[1] === y || u), { context: w } = this, { gl: S } = w;
            if (this.useMipmap = !!(n && n.useMipmap), S.bindTexture(S.TEXTURE_2D, this.texture), w.pixelStoreUnpackFlipY.set(false), w.pixelStoreUnpack.set(1), w.pixelStoreUnpackPremultiplyAlpha.set(this.format === S.RGBA && (!n || n.premultiply !== false)), b) this.size = [h, y], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || at(t) ? S.texImage2D(S.TEXTURE_2D, 0, this.format, this.format, S.UNSIGNED_BYTE, t) : S.texImage2D(S.TEXTURE_2D, 0, this.format, h, y, 0, this.format, S.UNSIGNED_BYTE, t.data);
            else {
              const { x: I, y: E } = u || { x: 0, y: 0 };
              t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || at(t) ? S.texSubImage2D(S.TEXTURE_2D, 0, I, E, S.RGBA, S.UNSIGNED_BYTE, t) : S.texSubImage2D(S.TEXTURE_2D, 0, I, E, h, y, S.RGBA, S.UNSIGNED_BYTE, t.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && S.generateMipmap(S.TEXTURE_2D), w.pixelStoreUnpackFlipY.setDefault(), w.pixelStoreUnpack.setDefault(), w.pixelStoreUnpackPremultiplyAlpha.setDefault();
          }
          bind(t, n, u) {
            const { context: h } = this, { gl: y } = h;
            y.bindTexture(y.TEXTURE_2D, this.texture), u !== y.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (u = y.LINEAR), t !== this.filter && (y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MAG_FILTER, t), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MIN_FILTER, u || t), this.filter = t), n !== this.wrap && (y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_S, n), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_T, n), this.wrap = n);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: t } = this.context;
            t.deleteTexture(this.texture), this.texture = null;
          }
        }
        class V0 {
          constructor(t, n, u, h = 1, y = 1, b = 1, w = 0) {
            if (this.uid = t, n.height !== n.width) throw new RangeError("DEM tiles must be square");
            if (u && !["mapbox", "terrarium", "custom"].includes(u)) return void Xt(`"${u}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = n.height;
            const S = this.dim = n.height - 2;
            switch (this.data = new Uint32Array(n.data.buffer), u) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = h, this.greenFactor = y, this.blueFactor = b, this.baseShift = w;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let I = 0; I < S; I++) this.data[this._idx(-1, I)] = this.data[this._idx(0, I)], this.data[this._idx(S, I)] = this.data[this._idx(S - 1, I)], this.data[this._idx(I, -1)] = this.data[this._idx(I, 0)], this.data[this._idx(I, S)] = this.data[this._idx(I, S - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(S, -1)] = this.data[this._idx(S - 1, 0)], this.data[this._idx(-1, S)] = this.data[this._idx(0, S - 1)], this.data[this._idx(S, S)] = this.data[this._idx(S - 1, S - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let I = 0; I < S; I++) for (let E = 0; E < S; E++) {
              const O = this.get(I, E);
              O > this.max && (this.max = O), O < this.min && (this.min = O);
            }
          }
          get(t, n) {
            const u = new Uint8Array(this.data.buffer), h = 4 * this._idx(t, n);
            return this.unpack(u[h], u[h + 1], u[h + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(t, n) {
            if (t < -1 || t >= this.dim + 1 || n < -1 || n >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (n + 1) * this.stride + (t + 1);
          }
          unpack(t, n, u) {
            return t * this.redFactor + n * this.greenFactor + u * this.blueFactor - this.baseShift;
          }
          pack(t) {
            return U0(t, this.getUnpackVector());
          }
          getPixels() {
            return new Vn({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(t, n, u) {
            if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
            let h = n * this.dim, y = n * this.dim + this.dim, b = u * this.dim, w = u * this.dim + this.dim;
            switch (n) {
              case -1:
                h = y - 1;
                break;
              case 1:
                y = h + 1;
            }
            switch (u) {
              case -1:
                b = w - 1;
                break;
              case 1:
                w = b + 1;
            }
            const S = -n * this.dim, I = -u * this.dim;
            for (let E = b; E < w; E++) for (let O = h; O < y; O++) this.data[this._idx(O, E)] = t.data[this._idx(O + S, E + I)];
          }
        }
        function U0(o, t) {
          const n = t[0], u = t[1], h = t[2], y = t[3], b = Math.min(n, u, h), w = Math.round((o + y) / b);
          return { r: Math.floor(w * b / n) % 256, g: Math.floor(w * b / u) % 256, b: Math.floor(w * b / h) % 256 };
        }
        Dt("DEMData", V0);
        class Dx extends uo {
          constructor(t, n) {
            super(t, Ax, n);
          }
          _createColorRamp(t) {
            const n = { elevationStops: [], colorStops: [] }, u = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (u instanceof ul && u._styleExpression.expression instanceof Vr) {
              this.colorRampExpression = u;
              const b = u._styleExpression.expression;
              n.elevationStops = b.labels, n.colorStops = [];
              for (const w of n.elevationStops) n.colorStops.push(b.evaluate({ globals: { elevation: w } }));
            }
            if (n.elevationStops.length < 1 && (n.elevationStops = [0], n.colorStops = [fr.transparent]), n.elevationStops.length < 2 && (n.elevationStops.push(n.elevationStops[0] + 1), n.colorStops.push(n.colorStops[0])), n.elevationStops.length <= t) return n;
            const h = { elevationStops: [], colorStops: [] }, y = (n.elevationStops.length - 1) / (t - 1);
            for (let b = 0; b < n.elevationStops.length - 0.5; b += y) h.elevationStops.push(n.elevationStops[Math.round(b)]), h.colorStops.push(n.colorStops[Math.round(b)]);
            return Xt(`Too many colors in specification of ${this.id} color-relief layer, may not render properly. Max possible colors: ${t}, provided: ${n.elevationStops.length}`), h;
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
          }
          getColorRampTextures(t, n, u) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const h = this._createColorRamp(n), y = new Vn({ width: h.colorStops.length, height: 1 }), b = new Vn({ width: h.colorStops.length, height: 1 });
            for (let w = 0; w < h.elevationStops.length; w++) {
              const S = U0(h.elevationStops[w], u);
              b.setPixel(0, w, new fr(S.r / 255, S.g / 255, S.b / 255, 1)), y.setPixel(0, w, h.colorStops[w]);
            }
            return this.colorRampTextures = { elevationTexture: new mm(t, b, t.gl.RGBA), colorTexture: new mm(t, y, t.gl.RGBA) }, this.colorRampTextures;
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures;
          }
        }
        const zx = Ci([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Fx } = zx;
        function wf(o, t, n) {
          const u = n.patternDependencies;
          let h = false;
          for (const y of t) {
            const b = y.paint.get(`${o}-pattern`);
            b.isConstant() || (h = true);
            const w = b.constantOr(null);
            w && (h = true, u[w.to] = true, u[w.from] = true);
          }
          return h;
        }
        function gm(o, t, n, u, h) {
          const { zoom: y } = u, b = h.patternDependencies;
          for (const w of t) {
            const S = w.paint.get(`${o}-pattern`).value;
            if (S.kind !== "constant") {
              let I = S.evaluate({ zoom: y - 1 }, n, {}, h.availableImages), E = S.evaluate({ zoom: y }, n, {}, h.availableImages), O = S.evaluate({ zoom: y + 1 }, n, {}, h.availableImages);
              I = I && I.name ? I.name : I, E = E && E.name ? E.name : E, O = O && O.name ? O.name : O, b[I] = true, b[E] = true, b[O] = true, n.patterns[w.id] = { min: I, mid: E, max: O };
            }
          }
          return n;
        }
        function G0(o, t, n, u, h) {
          let y;
          if (h === (function(b, w, S, I) {
            let E = 0;
            for (let O = w, V = S - I; O < S; O += I) E += (b[V] - b[O]) * (b[O + 1] + b[V + 1]), V = O;
            return E;
          })(o, t, n, u) > 0) for (let b = t; b < n; b += u) y = H0(b / u | 0, o[b], o[b + 1], y);
          else for (let b = n - u; b >= t; b -= u) y = H0(b / u | 0, o[b], o[b + 1], y);
          return y && Lu(y, y.next) && (xd(y), y = y.next), y;
        }
        function xl(o, t) {
          if (!o) return o;
          t || (t = o);
          let n, u = o;
          do
            if (n = false, u.steiner || !Lu(u, u.next) && Mi(u.prev, u, u.next) !== 0) u = u.next;
            else {
              if (xd(u), u = t = u.prev, u === u.next) break;
              n = true;
            }
          while (n || u !== t);
          return t;
        }
        function _d(o, t, n, u, h, y, b) {
          if (!o) return;
          !b && y && (function(S, I, E, O) {
            let V = S;
            do
              V.z === 0 && (V.z = vm(V.x, V.y, I, E, O)), V.prevZ = V.prev, V.nextZ = V.next, V = V.next;
            while (V !== S);
            V.prevZ.nextZ = null, V.prevZ = null, (function(U) {
              let W, ee = 1;
              do {
                let se, pe = U;
                U = null;
                let je = null;
                for (W = 0; pe; ) {
                  W++;
                  let be = pe, Me = 0;
                  for (let it = 0; it < ee && (Me++, be = be.nextZ, be); it++) ;
                  let Xe = ee;
                  for (; Me > 0 || Xe > 0 && be; ) Me !== 0 && (Xe === 0 || !be || pe.z <= be.z) ? (se = pe, pe = pe.nextZ, Me--) : (se = be, be = be.nextZ, Xe--), je ? je.nextZ = se : U = se, se.prevZ = je, je = se;
                  pe = be;
                }
                je.nextZ = null, ee *= 2;
              } while (W > 1);
            })(V);
          })(o, u, h, y);
          let w = o;
          for (; o.prev !== o.next; ) {
            const S = o.prev, I = o.next;
            if (y ? Bx(o, u, h, y) : Lx(o)) t.push(S.i, o.i, I.i), xd(o), o = I.next, w = I.next;
            else if ((o = I) === w) {
              b ? b === 1 ? _d(o = Ox(xl(o), t), t, n, u, h, y, 2) : b === 2 && $x(o, t, n, u, h, y) : _d(xl(o), t, n, u, h, y, 1);
              break;
            }
          }
        }
        function Lx(o) {
          const t = o.prev, n = o, u = o.next;
          if (Mi(t, n, u) >= 0) return false;
          const h = t.x, y = n.x, b = u.x, w = t.y, S = n.y, I = u.y, E = Math.min(h, y, b), O = Math.min(w, S, I), V = Math.max(h, y, b), U = Math.max(w, S, I);
          let W = u.next;
          for (; W !== t; ) {
            if (W.x >= E && W.x <= V && W.y >= O && W.y <= U && yd(h, w, y, S, b, I, W.x, W.y) && Mi(W.prev, W, W.next) >= 0) return false;
            W = W.next;
          }
          return true;
        }
        function Bx(o, t, n, u) {
          const h = o.prev, y = o, b = o.next;
          if (Mi(h, y, b) >= 0) return false;
          const w = h.x, S = y.x, I = b.x, E = h.y, O = y.y, V = b.y, U = Math.min(w, S, I), W = Math.min(E, O, V), ee = Math.max(w, S, I), se = Math.max(E, O, V), pe = vm(U, W, t, n, u), je = vm(ee, se, t, n, u);
          let be = o.prevZ, Me = o.nextZ;
          for (; be && be.z >= pe && Me && Me.z <= je; ) {
            if (be.x >= U && be.x <= ee && be.y >= W && be.y <= se && be !== h && be !== b && yd(w, E, S, O, I, V, be.x, be.y) && Mi(be.prev, be, be.next) >= 0 || (be = be.prevZ, Me.x >= U && Me.x <= ee && Me.y >= W && Me.y <= se && Me !== h && Me !== b && yd(w, E, S, O, I, V, Me.x, Me.y) && Mi(Me.prev, Me, Me.next) >= 0)) return false;
            Me = Me.nextZ;
          }
          for (; be && be.z >= pe; ) {
            if (be.x >= U && be.x <= ee && be.y >= W && be.y <= se && be !== h && be !== b && yd(w, E, S, O, I, V, be.x, be.y) && Mi(be.prev, be, be.next) >= 0) return false;
            be = be.prevZ;
          }
          for (; Me && Me.z <= je; ) {
            if (Me.x >= U && Me.x <= ee && Me.y >= W && Me.y <= se && Me !== h && Me !== b && yd(w, E, S, O, I, V, Me.x, Me.y) && Mi(Me.prev, Me, Me.next) >= 0) return false;
            Me = Me.nextZ;
          }
          return true;
        }
        function Ox(o, t) {
          let n = o;
          do {
            const u = n.prev, h = n.next.next;
            !Lu(u, h) && W0(u, n, n.next, h) && bd(u, h) && bd(h, u) && (t.push(u.i, n.i, h.i), xd(n), xd(n.next), n = o = h), n = n.next;
          } while (n !== o);
          return xl(n);
        }
        function $x(o, t, n, u, h, y) {
          let b = o;
          do {
            let w = b.next.next;
            for (; w !== b.prev; ) {
              if (b.i !== w.i && Gx(b, w)) {
                let S = Z0(b, w);
                return b = xl(b, b.next), S = xl(S, S.next), _d(b, t, n, u, h, y, 0), void _d(S, t, n, u, h, y, 0);
              }
              w = w.next;
            }
            b = b.next;
          } while (b !== o);
        }
        function jx(o, t) {
          let n = o.x - t.x;
          return n === 0 && (n = o.y - t.y, n === 0) && (n = (o.next.y - o.y) / (o.next.x - o.x) - (t.next.y - t.y) / (t.next.x - t.x)), n;
        }
        function Nx(o, t) {
          const n = (function(h, y) {
            let b = y;
            const w = h.x, S = h.y;
            let I, E = -1 / 0;
            if (Lu(h, b)) return b;
            do {
              if (Lu(h, b.next)) return b.next;
              if (S <= b.y && S >= b.next.y && b.next.y !== b.y) {
                const ee = b.x + (S - b.y) * (b.next.x - b.x) / (b.next.y - b.y);
                if (ee <= w && ee > E && (E = ee, I = b.x < b.next.x ? b : b.next, ee === w)) return I;
              }
              b = b.next;
            } while (b !== y);
            if (!I) return null;
            const O = I, V = I.x, U = I.y;
            let W = 1 / 0;
            b = I;
            do {
              if (w >= b.x && b.x >= V && w !== b.x && q0(S < U ? w : E, S, V, U, S < U ? E : w, S, b.x, b.y)) {
                const ee = Math.abs(S - b.y) / (w - b.x);
                bd(b, h) && (ee < W || ee === W && (b.x > I.x || b.x === I.x && Vx(I, b))) && (I = b, W = ee);
              }
              b = b.next;
            } while (b !== O);
            return I;
          })(o, t);
          if (!n) return t;
          const u = Z0(n, o);
          return xl(u, u.next), xl(n, n.next);
        }
        function Vx(o, t) {
          return Mi(o.prev, o, t.prev) < 0 && Mi(t.next, o, o.next) < 0;
        }
        function vm(o, t, n, u, h) {
          return (o = 1431655765 & ((o = 858993459 & ((o = 252645135 & ((o = 16711935 & ((o = (o - n) * h | 0) | o << 8)) | o << 4)) | o << 2)) | o << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - u) * h | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
        }
        function Ux(o) {
          let t = o, n = o;
          do
            (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next;
          while (t !== o);
          return n;
        }
        function q0(o, t, n, u, h, y, b, w) {
          return (h - b) * (t - w) >= (o - b) * (y - w) && (o - b) * (u - w) >= (n - b) * (t - w) && (n - b) * (y - w) >= (h - b) * (u - w);
        }
        function yd(o, t, n, u, h, y, b, w) {
          return !(o === b && t === w) && q0(o, t, n, u, h, y, b, w);
        }
        function Gx(o, t) {
          return o.next.i !== t.i && o.prev.i !== t.i && !(function(n, u) {
            let h = n;
            do {
              if (h.i !== n.i && h.next.i !== n.i && h.i !== u.i && h.next.i !== u.i && W0(h, h.next, n, u)) return true;
              h = h.next;
            } while (h !== n);
            return false;
          })(o, t) && (bd(o, t) && bd(t, o) && (function(n, u) {
            let h = n, y = false;
            const b = (n.x + u.x) / 2, w = (n.y + u.y) / 2;
            do
              h.y > w != h.next.y > w && h.next.y !== h.y && b < (h.next.x - h.x) * (w - h.y) / (h.next.y - h.y) + h.x && (y = !y), h = h.next;
            while (h !== n);
            return y;
          })(o, t) && (Mi(o.prev, o, t.prev) || Mi(o, t.prev, t)) || Lu(o, t) && Mi(o.prev, o, o.next) > 0 && Mi(t.prev, t, t.next) > 0);
        }
        function Mi(o, t, n) {
          return (t.y - o.y) * (n.x - t.x) - (t.x - o.x) * (n.y - t.y);
        }
        function Lu(o, t) {
          return o.x === t.x && o.y === t.y;
        }
        function W0(o, t, n, u) {
          const h = Sf(Mi(o, t, n)), y = Sf(Mi(o, t, u)), b = Sf(Mi(n, u, o)), w = Sf(Mi(n, u, t));
          return h !== y && b !== w || !(h !== 0 || !Cf(o, n, t)) || !(y !== 0 || !Cf(o, u, t)) || !(b !== 0 || !Cf(n, o, u)) || !(w !== 0 || !Cf(n, t, u));
        }
        function Cf(o, t, n) {
          return t.x <= Math.max(o.x, n.x) && t.x >= Math.min(o.x, n.x) && t.y <= Math.max(o.y, n.y) && t.y >= Math.min(o.y, n.y);
        }
        function Sf(o) {
          return o > 0 ? 1 : o < 0 ? -1 : 0;
        }
        function bd(o, t) {
          return Mi(o.prev, o, o.next) < 0 ? Mi(o, t, o.next) >= 0 && Mi(o, o.prev, t) >= 0 : Mi(o, t, o.prev) < 0 || Mi(o, o.next, t) < 0;
        }
        function Z0(o, t) {
          const n = _m(o.i, o.x, o.y), u = _m(t.i, t.x, t.y), h = o.next, y = t.prev;
          return o.next = t, t.prev = o, n.next = h, h.prev = n, u.next = n, n.prev = u, y.next = u, u.prev = y, u;
        }
        function H0(o, t, n, u) {
          const h = _m(o, t, n);
          return u ? (h.next = u.next, h.prev = u, u.next.prev = h, u.next = h) : (h.prev = h, h.next = h), h;
        }
        function xd(o) {
          o.next.prev = o.prev, o.prev.next = o.next, o.prevZ && (o.prevZ.nextZ = o.nextZ), o.nextZ && (o.nextZ.prevZ = o.prevZ);
        }
        function _m(o, t, n) {
          return { i: o, x: t, y: n, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
        }
        class Bu {
          constructor(t, n) {
            if (n > t) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t, this._minGranularity = n;
          }
          getGranularityForZoomLevel(t) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1);
          }
        }
        class kf {
          constructor(t) {
            this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle;
          }
        }
        kf.noSubdivision = new kf({ fill: new Bu(0, 0), line: new Bu(0, 0), tile: new Bu(0, 0), stencil: new Bu(0, 0), circle: 1 }), Dt("SubdivisionGranularityExpression", Bu), Dt("SubdivisionGranularitySetting", kf);
        const Ou = -32768, wd = 32767;
        class qx {
          constructor(t, n) {
            this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = false, this._granularity = t, this._granularityCellSize = nt / t, this._canonical = n;
          }
          _getKey(t, n) {
            return (t += 32768) << 16 | n + 32768;
          }
          _vertexToIndex(t, n) {
            if (t < -32768 || n < -32768 || t > 32767 || n > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const u = 0 | Math.round(t), h = 0 | Math.round(n), y = this._getKey(u, h);
            if (this._vertexDictionary.has(y)) return this._vertexDictionary.get(y);
            const b = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(y, b), this._vertexBuffer.push(u, h), b;
          }
          _subdivideTrianglesScanline(t) {
            if (this._granularity < 2) return (function(h, y) {
              const b = [];
              for (let w = 0; w < y.length; w += 3) {
                const S = y[w], I = y[w + 1], E = y[w + 2], O = h[2 * S], V = h[2 * S + 1];
                (h[2 * I] - O) * (h[2 * E + 1] - V) - (h[2 * I + 1] - V) * (h[2 * E] - O) > 0 ? (b.push(S), b.push(E), b.push(I)) : (b.push(S), b.push(I), b.push(E));
              }
              return b;
            })(this._vertexBuffer, t);
            const n = [], u = t.length;
            for (let h = 0; h < u; h += 3) {
              const y = [t[h + 0], t[h + 1], t[h + 2]], b = [this._vertexBuffer[2 * t[h + 0] + 0], this._vertexBuffer[2 * t[h + 0] + 1], this._vertexBuffer[2 * t[h + 1] + 0], this._vertexBuffer[2 * t[h + 1] + 1], this._vertexBuffer[2 * t[h + 2] + 0], this._vertexBuffer[2 * t[h + 2] + 1]];
              let w = 1 / 0, S = 1 / 0, I = -1 / 0, E = -1 / 0;
              for (let ee = 0; ee < 3; ee++) {
                const se = b[2 * ee], pe = b[2 * ee + 1];
                w = Math.min(w, se), I = Math.max(I, se), S = Math.min(S, pe), E = Math.max(E, pe);
              }
              if (w === I || S === E) continue;
              const O = Math.floor(w / this._granularityCellSize), V = Math.ceil(I / this._granularityCellSize), U = Math.floor(S / this._granularityCellSize), W = Math.ceil(E / this._granularityCellSize);
              if (O !== V || U !== W) for (let ee = U; ee < W; ee++) {
                const se = this._scanlineGenerateVertexRingForCellRow(ee, b, y);
                Wx(this._vertexBuffer, se, n);
              }
              else n.push(...y);
            }
            return n;
          }
          _scanlineGenerateVertexRingForCellRow(t, n, u) {
            const h = t * this._granularityCellSize, y = h + this._granularityCellSize, b = [];
            for (let w = 0; w < 3; w++) {
              const S = n[2 * w], I = n[2 * w + 1], E = n[2 * (w + 1) % 6], O = n[(2 * (w + 1) + 1) % 6], V = n[2 * (w + 2) % 6], U = n[(2 * (w + 2) + 1) % 6], W = E - S, ee = O - I, se = W === 0, pe = ee === 0, je = (h - I) / ee, be = (y - I) / ee, Me = Math.min(je, be), Xe = Math.max(je, be);
              if (!pe && (Me >= 1 || Xe <= 0) || pe && (I < h || I > y)) {
                O >= h && O <= y && b.push(u[(w + 1) % 3]);
                continue;
              }
              !pe && Me > 0 && b.push(this._vertexToIndex(S + W * Me, I + ee * Me));
              const it = S + W * Math.max(Me, 0), _t = S + W * Math.min(Xe, 1);
              se || this._generateIntraEdgeVertices(b, S, I, E, O, it, _t), !pe && Xe < 1 && b.push(this._vertexToIndex(S + W * Xe, I + ee * Xe)), (pe || O >= h && O <= y) && b.push(u[(w + 1) % 3]), !pe && (O <= h || O >= y) && this._generateInterEdgeVertices(b, S, I, E, O, V, U, _t, h, y);
            }
            return b;
          }
          _generateIntraEdgeVertices(t, n, u, h, y, b, w) {
            const S = h - n, I = y - u, E = I === 0, O = E ? Math.min(n, h) : Math.min(b, w), V = E ? Math.max(n, h) : Math.max(b, w), U = Math.floor(O / this._granularityCellSize) + 1, W = Math.ceil(V / this._granularityCellSize) - 1;
            if (E ? n < h : b < w) for (let ee = U; ee <= W; ee++) {
              const se = ee * this._granularityCellSize;
              t.push(this._vertexToIndex(se, u + I * (se - n) / S));
            }
            else for (let ee = W; ee >= U; ee--) {
              const se = ee * this._granularityCellSize;
              t.push(this._vertexToIndex(se, u + I * (se - n) / S));
            }
          }
          _generateInterEdgeVertices(t, n, u, h, y, b, w, S, I, E) {
            const O = y - u, V = b - h, U = w - y, W = (I - y) / U, ee = (E - y) / U, se = Math.min(W, ee), pe = Math.max(W, ee), je = h + V * se;
            let be = Math.floor(Math.min(je, S) / this._granularityCellSize) + 1, Me = Math.ceil(Math.max(je, S) / this._granularityCellSize) - 1, Xe = S < je;
            const it = U === 0;
            if (it && (w === I || w === E)) return;
            if (it || se >= 1 || pe <= 0) {
              const At = u - w, It = b + (n - b) * Math.min((I - w) / At, (E - w) / At);
              be = Math.floor(Math.min(It, S) / this._granularityCellSize) + 1, Me = Math.ceil(Math.max(It, S) / this._granularityCellSize) - 1, Xe = S < It;
            }
            const _t = O > 0 ? E : I;
            if (Xe) for (let At = be; At <= Me; At++) t.push(this._vertexToIndex(At * this._granularityCellSize, _t));
            else for (let At = Me; At >= be; At--) t.push(this._vertexToIndex(At * this._granularityCellSize, _t));
          }
          _generateOutline(t) {
            const n = [];
            for (const u of t) {
              const h = wl(u, this._granularity, true), y = this._pointArrayToIndices(h), b = [];
              for (let w = 1; w < y.length; w++) b.push(y[w - 1]), b.push(y[w]);
              n.push(b);
            }
            return n;
          }
          _handlePoles(t) {
            let n = false, u = false;
            this._canonical && (this._canonical.y === 0 && (n = true), this._canonical.y === (1 << this._canonical.z) - 1 && (u = true)), (n || u) && this._fillPoles(t, n, u);
          }
          _ensureNoPoleVertices() {
            const t = this._vertexBuffer;
            for (let n = 0; n < t.length; n += 2) {
              const u = t[n + 1];
              u === Ou && (t[n + 1] = -32767), u === wd && (t[n + 1] = 32766);
            }
          }
          _generatePoleQuad(t, n, u, h, y, b) {
            h > y != (b === Ou) ? (t.push(n), t.push(u), t.push(this._vertexToIndex(h, b)), t.push(u), t.push(this._vertexToIndex(y, b)), t.push(this._vertexToIndex(h, b))) : (t.push(u), t.push(n), t.push(this._vertexToIndex(h, b)), t.push(this._vertexToIndex(y, b)), t.push(u), t.push(this._vertexToIndex(h, b)));
          }
          _fillPoles(t, n, u) {
            const h = this._vertexBuffer, y = nt, b = t.length;
            for (let w = 2; w < b; w += 3) {
              const S = t[w - 2], I = t[w - 1], E = t[w], O = h[2 * S], V = h[2 * S + 1], U = h[2 * I], W = h[2 * I + 1], ee = h[2 * E], se = h[2 * E + 1];
              n && (V === 0 && W === 0 && this._generatePoleQuad(t, S, I, O, U, Ou), W === 0 && se === 0 && this._generatePoleQuad(t, I, E, U, ee, Ou), se === 0 && V === 0 && this._generatePoleQuad(t, E, S, ee, O, Ou)), u && (V === y && W === y && this._generatePoleQuad(t, S, I, O, U, wd), W === y && se === y && this._generatePoleQuad(t, I, E, U, ee, wd), se === y && V === y && this._generatePoleQuad(t, E, S, ee, O, wd));
            }
          }
          _initializeVertices(t) {
            for (let n = 0; n < t.length; n += 2) this._vertexToIndex(t[n], t[n + 1]);
          }
          subdividePolygonInternal(t, n) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = true;
            const { flattened: u, holeIndices: h } = (function(w) {
              const S = [], I = [];
              for (const E of w) if (E.length !== 0) {
                E !== w[0] && S.push(I.length / 2);
                for (let O = 0; O < E.length; O++) I.push(E[O].x), I.push(E[O].y);
              }
              return { flattened: I, holeIndices: S };
            })(t);
            let y;
            this._initializeVertices(u);
            try {
              const w = (function(I, E, O = 2) {
                const V = E && E.length, U = V ? E[0] * O : I.length;
                let W = G0(I, 0, U, O, true);
                const ee = [];
                if (!W || W.next === W.prev) return ee;
                let se, pe, je;
                if (V && (W = (function(be, Me, Xe, it) {
                  const _t = [];
                  for (let At = 0, It = Me.length; At < It; At++) {
                    const Et = G0(be, Me[At] * it, At < It - 1 ? Me[At + 1] * it : be.length, it, false);
                    Et === Et.next && (Et.steiner = true), _t.push(Ux(Et));
                  }
                  _t.sort(jx);
                  for (let At = 0; At < _t.length; At++) Xe = Nx(_t[At], Xe);
                  return Xe;
                })(I, E, W, O)), I.length > 80 * O) {
                  se = I[0], pe = I[1];
                  let be = se, Me = pe;
                  for (let Xe = O; Xe < U; Xe += O) {
                    const it = I[Xe], _t = I[Xe + 1];
                    it < se && (se = it), _t < pe && (pe = _t), it > be && (be = it), _t > Me && (Me = _t);
                  }
                  je = Math.max(be - se, Me - pe), je = je !== 0 ? 32767 / je : 0;
                }
                return _d(W, ee, O, se, pe, je, 0), ee;
              })(u, h), S = this._convertIndices(u, w);
              y = this._subdivideTrianglesScanline(S);
            } catch (w) {
              console.error(w);
            }
            let b = [];
            return n && (b = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(y), { verticesFlattened: this._vertexBuffer, indicesTriangles: y, indicesLineList: b };
          }
          _convertIndices(t, n) {
            const u = [];
            for (let h = 0; h < n.length; h++) u.push(this._vertexToIndex(t[2 * n[h]], t[2 * n[h] + 1]));
            return u;
          }
          _pointArrayToIndices(t) {
            const n = [];
            for (let u = 0; u < t.length; u++) {
              const h = t[u];
              n.push(this._vertexToIndex(h.x, h.y));
            }
            return n;
          }
        }
        function X0(o, t, n, u = true) {
          return new qx(n, t).subdividePolygonInternal(o, u);
        }
        function wl(o, t, n = false) {
          if (!o || o.length < 1) return [];
          if (o.length < 2) return [];
          const u = o[0], h = o[o.length - 1], y = n && (u.x !== h.x || u.y !== h.y);
          if (t < 2) return y ? [...o, o[0]] : [...o];
          const b = Math.floor(nt / t), w = [];
          w.push(new C(o[0].x, o[0].y));
          const S = o.length, I = y ? S : S - 1;
          for (let E = 0; E < I; E++) {
            const O = o[E], V = E < S - 1 ? o[E + 1] : o[0], U = O.x, W = O.y, ee = V.x, se = V.y, pe = U !== ee, je = W !== se;
            if (!pe && !je) continue;
            const be = ee - U, Me = se - W, Xe = Math.abs(be), it = Math.abs(Me);
            let _t = U, At = W;
            for (; ; ) {
              const Et = be > 0 ? (Math.floor(_t / b) + 1) * b : (Math.ceil(_t / b) - 1) * b, Yt = Me > 0 ? (Math.floor(At / b) + 1) * b : (Math.ceil(At / b) - 1) * b, Mt = Math.abs(_t - Et), Rt = Math.abs(At - Yt), lt = Math.abs(_t - ee), sr = Math.abs(At - se), cr = pe ? Mt / Xe : Number.POSITIVE_INFINITY, Qt = je ? Rt / it : Number.POSITIVE_INFINITY;
              if ((lt <= Mt || !pe) && (sr <= Rt || !je)) break;
              if (cr < Qt && pe || !je) {
                _t = Et, At += Me * cr;
                const Gt = new C(_t, Math.round(At));
                w[w.length - 1].x === Gt.x && w[w.length - 1].y === Gt.y || w.push(Gt);
              } else {
                _t += be * Qt, At = Yt;
                const Gt = new C(Math.round(_t), At);
                w[w.length - 1].x === Gt.x && w[w.length - 1].y === Gt.y || w.push(Gt);
              }
            }
            const It = new C(ee, se);
            w[w.length - 1].x === It.x && w[w.length - 1].y === It.y || w.push(It);
          }
          return w;
        }
        function Wx(o, t, n) {
          if (t.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let u = 0, h = o[2 * t[0]];
          for (let S = 1; S < t.length; S++) {
            const I = o[2 * t[S]];
            I < h && (h = I, u = S);
          }
          const y = t.length;
          let b = u, w = (b + 1) % y;
          for (; ; ) {
            const S = b - 1 >= 0 ? b - 1 : y - 1, I = (w + 1) % y, E = o[2 * t[S]], O = o[2 * t[I]], V = o[2 * t[b]], U = o[2 * t[b] + 1], W = o[2 * t[w] + 1];
            let ee = false;
            if (E < O) ee = true;
            else if (E > O) ee = false;
            else {
              const se = W - U, pe = -(o[2 * t[w]] - V), je = U < W ? 1 : -1;
              ((E - V) * se + (o[2 * t[S] + 1] - U) * pe) * je > ((O - V) * se + (o[2 * t[I] + 1] - U) * pe) * je && (ee = true);
            }
            if (ee) {
              const se = t[S], pe = t[b], je = t[w];
              se !== pe && se !== je && pe !== je && n.push(je, pe, se), b--, b < 0 && (b = y - 1);
            } else {
              const se = t[I], pe = t[b], je = t[w];
              se !== pe && se !== je && pe !== je && n.push(je, pe, se), w++, w >= y && (w = 0);
            }
            if (S === I) break;
          }
        }
        function Y0(o, t, n, u, h, y, b, w, S) {
          const I = h.length / 2, E = b && w && S;
          if (I < vr.MAX_VERTEX_ARRAY_LENGTH) {
            const O = t.prepareSegment(I, n, u), V = O.vertexLength;
            for (let ee = 0; ee < y.length; ee += 3) u.emplaceBack(V + y[ee], V + y[ee + 1], V + y[ee + 2]);
            let U, W;
            O.vertexLength += I, O.primitiveLength += y.length / 3, E && (W = b.prepareSegment(I, n, w), U = W.vertexLength, W.vertexLength += I);
            for (let ee = 0; ee < h.length; ee += 2) o(h[ee], h[ee + 1]);
            if (E) for (let ee = 0; ee < S.length; ee++) {
              const se = S[ee];
              for (let pe = 1; pe < se.length; pe += 2) w.emplaceBack(U + se[pe - 1], U + se[pe]);
              W.primitiveLength += se.length / 2;
            }
          } else (function(O, V, U, W, ee, se) {
            const pe = [];
            for (let it = 0; it < W.length / 2; it++) pe.push(-1);
            const je = { count: 0 };
            let be = 0, Me = O.getOrCreateLatestSegment(V, U), Xe = Me.vertexLength;
            for (let it = 2; it < ee.length; it += 3) {
              const _t = ee[it - 2], At = ee[it - 1], It = ee[it];
              let Et = pe[_t] < be, Yt = pe[At] < be, Mt = pe[It] < be;
              Me.vertexLength + ((Et ? 1 : 0) + (Yt ? 1 : 0) + (Mt ? 1 : 0)) > vr.MAX_VERTEX_ARRAY_LENGTH && (Me = O.createNewSegment(V, U), be = je.count, Et = true, Yt = true, Mt = true, Xe = 0);
              const Rt = Cd(pe, W, se, je, _t, Et, Me), lt = Cd(pe, W, se, je, At, Yt, Me), sr = Cd(pe, W, se, je, It, Mt, Me);
              U.emplaceBack(Xe + Rt - be, Xe + lt - be, Xe + sr - be), Me.primitiveLength++;
            }
          })(t, n, u, h, y, o), E && (function(O, V, U, W, ee, se) {
            const pe = [];
            for (let it = 0; it < W.length / 2; it++) pe.push(-1);
            const je = { count: 0 };
            let be = 0, Me = O.getOrCreateLatestSegment(V, U), Xe = Me.vertexLength;
            for (let it = 0; it < ee.length; it++) {
              const _t = ee[it];
              for (let At = 1; At < ee[it].length; At += 2) {
                const It = _t[At - 1], Et = _t[At];
                let Yt = pe[It] < be, Mt = pe[Et] < be;
                Me.vertexLength + ((Yt ? 1 : 0) + (Mt ? 1 : 0)) > vr.MAX_VERTEX_ARRAY_LENGTH && (Me = O.createNewSegment(V, U), be = je.count, Yt = true, Mt = true, Xe = 0);
                const Rt = Cd(pe, W, se, je, It, Yt, Me), lt = Cd(pe, W, se, je, Et, Mt, Me);
                U.emplaceBack(Xe + Rt - be, Xe + lt - be), Me.primitiveLength++;
              }
            }
          })(b, n, w, h, S, o), t.forceNewSegmentOnNextPrepare(), b == null ? void 0 : b.forceNewSegmentOnNextPrepare();
        }
        function Cd(o, t, n, u, h, y, b) {
          if (y) {
            const w = u.count;
            return n(t[2 * h], t[2 * h + 1]), o[h] = u.count, u.count++, b.vertexLength++, w;
          }
          return o[h];
        }
        class ym {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((n) => n.id)), this.index = t.index, this.hasDependencies = false, this.patternFeatures = [], this.layoutVertexArray = new me(), this.indexArray = new dt(), this.indexArray2 = new Nt(), this.programConfigurations = new Ha(t.layers, t.zoom), this.segments = new vr(), this.segments2 = new vr(), this.stateDependentLayerIds = this.layers.filter(((n) => n.isStateDependent())).map(((n) => n.id));
          }
          populate(t, n, u) {
            this.hasDependencies = wf("fill", this.layers, n);
            const h = this.layers[0].layout.get("fill-sort-key"), y = !h.isConstant(), b = [];
            for (const { feature: w, id: S, index: I, sourceLayerIndex: E } of t) {
              const O = this.layers[0]._featureFilter.needGeometry, V = ma(w, O);
              if (!this.layers[0]._featureFilter.filter(new Yr(this.zoom), V, u)) continue;
              const U = y ? h.evaluate(V, {}, u, n.availableImages) : void 0, W = { id: S, properties: w.properties, type: w.type, sourceLayerIndex: E, index: I, geometry: O ? V.geometry : qo(w), patterns: {}, sortKey: U };
              b.push(W);
            }
            y && b.sort(((w, S) => w.sortKey - S.sortKey));
            for (const w of b) {
              const { geometry: S, index: I, sourceLayerIndex: E } = w;
              if (this.hasDependencies) {
                const O = gm("fill", this.layers, w, { zoom: this.zoom }, n);
                this.patternFeatures.push(O);
              } else this.addFeature(w, S, I, u, {}, n.subdivisionGranularity);
              n.featureIndex.insert(t[I].feature, S, I, E, this.index);
            }
          }
          update(t, n, u) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, { imagePositions: u });
          }
          addFeatures(t, n, u) {
            for (const h of this.patternFeatures) this.addFeature(h, h.geometry, h.index, n, u, t.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Fx), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t, n, u, h, y, b) {
            for (const w of nu(n, 500)) {
              const S = X0(w, h, b.fill.getGranularityForZoomLevel(h.z)), I = this.layoutVertexArray;
              Y0(((E, O) => {
                I.emplaceBack(E, O);
              }), this.segments, this.layoutVertexArray, this.indexArray, S.verticesFlattened, S.indicesTriangles, this.segments2, this.indexArray2, S.indicesLineList);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, u, { imagePositions: y, canonical: h });
          }
        }
        let K0, J0;
        Dt("FillBucket", ym, { omit: ["layers", "patternFeatures"] });
        var Zx = { get paint() {
          return J0 = J0 || new dn({ "fill-antialias": new qt(Le.paint_fill["fill-antialias"]), "fill-opacity": new er(Le.paint_fill["fill-opacity"]), "fill-color": new er(Le.paint_fill["fill-color"]), "fill-outline-color": new er(Le.paint_fill["fill-outline-color"]), "fill-translate": new qt(Le.paint_fill["fill-translate"]), "fill-translate-anchor": new qt(Le.paint_fill["fill-translate-anchor"]), "fill-pattern": new vl(Le.paint_fill["fill-pattern"]) });
        }, get layout() {
          return K0 = K0 || new dn({ "fill-sort-key": new er(Le.layout_fill["fill-sort-key"]) });
        } };
        class Hx extends uo {
          constructor(t, n) {
            super(t, Zx, n);
          }
          recalculate(t, n) {
            super.recalculate(t, n);
            const u = this.paint._values["fill-outline-color"];
            u.value.kind === "constant" && u.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t) {
            return new ym(t);
          }
          queryRadius() {
            return bf(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, geometry: n, transform: u, pixelsToTileUnits: h }) {
            return E0(xf(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -u.bearingInRadians, h), n);
          }
          isTileClipped() {
            return true;
          }
        }
        const Xx = Ci([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Yx = Ci([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: Kx } = Xx;
        class $u {
          constructor(t, n, u, h, y) {
            this.properties = {}, this.extent = u, this.type = 0, this.id = void 0, this._pbf = t, this._geometry = -1, this._keys = h, this._values = y, t.readFields(Jx, this, n);
          }
          loadGeometry() {
            const t = this._pbf;
            t.pos = this._geometry;
            const n = t.readVarint() + t.pos, u = [];
            let h, y = 1, b = 0, w = 0, S = 0;
            for (; t.pos < n; ) {
              if (b <= 0) {
                const I = t.readVarint();
                y = 7 & I, b = I >> 3;
              }
              if (b--, y === 1 || y === 2) w += t.readSVarint(), S += t.readSVarint(), y === 1 && (h && u.push(h), h = []), h && h.push(new C(w, S));
              else {
                if (y !== 7) throw new Error(`unknown command ${y}`);
                h && h.push(h[0].clone());
              }
            }
            return h && u.push(h), u;
          }
          bbox() {
            const t = this._pbf;
            t.pos = this._geometry;
            const n = t.readVarint() + t.pos;
            let u = 1, h = 0, y = 0, b = 0, w = 1 / 0, S = -1 / 0, I = 1 / 0, E = -1 / 0;
            for (; t.pos < n; ) {
              if (h <= 0) {
                const O = t.readVarint();
                u = 7 & O, h = O >> 3;
              }
              if (h--, u === 1 || u === 2) y += t.readSVarint(), b += t.readSVarint(), y < w && (w = y), y > S && (S = y), b < I && (I = b), b > E && (E = b);
              else if (u !== 7) throw new Error(`unknown command ${u}`);
            }
            return [w, I, S, E];
          }
          toGeoJSON(t, n, u) {
            const h = this.extent * Math.pow(2, u), y = this.extent * t, b = this.extent * n, w = this.loadGeometry();
            function S(V) {
              return [360 * (V.x + y) / h - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (V.y + b) / h) * Math.PI)) - 90];
            }
            function I(V) {
              return V.map(S);
            }
            let E;
            if (this.type === 1) {
              const V = [];
              for (const W of w) V.push(W[0]);
              const U = I(V);
              E = V.length === 1 ? { type: "Point", coordinates: U[0] } : { type: "MultiPoint", coordinates: U };
            } else if (this.type === 2) {
              const V = w.map(I);
              E = V.length === 1 ? { type: "LineString", coordinates: V[0] } : { type: "MultiLineString", coordinates: V };
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const V = (function(W) {
                  const ee = W.length;
                  if (ee <= 1) return [W];
                  const se = [];
                  let pe, je;
                  for (let be = 0; be < ee; be++) {
                    const Me = Qx(W[be]);
                    Me !== 0 && (je === void 0 && (je = Me < 0), je === Me < 0 ? (pe && se.push(pe), pe = [W[be]]) : pe && pe.push(W[be]));
                  }
                  return pe && se.push(pe), se;
                })(w), U = [];
                for (const W of V) U.push(W.map(I));
                E = U.length === 1 ? { type: "Polygon", coordinates: U[0] } : { type: "MultiPolygon", coordinates: U };
              }
            }
            const O = { type: "Feature", geometry: E, properties: this.properties };
            return this.id != null && (O.id = this.id), O;
          }
        }
        function Jx(o, t, n) {
          o === 1 ? t.id = n.readVarint() : o === 2 ? (function(u, h) {
            const y = u.readVarint() + u.pos;
            for (; u.pos < y; ) {
              const b = h._keys[u.readVarint()], w = h._values[u.readVarint()];
              h.properties[b] = w;
            }
          })(n, t) : o === 3 ? t.type = n.readVarint() : o === 4 && (t._geometry = n.pos);
        }
        function Qx(o) {
          let t = 0;
          for (let n, u, h = 0, y = o.length, b = y - 1; h < y; b = h++) n = o[h], u = o[b], t += (u.x - n.x) * (n.y + u.y);
          return t;
        }
        $u.types = ["Unknown", "Point", "LineString", "Polygon"];
        class Q0 {
          constructor(t, n) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(e2, this, n), this.length = this._features.length;
          }
          feature(t) {
            if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t];
            const n = this._pbf.readVarint() + this._pbf.pos;
            return new $u(this._pbf, n, this.extent, this._keys, this._values);
          }
        }
        function e2(o, t, n) {
          o === 15 ? t.version = n.readVarint() : o === 1 ? t.name = n.readString() : o === 5 ? t.extent = n.readVarint() : o === 2 ? t._features.push(n.pos) : o === 3 ? t._keys.push(n.readString()) : o === 4 && t._values.push((function(u) {
            let h = null;
            const y = u.readVarint() + u.pos;
            for (; u.pos < y; ) {
              const b = u.readVarint() >> 3;
              h = b === 1 ? u.readString() : b === 2 ? u.readFloat() : b === 3 ? u.readDouble() : b === 4 ? u.readVarint64() : b === 5 ? u.readVarint() : b === 6 ? u.readSVarint() : b === 7 ? u.readBoolean() : null;
            }
            if (h == null) throw new Error("unknown feature value");
            return h;
          })(n));
        }
        class ev {
          constructor(t, n) {
            this.layers = t.readFields(t2, {}, n);
          }
        }
        function t2(o, t, n) {
          if (o === 3) {
            const u = new Q0(n, n.readVarint() + n.pos);
            u.length && (t[u.name] = u);
          }
        }
        const bm = Math.pow(2, 13);
        function Sd(o, t, n, u, h, y, b, w) {
          o.emplaceBack(t, n, 2 * Math.floor(u * bm) + b, h * bm * 2, y * bm * 2, Math.round(w));
        }
        class xm {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((n) => n.id)), this.index = t.index, this.hasDependencies = false, this.layoutVertexArray = new ke(), this.centroidVertexArray = new ge(), this.indexArray = new dt(), this.programConfigurations = new Ha(t.layers, t.zoom), this.segments = new vr(), this.stateDependentLayerIds = this.layers.filter(((n) => n.isStateDependent())).map(((n) => n.id));
          }
          populate(t, n, u) {
            this.features = [], this.hasDependencies = wf("fill-extrusion", this.layers, n);
            for (const { feature: h, id: y, index: b, sourceLayerIndex: w } of t) {
              const S = this.layers[0]._featureFilter.needGeometry, I = ma(h, S);
              if (!this.layers[0]._featureFilter.filter(new Yr(this.zoom), I, u)) continue;
              const E = { id: y, sourceLayerIndex: w, index: b, geometry: S ? I.geometry : qo(h), properties: h.properties, type: h.type, patterns: {} };
              this.hasDependencies ? this.features.push(gm("fill-extrusion", this.layers, E, { zoom: this.zoom }, n)) : this.addFeature(E, E.geometry, b, u, {}, n.subdivisionGranularity), n.featureIndex.insert(h, E.geometry, b, w, this.index, true);
            }
          }
          addFeatures(t, n, u) {
            for (const h of this.features) {
              const { geometry: y } = h;
              this.addFeature(h, y, h.index, n, u, t.subdivisionGranularity);
            }
          }
          update(t, n, u) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, { imagePositions: u });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Kx), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, Yx.members, true), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(t, n, u, h, y, b) {
            for (const w of nu(n, 500)) {
              const S = { x: 0, y: 0, sampleCount: 0 }, I = this.layoutVertexArray.length;
              this.processPolygon(S, h, t, w, b);
              const E = this.layoutVertexArray.length - I, O = Math.floor(S.x / S.sampleCount), V = Math.floor(S.y / S.sampleCount);
              for (let U = 0; U < E; U++) this.centroidVertexArray.emplaceBack(O, V);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, u, { imagePositions: y, canonical: h });
          }
          processPolygon(t, n, u, h, y) {
            if (h.length < 1 || tv(h[0])) return;
            for (const O of h) O.length !== 0 && r2(t, O);
            const b = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, w = y.fill.getGranularityForZoomLevel(n.z), S = $u.types[u.type] === "Polygon";
            for (const O of h) {
              if (O.length === 0 || tv(O)) continue;
              const V = wl(O, w, S);
              this._generateSideFaces(V, b);
            }
            if (!S) return;
            const I = X0(h, n, w, false), E = this.layoutVertexArray;
            Y0(((O, V) => {
              Sd(E, O, V, 0, 0, 1, 1, 0);
            }), this.segments, this.layoutVertexArray, this.indexArray, I.verticesFlattened, I.indicesTriangles);
          }
          _generateSideFaces(t, n) {
            let u = 0;
            for (let h = 1; h < t.length; h++) {
              const y = t[h], b = t[h - 1];
              if (i2(y, b)) continue;
              n.segment.vertexLength + 4 > vr.MAX_VERTEX_ARRAY_LENGTH && (n.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const w = y.sub(b)._perp()._unit(), S = b.dist(y);
              u + S > 32768 && (u = 0), Sd(this.layoutVertexArray, y.x, y.y, w.x, w.y, 0, 0, u), Sd(this.layoutVertexArray, y.x, y.y, w.x, w.y, 0, 1, u), u += S, Sd(this.layoutVertexArray, b.x, b.y, w.x, w.y, 0, 0, u), Sd(this.layoutVertexArray, b.x, b.y, w.x, w.y, 0, 1, u);
              const I = n.segment.vertexLength;
              this.indexArray.emplaceBack(I, I + 2, I + 1), this.indexArray.emplaceBack(I + 1, I + 2, I + 3), n.segment.vertexLength += 4, n.segment.primitiveLength += 2;
            }
          }
        }
        function r2(o, t) {
          for (let n = 0; n < t.length; n++) {
            const u = t[n];
            n === t.length - 1 && t[0].x === u.x && t[0].y === u.y || (o.x += u.x, o.y += u.y, o.sampleCount++);
          }
        }
        function i2(o, t) {
          return o.x === t.x && (o.x < 0 || o.x > nt) || o.y === t.y && (o.y < 0 || o.y > nt);
        }
        function tv(o) {
          return o.every(((t) => t.x < 0)) || o.every(((t) => t.x > nt)) || o.every(((t) => t.y < 0)) || o.every(((t) => t.y > nt));
        }
        let rv;
        Dt("FillExtrusionBucket", xm, { omit: ["layers", "features"] });
        var n2 = { get paint() {
          return rv = rv || new dn({ "fill-extrusion-opacity": new qt(Le["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new er(Le["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new qt(Le["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new qt(Le["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new vl(Le["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new er(Le["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new er(Le["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new qt(Le["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class o2 extends uo {
          constructor(t, n) {
            super(t, n2, n);
          }
          createBucket(t) {
            return new xm(t);
          }
          queryRadius() {
            return bf(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return true;
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: u, geometry: h, transform: y, pixelsToTileUnits: b, pixelPosMatrix: w }) {
            const S = xf(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -y.bearingInRadians, b), I = this.paint.get("fill-extrusion-height").evaluate(n, u), E = this.paint.get("fill-extrusion-base").evaluate(n, u), O = (function(U, W) {
              const ee = [];
              for (const se of U) {
                const pe = [se.x, se.y, 0, 1];
                tt(pe, pe, W), ee.push(new C(pe[0] / pe[3], pe[1] / pe[3]));
              }
              return ee;
            })(S, w), V = (function(U, W, ee, se) {
              const pe = [], je = [], be = se[8] * W, Me = se[9] * W, Xe = se[10] * W, it = se[11] * W, _t = se[8] * ee, At = se[9] * ee, It = se[10] * ee, Et = se[11] * ee;
              for (const Yt of U) {
                const Mt = [], Rt = [];
                for (const lt of Yt) {
                  const sr = lt.x, cr = lt.y, Qt = se[0] * sr + se[4] * cr + se[12], Gt = se[1] * sr + se[5] * cr + se[13], Mr = se[2] * sr + se[6] * cr + se[14], yi = se[3] * sr + se[7] * cr + se[15], Oi = Mr + Xe, fn = yi + it, fo = Qt + _t, Un = Gt + At, en = Mr + It, mi = yi + Et, Zi = new C((Qt + be) / fn, (Gt + Me) / fn);
                  Zi.z = Oi / fn, Mt.push(Zi);
                  const tn = new C(fo / mi, Un / mi);
                  tn.z = en / mi, Rt.push(tn);
                }
                pe.push(Mt), je.push(Rt);
              }
              return [pe, je];
            })(h, E, I, w);
            return (function(U, W, ee) {
              let se = 1 / 0;
              E0(ee, W) && (se = iv(ee, W[0]));
              for (let pe = 0; pe < W.length; pe++) {
                const je = W[pe], be = U[pe];
                for (let Me = 0; Me < je.length - 1; Me++) {
                  const Xe = je[Me], it = [Xe, je[Me + 1], be[Me + 1], be[Me], Xe];
                  M0(ee, it) && (se = Math.min(se, iv(ee, it)));
                }
              }
              return se !== 1 / 0 && se;
            })(V[0], V[1], O);
          }
        }
        function kd(o, t) {
          return o.x * t.x + o.y * t.y;
        }
        function iv(o, t) {
          if (o.length === 1) {
            let n = 0;
            const u = t[n++];
            let h;
            for (; !h || u.equals(h); ) if (h = t[n++], !h) return 1 / 0;
            for (; n < t.length; n++) {
              const y = t[n], b = o[0], w = h.sub(u), S = y.sub(u), I = b.sub(u), E = kd(w, w), O = kd(w, S), V = kd(S, S), U = kd(I, w), W = kd(I, S), ee = E * V - O * O, se = (V * U - O * W) / ee, pe = (E * W - O * U) / ee, je = u.z * (1 - se - pe) + h.z * se + y.z * pe;
              if (isFinite(je)) return je;
            }
            return 1 / 0;
          }
          {
            let n = 1 / 0;
            for (const u of t) n = Math.min(n, u.z);
            return n;
          }
        }
        const a2 = Ci([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: s2 } = a2, l2 = Ci([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: u2 } = l2, c2 = Math.cos(Math.PI / 180 * 37.5), nv = Math.pow(2, 14) / 0.5;
        class wm {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((n) => n.id)), this.index = t.index, this.hasDependencies = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(((n) => {
              this.gradients[n.id] = {};
            })), this.layoutVertexArray = new Re(), this.layoutVertexArray2 = new ye(), this.indexArray = new dt(), this.programConfigurations = new Ha(t.layers, t.zoom), this.segments = new vr(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(((n) => n.isStateDependent())).map(((n) => n.id));
          }
          populate(t, n, u) {
            this.hasDependencies = wf("line", this.layers, n) || this.hasLineDasharray(this.layers);
            const h = this.layers[0].layout.get("line-sort-key"), y = !h.isConstant(), b = [];
            for (const { feature: w, id: S, index: I, sourceLayerIndex: E } of t) {
              const O = this.layers[0]._featureFilter.needGeometry, V = ma(w, O);
              if (!this.layers[0]._featureFilter.filter(new Yr(this.zoom), V, u)) continue;
              const U = y ? h.evaluate(V, {}, u) : void 0, W = { id: S, properties: w.properties, type: w.type, sourceLayerIndex: E, index: I, geometry: O ? V.geometry : qo(w), patterns: {}, dashes: {}, sortKey: U };
              b.push(W);
            }
            y && b.sort(((w, S) => w.sortKey - S.sortKey));
            for (const w of b) {
              const { geometry: S, index: I, sourceLayerIndex: E } = w;
              this.hasDependencies ? (wf("line", this.layers, n) ? gm("line", this.layers, w, { zoom: this.zoom }, n) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, w, this.zoom, n), this.patternFeatures.push(w)) : this.addFeature(w, S, I, u, {}, {}, n.subdivisionGranularity), n.featureIndex.insert(t[I].feature, S, I, E, this.index);
            }
          }
          update(t, n, u, h) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, { imagePositions: u, dashPositions: h });
          }
          addFeatures(t, n, u, h) {
            for (const y of this.patternFeatures) this.addFeature(y, y.geometry, y.index, n, u, h, t.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, u2)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, s2), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t) {
            if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return { start: +t.properties.mapbox_clip_start, end: +t.properties.mapbox_clip_end };
          }
          addFeature(t, n, u, h, y, b, w) {
            const S = this.layers[0].layout, I = S.get("line-join").evaluate(t, {}), E = S.get("line-cap"), O = S.get("line-miter-limit"), V = S.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t);
            for (const U of n) this.addLine(U, t, I, E, O, V, h, w);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, u, { imagePositions: y, dashPositions: b, canonical: h });
          }
          addLine(t, n, u, h, y, b, w, S) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = wl(t, w ? S.line.getGranularityForZoomLevel(w.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let be = 0; be < t.length - 1; be++) this.totalDistance += t[be].dist(t[be + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const I = $u.types[n.type] === "Polygon";
            let E = t.length;
            for (; E >= 2 && t[E - 1].equals(t[E - 2]); ) E--;
            let O = 0;
            for (; O < E - 1 && t[O].equals(t[O + 1]); ) O++;
            if (E < (I ? 3 : 2)) return;
            u === "bevel" && (y = 1.05);
            const V = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, U = this.segments.prepareSegment(10 * E, this.layoutVertexArray, this.indexArray);
            let W, ee, se, pe, je;
            this.e1 = this.e2 = -1, I && (W = t[E - 2], je = t[O].sub(W)._unit()._perp());
            for (let be = O; be < E; be++) {
              if (se = be === E - 1 ? I ? t[O + 1] : void 0 : t[be + 1], se && t[be].equals(se)) continue;
              je && (pe = je), W && (ee = W), W = t[be], je = se ? se.sub(W)._unit()._perp() : pe, pe = pe || je;
              let Me = pe.add(je);
              Me.x === 0 && Me.y === 0 || Me._unit();
              const Xe = pe.x * je.x + pe.y * je.y, it = Me.x * je.x + Me.y * je.y, _t = it !== 0 ? 1 / it : 1 / 0, At = 2 * Math.sqrt(2 - 2 * it), It = it < c2 && ee && se, Et = pe.x * je.y - pe.y * je.x > 0;
              if (It && be > O) {
                const Rt = W.dist(ee);
                if (Rt > 2 * V) {
                  const lt = W.sub(W.sub(ee)._mult(V / Rt)._round());
                  this.updateDistance(ee, lt), this.addCurrentVertex(lt, pe, 0, 0, U), ee = lt;
                }
              }
              const Yt = ee && se;
              let Mt = Yt ? u : I ? "butt" : h;
              if (Yt && Mt === "round" && (_t < b ? Mt = "miter" : _t <= 2 && (Mt = "fakeround")), Mt === "miter" && _t > y && (Mt = "bevel"), Mt === "bevel" && (_t > 2 && (Mt = "flipbevel"), _t < y && (Mt = "miter")), ee && this.updateDistance(ee, W), Mt === "miter") Me._mult(_t), this.addCurrentVertex(W, Me, 0, 0, U);
              else if (Mt === "flipbevel") {
                if (_t > 100) Me = je.mult(-1);
                else {
                  const Rt = _t * pe.add(je).mag() / pe.sub(je).mag();
                  Me._perp()._mult(Rt * (Et ? -1 : 1));
                }
                this.addCurrentVertex(W, Me, 0, 0, U), this.addCurrentVertex(W, Me.mult(-1), 0, 0, U);
              } else if (Mt === "bevel" || Mt === "fakeround") {
                const Rt = -Math.sqrt(_t * _t - 1), lt = Et ? Rt : 0, sr = Et ? 0 : Rt;
                if (ee && this.addCurrentVertex(W, pe, lt, sr, U), Mt === "fakeround") {
                  const cr = Math.round(180 * At / Math.PI / 20);
                  for (let Qt = 1; Qt < cr; Qt++) {
                    let Gt = Qt / cr;
                    if (Gt !== 0.5) {
                      const yi = Gt - 0.5;
                      Gt += Gt * yi * (Gt - 1) * ((1.0904 + Xe * (Xe * (3.55645 - 1.43519 * Xe) - 3.2452)) * yi * yi + (0.848013 + Xe * (0.215638 * Xe - 1.06021)));
                    }
                    const Mr = je.sub(pe)._mult(Gt)._add(pe)._unit()._mult(Et ? -1 : 1);
                    this.addHalfVertex(W, Mr.x, Mr.y, false, Et, 0, U);
                  }
                }
                se && this.addCurrentVertex(W, je, -lt, -sr, U);
              } else if (Mt === "butt") this.addCurrentVertex(W, Me, 0, 0, U);
              else if (Mt === "square") {
                const Rt = ee ? 1 : -1;
                this.addCurrentVertex(W, Me, Rt, Rt, U);
              } else Mt === "round" && (ee && (this.addCurrentVertex(W, pe, 0, 0, U), this.addCurrentVertex(W, pe, 1, 1, U, true)), se && (this.addCurrentVertex(W, je, -1, -1, U, true), this.addCurrentVertex(W, je, 0, 0, U)));
              if (It && be < E - 1) {
                const Rt = W.dist(se);
                if (Rt > 2 * V) {
                  const lt = W.add(se.sub(W)._mult(V / Rt)._round());
                  this.updateDistance(W, lt), this.addCurrentVertex(lt, je, 0, 0, U), W = lt;
                }
              }
            }
          }
          addCurrentVertex(t, n, u, h, y, b = false) {
            const w = n.y * h - n.x, S = -n.y - n.x * h;
            this.addHalfVertex(t, n.x + n.y * u, n.y - n.x * u, b, false, u, y), this.addHalfVertex(t, w, S, b, true, -h, y), this.distance > nv / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, n, u, h, y, b));
          }
          addHalfVertex({ x: t, y: n }, u, h, y, b, w, S) {
            const I = 0.5 * (this.lineClips ? this.scaledDistance * (nv - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t << 1) + (y ? 1 : 0), (n << 1) + (b ? 1 : 0), Math.round(63 * u) + 128, Math.round(63 * h) + 128, 1 + (w === 0 ? 0 : w < 0 ? -1 : 1) | (63 & I) << 2, I >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const E = S.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, E, this.e2), S.primitiveLength++), b ? this.e2 = E : this.e1 = E;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(t, n) {
            this.distance += t.dist(n), this.updateScaledDistance();
          }
          hasLineDasharray(t) {
            for (const n of t) {
              const u = n.paint.get("line-dasharray");
              if (u && !u.isConstant()) return true;
            }
            return false;
          }
          addLineDashDependencies(t, n, u, h) {
            for (const y of t) {
              const b = y.paint.get("line-dasharray");
              if (!b || b.value.kind === "constant") continue;
              const w = y.layout.get("line-cap") === "round", S = { dasharray: b.value.evaluate({ zoom: u - 1 }, n, {}), round: w }, I = { dasharray: b.value.evaluate({ zoom: u }, n, {}), round: w }, E = { dasharray: b.value.evaluate({ zoom: u + 1 }, n, {}), round: w }, O = `${S.dasharray.join(",")},${S.round}`, V = `${I.dasharray.join(",")},${I.round}`, U = `${E.dasharray.join(",")},${E.round}`;
              h.dashDependencies[O] = S, h.dashDependencies[V] = I, h.dashDependencies[U] = E, n.dashes[y.id] = { min: O, mid: V, max: U };
            }
          }
        }
        let ov, av;
        Dt("LineBucket", wm, { omit: ["layers", "patternFeatures"] });
        var sv = { get paint() {
          return av = av || new dn({ "line-opacity": new er(Le.paint_line["line-opacity"]), "line-color": new er(Le.paint_line["line-color"]), "line-translate": new qt(Le.paint_line["line-translate"]), "line-translate-anchor": new qt(Le.paint_line["line-translate-anchor"]), "line-width": new er(Le.paint_line["line-width"]), "line-gap-width": new er(Le.paint_line["line-gap-width"]), "line-offset": new er(Le.paint_line["line-offset"]), "line-blur": new er(Le.paint_line["line-blur"]), "line-dasharray": new vl(Le.paint_line["line-dasharray"]), "line-pattern": new vl(Le.paint_line["line-pattern"]), "line-gradient": new _l(Le.paint_line["line-gradient"]) });
        }, get layout() {
          return ov = ov || new dn({ "line-cap": new qt(Le.layout_line["line-cap"]), "line-join": new er(Le.layout_line["line-join"]), "line-miter-limit": new qt(Le.layout_line["line-miter-limit"]), "line-round-limit": new qt(Le.layout_line["line-round-limit"]), "line-sort-key": new er(Le.layout_line["line-sort-key"]) });
        } };
        class d2 extends er {
          possiblyEvaluate(t, n) {
            return n = new Yr(Math.floor(n.zoom), { now: n.now, fadeDuration: n.fadeDuration, zoomHistory: n.zoomHistory, transition: n.transition }), super.possiblyEvaluate(t, n);
          }
          evaluate(t, n, u, h) {
            return n = Zt({}, n, { zoom: Math.floor(n.zoom) }), super.evaluate(t, n, u, h);
          }
        }
        let Pf;
        class h2 extends uo {
          constructor(t, n) {
            super(t, sv, n), this.gradientVersion = 0, Pf || (Pf = new d2(sv.paint.properties["line-width"].specification), Pf.useIntegerZoom = true);
          }
          _handleSpecialPaintPropertyUpdate(t) {
            if (t === "line-gradient") {
              const n = this.gradientExpression();
              this.stepInterpolant = !!(function(u) {
                return u._styleExpression !== void 0;
              })(n) && n._styleExpression.expression instanceof ms, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(t, n) {
            super.recalculate(t, n), this.paint._values["line-floorwidth"] = Pf.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t);
          }
          createBucket(t) {
            return new wm(t);
          }
          queryRadius(t) {
            const n = t, u = lv(Fu("line-width", this, n), Fu("line-gap-width", this, n)), h = Fu("line-offset", this, n);
            return u / 2 + Math.abs(h) + bf(this.paint.get("line-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: u, geometry: h, transform: y, pixelsToTileUnits: b }) {
            const w = xf(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -y.bearingInRadians, b), S = b / 2 * lv(this.paint.get("line-width").evaluate(n, u), this.paint.get("line-gap-width").evaluate(n, u)), I = this.paint.get("line-offset").evaluate(n, u);
            return I && (h = (function(E, O) {
              const V = [];
              for (let U = 0; U < E.length; U++) {
                const W = E[U], ee = [];
                for (let se = 0; se < W.length; se++) {
                  const pe = W[se - 1], je = W[se], be = W[se + 1], Me = se === 0 ? new C(0, 0) : je.sub(pe)._unit()._perp(), Xe = se === W.length - 1 ? new C(0, 0) : be.sub(je)._unit()._perp(), it = Me._add(Xe)._unit(), _t = it.x * Xe.x + it.y * Xe.y;
                  _t !== 0 && it._mult(1 / _t), ee.push(it._mult(O)._add(je));
                }
                V.push(ee);
              }
              return V;
            })(h, I * b)), (function(E, O, V) {
              for (let U = 0; U < O.length; U++) {
                const W = O[U];
                if (E.length >= 3) {
                  for (let ee = 0; ee < W.length; ee++) if (zu(E, W[ee])) return true;
                }
                if (yx(E, W, V)) return true;
              }
              return false;
            })(w, h, S);
          }
          isTileClipped() {
            return true;
          }
        }
        function lv(o, t) {
          return t > 0 ? t + 2 * o : o;
        }
        const f2 = Ci([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), p2 = Ci([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        Ci([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const m2 = Ci([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
        Ci([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const uv = Ci([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), g2 = Ci([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function v2(o, t, n) {
          return o.sections.forEach(((u) => {
            u.text = (function(h, y, b) {
              const w = y.layout.get("text-transform").evaluate(b, {});
              return w === "uppercase" ? h = h.toLocaleUpperCase() : w === "lowercase" && (h = h.toLocaleLowerCase()), No.applyArabicShaping && (h = No.applyArabicShaping(h)), h;
            })(u.text, t, n);
          })), o;
        }
        Ci([{ name: "triangle", components: 3, type: "Uint16" }]), Ci([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Ci([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Ci([{ type: "Float32", name: "offsetX" }]), Ci([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Ci([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        const Pd = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
        var Wi = 24;
        const Cm = 4294967296, cv = 1 / Cm, dv = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class Sm {
          constructor(t = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          readFields(t, n, u = this.length) {
            for (; this.pos < u; ) {
              const h = this.readVarint(), y = h >> 3, b = this.pos;
              this.type = 7 & h, t(y, n, this), this.pos === b && this.skip(h);
            }
            return n;
          }
          readMessage(t, n) {
            return this.readFields(t, n, this.readVarint() + this.pos);
          }
          readFixed32() {
            const t = this.dataView.getUint32(this.pos, true);
            return this.pos += 4, t;
          }
          readSFixed32() {
            const t = this.dataView.getInt32(this.pos, true);
            return this.pos += 4, t;
          }
          readFixed64() {
            const t = this.dataView.getUint32(this.pos, true) + this.dataView.getUint32(this.pos + 4, true) * Cm;
            return this.pos += 8, t;
          }
          readSFixed64() {
            const t = this.dataView.getUint32(this.pos, true) + this.dataView.getInt32(this.pos + 4, true) * Cm;
            return this.pos += 8, t;
          }
          readFloat() {
            const t = this.dataView.getFloat32(this.pos, true);
            return this.pos += 4, t;
          }
          readDouble() {
            const t = this.dataView.getFloat64(this.pos, true);
            return this.pos += 8, t;
          }
          readVarint(t) {
            const n = this.buf;
            let u, h;
            return h = n[this.pos++], u = 127 & h, h < 128 ? u : (h = n[this.pos++], u |= (127 & h) << 7, h < 128 ? u : (h = n[this.pos++], u |= (127 & h) << 14, h < 128 ? u : (h = n[this.pos++], u |= (127 & h) << 21, h < 128 ? u : (h = n[this.pos], u |= (15 & h) << 28, (function(y, b, w) {
              const S = w.buf;
              let I, E;
              if (E = S[w.pos++], I = (112 & E) >> 4, E < 128 || (E = S[w.pos++], I |= (127 & E) << 3, E < 128) || (E = S[w.pos++], I |= (127 & E) << 10, E < 128) || (E = S[w.pos++], I |= (127 & E) << 17, E < 128) || (E = S[w.pos++], I |= (127 & E) << 24, E < 128) || (E = S[w.pos++], I |= (1 & E) << 31, E < 128)) return ju(y, I, b);
              throw new Error("Expected varint not more than 10 bytes");
            })(u, t, this)))));
          }
          readVarint64() {
            return this.readVarint(true);
          }
          readSVarint() {
            const t = this.readVarint();
            return t % 2 == 1 ? (t + 1) / -2 : t / 2;
          }
          readBoolean() {
            return !!this.readVarint();
          }
          readString() {
            const t = this.readVarint() + this.pos, n = this.pos;
            return this.pos = t, t - n >= 12 && dv ? dv.decode(this.buf.subarray(n, t)) : (function(u, h, y) {
              let b = "", w = h;
              for (; w < y; ) {
                const S = u[w];
                let I, E, O, V = null, U = S > 239 ? 4 : S > 223 ? 3 : S > 191 ? 2 : 1;
                if (w + U > y) break;
                U === 1 ? S < 128 && (V = S) : U === 2 ? (I = u[w + 1], (192 & I) == 128 && (V = (31 & S) << 6 | 63 & I, V <= 127 && (V = null))) : U === 3 ? (I = u[w + 1], E = u[w + 2], (192 & I) == 128 && (192 & E) == 128 && (V = (15 & S) << 12 | (63 & I) << 6 | 63 & E, (V <= 2047 || V >= 55296 && V <= 57343) && (V = null))) : U === 4 && (I = u[w + 1], E = u[w + 2], O = u[w + 3], (192 & I) == 128 && (192 & E) == 128 && (192 & O) == 128 && (V = (15 & S) << 18 | (63 & I) << 12 | (63 & E) << 6 | 63 & O, (V <= 65535 || V >= 1114112) && (V = null))), V === null ? (V = 65533, U = 1) : V > 65535 && (V -= 65536, b += String.fromCharCode(V >>> 10 & 1023 | 55296), V = 56320 | 1023 & V), b += String.fromCharCode(V), w += U;
              }
              return b;
            })(this.buf, n, t);
          }
          readBytes() {
            const t = this.readVarint() + this.pos, n = this.buf.subarray(this.pos, t);
            return this.pos = t, n;
          }
          readPackedVarint(t = [], n) {
            const u = this.readPackedEnd();
            for (; this.pos < u; ) t.push(this.readVarint(n));
            return t;
          }
          readPackedSVarint(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readSVarint());
            return t;
          }
          readPackedBoolean(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readBoolean());
            return t;
          }
          readPackedFloat(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readFloat());
            return t;
          }
          readPackedDouble(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readDouble());
            return t;
          }
          readPackedFixed32(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readFixed32());
            return t;
          }
          readPackedSFixed32(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readSFixed32());
            return t;
          }
          readPackedFixed64(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readFixed64());
            return t;
          }
          readPackedSFixed64(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readSFixed64());
            return t;
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1;
          }
          skip(t) {
            const n = 7 & t;
            if (n === 0) for (; this.buf[this.pos++] > 127; ) ;
            else if (n === 2) this.pos = this.readVarint() + this.pos;
            else if (n === 5) this.pos += 4;
            else {
              if (n !== 1) throw new Error(`Unimplemented type: ${n}`);
              this.pos += 8;
            }
          }
          writeTag(t, n) {
            this.writeVarint(t << 3 | n);
          }
          realloc(t) {
            let n = this.length || 16;
            for (; n < this.pos + t; ) n *= 2;
            if (n !== this.length) {
              const u = new Uint8Array(n);
              u.set(this.buf), this.buf = u, this.dataView = new DataView(u.buffer), this.length = n;
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }
          writeFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, true), this.pos += 4;
          }
          writeSFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, true), this.pos += 4;
          }
          writeFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, true), this.dataView.setInt32(this.pos + 4, Math.floor(t * cv), true), this.pos += 8;
          }
          writeSFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, true), this.dataView.setInt32(this.pos + 4, Math.floor(t * cv), true), this.pos += 8;
          }
          writeVarint(t) {
            (t = +t || 0) > 268435455 || t < 0 ? (function(n, u) {
              let h, y;
              if (n >= 0 ? (h = n % 4294967296 | 0, y = n / 4294967296 | 0) : (h = ~(-n % 4294967296), y = ~(-n / 4294967296), 4294967295 ^ h ? h = h + 1 | 0 : (h = 0, y = y + 1 | 0)), n >= 18446744073709552e3 || n < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              u.realloc(10), (function(b, w, S) {
                S.buf[S.pos++] = 127 & b | 128, b >>>= 7, S.buf[S.pos++] = 127 & b | 128, b >>>= 7, S.buf[S.pos++] = 127 & b | 128, b >>>= 7, S.buf[S.pos++] = 127 & b | 128, S.buf[S.pos] = 127 & (b >>>= 7);
              })(h, 0, u), (function(b, w) {
                const S = (7 & b) << 4;
                w.buf[w.pos++] |= S | ((b >>>= 3) ? 128 : 0), b && (w.buf[w.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (w.buf[w.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (w.buf[w.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (w.buf[w.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (w.buf[w.pos++] = 127 & b)))));
              })(y, u);
            })(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));
          }
          writeSVarint(t) {
            this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
          }
          writeBoolean(t) {
            this.writeVarint(+t);
          }
          writeString(t) {
            t = String(t), this.realloc(4 * t.length), this.pos++;
            const n = this.pos;
            this.pos = (function(h, y, b) {
              for (let w, S, I = 0; I < y.length; I++) {
                if (w = y.charCodeAt(I), w > 55295 && w < 57344) {
                  if (!S) {
                    w > 56319 || I + 1 === y.length ? (h[b++] = 239, h[b++] = 191, h[b++] = 189) : S = w;
                    continue;
                  }
                  if (w < 56320) {
                    h[b++] = 239, h[b++] = 191, h[b++] = 189, S = w;
                    continue;
                  }
                  w = S - 55296 << 10 | w - 56320 | 65536, S = null;
                } else S && (h[b++] = 239, h[b++] = 191, h[b++] = 189, S = null);
                w < 128 ? h[b++] = w : (w < 2048 ? h[b++] = w >> 6 | 192 : (w < 65536 ? h[b++] = w >> 12 | 224 : (h[b++] = w >> 18 | 240, h[b++] = w >> 12 & 63 | 128), h[b++] = w >> 6 & 63 | 128), h[b++] = 63 & w | 128);
              }
              return b;
            })(this.buf, t, this.pos);
            const u = this.pos - n;
            u >= 128 && hv(n, u, this), this.pos = n - 1, this.writeVarint(u), this.pos += u;
          }
          writeFloat(t) {
            this.realloc(4), this.dataView.setFloat32(this.pos, t, true), this.pos += 4;
          }
          writeDouble(t) {
            this.realloc(8), this.dataView.setFloat64(this.pos, t, true), this.pos += 8;
          }
          writeBytes(t) {
            const n = t.length;
            this.writeVarint(n), this.realloc(n);
            for (let u = 0; u < n; u++) this.buf[this.pos++] = t[u];
          }
          writeRawMessage(t, n) {
            this.pos++;
            const u = this.pos;
            t(n, this);
            const h = this.pos - u;
            h >= 128 && hv(u, h, this), this.pos = u - 1, this.writeVarint(h), this.pos += h;
          }
          writeMessage(t, n, u) {
            this.writeTag(t, 2), this.writeRawMessage(n, u);
          }
          writePackedVarint(t, n) {
            n.length && this.writeMessage(t, _2, n);
          }
          writePackedSVarint(t, n) {
            n.length && this.writeMessage(t, y2, n);
          }
          writePackedBoolean(t, n) {
            n.length && this.writeMessage(t, w2, n);
          }
          writePackedFloat(t, n) {
            n.length && this.writeMessage(t, b2, n);
          }
          writePackedDouble(t, n) {
            n.length && this.writeMessage(t, x2, n);
          }
          writePackedFixed32(t, n) {
            n.length && this.writeMessage(t, C2, n);
          }
          writePackedSFixed32(t, n) {
            n.length && this.writeMessage(t, S2, n);
          }
          writePackedFixed64(t, n) {
            n.length && this.writeMessage(t, k2, n);
          }
          writePackedSFixed64(t, n) {
            n.length && this.writeMessage(t, P2, n);
          }
          writeBytesField(t, n) {
            this.writeTag(t, 2), this.writeBytes(n);
          }
          writeFixed32Field(t, n) {
            this.writeTag(t, 5), this.writeFixed32(n);
          }
          writeSFixed32Field(t, n) {
            this.writeTag(t, 5), this.writeSFixed32(n);
          }
          writeFixed64Field(t, n) {
            this.writeTag(t, 1), this.writeFixed64(n);
          }
          writeSFixed64Field(t, n) {
            this.writeTag(t, 1), this.writeSFixed64(n);
          }
          writeVarintField(t, n) {
            this.writeTag(t, 0), this.writeVarint(n);
          }
          writeSVarintField(t, n) {
            this.writeTag(t, 0), this.writeSVarint(n);
          }
          writeStringField(t, n) {
            this.writeTag(t, 2), this.writeString(n);
          }
          writeFloatField(t, n) {
            this.writeTag(t, 5), this.writeFloat(n);
          }
          writeDoubleField(t, n) {
            this.writeTag(t, 1), this.writeDouble(n);
          }
          writeBooleanField(t, n) {
            this.writeVarintField(t, +n);
          }
        }
        function ju(o, t, n) {
          return n ? 4294967296 * t + (o >>> 0) : 4294967296 * (t >>> 0) + (o >>> 0);
        }
        function hv(o, t, n) {
          const u = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
          n.realloc(u);
          for (let h = n.pos - 1; h >= o; h--) n.buf[h + u] = n.buf[h];
        }
        function _2(o, t) {
          for (let n = 0; n < o.length; n++) t.writeVarint(o[n]);
        }
        function y2(o, t) {
          for (let n = 0; n < o.length; n++) t.writeSVarint(o[n]);
        }
        function b2(o, t) {
          for (let n = 0; n < o.length; n++) t.writeFloat(o[n]);
        }
        function x2(o, t) {
          for (let n = 0; n < o.length; n++) t.writeDouble(o[n]);
        }
        function w2(o, t) {
          for (let n = 0; n < o.length; n++) t.writeBoolean(o[n]);
        }
        function C2(o, t) {
          for (let n = 0; n < o.length; n++) t.writeFixed32(o[n]);
        }
        function S2(o, t) {
          for (let n = 0; n < o.length; n++) t.writeSFixed32(o[n]);
        }
        function k2(o, t) {
          for (let n = 0; n < o.length; n++) t.writeFixed64(o[n]);
        }
        function P2(o, t) {
          for (let n = 0; n < o.length; n++) t.writeSFixed64(o[n]);
        }
        function T2(o, t, n) {
          o === 1 && n.readMessage(I2, t);
        }
        function I2(o, t, n) {
          if (o === 3) {
            const { id: u, bitmap: h, width: y, height: b, left: w, top: S, advance: I } = n.readMessage(M2, {});
            t.push({ id: u, bitmap: new vd({ width: y + 6, height: b + 6 }, h), metrics: { width: y, height: b, left: w, top: S, advance: I } });
          }
        }
        function M2(o, t, n) {
          o === 1 ? t.id = n.readVarint() : o === 2 ? t.bitmap = n.readBytes() : o === 3 ? t.width = n.readVarint() : o === 4 ? t.height = n.readVarint() : o === 5 ? t.left = n.readSVarint() : o === 6 ? t.top = n.readSVarint() : o === 7 && (t.advance = n.readVarint());
        }
        function fv(o) {
          let t = 0, n = 0;
          for (const b of o) t += b.w * b.h, n = Math.max(n, b.w);
          o.sort(((b, w) => w.h - b.h));
          const u = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), n), h: 1 / 0 }];
          let h = 0, y = 0;
          for (const b of o) for (let w = u.length - 1; w >= 0; w--) {
            const S = u[w];
            if (!(b.w > S.w || b.h > S.h)) {
              if (b.x = S.x, b.y = S.y, y = Math.max(y, b.y + b.h), h = Math.max(h, b.x + b.w), b.w === S.w && b.h === S.h) {
                const I = u.pop();
                I && w < u.length && (u[w] = I);
              } else b.h === S.h ? (S.x += b.w, S.w -= b.w) : b.w === S.w ? (S.y += b.h, S.h -= b.h) : (u.push({ x: S.x + b.w, y: S.y, w: S.w - b.w, h: b.h }), S.y += b.h, S.h -= b.h);
              break;
            }
          }
          return { w: h, h: y, fill: t / (h * y) || 0 };
        }
        class km {
          constructor(t, { pixelRatio: n, version: u, stretchX: h, stretchY: y, content: b, textFitWidth: w, textFitHeight: S }) {
            this.paddedRect = t, this.pixelRatio = n, this.stretchX = h, this.stretchY = y, this.content = b, this.version = u, this.textFitWidth = w, this.textFitHeight = S;
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
          }
        }
        class pv {
          constructor(t, n) {
            const u = {}, h = {};
            this.haveRenderCallbacks = [];
            const y = [];
            this.addImages(t, u, y), this.addImages(n, h, y);
            const { w: b, h: w } = fv(y), S = new Vn({ width: b || 1, height: w || 1 });
            for (const I in t) {
              const E = t[I], O = u[I].paddedRect;
              Vn.copy(E.data, S, { x: 0, y: 0 }, { x: O.x + 1, y: O.y + 1 }, E.data);
            }
            for (const I in n) {
              const E = n[I], O = h[I].paddedRect, V = O.x + 1, U = O.y + 1, W = E.data.width, ee = E.data.height;
              Vn.copy(E.data, S, { x: 0, y: 0 }, { x: V, y: U }, E.data), Vn.copy(E.data, S, { x: 0, y: ee - 1 }, { x: V, y: U - 1 }, { width: W, height: 1 }), Vn.copy(E.data, S, { x: 0, y: 0 }, { x: V, y: U + ee }, { width: W, height: 1 }), Vn.copy(E.data, S, { x: W - 1, y: 0 }, { x: V - 1, y: U }, { width: 1, height: ee }), Vn.copy(E.data, S, { x: 0, y: 0 }, { x: V + W, y: U }, { width: 1, height: ee });
            }
            this.image = S, this.iconPositions = u, this.patternPositions = h;
          }
          addImages(t, n, u) {
            for (const h in t) {
              const y = t[h], b = { x: 0, y: 0, w: y.data.width + 2, h: y.data.height + 2 };
              u.push(b), n[h] = new km(b, y), y.hasRenderCallback && this.haveRenderCallbacks.push(h);
            }
          }
          patchUpdatedImages(t, n) {
            t.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const u in t.updatedImages) this.patchUpdatedImage(this.iconPositions[u], t.getImage(u), n), this.patchUpdatedImage(this.patternPositions[u], t.getImage(u), n);
          }
          patchUpdatedImage(t, n, u) {
            if (!t || !n || t.version === n.version) return;
            t.version = n.version;
            const [h, y] = t.tl;
            u.update(n.data, void 0, { x: h, y });
          }
        }
        var Is;
        Dt("ImagePosition", km), Dt("ImageAtlas", pv), p.as = void 0, (Is = p.as || (p.as = {}))[Is.none = 0] = "none", Is[Is.horizontal = 1] = "horizontal", Is[Is.vertical = 2] = "vertical", Is[Is.horizontalOnly = 3] = "horizontalOnly";
        class Td {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
          }
          static forText(t, n, u) {
            const h = new Td();
            return h.scale = t || 1, h.fontStack = n, h.verticalAlign = u || "bottom", h;
          }
          static forImage(t, n) {
            const u = new Td();
            return u.imageName = t, u.verticalAlign = n || "bottom", u;
          }
        }
        class Nu {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t, n) {
            const u = new Nu();
            for (let h = 0; h < t.sections.length; h++) {
              const y = t.sections[h];
              y.image ? u.addImageSection(y) : u.addTextSection(y, n);
            }
            return u;
          }
          length() {
            return this.text.length;
          }
          getSection(t) {
            return this.sections[this.sectionIndex[t]];
          }
          getSectionIndex(t) {
            return this.sectionIndex[t];
          }
          getCharCode(t) {
            return this.text.charCodeAt(t);
          }
          verticalizePunctuation() {
            this.text = (function(t) {
              let n = "";
              for (let u = 0; u < t.length; u++) {
                const h = t.charCodeAt(u + 1) || null, y = t.charCodeAt(u - 1) || null;
                n += h && ku(h) && !Pd[t[u + 1]] || y && ku(y) && !Pd[t[u - 1]] || !Pd[t[u]] ? t[u] : Pd[t[u]];
              }
              return n;
            })(this.text);
          }
          trim() {
            let t = 0;
            for (let u = 0; u < this.text.length && If[this.text.charCodeAt(u)]; u++) t++;
            let n = this.text.length;
            for (let u = this.text.length - 1; u >= 0 && u >= t && If[this.text.charCodeAt(u)]; u--) n--;
            this.text = this.text.substring(t, n), this.sectionIndex = this.sectionIndex.slice(t, n);
          }
          substring(t, n) {
            const u = new Nu();
            return u.text = this.text.substring(t, n), u.sectionIndex = this.sectionIndex.slice(t, n), u.sections = this.sections, u;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((t, n) => Math.max(t, this.sections[n].scale)), 0);
          }
          getMaxImageSize(t) {
            let n = 0, u = 0;
            for (let h = 0; h < this.length(); h++) {
              const y = this.getSection(h);
              if (y.imageName) {
                const b = t[y.imageName];
                if (!b) continue;
                const w = b.displaySize;
                n = Math.max(n, w[0]), u = Math.max(u, w[1]);
              }
            }
            return { maxImageWidth: n, maxImageHeight: u };
          }
          addTextSection(t, n) {
            this.text += t.text, this.sections.push(Td.forText(t.scale, t.fontStack || n, t.verticalAlign));
            const u = this.sections.length - 1;
            for (let h = 0; h < t.text.length; ++h) this.sectionIndex.push(u);
          }
          addImageSection(t) {
            const n = t.image ? t.image.name : "";
            if (n.length === 0) return void Xt("Can't add FormattedSection with an empty image.");
            const u = this.getNextImageSectionCharCode();
            u ? (this.text += String.fromCharCode(u), this.sections.push(Td.forImage(n, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : Xt("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function Tf(o, t, n, u, h, y, b, w, S, I, E, O, V, U, W) {
          const ee = Nu.fromFeature(o, h);
          let se;
          O === p.as.vertical && ee.verticalizePunctuation();
          const { processBidirectionalText: pe, processStyledBidirectionalText: je } = No;
          if (pe && ee.sections.length === 1) {
            se = [];
            const Xe = pe(ee.toString(), Pm(ee, I, y, t, u, U));
            for (const it of Xe) {
              const _t = new Nu();
              _t.text = it, _t.sections = ee.sections;
              for (let At = 0; At < it.length; At++) _t.sectionIndex.push(0);
              se.push(_t);
            }
          } else if (je) {
            se = [];
            const Xe = je(ee.text, ee.sectionIndex, Pm(ee, I, y, t, u, U));
            for (const it of Xe) {
              const _t = new Nu();
              _t.text = it[0], _t.sectionIndex = it[1], _t.sections = ee.sections, se.push(_t);
            }
          } else se = (function(Xe, it) {
            const _t = [], At = Xe.text;
            let It = 0;
            for (const Et of it) _t.push(Xe.substring(It, Et)), It = Et;
            return It < At.length && _t.push(Xe.substring(It, At.length)), _t;
          })(ee, Pm(ee, I, y, t, u, U));
          const be = [], Me = { positionedLines: be, text: ee.toString(), top: E[1], bottom: E[1], left: E[0], right: E[0], writingMode: O, iconsInText: false, verticalizable: false };
          return (function(Xe, it, _t, At, It, Et, Yt, Mt, Rt, lt, sr, cr) {
            let Qt = 0, Gt = 0, Mr = 0, yi = 0;
            const Oi = Mt === "right" ? 1 : Mt === "left" ? 0 : 0.5, fn = Wi / cr;
            let fo = 0;
            for (const mi of It) {
              mi.trim();
              const Zi = mi.getMaxScale(), tn = { positionedGlyphs: [], lineOffset: 0 };
              Xe.positionedLines[fo] = tn;
              const rn = tn.positionedGlyphs;
              let Fn = 0;
              if (!mi.length()) {
                Gt += Et, ++fo;
                continue;
              }
              const po = D2(At, mi, fn);
              for (let Gn = 0; Gn < mi.length(); Gn++) {
                const $i = mi.getSection(Gn), Xi = mi.getSectionIndex(Gn), Yi = mi.getCharCode(Gn), zi = z2(Rt, sr, Yi);
                let ni;
                if ($i.imageName) {
                  if (Xe.iconsInText = true, $i.scale = $i.scale * fn, ni = L2($i, zi, Zi, po, At), !ni) continue;
                  Fn = Math.max(Fn, ni.imageOffset);
                } else if (ni = F2($i, Yi, zi, po, it, _t), !ni) continue;
                const { rect: Wo, metrics: qu, baselineOffset: Zo } = ni;
                rn.push({ glyph: Yi, imageName: $i.imageName, x: Qt, y: Gt + Zo + -17, vertical: zi, scale: $i.scale, fontStack: $i.fontStack, sectionIndex: Xi, metrics: qu, rect: Wo }), zi ? (Xe.verticalizable = true, Qt += ($i.imageName ? qu.advance : Wi) * $i.scale + lt) : Qt += qu.advance * $i.scale + lt;
              }
              rn.length !== 0 && (Mr = Math.max(Qt - lt, Mr), B2(rn, 0, rn.length - 1, Oi)), Qt = 0, tn.lineOffset = Math.max(Fn, (Zi - 1) * Wi);
              const Hi = Et * Zi + Fn;
              Gt += Hi, yi = Math.max(Hi, yi), ++fo;
            }
            const { horizontalAlign: Un, verticalAlign: en } = Tm(Yt);
            (function(mi, Zi, tn, rn, Fn, po, Hi, Gn, $i) {
              const Xi = (Zi - tn) * Fn;
              let Yi = 0;
              Yi = po !== Hi ? -Gn * rn - -17 : -rn * $i * Hi + 0.5 * Hi;
              for (const zi of mi) for (const ni of zi.positionedGlyphs) ni.x += Xi, ni.y += Yi;
            })(Xe.positionedLines, Oi, Un, en, Mr, yi, Et, Gt, It.length), Xe.top += -en * Gt, Xe.bottom = Xe.top + Gt, Xe.left += -Un * Mr, Xe.right = Xe.left + Mr;
          })(Me, t, n, u, se, b, w, S, O, I, V, W), !(function(Xe) {
            for (const it of Xe) if (it.positionedGlyphs.length !== 0) return false;
            return true;
          })(be) && Me;
        }
        const If = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, E2 = { 10: true, 32: true, 38: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true }, R2 = { 40: true };
        function mv(o, t, n, u, h, y) {
          if (t.imageName) {
            const b = u[t.imageName];
            return b ? b.displaySize[0] * t.scale * Wi / y + h : 0;
          }
          {
            const b = n[t.fontStack], w = b && b[o];
            return w ? w.metrics.advance * t.scale + h : 0;
          }
        }
        function gv(o, t, n, u) {
          const h = Math.pow(o - t, 2);
          return u ? o < t ? h / 2 : 2 * h : h + Math.abs(n) * n;
        }
        function A2(o, t, n) {
          let u = 0;
          return o === 10 && (u -= 1e4), n && (u += 150), o !== 40 && o !== 65288 || (u += 50), t !== 41 && t !== 65289 || (u += 50), u;
        }
        function vv(o, t, n, u, h, y) {
          let b = null, w = gv(t, n, h, y);
          for (const S of u) {
            const I = gv(t - S.x, n, h, y) + S.badness;
            I <= w && (b = S, w = I);
          }
          return { index: o, x: t, priorBreak: b, badness: w };
        }
        function _v(o) {
          return o ? _v(o.priorBreak).concat(o.index) : [];
        }
        function Pm(o, t, n, u, h, y) {
          if (!o) return [];
          const b = [], w = (function(O, V, U, W, ee, se) {
            let pe = 0;
            for (let je = 0; je < O.length(); je++) {
              const be = O.getSection(je);
              pe += mv(O.getCharCode(je), be, W, ee, V, se);
            }
            return pe / Math.max(1, Math.ceil(pe / U));
          })(o, t, n, u, h, y), S = o.text.indexOf("\u200B") >= 0;
          let I = 0;
          for (let O = 0; O < o.length(); O++) {
            const V = o.getSection(O), U = o.getCharCode(O);
            if (If[U] || (I += mv(U, V, u, h, t, y)), O < o.length() - 1) {
              const W = !((E = U) < 11904) && (!!wr["CJK Compatibility Forms"](E) || !!wr["CJK Compatibility"](E) || !!wr["CJK Strokes"](E) || !!wr["CJK Symbols and Punctuation"](E) || !!wr["Enclosed CJK Letters and Months"](E) || !!wr["Halfwidth and Fullwidth Forms"](E) || !!wr["Ideographic Description Characters"](E) || !!wr["Vertical Forms"](E) || od.test(String.fromCodePoint(E)));
              (E2[U] || W || V.imageName || O !== o.length() - 2 && R2[o.getCharCode(O + 1)]) && b.push(vv(O + 1, I, w, b, A2(U, o.getCharCode(O + 1), W && S), false));
            }
          }
          var E;
          return _v(vv(o.length(), I, w, b, 0, true));
        }
        function Tm(o) {
          let t = 0.5, n = 0.5;
          switch (o) {
            case "right":
            case "top-right":
            case "bottom-right":
              t = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              t = 0;
          }
          switch (o) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              n = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              n = 0;
          }
          return { horizontalAlign: t, verticalAlign: n };
        }
        function D2(o, t, n) {
          const u = t.getMaxScale() * Wi, { maxImageWidth: h, maxImageHeight: y } = t.getMaxImageSize(o), b = Math.max(u, y * n);
          return { verticalLineContentWidth: Math.max(u, h * n), horizontalLineContentHeight: b };
        }
        function yv(o) {
          switch (o) {
            case "top":
              return 0;
            case "center":
              return 0.5;
            default:
              return 1;
          }
        }
        function z2(o, t, n) {
          return !(o === p.as.horizontal || !t && !Su(n) || t && (If[n] || (u = n, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(u)))));
          var u;
        }
        function F2(o, t, n, u, h, y) {
          const b = y[o.fontStack], w = (function(I, E, O, V) {
            if (I && I.rect) return I;
            const U = E[O.fontStack], W = U && U[V];
            return W ? { rect: null, metrics: W.metrics } : null;
          })(b && b[t], h, o, t);
          if (w === null) return null;
          let S;
          if (n) S = u.verticalLineContentWidth - o.scale * Wi;
          else {
            const I = yv(o.verticalAlign);
            S = (u.horizontalLineContentHeight - o.scale * Wi) * I;
          }
          return { rect: w.rect, metrics: w.metrics, baselineOffset: S };
        }
        function L2(o, t, n, u, h) {
          const y = h[o.imageName];
          if (!y) return null;
          const b = y.paddedRect, w = y.displaySize, S = { width: w[0], height: w[1], left: 1, top: -3, advance: t ? w[1] : w[0] };
          let I;
          if (t) I = u.verticalLineContentWidth - w[1] * o.scale;
          else {
            const E = yv(o.verticalAlign);
            I = (u.horizontalLineContentHeight - w[1] * o.scale) * E;
          }
          return { rect: b, metrics: S, baselineOffset: I, imageOffset: (t ? w[0] : w[1]) * o.scale - Wi * n };
        }
        function B2(o, t, n, u) {
          if (u === 0) return;
          const h = o[n], y = (o[n].x + h.metrics.advance * h.scale) * u;
          for (let b = t; b <= n; b++) o[b].x -= y;
        }
        function O2(o, t, n) {
          const { horizontalAlign: u, verticalAlign: h } = Tm(n), y = t[0] - o.displaySize[0] * u, b = t[1] - o.displaySize[1] * h;
          return { image: o, top: b, bottom: b + o.displaySize[1], left: y, right: y + o.displaySize[0] };
        }
        function bv(o) {
          var t, n;
          let u = o.left, h = o.top, y = o.right - u, b = o.bottom - h;
          const w = (t = o.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink", S = (n = o.image.textFitHeight) !== null && n !== void 0 ? n : "stretchOrShrink", I = (o.image.content[2] - o.image.content[0]) / (o.image.content[3] - o.image.content[1]);
          if (S === "proportional") {
            if (w === "stretchOnly" && y / b < I || w === "proportional") {
              const E = Math.ceil(b * I);
              u *= E / y, y = E;
            }
          } else if (w === "proportional" && S === "stretchOnly" && I !== 0 && y / b > I) {
            const E = Math.ceil(y / I);
            h *= E / b, b = E;
          }
          return { x1: u, y1: h, x2: u + y, y2: h + b };
        }
        function xv(o, t, n, u, h, y) {
          const b = o.image;
          let w;
          if (b.content) {
            const se = b.content, pe = b.pixelRatio || 1;
            w = [se[0] / pe, se[1] / pe, b.displaySize[0] - se[2] / pe, b.displaySize[1] - se[3] / pe];
          }
          const S = t.left * y, I = t.right * y;
          let E, O, V, U;
          n === "width" || n === "both" ? (U = h[0] + S - u[3], O = h[0] + I + u[1]) : (U = h[0] + (S + I - b.displaySize[0]) / 2, O = U + b.displaySize[0]);
          const W = t.top * y, ee = t.bottom * y;
          return n === "height" || n === "both" ? (E = h[1] + W - u[0], V = h[1] + ee + u[2]) : (E = h[1] + (W + ee - b.displaySize[1]) / 2, V = E + b.displaySize[1]), { image: b, top: E, right: O, bottom: V, left: U, collisionPadding: w };
        }
        const Ya = 128, Ms = 32640;
        function wv(o, t) {
          const { expression: n } = t;
          if (n.kind === "constant") return { kind: "constant", layoutSize: n.evaluate(new Yr(o + 1)) };
          if (n.kind === "source") return { kind: "source" };
          {
            const { zoomStops: u, interpolationType: h } = n;
            let y = 0;
            for (; y < u.length && u[y] <= o; ) y++;
            y = Math.max(0, y - 1);
            let b = y;
            for (; b < u.length && u[b] < o + 1; ) b++;
            b = Math.min(u.length - 1, b);
            const w = u[y], S = u[b];
            return n.kind === "composite" ? { kind: "composite", minZoom: w, maxZoom: S, interpolationType: h } : { kind: "camera", minZoom: w, maxZoom: S, minSize: n.evaluate(new Yr(w)), maxSize: n.evaluate(new Yr(S)), interpolationType: h };
          }
        }
        function Im(o, t, n) {
          let u = "never";
          const h = o.get(t);
          return h ? u = h : o.get(n) && (u = "always"), u;
        }
        const $2 = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function Mf(o, t, n, u, h, y, b, w, S, I, E, O, V) {
          const U = w ? Math.min(Ms, Math.round(w[0])) : 0, W = w ? Math.min(Ms, Math.round(w[1])) : 0;
          o.emplaceBack(t, n, Math.round(32 * u), Math.round(32 * h), y, b, (U << 1) + (S ? 1 : 0), W, 16 * I, 16 * E, 256 * O, 256 * V);
        }
        function Mm(o, t, n) {
          o.emplaceBack(t.x, t.y, n), o.emplaceBack(t.x, t.y, n), o.emplaceBack(t.x, t.y, n), o.emplaceBack(t.x, t.y, n);
        }
        function j2(o) {
          for (const t of o.sections) if (nm(t.text)) return true;
          return false;
        }
        class Em {
          constructor(t) {
            this.layoutVertexArray = new He(), this.indexArray = new dt(), this.programConfigurations = t, this.segments = new vr(), this.dynamicLayoutVertexArray = new Ye(), this.opacityVertexArray = new Qe(), this.hasVisibleVertices = false, this.placedSymbolArray = new R();
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
          }
          upload(t, n, u, h) {
            this.isEmpty() || (u && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, f2.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, n), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, p2.members, true), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, $2, true), this.opacityVertexBuffer.itemSize = 1), (u || h) && this.programConfigurations.upload(t));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        Dt("SymbolBuffers", Em);
        class Rm {
          constructor(t, n, u) {
            this.layoutVertexArray = new t(), this.layoutAttributes = n, this.indexArray = new u(), this.segments = new vr(), this.collisionVertexArray = new Tt();
          }
          upload(t) {
            this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, m2.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        Dt("CollisionBuffers", Rm);
        class Vu {
          constructor(t) {
            this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = ze(globalThis) ? Math.min(t.overscaling, 128) : t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((b) => b.id)), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasDependencies = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const n = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = wv(this.zoom, n["text-size"]), this.iconSizeData = wv(this.zoom, n["icon-size"]);
            const u = this.layers[0].layout, h = u.get("symbol-sort-key"), y = u.get("symbol-z-order");
            this.canOverlap = Im(u, "text-overlap", "text-allow-overlap") !== "never" || Im(u, "icon-overlap", "icon-allow-overlap") !== "never" || u.get("text-ignore-placement") || u.get("icon-ignore-placement"), this.sortFeaturesByKey = y !== "viewport-y" && !h.isConstant(), this.sortFeaturesByY = (y === "viewport-y" || y === "auto" && !this.sortFeaturesByKey) && this.canOverlap, u.get("symbol-placement") === "point" && (this.writingModes = u.get("text-writing-mode").map(((b) => p.as[b]))), this.stateDependentLayerIds = this.layers.filter(((b) => b.isStateDependent())).map(((b) => b.id)), this.sourceID = t.sourceID;
          }
          createArrays() {
            this.text = new Em(new Ha(this.layers, this.zoom, ((t) => /^text/.test(t)))), this.icon = new Em(new Ha(this.layers, this.zoom, ((t) => /^icon/.test(t)))), this.glyphOffsetArray = new j(), this.lineVertexArray = new G(), this.symbolInstances = new N(), this.textAnchorOffsets = new le();
          }
          calculateGlyphDependencies(t, n, u, h, y) {
            for (let b = 0; b < t.length; b++) if (n[t.charCodeAt(b)] = true, (u || h) && y) {
              const w = Pd[t.charAt(b)];
              w && (n[w.charCodeAt(0)] = true);
            }
          }
          populate(t, n, u) {
            const h = this.layers[0], y = h.layout, b = y.get("text-font"), w = y.get("text-field"), S = y.get("icon-image"), I = (w.value.kind !== "constant" || w.value.value instanceof Rn && !w.value.value.isEmpty() || w.value.value.toString().length > 0) && (b.value.kind !== "constant" || b.value.value.length > 0), E = S.value.kind !== "constant" || !!S.value.value || Object.keys(S.parameters).length > 0, O = y.get("symbol-sort-key");
            if (this.features = [], !I && !E) return;
            const V = n.iconDependencies, U = n.glyphDependencies, W = n.availableImages, ee = new Yr(this.zoom);
            for (const { feature: se, id: pe, index: je, sourceLayerIndex: be } of t) {
              const Me = h._featureFilter.needGeometry, Xe = ma(se, Me);
              if (!h._featureFilter.filter(ee, Xe, u)) continue;
              let it, _t;
              if (Me || (Xe.geometry = qo(se)), I) {
                const It = h.getValueAndResolveTokens("text-field", Xe, u, W), Et = Rn.factory(It), Yt = this.hasRTLText = this.hasRTLText || j2(Et);
                (!Yt || No.getRTLTextPluginStatus() === "unavailable" || Yt && No.isParsed()) && (it = v2(Et, h, Xe));
              }
              if (E) {
                const It = h.getValueAndResolveTokens("icon-image", Xe, u, W);
                _t = It instanceof gn ? It : gn.fromString(It);
              }
              if (!it && !_t) continue;
              const At = this.sortFeaturesByKey ? O.evaluate(Xe, {}, u) : void 0;
              if (this.features.push({ id: pe, text: it, icon: _t, index: je, sourceLayerIndex: be, geometry: Xe.geometry, properties: se.properties, type: $u.types[se.type], sortKey: At }), _t && (V[_t.name] = true), it) {
                const It = b.evaluate(Xe, {}, u).join(","), Et = y.get("text-rotation-alignment") !== "viewport" && y.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(p.as.vertical) >= 0;
                for (const Yt of it.sections) if (Yt.image) V[Yt.image.name] = true;
                else {
                  const Mt = id(it.toString()), Rt = Yt.fontStack || It, lt = U[Rt] = U[Rt] || {};
                  this.calculateGlyphDependencies(Yt.text, lt, Et, this.allowVerticalPlacement, Mt);
                }
              }
            }
            y.get("symbol-placement") === "line" && (this.features = (function(se) {
              const pe = {}, je = {}, be = [];
              let Me = 0;
              function Xe(It) {
                be.push(se[It]), Me++;
              }
              function it(It, Et, Yt) {
                const Mt = je[It];
                return delete je[It], je[Et] = Mt, be[Mt].geometry[0].pop(), be[Mt].geometry[0] = be[Mt].geometry[0].concat(Yt[0]), Mt;
              }
              function _t(It, Et, Yt) {
                const Mt = pe[Et];
                return delete pe[Et], pe[It] = Mt, be[Mt].geometry[0].shift(), be[Mt].geometry[0] = Yt[0].concat(be[Mt].geometry[0]), Mt;
              }
              function At(It, Et, Yt) {
                const Mt = Yt ? Et[0][Et[0].length - 1] : Et[0][0];
                return `${It}:${Mt.x}:${Mt.y}`;
              }
              for (let It = 0; It < se.length; It++) {
                const Et = se[It], Yt = Et.geometry, Mt = Et.text ? Et.text.toString() : null;
                if (!Mt) {
                  Xe(It);
                  continue;
                }
                const Rt = At(Mt, Yt), lt = At(Mt, Yt, true);
                if (Rt in je && lt in pe && je[Rt] !== pe[lt]) {
                  const sr = _t(Rt, lt, Yt), cr = it(Rt, lt, be[sr].geometry);
                  delete pe[Rt], delete je[lt], je[At(Mt, be[cr].geometry, true)] = cr, be[sr].geometry = null;
                } else Rt in je ? it(Rt, lt, Yt) : lt in pe ? _t(Rt, lt, Yt) : (Xe(It), pe[Rt] = Me - 1, je[lt] = Me - 1);
              }
              return be.filter(((It) => It.geometry));
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((se, pe) => se.sortKey - pe.sortKey));
          }
          update(t, n, u) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, n, this.layers, { imagePositions: u }), this.icon.programConfigurations.updatePaintArrays(t, n, this.layers, { imagePositions: u }));
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t, n) {
            const u = this.lineVertexArray.length;
            if (t.segment !== void 0) {
              let h = t.dist(n[t.segment + 1]), y = t.dist(n[t.segment]);
              const b = {};
              for (let w = t.segment + 1; w < n.length; w++) b[w] = { x: n[w].x, y: n[w].y, tileUnitDistanceFromAnchor: h }, w < n.length - 1 && (h += n[w + 1].dist(n[w]));
              for (let w = t.segment || 0; w >= 0; w--) b[w] = { x: n[w].x, y: n[w].y, tileUnitDistanceFromAnchor: y }, w > 0 && (y += n[w - 1].dist(n[w]));
              for (let w = 0; w < n.length; w++) {
                const S = b[w];
                this.lineVertexArray.emplaceBack(S.x, S.y, S.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: u, lineLength: this.lineVertexArray.length - u };
          }
          addSymbols(t, n, u, h, y, b, w, S, I, E, O, V) {
            const U = t.indexArray, W = t.layoutVertexArray, ee = t.segments.prepareSegment(4 * n.length, W, U, this.canOverlap ? b.sortKey : void 0), se = this.glyphOffsetArray.length, pe = ee.vertexLength, je = this.allowVerticalPlacement && w === p.as.vertical ? Math.PI / 2 : 0, be = b.text && b.text.sections;
            for (let Me = 0; Me < n.length; Me++) {
              const { tl: Xe, tr: it, bl: _t, br: At, tex: It, pixelOffsetTL: Et, pixelOffsetBR: Yt, minFontScaleX: Mt, minFontScaleY: Rt, glyphOffset: lt, isSDF: sr, sectionIndex: cr } = n[Me], Qt = ee.vertexLength, Gt = lt[1];
              Mf(W, S.x, S.y, Xe.x, Gt + Xe.y, It.x, It.y, u, sr, Et.x, Et.y, Mt, Rt), Mf(W, S.x, S.y, it.x, Gt + it.y, It.x + It.w, It.y, u, sr, Yt.x, Et.y, Mt, Rt), Mf(W, S.x, S.y, _t.x, Gt + _t.y, It.x, It.y + It.h, u, sr, Et.x, Yt.y, Mt, Rt), Mf(W, S.x, S.y, At.x, Gt + At.y, It.x + It.w, It.y + It.h, u, sr, Yt.x, Yt.y, Mt, Rt), Mm(t.dynamicLayoutVertexArray, S, je), U.emplaceBack(Qt, Qt + 2, Qt + 1), U.emplaceBack(Qt + 1, Qt + 2, Qt + 3), ee.vertexLength += 4, ee.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(lt[0]), Me !== n.length - 1 && cr === n[Me + 1].sectionIndex || t.programConfigurations.populatePaintArrays(W.length, b, b.index, { imagePositions: {}, canonical: V, formattedSection: be && be[cr] });
            }
            t.placedSymbolArray.emplaceBack(S.x, S.y, se, this.glyphOffsetArray.length - se, pe, I, E, S.segment, u ? u[0] : 0, u ? u[1] : 0, h[0], h[1], w, 0, false, 0, O);
          }
          _addCollisionDebugVertex(t, n, u, h, y, b) {
            return n.emplaceBack(0, 0), t.emplaceBack(u.x, u.y, h, y, Math.round(b.x), Math.round(b.y));
          }
          addCollisionDebugVertices(t, n, u, h, y, b, w) {
            const S = y.segments.prepareSegment(4, y.layoutVertexArray, y.indexArray), I = S.vertexLength, E = y.layoutVertexArray, O = y.collisionVertexArray, V = w.anchorX, U = w.anchorY;
            this._addCollisionDebugVertex(E, O, b, V, U, new C(t, n)), this._addCollisionDebugVertex(E, O, b, V, U, new C(u, n)), this._addCollisionDebugVertex(E, O, b, V, U, new C(u, h)), this._addCollisionDebugVertex(E, O, b, V, U, new C(t, h)), S.vertexLength += 4;
            const W = y.indexArray;
            W.emplaceBack(I, I + 1), W.emplaceBack(I + 1, I + 2), W.emplaceBack(I + 2, I + 3), W.emplaceBack(I + 3, I), S.primitiveLength += 4;
          }
          addDebugCollisionBoxes(t, n, u, h) {
            for (let y = t; y < n; y++) {
              const b = this.collisionBoxArray.get(y);
              this.addCollisionDebugVertices(b.x1, b.y1, b.x2, b.y2, h ? this.textCollisionBox : this.iconCollisionBox, b.anchorPoint, u);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Rm(Pt, uv.members, Nt), this.iconCollisionBox = new Rm(Pt, uv.members, Nt);
            for (let t = 0; t < this.symbolInstances.length; t++) {
              const n = this.symbolInstances.get(t);
              this.addDebugCollisionBoxes(n.textBoxStartIndex, n.textBoxEndIndex, n, true), this.addDebugCollisionBoxes(n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n, true), this.addDebugCollisionBoxes(n.iconBoxStartIndex, n.iconBoxEndIndex, n, false), this.addDebugCollisionBoxes(n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex, n, false);
            }
          }
          _deserializeCollisionBoxesForSymbol(t, n, u, h, y, b, w, S, I) {
            const E = {};
            for (let O = n; O < u; O++) {
              const V = t.get(O);
              E.textBox = { x1: V.x1, y1: V.y1, x2: V.x2, y2: V.y2, anchorPointX: V.anchorPointX, anchorPointY: V.anchorPointY }, E.textFeatureIndex = V.featureIndex;
              break;
            }
            for (let O = h; O < y; O++) {
              const V = t.get(O);
              E.verticalTextBox = { x1: V.x1, y1: V.y1, x2: V.x2, y2: V.y2, anchorPointX: V.anchorPointX, anchorPointY: V.anchorPointY }, E.verticalTextFeatureIndex = V.featureIndex;
              break;
            }
            for (let O = b; O < w; O++) {
              const V = t.get(O);
              E.iconBox = { x1: V.x1, y1: V.y1, x2: V.x2, y2: V.y2, anchorPointX: V.anchorPointX, anchorPointY: V.anchorPointY }, E.iconFeatureIndex = V.featureIndex;
              break;
            }
            for (let O = S; O < I; O++) {
              const V = t.get(O);
              E.verticalIconBox = { x1: V.x1, y1: V.y1, x2: V.x2, y2: V.y2, anchorPointX: V.anchorPointX, anchorPointY: V.anchorPointY }, E.verticalIconFeatureIndex = V.featureIndex;
              break;
            }
            return E;
          }
          deserializeCollisionBoxes(t) {
            this.collisionArrays = [];
            for (let n = 0; n < this.symbolInstances.length; n++) {
              const u = this.symbolInstances.get(n);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, u.textBoxStartIndex, u.textBoxEndIndex, u.verticalTextBoxStartIndex, u.verticalTextBoxEndIndex, u.iconBoxStartIndex, u.iconBoxEndIndex, u.verticalIconBoxStartIndex, u.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t, n) {
            const u = t.placedSymbolArray.get(n), h = u.vertexStartIndex + 4 * u.numGlyphs;
            for (let y = u.vertexStartIndex; y < h; y += 4) t.indexArray.emplaceBack(y, y + 2, y + 1), t.indexArray.emplaceBack(y + 1, y + 2, y + 3);
          }
          getSortedSymbolIndexes(t) {
            if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const n = Math.sin(t), u = Math.cos(t), h = [], y = [], b = [];
            for (let w = 0; w < this.symbolInstances.length; ++w) {
              b.push(w);
              const S = this.symbolInstances.get(w);
              h.push(0 | Math.round(n * S.anchorX + u * S.anchorY)), y.push(S.featureIndex);
            }
            return b.sort(((w, S) => h[w] - h[S] || y[S] - y[w])), b;
          }
          addToSortKeyRanges(t, n) {
            const u = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            u && u.sortKey === n ? u.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({ sortKey: n, symbolInstanceStart: t, symbolInstanceEnd: t + 1 });
          }
          sortFeatures(t) {
            if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const n of this.symbolInstanceIndexes) {
                const u = this.symbolInstances.get(n);
                this.featureSortOrder.push(u.featureIndex), [u.rightJustifiedTextSymbolIndex, u.centerJustifiedTextSymbolIndex, u.leftJustifiedTextSymbolIndex].forEach(((h, y, b) => {
                  h >= 0 && b.indexOf(h) === y && this.addIndicesForPlacedSymbol(this.text, h);
                })), u.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, u.verticalPlacedTextSymbolIndex), u.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, u.placedIconSymbolIndex), u.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, u.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let Cv, Sv;
        Dt("SymbolBucket", Vu, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Vu.MAX_GLYPHS = 65535, Vu.addDynamicAttributes = Mm;
        var Am = { get paint() {
          return Sv = Sv || new dn({ "icon-opacity": new er(Le.paint_symbol["icon-opacity"]), "icon-color": new er(Le.paint_symbol["icon-color"]), "icon-halo-color": new er(Le.paint_symbol["icon-halo-color"]), "icon-halo-width": new er(Le.paint_symbol["icon-halo-width"]), "icon-halo-blur": new er(Le.paint_symbol["icon-halo-blur"]), "icon-translate": new qt(Le.paint_symbol["icon-translate"]), "icon-translate-anchor": new qt(Le.paint_symbol["icon-translate-anchor"]), "text-opacity": new er(Le.paint_symbol["text-opacity"]), "text-color": new er(Le.paint_symbol["text-color"], { runtimeType: Bi, getOverride: (o) => o.textColor, hasOverride: (o) => !!o.textColor }), "text-halo-color": new er(Le.paint_symbol["text-halo-color"]), "text-halo-width": new er(Le.paint_symbol["text-halo-width"]), "text-halo-blur": new er(Le.paint_symbol["text-halo-blur"]), "text-translate": new qt(Le.paint_symbol["text-translate"]), "text-translate-anchor": new qt(Le.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return Cv = Cv || new dn({ "symbol-placement": new qt(Le.layout_symbol["symbol-placement"]), "symbol-spacing": new qt(Le.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new qt(Le.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new er(Le.layout_symbol["symbol-sort-key"]), "symbol-z-order": new qt(Le.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new qt(Le.layout_symbol["icon-allow-overlap"]), "icon-overlap": new qt(Le.layout_symbol["icon-overlap"]), "icon-ignore-placement": new qt(Le.layout_symbol["icon-ignore-placement"]), "icon-optional": new qt(Le.layout_symbol["icon-optional"]), "icon-rotation-alignment": new qt(Le.layout_symbol["icon-rotation-alignment"]), "icon-size": new er(Le.layout_symbol["icon-size"]), "icon-text-fit": new qt(Le.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new qt(Le.layout_symbol["icon-text-fit-padding"]), "icon-image": new er(Le.layout_symbol["icon-image"]), "icon-rotate": new er(Le.layout_symbol["icon-rotate"]), "icon-padding": new er(Le.layout_symbol["icon-padding"]), "icon-keep-upright": new qt(Le.layout_symbol["icon-keep-upright"]), "icon-offset": new er(Le.layout_symbol["icon-offset"]), "icon-anchor": new er(Le.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new qt(Le.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new qt(Le.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new qt(Le.layout_symbol["text-rotation-alignment"]), "text-field": new er(Le.layout_symbol["text-field"]), "text-font": new er(Le.layout_symbol["text-font"]), "text-size": new er(Le.layout_symbol["text-size"]), "text-max-width": new er(Le.layout_symbol["text-max-width"]), "text-line-height": new qt(Le.layout_symbol["text-line-height"]), "text-letter-spacing": new er(Le.layout_symbol["text-letter-spacing"]), "text-justify": new er(Le.layout_symbol["text-justify"]), "text-radial-offset": new er(Le.layout_symbol["text-radial-offset"]), "text-variable-anchor": new qt(Le.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new er(Le.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new er(Le.layout_symbol["text-anchor"]), "text-max-angle": new qt(Le.layout_symbol["text-max-angle"]), "text-writing-mode": new qt(Le.layout_symbol["text-writing-mode"]), "text-rotate": new er(Le.layout_symbol["text-rotate"]), "text-padding": new qt(Le.layout_symbol["text-padding"]), "text-keep-upright": new qt(Le.layout_symbol["text-keep-upright"]), "text-transform": new er(Le.layout_symbol["text-transform"]), "text-offset": new er(Le.layout_symbol["text-offset"]), "text-allow-overlap": new qt(Le.layout_symbol["text-allow-overlap"]), "text-overlap": new qt(Le.layout_symbol["text-overlap"]), "text-ignore-placement": new qt(Le.layout_symbol["text-ignore-placement"]), "text-optional": new qt(Le.layout_symbol["text-optional"]) });
        } };
        class kv {
          constructor(t) {
            if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t.property.overrides ? t.property.overrides.runtimeType : mr, this.defaultValue = t;
          }
          evaluate(t) {
            if (t.formattedSection) {
              const n = this.defaultValue.property.overrides;
              if (n && n.hasOverride(t.formattedSection)) return n.getOverride(t.formattedSection);
            }
            return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t) {
            this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        Dt("FormatSectionOverride", kv, { omit: ["defaultValue"] });
        class Ef extends uo {
          constructor(t, n) {
            super(t, Am, n);
          }
          recalculate(t, n) {
            if (super.recalculate(t, n), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const u = this.layout.get("text-writing-mode");
              if (u) {
                const h = [];
                for (const y of u) h.indexOf(y) < 0 && h.push(y);
                this.layout._values["text-writing-mode"] = h;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t, n, u, h) {
            const y = this.layout.get(t).evaluate(n, {}, u, h), b = this._unevaluatedLayout._values[t];
            return b.isDataDriven() || pu(b.value) || !y ? y : (function(w, S) {
              return S.replace(/{([^{}]+)}/g, ((I, E) => w && E in w ? String(w[E]) : ""));
            })(n.properties, y);
          }
          createBucket(t) {
            return new Vu(t);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const t of Am.paint.overridableProperties) {
              if (!Ef.hasPaintOverride(this.layout, t)) continue;
              const n = this.paint.get(t), u = new kv(n), h = new Uc(u, n.property.specification);
              let y = null;
              y = n.value.kind === "constant" || n.value.kind === "source" ? new ul("source", h) : new Gc("composite", h, n.value.zoomStops), this.paint._values[t] = new lo(n.property, y, n.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t, n, u) {
            return !(!this.layout || n.isDataDriven() || u.isDataDriven()) && Ef.hasPaintOverride(this.layout, t);
          }
          static hasPaintOverride(t, n) {
            const u = t.get("text-field"), h = Am.paint.properties[n];
            let y = false;
            const b = (w) => {
              for (const S of w) if (h.overrides && h.overrides.hasOverride(S)) return void (y = true);
            };
            if (u.value.kind === "constant" && u.value.value instanceof Rn) b(u.value.value.sections);
            else if (u.value.kind === "source" || u.value.kind === "composite") {
              const w = (I) => {
                y || (I instanceof la && wi(I.value) === no ? b(I.value.sections) : I instanceof iu ? b(I.sections) : I.eachChild(w));
              }, S = u.value;
              S._styleExpression && w(S._styleExpression.expression);
            }
            return y;
          }
        }
        let Pv;
        var N2 = { get paint() {
          return Pv = Pv || new dn({ "background-color": new qt(Le.paint_background["background-color"]), "background-pattern": new ff(Le.paint_background["background-pattern"]), "background-opacity": new qt(Le.paint_background["background-opacity"]) });
        } };
        class V2 extends uo {
          constructor(t, n) {
            super(t, N2, n);
          }
        }
        class U2 extends uo {
          constructor(t, n) {
            super(t, {}, n), this.onAdd = (u) => {
              this.implementation.onAdd && this.implementation.onAdd(u, u.painter.context.gl);
            }, this.onRemove = (u) => {
              this.implementation.onRemove && this.implementation.onRemove(u, u.painter.context.gl);
            }, this.implementation = t;
          }
          is3D() {
            return this.implementation.renderingMode === "3d";
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return false;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class G2 {
          constructor(t) {
            this._methodToThrottle = t, this._triggered = false, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout((() => {
              this._triggered = false, this._methodToThrottle();
            }), 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const q2 = { once: true }, Dm = 63710088e-1;
        class Es {
          constructor(t, n) {
            if (isNaN(t) || isNaN(n)) throw new Error(`Invalid LngLat object: (${t}, ${n})`);
            if (this.lng = +t, this.lat = +n, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new Es(Bt(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t) {
            const n = Math.PI / 180, u = this.lat * n, h = t.lat * n, y = Math.sin(u) * Math.sin(h) + Math.cos(u) * Math.cos(h) * Math.cos((t.lng - this.lng) * n);
            return Dm * Math.acos(Math.min(y, 1));
          }
          static convert(t) {
            if (t instanceof Es) return t;
            if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new Es(Number(t[0]), Number(t[1]));
            if (!Array.isArray(t) && typeof t == "object" && t !== null) return new Es(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const Tv = 2 * Math.PI * Dm;
        function Iv(o) {
          return Tv * Math.cos(o * Math.PI / 180);
        }
        function Mv(o) {
          return (180 + o) / 360;
        }
        function Ev(o) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + o * Math.PI / 360))) / 360;
        }
        function Rv(o, t) {
          return o / Iv(t);
        }
        function Av(o) {
          return 360 * o - 180;
        }
        function Rf(o) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * o) * Math.PI / 180)) - 90;
        }
        function Dv(o, t) {
          return o * Iv(Rf(t));
        }
        class Id {
          constructor(t, n, u = 0) {
            this.x = +t, this.y = +n, this.z = +u;
          }
          static fromLngLat(t, n = 0) {
            const u = Es.convert(t);
            return new Id(Mv(u.lng), Ev(u.lat), Rv(n, u.lat));
          }
          toLngLat() {
            return new Es(Av(this.x), Rf(this.y));
          }
          toAltitude() {
            return Dv(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / Tv * (t = Rf(this.y), 1 / Math.cos(t * Math.PI / 180));
            var t;
          }
        }
        function zv(o, t, n) {
          var u = 2 * Math.PI * 6378137 / 256 / Math.pow(2, n);
          return [o * u - 2 * Math.PI * 6378137 / 2, t * u - 2 * Math.PI * 6378137 / 2];
        }
        class zm {
          constructor(t, n, u) {
            if (!(function(h, y, b) {
              return !(h < 0 || h > 25 || b < 0 || b >= Math.pow(2, h) || y < 0 || y >= Math.pow(2, h));
            })(t, n, u)) throw new Error(`x=${n}, y=${u}, z=${t} outside of bounds. 0<=x<${Math.pow(2, t)}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `);
            this.z = t, this.x = n, this.y = u, this.key = Uu(0, t, t, n, u);
          }
          equals(t) {
            return this.z === t.z && this.x === t.x && this.y === t.y;
          }
          url(t, n, u) {
            const h = (b = this.y, w = this.z, S = zv(256 * (y = this.x), 256 * (b = Math.pow(2, w) - b - 1), w), I = zv(256 * (y + 1), 256 * (b + 1), w), S[0] + "," + S[1] + "," + I[0] + "," + I[1]);
            var y, b, w, S, I;
            const E = (function(O, V, U) {
              let W, ee = "";
              for (let se = O; se > 0; se--) W = 1 << se - 1, ee += (V & W ? 1 : 0) + (U & W ? 2 : 0);
              return ee;
            })(this.z, this.x, this.y);
            return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(u === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, n > 1 ? "@2x" : "").replace(/{quadkey}/g, E).replace(/{bbox-epsg-3857}/g, h);
          }
          isChildOf(t) {
            const n = this.z - t.z;
            return n > 0 && t.x === this.x >> n && t.y === this.y >> n;
          }
          getTilePoint(t) {
            const n = Math.pow(2, this.z);
            return new C((t.x * n - this.x) * nt, (t.y * n - this.y) * nt);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class Fv {
          constructor(t, n) {
            this.wrap = t, this.canonical = n, this.key = Uu(t, n.z, n.z, n.x, n.y);
          }
        }
        class ho {
          constructor(t, n, u, h, y) {
            if (this.terrainRttPosMatrix32f = null, t < u) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${u}`);
            this.overscaledZ = t, this.wrap = n, this.canonical = new zm(u, +h, +y), this.key = Uu(n, t, u, h, y);
          }
          clone() {
            return new ho(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(t) {
            return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);
          }
          scaledTo(t) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const n = this.canonical.z - t;
            return t > this.canonical.z ? new ho(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new ho(t, this.wrap, t, this.canonical.x >> n, this.canonical.y >> n);
          }
          isOverscaled() {
            return this.overscaledZ > this.canonical.z;
          }
          calculateScaledKey(t, n) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const u = this.canonical.z - t;
            return t > this.canonical.z ? Uu(this.wrap * +n, t, this.canonical.z, this.canonical.x, this.canonical.y) : Uu(this.wrap * +n, t, t, this.canonical.x >> u, this.canonical.y >> u);
          }
          isChildOf(t) {
            if (t.wrap !== this.wrap || this.overscaledZ - t.overscaledZ <= 0) return false;
            if (t.overscaledZ === 0) return this.overscaledZ > 0;
            const n = this.canonical.z - t.canonical.z;
            return !(n < 0) && t.canonical.x === this.canonical.x >> n && t.canonical.y === this.canonical.y >> n;
          }
          children(t) {
            if (this.overscaledZ >= t) return [new ho(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const n = this.canonical.z + 1, u = 2 * this.canonical.x, h = 2 * this.canonical.y;
            return [new ho(n, this.wrap, n, u, h), new ho(n, this.wrap, n, u + 1, h), new ho(n, this.wrap, n, u, h + 1), new ho(n, this.wrap, n, u + 1, h + 1)];
          }
          isLessThan(t) {
            return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));
          }
          wrapped() {
            return new ho(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t) {
            return new ho(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new Fv(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(t) {
            return this.canonical.getTilePoint(new Id(t.x - this.wrap, t.y));
          }
        }
        function Uu(o, t, n, u, h) {
          (o *= 2) < 0 && (o = -1 * o - 1);
          const y = 1 << n;
          return (y * y * o + y * h + u).toString(36) + n.toString(36) + t.toString(36);
        }
        function Md(o, t) {
          return t ? o.properties[t] : o.id;
        }
        Dt("CanonicalTileID", zm), Dt("OverscaledTileID", ho, { omit: ["terrainRttPosMatrix32f"] });
        class Cl {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0;
          }
          extend(t) {
            return this.minX = Math.min(this.minX, t.x), this.minY = Math.min(this.minY, t.y), this.maxX = Math.max(this.maxX, t.x), this.maxY = Math.max(this.maxY, t.y), this;
          }
          expandBy(t) {
            return this.minX -= t, this.minY -= t, this.maxX += t, this.maxY += t, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this;
          }
          shrinkBy(t) {
            return this.expandBy(-t);
          }
          map(t) {
            const n = new Cl();
            return n.extend(t(new C(this.minX, this.minY))), n.extend(t(new C(this.maxX, this.minY))), n.extend(t(new C(this.minX, this.maxY))), n.extend(t(new C(this.maxX, this.maxY))), n;
          }
          static fromPoints(t) {
            const n = new Cl();
            for (const u of t) n.extend(u);
            return n;
          }
          contains(t) {
            return t.x >= this.minX && t.x <= this.maxX && t.y >= this.minY && t.y <= this.maxY;
          }
          empty() {
            return this.minX > this.maxX;
          }
          width() {
            return this.maxX - this.minX;
          }
          height() {
            return this.maxY - this.minY;
          }
          covers(t) {
            return !this.empty() && !t.empty() && t.minX >= this.minX && t.maxX <= this.maxX && t.minY >= this.minY && t.maxY <= this.maxY;
          }
          intersects(t) {
            return !this.empty() && !t.empty() && t.minX <= this.maxX && t.maxX >= this.minX && t.minY <= this.maxY && t.maxY >= this.minY;
          }
        }
        class Lv {
          constructor(t) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let n = 0; n < t.length; n++) {
              const u = t[n];
              this._stringToNumber[u] = n, this._numberToString[n] = u;
            }
          }
          encode(t) {
            return this._stringToNumber[t];
          }
          decode(t) {
            if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t];
          }
        }
        class Bv {
          constructor(t, n, u, h, y) {
            this.type = "Feature", this._vectorTileFeature = t, t._z = n, t._x = u, t._y = h, this.properties = t.properties, this.id = y;
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(t) {
            this._geometry = t;
          }
          toJSON() {
            const t = { geometry: this.geometry };
            for (const n in this) n !== "_geometry" && n !== "_vectorTileFeature" && (t[n] = this[n]);
            return t;
          }
        }
        class Ov {
          constructor(t, n) {
            this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new ja(nt, 16, 0), this.grid3D = new ja(nt, 16, 0), this.featureIndexArray = new de(), this.promoteId = n;
          }
          insert(t, n, u, h, y, b) {
            const w = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(u, h, y);
            const S = b ? this.grid3D : this.grid;
            for (let I = 0; I < n.length; I++) {
              const E = n[I], O = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let V = 0; V < E.length; V++) {
                const U = E[V];
                O[0] = Math.min(O[0], U.x), O[1] = Math.min(O[1], U.y), O[2] = Math.max(O[2], U.x), O[3] = Math.max(O[3], U.y);
              }
              O[0] < nt && O[1] < nt && O[2] >= 0 && O[3] >= 0 && S.insert(w, O[0], O[1], O[2], O[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new ev(new Sm(this.rawTileData)).layers, this.sourceLayerCoder = new Lv(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(t, n, u, h) {
            this.loadVTLayers();
            const y = t.params, b = nt / t.tileSize / t.scale, w = cl(y.filter, y.globalState), S = t.queryGeometry, I = t.queryPadding * b, E = Cl.fromPoints(S), O = this.grid.query(E.minX - I, E.minY - I, E.maxX + I, E.maxY + I), V = Cl.fromPoints(t.cameraQueryGeometry).expandBy(I), U = this.grid3D.query(V.minX, V.minY, V.maxX, V.maxY, ((se, pe, je, be) => (function(Me, Xe, it, _t, At) {
              for (const Et of Me) if (Xe <= Et.x && it <= Et.y && _t >= Et.x && At >= Et.y) return true;
              const It = [new C(Xe, it), new C(Xe, At), new C(_t, At), new C(_t, it)];
              if (Me.length > 2) {
                for (const Et of It) if (zu(Me, Et)) return true;
              }
              for (let Et = 0; Et < Me.length - 1; Et++) if (xx(Me[Et], Me[Et + 1], It)) return true;
              return false;
            })(t.cameraQueryGeometry, se - I, pe - I, je + I, be + I)));
            for (const se of U) O.push(se);
            O.sort(W2);
            const W = {};
            let ee;
            for (let se = 0; se < O.length; se++) {
              const pe = O[se];
              if (pe === ee) continue;
              ee = pe;
              const je = this.featureIndexArray.get(pe);
              let be = null;
              this.loadMatchingFeature(W, je.bucketIndex, je.sourceLayerIndex, je.featureIndex, w, y.layers, y.availableImages, n, u, h, ((Me, Xe, it) => (be || (be = qo(Me)), Xe.queryIntersectsFeature({ queryGeometry: S, feature: Me, featureState: it, geometry: be, zoom: this.z, transform: t.transform, pixelsToTileUnits: b, pixelPosMatrix: t.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: t.getElevation }))));
            }
            return W;
          }
          loadMatchingFeature(t, n, u, h, y, b, w, S, I, E, O) {
            const V = this.bucketLayerIDs[n];
            if (b && !V.some(((se) => b.has(se)))) return;
            const U = this.sourceLayerCoder.decode(u), W = this.vtLayers[U].feature(h);
            if (y.needGeometry) {
              const se = ma(W, true);
              if (!y.filter(new Yr(this.tileID.overscaledZ), se, this.tileID.canonical)) return;
            } else if (!y.filter(new Yr(this.tileID.overscaledZ), W)) return;
            const ee = this.getId(W, U);
            for (let se = 0; se < V.length; se++) {
              const pe = V[se];
              if (b && !b.has(pe)) continue;
              const je = S[pe];
              if (!je) continue;
              let be = {};
              ee && E && (be = E.getState(je.sourceLayer || "_geojsonTileLayer", ee));
              const Me = Zt({}, I[pe]);
              Me.paint = $v(Me.paint, je.paint, W, be, w), Me.layout = $v(Me.layout, je.layout, W, be, w);
              const Xe = !O || O(W, je, be);
              if (!Xe) continue;
              const it = new Bv(W, this.z, this.x, this.y, ee);
              it.layer = Me;
              let _t = t[pe];
              _t === void 0 && (_t = t[pe] = []), _t.push({ featureIndex: h, feature: it, intersectionZ: Xe });
            }
          }
          lookupSymbolFeatures(t, n, u, h, y, b, w, S) {
            const I = {};
            this.loadVTLayers();
            const E = cl(y.filterSpec, y.globalState);
            for (const O of t) this.loadMatchingFeature(I, u, h, O, E, b, w, S, n);
            return I;
          }
          hasLayer(t) {
            for (const n of this.bucketLayerIDs) for (const u of n) if (t === u) return true;
            return false;
          }
          getId(t, n) {
            var u;
            let h = t.id;
            return this.promoteId && (h = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[n]], typeof h == "boolean" && (h = Number(h)), h === void 0 && (!((u = t.properties) === null || u === void 0) && u.cluster) && this.promoteId && (h = Number(t.properties.cluster_id))), h;
          }
        }
        function $v(o, t, n, u, h) {
          return Cr(o, ((y, b) => {
            const w = t instanceof Na ? t.get(b) : null;
            return w && w.evaluate ? w.evaluate(n, u, h) : w;
          }));
        }
        function W2(o, t) {
          return t - o;
        }
        function jv(o, t, n, u, h) {
          const y = [];
          for (let b = 0; b < o.length; b++) {
            const w = o[b];
            let S;
            for (let I = 0; I < w.length - 1; I++) {
              let E = w[I], O = w[I + 1];
              E.x < t && O.x < t || (E.x < t ? E = new C(t, E.y + (t - E.x) / (O.x - E.x) * (O.y - E.y))._round() : O.x < t && (O = new C(t, E.y + (t - E.x) / (O.x - E.x) * (O.y - E.y))._round()), E.y < n && O.y < n || (E.y < n ? E = new C(E.x + (n - E.y) / (O.y - E.y) * (O.x - E.x), n)._round() : O.y < n && (O = new C(E.x + (n - E.y) / (O.y - E.y) * (O.x - E.x), n)._round()), E.x >= u && O.x >= u || (E.x >= u ? E = new C(u, E.y + (u - E.x) / (O.x - E.x) * (O.y - E.y))._round() : O.x >= u && (O = new C(u, E.y + (u - E.x) / (O.x - E.x) * (O.y - E.y))._round()), E.y >= h && O.y >= h || (E.y >= h ? E = new C(E.x + (h - E.y) / (O.y - E.y) * (O.x - E.x), h)._round() : O.y >= h && (O = new C(E.x + (h - E.y) / (O.y - E.y) * (O.x - E.x), h)._round()), S && E.equals(S[S.length - 1]) || (S = [E], y.push(S)), S.push(O)))));
            }
          }
          return y;
        }
        Dt("FeatureIndex", Ov, { omit: ["rawTileData", "sourceLayerCoder"] });
        class Rs extends C {
          constructor(t, n, u, h) {
            super(t, n), this.angle = u, h !== void 0 && (this.segment = h);
          }
          clone() {
            return new Rs(this.x, this.y, this.angle, this.segment);
          }
        }
        function Nv(o, t, n, u, h) {
          if (t.segment === void 0 || n === 0) return true;
          let y = t, b = t.segment + 1, w = 0;
          for (; w > -n / 2; ) {
            if (b--, b < 0) return false;
            w -= o[b].dist(y), y = o[b];
          }
          w += o[b].dist(o[b + 1]), b++;
          const S = [];
          let I = 0;
          for (; w < n / 2; ) {
            const E = o[b], O = o[b + 1];
            if (!O) return false;
            let V = o[b - 1].angleTo(E) - E.angleTo(O);
            for (V = Math.abs((V + 3 * Math.PI) % (2 * Math.PI) - Math.PI), S.push({ distance: w, angleDelta: V }), I += V; w - S[0].distance > u; ) I -= S.shift().angleDelta;
            if (I > h) return false;
            b++, w += E.dist(O);
          }
          return true;
        }
        function Vv(o) {
          let t = 0;
          for (let n = 0; n < o.length - 1; n++) t += o[n].dist(o[n + 1]);
          return t;
        }
        function Uv(o, t, n) {
          return o ? 0.6 * t * n : 0;
        }
        function Gv(o, t) {
          return Math.max(o ? o.right - o.left : 0, t ? t.right - t.left : 0);
        }
        function Z2(o, t, n, u, h, y) {
          const b = Uv(n, h, y), w = Gv(n, u) * y;
          let S = 0;
          const I = Vv(o) / 2;
          for (let E = 0; E < o.length - 1; E++) {
            const O = o[E], V = o[E + 1], U = O.dist(V);
            if (S + U > I) {
              const W = (I - S) / U, ee = Kn.number(O.x, V.x, W), se = Kn.number(O.y, V.y, W), pe = new Rs(ee, se, V.angleTo(O), E);
              return pe._round(), !b || Nv(o, pe, w, b, t) ? pe : void 0;
            }
            S += U;
          }
        }
        function H2(o, t, n, u, h, y, b, w, S) {
          const I = Uv(u, y, b), E = Gv(u, h), O = E * b, V = o[0].x === 0 || o[0].x === S || o[0].y === 0 || o[0].y === S;
          return t - O < t / 4 && (t = O + t / 4), qv(o, V ? t / 2 * w % t : (E / 2 + 2 * y) * b * w % t, t, I, n, O, V, false, S);
        }
        function qv(o, t, n, u, h, y, b, w, S) {
          const I = y / 2, E = Vv(o);
          let O = 0, V = t - n, U = [];
          for (let W = 0; W < o.length - 1; W++) {
            const ee = o[W], se = o[W + 1], pe = ee.dist(se), je = se.angleTo(ee);
            for (; V + n < O + pe; ) {
              V += n;
              const be = (V - O) / pe, Me = Kn.number(ee.x, se.x, be), Xe = Kn.number(ee.y, se.y, be);
              if (Me >= 0 && Me < S && Xe >= 0 && Xe < S && V - I >= 0 && V + I <= E) {
                const it = new Rs(Me, Xe, je, W);
                it._round(), u && !Nv(o, it, y, u, h) || U.push(it);
              }
            }
            O += pe;
          }
          return w || U.length || b || (U = qv(o, O / 2, n, u, h, y, b, true, S)), U;
        }
        function Wv(o, t, n, u) {
          const h = [], y = o.image, b = y.pixelRatio, w = y.paddedRect.w - 2, S = y.paddedRect.h - 2;
          let I = { x1: o.left, y1: o.top, x2: o.right, y2: o.bottom };
          const E = y.stretchX || [[0, w]], O = y.stretchY || [[0, S]], V = (lt, sr) => lt + sr[1] - sr[0], U = E.reduce(V, 0), W = O.reduce(V, 0), ee = w - U, se = S - W;
          let pe = 0, je = U, be = 0, Me = W, Xe = 0, it = ee, _t = 0, At = se;
          if (y.content && u) {
            const lt = y.content, sr = lt[2] - lt[0], cr = lt[3] - lt[1];
            (y.textFitWidth || y.textFitHeight) && (I = bv(o)), pe = Af(E, 0, lt[0]), be = Af(O, 0, lt[1]), je = Af(E, lt[0], lt[2]), Me = Af(O, lt[1], lt[3]), Xe = lt[0] - pe, _t = lt[1] - be, it = sr - je, At = cr - Me;
          }
          const It = I.x1, Et = I.y1, Yt = I.x2 - It, Mt = I.y2 - Et, Rt = (lt, sr, cr, Qt) => {
            const Gt = Df(lt.stretch - pe, je, Yt, It), Mr = zf(lt.fixed - Xe, it, lt.stretch, U), yi = Df(sr.stretch - be, Me, Mt, Et), Oi = zf(sr.fixed - _t, At, sr.stretch, W), fn = Df(cr.stretch - pe, je, Yt, It), fo = zf(cr.fixed - Xe, it, cr.stretch, U), Un = Df(Qt.stretch - be, Me, Mt, Et), en = zf(Qt.fixed - _t, At, Qt.stretch, W), mi = new C(Gt, yi), Zi = new C(fn, yi), tn = new C(fn, Un), rn = new C(Gt, Un), Fn = new C(Mr / b, Oi / b), po = new C(fo / b, en / b), Hi = t * Math.PI / 180;
            if (Hi) {
              const Xi = Math.sin(Hi), Yi = Math.cos(Hi), zi = [Yi, -Xi, Xi, Yi];
              mi._matMult(zi), Zi._matMult(zi), rn._matMult(zi), tn._matMult(zi);
            }
            const Gn = lt.stretch + lt.fixed, $i = sr.stretch + sr.fixed;
            return { tl: mi, tr: Zi, bl: rn, br: tn, tex: { x: y.paddedRect.x + 1 + Gn, y: y.paddedRect.y + 1 + $i, w: cr.stretch + cr.fixed - Gn, h: Qt.stretch + Qt.fixed - $i }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: Fn, pixelOffsetBR: po, minFontScaleX: it / b / Yt, minFontScaleY: At / b / Mt, isSDF: n };
          };
          if (u && (y.stretchX || y.stretchY)) {
            const lt = Zv(E, ee, U), sr = Zv(O, se, W);
            for (let cr = 0; cr < lt.length - 1; cr++) {
              const Qt = lt[cr], Gt = lt[cr + 1];
              for (let Mr = 0; Mr < sr.length - 1; Mr++) h.push(Rt(Qt, sr[Mr], Gt, sr[Mr + 1]));
            }
          } else h.push(Rt({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: w + 1 }, { fixed: 0, stretch: S + 1 }));
          return h;
        }
        function Af(o, t, n) {
          let u = 0;
          for (const h of o) u += Math.max(t, Math.min(n, h[1])) - Math.max(t, Math.min(n, h[0]));
          return u;
        }
        function Zv(o, t, n) {
          const u = [{ fixed: -1, stretch: 0 }];
          for (const [h, y] of o) {
            const b = u[u.length - 1];
            u.push({ fixed: h - b.stretch, stretch: b.stretch }), u.push({ fixed: h - b.stretch, stretch: b.stretch + (y - h) });
          }
          return u.push({ fixed: t + 1, stretch: n }), u;
        }
        function Df(o, t, n, u) {
          return o / t * n + u;
        }
        function zf(o, t, n, u) {
          return o - t * n / u;
        }
        Dt("Anchor", Rs);
        class Ff {
          constructor(t, n, u, h, y, b, w, S, I, E) {
            var O;
            if (this.boxStartIndex = t.length, I) {
              let V = b.top, U = b.bottom;
              const W = b.collisionPadding;
              W && (V -= W[1], U += W[3]);
              let ee = U - V;
              ee > 0 && (ee = Math.max(10, ee), this.circleDiameter = ee);
            } else {
              const V = !((O = b.image) === null || O === void 0) && O.content && (b.image.textFitWidth || b.image.textFitHeight) ? bv(b) : { x1: b.left, y1: b.top, x2: b.right, y2: b.bottom };
              V.y1 = V.y1 * w - S[0], V.y2 = V.y2 * w + S[2], V.x1 = V.x1 * w - S[3], V.x2 = V.x2 * w + S[1];
              const U = b.collisionPadding;
              if (U && (V.x1 -= U[0] * w, V.y1 -= U[1] * w, V.x2 += U[2] * w, V.y2 += U[3] * w), E) {
                const W = new C(V.x1, V.y1), ee = new C(V.x2, V.y1), se = new C(V.x1, V.y2), pe = new C(V.x2, V.y2), je = E * Math.PI / 180;
                W._rotate(je), ee._rotate(je), se._rotate(je), pe._rotate(je), V.x1 = Math.min(W.x, ee.x, se.x, pe.x), V.x2 = Math.max(W.x, ee.x, se.x, pe.x), V.y1 = Math.min(W.y, ee.y, se.y, pe.y), V.y2 = Math.max(W.y, ee.y, se.y, pe.y);
              }
              t.emplaceBack(n.x, n.y, V.x1, V.y1, V.x2, V.y2, u, h, y);
            }
            this.boxEndIndex = t.length;
          }
        }
        class X2 {
          constructor(t = [], n = (u, h) => u < h ? -1 : u > h ? 1 : 0) {
            if (this.data = t, this.length = this.data.length, this.compare = n, this.length > 0) for (let u = (this.length >> 1) - 1; u >= 0; u--) this._down(u);
          }
          push(t) {
            this.data.push(t), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const t = this.data[0], n = this.data.pop();
            return --this.length > 0 && (this.data[0] = n, this._down(0)), t;
          }
          peek() {
            return this.data[0];
          }
          _up(t) {
            const { data: n, compare: u } = this, h = n[t];
            for (; t > 0; ) {
              const y = t - 1 >> 1, b = n[y];
              if (u(h, b) >= 0) break;
              n[t] = b, t = y;
            }
            n[t] = h;
          }
          _down(t) {
            const { data: n, compare: u } = this, h = this.length >> 1, y = n[t];
            for (; t < h; ) {
              let b = 1 + (t << 1);
              const w = b + 1;
              if (w < this.length && u(n[w], n[b]) < 0 && (b = w), u(n[b], y) >= 0) break;
              n[t] = n[b], t = b;
            }
            n[t] = y;
          }
        }
        function Y2(o, t = 1, n = false) {
          const u = Cl.fromPoints(o[0]), h = Math.min(u.width(), u.height());
          let y = h / 2;
          const b = new X2([], K2), { minX: w, minY: S, maxX: I, maxY: E } = u;
          if (h === 0) return new C(w, S);
          for (let U = w; U < I; U += h) for (let W = S; W < E; W += h) b.push(new Gu(U + y, W + y, y, o));
          let O = (function(U) {
            let W = 0, ee = 0, se = 0;
            const pe = U[0];
            for (let je = 0, be = pe.length, Me = be - 1; je < be; Me = je++) {
              const Xe = pe[je], it = pe[Me], _t = Xe.x * it.y - it.x * Xe.y;
              ee += (Xe.x + it.x) * _t, se += (Xe.y + it.y) * _t, W += 3 * _t;
            }
            return new Gu(ee / W, se / W, 0, U);
          })(o), V = b.length;
          for (; b.length; ) {
            const U = b.pop();
            (U.d > O.d || !O.d) && (O = U, n && console.log("found best %d after %d probes", Math.round(1e4 * U.d) / 1e4, V)), U.max - O.d <= t || (y = U.h / 2, b.push(new Gu(U.p.x - y, U.p.y - y, y, o)), b.push(new Gu(U.p.x + y, U.p.y - y, y, o)), b.push(new Gu(U.p.x - y, U.p.y + y, y, o)), b.push(new Gu(U.p.x + y, U.p.y + y, y, o)), V += 4);
          }
          return n && (console.log(`num probes: ${V}`), console.log(`best distance: ${O.d}`)), O.p;
        }
        function K2(o, t) {
          return t.max - o.max;
        }
        function Gu(o, t, n, u) {
          this.p = new C(o, t), this.h = n, this.d = (function(h, y) {
            let b = false, w = 1 / 0;
            for (let S = 0; S < y.length; S++) {
              const I = y[S];
              for (let E = 0, O = I.length, V = O - 1; E < O; V = E++) {
                const U = I[E], W = I[V];
                U.y > h.y != W.y > h.y && h.x < (W.x - U.x) * (h.y - U.y) / (W.y - U.y) + U.x && (b = !b), w = Math.min(w, R0(h, U, W));
              }
            }
            return (b ? 1 : -1) * Math.sqrt(w);
          })(this.p, u), this.max = this.d + this.h * Math.SQRT2;
        }
        var hn;
        p.aI = void 0, (hn = p.aI || (p.aI = {}))[hn.center = 1] = "center", hn[hn.left = 2] = "left", hn[hn.right = 3] = "right", hn[hn.top = 4] = "top", hn[hn.bottom = 5] = "bottom", hn[hn["top-left"] = 6] = "top-left", hn[hn["top-right"] = 7] = "top-right", hn[hn["bottom-left"] = 8] = "bottom-left", hn[hn["bottom-right"] = 9] = "bottom-right";
        const Fm = Number.POSITIVE_INFINITY;
        function Hv(o, t) {
          return t[1] !== Fm ? (function(n, u, h) {
            let y = 0, b = 0;
            switch (u = Math.abs(u), h = Math.abs(h), n) {
              case "top-right":
              case "top-left":
              case "top":
                b = h - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                b = 7 - h;
            }
            switch (n) {
              case "top-right":
              case "bottom-right":
              case "right":
                y = -u;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                y = u;
            }
            return [y, b];
          })(o, t[0], t[1]) : (function(n, u) {
            let h = 0, y = 0;
            u < 0 && (u = 0);
            const b = u / Math.SQRT2;
            switch (n) {
              case "top-right":
              case "top-left":
                y = b - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                y = 7 - b;
                break;
              case "bottom":
                y = 7 - u;
                break;
              case "top":
                y = u - 7;
            }
            switch (n) {
              case "top-right":
              case "bottom-right":
                h = -b;
                break;
              case "top-left":
              case "bottom-left":
                h = b;
                break;
              case "left":
                h = u;
                break;
              case "right":
                h = -u;
            }
            return [h, y];
          })(o, t[0]);
        }
        function Xv(o, t, n) {
          var u;
          const h = o.layout, y = (u = h.get("text-variable-anchor-offset")) === null || u === void 0 ? void 0 : u.evaluate(t, {}, n);
          if (y) {
            const w = y.values, S = [];
            for (let I = 0; I < w.length; I += 2) {
              const E = S[I] = w[I], O = w[I + 1].map(((V) => V * Wi));
              E.startsWith("top") ? O[1] -= 7 : E.startsWith("bottom") && (O[1] += 7), S[I + 1] = O;
            }
            return new un(S);
          }
          const b = h.get("text-variable-anchor");
          if (b) {
            let w;
            w = o._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [h.get("text-radial-offset").evaluate(t, {}, n) * Wi, Fm] : h.get("text-offset").evaluate(t, {}, n).map(((I) => I * Wi));
            const S = [];
            for (const I of b) S.push(I, Hv(I, w));
            return new un(S);
          }
          return null;
        }
        function Lm(o) {
          switch (o) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function J2(o, t, n, u, h, y, b, w, S, I, E, O) {
          let V = y.textMaxSize.evaluate(t, {});
          V === void 0 && (V = b);
          const U = o.layers[0].layout, W = U.get("icon-offset").evaluate(t, {}, E), ee = Kv(n.horizontal), se = b / 24, pe = o.tilePixelRatio * se, je = o.tilePixelRatio * V / 24, be = o.tilePixelRatio * w, Me = o.tilePixelRatio * U.get("symbol-spacing"), Xe = U.get("text-padding") * o.tilePixelRatio, it = (function(cr, Qt, Gt, Mr = 1) {
            const yi = cr.get("icon-padding").evaluate(Qt, {}, Gt), Oi = yi && yi.values;
            return [Oi[0] * Mr, Oi[1] * Mr, Oi[2] * Mr, Oi[3] * Mr];
          })(U, t, E, o.tilePixelRatio), _t = U.get("text-max-angle") / 180 * Math.PI, At = U.get("text-rotation-alignment") !== "viewport" && U.get("symbol-placement") !== "point", It = U.get("icon-rotation-alignment") === "map" && U.get("symbol-placement") !== "point", Et = U.get("symbol-placement"), Yt = Me / 2, Mt = U.get("icon-text-fit");
          let Rt;
          u && Mt !== "none" && (o.allowVerticalPlacement && n.vertical && (Rt = xv(u, n.vertical, Mt, U.get("icon-text-fit-padding"), W, se)), ee && (u = xv(u, ee, Mt, U.get("icon-text-fit-padding"), W, se)));
          const lt = E ? O.line.getGranularityForZoomLevel(E.z) : 1, sr = (cr, Qt) => {
            Qt.x < 0 || Qt.x >= nt || Qt.y < 0 || Qt.y >= nt || (function(Gt, Mr, yi, Oi, fn, fo, Un, en, mi, Zi, tn, rn, Fn, po, Hi, Gn, $i, Xi, Yi, zi, ni, Wo, qu, Zo, tw) {
              const Wu = Gt.addToLineVertexArray(Mr, yi);
              let Sl, Zu, Hu, Xu, t_ = 0, r_ = 0, i_ = 0, n_ = 0, Gm = -1, qm = -1;
              const Ka = {};
              let o_ = Uo("");
              if (Gt.allowVerticalPlacement && Oi.vertical) {
                const xn = en.layout.get("text-rotate").evaluate(ni, {}, Zo) + 90;
                Hu = new Ff(mi, Mr, Zi, tn, rn, Oi.vertical, Fn, po, Hi, xn), Un && (Xu = new Ff(mi, Mr, Zi, tn, rn, Un, $i, Xi, Hi, xn));
              }
              if (fn) {
                const xn = en.layout.get("icon-rotate").evaluate(ni, {}), mo = en.layout.get("icon-text-fit") !== "none", kl = Wv(fn, xn, qu, mo), Xo = Un ? Wv(Un, xn, qu, mo) : void 0;
                Zu = new Ff(mi, Mr, Zi, tn, rn, fn, $i, Xi, false, xn), t_ = 4 * kl.length;
                const Pl = Gt.iconSizeData;
                let ga = null;
                Pl.kind === "source" ? (ga = [Ya * en.layout.get("icon-size").evaluate(ni, {})], ga[0] > Ms && Xt(`${Gt.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : Pl.kind === "composite" && (ga = [Ya * Wo.compositeIconSizes[0].evaluate(ni, {}, Zo), Ya * Wo.compositeIconSizes[1].evaluate(ni, {}, Zo)], (ga[0] > Ms || ga[1] > Ms) && Xt(`${Gt.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), Gt.addSymbols(Gt.icon, kl, ga, zi, Yi, ni, p.as.none, Mr, Wu.lineStartIndex, Wu.lineLength, -1, Zo), Gm = Gt.icon.placedSymbolArray.length - 1, Xo && (r_ = 4 * Xo.length, Gt.addSymbols(Gt.icon, Xo, ga, zi, Yi, ni, p.as.vertical, Mr, Wu.lineStartIndex, Wu.lineLength, -1, Zo), qm = Gt.icon.placedSymbolArray.length - 1);
              }
              const a_ = Object.keys(Oi.horizontal);
              for (const xn of a_) {
                const mo = Oi.horizontal[xn];
                if (!Sl) {
                  o_ = Uo(mo.text);
                  const Xo = en.layout.get("text-rotate").evaluate(ni, {}, Zo);
                  Sl = new Ff(mi, Mr, Zi, tn, rn, mo, Fn, po, Hi, Xo);
                }
                const kl = mo.positionedLines.length === 1;
                if (i_ += Yv(Gt, Mr, mo, fo, en, Hi, ni, Gn, Wu, Oi.vertical ? p.as.horizontal : p.as.horizontalOnly, kl ? a_ : [xn], Ka, Gm, Wo, Zo), kl) break;
              }
              Oi.vertical && (n_ += Yv(Gt, Mr, Oi.vertical, fo, en, Hi, ni, Gn, Wu, p.as.vertical, ["vertical"], Ka, qm, Wo, Zo));
              const rw = Sl ? Sl.boxStartIndex : Gt.collisionBoxArray.length, iw = Sl ? Sl.boxEndIndex : Gt.collisionBoxArray.length, nw = Hu ? Hu.boxStartIndex : Gt.collisionBoxArray.length, ow = Hu ? Hu.boxEndIndex : Gt.collisionBoxArray.length, aw = Zu ? Zu.boxStartIndex : Gt.collisionBoxArray.length, sw = Zu ? Zu.boxEndIndex : Gt.collisionBoxArray.length, lw = Xu ? Xu.boxStartIndex : Gt.collisionBoxArray.length, uw = Xu ? Xu.boxEndIndex : Gt.collisionBoxArray.length;
              let Ho = -1;
              const Bf = (xn, mo) => xn && xn.circleDiameter ? Math.max(xn.circleDiameter, mo) : mo;
              Ho = Bf(Sl, Ho), Ho = Bf(Hu, Ho), Ho = Bf(Zu, Ho), Ho = Bf(Xu, Ho);
              const s_ = Ho > -1 ? 1 : 0;
              s_ && (Ho *= tw / Wi), Gt.glyphOffsetArray.length >= Vu.MAX_GLYPHS && Xt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), ni.sortKey !== void 0 && Gt.addToSortKeyRanges(Gt.symbolInstances.length, ni.sortKey);
              const cw = Xv(en, ni, Zo), [dw, hw] = (function(xn, mo) {
                const kl = xn.length, Xo = mo == null ? void 0 : mo.values;
                if ((Xo == null ? void 0 : Xo.length) > 0) for (let Pl = 0; Pl < Xo.length; Pl += 2) {
                  const ga = Xo[Pl + 1];
                  xn.emplaceBack(p.aI[Xo[Pl]], ga[0], ga[1]);
                }
                return [kl, xn.length];
              })(Gt.textAnchorOffsets, cw);
              Gt.symbolInstances.emplaceBack(Mr.x, Mr.y, Ka.right >= 0 ? Ka.right : -1, Ka.center >= 0 ? Ka.center : -1, Ka.left >= 0 ? Ka.left : -1, Ka.vertical || -1, Gm, qm, o_, rw, iw, nw, ow, aw, sw, lw, uw, Zi, i_, n_, t_, r_, s_, 0, Fn, Ho, dw, hw);
            })(o, Qt, cr, n, u, h, Rt, o.layers[0], o.collisionBoxArray, t.index, t.sourceLayerIndex, o.index, pe, [Xe, Xe, Xe, Xe], At, S, be, it, It, W, t, y, I, E, b);
          };
          if (Et === "line") for (const cr of jv(t.geometry, 0, 0, nt, nt)) {
            const Qt = wl(cr, lt), Gt = H2(Qt, Me, _t, n.vertical || ee, u, 24, je, o.overscaling, nt);
            for (const Mr of Gt) ee && Q2(o, ee.text, Yt, Mr) || sr(Qt, Mr);
          }
          else if (Et === "line-center") {
            for (const cr of t.geometry) if (cr.length > 1) {
              const Qt = wl(cr, lt), Gt = Z2(Qt, _t, n.vertical || ee, u, 24, je);
              Gt && sr(Qt, Gt);
            }
          } else if (t.type === "Polygon") for (const cr of nu(t.geometry, 0)) {
            const Qt = Y2(cr, 16);
            sr(wl(cr[0], lt, true), new Rs(Qt.x, Qt.y, 0));
          }
          else if (t.type === "LineString") for (const cr of t.geometry) {
            const Qt = wl(cr, lt);
            sr(Qt, new Rs(Qt[0].x, Qt[0].y, 0));
          }
          else if (t.type === "Point") for (const cr of t.geometry) for (const Qt of cr) sr([Qt], new Rs(Qt.x, Qt.y, 0));
        }
        function Yv(o, t, n, u, h, y, b, w, S, I, E, O, V, U, W) {
          const ee = (function(je, be, Me, Xe, it, _t, At, It) {
            const Et = Xe.layout.get("text-rotate").evaluate(_t, {}) * Math.PI / 180, Yt = [];
            for (const Mt of be.positionedLines) for (const Rt of Mt.positionedGlyphs) {
              if (!Rt.rect) continue;
              const lt = Rt.rect || {};
              let sr = 4, cr = true, Qt = 1, Gt = 0;
              const Mr = (it || It) && Rt.vertical, yi = Rt.metrics.advance * Rt.scale / 2;
              if (It && be.verticalizable && (Gt = Mt.lineOffset / 2 - (Rt.imageName ? -(Wi - Rt.metrics.width * Rt.scale) / 2 : (Rt.scale - 1) * Wi)), Rt.imageName) {
                const Xi = At[Rt.imageName];
                cr = Xi.sdf, Qt = Xi.pixelRatio, sr = 1 / Qt;
              }
              const Oi = it ? [Rt.x + yi, Rt.y] : [0, 0];
              let fn = it ? [0, 0] : [Rt.x + yi + Me[0], Rt.y + Me[1] - Gt], fo = [0, 0];
              Mr && (fo = fn, fn = [0, 0]);
              const Un = Rt.metrics.isDoubleResolution ? 2 : 1, en = (Rt.metrics.left - sr) * Rt.scale - yi + fn[0], mi = (-Rt.metrics.top - sr) * Rt.scale + fn[1], Zi = en + lt.w / Un * Rt.scale / Qt, tn = mi + lt.h / Un * Rt.scale / Qt, rn = new C(en, mi), Fn = new C(Zi, mi), po = new C(en, tn), Hi = new C(Zi, tn);
              if (Mr) {
                const Xi = new C(-yi, yi - -17), Yi = -Math.PI / 2, zi = 12 - yi, ni = new C(22 - zi, -(Rt.imageName ? zi : 0)), Wo = new C(...fo);
                rn._rotateAround(Yi, Xi)._add(ni)._add(Wo), Fn._rotateAround(Yi, Xi)._add(ni)._add(Wo), po._rotateAround(Yi, Xi)._add(ni)._add(Wo), Hi._rotateAround(Yi, Xi)._add(ni)._add(Wo);
              }
              if (Et) {
                const Xi = Math.sin(Et), Yi = Math.cos(Et), zi = [Yi, -Xi, Xi, Yi];
                rn._matMult(zi), Fn._matMult(zi), po._matMult(zi), Hi._matMult(zi);
              }
              const Gn = new C(0, 0), $i = new C(0, 0);
              Yt.push({ tl: rn, tr: Fn, bl: po, br: Hi, tex: lt, writingMode: be.writingMode, glyphOffset: Oi, sectionIndex: Rt.sectionIndex, isSDF: cr, pixelOffsetTL: Gn, pixelOffsetBR: $i, minFontScaleX: 0, minFontScaleY: 0 });
            }
            return Yt;
          })(0, n, w, h, y, b, u, o.allowVerticalPlacement), se = o.textSizeData;
          let pe = null;
          se.kind === "source" ? (pe = [Ya * h.layout.get("text-size").evaluate(b, {})], pe[0] > Ms && Xt(`${o.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : se.kind === "composite" && (pe = [Ya * U.compositeTextSizes[0].evaluate(b, {}, W), Ya * U.compositeTextSizes[1].evaluate(b, {}, W)], (pe[0] > Ms || pe[1] > Ms) && Xt(`${o.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), o.addSymbols(o.text, ee, pe, w, y, b, I, t, S.lineStartIndex, S.lineLength, V, W);
          for (const je of E) O[je] = o.text.placedSymbolArray.length - 1;
          return 4 * ee.length;
        }
        function Kv(o) {
          for (const t in o) return o[t];
          return null;
        }
        function Q2(o, t, n, u) {
          const h = o.compareText;
          if (t in h) {
            const y = h[t];
            for (let b = y.length - 1; b >= 0; b--) if (u.dist(y[b]) < n) return true;
          } else h[t] = [];
          return h[t].push(u), false;
        }
        const Jv = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class Bm {
          static from(t) {
            if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [n, u] = new Uint8Array(t, 0, 2);
            if (n !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const h = u >> 4;
            if (h !== 1) throw new Error(`Got v${h} data when expected v1.`);
            const y = Jv[15 & u];
            if (!y) throw new Error("Unrecognized array type.");
            const [b] = new Uint16Array(t, 2, 1), [w] = new Uint32Array(t, 4, 1);
            return new Bm(w, b, y, t);
          }
          constructor(t, n = 64, u = Float64Array, h) {
            if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
            this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = u, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
            const y = Jv.indexOf(this.ArrayType), b = 2 * t * this.ArrayType.BYTES_PER_ELEMENT, w = t * this.IndexArrayType.BYTES_PER_ELEMENT, S = (8 - w % 8) % 8;
            if (y < 0) throw new Error(`Unexpected typed array class: ${u}.`);
            h && h instanceof ArrayBuffer ? (this.data = h, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + w + S, 2 * t), this._pos = 2 * t, this._finished = true) : (this.data = new ArrayBuffer(8 + b + w + S), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + w + S, 2 * t), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + y]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
          }
          add(t, n) {
            const u = this._pos >> 1;
            return this.ids[u] = u, this.coords[this._pos++] = t, this.coords[this._pos++] = n, u;
          }
          finish() {
            const t = this._pos >> 1;
            if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
            return Om(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
          }
          range(t, n, u, h) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: y, coords: b, nodeSize: w } = this, S = [0, y.length - 1, 0], I = [];
            for (; S.length; ) {
              const E = S.pop() || 0, O = S.pop() || 0, V = S.pop() || 0;
              if (O - V <= w) {
                for (let se = V; se <= O; se++) {
                  const pe = b[2 * se], je = b[2 * se + 1];
                  pe >= t && pe <= u && je >= n && je <= h && I.push(y[se]);
                }
                continue;
              }
              const U = V + O >> 1, W = b[2 * U], ee = b[2 * U + 1];
              W >= t && W <= u && ee >= n && ee <= h && I.push(y[U]), (E === 0 ? t <= W : n <= ee) && (S.push(V), S.push(U - 1), S.push(1 - E)), (E === 0 ? u >= W : h >= ee) && (S.push(U + 1), S.push(O), S.push(1 - E));
            }
            return I;
          }
          within(t, n, u) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: h, coords: y, nodeSize: b } = this, w = [0, h.length - 1, 0], S = [], I = u * u;
            for (; w.length; ) {
              const E = w.pop() || 0, O = w.pop() || 0, V = w.pop() || 0;
              if (O - V <= b) {
                for (let se = V; se <= O; se++) e_(y[2 * se], y[2 * se + 1], t, n) <= I && S.push(h[se]);
                continue;
              }
              const U = V + O >> 1, W = y[2 * U], ee = y[2 * U + 1];
              e_(W, ee, t, n) <= I && S.push(h[U]), (E === 0 ? t - u <= W : n - u <= ee) && (w.push(V), w.push(U - 1), w.push(1 - E)), (E === 0 ? t + u >= W : n + u >= ee) && (w.push(U + 1), w.push(O), w.push(1 - E));
            }
            return S;
          }
        }
        function Om(o, t, n, u, h, y) {
          if (h - u <= n) return;
          const b = u + h >> 1;
          Qv(o, t, b, u, h, y), Om(o, t, n, u, b - 1, 1 - y), Om(o, t, n, b + 1, h, 1 - y);
        }
        function Qv(o, t, n, u, h, y) {
          for (; h > u; ) {
            if (h - u > 600) {
              const I = h - u + 1, E = n - u + 1, O = Math.log(I), V = 0.5 * Math.exp(2 * O / 3), U = 0.5 * Math.sqrt(O * V * (I - V) / I) * (E - I / 2 < 0 ? -1 : 1);
              Qv(o, t, n, Math.max(u, Math.floor(n - E * V / I + U)), Math.min(h, Math.floor(n + (I - E) * V / I + U)), y);
            }
            const b = t[2 * n + y];
            let w = u, S = h;
            for (Ed(o, t, u, n), t[2 * h + y] > b && Ed(o, t, u, h); w < S; ) {
              for (Ed(o, t, w, S), w++, S--; t[2 * w + y] < b; ) w++;
              for (; t[2 * S + y] > b; ) S--;
            }
            t[2 * u + y] === b ? Ed(o, t, u, S) : (S++, Ed(o, t, S, h)), S <= n && (u = S + 1), n <= S && (h = S - 1);
          }
        }
        function Ed(o, t, n, u) {
          $m(o, n, u), $m(t, 2 * n, 2 * u), $m(t, 2 * n + 1, 2 * u + 1);
        }
        function $m(o, t, n) {
          const u = o[t];
          o[t] = o[n], o[n] = u;
        }
        function e_(o, t, n, u) {
          const h = o - n, y = t - u;
          return h * h + y * y;
        }
        var jm;
        p.cA = void 0, (jm = p.cA || (p.cA = {})).create = "create", jm.load = "load", jm.fullLoad = "fullLoad";
        let Lf = null, Rd = [];
        const Nm = 1e3 / 60, Vm = "loadTime", Um = "fullLoadTime", ew = { mark(o) {
          performance.mark(o);
        }, frame(o) {
          const t = o;
          Lf != null && Rd.push(t - Lf), Lf = t;
        }, clearMetrics() {
          Lf = null, Rd = [], performance.clearMeasures(Vm), performance.clearMeasures(Um);
          for (const o in p.cA) performance.clearMarks(p.cA[o]);
        }, getPerformanceMetrics() {
          performance.measure(Vm, p.cA.create, p.cA.load), performance.measure(Um, p.cA.create, p.cA.fullLoad);
          const o = performance.getEntriesByName(Vm)[0].duration, t = performance.getEntriesByName(Um)[0].duration, n = Rd.length, u = 1 / (Rd.reduce(((y, b) => y + b), 0) / n / 1e3), h = Rd.filter(((y) => y > Nm)).reduce(((y, b) => y + (b - Nm) / Nm), 0);
          return { loadTime: o, fullLoadTime: t, fps: u, percentDroppedFrames: h / (n + h) * 100, totalFrames: n };
        } };
        p.$ = Je, p.A = te, p.B = Cs, p.C = function([o, t, n]) {
          return t += 90, t *= Math.PI / 180, n *= Math.PI / 180, { x: o * Math.cos(t) * Math.sin(n), y: o * Math.sin(t) * Math.sin(n), z: o * Math.cos(n) };
        }, p.D = qt, p.E = xt, p.F = Kn, p.G = Yr, p.H = pl, p.I = km, p.J = ze, p.K = class {
          constructor(o, t) {
            this.target = o, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new G2((() => this.process())), this.subscription = rt(this.target, "message", ((n) => this.receive(n)), false), this.globalScope = nr(self) ? o : window;
          }
          registerMessageHandler(o, t) {
            this.messageHandlers[o] = t;
          }
          sendAsync(o, t) {
            return new Promise(((n, u) => {
              const h = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), y = t ? rt(t.signal, "abort", (() => {
                y == null ? void 0 : y.unsubscribe(), delete this.resolveRejects[h];
                const S = { id: h, type: "<cancel>", origin: location.origin, targetMapId: o.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(S);
              }), q2) : null;
              this.resolveRejects[h] = { resolve: (S) => {
                y == null ? void 0 : y.unsubscribe(), n(S);
              }, reject: (S) => {
                y == null ? void 0 : y.unsubscribe(), u(S);
              } };
              const b = [], w = Object.assign(Object.assign({}, o), { id: h, sourceMapId: this.mapId, origin: location.origin, data: jo(o.data, b) });
              this.target.postMessage(w, { transfer: b });
            }));
          }
          receive(o) {
            const t = o.data, n = t.id;
            if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
              if (t.type === "<cancel>") {
                delete this.tasks[n];
                const u = this.abortControllers[n];
                return delete this.abortControllers[n], void (u && u.abort());
              }
              if (nr(self) || t.mustQueue) return this.tasks[n] = t, this.taskQueue.push(n), void this.invoker.trigger();
              this.processTask(n, t);
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const o = this.taskQueue.shift(), t = this.tasks[o];
            delete this.tasks[o], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(o, t);
          }
          processTask(o, t) {
            return s(this, void 0, void 0, (function* () {
              if (t.type === "<response>") {
                const h = this.resolveRejects[o];
                return delete this.resolveRejects[o], h ? void (t.error ? h.reject(ml(t.error)) : h.resolve(ml(t.data))) : void 0;
              }
              if (!this.messageHandlers[t.type]) return void this.completeTask(o, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const n = ml(t.data), u = new AbortController();
              this.abortControllers[o] = u;
              try {
                const h = yield this.messageHandlers[t.type](t.sourceMapId, n, u);
                this.completeTask(o, null, h);
              } catch (h) {
                this.completeTask(o, h);
              }
            }));
          }
          completeTask(o, t, n) {
            const u = [];
            delete this.abortControllers[o];
            const h = { id: o, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: t ? jo(t) : null, data: jo(n, u) };
            this.target.postMessage(h, { transfer: u });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, p.L = ne, p.M = function() {
          var o = new te(16);
          return te != Float32Array && (o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0), o[0] = 1, o[5] = 1, o[10] = 1, o[15] = 1, o;
        }, p.N = function(o, t, n) {
          var u, h, y, b, w, S, I, E, O, V, U, W, ee = n[0], se = n[1], pe = n[2];
          return t === o ? (o[12] = t[0] * ee + t[4] * se + t[8] * pe + t[12], o[13] = t[1] * ee + t[5] * se + t[9] * pe + t[13], o[14] = t[2] * ee + t[6] * se + t[10] * pe + t[14], o[15] = t[3] * ee + t[7] * se + t[11] * pe + t[15]) : (h = t[1], y = t[2], b = t[3], w = t[4], S = t[5], I = t[6], E = t[7], O = t[8], V = t[9], U = t[10], W = t[11], o[0] = u = t[0], o[1] = h, o[2] = y, o[3] = b, o[4] = w, o[5] = S, o[6] = I, o[7] = E, o[8] = O, o[9] = V, o[10] = U, o[11] = W, o[12] = u * ee + w * se + O * pe + t[12], o[13] = h * ee + S * se + V * pe + t[13], o[14] = y * ee + I * se + U * pe + t[14], o[15] = b * ee + E * se + W * pe + t[15]), o;
        }, p.O = function(o, t, n) {
          var u = n[0], h = n[1], y = n[2];
          return o[0] = t[0] * u, o[1] = t[1] * u, o[2] = t[2] * u, o[3] = t[3] * u, o[4] = t[4] * h, o[5] = t[5] * h, o[6] = t[6] * h, o[7] = t[7] * h, o[8] = t[8] * y, o[9] = t[9] * y, o[10] = t[10] * y, o[11] = t[11] * y, o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15], o;
        }, p.P = C, p.Q = function(o, t, n) {
          var u = t[0], h = t[1], y = t[2], b = t[3], w = t[4], S = t[5], I = t[6], E = t[7], O = t[8], V = t[9], U = t[10], W = t[11], ee = t[12], se = t[13], pe = t[14], je = t[15], be = n[0], Me = n[1], Xe = n[2], it = n[3];
          return o[0] = be * u + Me * w + Xe * O + it * ee, o[1] = be * h + Me * S + Xe * V + it * se, o[2] = be * y + Me * I + Xe * U + it * pe, o[3] = be * b + Me * E + Xe * W + it * je, o[4] = (be = n[4]) * u + (Me = n[5]) * w + (Xe = n[6]) * O + (it = n[7]) * ee, o[5] = be * h + Me * S + Xe * V + it * se, o[6] = be * y + Me * I + Xe * U + it * pe, o[7] = be * b + Me * E + Xe * W + it * je, o[8] = (be = n[8]) * u + (Me = n[9]) * w + (Xe = n[10]) * O + (it = n[11]) * ee, o[9] = be * h + Me * S + Xe * V + it * se, o[10] = be * y + Me * I + Xe * U + it * pe, o[11] = be * b + Me * E + Xe * W + it * je, o[12] = (be = n[12]) * u + (Me = n[13]) * w + (Xe = n[14]) * O + (it = n[15]) * ee, o[13] = be * h + Me * S + Xe * V + it * se, o[14] = be * y + Me * I + Xe * U + it * pe, o[15] = be * b + Me * E + Xe * W + it * je, o;
        }, p.R = Vn, p.S = function(o, t) {
          const n = {};
          for (let u = 0; u < t.length; u++) {
            const h = t[u];
            h in o && (n[h] = o[h]);
          }
          return n;
        }, p.T = mm, p.U = Es, p.V = Bt, p.W = Ev, p.X = Mv, p.Y = Z, p.Z = q, p._ = s, p.a = X, p.a$ = function(o, t, n) {
          return o[0] = t[0] * n[0], o[1] = t[1] * n[1], o[2] = t[2] * n[2], o[3] = t[3] * n[3], o;
        }, p.a0 = ho, p.a1 = Av, p.a2 = Rf, p.a3 = nt, p.a4 = function(o, t) {
          var n, u, h, y, b;
          if (!o) return t ?? {};
          if (!t) return o;
          let w = Object.assign({}, o);
          if (t.removeAll && (w = { removeAll: true }), t.remove) {
            const S = new Set(t.remove);
            w.add && (w.add = w.add.filter(((E) => !S.has(E.id)))), w.update && (w.update = w.update.filter(((E) => !S.has(E.id))));
            const I = new Set(((n = o.add) !== null && n !== void 0 ? n : []).map(((E) => E.id)));
            t.remove = t.remove.filter(((E) => !I.has(E)));
          }
          if (t.remove) {
            const S = new Set(w.remove ? w.remove.concat(t.remove) : t.remove);
            w.remove = Array.from(S.values());
          }
          if (t.add) {
            const S = w.add ? w.add.concat(t.add) : t.add, I = new Map(S.map(((E) => [E.id, E])));
            w.add = Array.from(I.values());
          }
          if (t.update) {
            const S = new Map((u = w.update) === null || u === void 0 ? void 0 : u.map(((I) => [I.id, I])));
            for (const I of t.update) {
              const E = (h = S.get(I.id)) !== null && h !== void 0 ? h : { id: I.id };
              I.newGeometry && (E.newGeometry = I.newGeometry), I.addOrUpdateProperties && (E.addOrUpdateProperties = ((y = E.addOrUpdateProperties) !== null && y !== void 0 ? y : []).concat(I.addOrUpdateProperties)), I.removeProperties && (E.removeProperties = ((b = E.removeProperties) !== null && b !== void 0 ? b : []).concat(I.removeProperties)), I.removeAllProperties && (E.removeAllProperties = true), S.set(I.id, E);
            }
            w.update = Array.from(S.values());
          }
          return w.remove && w.add && (w.remove = w.remove.filter(((S) => w.add.findIndex(((I) => I.id === S)) === -1))), w;
        }, p.a5 = Id, p.a6 = Cl, p.a7 = 25, p.a8 = zm, p.a9 = (o) => {
          const t = window.document.createElement("video");
          return t.muted = true, new Promise(((n) => {
            t.onloadstart = () => {
              n(t);
            };
            for (const u of o) {
              const h = window.document.createElement("source");
              Pe(u) || (t.crossOrigin = "Anonymous"), h.src = u, t.appendChild(h);
            }
          }));
        }, p.aA = tt, p.aB = function(o, t, n, u) {
          const h = t.y - o.y, y = t.x - o.x, b = u.y - n.y, w = u.x - n.x, S = b * y - w * h;
          if (S === 0) return null;
          const I = (w * (o.y - n.y) - b * (o.x - n.x)) / S;
          return new C(o.x + I * y, o.y + I * h);
        }, p.aC = jv, p.aD = M0, p.aE = function(o) {
          let t = 1 / 0, n = 1 / 0, u = -1 / 0, h = -1 / 0;
          for (const y of o) t = Math.min(t, y.x), n = Math.min(n, y.y), u = Math.max(u, y.x), h = Math.max(h, y.y);
          return [t, n, u, h];
        }, p.aF = Wi, p.aG = ft, p.aH = function(o, t, n, u, h = false) {
          if (!n[0] && !n[1]) return [0, 0];
          const y = h ? u === "map" ? -o.bearingInRadians : 0 : u === "viewport" ? o.bearingInRadians : 0;
          if (y) {
            const b = Math.sin(y), w = Math.cos(y);
            n = [n[0] * w - n[1] * b, n[0] * b + n[1] * w];
          }
          return [h ? n[0] : ft(t, n[0], o.zoom), h ? n[1] : ft(t, n[1], o.zoom)];
        }, p.aJ = Im, p.aK = Lm, p.aL = Tm, p.aM = Bm, p.aN = Ci, p.aO = kf, p.aP = ge, p.aQ = vr, p.aR = dt, p.aS = Wt, p.aT = Dv, p.aU = he, p.aV = oe, p.aW = function(o) {
          var t = new te(3);
          return t[0] = o[0], t[1] = o[1], t[2] = o[2], t;
        }, p.aX = function(o, t, n) {
          return o[0] = t[0] - n[0], o[1] = t[1] - n[1], o[2] = t[2] - n[2], o;
        }, p.aY = function(o, t) {
          var n = t[0], u = t[1], h = t[2], y = n * n + u * u + h * h;
          return y > 0 && (y = 1 / Math.sqrt(y)), o[0] = t[0] * y, o[1] = t[1] * y, o[2] = t[2] * y, o;
        }, p.aZ = _e, p.a_ = function(o, t) {
          return o[0] * t[0] + o[1] * t[1] + o[2] * t[2];
        }, p.aa = Te, p.ab = function() {
          return ir++;
        }, p.ac = k, p.ad = Vu, p.ae = cl, p.af = ma, p.ag = Bv, p.ah = function(o) {
          const t = {};
          if (o.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((n, u, h, y) => {
            const b = h || y;
            return t[u] = !b || b.toLowerCase(), "";
          })), t["max-age"]) {
            const n = parseInt(t["max-age"], 10);
            isNaN(n) ? delete t["max-age"] : t["max-age"] = n;
          }
          return t;
        }, p.ai = gt, p.aj = 85.051129, p.ak = vt, p.al = function(o) {
          return Math.pow(2, o);
        }, p.am = ie, p.an = Rv, p.ao = function(o) {
          return Math.log(o) / Math.LN2;
        }, p.ap = function(o) {
          var t = o[0], n = o[1];
          return t * t + n * n;
        }, p.aq = function(o) {
          if (!o.length) return /* @__PURE__ */ new Set();
          const t = Math.max(...o.map(((S) => S.canonical.z)));
          let n = 1 / 0, u = -1 / 0, h = 1 / 0, y = -1 / 0;
          const b = [];
          for (const S of o) {
            const { x: I, y: E, z: O } = S.canonical, V = Math.pow(2, t - O), U = I * V, W = E * V;
            b.push({ id: S, x: U, y: W }), U < n && (n = U), U > u && (u = U), W < h && (h = W), W > y && (y = W);
          }
          const w = /* @__PURE__ */ new Set();
          for (const S of b) S.x !== n && S.x !== u && S.y !== h && S.y !== y || w.add(S.id);
          return w;
        }, p.ar = function(o, t) {
          let n = 0, u = 0;
          if (o.kind === "constant") u = o.layoutSize;
          else if (o.kind !== "source") {
            const { interpolationType: h, minZoom: y, maxZoom: b } = o, w = h ? gt(Vr.interpolationFactor(h, t, y, b), 0, 1) : 0;
            o.kind === "camera" ? u = Kn.number(o.minSize, o.maxSize, w) : n = w;
          }
          return { uSizeT: n, uSize: u };
        }, p.at = function(o, { uSize: t, uSizeT: n }, { lowerSize: u, upperSize: h }) {
          return o.kind === "source" ? u / Ya : o.kind === "composite" ? Kn.number(u / Ya, h / Ya, n) : t;
        }, p.au = function(o, t) {
          var n = t[0], u = t[1], h = t[2], y = t[3], b = t[4], w = t[5], S = t[6], I = t[7], E = t[8], O = t[9], V = t[10], U = t[11], W = t[12], ee = t[13], se = t[14], pe = t[15], je = n * w - u * b, be = n * S - h * b, Me = n * I - y * b, Xe = u * S - h * w, it = u * I - y * w, _t = h * I - y * S, At = E * ee - O * W, It = E * se - V * W, Et = E * pe - U * W, Yt = O * se - V * ee, Mt = O * pe - U * ee, Rt = V * pe - U * se, lt = je * Rt - be * Mt + Me * Yt + Xe * Et - it * It + _t * At;
          return lt ? (o[0] = (w * Rt - S * Mt + I * Yt) * (lt = 1 / lt), o[1] = (h * Mt - u * Rt - y * Yt) * lt, o[2] = (ee * _t - se * it + pe * Xe) * lt, o[3] = (V * it - O * _t - U * Xe) * lt, o[4] = (S * Et - b * Rt - I * It) * lt, o[5] = (n * Rt - h * Et + y * It) * lt, o[6] = (se * Me - W * _t - pe * be) * lt, o[7] = (E * _t - V * Me + U * be) * lt, o[8] = (b * Mt - w * Et + I * At) * lt, o[9] = (u * Et - n * Mt - y * At) * lt, o[10] = (W * it - ee * Me + pe * je) * lt, o[11] = (O * Me - E * it - U * je) * lt, o[12] = (w * It - b * Yt - S * At) * lt, o[13] = (n * Yt - u * It + h * At) * lt, o[14] = (ee * be - W * Xe - se * je) * lt, o[15] = (E * Xe - O * be + V * je) * lt, o) : null;
        }, p.av = St, p.aw = function(o) {
          var t = o[0], n = o[1];
          return Math.sqrt(t * t + n * n);
        }, p.ax = function(o) {
          return o[0] = 0, o[1] = 0, o;
        }, p.ay = function(o, t, n) {
          return o[0] = t[0] * n, o[1] = t[1] * n, o;
        }, p.az = Mm, p.b = at, p.b$ = function(o, t, n) {
          var u = t[0], h = t[1], y = t[2];
          return o[0] = u * n[0] + h * n[3] + y * n[6], o[1] = u * n[1] + h * n[4] + y * n[7], o[2] = u * n[2] + h * n[5] + y * n[8], o;
        }, p.b0 = we, p.b1 = function(o, t, n) {
          const u = t[0] * n[0] + t[1] * n[1] + t[2] * n[2];
          return u === 0 ? null : (-(o[0] * n[0] + o[1] * n[1] + o[2] * n[2]) - n[3]) / u;
        }, p.b2 = qe, p.b3 = function(o, t, n) {
          return o[0] = t[0] * n, o[1] = t[1] * n, o[2] = t[2] * n, o[3] = t[3] * n, o;
        }, p.b4 = function(o, t) {
          return o[0] * t[0] + o[1] * t[1] + o[2] * t[2] + o[3];
        }, p.b5 = Fv, p.b6 = Uu, p.b7 = function(o, t, n, u, h) {
          var y = 1 / Math.tan(t / 2);
          if (o[0] = y / n, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = y, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[11] = -1, o[12] = 0, o[13] = 0, o[15] = 0, h != null && h !== 1 / 0) {
            var b = 1 / (u - h);
            o[10] = (h + u) * b, o[14] = 2 * h * u * b;
          } else o[10] = -1, o[14] = -2 * u;
          return o;
        }, p.b8 = function(o) {
          var t = new te(16);
          return t[0] = o[0], t[1] = o[1], t[2] = o[2], t[3] = o[3], t[4] = o[4], t[5] = o[5], t[6] = o[6], t[7] = o[7], t[8] = o[8], t[9] = o[9], t[10] = o[10], t[11] = o[11], t[12] = o[12], t[13] = o[13], t[14] = o[14], t[15] = o[15], t;
        }, p.b9 = function(o, t, n) {
          var u = Math.sin(n), h = Math.cos(n), y = t[0], b = t[1], w = t[2], S = t[3], I = t[4], E = t[5], O = t[6], V = t[7];
          return t !== o && (o[8] = t[8], o[9] = t[9], o[10] = t[10], o[11] = t[11], o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15]), o[0] = y * h + I * u, o[1] = b * h + E * u, o[2] = w * h + O * u, o[3] = S * h + V * u, o[4] = I * h - y * u, o[5] = E * h - b * u, o[6] = O * h - w * u, o[7] = V * h - S * u, o;
        }, p.bA = function(o, t, n, u) {
          var h = [], y = [];
          return h[0] = t[0] - n[0], h[1] = t[1] - n[1], h[2] = t[2] - n[2], y[0] = h[0], y[1] = h[1] * Math.cos(u) - h[2] * Math.sin(u), y[2] = h[1] * Math.sin(u) + h[2] * Math.cos(u), o[0] = y[0] + n[0], o[1] = y[1] + n[1], o[2] = y[2] + n[2], o;
        }, p.bB = function(o, t, n, u) {
          var h = [], y = [];
          return h[0] = t[0] - n[0], h[1] = t[1] - n[1], h[2] = t[2] - n[2], y[0] = h[2] * Math.sin(u) + h[0] * Math.cos(u), y[1] = h[1], y[2] = h[2] * Math.cos(u) - h[0] * Math.sin(u), o[0] = y[0] + n[0], o[1] = y[1] + n[1], o[2] = y[2] + n[2], o;
        }, p.bC = function(o, t, n) {
          var u = Math.sin(n), h = Math.cos(n), y = t[0], b = t[1], w = t[2], S = t[3], I = t[8], E = t[9], O = t[10], V = t[11];
          return t !== o && (o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7], o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15]), o[0] = y * h - I * u, o[1] = b * h - E * u, o[2] = w * h - O * u, o[3] = S * h - V * u, o[8] = y * u + I * h, o[9] = b * u + E * h, o[10] = w * u + O * h, o[11] = S * u + V * h, o;
        }, p.bD = function(o, t) {
          const n = Lt(o, 360), u = Lt(t, 360), h = u - n, y = u > n ? h - 360 : h + 360;
          return Math.abs(h) < Math.abs(y) ? h : y;
        }, p.bE = function(o) {
          return o[0] = 0, o[1] = 0, o[2] = 0, o;
        }, p.bF = function(o, t, n, u) {
          const h = Math.sqrt(o * o + t * t), y = Math.sqrt(n * n + u * u);
          o /= h, t /= h, n /= y, u /= y;
          const b = Math.acos(o * n + t * u);
          return -t * n + o * u > 0 ? b : -b;
        }, p.bG = function(o, t) {
          const n = Lt(o, 2 * Math.PI), u = Lt(t, 2 * Math.PI);
          return Math.min(Math.abs(n - u), Math.abs(n - u + 2 * Math.PI), Math.abs(n - u - 2 * Math.PI));
        }, p.bH = function() {
          const o = {}, t = Le.$version;
          for (const n in Le.$root) {
            const u = Le.$root[n];
            if (u.required) {
              let h = null;
              h = n === "version" ? t : u.type === "array" ? [] : {}, h != null && (o[n] = h);
            }
          }
          return o;
        }, p.bI = rd, p.bJ = Ce, p.bK = function o(t, n) {
          if (Array.isArray(t)) {
            if (!Array.isArray(n) || t.length !== n.length) return false;
            for (let u = 0; u < t.length; u++) if (!o(t[u], n[u])) return false;
            return true;
          }
          if (typeof t == "object" && t !== null && n !== null) {
            if (typeof n != "object" || Object.keys(t).length !== Object.keys(n).length) return false;
            for (const u in t) if (!o(t[u], n[u])) return false;
            return true;
          }
          return t === n;
        }, p.bL = function(o) {
          o = o.slice();
          const t = /* @__PURE__ */ Object.create(null);
          for (let n = 0; n < o.length; n++) t[o[n].id] = o[n];
          for (let n = 0; n < o.length; n++) "ref" in o[n] && (o[n] = Zr(o[n], t[o[n].ref]));
          return o;
        }, p.bM = function(o, t) {
          if (o.type === "custom") return new U2(o, t);
          switch (o.type) {
            case "background":
              return new V2(o, t);
            case "circle":
              return new Tx(o, t);
            case "color-relief":
              return new Dx(o, t);
            case "fill":
              return new Hx(o, t);
            case "fill-extrusion":
              return new o2(o, t);
            case "heatmap":
              return new Mx(o, t);
            case "hillshade":
              return new Rx(o, t);
            case "line":
              return new h2(o, t);
            case "raster":
              return new am(o, t);
            case "symbol":
              return new Ef(o, t);
          }
        }, p.bN = (o) => o.type === "raster", p.bO = or, p.bP = function(o, t) {
          if (!o) return [{ command: "setStyle", args: [t] }];
          let n = [];
          try {
            if (!Ut(o.version, t.version)) return [{ command: "setStyle", args: [t] }];
            Ut(o.center, t.center) || n.push({ command: "setCenter", args: [t.center] }), Ut(o.state, t.state) || n.push({ command: "setGlobalState", args: [t.state] }), Ut(o.centerAltitude, t.centerAltitude) || n.push({ command: "setCenterAltitude", args: [t.centerAltitude] }), Ut(o.zoom, t.zoom) || n.push({ command: "setZoom", args: [t.zoom] }), Ut(o.bearing, t.bearing) || n.push({ command: "setBearing", args: [t.bearing] }), Ut(o.pitch, t.pitch) || n.push({ command: "setPitch", args: [t.pitch] }), Ut(o.roll, t.roll) || n.push({ command: "setRoll", args: [t.roll] }), Ut(o.sprite, t.sprite) || n.push({ command: "setSprite", args: [t.sprite] }), Ut(o.glyphs, t.glyphs) || n.push({ command: "setGlyphs", args: [t.glyphs] }), Ut(o.transition, t.transition) || n.push({ command: "setTransition", args: [t.transition] }), Ut(o.light, t.light) || n.push({ command: "setLight", args: [t.light] }), Ut(o.terrain, t.terrain) || n.push({ command: "setTerrain", args: [t.terrain] }), Ut(o.sky, t.sky) || n.push({ command: "setSky", args: [t.sky] }), Ut(o.projection, t.projection) || n.push({ command: "setProjection", args: [t.projection] });
            const u = {}, h = [];
            (function(b, w, S, I) {
              let E;
              for (E in w = w || {}, b = b || {}) Object.prototype.hasOwnProperty.call(b, E) && (Object.prototype.hasOwnProperty.call(w, E) || jr(E, S, I));
              for (E in w) Object.prototype.hasOwnProperty.call(w, E) && (Object.prototype.hasOwnProperty.call(b, E) ? Ut(b[E], w[E]) || (b[E].type === "geojson" && w[E].type === "geojson" && Hr(b, w, E) ? dr(S, { command: "setGeoJSONSourceData", args: [E, w[E].data] }) : di(E, w, S, I)) : Er(E, w, S));
            })(o.sources, t.sources, h, u);
            const y = [];
            o.layers && o.layers.forEach(((b) => {
              "source" in b && u[b.source] ? n.push({ command: "removeLayer", args: [b.id] }) : y.push(b);
            })), n = n.concat(h), (function(b, w, S) {
              w = w || [];
              const I = (b = b || []).map(Lr), E = w.map(Lr), O = b.reduce(Ne, {}), V = w.reduce(Ne, {}), U = I.slice(), W = /* @__PURE__ */ Object.create(null);
              let ee, se, pe, je, be;
              for (let Me = 0, Xe = 0; Me < I.length; Me++) ee = I[Me], Object.prototype.hasOwnProperty.call(V, ee) ? Xe++ : (dr(S, { command: "removeLayer", args: [ee] }), U.splice(U.indexOf(ee, Xe), 1));
              for (let Me = 0, Xe = 0; Me < E.length; Me++) ee = E[E.length - 1 - Me], U[U.length - 1 - Me] !== ee && (Object.prototype.hasOwnProperty.call(O, ee) ? (dr(S, { command: "removeLayer", args: [ee] }), U.splice(U.lastIndexOf(ee, U.length - Xe), 1)) : Xe++, je = U[U.length - Me], dr(S, { command: "addLayer", args: [V[ee], je] }), U.splice(U.length - Me, 0, ee), W[ee] = true);
              for (let Me = 0; Me < E.length; Me++) if (ee = E[Me], se = O[ee], pe = V[ee], !W[ee] && !Ut(se, pe)) if (Ut(se.source, pe.source) && Ut(se["source-layer"], pe["source-layer"]) && Ut(se.type, pe.type)) {
                for (be in Jr(se.layout, pe.layout, S, ee, null, "setLayoutProperty"), Jr(se.paint, pe.paint, S, ee, null, "setPaintProperty"), Ut(se.filter, pe.filter) || dr(S, { command: "setFilter", args: [ee, pe.filter] }), Ut(se.minzoom, pe.minzoom) && Ut(se.maxzoom, pe.maxzoom) || dr(S, { command: "setLayerZoomRange", args: [ee, pe.minzoom, pe.maxzoom] }), se) Object.prototype.hasOwnProperty.call(se, be) && be !== "layout" && be !== "paint" && be !== "filter" && be !== "metadata" && be !== "minzoom" && be !== "maxzoom" && (be.indexOf("paint.") === 0 ? Jr(se[be], pe[be], S, ee, be.slice(6), "setPaintProperty") : Ut(se[be], pe[be]) || dr(S, { command: "setLayerProperty", args: [ee, be, pe[be]] }));
                for (be in pe) Object.prototype.hasOwnProperty.call(pe, be) && !Object.prototype.hasOwnProperty.call(se, be) && be !== "layout" && be !== "paint" && be !== "filter" && be !== "metadata" && be !== "minzoom" && be !== "maxzoom" && (be.indexOf("paint.") === 0 ? Jr(se[be], pe[be], S, ee, be.slice(6), "setPaintProperty") : Ut(se[be], pe[be]) || dr(S, { command: "setLayerProperty", args: [ee, be, pe[be]] }));
              } else dr(S, { command: "removeLayer", args: [ee] }), je = U[U.lastIndexOf(ee) + 1], dr(S, { command: "addLayer", args: [pe, je] });
            })(y, t.layers, n);
          } catch (u) {
            console.warn("Unable to compute style diff:", u), n = [{ command: "setStyle", args: [t] }];
          }
          return n;
        }, p.bQ = function(o) {
          const t = [], n = o.id;
          return n === void 0 && t.push({ message: `layers.${n}: missing required property "id"` }), o.render === void 0 && t.push({ message: `layers.${n}: missing required method "render"` }), o.renderingMode && o.renderingMode !== "2d" && o.renderingMode !== "3d" && t.push({ message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"` }), t;
        }, p.bR = Cr, p.bS = Ar, p.bT = class extends zn {
          constructor(o, t) {
            super(o, t), this.current = 0;
          }
          set(o) {
            this.current !== o && (this.current = o, this.gl.uniform1i(this.location, o));
          }
        }, p.bU = fa, p.bV = class extends zn {
          constructor(o, t) {
            super(o, t), this.current = bl;
          }
          set(o) {
            if (o[12] !== this.current[12] || o[0] !== this.current[0]) return this.current = o, void this.gl.uniformMatrix4fv(this.location, false, o);
            for (let t = 1; t < 16; t++) if (o[t] !== this.current[t]) {
              this.current = o, this.gl.uniformMatrix4fv(this.location, false, o);
              break;
            }
          }
        }, p.bW = Go, p.bX = class extends zn {
          constructor(o, t) {
            super(o, t), this.current = [0, 0, 0];
          }
          set(o) {
            o[0] === this.current[0] && o[1] === this.current[1] && o[2] === this.current[2] || (this.current = o, this.gl.uniform3f(this.location, o[0], o[1], o[2]));
          }
        }, p.bY = class extends zn {
          constructor(o, t) {
            super(o, t), this.current = [0, 0];
          }
          set(o) {
            o[0] === this.current[0] && o[1] === this.current[1] || (this.current = o, this.gl.uniform2f(this.location, o[0], o[1]));
          }
        }, p.bZ = re, p.b_ = function(o, t) {
          var n = Math.sin(t), u = Math.cos(t);
          return o[0] = u, o[1] = n, o[2] = 0, o[3] = -n, o[4] = u, o[5] = 0, o[6] = 0, o[7] = 0, o[8] = 1, o;
        }, p.ba = function(o, t, n) {
          var u = Math.sin(n), h = Math.cos(n), y = t[4], b = t[5], w = t[6], S = t[7], I = t[8], E = t[9], O = t[10], V = t[11];
          return t !== o && (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15]), o[4] = y * h + I * u, o[5] = b * h + E * u, o[6] = w * h + O * u, o[7] = S * h + V * u, o[8] = I * h - y * u, o[9] = E * h - b * u, o[10] = O * h - w * u, o[11] = V * h - S * u, o;
        }, p.bb = function() {
          const o = new Float32Array(16);
          return ie(o), o;
        }, p.bc = function() {
          const o = new Float64Array(16);
          return ie(o), o;
        }, p.bd = function() {
          return new Float64Array(16);
        }, p.be = function(o, t, n) {
          const u = new Float64Array(4);
          return mt(u, o, t - 90, n), u;
        }, p.bf = function(o, t, n, u) {
          var h, y, b, w, S, I = t[0], E = t[1], O = t[2], V = t[3], U = n[0], W = n[1], ee = n[2], se = n[3];
          return (y = I * U + E * W + O * ee + V * se) < 0 && (y = -y, U = -U, W = -W, ee = -ee, se = -se), 1 - y > K ? (h = Math.acos(y), b = Math.sin(h), w = Math.sin((1 - u) * h) / b, S = Math.sin(u * h) / b) : (w = 1 - u, S = u), o[0] = w * I + S * U, o[1] = w * E + S * W, o[2] = w * O + S * ee, o[3] = w * V + S * se, o;
        }, p.bg = function(o) {
          const t = new Float64Array(9);
          var n, u, h, y, b, w, S, I, E, O, V, U, W, ee, se, pe, je, be;
          O = (h = (u = o)[0]) * (S = h + h), V = (y = u[1]) * S, W = (b = u[2]) * S, ee = b * (I = y + y), pe = (w = u[3]) * S, je = w * I, be = w * (E = b + b), (n = t)[0] = 1 - (U = y * I) - (se = b * E), n[3] = V - be, n[6] = W + je, n[1] = V + be, n[4] = 1 - O - se, n[7] = ee - pe, n[2] = W - je, n[5] = ee + pe, n[8] = 1 - O - U;
          const Me = Wt(-Math.asin(gt(t[2], -1, 1)));
          let Xe, it;
          return Math.hypot(t[5], t[8]) < 1e-3 ? (Xe = 0, it = -Wt(Math.atan2(t[3], t[4]))) : (Xe = Wt(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), it = Wt(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), { roll: Xe, pitch: Me + 90, bearing: it };
        }, p.bh = function(o, t) {
          return o.roll == t.roll && o.pitch == t.pitch && o.bearing == t.bearing;
        }, p.bi = fr, p.bj = bn, p.bk = Ou, p.bl = wd, p.bm = Bu, p.bn = pt, p.bo = wt, p.bp = Nn, p.bq = function(o, t, n, u, h) {
          return pt(u, h, gt((o - t) / (n - t), 0, 1));
        }, p.br = Lt, p.bs = function() {
          return new Float64Array(3);
        }, p.bt = function(o, t, n, u) {
          return o[0] = t[0] + n[0] * u, o[1] = t[1] + n[1] * u, o[2] = t[2] + n[2] * u, o;
        }, p.bu = mt, p.bv = function(o, t, n) {
          var u = n[0], h = n[1], y = n[2], b = n[3], w = t[0], S = t[1], I = t[2], E = h * I - y * S, O = y * w - u * I, V = u * S - h * w;
          return o[0] = w + b * (E += E) + h * (V += V) - y * (O += O), o[1] = S + b * O + y * E - u * V, o[2] = I + b * V + u * O - h * E, o;
        }, p.bw = function(o, t, n) {
          const u = (h = [o[0], o[1], o[2], t[0], t[1], t[2], n[0], n[1], n[2]])[0] * ((E = h[8]) * (b = h[4]) - (w = h[5]) * (I = h[7])) + h[1] * (-E * (y = h[3]) + w * (S = h[6])) + h[2] * (I * y - b * S);
          var h, y, b, w, S, I, E;
          if (u === 0) return null;
          const O = _e([], [t[0], t[1], t[2]], [n[0], n[1], n[2]]), V = _e([], [n[0], n[1], n[2]], [o[0], o[1], o[2]]), U = _e([], [o[0], o[1], o[2]], [t[0], t[1], t[2]]), W = he([], O, -o[3]);
          return oe(W, W, he([], V, -t[3])), oe(W, W, he([], U, -n[3])), he(W, W, 1 / u), W;
        }, p.bx = Dm, p.by = function() {
          return new Float64Array(4);
        }, p.bz = function(o, t, n, u) {
          var h = [], y = [];
          return h[0] = t[0] - n[0], h[1] = t[1] - n[1], h[2] = t[2] - n[2], y[0] = h[0] * Math.cos(u) - h[1] * Math.sin(u), y[1] = h[0] * Math.sin(u) + h[1] * Math.cos(u), y[2] = h[2], o[0] = y[0] + n[0], o[1] = y[1] + n[1], o[2] = y[2] + n[2], o;
        }, p.c = Fe, p.c0 = function(o, t, n, u, h, y, b) {
          var w = 1 / (t - n), S = 1 / (u - h), I = 1 / (y - b);
          return o[0] = -2 * w, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = -2 * S, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 2 * I, o[11] = 0, o[12] = (t + n) * w, o[13] = (h + u) * S, o[14] = (b + y) * I, o[15] = 1, o;
        }, p.c1 = class extends zn {
          constructor(o, t) {
            super(o, t), this.current = new Array();
          }
          set(o) {
            if (o != this.current) {
              this.current = o;
              const t = new Float32Array(4 * o.length);
              for (let n = 0; n < o.length; n++) t[4 * n] = o[n].r, t[4 * n + 1] = o[n].g, t[4 * n + 2] = o[n].b, t[4 * n + 3] = o[n].a;
              this.gl.uniform4fv(this.location, t);
            }
          }
        }, p.c2 = class extends zn {
          constructor(o, t) {
            super(o, t), this.current = new Array();
          }
          set(o) {
            if (o != this.current) {
              this.current = o;
              const t = new Float32Array(o);
              this.gl.uniform1fv(this.location, t);
            }
          }
        }, p.c3 = class extends Ga {
        }, p.c4 = g2, p.c5 = class extends Eu {
        }, p.c6 = pm, p.c7 = function(o) {
          return o <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(o) / Math.LN2));
        }, p.c8 = $0, p.c9 = function(o, t, n) {
          var u = t[0], h = t[1], y = t[2], b = n[3] * u + n[7] * h + n[11] * y + n[15];
          return o[0] = (n[0] * u + n[4] * h + n[8] * y + n[12]) / (b = b || 1), o[1] = (n[1] * u + n[5] * h + n[9] * y + n[13]) / b, o[2] = (n[2] * u + n[6] * h + n[10] * y + n[14]) / b, o;
        }, p.cB = function(o) {
          return o.message === sn;
        }, p.cC = ve, p.cD = function(o, t) {
          X.REGISTERED_PROTOCOLS[o] = t;
        }, p.cE = function(o) {
          delete X.REGISTERED_PROTOCOLS[o];
        }, p.cF = function(o, t) {
          const n = {};
          for (let h = 0; h < o.length; h++) {
            const y = t && t[o[h].id] || Gh(o[h]);
            t && (t[o[h].id] = y);
            let b = n[y];
            b || (b = n[y] = []), b.push(o[h]);
          }
          const u = [];
          for (const h in n) u.push(n[h]);
          return u;
        }, p.cG = Dt, p.cH = Lv, p.cI = Ov, p.cJ = pv, p.cK = function(o) {
          o.bucket.createArrays(), o.bucket.tilePixelRatio = nt / (512 * o.bucket.overscaling), o.bucket.compareText = {}, o.bucket.iconsNeedLinear = false;
          const t = o.bucket.layers[0], n = t.layout, u = t._unevaluatedLayout._values, h = { layoutIconSize: u["icon-size"].possiblyEvaluate(new Yr(o.bucket.zoom + 1), o.canonical), layoutTextSize: u["text-size"].possiblyEvaluate(new Yr(o.bucket.zoom + 1), o.canonical), textMaxSize: u["text-size"].possiblyEvaluate(new Yr(18)) };
          if (o.bucket.textSizeData.kind === "composite") {
            const { minZoom: I, maxZoom: E } = o.bucket.textSizeData;
            h.compositeTextSizes = [u["text-size"].possiblyEvaluate(new Yr(I), o.canonical), u["text-size"].possiblyEvaluate(new Yr(E), o.canonical)];
          }
          if (o.bucket.iconSizeData.kind === "composite") {
            const { minZoom: I, maxZoom: E } = o.bucket.iconSizeData;
            h.compositeIconSizes = [u["icon-size"].possiblyEvaluate(new Yr(I), o.canonical), u["icon-size"].possiblyEvaluate(new Yr(E), o.canonical)];
          }
          const y = n.get("text-line-height") * Wi, b = n.get("text-rotation-alignment") !== "viewport" && n.get("symbol-placement") !== "point", w = n.get("text-keep-upright"), S = n.get("text-size");
          for (const I of o.bucket.features) {
            const E = n.get("text-font").evaluate(I, {}, o.canonical).join(","), O = S.evaluate(I, {}, o.canonical), V = h.layoutTextSize.evaluate(I, {}, o.canonical), U = h.layoutIconSize.evaluate(I, {}, o.canonical), W = { horizontal: {}, vertical: void 0 }, ee = I.text;
            let se, pe = [0, 0];
            if (ee) {
              const Me = ee.toString(), Xe = n.get("text-letter-spacing").evaluate(I, {}, o.canonical) * Wi, it = nd(Me) ? Xe : 0, _t = n.get("text-anchor").evaluate(I, {}, o.canonical), At = Xv(t, I, o.canonical);
              if (!At) {
                const Mt = n.get("text-radial-offset").evaluate(I, {}, o.canonical);
                pe = Mt ? Hv(_t, [Mt * Wi, Fm]) : n.get("text-offset").evaluate(I, {}, o.canonical).map(((Rt) => Rt * Wi));
              }
              let It = b ? "center" : n.get("text-justify").evaluate(I, {}, o.canonical);
              const Et = n.get("symbol-placement") === "point" ? n.get("text-max-width").evaluate(I, {}, o.canonical) * Wi : 1 / 0, Yt = () => {
                o.bucket.allowVerticalPlacement && id(Me) && (W.vertical = Tf(ee, o.glyphMap, o.glyphPositions, o.imagePositions, E, Et, y, _t, "left", it, pe, p.as.vertical, true, V, O));
              };
              if (!b && At) {
                const Mt = /* @__PURE__ */ new Set();
                if (It === "auto") for (let lt = 0; lt < At.values.length; lt += 2) Mt.add(Lm(At.values[lt]));
                else Mt.add(It);
                let Rt = false;
                for (const lt of Mt) if (!W.horizontal[lt]) if (Rt) W.horizontal[lt] = W.horizontal[0];
                else {
                  const sr = Tf(ee, o.glyphMap, o.glyphPositions, o.imagePositions, E, Et, y, "center", lt, it, pe, p.as.horizontal, false, V, O);
                  sr && (W.horizontal[lt] = sr, Rt = sr.positionedLines.length === 1);
                }
                Yt();
              } else {
                It === "auto" && (It = Lm(_t));
                const Mt = Tf(ee, o.glyphMap, o.glyphPositions, o.imagePositions, E, Et, y, _t, It, it, pe, p.as.horizontal, false, V, O);
                Mt && (W.horizontal[It] = Mt), Yt(), id(Me) && b && w && (W.vertical = Tf(ee, o.glyphMap, o.glyphPositions, o.imagePositions, E, Et, y, _t, It, it, pe, p.as.vertical, false, V, O));
              }
            }
            let je = false;
            if (I.icon && I.icon.name) {
              const Me = o.imageMap[I.icon.name];
              Me && (se = O2(o.imagePositions[I.icon.name], n.get("icon-offset").evaluate(I, {}, o.canonical), n.get("icon-anchor").evaluate(I, {}, o.canonical)), je = !!Me.sdf, o.bucket.sdfIcons === void 0 ? o.bucket.sdfIcons = je : o.bucket.sdfIcons !== je && Xt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Me.pixelRatio !== o.bucket.pixelRatio || n.get("icon-rotate").constantOr(1) !== 0) && (o.bucket.iconsNeedLinear = true));
            }
            const be = Kv(W.horizontal) || W.vertical;
            o.bucket.iconsInText = !!be && be.iconsInText, (be || se) && J2(o.bucket, I, W, se, o.imageMap, h, V, U, pe, je, o.canonical, o.subdivisionGranularity);
          }
          o.showCollisionBoxes && o.bucket.generateCollisionDebugBuffers();
        }, p.cL = ym, p.cM = xm, p.cN = wm, p.cO = ev, p.cP = Sm, p.cQ = class {
          constructor(o) {
            this._marks = { start: [o.url, "start"].join("#"), end: [o.url, "end"].join("#"), measure: o.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let o = performance.getEntriesByName(this._marks.measure);
            return o.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), o = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), o;
          }
        }, p.cR = function(o, t, n, u, h) {
          return s(this, void 0, void 0, (function* () {
            if (q()) try {
              return yield Je(o, t, n, u, h);
            } catch {
            }
            return (function(y, b, w, S, I) {
              const E = y.width, O = y.height;
              ht && bt || (ht = new OffscreenCanvas(E, O), bt = ht.getContext("2d", { willReadFrequently: true })), ht.width = E, ht.height = O, bt.drawImage(y, 0, 0, E, O);
              const V = bt.getImageData(b, w, S, I);
              return bt.clearRect(0, 0, E, O), V.data;
            })(o, t, n, u, h);
          }));
        }, p.cS = V0, p.cT = P, p.cU = Q0, p.cV = $u, p.cW = Oa, p.cX = function(o, t) {
          const n = /* @__PURE__ */ new Map();
          if (o != null) if (o.type === "Feature") n.set(Md(o, t), o);
          else for (const u of o.features) n.set(Md(u, t), u);
          return n;
        }, p.cY = function(o, t) {
          if (o == null) return true;
          if (o.type === "Feature") return Md(o, t) != null;
          if (o.type === "FeatureCollection") {
            const n = /* @__PURE__ */ new Set();
            for (const u of o.features) {
              const h = Md(u, t);
              if (h == null || n.has(h)) return false;
              n.add(h);
            }
            return true;
          }
          return false;
        }, p.cZ = function(o, t, n) {
          var u, h, y, b;
          if (t.removeAll && o.clear(), t.remove) for (const w of t.remove) o.delete(w);
          if (t.add) for (const w of t.add) {
            const S = Md(w, n);
            S != null && o.set(S, w);
          }
          if (t.update) for (const w of t.update) {
            let S = o.get(w.id);
            if (S == null) continue;
            const I = !w.removeAllProperties && (((u = w.removeProperties) === null || u === void 0 ? void 0 : u.length) > 0 || ((h = w.addOrUpdateProperties) === null || h === void 0 ? void 0 : h.length) > 0);
            if ((w.newGeometry || w.removeAllProperties || I) && (S = Object.assign({}, S), o.set(w.id, S), I && (S.properties = Object.assign({}, S.properties))), w.newGeometry && (S.geometry = w.newGeometry), w.removeAllProperties) S.properties = {};
            else if (((y = w.removeProperties) === null || y === void 0 ? void 0 : y.length) > 0) for (const E of w.removeProperties) Object.prototype.hasOwnProperty.call(S.properties, E) && delete S.properties[E];
            if (((b = w.addOrUpdateProperties) === null || b === void 0 ? void 0 : b.length) > 0) for (const { key: E, value: O } of w.addOrUpdateProperties) S.properties[E] = O;
          }
        }, p.c_ = No, p.ca = class extends cd {
        }, p.cb = class extends m {
        }, p.cc = function(o, t) {
          return o[0] === t[0] && o[1] === t[1] && o[2] === t[2] && o[3] === t[3] && o[4] === t[4] && o[5] === t[5] && o[6] === t[6] && o[7] === t[7] && o[8] === t[8] && o[9] === t[9] && o[10] === t[10] && o[11] === t[11] && o[12] === t[12] && o[13] === t[13] && o[14] === t[14] && o[15] === t[15];
        }, p.cd = function(o, t) {
          var n = o[0], u = o[1], h = o[2], y = o[3], b = o[4], w = o[5], S = o[6], I = o[7], E = o[8], O = o[9], V = o[10], U = o[11], W = o[12], ee = o[13], se = o[14], pe = o[15], je = t[0], be = t[1], Me = t[2], Xe = t[3], it = t[4], _t = t[5], At = t[6], It = t[7], Et = t[8], Yt = t[9], Mt = t[10], Rt = t[11], lt = t[12], sr = t[13], cr = t[14], Qt = t[15];
          return Math.abs(n - je) <= K * Math.max(1, Math.abs(n), Math.abs(je)) && Math.abs(u - be) <= K * Math.max(1, Math.abs(u), Math.abs(be)) && Math.abs(h - Me) <= K * Math.max(1, Math.abs(h), Math.abs(Me)) && Math.abs(y - Xe) <= K * Math.max(1, Math.abs(y), Math.abs(Xe)) && Math.abs(b - it) <= K * Math.max(1, Math.abs(b), Math.abs(it)) && Math.abs(w - _t) <= K * Math.max(1, Math.abs(w), Math.abs(_t)) && Math.abs(S - At) <= K * Math.max(1, Math.abs(S), Math.abs(At)) && Math.abs(I - It) <= K * Math.max(1, Math.abs(I), Math.abs(It)) && Math.abs(E - Et) <= K * Math.max(1, Math.abs(E), Math.abs(Et)) && Math.abs(O - Yt) <= K * Math.max(1, Math.abs(O), Math.abs(Yt)) && Math.abs(V - Mt) <= K * Math.max(1, Math.abs(V), Math.abs(Mt)) && Math.abs(U - Rt) <= K * Math.max(1, Math.abs(U), Math.abs(Rt)) && Math.abs(W - lt) <= K * Math.max(1, Math.abs(W), Math.abs(lt)) && Math.abs(ee - sr) <= K * Math.max(1, Math.abs(ee), Math.abs(sr)) && Math.abs(se - cr) <= K * Math.max(1, Math.abs(se), Math.abs(cr)) && Math.abs(pe - Qt) <= K * Math.max(1, Math.abs(pe), Math.abs(Qt));
        }, p.ce = function(o, t) {
          return o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7], o[8] = t[8], o[9] = t[9], o[10] = t[10], o[11] = t[11], o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15], o;
        }, p.cf = (o) => o.type === "symbol", p.cg = (o) => o.type === "circle", p.ch = (o) => o.type === "heatmap", p.ci = (o) => o.type === "line", p.cj = (o) => o.type === "fill", p.ck = (o) => o.type === "fill-extrusion", p.cl = (o) => o.type === "hillshade", p.cm = (o) => o.type === "color-relief", p.cn = (o) => o.type === "background", p.co = (o) => o.type === "custom", p.cp = Ft, p.cq = function(o, t, n) {
          const u = st(t.x - n.x, t.y - n.y), h = st(o.x - n.x, o.y - n.y);
          var y, b;
          return Wt(Math.atan2(u[0] * h[1] - u[1] * h[0], (y = u)[0] * (b = h)[0] + y[1] * b[1]));
        }, p.cr = tr, p.cs = function(o, t) {
          return Ai[t] && (o instanceof MouseEvent || o instanceof WheelEvent);
        }, p.ct = function(o, t) {
          return ci[t] && "touches" in o;
        }, p.cu = function(o) {
          return ci[o] || Ai[o];
        }, p.cv = function(o, t, n) {
          var u = t[0], h = t[1];
          return o[0] = n[0] * u + n[4] * h + n[12], o[1] = n[1] * u + n[5] * h + n[13], o;
        }, p.cw = function(o, t) {
          const { x: n, y: u } = Id.fromLngLat(t);
          return !(o < 0 || o > 25 || u < 0 || u >= 1 || n < 0 || n >= 1);
        }, p.cx = function(o, t) {
          return o[0] = t[0], o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = t[1], o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = t[2], o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, o;
        }, p.cy = class extends Pu {
        }, p.cz = ew, p.d = Pe, p.e = Zt, p.f = (o) => s(void 0, void 0, void 0, (function* () {
          if (o.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const t = new Blob([new Uint8Array(o)], { type: "image/png" });
          try {
            return createImageBitmap(t);
          } catch (n) {
            throw new Error(`Could not load image because of ${n.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
          }
        })), p.g = Y, p.h = (o) => new Promise(((t, n) => {
          const u = new Image();
          u.onload = () => {
            t(u), URL.revokeObjectURL(u.src), u.onload = null, window.requestAnimationFrame((() => {
              u.src = Oe;
            }));
          }, u.onerror = () => n(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const h = new Blob([new Uint8Array(o)], { type: "image/png" });
          u.src = o.byteLength ? URL.createObjectURL(h) : Oe;
        })), p.i = nr, p.j = (o, t) => ae(Zt(o, { type: "json" }), t), p.k = We, p.l = et, p.m = ae, p.n = (o, t) => ae(Zt(o, { type: "arrayBuffer" }), t), p.o = function(o) {
          return new Sm(o).readFields(T2, []);
        }, p.p = fv, p.q = vd, p.r = dn, p.s = rt, p.t = Le, p.u = wr, p.v = Qh, p.w = Xt, p.x = df, p.y = im, p.z = tf;
      })), f("worker", ["./shared"], (function(p) {
        class s {
          constructor(X, Y) {
            this.keyCache = {}, X && this.replace(X, Y);
          }
          replace(X, Y) {
            this._layerConfigs = {}, this._layers = {}, this.update(X, [], Y);
          }
          update(X, Y, ne) {
            for (const Ce of X) {
              this._layerConfigs[Ce.id] = Ce;
              const ae = this._layers[Ce.id] = p.bM(Ce, ne);
              ae._featureFilter = p.ae(ae.filter, ne), this.keyCache[Ce.id] && delete this.keyCache[Ce.id];
            }
            for (const Ce of Y) delete this.keyCache[Ce], delete this._layerConfigs[Ce], delete this._layers[Ce];
            this.familiesBySource = {};
            const ve = p.cF(Object.values(this._layerConfigs), this.keyCache);
            for (const Ce of ve) {
              const ae = Ce.map(((xt) => this._layers[xt.id])), Pe = ae[0];
              if (Pe.visibility === "none") continue;
              const xe = Pe.source || "";
              let Ve = this.familiesBySource[xe];
              Ve || (Ve = this.familiesBySource[xe] = {});
              const et = Pe.sourceLayer || "_geojsonTileLayer";
              let We = Ve[et];
              We || (We = Ve[et] = []), We.push(ae);
            }
          }
        }
        class C {
          constructor(X) {
            const Y = {}, ne = [];
            for (const Pe in X) {
              const xe = X[Pe], Ve = Y[Pe] = {};
              for (const et in xe) {
                const We = xe[+et];
                if (!We || We.bitmap.width === 0 || We.bitmap.height === 0) continue;
                const xt = { x: 0, y: 0, w: We.bitmap.width + 2, h: We.bitmap.height + 2 };
                ne.push(xt), Ve[et] = { rect: xt, metrics: We.metrics };
              }
            }
            const { w: ve, h: Ce } = p.p(ne), ae = new p.q({ width: ve || 1, height: Ce || 1 });
            for (const Pe in X) {
              const xe = X[Pe];
              for (const Ve in xe) {
                const et = xe[+Ve];
                if (!et || et.bitmap.width === 0 || et.bitmap.height === 0) continue;
                const We = Y[Pe][Ve].rect;
                p.q.copy(et.bitmap, ae, { x: 0, y: 0 }, { x: We.x + 1, y: We.y + 1 }, et.bitmap);
              }
            }
            this.image = ae, this.positions = Y;
          }
        }
        p.cG("GlyphAtlas", C);
        class P {
          constructor(X) {
            this.tileID = new p.a0(X.tileID.overscaledZ, X.tileID.wrap, X.tileID.canonical.z, X.tileID.canonical.x, X.tileID.canonical.y), this.uid = X.uid, this.zoom = X.zoom, this.pixelRatio = X.pixelRatio, this.tileSize = X.tileSize, this.source = X.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = X.showCollisionBoxes, this.collectResourceTiming = !!X.collectResourceTiming, this.returnDependencies = !!X.returnDependencies, this.promoteId = X.promoteId, this.inFlightDependencies = [];
          }
          parse(X, Y, ne, ve, Ce) {
            return p._(this, void 0, void 0, (function* () {
              this.status = "parsing", this.data = X, this.collisionBoxArray = new p.ac();
              const ae = new p.cH(Object.keys(X.layers).sort()), Pe = new p.cI(this.tileID, this.promoteId);
              Pe.bucketLayerIDs = [];
              const xe = {}, Ve = { featureIndex: Pe, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, dashDependencies: {}, availableImages: ne, subdivisionGranularity: Ce }, et = Y.familiesBySource[this.source];
              for (const Te in et) {
                const jt = X.layers[Te];
                if (!jt) continue;
                jt.version === 1 && p.w(`Vector tile source "${this.source}" layer "${Te}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const _r = ae.encode(Te), Nr = [];
                for (let mr = 0; mr < jt.length; mr++) {
                  const Ct = jt.feature(mr), ar = Pe.getId(Ct, Te);
                  Nr.push({ feature: Ct, id: ar, index: mr, sourceLayerIndex: _r });
                }
                for (const mr of et[Te]) {
                  const Ct = mr[0];
                  Ct.source !== this.source && p.w(`layer.source = ${Ct.source} does not equal this.source = ${this.source}`), Ct.isHidden(this.zoom, true) || (M(mr, this.zoom, ne), (xe[Ct.id] = Ct.createBucket({ index: Pe.bucketLayerIDs.length, layers: mr, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: _r, sourceID: this.source })).populate(Nr, Ve, this.tileID.canonical), Pe.bucketLayerIDs.push(mr.map(((ar) => ar.id))));
                }
              }
              const We = p.bR(Ve.glyphDependencies, ((Te) => Object.keys(Te).map(Number)));
              this.inFlightDependencies.forEach(((Te) => Te == null ? void 0 : Te.abort())), this.inFlightDependencies = [];
              let xt = Promise.resolve({});
              if (Object.keys(We).length) {
                const Te = new AbortController();
                this.inFlightDependencies.push(Te), xt = ve.sendAsync({ type: "GG", data: { stacks: We, source: this.source, tileID: this.tileID, type: "glyphs" } }, Te);
              }
              const Le = Object.keys(Ve.iconDependencies);
              let rr = Promise.resolve({});
              if (Le.length) {
                const Te = new AbortController();
                this.inFlightDependencies.push(Te), rr = ve.sendAsync({ type: "GI", data: { icons: Le, source: this.source, tileID: this.tileID, type: "icons" } }, Te);
              }
              const Zr = Object.keys(Ve.patternDependencies);
              let Ut = Promise.resolve({});
              if (Zr.length) {
                const Te = new AbortController();
                this.inFlightDependencies.push(Te), Ut = ve.sendAsync({ type: "GI", data: { icons: Zr, source: this.source, tileID: this.tileID, type: "patterns" } }, Te);
              }
              const dr = Ve.dashDependencies;
              let Er = Promise.resolve({});
              if (Object.keys(dr).length) {
                const Te = new AbortController();
                this.inFlightDependencies.push(Te), Er = ve.sendAsync({ type: "GDA", data: { dashes: dr } }, Te);
              }
              const [jr, di, Hr, Jr] = yield Promise.all([xt, rr, Ut, Er]), Lr = new C(jr), Ne = new p.cJ(di, Hr);
              for (const Te in xe) {
                const jt = xe[Te];
                jt instanceof p.ad ? (M(jt.layers, this.zoom, ne), p.cK({ bucket: jt, glyphMap: jr, glyphPositions: Lr.positions, imageMap: di, imagePositions: Ne.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: Ve.subdivisionGranularity })) : jt.hasDependencies && (jt instanceof p.cL || jt instanceof p.cM || jt instanceof p.cN) && (M(jt.layers, this.zoom, ne), jt.addFeatures(Ve, this.tileID.canonical, Ne.patternPositions, Jr));
              }
              return this.status = "done", { buckets: Object.values(xe).filter(((Te) => !Te.isEmpty())), featureIndex: Pe, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Lr.image, imageAtlas: Ne, dashPositions: Jr, glyphMap: this.returnDependencies ? jr : null, iconMap: this.returnDependencies ? di : null, glyphPositions: this.returnDependencies ? Lr.positions : null };
            }));
          }
        }
        function M(Fe, X, Y) {
          const ne = new p.G(X);
          for (const ve of Fe) ve.recalculate(ne, Y);
        }
        class D {
          constructor(X, Y, ne) {
            this.actor = X, this.layerIndex = Y, this.availableImages = ne, this.fetching = {}, this.loading = {}, this.loaded = {};
          }
          loadVectorTile(X, Y) {
            return p._(this, void 0, void 0, (function* () {
              const ne = yield p.n(X.request, Y);
              try {
                return { vectorTile: new p.cO(new p.cP(ne.data)), rawData: ne.data, cacheControl: ne.cacheControl, expires: ne.expires };
              } catch (ve) {
                const Ce = new Uint8Array(ne.data);
                let ae = `Unable to parse the tile at ${X.request.url}, `;
                throw ae += Ce[0] === 31 && Ce[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${ve.message}`, new Error(ae);
              }
            }));
          }
          loadTile(X) {
            return p._(this, void 0, void 0, (function* () {
              const Y = X.uid, ne = !!(X && X.request && X.request.collectResourceTiming) && new p.cQ(X.request), ve = new P(X);
              this.loading[Y] = ve;
              const Ce = new AbortController();
              ve.abort = Ce;
              try {
                const ae = yield this.loadVectorTile(X, Ce);
                if (delete this.loading[Y], !ae) return null;
                const Pe = ae.rawData, xe = {};
                ae.expires && (xe.expires = ae.expires), ae.cacheControl && (xe.cacheControl = ae.cacheControl);
                const Ve = {};
                if (ne) {
                  const We = ne.finish();
                  We && (Ve.resourceTiming = JSON.parse(JSON.stringify(We)));
                }
                ve.vectorTile = ae.vectorTile;
                const et = ve.parse(ae.vectorTile, this.layerIndex, this.availableImages, this.actor, X.subdivisionGranularity);
                this.loaded[Y] = ve, this.fetching[Y] = { rawTileData: Pe, cacheControl: xe, resourceTiming: Ve };
                try {
                  const We = yield et;
                  return p.e({ rawTileData: Pe.slice(0) }, We, xe, Ve);
                } finally {
                  delete this.fetching[Y];
                }
              } catch (ae) {
                throw delete this.loading[Y], ve.status = "done", this.loaded[Y] = ve, ae;
              }
            }));
          }
          reloadTile(X) {
            return p._(this, void 0, void 0, (function* () {
              const Y = X.uid;
              if (!this.loaded || !this.loaded[Y]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const ne = this.loaded[Y];
              if (ne.showCollisionBoxes = X.showCollisionBoxes, ne.status === "parsing") {
                const ve = yield ne.parse(ne.vectorTile, this.layerIndex, this.availableImages, this.actor, X.subdivisionGranularity);
                let Ce;
                if (this.fetching[Y]) {
                  const { rawTileData: ae, cacheControl: Pe, resourceTiming: xe } = this.fetching[Y];
                  delete this.fetching[Y], Ce = p.e({ rawTileData: ae.slice(0) }, ve, Pe, xe);
                } else Ce = ve;
                return Ce;
              }
              if (ne.status === "done" && ne.vectorTile) return ne.parse(ne.vectorTile, this.layerIndex, this.availableImages, this.actor, X.subdivisionGranularity);
            }));
          }
          abortTile(X) {
            return p._(this, void 0, void 0, (function* () {
              const Y = this.loading, ne = X.uid;
              Y && Y[ne] && Y[ne].abort && (Y[ne].abort.abort(), delete Y[ne]);
            }));
          }
          removeTile(X) {
            return p._(this, void 0, void 0, (function* () {
              this.loaded && this.loaded[X.uid] && delete this.loaded[X.uid];
            }));
          }
        }
        class L {
          constructor() {
            this.loaded = {};
          }
          loadTile(X) {
            return p._(this, void 0, void 0, (function* () {
              const { uid: Y, encoding: ne, rawImageData: ve, redFactor: Ce, greenFactor: ae, blueFactor: Pe, baseShift: xe } = X, Ve = ve.width + 2, et = ve.height + 2, We = p.b(ve) ? new p.R({ width: Ve, height: et }, yield p.cR(ve, -1, -1, Ve, et)) : ve, xt = new p.cS(Y, We, ne, Ce, ae, Pe, xe);
              return this.loaded = this.loaded || {}, this.loaded[Y] = xt, xt;
            }));
          }
          removeTile(X) {
            const Y = this.loaded, ne = X.uid;
            Y && Y[ne] && delete Y[ne];
          }
        }
        var $, z, F = (function() {
          if (z) return $;
          function Fe(Y, ne) {
            if (Y.length !== 0) {
              X(Y[0], ne);
              for (var ve = 1; ve < Y.length; ve++) X(Y[ve], !ne);
            }
          }
          function X(Y, ne) {
            for (var ve = 0, Ce = 0, ae = 0, Pe = Y.length, xe = Pe - 1; ae < Pe; xe = ae++) {
              var Ve = (Y[ae][0] - Y[xe][0]) * (Y[xe][1] + Y[ae][1]), et = ve + Ve;
              Ce += Math.abs(ve) >= Math.abs(Ve) ? ve - et + Ve : Ve - et + ve, ve = et;
            }
            ve + Ce >= 0 != !!ne && Y.reverse();
          }
          return z = 1, $ = function Y(ne, ve) {
            var Ce, ae = ne && ne.type;
            if (ae === "FeatureCollection") for (Ce = 0; Ce < ne.features.length; Ce++) Y(ne.features[Ce], ve);
            else if (ae === "GeometryCollection") for (Ce = 0; Ce < ne.geometries.length; Ce++) Y(ne.geometries[Ce], ve);
            else if (ae === "Feature") Y(ne.geometry, ve);
            else if (ae === "Polygon") Fe(ne.coordinates, ve);
            else if (ae === "MultiPolygon") for (Ce = 0; Ce < ne.coordinates.length; Ce++) Fe(ne.coordinates[Ce], ve);
            return ne;
          };
        })(), Z = p.cT(F);
        class q extends p.cV {
          constructor(X, Y) {
            super(new p.cP(), 0, Y, [], []), this.feature = X, this.type = X.type, this.properties = X.tags ? X.tags : {}, "id" in X && (typeof X.id == "string" ? this.id = parseInt(X.id, 10) : typeof X.id != "number" || isNaN(X.id) || (this.id = X.id));
          }
          loadGeometry() {
            const X = [], Y = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const ne of Y) {
              const ve = [];
              for (const Ce of ne) ve.push(new p.P(Ce[0], Ce[1]));
              X.push(ve);
            }
            return X;
          }
        }
        class K extends p.cU {
          constructor(X, Y) {
            super(new p.cP()), this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.version = Y ? Y.version : 1, this.extent = Y ? Y.extent : 4096, this.length = X.length, this.features = X;
          }
          feature(X) {
            return new q(this.features[X], this.extent);
          }
        }
        function te(Fe, X) {
          X.writeVarintField(15, Fe.version || 1), X.writeStringField(1, Fe.name || ""), X.writeVarintField(5, Fe.extent || 4096);
          const Y = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (let Ce = 0; Ce < Fe.length; Ce++) Y.feature = Fe.feature(Ce), X.writeMessage(2, re, Y);
          const ne = Y.keys;
          for (const Ce of ne) X.writeStringField(3, Ce);
          const ve = Y.values;
          for (const Ce of ve) X.writeMessage(4, oe, Ce);
        }
        function re(Fe, X) {
          if (!Fe.feature) return;
          const Y = Fe.feature;
          Y.id !== void 0 && X.writeVarintField(1, Y.id), X.writeMessage(2, ie, Fe), X.writeVarintField(3, Y.type), X.writeMessage(4, fe, Y);
        }
        function ie(Fe, X) {
          var _a3;
          for (const Y in (_a3 = Fe.feature) == null ? void 0 : _a3.properties) {
            let ne = Fe.feature.properties[Y], ve = Fe.keycache[Y];
            if (ne === null) continue;
            ve === void 0 && (Fe.keys.push(Y), ve = Fe.keys.length - 1, Fe.keycache[Y] = ve), X.writeVarint(ve), typeof ne != "string" && typeof ne != "boolean" && typeof ne != "number" && (ne = JSON.stringify(ne));
            const Ce = typeof ne + ":" + ne;
            let ae = Fe.valuecache[Ce];
            ae === void 0 && (Fe.values.push(ne), ae = Fe.values.length - 1, Fe.valuecache[Ce] = ae), X.writeVarint(ae);
          }
        }
        function J(Fe, X) {
          return (X << 3) + (7 & Fe);
        }
        function we(Fe) {
          return Fe << 1 ^ Fe >> 31;
        }
        function fe(Fe, X) {
          const Y = Fe.loadGeometry(), ne = Fe.type;
          let ve = 0, Ce = 0;
          for (const ae of Y) {
            let Pe = 1;
            ne === 1 && (Pe = ae.length), X.writeVarint(J(1, Pe));
            const xe = ne === 3 ? ae.length - 1 : ae.length;
            for (let Ve = 0; Ve < xe; Ve++) {
              Ve === 1 && ne !== 1 && X.writeVarint(J(2, xe - 1));
              const et = ae[Ve].x - ve, We = ae[Ve].y - Ce;
              X.writeVarint(we(et)), X.writeVarint(we(We)), ve += et, Ce += We;
            }
            Fe.type === 3 && X.writeVarint(J(7, 1));
          }
        }
        function oe(Fe, X) {
          const Y = typeof Fe;
          Y === "string" ? X.writeStringField(1, Fe) : Y === "boolean" ? X.writeBooleanField(7, Fe) : Y === "number" && (Fe % 1 != 0 ? X.writeDoubleField(3, Fe) : Fe < 0 ? X.writeSVarintField(6, Fe) : X.writeVarintField(5, Fe));
        }
        const he = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (Fe) => Fe }, _e = Math.fround || (Ue = new Float32Array(1), (Fe) => (Ue[0] = +Fe, Ue[0]));
        var Ue;
        class qe {
          constructor(X) {
            this.options = Object.assign(Object.create(he), X), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(X) {
            const { log: Y, minZoom: ne, maxZoom: ve } = this.options;
            Y && console.time("total time");
            const Ce = `prepare ${X.length} points`;
            Y && console.time(Ce), this.points = X;
            const ae = [];
            for (let xe = 0; xe < X.length; xe++) {
              const Ve = X[xe];
              if (!Ve.geometry) continue;
              const [et, We] = Ve.geometry.coordinates, xt = _e(mt(et)), Le = _e(St(We));
              ae.push(xt, Le, 1 / 0, xe, -1, 1), this.options.reduce && ae.push(0);
            }
            let Pe = this.trees[ve + 1] = this._createTree(ae);
            Y && console.timeEnd(Ce);
            for (let xe = ve; xe >= ne; xe--) {
              const Ve = +Date.now();
              Pe = this.trees[xe] = this._createTree(this._cluster(Pe, xe)), Y && console.log("z%d: %d clusters in %dms", xe, Pe.numItems, +Date.now() - Ve);
            }
            return Y && console.timeEnd("total time"), this;
          }
          getClusters(X, Y) {
            let ne = ((X[0] + 180) % 360 + 360) % 360 - 180;
            const ve = Math.max(-90, Math.min(90, X[1]));
            let Ce = X[2] === 180 ? 180 : ((X[2] + 180) % 360 + 360) % 360 - 180;
            const ae = Math.max(-90, Math.min(90, X[3]));
            if (X[2] - X[0] >= 360) ne = -180, Ce = 180;
            else if (ne > Ce) {
              const We = this.getClusters([ne, ve, 180, ae], Y), xt = this.getClusters([-180, ve, Ce, ae], Y);
              return We.concat(xt);
            }
            const Pe = this.trees[this._limitZoom(Y)], xe = Pe.range(mt(ne), St(ae), mt(Ce), St(ve)), Ve = Pe.data, et = [];
            for (const We of xe) {
              const xt = this.stride * We;
              et.push(Ve[xt + 5] > 1 ? tt(Ve, xt, this.clusterProps) : this.points[Ve[xt + 3]]);
            }
            return et;
          }
          getChildren(X) {
            const Y = this._getOriginId(X), ne = this._getOriginZoom(X), ve = "No cluster with the specified id.", Ce = this.trees[ne];
            if (!Ce) throw new Error(ve);
            const ae = Ce.data;
            if (Y * this.stride >= ae.length) throw new Error(ve);
            const Pe = this.options.radius / (this.options.extent * Math.pow(2, ne - 1)), xe = Ce.within(ae[Y * this.stride], ae[Y * this.stride + 1], Pe), Ve = [];
            for (const et of xe) {
              const We = et * this.stride;
              ae[We + 4] === X && Ve.push(ae[We + 5] > 1 ? tt(ae, We, this.clusterProps) : this.points[ae[We + 3]]);
            }
            if (Ve.length === 0) throw new Error(ve);
            return Ve;
          }
          getLeaves(X, Y, ne) {
            const ve = [];
            return this._appendLeaves(ve, X, Y = Y || 10, ne = ne || 0, 0), ve;
          }
          getTile(X, Y, ne) {
            const ve = this.trees[this._limitZoom(X)], Ce = Math.pow(2, X), { extent: ae, radius: Pe } = this.options, xe = Pe / ae, Ve = (ne - xe) / Ce, et = (ne + 1 + xe) / Ce, We = { features: [] };
            return this._addTileFeatures(ve.range((Y - xe) / Ce, Ve, (Y + 1 + xe) / Ce, et), ve.data, Y, ne, Ce, We), Y === 0 && this._addTileFeatures(ve.range(1 - xe / Ce, Ve, 1, et), ve.data, Ce, ne, Ce, We), Y === Ce - 1 && this._addTileFeatures(ve.range(0, Ve, xe / Ce, et), ve.data, -1, ne, Ce, We), We.features.length ? We : null;
          }
          getClusterExpansionZoom(X) {
            let Y = this._getOriginZoom(X) - 1;
            for (; Y <= this.options.maxZoom; ) {
              const ne = this.getChildren(X);
              if (Y++, ne.length !== 1) break;
              X = ne[0].properties.cluster_id;
            }
            return Y;
          }
          _appendLeaves(X, Y, ne, ve, Ce) {
            const ae = this.getChildren(Y);
            for (const Pe of ae) {
              const xe = Pe.properties;
              if (xe && xe.cluster ? Ce + xe.point_count <= ve ? Ce += xe.point_count : Ce = this._appendLeaves(X, xe.cluster_id, ne, ve, Ce) : Ce < ve ? Ce++ : X.push(Pe), X.length === ne) break;
            }
            return Ce;
          }
          _createTree(X) {
            const Y = new p.aM(X.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let ne = 0; ne < X.length; ne += this.stride) Y.add(X[ne], X[ne + 1]);
            return Y.finish(), Y.data = X, Y;
          }
          _addTileFeatures(X, Y, ne, ve, Ce, ae) {
            for (const Pe of X) {
              const xe = Pe * this.stride, Ve = Y[xe + 5] > 1;
              let et, We, xt;
              if (Ve) et = ut(Y, xe, this.clusterProps), We = Y[xe], xt = Y[xe + 1];
              else {
                const Zr = this.points[Y[xe + 3]];
                et = Zr.properties;
                const [Ut, dr] = Zr.geometry.coordinates;
                We = mt(Ut), xt = St(dr);
              }
              const Le = { type: 1, geometry: [[Math.round(this.options.extent * (We * Ce - ne)), Math.round(this.options.extent * (xt * Ce - ve))]], tags: et };
              let rr;
              rr = Ve || this.options.generateId ? Y[xe + 3] : this.points[Y[xe + 3]].id, rr !== void 0 && (Le.id = rr), ae.features.push(Le);
            }
          }
          _limitZoom(X) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+X), this.options.maxZoom + 1));
          }
          _cluster(X, Y) {
            const { radius: ne, extent: ve, reduce: Ce, minPoints: ae } = this.options, Pe = ne / (ve * Math.pow(2, Y)), xe = X.data, Ve = [], et = this.stride;
            for (let We = 0; We < xe.length; We += et) {
              if (xe[We + 2] <= Y) continue;
              xe[We + 2] = Y;
              const xt = xe[We], Le = xe[We + 1], rr = X.within(xe[We], xe[We + 1], Pe), Zr = xe[We + 5];
              let Ut = Zr;
              for (const dr of rr) {
                const Er = dr * et;
                xe[Er + 2] > Y && (Ut += xe[Er + 5]);
              }
              if (Ut > Zr && Ut >= ae) {
                let dr, Er = xt * Zr, jr = Le * Zr, di = -1;
                const Hr = (We / et << 5) + (Y + 1) + this.points.length;
                for (const Jr of rr) {
                  const Lr = Jr * et;
                  if (xe[Lr + 2] <= Y) continue;
                  xe[Lr + 2] = Y;
                  const Ne = xe[Lr + 5];
                  Er += xe[Lr] * Ne, jr += xe[Lr + 1] * Ne, xe[Lr + 4] = Hr, Ce && (dr || (dr = this._map(xe, We, true), di = this.clusterProps.length, this.clusterProps.push(dr)), Ce(dr, this._map(xe, Lr)));
                }
                xe[We + 4] = Hr, Ve.push(Er / Ut, jr / Ut, 1 / 0, Hr, -1, Ut), Ce && Ve.push(di);
              } else {
                for (let dr = 0; dr < et; dr++) Ve.push(xe[We + dr]);
                if (Ut > 1) for (const dr of rr) {
                  const Er = dr * et;
                  if (!(xe[Er + 2] <= Y)) {
                    xe[Er + 2] = Y;
                    for (let jr = 0; jr < et; jr++) Ve.push(xe[Er + jr]);
                  }
                }
              }
            }
            return Ve;
          }
          _getOriginId(X) {
            return X - this.points.length >> 5;
          }
          _getOriginZoom(X) {
            return (X - this.points.length) % 32;
          }
          _map(X, Y, ne) {
            if (X[Y + 5] > 1) {
              const ae = this.clusterProps[X[Y + 6]];
              return ne ? Object.assign({}, ae) : ae;
            }
            const ve = this.points[X[Y + 3]].properties, Ce = this.options.map(ve);
            return ne && Ce === ve ? Object.assign({}, Ce) : Ce;
          }
        }
        function tt(Fe, X, Y) {
          return { type: "Feature", id: Fe[X + 3], properties: ut(Fe, X, Y), geometry: { type: "Point", coordinates: [(ne = Fe[X], 360 * (ne - 0.5)), st(Fe[X + 1])] } };
          var ne;
        }
        function ut(Fe, X, Y) {
          const ne = Fe[X + 5], ve = ne >= 1e4 ? `${Math.round(ne / 1e3)}k` : ne >= 1e3 ? Math.round(ne / 100) / 10 + "k" : ne, Ce = Fe[X + 6], ae = Ce === -1 ? {} : Object.assign({}, Y[Ce]);
          return Object.assign(ae, { cluster: true, cluster_id: Fe[X + 3], point_count: ne, point_count_abbreviated: ve });
        }
        function mt(Fe) {
          return Fe / 360 + 0.5;
        }
        function St(Fe) {
          const X = Math.sin(Fe * Math.PI / 180), Y = 0.5 - 0.25 * Math.log((1 + X) / (1 - X)) / Math.PI;
          return Y < 0 ? 0 : Y > 1 ? 1 : Y;
        }
        function st(Fe) {
          const X = (180 - 360 * Fe) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(X)) / Math.PI - 90;
        }
        function nt(Fe, X, Y, ne) {
          let ve = ne;
          const Ce = X + (Y - X >> 1);
          let ae, Pe = Y - X;
          const xe = Fe[X], Ve = Fe[X + 1], et = Fe[Y], We = Fe[Y + 1];
          for (let xt = X + 3; xt < Y; xt += 3) {
            const Le = ft(Fe[xt], Fe[xt + 1], xe, Ve, et, We);
            if (Le > ve) ae = xt, ve = Le;
            else if (Le === ve) {
              const rr = Math.abs(xt - Ce);
              rr < Pe && (ae = xt, Pe = rr);
            }
          }
          ve > ne && (ae - X > 3 && nt(Fe, X, ae, ne), Fe[ae + 2] = ve, Y - ae > 3 && nt(Fe, ae, Y, ne));
        }
        function ft(Fe, X, Y, ne, ve, Ce) {
          let ae = ve - Y, Pe = Ce - ne;
          if (ae !== 0 || Pe !== 0) {
            const xe = ((Fe - Y) * ae + (X - ne) * Pe) / (ae * ae + Pe * Pe);
            xe > 1 ? (Y = ve, ne = Ce) : xe > 0 && (Y += ae * xe, ne += Pe * xe);
          }
          return ae = Fe - Y, Pe = X - ne, ae * ae + Pe * Pe;
        }
        function Lt(Fe, X, Y, ne) {
          const ve = { id: Fe ?? null, type: X, geometry: Y, tags: ne, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if (X === "Point" || X === "MultiPoint" || X === "LineString") pt(ve, Y);
          else if (X === "Polygon") pt(ve, Y[0]);
          else if (X === "MultiLineString") for (const Ce of Y) pt(ve, Ce);
          else if (X === "MultiPolygon") for (const Ce of Y) pt(ve, Ce[0]);
          return ve;
        }
        function pt(Fe, X) {
          for (let Y = 0; Y < X.length; Y += 3) Fe.minX = Math.min(Fe.minX, X[Y]), Fe.minY = Math.min(Fe.minY, X[Y + 1]), Fe.maxX = Math.max(Fe.maxX, X[Y]), Fe.maxY = Math.max(Fe.maxY, X[Y + 1]);
        }
        function wt(Fe, X, Y, ne) {
          if (!X.geometry) return;
          const ve = X.geometry.coordinates;
          if (ve && ve.length === 0) return;
          const Ce = X.geometry.type, ae = Math.pow(Y.tolerance / ((1 << Y.maxZoom) * Y.extent), 2);
          let Pe = [], xe = X.id;
          if (Y.promoteId ? xe = X.properties[Y.promoteId] : Y.generateId && (xe = ne || 0), Ce === "Point") Ft(ve, Pe);
          else if (Ce === "MultiPoint") for (const Ve of ve) Ft(Ve, Pe);
          else if (Ce === "LineString") tr(ve, Pe, ae, false);
          else if (Ce === "MultiLineString") {
            if (Y.lineMetrics) {
              for (const Ve of ve) Pe = [], tr(Ve, Pe, ae, false), Fe.push(Lt(xe, "LineString", Pe, X.properties));
              return;
            }
            gt(ve, Pe, ae, false);
          } else if (Ce === "Polygon") gt(ve, Pe, ae, true);
          else {
            if (Ce !== "MultiPolygon") {
              if (Ce === "GeometryCollection") {
                for (const Ve of X.geometry.geometries) wt(Fe, { id: xe, geometry: Ve, properties: X.properties }, Y, ne);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const Ve of ve) {
              const et = [];
              gt(Ve, et, ae, true), Pe.push(et);
            }
          }
          Fe.push(Lt(xe, Ce, Pe, X.properties));
        }
        function Ft(Fe, X) {
          X.push(Bt(Fe[0]), Zt(Fe[1]), 0);
        }
        function tr(Fe, X, Y, ne) {
          let ve, Ce, ae = 0;
          for (let xe = 0; xe < Fe.length; xe++) {
            const Ve = Bt(Fe[xe][0]), et = Zt(Fe[xe][1]);
            X.push(Ve, et, 0), xe > 0 && (ae += ne ? (ve * et - Ve * Ce) / 2 : Math.sqrt(Math.pow(Ve - ve, 2) + Math.pow(et - Ce, 2))), ve = Ve, Ce = et;
          }
          const Pe = X.length - 3;
          X[2] = 1, nt(X, 0, Pe, Y), X[Pe + 2] = 1, X.size = Math.abs(ae), X.start = 0, X.end = X.size;
        }
        function gt(Fe, X, Y, ne) {
          for (let ve = 0; ve < Fe.length; ve++) {
            const Ce = [];
            tr(Fe[ve], Ce, Y, ne), X.push(Ce);
          }
        }
        function Bt(Fe) {
          return Fe / 360 + 0.5;
        }
        function Zt(Fe) {
          const X = Math.sin(Fe * Math.PI / 180), Y = 0.5 - 0.25 * Math.log((1 + X) / (1 - X)) / Math.PI;
          return Y < 0 ? 0 : Y > 1 ? 1 : Y;
        }
        function ir(Fe, X, Y, ne, ve, Ce, ae, Pe) {
          if (ne /= X, Ce >= (Y /= X) && ae < ne) return Fe;
          if (ae < Y || Ce >= ne) return null;
          const xe = [];
          for (const Ve of Fe) {
            const et = Ve.geometry;
            let We = Ve.type;
            const xt = ve === 0 ? Ve.minX : Ve.minY, Le = ve === 0 ? Ve.maxX : Ve.maxY;
            if (xt >= Y && Le < ne) {
              xe.push(Ve);
              continue;
            }
            if (Le < Y || xt >= ne) continue;
            let rr = [];
            if (We === "Point" || We === "MultiPoint") Cr(et, rr, Y, ne, ve);
            else if (We === "LineString") Ar(et, rr, Y, ne, ve, false, Pe.lineMetrics);
            else if (We === "MultiLineString") Tr(et, rr, Y, ne, ve, false);
            else if (We === "Polygon") Tr(et, rr, Y, ne, ve, true);
            else if (We === "MultiPolygon") for (const Zr of et) {
              const Ut = [];
              Tr(Zr, Ut, Y, ne, ve, true), Ut.length && rr.push(Ut);
            }
            if (rr.length) {
              if (Pe.lineMetrics && We === "LineString") {
                for (const Zr of rr) xe.push(Lt(Ve.id, We, Zr, Ve.tags));
                continue;
              }
              We !== "LineString" && We !== "MultiLineString" || (rr.length === 1 ? (We = "LineString", rr = rr[0]) : We = "MultiLineString"), We !== "Point" && We !== "MultiPoint" || (We = rr.length === 3 ? "Point" : "MultiPoint"), xe.push(Lt(Ve.id, We, rr, Ve.tags));
            }
          }
          return xe.length ? xe : null;
        }
        function Cr(Fe, X, Y, ne, ve) {
          for (let Ce = 0; Ce < Fe.length; Ce += 3) {
            const ae = Fe[Ce + ve];
            ae >= Y && ae <= ne && Xt(X, Fe[Ce], Fe[Ce + 1], Fe[Ce + 2]);
          }
        }
        function Ar(Fe, X, Y, ne, ve, Ce, ae) {
          let Pe = or(Fe);
          const xe = ve === 0 ? Dr : nr;
          let Ve, et, We = Fe.start;
          for (let Ut = 0; Ut < Fe.length - 3; Ut += 3) {
            const dr = Fe[Ut], Er = Fe[Ut + 1], jr = Fe[Ut + 2], di = Fe[Ut + 3], Hr = Fe[Ut + 4], Jr = ve === 0 ? dr : Er, Lr = ve === 0 ? di : Hr;
            let Ne = false;
            ae && (Ve = Math.sqrt(Math.pow(dr - di, 2) + Math.pow(Er - Hr, 2))), Jr < Y ? Lr > Y && (et = xe(Pe, dr, Er, di, Hr, Y), ae && (Pe.start = We + Ve * et)) : Jr > ne ? Lr < ne && (et = xe(Pe, dr, Er, di, Hr, ne), ae && (Pe.start = We + Ve * et)) : Xt(Pe, dr, Er, jr), Lr < Y && Jr >= Y && (et = xe(Pe, dr, Er, di, Hr, Y), Ne = true), Lr > ne && Jr <= ne && (et = xe(Pe, dr, Er, di, Hr, ne), Ne = true), !Ce && Ne && (ae && (Pe.end = We + Ve * et), X.push(Pe), Pe = or(Fe)), ae && (We += Ve);
          }
          let xt = Fe.length - 3;
          const Le = Fe[xt], rr = Fe[xt + 1], Zr = ve === 0 ? Le : rr;
          Zr >= Y && Zr <= ne && Xt(Pe, Le, rr, Fe[xt + 2]), xt = Pe.length - 3, Ce && xt >= 3 && (Pe[xt] !== Pe[0] || Pe[xt + 1] !== Pe[1]) && Xt(Pe, Pe[0], Pe[1], Pe[2]), Pe.length && X.push(Pe);
        }
        function or(Fe) {
          const X = [];
          return X.size = Fe.size, X.start = Fe.start, X.end = Fe.end, X;
        }
        function Tr(Fe, X, Y, ne, ve, Ce) {
          for (const ae of Fe) Ar(ae, X, Y, ne, ve, Ce, false);
        }
        function Xt(Fe, X, Y, ne) {
          Fe.push(X, Y, ne);
        }
        function Dr(Fe, X, Y, ne, ve, Ce) {
          const ae = (Ce - X) / (ne - X);
          return Xt(Fe, Ce, Y + (ve - Y) * ae, 1), ae;
        }
        function nr(Fe, X, Y, ne, ve, Ce) {
          const ae = (Ce - Y) / (ve - Y);
          return Xt(Fe, X + (ne - X) * ae, Ce, 1), ae;
        }
        function kt(Fe, X) {
          const Y = [];
          for (let ne = 0; ne < Fe.length; ne++) {
            const ve = Fe[ne], Ce = ve.type;
            let ae;
            if (Ce === "Point" || Ce === "MultiPoint" || Ce === "LineString") ae = ze(ve.geometry, X);
            else if (Ce === "MultiLineString" || Ce === "Polygon") {
              ae = [];
              for (const Pe of ve.geometry) ae.push(ze(Pe, X));
            } else if (Ce === "MultiPolygon") {
              ae = [];
              for (const Pe of ve.geometry) {
                const xe = [];
                for (const Ve of Pe) xe.push(ze(Ve, X));
                ae.push(xe);
              }
            }
            Y.push(Lt(ve.id, Ce, ae, ve.tags));
          }
          return Y;
        }
        function ze(Fe, X) {
          const Y = [];
          Y.size = Fe.size, Fe.start !== void 0 && (Y.start = Fe.start, Y.end = Fe.end);
          for (let ne = 0; ne < Fe.length; ne += 3) Y.push(Fe[ne] + X, Fe[ne + 1], Fe[ne + 2]);
          return Y;
        }
        function at(Fe, X) {
          if (Fe.transformed) return Fe;
          const Y = 1 << Fe.z, ne = Fe.x, ve = Fe.y;
          for (const Ce of Fe.features) {
            const ae = Ce.geometry, Pe = Ce.type;
            if (Ce.geometry = [], Pe === 1) for (let xe = 0; xe < ae.length; xe += 2) Ce.geometry.push(Oe(ae[xe], ae[xe + 1], X, Y, ne, ve));
            else for (let xe = 0; xe < ae.length; xe++) {
              const Ve = [];
              for (let et = 0; et < ae[xe].length; et += 2) Ve.push(Oe(ae[xe][et], ae[xe][et + 1], X, Y, ne, ve));
              Ce.geometry.push(Ve);
            }
          }
          return Fe.transformed = true, Fe;
        }
        function Oe(Fe, X, Y, ne, ve, Ce) {
          return [Math.round(Y * (Fe * ne - ve)), Math.round(Y * (X * ne - Ce))];
        }
        function Je(Fe, X, Y, ne, ve) {
          const Ce = X === ve.maxZoom ? 0 : ve.tolerance / ((1 << X) * ve.extent), ae = { features: [], numPoints: 0, numSimplified: 0, numFeatures: Fe.length, source: null, x: Y, y: ne, z: X, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const Pe of Fe) ht(ae, Pe, Ce, ve);
          return ae;
        }
        function ht(Fe, X, Y, ne) {
          const ve = X.geometry, Ce = X.type, ae = [];
          if (Fe.minX = Math.min(Fe.minX, X.minX), Fe.minY = Math.min(Fe.minY, X.minY), Fe.maxX = Math.max(Fe.maxX, X.maxX), Fe.maxY = Math.max(Fe.maxY, X.maxY), Ce === "Point" || Ce === "MultiPoint") for (let Pe = 0; Pe < ve.length; Pe += 3) ae.push(ve[Pe], ve[Pe + 1]), Fe.numPoints++, Fe.numSimplified++;
          else if (Ce === "LineString") bt(ae, ve, Fe, Y, false, false);
          else if (Ce === "MultiLineString" || Ce === "Polygon") for (let Pe = 0; Pe < ve.length; Pe++) bt(ae, ve[Pe], Fe, Y, Ce === "Polygon", Pe === 0);
          else if (Ce === "MultiPolygon") for (let Pe = 0; Pe < ve.length; Pe++) {
            const xe = ve[Pe];
            for (let Ve = 0; Ve < xe.length; Ve++) bt(ae, xe[Ve], Fe, Y, true, Ve === 0);
          }
          if (ae.length) {
            let Pe = X.tags || null;
            if (Ce === "LineString" && ne.lineMetrics) {
              Pe = {};
              for (const Ve in X.tags) Pe[Ve] = X.tags[Ve];
              Pe.mapbox_clip_start = ve.start / ve.size, Pe.mapbox_clip_end = ve.end / ve.size;
            }
            const xe = { geometry: ae, type: Ce === "Polygon" || Ce === "MultiPolygon" ? 3 : Ce === "LineString" || Ce === "MultiLineString" ? 2 : 1, tags: Pe };
            X.id !== null && (xe.id = X.id), Fe.features.push(xe);
          }
        }
        function bt(Fe, X, Y, ne, ve, Ce) {
          const ae = ne * ne;
          if (ne > 0 && X.size < (ve ? ae : ne)) return void (Y.numPoints += X.length / 3);
          const Pe = [];
          for (let xe = 0; xe < X.length; xe += 3) (ne === 0 || X[xe + 2] > ae) && (Y.numSimplified++, Pe.push(X[xe], X[xe + 1])), Y.numPoints++;
          ve && (function(xe, Ve) {
            let et = 0;
            for (let We = 0, xt = xe.length, Le = xt - 2; We < xt; Le = We, We += 2) et += (xe[We] - xe[Le]) * (xe[We + 1] + xe[Le + 1]);
            if (et > 0 === Ve) for (let We = 0, xt = xe.length; We < xt / 2; We += 2) {
              const Le = xe[We], rr = xe[We + 1];
              xe[We] = xe[xt - 2 - We], xe[We + 1] = xe[xt - 1 - We], xe[xt - 2 - We] = Le, xe[xt - 1 - We] = rr;
            }
          })(Pe, Ce), Fe.push(Pe);
        }
        const rt = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 };
        class vt {
          constructor(X, Y) {
            const ne = (Y = this.options = (function(Ce, ae) {
              for (const Pe in ae) Ce[Pe] = ae[Pe];
              return Ce;
            })(Object.create(rt), Y)).debug;
            if (ne && console.time("preprocess data"), Y.maxZoom < 0 || Y.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (Y.promoteId && Y.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let ve = (function(Ce, ae) {
              const Pe = [];
              if (Ce.type === "FeatureCollection") for (let xe = 0; xe < Ce.features.length; xe++) wt(Pe, Ce.features[xe], ae, xe);
              else wt(Pe, Ce.type === "Feature" ? Ce : { geometry: Ce }, ae);
              return Pe;
            })(X, Y);
            this.tiles = {}, this.tileCoords = [], ne && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", Y.indexMaxZoom, Y.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), ve = (function(Ce, ae) {
              const Pe = ae.buffer / ae.extent;
              let xe = Ce;
              const Ve = ir(Ce, 1, -1 - Pe, Pe, 0, -1, 2, ae), et = ir(Ce, 1, 1 - Pe, 2 + Pe, 0, -1, 2, ae);
              return (Ve || et) && (xe = ir(Ce, 1, -Pe, 1 + Pe, 0, -1, 2, ae) || [], Ve && (xe = kt(Ve, 1).concat(xe)), et && (xe = xe.concat(kt(et, -1)))), xe;
            })(ve, Y), ve.length && this.splitTile(ve, 0, 0, 0), ne && (ve.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile(X, Y, ne, ve, Ce, ae, Pe) {
            const xe = [X, Y, ne, ve], Ve = this.options, et = Ve.debug;
            for (; xe.length; ) {
              ve = xe.pop(), ne = xe.pop(), Y = xe.pop(), X = xe.pop();
              const We = 1 << Y, xt = Wt(Y, ne, ve);
              let Le = this.tiles[xt];
              if (!Le && (et > 1 && console.time("creation"), Le = this.tiles[xt] = Je(X, Y, ne, ve, Ve), this.tileCoords.push({ z: Y, x: ne, y: ve }), et)) {
                et > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", Y, ne, ve, Le.numFeatures, Le.numPoints, Le.numSimplified), console.timeEnd("creation"));
                const Ne = `z${Y}`;
                this.stats[Ne] = (this.stats[Ne] || 0) + 1, this.total++;
              }
              if (Le.source = X, Ce == null) {
                if (Y === Ve.indexMaxZoom || Le.numPoints <= Ve.indexMaxPoints) continue;
              } else {
                if (Y === Ve.maxZoom || Y === Ce) continue;
                if (Ce != null) {
                  const Ne = Ce - Y;
                  if (ne !== ae >> Ne || ve !== Pe >> Ne) continue;
                }
              }
              if (Le.source = null, X.length === 0) continue;
              et > 1 && console.time("clipping");
              const rr = 0.5 * Ve.buffer / Ve.extent, Zr = 0.5 - rr, Ut = 0.5 + rr, dr = 1 + rr;
              let Er = null, jr = null, di = null, Hr = null, Jr = ir(X, We, ne - rr, ne + Ut, 0, Le.minX, Le.maxX, Ve), Lr = ir(X, We, ne + Zr, ne + dr, 0, Le.minX, Le.maxX, Ve);
              X = null, Jr && (Er = ir(Jr, We, ve - rr, ve + Ut, 1, Le.minY, Le.maxY, Ve), jr = ir(Jr, We, ve + Zr, ve + dr, 1, Le.minY, Le.maxY, Ve), Jr = null), Lr && (di = ir(Lr, We, ve - rr, ve + Ut, 1, Le.minY, Le.maxY, Ve), Hr = ir(Lr, We, ve + Zr, ve + dr, 1, Le.minY, Le.maxY, Ve), Lr = null), et > 1 && console.timeEnd("clipping"), xe.push(Er || [], Y + 1, 2 * ne, 2 * ve), xe.push(jr || [], Y + 1, 2 * ne, 2 * ve + 1), xe.push(di || [], Y + 1, 2 * ne + 1, 2 * ve), xe.push(Hr || [], Y + 1, 2 * ne + 1, 2 * ve + 1);
            }
          }
          getTile(X, Y, ne) {
            X = +X, Y = +Y, ne = +ne;
            const ve = this.options, { extent: Ce, debug: ae } = ve;
            if (X < 0 || X > 24) return null;
            const Pe = 1 << X, xe = Wt(X, Y = Y + Pe & Pe - 1, ne);
            if (this.tiles[xe]) return at(this.tiles[xe], Ce);
            ae > 1 && console.log("drilling down to z%d-%d-%d", X, Y, ne);
            let Ve, et = X, We = Y, xt = ne;
            for (; !Ve && et > 0; ) et--, We >>= 1, xt >>= 1, Ve = this.tiles[Wt(et, We, xt)];
            return Ve && Ve.source ? (ae > 1 && (console.log("found parent tile z%d-%d-%d", et, We, xt), console.time("drilling down")), this.splitTile(Ve.source, et, We, xt, X, Y, ne), ae > 1 && console.timeEnd("drilling down"), this.tiles[xe] ? at(this.tiles[xe], Ce) : null) : null;
          }
        }
        function Wt(Fe, X, Y) {
          return 32 * ((1 << Fe) * Y + X) + Fe;
        }
        class ci extends D {
          constructor(X, Y, ne, ve = Ai) {
            super(X, Y, ne), this._dataUpdateable = /* @__PURE__ */ new Map(), this._createGeoJSONIndex = ve;
          }
          loadVectorTile(X, Y) {
            return p._(this, void 0, void 0, (function* () {
              const ne = X.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const ve = this._geoJSONIndex.getTile(ne.z, ne.x, ne.y);
              if (!ve) return null;
              const Ce = new K(ve.features, { version: 2, extent: p.a3 });
              let ae = (function(Pe) {
                const xe = new p.cP();
                return (function(Ve, et) {
                  for (const We in Ve.layers) et.writeMessage(3, te, Ve.layers[We]);
                })(Pe, xe), xe.finish();
              })(Ce);
              return ae.byteOffset === 0 && ae.byteLength === ae.buffer.byteLength || (ae = new Uint8Array(ae)), { vectorTile: Ce, rawData: ae.buffer };
            }));
          }
          loadData(X) {
            return p._(this, void 0, void 0, (function* () {
              var Y;
              (Y = this._pendingRequest) === null || Y === void 0 || Y.abort();
              const ne = !!(X && X.request && X.request.collectResourceTiming) && new p.cQ(X.request);
              this._pendingRequest = new AbortController();
              try {
                (!this._pendingData || X.request || X.data || X.dataDiff) && (this._pendingData = this.loadAndProcessGeoJSON(X, this._pendingRequest));
                const ve = yield this._pendingData;
                this._geoJSONIndex = this._createGeoJSONIndex(ve, X), this.loaded = {};
                const Ce = { data: ve };
                if (ne) {
                  const ae = ne.finish();
                  ae && (Ce.resourceTiming = {}, Ce.resourceTiming[X.source] = JSON.parse(JSON.stringify(ae)));
                }
                return Ce;
              } catch (ve) {
                if (delete this._pendingRequest, p.cB(ve)) return { abandoned: true };
                throw ve;
              }
            }));
          }
          getData() {
            return p._(this, void 0, void 0, (function* () {
              return this._pendingData;
            }));
          }
          reloadTile(X) {
            const Y = this.loaded;
            return Y && Y[X.uid] ? super.reloadTile(X) : this.loadTile(X);
          }
          loadAndProcessGeoJSON(X, Y) {
            return p._(this, void 0, void 0, (function* () {
              let ne = yield this.loadGeoJSON(X, Y);
              if (delete this._pendingRequest, typeof ne != "object") throw new Error(`Input data given to '${X.source}' is not a valid GeoJSON object.`);
              if (Z(ne, true), X.filter) {
                const ve = p.cW(X.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                if (ve.result === "error") throw new Error(ve.value.map(((ae) => `${ae.key}: ${ae.message}`)).join(", "));
                ne = { type: "FeatureCollection", features: ne.features.filter(((ae) => ve.value.evaluate({ zoom: 0 }, ae))) };
              }
              return ne;
            }));
          }
          loadGeoJSON(X, Y) {
            return p._(this, void 0, void 0, (function* () {
              const { promoteId: ne } = X;
              if (X.request) {
                const ve = yield p.j(X.request, Y);
                return this._dataUpdateable = p.cY(ve.data, ne) ? p.cX(ve.data, ne) : void 0, ve.data;
              }
              if (typeof X.data == "string") try {
                const ve = JSON.parse(X.data);
                return this._dataUpdateable = p.cY(ve, ne) ? p.cX(ve, ne) : void 0, ve;
              } catch {
                throw new Error(`Input data given to '${X.source}' is not a valid GeoJSON object.`);
              }
              if (!X.dataDiff) throw new Error(`Input data given to '${X.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${X.source}`);
              return p.cZ(this._dataUpdateable, X.dataDiff, ne), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
            }));
          }
          removeSource(X) {
            return p._(this, void 0, void 0, (function* () {
              this._pendingRequest && this._pendingRequest.abort();
            }));
          }
          getClusterExpansionZoom(X) {
            return this._geoJSONIndex.getClusterExpansionZoom(X.clusterId);
          }
          getClusterChildren(X) {
            return this._geoJSONIndex.getChildren(X.clusterId);
          }
          getClusterLeaves(X) {
            return this._geoJSONIndex.getLeaves(X.clusterId, X.limit, X.offset);
          }
        }
        function Ai(Fe, X) {
          return X.cluster ? new qe((function({ superclusterOptions: Y, clusterProperties: ne }) {
            if (!ne || !Y) return Y;
            const ve = {}, Ce = {}, ae = { accumulated: null, zoom: 0 }, Pe = { properties: null }, xe = Object.keys(ne);
            for (const Ve of xe) {
              const [et, We] = ne[Ve], xt = p.cW(We), Le = p.cW(typeof et == "string" ? [et, ["accumulated"], ["get", Ve]] : et);
              ve[Ve] = xt.value, Ce[Ve] = Le.value;
            }
            return Y.map = (Ve) => {
              Pe.properties = Ve;
              const et = {};
              for (const We of xe) et[We] = ve[We].evaluate(ae, Pe);
              return et;
            }, Y.reduce = (Ve, et) => {
              Pe.properties = et;
              for (const We of xe) ae.accumulated = Ve[We], Ve[We] = Ce[We].evaluate(ae, Pe);
            }, Y;
          })(X)).load(Fe.features) : (function(Y, ne) {
            return new vt(Y, ne);
          })(Fe, X.geojsonVtOptions);
        }
        class sn {
          constructor(X) {
            this.self = X, this.actor = new p.K(X), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = /* @__PURE__ */ new Map(), this.self.registerWorkerSource = (Y, ne) => {
              if (this.externalWorkerSourceTypes[Y]) throw new Error(`Worker source with name "${Y}" already registered.`);
              this.externalWorkerSourceTypes[Y] = ne;
            }, this.self.addProtocol = p.cD, this.self.removeProtocol = p.cE, this.self.registerRTLTextPlugin = (Y) => {
              p.c_.setMethods(Y);
            }, this.actor.registerMessageHandler("LDT", ((Y, ne) => this._getDEMWorkerSource(Y, ne.source).loadTile(ne))), this.actor.registerMessageHandler("RDT", ((Y, ne) => p._(this, void 0, void 0, (function* () {
              this._getDEMWorkerSource(Y, ne.source).removeTile(ne);
            })))), this.actor.registerMessageHandler("GCEZ", ((Y, ne) => p._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(Y, ne.type, ne.source).getClusterExpansionZoom(ne);
            })))), this.actor.registerMessageHandler("GCC", ((Y, ne) => p._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(Y, ne.type, ne.source).getClusterChildren(ne);
            })))), this.actor.registerMessageHandler("GCL", ((Y, ne) => p._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(Y, ne.type, ne.source).getClusterLeaves(ne);
            })))), this.actor.registerMessageHandler("LD", ((Y, ne) => this._getWorkerSource(Y, ne.type, ne.source).loadData(ne))), this.actor.registerMessageHandler("GD", ((Y, ne) => this._getWorkerSource(Y, ne.type, ne.source).getData())), this.actor.registerMessageHandler("LT", ((Y, ne) => this._getWorkerSource(Y, ne.type, ne.source).loadTile(ne))), this.actor.registerMessageHandler("RT", ((Y, ne) => this._getWorkerSource(Y, ne.type, ne.source).reloadTile(ne))), this.actor.registerMessageHandler("AT", ((Y, ne) => this._getWorkerSource(Y, ne.type, ne.source).abortTile(ne))), this.actor.registerMessageHandler("RMT", ((Y, ne) => this._getWorkerSource(Y, ne.type, ne.source).removeTile(ne))), this.actor.registerMessageHandler("RS", ((Y, ne) => p._(this, void 0, void 0, (function* () {
              if (!this.workerSources[Y] || !this.workerSources[Y][ne.type] || !this.workerSources[Y][ne.type][ne.source]) return;
              const ve = this.workerSources[Y][ne.type][ne.source];
              delete this.workerSources[Y][ne.type][ne.source], ve.removeSource !== void 0 && ve.removeSource(ne);
            })))), this.actor.registerMessageHandler("RM", ((Y) => p._(this, void 0, void 0, (function* () {
              delete this.layerIndexes[Y], delete this.availableImages[Y], delete this.workerSources[Y], delete this.demWorkerSources[Y], this.globalStates.delete(Y);
            })))), this.actor.registerMessageHandler("SR", ((Y, ne) => p._(this, void 0, void 0, (function* () {
              this.referrer = ne;
            })))), this.actor.registerMessageHandler("SRPS", ((Y, ne) => this._syncRTLPluginState(Y, ne))), this.actor.registerMessageHandler("IS", ((Y, ne) => p._(this, void 0, void 0, (function* () {
              this.self.importScripts(ne);
            })))), this.actor.registerMessageHandler("SI", ((Y, ne) => this._setImages(Y, ne))), this.actor.registerMessageHandler("UL", ((Y, ne) => p._(this, void 0, void 0, (function* () {
              this._getLayerIndex(Y).update(ne.layers, ne.removedIds, this._getGlobalState(Y));
            })))), this.actor.registerMessageHandler("UGS", ((Y, ne) => p._(this, void 0, void 0, (function* () {
              const ve = this._getGlobalState(Y);
              for (const Ce in ne) ve[Ce] = ne[Ce];
            })))), this.actor.registerMessageHandler("SL", ((Y, ne) => p._(this, void 0, void 0, (function* () {
              this._getLayerIndex(Y).replace(ne, this._getGlobalState(Y));
            }))));
          }
          _getGlobalState(X) {
            let Y = this.globalStates.get(X);
            return Y || (Y = {}, this.globalStates.set(X, Y)), Y;
          }
          _setImages(X, Y) {
            return p._(this, void 0, void 0, (function* () {
              this.availableImages[X] = Y;
              for (const ne in this.workerSources[X]) {
                const ve = this.workerSources[X][ne];
                for (const Ce in ve) ve[Ce].availableImages = Y;
              }
            }));
          }
          _syncRTLPluginState(X, Y) {
            return p._(this, void 0, void 0, (function* () {
              return yield p.c_.syncState(Y, this.self.importScripts);
            }));
          }
          _getAvailableImages(X) {
            let Y = this.availableImages[X];
            return Y || (Y = []), Y;
          }
          _getLayerIndex(X) {
            let Y = this.layerIndexes[X];
            return Y || (Y = this.layerIndexes[X] = new s()), Y;
          }
          _getWorkerSource(X, Y, ne) {
            if (this.workerSources[X] || (this.workerSources[X] = {}), this.workerSources[X][Y] || (this.workerSources[X][Y] = {}), !this.workerSources[X][Y][ne]) {
              const ve = { sendAsync: (Ce, ae) => (Ce.targetMapId = X, this.actor.sendAsync(Ce, ae)) };
              switch (Y) {
                case "vector":
                  this.workerSources[X][Y][ne] = new D(ve, this._getLayerIndex(X), this._getAvailableImages(X));
                  break;
                case "geojson":
                  this.workerSources[X][Y][ne] = new ci(ve, this._getLayerIndex(X), this._getAvailableImages(X));
                  break;
                default:
                  this.workerSources[X][Y][ne] = new this.externalWorkerSourceTypes[Y](ve, this._getLayerIndex(X), this._getAvailableImages(X));
              }
            }
            return this.workerSources[X][Y][ne];
          }
          _getDEMWorkerSource(X, Y) {
            return this.demWorkerSources[X] || (this.demWorkerSources[X] = {}), this.demWorkerSources[X][Y] || (this.demWorkerSources[X][Y] = new L()), this.demWorkerSources[X][Y];
          }
        }
        return p.i(self) && (self.worker = new sn(self)), sn;
      })), f("index", ["exports", "./shared"], (function(p, s) {
        var C = "5.11.0";
        function P() {
          var v = new s.A(4);
          return s.A != Float32Array && (v[1] = 0, v[2] = 0), v[0] = 1, v[3] = 1, v;
        }
        let M, D;
        const L = { frame(v, e, a) {
          const c = requestAnimationFrame(((_) => {
            m(), e(_);
          })), { unsubscribe: m } = s.s(v.signal, "abort", (() => {
            m(), cancelAnimationFrame(c), a(s.c());
          }), false);
        }, frameAsync(v) {
          return new Promise(((e, a) => {
            this.frame(v, e, a);
          }));
        }, getImageData(v, e = 0) {
          return this.getImageCanvasContext(v).getImageData(-e, -e, v.width + 2 * e, v.height + 2 * e);
        }, getImageCanvasContext(v) {
          const e = window.document.createElement("canvas"), a = e.getContext("2d", { willReadFrequently: true });
          if (!a) throw new Error("failed to create canvas 2d context");
          return e.width = v.width, e.height = v.height, a.drawImage(v, 0, 0, v.width, v.height), a;
        }, resolveURL: (v) => (M || (M = document.createElement("a")), M.href = v, M.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return !!matchMedia && (D == null && (D = matchMedia("(prefers-reduced-motion: reduce)")), D.matches);
        } }, $ = new class {
          constructor() {
            this._realTime = typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), this._frozenAt = null;
          }
          getCurrentTime() {
            return this._frozenAt !== null ? this._frozenAt : this._realTime();
          }
          setNow(v) {
            this._frozenAt = v;
          }
          restoreNow() {
            this._frozenAt = null;
          }
          isFrozen() {
            return this._frozenAt !== null;
          }
        }();
        function z() {
          return $.getCurrentTime();
        }
        class F {
          static testProp(e) {
            if (!F.docStyle) return e[0];
            for (let a = 0; a < e.length; a++) if (e[a] in F.docStyle) return e[a];
            return e[0];
          }
          static create(e, a, c) {
            const m = window.document.createElement(e);
            return a !== void 0 && (m.className = a), c && c.appendChild(m), m;
          }
          static createNS(e, a) {
            return window.document.createElementNS(e, a);
          }
          static disableDrag() {
            F.docStyle && F.selectProp && (F.userSelect = F.docStyle[F.selectProp], F.docStyle[F.selectProp] = "none");
          }
          static enableDrag() {
            F.docStyle && F.selectProp && (F.docStyle[F.selectProp] = F.userSelect);
          }
          static setTransform(e, a) {
            e.style[F.transformProp] = a;
          }
          static addEventListener(e, a, c, m = {}) {
            e.addEventListener(a, c, "passive" in m ? m : m.capture);
          }
          static removeEventListener(e, a, c, m = {}) {
            e.removeEventListener(a, c, "passive" in m ? m : m.capture);
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", F.suppressClickInternal, true);
          }
          static suppressClick() {
            window.addEventListener("click", F.suppressClickInternal, true), window.setTimeout((() => {
              window.removeEventListener("click", F.suppressClickInternal, true);
            }), 0);
          }
          static getScale(e) {
            const a = e.getBoundingClientRect();
            return { x: a.width / e.offsetWidth || 1, y: a.height / e.offsetHeight || 1, boundingClientRect: a };
          }
          static getPoint(e, a, c) {
            const m = a.boundingClientRect;
            return new s.P((c.clientX - m.left) / a.x - e.clientLeft, (c.clientY - m.top) / a.y - e.clientTop);
          }
          static mousePos(e, a) {
            const c = F.getScale(e);
            return F.getPoint(e, c, a);
          }
          static touchPos(e, a) {
            const c = [], m = F.getScale(e);
            for (let _ = 0; _ < a.length; _++) c.push(F.getPoint(e, m, a[_]));
            return c;
          }
          static mouseButton(e) {
            return e.button;
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e);
          }
          static sanitize(e) {
            const a = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"), c = a.querySelectorAll("script");
            for (const m of c) m.remove();
            return F.clean(a), a.innerHTML;
          }
          static isPossiblyDangerous(e, a) {
            const c = a.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e) || !c.includes("javascript:") && !c.includes("data:")) || !!e.startsWith("on") || void 0;
          }
          static clean(e) {
            const a = e.children;
            for (const c of a) F.removeAttributes(c), F.clean(c);
          }
          static removeAttributes(e) {
            for (const { name: a, value: c } of e.attributes) F.isPossiblyDangerous(a, c) && e.removeAttribute(a);
          }
        }
        F.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, F.selectProp = F.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), F.transformProp = F.testProp(["transform", "WebkitTransform"]);
        const Z = { supported: false, testSupport: function(v) {
          !te && K && (re ? ie(v) : q = v);
        } };
        let q, K, te = false, re = false;
        function ie(v) {
          const e = v.createTexture();
          v.bindTexture(v.TEXTURE_2D, e);
          try {
            if (v.texImage2D(v.TEXTURE_2D, 0, v.RGBA, v.RGBA, v.UNSIGNED_BYTE, K), v.isContextLost()) return;
            Z.supported = true;
          } catch {
          }
          v.deleteTexture(e), te = true;
        }
        var J;
        typeof document < "u" && (K = document.createElement("img"), K.onload = () => {
          q && ie(q), q = null, re = true;
        }, K.onerror = () => {
          te = true, q = null;
        }, K.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(v) {
          let e, a, c, m;
          v.resetRequestQueue = () => {
            e = [], a = 0, c = 0, m = {};
          }, v.addThrottleControl = (T) => {
            const R = c++;
            return m[R] = T, R;
          }, v.removeThrottleControl = (T) => {
            delete m[T], x();
          }, v.getImage = (T, R, A = true) => new Promise(((N, j) => {
            Z.supported && (T.headers || (T.headers = {}), T.headers.accept = "image/webp,*/*"), s.e(T, { type: "image" }), e.push({ abortController: R, requestParameters: T, supportImageRefresh: A, state: "queued", onError: (G) => {
              j(G);
            }, onSuccess: (G) => {
              N(G);
            } }), x();
          }));
          const _ = (T) => s._(this, void 0, void 0, (function* () {
            T.state = "running";
            const { requestParameters: R, supportImageRefresh: A, onError: N, onSuccess: j, abortController: G } = T, Q = A === false && !s.i(self) && !s.g(R.url) && (!R.headers || Object.keys(R.headers).reduce(((de, ge) => de && ge === "accept"), true));
            a++;
            const le = Q ? k(R, G) : s.m(R, G);
            try {
              const de = yield le;
              delete T.abortController, T.state = "completed", de.data instanceof HTMLImageElement || s.b(de.data) ? j(de) : de.data && j({ data: yield (ce = de.data, typeof createImageBitmap == "function" ? s.f(ce) : s.h(ce)), cacheControl: de.cacheControl, expires: de.expires });
            } catch (de) {
              delete T.abortController, N(de);
            } finally {
              a--, x();
            }
            var ce;
          })), x = () => {
            const T = (() => {
              for (const R of Object.keys(m)) if (m[R]()) return true;
              return false;
            })() ? s.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : s.a.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let R = a; R < T && e.length > 0; R++) {
              const A = e.shift();
              A.abortController.signal.aborted ? R-- : _(A);
            }
          }, k = (T, R) => new Promise(((A, N) => {
            const j = new Image(), G = T.url, Q = T.credentials;
            Q && Q === "include" ? j.crossOrigin = "use-credentials" : (Q && Q === "same-origin" || !s.d(G)) && (j.crossOrigin = "anonymous"), R.signal.addEventListener("abort", (() => {
              j.src = "", N(s.c());
            })), j.fetchPriority = "high", j.onload = () => {
              j.onerror = j.onload = null, A({ data: j });
            }, j.onerror = () => {
              j.onerror = j.onload = null, R.signal.aborted || N(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, j.src = G;
          }));
        })(J || (J = {})), J.resetRequestQueue();
        class we {
          constructor(e) {
            this._transformRequestFn = e ?? null;
          }
          transformRequest(e, a) {
            return this._transformRequestFn && this._transformRequestFn(e, a) || { url: e };
          }
          setTransformRequest(e) {
            this._transformRequestFn = e;
          }
        }
        function fe(v) {
          const e = [];
          if (typeof v == "string") e.push({ id: "default", url: v });
          else if (v && v.length > 0) {
            const a = [];
            for (const { id: c, url: m } of v) {
              const _ = `${c}${m}`;
              a.indexOf(_) === -1 && (a.push(_), e.push({ id: c, url: m }));
            }
          }
          return e;
        }
        function oe(v, e, a) {
          try {
            const c = new URL(v);
            return c.pathname += `${e}${a}`, c.toString();
          } catch {
            throw new Error(`Invalid sprite URL "${v}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
          }
        }
        function he(v) {
          const { userImage: e } = v;
          return !!(e && e.render && e.render()) && (v.data.replace(new Uint8Array(e.data.buffer)), true);
        }
        class _e extends s.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new s.R({ width: 1, height: 1 }), this.dirty = true;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e, e)) {
              for (const { ids: a, promiseResolve: c } of this.requestors) c(this._getImagesForIds(a));
              this.requestors = [];
            }
          }
          getImage(e) {
            const a = this.images[e];
            if (a && !a.data && a.spriteData) {
              const c = a.spriteData;
              a.data = new s.R({ width: c.width, height: c.height }, c.context.getImageData(c.x, c.y, c.width, c.height).data), a.spriteData = null;
            }
            return a;
          }
          addImage(e, a) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, a) && (this.images[e] = a);
          }
          _validate(e, a) {
            let c = true;
            const m = a.data || a.spriteData;
            return this._validateStretch(a.stretchX, m && m.width) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "stretchX" value`))), c = false), this._validateStretch(a.stretchY, m && m.height) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "stretchY" value`))), c = false), this._validateContent(a.content, a) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "content" value`))), c = false), c;
          }
          _validateStretch(e, a) {
            if (!e) return true;
            let c = 0;
            for (const m of e) {
              if (m[0] < c || m[1] < m[0] || a < m[1]) return false;
              c = m[1];
            }
            return true;
          }
          _validateContent(e, a) {
            if (!e) return true;
            if (e.length !== 4) return false;
            const c = a.spriteData, m = c && c.width || a.data.width, _ = c && c.height || a.data.height;
            return !(e[0] < 0 || m < e[0] || e[1] < 0 || _ < e[1] || e[2] < 0 || m < e[2] || e[3] < 0 || _ < e[3] || e[2] < e[0] || e[3] < e[1]);
          }
          updateImage(e, a, c = true) {
            const m = this.getImage(e);
            if (c && (m.data.width !== a.data.width || m.data.height !== a.data.height)) throw new Error(`size mismatch between old image (${m.data.width}x${m.data.height}) and new image (${a.data.width}x${a.data.height}).`);
            a.version = m.version + 1, this.images[e] = a, this.updatedImages[e] = true;
          }
          removeImage(e) {
            const a = this.images[e];
            delete this.images[e], delete this.patterns[e], a.userImage && a.userImage.onRemove && a.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(e) {
            return new Promise(((a, c) => {
              let m = true;
              if (!this.isLoaded()) for (const _ of e) this.images[_] || (m = false);
              this.isLoaded() || m ? a(this._getImagesForIds(e)) : this.requestors.push({ ids: e, promiseResolve: a });
            }));
          }
          _getImagesForIds(e) {
            const a = {};
            for (const c of e) {
              let m = this.getImage(c);
              m || (this.fire(new s.l("styleimagemissing", { id: c })), m = this.getImage(c)), m ? a[c] = { data: m.data.clone(), pixelRatio: m.pixelRatio, sdf: m.sdf, version: m.version, stretchX: m.stretchX, stretchY: m.stretchY, content: m.content, textFitWidth: m.textFitWidth, textFitHeight: m.textFitHeight, hasRenderCallback: !!(m.userImage && m.userImage.render) } : s.w(`Image "${c}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            return a;
          }
          getPixelSize() {
            const { width: e, height: a } = this.atlasImage;
            return { width: e, height: a };
          }
          getPattern(e) {
            const a = this.patterns[e], c = this.getImage(e);
            if (!c) return null;
            if (a && a.position.version === c.version) return a.position;
            if (a) a.position.version = c.version;
            else {
              const m = { w: c.data.width + 2, h: c.data.height + 2, x: 0, y: 0 }, _ = new s.I(m, c);
              this.patterns[e] = { bin: m, position: _ };
            }
            return this._updatePatternAtlas(), this.patterns[e].position;
          }
          bind(e) {
            const a = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new s.T(e, this.atlasImage, a.RGBA), this.atlasTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const e = [];
            for (const _ in this.patterns) e.push(this.patterns[_].bin);
            const { w: a, h: c } = s.p(e), m = this.atlasImage;
            m.resize({ width: a || 1, height: c || 1 });
            for (const _ in this.patterns) {
              const { bin: x } = this.patterns[_], k = x.x + 1, T = x.y + 1, R = this.getImage(_).data, A = R.width, N = R.height;
              s.R.copy(R, m, { x: 0, y: 0 }, { x: k, y: T }, { width: A, height: N }), s.R.copy(R, m, { x: 0, y: N - 1 }, { x: k, y: T - 1 }, { width: A, height: 1 }), s.R.copy(R, m, { x: 0, y: 0 }, { x: k, y: T + N }, { width: A, height: 1 }), s.R.copy(R, m, { x: A - 1, y: 0 }, { x: k - 1, y: T }, { width: 1, height: N }), s.R.copy(R, m, { x: 0, y: 0 }, { x: k + A, y: T }, { width: 1, height: N });
            }
            this.dirty = true;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(e) {
            for (const a of e) {
              if (this.callbackDispatchedThisFrame[a]) continue;
              this.callbackDispatchedThisFrame[a] = true;
              const c = this.getImage(a);
              c || s.w(`Image with ID: "${a}" was not found`), he(c) && this.updateImage(a, c);
            }
          }
        }
        const Ue = 1e20;
        function qe(v, e, a, c, m, _, x, k, T) {
          for (let R = e; R < e + c; R++) tt(v, a * _ + R, _, m, x, k, T);
          for (let R = a; R < a + m; R++) tt(v, R * _ + e, 1, c, x, k, T);
        }
        function tt(v, e, a, c, m, _, x) {
          _[0] = 0, x[0] = -Ue, x[1] = Ue, m[0] = v[e];
          for (let k = 1, T = 0, R = 0; k < c; k++) {
            m[k] = v[e + k * a];
            const A = k * k;
            do {
              const N = _[T];
              R = (m[k] - m[N] + A - N * N) / (k - N) / 2;
            } while (R <= x[T] && --T > -1);
            T++, _[T] = k, x[T] = R, x[T + 1] = Ue;
          }
          for (let k = 0, T = 0; k < c; k++) {
            for (; x[T + 1] < k; ) T++;
            const R = _[T], A = k - R;
            v[e + k * a] = m[R] + A * A;
          }
        }
        const ut = s.v.layout_symbol["text-font"].default.join(",");
        class mt {
          constructor(e, a, c) {
            this.requestManager = e, this.localIdeographFontFamily = a, this.entries = {}, this.lang = c;
          }
          setURL(e) {
            this.url = e;
          }
          getGlyphs(e) {
            return s._(this, void 0, void 0, (function* () {
              const a = [];
              for (const _ in e) for (const x of e[_]) a.push(this._getAndCacheGlyphsPromise(_, x));
              const c = yield Promise.all(a), m = {};
              for (const { stack: _, id: x, glyph: k } of c) m[_] || (m[_] = {}), m[_][x] = k && { id: k.id, bitmap: k.bitmap.clone(), metrics: k.metrics };
              return m;
            }));
          }
          _getAndCacheGlyphsPromise(e, a) {
            return s._(this, void 0, void 0, (function* () {
              let c = this.entries[e];
              c || (c = this.entries[e] = { glyphs: {}, requests: {}, ranges: {} });
              let m = c.glyphs[a];
              return m !== void 0 ? { stack: e, id: a, glyph: m } : !this.url || this._charUsesLocalIdeographFontFamily(a) ? (m = c.glyphs[a] = this._drawGlyph(c, e, a), { stack: e, id: a, glyph: m }) : yield this._downloadAndCacheRangePromise(e, a);
            }));
          }
          _downloadAndCacheRangePromise(e, a) {
            return s._(this, void 0, void 0, (function* () {
              const c = Math.floor(a / 256);
              if (256 * c > 65535) throw new Error("glyphs > 65535 not supported");
              const m = this.entries[e];
              if (m.ranges[c]) return { stack: e, id: a, glyph: null };
              if (!m.requests[c]) {
                const _ = mt.loadGlyphRange(e, c, this.url, this.requestManager);
                m.requests[c] = _;
              }
              try {
                const _ = yield m.requests[c];
                for (const x in _) m.glyphs[+x] = _[+x];
                return m.ranges[c] = true, { stack: e, id: a, glyph: _[a] || null };
              } catch (_) {
                const x = m.glyphs[a] = this._drawGlyph(m, e, a);
                return this._warnOnMissingGlyphRange(x, c, a, _), { stack: e, id: a, glyph: x };
              }
            }));
          }
          _warnOnMissingGlyphRange(e, a, c, m) {
            const _ = 256 * a, x = _ + 255, k = c.toString(16).padStart(4, "0").toUpperCase();
            s.w(`Unable to load glyph range ${a}, ${_}-${x}. Rendering codepoint U+${k} locally instead. ${m}`);
          }
          _charUsesLocalIdeographFontFamily(e) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || s.u["CJK Unified Ideographs"](e) || s.u["Hangul Syllables"](e) || s.u.Hiragana(e) || s.u.Katakana(e) || s.u["CJK Symbols and Punctuation"](e) || s.u["Halfwidth and Fullwidth Forms"](e));
          }
          _drawGlyph(e, a, c) {
            const m = a === ut && this.localIdeographFontFamily !== "" && this._charUsesLocalIdeographFontFamily(c), _ = m ? "ideographTinySDF" : "tinySDF";
            e[_] || (e[_] = this._createTinySDF(m ? this.localIdeographFontFamily : a));
            const x = e[_].draw(String.fromCharCode(c));
            return { id: c, bitmap: new s.q({ width: x.width || 60, height: x.height || 60 }, x.data), metrics: { width: x.glyphWidth / 2 || 24, height: x.glyphHeight / 2 || 24, left: x.glyphLeft / 2 + 0.5 || 0, top: x.glyphTop / 2 - 27.5 || -8, advance: x.glyphAdvance / 2 || 24, isDoubleResolution: true } };
          }
          _createTinySDF(e) {
            const a = e ? e.split(",") : [];
            a.push("sans-serif");
            const c = a.map(((m) => /[-\w]+/.test(m) ? m : `'${CSS.escape(m)}'`)).join(",");
            return new mt.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: c, fontWeight: this._fontWeight(a[0]), fontStyle: this._fontStyle(a[0]), lang: this.lang });
          }
          _fontStyle(e) {
            return /italic/i.test(e) ? "italic" : /oblique/i.test(e) ? "oblique" : "normal";
          }
          _fontWeight(e) {
            const a = { thin: 100, hairline: 100, "extra light": 200, "ultra light": 200, light: 300, normal: 400, regular: 400, medium: 500, semibold: 600, demibold: 600, bold: 700, "extra bold": 800, "ultra bold": 800, black: 900, heavy: 900, "extra black": 950, "ultra black": 950 };
            let c;
            for (const [m, _] of Object.entries(a)) new RegExp(`\\b${m}\\b`, "i").test(e) && (c = `${_}`);
            return c;
          }
        }
        mt.loadGlyphRange = function(v, e, a, c) {
          return s._(this, void 0, void 0, (function* () {
            const m = 256 * e, _ = m + 255, x = c.transformRequest(a.replace("{fontstack}", v).replace("{range}", `${m}-${_}`), "Glyphs"), k = yield s.n(x, new AbortController());
            if (!k || !k.data) throw new Error(`Could not load glyph range. range: ${e}, ${m}-${_}`);
            const T = {};
            for (const R of s.o(k.data)) T[R.id] = R;
            return T;
          }));
        }, mt.TinySDF = class {
          constructor({ fontSize: v = 24, buffer: e = 3, radius: a = 8, cutoff: c = 0.25, fontFamily: m = "sans-serif", fontWeight: _ = "normal", fontStyle: x = "normal", lang: k = null } = {}) {
            this.buffer = e, this.cutoff = c, this.radius = a, this.lang = k;
            const T = this.size = v + 4 * e, R = this._createCanvas(T), A = this.ctx = R.getContext("2d", { willReadFrequently: true });
            A.font = `${x} ${_} ${v}px ${m}`, A.textBaseline = "alphabetic", A.textAlign = "left", A.fillStyle = "black", this.gridOuter = new Float64Array(T * T), this.gridInner = new Float64Array(T * T), this.f = new Float64Array(T), this.z = new Float64Array(T + 1), this.v = new Uint16Array(T);
          }
          _createCanvas(v) {
            const e = document.createElement("canvas");
            return e.width = e.height = v, e;
          }
          draw(v) {
            const { width: e, actualBoundingBoxAscent: a, actualBoundingBoxDescent: c, actualBoundingBoxLeft: m, actualBoundingBoxRight: _ } = this.ctx.measureText(v), x = Math.ceil(a), k = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(_ - m))), T = Math.min(this.size - this.buffer, x + Math.ceil(c)), R = k + 2 * this.buffer, A = T + 2 * this.buffer, N = Math.max(R * A, 0), j = new Uint8ClampedArray(N), G = { data: j, width: R, height: A, glyphWidth: k, glyphHeight: T, glyphTop: x, glyphLeft: 0, glyphAdvance: e };
            if (k === 0 || T === 0) return G;
            const { ctx: Q, buffer: le, gridInner: ce, gridOuter: de } = this;
            this.lang && (Q.lang = this.lang), Q.clearRect(le, le, k, T), Q.fillText(v, le, le + x);
            const ge = Q.getImageData(le, le, k, T);
            de.fill(Ue, 0, N), ce.fill(0, 0, N);
            for (let Se = 0; Se < T; Se++) for (let me = 0; me < k; me++) {
              const ke = ge.data[4 * (Se * k + me) + 3] / 255;
              if (ke === 0) continue;
              const Re = (Se + le) * R + me + le;
              if (ke === 1) de[Re] = 0, ce[Re] = Ue;
              else {
                const ye = 0.5 - ke;
                de[Re] = ye > 0 ? ye * ye : 0, ce[Re] = ye < 0 ? ye * ye : 0;
              }
            }
            qe(de, 0, 0, R, A, R, this.f, this.v, this.z), qe(ce, le, le, k, T, R, this.f, this.v, this.z);
            for (let Se = 0; Se < N; Se++) {
              const me = Math.sqrt(de[Se]) - Math.sqrt(ce[Se]);
              j[Se] = Math.round(255 - 255 * (me / this.radius + this.cutoff));
            }
            return G;
          }
        };
        class St {
          constructor() {
            this.specification = s.t.light.position;
          }
          possiblyEvaluate(e, a) {
            return s.C(e.expression.evaluate(a));
          }
          interpolate(e, a, c) {
            return { x: s.F.number(e.x, a.x, c), y: s.F.number(e.y, a.y, c), z: s.F.number(e.z, a.z, c) };
          }
        }
        let st;
        class nt extends s.E {
          constructor(e) {
            super(), st = st || new s.r({ anchor: new s.D(s.t.light.anchor), position: new St(), color: new s.D(s.t.light.color), intensity: new s.D(s.t.light.intensity) }), this._transitionable = new s.x(st, void 0), this.setLight(e), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(e, a = {}) {
            if (!this._validate(s.y, e, a)) for (const c in e) {
              const m = e[c];
              c.endsWith("-transition") ? this._transitionable.setTransition(c.slice(0, -11), m) : this._transitionable.setValue(c, m);
            }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, a, c) {
            return (!c || c.validate !== false) && s.z(this, e.call(s.B, { value: a, style: { glyphs: true, sprite: true }, styleSpec: s.t }));
          }
        }
        const ft = new s.r({ "sky-color": new s.D(s.t.sky["sky-color"]), "horizon-color": new s.D(s.t.sky["horizon-color"]), "fog-color": new s.D(s.t.sky["fog-color"]), "fog-ground-blend": new s.D(s.t.sky["fog-ground-blend"]), "horizon-fog-blend": new s.D(s.t.sky["horizon-fog-blend"]), "sky-horizon-blend": new s.D(s.t.sky["sky-horizon-blend"]), "atmosphere-blend": new s.D(s.t.sky["atmosphere-blend"]) });
        class Lt extends s.E {
          constructor(e) {
            super(), this._transitionable = new s.x(ft, void 0), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.G(0));
          }
          setSky(e, a = {}) {
            if (!this._validate(s.H, e, a)) {
              e || (e = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
              for (const c in e) {
                const m = e[c];
                c.endsWith("-transition") ? this._transitionable.setTransition(c.slice(0, -11), m) : this._transitionable.setValue(c, m);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, a, c = {}) {
            return (c == null ? void 0 : c.validate) !== false && s.z(this, e.call(s.B, s.e({ value: a, style: { glyphs: true, sprite: true }, styleSpec: s.t })));
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1;
          }
        }
        class pt {
          constructor(e, a) {
            this.width = e, this.height = a, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(e, a) {
            const c = e.join(",") + String(a);
            return this.dashEntry[c] || (this.dashEntry[c] = this.addDash(e, a)), this.dashEntry[c];
          }
          getDashRanges(e, a, c) {
            const m = [];
            let _ = e.length % 2 == 1 ? -e[e.length - 1] * c : 0, x = e[0] * c, k = true;
            m.push({ left: _, right: x, isDash: k, zeroLength: e[0] === 0 });
            let T = e[0];
            for (let R = 1; R < e.length; R++) {
              k = !k;
              const A = e[R];
              _ = T * c, T += A, x = T * c, m.push({ left: _, right: x, isDash: k, zeroLength: A === 0 });
            }
            return m;
          }
          addRoundDash(e, a, c) {
            const m = a / 2;
            for (let _ = -c; _ <= c; _++) {
              const x = this.width * (this.nextRow + c + _);
              let k = 0, T = e[k];
              for (let R = 0; R < this.width; R++) {
                R / T.right > 1 && (T = e[++k]);
                const A = Math.abs(R - T.left), N = Math.abs(R - T.right), j = Math.min(A, N);
                let G;
                const Q = _ / c * (m + 1);
                if (T.isDash) {
                  const le = m - Math.abs(Q);
                  G = Math.sqrt(j * j + le * le);
                } else G = m - Math.sqrt(j * j + Q * Q);
                this.data[x + R] = Math.max(0, Math.min(255, G + 128));
              }
            }
          }
          addRegularDash(e) {
            for (let k = e.length - 1; k >= 0; --k) {
              const T = e[k], R = e[k + 1];
              T.zeroLength ? e.splice(k, 1) : R && R.isDash === T.isDash && (R.left = T.left, e.splice(k, 1));
            }
            const a = e[0], c = e[e.length - 1];
            a.isDash === c.isDash && (a.left = c.left - this.width, c.right = a.right + this.width);
            const m = this.width * this.nextRow;
            let _ = 0, x = e[_];
            for (let k = 0; k < this.width; k++) {
              k / x.right > 1 && (x = e[++_]);
              const T = Math.abs(k - x.left), R = Math.abs(k - x.right), A = Math.min(T, R);
              this.data[m + k] = Math.max(0, Math.min(255, (x.isDash ? A : -A) + 128));
            }
          }
          addDash(e, a) {
            const c = a ? 7 : 0, m = 2 * c + 1;
            if (this.nextRow + m > this.height) return s.w("LineAtlas out of space"), null;
            let _ = 0;
            for (let k = 0; k < e.length; k++) _ += e[k];
            if (_ !== 0) {
              const k = this.width / _, T = this.getDashRanges(e, this.width, k);
              a ? this.addRoundDash(T, k, c) : this.addRegularDash(T);
            }
            const x = { y: this.nextRow + c, height: 2 * c, width: _ };
            return this.nextRow += m, this.dirty = true, x;
          }
          bind(e) {
            const a = e.gl;
            this.texture ? (a.bindTexture(a.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, this.width, this.height, a.ALPHA, a.UNSIGNED_BYTE, this.data))) : (this.texture = a.createTexture(), a.bindTexture(a.TEXTURE_2D, this.texture), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.REPEAT), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.REPEAT), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR), a.texImage2D(a.TEXTURE_2D, 0, a.ALPHA, this.width, this.height, 0, a.ALPHA, a.UNSIGNED_BYTE, this.data));
          }
        }
        const wt = "maplibre_preloaded_worker_pool";
        class Ft {
          constructor() {
            this.active = {};
          }
          acquire(e) {
            if (!this.workers) for (this.workers = []; this.workers.length < Ft.workerCount; ) this.workers.push(new Worker(s.a.WORKER_URL));
            return this.active[e] = true, this.workers.slice();
          }
          release(e) {
            delete this.active[e], this.numActive() === 0 && (this.workers.forEach(((a) => {
              a.terminate();
            })), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[wt];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const tr = Math.floor(L.hardwareConcurrency / 2);
        let gt, Bt;
        function Zt() {
          return gt || (gt = new Ft()), gt;
        }
        Ft.workerCount = s.J(globalThis) ? Math.max(Math.min(tr, 3), 1) : 1;
        class ir {
          constructor(e, a) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = a;
            const c = this.workerPool.acquire(a);
            for (let m = 0; m < c.length; m++) {
              const _ = new s.K(c[m], a);
              _.name = `Worker ${m}`, this.actors.push(_);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(e, a) {
            const c = [];
            for (const m of this.actors) c.push(m.sendAsync({ type: e, data: a }));
            return Promise.all(c);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(e = true) {
            this.actors.forEach(((a) => {
              a.remove();
            })), this.actors = [], e && this.workerPool.release(this.id);
          }
          registerMessageHandler(e, a) {
            for (const c of this.actors) c.registerMessageHandler(e, a);
          }
        }
        function Cr() {
          return Bt || (Bt = new ir(Zt(), s.L), Bt.registerMessageHandler("GR", ((v, e, a) => s.m(e, a)))), Bt;
        }
        function Ar(v, e) {
          const a = s.M();
          return s.N(a, a, [1, 1, 0]), s.O(a, a, [0.5 * v.width, 0.5 * v.height, 1]), v.calculatePosMatrix ? s.Q(a, a, v.calculatePosMatrix(e.toUnwrapped())) : a;
        }
        function or(v, e, a, c, m, _, x) {
          var k;
          const T = (function(j, G, Q) {
            if (j) for (const le of j) {
              const ce = G[le];
              if (ce && ce.source === Q && ce.type === "fill-extrusion") return true;
            }
            else for (const le in G) {
              const ce = G[le];
              if (ce.source === Q && ce.type === "fill-extrusion") return true;
            }
            return false;
          })((k = m == null ? void 0 : m.layers) !== null && k !== void 0 ? k : null, e, v.id), R = _.maxPitchScaleFactor(), A = v.tilesIn(c, R, T);
          A.sort(Tr);
          const N = [];
          for (const j of A) N.push({ wrappedTileID: j.tileID.wrapped().key, queryResults: j.tile.queryRenderedFeatures(e, a, v.getState(), j.queryGeometry, j.cameraQueryGeometry, j.scale, m, _, R, Ar(_, j.tileID), x ? (G, Q) => x(j.tileID, G, Q) : void 0) });
          return (function(j, G) {
            for (const Q in j) for (const le of j[Q]) Xt(le, G);
            return j;
          })((function(j) {
            const G = {}, Q = {};
            for (const le of j) {
              const ce = le.queryResults, de = le.wrappedTileID, ge = Q[de] = Q[de] || {};
              for (const Se in ce) {
                const me = ce[Se], ke = ge[Se] = ge[Se] || {}, Re = G[Se] = G[Se] || [];
                for (const ye of me) ke[ye.featureIndex] || (ke[ye.featureIndex] = true, Re.push(ye));
              }
            }
            return G;
          })(N), v);
        }
        function Tr(v, e) {
          const a = v.tileID, c = e.tileID;
          return a.overscaledZ - c.overscaledZ || a.canonical.y - c.canonical.y || a.wrap - c.wrap || a.canonical.x - c.canonical.x;
        }
        function Xt(v, e) {
          const a = v.feature, c = e.getFeatureState(a.layer["source-layer"], a.id);
          a.source = a.layer.source, a.layer["source-layer"] && (a.sourceLayer = a.layer["source-layer"]), a.state = c;
        }
        function Dr(v, e, a) {
          return s._(this, void 0, void 0, (function* () {
            let c = v;
            if (v.url ? c = (yield s.j(e.transformRequest(v.url, "Source"), a)).data : yield L.frameAsync(a), !c) return null;
            const m = s.S(s.e(c, v), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in c && c.vector_layers && (m.vectorLayerIds = c.vector_layers.map(((_) => _.id))), m;
          }));
        }
        class nr {
          constructor(e, a) {
            e && (a ? this.setSouthWest(e).setNorthEast(a) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])));
          }
          setNorthEast(e) {
            return this._ne = e instanceof s.U ? new s.U(e.lng, e.lat) : s.U.convert(e), this;
          }
          setSouthWest(e) {
            return this._sw = e instanceof s.U ? new s.U(e.lng, e.lat) : s.U.convert(e), this;
          }
          extend(e) {
            const a = this._sw, c = this._ne;
            let m, _;
            if (e instanceof s.U) m = e, _ = e;
            else {
              if (!(e instanceof nr)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(nr.convert(e)) : this.extend(s.U.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(s.U.convert(e)) : this;
              if (m = e._sw, _ = e._ne, !m || !_) return this;
            }
            return a || c ? (a.lng = Math.min(m.lng, a.lng), a.lat = Math.min(m.lat, a.lat), c.lng = Math.max(_.lng, c.lng), c.lat = Math.max(_.lat, c.lat)) : (this._sw = new s.U(m.lng, m.lat), this._ne = new s.U(_.lng, _.lat)), this;
          }
          getCenter() {
            return new s.U((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new s.U(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new s.U(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(e) {
            const { lng: a, lat: c } = s.U.convert(e);
            let m = this._sw.lng <= a && a <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (m = this._sw.lng >= a && a >= this._ne.lng), this._sw.lat <= c && c <= this._ne.lat && m;
          }
          intersects(e) {
            if ((e = nr.convert(e)).getNorth() < this.getSouth() || e.getSouth() > this.getNorth()) return false;
            const a = s.V(this.getWest(), -180, 180), c = s.V(this.getEast(), -180, 180), m = s.V(e.getWest(), -180, 180), _ = s.V(e.getEast(), -180, 180), x = a > c, k = m > _;
            return !(!x || !k) || (x ? _ >= a || m <= c : k ? c >= m || a <= _ : !(m > c || _ < a));
          }
          static convert(e) {
            return e instanceof nr ? e : e && new nr(e);
          }
          static fromLngLat(e, a = 0) {
            const c = 360 * a / 40075017, m = c / Math.cos(Math.PI / 180 * e.lat);
            return new nr(new s.U(e.lng - m, e.lat - c), new s.U(e.lng + m, e.lat + c));
          }
          adjustAntiMeridian() {
            const e = new s.U(this._sw.lng, this._sw.lat), a = new s.U(this._ne.lng, this._ne.lat);
            return new nr(e, e.lng > a.lng ? new s.U(a.lng + 360, a.lat) : a);
          }
        }
        class kt {
          constructor(e, a, c) {
            this.bounds = nr.convert(this.validateBounds(e)), this.minzoom = a || 0, this.maxzoom = c || 24;
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];
          }
          contains(e) {
            const a = Math.pow(2, e.z), c = Math.floor(s.X(this.bounds.getWest()) * a), m = Math.floor(s.W(this.bounds.getNorth()) * a), _ = Math.ceil(s.X(this.bounds.getEast()) * a), x = Math.ceil(s.W(this.bounds.getSouth()) * a);
            return e.x >= c && e.x < _ && e.y >= m && e.y < x;
          }
        }
        class ze extends s.E {
          constructor(e, a, c, m) {
            if (super(), this.id = e, this.dispatcher = c, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, s.e(this, s.S(a, ["url", "scheme", "tileSize", "promoteId"])), this._options = s.e({ type: "vector" }, a), this._collectResourceTiming = a.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(m);
          }
          load() {
            return s._(this, void 0, void 0, (function* () {
              this._loaded = false, this.fire(new s.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const e = yield Dr(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, this.map.style.tileManagers[this.id].clearTiles(), e && (s.e(this, e), e.bounds && (this.tileBounds = new kt(e.bounds, this.minzoom, this.maxzoom)), this.fire(new s.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.l("data", { dataType: "source", sourceDataType: "content" })));
              } catch (e) {
                this._tileJSONRequest = null, this._loaded = true, this.fire(new s.k(e));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load();
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e;
            })), this;
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e;
            })), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return s.e({}, this._options);
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), c = { request: this.map._requestManager.transformRequest(a, "Tile"), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
              c.request.collectResourceTiming = this._collectResourceTiming;
              let m = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading") return new Promise(((_, x) => {
                  e.reloadPromise = { resolve: _, reject: x };
                }));
              } else e.actor = this.dispatcher.getActor(), m = "LT";
              e.abortController = new AbortController();
              try {
                const _ = yield e.actor.sendAsync({ type: m, data: c }, e.abortController);
                if (delete e.abortController, e.aborted) return;
                this._afterTileLoadWorkerResponse(e, _);
              } catch (_) {
                if (delete e.abortController, e.aborted) return;
                if (_ && _.status !== 404) throw _;
                this._afterTileLoadWorkerResponse(e, null);
              }
            }));
          }
          _afterTileLoadWorkerResponse(e, a) {
            if (a && a.resourceTiming && (e.resourceTiming = a.resourceTiming), a && this.map._refreshExpiredTiles && e.setExpiryData(a), e.loadVectorData(a, this.map.painter), e.reloadPromise) {
              const c = e.reloadPromise;
              e.reloadPromise = null, this.loadTile(e).then(c.resolve).catch(c.reject);
            }
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({ type: "AT", data: { uid: e.uid, type: this.type, source: this.id } }));
            }));
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } }));
            }));
          }
          hasTransition() {
            return false;
          }
        }
        class at extends s.E {
          constructor(e, a, c, m) {
            super(), this.id = e, this.dispatcher = c, this.setEventedParent(m), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = s.e({ type: "raster" }, a), s.e(this, s.S(a, ["url", "scheme", "tileSize"]));
          }
          load() {
            return s._(this, arguments, void 0, (function* (e = false) {
              this._loaded = false, this.fire(new s.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const a = yield Dr(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, a && (s.e(this, a), a.bounds && (this.tileBounds = new kt(a.bounds, this.minzoom, this.maxzoom)), this.fire(new s.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: e })));
              } catch (a) {
                this._tileJSONRequest = null, this._loaded = true, this.fire(new s.k(a));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(e) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(true);
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e;
            })), this;
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e;
            })), this;
          }
          serialize() {
            return s.e({}, this._options);
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e.abortController = new AbortController();
              try {
                const c = yield J.getImage(this.map._requestManager.transformRequest(a, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
                if (c && c.data) {
                  this.map._refreshExpiredTiles && (c.cacheControl || c.expires) && e.setExpiryData({ cacheControl: c.cacheControl, expires: c.expires });
                  const m = this.map.painter.context, _ = m.gl, x = c.data;
                  e.texture = this.map.painter.getTileTexture(x.width), e.texture ? e.texture.update(x, { useMipmap: true }) : (e.texture = new s.T(m, x, _.RGBA, { useMipmap: true }), e.texture.bind(_.LINEAR, _.CLAMP_TO_EDGE, _.LINEAR_MIPMAP_NEAREST)), e.state = "loaded";
                }
              } catch (c) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (c) throw e.state = "errored", c;
              }
            }));
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController);
            }));
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.texture && this.map.painter.saveTileTexture(e.texture);
            }));
          }
          hasTransition() {
            return false;
          }
        }
        class Oe extends at {
          constructor(e, a, c, m) {
            super(e, a, c, m), this.type = "raster-dem", this.maxzoom = 22, this._options = s.e({ type: "raster-dem" }, a), this.encoding = a.encoding || "mapbox", this.redFactor = a.redFactor, this.greenFactor = a.greenFactor, this.blueFactor = a.blueFactor, this.baseShift = a.baseShift;
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), c = this.map._requestManager.transformRequest(a, "Tile");
              e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController();
              try {
                const m = yield J.getImage(c, e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
                if (m && m.data) {
                  const _ = m.data;
                  this.map._refreshExpiredTiles && (m.cacheControl || m.expires) && e.setExpiryData({ cacheControl: m.cacheControl, expires: m.expires });
                  const x = s.b(_) && s.Y() ? _ : yield this.readImageNow(_), k = { type: this.type, uid: e.uid, source: this.id, rawImageData: x, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const T = yield e.actor.sendAsync({ type: "LDT", data: k });
                    e.dem = T, e.needsHillshadePrepare = true, e.needsTerrainPrepare = true, e.state = "loaded";
                  }
                }
              } catch (m) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (m) throw e.state = "errored", m;
              }
            }));
          }
          readImageNow(e) {
            return s._(this, void 0, void 0, (function* () {
              if (typeof VideoFrame < "u" && s.Z()) {
                const a = e.width + 2, c = e.height + 2;
                try {
                  return new s.R({ width: a, height: c }, yield s.$(e, -1, -1, a, c));
                } catch {
                }
              }
              return L.getImageData(e, 1);
            }));
          }
          _getNeighboringTiles(e) {
            const a = e.canonical, c = Math.pow(2, a.z), m = (a.x - 1 + c) % c, _ = a.x === 0 ? e.wrap - 1 : e.wrap, x = (a.x + 1 + c) % c, k = a.x + 1 === c ? e.wrap + 1 : e.wrap, T = {};
            return T[new s.a0(e.overscaledZ, _, a.z, m, a.y).key] = { backfilled: false }, T[new s.a0(e.overscaledZ, k, a.z, x, a.y).key] = { backfilled: false }, a.y > 0 && (T[new s.a0(e.overscaledZ, _, a.z, m, a.y - 1).key] = { backfilled: false }, T[new s.a0(e.overscaledZ, e.wrap, a.z, a.x, a.y - 1).key] = { backfilled: false }, T[new s.a0(e.overscaledZ, k, a.z, x, a.y - 1).key] = { backfilled: false }), a.y + 1 < c && (T[new s.a0(e.overscaledZ, _, a.z, m, a.y + 1).key] = { backfilled: false }, T[new s.a0(e.overscaledZ, e.wrap, a.z, a.x, a.y + 1).key] = { backfilled: false }, T[new s.a0(e.overscaledZ, k, a.z, x, a.y + 1).key] = { backfilled: false }), T;
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e.uid, source: this.id } }));
            }));
          }
        }
        function Je(v) {
          return v.type === "GeometryCollection" ? v.geometries.map(((e) => e.coordinates)).flat(1 / 0) : v.coordinates.flat(1 / 0);
        }
        function ht(v) {
          const e = new nr();
          let a;
          switch (v.type) {
            case "FeatureCollection":
              a = v.features.map(((c) => Je(c.geometry))).flat(1 / 0);
              break;
            case "Feature":
              a = Je(v.geometry);
              break;
            default:
              a = Je(v);
          }
          if (a.length == 0) return e;
          for (let c = 0; c < a.length - 1; c += 2) e.extend([a[c], a[c + 1]]);
          return e;
        }
        class bt extends s.E {
          constructor(e, a, c, m) {
            super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._isUpdatingWorker = false, this._pendingWorkerUpdate = { data: a.data }, this.actor = c.getActor(), this.setEventedParent(m), this._data = a.data, this._options = s.e({}, a), this._collectResourceTiming = a.collectResourceTiming, a.maxzoom !== void 0 && (this.maxzoom = a.maxzoom), a.type && (this.type = a.type), a.attribution && (this.attribution = a.attribution), this.promoteId = a.promoteId, a.clusterMaxZoom !== void 0 && this.maxzoom <= a.clusterMaxZoom && s.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${a.clusterMaxZoom}".`), this.workerOptions = s.e({ source: this.id, cluster: a.cluster || false, geojsonVtOptions: { buffer: this._pixelsToTileUnits(a.buffer !== void 0 ? a.buffer : 128), tolerance: this._pixelsToTileUnits(a.tolerance !== void 0 ? a.tolerance : 0.375), extent: s.a3, maxZoom: this.maxzoom, lineMetrics: a.lineMetrics || false, generateId: a.generateId || false }, superclusterOptions: { maxZoom: this._getClusterMaxZoom(a.clusterMaxZoom), minPoints: Math.max(2, a.clusterMinPoints || 2), extent: s.a3, radius: this._pixelsToTileUnits(a.clusterRadius || 50), log: false, generateId: a.generateId || false }, clusterProperties: a.clusterProperties, filter: a.filter }, a.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
          }
          _hasPendingWorkerUpdate() {
            return this._pendingWorkerUpdate.data !== void 0 || this._pendingWorkerUpdate.diff !== void 0 || this._pendingWorkerUpdate.optionsChanged;
          }
          _pixelsToTileUnits(e) {
            return e * (s.a3 / this.tileSize);
          }
          _getClusterMaxZoom(e) {
            const a = e ? Math.round(e) : this.maxzoom - 1;
            return Number.isInteger(e) || e === void 0 || s.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${a}"`), a;
          }
          load() {
            return s._(this, void 0, void 0, (function* () {
              yield this._updateWorkerData();
            }));
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          setData(e) {
            return this._data = e, this._pendingWorkerUpdate = { data: e }, this._updateWorkerData(), this;
          }
          updateData(e) {
            return this._pendingWorkerUpdate.diff = s.a4(this._pendingWorkerUpdate.diff, e), this._updateWorkerData(), this;
          }
          getData() {
            return s._(this, void 0, void 0, (function* () {
              const e = s.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: "GD", data: e });
            }));
          }
          getBounds() {
            return s._(this, void 0, void 0, (function* () {
              return ht(yield this.getData());
            }));
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom)), this._pendingWorkerUpdate.optionsChanged = true, this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e, source: this.id } });
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e, source: this.id } });
          }
          getClusterLeaves(e, a, c) {
            return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e, limit: a, offset: c } });
          }
          _updateWorkerData() {
            return s._(this, void 0, void 0, (function* () {
              if (this._isUpdatingWorker) return;
              if (!this._hasPendingWorkerUpdate()) return void s.w(`No pending worker updates for GeoJSONSource ${this.id}.`);
              const { data: e, diff: a } = this._pendingWorkerUpdate, c = s.e({ type: this.type }, this.workerOptions);
              e ? (typeof e == "string" ? (c.request = this.map._requestManager.transformRequest(L.resolveURL(e), "Source"), c.request.collectResourceTiming = this._collectResourceTiming) : c.data = JSON.stringify(e), this._pendingWorkerUpdate.data = void 0) : a && (c.dataDiff = a, this._pendingWorkerUpdate.diff = void 0), this._pendingWorkerUpdate.optionsChanged = void 0, this._isUpdatingWorker = true, this.fire(new s.l("dataloading", { dataType: "source" }));
              try {
                const m = yield this.actor.sendAsync({ type: "LD", data: c });
                if (this._isUpdatingWorker = false, this._removed || m.abandoned) return void this.fire(new s.l("dataabort", { dataType: "source" }));
                this._data = m.data;
                let _ = null;
                m.resourceTiming && m.resourceTiming[this.id] && (_ = m.resourceTiming[this.id].slice(0));
                const x = { dataType: "source" };
                this._collectResourceTiming && _ && _.length > 0 && s.e(x, { resourceTiming: _ }), this.fire(new s.l("data", Object.assign(Object.assign({}, x), { sourceDataType: "metadata" }))), this.fire(new s.l("data", Object.assign(Object.assign({}, x), { sourceDataType: "content", shouldReloadTileOptions: this._getShouldReloadTileOptions(a) })));
              } catch (m) {
                if (this._isUpdatingWorker = false, this._removed) return void this.fire(new s.l("dataabort", { dataType: "source" }));
                this.fire(new s.k(m));
              } finally {
                this._hasPendingWorkerUpdate() && this._updateWorkerData();
              }
            }));
          }
          _getShouldReloadTileOptions(e) {
            if (!e || e.removeAll) return;
            const { add: a = [], update: c = [], remove: m = [] } = e || {}, _ = /* @__PURE__ */ new Set([...c.map(((x) => x.id)), ...m]);
            return { nextBounds: [...c.map(((x) => x.newGeometry)), ...a.map(((x) => x.geometry))].map(((x) => ht(x))), prevIds: _ };
          }
          shouldReloadTile(e, { nextBounds: a, prevIds: c }) {
            const m = e.latestFeatureIndex.loadVTLayers();
            for (let T = 0; T < e.latestFeatureIndex.featureIndexArray.length; T++) {
              const R = e.latestFeatureIndex.featureIndexArray.get(T), A = m._geojsonTileLayer.feature(R.featureIndex);
              if (c.has(A.id)) return true;
            }
            const { buffer: _, extent: x } = this.workerOptions.geojsonVtOptions, k = (function({ x: T, y: R, z: A }, N = 0) {
              const j = s.a1((T - N) / Math.pow(2, A)), G = s.a2((R + 1 + N) / Math.pow(2, A)), Q = s.a1((T + 1 + N) / Math.pow(2, A)), le = s.a2((R - N) / Math.pow(2, A));
              return new nr([j, G], [Q, le]);
            })(e.tileID.canonical, _ / x);
            for (const T of a) if (k.intersects(T)) return true;
            return false;
          }
          loaded() {
            return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate();
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              const a = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const c = { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
              e.abortController = new AbortController();
              const m = yield this.actor.sendAsync({ type: a, data: c }, e.abortController);
              delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(m, this.map.painter, a === "RT");
            }));
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = true;
            }));
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
            }));
          }
          onRemove() {
            this._removed = true, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return s.e({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return false;
          }
        }
        class rt extends s.E {
          constructor(e, a, c, m) {
            super(), this.flippedWindingOrder = false, this.id = e, this.dispatcher = c, this.coordinates = a.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(m), this.options = a;
          }
          load(e) {
            return s._(this, void 0, void 0, (function* () {
              this._loaded = false, this.fire(new s.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const a = yield J.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = true, a && a.data && (this.image = a.data, e && (this.coordinates = e), this._finishLoading());
              } catch (a) {
                this._request = null, this._loaded = true, this.fire(new s.k(a));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          updateImage(e) {
            return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally((() => {
              this.texture = null;
            })), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new s.l("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(e) {
            this.coordinates = e;
            const a = e.map(s.a5.fromLngLat);
            var c;
            return this.tileID = (function(m) {
              const _ = s.a6.fromPoints(m), x = _.width(), k = _.height(), T = Math.max(x, k), R = Math.max(0, Math.floor(-Math.log(T) / Math.LN2)), A = Math.pow(2, R);
              return new s.a8(R, Math.floor((_.minX + _.maxX) / 2 * A), Math.floor((_.minY + _.maxY) / 2 * A));
            })(a), this.terrainTileRanges = this._getOverlappingTileRanges(a), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = a.map(((m) => this.tileID.getTilePoint(m)._round())), this.flippedWindingOrder = ((c = this.tileCoords)[1].x - c[0].x) * (c[2].y - c[0].y) - (c[1].y - c[0].y) * (c[2].x - c[0].x) < 0, this.fire(new s.l("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context, a = e.gl;
            this.texture || (this.texture = new s.T(e, this.image, a.RGBA), this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
            let c = false;
            for (const m in this.tiles) {
              const _ = this.tiles[m];
              _.state !== "loaded" && (_.state = "loaded", _.texture = this.texture, c = true);
            }
            c && this.fire(new s.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored";
            }));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return false;
          }
          _getOverlappingTileRanges(e) {
            const { minX: a, minY: c, maxX: m, maxY: _ } = s.a6.fromPoints(e), x = {};
            for (let k = 0; k <= s.a7; k++) {
              const T = Math.pow(2, k), R = Math.floor(a * T), A = Math.floor(c * T), N = Math.floor(m * T), j = Math.floor(_ * T);
              x[k] = { minTileX: R, minTileY: A, maxTileX: N, maxTileY: j };
            }
            return x;
          }
        }
        class vt extends rt {
          constructor(e, a, c, m) {
            super(e, a, c, m), this.roundZoom = true, this.type = "video", this.options = a;
          }
          load() {
            return s._(this, void 0, void 0, (function* () {
              this._loaded = false;
              const e = this.options;
              this.urls = [];
              for (const a of e.urls) this.urls.push(this.map._requestManager.transformRequest(a, "Source").url);
              try {
                const a = yield s.a9(this.urls);
                if (this._loaded = true, !a) return;
                this.video = a, this.video.loop = true, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint();
                })), this.map && this.video.play(), this._finishLoading();
              } catch (a) {
                this.fire(new s.k(a));
              }
            }));
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(e) {
            if (this.video) {
              const a = this.video.seekable;
              e < a.start(0) || e > a.end(0) ? this.fire(new s.k(new s.aa(`sources.${this.id}`, null, `Playback for this video can be set only between the ${a.start(0)} and ${a.end(0)}-second mark.`))) : this.video.currentTime = e;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const e = this.map.painter.context, a = e.gl;
            this.texture ? this.video.paused || (this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE), a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, a.RGBA, a.UNSIGNED_BYTE, this.video)) : (this.texture = new s.T(e, this.video, a.RGBA), this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
            let c = false;
            for (const m in this.tiles) {
              const _ = this.tiles[m];
              _.state !== "loaded" && (_.state = "loaded", _.texture = this.texture, c = true);
            }
            c && this.fire(new s.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class Wt extends rt {
          constructor(e, a, c, m) {
            super(e, a, c, m), a.coordinates ? Array.isArray(a.coordinates) && a.coordinates.length === 4 && !a.coordinates.some(((_) => !Array.isArray(_) || _.length !== 2 || _.some(((x) => typeof x != "number")))) || this.fire(new s.k(new s.aa(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new s.k(new s.aa(`sources.${e}`, null, 'missing required property "coordinates"'))), a.animate && typeof a.animate != "boolean" && this.fire(new s.k(new s.aa(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), a.canvas ? typeof a.canvas == "string" || a.canvas instanceof HTMLCanvasElement || this.fire(new s.k(new s.aa(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new s.k(new s.aa(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = a, this.animate = a.animate === void 0 || a.animate;
          }
          load() {
            return s._(this, void 0, void 0, (function* () {
              this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new s.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = true, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = false);
              }, this._finishLoading());
            }));
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let e = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e = true), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const a = this.map.painter.context, c = a.gl;
            this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new s.T(a, this.canvas, c.RGBA, { premultiply: true });
            let m = false;
            for (const _ in this.tiles) {
              const x = this.tiles[_];
              x.state !== "loaded" && (x.state = "loaded", x.texture = this.texture, m = true);
            }
            m && this.fire(new s.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return true;
            return false;
          }
        }
        const ci = {}, Ai = (v) => {
          switch (v) {
            case "geojson":
              return bt;
            case "image":
              return rt;
            case "raster":
              return at;
            case "raster-dem":
              return Oe;
            case "vector":
              return ze;
            case "video":
              return vt;
            case "canvas":
              return Wt;
          }
          return ci[v];
        }, sn = "RTLPluginLoaded";
        class Fe extends s.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Cr();
          }
          _syncState(e) {
            return this.status = e, this.dispatcher.broadcast("SRPS", { pluginStatus: e, pluginURL: this.url }).catch(((a) => {
              throw this.status = "error", a;
            }));
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null;
          }
          setRTLTextPlugin(e) {
            return s._(this, arguments, void 0, (function* (a, c = false) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = L.resolveURL(a), !this.url) throw new Error(`requested url ${a} is invalid`);
              if (this.status === "unavailable") {
                if (!c) return this._requestImport();
                this.status = "deferred", this._syncState(this.status);
              } else if (this.status === "requested") return this._requestImport();
            }));
          }
          _requestImport() {
            return s._(this, void 0, void 0, (function* () {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new s.l(sn));
            }));
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
          }
        }
        let X = null;
        function Y() {
          return X || (X = new Fe()), X;
        }
        var ne, ve;
        (function(v) {
          v[v.Base = 0] = "Base", v[v.Parent = 1] = "Parent";
        })(ne || (ne = {})), (function(v) {
          v[v.Departing = 0] = "Departing", v[v.Incoming = 1] = "Incoming";
        })(ve || (ve = {}));
        class Ce {
          constructor(e, a) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.fadeOpacity = 1, this.tileID = e, this.uid = s.ab(), this.uses = 0, this.tileSize = a, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          isRenderable(e) {
            return this.hasData() && (!this.fadeEndTime || this.fadeOpacity > 0) && (e || !this.holdingForSymbolFade());
          }
          setCrossFadeLogic({ fadingRole: e, fadingDirection: a, fadingParentID: c, fadeEndTime: m }) {
            this.resetFadeLogic(), this.fadingRole = e, this.fadingDirection = a, this.fadingParentID = c, this.fadeEndTime = m;
          }
          setSelfFadeLogic(e) {
            this.resetFadeLogic(), this.selfFading = true, this.fadeEndTime = e;
          }
          resetFadeLogic() {
            this.fadingRole = null, this.fadingDirection = null, this.fadingParentID = null, this.selfFading = false, this.timeAdded = z(), this.fadeEndTime = 0, this.fadeOpacity = 1;
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(e, a, c) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = (function(m, _) {
                const x = {};
                if (!_) return x;
                for (const k of m) {
                  const T = k.layerIds.map(((R) => _.getLayer(R))).filter(Boolean);
                  if (T.length !== 0) {
                    k.layers = T, k.stateDependentLayerIds && (k.stateDependentLayers = k.stateDependentLayerIds.map(((R) => T.filter(((A) => A.id === R))[0])));
                    for (const R of T) x[R.id] = k;
                  }
                }
                return x;
              })(e.buckets, a == null ? void 0 : a.style), this.hasSymbolBuckets = false;
              for (const m in this.buckets) {
                const _ = this.buckets[m];
                if (_ instanceof s.ad) {
                  if (this.hasSymbolBuckets = true, !c) break;
                  _.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets) for (const m in this.buckets) {
                const _ = this.buckets[m];
                if (_ instanceof s.ad && _.hasRTLText) {
                  this.hasRTLText = true, Y().lazyLoad();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const m in this.buckets) {
                const _ = this.buckets[m];
                this.queryPadding = Math.max(this.queryPadding, a.style.getLayer(m).queryRadius(_));
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage), this.dashPositions = e.dashPositions;
            } else this.collisionBoxArray = new s.ac();
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions && (this.dashPositions = null), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(e) {
            return this.buckets[e.id];
          }
          upload(e) {
            for (const c in this.buckets) {
              const m = this.buckets[c];
              m.uploadPending() && m.upload(e);
            }
            const a = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new s.T(e, this.imageAtlas.image, a.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new s.T(e, this.glyphAtlasImage, a.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
          }
          queryRenderedFeatures(e, a, c, m, _, x, k, T, R, A, N) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: m, cameraQueryGeometry: _, scale: x, tileSize: this.tileSize, pixelPosMatrix: A, transform: T, params: k, queryPadding: this.queryPadding * R, getElevation: N }, e, a, c) : {};
          }
          querySourceFeatures(e, a) {
            const c = this.latestFeatureIndex;
            if (!c || !c.rawTileData) return;
            const m = c.loadVTLayers(), _ = a && a.sourceLayer ? a.sourceLayer : "", x = m._geojsonTileLayer || m[_];
            if (!x) return;
            const k = s.ae(a == null ? void 0 : a.filter, a == null ? void 0 : a.globalState), { z: T, x: R, y: A } = this.tileID.canonical, N = { z: T, x: R, y: A };
            for (let j = 0; j < x.length; j++) {
              const G = x.feature(j);
              if (k.needGeometry) {
                const ce = s.af(G, true);
                if (!k.filter(new s.G(this.tileID.overscaledZ), ce, this.tileID.canonical)) continue;
              } else if (!k.filter(new s.G(this.tileID.overscaledZ), G)) continue;
              const Q = c.getId(G, _), le = new s.ag(G, T, R, A, Q);
              le.tile = N, e.push(le);
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(e) {
            const a = this.expirationTime;
            if (e.cacheControl) {
              const c = s.ah(e.cacheControl);
              c["max-age"] && (this.expirationTime = Date.now() + 1e3 * c["max-age"]);
            } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const c = Date.now();
              let m = false;
              if (this.expirationTime > c) m = false;
              else if (a) if (this.expirationTime < a) m = true;
              else {
                const _ = this.expirationTime - a;
                _ ? this.expirationTime = c + Math.max(_, 3e4) : m = true;
              }
              else m = true;
              m ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(e, a) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
            const c = this.latestFeatureIndex.loadVTLayers();
            for (const m in this.buckets) {
              if (!a.style.hasLayer(m)) continue;
              const _ = this.buckets[m], x = _.layers[0].sourceLayer || "_geojsonTileLayer", k = c[x], T = e[x];
              if (!k || !T || Object.keys(T).length === 0) continue;
              _.update(T, k, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
              const R = a && a.style && a.style.getLayer(m);
              R && (this.queryPadding = Math.max(this.queryPadding, R.queryRadius(_)));
            }
          }
          holdingForSymbolFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < z();
          }
          clearSymbolFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setSymbolHoldDuration(e) {
            this.symbolFadeHoldUntil = z() + e;
          }
          setDependencies(e, a) {
            const c = {};
            for (const m of a) c[m] = true;
            this.dependencies[e] = c;
          }
          hasDependency(e, a) {
            for (const c of e) {
              const m = this.dependencies[c];
              if (m) {
                for (const _ of a) if (m[_]) return true;
              }
            }
            return false;
          }
        }
        class ae {
          constructor(e, a) {
            this.max = e, this.onRemove = a, this.reset();
          }
          reset() {
            for (const e in this.data) for (const a of this.data[e]) a.timeout && clearTimeout(a.timeout), this.onRemove(a.value);
            return this.data = {}, this.order = [], this;
          }
          add(e, a, c) {
            const m = e.wrapped().key;
            this.data[m] === void 0 && (this.data[m] = []);
            const _ = { value: a, timeout: void 0 };
            if (c !== void 0 && (_.timeout = setTimeout((() => {
              this.remove(e, _);
            }), c)), this.data[m].push(_), this.order.push(m), this.order.length > this.max) {
              const x = this._getAndRemoveByKey(this.order[0]);
              x && this.onRemove(x);
            }
            return this;
          }
          has(e) {
            return e.wrapped().key in this.data;
          }
          getAndRemove(e) {
            return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
          }
          _getAndRemoveByKey(e) {
            const a = this.data[e].shift();
            return a.timeout && clearTimeout(a.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), a.value;
          }
          getByKey(e) {
            const a = this.data[e];
            return a ? a[0].value : null;
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null;
          }
          remove(e, a) {
            if (!this.has(e)) return this;
            const c = e.wrapped().key, m = a === void 0 ? 0 : this.data[c].indexOf(a), _ = this.data[c][m];
            return this.data[c].splice(m, 1), _.timeout && clearTimeout(_.timeout), this.data[c].length === 0 && delete this.data[c], this.onRemove(_.value), this.order.splice(this.order.indexOf(c), 1), this;
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max; ) {
              const a = this._getAndRemoveByKey(this.order[0]);
              a && this.onRemove(a);
            }
            return this;
          }
          filter(e) {
            const a = [];
            for (const c in this.data) for (const m of this.data[c]) e(m.value) || a.push(m);
            for (const c of a) this.remove(c.value.tileID, c);
          }
        }
        class Pe {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(e, a, c) {
            const m = String(a);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][m] = this.stateChanges[e][m] || {}, s.e(this.stateChanges[e][m], c), this.deletedStates[e] === null) {
              this.deletedStates[e] = {};
              for (const _ in this.state[e]) _ !== m && (this.deletedStates[e][_] = null);
            } else if (this.deletedStates[e] && this.deletedStates[e][m] === null) {
              this.deletedStates[e][m] = {};
              for (const _ in this.state[e][m]) c[_] || (this.deletedStates[e][m][_] = null);
            } else for (const _ in c) this.deletedStates[e] && this.deletedStates[e][m] && this.deletedStates[e][m][_] === null && delete this.deletedStates[e][m][_];
          }
          removeFeatureState(e, a, c) {
            if (this.deletedStates[e] === null) return;
            const m = String(a);
            if (this.deletedStates[e] = this.deletedStates[e] || {}, c && a !== void 0) this.deletedStates[e][m] !== null && (this.deletedStates[e][m] = this.deletedStates[e][m] || {}, this.deletedStates[e][m][c] = null);
            else if (a !== void 0) if (this.stateChanges[e] && this.stateChanges[e][m]) for (c in this.deletedStates[e][m] = {}, this.stateChanges[e][m]) this.deletedStates[e][m][c] = null;
            else this.deletedStates[e][m] = null;
            else this.deletedStates[e] = null;
          }
          getState(e, a) {
            const c = String(a), m = s.e({}, (this.state[e] || {})[c], (this.stateChanges[e] || {})[c]);
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const _ = this.deletedStates[e][a];
              if (_ === null) return {};
              for (const x in _) delete m[x];
            }
            return m;
          }
          initializeTileState(e, a) {
            e.setFeatureState(this.state, a);
          }
          coalesceChanges(e, a) {
            const c = {};
            for (const m in this.stateChanges) {
              this.state[m] = this.state[m] || {};
              const _ = {};
              for (const x in this.stateChanges[m]) this.state[m][x] || (this.state[m][x] = {}), s.e(this.state[m][x], this.stateChanges[m][x]), _[x] = this.state[m][x];
              c[m] = _;
            }
            for (const m in this.deletedStates) {
              this.state[m] = this.state[m] || {};
              const _ = {};
              if (this.deletedStates[m] === null) for (const x in this.state[m]) _[x] = {}, this.state[m][x] = {};
              else for (const x in this.deletedStates[m]) {
                if (this.deletedStates[m][x] === null) this.state[m][x] = {};
                else for (const k of Object.keys(this.deletedStates[m][x])) delete this.state[m][x][k];
                _[x] = this.state[m][x];
              }
              c[m] = c[m] || {}, s.e(c[m], _);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(c).length !== 0) for (const m in e) e[m].setFeatureState(c, a);
          }
        }
        const xe = 89.25;
        function Ve(v, e) {
          const a = s.ai(e.lat, -s.aj, s.aj);
          return new s.P(s.X(e.lng) * v, s.W(a) * v);
        }
        function et(v, e) {
          return new s.a5(e.x / v, e.y / v).toLngLat();
        }
        function We(v) {
          return v.cameraToCenterDistance * Math.min(0.85 * Math.tan(s.ak(90 - v.pitch)), Math.tan(s.ak(xe - v.pitch)));
        }
        function xt(v, e) {
          const a = v.canonical, c = e / s.al(a.z), m = a.x + Math.pow(2, a.z) * v.wrap, _ = s.am(new Float64Array(16));
          return s.N(_, _, [m * c, a.y * c, 0]), s.O(_, _, [c / s.a3, c / s.a3, 1]), _;
        }
        function Le(v, e, a, c, m) {
          const _ = s.a5.fromLngLat(v, e), x = m * s.an(1, v.lat), k = x * Math.cos(s.ak(a)), T = Math.sqrt(x * x - k * k), R = T * Math.sin(s.ak(-c)), A = T * Math.cos(s.ak(-c));
          return new s.a5(_.x + R, _.y + A, _.z + k);
        }
        function rr(v, e, a) {
          const c = e.intersectsFrustum(v);
          if (!a || c === 0) return c;
          const m = e.intersectsPlane(a);
          return m === 0 ? 0 : c === 2 && m === 2 ? 2 : 1;
        }
        function Zr(v, e, a) {
          let c = 0;
          const m = (a - e) / 10;
          for (let _ = 0; _ < 10; _++) c += m * Math.pow(Math.cos(e + (_ + 0.5) / 10 * (a - e)), v);
          return c;
        }
        function Ut(v, e) {
          return function(a, c, m, _, x) {
            const k = 2 * ((v - 1) / s.ao(Math.cos(s.ak(xe - x)) / Math.cos(s.ak(xe))) - 1), T = Math.acos(m / _), R = 2 * Zr(k - 1, 0, s.ak(x / 2)), A = Math.min(s.ak(xe), T + s.ak(x / 2)), N = Zr(k - 1, Math.min(A, T - s.ak(x / 2)), A), j = Math.atan(c / m), G = Math.hypot(c, m);
            let Q = a;
            return Q += s.ao(_ / G / Math.max(0.5, Math.cos(s.ak(x / 2)))), Q += k * s.ao(Math.cos(j)) / 2, Q -= s.ao(Math.max(1, N / R / e)) / 2, Q;
          };
        }
        const dr = Ut(9.314, 3);
        function Er(v, e) {
          const a = (e.roundZoom ? Math.round : Math.floor)(v.zoom + s.ao(v.tileSize / e.tileSize));
          return Math.max(0, a);
        }
        function jr(v, e) {
          const a = v.getCameraFrustum(), c = v.getClippingPlane(), m = v.screenPointToMercatorCoordinate(v.getCameraPoint()), _ = s.a5.fromLngLat(v.center, v.elevation);
          m.z = _.z + Math.cos(v.pitchInRadians) * v.cameraToCenterDistance / v.worldSize;
          const x = v.getCoveringTilesDetailsProvider(), k = x.allowVariableZoom(v, e), T = Er(v, e), R = e.minzoom || 0, A = e.maxzoom !== void 0 ? e.maxzoom : v.maxZoom, N = Math.min(Math.max(0, T), A), j = Math.pow(2, N), G = [j * m.x, j * m.y, 0], Q = [j * _.x, j * _.y, 0], le = Math.hypot(_.x - m.x, _.y - m.y), ce = Math.abs(_.z - m.z), de = Math.hypot(le, ce), ge = (ke) => ({ zoom: 0, x: 0, y: 0, wrap: ke, fullyVisible: false }), Se = [], me = [];
          if (v.renderWorldCopies && x.allowWorldCopies()) for (let ke = 1; ke <= 3; ke++) Se.push(ge(-ke)), Se.push(ge(ke));
          for (Se.push(ge(0)); Se.length > 0; ) {
            const ke = Se.pop(), Re = ke.x, ye = ke.y;
            let Be = ke.fullyVisible;
            const Ke = { x: Re, y: ye, z: ke.zoom }, He = x.getTileBoundingVolume(Ke, ke.wrap, v.elevation, e);
            if (!Be) {
              const Tt = rr(a, He, c);
              if (Tt === 0) continue;
              Be = Tt === 2;
            }
            const Ye = x.distanceToTile2d(m.x, m.y, Ke, He);
            let Qe = T;
            k && (Qe = (e.calculateTileZoom || dr)(v.zoom + s.ao(v.tileSize / e.tileSize), Ye, ce, de, v.fov)), Qe = (e.roundZoom ? Math.round : Math.floor)(Qe), Qe = Math.max(0, Qe);
            const Pt = Math.min(Qe, A);
            if (ke.wrap = x.getWrap(_, Ke, ke.wrap), ke.zoom >= Pt) {
              if (ke.zoom < R) continue;
              const Tt = N - ke.zoom, dt = G[0] - 0.5 - (Re << Tt), Nt = G[1] - 0.5 - (ye << Tt), pr = e.reparseOverscaled ? Math.max(ke.zoom, Qe) : ke.zoom;
              me.push({ tileID: new s.a0(ke.zoom === A ? pr : ke.zoom, ke.wrap, ke.zoom, Re, ye), distanceSq: s.ap([Q[0] - 0.5 - Re, Q[1] - 0.5 - ye]), tileDistanceToCamera: Math.sqrt(dt * dt + Nt * Nt) });
            } else for (let Tt = 0; Tt < 4; Tt++) Se.push({ zoom: ke.zoom + 1, x: (Re << 1) + Tt % 2, y: (ye << 1) + (Tt >> 1), wrap: ke.wrap, fullyVisible: Be });
          }
          return me.sort(((ke, Re) => ke.distanceSq - Re.distanceSq)).map(((ke) => ke.tileID));
        }
        const di = s.a6.fromPoints([new s.P(0, 0), new s.P(s.a3, s.a3)]);
        class Hr extends s.E {
          constructor(e, a, c) {
            super(), this.id = e, this.dispatcher = c, this.on("data", ((m) => this._dataHandler(m))), this.on("dataloading", (() => {
              this._sourceErrored = false;
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded();
            })), this._source = ((m, _, x, k) => {
              const T = new (Ai(_.type))(m, _, x, k);
              if (T.id !== m) throw new Error(`Expected Source id to be ${m} instead of ${T.id}`);
              return T;
            })(e, a, c, this), this._tiles = {}, this._cache = new ae(0, ((m) => this._unloadTile(m))), this._timers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._rasterFadeDuration = 0, this._maxFadingAncestorLevels = 5, this._state = new Pe(), this._didEmitContent = false, this._updated = false;
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e);
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e);
          }
          loaded() {
            if (this._sourceErrored) return true;
            if (!this._sourceLoaded || !this._source.loaded()) return false;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return true;
            if (!this._updated) return false;
            for (const e in this._tiles) {
              const a = this._tiles[e];
              if (a.state !== "loaded" && a.state !== "errored") return false;
            }
            return true;
          }
          getSource() {
            return this._source;
          }
          getState() {
            return this._state;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, e && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(e, a, c) {
            return s._(this, void 0, void 0, (function* () {
              try {
                yield this._source.loadTile(e), this._tileLoaded(e, a, c);
              } catch (m) {
                e.state = "errored", m.status !== 404 ? this._source.fire(new s.k(m, { tile: e })) : this.update(this.transform, this.terrain);
              }
            }));
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e);
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e), this._source.fire(new s.l("dataabort", { tile: e, coord: e.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const a in this._tiles) {
              const c = this._tiles[a];
              c.upload(e), c.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map(((e) => e.tileID)).sort(Jr).map(((e) => e.key));
          }
          getRenderableIds(e) {
            const a = [];
            for (const c in this._tiles) this._isIdRenderable(c, e) && a.push(this._tiles[c]);
            return e ? a.sort(((c, m) => {
              const _ = c.tileID, x = m.tileID, k = new s.P(_.canonical.x, _.canonical.y)._rotate(-this.transform.bearingInRadians), T = new s.P(x.canonical.x, x.canonical.y)._rotate(-this.transform.bearingInRadians);
              return _.overscaledZ - x.overscaledZ || T.y - k.y || T.x - k.x;
            })).map(((c) => c.tileID.key)) : a.map(((c) => c.tileID)).sort(Jr).map(((c) => c.key));
          }
          hasRenderableParent(e) {
            const a = e.overscaledZ - 1;
            if (a >= this._source.minzoom) {
              const c = this.getLoadedTile(e.scaledTo(a));
              if (c) return this._isIdRenderable(c.tileID.key);
            }
            return false;
          }
          _isIdRenderable(e, a = false) {
            var c;
            return (c = this._tiles[e]) === null || c === void 0 ? void 0 : c.isRenderable(a);
          }
          reload(e, a = void 0) {
            if (this._paused) this._shouldReloadOnResume = true;
            else {
              this._cache.reset();
              for (const c in this._tiles) a && this._source.shouldReloadTile && !this._source.shouldReloadTile(this._tiles[c], a) || (e ? this._reloadTile(c, "expired") : this._tiles[c].state !== "errored" && this._reloadTile(c, "reloading"));
            }
          }
          _reloadTile(e, a) {
            return s._(this, void 0, void 0, (function* () {
              const c = this._tiles[e];
              c && (c.state !== "loading" && (c.state = a), yield this._loadTile(c, e, a));
            }));
          }
          _tileLoaded(e, a, c) {
            e.timeAdded = z(), e.selfFading && (e.fadeEndTime = e.timeAdded + this._rasterFadeDuration), c === "expired" && (e.refreshedUponExpiration = true), this._setTileReloadTimer(a, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new s.l("data", { dataType: "source", tile: e, coord: e.tileID }));
          }
          _backfillDEM(e) {
            const a = this.getRenderableIds();
            for (let m = 0; m < a.length; m++) {
              const _ = a[m];
              if (e.neighboringTiles && e.neighboringTiles[_]) {
                const x = this.getTileByID(_);
                c(e, x), c(x, e);
              }
            }
            function c(m, _) {
              m.needsHillshadePrepare = true, m.needsTerrainPrepare = true;
              let x = _.tileID.canonical.x - m.tileID.canonical.x;
              const k = _.tileID.canonical.y - m.tileID.canonical.y, T = Math.pow(2, m.tileID.canonical.z), R = _.tileID.key;
              x === 0 && k === 0 || Math.abs(k) > 1 || (Math.abs(x) > 1 && (Math.abs(x + T) === 1 ? x += T : Math.abs(x - T) === 1 && (x -= T)), _.dem && m.dem && (m.dem.backfillBorder(_.dem, x, k), m.neighboringTiles && m.neighboringTiles[R] && (m.neighboringTiles[R].backfilled = true)));
            }
          }
          getTile(e) {
            return this.getTileByID(e.key);
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          _retainLoadedChildren(e, a) {
            const c = Object.values(e), m = this._getLoadedDescendents(c), _ = {};
            for (const x of c) {
              const k = m[x.key];
              if (!(k == null ? void 0 : k.length)) {
                _[x.key] = x;
                continue;
              }
              const T = x.overscaledZ + Hr.maxUnderzooming, R = k.filter(((j) => j.tileID.overscaledZ <= T));
              if (!R.length) {
                _[x.key] = x;
                continue;
              }
              const A = Math.min(...R.map(((j) => j.tileID.overscaledZ))), N = R.filter(((j) => j.tileID.overscaledZ === A)).map(((j) => j.tileID));
              for (const j of N) a[j.key] = j;
              this._areDescendentsComplete(N, A, x.overscaledZ) || (_[x.key] = x);
            }
            return _;
          }
          _getLoadedDescendents(e) {
            var a;
            const c = {};
            for (const m in this._tiles) {
              const _ = this._tiles[m];
              if (_.hasData()) for (const x of e) _.tileID.isChildOf(x) && (c[a = x.key] || (c[a] = [])).push(_);
            }
            return c;
          }
          _areDescendentsComplete(e, a, c) {
            return e.length === 1 && e[0].isOverscaled() ? e[0].overscaledZ === a : Math.pow(4, a - c) === e.length;
          }
          getLoadedTile(e) {
            const a = this._tiles[e.key];
            return (a == null ? void 0 : a.hasData()) ? a : null;
          }
          updateCacheSize(e) {
            const a = Math.ceil(e.width / this._source.tileSize) + 1, c = Math.ceil(e.height / this._source.tileSize) + 1, m = Math.floor(a * c * (this._maxTileCacheZoomLevels === null ? s.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), _ = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, m) : m;
            this._cache.setMaxSize(_);
          }
          handleWrapJump(e) {
            const a = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
            if (this._prevLng = e, a) {
              const c = {};
              for (const m in this._tiles) {
                const _ = this._tiles[m];
                _.tileID = _.tileID.unwrapTo(_.tileID.wrap + a), c[_.tileID.key] = _;
              }
              this._tiles = c, this._resetTileReloadTimers();
            }
          }
          update(e, a) {
            if (!this._sourceLoaded || this._paused) return;
            let c;
            this.transform = e, this.terrain = a, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this.used || this.usedForTerrain ? this._source.tileID ? c = e.getVisibleUnwrappedCoordinates(this._source.tileID).map(((T) => new s.a0(T.canonical.z, T.wrap, T.canonical.z, T.canonical.x, T.canonical.y))) : (c = jr(e, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: a, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (c = c.filter(((T) => this._source.hasTile(T))))) : c = [], this.usedForTerrain && (c = this._addTerrainIdealTiles(c));
            const m = c.length === 0 && !this._updated && this._didEmitContent;
            this._updated = true, m && this.fire(new s.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const _ = Er(e, this._source), x = this._updateRetainedTiles(c, _), k = Lr(this._source.type);
            k && this._rasterFadeDuration > 0 && !a && this._updateFadingTiles(c, x), k ? this._cleanUpRasterTiles(x) : this._cleanUpVectorTiles(x);
          }
          _cleanUpRasterTiles(e) {
            for (const a in this._tiles) e[a] || this._removeTile(a);
          }
          _cleanUpVectorTiles(e) {
            for (const a in this._tiles) {
              const c = this._tiles[a];
              e[a] ? c.clearSymbolFadeHold() : c.hasSymbolBuckets ? c.holdingForSymbolFade() ? c.symbolFadeFinished() && this._removeTile(a) : c.setSymbolHoldDuration(this.map._fadeDuration) : this._removeTile(a);
            }
          }
          _addTerrainIdealTiles(e) {
            const a = [];
            for (const c of e) if (c.canonical.z > this._source.minzoom) {
              const m = c.scaledTo(c.canonical.z - 1);
              a.push(m);
              const _ = c.scaledTo(Math.max(this._source.minzoom, Math.min(c.canonical.z, 5)));
              a.push(_);
            }
            return e.concat(a);
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForSymbolFade() && this._removeTile(e);
          }
          _updateRetainedTiles(e, a) {
            var c;
            const m = {}, _ = {}, x = Math.max(a - Hr.maxOverzooming, this._source.minzoom);
            let k = {};
            for (const T of e) {
              const R = this._addTile(T);
              m[T.key] = T, R.hasData() || (k[T.key] = T);
            }
            k = this._retainLoadedChildren(k, m);
            for (const T in k) {
              const R = k[T];
              let A = this._tiles[T], N = A == null ? void 0 : A.wasRequested();
              for (let j = R.overscaledZ - 1; j >= x; --j) {
                const G = R.scaledTo(j);
                if (_[G.key]) break;
                if (_[G.key] = true, A = this.getTile(G), !A && N && (A = this._addTile(G)), A) {
                  const Q = A.hasData();
                  if ((Q || !(!((c = this.map) === null || c === void 0) && c.cancelPendingTileRequestsWhileZooming) || N) && (m[G.key] = G), N = A.wasRequested(), Q) break;
                }
              }
            }
            return m;
          }
          _updateFadingTiles(e, a) {
            const c = z(), m = s.aq(e);
            for (const _ of e) {
              const x = this._tiles[_.key];
              x.fadingDirection !== ve.Departing && x.fadeOpacity !== 0 || x.resetFadeLogic(), this._updateFadingAncestor(x, a, c) || this._updateFadingDescendents(x, a, c) || this._updateFadingEdge(x, m, c) || x.resetFadeLogic();
            }
          }
          _updateFadingAncestor(e, a, c) {
            if (!e.hasData()) return false;
            const { tileID: m, fadingRole: _, fadingDirection: x, fadingParentID: k } = e;
            if (_ === ne.Base && x === ve.Incoming && k) return a[k.key] = k, true;
            const T = Math.max(m.overscaledZ - this._maxFadingAncestorLevels, this._source.minzoom);
            for (let R = m.overscaledZ - 1; R >= T; R--) {
              const A = m.scaledTo(R), N = this.getLoadedTile(A);
              if (N) return e.setCrossFadeLogic({ fadingRole: ne.Base, fadingDirection: ve.Incoming, fadingParentID: N.tileID, fadeEndTime: c + this._rasterFadeDuration }), N.setCrossFadeLogic({ fadingRole: ne.Parent, fadingDirection: ve.Departing, fadeEndTime: c + this._rasterFadeDuration }), a[A.key] = A, true;
            }
            return false;
          }
          _updateFadingDescendents(e, a, c) {
            if (!e.hasData()) return false;
            const m = e.tileID.children(this._source.maxzoom);
            let _ = this._updateFadingChildren(e, m, a, c);
            if (_) return true;
            for (const x of m) {
              const k = x.children(this._source.maxzoom);
              this._updateFadingChildren(e, k, a, c) && (_ = true);
            }
            return _;
          }
          _updateFadingChildren(e, a, c, m) {
            if (a[0].overscaledZ >= this._source.maxzoom) return false;
            let _ = false;
            for (const x of a) {
              const k = this.getLoadedTile(x);
              if (!k) continue;
              const { fadingRole: T, fadingDirection: R, fadingParentID: A } = k;
              T === ne.Base && R === ve.Departing && A || (k.setCrossFadeLogic({ fadingRole: ne.Base, fadingDirection: ve.Departing, fadingParentID: e.tileID, fadeEndTime: m + this._rasterFadeDuration }), e.setCrossFadeLogic({ fadingRole: ne.Parent, fadingDirection: ve.Incoming, fadeEndTime: m + this._rasterFadeDuration })), c[x.key] = x, _ = true;
            }
            return _;
          }
          _updateFadingEdge(e, a, c) {
            const m = e.tileID;
            return !!e.selfFading || !e.hasData() && !!a.has(m) && (e.setSelfFadeLogic(c + this._rasterFadeDuration), true);
          }
          _addTile(e) {
            let a = this._tiles[e.key];
            if (a) return a;
            a = this._cache.getAndRemove(e), a && (a.resetFadeLogic(), this._setTileReloadTimer(e.key, a), a.tileID = e, this._state.initializeTileState(a, this.map ? this.map.painter : null));
            const c = a;
            return a || (a = new Ce(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(a, e.key, a.state)), a.uses++, this._tiles[e.key] = a, c || this._source.fire(new s.l("dataloading", { tile: a, coord: a.tileID, dataType: "source" })), a;
          }
          _setTileReloadTimer(e, a) {
            this._clearTileReloadTimer(e);
            const c = a.getExpiryTimeout();
            c && (this._timers[e] = setTimeout((() => {
              this._reloadTile(e, "expired"), delete this._timers[e];
            }), c));
          }
          _clearTileReloadTimer(e) {
            const a = this._timers[e];
            a && (clearTimeout(a), delete this._timers[e]);
          }
          _resetTileReloadTimers() {
            for (const e in this._timers) clearTimeout(this._timers[e]), delete this._timers[e];
            for (const e in this._tiles) this._setTileReloadTimer(e, this._tiles[e]);
          }
          refreshTiles(e) {
            for (const a in this._tiles) (this._isIdRenderable(a) || this._tiles[a].state == "errored") && e.some(((c) => c.equals(this._tiles[a].tileID.canonical))) && this._reloadTile(a, "expired");
          }
          _removeTile(e) {
            const a = this._tiles[e];
            a && (a.uses--, delete this._tiles[e], this._clearTileReloadTimer(e), a.uses > 0 || (a.hasData() && a.state !== "reloading" ? this._cache.add(a.tileID, a, a.getExpiryTimeout()) : (a.aborted = true, this._abortTile(a), this._unloadTile(a))));
          }
          _dataHandler(e) {
            e.dataType === "source" && (e.sourceDataType !== "metadata" ? e.sourceDataType === "content" && this._sourceLoaded && !this._paused && (this.reload(e.sourceDataChanged, e.shouldReloadTileOptions), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true) : this._sourceLoaded = true);
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset();
          }
          tilesIn(e, a, c) {
            const m = [], _ = this.transform;
            if (!_) return m;
            const x = _.getCoveringTilesDetailsProvider().allowWorldCopies(), k = c ? _.getCameraQueryGeometry(e) : e, T = (G) => _.screenPointToMercatorCoordinate(G, this.terrain), R = this.transformBbox(e, T, !x), A = this.transformBbox(k, T, !x), N = this.getIds(), j = s.a6.fromPoints(A);
            for (let G = 0; G < N.length; G++) {
              const Q = this._tiles[N[G]];
              if (Q.holdingForSymbolFade()) continue;
              const le = x ? [Q.tileID] : [Q.tileID.unwrapTo(-1), Q.tileID.unwrapTo(0)], ce = Math.pow(2, _.zoom - Q.tileID.overscaledZ), de = a * Q.queryPadding * s.a3 / Q.tileSize / ce;
              for (const ge of le) {
                const Se = j.map(((me) => ge.getTilePoint(new s.a5(me.x, me.y))));
                if (Se.expandBy(de), Se.intersects(di)) {
                  const me = R.map(((Re) => ge.getTilePoint(Re))), ke = A.map(((Re) => ge.getTilePoint(Re)));
                  m.push({ tile: Q, tileID: x ? ge : ge.unwrapTo(0), queryGeometry: me, cameraQueryGeometry: ke, scale: ce });
                }
              }
            }
            return m;
          }
          transformBbox(e, a, c) {
            let m = e.map(a);
            if (c) {
              const _ = s.a6.fromPoints(e);
              _.shrinkBy(1e-3 * Math.min(_.width(), _.height()));
              const x = _.map(a);
              s.a6.fromPoints(m).covers(x) || (m = m.map(((k) => k.x > 0.5 ? new s.a5(k.x - 1, k.y, k.z) : k)));
            }
            return m;
          }
          getVisibleCoordinates(e) {
            const a = this.getRenderableIds(e).map(((c) => this._tiles[c].tileID));
            return this.transform && this.transform.populateCache(a), a;
          }
          hasTransition() {
            if (this._source.hasTransition()) return true;
            if (Lr(this._source.type) && this._rasterFadeDuration > 0) {
              const e = z();
              for (const a in this._tiles) if (this._tiles[a].fadeEndTime >= e) return true;
            }
            return false;
          }
          setRasterFadeDuration(e) {
            this._rasterFadeDuration = e;
          }
          setFeatureState(e, a, c) {
            this._state.updateState(e = e || "_geojsonTileLayer", a, c);
          }
          removeFeatureState(e, a, c) {
            this._state.removeFeatureState(e = e || "_geojsonTileLayer", a, c);
          }
          getFeatureState(e, a) {
            return this._state.getState(e = e || "_geojsonTileLayer", a);
          }
          setDependencies(e, a, c) {
            const m = this._tiles[e];
            m && m.setDependencies(a, c);
          }
          reloadTilesForDependencies(e, a) {
            for (const c in this._tiles) this._tiles[c].hasDependency(e, a) && this._reloadTile(c, "reloading");
            this._cache.filter(((c) => !c.hasDependency(e, a)));
          }
        }
        function Jr(v, e) {
          const a = Math.abs(2 * v.wrap) - +(v.wrap < 0), c = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return v.overscaledZ - e.overscaledZ || c - a || e.canonical.y - v.canonical.y || e.canonical.x - v.canonical.x;
        }
        function Lr(v) {
          return v === "raster" || v === "image" || v === "video";
        }
        Hr.maxOverzooming = 10, Hr.maxUnderzooming = 3;
        class Ne {
          constructor(e, a) {
            this.reset(e, a);
          }
          reset(e, a) {
            this.points = e || [], this._distances = [0];
            for (let c = 1; c < this.points.length; c++) this._distances[c] = this._distances[c - 1] + this.points[c].dist(this.points[c - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(a || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = s.ai(e, 0, 1);
            let a = 1, c = this._distances[a];
            const m = e * this.paddedLength + this.padding;
            for (; c < m && a < this._distances.length; ) c = this._distances[++a];
            const _ = a - 1, x = this._distances[_], k = c - x, T = k > 0 ? (m - x) / k : 0;
            return this.points[_].mult(1 - T).add(this.points[a].mult(T));
          }
        }
        function Te(v, e) {
          let a = true;
          return v === "always" || v !== "never" && e !== "never" || (a = false), a;
        }
        class jt {
          constructor(e, a, c) {
            const m = this.boxCells = [], _ = this.circleCells = [];
            this.xCellCount = Math.ceil(e / c), this.yCellCount = Math.ceil(a / c);
            for (let x = 0; x < this.xCellCount * this.yCellCount; x++) m.push([]), _.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = a, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / a, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(e, a, c, m, _) {
            this._forEachCell(a, c, m, _, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(a), this.bboxes.push(c), this.bboxes.push(m), this.bboxes.push(_);
          }
          insertCircle(e, a, c, m) {
            this._forEachCell(a - m, c - m, a + m, c + m, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(a), this.circles.push(c), this.circles.push(m);
          }
          _insertBoxCell(e, a, c, m, _, x) {
            this.boxCells[_].push(x);
          }
          _insertCircleCell(e, a, c, m, _, x) {
            this.circleCells[_].push(x);
          }
          _query(e, a, c, m, _, x, k) {
            if (c < 0 || e > this.width || m < 0 || a > this.height) return [];
            const T = [];
            if (e <= 0 && a <= 0 && this.width <= c && this.height <= m) {
              if (_) return [{ key: null, x1: e, y1: a, x2: c, y2: m }];
              for (let R = 0; R < this.boxKeys.length; R++) T.push({ key: this.boxKeys[R], x1: this.bboxes[4 * R], y1: this.bboxes[4 * R + 1], x2: this.bboxes[4 * R + 2], y2: this.bboxes[4 * R + 3] });
              for (let R = 0; R < this.circleKeys.length; R++) {
                const A = this.circles[3 * R], N = this.circles[3 * R + 1], j = this.circles[3 * R + 2];
                T.push({ key: this.circleKeys[R], x1: A - j, y1: N - j, x2: A + j, y2: N + j });
              }
            } else this._forEachCell(e, a, c, m, this._queryCell, T, { hitTest: _, overlapMode: x, seenUids: { box: {}, circle: {} } }, k);
            return T;
          }
          query(e, a, c, m) {
            return this._query(e, a, c, m, false, null);
          }
          hitTest(e, a, c, m, _, x) {
            return this._query(e, a, c, m, true, _, x).length > 0;
          }
          hitTestCircle(e, a, c, m, _) {
            const x = e - c, k = e + c, T = a - c, R = a + c;
            if (k < 0 || x > this.width || R < 0 || T > this.height) return false;
            const A = [];
            return this._forEachCell(x, T, k, R, this._queryCellCircle, A, { hitTest: true, overlapMode: m, circle: { x: e, y: a, radius: c }, seenUids: { box: {}, circle: {} } }, _), A.length > 0;
          }
          _queryCell(e, a, c, m, _, x, k, T) {
            const { seenUids: R, hitTest: A, overlapMode: N } = k, j = this.boxCells[_];
            if (j !== null) {
              const Q = this.bboxes;
              for (const le of j) if (!R.box[le]) {
                R.box[le] = true;
                const ce = 4 * le, de = this.boxKeys[le];
                if (e <= Q[ce + 2] && a <= Q[ce + 3] && c >= Q[ce + 0] && m >= Q[ce + 1] && (!T || T(de)) && (!A || !Te(N, de.overlapMode)) && (x.push({ key: de, x1: Q[ce], y1: Q[ce + 1], x2: Q[ce + 2], y2: Q[ce + 3] }), A)) return true;
              }
            }
            const G = this.circleCells[_];
            if (G !== null) {
              const Q = this.circles;
              for (const le of G) if (!R.circle[le]) {
                R.circle[le] = true;
                const ce = 3 * le, de = this.circleKeys[le];
                if (this._circleAndRectCollide(Q[ce], Q[ce + 1], Q[ce + 2], e, a, c, m) && (!T || T(de)) && (!A || !Te(N, de.overlapMode))) {
                  const ge = Q[ce], Se = Q[ce + 1], me = Q[ce + 2];
                  if (x.push({ key: de, x1: ge - me, y1: Se - me, x2: ge + me, y2: Se + me }), A) return true;
                }
              }
            }
            return false;
          }
          _queryCellCircle(e, a, c, m, _, x, k, T) {
            const { circle: R, seenUids: A, overlapMode: N } = k, j = this.boxCells[_];
            if (j !== null) {
              const Q = this.bboxes;
              for (const le of j) if (!A.box[le]) {
                A.box[le] = true;
                const ce = 4 * le, de = this.boxKeys[le];
                if (this._circleAndRectCollide(R.x, R.y, R.radius, Q[ce + 0], Q[ce + 1], Q[ce + 2], Q[ce + 3]) && (!T || T(de)) && !Te(N, de.overlapMode)) return x.push(true), true;
              }
            }
            const G = this.circleCells[_];
            if (G !== null) {
              const Q = this.circles;
              for (const le of G) if (!A.circle[le]) {
                A.circle[le] = true;
                const ce = 3 * le, de = this.circleKeys[le];
                if (this._circlesCollide(Q[ce], Q[ce + 1], Q[ce + 2], R.x, R.y, R.radius) && (!T || T(de)) && !Te(N, de.overlapMode)) return x.push(true), true;
              }
            }
          }
          _forEachCell(e, a, c, m, _, x, k, T) {
            const R = this._convertToXCellCoord(e), A = this._convertToYCellCoord(a), N = this._convertToXCellCoord(c), j = this._convertToYCellCoord(m);
            for (let G = R; G <= N; G++) for (let Q = A; Q <= j; Q++) if (_.call(this, e, a, c, m, this.xCellCount * Q + G, x, k, T)) return;
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
          }
          _circlesCollide(e, a, c, m, _, x) {
            const k = m - e, T = _ - a, R = c + x;
            return R * R > k * k + T * T;
          }
          _circleAndRectCollide(e, a, c, m, _, x, k) {
            const T = (x - m) / 2, R = Math.abs(e - (m + T));
            if (R > T + c) return false;
            const A = (k - _) / 2, N = Math.abs(a - (_ + A));
            if (N > A + c) return false;
            if (R <= T || N <= A) return true;
            const j = R - T, G = N - A;
            return j * j + G * G <= c * c;
          }
        }
        function _r(v, e, a) {
          const c = s.M();
          if (!v) {
            const { vecSouth: N, vecEast: j } = mr(e), G = P();
            G[0] = j[0], G[1] = j[1], G[2] = N[0], G[3] = N[1], m = G, (A = (x = (_ = G)[0]) * (R = _[3]) - (T = _[2]) * (k = _[1])) && (m[0] = R * (A = 1 / A), m[1] = -k * A, m[2] = -T * A, m[3] = x * A), c[0] = G[0], c[1] = G[1], c[4] = G[2], c[5] = G[3];
          }
          var m, _, x, k, T, R, A;
          return s.O(c, c, [1 / a, 1 / a, 1]), c;
        }
        function Nr(v, e, a, c) {
          if (v) {
            const m = s.M();
            if (!e) {
              const { vecSouth: _, vecEast: x } = mr(a);
              m[0] = x[0], m[1] = x[1], m[4] = _[0], m[5] = _[1];
            }
            return s.O(m, m, [c, c, 1]), m;
          }
          return a.pixelsToClipSpaceMatrix;
        }
        function mr(v) {
          const e = Math.cos(v.rollInRadians), a = Math.sin(v.rollInRadians), c = Math.cos(v.pitchInRadians), m = Math.cos(v.bearingInRadians), _ = Math.sin(v.bearingInRadians), x = s.av();
          x[0] = -m * c * a - _ * e, x[1] = -_ * c * a + m * e;
          const k = s.aw(x);
          k < 1e-9 ? s.ax(x) : s.ay(x, x, 1 / k);
          const T = s.av();
          T[0] = m * c * e - _ * a, T[1] = _ * c * e + m * a;
          const R = s.aw(T);
          return R < 1e-9 ? s.ax(T) : s.ay(T, T, 1 / R), { vecEast: T, vecSouth: x };
        }
        function Ct(v, e, a, c) {
          let m;
          c ? (m = [v, e, c(v, e), 1], s.aA(m, m, a)) : (m = [v, e, 0, 1], Do(m, m, a));
          const _ = m[3];
          return { point: new s.P(m[0] / _, m[1] / _), signedDistanceFromCamera: _, isOccluded: false };
        }
        function ar(v, e) {
          return 0.5 + v / e * 0.5;
        }
        function lr(v, e) {
          return v.x >= -e[0] && v.x <= e[0] && v.y >= -e[1] && v.y <= e[1];
        }
        function Bi(v, e, a, c, m, _, x, k, T, R, A, N, j) {
          const G = a ? v.textSizeData : v.iconSizeData, Q = s.ar(G, e.transform.zoom), le = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1], ce = a ? v.text.dynamicLayoutVertexArray : v.icon.dynamicLayoutVertexArray;
          ce.clear();
          const de = v.lineVertexArray, ge = a ? v.text.placedSymbolArray : v.icon.placedSymbolArray, Se = e.transform.width / e.transform.height;
          let me = false;
          for (let ke = 0; ke < ge.length; ke++) {
            const Re = ge.get(ke);
            if (Re.hidden || Re.writingMode === s.as.vertical && !me) {
              ia(Re.numGlyphs, ce);
              continue;
            }
            me = false;
            const ye = new s.P(Re.anchorX, Re.anchorY), Be = { getElevation: j, pitchedLabelPlaneMatrix: c, lineVertexArray: de, pitchWithMap: _, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: e.transform, tileAnchorPoint: ye, unwrappedTileID: T, width: R, height: A, translation: N }, Ke = Xn(Re.anchorX, Re.anchorY, Be);
            if (!lr(Ke.point, le)) {
              ia(Re.numGlyphs, ce);
              continue;
            }
            const He = ar(e.transform.cameraToCenterDistance, Ke.signedDistanceFromCamera), Ye = s.at(G, Q, Re), Qe = _ ? Ye * e.transform.getPitchedTextCorrection(Re.anchorX, Re.anchorY, T) / He : Ye * He, Pt = hr({ projectionContext: Be, pitchedLabelPlaneMatrixInverse: m, symbol: Re, fontSize: Qe, flip: false, keepUpright: x, glyphOffsetArray: v.glyphOffsetArray, dynamicLayoutVertexArray: ce, aspectRatio: Se, rotateToLine: k });
            me = Pt.useVertical, (Pt.notEnoughRoom || me || Pt.needsFlipping && hr({ projectionContext: Be, pitchedLabelPlaneMatrixInverse: m, symbol: Re, fontSize: Qe, flip: true, keepUpright: x, glyphOffsetArray: v.glyphOffsetArray, dynamicLayoutVertexArray: ce, aspectRatio: Se, rotateToLine: k }).notEnoughRoom) && ia(Re.numGlyphs, ce);
          }
          a ? v.text.dynamicLayoutVertexBuffer.updateData(ce) : v.icon.dynamicLayoutVertexBuffer.updateData(ce);
        }
        function jn(v, e, a, c, m, _, x, k) {
          const T = _.glyphStartIndex + _.numGlyphs, R = _.lineStartIndex, A = _.lineStartIndex + _.lineLength, N = e.getoffsetX(_.glyphStartIndex), j = e.getoffsetX(T - 1), G = Vi(v * N, a, c, m, _.segment, R, A, k, x);
          if (!G) return null;
          const Q = Vi(v * j, a, c, m, _.segment, R, A, k, x);
          return Q ? k.projectionCache.anyProjectionOccluded ? null : { first: G, last: Q } : null;
        }
        function In(v, e, a, c) {
          return v === s.as.horizontal && Math.abs(a.y - e.y) > Math.abs(a.x - e.x) * c ? { useVertical: true } : (v === s.as.vertical ? e.y < a.y : e.x > a.x) ? { needsFlipping: true } : null;
        }
        function hr(v) {
          const { projectionContext: e, pitchedLabelPlaneMatrixInverse: a, symbol: c, fontSize: m, flip: _, keepUpright: x, glyphOffsetArray: k, dynamicLayoutVertexArray: T, aspectRatio: R, rotateToLine: A } = v, N = m / 24, j = c.lineOffsetX * N, G = c.lineOffsetY * N;
          let Q;
          if (c.numGlyphs > 1) {
            const le = c.glyphStartIndex + c.numGlyphs, ce = c.lineStartIndex, de = c.lineStartIndex + c.lineLength, ge = jn(N, k, j, G, _, c, A, e);
            if (!ge) return { notEnoughRoom: true };
            const Se = Hn(ge.first.point.x, ge.first.point.y, e, a), me = Hn(ge.last.point.x, ge.last.point.y, e, a);
            if (x && !_) {
              const ke = In(c.writingMode, Se, me, R);
              if (ke) return ke;
            }
            Q = [ge.first];
            for (let ke = c.glyphStartIndex + 1; ke < le - 1; ke++) {
              const Re = Vi(N * k.getoffsetX(ke), j, G, _, c.segment, ce, de, e, A);
              if (!Re) return { notEnoughRoom: true };
              Q.push(Re);
            }
            Q.push(ge.last);
          } else {
            if (x && !_) {
              const ce = Mn(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point, de = c.lineStartIndex + c.segment + 1, ge = new s.P(e.lineVertexArray.getx(de), e.lineVertexArray.gety(de)), Se = Mn(ge.x, ge.y, e), me = Se.signedDistanceFromCamera > 0 ? Se.point : Ao(e.tileAnchorPoint, ge, ce, 1, e), ke = Hn(ce.x, ce.y, e, a), Re = Hn(me.x, me.y, e, a), ye = In(c.writingMode, ke, Re, R);
              if (ye) return ye;
            }
            const le = Vi(N * k.getoffsetX(c.glyphStartIndex), j, G, _, c.segment, c.lineStartIndex, c.lineStartIndex + c.lineLength, e, A);
            if (!le || e.projectionCache.anyProjectionOccluded) return { notEnoughRoom: true };
            Q = [le];
          }
          for (const le of Q) s.az(T, le.point, le.angle);
          return {};
        }
        function Ao(v, e, a, c, m) {
          const _ = v.add(v.sub(e)._unit()), x = Mn(_.x, _.y, m).point, k = a.sub(x);
          return a.add(k._mult(c / k.mag()));
        }
        function no(v, e, a) {
          const c = e.projectionCache;
          if (c.projections[v]) return c.projections[v];
          const m = new s.P(e.lineVertexArray.getx(v), e.lineVertexArray.gety(v)), _ = Mn(m.x, m.y, e);
          if (_.signedDistanceFromCamera > 0) return c.projections[v] = _.point, c.anyProjectionOccluded = c.anyProjectionOccluded || _.isOccluded, _.point;
          const x = v - a.direction;
          return Ao(a.distanceFromAnchor === 0 ? e.tileAnchorPoint : new s.P(e.lineVertexArray.getx(x), e.lineVertexArray.gety(x)), m, a.previousVertex, a.absOffsetX - a.distanceFromAnchor + 1, e);
        }
        function Mn(v, e, a) {
          const c = v + a.translation[0], m = e + a.translation[1];
          let _;
          return a.pitchWithMap ? (_ = Ct(c, m, a.pitchedLabelPlaneMatrix, a.getElevation), _.isOccluded = false) : (_ = a.transform.projectTileCoordinates(c, m, a.unwrappedTileID, a.getElevation), _.point.x = (0.5 * _.point.x + 0.5) * a.width, _.point.y = (0.5 * -_.point.y + 0.5) * a.height), _;
        }
        function Hn(v, e, a, c) {
          if (a.pitchWithMap) {
            const m = [v, e, 0, 1];
            return s.aA(m, m, c), a.transform.projectTileCoordinates(m[0] / m[3], m[1] / m[3], a.unwrappedTileID, a.getElevation).point;
          }
          return { x: v / a.width * 2 - 1, y: 1 - e / a.height * 2 };
        }
        function Xn(v, e, a) {
          return a.transform.projectTileCoordinates(v, e, a.unwrappedTileID, a.getElevation);
        }
        function En(v, e, a) {
          return v._unit()._perp()._mult(e * a);
        }
        function ls(v, e, a, c, m, _, x, k, T) {
          if (k.projectionCache.offsets[v]) return k.projectionCache.offsets[v];
          const R = a.add(e);
          if (v + T.direction < c || v + T.direction >= m) return k.projectionCache.offsets[v] = R, R;
          const A = no(v + T.direction, k, T), N = En(A.sub(a), x, T.direction), j = a.add(N), G = A.add(N);
          return k.projectionCache.offsets[v] = s.aB(_, R, j, G) || R, k.projectionCache.offsets[v];
        }
        function Vi(v, e, a, c, m, _, x, k, T) {
          const R = c ? v - e : v + e;
          let A = R > 0 ? 1 : -1, N = 0;
          c && (A *= -1, N = Math.PI), A < 0 && (N += Math.PI);
          let j, G = A > 0 ? _ + m : _ + m + 1;
          k.projectionCache.cachedAnchorPoint ? j = k.projectionCache.cachedAnchorPoint : (j = Mn(k.tileAnchorPoint.x, k.tileAnchorPoint.y, k).point, k.projectionCache.cachedAnchorPoint = j);
          let Q, le, ce = j, de = j, ge = 0, Se = 0;
          const me = Math.abs(R), ke = [];
          let Re;
          for (; ge + Se <= me; ) {
            if (G += A, G < _ || G >= x) return null;
            ge += Se, de = ce, le = Q;
            const Ke = { absOffsetX: me, direction: A, distanceFromAnchor: ge, previousVertex: de };
            if (ce = no(G, k, Ke), a === 0) ke.push(de), Re = ce.sub(de);
            else {
              let He;
              const Ye = ce.sub(de);
              He = Ye.mag() === 0 ? En(no(G + A, k, Ke).sub(ce), a, A) : En(Ye, a, A), le || (le = de.add(He)), Q = ls(G, He, ce, _, x, le, a, k, Ke), ke.push(le), Re = Q.sub(le);
            }
            Se = Re.mag();
          }
          const ye = Re._mult((me - ge) / Se)._add(le || de), Be = N + Math.atan2(ce.y - de.y, ce.x - de.x);
          return ke.push(ye), { point: ye, angle: T ? Be : 0, path: ke };
        }
        const ti = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function ia(v, e) {
          for (let a = 0; a < v; a++) {
            const c = e.length;
            e.resize(c + 4), e.float32.set(ti, 3 * c);
          }
        }
        function Do(v, e, a) {
          const c = e[0], m = e[1];
          return v[0] = a[0] * c + a[4] * m + a[12], v[1] = a[1] * c + a[5] * m + a[13], v[3] = a[3] * c + a[7] * m + a[15], v;
        }
        const xi = 100;
        class zo {
          constructor(e, a = new jt(e.width + 200, e.height + 200, 25), c = new jt(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = a, this.ignoredGrid = c, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + xi, this.screenBottomBoundary = e.height + xi, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(e, a, c, m, _, x, k, T, R, A, N, j) {
            const G = this.projectAndGetPerspectiveRatio(e.anchorPointX + T[0], e.anchorPointY + T[1], _, A, j), Q = c * G.perspectiveRatio;
            let le;
            if (x || k) le = this._projectCollisionBox(e, Q, m, _, x, k, T, G, A, N, j);
            else {
              const Re = G.x + (N ? N.x * Q : 0), ye = G.y + (N ? N.y * Q : 0);
              le = { allPointsOccluded: false, box: [Re + e.x1 * Q, ye + e.y1 * Q, Re + e.x2 * Q, ye + e.y2 * Q] };
            }
            const [ce, de, ge, Se] = le.box, me = x ? le.allPointsOccluded : G.isOccluded;
            let ke = me;
            return ke || (ke = G.perspectiveRatio < this.perspectiveRatioCutoff), ke || (ke = !this.isInsideGrid(ce, de, ge, Se)), ke || a !== "always" && this.grid.hitTest(ce, de, ge, Se, a, R) ? { box: [ce, de, ge, Se], placeable: false, offscreen: false, occluded: me } : { box: [ce, de, ge, Se], placeable: true, offscreen: this.isOffscreen(ce, de, ge, Se), occluded: me };
          }
          placeCollisionCircles(e, a, c, m, _, x, k, T, R, A, N, j, G, Q) {
            const le = [], ce = new s.P(a.anchorX, a.anchorY), de = this.getPerspectiveRatio(ce.x, ce.y, x, Q), ge = (R ? _ * this.transform.getPitchedTextCorrection(a.anchorX, a.anchorY, x) / de : _ * de) / s.aF, Se = { getElevation: Q, pitchedLabelPlaneMatrix: k, lineVertexArray: c, pitchWithMap: R, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: this.transform, tileAnchorPoint: ce, unwrappedTileID: x, width: this.transform.width, height: this.transform.height, translation: G }, me = jn(ge, m, a.lineOffsetX * ge, a.lineOffsetY * ge, false, a, false, Se);
            let ke = false, Re = false, ye = true;
            if (me) {
              const Be = 0.5 * N * de + j, Ke = new s.P(-100, -100), He = new s.P(this.screenRightBoundary, this.screenBottomBoundary), Ye = new Ne(), Qe = me.first, Pt = me.last;
              let Tt = [];
              for (let pr = Qe.path.length - 1; pr >= 1; pr--) Tt.push(Qe.path[pr]);
              for (let pr = 1; pr < Pt.path.length; pr++) Tt.push(Pt.path[pr]);
              const dt = 2.5 * Be;
              if (R) {
                const pr = this.projectPathToScreenSpace(Tt, Se);
                Tt = pr.some(((Ur) => Ur.signedDistanceFromCamera <= 0)) ? [] : pr.map(((Ur) => Ur.point));
              }
              let Nt = [];
              if (Tt.length > 0) {
                const pr = Tt[0].clone(), Ur = Tt[0].clone();
                for (let vr = 1; vr < Tt.length; vr++) pr.x = Math.min(pr.x, Tt[vr].x), pr.y = Math.min(pr.y, Tt[vr].y), Ur.x = Math.max(Ur.x, Tt[vr].x), Ur.y = Math.max(Ur.y, Tt[vr].y);
                Nt = pr.x >= Ke.x && Ur.x <= He.x && pr.y >= Ke.y && Ur.y <= He.y ? [Tt] : Ur.x < Ke.x || pr.x > He.x || Ur.y < Ke.y || pr.y > He.y ? [] : s.aC([Tt], Ke.x, Ke.y, He.x, He.y);
              }
              for (const pr of Nt) {
                Ye.reset(pr, 0.25 * Be);
                let Ur = 0;
                Ur = Ye.length <= 0.5 * Be ? 1 : Math.ceil(Ye.paddedLength / dt) + 1;
                for (let vr = 0; vr < Ur; vr++) {
                  const Kr = vr / Math.max(Ur - 1, 1), pi = Ye.lerp(Kr), Qr = pi.x + xi, Di = pi.y + xi;
                  le.push(Qr, Di, Be, 0);
                  const si = Qr - Be, Gi = Di - Be, li = Qr + Be, Ti = Di + Be;
                  if (ye = ye && this.isOffscreen(si, Gi, li, Ti), Re = Re || this.isInsideGrid(si, Gi, li, Ti), e !== "always" && this.grid.hitTestCircle(Qr, Di, Be, e, A) && (ke = true, !T)) return { circles: [], offscreen: false, collisionDetected: ke };
                }
              }
            }
            return { circles: !T && ke || !Re || de < this.perspectiveRatioCutoff ? [] : le, offscreen: ye, collisionDetected: ke };
          }
          projectPathToScreenSpace(e, a) {
            const c = (function(m, _) {
              const x = s.M();
              return s.au(x, _.pitchedLabelPlaneMatrix), m.map(((k) => {
                const T = Ct(k.x, k.y, x, _.getElevation), R = _.transform.projectTileCoordinates(T.point.x, T.point.y, _.unwrappedTileID, _.getElevation);
                return R.point.x = (0.5 * R.point.x + 0.5) * _.width, R.point.y = (0.5 * -R.point.y + 0.5) * _.height, R;
              }));
            })(e, a);
            return (function(m) {
              let _ = 0, x = 0, k = 0, T = 0;
              for (let R = 0; R < m.length; R++) m[R].isOccluded ? (k = R + 1, T = 0) : (T++, T > x && (x = T, _ = k));
              return m.slice(_, _ + x);
            })(c);
          }
          queryRenderedSymbols(e) {
            if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const a = [], c = new s.a6();
            for (const N of e) {
              const j = new s.P(N.x + xi, N.y + xi);
              c.extend(j), a.push(j);
            }
            const { minX: m, minY: _, maxX: x, maxY: k } = c, T = this.grid.query(m, _, x, k).concat(this.ignoredGrid.query(m, _, x, k)), R = {}, A = {};
            for (const N of T) {
              const j = N.key;
              if (R[j.bucketInstanceId] === void 0 && (R[j.bucketInstanceId] = {}), R[j.bucketInstanceId][j.featureIndex]) continue;
              const G = [new s.P(N.x1, N.y1), new s.P(N.x2, N.y1), new s.P(N.x2, N.y2), new s.P(N.x1, N.y2)];
              s.aD(a, G) && (R[j.bucketInstanceId][j.featureIndex] = true, A[j.bucketInstanceId] === void 0 && (A[j.bucketInstanceId] = []), A[j.bucketInstanceId].push(j.featureIndex));
            }
            return A;
          }
          insertCollisionBox(e, a, c, m, _, x) {
            (c ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: m, featureIndex: _, collisionGroupID: x, overlapMode: a }, e[0], e[1], e[2], e[3]);
          }
          insertCollisionCircles(e, a, c, m, _, x) {
            const k = c ? this.ignoredGrid : this.grid, T = { bucketInstanceId: m, featureIndex: _, collisionGroupID: x, overlapMode: a };
            for (let R = 0; R < e.length; R += 4) k.insertCircle(T, e[R], e[R + 1], e[R + 2]);
          }
          projectAndGetPerspectiveRatio(e, a, c, m, _) {
            if (_) {
              let x;
              m ? (x = [e, a, m(e, a), 1], s.aA(x, x, _)) : (x = [e, a, 0, 1], Do(x, x, _));
              const k = x[3];
              return { x: (x[0] / k + 1) / 2 * this.transform.width + xi, y: (-x[1] / k + 1) / 2 * this.transform.height + xi, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / k * 0.5, isOccluded: false, signedDistanceFromCamera: k };
            }
            {
              const x = this.transform.projectTileCoordinates(e, a, c, m);
              return { x: (x.point.x + 1) / 2 * this.transform.width + xi, y: (1 - x.point.y) / 2 * this.transform.height + xi, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / x.signedDistanceFromCamera * 0.5, isOccluded: x.isOccluded, signedDistanceFromCamera: x.signedDistanceFromCamera };
            }
          }
          getPerspectiveRatio(e, a, c, m) {
            const _ = this.transform.projectTileCoordinates(e, a, c, m);
            return 0.5 + this.transform.cameraToCenterDistance / _.signedDistanceFromCamera * 0.5;
          }
          isOffscreen(e, a, c, m) {
            return c < xi || e >= this.screenRightBoundary || m < xi || a > this.screenBottomBoundary;
          }
          isInsideGrid(e, a, c, m) {
            return c >= 0 && e < this.gridRightBoundary && m >= 0 && a < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const e = s.am([]);
            return s.N(e, e, [-100, -100, 0]), e;
          }
          _projectCollisionBox(e, a, c, m, _, x, k, T, R, A, N) {
            let j = 1, G = 0, Q = 0, le = 1;
            const ce = e.anchorPointX + k[0], de = e.anchorPointY + k[1];
            if (x && !_) {
              const Tt = this.projectAndGetPerspectiveRatio(ce + 1, de, m, R, N), dt = Tt.x - T.x, Nt = Math.atan((Tt.y - T.y) / dt) + (dt < 0 ? Math.PI : 0), pr = Math.sin(Nt), Ur = Math.cos(Nt);
              j = Ur, G = pr, Q = -pr, le = Ur;
            } else if (!x && _) {
              const Tt = mr(this.transform);
              j = Tt.vecEast[0], G = Tt.vecEast[1], Q = Tt.vecSouth[0], le = Tt.vecSouth[1];
            }
            let ge = T.x, Se = T.y, me = a;
            _ && (ge = ce, Se = de, me = Math.pow(2, -(this.transform.zoom - c.overscaledZ)), me *= this.transform.getPitchedTextCorrection(ce, de, m), A || (me *= s.ai(0.5 + T.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), A && (ge += j * A.x * me + Q * A.y * me, Se += G * A.x * me + le * A.y * me);
            const ke = e.x1 * me, Re = e.x2 * me, ye = (ke + Re) / 2, Be = e.y1 * me, Ke = e.y2 * me, He = (Be + Ke) / 2, Ye = [{ offsetX: ke, offsetY: Be }, { offsetX: ye, offsetY: Be }, { offsetX: Re, offsetY: Be }, { offsetX: Re, offsetY: He }, { offsetX: Re, offsetY: Ke }, { offsetX: ye, offsetY: Ke }, { offsetX: ke, offsetY: Ke }, { offsetX: ke, offsetY: He }];
            let Qe = [];
            for (const { offsetX: Tt, offsetY: dt } of Ye) Qe.push(new s.P(ge + j * Tt + Q * dt, Se + G * Tt + le * dt));
            let Pt = false;
            if (_) {
              const Tt = Qe.map(((dt) => this.projectAndGetPerspectiveRatio(dt.x, dt.y, m, R, N)));
              Pt = Tt.some(((dt) => !dt.isOccluded)), Qe = Tt.map(((dt) => new s.P(dt.x, dt.y)));
            } else Pt = true;
            return { box: s.aE(Qe), allPointsOccluded: !Pt };
          }
        }
        class oo {
          constructor(e, a, c, m) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? a : -a))) : m && c ? 1 : 0, this.placed = c;
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class na {
          constructor(e, a, c, m, _) {
            this.text = new oo(e ? e.text : null, a, c, _), this.icon = new oo(e ? e.icon : null, a, m, _);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Gs {
          constructor(e, a, c) {
            this.text = e, this.icon = a, this.skipFade = c;
          }
        }
        class Ul {
          constructor(e, a, c, m, _) {
            this.bucketInstanceId = e, this.featureIndex = a, this.sourceLayerIndex = c, this.bucketIndex = m, this.tileID = _;
          }
        }
        class oa {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(e) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[e]) {
              const a = ++this.maxGroupID;
              this.collisionGroups[e] = { ID: a, predicate: (c) => c.collisionGroupID === a };
            }
            return this.collisionGroups[e];
          }
        }
        function qs(v, e, a, c, m) {
          const { horizontalAlign: _, verticalAlign: x } = s.aL(v);
          return new s.P(-(_ - 0.5) * e + c[0] * m, -(x - 0.5) * a + c[1] * m);
        }
        class Cc {
          constructor(e, a, c, m, _) {
            this.transform = e.clone(), this.terrain = a, this.collisionIndex = new zo(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = c, this.retainedQueryData = {}, this.collisionGroups = new oa(m), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = _, _ && (_.prevPlacement = void 0), this.placedOrientations = {};
          }
          _getTerrainElevationFunc(e) {
            const a = this.terrain;
            return a ? (c, m) => a.getElevation(e, c, m) : null;
          }
          getBucketParts(e, a, c, m) {
            const _ = c.getBucket(a), x = c.latestFeatureIndex;
            if (!_ || !x || a.id !== _.layerIds[0]) return;
            const k = c.collisionBoxArray, T = _.layers[0].layout, R = _.layers[0].paint, A = Math.pow(2, this.transform.zoom - c.tileID.overscaledZ), N = c.tileSize / s.a3, j = c.tileID.toUnwrapped(), G = T.get("text-rotation-alignment") === "map", Q = s.aG(c, 1, this.transform.zoom), le = s.aH(this.collisionIndex.transform, c, R.get("text-translate"), R.get("text-translate-anchor")), ce = s.aH(this.collisionIndex.transform, c, R.get("icon-translate"), R.get("icon-translate-anchor")), de = _r(G, this.transform, Q);
            this.retainedQueryData[_.bucketInstanceId] = new Ul(_.bucketInstanceId, x, _.sourceLayerIndex, _.index, c.tileID);
            const ge = { bucket: _, layout: T, translationText: le, translationIcon: ce, unwrappedTileID: j, pitchedLabelPlaneMatrix: de, scale: A, textPixelRatio: N, holdingForFade: c.holdingForSymbolFade(), collisionBoxArray: k, partiallyEvaluatedTextSize: s.ar(_.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(_.sourceID) };
            if (m) for (const Se of _.sortKeyRanges) {
              const { sortKey: me, symbolInstanceStart: ke, symbolInstanceEnd: Re } = Se;
              e.push({ sortKey: me, symbolInstanceStart: ke, symbolInstanceEnd: Re, parameters: ge });
            }
            else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: _.symbolInstances.length, parameters: ge });
          }
          attemptAnchorPlacement(e, a, c, m, _, x, k, T, R, A, N, j, G, Q, le, ce, de, ge, Se, me) {
            const ke = s.aI[e.textAnchor], Re = [e.textOffset0, e.textOffset1], ye = qs(ke, c, m, Re, _), Be = this.collisionIndex.placeCollisionBox(a, j, T, R, A, k, x, ce, N.predicate, Se, ye, me);
            if ((!ge || this.collisionIndex.placeCollisionBox(ge, j, T, R, A, k, x, de, N.predicate, Se, ye, me).placeable) && Be.placeable) {
              let Ke;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[G.crossTileID] && this.prevPlacement.placements[G.crossTileID] && this.prevPlacement.placements[G.crossTileID].text && (Ke = this.prevPlacement.variableOffsets[G.crossTileID].anchor), G.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[G.crossTileID] = { textOffset: Re, width: c, height: m, anchor: ke, textBoxScale: _, prevAnchor: Ke }, this.markUsedJustification(Q, ke, G, le), Q.allowVerticalPlacement && (this.markUsedOrientation(Q, le, G), this.placedOrientations[G.crossTileID] = le), { shift: ye, placedGlyphBoxes: Be };
            }
          }
          placeLayerBucketPart(e, a, c) {
            const { bucket: m, layout: _, translationText: x, translationIcon: k, unwrappedTileID: T, pitchedLabelPlaneMatrix: R, textPixelRatio: A, holdingForFade: N, collisionBoxArray: j, partiallyEvaluatedTextSize: G, collisionGroup: Q } = e.parameters, le = _.get("text-optional"), ce = _.get("icon-optional"), de = s.aJ(_, "text-overlap", "text-allow-overlap"), ge = de === "always", Se = s.aJ(_, "icon-overlap", "icon-allow-overlap"), me = Se === "always", ke = _.get("text-rotation-alignment") === "map", Re = _.get("text-pitch-alignment") === "map", ye = _.get("icon-text-fit") !== "none", Be = _.get("symbol-z-order") === "viewport-y", Ke = ge && (me || !m.hasIconData() || ce), He = me && (ge || !m.hasTextData() || le);
            !m.collisionArrays && j && m.deserializeCollisionBoxes(j);
            const Ye = this.retainedQueryData[m.bucketInstanceId].tileID, Qe = this._getTerrainElevationFunc(Ye), Pt = this.transform.getFastPathSimpleProjectionMatrix(Ye), Tt = (dt, Nt, pr) => {
              var Ur, vr;
              if (a[dt.crossTileID]) return;
              if (N) return void (this.placements[dt.crossTileID] = new Gs(false, false, false));
              let Kr = false, pi = false, Qr = true, Di = null, si = { box: null, placeable: false, offscreen: null, occluded: false }, Gi = { placeable: false }, li = null, Ti = null, yn = null, qa = 0, Uo = 0, To = 0;
              Nt.textFeatureIndex ? qa = Nt.textFeatureIndex : dt.useRuntimeCollisionCircles && (qa = dt.featureIndex), Nt.verticalTextFeatureIndex && (Uo = Nt.verticalTextFeatureIndex);
              const Wa = Nt.textBox;
              if (Wa) {
                const bn = (Ii) => {
                  let Si = s.as.horizontal;
                  if (m.allowVerticalPlacement && !Ii && this.prevPlacement) {
                    const qi = this.prevPlacement.placedOrientations[dt.crossTileID];
                    qi && (this.placedOrientations[dt.crossTileID] = qi, Si = qi, this.markUsedOrientation(m, Si, dt));
                  }
                  return Si;
                }, Go = (Ii, Si) => {
                  if (m.allowVerticalPlacement && dt.numVerticalGlyphVertices > 0 && Nt.verticalTextBox) {
                    for (const qi of m.writingModes) if (qi === s.as.vertical ? (si = Si(), Gi = si) : si = Ii(), si && si.placeable) break;
                  } else si = Ii();
                }, fa = dt.textAnchorOffsetStartIndex, bl = dt.textAnchorOffsetEndIndex;
                if (bl === fa) {
                  const Ii = (Si, qi) => {
                    const ii = this.collisionIndex.placeCollisionBox(Si, de, A, Ye, T, Re, ke, x, Q.predicate, Qe, void 0, Pt);
                    return ii && ii.placeable && (this.markUsedOrientation(m, qi, dt), this.placedOrientations[dt.crossTileID] = qi), ii;
                  };
                  Go((() => Ii(Wa, s.as.horizontal)), (() => {
                    const Si = Nt.verticalTextBox;
                    return m.allowVerticalPlacement && dt.numVerticalGlyphVertices > 0 && Si ? Ii(Si, s.as.vertical) : { box: null, offscreen: null };
                  })), bn(si && si.placeable);
                } else {
                  let Ii = s.aI[(vr = (Ur = this.prevPlacement) === null || Ur === void 0 ? void 0 : Ur.variableOffsets[dt.crossTileID]) === null || vr === void 0 ? void 0 : vr.anchor];
                  const Si = (ii, co, pa) => {
                    const gf = ii.x2 - ii.x1, vf = ii.y2 - ii.y1, _f = dt.textBoxScale, Ha = ye && Se === "never" ? co : null;
                    let Xa = null, md = de === "never" ? 1 : 2, Au = "never";
                    Ii && md++;
                    for (let gd = 0; gd < md; gd++) {
                      for (let qo = fa; qo < bl; qo++) {
                        const ma = m.textAnchorOffsets.get(qo);
                        if (Ii && ma.textAnchor !== Ii) continue;
                        const Du = this.attemptAnchorPlacement(ma, ii, gf, vf, _f, ke, Re, A, Ye, T, Q, Au, dt, m, pa, x, k, Ha, Qe);
                        if (Du && (Xa = Du.placedGlyphBoxes, Xa && Xa.placeable)) return Kr = true, Di = Du.shift, Xa;
                      }
                      Ii ? Ii = null : Au = de;
                    }
                    return c && !Xa && (Xa = { box: this.collisionIndex.placeCollisionBox(Wa, "always", A, Ye, T, Re, ke, x, Q.predicate, Qe, void 0, Pt).box, offscreen: false, placeable: false, occluded: false }), Xa;
                  };
                  Go((() => Si(Wa, Nt.iconBox, s.as.horizontal)), (() => {
                    const ii = Nt.verticalTextBox;
                    return m.allowVerticalPlacement && (!si || !si.placeable) && dt.numVerticalGlyphVertices > 0 && ii ? Si(ii, Nt.verticalIconBox, s.as.vertical) : { box: null, occluded: true, offscreen: null };
                  })), si && (Kr = si.placeable, Qr = si.offscreen);
                  const qi = bn(si && si.placeable);
                  if (!Kr && this.prevPlacement) {
                    const ii = this.prevPlacement.variableOffsets[dt.crossTileID];
                    ii && (this.variableOffsets[dt.crossTileID] = ii, this.markUsedJustification(m, ii.anchor, dt, qi));
                  }
                }
              }
              if (li = si, Kr = li && li.placeable, Qr = li && li.offscreen, dt.useRuntimeCollisionCircles && dt.centerJustifiedTextSymbolIndex >= 0) {
                const bn = m.text.placedSymbolArray.get(dt.centerJustifiedTextSymbolIndex), Go = s.at(m.textSizeData, G, bn), fa = _.get("text-padding");
                Ti = this.collisionIndex.placeCollisionCircles(de, bn, m.lineVertexArray, m.glyphOffsetArray, Go, T, R, c, Re, Q.predicate, dt.collisionCircleDiameter, fa, x, Qe), Ti.circles.length && Ti.collisionDetected && !c && s.w("Collisions detected, but collision boxes are not shown"), Kr = ge || Ti.circles.length > 0 && !Ti.collisionDetected, Qr = Qr && Ti.offscreen;
              }
              if (Nt.iconFeatureIndex && (To = Nt.iconFeatureIndex), Nt.iconBox) {
                const bn = (Go) => this.collisionIndex.placeCollisionBox(Go, Se, A, Ye, T, Re, ke, k, Q.predicate, Qe, ye && Di ? Di : void 0, Pt);
                Gi && Gi.placeable && Nt.verticalIconBox ? (yn = bn(Nt.verticalIconBox), pi = yn.placeable) : (yn = bn(Nt.iconBox), pi = yn.placeable), Qr = Qr && yn.offscreen;
              }
              const Ts = le || dt.numHorizontalGlyphVertices === 0 && dt.numVerticalGlyphVertices === 0, Za = ce || dt.numIconVertices === 0;
              Ts || Za ? Za ? Ts || (pi = pi && Kr) : Kr = pi && Kr : pi = Kr = pi && Kr;
              const zn = pi && yn.placeable;
              if (Kr && li.placeable && this.collisionIndex.insertCollisionBox(li.box, de, _.get("text-ignore-placement"), m.bucketInstanceId, Gi && Gi.placeable && Uo ? Uo : qa, Q.ID), zn && this.collisionIndex.insertCollisionBox(yn.box, Se, _.get("icon-ignore-placement"), m.bucketInstanceId, To, Q.ID), Ti && Kr && this.collisionIndex.insertCollisionCircles(Ti.circles, de, _.get("text-ignore-placement"), m.bucketInstanceId, qa, Q.ID), c && this.storeCollisionData(m.bucketInstanceId, pr, Nt, li, yn, Ti), dt.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              if (m.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[dt.crossTileID] = new Gs((Kr || Ke) && !(li == null ? void 0 : li.occluded), (pi || He) && !(yn == null ? void 0 : yn.occluded), Qr || m.justReloaded), a[dt.crossTileID] = true;
            };
            if (Be) {
              if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const dt = m.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let Nt = dt.length - 1; Nt >= 0; --Nt) {
                const pr = dt[Nt];
                Tt(m.symbolInstances.get(pr), m.collisionArrays[pr], pr);
              }
            } else for (let dt = e.symbolInstanceStart; dt < e.symbolInstanceEnd; dt++) Tt(m.symbolInstances.get(dt), m.collisionArrays[dt], dt);
            m.justReloaded = false;
          }
          storeCollisionData(e, a, c, m, _, x) {
            if (c.textBox || c.iconBox) {
              let k, T;
              this.collisionBoxArrays.has(e) ? k = this.collisionBoxArrays.get(e) : (k = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e, k)), k.has(a) ? T = k.get(a) : (T = { text: null, icon: null }, k.set(a, T)), c.textBox && (T.text = m.box), c.iconBox && (T.icon = _.box);
            }
            if (x) {
              let k = this.collisionCircleArrays[e];
              k === void 0 && (k = this.collisionCircleArrays[e] = []);
              for (let T = 0; T < x.circles.length; T += 4) k.push(x.circles[T + 0] - xi), k.push(x.circles[T + 1] - xi), k.push(x.circles[T + 2]), k.push(x.collisionDetected ? 1 : 0);
            }
          }
          markUsedJustification(e, a, c, m) {
            let _;
            _ = m === s.as.vertical ? c.verticalPlacedTextSymbolIndex : { left: c.leftJustifiedTextSymbolIndex, center: c.centerJustifiedTextSymbolIndex, right: c.rightJustifiedTextSymbolIndex }[s.aK(a)];
            const x = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex, c.verticalPlacedTextSymbolIndex];
            for (const k of x) k >= 0 && (e.text.placedSymbolArray.get(k).crossTileID = _ >= 0 && k !== _ ? 0 : c.crossTileID);
          }
          markUsedOrientation(e, a, c) {
            const m = a === s.as.horizontal || a === s.as.horizontalOnly ? a : 0, _ = a === s.as.vertical ? a : 0, x = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex];
            for (const k of x) e.text.placedSymbolArray.get(k).placedOrientation = m;
            c.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(c.verticalPlacedTextSymbolIndex).placedOrientation = _);
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const a = this.prevPlacement;
            let c = false;
            this.prevZoomAdjustment = a ? a.zoomAdjustment(this.transform.zoom) : 0;
            const m = a ? a.symbolFadeChange(e) : 1, _ = a ? a.opacities : {}, x = a ? a.variableOffsets : {}, k = a ? a.placedOrientations : {};
            for (const T in this.placements) {
              const R = this.placements[T], A = _[T];
              A ? (this.opacities[T] = new na(A, m, R.text, R.icon), c = c || R.text !== A.text.placed || R.icon !== A.icon.placed) : (this.opacities[T] = new na(null, m, R.text, R.icon, R.skipFade), c = c || R.text || R.icon);
            }
            for (const T in _) {
              const R = _[T];
              if (!this.opacities[T]) {
                const A = new na(R, m, false, false);
                A.isHidden() || (this.opacities[T] = A, c = c || R.text.placed || R.icon.placed);
              }
            }
            for (const T in x) this.variableOffsets[T] || !this.opacities[T] || this.opacities[T].isHidden() || (this.variableOffsets[T] = x[T]);
            for (const T in k) this.placedOrientations[T] || !this.opacities[T] || this.opacities[T].isHidden() || (this.placedOrientations[T] = k[T]);
            if (a && a.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            c ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = a ? a.lastPlacementChangeTime : e);
          }
          updateLayerOpacities(e, a) {
            const c = {};
            for (const m of a) {
              const _ = m.getBucket(e);
              _ && m.latestFeatureIndex && e.id === _.layerIds[0] && this.updateBucketOpacities(_, m.tileID, c, m.collisionBoxArray);
            }
          }
          updateBucketOpacities(e, a, c, m) {
            e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = false), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = false), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
            const _ = e.layers[0], x = _.layout, k = new na(null, 0, false, false, true), T = x.get("text-allow-overlap"), R = x.get("icon-allow-overlap"), A = _._unevaluatedLayout.hasValue("text-variable-anchor") || _._unevaluatedLayout.hasValue("text-variable-anchor-offset"), N = x.get("text-rotation-alignment") === "map", j = x.get("text-pitch-alignment") === "map", G = x.get("icon-text-fit") !== "none", Q = new na(null, 0, T && (R || !e.hasIconData() || x.get("icon-optional")), R && (T || !e.hasTextData() || x.get("text-optional")), true);
            !e.collisionArrays && m && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(m);
            const le = (de, ge, Se) => {
              for (let me = 0; me < ge / 4; me++) de.opacityVertexArray.emplaceBack(Se);
              de.hasVisibleVertices = de.hasVisibleVertices || Se !== Ia;
            }, ce = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let de = 0; de < e.symbolInstances.length; de++) {
              const ge = e.symbolInstances.get(de), { numHorizontalGlyphVertices: Se, numVerticalGlyphVertices: me, crossTileID: ke } = ge;
              let Re = this.opacities[ke];
              c[ke] ? Re = k : Re || (Re = Q, this.opacities[ke] = Re), c[ke] = true;
              const ye = ge.numIconVertices > 0, Be = this.placedOrientations[ge.crossTileID], Ke = Be === s.as.vertical, He = Be === s.as.horizontal || Be === s.as.horizontalOnly;
              if (Se > 0 || me > 0) {
                const Qe = us(Re.text);
                le(e.text, Se, Ke ? Ia : Qe), le(e.text, me, He ? Ia : Qe);
                const Pt = Re.text.isHidden();
                [ge.rightJustifiedTextSymbolIndex, ge.centerJustifiedTextSymbolIndex, ge.leftJustifiedTextSymbolIndex].forEach(((Nt) => {
                  Nt >= 0 && (e.text.placedSymbolArray.get(Nt).hidden = Pt || Ke ? 1 : 0);
                })), ge.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(ge.verticalPlacedTextSymbolIndex).hidden = Pt || He ? 1 : 0);
                const Tt = this.variableOffsets[ge.crossTileID];
                Tt && this.markUsedJustification(e, Tt.anchor, ge, Be);
                const dt = this.placedOrientations[ge.crossTileID];
                dt && (this.markUsedJustification(e, "left", ge, dt), this.markUsedOrientation(e, dt, ge));
              }
              if (ye) {
                const Qe = us(Re.icon), Pt = !(G && ge.verticalPlacedIconSymbolIndex && Ke);
                ge.placedIconSymbolIndex >= 0 && (le(e.icon, ge.numIconVertices, Pt ? Qe : Ia), e.icon.placedSymbolArray.get(ge.placedIconSymbolIndex).hidden = Re.icon.isHidden()), ge.verticalPlacedIconSymbolIndex >= 0 && (le(e.icon, ge.numVerticalIconVertices, Pt ? Ia : Qe), e.icon.placedSymbolArray.get(ge.verticalPlacedIconSymbolIndex).hidden = Re.icon.isHidden());
              }
              const Ye = ce && ce.has(de) ? ce.get(de) : { text: null, icon: null };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const Qe = e.collisionArrays[de];
                if (Qe) {
                  let Pt = new s.P(0, 0);
                  if (Qe.textBox || Qe.verticalTextBox) {
                    let Tt = true;
                    if (A) {
                      const dt = this.variableOffsets[ke];
                      dt ? (Pt = qs(dt.anchor, dt.width, dt.height, dt.textOffset, dt.textBoxScale), N && Pt._rotate(j ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : Tt = false;
                    }
                    if (Qe.textBox || Qe.verticalTextBox) {
                      let dt;
                      Qe.textBox && (dt = Ke), Qe.verticalTextBox && (dt = He), Gl(e.textCollisionBox.collisionVertexArray, Re.text.placed, !Tt || dt, Ye.text, Pt.x, Pt.y);
                    }
                  }
                  if (Qe.iconBox || Qe.verticalIconBox) {
                    const Tt = !!(!He && Qe.verticalIconBox);
                    let dt;
                    Qe.iconBox && (dt = Tt), Qe.verticalIconBox && (dt = !Tt), Gl(e.iconCollisionBox.collisionVertexArray, Re.icon.placed, dt, Ye.icon, G ? Pt.x : 0, G ? Pt.y : 0);
                  }
                }
              }
            }
            if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
            if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
            e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId]);
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5);
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(e, a) {
            const c = this.zoomAtLastRecencyCheck === a ? 1 - this.zoomAdjustment(a) : 1;
            return this.zoomAtLastRecencyCheck = a, this.commitTime + this.fadeDuration * c > e;
          }
          setStale() {
            this.stale = true;
          }
        }
        function Gl(v, e, a, c, m, _) {
          c && c.length !== 0 || (c = [0, 0, 0, 0]);
          const x = c[0] - xi, k = c[1] - xi, T = c[2] - xi, R = c[3] - xi;
          v.emplaceBack(e ? 1 : 0, a ? 1 : 0, m || 0, _ || 0, x, k), v.emplaceBack(e ? 1 : 0, a ? 1 : 0, m || 0, _ || 0, T, k), v.emplaceBack(e ? 1 : 0, a ? 1 : 0, m || 0, _ || 0, T, R), v.emplaceBack(e ? 1 : 0, a ? 1 : 0, m || 0, _ || 0, x, R);
        }
        const Sc = Math.pow(2, 25), ql = Math.pow(2, 24), Wl = Math.pow(2, 17), Ws = Math.pow(2, 16), Zs = Math.pow(2, 9), Zl = Math.pow(2, 8), Hs = Math.pow(2, 1);
        function us(v) {
          if (v.opacity === 0 && !v.placed) return 0;
          if (v.opacity === 1 && v.placed) return 4294967295;
          const e = v.placed ? 1 : 0, a = Math.floor(127 * v.opacity);
          return a * Sc + e * ql + a * Wl + e * Ws + a * Zs + e * Zl + a * Hs + e;
        }
        const Ia = 0;
        class Ma {
          constructor(e) {
            this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(e, a, c, m, _) {
            const x = this._bucketParts;
            for (; this._currentTileIndex < e.length; ) if (a.getBucketParts(x, m, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, _()) return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, x.sort(((k, T) => k.sortKey - T.sortKey))); this._currentPartIndex < x.length; ) if (a.placeLayerBucketPart(x[this._currentPartIndex], this._seenCrossTileIDs, c), this._currentPartIndex++, _()) return true;
            return false;
          }
        }
        class cs {
          constructor(e, a, c, m, _, x, k, T) {
            this.placement = new Cc(e, a, x, k, T), this._currentPlacementIndex = c.length - 1, this._forceFullPlacement = m, this._showCollisionBoxes = _, this._done = false;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(e, a, c) {
            const m = z(), _ = () => !this._forceFullPlacement && z() - m > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const x = a[e[this._currentPlacementIndex]], k = this.placement.collisionIndex.transform.zoom;
              if (x.type === "symbol" && (!x.minzoom || x.minzoom <= k) && (!x.maxzoom || x.maxzoom > k)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Ma(x)), this._inProgressLayer.continuePlacement(c[x.source], this.placement, this._showCollisionBoxes, x, _)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }
          commit(e) {
            return this.placement.commit(e), this.placement;
          }
        }
        const aa = 512 / s.a3 / 2;
        class sa {
          constructor(e, a, c) {
            this.tileID = e, this.bucketInstanceId = c, this._symbolsByKey = {};
            const m = /* @__PURE__ */ new Map();
            for (let _ = 0; _ < a.length; _++) {
              const x = a.get(_), k = x.key, T = m.get(k);
              T ? T.push(x) : m.set(k, [x]);
            }
            for (const [_, x] of m) {
              const k = { positions: x.map(((T) => ({ x: Math.floor(T.anchorX * aa), y: Math.floor(T.anchorY * aa) }))), crossTileIDs: x.map(((T) => T.crossTileID)) };
              if (k.positions.length > 128) {
                const T = new s.aM(k.positions.length, 16, Uint16Array);
                for (const { x: R, y: A } of k.positions) T.add(R, A);
                T.finish(), delete k.positions, k.index = T;
              }
              this._symbolsByKey[_] = k;
            }
          }
          getScaledCoordinates(e, a) {
            const { x: c, y: m, z: _ } = this.tileID.canonical, { x, y: k, z: T } = a.canonical, R = aa / Math.pow(2, T - _), A = (k * s.a3 + e.anchorY) * R, N = m * s.a3 * aa;
            return { x: Math.floor((x * s.a3 + e.anchorX) * R - c * s.a3 * aa), y: Math.floor(A - N) };
          }
          findMatches(e, a, c) {
            const m = this.tileID.canonical.z < a.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - a.canonical.z);
            for (let _ = 0; _ < e.length; _++) {
              const x = e.get(_);
              if (x.crossTileID) continue;
              const k = this._symbolsByKey[x.key];
              if (!k) continue;
              const T = this.getScaledCoordinates(x, a);
              if (k.index) {
                const R = k.index.range(T.x - m, T.y - m, T.x + m, T.y + m).sort();
                for (const A of R) {
                  const N = k.crossTileIDs[A];
                  if (!c[N]) {
                    c[N] = true, x.crossTileID = N;
                    break;
                  }
                }
              } else if (k.positions) for (let R = 0; R < k.positions.length; R++) {
                const A = k.positions[R], N = k.crossTileIDs[R];
                if (Math.abs(A.x - T.x) <= m && Math.abs(A.y - T.y) <= m && !c[N]) {
                  c[N] = true, x.crossTileID = N;
                  break;
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({ crossTileIDs: e }) => e));
          }
        }
        class Hl {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class kc {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(e) {
            const a = Math.round((e - this.lng) / 360);
            if (a !== 0) for (const c in this.indexes) {
              const m = this.indexes[c], _ = {};
              for (const x in m) {
                const k = m[x];
                k.tileID = k.tileID.unwrapTo(k.tileID.wrap + a), _[k.tileID.key] = k;
              }
              this.indexes[c] = _;
            }
            this.lng = e;
          }
          addBucket(e, a, c) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === a.bucketInstanceId) return false;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
            }
            for (let _ = 0; _ < a.symbolInstances.length; _++) a.symbolInstances.get(_).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            const m = this.usedCrossTileIDs[e.overscaledZ];
            for (const _ in this.indexes) {
              const x = this.indexes[_];
              if (Number(_) > e.overscaledZ) for (const k in x) {
                const T = x[k];
                T.tileID.isChildOf(e) && T.findMatches(a.symbolInstances, e, m);
              }
              else {
                const k = x[e.scaledTo(Number(_)).key];
                k && k.findMatches(a.symbolInstances, e, m);
              }
            }
            for (let _ = 0; _ < a.symbolInstances.length; _++) {
              const x = a.symbolInstances.get(_);
              x.crossTileID || (x.crossTileID = c.generate(), m[x.crossTileID] = true);
            }
            return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new sa(e, a.symbolInstances, a.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(e, a) {
            for (const c of a.getCrossTileIDsLists()) for (const m of c) delete this.usedCrossTileIDs[e][m];
          }
          removeStaleBuckets(e) {
            let a = false;
            for (const c in this.indexes) {
              const m = this.indexes[c];
              for (const _ in m) e[m[_].bucketInstanceId] || (this.removeBucketCrossTileIDs(c, m[_]), delete m[_], a = true);
            }
            return a;
          }
        }
        class ao {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Hl(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(e, a, c) {
            let m = this.layerIndexes[e.id];
            m === void 0 && (m = this.layerIndexes[e.id] = new kc());
            let _ = false;
            const x = {};
            m.handleWrapJump(c);
            for (const k of a) {
              const T = k.getBucket(e);
              T && e.id === T.layerIds[0] && (T.bucketInstanceId || (T.bucketInstanceId = ++this.maxBucketInstanceId), m.addBucket(k.tileID, T, this.crossTileIDs) && (_ = true), x[T.bucketInstanceId] = true);
            }
            return m.removeStaleBuckets(x) && (_ = true), _;
          }
          pruneUnusedLayers(e) {
            const a = {};
            e.forEach(((c) => {
              a[c] = true;
            }));
            for (const c in this.layerIndexes) a[c] || delete this.layerIndexes[c];
          }
        }
        var Fo = "void main() {fragColor=vec4(1.0);}";
        const fr = { prelude: Ir(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: Ir("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: Ir("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: Ir(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: Ir(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Ir(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Ir(Fo, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: Ir(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: Ir(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Ir("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Ir("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), colorRelief: Ir(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), debug: Ir("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: Ir(Fo, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: Ir(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: Ir(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: Ir(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: Ir(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Ir(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Ir(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Ir(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Ir(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: Ir(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Ir(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Ir(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Ir(`uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`), lineGradientSDF: Ir(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define mediump vec4 dasharray_from
#pragma mapbox: define mediump vec4 dasharray_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 dasharray_from
#pragma mapbox: initialize mediump vec4 dasharray_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
float u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}`), raster: Ir(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: Ir(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Ir(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Ir(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Ir("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Ir("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Ir("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: Ir("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: Ir(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: Ir("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
        function Ir(v, e) {
          const a = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, c = e.match(/in ([\w]+) ([\w]+)/g), m = v.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), _ = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), x = _ ? _.concat(m) : m, k = {};
          return { fragmentSource: v = v.replace(a, ((T, R, A, N, j) => (k[j] = true, R === "define" ? `
#ifndef HAS_UNIFORM_u_${j}
in ${A} ${N} ${j};
#else
uniform ${A} ${N} u_${j};
#endif
` : `
#ifdef HAS_UNIFORM_u_${j}
    ${A} ${N} ${j} = u_${j};
#endif
`))), vertexSource: e = e.replace(a, ((T, R, A, N, j) => {
            const G = N === "float" ? "vec2" : "vec4", Q = j.match(/color/) ? "color" : G;
            return k[j] ? R === "define" ? `
#ifndef HAS_UNIFORM_u_${j}
uniform lowp float u_${j}_t;
in ${A} ${G} a_${j};
out ${A} ${N} ${j};
#else
uniform ${A} ${N} u_${j};
#endif
` : Q === "vec4" ? `
#ifndef HAS_UNIFORM_u_${j}
    ${j} = a_${j};
#else
    ${A} ${N} ${j} = u_${j};
#endif
` : `
#ifndef HAS_UNIFORM_u_${j}
    ${j} = unpack_mix_${Q}(a_${j}, u_${j}_t);
#else
    ${A} ${N} ${j} = u_${j};
#endif
` : R === "define" ? `
#ifndef HAS_UNIFORM_u_${j}
uniform lowp float u_${j}_t;
in ${A} ${G} a_${j};
#else
uniform ${A} ${N} u_${j};
#endif
` : Q === "vec4" ? `
#ifndef HAS_UNIFORM_u_${j}
    ${A} ${N} ${j} = a_${j};
#else
    ${A} ${N} ${j} = u_${j};
#endif
` : `
#ifndef HAS_UNIFORM_u_${j}
    ${A} ${N} ${j} = unpack_mix_${Q}(a_${j}, u_${j}_t);
#else
    ${A} ${N} ${j} = u_${j};
#endif
`;
          })), staticAttributes: c, staticUniforms: x };
        }
        class ds {
          constructor(e, a, c) {
            this.vertexBuffer = e, this.indexBuffer = a, this.segments = c;
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
          }
        }
        var Co = s.aN([{ name: "a_pos", type: "Int16", components: 2 }]);
        const Rn = "#define PROJECTION_MERCATOR", ln = "mercator";
        class Qi {
          constructor() {
            this._cachedMesh = null;
          }
          get name() {
            return "mercator";
          }
          get useSubdivision() {
            return false;
          }
          get shaderVariantName() {
            return ln;
          }
          get shaderDefine() {
            return Rn;
          }
          get shaderPreludeCode() {
            return fr.projectionMercator;
          }
          get vertexShaderPreludeCode() {
            return fr.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return s.aO.noSubdivision;
          }
          get useGlobeControls() {
            return false;
          }
          get transitionState() {
            return 0;
          }
          get latitudeErrorCorrectionRadians() {
            return 0;
          }
          destroy() {
          }
          updateGPUdependent(e) {
          }
          getMeshFromTileID(e, a, c, m, _) {
            if (this._cachedMesh) return this._cachedMesh;
            const x = new s.aP();
            x.emplaceBack(0, 0), x.emplaceBack(s.a3, 0), x.emplaceBack(0, s.a3), x.emplaceBack(s.a3, s.a3);
            const k = e.createVertexBuffer(x, Co.members), T = s.aQ.simpleSegment(0, 0, 4, 2), R = new s.aR();
            R.emplaceBack(1, 0, 2), R.emplaceBack(1, 2, 3);
            const A = e.createIndexBuffer(R);
            return this._cachedMesh = new ds(k, A, T), this._cachedMesh;
          }
          recalculate() {
          }
          hasTransition() {
            return false;
          }
          setErrorQueryLatitudeDegrees(e) {
          }
        }
        class Pi {
          constructor(e = 0, a = 0, c = 0, m = 0) {
            if (isNaN(e) || e < 0 || isNaN(a) || a < 0 || isNaN(c) || c < 0 || isNaN(m) || m < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = a, this.left = c, this.right = m;
          }
          interpolate(e, a, c) {
            return a.top != null && e.top != null && (this.top = s.F.number(e.top, a.top, c)), a.bottom != null && e.bottom != null && (this.bottom = s.F.number(e.bottom, a.bottom, c)), a.left != null && e.left != null && (this.left = s.F.number(e.left, a.left, c)), a.right != null && e.right != null && (this.right = s.F.number(e.right, a.right, c)), this;
          }
          getCenter(e, a) {
            const c = s.ai((this.left + e - this.right) / 2, 0, e), m = s.ai((this.top + a - this.bottom) / 2, 0, a);
            return new s.P(c, m);
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
          }
          clone() {
            return new Pi(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function ri(v, e) {
          if (!v.renderWorldCopies || v.lngRange) return;
          const a = e.lng - v.center.lng;
          e.lng += a > 180 ? -360 : a < -180 ? 360 : 0;
        }
        function yh(v) {
          return Math.max(0, Math.floor(v));
        }
        class un {
          constructor(e, a) {
            var c;
            this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = (a == null ? void 0 : a.renderWorldCopies) === void 0 || !!(a == null ? void 0 : a.renderWorldCopies), this._minZoom = (a == null ? void 0 : a.minZoom) || 0, this._maxZoom = (a == null ? void 0 : a.maxZoom) || 22, this._minPitch = (a == null ? void 0 : a.minPitch) == null ? 0 : a == null ? void 0 : a.minPitch, this._maxPitch = (a == null ? void 0 : a.maxPitch) == null ? 60 : a == null ? void 0 : a.maxPitch, this._constrain = (c = a == null ? void 0 : a.constrain) !== null && c !== void 0 ? c : this._callbacks.constrain, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new s.U(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = yh(this._zoom), this._scale = s.al(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = true, this._edgeInsets = new Pi(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = true;
          }
          apply(e, a, c) {
            this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = yh(this._zoom), this._scale = s.al(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new Pi(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !c && e.autoCalculateNearFarZ, a && this.constrainInternal(), this._calcMatrices();
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix;
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile;
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e;
          }
          get tileSize() {
            return this._tileSize;
          }
          get tileZoom() {
            return this._tileZoom;
          }
          get scale() {
            return this._scale;
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get bearingInRadians() {
            return this._bearingInRadians;
          }
          get lngRange() {
            return this._lngRange;
          }
          get latRange() {
            return this._latRange;
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits;
          }
          get minZoom() {
            return this._minZoom;
          }
          setMinZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.setZoom(this.constrain(this._center, this.zoom).zoom));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          setMaxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.constrain(this._center, this.zoom).zoom));
          }
          get minPitch() {
            return this._minPitch;
          }
          setMinPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          setMaxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          setRenderWorldCopies(e) {
            e === void 0 ? e = true : e === null && (e = false), this._renderWorldCopies = e;
          }
          get constrain() {
            return this._constrain;
          }
          setConstrain(e) {
            e || (e = this._callbacks.constrain), this._constrain = e, this.constrainInternal(), this._calcMatrices();
          }
          get worldSize() {
            return this._tileSize * this._scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new s.P(this._width, this._height);
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180;
          }
          setBearing(e) {
            const a = s.V(e, -180, 180) * Math.PI / 180;
            var c, m, _, x, k, T, R, A, N;
            this._bearingInRadians !== a && (this._unmodified = false, this._bearingInRadians = a, this._calcMatrices(), this._rotationMatrix = P(), c = this._rotationMatrix, _ = -this._bearingInRadians, x = (m = this._rotationMatrix)[0], k = m[1], T = m[2], R = m[3], A = Math.sin(_), N = Math.cos(_), c[0] = x * N + T * A, c[1] = k * N + R * A, c[2] = x * -A + T * N, c[3] = k * -A + R * N);
          }
          get rotationMatrix() {
            return this._rotationMatrix;
          }
          get pitchInRadians() {
            return this._pitchInRadians;
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180;
          }
          setPitch(e) {
            const a = s.ai(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== a && (this._unmodified = false, this._pitchInRadians = a, this._calcMatrices());
          }
          get rollInRadians() {
            return this._rollInRadians;
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180;
          }
          setRoll(e) {
            const a = e / 180 * Math.PI;
            this._rollInRadians !== a && (this._unmodified = false, this._rollInRadians = a, this._calcMatrices());
          }
          get fovInRadians() {
            return this._fovInRadians;
          }
          get fov() {
            return s.aS(this._fovInRadians);
          }
          setFov(e) {
            e = s.ai(e, 0.1, 150), this.fov !== e && (this._unmodified = false, this._fovInRadians = s.ak(e), this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          setZoom(e) {
            const a = this.constrain(this._center, e).zoom;
            this._zoom !== a && (this._unmodified = false, this._zoom = a, this._tileZoom = Math.max(0, Math.floor(a)), this._scale = s.al(a), this.constrainInternal(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          setCenter(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = false, this._center = e, this.constrainInternal(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          setElevation(e) {
            e !== this._elevation && (this._elevation = e, this.constrainInternal(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          setPadding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height);
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter;
          }
          get unmodified() {
            return this._unmodified;
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance;
          }
          get nearZ() {
            return this._nearZ;
          }
          get farZ() {
            return this._farZ;
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ;
          }
          overrideNearFarZ(e, a) {
            this._autoCalculateNearFarZ = false, this._nearZ = e, this._farZ = a, this._calcMatrices();
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = true, this._calcMatrices();
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e);
          }
          interpolatePadding(e, a, c) {
            this._unmodified = false, this._edgeInsets.interpolate(e, a, c), this.constrainInternal(), this._calcMatrices();
          }
          resize(e, a, c = true) {
            this._width = e, this._height = a, c && this.constrainInternal(), this._calcMatrices();
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new nr([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
          }
          setMaxBounds(e) {
            e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this.constrainInternal()) : (this._lngRange = null, this._latRange = [-s.aj, s.aj]);
          }
          getCameraQueryGeometry(e, a) {
            if (a.length === 1) return [a[0], e];
            {
              const { minX: c, minY: m, maxX: _, maxY: x } = s.a6.fromPoints(a).extend(e);
              return [new s.P(c, m), new s.P(_, m), new s.P(_, x), new s.P(c, x), new s.P(c, m)];
            }
          }
          constrainInternal() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = true;
            const e = this._unmodified, { center: a, zoom: c } = this.constrain(this.center, this.zoom);
            this.setCenter(a), this.setZoom(c), this._unmodified = e, this._constraining = false;
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = s.am(new Float64Array(16));
              s.O(e, e, [this._width / 2, -this._height / 2, 1]), s.N(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = s.am(new Float64Array(16)), s.O(e, e, [1, -1, 1]), s.N(e, e, [-1, -1, 0]), s.O(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
            }
            this._callbacks.calcMatrices();
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, m) {
            const _ = c !== void 0 ? c : this.bearing, x = m = m !== void 0 ? m : this.pitch, k = s.a5.fromLngLat(e, a), T = -Math.cos(s.ak(x)), R = Math.sin(s.ak(x)), A = R * Math.sin(s.ak(_)), N = -R * Math.cos(s.ak(_));
            let j = this.elevation;
            const G = a - j;
            let Q;
            T * G >= 0 || Math.abs(T) < 0.1 ? (Q = 1e4, j = a + Q * T) : Q = -G / T;
            let le, ce, de = s.aT(1, k.y), ge = 0;
            do {
              if (ge += 1, ge > 10) break;
              ce = Q / de, le = new s.a5(k.x + A * ce, k.y + N * ce), de = 1 / le.meterInMercatorCoordinateUnits();
            } while (Math.abs(Q - ce * de) > 1e-12);
            return { center: le.toLngLat(), elevation: j, zoom: s.ao(this.height / 2 / Math.tan(this.fovInRadians / 2) / ce / this.tileSize) };
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const a = s.an(1, this.center.lat) * this.worldSize, c = this.cameraToCenterDistance / a, m = s.a5.fromLngLat(this.center, this.elevation), _ = Le(this.center, this.elevation, this.pitch, this.bearing, c);
            this._elevation = e;
            const x = this.calculateCenterFromCameraLngLatAlt(_.toLngLat(), s.aT(_.z, m.y), this.bearing, this.pitch);
            this._elevation = x.elevation, this._center = x.center, this.setZoom(x.zoom);
          }
          getCameraPoint() {
            const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new s.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)));
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
          }
          getCameraLngLat() {
            const e = s.an(1, this.center.lat) * this.worldSize;
            return Le(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat();
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const a = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
            return [e.canonical.x / a, e.canonical.y / a, 1 / a / s.a3, 1 / a / s.a3];
          }
        }
        class gn {
          constructor(e, a) {
            this.min = e, this.max = a, this.center = s.aU([], s.aV([], this.min, this.max), 0.5);
          }
          quadrant(e) {
            const a = [e % 2 == 0, e < 2], c = s.aW(this.min), m = s.aW(this.max);
            for (let _ = 0; _ < a.length; _++) c[_] = a[_] ? this.min[_] : this.center[_], m[_] = a[_] ? this.center[_] : this.max[_];
            return m[2] = this.max[2], new gn(c, m);
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
          }
          intersectsFrustum(e) {
            let a = true;
            for (let c = 0; c < e.planes.length; c++) {
              const m = this.intersectsPlane(e.planes[c]);
              if (m === 0) return 0;
              m === 1 && (a = false);
            }
            return a ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1;
          }
          intersectsPlane(e) {
            let a = e[3], c = e[3];
            for (let m = 0; m < 3; m++) e[m] > 0 ? (a += e[m] * this.min[m], c += e[m] * this.max[m]) : (c += e[m] * this.min[m], a += e[m] * this.max[m]);
            return a >= 0 ? 2 : c < 0 ? 0 : 1;
          }
        }
        class Nn {
          distanceToTile2d(e, a, c, m) {
            const _ = m.distanceX([e, a]), x = m.distanceY([e, a]);
            return Math.hypot(_, x);
          }
          getWrap(e, a, c) {
            return c;
          }
          getTileBoundingVolume(e, a, c, m) {
            var _, x;
            let k = 0, T = 0;
            if (m == null ? void 0 : m.terrain) {
              const A = new s.a0(e.z, a, e.z, e.x, e.y), N = m.terrain.getMinMaxElevation(A);
              k = (_ = N.minElevation) !== null && _ !== void 0 ? _ : Math.min(0, c), T = (x = N.maxElevation) !== null && x !== void 0 ? x : Math.max(0, c);
            }
            const R = 1 << e.z;
            return new gn([a + e.x / R, e.y / R, k], [a + (e.x + 1) / R, (e.y + 1) / R, T]);
          }
          allowVariableZoom(e, a) {
            const c = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height, m = s.ai(78.5 - c / 2, 0, 60);
            return !!a.terrain || e.pitch > m;
          }
          allowWorldCopies() {
            return true;
          }
          prepareNextFrame() {
          }
        }
        class Xs {
          constructor(e, a, c) {
            this.points = e, this.planes = a, this.aabb = c;
          }
          static fromInvProjectionMatrix(e, a = 1, c = 0, m, _) {
            const x = _ ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]], k = Math.pow(2, c), T = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(((j) => (function(G, Q, le, ce) {
              const de = s.aA([], G, Q), ge = 1 / de[3] / le * ce;
              return s.a$(de, de, [ge, ge, 1 / de[3], ge]);
            })(j, e, a, k)));
            m && (function(j, G, Q, le) {
              const ce = le ? 4 : 0, de = le ? 0 : 4;
              let ge = 0;
              const Se = [], me = [];
              for (let ye = 0; ye < 4; ye++) {
                const Be = s.aX([], j[ye + de], j[ye + ce]), Ke = s.b0(Be);
                s.aU(Be, Be, 1 / Ke), Se.push(Ke), me.push(Be);
              }
              for (let ye = 0; ye < 4; ye++) {
                const Be = s.b1(j[ye + ce], me[ye], Q);
                ge = Be !== null && Be >= 0 ? Math.max(ge, Be) : Math.max(ge, Se[ye]);
              }
              const ke = (function(ye, Be) {
                const Ke = s.aX([], ye[Be[0]], ye[Be[1]]), He = s.aX([], ye[Be[2]], ye[Be[1]]), Ye = [0, 0, 0, 0];
                return s.aY(Ye, s.aZ([], Ke, He)), Ye[3] = -s.a_(Ye, ye[Be[0]]), Ye;
              })(j, G), Re = (function(ye, Be) {
                const Ke = s.b2(ye), He = s.b3([], ye, 1 / Ke), Ye = s.aX([], Be, s.aU([], He, s.a_(Be, He))), Qe = s.b2(Ye);
                if (Qe > 0) {
                  const Pt = Math.sqrt(1 - He[3] * He[3]), Tt = s.aU([], He, -He[3]), dt = s.aV([], Tt, s.aU([], Ye, Pt / Qe));
                  return s.b4(Be, dt);
                }
                return null;
              })(Q, ke);
              if (Re !== null) {
                const ye = Re / s.a_(me[0], ke);
                ge = Math.min(ge, ye);
              }
              for (let ye = 0; ye < 4; ye++) {
                const Be = Math.min(ge, Se[ye]);
                j[ye + de] = [j[ye + ce][0] + me[ye][0] * Be, j[ye + ce][1] + me[ye][1] * Be, j[ye + ce][2] + me[ye][2] * Be, 1];
              }
            })(T, x[0], m, _);
            const R = x.map(((j) => {
              const G = s.aX([], T[j[0]], T[j[1]]), Q = s.aX([], T[j[2]], T[j[1]]), le = s.aY([], s.aZ([], G, Q)), ce = -s.a_(le, T[j[1]]);
              return le.concat(ce);
            })), A = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], N = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const j of T) for (let G = 0; G < 3; G++) A[G] = Math.min(A[G], j[G]), N[G] = Math.max(N[G], j[G]);
            return new Xs(T, R, new gn(A, N));
          }
        }
        class So {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, a, c) {
            return this._helper.interpolatePadding(e, a, c);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, a, c = true) {
            this._helper.resize(e, a, c);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          setConstrain(e) {
            this._helper.setConstrain(e);
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get constrain() {
            return this._helper.constrain;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e, a) {
          }
          constructor(e) {
            this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this.defaultConstrain = (a, c) => {
              c = s.ai(+c, this.minZoom, this.maxZoom);
              const m = { center: new s.U(a.lng, a.lat), zoom: c };
              let _ = this._helper._lngRange;
              if (!this._helper._renderWorldCopies && _ === null) {
                const me = 179.9999999999;
                _ = [-me, me];
              }
              const x = this.tileSize * s.al(m.zoom);
              let k = 0, T = x, R = 0, A = x, N = 0, j = 0;
              const { x: G, y: Q } = this.size;
              if (this._helper._latRange) {
                const me = this._helper._latRange;
                k = s.W(me[1]) * x, T = s.W(me[0]) * x, T - k < Q && (N = Q / (T - k));
              }
              _ && (R = s.V(s.X(_[0]) * x, 0, x), A = s.V(s.X(_[1]) * x, 0, x), A < R && (A += x), A - R < G && (j = G / (A - R)));
              const { x: le, y: ce } = Ve(x, a);
              let de, ge;
              const Se = Math.max(j || 0, N || 0);
              if (Se) {
                const me = new s.P(j ? (A + R) / 2 : le, N ? (T + k) / 2 : ce);
                return m.center = et(x, me).wrap(), m.zoom += s.ao(Se), m;
              }
              if (this._helper._latRange) {
                const me = Q / 2;
                ce - me < k && (ge = k + me), ce + me > T && (ge = T - me);
              }
              if (_) {
                const me = (R + A) / 2;
                let ke = le;
                this._helper._renderWorldCopies && (ke = s.V(le, me - x / 2, me + x / 2));
                const Re = G / 2;
                ke - Re < R && (de = R + Re), ke + Re > A && (de = A - Re);
              }
              if (de !== void 0 || ge !== void 0) {
                const me = new s.P(de ?? le, ge ?? ce);
                m.center = et(x, me).wrap();
              }
              return m;
            }, this._helper = new un({ calcMatrices: () => {
              this._calcMatrices();
            }, constrain: (a, c) => this.defaultConstrain(a, c) }, e), this._coveringTilesDetailsProvider = new Nn();
          }
          clone() {
            const e = new So();
            return e.apply(this), e;
          }
          apply(e, a, c) {
            this._helper.apply(e, a, c);
          }
          get cameraPosition() {
            return this._cameraPosition;
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix;
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix;
          }
          get mercatorMatrix() {
            return this._mercatorMatrix;
          }
          getVisibleUnwrappedCoordinates(e) {
            const a = [new s.b5(0, e)];
            if (this._helper._renderWorldCopies) {
              const c = this.screenPointToMercatorCoordinate(new s.P(0, 0)), m = this.screenPointToMercatorCoordinate(new s.P(this._helper._width, 0)), _ = this.screenPointToMercatorCoordinate(new s.P(this._helper._width, this._helper._height)), x = this.screenPointToMercatorCoordinate(new s.P(0, this._helper._height)), k = Math.floor(Math.min(c.x, m.x, _.x, x.x)), T = Math.floor(Math.max(c.x, m.x, _.x, x.x)), R = 1;
              for (let A = k - R; A <= T + R; A++) A !== 0 && a.push(new s.b5(A, e));
            }
            return a;
          }
          getCameraFrustum() {
            return Xs.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
          }
          getClippingPlane() {
            return null;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e) {
            const a = this.screenPointToLocation(this.centerPoint, e), c = e ? e.getElevationForLngLatZoom(a, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(c);
          }
          setLocationAtPoint(e, a) {
            const c = s.an(this.elevation, this.center.lat), m = this.screenPointToMercatorCoordinateAtZ(a, c), _ = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, c), x = s.a5.fromLngLat(e), k = new s.a5(x.x - (m.x - _.x), x.y - (m.y - _.y));
            this.setCenter(k == null ? void 0 : k.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
          }
          locationToScreenPoint(e, a) {
            return a ? this.coordinatePoint(s.a5.fromLngLat(e), a.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(s.a5.fromLngLat(e));
          }
          screenPointToLocation(e, a) {
            var c;
            return (c = this.screenPointToMercatorCoordinate(e, a)) === null || c === void 0 ? void 0 : c.toLngLat();
          }
          screenPointToMercatorCoordinate(e, a) {
            if (a) {
              const c = a.pointCoordinate(e);
              if (c != null) return c;
            }
            return this.screenPointToMercatorCoordinateAtZ(e);
          }
          screenPointToMercatorCoordinateAtZ(e, a) {
            const c = a || 0, m = [e.x, e.y, 0, 1], _ = [e.x, e.y, 1, 1];
            s.aA(m, m, this._pixelMatrixInverse), s.aA(_, _, this._pixelMatrixInverse);
            const x = m[3], k = _[3], T = m[1] / x, R = _[1] / k, A = m[2] / x, N = _[2] / k, j = A === N ? 0 : (c - A) / (N - A);
            return new s.a5(s.F.number(m[0] / x, _[0] / k, j) / this.worldSize, s.F.number(T, R, j) / this.worldSize, c);
          }
          coordinatePoint(e, a = 0, c = this._pixelMatrix) {
            const m = [e.x * this.worldSize, e.y * this.worldSize, a, 1];
            return s.aA(m, m, c), new s.P(m[0] / m[3], m[1] / m[3]);
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - We(this));
            return new nr().extend(this.screenPointToLocation(new s.P(0, e))).extend(this.screenPointToLocation(new s.P(this._helper._width, e))).extend(this.screenPointToLocation(new s.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new s.P(0, this._helper._height)));
          }
          isPointOnMapSurface(e, a) {
            return a ? a.pointCoordinate(e) != null : e.y > this.height / 2 - We(this);
          }
          calculatePosMatrix(e, a = false, c) {
            var m;
            const _ = (m = e.key) !== null && m !== void 0 ? m : s.b6(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y), x = a ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (x.has(_)) {
              const R = x.get(_);
              return c ? R.f32 : R.f64;
            }
            const k = xt(e, this.worldSize);
            s.Q(k, a ? this._alignedProjMatrix : this._viewProjMatrix, k);
            const T = { f64: k, f32: new Float32Array(k) };
            return x.set(_, T), c ? T.f32 : T.f64;
          }
          calculateFogMatrix(e) {
            const a = e.key, c = this._fogMatrixCacheF32;
            if (c.has(a)) return c.get(a);
            const m = xt(e, this.worldSize);
            return s.Q(m, this._fogMatrix, m), c.set(a, new Float32Array(m)), c.get(a);
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, m) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, c, m);
          }
          _calculateNearFarZIfNeeded(e, a, c) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const m = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), _ = e - m * this._helper._pixelPerMeter / Math.cos(a), x = m < 0 ? _ : e, k = Math.PI / 2 + this.pitchInRadians, T = s.ak(this.fov) * (Math.abs(Math.cos(s.ak(this.roll))) * this.height + Math.abs(Math.sin(s.ak(this.roll))) * this.width) / this.height * (0.5 + c.y / this.height), R = Math.sin(T) * x / Math.sin(s.ai(Math.PI - k - T, 0.01, Math.PI - 0.01)), A = We(this), N = Math.atan(A / this._helper.cameraToCenterDistance), j = s.ak(0.75), G = N > j ? 2 * N * (0.5 + c.y / (2 * A)) : j, Q = Math.sin(G) * x / Math.sin(s.ai(Math.PI - k - G, 0.01, Math.PI - 0.01)), le = Math.min(R, Q);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - a) * le + x), this._helper._nearZ = this._helper._height / 50;
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset, a = Ve(this.worldSize, this.center), c = a.x, m = a.y;
            this._helper._pixelPerMeter = s.an(1, this.center.lat) * this.worldSize;
            const _ = s.ak(Math.min(this.pitch, xe)), x = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(_));
            let k;
            this._calculateNearFarZIfNeeded(x, _, e), k = new Float64Array(16), s.b7(k, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), s.au(this._invProjMatrix, k), k[8] = 2 * -e.x / this._helper._width, k[9] = 2 * e.y / this._helper._height, this._projectionMatrix = s.b8(k), s.O(k, k, [1, -1, 1]), s.N(k, k, [0, 0, -this._helper.cameraToCenterDistance]), s.b9(k, k, -this.rollInRadians), s.ba(k, k, this.pitchInRadians), s.b9(k, k, -this.bearingInRadians), s.N(k, k, [-c, -m, 0]), this._mercatorMatrix = s.O([], k, [this.worldSize, this.worldSize, this.worldSize]), s.O(k, k, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = s.Q(new Float64Array(16), this.clipSpaceToPixelsMatrix, k), s.N(k, k, [0, 0, -this.elevation]), this._viewProjMatrix = k, this._invViewProjMatrix = s.au([], k);
            const T = [0, 0, -1, 1];
            s.aA(T, T, this._invViewProjMatrix), this._cameraPosition = [T[0] / T[3], T[1] / T[3], T[2] / T[3]], this._fogMatrix = new Float64Array(16), s.b7(this._fogMatrix, this.fovInRadians, this.width / this.height, x, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, s.O(this._fogMatrix, this._fogMatrix, [1, -1, 1]), s.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), s.b9(this._fogMatrix, this._fogMatrix, -this.rollInRadians), s.ba(this._fogMatrix, this._fogMatrix, this.pitchInRadians), s.b9(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), s.N(this._fogMatrix, this._fogMatrix, [-c, -m, 0]), s.O(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), s.N(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = s.Q(new Float64Array(16), this.clipSpaceToPixelsMatrix, k);
            const R = this._helper._width % 2 / 2, A = this._helper._height % 2 / 2, N = Math.cos(this.bearingInRadians), j = Math.sin(-this.bearingInRadians), G = c - Math.round(c) + N * R + j * A, Q = m - Math.round(m) + N * A + j * R, le = new Float64Array(k);
            if (s.N(le, le, [G > 0.5 ? G - 1 : G, Q > 0.5 ? Q - 1 : Q, 0]), this._alignedProjMatrix = le, k = s.au(new Float64Array(16), this._pixelMatrix), !k) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = k, this._clearMatrixCaches();
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new s.P(0, 0)), a = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return s.aA(a, a, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            const e = s.an(1, this.center.lat) * this.worldSize;
            return Le(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat();
          }
          lngLatToCameraDepth(e, a) {
            const c = s.a5.fromLngLat(e), m = [c.x * this.worldSize, c.y * this.worldSize, a, 1];
            return s.aA(m, m, this._viewProjMatrix), m[2] / m[3];
          }
          getProjectionData(e) {
            const { overscaledTileID: a, aligned: c, applyTerrainMatrix: m } = e, _ = this._helper.getMercatorTileCoordinates(a), x = a ? this.calculatePosMatrix(a, c, true) : null;
            let k;
            return k = a && a.terrainRttPosMatrix32f && m ? a.terrainRttPosMatrix32f : x || s.bb(), { mainMatrix: k, tileMercatorCoords: _, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: k };
          }
          isLocationOccluded(e) {
            return false;
          }
          getPixelScale() {
            return 1;
          }
          getCircleRadiusCorrection() {
            return 1;
          }
          getPitchedTextCorrection(e, a, c) {
            return 1;
          }
          transformLightDirection(e) {
            return s.aW(e);
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.");
          }
          projectTileCoordinates(e, a, c, m) {
            const _ = this.calculatePosMatrix(c);
            let x;
            m ? (x = [e, a, m(e, a), 1], s.aA(x, x, _)) : (x = [e, a, 0, 1], Do(x, x, _));
            const k = x[3];
            return { point: new s.P(x[0] / k, x[1] / k), signedDistanceFromCamera: k, isOccluded: false };
          }
          populateCache(e) {
            for (const a of e) this.calculatePosMatrix(a);
          }
          getMatrixForModel(e, a) {
            const c = s.a5.fromLngLat(e, a), m = c.meterInMercatorCoordinateUnits(), _ = s.bc();
            return s.N(_, _, [c.x, c.y, c.z]), s.b9(_, _, Math.PI), s.ba(_, _, Math.PI / 2), s.O(_, _, [-m, m, m]), _;
          }
          getProjectionDataForCustomLayer(e = true) {
            const a = new s.a0(0, 0, 0, 0, 0), c = this.getProjectionData({ overscaledTileID: a, applyGlobeMatrix: e }), m = xt(a, this.worldSize);
            s.Q(m, this._viewProjMatrix, m), c.tileMercatorCoords = [0, 0, 1, 1];
            const _ = [s.a3, s.a3, this.worldSize / this._helper.pixelsPerMeter], x = s.bd();
            return s.O(x, m, _), c.fallbackMatrix = x, c.mainMatrix = x, c;
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e);
          }
        }
        function wi() {
          s.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }
        function hs(v) {
          if (v.useSlerp) if (v.k < 1) {
            const e = s.be(v.startEulerAngles.roll, v.startEulerAngles.pitch, v.startEulerAngles.bearing), a = s.be(v.endEulerAngles.roll, v.endEulerAngles.pitch, v.endEulerAngles.bearing), c = new Float64Array(4);
            s.bf(c, e, a, v.k);
            const m = s.bg(c);
            v.tr.setRoll(m.roll), v.tr.setPitch(m.pitch), v.tr.setBearing(m.bearing);
          } else v.tr.setRoll(v.endEulerAngles.roll), v.tr.setPitch(v.endEulerAngles.pitch), v.tr.setBearing(v.endEulerAngles.bearing);
          else v.tr.setRoll(s.F.number(v.startEulerAngles.roll, v.endEulerAngles.roll, v.k)), v.tr.setPitch(s.F.number(v.startEulerAngles.pitch, v.endEulerAngles.pitch, v.k)), v.tr.setBearing(s.F.number(v.startEulerAngles.bearing, v.endEulerAngles.bearing, v.k));
        }
        function la(v, e, a, c, m) {
          const _ = m.padding, x = Ve(m.worldSize, a.getNorthWest()), k = Ve(m.worldSize, a.getNorthEast()), T = Ve(m.worldSize, a.getSouthEast()), R = Ve(m.worldSize, a.getSouthWest()), A = s.ak(-c), N = x.rotate(A), j = k.rotate(A), G = T.rotate(A), Q = R.rotate(A), le = new s.P(Math.max(N.x, j.x, Q.x, G.x), Math.max(N.y, j.y, Q.y, G.y)), ce = new s.P(Math.min(N.x, j.x, Q.x, G.x), Math.min(N.y, j.y, Q.y, G.y)), de = le.sub(ce), ge = (m.width - (_.left + _.right + e.left + e.right)) / de.x, Se = (m.height - (_.top + _.bottom + e.top + e.bottom)) / de.y;
          if (Se < 0 || ge < 0) return void wi();
          const me = Math.min(s.ao(m.scale * Math.min(ge, Se)), v.maxZoom), ke = s.P.convert(v.offset), Re = new s.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(s.ak(c)), ye = ke.add(Re).mult(m.scale / s.al(me));
          return { center: et(m.worldSize, x.add(T).div(2).sub(ye)), zoom: me, bearing: c };
        }
        class Ea {
          get useGlobeControls() {
            return false;
          }
          handlePanInertia(e, a) {
            const c = e.mag(), m = Math.abs(We(a));
            return { easingOffset: e.mult(Math.min(0.75 * m / c, 1)), easingCenter: a.center };
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            e.bearingDelta && a.setBearing(a.bearing + e.bearingDelta), e.pitchDelta && a.setPitch(a.pitch + e.pitchDelta), e.rollDelta && a.setRoll(a.roll + e.rollDelta), e.zoomDelta && a.setZoom(a.zoom + e.zoomDelta);
          }
          handleMapControlsPan(e, a, c) {
            e.around.distSqr(a.centerPoint) < 0.01 || a.setLocationAtPoint(c, e.around);
          }
          cameraForBoxAndBearing(e, a, c, m, _) {
            return la(e, a, c, m, _);
          }
          handleJumpToCenterZoom(e, a) {
            e.zoom !== (a.zoom !== void 0 ? +a.zoom : e.zoom) && e.setZoom(+a.zoom), a.center !== void 0 && e.setCenter(s.U.convert(a.center));
          }
          handleEaseTo(e, a) {
            const c = e.zoom, m = e.padding, _ = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, x = { roll: a.roll === void 0 ? e.roll : a.roll, pitch: a.pitch === void 0 ? e.pitch : a.pitch, bearing: a.bearing === void 0 ? e.bearing : a.bearing }, k = a.zoom !== void 0, T = !e.isPaddingEqual(a.padding);
            let R = false;
            const A = k ? +a.zoom : e.zoom;
            let N = e.centerPoint.add(a.offsetAsPoint);
            const j = e.screenPointToLocation(N), { center: G, zoom: Q } = e.constrain(s.U.convert(a.center || j), A ?? c);
            ri(e, G);
            const le = Ve(e.worldSize, j), ce = Ve(e.worldSize, G).sub(le), de = s.al(Q - c);
            return R = Q !== c, { easeFunc: (ge) => {
              if (R && e.setZoom(s.F.number(c, Q, ge)), s.bh(_, x) || hs({ startEulerAngles: _, endEulerAngles: x, tr: e, k: ge, useSlerp: _.roll != x.roll }), T && (e.interpolatePadding(m, a.padding, ge), N = e.centerPoint.add(a.offsetAsPoint)), a.around) e.setLocationAtPoint(a.around, a.aroundPoint);
              else {
                const Se = s.al(e.zoom - c), me = Q > c ? Math.min(2, de) : Math.max(0.5, de), ke = Math.pow(me, 1 - ge), Re = et(e.worldSize, le.add(ce.mult(ge * ke)).mult(Se));
                e.setLocationAtPoint(e.renderWorldCopies ? Re.wrap() : Re, N);
              }
            }, isZooming: R, elevationCenter: G };
          }
          handleFlyTo(e, a) {
            const c = a.zoom !== void 0, m = e.zoom, _ = e.constrain(s.U.convert(a.center || a.locationAtOffset), c ? +a.zoom : m), x = _.center, k = _.zoom;
            ri(e, x);
            const T = Ve(e.worldSize, a.locationAtOffset), R = Ve(e.worldSize, x).sub(T), A = R.mag(), N = s.al(k - m);
            let j;
            if (a.minZoom !== void 0) {
              const G = Math.min(+a.minZoom, m, k), Q = e.constrain(x, G).zoom;
              j = s.al(Q - m);
            }
            return { easeFunc: (G, Q, le, ce) => {
              e.setZoom(G === 1 ? k : m + s.ao(Q));
              const de = G === 1 ? x : et(e.worldSize, T.add(R.mult(le)).mult(Q));
              e.setLocationAtPoint(e.renderWorldCopies ? de.wrap() : de, ce);
            }, scaleOfZoom: N, targetCenter: x, scaleOfMinZoom: j, pixelPathLength: A };
          }
        }
        class zr {
          constructor(e, a, c) {
            this.blendFunction = e, this.blendColor = a, this.mask = c;
          }
        }
        zr.Replace = [1, 0], zr.disabled = new zr(zr.Replace, s.bi.transparent, [false, false, false, false]), zr.unblended = new zr(zr.Replace, s.bi.transparent, [true, true, true, true]), zr.alphaBlended = new zr([1, 771], s.bi.transparent, [true, true, true, true]);
        const Xl = 2305;
        class xr {
          constructor(e, a, c) {
            this.enable = e, this.mode = a, this.frontFace = c;
          }
        }
        xr.disabled = new xr(false, 1029, Xl), xr.backCCW = new xr(true, 1029, Xl), xr.frontCCW = new xr(true, 1028, Xl);
        class br {
          constructor(e, a, c) {
            this.func = e, this.mask = a, this.range = c;
          }
        }
        br.ReadOnly = false, br.ReadWrite = true, br.disabled = new br(519, br.ReadOnly, [0, 1]);
        const Yl = 7680;
        class Rr {
          constructor(e, a, c, m, _, x) {
            this.test = e, this.ref = a, this.mask = c, this.fail = m, this.depthFail = _, this.pass = x;
          }
        }
        Rr.disabled = new Rr({ func: 519, mask: 0 }, 0, 0, Yl, Yl, Yl);
        const fs = /* @__PURE__ */ new WeakMap();
        function Yn(v) {
          var e;
          if (fs.has(v)) return fs.get(v);
          {
            const a = (e = v.getParameter(v.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
            return fs.set(v, a), a;
          }
        }
        class Ys {
          get awaitingQuery() {
            return !!this._readbackQueue;
          }
          constructor(e) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
            const a = e.context, c = a.gl;
            this._texFormat = c.RGBA, this._texType = c.UNSIGNED_BYTE;
            const m = new s.aP();
            m.emplaceBack(-1, -1), m.emplaceBack(2, -1), m.emplaceBack(-1, 2);
            const _ = new s.aR();
            _.emplaceBack(0, 1, 2), this._fullscreenTriangle = new ds(a.createVertexBuffer(m, Co.members), a.createIndexBuffer(_), s.aQ.simpleSegment(0, 0, m.length, _.length)), this._resultBuffer = new Uint8Array(4), a.activeTexture.set(c.TEXTURE1);
            const x = c.createTexture();
            c.bindTexture(c.TEXTURE_2D, x), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.NEAREST), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.NEAREST), c.texImage2D(c.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = a.createFramebuffer(this._texWidth, this._texHeight, false, false), this._fbo.colorAttachment.set(x), Yn(c) && (this._pbo = c.createBuffer(), c.bindBuffer(c.PIXEL_PACK_BUFFER, this._pbo), c.bufferData(c.PIXEL_PACK_BUFFER, 4, c.STREAM_READ), c.bindBuffer(c.PIXEL_PACK_BUFFER, null));
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
          }
          updateErrorLoop(e, a) {
            const c = this._updateCount;
            return this._readbackQueue ? c >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : c >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, a), this._updateCount++, this._measuredError;
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context, a = e.gl;
            e.activeTexture.set(a.TEXTURE1), a.bindTexture(a.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer);
          }
          _renderErrorTexture(e, a) {
            const c = this._cachedRenderContext.context, m = c.gl;
            if (this._bindFramebuffer(), c.viewport.set([0, 0, this._texWidth, this._texHeight]), c.clear({ color: s.bi.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(c, m.TRIANGLES, br.disabled, Rr.disabled, zr.unblended, xr.disabled, /* @__PURE__ */ ((_, x) => ({ u_input: _, u_output_expected: x }))(e, a), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && Yn(m)) {
              m.bindBuffer(m.PIXEL_PACK_BUFFER, this._pbo), m.readBuffer(m.COLOR_ATTACHMENT0), m.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), m.bindBuffer(m.PIXEL_PACK_BUFFER, null);
              const _ = m.fenceSync(m.SYNC_GPU_COMMANDS_COMPLETE, 0);
              m.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: _ };
            } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && Yn(e)) {
              const a = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (a === e.WAIT_FAILED) return s.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
              if (a === e.TIMEOUT_EXPIRED) return;
              e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null);
            } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = Ys._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
          }
          static _parseRGBA8float(e) {
            let a = 0;
            return a += e[0] / 256, a += e[1] / 65536, a += e[2] / 16777216, e[3] < 127 && (a = -a), a / 128;
          }
        }
        const ps = s.a3 / 128;
        function Ks(v, e) {
          const a = v.granularity !== void 0 ? Math.max(v.granularity, 1) : 1, c = a + (v.generateBorders ? 2 : 0), m = a + (v.extendToNorthPole || v.generateBorders ? 1 : 0) + (v.extendToSouthPole || v.generateBorders ? 1 : 0), _ = c + 1, x = m + 1, k = v.generateBorders ? -1 : 0, T = v.generateBorders || v.extendToNorthPole ? -1 : 0, R = a + (v.generateBorders ? 1 : 0), A = a + (v.generateBorders || v.extendToSouthPole ? 1 : 0), N = _ * x, j = c * m * 6, G = _ * x > 65536;
          if (G && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const Q = G || e === "32bit", le = new Int16Array(2 * N);
          let ce = 0;
          for (let Se = T; Se <= A; Se++) for (let me = k; me <= R; me++) {
            let ke = me / a * s.a3;
            me === -1 && (ke = -ps), me === a + 1 && (ke = s.a3 + ps);
            let Re = Se / a * s.a3;
            Se === -1 && (Re = v.extendToNorthPole ? s.bk : -ps), Se === a + 1 && (Re = v.extendToSouthPole ? s.bl : s.a3 + ps), le[ce++] = ke, le[ce++] = Re;
          }
          const de = Q ? new Uint32Array(j) : new Uint16Array(j);
          let ge = 0;
          for (let Se = 0; Se < m; Se++) for (let me = 0; me < c; me++) {
            const ke = me + 1 + Se * _, Re = me + (Se + 1) * _, ye = me + 1 + (Se + 1) * _;
            de[ge++] = me + Se * _, de[ge++] = Re, de[ge++] = ke, de[ge++] = ke, de[ge++] = Re, de[ge++] = ye;
          }
          return { vertices: le.buffer.slice(0), indices: de.buffer.slice(0), uses32bitIndices: Q };
        }
        const Js = new s.aO({ fill: new s.bm(128, 2), line: new s.bm(512, 0), tile: new s.bm(128, 32), stencil: new s.bm(128, 1), circle: 3 });
        class Kl {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
          }
          get name() {
            return "vertical-perspective";
          }
          get transitionState() {
            return 1;
          }
          get useSubdivision() {
            return true;
          }
          get shaderVariantName() {
            return "globe";
          }
          get shaderDefine() {
            return "#define GLOBE";
          }
          get shaderPreludeCode() {
            return fr.projectionGlobe;
          }
          get vertexShaderPreludeCode() {
            return fr.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return Js;
          }
          get useGlobeControls() {
            return true;
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable;
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy();
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new Ys(e));
            const a = s.W(this._errorQueryLatitudeDegrees), c = 2 * Math.atan(Math.exp(Math.PI - a * Math.PI * 2)) - 0.5 * Math.PI, m = this._errorMeasurement.updateErrorLoop(a, c), _ = z();
            m !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = m, this._errorMeasurementLastChangeTime = _);
            const x = Math.min(Math.max((_ - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
            this._errorCorrectionUsable = s.bn(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, s.bo(x));
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders ? "b" : ""}${e.extendToNorthPole ? "n" : ""}${e.extendToSouthPole ? "s" : ""}`;
          }
          getMeshFromTileID(e, a, c, m, _) {
            const x = (_ === "stencil" ? Js.stencil : Js.tile).getGranularityForZoomLevel(a.z);
            return this._getMesh(e, { granularity: x, generateBorders: c, extendToNorthPole: a.y === 0 && m, extendToSouthPole: a.y === (1 << a.z) - 1 && m });
          }
          _getMesh(e, a) {
            const c = this._getMeshKey(a);
            if (c in this._tileMeshCache) return this._tileMeshCache[c];
            const m = (function(_, x) {
              const k = Ks(x, "16bit"), T = s.aP.deserialize({ arrayBuffer: k.vertices, length: k.vertices.byteLength / 2 / 2 }), R = s.aR.deserialize({ arrayBuffer: k.indices, length: k.indices.byteLength / 2 / 3 });
              return new ds(_.createVertexBuffer(T, Co.members), _.createIndexBuffer(R), s.aQ.simpleSegment(0, 0, T.length, R.length));
            })(e, a);
            return this._tileMeshCache[c] = m, m;
          }
          recalculate(e) {
          }
          hasTransition() {
            const e = z();
            let a = false;
            return a = a || (e - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, a = a || this._errorMeasurement && this._errorMeasurement.awaitingQuery, a;
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e;
          }
        }
        const Jl = new s.r({ type: new s.D(s.t.projection.type) });
        class Qs extends s.E {
          constructor(e) {
            super(), this._transitionable = new s.x(Jl, void 0), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.G(0)), this._mercatorProjection = new Qi(), this._verticalPerspectiveProjection = new Kl();
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof s.bp) {
              if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition;
            }
            return 1;
          }
          get useGlobeRendering() {
            return this.transitionState > 0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
          }
          get name() {
            return "globe";
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision;
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName;
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine;
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode;
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode;
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity;
          }
          get useGlobeControls() {
            return this.transitionState > 0;
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
          }
          updateGPUdependent(e) {
            this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e);
          }
          getMeshFromTileID(e, a, c, m, _) {
            return this.currentProjection.getMeshFromTileID(e, a, c, m, _);
          }
          setProjection(e) {
            this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator");
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          setErrorQueryLatitudeDegrees(e) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e);
          }
        }
        function ms(v) {
          const e = el(v.worldSize, v.center.lat);
          return 2 * Math.PI * e;
        }
        function ua(v, e, a, c, m) {
          const _ = 1 / (1 << m), x = e / s.a3 * _ + c * _, k = s.br((v / s.a3 * _ + a * _) * Math.PI * 2 + Math.PI, 2 * Math.PI), T = 2 * Math.atan(Math.exp(Math.PI - x * Math.PI * 2)) - 0.5 * Math.PI, R = Math.cos(T), A = new Float64Array(3);
          return A[0] = Math.sin(k) * R, A[1] = Math.sin(T), A[2] = Math.cos(k) * R, A;
        }
        function Ui(v) {
          return (function(e, a) {
            const c = Math.cos(a), m = new Float64Array(3);
            return m[0] = Math.sin(e) * c, m[1] = Math.sin(a), m[2] = Math.cos(e) * c, m;
          })(v.lng * Math.PI / 180, v.lat * Math.PI / 180);
        }
        function el(v, e) {
          return v / (2 * Math.PI) / Math.cos(e * Math.PI / 180);
        }
        function bh(v) {
          const e = Math.asin(v[1]) / Math.PI * 180, a = Math.sqrt(v[0] * v[0] + v[2] * v[2]);
          if (a > 1e-6) {
            const c = v[0] / a, m = Math.acos(v[2] / a), _ = (c > 0 ? m : -m) / Math.PI * 180;
            return new s.U(s.V(_, -180, 180), e);
          }
          return new s.U(0, e);
        }
        function Ql(v) {
          return Math.cos(v * Math.PI / 180);
        }
        function Vr(v, e) {
          const a = Ql(v), c = Ql(e);
          return s.ao(c / a);
        }
        function eu(v, e) {
          const a = v.rotate(e.bearingInRadians), c = e.zoom + Vr(e.center.lat, 0), m = s.bn(1 / Ql(e.center.lat), 1 / Ql(Math.min(Math.abs(e.center.lat), 60)), s.bq(c, 7, 3, 0, 1)), _ = 360 / ms({ worldSize: e.worldSize, center: { lat: e.center.lat } });
          return new s.U(e.center.lng - a.x * _ * m, s.ai(e.center.lat + a.y * _, -s.aj, s.aj));
        }
        function Kn(v) {
          const e = 0.5 * v, a = Math.sin(e), c = Math.cos(e);
          return Math.log(a + c) - Math.log(c - a);
        }
        function tl(v, e, a, c) {
          const m = v.lat + a * c;
          if (Math.abs(a) > 1) {
            const _ = (Math.sign(v.lat + a) !== Math.sign(v.lat) ? -Math.abs(v.lat) : Math.abs(v.lat)) * Math.PI / 180, x = Math.abs(v.lat + a) * Math.PI / 180, k = Kn(_ + c * (x - _)), T = Kn(_), R = Kn(x);
            return new s.U(v.lng + e * ((k - T) / (R - T)), m);
          }
          return new s.U(v.lng + e * c, m);
        }
        class xh {
          constructor(e) {
            this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = false, this._boundingVolumeFactory = e;
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = false;
          }
          getTileBoundingVolume(e, a, c, m) {
            const _ = `${e.z}_${e.x}_${e.y}_${(m == null ? void 0 : m.terrain) ? "t" : ""}`, x = this._cache.get(_);
            if (x) return x;
            const k = this._cachePrevious.get(_);
            if (k) return this._cache.set(_, k), k;
            const T = this._boundingVolumeFactory(e, a, c, m);
            return this._cache.set(_, T), this._hadAnyChanges = true, T;
          }
        }
        class Ra {
          constructor(e, a, c, m) {
            this.min = c, this.max = m, this.points = e, this.planes = a;
          }
          static fromAabb(e, a) {
            const c = [];
            for (let m = 0; m < 8; m++) c.push([1 & ~m ? e[0] : a[0], (m >> 1 & 1) == 1 ? a[1] : e[1], (m >> 2 & 1) == 1 ? a[2] : e[2]]);
            return new Ra(c, [[-1, 0, 0, a[0]], [1, 0, 0, -e[0]], [0, -1, 0, a[1]], [0, 1, 0, -e[1]], [0, 0, -1, a[2]], [0, 0, 1, -e[2]]], e, a);
          }
          static fromCenterSizeAngles(e, a, c) {
            const m = s.bu([], c[0], c[1], c[2]), _ = s.bv([], [a[0], 0, 0], m), x = s.bv([], [0, a[1], 0], m), k = s.bv([], [0, 0, a[2]], m), T = [...e], R = [...e];
            for (let N = 0; N < 8; N++) for (let j = 0; j < 3; j++) {
              const G = e[j] + _[j] * (1 & ~N ? -1 : 1) + x[j] * ((N >> 1 & 1) == 1 ? 1 : -1) + k[j] * ((N >> 2 & 1) == 1 ? 1 : -1);
              T[j] = Math.min(T[j], G), R[j] = Math.max(R[j], G);
            }
            const A = [];
            for (let N = 0; N < 8; N++) {
              const j = [...e];
              s.aV(j, j, s.aU([], _, 1 & ~N ? -1 : 1)), s.aV(j, j, s.aU([], x, (N >> 1 & 1) == 1 ? 1 : -1)), s.aV(j, j, s.aU([], k, (N >> 2 & 1) == 1 ? 1 : -1)), A.push(j);
            }
            return new Ra(A, [[..._, -s.a_(_, A[0])], [...x, -s.a_(x, A[0])], [...k, -s.a_(k, A[0])], [-_[0], -_[1], -_[2], -s.a_(_, A[7])], [-x[0], -x[1], -x[2], -s.a_(x, A[7])], [-k[0], -k[1], -k[2], -s.a_(k, A[7])]], T, R);
          }
          intersectsFrustum(e) {
            let a = true;
            const c = this.points.length, m = this.planes.length, _ = e.planes.length, x = e.points.length;
            for (let k = 0; k < _; k++) {
              const T = e.planes[k];
              let R = 0;
              for (let A = 0; A < c; A++) {
                const N = this.points[A];
                T[0] * N[0] + T[1] * N[1] + T[2] * N[2] + T[3] >= 0 && R++;
              }
              if (R === 0) return 0;
              R < c && (a = false);
            }
            if (a) return 2;
            for (let k = 0; k < m; k++) {
              const T = this.planes[k];
              let R = 0;
              for (let A = 0; A < x; A++) {
                const N = e.points[A];
                T[0] * N[0] + T[1] * N[1] + T[2] * N[2] + T[3] >= 0 && R++;
              }
              if (R === 0) return 0;
            }
            return 1;
          }
          intersectsPlane(e) {
            const a = this.points.length;
            let c = 0;
            for (let m = 0; m < a; m++) {
              const _ = this.points[m];
              e[0] * _[0] + e[1] * _[1] + e[2] * _[2] + e[3] >= 0 && c++;
            }
            return c === a ? 2 : c === 0 ? 0 : 1;
          }
        }
        function Lo(v, e, a) {
          const c = v - e;
          return c < 0 ? -c : Math.max(0, c - a);
        }
        function Pc(v, e, a, c, m) {
          const _ = v - a;
          let x;
          return x = _ < 0 ? Math.min(-_, 1 + _ - m) : _ > 1 ? Math.min(Math.max(_ - m, 0), 1 - _) : 0, Math.max(x, Lo(e, c, m));
        }
        class Np {
          constructor() {
            this._boundingVolumeCache = new xh(this._computeTileBoundingVolume);
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers();
          }
          distanceToTile2d(e, a, c, m) {
            const _ = 1 << c.z, x = 1 / _, k = c.x / _, T = c.y / _;
            let R = 2;
            return R = Math.min(R, Pc(e, a, k, T, x)), R = Math.min(R, Pc(e, a, k + 0.5, -T - x, x)), R = Math.min(R, Pc(e, a, k + 0.5, 2 - T - x, x)), R;
          }
          getWrap(e, a, c) {
            const m = 1 << a.z, _ = 1 / m, x = a.x / m, k = Lo(e.x, x, _), T = Lo(e.x, x - 1, _), R = Lo(e.x, x + 1, _), A = Math.min(k, T, R);
            return A === R ? 1 : A === T ? -1 : 0;
          }
          allowVariableZoom(e, a) {
            return Er(e, a) > 4;
          }
          allowWorldCopies() {
            return false;
          }
          getTileBoundingVolume(e, a, c, m) {
            return this._boundingVolumeCache.getTileBoundingVolume(e, a, c, m);
          }
          _computeTileBoundingVolume(e, a, c, m) {
            var _, x;
            let k = 0, T = 0;
            if (m == null ? void 0 : m.terrain) {
              const R = new s.a0(e.z, a, e.z, e.x, e.y), A = m.terrain.getMinMaxElevation(R);
              k = (_ = A.minElevation) !== null && _ !== void 0 ? _ : Math.min(0, c), T = (x = A.maxElevation) !== null && x !== void 0 ? x : Math.max(0, c);
            }
            if (k /= s.bx, T /= s.bx, k += 1, T += 1, e.z <= 0) return Ra.fromAabb([-T, -T, -T], [T, T, T]);
            if (e.z === 1) return Ra.fromAabb([e.x === 0 ? -T : 0, e.y === 0 ? 0 : -T, -T], [e.x === 0 ? 0 : T, e.y === 0 ? T : 0, T]);
            {
              const R = [ua(0, 0, e.x, e.y, e.z), ua(s.a3, 0, e.x, e.y, e.z), ua(s.a3, s.a3, e.x, e.y, e.z), ua(0, s.a3, e.x, e.y, e.z)], A = [];
              for (const Ye of R) A.push(s.aU([], Ye, T));
              if (T !== k) for (const Ye of R) A.push(s.aU([], Ye, k));
              e.y === 0 && A.push([0, 1, 0]), e.y === (1 << e.z) - 1 && A.push([0, -1, 0]);
              const N = [1, 1, 1], j = [-1, -1, -1];
              for (const Ye of A) for (let Qe = 0; Qe < 3; Qe++) N[Qe] = Math.min(N[Qe], Ye[Qe]), j[Qe] = Math.max(j[Qe], Ye[Qe]);
              const G = ua(s.a3 / 2, s.a3 / 2, e.x, e.y, e.z), Q = s.aZ([], [0, 1, 0], G);
              s.aY(Q, Q);
              const le = s.aZ([], G, Q);
              s.aY(le, le);
              const ce = s.aZ([], R[2], R[1]);
              s.aY(ce, ce);
              const de = s.aZ([], R[0], R[3]);
              s.aY(de, de), A.push(s.aU([], G, T)), e.y >= (1 << e.z) / 2 && A.push(s.aU([], ua(s.a3 / 2, 0, e.x, e.y, e.z), T)), e.y < (1 << e.z) / 2 && A.push(s.aU([], ua(s.a3 / 2, s.a3, e.x, e.y, e.z), T));
              const ge = wh(G, A), Se = wh(le, A), me = [-G[0], -G[1], -G[2], ge.max], ke = [G[0], G[1], G[2], -ge.min], Re = [-le[0], -le[1], -le[2], Se.max], ye = [le[0], le[1], le[2], -Se.min], Be = [...ce, 0], Ke = [...de, 0], He = [];
              return e.y === 0 ? He.push(s.bw(Ke, Be, me), s.bw(Ke, Be, ke)) : He.push(s.bw(Re, Be, me), s.bw(Re, Be, ke), s.bw(Re, Ke, me), s.bw(Re, Ke, ke)), e.y === (1 << e.z) - 1 ? He.push(s.bw(Ke, Be, me), s.bw(Ke, Be, ke)) : He.push(s.bw(ye, Be, me), s.bw(ye, Be, ke), s.bw(ye, Ke, me), s.bw(ye, Ke, ke)), new Ra(He, [me, ke, Re, ye, Be, Ke], N, j);
            }
          }
        }
        function wh(v, e) {
          let a = 1 / 0, c = -1 / 0;
          for (const m of e) {
            const _ = s.a_(v, m);
            a = Math.min(a, _), c = Math.max(c, _);
          }
          return { min: a, max: c };
        }
        class tu {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, a, c) {
            return this._helper.interpolatePadding(e, a, c);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, a) {
            this._helper.resize(e, a);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          setConstrain(e) {
            this._helper.setConstrain(e);
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get constrain() {
            return this._helper.constrain;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e) {
          }
          constructor(e) {
            this._cachedClippingPlane = s.by(), this._projectionMatrix = s.bc(), this._globeViewProjMatrix32f = s.bb(), this._globeViewProjMatrixNoCorrection = s.bc(), this._globeViewProjMatrixNoCorrectionInverted = s.bc(), this._globeProjMatrixInverted = s.bc(), this._cameraPosition = s.bs(), this._globeLatitudeErrorCorrectionRadians = 0, this.defaultConstrain = (a, c) => {
              const m = s.ai(a.lat, -s.aj, s.aj), _ = s.ai(+c, this.minZoom + Vr(0, m), this.maxZoom);
              return { center: new s.U(a.lng, m), zoom: _ };
            }, this._helper = new un({ calcMatrices: () => {
              this._calcMatrices();
            }, constrain: (a, c) => this.defaultConstrain(a, c) }, e), this._coveringTilesDetailsProvider = new Np();
          }
          clone() {
            const e = new tu();
            return e.apply(this), e;
          }
          apply(e, a) {
            this._globeLatitudeErrorCorrectionRadians = a || 0, this._helper.apply(e);
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection;
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted;
          }
          get cameraPosition() {
            const e = s.bs();
            return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          getProjectionData(e) {
            const { overscaledTileID: a, applyGlobeMatrix: c } = e, m = this._helper.getMercatorTileCoordinates(a);
            return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: m, clippingPlane: this._cachedClippingPlane, projectionTransition: c ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
          }
          _computeClippingPlane(e) {
            const a = this.pitchInRadians, c = this.cameraToCenterDistance / e, m = Math.sin(a) * c, _ = Math.cos(a) * c + 1, x = 1 / Math.sqrt(m * m + _ * _) * 1;
            let k = -m, T = _;
            const R = Math.sqrt(k * k + T * T);
            k /= R, T /= R;
            const A = [0, k, T];
            s.bz(A, A, [0, 0, 0], -this.bearingInRadians), s.bA(A, A, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), s.bB(A, A, [0, 0, 0], this.center.lng * Math.PI / 180);
            const N = 1 / s.b0(A);
            return s.aU(A, A, N), [...A, -x * N];
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(Ui(e));
          }
          transformLightDirection(e) {
            const a = this._helper._center.lng * Math.PI / 180, c = this._helper._center.lat * Math.PI / 180, m = Math.cos(c), _ = [Math.sin(a) * m, Math.sin(c), Math.cos(a) * m], x = [_[2], 0, -_[0]], k = [0, 0, 0];
            s.aZ(k, x, _), s.aY(x, x), s.aY(k, k);
            const T = [0, 0, 0];
            return s.aY(T, [x[0] * e[0] + k[0] * e[1] + _[0] * e[2], x[1] * e[0] + k[1] * e[1] + _[1] * e[2], x[2] * e[0] + k[2] * e[1] + _[2] * e[2]]), T;
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getPitchedTextCorrection(e, a, c) {
            const m = (function(k, T, R) {
              const A = 1 / (1 << R.z);
              return new s.a5(k / s.a3 * A + R.x * A, T / s.a3 * A + R.y * A);
            })(e, a, c.canonical), _ = (x = m.y, [s.br(m.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - x * Math.PI * 2)) - 0.5 * Math.PI]);
            var x;
            return this.getCircleRadiusCorrection() / Math.cos(_[1]);
          }
          projectTileCoordinates(e, a, c, m) {
            const _ = c.canonical, x = ua(e, a, _.x, _.y, _.z), k = 1 + (m ? m(e, a) : 0) / s.bx, T = [x[0] * k, x[1] * k, x[2] * k, 1];
            s.aA(T, T, this._globeViewProjMatrixNoCorrection);
            const R = this._cachedClippingPlane, A = R[0] * x[0] + R[1] * x[1] + R[2] * x[2] + R[3] < 0;
            return { point: new s.P(T[0] / T[3], T[1] / T[3]), signedDistanceFromCamera: T[3], isOccluded: A };
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = el(this.worldSize, this.center.lat), a = s.bd(), c = s.bd();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), s.b7(a, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const m = this.centerOffset;
            a[8] = 2 * -m.x / this._helper._width, a[9] = 2 * m.y / this._helper._height, this._projectionMatrix = s.b8(a), this._globeProjMatrixInverted = s.bd(), s.au(this._globeProjMatrixInverted, a), s.N(a, a, [0, 0, -this.cameraToCenterDistance]), s.b9(a, a, this.rollInRadians), s.ba(a, a, -this.pitchInRadians), s.b9(a, a, this.bearingInRadians), s.N(a, a, [0, 0, -e]);
            const _ = s.bs();
            _[0] = e, _[1] = e, _[2] = e, s.ba(c, a, this.center.lat * Math.PI / 180), s.bC(c, c, -this.center.lng * Math.PI / 180), s.O(c, c, _), this._globeViewProjMatrixNoCorrection = c, s.ba(a, a, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), s.bC(a, a, -this.center.lng * Math.PI / 180), s.O(a, a, _), this._globeViewProjMatrix32f = new Float32Array(a), this._globeViewProjMatrixNoCorrectionInverted = s.bd(), s.au(this._globeViewProjMatrixNoCorrectionInverted, c);
            const x = s.bs();
            this._cameraPosition = s.bs(), this._cameraPosition[2] = this.cameraToCenterDistance / e, s.bz(this._cameraPosition, this._cameraPosition, x, -this.rollInRadians), s.bA(this._cameraPosition, this._cameraPosition, x, this.pitchInRadians), s.bz(this._cameraPosition, this._cameraPosition, x, -this.bearingInRadians), s.aV(this._cameraPosition, this._cameraPosition, [0, 0, 1]), s.bA(this._cameraPosition, this._cameraPosition, x, -this.center.lat * Math.PI / 180), s.bB(this._cameraPosition, this._cameraPosition, x, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
            const k = s.b8(this._globeViewProjMatrixNoCorrectionInverted);
            s.O(k, k, [1, 1, -1]), this._cachedFrustum = Xs.fromInvProjectionMatrix(k, 1, 0, this._cachedClippingPlane, true);
          }
          calculateFogMatrix(e) {
            s.w("calculateFogMatrix is not supported on globe projection.");
            const a = s.bd();
            return s.am(a), a;
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new s.b5(0, e)];
          }
          getCameraFrustum() {
            return this._cachedFrustum;
          }
          getClippingPlane() {
            return this._cachedClippingPlane;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e) {
            e && s.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
          }
          maxPitchScaleFactor() {
            return 1;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e, a) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const c = Ui(e);
            s.aU(c, c, 1 + a / s.bx);
            const m = s.by();
            return s.aA(m, [c[0], c[1], c[2], 1], this._globeViewProjMatrixNoCorrection), m[2] / m[3];
          }
          populateCache(e) {
          }
          getBounds() {
            const e = 0.5 * this.width, a = 0.5 * this.height, c = [new s.P(0, 0), new s.P(e, 0), new s.P(this.width, 0), new s.P(this.width, a), new s.P(this.width, this.height), new s.P(e, this.height), new s.P(0, this.height), new s.P(0, a)], m = [];
            for (const N of c) m.push(this.unprojectScreenPoint(N));
            let _ = 0, x = 0, k = 0, T = 0;
            const R = this.center;
            for (const N of m) {
              const j = s.bD(R.lng, N.lng), G = s.bD(R.lat, N.lat);
              j < x && (x = j), j > _ && (_ = j), G < T && (T = G), G > k && (k = G);
            }
            const A = [R.lng + x, R.lat + T, R.lng + _, R.lat + k];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (A[3] = 90, A[0] = -180, A[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (A[1] = -90, A[0] = -180, A[2] = 180), new nr(A);
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, m) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, c, m);
          }
          setLocationAtPoint(e, a) {
            const c = Ui(this.unprojectScreenPoint(a)), m = Ui(e), _ = s.bs();
            s.bE(_);
            const x = s.bs();
            s.bB(x, c, _, -this.center.lng * Math.PI / 180), s.bA(x, x, _, this.center.lat * Math.PI / 180);
            const k = m[0] * m[0] + m[2] * m[2], T = x[0] * x[0];
            if (k < T) return;
            const R = Math.sqrt(k - T), A = -R, N = s.bF(m[0], m[2], x[0], R), j = s.bF(m[0], m[2], x[0], A), G = s.bs();
            s.bB(G, m, _, -N);
            const Q = s.bF(G[1], G[2], x[1], x[2]), le = s.bs();
            s.bB(le, m, _, -j);
            const ce = s.bF(le[1], le[2], x[1], x[2]), de = 0.5 * Math.PI, ge = Q >= -de && Q <= de, Se = ce >= -de && ce <= de;
            let me, ke;
            if (ge && Se) {
              const Ke = this.center.lng * Math.PI / 180, He = this.center.lat * Math.PI / 180;
              s.bG(N, Ke) + s.bG(Q, He) < s.bG(j, Ke) + s.bG(ce, He) ? (me = N, ke = Q) : (me = j, ke = ce);
            } else if (ge) me = N, ke = Q;
            else {
              if (!Se) return;
              me = j, ke = ce;
            }
            const Re = me / Math.PI * 180, ye = ke / Math.PI * 180, Be = this.center.lat;
            this.setCenter(new s.U(Re, s.ai(ye, -90, 90))), this.setZoom(this.zoom + Vr(Be, this.center.lat));
          }
          locationToScreenPoint(e, a) {
            const c = Ui(e);
            if (a) {
              const m = a.getElevationForLngLatZoom(e, this._helper._tileZoom);
              s.aU(c, c, 1 + m / s.bx);
            }
            return this._projectSurfacePointToScreen(c);
          }
          _projectSurfacePointToScreen(e) {
            const a = s.by();
            return s.aA(a, [...e, 1], this._globeViewProjMatrixNoCorrection), a[0] /= a[3], a[1] /= a[3], new s.P((0.5 * a[0] + 0.5) * this.width, (0.5 * -a[1] + 0.5) * this.height);
          }
          screenPointToMercatorCoordinate(e, a) {
            if (a) {
              const c = a.pointCoordinate(e);
              if (c) return c;
            }
            return s.a5.fromLngLat(this.unprojectScreenPoint(e));
          }
          screenPointToLocation(e, a) {
            var c;
            return (c = this.screenPointToMercatorCoordinate(e, a)) === null || c === void 0 ? void 0 : c.toLngLat();
          }
          isPointOnMapSurface(e, a) {
            const c = this._cameraPosition, m = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(c, m);
          }
          getRayDirectionFromPixel(e) {
            const a = s.by();
            a[0] = e.x / this.width * 2 - 1, a[1] = -1 * (e.y / this.height * 2 - 1), a[2] = 1, a[3] = 1, s.aA(a, a, this._globeViewProjMatrixNoCorrectionInverted), a[0] /= a[3], a[1] /= a[3], a[2] /= a[3];
            const c = s.bs();
            c[0] = a[0] - this._cameraPosition[0], c[1] = a[1] - this._cameraPosition[1], c[2] = a[2] - this._cameraPosition[2];
            const m = s.bs();
            return s.aY(m, c), m;
          }
          isSurfacePointVisible(e) {
            const a = this._cachedClippingPlane;
            return a[0] * e[0] + a[1] * e[1] + a[2] * e[2] + a[3] >= 0;
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return false;
            const a = s.by();
            return s.aA(a, [...e, 1], this._globeViewProjMatrixNoCorrection), a[0] /= a[3], a[1] /= a[3], a[2] /= a[3], a[0] > -1 && a[0] < 1 && a[1] > -1 && a[1] < 1 && a[2] > -1 && a[2] < 1;
          }
          rayPlanetIntersection(e, a) {
            const c = s.a_(e, a), m = s.bs(), _ = s.bs();
            s.aU(_, a, c), s.aX(m, e, _);
            const x = 1 - s.a_(m, m);
            if (x < 0) return null;
            const k = s.a_(e, e) - 1, T = -c + (c < 0 ? 1 : -1) * Math.sqrt(x), R = k / T, A = T;
            return { tMin: Math.min(R, A), tMax: Math.max(R, A) };
          }
          unprojectScreenPoint(e) {
            const a = this._cameraPosition, c = this.getRayDirectionFromPixel(e), m = this.rayPlanetIntersection(a, c);
            if (m) {
              const A = s.bs();
              s.aV(A, a, [c[0] * m.tMin, c[1] * m.tMin, c[2] * m.tMin]);
              const N = s.bs();
              return s.aY(N, A), bh(N);
            }
            const _ = this._cachedClippingPlane, x = _[0] * c[0] + _[1] * c[1] + _[2] * c[2], k = -s.b4(_, a) / x, T = s.bs();
            if (k > 0) s.aV(T, a, [c[0] * k, c[1] * k, c[2] * k]);
            else {
              const A = s.bs();
              s.aV(A, a, [2 * c[0], 2 * c[1], 2 * c[2]]);
              const N = s.b4(this._cachedClippingPlane, A);
              s.aX(T, A, [this._cachedClippingPlane[0] * N, this._cachedClippingPlane[1] * N, this._cachedClippingPlane[2] * N]);
            }
            const R = (function(A) {
              const N = s.bs();
              return N[0] = A[0] * -A[3], N[1] = A[1] * -A[3], N[2] = A[2] * -A[3], { center: N, radius: Math.sqrt(1 - A[3] * A[3]) };
            })(_);
            return bh((function(A, N, j) {
              const G = s.bs();
              s.aX(G, j, A);
              const Q = s.bs();
              return s.bt(Q, A, G, N / s.b2(G)), Q;
            })(R.center, R.radius, T));
          }
          getMatrixForModel(e, a) {
            const c = s.U.convert(e), m = 1 / s.bx, _ = s.bc();
            return s.bC(_, _, c.lng / 180 * Math.PI), s.ba(_, _, -c.lat / 180 * Math.PI), s.N(_, _, [0, 0, 1 + a / s.bx]), s.ba(_, _, 0.5 * Math.PI), s.O(_, _, [m, m, m]), _;
          }
          getProjectionDataForCustomLayer(e = true) {
            const a = this.getProjectionData({ overscaledTileID: new s.a0(0, 0, 0, 0, 0), applyGlobeMatrix: e });
            return a.tileMercatorCoords = [0, 0, 1, 1], a;
          }
          getFastPathSimpleProjectionMatrix(e) {
          }
        }
        class ru {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, a, c) {
            return this._helper.interpolatePadding(e, a, c);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, a, c = true) {
            this._helper.resize(e, a, c);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          setConstrain(e) {
            this._helper.setConstrain(e);
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get constrain() {
            return this._helper.constrain;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          get isGlobeRendering() {
            return this._globeness > 0;
          }
          setTransitionState(e, a) {
            this._globeness = e, this._globeLatitudeErrorCorrectionRadians = a, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
          }
          constructor(e) {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this.defaultConstrain = (a, c) => this.currentTransform.defaultConstrain(a, c), this._helper = new un({ calcMatrices: () => {
              this._calcMatrices();
            }, constrain: (a, c) => this.defaultConstrain(a, c) }, e), this._globeness = 1, this._mercatorTransform = new So(), this._verticalPerspectiveTransform = new tu();
          }
          clone() {
            const e = new ru();
            return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e;
          }
          apply(e) {
            this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix;
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix;
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition;
          }
          getProjectionData(e) {
            const a = this._mercatorTransform.getProjectionData(e), c = this._verticalPerspectiveTransform.getProjectionData(e);
            return { mainMatrix: this.isGlobeRendering ? c.mainMatrix : a.mainMatrix, clippingPlane: c.clippingPlane, tileMercatorCoords: c.tileMercatorCoords, projectionTransition: e.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: a.fallbackMatrix };
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e);
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e);
          }
          getPixelScale() {
            return s.bn(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
          }
          getCircleRadiusCorrection() {
            return s.bn(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
          }
          getPitchedTextCorrection(e, a, c) {
            const m = this._mercatorTransform.getPitchedTextCorrection(e, a, c), _ = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, a, c);
            return s.bn(m, _, this._globeness);
          }
          projectTileCoordinates(e, a, c, m) {
            return this.currentTransform.projectTileCoordinates(e, a, c, m);
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, true, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e);
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e);
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum();
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane();
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider();
          }
          recalculateZoomAndCenter(e) {
            this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e);
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor();
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e, a) {
            return this.currentTransform.lngLatToCameraDepth(e, a);
          }
          populateCache(e) {
            this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e);
          }
          getBounds() {
            return this.currentTransform.getBounds();
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, m) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, c, m);
          }
          setLocationAtPoint(e, a) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, a), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e, a), this.apply(this._verticalPerspectiveTransform);
          }
          locationToScreenPoint(e, a) {
            return this.currentTransform.locationToScreenPoint(e, a);
          }
          screenPointToMercatorCoordinate(e, a) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, a);
          }
          screenPointToLocation(e, a) {
            return this.currentTransform.screenPointToLocation(e, a);
          }
          isPointOnMapSurface(e, a) {
            return this.currentTransform.isPointOnMapSurface(e, a);
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e);
          }
          getMatrixForModel(e, a) {
            return this.currentTransform.getMatrixForModel(e, a);
          }
          getProjectionDataForCustomLayer(e = true) {
            const a = this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return a;
            const c = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
            return c.fallbackMatrix = a.mainMatrix, c;
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e);
          }
        }
        class so {
          get useGlobeControls() {
            return true;
          }
          handlePanInertia(e, a) {
            const c = eu(e, a);
            return Math.abs(c.lng - a.center.lng) > 180 && (c.lng = a.center.lng + 179.5 * Math.sign(c.lng - a.center.lng)), { easingCenter: c, easingOffset: new s.P(0, 0) };
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            const c = e.around, m = a.screenPointToLocation(c);
            e.bearingDelta && a.setBearing(a.bearing + e.bearingDelta), e.pitchDelta && a.setPitch(a.pitch + e.pitchDelta), e.rollDelta && a.setRoll(a.roll + e.rollDelta);
            const _ = a.zoom;
            e.zoomDelta && a.setZoom(a.zoom + e.zoomDelta);
            const x = a.zoom - _;
            if (x === 0) return;
            const k = s.bD(a.center.lng, m.lng), T = k / (Math.abs(k / 180) + 1), R = s.bD(a.center.lat, m.lat), A = a.getRayDirectionFromPixel(c), N = a.cameraPosition, j = -1 * s.a_(N, A), G = s.bs();
            s.aV(G, N, [A[0] * j, A[1] * j, A[2] * j]);
            const Q = s.b0(G) - 1, le = Math.exp(0.5 * -Math.max(Q - 0.3, 0)), ce = el(a.worldSize, a.center.lat) / Math.min(a.width, a.height), de = s.bq(ce, 0.9, 0.5, 1, 0.25), ge = (1 - s.al(-x)) * Math.min(le, de), Se = a.center.lat, me = a.zoom, ke = new s.U(a.center.lng + T * ge, s.ai(a.center.lat + R * ge, -s.aj, s.aj));
            a.setLocationAtPoint(m, c);
            const Re = a.center, ye = s.bq(Math.abs(k), 45, 85, 0, 1), Be = s.bq(ce, 0.75, 0.35, 0, 1), Ke = Math.pow(Math.max(ye, Be), 0.25), He = s.bD(Re.lng, ke.lng), Ye = s.bD(Re.lat, ke.lat);
            a.setCenter(new s.U(Re.lng + He * Ke, Re.lat + Ye * Ke).wrap()), a.setZoom(me + Vr(Se, a.center.lat));
          }
          handleMapControlsPan(e, a, c) {
            if (!e.panDelta) return;
            const m = a.center.lat, _ = a.zoom;
            a.setCenter(eu(e.panDelta, a).wrap()), a.setZoom(_ + Vr(m, a.center.lat));
          }
          cameraForBoxAndBearing(e, a, c, m, _) {
            const x = la(e, a, c, m, _), k = a.left / _.width * 2 - 1, T = (_.width - a.right) / _.width * 2 - 1, R = a.top / _.height * -2 + 1, A = (_.height - a.bottom) / _.height * -2 + 1, N = s.bD(c.getWest(), c.getEast()) < 0, j = N ? c.getEast() : c.getWest(), G = N ? c.getWest() : c.getEast(), Q = Math.max(c.getNorth(), c.getSouth()), le = Math.min(c.getNorth(), c.getSouth()), ce = j + 0.5 * s.bD(j, G), de = Q + 0.5 * s.bD(Q, le), ge = _.clone();
            ge.setCenter(x.center), ge.setBearing(x.bearing), ge.setPitch(0), ge.setRoll(0), ge.setZoom(x.zoom);
            const Se = ge.modelViewProjectionMatrix, me = [Ui(c.getNorthWest()), Ui(c.getNorthEast()), Ui(c.getSouthWest()), Ui(c.getSouthEast()), Ui(new s.U(G, de)), Ui(new s.U(j, de)), Ui(new s.U(ce, Q)), Ui(new s.U(ce, le))], ke = Ui(x.center);
            let Re = Number.POSITIVE_INFINITY;
            for (const ye of me) k < 0 && (Re = so.getLesserNonNegativeNonNull(Re, so.solveVectorScale(ye, ke, Se, "x", k))), T > 0 && (Re = so.getLesserNonNegativeNonNull(Re, so.solveVectorScale(ye, ke, Se, "x", T))), R > 0 && (Re = so.getLesserNonNegativeNonNull(Re, so.solveVectorScale(ye, ke, Se, "y", R))), A < 0 && (Re = so.getLesserNonNegativeNonNull(Re, so.solveVectorScale(ye, ke, Se, "y", A)));
            if (Number.isFinite(Re) && Re !== 0) return x.zoom = ge.zoom + s.ao(Re), x;
            wi();
          }
          handleJumpToCenterZoom(e, a) {
            const c = e.center.lat, m = e.constrain(a.center ? s.U.convert(a.center) : e.center, e.zoom).center;
            e.setCenter(m.wrap());
            const _ = a.zoom !== void 0 ? +a.zoom : e.zoom + Vr(c, m.lat);
            e.zoom !== _ && e.setZoom(_);
          }
          handleEaseTo(e, a) {
            const c = e.zoom, m = e.center, _ = e.padding, x = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, k = { roll: a.roll === void 0 ? e.roll : a.roll, pitch: a.pitch === void 0 ? e.pitch : a.pitch, bearing: a.bearing === void 0 ? e.bearing : a.bearing }, T = a.zoom !== void 0, R = !e.isPaddingEqual(a.padding);
            let A = false;
            const N = a.center ? s.U.convert(a.center) : m, j = e.constrain(N, c).center;
            ri(e, j);
            const G = e.clone();
            G.setCenter(j), G.setZoom(T ? +a.zoom : c + Vr(m.lat, N.lat)), G.setBearing(a.bearing);
            const Q = new s.P(s.ai(e.centerPoint.x + a.offsetAsPoint.x, 0, e.width), s.ai(e.centerPoint.y + a.offsetAsPoint.y, 0, e.height));
            G.setLocationAtPoint(j, Q);
            const le = (a.offset && a.offsetAsPoint.mag()) > 0 ? G.center : j, ce = T ? +a.zoom : c + Vr(m.lat, le.lat), de = c + Vr(m.lat, 0), ge = ce + Vr(le.lat, 0), Se = s.bD(m.lng, le.lng), me = s.bD(m.lat, le.lat), ke = s.al(ge - de);
            return A = ce !== c, { easeFunc: (Re) => {
              if (s.bh(x, k) || hs({ startEulerAngles: x, endEulerAngles: k, tr: e, k: Re, useSlerp: x.roll != k.roll }), R && e.interpolatePadding(_, a.padding, Re), a.around) s.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(a.around, a.aroundPoint);
              else {
                const ye = ge > de ? Math.min(2, ke) : Math.max(0.5, ke), Be = Math.pow(ye, 1 - Re), Ke = tl(m, Se, me, Re * Be);
                e.setCenter(Ke.wrap());
              }
              if (A) {
                const ye = s.F.number(de, ge, Re) + Vr(0, e.center.lat);
                e.setZoom(ye);
              }
            }, isZooming: A, elevationCenter: le };
          }
          handleFlyTo(e, a) {
            const c = a.zoom !== void 0, m = e.center, _ = e.zoom, x = e.padding, k = !e.isPaddingEqual(a.padding), T = e.constrain(s.U.convert(a.center || a.locationAtOffset), _).center, R = c ? +a.zoom : e.zoom + Vr(e.center.lat, T.lat), A = e.clone();
            A.setCenter(T), A.setZoom(R), A.setBearing(a.bearing);
            const N = new s.P(s.ai(e.centerPoint.x + a.offsetAsPoint.x, 0, e.width), s.ai(e.centerPoint.y + a.offsetAsPoint.y, 0, e.height));
            A.setLocationAtPoint(T, N);
            const j = A.center;
            ri(e, j);
            const G = (function(me, ke, Re) {
              const ye = Ui(ke), Be = Ui(Re), Ke = s.a_(ye, Be), He = Math.acos(Ke), Ye = ms(me);
              return He / (2 * Math.PI) * Ye;
            })(e, m, j), Q = _ + Vr(m.lat, 0), le = R + Vr(j.lat, 0), ce = s.al(le - Q);
            let de;
            if (typeof a.minZoom == "number") {
              const me = +a.minZoom + Vr(j.lat, 0), ke = Math.min(me, Q, le) + Vr(0, j.lat), Re = e.constrain(j, ke).zoom + Vr(j.lat, 0);
              de = s.al(Re - Q);
            }
            const ge = s.bD(m.lng, j.lng), Se = s.bD(m.lat, j.lat);
            return { easeFunc: (me, ke, Re, ye) => {
              const Be = tl(m, ge, Se, Re);
              k && e.interpolatePadding(x, a.padding, me);
              const Ke = me === 1 ? j : Be;
              e.setCenter(Ke.wrap());
              const He = Q + s.ao(ke);
              e.setZoom(me === 1 ? R : He + Vr(0, Ke.lat));
            }, scaleOfZoom: ce, targetCenter: j, scaleOfMinZoom: de, pixelPathLength: G };
          }
          static solveVectorScale(e, a, c, m, _) {
            const x = m === "x" ? [c[0], c[4], c[8], c[12]] : [c[1], c[5], c[9], c[13]], k = [c[3], c[7], c[11], c[15]], T = e[0] * x[0] + e[1] * x[1] + e[2] * x[2], R = e[0] * k[0] + e[1] * k[1] + e[2] * k[2], A = a[0] * x[0] + a[1] * x[1] + a[2] * x[2], N = a[0] * k[0] + a[1] * k[1] + a[2] * k[2];
            return A + _ * R === T + _ * N || k[3] * (T - A) + x[3] * (N - R) + T * N == A * R ? null : (A + x[3] - _ * N - _ * k[3]) / (A - T - _ * N + _ * R);
          }
          static getLesserNonNegativeNonNull(e, a) {
            return a !== null && a >= 0 && a < e ? a : e;
          }
        }
        class rl {
          constructor(e) {
            this._globe = e, this._mercatorCameraHelper = new Ea(), this._verticalPerspectiveCameraHelper = new so();
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering;
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
          }
          handlePanInertia(e, a) {
            return this.currentHelper.handlePanInertia(e, a);
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, a);
          }
          handleMapControlsPan(e, a, c) {
            this.currentHelper.handleMapControlsPan(e, a, c);
          }
          cameraForBoxAndBearing(e, a, c, m, _) {
            return this.currentHelper.cameraForBoxAndBearing(e, a, c, m, _);
          }
          handleJumpToCenterZoom(e, a) {
            this.currentHelper.handleJumpToCenterZoom(e, a);
          }
          handleEaseTo(e, a) {
            return this.currentHelper.handleEaseTo(e, a);
          }
          handleFlyTo(e, a) {
            return this.currentHelper.handleFlyTo(e, a);
          }
        }
        const gs = (v, e) => s.z(v, e && e.filter(((a) => a.identifier !== "source.canvas"))), iu = s.bH();
        class il extends s.E {
          constructor(e, a = {}) {
            var c, m;
            super(), this._rtlPluginLoaded = () => {
              for (const x in this.tileManagers) {
                const k = this.tileManagers[x].getSource().type;
                k !== "vector" && k !== "geojson" || this.tileManagers[x].reload();
              }
            }, this.map = e, this.dispatcher = new ir(Zt(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", ((x, k) => this.getGlyphs(x, k))), this.dispatcher.registerMessageHandler("GI", ((x, k) => this.getImages(x, k))), this.dispatcher.registerMessageHandler("GDA", ((x, k) => this.getDashes(x, k))), this.imageManager = new _e(), this.imageManager.setEventedParent(this);
            const _ = ((c = e._container) === null || c === void 0 ? void 0 : c.lang) || typeof document < "u" && ((m = document.documentElement) === null || m === void 0 ? void 0 : m.lang) || void 0;
            this.glyphManager = new mt(e._requestManager, a.localIdeographFontFamily, _), this.lineAtlas = new pt(256, 512), this.crossTileSymbolIndex = new ao(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.tileManagers = {}, this.zoomHistory = new s.bI(), this._loaded = false, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", s.bJ()), Y().on(sn, this._rtlPluginLoaded), this.on("data", ((x) => {
              if (x.dataType !== "source" || x.sourceDataType !== "metadata") return;
              const k = this.tileManagers[x.sourceId];
              if (!k) return;
              const T = k.getSource();
              if (T && T.vectorLayerIds) for (const R in this._layers) {
                const A = this._layers[R];
                A.source === T.id && this._validateLayer(A);
              }
            }));
          }
          setGlobalStateProperty(e, a) {
            var c, m, _;
            this._checkLoaded();
            const x = a === null ? (_ = (m = (c = this.stylesheet.state) === null || c === void 0 ? void 0 : c[e]) === null || m === void 0 ? void 0 : m.default) !== null && _ !== void 0 ? _ : null : a;
            if (s.bK(x, this._globalState[e])) return this;
            this._globalState[e] = x, this._applyGlobalStateChanges([e]);
          }
          getGlobalState() {
            return this._globalState;
          }
          setGlobalState(e) {
            this._checkLoaded();
            const a = [];
            for (const c in e) !s.bK(this._globalState[c], e[c].default) && (a.push(c), this._globalState[c] = e[c].default);
            this._applyGlobalStateChanges(a);
          }
          _applyGlobalStateChanges(e) {
            if (e.length === 0) return;
            const a = /* @__PURE__ */ new Set(), c = {};
            for (const m of e) {
              c[m] = this._globalState[m];
              for (const _ in this._layers) {
                const x = this._layers[_], k = x.getLayoutAffectingGlobalStateRefs(), T = x.getPaintAffectingGlobalStateRefs();
                if (k.has(m) && a.add(x.source), T.has(m)) for (const { name: R, value: A } of T.get(m)) this._updatePaintProperty(x, R, A);
              }
            }
            this.dispatcher.broadcast("UGS", c);
            for (const m in this.tileManagers) a.has(m) && (this._reloadSource(m), this._changed = true);
          }
          loadURL(e, a = {}, c) {
            this.fire(new s.l("dataloading", { dataType: "style" })), a.validate = typeof a.validate != "boolean" || a.validate;
            const m = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController();
            const _ = this._loadStyleRequest;
            s.j(m, this._loadStyleRequest).then(((x) => {
              this._loadStyleRequest = null, this._load(x.data, a, c);
            })).catch(((x) => {
              this._loadStyleRequest = null, x && !_.signal.aborted && this.fire(new s.k(x));
            }));
          }
          loadJSON(e, a = {}, c) {
            this.fire(new s.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), L.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, a.validate = a.validate !== false, this._load(e, a, c);
            })).catch((() => {
            }));
          }
          loadEmpty() {
            this.fire(new s.l("dataloading", { dataType: "style" })), this._load(iu, { validate: false });
          }
          _load(e, a, c) {
            var m, _;
            let x = a.transformStyle ? a.transformStyle(c, e) : e;
            if (!a.validate || !gs(this, s.B(x))) {
              x = Object.assign({}, x), this._loaded = true, this.stylesheet = x;
              for (const k in x.sources) this.addSource(k, x.sources[k], { validate: false });
              x.sprite ? this._loadSprite(x.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(x.glyphs), this._createLayers(), this.light = new nt(this.stylesheet.light), this._setProjectionInternal(((m = this.stylesheet.projection) === null || m === void 0 ? void 0 : m.type) || "mercator"), this.sky = new Lt(this.stylesheet.sky), this.map.setTerrain((_ = this.stylesheet.terrain) !== null && _ !== void 0 ? _ : null), this.fire(new s.l("data", { dataType: "style" })), this.fire(new s.l("style.load"));
            }
          }
          _createLayers() {
            var e, a, c;
            const m = s.bL(this.stylesheet.layers);
            this.setGlobalState((e = this.stylesheet.state) !== null && e !== void 0 ? e : null), this.dispatcher.broadcast("SL", m), this._order = m.map(((_) => _.id)), this._layers = {}, this._serializedLayers = null;
            for (const _ of m) {
              const x = s.bM(_, this._globalState);
              if (x.setEventedParent(this, { layer: { id: _.id } }), this._layers[_.id] = x, s.bN(x) && this.tileManagers[x.source]) {
                const k = (c = (a = _.paint) === null || a === void 0 ? void 0 : a["raster-fade-duration"]) !== null && c !== void 0 ? c : x.paint.get("raster-fade-duration");
                this.tileManagers[x.source].setRasterFadeDuration(k);
              }
            }
          }
          _loadSprite(e, a = false, c = void 0) {
            let m;
            this.imageManager.setLoaded(false), this._spriteRequest = new AbortController(), (function(_, x, k, T) {
              return s._(this, void 0, void 0, (function* () {
                const R = fe(_), A = k > 1 ? "@2x" : "", N = {}, j = {};
                for (const { id: G, url: Q } of R) {
                  const le = x.transformRequest(oe(Q, A, ".json"), "SpriteJSON");
                  N[G] = s.j(le, T);
                  const ce = x.transformRequest(oe(Q, A, ".png"), "SpriteImage");
                  j[G] = J.getImage(ce, T);
                }
                return yield Promise.all([...Object.values(N), ...Object.values(j)]), (function(G, Q) {
                  return s._(this, void 0, void 0, (function* () {
                    const le = {};
                    for (const ce in G) {
                      le[ce] = {};
                      const de = L.getImageCanvasContext((yield Q[ce]).data), ge = (yield G[ce]).data;
                      for (const Se in ge) {
                        const { width: me, height: ke, x: Re, y: ye, sdf: Be, pixelRatio: Ke, stretchX: He, stretchY: Ye, content: Qe, textFitWidth: Pt, textFitHeight: Tt } = ge[Se];
                        le[ce][Se] = { data: null, pixelRatio: Ke, sdf: Be, stretchX: He, stretchY: Ye, content: Qe, textFitWidth: Pt, textFitHeight: Tt, spriteData: { width: me, height: ke, x: Re, y: ye, context: de } };
                      }
                    }
                    return le;
                  }));
                })(N, j);
              }));
            })(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(((_) => {
              if (this._spriteRequest = null, _) for (const x in _) {
                this._spritesImagesIds[x] = [];
                const k = this._spritesImagesIds[x] ? this._spritesImagesIds[x].filter(((T) => !(T in _))) : [];
                for (const T of k) this.imageManager.removeImage(T), this._changedImages[T] = true;
                for (const T in _[x]) {
                  const R = x === "default" ? T : `${x}:${T}`;
                  this._spritesImagesIds[x].push(R), R in this.imageManager.images ? this.imageManager.updateImage(R, _[x][T], false) : this.imageManager.addImage(R, _[x][T]), a && (this._changedImages[R] = true);
                }
              }
            })).catch(((_) => {
              this._spriteRequest = null, m = _, this.fire(new s.k(m));
            })).finally((() => {
              this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), a && (this._changed = true), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", { dataType: "style" })), c && c(m);
            }));
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = true;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", { dataType: "style" }));
          }
          _validateLayer(e) {
            const a = this.tileManagers[e.source];
            if (!a) return;
            const c = e.sourceLayer;
            if (!c) return;
            const m = a.getSource();
            (m.type === "geojson" || m.vectorLayerIds && m.vectorLayerIds.indexOf(c) === -1) && this.fire(new s.k(new Error(`Source layer "${c}" does not exist on source "${m.id}" as specified by style layer "${e.id}".`)));
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return false;
            for (const e in this.tileManagers) if (!this.tileManagers[e].loaded()) return false;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(e, a = false) {
            const c = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(a ? s.bO(c) : c);
            const m = [];
            for (const _ of e) if (c[_]) {
              const x = a ? s.bO(c[_]) : c[_];
              m.push(x);
            }
            return m;
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const a = Object.keys(this._layers);
            for (const c of a) {
              const m = this._layers[c];
              m.type !== "custom" && (e[c] = m.serialize());
            }
            return e;
          }
          hasTransitions() {
            var e, a, c;
            if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((a = this.sky) === null || a === void 0) && a.hasTransition() || !((c = this.projection) === null || c === void 0) && c.hasTransition()) return true;
            for (const m in this.tileManagers) if (this.tileManagers[m].hasTransition()) return true;
            for (const m in this._layers) if (this._layers[m].hasTransition()) return true;
            return false;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(e) {
            if (!this._loaded) return;
            const a = this._changed;
            if (a) {
              const m = Object.keys(this._updatedLayers), _ = Object.keys(this._removedLayers);
              (m.length || _.length) && this._updateWorkerLayers(m, _);
              for (const x in this._updatedSources) {
                const k = this._updatedSources[x];
                if (k === "reload") this._reloadSource(x);
                else {
                  if (k !== "clear") throw new Error(`Invalid action ${k}`);
                  this._clearSource(x);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const x in this._updatedPaintProps) this._layers[x].updateTransitions(e);
              this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates();
            }
            const c = {};
            for (const m in this.tileManagers) {
              const _ = this.tileManagers[m];
              c[m] = _.used, _.used = false;
            }
            for (const m of this._order) {
              const _ = this._layers[m];
              _.recalculate(e, this._availableImages), !_.isHidden(e.zoom) && _.source && (this.tileManagers[_.source].used = true);
            }
            for (const m in c) {
              const _ = this.tileManagers[m];
              !!c[m] != !!_.used && _.fire(new s.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: m }));
            }
            this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, a && this.fire(new s.l("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const a in this.tileManagers) this.tileManagers[a].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.tileManagers) this.tileManagers[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = false;
            }
          }
          _updateWorkerLayers(e, a) {
            this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e, false), removedIds: a });
          }
          _resetUpdates() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
          }
          setState(e, a = {}) {
            var c;
            this._checkLoaded();
            const m = this.serialize();
            if (e = a.transformStyle ? a.transformStyle(m, e) : e, ((c = a.validate) === null || c === void 0 || c) && gs(this, s.B(e))) return false;
            (e = s.bO(e)).layers = s.bL(e.layers);
            const _ = s.bP(m, e), x = this._getOperationsToPerform(_);
            if (x.unimplemented.length > 0) throw new Error(`Unimplemented: ${x.unimplemented.join(", ")}.`);
            if (x.operations.length === 0) return false;
            for (const k of x.operations) k();
            return this.stylesheet = e, this._serializedLayers = null, true;
          }
          _getOperationsToPerform(e) {
            const a = [], c = [];
            for (const m of e) switch (m.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                a.push((() => this.addLayer.apply(this, m.args)));
                break;
              case "removeLayer":
                a.push((() => this.removeLayer.apply(this, m.args)));
                break;
              case "setPaintProperty":
                a.push((() => this.setPaintProperty.apply(this, m.args)));
                break;
              case "setLayoutProperty":
                a.push((() => this.setLayoutProperty.apply(this, m.args)));
                break;
              case "setFilter":
                a.push((() => this.setFilter.apply(this, m.args)));
                break;
              case "addSource":
                a.push((() => this.addSource.apply(this, m.args)));
                break;
              case "removeSource":
                a.push((() => this.removeSource.apply(this, m.args)));
                break;
              case "setLayerZoomRange":
                a.push((() => this.setLayerZoomRange.apply(this, m.args)));
                break;
              case "setLight":
                a.push((() => this.setLight.apply(this, m.args)));
                break;
              case "setGeoJSONSourceData":
                a.push((() => this.setGeoJSONSourceData.apply(this, m.args)));
                break;
              case "setGlyphs":
                a.push((() => this.setGlyphs.apply(this, m.args)));
                break;
              case "setSprite":
                a.push((() => this.setSprite.apply(this, m.args)));
                break;
              case "setTerrain":
                a.push((() => this.map.setTerrain.apply(this, m.args)));
                break;
              case "setSky":
                a.push((() => this.setSky.apply(this, m.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, m.args);
                break;
              case "setGlobalState":
                a.push((() => this.setGlobalState.apply(this, m.args)));
                break;
              case "setTransition":
                a.push((() => {
                }));
                break;
              default:
                c.push(m.command);
            }
            return { operations: a, unimplemented: c };
          }
          addImage(e, a) {
            if (this.getImage(e)) return this.fire(new s.k(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, a), this._afterImageUpdated(e);
          }
          updateImage(e, a) {
            this.imageManager.updateImage(e, a);
          }
          getImage(e) {
            return this.imageManager.getImage(e);
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new s.k(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e);
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = true, this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(e, a, c = {}) {
            if (this._checkLoaded(), this.tileManagers[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
            if (!a.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(a).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(a.type) >= 0 && this._validate(s.B.source, `sources.${e}`, a, null, c)) return;
            this.map && this.map._collectResourceTiming && (a.collectResourceTiming = true);
            const m = this.tileManagers[e] = new Hr(e, a, this.dispatcher);
            m.style = this, m.setEventedParent(this, (() => ({ isSourceLoaded: m.loaded(), source: m.serialize(), sourceId: e }))), m.onAdd(this.map), this._changed = true;
          }
          removeSource(e) {
            if (this._checkLoaded(), this.tileManagers[e] === void 0) throw new Error("There is no source with this ID");
            for (const c in this._layers) if (this._layers[c].source === e) return this.fire(new s.k(new Error(`Source "${e}" cannot be removed while layer "${c}" is using it.`)));
            const a = this.tileManagers[e];
            delete this.tileManagers[e], delete this._updatedSources[e], a.fire(new s.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: e })), a.setEventedParent(null), a.onRemove(this.map), this._changed = true;
          }
          setGeoJSONSourceData(e, a) {
            if (this._checkLoaded(), this.tileManagers[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
            const c = this.tileManagers[e].getSource();
            if (c.type !== "geojson") throw new Error(`geojsonSource.type is ${c.type}, which is !== 'geojson`);
            c.setData(a), this._changed = true;
          }
          getSource(e) {
            return this.tileManagers[e] && this.tileManagers[e].getSource();
          }
          addLayer(e, a, c = {}) {
            this._checkLoaded();
            const m = e.id;
            if (this.getLayer(m)) return void this.fire(new s.k(new Error(`Layer "${m}" already exists on this map.`)));
            let _;
            if (e.type === "custom") {
              if (gs(this, s.bQ(e))) return;
              _ = s.bM(e, this._globalState);
            } else {
              if ("source" in e && typeof e.source == "object" && (this.addSource(m, e.source), e = s.bO(e), e = s.e(e, { source: m })), this._validate(s.B.layer, `layers.${m}`, e, { arrayIndex: -1 }, c)) return;
              _ = s.bM(e, this._globalState), this._validateLayer(_), _.setEventedParent(this, { layer: { id: m } });
            }
            const x = a ? this._order.indexOf(a) : this._order.length;
            if (a && x === -1) this.fire(new s.k(new Error(`Cannot add layer "${m}" before non-existing layer "${a}".`)));
            else {
              if (this._order.splice(x, 0, m), this._layerOrderChanged = true, this._layers[m] = _, this._removedLayers[m] && _.source && _.type !== "custom") {
                const k = this._removedLayers[m];
                delete this._removedLayers[m], k.type !== _.type ? this._updatedSources[_.source] = "clear" : (this._updatedSources[_.source] = "reload", this.tileManagers[_.source].pause());
              }
              this._updateLayer(_), _.onAdd && _.onAdd(this.map);
            }
          }
          moveLayer(e, a) {
            if (this._checkLoaded(), this._changed = true, !this._layers[e]) return void this.fire(new s.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
            if (e === a) return;
            const c = this._order.indexOf(e);
            this._order.splice(c, 1);
            const m = a ? this._order.indexOf(a) : this._order.length;
            a && m === -1 ? this.fire(new s.k(new Error(`Cannot move layer "${e}" before non-existing layer "${a}".`))) : (this._order.splice(m, 0, e), this._layerOrderChanged = true);
          }
          removeLayer(e) {
            this._checkLoaded();
            const a = this._layers[e];
            if (!a) return void this.fire(new s.k(new Error(`Cannot remove non-existing layer "${e}".`)));
            a.setEventedParent(null);
            const c = this._order.indexOf(e);
            this._order.splice(c, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e] = a, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], a.onRemove && a.onRemove(this.map);
          }
          getLayer(e) {
            return this._layers[e];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(e) {
            return e in this._layers;
          }
          setLayerZoomRange(e, a, c) {
            this._checkLoaded();
            const m = this.getLayer(e);
            m ? m.minzoom === a && m.maxzoom === c || (a != null && (m.minzoom = a), c != null && (m.maxzoom = c), this._updateLayer(m)) : this.fire(new s.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)));
          }
          setFilter(e, a, c = {}) {
            this._checkLoaded();
            const m = this.getLayer(e);
            if (m) {
              if (!s.bK(m.filter, a)) return a == null ? (m.setFilter(void 0), void this._updateLayer(m)) : void (this._validate(s.B.filter, `layers.${m.id}.filter`, a, null, c) || (m.setFilter(s.bO(a)), this._updateLayer(m)));
            } else this.fire(new s.k(new Error(`Cannot filter non-existing layer "${e}".`)));
          }
          getFilter(e) {
            return s.bO(this.getLayer(e).filter);
          }
          setLayoutProperty(e, a, c, m = {}) {
            this._checkLoaded();
            const _ = this.getLayer(e);
            _ ? s.bK(_.getLayoutProperty(a), c) || (_.setLayoutProperty(a, c, m), this._updateLayer(_)) : this.fire(new s.k(new Error(`Cannot style non-existing layer "${e}".`)));
          }
          getLayoutProperty(e, a) {
            const c = this.getLayer(e);
            if (c) return c.getLayoutProperty(a);
            this.fire(new s.k(new Error(`Cannot get style of non-existing layer "${e}".`)));
          }
          setPaintProperty(e, a, c, m = {}) {
            this._checkLoaded();
            const _ = this.getLayer(e);
            _ ? s.bK(_.getPaintProperty(a), c) || this._updatePaintProperty(_, a, c, m) : this.fire(new s.k(new Error(`Cannot style non-existing layer "${e}".`)));
          }
          _updatePaintProperty(e, a, c, m = {}) {
            e.setPaintProperty(a, c, m) && this._updateLayer(e), s.bN(e) && a === "raster-fade-duration" && this.tileManagers[e.source].setRasterFadeDuration(c), this._changed = true, this._updatedPaintProps[e.id] = true, this._serializedLayers = null;
          }
          getPaintProperty(e, a) {
            return this.getLayer(e).getPaintProperty(a);
          }
          setFeatureState(e, a) {
            this._checkLoaded();
            const c = e.source, m = e.sourceLayer, _ = this.tileManagers[c];
            if (_ === void 0) return void this.fire(new s.k(new Error(`The source '${c}' does not exist in the map's style.`)));
            const x = _.getSource().type;
            x === "geojson" && m ? this.fire(new s.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : x !== "vector" || m ? (e.id === void 0 && this.fire(new s.k(new Error("The feature id parameter must be provided."))), _.setFeatureState(m, e.id, a)) : this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(e, a) {
            this._checkLoaded();
            const c = e.source, m = this.tileManagers[c];
            if (m === void 0) return void this.fire(new s.k(new Error(`The source '${c}' does not exist in the map's style.`)));
            const _ = m.getSource().type, x = _ === "vector" ? e.sourceLayer : void 0;
            _ !== "vector" || x ? a && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new s.k(new Error("A feature id is required to remove its specific state property."))) : m.removeFeatureState(x, e.id, a) : this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(e) {
            this._checkLoaded();
            const a = e.source, c = e.sourceLayer, m = this.tileManagers[a];
            if (m !== void 0) return m.getSource().type !== "vector" || c ? (e.id === void 0 && this.fire(new s.k(new Error("The feature id parameter must be provided."))), m.getFeatureState(c, e.id)) : void this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new s.k(new Error(`The source '${a}' does not exist in the map's style.`)));
          }
          getTransition() {
            return s.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded) return;
            const e = s.bR(this.tileManagers, ((_) => _.serialize())), a = this._serializeByIds(this._order, true), c = this.map.getTerrain() || void 0, m = this.stylesheet;
            return s.bS({ version: m.version, name: m.name, metadata: m.metadata, light: m.light, sky: m.sky, center: m.center, zoom: m.zoom, bearing: m.bearing, pitch: m.pitch, sprite: m.sprite, glyphs: m.glyphs, transition: m.transition, projection: m.projection, sources: e, layers: a, terrain: c }, ((_) => _ !== void 0));
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = true, e.source && !this._updatedSources[e.source] && this.tileManagers[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.tileManagers[e.source].pause()), this._serializedLayers = null, this._changed = true;
          }
          _flattenAndSortRenderedFeatures(e) {
            const a = (x) => this._layers[x].type === "fill-extrusion", c = {}, m = [];
            for (let x = this._order.length - 1; x >= 0; x--) {
              const k = this._order[x];
              if (a(k)) {
                c[k] = x;
                for (const T of e) {
                  const R = T[k];
                  if (R) for (const A of R) m.push(A);
                }
              }
            }
            m.sort(((x, k) => k.intersectionZ - x.intersectionZ));
            const _ = [];
            for (let x = this._order.length - 1; x >= 0; x--) {
              const k = this._order[x];
              if (a(k)) for (let T = m.length - 1; T >= 0; T--) {
                const R = m[T].feature;
                if (c[R.layer.id] < x) break;
                _.push(R), m.pop();
              }
              else for (const T of e) {
                const R = T[k];
                if (R) for (const A of R) _.push(A.feature);
              }
            }
            return _;
          }
          queryRenderedFeatures(e, a, c) {
            a && a.filter && this._validate(s.B.filter, "queryRenderedFeatures.filter", a.filter, null, a);
            const m = {};
            if (a && a.layers) {
              if (!(Array.isArray(a.layers) || a.layers instanceof Set)) return this.fire(new s.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const R of a.layers) {
                const A = this._layers[R];
                if (!A) return this.fire(new s.k(new Error(`The layer '${R}' does not exist in the map's style and cannot be queried for features.`))), [];
                m[A.source] = true;
              }
            }
            const _ = [];
            a.availableImages = this._availableImages;
            const x = this._serializedAllLayers(), k = a.layers instanceof Set ? a.layers : Array.isArray(a.layers) ? new Set(a.layers) : null, T = Object.assign(Object.assign({}, a), { layers: k, globalState: this._globalState });
            for (const R in this.tileManagers) a.layers && !m[R] || _.push(or(this.tileManagers[R], this._layers, x, e, T, c, this.map.terrain ? (A, N, j) => this.map.terrain.getElevation(A, N, j) : void 0));
            return this.placement && _.push((function(R, A, N, j, G, Q, le) {
              const ce = {}, de = Q.queryRenderedSymbols(j), ge = [];
              for (const Se of Object.keys(de).map(Number)) ge.push(le[Se]);
              ge.sort(Tr);
              for (const Se of ge) {
                const me = Se.featureIndex.lookupSymbolFeatures(de[Se.bucketInstanceId], A, Se.bucketIndex, Se.sourceLayerIndex, { filterSpec: G.filter, globalState: G.globalState }, G.layers, G.availableImages, R);
                for (const ke in me) {
                  const Re = ce[ke] = ce[ke] || [], ye = me[ke];
                  ye.sort(((Be, Ke) => {
                    const He = Se.featureSortOrder;
                    if (He) {
                      const Ye = He.indexOf(Be.featureIndex);
                      return He.indexOf(Ke.featureIndex) - Ye;
                    }
                    return Ke.featureIndex - Be.featureIndex;
                  }));
                  for (const Be of ye) Re.push(Be);
                }
              }
              return (function(Se, me, ke) {
                for (const Re in Se) for (const ye of Se[Re]) Xt(ye, ke[me[Re].source]);
                return Se;
              })(ce, R, N);
            })(this._layers, x, this.tileManagers, e, T, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(_);
          }
          querySourceFeatures(e, a) {
            (a == null ? void 0 : a.filter) && this._validate(s.B.filter, "querySourceFeatures.filter", a.filter, null, a);
            const c = this.tileManagers[e];
            return c ? (function(m, _) {
              const x = m.getRenderableIds().map(((R) => m.getTileByID(R))), k = [], T = {};
              for (let R = 0; R < x.length; R++) {
                const A = x[R], N = A.tileID.canonical.key;
                T[N] || (T[N] = true, A.querySourceFeatures(k, _));
              }
              return k;
            })(c, a ? Object.assign(Object.assign({}, a), { globalState: this._globalState }) : { globalState: this._globalState }) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(e, a = {}) {
            this._checkLoaded();
            const c = this.light.getLight();
            let m = false;
            for (const x in e) if (!s.bK(e[x], c[x])) {
              m = true;
              break;
            }
            if (!m) return;
            const _ = { now: z(), transition: s.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(e, a), this.light.updateTransitions(_);
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection;
          }
          setProjection(e) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e.type) return;
              this.projection.destroy(), delete this.projection;
            }
            this.stylesheet.projection = e, this._setProjectionInternal(e.type);
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky;
          }
          setSky(e, a = {}) {
            this._checkLoaded();
            const c = this.getSky();
            let m = false;
            if (!e && !c) return;
            if (e && !c) m = true;
            else if (!e && c) m = true;
            else for (const x in e) if (!s.bK(e[x], c[x])) {
              m = true;
              break;
            }
            if (!m) return;
            const _ = { now: z(), transition: s.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.stylesheet.sky = e, this.sky.setSky(e, a), this.sky.updateTransitions(_);
          }
          _setProjectionInternal(e) {
            const a = (function(c, m) {
              const _ = { constrain: m };
              if (Array.isArray(c)) {
                const x = new Qs({ type: c });
                return { projection: x, transform: new ru(_), cameraHelper: new rl(x) };
              }
              switch (c) {
                case "mercator":
                  return { projection: new Qi(), transform: new So(_), cameraHelper: new Ea() };
                case "globe": {
                  const x = new Qs({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                  return { projection: x, transform: new ru(_), cameraHelper: new rl(x) };
                }
                case "vertical-perspective":
                  return { projection: new Kl(), transform: new tu(_), cameraHelper: new so() };
                default:
                  return s.w(`Unknown projection name: ${c}. Falling back to mercator projection.`), { projection: new Qi(), transform: new So(_), cameraHelper: new Ea() };
              }
            })(e, this.map.transformConstrain);
            this.projection = a.projection, this.map.migrateProjection(a.transform, a.cameraHelper);
            for (const c in this.tileManagers) this.tileManagers[c].reload();
          }
          _validate(e, a, c, m, _ = {}) {
            return (!_ || _.validate !== false) && gs(this, e.call(s.B, s.e({ key: a, style: this.serialize(), value: c, styleSpec: s.t }, m)));
          }
          _remove(e = true) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Y().off(sn, this._rtlPluginLoaded);
            for (const a in this._layers) this._layers[a].setEventedParent(null);
            for (const a in this.tileManagers) {
              const c = this.tileManagers[a];
              c.setEventedParent(null), c.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e);
          }
          _clearSource(e) {
            this.tileManagers[e].clearTiles();
          }
          _reloadSource(e) {
            this.tileManagers[e].resume(), this.tileManagers[e].reload();
          }
          _updateSources(e) {
            for (const a in this.tileManagers) this.tileManagers[a].update(e, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const e in this.tileManagers) this._reloadSource(e);
          }
          _updatePlacement(e, a, c, m, _ = false) {
            let x = false, k = false;
            const T = {};
            for (const R of this._order) {
              const A = this._layers[R];
              if (A.type !== "symbol") continue;
              if (!T[A.source]) {
                const j = this.tileManagers[A.source];
                T[A.source] = j.getRenderableIds(true).map(((G) => j.getTileByID(G))).sort(((G, Q) => Q.tileID.overscaledZ - G.tileID.overscaledZ || (G.tileID.isLessThan(Q.tileID) ? -1 : 1)));
              }
              const N = this.crossTileSymbolIndex.addLayer(A, T[A.source], e.center.lng);
              x = x || N;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((_ = _ || this._layerOrderChanged || c === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(z(), e.zoom)) && (this.pauseablePlacement = new cs(e, this.map.terrain, this._order, _, a, c, m, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, T), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(z()), k = true), x && this.pauseablePlacement.placement.setStale()), k || x) for (const R of this._order) {
              const A = this._layers[R];
              A.type === "symbol" && this.placement.updateLayerOpacities(A, T[A.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(z());
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.tileManagers) this.tileManagers[e].releaseSymbolFadeTiles();
          }
          getImages(e, a) {
            return s._(this, void 0, void 0, (function* () {
              const c = yield this.imageManager.getImages(a.icons);
              this._updateTilesForChangedImages();
              const m = this.tileManagers[a.source];
              return m && m.setDependencies(a.tileID.key, a.type, a.icons), c;
            }));
          }
          getGlyphs(e, a) {
            return s._(this, void 0, void 0, (function* () {
              const c = yield this.glyphManager.getGlyphs(a.stacks), m = this.tileManagers[a.source];
              return m && m.setDependencies(a.tileID.key, a.type, [""]), c;
            }));
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(e, a = {}) {
            this._checkLoaded(), e && this._validate(s.B.glyphs, "glyphs", e, null, a) || (this._glyphsDidChange = true, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e));
          }
          getDashes(e, a) {
            return s._(this, void 0, void 0, (function* () {
              const c = {};
              for (const [m, _] of Object.entries(a.dashes)) c[m] = this.lineAtlas.getDash(_.dasharray, _.round);
              return c;
            }));
          }
          addSprite(e, a, c = {}, m) {
            this._checkLoaded();
            const _ = [{ id: e, url: a }], x = [...fe(this.stylesheet.sprite), ..._];
            this._validate(s.B.sprite, "sprite", x, null, c) || (this.stylesheet.sprite = x, this._loadSprite(_, true, m));
          }
          removeSprite(e) {
            this._checkLoaded();
            const a = fe(this.stylesheet.sprite);
            if (a.find(((c) => c.id === e))) {
              if (this._spritesImagesIds[e]) for (const c of this._spritesImagesIds[e]) this.imageManager.removeImage(c), this._changedImages[c] = true;
              a.splice(a.findIndex(((c) => c.id === e)), 1), this.stylesheet.sprite = a.length > 0 ? a : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", { dataType: "style" }));
            } else this.fire(new s.k(new Error(`Sprite "${e}" doesn't exists on this map.`)));
          }
          getSprite() {
            return fe(this.stylesheet.sprite);
          }
          setSprite(e, a = {}, c) {
            this._checkLoaded(), e && this._validate(s.B.sprite, "sprite", e, null, a) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, true, c) : (this._unloadSprite(), c && c(null)));
          }
        }
        var Tc = s.aN([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class ko {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(e, a, c, m, _, x, k, T, R) {
            this.context = e;
            let A = this.boundPaintVertexBuffers.length !== m.length;
            for (let N = 0; !A && N < m.length; N++) this.boundPaintVertexBuffers[N] !== m[N] && (A = true);
            !this.vao || this.boundProgram !== a || this.boundLayoutVertexBuffer !== c || A || this.boundIndexBuffer !== _ || this.boundVertexOffset !== x || this.boundDynamicVertexBuffer !== k || this.boundDynamicVertexBuffer2 !== T || this.boundDynamicVertexBuffer3 !== R ? this.freshBind(a, c, m, _, x, k, T, R) : (e.bindVertexArray.set(this.vao), k && k.bind(), _ && _.dynamicDraw && _.bind(), T && T.bind(), R && R.bind());
          }
          freshBind(e, a, c, m, _, x, k, T) {
            const R = e.numAttributes, A = this.context, N = A.gl;
            this.vao && this.destroy(), this.vao = A.createVertexArray(), A.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = a, this.boundPaintVertexBuffers = c, this.boundIndexBuffer = m, this.boundVertexOffset = _, this.boundDynamicVertexBuffer = x, this.boundDynamicVertexBuffer2 = k, this.boundDynamicVertexBuffer3 = T, a.enableAttributes(N, e);
            for (const j of c) j.enableAttributes(N, e);
            x && x.enableAttributes(N, e), k && k.enableAttributes(N, e), T && T.enableAttributes(N, e), a.bind(), a.setVertexAttribPointers(N, e, _);
            for (const j of c) j.bind(), j.setVertexAttribPointers(N, e, _);
            x && (x.bind(), x.setVertexAttribPointers(N, e, _)), m && m.bind(), k && (k.bind(), k.setVertexAttribPointers(N, e, _)), T && (T.bind(), T.setVertexAttribPointers(N, e, _)), A.currentNumAttributes = R;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        const Vp = (v, e, a, c, m) => ({ u_texture: 0, u_ele_delta: v, u_fog_matrix: e, u_fog_color: a ? a.properties.get("fog-color") : s.bi.white, u_fog_ground_blend: a ? a.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: m ? 0 : a ? a.calculateFogBlendOpacity(c) : 0, u_horizon_color: a ? a.properties.get("horizon-color") : s.bi.white, u_horizon_fog_blend: a ? a.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: m ? 1 : 0 }), Ic = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
        function ca(v) {
          const e = [];
          for (let a = 0; a < v.length; a++) {
            if (v[a] === null) continue;
            const c = v[a].split(" ");
            e.push(c.pop());
          }
          return e;
        }
        class nl {
          constructor(e, a, c, m, _, x, k, T, R = []) {
            const A = e.gl;
            this.program = A.createProgram();
            const N = ca(a.staticAttributes), j = c ? c.getBinderAttributes() : [], G = N.concat(j), Q = fr.prelude.staticUniforms ? ca(fr.prelude.staticUniforms) : [], le = k.staticUniforms ? ca(k.staticUniforms) : [], ce = a.staticUniforms ? ca(a.staticUniforms) : [], de = c ? c.getBinderUniforms() : [], ge = Q.concat(le).concat(ce).concat(de), Se = [];
            for (const He of ge) Se.indexOf(He) < 0 && Se.push(He);
            const me = c ? c.defines() : [];
            Yn(A) && me.unshift("#version 300 es"), _ && me.push("#define OVERDRAW_INSPECTOR;"), x && me.push("#define TERRAIN3D;"), T && me.push(T), R && me.push(...R);
            let ke = me.concat(fr.prelude.fragmentSource, k.fragmentSource, a.fragmentSource).join(`
`), Re = me.concat(fr.prelude.vertexSource, k.vertexSource, a.vertexSource).join(`
`);
            Yn(A) || (ke = (function(He) {
              return He.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
            })(ke), Re = (function(He) {
              return He.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
            })(Re));
            const ye = A.createShader(A.FRAGMENT_SHADER);
            if (A.isContextLost()) return void (this.failedToCreate = true);
            if (A.shaderSource(ye, ke), A.compileShader(ye), !A.getShaderParameter(ye, A.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${A.getShaderInfoLog(ye)}`);
            A.attachShader(this.program, ye);
            const Be = A.createShader(A.VERTEX_SHADER);
            if (A.isContextLost()) return void (this.failedToCreate = true);
            if (A.shaderSource(Be, Re), A.compileShader(Be), !A.getShaderParameter(Be, A.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${A.getShaderInfoLog(Be)}`);
            A.attachShader(this.program, Be), this.attributes = {};
            const Ke = {};
            this.numAttributes = G.length;
            for (let He = 0; He < this.numAttributes; He++) G[He] && (A.bindAttribLocation(this.program, He, G[He]), this.attributes[G[He]] = He);
            if (A.linkProgram(this.program), !A.getProgramParameter(this.program, A.LINK_STATUS)) throw new Error(`Program failed to link: ${A.getProgramInfoLog(this.program)}`);
            A.deleteShader(Be), A.deleteShader(ye);
            for (let He = 0; He < Se.length; He++) {
              const Ye = Se[He];
              if (Ye && !Ke[Ye]) {
                const Qe = A.getUniformLocation(this.program, Ye);
                Qe && (Ke[Ye] = Qe);
              }
            }
            this.fixedUniforms = m(e, Ke), this.terrainUniforms = ((He, Ye) => ({ u_depth: new s.bT(He, Ye.u_depth), u_terrain: new s.bT(He, Ye.u_terrain), u_terrain_dim: new s.bj(He, Ye.u_terrain_dim), u_terrain_matrix: new s.bV(He, Ye.u_terrain_matrix), u_terrain_unpack: new s.bW(He, Ye.u_terrain_unpack), u_terrain_exaggeration: new s.bj(He, Ye.u_terrain_exaggeration) }))(e, Ke), this.projectionUniforms = ((He, Ye) => ({ u_projection_matrix: new s.bV(He, Ye.u_projection_matrix), u_projection_tile_mercator_coords: new s.bW(He, Ye.u_projection_tile_mercator_coords), u_projection_clipping_plane: new s.bW(He, Ye.u_projection_clipping_plane), u_projection_transition: new s.bj(He, Ye.u_projection_transition), u_projection_fallback_matrix: new s.bV(He, Ye.u_projection_fallback_matrix) }))(e, Ke), this.binderUniforms = c ? c.getUniforms(e, Ke) : [];
          }
          draw(e, a, c, m, _, x, k, T, R, A, N, j, G, Q, le, ce, de, ge, Se) {
            const me = e.gl;
            if (this.failedToCreate) return;
            if (e.program.set(this.program), e.setDepthMode(c), e.setStencilMode(m), e.setColorMode(_), e.setCullFace(x), T) {
              e.activeTexture.set(me.TEXTURE2), me.bindTexture(me.TEXTURE_2D, T.depthTexture), e.activeTexture.set(me.TEXTURE3), me.bindTexture(me.TEXTURE_2D, T.texture);
              for (const Re in this.terrainUniforms) this.terrainUniforms[Re].set(T[Re]);
            }
            if (R) for (const Re in R) this.projectionUniforms[Ic[Re]].set(R[Re]);
            if (k) for (const Re in this.fixedUniforms) this.fixedUniforms[Re].set(k[Re]);
            ce && ce.setUniforms(e, this.binderUniforms, Q, { zoom: le });
            let ke = 0;
            switch (a) {
              case me.LINES:
                ke = 2;
                break;
              case me.TRIANGLES:
                ke = 3;
                break;
              case me.LINE_STRIP:
                ke = 1;
            }
            for (const Re of G.get()) {
              const ye = Re.vaos || (Re.vaos = {});
              (ye[A] || (ye[A] = new ko())).bind(e, this, N, ce ? ce.getPaintVertexBuffers() : [], j, Re.vertexOffset, de, ge, Se), me.drawElements(a, Re.primitiveLength * ke, me.UNSIGNED_SHORT, Re.primitiveOffset * ke * 2);
            }
          }
        }
        function Ch(v, e, a) {
          const c = 1 / s.aG(a, 1, e.transform.tileZoom), m = Math.pow(2, a.tileID.overscaledZ), _ = a.tileSize * Math.pow(2, e.transform.tileZoom) / m, x = _ * (a.tileID.canonical.x + a.tileID.wrap * m), k = _ * a.tileID.canonical.y;
          return { u_image: 0, u_texsize: a.imageAtlasTexture.size, u_scale: [c, v.fromScale, v.toScale], u_fade: v.t, u_pixel_coord_upper: [x >> 16, k >> 16], u_pixel_coord_lower: [65535 & x, 65535 & k] };
        }
        const ol = (v, e, a, c) => {
          const m = v.style.light, _ = m.properties.get("position"), x = [_.x, _.y, _.z], k = s.bZ();
          m.properties.get("anchor") === "viewport" && s.b_(k, v.transform.bearingInRadians), s.b$(x, x, k);
          const T = v.transform.transformLightDirection(x), R = m.properties.get("color");
          return { u_lightpos: x, u_lightpos_globe: T, u_lightintensity: m.properties.get("intensity"), u_lightcolor: [R.r, R.g, R.b], u_vertical_gradient: +e, u_opacity: a, u_fill_translate: c };
        }, Up = (v, e, a, c, m, _, x) => s.e(ol(v, e, a, c), Ch(_, v, x), { u_height_factor: -Math.pow(2, m.overscaledZ) / x.tileSize / 8 }), Aa = (v, e, a, c) => s.e(Ch(e, v, a), { u_fill_translate: c }), Gp = (v, e) => ({ u_world: v, u_fill_translate: e }), Sh = (v, e, a, c, m) => s.e(Aa(v, e, a, m), { u_world: c }), qp = (v, e, a, c, m) => {
          const _ = v.transform;
          let x, k, T = 0;
          if (a.paint.get("circle-pitch-alignment") === "map") {
            const R = s.aG(e, 1, _.zoom);
            x = true, k = [R, R], T = R / (s.a3 * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * m;
          } else x = false, k = _.pixelsToGLUnits;
          return { u_camera_to_center_distance: _.cameraToCenterDistance, u_scale_with_map: +(a.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +x, u_device_pixel_ratio: v.pixelRatio, u_extrude_scale: k, u_globe_extrude_scale: T, u_translate: c };
        }, kh = (v) => ({ u_pixel_extrude_scale: [1 / v.width, 1 / v.height] }), Mc = (v) => ({ u_viewport_size: [v.width, v.height] }), Ec = (v, e = 1) => ({ u_color: v, u_overlay: 0, u_overlay_scale: e }), Rc = (v, e, a, c) => {
          const m = s.aG(v, 1, e) / (s.a3 * Math.pow(2, v.tileID.overscaledZ)) * 2 * Math.PI * c;
          return { u_extrude_scale: s.aG(v, 1, e), u_intensity: a, u_globe_extrude_scale: m };
        }, Ac = (v, e, a, c) => {
          const m = s.M();
          s.c0(m, 0, v.width, v.height, 0, 0, 1);
          const _ = v.context.gl;
          return { u_matrix: m, u_world: [_.drawingBufferWidth, _.drawingBufferHeight], u_image: a, u_color_ramp: c, u_opacity: e.paint.get("heatmap-opacity") };
        }, Ph = (v, e, a) => {
          const c = a.paint.get("hillshade-accent-color");
          let m;
          switch (a.paint.get("hillshade-method")) {
            case "basic":
              m = 4;
              break;
            case "combined":
              m = 1;
              break;
            case "igor":
              m = 2;
              break;
            case "multidirectional":
              m = 3;
              break;
            default:
              m = 0;
          }
          const _ = a.getIlluminationProperties();
          for (let x = 0; x < _.directionRadians.length; x++) a.paint.get("hillshade-illumination-anchor") === "viewport" && (_.directionRadians[x] += v.transform.bearingInRadians);
          return { u_image: 0, u_latrange: Th(0, e.tileID), u_exaggeration: a.paint.get("hillshade-exaggeration"), u_altitudes: _.altitudeRadians, u_azimuths: _.directionRadians, u_accent: c, u_method: m, u_highlights: _.highlightColor, u_shadows: _.shadowColor };
        }, Da = (v, e) => {
          const a = e.stride, c = s.M();
          return s.c0(c, 0, s.a3, -s.a3, 0, 0, 1), s.N(c, c, [0, -s.a3, 0]), { u_matrix: c, u_image: 1, u_dimension: [a, a], u_zoom: v.overscaledZ, u_unpack: e.getUnpackVector() };
        };
        function Th(v, e) {
          const a = Math.pow(2, e.canonical.z), c = e.canonical.y;
          return [new s.a5(0, c / a).toLngLat().lat, new s.a5(0, (c + 1) / a).toLngLat().lat];
        }
        const Ih = (v, e, a = 0) => ({ u_image: 0, u_unpack: e.getUnpackVector(), u_dimension: [e.stride, e.stride], u_elevation_stops: 1, u_color_stops: 4, u_color_ramp_size: a, u_opacity: v.paint.get("color-relief-opacity") }), da = (v, e, a, c) => {
          const m = v.transform;
          return { u_translation: Dc(v, e, a), u_ratio: c / s.aG(e, 1, m.zoom), u_device_pixel_ratio: v.pixelRatio, u_units_to_pixels: [1 / m.pixelsToGLUnits[0], 1 / m.pixelsToGLUnits[1]] };
        }, Wp = (v, e, a, c, m) => s.e(da(v, e, a, c), { u_image: 0, u_image_height: m }), nu = (v, e, a, c, m) => {
          const _ = v.transform, x = ou(e, _);
          return { u_translation: Dc(v, e, a), u_texsize: e.imageAtlasTexture.size, u_ratio: c / s.aG(e, 1, _.zoom), u_device_pixel_ratio: v.pixelRatio, u_image: 0, u_scale: [x, m.fromScale, m.toScale], u_fade: m.t, u_units_to_pixels: [1 / _.pixelsToGLUnits[0], 1 / _.pixelsToGLUnits[1]] };
        }, Zp = (v, e, a, c, m) => {
          const _ = ou(e, v.transform);
          return s.e(da(v, e, a, c), { u_tileratio: _, u_crossfade_from: m.fromScale, u_crossfade_to: m.toScale, u_image: 0, u_mix: m.t, u_lineatlas_width: v.lineAtlas.width, u_lineatlas_height: v.lineAtlas.height });
        }, Hp = (v, e, a, c, m, _) => {
          const x = ou(e, v.transform);
          return s.e(da(v, e, a, c), { u_image: 0, u_image_height: _, u_tileratio: x, u_crossfade_from: m.fromScale, u_crossfade_to: m.toScale, u_image_dash: 1, u_mix: m.t, u_lineatlas_width: v.lineAtlas.width, u_lineatlas_height: v.lineAtlas.height });
        };
        function ou(v, e) {
          return 1 / s.aG(v, 1, e.tileZoom);
        }
        function Dc(v, e, a) {
          return s.aH(v.transform, e, a.paint.get("line-translate"), a.paint.get("line-translate-anchor"));
        }
        const Mh = (v, e, a, c, m) => {
          return { u_tl_parent: v, u_scale_parent: e, u_buffer_scale: 1, u_fade_t: a.mix, u_opacity: a.opacity * c.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: c.paint.get("raster-brightness-min"), u_brightness_high: c.paint.get("raster-brightness-max"), u_saturation_factor: (x = c.paint.get("raster-saturation"), x > 0 ? 1 - 1 / (1.001 - x) : -x), u_contrast_factor: (_ = c.paint.get("raster-contrast"), _ > 0 ? 1 / (1 - _) : 1 + _), u_spin_weights: zc(c.paint.get("raster-hue-rotate")), u_coords_top: [m[0].x, m[0].y, m[1].x, m[1].y], u_coords_bottom: [m[3].x, m[3].y, m[2].x, m[2].y] };
          var _, x;
        };
        function zc(v) {
          v *= Math.PI / 180;
          const e = Math.sin(v), a = Math.cos(v);
          return [(2 * a + 1) / 3, (-Math.sqrt(3) * e - a + 1) / 3, (Math.sqrt(3) * e - a + 1) / 3];
        }
        const Fc = (v, e, a, c, m, _, x, k, T, R, A, N, j) => {
          const G = x.transform;
          return { u_is_size_zoom_constant: +(v === "constant" || v === "source"), u_is_size_feature_constant: +(v === "constant" || v === "camera"), u_size_t: e ? e.uSizeT : 0, u_size: e ? e.uSize : 0, u_camera_to_center_distance: G.cameraToCenterDistance, u_pitch: G.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +a, u_aspect_ratio: G.width / G.height, u_fade_change: x.options.fadeDuration ? x.symbolFadeChange : 1, u_label_plane_matrix: k, u_coord_matrix: T, u_is_text: +A, u_pitch_with_map: +c, u_is_along_line: m, u_is_variable_anchor: _, u_texsize: N, u_texture: 0, u_translation: R, u_pitched_scale: j };
        }, al = (v, e, a, c, m, _, x, k, T, R, A, N, j, G) => {
          const Q = x.transform;
          return s.e(Fc(v, e, a, c, m, _, x, k, T, R, A, N, G), { u_gamma_scale: c ? Math.cos(Q.pitch * Math.PI / 180) * Q.cameraToCenterDistance : 1, u_device_pixel_ratio: x.pixelRatio, u_is_halo: 1 });
        }, Bo = (v, e, a, c, m, _, x, k, T, R, A, N, j) => s.e(al(v, e, a, c, m, _, x, k, T, R, true, A, 0, j), { u_texsize_icon: N, u_texture_icon: 1 }), Lc = (v, e) => ({ u_opacity: v, u_color: e }), Bc = (v, e, a, c, m) => s.e((function(_, x, k, T) {
          const R = k.imageManager.getPattern(_.from.toString()), A = k.imageManager.getPattern(_.to.toString()), { width: N, height: j } = k.imageManager.getPixelSize(), G = Math.pow(2, T.tileID.overscaledZ), Q = T.tileSize * Math.pow(2, k.transform.tileZoom) / G, le = Q * (T.tileID.canonical.x + T.tileID.wrap * G), ce = Q * T.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: R.tl, u_pattern_br_a: R.br, u_pattern_tl_b: A.tl, u_pattern_br_b: A.br, u_texsize: [N, j], u_mix: x.t, u_pattern_size_a: R.displaySize, u_pattern_size_b: A.displaySize, u_scale_a: x.fromScale, u_scale_b: x.toScale, u_tile_units_to_pixels: 1 / s.aG(T, 1, k.transform.tileZoom), u_pixel_coord_upper: [le >> 16, ce >> 16], u_pixel_coord_lower: [65535 & le, 65535 & ce] };
        })(a, m, e, c), { u_opacity: v }), au = (v, e) => {
        }, Eh = { fillExtrusion: (v, e) => ({ u_lightpos: new s.bX(v, e.u_lightpos), u_lightpos_globe: new s.bX(v, e.u_lightpos_globe), u_lightintensity: new s.bj(v, e.u_lightintensity), u_lightcolor: new s.bX(v, e.u_lightcolor), u_vertical_gradient: new s.bj(v, e.u_vertical_gradient), u_opacity: new s.bj(v, e.u_opacity), u_fill_translate: new s.bY(v, e.u_fill_translate) }), fillExtrusionPattern: (v, e) => ({ u_lightpos: new s.bX(v, e.u_lightpos), u_lightpos_globe: new s.bX(v, e.u_lightpos_globe), u_lightintensity: new s.bj(v, e.u_lightintensity), u_lightcolor: new s.bX(v, e.u_lightcolor), u_vertical_gradient: new s.bj(v, e.u_vertical_gradient), u_height_factor: new s.bj(v, e.u_height_factor), u_opacity: new s.bj(v, e.u_opacity), u_fill_translate: new s.bY(v, e.u_fill_translate), u_image: new s.bT(v, e.u_image), u_texsize: new s.bY(v, e.u_texsize), u_pixel_coord_upper: new s.bY(v, e.u_pixel_coord_upper), u_pixel_coord_lower: new s.bY(v, e.u_pixel_coord_lower), u_scale: new s.bX(v, e.u_scale), u_fade: new s.bj(v, e.u_fade) }), fill: (v, e) => ({ u_fill_translate: new s.bY(v, e.u_fill_translate) }), fillPattern: (v, e) => ({ u_image: new s.bT(v, e.u_image), u_texsize: new s.bY(v, e.u_texsize), u_pixel_coord_upper: new s.bY(v, e.u_pixel_coord_upper), u_pixel_coord_lower: new s.bY(v, e.u_pixel_coord_lower), u_scale: new s.bX(v, e.u_scale), u_fade: new s.bj(v, e.u_fade), u_fill_translate: new s.bY(v, e.u_fill_translate) }), fillOutline: (v, e) => ({ u_world: new s.bY(v, e.u_world), u_fill_translate: new s.bY(v, e.u_fill_translate) }), fillOutlinePattern: (v, e) => ({ u_world: new s.bY(v, e.u_world), u_image: new s.bT(v, e.u_image), u_texsize: new s.bY(v, e.u_texsize), u_pixel_coord_upper: new s.bY(v, e.u_pixel_coord_upper), u_pixel_coord_lower: new s.bY(v, e.u_pixel_coord_lower), u_scale: new s.bX(v, e.u_scale), u_fade: new s.bj(v, e.u_fade), u_fill_translate: new s.bY(v, e.u_fill_translate) }), circle: (v, e) => ({ u_camera_to_center_distance: new s.bj(v, e.u_camera_to_center_distance), u_scale_with_map: new s.bT(v, e.u_scale_with_map), u_pitch_with_map: new s.bT(v, e.u_pitch_with_map), u_extrude_scale: new s.bY(v, e.u_extrude_scale), u_device_pixel_ratio: new s.bj(v, e.u_device_pixel_ratio), u_globe_extrude_scale: new s.bj(v, e.u_globe_extrude_scale), u_translate: new s.bY(v, e.u_translate) }), collisionBox: (v, e) => ({ u_pixel_extrude_scale: new s.bY(v, e.u_pixel_extrude_scale) }), collisionCircle: (v, e) => ({ u_viewport_size: new s.bY(v, e.u_viewport_size) }), debug: (v, e) => ({ u_color: new s.bU(v, e.u_color), u_overlay: new s.bT(v, e.u_overlay), u_overlay_scale: new s.bj(v, e.u_overlay_scale) }), depth: au, clippingMask: au, heatmap: (v, e) => ({ u_extrude_scale: new s.bj(v, e.u_extrude_scale), u_intensity: new s.bj(v, e.u_intensity), u_globe_extrude_scale: new s.bj(v, e.u_globe_extrude_scale) }), heatmapTexture: (v, e) => ({ u_matrix: new s.bV(v, e.u_matrix), u_world: new s.bY(v, e.u_world), u_image: new s.bT(v, e.u_image), u_color_ramp: new s.bT(v, e.u_color_ramp), u_opacity: new s.bj(v, e.u_opacity) }), hillshade: (v, e) => ({ u_image: new s.bT(v, e.u_image), u_latrange: new s.bY(v, e.u_latrange), u_exaggeration: new s.bj(v, e.u_exaggeration), u_altitudes: new s.c2(v, e.u_altitudes), u_azimuths: new s.c2(v, e.u_azimuths), u_accent: new s.bU(v, e.u_accent), u_method: new s.bT(v, e.u_method), u_shadows: new s.c1(v, e.u_shadows), u_highlights: new s.c1(v, e.u_highlights) }), hillshadePrepare: (v, e) => ({ u_matrix: new s.bV(v, e.u_matrix), u_image: new s.bT(v, e.u_image), u_dimension: new s.bY(v, e.u_dimension), u_zoom: new s.bj(v, e.u_zoom), u_unpack: new s.bW(v, e.u_unpack) }), colorRelief: (v, e) => ({ u_image: new s.bT(v, e.u_image), u_unpack: new s.bW(v, e.u_unpack), u_dimension: new s.bY(v, e.u_dimension), u_elevation_stops: new s.bT(v, e.u_elevation_stops), u_color_stops: new s.bT(v, e.u_color_stops), u_color_ramp_size: new s.bT(v, e.u_color_ramp_size), u_opacity: new s.bj(v, e.u_opacity) }), line: (v, e) => ({ u_translation: new s.bY(v, e.u_translation), u_ratio: new s.bj(v, e.u_ratio), u_device_pixel_ratio: new s.bj(v, e.u_device_pixel_ratio), u_units_to_pixels: new s.bY(v, e.u_units_to_pixels) }), lineGradient: (v, e) => ({ u_translation: new s.bY(v, e.u_translation), u_ratio: new s.bj(v, e.u_ratio), u_device_pixel_ratio: new s.bj(v, e.u_device_pixel_ratio), u_units_to_pixels: new s.bY(v, e.u_units_to_pixels), u_image: new s.bT(v, e.u_image), u_image_height: new s.bj(v, e.u_image_height) }), linePattern: (v, e) => ({ u_translation: new s.bY(v, e.u_translation), u_texsize: new s.bY(v, e.u_texsize), u_ratio: new s.bj(v, e.u_ratio), u_device_pixel_ratio: new s.bj(v, e.u_device_pixel_ratio), u_image: new s.bT(v, e.u_image), u_units_to_pixels: new s.bY(v, e.u_units_to_pixels), u_scale: new s.bX(v, e.u_scale), u_fade: new s.bj(v, e.u_fade) }), lineSDF: (v, e) => ({ u_translation: new s.bY(v, e.u_translation), u_ratio: new s.bj(v, e.u_ratio), u_device_pixel_ratio: new s.bj(v, e.u_device_pixel_ratio), u_units_to_pixels: new s.bY(v, e.u_units_to_pixels), u_image: new s.bT(v, e.u_image), u_mix: new s.bj(v, e.u_mix), u_tileratio: new s.bj(v, e.u_tileratio), u_crossfade_from: new s.bj(v, e.u_crossfade_from), u_crossfade_to: new s.bj(v, e.u_crossfade_to), u_lineatlas_width: new s.bj(v, e.u_lineatlas_width), u_lineatlas_height: new s.bj(v, e.u_lineatlas_height) }), lineGradientSDF: (v, e) => ({ u_translation: new s.bY(v, e.u_translation), u_ratio: new s.bj(v, e.u_ratio), u_device_pixel_ratio: new s.bj(v, e.u_device_pixel_ratio), u_units_to_pixels: new s.bY(v, e.u_units_to_pixels), u_image: new s.bT(v, e.u_image), u_image_height: new s.bj(v, e.u_image_height), u_tileratio: new s.bj(v, e.u_tileratio), u_crossfade_from: new s.bj(v, e.u_crossfade_from), u_crossfade_to: new s.bj(v, e.u_crossfade_to), u_image_dash: new s.bT(v, e.u_image_dash), u_mix: new s.bj(v, e.u_mix), u_lineatlas_width: new s.bj(v, e.u_lineatlas_width), u_lineatlas_height: new s.bj(v, e.u_lineatlas_height) }), raster: (v, e) => ({ u_tl_parent: new s.bY(v, e.u_tl_parent), u_scale_parent: new s.bj(v, e.u_scale_parent), u_buffer_scale: new s.bj(v, e.u_buffer_scale), u_fade_t: new s.bj(v, e.u_fade_t), u_opacity: new s.bj(v, e.u_opacity), u_image0: new s.bT(v, e.u_image0), u_image1: new s.bT(v, e.u_image1), u_brightness_low: new s.bj(v, e.u_brightness_low), u_brightness_high: new s.bj(v, e.u_brightness_high), u_saturation_factor: new s.bj(v, e.u_saturation_factor), u_contrast_factor: new s.bj(v, e.u_contrast_factor), u_spin_weights: new s.bX(v, e.u_spin_weights), u_coords_top: new s.bW(v, e.u_coords_top), u_coords_bottom: new s.bW(v, e.u_coords_bottom) }), symbolIcon: (v, e) => ({ u_is_size_zoom_constant: new s.bT(v, e.u_is_size_zoom_constant), u_is_size_feature_constant: new s.bT(v, e.u_is_size_feature_constant), u_size_t: new s.bj(v, e.u_size_t), u_size: new s.bj(v, e.u_size), u_camera_to_center_distance: new s.bj(v, e.u_camera_to_center_distance), u_pitch: new s.bj(v, e.u_pitch), u_rotate_symbol: new s.bT(v, e.u_rotate_symbol), u_aspect_ratio: new s.bj(v, e.u_aspect_ratio), u_fade_change: new s.bj(v, e.u_fade_change), u_label_plane_matrix: new s.bV(v, e.u_label_plane_matrix), u_coord_matrix: new s.bV(v, e.u_coord_matrix), u_is_text: new s.bT(v, e.u_is_text), u_pitch_with_map: new s.bT(v, e.u_pitch_with_map), u_is_along_line: new s.bT(v, e.u_is_along_line), u_is_variable_anchor: new s.bT(v, e.u_is_variable_anchor), u_texsize: new s.bY(v, e.u_texsize), u_texture: new s.bT(v, e.u_texture), u_translation: new s.bY(v, e.u_translation), u_pitched_scale: new s.bj(v, e.u_pitched_scale) }), symbolSDF: (v, e) => ({ u_is_size_zoom_constant: new s.bT(v, e.u_is_size_zoom_constant), u_is_size_feature_constant: new s.bT(v, e.u_is_size_feature_constant), u_size_t: new s.bj(v, e.u_size_t), u_size: new s.bj(v, e.u_size), u_camera_to_center_distance: new s.bj(v, e.u_camera_to_center_distance), u_pitch: new s.bj(v, e.u_pitch), u_rotate_symbol: new s.bT(v, e.u_rotate_symbol), u_aspect_ratio: new s.bj(v, e.u_aspect_ratio), u_fade_change: new s.bj(v, e.u_fade_change), u_label_plane_matrix: new s.bV(v, e.u_label_plane_matrix), u_coord_matrix: new s.bV(v, e.u_coord_matrix), u_is_text: new s.bT(v, e.u_is_text), u_pitch_with_map: new s.bT(v, e.u_pitch_with_map), u_is_along_line: new s.bT(v, e.u_is_along_line), u_is_variable_anchor: new s.bT(v, e.u_is_variable_anchor), u_texsize: new s.bY(v, e.u_texsize), u_texture: new s.bT(v, e.u_texture), u_gamma_scale: new s.bj(v, e.u_gamma_scale), u_device_pixel_ratio: new s.bj(v, e.u_device_pixel_ratio), u_is_halo: new s.bT(v, e.u_is_halo), u_translation: new s.bY(v, e.u_translation), u_pitched_scale: new s.bj(v, e.u_pitched_scale) }), symbolTextAndIcon: (v, e) => ({ u_is_size_zoom_constant: new s.bT(v, e.u_is_size_zoom_constant), u_is_size_feature_constant: new s.bT(v, e.u_is_size_feature_constant), u_size_t: new s.bj(v, e.u_size_t), u_size: new s.bj(v, e.u_size), u_camera_to_center_distance: new s.bj(v, e.u_camera_to_center_distance), u_pitch: new s.bj(v, e.u_pitch), u_rotate_symbol: new s.bT(v, e.u_rotate_symbol), u_aspect_ratio: new s.bj(v, e.u_aspect_ratio), u_fade_change: new s.bj(v, e.u_fade_change), u_label_plane_matrix: new s.bV(v, e.u_label_plane_matrix), u_coord_matrix: new s.bV(v, e.u_coord_matrix), u_is_text: new s.bT(v, e.u_is_text), u_pitch_with_map: new s.bT(v, e.u_pitch_with_map), u_is_along_line: new s.bT(v, e.u_is_along_line), u_is_variable_anchor: new s.bT(v, e.u_is_variable_anchor), u_texsize: new s.bY(v, e.u_texsize), u_texsize_icon: new s.bY(v, e.u_texsize_icon), u_texture: new s.bT(v, e.u_texture), u_texture_icon: new s.bT(v, e.u_texture_icon), u_gamma_scale: new s.bj(v, e.u_gamma_scale), u_device_pixel_ratio: new s.bj(v, e.u_device_pixel_ratio), u_is_halo: new s.bT(v, e.u_is_halo), u_translation: new s.bY(v, e.u_translation), u_pitched_scale: new s.bj(v, e.u_pitched_scale) }), background: (v, e) => ({ u_opacity: new s.bj(v, e.u_opacity), u_color: new s.bU(v, e.u_color) }), backgroundPattern: (v, e) => ({ u_opacity: new s.bj(v, e.u_opacity), u_image: new s.bT(v, e.u_image), u_pattern_tl_a: new s.bY(v, e.u_pattern_tl_a), u_pattern_br_a: new s.bY(v, e.u_pattern_br_a), u_pattern_tl_b: new s.bY(v, e.u_pattern_tl_b), u_pattern_br_b: new s.bY(v, e.u_pattern_br_b), u_texsize: new s.bY(v, e.u_texsize), u_mix: new s.bj(v, e.u_mix), u_pattern_size_a: new s.bY(v, e.u_pattern_size_a), u_pattern_size_b: new s.bY(v, e.u_pattern_size_b), u_scale_a: new s.bj(v, e.u_scale_a), u_scale_b: new s.bj(v, e.u_scale_b), u_pixel_coord_upper: new s.bY(v, e.u_pixel_coord_upper), u_pixel_coord_lower: new s.bY(v, e.u_pixel_coord_lower), u_tile_units_to_pixels: new s.bj(v, e.u_tile_units_to_pixels) }), terrain: (v, e) => ({ u_texture: new s.bT(v, e.u_texture), u_ele_delta: new s.bj(v, e.u_ele_delta), u_fog_matrix: new s.bV(v, e.u_fog_matrix), u_fog_color: new s.bU(v, e.u_fog_color), u_fog_ground_blend: new s.bj(v, e.u_fog_ground_blend), u_fog_ground_blend_opacity: new s.bj(v, e.u_fog_ground_blend_opacity), u_horizon_color: new s.bU(v, e.u_horizon_color), u_horizon_fog_blend: new s.bj(v, e.u_horizon_fog_blend), u_is_globe_mode: new s.bj(v, e.u_is_globe_mode) }), terrainDepth: (v, e) => ({ u_ele_delta: new s.bj(v, e.u_ele_delta) }), terrainCoords: (v, e) => ({ u_texture: new s.bT(v, e.u_texture), u_terrain_coords_id: new s.bj(v, e.u_terrain_coords_id), u_ele_delta: new s.bj(v, e.u_ele_delta) }), projectionErrorMeasurement: (v, e) => ({ u_input: new s.bj(v, e.u_input), u_output_expected: new s.bj(v, e.u_output_expected) }), atmosphere: (v, e) => ({ u_sun_pos: new s.bX(v, e.u_sun_pos), u_atmosphere_blend: new s.bj(v, e.u_atmosphere_blend), u_globe_position: new s.bX(v, e.u_globe_position), u_globe_radius: new s.bj(v, e.u_globe_radius), u_inv_proj_matrix: new s.bV(v, e.u_inv_proj_matrix) }), sky: (v, e) => ({ u_sky_color: new s.bU(v, e.u_sky_color), u_horizon_color: new s.bU(v, e.u_horizon_color), u_horizon: new s.bY(v, e.u_horizon), u_horizon_normal: new s.bY(v, e.u_horizon_normal), u_sky_horizon_blend: new s.bj(v, e.u_sky_horizon_blend), u_sky_blend: new s.bj(v, e.u_sky_blend) }) };
        class Oc {
          constructor(e, a, c) {
            this.context = e;
            const m = e.gl;
            this.buffer = m.createBuffer(), this.dynamicDraw = !!c, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), m.bufferData(m.ELEMENT_ARRAY_BUFFER, a.arrayBuffer, this.dynamicDraw ? m.DYNAMIC_DRAW : m.STATIC_DRAW), this.dynamicDraw || delete a.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(e) {
            const a = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), a.bufferSubData(a.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const za = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class $c {
          constructor(e, a, c, m) {
            this.length = a.length, this.attributes = c, this.itemSize = a.bytesPerElement, this.dynamicDraw = m, this.context = e;
            const _ = e.gl;
            this.buffer = _.createBuffer(), e.bindVertexBuffer.set(this.buffer), _.bufferData(_.ARRAY_BUFFER, a.arrayBuffer, this.dynamicDraw ? _.DYNAMIC_DRAW : _.STATIC_DRAW), this.dynamicDraw || delete a.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
            const a = this.context.gl;
            this.bind(), a.bufferSubData(a.ARRAY_BUFFER, 0, e.arrayBuffer);
          }
          enableAttributes(e, a) {
            for (let c = 0; c < this.attributes.length; c++) {
              const m = a.attributes[this.attributes[c].name];
              m !== void 0 && e.enableVertexAttribArray(m);
            }
          }
          setVertexAttribPointers(e, a, c) {
            for (let m = 0; m < this.attributes.length; m++) {
              const _ = this.attributes[m], x = a.attributes[_.name];
              x !== void 0 && e.vertexAttribPointer(x, _.components, e[za[_.type]], false, this.itemSize, _.offset + this.itemSize * (c || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class Or {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(e) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Xp extends Or {
          getDefault() {
            return s.bi.transparent;
          }
          set(e) {
            const a = this.current;
            (e.r !== a.r || e.g !== a.g || e.b !== a.b || e.a !== a.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = false);
          }
        }
        class Yp extends Or {
          getDefault() {
            return 1;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = false);
          }
        }
        class Kp extends Or {
          getDefault() {
            return 0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = false);
          }
        }
        class Rh extends Or {
          getDefault() {
            return [true, true, true, true];
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || e[3] !== a[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = false);
          }
        }
        class Jp extends Or {
          getDefault() {
            return true;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = false);
          }
        }
        class Ah extends Or {
          getDefault() {
            return 255;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = false);
          }
        }
        class su extends Or {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(e) {
            const a = this.current;
            (e.func !== a.func || e.ref !== a.ref || e.mask !== a.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = false);
          }
        }
        class lu extends Or {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP];
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = false);
          }
        }
        class uu extends Or {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.STENCIL_TEST) : a.disable(a.STENCIL_TEST), this.current = e, this.dirty = false;
          }
        }
        class jc extends Or {
          getDefault() {
            return [0, 1];
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = false);
          }
        }
        class Fa extends Or {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.DEPTH_TEST) : a.disable(a.DEPTH_TEST), this.current = e, this.dirty = false;
          }
        }
        class sl extends Or {
          getDefault() {
            return this.gl.LESS;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = false);
          }
        }
        class vs extends Or {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.BLEND) : a.disable(a.BLEND), this.current = e, this.dirty = false;
          }
        }
        class Jn extends Or {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO];
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = false);
          }
        }
        class Dh extends Or {
          getDefault() {
            return s.bi.transparent;
          }
          set(e) {
            const a = this.current;
            (e.r !== a.r || e.g !== a.g || e.b !== a.b || e.a !== a.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = false);
          }
        }
        class zh extends Or {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = false);
          }
        }
        class Nc extends Or {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.CULL_FACE) : a.disable(a.CULL_FACE), this.current = e, this.dirty = false;
          }
        }
        class La extends Or {
          getDefault() {
            return this.gl.BACK;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = false);
          }
        }
        class cu extends Or {
          getDefault() {
            return this.gl.CCW;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = false);
          }
        }
        class du extends Or {
          getDefault() {
            return null;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = false);
          }
        }
        class ll extends Or {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = false);
          }
        }
        class hu extends Or {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || e[3] !== a[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = false);
          }
        }
        class Fh extends Or {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindFramebuffer(a.FRAMEBUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class _s extends Or {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindRenderbuffer(a.RENDERBUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class ys extends Or {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindTexture(a.TEXTURE_2D, e), this.current = e, this.dirty = false;
          }
        }
        class Lh extends Or {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindBuffer(a.ARRAY_BUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class Vc extends Or {
          getDefault() {
            return null;
          }
          set(e) {
            const a = this.gl;
            a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class kr extends Or {
          getDefault() {
            return null;
          }
          set(e) {
            var a;
            if (e === this.current && !this.dirty) return;
            const c = this.gl;
            Yn(c) ? c.bindVertexArray(e) : (a = c.getExtension("OES_vertex_array_object")) === null || a === void 0 || a.bindVertexArrayOES(e), this.current = e, this.dirty = false;
          }
        }
        class fu extends Or {
          getDefault() {
            return 4;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = false;
          }
        }
        class Qp extends Or {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = false;
          }
        }
        class Bh extends Or {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = false;
          }
        }
        class Ba extends Or {
          constructor(e, a) {
            super(e), this.context = e, this.parent = a;
          }
          getDefault() {
            return null;
          }
        }
        class em extends Ba {
          setDirty() {
            this.dirty = true;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, e, 0), this.current = e, this.dirty = false;
          }
        }
        class tm extends Ba {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class Oh extends Ba {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, e), this.current = e, this.dirty = false;
          }
        }
        const $h = "Framebuffer is not complete";
        class Uc {
          constructor(e, a, c, m, _) {
            this.context = e, this.width = a, this.height = c;
            const x = e.gl, k = this.framebuffer = x.createFramebuffer();
            if (this.colorAttachment = new em(e, k), m) this.depthAttachment = _ ? new Oh(e, k) : new tm(e, k);
            else if (_) throw new Error("Stencil cannot be set without depth");
            if (x.checkFramebufferStatus(x.FRAMEBUFFER) !== x.FRAMEBUFFER_COMPLETE) throw new Error($h);
          }
          destroy() {
            const e = this.context.gl, a = this.colorAttachment.get();
            if (a && e.deleteTexture(a), this.depthAttachment) {
              const c = this.depthAttachment.get();
              c && e.deleteRenderbuffer(c);
            }
            e.deleteFramebuffer(this.framebuffer);
          }
        }
        class pu {
          constructor(e) {
            var a, c;
            if (this.gl = e, this.clearColor = new Xp(this), this.clearDepth = new Yp(this), this.clearStencil = new Kp(this), this.colorMask = new Rh(this), this.depthMask = new Jp(this), this.stencilMask = new Ah(this), this.stencilFunc = new su(this), this.stencilOp = new lu(this), this.stencilTest = new uu(this), this.depthRange = new jc(this), this.depthTest = new Fa(this), this.depthFunc = new sl(this), this.blend = new vs(this), this.blendFunc = new Jn(this), this.blendColor = new Dh(this), this.blendEquation = new zh(this), this.cullFace = new Nc(this), this.cullFaceSide = new La(this), this.frontFace = new cu(this), this.program = new du(this), this.activeTexture = new ll(this), this.viewport = new hu(this), this.bindFramebuffer = new Fh(this), this.bindRenderbuffer = new _s(this), this.bindTexture = new ys(this), this.bindVertexBuffer = new Lh(this), this.bindElementBuffer = new Vc(this), this.bindVertexArray = new kr(this), this.pixelStoreUnpack = new fu(this), this.pixelStoreUnpackPremultiplyAlpha = new Qp(this), this.pixelStoreUnpackFlipY = new Bh(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), Yn(e)) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const m = e.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (a = e.RGBA16F) !== null && a !== void 0 ? a : m == null ? void 0 : m.RGBA16F_EXT, this.RGB16F = (c = e.RGB16F) !== null && c !== void 0 ? c : m == null ? void 0 : m.RGB16F_EXT, e.getExtension("EXT_color_buffer_float");
            } else {
              e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
              const m = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = m == null ? void 0 : m.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(e, a) {
            return new Oc(this, e, a);
          }
          createVertexBuffer(e, a, c) {
            return new $c(this, e, a, c);
          }
          createRenderbuffer(e, a, c) {
            const m = this.gl, _ = m.createRenderbuffer();
            return this.bindRenderbuffer.set(_), m.renderbufferStorage(m.RENDERBUFFER, e, a, c), this.bindRenderbuffer.set(null), _;
          }
          createFramebuffer(e, a, c, m) {
            return new Uc(this, e, a, c, m);
          }
          clear({ color: e, depth: a, stencil: c }) {
            const m = this.gl;
            let _ = 0;
            e && (_ |= m.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([true, true, true, true])), a !== void 0 && (_ |= m.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(a), this.depthMask.set(true)), c !== void 0 && (_ |= m.STENCIL_BUFFER_BIT, this.clearStencil.set(c), this.stencilMask.set(255)), m.clear(_);
          }
          setCullFace(e) {
            e.enable === false ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(true), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(false);
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(true), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(e) {
            s.bK(e.blendFunction, zr.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);
          }
          createVertexArray() {
            var e;
            return Yn(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES();
          }
          deleteVertexArray(e) {
            var a;
            return Yn(this.gl) ? this.gl.deleteVertexArray(e) : (a = this.gl.getExtension("OES_vertex_array_object")) === null || a === void 0 ? void 0 : a.deleteVertexArrayOES(e);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        let Oa;
        function ul(v, e, a, c, m) {
          const _ = v.context, x = v.transform, k = _.gl, T = v.useProgram("collisionBox"), R = [];
          let A = 0, N = 0;
          for (let de = 0; de < c.length; de++) {
            const ge = c[de], Se = e.getTile(ge).getBucket(a);
            if (!Se) continue;
            const me = m ? Se.textCollisionBox : Se.iconCollisionBox, ke = Se.collisionCircleArray;
            ke.length > 0 && (R.push({ circleArray: ke, circleOffset: N, coord: ge }), A += ke.length / 4, N = A), me && T.draw(_, k.LINES, br.disabled, Rr.disabled, v.colorModeForRenderPass(), xr.disabled, kh(v.transform), v.style.map.terrain && v.style.map.terrain.getTerrainData(ge), x.getProjectionData({ overscaledTileID: ge, applyGlobeMatrix: true, applyTerrainMatrix: true }), a.id, me.layoutVertexBuffer, me.indexBuffer, me.segments, null, v.transform.zoom, null, null, me.collisionVertexBuffer);
          }
          if (!m || !R.length) return;
          const j = v.useProgram("collisionCircle"), G = new s.c3();
          G.resize(4 * A), G._trim();
          let Q = 0;
          for (const de of R) for (let ge = 0; ge < de.circleArray.length / 4; ge++) {
            const Se = 4 * ge, me = de.circleArray[Se + 0], ke = de.circleArray[Se + 1], Re = de.circleArray[Se + 2], ye = de.circleArray[Se + 3];
            G.emplace(Q++, me, ke, Re, ye, 0), G.emplace(Q++, me, ke, Re, ye, 1), G.emplace(Q++, me, ke, Re, ye, 2), G.emplace(Q++, me, ke, Re, ye, 3);
          }
          (!Oa || Oa.length < 2 * A) && (Oa = (function(de) {
            const ge = 2 * de, Se = new s.c5();
            Se.resize(ge), Se._trim();
            for (let me = 0; me < ge; me++) {
              const ke = 6 * me;
              Se.uint16[ke + 0] = 4 * me + 0, Se.uint16[ke + 1] = 4 * me + 1, Se.uint16[ke + 2] = 4 * me + 2, Se.uint16[ke + 3] = 4 * me + 2, Se.uint16[ke + 4] = 4 * me + 3, Se.uint16[ke + 5] = 4 * me + 0;
            }
            return Se;
          })(A));
          const le = _.createIndexBuffer(Oa, true), ce = _.createVertexBuffer(G, s.c4.members, true);
          for (const de of R) {
            const ge = Mc(v.transform);
            j.draw(_, k.TRIANGLES, br.disabled, Rr.disabled, v.colorModeForRenderPass(), xr.disabled, ge, v.style.map.terrain && v.style.map.terrain.getTerrainData(de.coord), null, a.id, ce, le, s.aQ.simpleSegment(0, 2 * de.circleOffset, de.circleArray.length, de.circleArray.length / 2), null, v.transform.zoom, null, null, null);
          }
          ce.destroy(), le.destroy();
        }
        const Gc = s.am(new Float32Array(16));
        function jh(v, e, a, c, m, _) {
          const { horizontalAlign: x, verticalAlign: k } = s.aL(v);
          return new s.P((-(x - 0.5) * e / m + c[0]) * _, (-(k - 0.5) * a / m + c[1]) * _);
        }
        function mu(v, e, a, c, m, _) {
          const x = e.tileAnchorPoint.add(new s.P(e.translation[0], e.translation[1]));
          if (e.pitchWithMap) {
            let k = c.mult(_);
            a || (k = k.rotate(-m));
            const T = x.add(k);
            return Ct(T.x, T.y, e.pitchedLabelPlaneMatrix, e.getElevation).point;
          }
          if (a) {
            const k = Mn(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(v), T = Math.atan(k.y / k.x) + (k.x < 0 ? Math.PI : 0);
            return v.add(c.rotate(T));
          }
          return v.add(c);
        }
        function gu(v, e, a, c, m, _, x, k, T, R, A, N) {
          const j = v.text.placedSymbolArray, G = v.text.dynamicLayoutVertexArray, Q = v.icon.dynamicLayoutVertexArray, le = {};
          G.clear();
          for (let ce = 0; ce < j.length; ce++) {
            const de = j.get(ce), ge = de.hidden || !de.crossTileID || v.allowVerticalPlacement && !de.placedOrientation ? null : c[de.crossTileID];
            if (ge) {
              const Se = new s.P(de.anchorX, de.anchorY), me = { getElevation: N, width: m.width, height: m.height, pitchedLabelPlaneMatrix: _, pitchWithMap: a, transform: m, tileAnchorPoint: Se, translation: R, unwrappedTileID: A }, ke = a ? Xn(Se.x, Se.y, me) : Mn(Se.x, Se.y, me), Re = ar(m.cameraToCenterDistance, ke.signedDistanceFromCamera);
              let ye = s.at(v.textSizeData, k, de) * Re / s.aF;
              a && (ye *= v.tilePixelRatio / x);
              const { width: Be, height: Ke, anchor: He, textOffset: Ye, textBoxScale: Qe } = ge, Pt = jh(He, Be, Ke, Ye, Qe, ye), Tt = m.getPitchedTextCorrection(Se.x + R[0], Se.y + R[1], A), dt = mu(ke.point, me, e, Pt, -m.bearingInRadians, Tt), Nt = v.allowVerticalPlacement && de.placedOrientation === s.as.vertical ? Math.PI / 2 : 0;
              for (let pr = 0; pr < de.numGlyphs; pr++) s.az(G, dt, Nt);
              T && de.associatedIconIndex >= 0 && (le[de.associatedIconIndex] = { shiftedAnchor: dt, angle: Nt });
            } else ia(de.numGlyphs, G);
          }
          if (T) {
            Q.clear();
            const ce = v.icon.placedSymbolArray;
            for (let de = 0; de < ce.length; de++) {
              const ge = ce.get(de);
              if (ge.hidden) ia(ge.numGlyphs, Q);
              else {
                const Se = le[de];
                if (Se) for (let me = 0; me < ge.numGlyphs; me++) s.az(Q, Se.shiftedAnchor, Se.angle);
                else ia(ge.numGlyphs, Q);
              }
            }
            v.icon.dynamicLayoutVertexBuffer.updateData(Q);
          }
          v.text.dynamicLayoutVertexBuffer.updateData(G);
        }
        function vu(v, e, a) {
          return a.iconsInText && e ? "symbolTextAndIcon" : v ? "symbolSDF" : "symbolIcon";
        }
        function $a(v, e, a, c, m, _, x, k, T, R, A, N, j) {
          const G = v.context, Q = G.gl, le = v.transform, ce = k === "map", de = T === "map", ge = k !== "viewport" && a.layout.get("symbol-placement") !== "point", Se = ce && !de && !ge, me = !a.layout.get("symbol-sort-key").isConstant();
          let ke = false;
          const Re = v.getDepthModeForSublayer(0, br.ReadOnly), ye = a._unevaluatedLayout.hasValue("text-variable-anchor") || a._unevaluatedLayout.hasValue("text-variable-anchor-offset"), Be = [], Ke = le.getCircleRadiusCorrection();
          for (const He of c) {
            const Ye = e.getTile(He), Qe = Ye.getBucket(a);
            if (!Qe) continue;
            const Pt = m ? Qe.text : Qe.icon;
            if (!Pt || !Pt.segments.get().length || !Pt.hasVisibleVertices) continue;
            const Tt = Pt.programConfigurations.get(a.id), dt = m || Qe.sdfIcons, Nt = m ? Qe.textSizeData : Qe.iconSizeData, pr = de || le.pitch !== 0, Ur = v.useProgram(vu(dt, m, Qe), Tt), vr = s.ar(Nt, le.zoom), Kr = v.style.map.terrain && v.style.map.terrain.getTerrainData(He);
            let pi, Qr, Di, si, Gi = [0, 0], li = null;
            if (m) Qr = Ye.glyphAtlasTexture, Di = Q.LINEAR, pi = Ye.glyphAtlasTexture.size, Qe.iconsInText && (Gi = Ye.imageAtlasTexture.size, li = Ye.imageAtlasTexture, si = pr || v.options.rotating || v.options.zooming || Nt.kind === "composite" || Nt.kind === "camera" ? Q.LINEAR : Q.NEAREST);
            else {
              const Ii = a.layout.get("icon-size").constantOr(0) !== 1 || Qe.iconsNeedLinear;
              Qr = Ye.imageAtlasTexture, Di = dt || v.options.rotating || v.options.zooming || Ii || pr ? Q.LINEAR : Q.NEAREST, pi = Ye.imageAtlasTexture.size;
            }
            const Ti = s.aG(Ye, 1, v.transform.zoom), yn = _r(ce, v.transform, Ti), qa = s.M();
            s.au(qa, yn);
            const Uo = Nr(de, ce, v.transform, Ti), To = s.aH(le, Ye, _, x), Wa = le.getProjectionData({ overscaledTileID: He, applyGlobeMatrix: !j, applyTerrainMatrix: true }), Ts = ye && Qe.hasTextData(), Za = a.layout.get("icon-text-fit") !== "none" && Ts && Qe.hasIconData();
            if (ge) {
              const Ii = v.style.map.terrain ? (qi, ii) => v.style.map.terrain.getElevation(He, qi, ii) : null, Si = a.layout.get("text-rotation-alignment") === "map";
              Bi(Qe, v, m, yn, qa, de, R, Si, He.toUnwrapped(), le.width, le.height, To, Ii);
            }
            const zn = m && ye || Za, bn = ge || zn ? Gc : de ? yn : v.transform.clipSpaceToPixelsMatrix, Go = dt && a.paint.get(m ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let fa;
            fa = dt ? Qe.iconsInText ? Bo(Nt.kind, vr, Se, de, ge, zn, v, bn, Uo, To, pi, Gi, Ke) : al(Nt.kind, vr, Se, de, ge, zn, v, bn, Uo, To, m, pi, 0, Ke) : Fc(Nt.kind, vr, Se, de, ge, zn, v, bn, Uo, To, m, pi, Ke);
            const bl = { program: Ur, buffers: Pt, uniformValues: fa, projectionData: Wa, atlasTexture: Qr, atlasTextureIcon: li, atlasInterpolation: Di, atlasInterpolationIcon: si, isSDF: dt, hasHalo: Go };
            if (me && Qe.canOverlap) {
              ke = true;
              const Ii = Pt.segments.get();
              for (const Si of Ii) Be.push({ segments: new s.aQ([Si]), sortKey: Si.sortKey, state: bl, terrainData: Kr });
            } else Be.push({ segments: Pt.segments, sortKey: 0, state: bl, terrainData: Kr });
          }
          ke && Be.sort(((He, Ye) => He.sortKey - Ye.sortKey));
          for (const He of Be) {
            const Ye = He.state;
            if (G.activeTexture.set(Q.TEXTURE0), Ye.atlasTexture.bind(Ye.atlasInterpolation, Q.CLAMP_TO_EDGE), Ye.atlasTextureIcon && (G.activeTexture.set(Q.TEXTURE1), Ye.atlasTextureIcon && Ye.atlasTextureIcon.bind(Ye.atlasInterpolationIcon, Q.CLAMP_TO_EDGE)), Ye.isSDF) {
              const Qe = Ye.uniformValues;
              Ye.hasHalo && (Qe.u_is_halo = 1, _u(Ye.buffers, He.segments, a, v, Ye.program, Re, A, N, Qe, Ye.projectionData, He.terrainData)), Qe.u_is_halo = 0;
            }
            _u(Ye.buffers, He.segments, a, v, Ye.program, Re, A, N, Ye.uniformValues, Ye.projectionData, He.terrainData);
          }
        }
        function _u(v, e, a, c, m, _, x, k, T, R, A) {
          const N = c.context;
          m.draw(N, N.gl.TRIANGLES, _, x, k, xr.backCCW, T, A, R, a.id, v.layoutVertexBuffer, v.indexBuffer, e, a.paint, c.transform.zoom, v.programConfigurations.get(a.id), v.dynamicLayoutVertexBuffer, v.opacityVertexBuffer);
        }
        function rm(v, e, a, c, m) {
          const _ = v.context, x = _.gl, k = Rr.disabled, T = new zr([x.ONE, x.ONE], s.bi.transparent, [true, true, true, true]), R = e.getBucket(a);
          if (!R) return;
          const A = c.key;
          let N = a.heatmapFbos.get(A);
          N || (N = Nh(_, e.tileSize, e.tileSize), a.heatmapFbos.set(A, N)), _.bindFramebuffer.set(N.framebuffer), _.viewport.set([0, 0, e.tileSize, e.tileSize]), _.clear({ color: s.bi.transparent });
          const j = R.programConfigurations.get(a.id), G = v.useProgram("heatmap", j, !m), Q = v.transform.getProjectionData({ overscaledTileID: e.tileID, applyGlobeMatrix: true, applyTerrainMatrix: true }), le = v.style.map.terrain.getTerrainData(c);
          G.draw(_, x.TRIANGLES, br.disabled, k, T, xr.disabled, Rc(e, v.transform.zoom, a.paint.get("heatmap-intensity"), 1), le, Q, a.id, R.layoutVertexBuffer, R.indexBuffer, R.segments, a.paint, v.transform.zoom, j);
        }
        function cl(v, e, a, c, m) {
          const _ = v.context, x = _.gl, k = v.transform;
          _.setColorMode(v.colorModeForRenderPass());
          const T = qc(_, e), R = a.key, A = e.heatmapFbos.get(R);
          if (!A) return;
          _.activeTexture.set(x.TEXTURE0), x.bindTexture(x.TEXTURE_2D, A.colorAttachment.get()), _.activeTexture.set(x.TEXTURE1), T.bind(x.LINEAR, x.CLAMP_TO_EDGE);
          const N = k.getProjectionData({ overscaledTileID: a, applyTerrainMatrix: m, applyGlobeMatrix: !c });
          v.useProgram("heatmapTexture").draw(_, x.TRIANGLES, br.disabled, Rr.disabled, v.colorModeForRenderPass(), xr.disabled, Ac(v, e, 0, 1), null, N, e.id, v.rasterBoundsBuffer, v.quadTriangleIndexBuffer, v.rasterBoundsSegments, e.paint, k.zoom), A.destroy(), e.heatmapFbos.delete(R);
        }
        function Nh(v, e, a) {
          var c, m;
          const _ = v.gl, x = _.createTexture();
          _.bindTexture(_.TEXTURE_2D, x), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_S, _.CLAMP_TO_EDGE), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_T, _.CLAMP_TO_EDGE), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_MIN_FILTER, _.LINEAR), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_MAG_FILTER, _.LINEAR);
          const k = (c = v.HALF_FLOAT) !== null && c !== void 0 ? c : _.UNSIGNED_BYTE, T = (m = v.RGBA16F) !== null && m !== void 0 ? m : _.RGBA;
          _.texImage2D(_.TEXTURE_2D, 0, T, e, a, 0, _.RGBA, k, null);
          const R = v.createFramebuffer(e, a, false, false);
          return R.colorAttachment.set(x), R;
        }
        function qc(v, e) {
          return e.colorRampTexture || (e.colorRampTexture = new s.T(v, e.colorRamp, v.gl.RGBA)), e.colorRampTexture;
        }
        function dl(v, e, a, c, m, _, x, k) {
          let T = 256;
          if (m.stepInterpolant) {
            const R = e.getSource().maxzoom, A = x.canonical.z === R ? Math.ceil(1 << v.transform.maxZoom - x.canonical.z) : 1;
            T = s.ai(s.c7(_.maxLineLength / s.a3 * 1024 * A), 256, a.maxTextureSize);
          }
          return k.gradient = s.c8({ expression: m.gradientExpression(), evaluationKey: "lineProgress", resolution: T, image: k.gradient || void 0, clips: _.lineClipsArray }), k.texture ? k.texture.update(k.gradient) : k.texture = new s.T(a, k.gradient, c.RGBA), k.version = m.gradientVersion, k.texture;
        }
        function Wc(v, e, a, c, m) {
          v.activeTexture.set(e.TEXTURE0), a.imageAtlasTexture.bind(e.LINEAR, e.CLAMP_TO_EDGE), c.updatePaintBuffers(m);
        }
        function Vh(v, e, a, c, m, _) {
          (m || v.lineAtlas.dirty) && (e.activeTexture.set(a.TEXTURE0), v.lineAtlas.bind(e)), c.updatePaintBuffers(_);
        }
        function Uh(v, e, a, c, m, _, x) {
          const k = _.gradients[m.id];
          let T = k.texture;
          m.gradientVersion !== k.version && (T = dl(v, e, a, c, m, _, x, k)), a.activeTexture.set(c.TEXTURE0), T.bind(m.stepInterpolant ? c.NEAREST : c.LINEAR, c.CLAMP_TO_EDGE);
        }
        function yu(v, e, a, c, m, _, x, k, T) {
          const R = _.gradients[m.id];
          let A = R.texture;
          m.gradientVersion !== R.version && (A = dl(v, e, a, c, m, _, x, R)), a.activeTexture.set(c.TEXTURE0), A.bind(m.stepInterpolant ? c.NEAREST : c.LINEAR, c.CLAMP_TO_EDGE), a.activeTexture.set(c.TEXTURE1), v.lineAtlas.bind(a), k.updatePaintBuffers(T);
        }
        function bu(v, e, a, c, m) {
          if (!a || !c || !c.imageAtlas) return;
          const _ = c.imageAtlas.patternPositions;
          let x = _[a.to.toString()], k = _[a.from.toString()];
          if (!x && k && (x = k), !k && x && (k = x), !x || !k) {
            const T = m.getPaintProperty(e);
            x = _[T], k = _[T];
          }
          x && k && v.setConstantPatternPositions(x, k);
        }
        function Gh(v, e, a, c, m, _, x, k) {
          const T = v.context.gl, R = "fill-pattern", A = a.paint.get(R), N = A && A.constantOr(1), j = a.getCrossfadeParameters();
          let G, Q, le, ce, de;
          const ge = v.transform, Se = a.paint.get("fill-translate"), me = a.paint.get("fill-translate-anchor");
          x ? (Q = N && !a.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", G = T.LINES) : (Q = N ? "fillPattern" : "fill", G = T.TRIANGLES);
          const ke = A.constantOr(null);
          for (const Re of c) {
            const ye = e.getTile(Re);
            if (N && !ye.patternsLoaded()) continue;
            const Be = ye.getBucket(a);
            if (!Be) continue;
            const Ke = Be.programConfigurations.get(a.id), He = v.useProgram(Q, Ke), Ye = v.style.map.terrain && v.style.map.terrain.getTerrainData(Re);
            N && (v.context.activeTexture.set(T.TEXTURE0), ye.imageAtlasTexture.bind(T.LINEAR, T.CLAMP_TO_EDGE), Ke.updatePaintBuffers(j)), bu(Ke, R, ke, ye, a);
            const Qe = ge.getProjectionData({ overscaledTileID: Re, applyGlobeMatrix: !k, applyTerrainMatrix: true }), Pt = s.aH(ge, ye, Se, me);
            if (x) {
              ce = Be.indexBuffer2, de = Be.segments2;
              const dt = [T.drawingBufferWidth, T.drawingBufferHeight];
              le = Q === "fillOutlinePattern" && N ? Sh(v, j, ye, dt, Pt) : Gp(dt, Pt);
            } else ce = Be.indexBuffer, de = Be.segments, le = N ? Aa(v, j, ye, Pt) : { u_fill_translate: Pt };
            const Tt = v.stencilModeForClipping(Re);
            He.draw(v.context, G, m, Tt, _, xr.backCCW, le, Ye, Qe, a.id, Be.layoutVertexBuffer, ce, de, a.paint, v.transform.zoom, Ke);
          }
        }
        function xu(v, e, a, c, m, _, x, k) {
          const T = v.context, R = T.gl, A = "fill-extrusion-pattern", N = a.paint.get(A), j = N.constantOr(1), G = a.getCrossfadeParameters(), Q = a.paint.get("fill-extrusion-opacity"), le = N.constantOr(null), ce = v.transform;
          for (const de of c) {
            const ge = e.getTile(de), Se = ge.getBucket(a);
            if (!Se) continue;
            const me = v.style.map.terrain && v.style.map.terrain.getTerrainData(de), ke = Se.programConfigurations.get(a.id), Re = v.useProgram(j ? "fillExtrusionPattern" : "fillExtrusion", ke);
            j && (v.context.activeTexture.set(R.TEXTURE0), ge.imageAtlasTexture.bind(R.LINEAR, R.CLAMP_TO_EDGE), ke.updatePaintBuffers(G));
            const ye = ce.getProjectionData({ overscaledTileID: de, applyGlobeMatrix: !k, applyTerrainMatrix: true });
            bu(ke, A, le, ge, a);
            const Be = s.aH(ce, ge, a.paint.get("fill-extrusion-translate"), a.paint.get("fill-extrusion-translate-anchor")), Ke = a.paint.get("fill-extrusion-vertical-gradient"), He = j ? Up(v, Ke, Q, Be, de, G, ge) : ol(v, Ke, Q, Be);
            Re.draw(T, T.gl.TRIANGLES, m, _, x, xr.backCCW, He, me, ye, a.id, Se.layoutVertexBuffer, Se.indexBuffer, Se.segments, a.paint, v.transform.zoom, ke, v.style.map.terrain && Se.centroidVertexBuffer);
          }
        }
        function hi(v, e, a, c, m, _, x, k, T) {
          var R;
          const A = v.style.projection, N = v.context, j = v.transform, G = N.gl, Q = [`#define NUM_ILLUMINATION_SOURCES ${a.paint.get("hillshade-highlight-color").values.length}`], le = v.useProgram("hillshade", null, false, Q), ce = !v.options.moving;
          for (const de of c) {
            const ge = e.getTile(de), Se = ge.fbo;
            if (!Se) continue;
            const me = A.getMeshFromTileID(N, de.canonical, k, true, "raster"), ke = (R = v.style.map.terrain) === null || R === void 0 ? void 0 : R.getTerrainData(de);
            N.activeTexture.set(G.TEXTURE0), G.bindTexture(G.TEXTURE_2D, Se.colorAttachment.get());
            const Re = j.getProjectionData({ overscaledTileID: de, aligned: ce, applyGlobeMatrix: !T, applyTerrainMatrix: true });
            le.draw(N, G.TRIANGLES, _, m[de.overscaledZ], x, xr.backCCW, Ph(v, ge, a), ke, Re, a.id, me.vertexBuffer, me.indexBuffer, me.segments);
          }
        }
        function Oo(v, e, a, c, m, _, x, k, T) {
          var R;
          const A = v.style.projection, N = v.context, j = v.transform, G = N.gl, Q = v.useProgram("colorRelief"), le = !v.options.moving;
          let ce = true, de = 0;
          for (const ge of c) {
            const Se = e.getTile(ge), me = Se.dem;
            if (ce) {
              const He = G.getParameter(G.MAX_TEXTURE_SIZE), { elevationTexture: Ye, colorTexture: Qe } = a.getColorRampTextures(N, He, me.getUnpackVector());
              N.activeTexture.set(G.TEXTURE1), Ye.bind(G.NEAREST, G.CLAMP_TO_EDGE), N.activeTexture.set(G.TEXTURE4), Qe.bind(G.LINEAR, G.CLAMP_TO_EDGE), ce = false, de = Ye.size[0];
            }
            if (!me || !me.data) continue;
            const ke = me.stride, Re = me.getPixels();
            if (N.activeTexture.set(G.TEXTURE0), N.pixelStoreUnpackPremultiplyAlpha.set(false), Se.demTexture = Se.demTexture || v.getTileTexture(ke), Se.demTexture) {
              const He = Se.demTexture;
              He.update(Re, { premultiply: false }), He.bind(G.LINEAR, G.CLAMP_TO_EDGE);
            } else Se.demTexture = new s.T(N, Re, G.RGBA, { premultiply: false }), Se.demTexture.bind(G.LINEAR, G.CLAMP_TO_EDGE);
            const ye = A.getMeshFromTileID(N, ge.canonical, k, true, "raster"), Be = (R = v.style.map.terrain) === null || R === void 0 ? void 0 : R.getTerrainData(ge), Ke = j.getProjectionData({ overscaledTileID: ge, aligned: le, applyGlobeMatrix: !T, applyTerrainMatrix: true });
            Q.draw(N, G.TRIANGLES, _, m[ge.overscaledZ], x, xr.backCCW, Ih(a, Se.dem, de), Be, Ke, a.id, ye.vertexBuffer, ye.indexBuffer, ye.segments);
          }
        }
        const An = [new s.P(0, 0), new s.P(s.a3, 0), new s.P(s.a3, s.a3), new s.P(0, s.a3)];
        function bs(v, e, a, c, m, _, x, k, T = false, R = false) {
          const A = c[c.length - 1].overscaledZ, N = v.context, j = N.gl, G = v.useProgram("raster"), Q = v.transform, le = v.style.projection, ce = v.colorModeForRenderPass(), de = !v.options.moving, ge = a.paint.get("raster-opacity"), Se = a.paint.get("raster-resampling"), me = a.paint.get("raster-fade-duration"), ke = !!v.style.map.terrain;
          for (const Re of c) {
            const ye = v.getDepthModeForSublayer(Re.overscaledZ - A, ge === 1 ? br.ReadWrite : br.ReadOnly, j.LESS), Be = e.getTile(Re), Ke = Se === "nearest" ? j.NEAREST : j.LINEAR;
            N.activeTexture.set(j.TEXTURE0), Be.texture.bind(Ke, j.CLAMP_TO_EDGE, j.LINEAR_MIPMAP_NEAREST), N.activeTexture.set(j.TEXTURE1);
            const { parentTile: He, parentScaleBy: Ye, parentTopLeft: Qe, fadeValues: Pt } = wu(Be, e, me, ke);
            Be.fadeOpacity = Pt.tileOpacity, He ? (He.fadeOpacity = Pt.parentTileOpacity, He.texture.bind(Ke, j.CLAMP_TO_EDGE, j.LINEAR_MIPMAP_NEAREST)) : Be.texture.bind(Ke, j.CLAMP_TO_EDGE, j.LINEAR_MIPMAP_NEAREST), Be.texture.useMipmap && N.extTextureFilterAnisotropic && v.transform.pitch > 20 && j.texParameterf(j.TEXTURE_2D, N.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, N.extTextureFilterAnisotropicMax);
            const Tt = v.style.map.terrain && v.style.map.terrain.getTerrainData(Re), dt = Q.getProjectionData({ overscaledTileID: Re, aligned: de, applyGlobeMatrix: !R, applyTerrainMatrix: true }), Nt = Mh(Qe, Ye, Pt.fadeMix, a, k), pr = le.getMeshFromTileID(N, Re.canonical, _, x, "raster");
            G.draw(N, j.TRIANGLES, ye, m ? m[Re.overscaledZ] : Rr.disabled, ce, T ? xr.frontCCW : xr.backCCW, Nt, Tt, dt, a.id, pr.vertexBuffer, pr.indexBuffer, pr.segments);
          }
        }
        function wu(v, e, a, c) {
          const m = { parentTile: null, parentScaleBy: 1, parentTopLeft: [0, 0], fadeValues: { tileOpacity: 1, parentTileOpacity: 1, fadeMix: { opacity: 1, mix: 0 } } };
          if (a === 0 || c) return m;
          if (v.fadingParentID) {
            const _ = e.getLoadedTile(v.fadingParentID);
            if (!_) return m;
            const x = Math.pow(2, _.tileID.overscaledZ - v.tileID.overscaledZ), k = [v.tileID.canonical.x * x % 1, v.tileID.canonical.y * x % 1], T = (function(R, A, N) {
              const j = z(), G = (j - A.timeAdded) / N, Q = R.fadingDirection === ve.Incoming, le = s.ai((j - R.timeAdded) / N, 0, 1), ce = s.ai(1 - G, 0, 1), de = Q ? le : ce;
              return { tileOpacity: de, parentTileOpacity: Q ? ce : le, fadeMix: { opacity: 1, mix: 1 - de } };
            })(v, _, a);
            return { parentTile: _, parentScaleBy: x, parentTopLeft: k, fadeValues: T };
          }
          if (v.selfFading) {
            const _ = (function(x, k) {
              const T = (z() - x.timeAdded) / k, R = s.ai(T, 0, 1);
              return { tileOpacity: R, fadeMix: { opacity: R, mix: 0 } };
            })(v, a);
            return { parentTile: null, parentScaleBy: 1, parentTopLeft: [0, 0], fadeValues: _ };
          }
          return m;
        }
        const qh = new s.bi(1, 0, 0, 1), xs = new s.bi(0, 1, 0, 1), Zc = new s.bi(0, 0, 1, 1), hl = new s.bi(1, 0, 1, 1), Hc = new s.bi(0, 1, 1, 1);
        function Xc(v, e, a, c) {
          fl(v, 0, e + a / 2, v.transform.width, a, c);
        }
        function Yc(v, e, a, c) {
          fl(v, e - a / 2, 0, a, v.transform.height, c);
        }
        function fl(v, e, a, c, m, _) {
          const x = v.context, k = x.gl;
          k.enable(k.SCISSOR_TEST), k.scissor(e * v.pixelRatio, a * v.pixelRatio, c * v.pixelRatio, m * v.pixelRatio), x.clear({ color: _ }), k.disable(k.SCISSOR_TEST);
        }
        function Wh(v, e, a) {
          const c = v.context, m = c.gl, _ = v.useProgram("debug"), x = br.disabled, k = Rr.disabled, T = v.colorModeForRenderPass(), R = "$debug", A = v.style.map.terrain && v.style.map.terrain.getTerrainData(a);
          c.activeTexture.set(m.TEXTURE0);
          const N = e.getTileByID(a.key).latestRawTileData, j = Math.floor((N && N.byteLength || 0) / 1024), G = e.getTile(a).tileSize, Q = 512 / Math.min(G, 512) * (a.overscaledZ / v.transform.zoom) * 0.5;
          let le = a.canonical.toString();
          a.overscaledZ !== a.canonical.z && (le += ` => ${a.overscaledZ}`), (function(de, ge) {
            de.initDebugOverlayCanvas();
            const Se = de.debugOverlayCanvas, me = de.context.gl, ke = de.debugOverlayCanvas.getContext("2d");
            ke.clearRect(0, 0, Se.width, Se.height), ke.shadowColor = "white", ke.shadowBlur = 2, ke.lineWidth = 1.5, ke.strokeStyle = "white", ke.textBaseline = "top", ke.font = "bold 36px Open Sans, sans-serif", ke.fillText(ge, 5, 5), ke.strokeText(ge, 5, 5), de.debugOverlayTexture.update(Se), de.debugOverlayTexture.bind(me.LINEAR, me.CLAMP_TO_EDGE);
          })(v, `${le} ${j}kB`);
          const ce = v.transform.getProjectionData({ overscaledTileID: a, applyGlobeMatrix: true, applyTerrainMatrix: true });
          _.draw(c, m.TRIANGLES, x, k, zr.alphaBlended, xr.disabled, Ec(s.bi.transparent, Q), null, ce, R, v.debugBuffer, v.quadTriangleIndexBuffer, v.debugSegments), _.draw(c, m.LINE_STRIP, x, k, T, xr.disabled, Ec(s.bi.red), A, ce, R, v.debugBuffer, v.tileBorderIndexBuffer, v.debugSegments);
        }
        function Kc(v, e, a, c) {
          const { isRenderingGlobe: m } = c, _ = v.context, x = _.gl, k = v.transform, T = v.colorModeForRenderPass(), R = v.getDepthModeFor3D(), A = v.useProgram("terrain");
          _.bindFramebuffer.set(null), _.viewport.set([0, 0, v.width, v.height]);
          for (const N of a) {
            const j = e.getTerrainMesh(N.tileID), G = v.renderToTexture.getTexture(N), Q = e.getTerrainData(N.tileID);
            _.activeTexture.set(x.TEXTURE0), x.bindTexture(x.TEXTURE_2D, G.texture);
            const le = e.getMeshFrameDelta(k.zoom), ce = k.calculateFogMatrix(N.tileID.toUnwrapped()), de = Vp(le, ce, v.style.sky, k.pitch, m), ge = k.getProjectionData({ overscaledTileID: N.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
            A.draw(_, x.TRIANGLES, R, Rr.disabled, T, xr.backCCW, de, Q, ge, "terrain", j.vertexBuffer, j.indexBuffer, j.segments);
          }
        }
        function ha(v, e) {
          if (!e.mesh) {
            const a = new s.aP();
            a.emplaceBack(-1, -1), a.emplaceBack(1, -1), a.emplaceBack(1, 1), a.emplaceBack(-1, 1);
            const c = new s.aR();
            c.emplaceBack(0, 1, 2), c.emplaceBack(0, 2, 3), e.mesh = new ds(v.createVertexBuffer(a, Co.members), v.createIndexBuffer(c), s.aQ.simpleSegment(0, 0, a.length, c.length));
          }
          return e.mesh;
        }
        class Zh {
          constructor(e, a) {
            this.context = new pu(e), this.transform = a, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: s.am(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = Hr.maxUnderzooming + Hr.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new ao();
          }
          resize(e, a, c) {
            if (this.width = Math.floor(e * c), this.height = Math.floor(a * c), this.pixelRatio = c, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const m of this.style._order) this.style._layers[m].resize();
          }
          setup() {
            const e = this.context, a = new s.aP();
            a.emplaceBack(0, 0), a.emplaceBack(s.a3, 0), a.emplaceBack(0, s.a3), a.emplaceBack(s.a3, s.a3), this.tileExtentBuffer = e.createVertexBuffer(a, Co.members), this.tileExtentSegments = s.aQ.simpleSegment(0, 0, 4, 2);
            const c = new s.aP();
            c.emplaceBack(0, 0), c.emplaceBack(s.a3, 0), c.emplaceBack(0, s.a3), c.emplaceBack(s.a3, s.a3), this.debugBuffer = e.createVertexBuffer(c, Co.members), this.debugSegments = s.aQ.simpleSegment(0, 0, 4, 5);
            const m = new s.ca();
            m.emplaceBack(0, 0, 0, 0), m.emplaceBack(s.a3, 0, s.a3, 0), m.emplaceBack(0, s.a3, 0, s.a3), m.emplaceBack(s.a3, s.a3, s.a3, s.a3), this.rasterBoundsBuffer = e.createVertexBuffer(m, Tc.members), this.rasterBoundsSegments = s.aQ.simpleSegment(0, 0, 4, 2);
            const _ = new s.aP();
            _.emplaceBack(0, 0), _.emplaceBack(s.a3, 0), _.emplaceBack(0, s.a3), _.emplaceBack(s.a3, s.a3), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(_, Co.members), this.rasterBoundsSegmentsPosOnly = s.aQ.simpleSegment(0, 0, 4, 5);
            const x = new s.aP();
            x.emplaceBack(0, 0), x.emplaceBack(1, 0), x.emplaceBack(0, 1), x.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(x, Co.members), this.viewportSegments = s.aQ.simpleSegment(0, 0, 4, 2);
            const k = new s.cb();
            k.emplaceBack(0), k.emplaceBack(1), k.emplaceBack(3), k.emplaceBack(2), k.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(k);
            const T = new s.aR();
            T.emplaceBack(1, 0, 2), T.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(T);
            const R = this.context.gl;
            this.stencilClearMode = new Rr({ func: R.ALWAYS, mask: 0 }, 0, 255, R.ZERO, R.ZERO, R.ZERO), this.tileExtentMesh = new ds(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
          clearStencil() {
            const e = this.context, a = e.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const c = s.M();
            s.c0(c, 0, this.width, this.height, 0, 0, 1), s.O(c, c, [a.drawingBufferWidth, a.drawingBufferHeight, 0]);
            const m = { mainMatrix: c, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: c };
            this.useProgram("clippingMask", null, true).draw(e, a.TRIANGLES, br.disabled, this.stencilClearMode, zr.disabled, xr.disabled, null, null, m, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(e, a, c) {
            if (this.currentStencilSource === e.source || !e.isTileClipped() || !a || !a.length) return;
            this.currentStencilSource = e.source, this.nextStencilID + a.length > 256 && this.clearStencil();
            const m = this.context;
            m.setColorMode(zr.disabled), m.setDepthMode(br.disabled);
            const _ = {};
            for (const x of a) _[x.key] = this.nextStencilID++;
            this._renderTileMasks(_, a, c, true), this._renderTileMasks(_, a, c, false), this._tileClippingMaskIDs = _;
          }
          _renderTileMasks(e, a, c, m) {
            const _ = this.context, x = _.gl, k = this.style.projection, T = this.transform, R = this.useProgram("clippingMask");
            for (const A of a) {
              const N = e[A.key], j = this.style.map.terrain && this.style.map.terrain.getTerrainData(A), G = k.getMeshFromTileID(this.context, A.canonical, m, true, "stencil"), Q = T.getProjectionData({ overscaledTileID: A, applyGlobeMatrix: !c, applyTerrainMatrix: true });
              R.draw(_, x.TRIANGLES, br.disabled, new Rr({ func: x.ALWAYS, mask: 0 }, N, 255, x.KEEP, x.KEEP, x.REPLACE), zr.disabled, c ? xr.disabled : xr.backCCW, null, j, Q, "$clipping", G.vertexBuffer, G.indexBuffer, G.segments);
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context, a = e.gl, c = this.style.projection, m = this.transform, _ = this.useProgram("depth"), x = this.getDepthModeFor3D(), k = jr(m, { tileSize: m.tileSize });
            for (const T of k) {
              const R = this.style.map.terrain && this.style.map.terrain.getTerrainData(T), A = c.getMeshFromTileID(this.context, T.canonical, true, true, "raster"), N = m.getProjectionData({ overscaledTileID: T, applyGlobeMatrix: true, applyTerrainMatrix: true });
              _.draw(e, a.TRIANGLES, x, Rr.disabled, zr.disabled, xr.backCCW, null, R, N, "$clipping", A.vertexBuffer, A.indexBuffer, A.segments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e = this.nextStencilID++, a = this.context.gl;
            return new Rr({ func: a.NOTEQUAL, mask: 255 }, e, 255, a.KEEP, a.KEEP, a.REPLACE);
          }
          stencilModeForClipping(e) {
            const a = this.context.gl;
            return new Rr({ func: a.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e.key], 0, a.KEEP, a.KEEP, a.REPLACE);
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const a = this.context.gl, c = e.sort(((x, k) => k.overscaledZ - x.overscaledZ)), m = c[c.length - 1].overscaledZ, _ = c[0].overscaledZ - m + 1;
            if (_ > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + _ > 256 && this.clearStencil();
              const x = {};
              for (let k = 0; k < _; k++) x[k + m] = new Rr({ func: a.GEQUAL, mask: 255 }, k + this.nextStencilID, 255, a.KEEP, a.KEEP, a.REPLACE);
              return this.nextStencilID += _, [x, c];
            }
            return [{ [m]: Rr.disabled }, c];
          }
          stencilConfigForOverlapTwoPass(e) {
            const a = this.context.gl, c = e.sort(((x, k) => k.overscaledZ - x.overscaledZ)), m = c[c.length - 1].overscaledZ, _ = c[0].overscaledZ - m + 1;
            if (this.clearStencil(), _ > 1) {
              const x = {}, k = {};
              for (let T = 0; T < _; T++) x[T + m] = new Rr({ func: a.GREATER, mask: 255 }, _ + 1 + T, 255, a.KEEP, a.KEEP, a.REPLACE), k[T + m] = new Rr({ func: a.GREATER, mask: 255 }, 1 + T, 255, a.KEEP, a.KEEP, a.REPLACE);
              return this.nextStencilID = 2 * _ + 1, [x, k, c];
            }
            return this.nextStencilID = 3, [{ [m]: new Rr({ func: a.GREATER, mask: 255 }, 2, 255, a.KEEP, a.KEEP, a.REPLACE) }, { [m]: new Rr({ func: a.GREATER, mask: 255 }, 1, 255, a.KEEP, a.KEEP, a.REPLACE) }, c];
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector ? new zr([e.CONSTANT_COLOR, e.ONE], new s.bi(0.125, 0.125, 0.125, 0), [true, true, true, true]) : this.renderPass === "opaque" ? zr.unblended : zr.alphaBlended;
          }
          getDepthModeForSublayer(e, a, c) {
            if (!this.opaquePassEnabledForLayer()) return br.disabled;
            const m = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
            return new br(c || this.context.gl.LEQUAL, a, [m, m]);
          }
          getDepthModeFor3D() {
            return new br(this.context.gl.LEQUAL, br.ReadWrite, this.depthRangeFor3D);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(e, a) {
            var c, m;
            this.style = e, this.options = a, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(z()), this.imageManager.beginFrame();
            const _ = this.style._order, x = this.style.tileManagers, k = {}, T = {}, R = {}, A = { isRenderingToTexture: false, isRenderingGlobe: ((c = e.projection) === null || c === void 0 ? void 0 : c.transitionState) > 0 };
            for (const j in x) {
              const G = x[j];
              G.used && G.prepare(this.context), k[j] = G.getVisibleCoordinates(false), T[j] = k[j].slice().reverse(), R[j] = G.getVisibleCoordinates(true).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let j = 0; j < _.length; j++) if (this.style._layers[_[j]].is3D()) {
              this.opaquePassCutoff = j;
              break;
            }
            this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const j of _) {
              const G = this.style._layers[j];
              if (!G.hasOffscreenPass() || G.isHidden(this.transform.zoom)) continue;
              const Q = T[G.source];
              (G.type === "custom" || Q.length) && this.renderLayer(this, x[G.source], G, Q, A);
            }
            if ((m = this.style.projection) === null || m === void 0 || m.updateGPUdependent({ context: this.context, useProgram: (j) => this.useProgram(j) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: a.showOverdrawInspector ? s.bi.black : s.bi.transparent, depth: 1 }), this.clearStencil(), this.style.sky && (function(j, G) {
              const Q = j.context, le = Q.gl, ce = ((Re, ye, Be) => {
                const Ke = Math.cos(ye.rollInRadians), He = Math.sin(ye.rollInRadians), Ye = We(ye), Qe = ye.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }).projectionTransition;
                return { u_sky_color: Re.properties.get("sky-color"), u_horizon_color: Re.properties.get("horizon-color"), u_horizon: [(ye.width / 2 - Ye * He) * Be, (ye.height / 2 + Ye * Ke) * Be], u_horizon_normal: [-He, Ke], u_sky_horizon_blend: Re.properties.get("sky-horizon-blend") * ye.height / 2 * Be, u_sky_blend: Qe };
              })(G, j.style.map.transform, j.pixelRatio), de = new br(le.LEQUAL, br.ReadWrite, [0, 1]), ge = Rr.disabled, Se = j.colorModeForRenderPass(), me = j.useProgram("sky"), ke = ha(Q, G);
              me.draw(Q, le.TRIANGLES, de, ge, Se, xr.disabled, ce, null, void 0, "sky", ke.vertexBuffer, ke.indexBuffer, ke.segments);
            })(this, this.style.sky), this._showOverdrawInspector = a.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = _.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const j = this.style._layers[_[this.currentLayer]], G = x[j.source], Q = k[j.source];
              this._renderTileClippingMasks(j, Q, false), this.renderLayer(this, G, j, Q, A);
            }
            this.renderPass = "translucent";
            let N = false;
            for (this.currentLayer = 0; this.currentLayer < _.length; this.currentLayer++) {
              const j = this.style._layers[_[this.currentLayer]], G = x[j.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(j, A)) continue;
              this.opaquePassEnabledForLayer() || N || (N = true, A.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const Q = (j.type === "symbol" ? R : T)[j.source];
              this._renderTileClippingMasks(j, k[j.source], !!this.renderToTexture), this.renderLayer(this, G, j, Q, A);
            }
            if (A.isRenderingGlobe && (function(j, G, Q) {
              const le = j.context, ce = le.gl, de = j.useProgram("atmosphere"), ge = new br(ce.LEQUAL, br.ReadOnly, [0, 1]), Se = j.transform, me = (function(Qe, Pt) {
                const Tt = Qe.properties.get("position"), dt = [-Tt.x, -Tt.y, -Tt.z], Nt = s.am(new Float64Array(16));
                return Qe.properties.get("anchor") === "map" && (s.b9(Nt, Nt, Pt.rollInRadians), s.ba(Nt, Nt, -Pt.pitchInRadians), s.b9(Nt, Nt, Pt.bearingInRadians), s.ba(Nt, Nt, Pt.center.lat * Math.PI / 180), s.bC(Nt, Nt, -Pt.center.lng * Math.PI / 180)), s.c9(dt, dt, Nt), dt;
              })(Q, j.transform), ke = Se.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }), Re = G.properties.get("atmosphere-blend") * ke.projectionTransition;
              if (Re === 0) return;
              const ye = el(Se.worldSize, Se.center.lat), Be = Se.inverseProjectionMatrix, Ke = new Float64Array(4);
              Ke[3] = 1, s.aA(Ke, Ke, Se.modelViewProjectionMatrix), Ke[0] /= Ke[3], Ke[1] /= Ke[3], Ke[2] /= Ke[3], Ke[3] = 1, s.aA(Ke, Ke, Be), Ke[0] /= Ke[3], Ke[1] /= Ke[3], Ke[2] /= Ke[3], Ke[3] = 1;
              const He = /* @__PURE__ */ ((Qe, Pt, Tt, dt, Nt) => ({ u_sun_pos: Qe, u_atmosphere_blend: Pt, u_globe_position: Tt, u_globe_radius: dt, u_inv_proj_matrix: Nt }))(me, Re, [Ke[0], Ke[1], Ke[2]], ye, Be), Ye = ha(le, G);
              de.draw(le, ce.TRIANGLES, ge, Rr.disabled, zr.alphaBlended, xr.disabled, He, null, null, "atmosphere", Ye.vertexBuffer, Ye.indexBuffer, Ye.segments);
            })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const j = (function(G, Q) {
                let le = null;
                const ce = Object.values(G._layers).flatMap(((me) => me.source && !me.isHidden(Q) ? [G.tileManagers[me.source]] : [])), de = ce.filter(((me) => me.getSource().type === "vector")), ge = ce.filter(((me) => me.getSource().type !== "vector")), Se = (me) => {
                  (!le || le.getSource().maxzoom < me.getSource().maxzoom) && (le = me);
                };
                return de.forEach(((me) => Se(me))), le || ge.forEach(((me) => Se(me))), le;
              })(this.style, this.transform.zoom);
              j && (function(G, Q, le) {
                for (let ce = 0; ce < le.length; ce++) Wh(G, Q, le[ce]);
              })(this, j, j.getVisibleCoordinates());
            }
            this.options.showPadding && (function(j) {
              const G = j.transform.padding;
              Xc(j, j.transform.height - (G.top || 0), 3, qh), Xc(j, G.bottom || 0, 3, xs), Yc(j, G.left || 0, 3, Zc), Yc(j, j.transform.width - (G.right || 0), 3, hl);
              const Q = j.transform.centerPoint;
              (function(le, ce, de, ge) {
                fl(le, ce - 1, de - 10, 2, 20, ge), fl(le, ce - 10, de - 1, 20, 2, ge);
              })(j, Q.x, j.transform.height - Q.y, Hc);
            })(this), this.context.setDefault();
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const a = this.terrainFacilitator.matrix, c = this.transform.modelViewProjectionMatrix;
            let m = this.terrainFacilitator.dirty;
            m || (m = e ? !s.cc(a, c) : !s.cd(a, c)), m || (m = this.style.map.terrain.tileManager.anyTilesAfterTime(this.terrainFacilitator.renderTime)), m && (s.ce(a, c), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, (function(_, x) {
              const k = _.context, T = k.gl, R = _.transform, A = zr.unblended, N = new br(T.LEQUAL, br.ReadWrite, [0, 1]), j = x.tileManager.getRenderableTiles(), G = _.useProgram("terrainDepth");
              k.bindFramebuffer.set(x.getFramebuffer("depth").framebuffer), k.viewport.set([0, 0, _.width / devicePixelRatio, _.height / devicePixelRatio]), k.clear({ color: s.bi.transparent, depth: 1 });
              for (const Q of j) {
                const le = x.getTerrainMesh(Q.tileID), ce = x.getTerrainData(Q.tileID), de = R.getProjectionData({ overscaledTileID: Q.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true }), ge = { u_ele_delta: x.getMeshFrameDelta(R.zoom) };
                G.draw(k, T.TRIANGLES, N, Rr.disabled, A, xr.backCCW, ge, ce, de, "terrain", le.vertexBuffer, le.indexBuffer, le.segments);
              }
              k.bindFramebuffer.set(null), k.viewport.set([0, 0, _.width, _.height]);
            })(this, this.style.map.terrain), (function(_, x) {
              const k = _.context, T = k.gl, R = _.transform, A = zr.unblended, N = new br(T.LEQUAL, br.ReadWrite, [0, 1]), j = x.getCoordsTexture(), G = x.tileManager.getRenderableTiles(), Q = _.useProgram("terrainCoords");
              k.bindFramebuffer.set(x.getFramebuffer("coords").framebuffer), k.viewport.set([0, 0, _.width / devicePixelRatio, _.height / devicePixelRatio]), k.clear({ color: s.bi.transparent, depth: 1 }), x.coordsIndex = [];
              for (const le of G) {
                const ce = x.getTerrainMesh(le.tileID), de = x.getTerrainData(le.tileID);
                k.activeTexture.set(T.TEXTURE0), T.bindTexture(T.TEXTURE_2D, j.texture);
                const ge = { u_terrain_coords_id: (255 - x.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: x.getMeshFrameDelta(R.zoom) }, Se = R.getProjectionData({ overscaledTileID: le.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
                Q.draw(k, T.TRIANGLES, N, Rr.disabled, A, xr.backCCW, ge, de, Se, "terrain", ce.vertexBuffer, ce.indexBuffer, ce.segments), x.coordsIndex.push(le.tileID.key);
              }
              k.bindFramebuffer.set(null), k.viewport.set([0, 0, _.width, _.height]);
            })(this, this.style.map.terrain));
          }
          renderLayer(e, a, c, m, _) {
            c.isHidden(this.transform.zoom) || (c.type === "background" || c.type === "custom" || (m || []).length) && (this.id = c.id, s.cf(c) ? (function(x, k, T, R, A, N) {
              if (x.renderPass !== "translucent") return;
              const { isRenderingToTexture: j } = N, G = Rr.disabled, Q = x.colorModeForRenderPass();
              (T._unevaluatedLayout.hasValue("text-variable-anchor") || T._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(le, ce, de, ge, Se, me, ke, Re, ye) {
                const Be = ce.transform, Ke = ce.style.map.terrain, He = Se === "map", Ye = me === "map";
                for (const Qe of le) {
                  const Pt = ge.getTile(Qe), Tt = Pt.getBucket(de);
                  if (!Tt || !Tt.text || !Tt.text.segments.get().length) continue;
                  const dt = s.ar(Tt.textSizeData, Be.zoom), Nt = s.aG(Pt, 1, ce.transform.zoom), pr = _r(He, ce.transform, Nt), Ur = de.layout.get("icon-text-fit") !== "none" && Tt.hasIconData();
                  if (dt) {
                    const vr = Math.pow(2, Be.zoom - Pt.tileID.overscaledZ), Kr = Ke ? (pi, Qr) => Ke.getElevation(Qe, pi, Qr) : null;
                    gu(Tt, He, Ye, ye, Be, pr, vr, dt, Ur, s.aH(Be, Pt, ke, Re), Qe.toUnwrapped(), Kr);
                  }
                }
              })(R, x, T, k, T.layout.get("text-rotation-alignment"), T.layout.get("text-pitch-alignment"), T.paint.get("text-translate"), T.paint.get("text-translate-anchor"), A), T.paint.get("icon-opacity").constantOr(1) !== 0 && $a(x, k, T, R, false, T.paint.get("icon-translate"), T.paint.get("icon-translate-anchor"), T.layout.get("icon-rotation-alignment"), T.layout.get("icon-pitch-alignment"), T.layout.get("icon-keep-upright"), G, Q, j), T.paint.get("text-opacity").constantOr(1) !== 0 && $a(x, k, T, R, true, T.paint.get("text-translate"), T.paint.get("text-translate-anchor"), T.layout.get("text-rotation-alignment"), T.layout.get("text-pitch-alignment"), T.layout.get("text-keep-upright"), G, Q, j), k.map.showCollisionBoxes && (ul(x, k, T, R, true), ul(x, k, T, R, false));
            })(e, a, c, m, this.style.placement.variableOffsets, _) : s.cg(c) ? (function(x, k, T, R, A) {
              if (x.renderPass !== "translucent") return;
              const { isRenderingToTexture: N } = A, j = T.paint.get("circle-opacity"), G = T.paint.get("circle-stroke-width"), Q = T.paint.get("circle-stroke-opacity"), le = !T.layout.get("circle-sort-key").isConstant();
              if (j.constantOr(1) === 0 && (G.constantOr(1) === 0 || Q.constantOr(1) === 0)) return;
              const ce = x.context, de = ce.gl, ge = x.transform, Se = x.getDepthModeForSublayer(0, br.ReadOnly), me = Rr.disabled, ke = x.colorModeForRenderPass(), Re = [], ye = ge.getCircleRadiusCorrection();
              for (let Be = 0; Be < R.length; Be++) {
                const Ke = R[Be], He = k.getTile(Ke), Ye = He.getBucket(T);
                if (!Ye) continue;
                const Qe = T.paint.get("circle-translate"), Pt = T.paint.get("circle-translate-anchor"), Tt = s.aH(ge, He, Qe, Pt), dt = Ye.programConfigurations.get(T.id), Nt = x.useProgram("circle", dt), pr = Ye.layoutVertexBuffer, Ur = Ye.indexBuffer, vr = x.style.map.terrain && x.style.map.terrain.getTerrainData(Ke), Kr = { programConfiguration: dt, program: Nt, layoutVertexBuffer: pr, indexBuffer: Ur, uniformValues: qp(x, He, T, Tt, ye), terrainData: vr, projectionData: ge.getProjectionData({ overscaledTileID: Ke, applyGlobeMatrix: !N, applyTerrainMatrix: true }) };
                if (le) {
                  const pi = Ye.segments.get();
                  for (const Qr of pi) Re.push({ segments: new s.aQ([Qr]), sortKey: Qr.sortKey, state: Kr });
                } else Re.push({ segments: Ye.segments, sortKey: 0, state: Kr });
              }
              le && Re.sort(((Be, Ke) => Be.sortKey - Ke.sortKey));
              for (const Be of Re) {
                const { programConfiguration: Ke, program: He, layoutVertexBuffer: Ye, indexBuffer: Qe, uniformValues: Pt, terrainData: Tt, projectionData: dt } = Be.state;
                He.draw(ce, de.TRIANGLES, Se, me, ke, xr.backCCW, Pt, Tt, dt, T.id, Ye, Qe, Be.segments, T.paint, x.transform.zoom, Ke);
              }
            })(e, a, c, m, _) : s.ch(c) ? (function(x, k, T, R, A) {
              if (T.paint.get("heatmap-opacity") === 0) return;
              const N = x.context, { isRenderingToTexture: j, isRenderingGlobe: G } = A;
              if (x.style.map.terrain) {
                for (const Q of R) {
                  const le = k.getTile(Q);
                  k.hasRenderableParent(Q) || (x.renderPass === "offscreen" ? rm(x, le, T, Q, G) : x.renderPass === "translucent" && cl(x, T, Q, j, G));
                }
                N.viewport.set([0, 0, x.width, x.height]);
              } else x.renderPass === "offscreen" ? (function(Q, le, ce, de) {
                const ge = Q.context, Se = ge.gl, me = Q.transform, ke = Rr.disabled, Re = new zr([Se.ONE, Se.ONE], s.bi.transparent, [true, true, true, true]);
                (function(ye, Be, Ke) {
                  const He = ye.gl;
                  ye.activeTexture.set(He.TEXTURE1), ye.viewport.set([0, 0, Be.width / 4, Be.height / 4]);
                  let Ye = Ke.heatmapFbos.get(s.c6);
                  Ye ? (He.bindTexture(He.TEXTURE_2D, Ye.colorAttachment.get()), ye.bindFramebuffer.set(Ye.framebuffer)) : (Ye = Nh(ye, Be.width / 4, Be.height / 4), Ke.heatmapFbos.set(s.c6, Ye));
                })(ge, Q, ce), ge.clear({ color: s.bi.transparent });
                for (let ye = 0; ye < de.length; ye++) {
                  const Be = de[ye];
                  if (le.hasRenderableParent(Be)) continue;
                  const Ke = le.getTile(Be), He = Ke.getBucket(ce);
                  if (!He) continue;
                  const Ye = He.programConfigurations.get(ce.id), Qe = Q.useProgram("heatmap", Ye), Pt = me.getProjectionData({ overscaledTileID: Be, applyGlobeMatrix: true, applyTerrainMatrix: false }), Tt = me.getCircleRadiusCorrection();
                  Qe.draw(ge, Se.TRIANGLES, br.disabled, ke, Re, xr.backCCW, Rc(Ke, me.zoom, ce.paint.get("heatmap-intensity"), Tt), null, Pt, ce.id, He.layoutVertexBuffer, He.indexBuffer, He.segments, ce.paint, me.zoom, Ye);
                }
                ge.viewport.set([0, 0, Q.width, Q.height]);
              })(x, k, T, R) : x.renderPass === "translucent" && (function(Q, le) {
                const ce = Q.context, de = ce.gl;
                ce.setColorMode(Q.colorModeForRenderPass());
                const ge = le.heatmapFbos.get(s.c6);
                ge && (ce.activeTexture.set(de.TEXTURE0), de.bindTexture(de.TEXTURE_2D, ge.colorAttachment.get()), ce.activeTexture.set(de.TEXTURE1), qc(ce, le).bind(de.LINEAR, de.CLAMP_TO_EDGE), Q.useProgram("heatmapTexture").draw(ce, de.TRIANGLES, br.disabled, Rr.disabled, Q.colorModeForRenderPass(), xr.disabled, Ac(Q, le, 0, 1), null, null, le.id, Q.viewportBuffer, Q.quadTriangleIndexBuffer, Q.viewportSegments, le.paint, Q.transform.zoom));
              })(x, T);
            })(e, a, c, m, _) : s.ci(c) ? (function(x, k, T, R, A) {
              if (x.renderPass !== "translucent") return;
              const { isRenderingToTexture: N } = A, j = T.paint.get("line-opacity"), G = T.paint.get("line-width");
              if (j.constantOr(1) === 0 || G.constantOr(1) === 0) return;
              const Q = x.getDepthModeForSublayer(0, br.ReadOnly), le = x.colorModeForRenderPass(), ce = T.paint.get("line-dasharray"), de = ce.constantOr(1), ge = T.paint.get("line-pattern"), Se = ge.constantOr(1), me = T.paint.get("line-gradient"), ke = T.getCrossfadeParameters();
              let Re;
              Re = Se ? "linePattern" : de && me ? "lineGradientSDF" : de ? "lineSDF" : me ? "lineGradient" : "line";
              const ye = x.context, Be = ye.gl, Ke = x.transform;
              let He = true;
              for (const Ye of R) {
                const Qe = k.getTile(Ye);
                if (Se && !Qe.patternsLoaded()) continue;
                const Pt = Qe.getBucket(T);
                if (!Pt) continue;
                const Tt = Pt.programConfigurations.get(T.id), dt = x.context.program.get(), Nt = x.useProgram(Re, Tt), pr = He || Nt.program !== dt, Ur = x.style.map.terrain && x.style.map.terrain.getTerrainData(Ye), vr = ge.constantOr(null), Kr = ce && ce.constantOr(null);
                if (vr && Qe.imageAtlas) {
                  const Gi = Qe.imageAtlas, li = Gi.patternPositions[vr.to.toString()], Ti = Gi.patternPositions[vr.from.toString()];
                  li && Ti && Tt.setConstantPatternPositions(li, Ti);
                } else if (Kr) {
                  const Gi = T.layout.get("line-cap") === "round", li = x.lineAtlas.getDash(Kr.to, Gi), Ti = x.lineAtlas.getDash(Kr.from, Gi);
                  Tt.setConstantDashPositions(li, Ti);
                }
                const pi = Ke.getProjectionData({ overscaledTileID: Ye, applyGlobeMatrix: !N, applyTerrainMatrix: true }), Qr = Ke.getPixelScale();
                let Di;
                Se ? (Di = nu(x, Qe, T, Qr, ke), Wc(ye, Be, Qe, Tt, ke)) : de && me ? (Di = Hp(x, Qe, T, Qr, ke, Pt.lineClipsArray.length), yu(x, k, ye, Be, T, Pt, Ye, Tt, ke)) : de ? (Di = Zp(x, Qe, T, Qr, ke), Vh(x, ye, Be, Tt, pr, ke)) : me ? (Di = Wp(x, Qe, T, Qr, Pt.lineClipsArray.length), Uh(x, k, ye, Be, T, Pt, Ye)) : Di = da(x, Qe, T, Qr);
                const si = x.stencilModeForClipping(Ye);
                Nt.draw(ye, Be.TRIANGLES, Q, si, le, xr.disabled, Di, Ur, pi, T.id, Pt.layoutVertexBuffer, Pt.indexBuffer, Pt.segments, T.paint, x.transform.zoom, Tt, Pt.layoutVertexBuffer2), He = false;
              }
            })(e, a, c, m, _) : s.cj(c) ? (function(x, k, T, R, A) {
              const N = T.paint.get("fill-color"), j = T.paint.get("fill-opacity");
              if (j.constantOr(1) === 0) return;
              const { isRenderingToTexture: G } = A, Q = x.colorModeForRenderPass(), le = T.paint.get("fill-pattern"), ce = x.opaquePassEnabledForLayer() && !le.constantOr(1) && N.constantOr(s.bi.transparent).a === 1 && j.constantOr(0) === 1 ? "opaque" : "translucent";
              if (x.renderPass === ce) {
                const de = x.getDepthModeForSublayer(1, x.renderPass === "opaque" ? br.ReadWrite : br.ReadOnly);
                Gh(x, k, T, R, de, Q, false, G);
              }
              if (x.renderPass === "translucent" && T.paint.get("fill-antialias")) {
                const de = x.getDepthModeForSublayer(T.getPaintProperty("fill-outline-color") ? 2 : 0, br.ReadOnly);
                Gh(x, k, T, R, de, Q, true, G);
              }
            })(e, a, c, m, _) : s.ck(c) ? (function(x, k, T, R, A) {
              const N = T.paint.get("fill-extrusion-opacity");
              if (N === 0) return;
              const { isRenderingToTexture: j } = A;
              if (x.renderPass === "translucent") {
                const G = new br(x.context.gl.LEQUAL, br.ReadWrite, x.depthRangeFor3D);
                if (N !== 1 || T.paint.get("fill-extrusion-pattern").constantOr(1)) xu(x, k, T, R, G, Rr.disabled, zr.disabled, j), xu(x, k, T, R, G, x.stencilModeFor3D(), x.colorModeForRenderPass(), j);
                else {
                  const Q = x.colorModeForRenderPass();
                  xu(x, k, T, R, G, Rr.disabled, Q, j);
                }
              }
            })(e, a, c, m, _) : s.cl(c) ? (function(x, k, T, R, A) {
              if (x.renderPass !== "offscreen" && x.renderPass !== "translucent") return;
              const { isRenderingToTexture: N } = A, j = x.context, G = x.style.projection.useSubdivision, Q = x.getDepthModeForSublayer(0, br.ReadOnly), le = x.colorModeForRenderPass();
              if (x.renderPass === "offscreen") (function(ce, de, ge, Se, me, ke, Re) {
                const ye = ce.context, Be = ye.gl;
                for (const Ke of ge) {
                  const He = de.getTile(Ke), Ye = He.dem;
                  if (!Ye || !Ye.data || !He.needsHillshadePrepare) continue;
                  const Qe = Ye.dim, Pt = Ye.stride, Tt = Ye.getPixels();
                  if (ye.activeTexture.set(Be.TEXTURE1), ye.pixelStoreUnpackPremultiplyAlpha.set(false), He.demTexture = He.demTexture || ce.getTileTexture(Pt), He.demTexture) {
                    const Nt = He.demTexture;
                    Nt.update(Tt, { premultiply: false }), Nt.bind(Be.NEAREST, Be.CLAMP_TO_EDGE);
                  } else He.demTexture = new s.T(ye, Tt, Be.RGBA, { premultiply: false }), He.demTexture.bind(Be.NEAREST, Be.CLAMP_TO_EDGE);
                  ye.activeTexture.set(Be.TEXTURE0);
                  let dt = He.fbo;
                  if (!dt) {
                    const Nt = new s.T(ye, { width: Qe, height: Qe, data: null }, Be.RGBA);
                    Nt.bind(Be.LINEAR, Be.CLAMP_TO_EDGE), dt = He.fbo = ye.createFramebuffer(Qe, Qe, true, false), dt.colorAttachment.set(Nt.texture);
                  }
                  ye.bindFramebuffer.set(dt.framebuffer), ye.viewport.set([0, 0, Qe, Qe]), ce.useProgram("hillshadePrepare").draw(ye, Be.TRIANGLES, me, ke, Re, xr.disabled, Da(He.tileID, Ye), null, null, Se.id, ce.rasterBoundsBuffer, ce.quadTriangleIndexBuffer, ce.rasterBoundsSegments), He.needsHillshadePrepare = false;
                }
              })(x, k, R, T, Q, Rr.disabled, le), j.viewport.set([0, 0, x.width, x.height]);
              else if (x.renderPass === "translucent") if (G) {
                const [ce, de, ge] = x.stencilConfigForOverlapTwoPass(R);
                hi(x, k, T, ge, ce, Q, le, false, N), hi(x, k, T, ge, de, Q, le, true, N);
              } else {
                const [ce, de] = x.getStencilConfigForOverlapAndUpdateStencilID(R);
                hi(x, k, T, de, ce, Q, le, false, N);
              }
            })(e, a, c, m, _) : s.cm(c) ? (function(x, k, T, R, A) {
              if (x.renderPass !== "translucent" || !R.length) return;
              const { isRenderingToTexture: N } = A, j = x.style.projection.useSubdivision, G = x.getDepthModeForSublayer(0, br.ReadOnly), Q = x.colorModeForRenderPass();
              if (j) {
                const [le, ce, de] = x.stencilConfigForOverlapTwoPass(R);
                Oo(x, k, T, de, le, G, Q, false, N), Oo(x, k, T, de, ce, G, Q, true, N);
              } else {
                const [le, ce] = x.getStencilConfigForOverlapAndUpdateStencilID(R);
                Oo(x, k, T, ce, le, G, Q, false, N);
              }
            })(e, a, c, m, _) : s.bN(c) ? (function(x, k, T, R, A) {
              if (x.renderPass !== "translucent" || T.paint.get("raster-opacity") === 0 || !R.length) return;
              const { isRenderingToTexture: N } = A, j = k.getSource(), G = x.style.projection.useSubdivision;
              if (j instanceof rt) bs(x, k, T, R, null, false, false, j.tileCoords, j.flippedWindingOrder, N);
              else if (G) {
                const [Q, le, ce] = x.stencilConfigForOverlapTwoPass(R);
                bs(x, k, T, ce, Q, false, true, An, false, N), bs(x, k, T, ce, le, true, true, An, false, N);
              } else {
                const [Q, le] = x.getStencilConfigForOverlapAndUpdateStencilID(R);
                bs(x, k, T, le, Q, false, true, An, false, N);
              }
            })(e, a, c, m, _) : s.cn(c) ? (function(x, k, T, R, A) {
              const N = T.paint.get("background-color"), j = T.paint.get("background-opacity");
              if (j === 0) return;
              const { isRenderingToTexture: G } = A, Q = x.context, le = Q.gl, ce = x.style.projection, de = x.transform, ge = de.tileSize, Se = T.paint.get("background-pattern");
              if (x.isPatternMissing(Se)) return;
              const me = !Se && N.a === 1 && j === 1 && x.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (x.renderPass !== me) return;
              const ke = Rr.disabled, Re = x.getDepthModeForSublayer(0, me === "opaque" ? br.ReadWrite : br.ReadOnly), ye = x.colorModeForRenderPass(), Be = x.useProgram(Se ? "backgroundPattern" : "background"), Ke = R || jr(de, { tileSize: ge, terrain: x.style.map.terrain });
              Se && (Q.activeTexture.set(le.TEXTURE0), x.imageManager.bind(x.context));
              const He = T.getCrossfadeParameters();
              for (const Ye of Ke) {
                const Qe = de.getProjectionData({ overscaledTileID: Ye, applyGlobeMatrix: !G, applyTerrainMatrix: true }), Pt = Se ? Bc(j, x, Se, { tileID: Ye, tileSize: ge }, He) : Lc(j, N), Tt = x.style.map.terrain && x.style.map.terrain.getTerrainData(Ye), dt = ce.getMeshFromTileID(Q, Ye.canonical, false, true, "raster");
                Be.draw(Q, le.TRIANGLES, Re, ke, ye, xr.backCCW, Pt, Tt, Qe, T.id, dt.vertexBuffer, dt.indexBuffer, dt.segments);
              }
            })(e, 0, c, m, _) : s.co(c) && (function(x, k, T, R) {
              const { isRenderingGlobe: A } = R, N = x.context, j = T.implementation, G = x.style.projection, Q = x.transform, le = Q.getProjectionDataForCustomLayer(A), ce = { farZ: Q.farZ, nearZ: Q.nearZ, fov: Q.fov * Math.PI / 180, modelViewProjectionMatrix: Q.modelViewProjectionMatrix, projectionMatrix: Q.projectionMatrix, shaderData: { variantName: G.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${G.shaderPreludeCode.vertexSource}`, define: G.shaderDefine }, defaultProjectionData: le }, de = j.renderingMode ? j.renderingMode : "2d";
              if (x.renderPass === "offscreen") {
                const ge = j.prerender;
                ge && (x.setCustomLayerDefaults(), N.setColorMode(x.colorModeForRenderPass()), ge.call(j, N.gl, ce), N.setDirty(), x.setBaseState());
              } else if (x.renderPass === "translucent") {
                x.setCustomLayerDefaults(), N.setColorMode(x.colorModeForRenderPass()), N.setStencilMode(Rr.disabled);
                const ge = de === "3d" ? x.getDepthModeFor3D() : x.getDepthModeForSublayer(0, br.ReadOnly);
                N.setDepthMode(ge), j.render(N.gl, ce), N.setDirty(), x.setBaseState(), N.bindFramebuffer.set(null);
              }
            })(e, 0, c, _));
          }
          saveTileTexture(e) {
            const a = this._tileTextures[e.size[0]];
            a ? a.push(e) : this._tileTextures[e.size[0]] = [e];
          }
          getTileTexture(e) {
            const a = this._tileTextures[e];
            return a && a.length > 0 ? a.pop() : null;
          }
          isPatternMissing(e) {
            if (!e) return false;
            if (!e.from || !e.to) return true;
            const a = this.imageManager.getPattern(e.from.toString()), c = this.imageManager.getPattern(e.to.toString());
            return !a || !c;
          }
          useProgram(e, a, c = false, m = []) {
            this.cache = this.cache || {};
            const _ = !!this.style.map.terrain, x = this.style.projection, k = c ? fr.projectionMercator : x.shaderPreludeCode, T = c ? Rn : x.shaderDefine, R = e + (a ? a.cacheKey : "") + `/${c ? ln : x.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (_ ? "/terrain" : "") + (m ? `/${m.join("/")}` : "");
            return this.cache[R] || (this.cache[R] = new nl(this.context, fr[e], a, Eh[e], this._showOverdrawInspector, _, k, T, m)), this.cache[R];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const e = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new s.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            const { drawingBufferWidth: e, drawingBufferHeight: a } = this.context.gl;
            return this.width !== e || this.height !== a;
          }
        }
        function Jc(v, e) {
          let a, c = false, m = null, _ = null;
          const x = () => {
            m = null, c && (v.apply(_, a), m = setTimeout(x, e), c = false);
          };
          return (...k) => (c = true, _ = this, a = k, m || x(), m);
        }
        class Qc {
          constructor(e) {
            this._getCurrentHash = () => {
              const a = window.location.hash.replace("#", "");
              if (this._hashName) {
                let c;
                return a.split("&").map(((m) => m.split("="))).forEach(((m) => {
                  m[0] === this._hashName && (c = m);
                })), (c && c[1] || "").split("/");
              }
              return a.split("/");
            }, this._onHashChange = () => {
              const a = this._getCurrentHash();
              if (!this._isValidHash(a)) return false;
              const c = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(a[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+a[2], +a[1]], zoom: +a[0], bearing: c, pitch: +(a[4] || 0) }), true;
            }, this._updateHashUnthrottled = () => {
              const a = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, a);
            }, this._removeHash = () => {
              const a = this._getCurrentHash();
              if (a.length === 0) return;
              const c = a.join("/");
              let m = c;
              m.split("&").length > 0 && (m = m.split("&")[0]), this._hashName && (m = `${this._hashName}=${c}`);
              let _ = window.location.hash.replace(m, "");
              _.startsWith("#&") ? _ = _.slice(0, 1) + _.slice(2) : _ === "#" && (_ = "");
              let x = window.location.href.replace(/(#.+)?$/, _);
              x = x.replace("&&", "&"), window.history.replaceState(window.history.state, null, x);
            }, this._updateHash = Jc(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e);
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
          }
          getHashString(e) {
            const a = this._map.getCenter(), c = Math.round(100 * this._map.getZoom()) / 100, m = Math.ceil((c * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), _ = Math.pow(10, m), x = Math.round(a.lng * _) / _, k = Math.round(a.lat * _) / _, T = this._map.getBearing(), R = this._map.getPitch();
            let A = "";
            if (A += e ? `/${x}/${k}/${c}` : `${c}/${k}/${x}`, (T || R) && (A += "/" + Math.round(10 * T) / 10), R && (A += `/${Math.round(R)}`), this._hashName) {
              const N = this._hashName;
              let j = false;
              const G = window.location.hash.slice(1).split("&").map(((Q) => {
                const le = Q.split("=")[0];
                return le === N ? (j = true, `${le}=${A}`) : Q;
              })).filter(((Q) => Q));
              return j || G.push(`${N}=${A}`), `#${G.join("&")}`;
            }
            return `#${A}`;
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return false;
            try {
              new s.U(+e[2], +e[1]);
            } catch {
              return false;
            }
            const a = +e[0], c = +(e[3] || 0), m = +(e[4] || 0);
            return a >= this._map.getMinZoom() && a <= this._map.getMaxZoom() && c >= -180 && c <= 180 && m >= this._map.getMinPitch() && m <= this._map.getMaxPitch();
          }
        }
        const ws = { linearity: 0.3, easing: s.cp(0, 0, 0.3, 1) }, Hh = s.e({ deceleration: 2500, maxSpeed: 1400 }, ws), Xh = s.e({ deceleration: 20, maxSpeed: 1400 }, ws), Yh = s.e({ deceleration: 1e3, maxSpeed: 360 }, ws), Kh = s.e({ deceleration: 1e3, maxSpeed: 90 }, ws), Cu = s.e({ deceleration: 1e3, maxSpeed: 360 }, ws);
        class Jh {
          constructor(e) {
            this._map = e, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: z(), settings: e });
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer, a = z();
            for (; e.length > 0 && a - e[0].time > 160; ) e.shift();
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const a = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new s.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: _ } of this._inertiaBuffer) a.zoom += _.zoomDelta || 0, a.bearing += _.bearingDelta || 0, a.pitch += _.pitchDelta || 0, a.roll += _.rollDelta || 0, _.panDelta && a.pan._add(_.panDelta), _.around && (a.around = _.around), _.pinchAround && (a.pinchAround = _.pinchAround);
            const c = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, m = {};
            if (a.pan.mag()) {
              const _ = vn(a.pan.mag(), c, s.e({}, Hh, e || {})), x = a.pan.mult(_.amount / a.pan.mag()), k = this._map.cameraHelper.handlePanInertia(x, this._map.transform);
              m.center = k.easingCenter, m.offset = k.easingOffset, cn(m, _);
            }
            if (a.zoom) {
              const _ = vn(a.zoom, c, Xh);
              m.zoom = this._map.transform.zoom + _.amount, cn(m, _);
            }
            if (a.bearing) {
              const _ = vn(a.bearing, c, Yh);
              m.bearing = this._map.transform.bearing + s.ai(_.amount, -179, 179), cn(m, _);
            }
            if (a.pitch) {
              const _ = vn(a.pitch, c, Kh);
              m.pitch = this._map.transform.pitch + _.amount, cn(m, _);
            }
            if (a.roll) {
              const _ = vn(a.roll, c, Cu);
              m.roll = this._map.transform.roll + s.ai(_.amount, -179, 179), cn(m, _);
            }
            if (m.zoom || m.bearing) {
              const _ = a.pinchAround === void 0 ? a.around : a.pinchAround;
              m.around = _ ? this._map.unproject(_) : this._map.getCenter();
            }
            return this.clear(), s.e(m, { noMoveStart: true });
          }
        }
        function cn(v, e) {
          (!v.duration || v.duration < e.duration) && (v.duration = e.duration, v.easing = e.easing);
        }
        function vn(v, e, a) {
          const { maxSpeed: c, linearity: m, deceleration: _ } = a, x = s.ai(v * m / (e / 1e3), -c, c), k = Math.abs(x) / (_ * m);
          return { easing: a.easing, duration: 1e3 * k, amount: x * (k / 2) };
        }
        class Dn extends s.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, a, c, m = {}) {
            c = c instanceof MouseEvent ? c : new MouseEvent(e, c);
            const _ = F.mousePos(a.getCanvas(), c), x = a.unproject(_);
            super(e, s.e({ point: _, lngLat: x, originalEvent: c }, m)), this._defaultPrevented = false, this.target = a;
          }
        }
        class _n extends s.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, a, c) {
            const m = e === "touchend" ? c.changedTouches : c.touches, _ = F.touchPos(a.getCanvasContainer(), m), x = _.map(((T) => a.unproject(T))), k = _.reduce(((T, R, A, N) => T.add(R.div(N.length))), new s.P(0, 0));
            super(e, { points: _, point: k, lngLats: x, lngLat: a.unproject(k), originalEvent: c }), this._defaultPrevented = false;
          }
        }
        class Qh extends s.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, a, c) {
            super(e, { originalEvent: c }), this._defaultPrevented = false;
          }
        }
        class Cs {
          constructor(e, a) {
            this._map = e, this._clickTolerance = a.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(e) {
            return this._firePreventable(new Qh(e.type, this._map, e));
          }
          mousedown(e, a) {
            return this._mousedownPos = a, this._firePreventable(new Dn(e.type, this._map, e));
          }
          mouseup(e) {
            this._map.fire(new Dn(e.type, this._map, e));
          }
          click(e, a) {
            this._mousedownPos && this._mousedownPos.dist(a) >= this._clickTolerance || this._map.fire(new Dn(e.type, this._map, e));
          }
          dblclick(e) {
            return this._firePreventable(new Dn(e.type, this._map, e));
          }
          mouseover(e) {
            this._map.fire(new Dn(e.type, this._map, e));
          }
          mouseout(e) {
            this._map.fire(new Dn(e.type, this._map, e));
          }
          touchstart(e) {
            return this._firePreventable(new _n(e.type, this._map, e));
          }
          touchmove(e) {
            this._map.fire(new _n(e.type, this._map, e));
          }
          touchend(e) {
            this._map.fire(new _n(e.type, this._map, e));
          }
          touchcancel(e) {
            this._map.fire(new _n(e.type, this._map, e));
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class im {
          constructor(e) {
            this._map = e;
          }
          reset() {
            this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
          }
          mousemove(e) {
            this._map.fire(new Dn(e.type, this._map, e));
          }
          mousedown() {
            this._delayContextMenu = true, this._ignoreContextMenu = false;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new Dn("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new Dn(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class pl {
          constructor(e) {
            this._map = e;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(e) {
            return this.transform.screenPointToLocation(s.P.convert(e), this._map.terrain);
          }
        }
        class ef {
          constructor(e, a) {
            this._map = e, this._tr = new pl(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = a.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(e, a) {
            this.isEnabled() && e.shiftKey && e.button === 0 && (F.disableDrag(), this._startPos = this._lastPos = a, this._active = true);
          }
          mousemoveWindow(e, a) {
            if (!this._active) return;
            const c = a;
            if (this._lastPos.equals(c) || !this._box && c.dist(this._startPos) < this._clickTolerance) return;
            const m = this._startPos;
            this._lastPos = c, this._box || (this._box = F.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
            const _ = Math.min(m.x, c.x), x = Math.max(m.x, c.x), k = Math.min(m.y, c.y), T = Math.max(m.y, c.y);
            F.setTransform(this._box, `translate(${_}px,${k}px)`), this._box.style.width = x - _ + "px", this._box.style.height = T - k + "px";
          }
          mouseupWindow(e, a) {
            if (!this._active || e.button !== 0) return;
            const c = this._startPos, m = a;
            if (this.reset(), F.suppressClick(), c.x !== m.x || c.y !== m.y) return this._map.fire(new s.l("boxzoomend", { originalEvent: e })), { cameraAnimation: (_) => _.fitScreenCoordinates(c, m, this._tr.bearing, { linear: true }) };
            this._fireEvent("boxzoomcancel", e);
          }
          keydown(e) {
            this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e));
          }
          reset() {
            this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (F.remove(this._box), this._box = null), F.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(e, a) {
            return this._map.fire(new s.l(e, { originalEvent: a }));
          }
        }
        function ed(v, e) {
          if (v.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${v.length}, points ${e.length}`);
          const a = {};
          for (let c = 0; c < v.length; c++) a[v[c].identifier] = e[c];
          return a;
        }
        class tf {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
          }
          touchstart(e, a, c) {
            (this.centroid || c.length > this.numTouches) && (this.aborted = true), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), c.length === this.numTouches && (this.centroid = (function(m) {
              const _ = new s.P(0, 0);
              for (const x of m) _._add(x);
              return _.div(m.length);
            })(a), this.touches = ed(c, a)));
          }
          touchmove(e, a, c) {
            if (this.aborted || !this.centroid) return;
            const m = ed(c, a);
            for (const _ in this.touches) {
              const x = m[_];
              (!x || x.dist(this.touches[_]) > 30) && (this.aborted = true);
            }
          }
          touchend(e, a, c) {
            if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = true), c.length === 0) {
              const m = !this.aborted && this.centroid;
              if (this.reset(), m) return m;
            }
          }
        }
        class ja {
          constructor(e) {
            this.singleTap = new tf(e), this.numTaps = e.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(e, a, c) {
            this.singleTap.touchstart(e, a, c);
          }
          touchmove(e, a, c) {
            this.singleTap.touchmove(e, a, c);
          }
          touchend(e, a, c) {
            const m = this.singleTap.touchend(e, a, c);
            if (m) {
              const _ = e.timeStamp - this.lastTime < 500, x = !this.lastTap || this.lastTap.dist(m) < 30;
              if (_ && x || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = m, this.count === this.numTaps) return this.reset(), m;
            }
          }
        }
        class $o {
          constructor(e) {
            this._tr = new pl(e), this._zoomIn = new ja({ numTouches: 1, numTaps: 2 }), this._zoomOut = new ja({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(e, a, c) {
            this._zoomIn.touchstart(e, a, c), this._zoomOut.touchstart(e, a, c);
          }
          touchmove(e, a, c) {
            this._zoomIn.touchmove(e, a, c), this._zoomOut.touchmove(e, a, c);
          }
          touchend(e, a, c) {
            const m = this._zoomIn.touchend(e, a, c), _ = this._zoomOut.touchend(e, a, c), x = this._tr;
            return m ? (this._active = true, e.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (k) => k.easeTo({ duration: 300, zoom: x.zoom + 1, around: x.unproject(m) }, { originalEvent: e }) }) : _ ? (this._active = true, e.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (k) => k.easeTo({ duration: 300, zoom: x.zoom - 1, around: x.unproject(_) }, { originalEvent: e }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Dt {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset();
          }
          reset(e) {
            this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(e);
          }
          _move(...e) {
            const a = this._moveFunction(...e);
            if (a.bearingDelta || a.pitchDelta || a.rollDelta || a.around || a.panDelta) return this._active = true, a;
          }
          dragStart(e, a) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(a) ? a[0] : a, this._activateOnStart && this._lastPoint && (this._active = true));
          }
          dragMove(e, a) {
            if (!this.isEnabled()) return;
            const c = this._lastPoint;
            if (!c) return;
            if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
            const m = Array.isArray(a) ? a[0] : a;
            return !this._moved && m.dist(c) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = m, this._move(c, m));
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && F.suppressClick(), this.reset(e));
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const rf = 0, td = 2, nf = { [rf]: 1, [td]: 2 };
        class jo {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent;
          }
          startMove(e) {
            const a = F.mouseButton(e);
            this._eventButton = a;
          }
          endMove(e) {
            delete this._eventButton;
          }
          isValidStartEvent(e) {
            return this._correctEvent(e);
          }
          isValidMoveEvent(e) {
            return !(function(a, c) {
              const m = nf[c];
              return a.buttons === void 0 || (a.buttons & m) !== m;
            })(e, this._eventButton);
          }
          isValidEndEvent(e) {
            return F.mouseButton(e) === this._eventButton;
          }
        }
        class ml {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1;
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier;
          }
          endMove(e) {
            delete this._firstTouch;
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e);
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
        }
        class rd {
          constructor(e = new jo({ checkCorrectEvent: () => true }), a = new ml()) {
            this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = a;
          }
          _executeRelevantHandler(e, a, c) {
            return e instanceof MouseEvent ? a(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? c(e) : void 0;
          }
          startMove(e) {
            this._executeRelevantHandler(e, ((a) => this.mouseMoveStateManager.startMove(a)), ((a) => this.oneFingerTouchMoveStateManager.startMove(a)));
          }
          endMove(e) {
            this._executeRelevantHandler(e, ((a) => this.mouseMoveStateManager.endMove(a)), ((a) => this.oneFingerTouchMoveStateManager.endMove(a)));
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(e, ((a) => this.mouseMoveStateManager.isValidStartEvent(a)), ((a) => this.oneFingerTouchMoveStateManager.isValidStartEvent(a)));
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(e, ((a) => this.mouseMoveStateManager.isValidMoveEvent(a)), ((a) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(a)));
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(e, ((a) => this.mouseMoveStateManager.isValidEndEvent(a)), ((a) => this.oneFingerTouchMoveStateManager.isValidEndEvent(a)));
          }
        }
        const wr = (v) => {
          v.mousedown = v.dragStart, v.mousemoveWindow = v.dragMove, v.mouseup = v.dragEnd, v.contextmenu = (e) => {
            e.preventDefault();
          };
        };
        class id {
          constructor(e, a) {
            this._clickTolerance = e.clickTolerance || 1, this._map = a, this.reset();
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new s.P(0, 0);
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(e, a, c) {
            return this._calculateTransform(e, a, c);
          }
          touchmove(e, a, c) {
            if (this._active) {
              if (!this._shouldBePrevented(c.length)) return e.preventDefault(), this._calculateTransform(e, a, c);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e);
            }
          }
          touchend(e, a, c) {
            this._calculateTransform(e, a, c), this._active && this._shouldBePrevented(c.length) && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(e, a, c) {
            c.length > 0 && (this._active = true);
            const m = ed(c, a), _ = new s.P(0, 0), x = new s.P(0, 0);
            let k = 0;
            for (const R in m) {
              const A = m[R], N = this._touches[R];
              N && (_._add(A), x._add(A.sub(N)), k++, m[R] = A);
            }
            if (this._touches = m, this._shouldBePrevented(k) || !x.mag()) return;
            const T = x.div(k);
            return this._sum._add(T), this._sum.mag() < this._clickTolerance ? void 0 : { around: _.div(k), panDelta: T };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class nd {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, delete this._firstTwoTouches;
          }
          touchstart(e, a, c) {
            this._firstTwoTouches || c.length < 2 || (this._firstTwoTouches = [c[0].identifier, c[1].identifier], this._start([a[0], a[1]]));
          }
          touchmove(e, a, c) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [m, _] = this._firstTwoTouches, x = Ss(c, a, m), k = Ss(c, a, _);
            if (!x || !k) return;
            const T = this._aroundCenter ? null : x.add(k).div(2);
            return this._move([x, k], T, e);
          }
          touchend(e, a, c) {
            if (!this._firstTwoTouches) return;
            const [m, _] = this._firstTwoTouches, x = Ss(c, a, m), k = Ss(c, a, _);
            x && k || (this._active && F.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(e) {
            this._enabled = true, this._aroundCenter = !!e && e.around === "center";
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function Ss(v, e, a) {
          for (let c = 0; c < v.length; c++) if (v[c].identifier === a) return e[c];
        }
        function of(v, e) {
          return Math.log(v / e) / Math.LN2;
        }
        class af extends nd {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1]);
          }
          _move(e, a) {
            const c = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(of(this._distance, this._startDistance)) < 0.1)) return this._active = true, { zoomDelta: of(this._distance, c), pinchAround: a };
          }
        }
        function od(v, e) {
          return 180 * v.angleWith(e) / Math.PI;
        }
        class Su extends nd {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
          }
          _move(e, a, c) {
            const m = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = true, { bearingDelta: od(this._vector, m), pinchAround: a };
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const a = 25 / (Math.PI * this._minDiameter) * 360, c = od(e, this._startVector);
            return Math.abs(c) < a;
          }
        }
        function ku(v) {
          return Math.abs(v.y) > Math.abs(v.x);
        }
        class sf extends nd {
          constructor(e) {
            super(), this._currentTouchCount = 0, this._map = e;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(e, a, c) {
            super.touchstart(e, a, c), this._currentTouchCount = c.length;
          }
          _start(e) {
            this._lastPoints = e, ku(e[0].sub(e[1])) && (this._valid = false);
          }
          _move(e, a, c) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const m = e[0].sub(this._lastPoints[0]), _ = e[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(m, _, c.timeStamp), this._valid ? (this._lastPoints = e, this._active = true, { pitchDelta: (m.y + _.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(e, a, c) {
            if (this._valid !== void 0) return this._valid;
            const m = e.mag() >= 2, _ = a.mag() >= 2;
            if (!m && !_) return;
            if (!m || !_) return this._firstMove === void 0 && (this._firstMove = c), c - this._firstMove < 100 && void 0;
            const x = e.y > 0 == a.y > 0;
            return ku(e) && ku(a) && x;
          }
        }
        const lf = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class uf {
          constructor(e) {
            this._tr = new pl(e);
            const a = lf;
            this._panStep = a.panStep, this._bearingStep = a.bearingStep, this._pitchStep = a.pitchStep, this._rotationDisabled = false;
          }
          reset() {
            this._active = false;
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let a = 0, c = 0, m = 0, _ = 0, x = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                a = 1;
                break;
              case 189:
              case 109:
              case 173:
                a = -1;
                break;
              case 37:
                e.shiftKey ? c = -1 : (e.preventDefault(), _ = -1);
                break;
              case 39:
                e.shiftKey ? c = 1 : (e.preventDefault(), _ = 1);
                break;
              case 38:
                e.shiftKey ? m = 1 : (e.preventDefault(), x = -1);
                break;
              case 40:
                e.shiftKey ? m = -1 : (e.preventDefault(), x = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (c = 0, m = 0), { cameraAnimation: (k) => {
              const T = this._tr;
              k.easeTo({ duration: 300, easeId: "keyboardHandler", easing: nm, zoom: a ? Math.round(T.zoom) + a * (e.shiftKey ? 2 : 1) : T.zoom, bearing: T.bearing + c * this._bearingStep, pitch: T.pitch + m * this._pitchStep, offset: [-_ * this._panStep, -x * this._panStep], center: T.center }, { originalEvent: e });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function nm(v) {
          return v * (2 - v);
        }
        const No = 4.000244140625, Yr = 1 / 450;
        class cf {
          constructor(e, a) {
            this._onTimeout = (c) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(c);
            }, this._map = e, this._tr = new pl(e), this._triggerRenderFrame = a, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = Yr;
          }
          setZoomRate(e) {
            this._defaultZoomRate = e;
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(e) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e && e.around === "center");
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          _shouldBePrevented(e) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e));
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
            let a = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
            const c = z(), m = c - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = c, a !== 0 && a % No == 0 ? this._type = "wheel" : a !== 0 && Math.abs(a) < 4 ? this._type = "trackpad" : m > 400 ? (this._type = null, this._lastValue = a, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(m * a) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, a += this._lastValue)), e.shiftKey && a && (a /= 4), this._type && (this._lastWheelEvent = e, this._delta -= a, this._active || this._start(e)), e.preventDefault();
          }
          _start(e) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const a = F.mousePos(this._map.getCanvas(), e), c = this._tr;
            this._aroundPoint = this._aroundCenter ? c.transform.locationToScreenPoint(s.U.convert(c.center)) : a, this._frameId || (this._frameId = true, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const k = e.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += k), typeof this._targetZoom == "number" && (this._targetZoom += k);
            }
            if (this._delta !== 0) {
              const k = this._type === "wheel" && Math.abs(this._delta) > No ? this._wheelZoomRate : this._defaultZoomRate;
              let T = 2 / (1 + Math.exp(-Math.abs(this._delta * k)));
              this._delta < 0 && T !== 0 && (T = 1 / T);
              const R = typeof this._targetZoom != "number" ? e.scale : s.al(this._targetZoom);
              this._targetZoom = e.constrain(e.getCameraLngLat(), s.ao(R * T)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const a = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom, c = this._startZoom, m = this._easing;
            let _, x = false;
            if (this._type === "wheel" && c && m) {
              const k = z() - this._lastWheelEventTime, T = Math.min((k + 5) / 200, 1), R = m(T);
              _ = s.F.number(c, a, R), T < 1 ? this._frameId || (this._frameId = true) : x = true;
            } else _ = a, x = true;
            return this._active = true, x && (this._active = false, this._finishTimeout = setTimeout((() => {
              this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
            }), 200)), this._lastExpectedZoom = _, { noInertia: true, needsRenderFrame: !x, zoomDelta: _ - e.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(e) {
            let a = s.cr;
            if (this._prevEase) {
              const c = this._prevEase, m = (z() - c.start) / c.duration, _ = c.easing(m + 0.01) - c.easing(m), x = 0.27 / Math.sqrt(_ * _ + 1e-4) * 0.01, k = Math.sqrt(0.0729 - x * x);
              a = s.cp(x, k, 0.25, 1);
            }
            return this._prevEase = { start: z(), duration: e, easing: a }, a;
          }
          reset() {
            this._active = false, this._zooming = false, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class gl {
          constructor(e, a) {
            this._clickZoom = e, this._tapZoom = a;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class ad {
          constructor(e) {
            this._tr = new pl(e), this.reset();
          }
          reset() {
            this._active = false;
          }
          dblclick(e, a) {
            return e.preventDefault(), { cameraAnimation: (c) => {
              c.easeTo({ duration: 300, zoom: this._tr.zoom + (e.shiftKey ? -1 : 1), around: this._tr.unproject(a) }, { originalEvent: e });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class df {
          constructor() {
            this._tap = new ja({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(e, a, c) {
            if (!this._swipePoint) if (this._tapTime) {
              const m = a[0], _ = e.timeStamp - this._tapTime < 500, x = this._tapPoint.dist(m) < 30;
              _ && x ? c.length > 0 && (this._swipePoint = m, this._swipeTouch = c[0].identifier) : this.reset();
            } else this._tap.touchstart(e, a, c);
          }
          touchmove(e, a, c) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (c[0].identifier !== this._swipeTouch) return;
                const m = a[0], _ = m.y - this._swipePoint.y;
                return this._swipePoint = m, e.preventDefault(), this._active = true, { zoomDelta: _ / 128 };
              }
            } else this._tap.touchmove(e, a, c);
          }
          touchend(e, a, c) {
            if (this._tapTime) this._swipePoint && c.length === 0 && this.reset();
            else {
              const m = this._tap.touchend(e, a, c);
              m && (this._tapTime = e.timeStamp, this._tapPoint = m);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class sd {
          constructor(e, a, c) {
            this._el = e, this._mousePan = a, this._touchPan = c;
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class ld {
          constructor(e, a, c, m) {
            this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = a, this._mousePitch = c, this._mouseRoll = m;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
          }
        }
        class hf {
          constructor(e, a, c, m) {
            this._el = e, this._touchZoom = a, this._touchRotate = c, this._tapDragZoom = m, this._rotationDisabled = false, this._enabled = true;
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class lo {
          constructor(e, a) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = a, this._enabled = false;
          }
          isActive() {
            return false;
          }
          reset() {
          }
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            e.classList.add("maplibregl-cooperative-gestures"), this._container = F.create("div", "maplibregl-cooperative-gesture-screen", e);
            let a = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (a = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const c = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), m = document.createElement("div");
            m.className = "maplibregl-desktop-message", m.textContent = a, this._container.appendChild(m);
            const _ = document.createElement("div");
            _.className = "maplibregl-mobile-message", _.textContent = c, this._container.appendChild(_), this._container.setAttribute("aria-hidden", "true");
          }
          _destroyUI() {
            this._container && (F.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = true;
          }
          disable() {
            this._enabled = false, this._destroyUI();
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(e) {
            return e[this._bypassKey];
          }
          notifyGestureBlocked(e, a) {
            this._enabled && (this._map.fire(new s.l("cooperativegestureprevented", { gestureType: e, originalEvent: a })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show");
            }), 100));
          }
        }
        const Na = (v) => v.zoom || v.drag || v.roll || v.pitch || v.rotate;
        class qt extends s.l {
        }
        function er(v) {
          return v.panDelta && v.panDelta.mag() || v.zoomDelta || v.bearingDelta || v.pitchDelta || v.rollDelta;
        }
        class vl {
          constructor(e, a) {
            this.handleWindowEvent = (m) => {
              this.handleEvent(m, `${m.type}Window`);
            }, this.handleEvent = (m, _) => {
              if (m.type === "blur") return void this.stop(true);
              this._updatingCamera = true;
              const x = m.type === "renderFrame" ? void 0 : m, k = { needsRenderFrame: false }, T = {}, R = {};
              for (const { handlerName: j, handler: G, allowed: Q } of this._handlers) {
                if (!G.isEnabled()) continue;
                let le;
                if (this._blockedByActive(R, Q, j)) G.reset();
                else if (G[_ || m.type]) {
                  if (s.cs(m, _ || m.type)) {
                    const ce = F.mousePos(this._map.getCanvas(), m);
                    le = G[_ || m.type](m, ce);
                  } else if (s.ct(m, _ || m.type)) {
                    const ce = this._getMapTouches(m.touches), de = F.touchPos(this._map.getCanvas(), ce);
                    le = G[_ || m.type](m, de, ce);
                  } else s.cu(_ || m.type) || (le = G[_ || m.type](m));
                  this.mergeHandlerResult(k, T, le, j, x), le && le.needsRenderFrame && this._triggerRenderFrame();
                }
                (le || G.isActive()) && (R[j] = G);
              }
              const A = {};
              for (const j in this._previousActiveHandlers) R[j] || (A[j] = x);
              this._previousActiveHandlers = R, (Object.keys(A).length || er(k)) && (this._changes.push([k, T, A]), this._triggerRenderFrame()), (Object.keys(R).length || er(k)) && this._map._stop(true), this._updatingCamera = false;
              const { cameraAnimation: N } = k;
              N && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], N(this._map));
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Jh(e), this._bearingSnap = a.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(a);
            const c = this._el;
            this._listeners = [[c, "touchstart", { passive: true }], [c, "touchmove", { passive: false }], [c, "touchend", void 0], [c, "touchcancel", void 0], [c, "mousedown", void 0], [c, "mousemove", void 0], [c, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [c, "mouseover", void 0], [c, "mouseout", void 0], [c, "dblclick", void 0], [c, "click", void 0], [c, "keydown", { capture: false }], [c, "keyup", void 0], [c, "wheel", { passive: false }], [c, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [m, _, x] of this._listeners) F.addEventListener(m, _, m === document ? this.handleWindowEvent : this.handleEvent, x);
          }
          destroy() {
            for (const [e, a, c] of this._listeners) F.removeEventListener(e, a, e === document ? this.handleWindowEvent : this.handleEvent, c);
          }
          _addDefaultHandlers(e) {
            const a = this._map, c = a.getCanvasContainer();
            this._add("mapEvent", new Cs(a, e));
            const m = a.boxZoom = new ef(a, e);
            this._add("boxZoom", m), e.interactive && e.boxZoom && m.enable();
            const _ = a.cooperativeGestures = new lo(a, e.cooperativeGestures);
            this._add("cooperativeGestures", _), e.cooperativeGestures && _.enable();
            const x = new $o(a), k = new ad(a);
            a.doubleClickZoom = new gl(k, x), this._add("tapZoom", x), this._add("clickZoom", k), e.interactive && e.doubleClickZoom && a.doubleClickZoom.enable();
            const T = new df();
            this._add("tapDragZoom", T);
            const R = a.touchPitch = new sf(a);
            this._add("touchPitch", R), e.interactive && e.touchPitch && a.touchPitch.enable(e.touchPitch);
            const A = () => a.project(a.getCenter()), N = (function({ enable: me, clickTolerance: ke, aroundCenter: Re = true, minPixelCenterThreshold: ye = 100, rotateDegreesPerPixelMoved: Be = 0.8 }, Ke) {
              const He = new jo({ checkCorrectEvent: (Ye) => F.mouseButton(Ye) === 0 && Ye.ctrlKey || F.mouseButton(Ye) === 2 && !Ye.ctrlKey });
              return new Dt({ clickTolerance: ke, move: (Ye, Qe) => {
                const Pt = Ke();
                if (Re && Math.abs(Pt.y - Ye.y) > ye) return { bearingDelta: s.cq(new s.P(Ye.x, Qe.y), Qe, Pt) };
                let Tt = (Qe.x - Ye.x) * Be;
                return Re && Qe.y < Pt.y && (Tt = -Tt), { bearingDelta: Tt };
              }, moveStateManager: He, enable: me, assignEvents: wr });
            })(e, A), j = (function({ enable: me, clickTolerance: ke, pitchDegreesPerPixelMoved: Re = -0.5 }) {
              const ye = new jo({ checkCorrectEvent: (Be) => F.mouseButton(Be) === 0 && Be.ctrlKey || F.mouseButton(Be) === 2 });
              return new Dt({ clickTolerance: ke, move: (Be, Ke) => ({ pitchDelta: (Ke.y - Be.y) * Re }), moveStateManager: ye, enable: me, assignEvents: wr });
            })(e), G = (function({ enable: me, clickTolerance: ke, rollDegreesPerPixelMoved: Re = 0.3 }, ye) {
              const Be = new jo({ checkCorrectEvent: (Ke) => F.mouseButton(Ke) === 2 && Ke.ctrlKey });
              return new Dt({ clickTolerance: ke, move: (Ke, He) => {
                const Ye = ye();
                let Qe = (He.x - Ke.x) * Re;
                return He.y < Ye.y && (Qe = -Qe), { rollDelta: Qe };
              }, moveStateManager: Be, enable: me, assignEvents: wr });
            })(e, A);
            a.dragRotate = new ld(e, N, j, G), this._add("mouseRotate", N, ["mousePitch"]), this._add("mousePitch", j, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", G, ["mousePitch"]), e.interactive && e.dragRotate && a.dragRotate.enable();
            const Q = (function({ enable: me, clickTolerance: ke }) {
              const Re = new jo({ checkCorrectEvent: (ye) => F.mouseButton(ye) === 0 && !ye.ctrlKey });
              return new Dt({ clickTolerance: ke, move: (ye, Be) => ({ around: Be, panDelta: Be.sub(ye) }), activateOnStart: true, moveStateManager: Re, enable: me, assignEvents: wr });
            })(e), le = new id(e, a);
            a.dragPan = new sd(c, Q, le), this._add("mousePan", Q), this._add("touchPan", le, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && a.dragPan.enable(e.dragPan);
            const ce = new Su(), de = new af();
            a.touchZoomRotate = new hf(c, de, ce, T), this._add("touchRotate", ce, ["touchPan", "touchZoom"]), this._add("touchZoom", de, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && a.touchZoomRotate.enable(e.touchZoomRotate), this._add("blockableMapEvent", new im(a));
            const ge = a.scrollZoom = new cf(a, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", ge, ["mousePan"]), e.interactive && e.scrollZoom && a.scrollZoom.enable(e.scrollZoom);
            const Se = a.keyboard = new uf(a);
            this._add("keyboard", Se), e.interactive && e.keyboard && a.keyboard.enable();
          }
          _add(e, a, c) {
            this._handlers.push({ handlerName: e, handler: a, allowed: c }), this._handlersById[e] = a;
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const { handler: a } of this._handlers) a.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: e } of this._handlers) if (e.isActive()) return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!Na(this._eventsInProgress) || this.isZooming();
          }
          _blockedByActive(e, a, c) {
            for (const m in e) if (m !== c && (!a || a.indexOf(m) < 0)) return true;
            return false;
          }
          _getMapTouches(e) {
            const a = [];
            for (const c of e) this._el.contains(c.target) && a.push(c);
            return a;
          }
          mergeHandlerResult(e, a, c, m, _) {
            if (!c) return;
            s.e(e, c);
            const x = { handlerName: m, originalEvent: c.originalEvent || _ };
            c.zoomDelta !== void 0 && (a.zoom = x), c.panDelta !== void 0 && (a.drag = x), c.rollDelta !== void 0 && (a.roll = x), c.pitchDelta !== void 0 && (a.pitch = x), c.bearingDelta !== void 0 && (a.rotate = x);
          }
          _applyChanges() {
            const e = {}, a = {}, c = {};
            for (const [m, _, x] of this._changes) m.panDelta && (e.panDelta = (e.panDelta || new s.P(0, 0))._add(m.panDelta)), m.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + m.zoomDelta), m.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + m.bearingDelta), m.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + m.pitchDelta), m.rollDelta && (e.rollDelta = (e.rollDelta || 0) + m.rollDelta), m.around !== void 0 && (e.around = m.around), m.pinchAround !== void 0 && (e.pinchAround = m.pinchAround), m.noInertia && (e.noInertia = m.noInertia), s.e(a, _), s.e(c, x);
            this._updateMapTransform(e, a, c), this._changes = [];
          }
          _updateMapTransform(e, a, c) {
            const m = this._map, _ = m._getTransformForUpdate(), x = m.terrain;
            if (!(er(e) || x && this._terrainMovement)) return this._fireEvents(a, c, true);
            m._stop(true);
            let { panDelta: k, zoomDelta: T, bearingDelta: R, pitchDelta: A, rollDelta: N, around: j, pinchAround: G } = e;
            G !== void 0 && (j = G), j = j || m.transform.centerPoint, x && !_.isPointOnMapSurface(j) && (j = _.centerPoint);
            const Q = { panDelta: k, zoomDelta: T, rollDelta: N, pitchDelta: A, bearingDelta: R, around: j };
            this._map.cameraHelper.useGlobeControls && !_.isPointOnMapSurface(j) && (j = _.centerPoint);
            const le = j.distSqr(_.centerPoint) < 0.01 ? _.center : _.screenPointToLocation(k ? j.sub(k) : j);
            this._handleMapControls({ terrain: x, tr: _, deltasForHelper: Q, preZoomAroundLoc: le, combinedEventsInProgress: a, panDelta: k }), m._applyUpdatedTransform(_), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(a, c, true);
          }
          _handleMapControls({ terrain: e, tr: a, deltasForHelper: c, preZoomAroundLoc: m, combinedEventsInProgress: _, panDelta: x }) {
            const k = this._map.cameraHelper;
            if (k.handleMapControlsRollPitchBearingZoom(c, a), e) return k.useGlobeControls ? (this._terrainMovement || !_.drag && !_.zoom || (this._terrainMovement = true, this._map._elevationFreeze = true), void k.handleMapControlsPan(c, a, m)) : this._terrainMovement || !_.drag && !_.zoom ? void (_.drag && this._terrainMovement && x ? a.setCenter(a.screenPointToLocation(a.centerPoint.sub(x))) : k.handleMapControlsPan(c, a, m)) : (this._terrainMovement = true, this._map._elevationFreeze = true, void k.handleMapControlsPan(c, a, m));
            k.handleMapControlsPan(c, a, m);
          }
          _fireEvents(e, a, c) {
            const m = Na(this._eventsInProgress), _ = Na(e), x = {};
            for (const N in e) {
              const { originalEvent: j } = e[N];
              this._eventsInProgress[N] || (x[`${N}start`] = j), this._eventsInProgress[N] = e[N];
            }
            !m && _ && this._fireEvent("movestart", _.originalEvent);
            for (const N in x) this._fireEvent(N, x[N]);
            _ && this._fireEvent("move", _.originalEvent);
            for (const N in e) {
              const { originalEvent: j } = e[N];
              this._fireEvent(N, j);
            }
            const k = {};
            let T;
            for (const N in this._eventsInProgress) {
              const { handlerName: j, originalEvent: G } = this._eventsInProgress[N];
              this._handlersById[j].isActive() || (delete this._eventsInProgress[N], T = a[j] || G, k[`${N}end`] = T);
            }
            for (const N in k) this._fireEvent(N, k[N]);
            const R = Na(this._eventsInProgress), A = (m || _) && !R;
            if (A && this._terrainMovement) {
              this._map._elevationFreeze = false, this._terrainMovement = false;
              const N = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && N.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(N);
            }
            if (c && A) {
              this._updatingCamera = true;
              const N = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), j = (G) => G !== 0 && -this._bearingSnap < G && G < this._bearingSnap;
              !N || !N.essential && L.prefersReducedMotion ? (this._map.fire(new s.l("moveend", { originalEvent: T })), j(this._map.getBearing()) && this._map.resetNorth()) : (j(N.bearing || this._map.getBearing()) && (N.bearing = 0), N.freezeElevation = true, this._map.easeTo(N, { originalEvent: T })), this._updatingCamera = false;
            }
          }
          _fireEvent(e, a) {
            this._map.fire(new s.l(e, a ? { originalEvent: a } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add(((e) => {
              delete this._frameId, this.handleEvent(new qt("renderFrame", { timeStamp: e })), this._applyChanges();
            }));
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        class ff extends s.E {
          constructor(e, a, c) {
            super(), this._renderFrameCallback = () => {
              const m = Math.min((z() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(m)), m < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = false, this._zooming = false, this.transform = e, this._bearingSnap = c.bearingSnap, this.cameraHelper = a, this.on("moveend", (() => {
              delete this._requestedCameraState;
            }));
          }
          migrateProjection(e, a) {
            e.apply(this.transform), this.transform = e, this.cameraHelper = a;
          }
          getCenter() {
            return new s.U(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(e, a) {
            return this.jumpTo({ center: e }, a);
          }
          getCenterElevation() {
            return this.transform.elevation;
          }
          setCenterElevation(e, a) {
            return this.jumpTo({ elevation: e }, a), this;
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround;
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e;
          }
          panBy(e, a, c) {
            return e = s.P.convert(e).mult(-1), this.panTo(this.transform.center, s.e({ offset: e }, a), c);
          }
          panTo(e, a, c) {
            return this.easeTo(s.e({ center: e }, a), c);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(e, a) {
            return this.jumpTo({ zoom: e }, a), this;
          }
          zoomTo(e, a, c) {
            return this.easeTo(s.e({ zoom: e }, a), c);
          }
          zoomIn(e, a) {
            return this.zoomTo(this.getZoom() + 1, e, a), this;
          }
          zoomOut(e, a) {
            return this.zoomTo(this.getZoom() - 1, e, a), this;
          }
          getVerticalFieldOfView() {
            return this.transform.fov;
          }
          setVerticalFieldOfView(e, a) {
            return e != this.transform.fov && (this.transform.setFov(e), this.fire(new s.l("movestart", a)).fire(new s.l("move", a)).fire(new s.l("moveend", a))), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(e, a) {
            return this.jumpTo({ bearing: e }, a), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(e, a) {
            return this.jumpTo({ padding: e }, a), this;
          }
          rotateTo(e, a, c) {
            return this.easeTo(s.e({ bearing: e }, a), c);
          }
          resetNorth(e, a) {
            return this.rotateTo(0, s.e({ duration: 1e3 }, e), a), this;
          }
          resetNorthPitch(e, a) {
            return this.easeTo(s.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e), a), this;
          }
          snapToNorth(e, a) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, a) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(e, a) {
            return this.jumpTo({ pitch: e }, a), this;
          }
          getRoll() {
            return this.transform.roll;
          }
          setRoll(e, a) {
            return this.jumpTo({ roll: e }, a), this;
          }
          cameraForBounds(e, a) {
            e = nr.convert(e).adjustAntiMeridian();
            const c = a && a.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), c, a);
          }
          _cameraForBoxAndBearing(e, a, c, m) {
            const _ = { top: 0, bottom: 0, right: 0, left: 0 };
            if (typeof (m = s.e({ padding: _, offset: [0, 0], maxZoom: this.transform.maxZoom }, m)).padding == "number") {
              const R = m.padding;
              m.padding = { top: R, bottom: R, right: R, left: R };
            }
            const x = s.e(_, m.padding);
            m.padding = x;
            const k = this.transform, T = new nr(e, a);
            return this.cameraHelper.cameraForBoxAndBearing(m, x, T, c, k);
          }
          fitBounds(e, a, c) {
            return this._fitInternal(this.cameraForBounds(e, a), a, c);
          }
          fitScreenCoordinates(e, a, c, m, _) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(s.P.convert(e)), this.transform.screenPointToLocation(s.P.convert(a)), c, m), m, _);
          }
          _fitInternal(e, a, c) {
            return e ? (delete (a = s.e(e, a)).padding, a.linear ? this.easeTo(a, c) : this.flyTo(a, c)) : this;
          }
          jumpTo(e, a) {
            this.stop();
            const c = this._getTransformForUpdate();
            let m = false, _ = false, x = false;
            const k = c.zoom;
            this.cameraHelper.handleJumpToCenterZoom(c, e);
            const T = c.zoom !== k;
            return "elevation" in e && c.elevation !== +e.elevation && c.setElevation(+e.elevation), "bearing" in e && c.bearing !== +e.bearing && (m = true, c.setBearing(+e.bearing)), "pitch" in e && c.pitch !== +e.pitch && (_ = true, c.setPitch(+e.pitch)), "roll" in e && c.roll !== +e.roll && (x = true, c.setRoll(+e.roll)), e.padding == null || c.isPaddingEqual(e.padding) || c.setPadding(e.padding), this._applyUpdatedTransform(c), this.fire(new s.l("movestart", a)).fire(new s.l("move", a)), T && this.fire(new s.l("zoomstart", a)).fire(new s.l("zoom", a)).fire(new s.l("zoomend", a)), m && this.fire(new s.l("rotatestart", a)).fire(new s.l("rotate", a)).fire(new s.l("rotateend", a)), _ && this.fire(new s.l("pitchstart", a)).fire(new s.l("pitch", a)).fire(new s.l("pitchend", a)), x && this.fire(new s.l("rollstart", a)).fire(new s.l("roll", a)).fire(new s.l("rollend", a)), this.fire(new s.l("moveend", a));
          }
          calculateCameraOptionsFromTo(e, a, c, m = 0) {
            const _ = s.a5.fromLngLat(e, a), x = s.a5.fromLngLat(c, m), k = x.x - _.x, T = x.y - _.y, R = x.z - _.z, A = Math.hypot(k, T, R);
            if (A === 0) throw new Error("Can't calculate camera options with same From and To");
            const N = Math.hypot(k, T), j = s.ao(this.transform.cameraToCenterDistance / A / this.transform.tileSize), G = 180 * Math.atan2(k, -T) / Math.PI;
            let Q = 180 * Math.acos(N / A) / Math.PI;
            return Q = R < 0 ? 90 - Q : 90 + Q, { center: x.toLngLat(), elevation: m, zoom: j, pitch: Q, bearing: G };
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, a, c, m, _) {
            const x = this.transform.calculateCenterFromCameraLngLatAlt(e, a, c, m);
            return { center: x.center, elevation: x.elevation, zoom: x.zoom, bearing: c, pitch: m, roll: _ };
          }
          easeTo(e, a) {
            this._stop(false, e.easeId), ((e = s.e({ offset: [0, 0], duration: 500, easing: s.cr }, e)).animate === false || !e.essential && L.prefersReducedMotion) && (e.duration = 0);
            const c = this._getTransformForUpdate(), m = this.getBearing(), _ = c.pitch, x = c.roll, k = "bearing" in e ? this._normalizeBearing(e.bearing, m) : m, T = "pitch" in e ? +e.pitch : _, R = "roll" in e ? this._normalizeBearing(e.roll, x) : x, A = "padding" in e ? e.padding : c.padding, N = s.P.convert(e.offset);
            let j, G;
            e.around && (j = s.U.convert(e.around), G = c.locationToScreenPoint(j));
            const Q = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, le = this.cameraHelper.handleEaseTo(c, { bearing: k, pitch: T, roll: R, padding: A, around: j, aroundPoint: G, offsetAsPoint: N, offset: e.offset, zoom: e.zoom, center: e.center });
            return this._rotating = this._rotating || m !== k, this._pitching = this._pitching || T !== _, this._rolling = this._rolling || R !== x, this._padding = !c.isPaddingEqual(A), this._zooming = this._zooming || le.isZooming, this._easeId = e.easeId, this._prepareEase(a, e.noMoveStart, Q), this.terrain && this._prepareElevation(le.elevationCenter), this._ease(((ce) => {
              le.easeFunc(ce), this.terrain && !e.freezeElevation && this._updateElevation(ce), this._applyUpdatedTransform(c), this._fireMoveEvents(a);
            }), ((ce) => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(a, ce);
            }), e), this;
          }
          _prepareEase(e, a, c = {}) {
            this._moving = true, a || c.moving || this.fire(new s.l("movestart", e)), this._zooming && !c.zooming && this.fire(new s.l("zoomstart", e)), this._rotating && !c.rotating && this.fire(new s.l("rotatestart", e)), this._pitching && !c.pitching && this.fire(new s.l("pitchstart", e)), this._rolling && !c.rolling && this.fire(new s.l("rollstart", e));
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = true;
          }
          _updateElevation(e) {
            this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const a = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e < 1 && a !== this._elevationTarget) {
              const c = this._elevationTarget - this._elevationStart;
              this._elevationStart += e * (c - (a - (c * e + this._elevationStart)) / (1 - e)), this._elevationTarget = a;
            }
            this.transform.setElevation(s.F.number(this._elevationStart, this._elevationTarget, e));
          }
          _finalizeElevation() {
            this._elevationFreeze = false, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const a = e.getCameraLngLat(), c = e.getCameraAltitude(), m = this.terrain ? this.terrain.getElevationForLngLatZoom(a, e.zoom) : 0;
            if (c < m) {
              const _ = this.calculateCameraOptionsFromTo(a, m, e.center, e.elevation);
              return { pitch: _.pitch, zoom: _.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(e) {
            const a = [];
            if (a.push(((m) => this._elevateCameraIfInsideTerrain(m))), this.transformCameraUpdate && a.push(((m) => this.transformCameraUpdate(m))), !a.length) return;
            const c = e.clone();
            for (const m of a) {
              const _ = c.clone(), { center: x, zoom: k, roll: T, pitch: R, bearing: A, elevation: N } = m(_);
              x && _.setCenter(x), N !== void 0 && _.setElevation(N), k !== void 0 && _.setZoom(k), T !== void 0 && _.setRoll(T), R !== void 0 && _.setPitch(R), A !== void 0 && _.setBearing(A), c.apply(_);
            }
            this.transform.apply(c);
          }
          _fireMoveEvents(e) {
            this.fire(new s.l("move", e)), this._zooming && this.fire(new s.l("zoom", e)), this._rotating && this.fire(new s.l("rotate", e)), this._pitching && this.fire(new s.l("pitch", e)), this._rolling && this.fire(new s.l("roll", e));
          }
          _afterEase(e, a) {
            if (this._easeId && a && this._easeId === a) return;
            delete this._easeId;
            const c = this._zooming, m = this._rotating, _ = this._pitching, x = this._rolling;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._rolling = false, this._padding = false, c && this.fire(new s.l("zoomend", e)), m && this.fire(new s.l("rotateend", e)), _ && this.fire(new s.l("pitchend", e)), x && this.fire(new s.l("rollend", e)), this.fire(new s.l("moveend", e));
          }
          flyTo(e, a) {
            if (!e.essential && L.prefersReducedMotion) {
              const Qe = s.S(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation", "padding"]);
              return this.jumpTo(Qe, a);
            }
            this.stop(), e = s.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: s.cr }, e);
            const c = this._getTransformForUpdate(), m = c.bearing, _ = c.pitch, x = c.roll, k = c.padding, T = "bearing" in e ? this._normalizeBearing(e.bearing, m) : m, R = "pitch" in e ? +e.pitch : _, A = "roll" in e ? this._normalizeBearing(e.roll, x) : x, N = "padding" in e ? e.padding : c.padding, j = s.P.convert(e.offset);
            let G = c.centerPoint.add(j);
            const Q = c.screenPointToLocation(G), le = this.cameraHelper.handleFlyTo(c, { bearing: T, pitch: R, roll: A, padding: N, locationAtOffset: Q, offsetAsPoint: j, center: e.center, minZoom: e.minZoom, zoom: e.zoom });
            let ce = e.curve;
            const de = Math.max(c.width, c.height), ge = de / le.scaleOfZoom, Se = le.pixelPathLength;
            typeof le.scaleOfMinZoom == "number" && (ce = Math.sqrt(de / le.scaleOfMinZoom / Se * 2));
            const me = ce * ce;
            function ke(Qe) {
              const Pt = (ge * ge - de * de + (Qe ? -1 : 1) * me * me * Se * Se) / (2 * (Qe ? ge : de) * me * Se);
              return Math.log(Math.sqrt(Pt * Pt + 1) - Pt);
            }
            function Re(Qe) {
              return (Math.exp(Qe) - Math.exp(-Qe)) / 2;
            }
            function ye(Qe) {
              return (Math.exp(Qe) + Math.exp(-Qe)) / 2;
            }
            const Be = ke(false);
            let Ke = function(Qe) {
              return ye(Be) / ye(Be + ce * Qe);
            }, He = function(Qe) {
              return de * ((ye(Be) * (Re(Pt = Be + ce * Qe) / ye(Pt)) - Re(Be)) / me) / Se;
              var Pt;
            }, Ye = (ke(true) - Be) / ce;
            if (Math.abs(Se) < 2e-6 || !isFinite(Ye)) {
              if (Math.abs(de - ge) < 1e-6) return this.easeTo(e, a);
              const Qe = ge < de ? -1 : 1;
              Ye = Math.abs(Math.log(ge / de)) / ce, He = () => 0, Ke = (Pt) => Math.exp(Qe * ce * Pt);
            }
            return e.duration = "duration" in e ? +e.duration : 1e3 * Ye / ("screenSpeed" in e ? +e.screenSpeed / ce : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = true, this._rotating = m !== T, this._pitching = R !== _, this._rolling = A !== x, this._padding = !c.isPaddingEqual(N), this._prepareEase(a, false), this.terrain && this._prepareElevation(le.targetCenter), this._ease(((Qe) => {
              const Pt = Qe * Ye, Tt = 1 / Ke(Pt), dt = He(Pt);
              this._rotating && c.setBearing(s.F.number(m, T, Qe)), this._pitching && c.setPitch(s.F.number(_, R, Qe)), this._rolling && c.setRoll(s.F.number(x, A, Qe)), this._padding && (c.interpolatePadding(k, N, Qe), G = c.centerPoint.add(j)), le.easeFunc(Qe, Tt, dt, G), this.terrain && !e.freezeElevation && this._updateElevation(Qe), this._applyUpdatedTransform(c), this._fireMoveEvents(a);
            }), (() => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(a);
            }), e), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(e, a) {
            var c;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const m = this._onEaseEnd;
              delete this._onEaseEnd, m.call(this, a);
            }
            return e || (c = this.handlers) === null || c === void 0 || c.stop(false), this;
          }
          _ease(e, a, c) {
            c.animate === false || c.duration === 0 ? (e(1), a()) : (this._easeStart = z(), this._easeOptions = c, this._onEaseFrame = e, this._onEaseEnd = a, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(e, a) {
            e = s.V(e, -180, 180);
            const c = Math.abs(e - a);
            return Math.abs(e - 360 - a) < c && (e -= 360), Math.abs(e + 360 - a) < c && (e += 360), e;
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(s.U.convert(e), this.transform.tileZoom) : null;
          }
        }
        const _l = { compact: true, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class dn {
          constructor(e = _l) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (a) => {
              !a || a.sourceDataType !== "metadata" && a.sourceDataType !== "visibility" && a.dataType !== "style" && a.type !== "terrain" || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === false ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = e;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options.compact, this._container = F.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = F.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = F.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            F.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(e, a) {
            const c = this._map._getUIString(`AttributionControl.${a}`);
            e.title = c, e.setAttribute("aria-label", c);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map(((m) => typeof m != "string" ? "" : m))) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const m = this._map.style.stylesheet;
              this.styleOwner = m.owner, this.styleId = m.id;
            }
            const a = this._map.style.tileManagers;
            for (const m in a) {
              const _ = a[m];
              if (_.used || _.usedForTerrain) {
                const x = _.getSource();
                x.attribution && e.indexOf(x.attribution) < 0 && e.push(x.attribution);
              }
            }
            e = e.filter(((m) => String(m).trim())), e.sort(((m, _) => m.length - _.length)), e = e.filter(((m, _) => {
              for (let x = _ + 1; x < e.length; x++) if (e[x].indexOf(m) >= 0) return false;
              return true;
            }));
            const c = e.join(" | ");
            c !== this._attribHTML && (this._attribHTML = c, e.length ? (this._innerContainer.innerHTML = F.sanitize(c), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class ud {
          constructor(e = {}) {
            this._updateCompact = () => {
              const a = this._container.children;
              if (a.length) {
                const c = a[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== false && c.classList.add("maplibregl-compact") : c.classList.remove("maplibregl-compact");
              }
            }, this.options = e;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = F.create("div", "maplibregl-ctrl");
            const a = F.create("a", "maplibregl-ctrl-logo");
            return a.target = "_blank", a.rel = "noopener nofollow", a.href = "https://maplibre.org/", a.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), a.setAttribute("rel", "noopener nofollow"), this._container.appendChild(a), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            F.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class uo {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(e) {
            const a = ++this._id;
            return this._queue.push({ callback: e, id: a, cancelled: false }), a;
          }
          remove(e) {
            const a = this._currentlyRunning, c = a ? this._queue.concat(a) : this._queue;
            for (const m of c) if (m.id === e) return void (m.cancelled = true);
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const a = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const c of a) if (!c.cancelled && (c.callback(e), this._cleared)) break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        var pf = s.aN([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class om extends s.E {
          constructor(e) {
            super(), this._lastTilesetChange = z(), this.tileManager = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = true, e.tileSize = this.tileSize;
          }
          destruct() {
            this.tileManager.usedForTerrain = false, this.tileManager.tileSize = null;
          }
          getSource() {
            return this.tileManager._source;
          }
          update(e, a) {
            this.tileManager.update(e, a), this._renderableTilesKeys = [];
            const c = {};
            for (const m of jr(e, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: a, calculateTileZoom: this.tileManager._source.calculateTileZoom })) c[m.key] = true, this._renderableTilesKeys.push(m.key), this._tiles[m.key] || (m.terrainRttPosMatrix32f = new Float64Array(16), s.c0(m.terrainRttPosMatrix32f, 0, s.a3, s.a3, 0, 0, 1), this._tiles[m.key] = new Ce(m, this.tileSize), this._lastTilesetChange = z());
            for (const m in this._tiles) c[m] || delete this._tiles[m];
          }
          freeRtt(e) {
            for (const a in this._tiles) {
              const c = this._tiles[a];
              (!e || c.tileID.equals(e) || c.tileID.isChildOf(e) || e.isChildOf(c.tileID)) && (c.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map(((e) => this.getTileByID(e)));
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          getTerrainCoords(e, a) {
            return a ? this._getTerrainCoordsForTileRanges(e, a) : this._getTerrainCoordsForRegularTile(e);
          }
          _getTerrainCoordsForRegularTile(e) {
            const a = {};
            for (const c of this._renderableTilesKeys) {
              const m = this._tiles[c].tileID, _ = e.clone(), x = s.bd();
              if (m.canonical.equals(e.canonical)) s.c0(x, 0, s.a3, s.a3, 0, 0, 1);
              else if (m.canonical.isChildOf(e.canonical)) {
                const k = m.canonical.z - e.canonical.z, T = m.canonical.x - (m.canonical.x >> k << k), R = m.canonical.y - (m.canonical.y >> k << k), A = s.a3 >> k;
                s.c0(x, 0, A, A, 0, 0, 1), s.N(x, x, [-T * A, -R * A, 0]);
              } else {
                if (!e.canonical.isChildOf(m.canonical)) continue;
                {
                  const k = e.canonical.z - m.canonical.z, T = e.canonical.x - (e.canonical.x >> k << k), R = e.canonical.y - (e.canonical.y >> k << k), A = s.a3 >> k;
                  s.c0(x, 0, s.a3, s.a3, 0, 0, 1), s.N(x, x, [T * A, R * A, 0]), s.O(x, x, [1 / 2 ** k, 1 / 2 ** k, 0]);
                }
              }
              _.terrainRttPosMatrix32f = new Float32Array(x), a[c] = _;
            }
            return a;
          }
          _getTerrainCoordsForTileRanges(e, a) {
            const c = {};
            for (const m of this._renderableTilesKeys) {
              const _ = this._tiles[m].tileID;
              if (!this._isWithinTileRanges(_, a)) continue;
              const x = e.clone(), k = s.bd();
              if (_.canonical.z === e.canonical.z) {
                const T = e.canonical.x - _.canonical.x, R = e.canonical.y - _.canonical.y;
                s.c0(k, 0, s.a3, s.a3, 0, 0, 1), s.N(k, k, [T * s.a3, R * s.a3, 0]);
              } else if (_.canonical.z > e.canonical.z) {
                const T = _.canonical.z - e.canonical.z, R = _.canonical.x - (_.canonical.x >> T << T), A = _.canonical.y - (_.canonical.y >> T << T), N = e.canonical.x - (_.canonical.x >> T), j = e.canonical.y - (_.canonical.y >> T), G = s.a3 >> T;
                s.c0(k, 0, G, G, 0, 0, 1), s.N(k, k, [-R * G + N * s.a3, -A * G + j * s.a3, 0]);
              } else {
                const T = e.canonical.z - _.canonical.z, R = e.canonical.x - (e.canonical.x >> T << T), A = e.canonical.y - (e.canonical.y >> T << T), N = (e.canonical.x >> T) - _.canonical.x, j = (e.canonical.y >> T) - _.canonical.y, G = s.a3 << T;
                s.c0(k, 0, G, G, 0, 0, 1), s.N(k, k, [R * s.a3 + N * G, A * s.a3 + j * G, 0]);
              }
              x.terrainRttPosMatrix32f = new Float32Array(k), c[m] = x;
            }
            return c;
          }
          getSourceTile(e, a) {
            const c = this.tileManager._source;
            let m = e.overscaledZ - this.deltaZoom;
            if (m > c.maxzoom && (m = c.maxzoom), m < c.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(m).key);
            let _ = this.tileManager.getTileByID(this._sourceTileCache[e.key]);
            if ((!_ || !_.dem) && a) for (; m >= c.minzoom && (!_ || !_.dem); ) _ = this.tileManager.getTileByID(e.scaledTo(m--).key);
            return _;
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e;
          }
          _isWithinTileRanges(e, a) {
            return a[e.canonical.z] && e.canonical.x >= a[e.canonical.z].minTileX && e.canonical.x <= a[e.canonical.z].maxTileX && e.canonical.y >= a[e.canonical.z].minTileY && e.canonical.y <= a[e.canonical.z].maxTileY;
          }
        }
        class am {
          constructor(e, a, c) {
            this._meshCache = {}, this.painter = e, this.tileManager = new om(a), this.options = c, this.exaggeration = typeof c.exaggeration == "number" ? c.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(e, a, c, m = s.a3) {
            var _;
            if (!(a >= 0 && a < m && c >= 0 && c < m)) return 0;
            const x = this.getTerrainData(e), k = (_ = x.tile) === null || _ === void 0 ? void 0 : _.dem;
            if (!k) return 0;
            const T = s.cv([], [a / m * s.a3, c / m * s.a3], x.u_terrain_matrix), R = [T[0] * k.dim, T[1] * k.dim], A = Math.floor(R[0]), N = Math.floor(R[1]), j = R[0] - A, G = R[1] - N;
            return k.get(A, N) * (1 - j) * (1 - G) + k.get(A + 1, N) * j * (1 - G) + k.get(A, N + 1) * (1 - j) * G + k.get(A + 1, N + 1) * j * G;
          }
          getElevationForLngLatZoom(e, a) {
            if (!s.cw(a, e.wrap())) return 0;
            const { tileID: c, mercatorX: m, mercatorY: _ } = this._getOverscaledTileIDFromLngLatZoom(e, a);
            return this.getElevation(c, m % s.a3, _ % s.a3, s.a3);
          }
          getElevation(e, a, c, m = s.a3) {
            return this.getDEMElevation(e, a, c, m) * this.exaggeration;
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const m = this.painter.context, _ = new s.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new s.T(m, _, m.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new s.T(m, new s.R({ width: 1, height: 1 }), m.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(m.gl.NEAREST, m.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = s.am([]);
            }
            const a = this.tileManager.getSourceTile(e, true);
            if (a && a.dem && (!a.demTexture || a.needsTerrainPrepare)) {
              const m = this.painter.context;
              a.demTexture = this.painter.getTileTexture(a.dem.stride), a.demTexture ? a.demTexture.update(a.dem.getPixels(), { premultiply: false }) : a.demTexture = new s.T(m, a.dem.getPixels(), m.gl.RGBA, { premultiply: false }), a.demTexture.bind(m.gl.NEAREST, m.gl.CLAMP_TO_EDGE), a.needsTerrainPrepare = false;
            }
            const c = a && a + a.tileID.key + e.key;
            if (c && !this._demMatrixCache[c]) {
              const m = this.tileManager.getSource().maxzoom;
              let _ = e.canonical.z - a.tileID.canonical.z;
              e.overscaledZ > e.canonical.z && (e.canonical.z >= m ? _ = e.canonical.z - m : s.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const x = e.canonical.x - (e.canonical.x >> _ << _), k = e.canonical.y - (e.canonical.y >> _ << _), T = s.cx(new Float64Array(16), [1 / (s.a3 << _), 1 / (s.a3 << _), 0]);
              s.N(T, T, [x * s.a3, k * s.a3, 0]), this._demMatrixCache[e.key] = { matrix: T, coord: e };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: a && a.dem && a.dem.dim || 1, u_terrain_matrix: c ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix, u_terrain_unpack: a && a.dem && a.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (a && a.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: a };
          }
          getFramebuffer(e) {
            const a = this.painter, c = a.width / devicePixelRatio, m = a.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === c && this._fbo.height === m || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new s.T(a.context, { width: c, height: m, data: null }, a.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(a.context.gl.NEAREST, a.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new s.T(a.context, { width: c, height: m, data: null }, a.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(a.context.gl.NEAREST, a.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = a.context.createFramebuffer(c, m, true, false), this._fbo.depthAttachment.set(a.context.createRenderbuffer(a.context.gl.DEPTH_COMPONENT16, c, m))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const a = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let _ = 0, x = 0; _ < this._coordsTextureSize; _++) for (let k = 0; k < this._coordsTextureSize; k++, x += 4) a[x + 0] = 255 & k, a[x + 1] = 255 & _, a[x + 2] = k >> 8 << 4 | _ >> 8, a[x + 3] = 0;
            const c = new s.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(a.buffer)), m = new s.T(e, c, e.gl.RGBA, { premultiply: false });
            return m.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = m, m;
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(true);
            const a = new Uint8Array(4), c = this.painter.context, m = c.gl, _ = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio), x = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio), k = Math.round(this.painter.height / devicePixelRatio);
            c.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), m.readPixels(_, k - x - 1, 1, 1, m.RGBA, m.UNSIGNED_BYTE, a), c.bindFramebuffer.set(null);
            const T = a[0] + (a[2] >> 4 << 8), R = a[1] + ((15 & a[2]) << 8), A = this.coordsIndex[255 - a[3]], N = A && this.tileManager.getTileByID(A);
            if (!N) return null;
            const j = this._coordsTextureSize, G = (1 << N.tileID.canonical.z) * j;
            return new s.a5((N.tileID.canonical.x * j + T) / G + N.tileID.wrap, (N.tileID.canonical.y * j + R) / G, this.getElevation(N.tileID, T, R, j));
          }
          depthAtPoint(e) {
            const a = new Uint8Array(4), c = this.painter.context, m = c.gl;
            return c.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), m.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, m.RGBA, m.UNSIGNED_BYTE, a), c.bindFramebuffer.set(null), (a[0] / 16777216 + a[1] / 65536 + a[2] / 256 + a[3]) / 256;
          }
          getTerrainMesh(e) {
            var a;
            const c = ((a = this.painter.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0, m = c && e.canonical.y === 0, _ = c && e.canonical.y === (1 << e.canonical.z) - 1, x = `m_${m ? "n" : ""}_${_ ? "s" : ""}`;
            if (this._meshCache[x]) return this._meshCache[x];
            const k = this.painter.context, T = new s.cy(), R = new s.aR(), A = this.meshSize, N = s.a3 / A, j = A * A;
            for (let ye = 0; ye <= A; ye++) for (let Be = 0; Be <= A; Be++) T.emplaceBack(Be * N, ye * N, 0);
            for (let ye = 0; ye < j; ye += A + 1) for (let Be = 0; Be < A; Be++) R.emplaceBack(Be + ye, A + Be + ye + 1, A + Be + ye + 2), R.emplaceBack(Be + ye, A + Be + ye + 2, Be + ye + 1);
            const G = T.length, Q = G + (A + 1), le = (A + 1) * A, ce = m ? s.bk : 0, de = m ? 0 : 1, ge = _ ? s.bl : s.a3, Se = _ ? 0 : 1;
            for (let ye = 0; ye <= A; ye++) T.emplaceBack(ye * N, ce, de);
            for (let ye = 0; ye <= A; ye++) T.emplaceBack(ye * N, ge, Se);
            for (let ye = 0; ye < A; ye++) R.emplaceBack(le + ye, Q + ye, Q + ye + 1), R.emplaceBack(le + ye, Q + ye + 1, le + ye + 1), R.emplaceBack(0 + ye, G + ye + 1, G + ye), R.emplaceBack(0 + ye, 0 + ye + 1, G + ye + 1);
            const me = T.length, ke = me + 2 * (A + 1);
            for (const ye of [0, 1]) for (let Be = 0; Be <= A; Be++) for (const Ke of [0, 1]) T.emplaceBack(ye * s.a3, Be * N, Ke);
            for (let ye = 0; ye < 2 * A; ye += 2) R.emplaceBack(me + ye, me + ye + 1, me + ye + 3), R.emplaceBack(me + ye, me + ye + 3, me + ye + 2), R.emplaceBack(ke + ye, ke + ye + 3, ke + ye + 1), R.emplaceBack(ke + ye, ke + ye + 2, ke + ye + 3);
            const Re = new ds(k.createVertexBuffer(T, pf.members), k.createIndexBuffer(R), s.aQ.simpleSegment(0, 0, T.length, R.length));
            return this._meshCache[x] = Re, Re;
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * s.bx / Math.pow(2, Math.max(e, 0)) / 5;
          }
          getMinTileElevationForLngLatZoom(e, a) {
            var c;
            const { tileID: m } = this._getOverscaledTileIDFromLngLatZoom(e, a);
            return (c = this.getMinMaxElevation(m).minElevation) !== null && c !== void 0 ? c : 0;
          }
          getMinMaxElevation(e) {
            const a = this.getTerrainData(e).tile, c = { minElevation: null, maxElevation: null };
            return a && a.dem && (c.minElevation = a.dem.min * this.exaggeration, c.maxElevation = a.dem.max * this.exaggeration), c;
          }
          _getOverscaledTileIDFromLngLatZoom(e, a) {
            const c = s.a5.fromLngLat(e.wrap()), m = (1 << a) * s.a3, _ = c.x * m, x = c.y * m, k = Math.floor(_ / s.a3), T = Math.floor(x / s.a3);
            return { tileID: new s.a0(a, 0, a, k, T), mercatorX: _, mercatorY: x };
          }
        }
        class sm {
          constructor(e, a, c) {
            this._context = e, this._size = a, this._tileSize = c, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy();
          }
          _createObject(e) {
            const a = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), c = new s.T(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return c.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), a.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), a.colorAttachment.set(c.texture), { id: e, fbo: a, texture: c, stamp: -1, inUse: false };
          }
          getObjectForId(e) {
            return this._objects[e];
          }
          useObject(e) {
            e.inUse = true, this._recentlyUsed = this._recentlyUsed.filter(((a) => e.id !== a)), this._recentlyUsed.push(e.id);
          }
          stampObject(e) {
            e.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const a of this._recentlyUsed) if (!this._objects[a].inUse) return this._objects[a];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e = this._createObject(this._objects.length);
            return this._objects.push(e), e;
          }
          freeObject(e) {
            e.inUse = false;
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e);
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some(((e) => !e.inUse)) === false;
          }
        }
        const Po = { background: true, fill: true, line: true, raster: true, hillshade: true, "color-relief": true };
        class fi {
          constructor(e, a) {
            this.painter = e, this.terrain = a, this.pool = new sm(e.context, 30, a.tileManager.tileSize * a.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(e, a) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.tileManager.getRenderableTiles(), this._renderableLayerIds = e._order.filter(((c) => !e._layers[c].isHidden(a))), this._coordsAscending = {};
            for (const c in e.tileManagers) {
              this._coordsAscending[c] = {};
              const m = e.tileManagers[c].getVisibleCoordinates(), _ = e.tileManagers[c].getSource(), x = _ instanceof rt ? _.terrainTileRanges : null;
              for (const k of m) {
                const T = this.terrain.tileManager.getTerrainCoords(k, x);
                for (const R in T) this._coordsAscending[c][R] || (this._coordsAscending[c][R] = []), this._coordsAscending[c][R].push(T[R]);
              }
            }
            this._coordsAscendingStr = {};
            for (const c of e._order) {
              const m = e._layers[c], _ = m.source;
              if (Po[m.type] && !this._coordsAscendingStr[_]) {
                this._coordsAscendingStr[_] = {};
                for (const x in this._coordsAscending[_]) this._coordsAscendingStr[_][x] = this._coordsAscending[_][x].map(((k) => k.key)).sort().join();
              }
            }
            for (const c of this._renderableTiles) for (const m in this._coordsAscendingStr) {
              const _ = this._coordsAscendingStr[m][c.tileID.key];
              _ && _ !== c.rttCoords[m] && (c.rtt = []);
            }
          }
          renderLayer(e, a) {
            if (e.isHidden(this.painter.transform.zoom)) return false;
            const c = Object.assign(Object.assign({}, a), { isRenderingToTexture: true }), m = e.type, _ = this.painter, x = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
            if (Po[m] && (this._prevType && Po[this._prevType] || this._stacks.push([]), this._prevType = m, this._stacks[this._stacks.length - 1].push(e.id), !x)) return true;
            if (Po[this._prevType] || Po[m] && x) {
              this._prevType = m;
              const k = this._stacks.length - 1, T = this._stacks[k] || [];
              for (const R of this._renderableTiles) {
                if (this.pool.isFull() && (Kc(this.painter, this.terrain, this._rttTiles, c), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(R), R.rtt[k]) {
                  const N = this.pool.getObjectForId(R.rtt[k].id);
                  if (N.stamp === R.rtt[k].stamp) {
                    this.pool.useObject(N);
                    continue;
                  }
                }
                const A = this.pool.getOrCreateFreeObject();
                this.pool.useObject(A), this.pool.stampObject(A), R.rtt[k] = { id: A.id, stamp: A.stamp }, _.context.bindFramebuffer.set(A.fbo.framebuffer), _.context.clear({ color: s.bi.transparent, stencil: 0 }), _.currentStencilSource = void 0;
                for (let N = 0; N < T.length; N++) {
                  const j = _.style._layers[T[N]], G = j.source ? this._coordsAscending[j.source][R.tileID.key] : [R.tileID];
                  _.context.viewport.set([0, 0, A.fbo.width, A.fbo.height]), _._renderTileClippingMasks(j, G, true), _.renderLayer(_, _.style.tileManagers[j.source], j, G, c), j.source && (R.rttCoords[j.source] = this._coordsAscendingStr[j.source][R.tileID.key]);
                }
              }
              return Kc(this.painter, this.terrain, this._rttTiles, c), this._rttTiles = [], this.pool.freeAllObjects(), Po[m];
            }
            return false;
          }
        }
        const Ci = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use \u2318 + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, mf = C, ks = { hash: false, interactive: true, bearingSnap: 7, attributionControl: _l, maplibreLogo: false, refreshExpiredTiles: true, canvasContextAttributes: { antialias: false, preserveDrawingBuffer: false, powerPreference: "high-performance", failIfMajorPerformanceCaveat: false, desynchronized: false, contextType: void 0 }, scrollZoom: true, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, trackResize: true, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: true, maxTileCacheSize: null, maxTileCacheZoomLevels: s.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, transformConstrain: null, fadeDuration: 300, crossSourceCollisions: true, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: true, rollEnabled: false, validateStyle: true, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: true, centerClampedToGround: true }, Pu = { showCompass: true, showZoom: true, visualizePitch: false, visualizeRoll: true };
        class cd {
          constructor(e, a, c = false) {
            this.mousedown = (_) => {
              this.startMove(_, F.mousePos(this.element, _)), F.addEventListener(window, "mousemove", this.mousemove), F.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (_) => {
              this.move(_, F.mousePos(this.element, _));
            }, this.mouseup = (_) => {
              this._rotatePitchHandler.dragEnd(_), this.offTemp();
            }, this.touchstart = (_) => {
              _.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = F.touchPos(this.element, _.targetTouches)[0], this.startMove(_, this._startPos), F.addEventListener(window, "touchmove", this.touchmove, { passive: false }), F.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (_) => {
              _.targetTouches.length !== 1 ? this.reset() : (this._lastPos = F.touchPos(this.element, _.targetTouches)[0], this.move(_, this._lastPos));
            }, this.touchend = (_) => {
              _.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10, this.element = a;
            const m = new rd();
            this._rotatePitchHandler = new Dt({ clickTolerance: 3, move: (_, x) => {
              const k = a.getBoundingClientRect(), T = new s.P((k.bottom - k.top) / 2, (k.right - k.left) / 2);
              return { bearingDelta: s.cq(new s.P(_.x, x.y), x, T), pitchDelta: c ? -0.5 * (x.y - _.y) : void 0 };
            }, moveStateManager: m, enable: true, assignEvents: () => {
            } }), this.map = e, F.addEventListener(a, "mousedown", this.mousedown), F.addEventListener(a, "touchstart", this.touchstart, { passive: false }), F.addEventListener(a, "touchcancel", this.reset);
          }
          startMove(e, a) {
            this._rotatePitchHandler.dragStart(e, a), F.disableDrag();
          }
          move(e, a) {
            const c = this.map, { bearingDelta: m, pitchDelta: _ } = this._rotatePitchHandler.dragMove(e, a) || {};
            m && c.setBearing(c.getBearing() + m), _ && c.setPitch(c.getPitch() + _);
          }
          off() {
            const e = this.element;
            F.removeEventListener(e, "mousedown", this.mousedown), F.removeEventListener(e, "touchstart", this.touchstart, { passive: false }), F.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), F.removeEventListener(window, "touchend", this.touchend), F.removeEventListener(e, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            F.enableDrag(), F.removeEventListener(window, "mousemove", this.mousemove), F.removeEventListener(window, "mouseup", this.mouseup), F.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), F.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let Vo;
        function Tu(v, e, a, c = false) {
          if (c || !a.getCoveringTilesDetailsProvider().allowWorldCopies()) return v == null ? void 0 : v.wrap();
          const m = new s.U(v.lng, v.lat);
          if (v = new s.U(v.lng, v.lat), e) {
            const _ = new s.U(v.lng - 360, v.lat), x = new s.U(v.lng + 360, v.lat), k = a.locationToScreenPoint(v).distSqr(e);
            a.locationToScreenPoint(_).distSqr(e) < k ? v = _ : a.locationToScreenPoint(x).distSqr(e) < k && (v = x);
          }
          for (; Math.abs(v.lng - a.center.lng) > 180; ) {
            const _ = a.locationToScreenPoint(v);
            if (_.x >= 0 && _.y >= 0 && _.x <= a.width && _.y <= a.height) break;
            v.lng > a.center.lng ? v.lng -= 360 : v.lng += 360;
          }
          return v.lng !== m.lng && a.isPointOnMapSurface(a.locationToScreenPoint(v)) ? v : m;
        }
        const Va = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function Iu(v, e, a) {
          const c = v.classList;
          for (const m in Va) c.remove(`maplibregl-${a}-anchor-${m}`);
          c.add(`maplibregl-${a}-anchor-${e}`);
        }
        class yl extends s.E {
          constructor(e) {
            if (super(), this._onKeyPress = (a) => {
              const c = a.code, m = a.charCode || a.keyCode;
              c !== "Space" && c !== "Enter" && m !== 32 && m !== 13 || this.togglePopup();
            }, this._onMapClick = (a) => {
              const c = a.originalEvent.target, m = this._element;
              this._popup && (c === m || m.contains(c)) && this.togglePopup();
            }, this._update = (a) => {
              if (!this._map) return;
              const c = this._map.loaded() && !this._map.isMoving();
              ((a == null ? void 0 : a.type) === "terrain" || (a == null ? void 0 : a.type) === "render" && !c) && this._map.once("render", this._update), this._lngLat = Tu(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
              let m = "";
              this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? m = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (m = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let _ = "";
              this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? _ = "rotateX(0deg)" : this._pitchAlignment === "map" && (_ = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || a && a.type !== "moveend" || (this._pos = this._pos.round()), F.setTransform(this._element, `${Va[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${_} ${m}`), L.frameAsync(new AbortController()).then((() => {
                this._updateOpacity(a && a.type === "moveend");
              })).catch((() => {
              }));
            }, this._onMove = (a) => {
              if (!this._isDragging) {
                const c = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = a.point.dist(this._pointerdownPos) >= c;
              }
              this._isDragging && (this._pos = a.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new s.l("dragstart"))), this.fire(new s.l("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new s.l("dragend")), this._state = "inactive";
            }, this._addDragHandler = (a) => {
              this._element.contains(a.originalEvent.target) && (a.preventDefault(), this._positionDelta = a.point.sub(this._pos).add(this._offset), this._pointerdownPos = a.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || false, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || false, this._isDragging = false, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = s.P.convert(e && e.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = F.create("div");
              const a = F.createNS("http://www.w3.org/2000/svg", "svg"), c = 41, m = 27;
              a.setAttributeNS(null, "display", "block"), a.setAttributeNS(null, "height", `${c}px`), a.setAttributeNS(null, "width", `${m}px`), a.setAttributeNS(null, "viewBox", `0 0 ${m} ${c}`);
              const _ = F.createNS("http://www.w3.org/2000/svg", "g");
              _.setAttributeNS(null, "stroke", "none"), _.setAttributeNS(null, "stroke-width", "1"), _.setAttributeNS(null, "fill", "none"), _.setAttributeNS(null, "fill-rule", "evenodd");
              const x = F.createNS("http://www.w3.org/2000/svg", "g");
              x.setAttributeNS(null, "fill-rule", "nonzero");
              const k = F.createNS("http://www.w3.org/2000/svg", "g");
              k.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), k.setAttributeNS(null, "fill", "#000000");
              const T = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const de of T) {
                const ge = F.createNS("http://www.w3.org/2000/svg", "ellipse");
                ge.setAttributeNS(null, "opacity", "0.04"), ge.setAttributeNS(null, "cx", "10.5"), ge.setAttributeNS(null, "cy", "5.80029008"), ge.setAttributeNS(null, "rx", de.rx), ge.setAttributeNS(null, "ry", de.ry), k.appendChild(ge);
              }
              const R = F.createNS("http://www.w3.org/2000/svg", "g");
              R.setAttributeNS(null, "fill", this._color);
              const A = F.createNS("http://www.w3.org/2000/svg", "path");
              A.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), R.appendChild(A);
              const N = F.createNS("http://www.w3.org/2000/svg", "g");
              N.setAttributeNS(null, "opacity", "0.25"), N.setAttributeNS(null, "fill", "#000000");
              const j = F.createNS("http://www.w3.org/2000/svg", "path");
              j.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), N.appendChild(j);
              const G = F.createNS("http://www.w3.org/2000/svg", "g");
              G.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), G.setAttributeNS(null, "fill", "#FFFFFF");
              const Q = F.createNS("http://www.w3.org/2000/svg", "g");
              Q.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const le = F.createNS("http://www.w3.org/2000/svg", "circle");
              le.setAttributeNS(null, "fill", "#000000"), le.setAttributeNS(null, "opacity", "0.25"), le.setAttributeNS(null, "cx", "5.5"), le.setAttributeNS(null, "cy", "5.5"), le.setAttributeNS(null, "r", "5.4999962");
              const ce = F.createNS("http://www.w3.org/2000/svg", "circle");
              ce.setAttributeNS(null, "fill", "#FFFFFF"), ce.setAttributeNS(null, "cx", "5.5"), ce.setAttributeNS(null, "cy", "5.5"), ce.setAttributeNS(null, "r", "5.4999962"), Q.appendChild(le), Q.appendChild(ce), x.appendChild(k), x.appendChild(R), x.appendChild(N), x.appendChild(G), x.appendChild(Q), a.appendChild(x), a.setAttributeNS(null, "height", c * this._scale + "px"), a.setAttributeNS(null, "width", m * this._scale + "px"), this._element.appendChild(a), this._offset = s.P.convert(e && e.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", ((a) => {
              a.preventDefault();
            })), this._element.addEventListener("mousedown", ((a) => {
              a.preventDefault();
            })), Iu(this._element, this._anchor, "marker"), e && e.className) for (const a of e.className.split(" ")) this._element.classList.add(a);
            this._popup = null;
          }
          addTo(e) {
            return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), this._element.hasAttribute("role") || this._element.setAttribute("role", "button"), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), F.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e) {
            return this._lngLat = s.U.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(e) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
              if (!("offset" in e.options)) {
                const m = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [m, -1 * (38.1 - 13.5 + m)], "bottom-right": [-m, -1 * (38.1 - 13.5 + m)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
              }
              this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          setSubpixelPositioning(e) {
            return this._subpixelPositioning = e, this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this;
          }
          _updateOpacity(e = false) {
            var a, c;
            const m = (a = this._map) === null || a === void 0 ? void 0 : a.terrain, _ = this._map.transform.isLocationOccluded(this._lngLat);
            if (!m || _) {
              const G = _ ? this._opacityWhenCovered : this._opacity;
              return void (this._element.style.opacity !== G && (this._element.style.opacity = G));
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null;
              }), 100);
            }
            const x = this._map, k = x.terrain.depthAtPoint(this._pos), T = x.terrain.getElevationForLngLatZoom(this._lngLat, x.transform.tileZoom);
            if (x.transform.lngLatToCameraDepth(this._lngLat, T) - k < 6e-3) return void (this._element.style.opacity = this._opacity);
            const R = -this._offset.y / x.transform.pixelsPerMeter, A = Math.sin(x.getPitch() * Math.PI / 180) * R, N = x.terrain.depthAtPoint(new s.P(this._pos.x, this._pos.y - this._offset.y)), j = x.transform.lngLatToCameraDepth(this._lngLat, T + A) - N > 6e-3;
            !((c = this._popup) === null || c === void 0) && c.isOpen() && j && this._popup.remove(), this._element.style.opacity = j ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(e) {
            return this._offset = s.P.convert(e), this._update(), this;
          }
          addClassName(e) {
            this._element.classList.add(e);
          }
          removeClassName(e) {
            this._element.classList.remove(e);
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e);
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(e, a) {
            return (this._opacity === void 0 || e === void 0 && a === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), a !== void 0 && (this._opacityWhenCovered = a), this._map && this._updateOpacity(true), this;
          }
        }
        const dd = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
        let Ps = 0, Ua = false;
        const hd = { maxWidth: 100, unit: "metric" };
        function Mu(v, e, a) {
          const c = a && a.maxWidth || 100, m = v._container.clientHeight / 2, _ = v._container.clientWidth / 2, x = v.unproject([_ - c / 2, m]), k = v.unproject([_ + c / 2, m]), T = Math.round(v.project(k).x - v.project(x).x), R = Math.min(c, T, v._container.clientWidth), A = x.distanceTo(k);
          if (a && a.unit === "imperial") {
            const N = 3.2808 * A;
            N > 5280 ? Ga(e, R, N / 5280, v._getUIString("ScaleControl.Miles")) : Ga(e, R, N, v._getUIString("ScaleControl.Feet"));
          } else a && a.unit === "nautical" ? Ga(e, R, A / 1852, v._getUIString("ScaleControl.NauticalMiles")) : A >= 1e3 ? Ga(e, R, A / 1e3, v._getUIString("ScaleControl.Kilometers")) : Ga(e, R, A, v._getUIString("ScaleControl.Meters"));
        }
        function Ga(v, e, a, c) {
          const m = (function(_) {
            const x = Math.pow(10, `${Math.floor(_)}`.length - 1);
            let k = _ / x;
            return k = k >= 10 ? 10 : k >= 5 ? 5 : k >= 3 ? 3 : k >= 2 ? 2 : k >= 1 ? 1 : (function(T) {
              const R = Math.pow(10, Math.ceil(-Math.log(T) / Math.LN10));
              return Math.round(T * R) / R;
            })(k), x * k;
          })(a);
          v.style.width = e * (m / a) + "px", v.innerHTML = `${m}&nbsp;${c}`;
        }
        const fd = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", subpixelPositioning: false, locationOccludedOpacity: void 0 }, Eu = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function Ru(v) {
          if (v) {
            if (typeof v == "number") {
              const e = Math.round(Math.abs(v) / Math.SQRT2);
              return { center: new s.P(0, 0), top: new s.P(0, v), "top-left": new s.P(e, e), "top-right": new s.P(-e, e), bottom: new s.P(0, -v), "bottom-left": new s.P(e, -e), "bottom-right": new s.P(-e, -e), left: new s.P(v, 0), right: new s.P(-v, 0) };
            }
            if (v instanceof s.P || Array.isArray(v)) {
              const e = s.P.convert(v);
              return { center: e, top: e, "top-left": e, "top-right": e, bottom: e, "bottom-left": e, "bottom-right": e, left: e, right: e };
            }
            return { center: s.P.convert(v.center || [0, 0]), top: s.P.convert(v.top || [0, 0]), "top-left": s.P.convert(v["top-left"] || [0, 0]), "top-right": s.P.convert(v["top-right"] || [0, 0]), bottom: s.P.convert(v.bottom || [0, 0]), "bottom-left": s.P.convert(v["bottom-left"] || [0, 0]), "bottom-right": s.P.convert(v["bottom-right"] || [0, 0]), left: s.P.convert(v.left || [0, 0]), right: s.P.convert(v.right || [0, 0]) };
          }
          return Ru(new s.P(0, 0));
        }
        const pd = C;
        p.AJAXError = s.cC, p.Event = s.l, p.Evented = s.E, p.LngLat = s.U, p.MercatorCoordinate = s.a5, p.Point = s.P, p.addProtocol = s.cD, p.config = s.a, p.removeProtocol = s.cE, p.AttributionControl = dn, p.BoxZoomHandler = ef, p.CanvasSource = Wt, p.CooperativeGesturesHandler = lo, p.DoubleClickZoomHandler = gl, p.DragPanHandler = sd, p.DragRotateHandler = ld, p.EdgeInsets = Pi, p.FullscreenControl = class extends s.E {
          constructor(v = {}) {
            super(), this._onFullscreenChange = () => {
              var e;
              let a = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((e = a == null ? void 0 : a.shadowRoot) === null || e === void 0) && e.fullscreenElement; ) a = a.shadowRoot.fullscreenElement;
              a === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = false, v && v.container && (v.container instanceof HTMLElement ? this._container = v.container : s.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(v) {
            return this._map = v, this._container || (this._container = this._map.getContainer()), this._controlContainer = F.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            F.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const v = this._fullscreenButton = F.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            F.create("span", "maplibregl-ctrl-icon", v).setAttribute("aria-hidden", "true"), v.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const v = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", v), this._fullscreenButton.title = v;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new s.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new s.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, p.GeoJSONSource = bt, p.GeolocateControl = class extends s.E {
          constructor(v) {
            super(), this._onSuccess = (e) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new s.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new s.l("geolocate", e)), this._finish();
              }
            }, this._updateCamera = (e) => {
              const a = new s.U(e.coords.longitude, e.coords.latitude), c = e.coords.accuracy, m = this._map.getBearing(), _ = s.e({ bearing: m }, this.options.fitBoundsOptions), x = nr.fromLngLat(a, c);
              this._map.fitBounds(x, _, { geolocateSource: true });
            }, this._updateMarker = (e) => {
              if (e) {
                const a = new s.U(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(a).addTo(this._map), this._userLocationDotMarker.setLngLat(a).addTo(this._map), this._accuracy = e.coords.accuracy, this._updateCircleRadiusIfNeeded();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onUpdate = () => {
              this._updateCircleRadiusIfNeeded();
            }, this._onError = (e) => {
              if (this._map) {
                if (e.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                  const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a), this._geolocationWatchID !== void 0 && this._clearWatch();
                } else {
                  if (e.code === 3 && Ua) return;
                  this._setErrorState();
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new s.l("error", e)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", ((e) => e.preventDefault())), this._geolocateButton = F.create("button", "maplibregl-ctrl-geolocate", this._container), F.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = true);
            }, this._finishSetupUI = (e) => {
              if (this._map) {
                if (e === false) {
                  s.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = true, this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a);
                } else {
                  const a = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = false, this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = F.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new yl({ element: this._dotElement }), this._circleElement = F.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new yl({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", ((a) => {
                  const c = (a == null ? void 0 : a[0]) instanceof ResizeObserverEntry;
                  a.geolocateSource || this._watchState !== "ACTIVE_LOCK" || c || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new s.l("trackuserlocationend")), this.fire(new s.l("userlocationlostfocus")));
                }));
              }
            }, this.options = s.e({}, dd, v);
          }
          onAdd(v) {
            return this._map = v, this._container = F.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return s._(this, arguments, void 0, (function* (e = false) {
                if (Vo !== void 0 && !e) return Vo;
                if (window.navigator.permissions === void 0) return Vo = !!window.navigator.geolocation, Vo;
                try {
                  Vo = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
                } catch {
                  Vo = !!window.navigator.geolocation;
                }
                return Vo;
              }));
            })().then(((e) => this._finishSetupUI(e))), this._container;
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), F.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, Ps = 0, Ua = false;
          }
          _isOutOfMapMaxBounds(v) {
            const e = this._map.getMaxBounds(), a = v.coords;
            return e && (a.longitude < e.getWest() || a.longitude > e.getEast() || a.latitude < e.getSouth() || a.latitude > e.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
              case "OFF":
              case void 0:
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadiusIfNeeded() {
            const v = this._userLocationDotMarker.getLngLat();
            if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && v)) return;
            const e = this._map.project(v), a = this._map.unproject([e.x + 100, e.y]), c = v.distanceTo(a) / 100, m = 2 * this._accuracy / c;
            this._circleElement.style.width = `${m.toFixed(2)}px`, this._circleElement.style.height = `${m.toFixed(2)}px`;
          }
          trigger() {
            if (!this._setup) return s.w("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new s.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Ps--, Ua = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new s.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new s.l("trackuserlocationstart")), this.fire(new s.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let v;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Ps++, Ps > 1 ? (v = { maximumAge: 6e5, timeout: 0 }, Ua = true) : (v = this.options.positionOptions, Ua = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, v);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, p.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var v;
              const e = (v = this._map.getProjection()) === null || v === void 0 ? void 0 : v.type;
              this._map.setProjection(e !== "mercator" && e ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
            }, this._updateGlobeIcon = () => {
              var v;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((v = this._map.getProjection()) === null || v === void 0 ? void 0 : v.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
            };
          }
          onAdd(v) {
            return this._map = v, this._container = F.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = F.create("button", "maplibregl-ctrl-globe", this._container), F.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
          }
          onRemove() {
            F.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
          }
        }, p.Hash = Qc, p.ImageSource = rt, p.KeyboardHandler = uf, p.LngLatBounds = nr, p.LogoControl = ud, p.Map = class extends ff {
          constructor(v) {
            var e, a;
            s.cz.mark(s.cA.create);
            const c = Object.assign(Object.assign(Object.assign({}, ks), v), { canvasContextAttributes: Object.assign(Object.assign({}, ks.canvasContextAttributes), v.canvasContextAttributes) });
            if (c.minZoom != null && c.maxZoom != null && c.minZoom > c.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (c.minPitch != null && c.maxPitch != null && c.minPitch > c.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (c.minPitch != null && c.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (c.maxPitch != null && c.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const m = new So(), _ = new Ea();
            if (c.minZoom !== void 0 && m.setMinZoom(c.minZoom), c.maxZoom !== void 0 && m.setMaxZoom(c.maxZoom), c.minPitch !== void 0 && m.setMinPitch(c.minPitch), c.maxPitch !== void 0 && m.setMaxPitch(c.maxPitch), c.renderWorldCopies !== void 0 && m.setRenderWorldCopies(c.renderWorldCopies), c.transformConstrain !== null && m.setConstrain(c.transformConstrain), super(m, _, { bearingSnap: c.bearingSnap }), this._idleTriggered = false, this._crossFadingFactor = 1, this._renderTaskQueue = new uo(), this._controls = [], this._mapId = s.ab(), this._contextLost = (k) => {
              k.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new s.l("webglcontextlost", { originalEvent: k }));
            }, this._contextRestored = (k) => {
              this._setupPainter(), this.resize(), this._update(), this.fire(new s.l("webglcontextrestored", { originalEvent: k }));
            }, this._onMapScroll = (k) => {
              if (k.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = c.interactive, this._maxTileCacheSize = c.maxTileCacheSize, this._maxTileCacheZoomLevels = c.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, c.canvasContextAttributes), this._trackResize = c.trackResize === true, this._bearingSnap = c.bearingSnap, this._centerClampedToGround = c.centerClampedToGround, this._refreshExpiredTiles = c.refreshExpiredTiles === true, this._fadeDuration = c.fadeDuration, this._crossSourceCollisions = c.crossSourceCollisions === true, this._collectResourceTiming = c.collectResourceTiming === true, this._locale = Object.assign(Object.assign({}, Ci), c.locale), this._clickTolerance = c.clickTolerance, this._overridePixelRatio = c.pixelRatio, this._maxCanvasSize = c.maxCanvasSize, this.transformCameraUpdate = c.transformCameraUpdate, this.transformConstrain = c.transformConstrain, this.cancelPendingTileRequestsWhileZooming = c.cancelPendingTileRequestsWhileZooming === true, this._imageQueueHandle = J.addThrottleControl((() => this.isMoving())), this._requestManager = new we(c.transformRequest), typeof c.container == "string") {
              if (this._container = document.getElementById(c.container), !this._container) throw new Error(`Container '${c.container}' not found.`);
            } else {
              if (!(c.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = c.container;
            }
            if (c.maxBounds && this.setMaxBounds(c.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(false))), this.on("moveend", (() => this._update(false))), this.on("zoom", (() => this._update(true))), this.on("terrain", (() => {
              this.painter.terrainFacilitator.dirty = true, this._update(true);
            })), this.once("idle", (() => {
              this._idleTriggered = true;
            })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, false);
              let k = false;
              const T = Jc(((R) => {
                this._trackResize && !this._removed && (this.resize(R), this.redraw());
              }), 50);
              this._resizeObserver = new ResizeObserver(((R) => {
                k ? T(R) : k = true;
              })), this._resizeObserver.observe(this._container);
            }
            this.handlers = new vl(this, c), this._hash = c.hash && new Qc(typeof c.hash == "string" && c.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: c.center, elevation: c.elevation, zoom: c.zoom, bearing: c.bearing, pitch: c.pitch, roll: c.roll }), c.bounds && (this.resize(), this.fitBounds(c.bounds, s.e({}, c.fitBoundsOptions, { duration: 0 }))));
            const x = typeof c.style == "string" || ((a = (e = c.style) === null || e === void 0 ? void 0 : e.projection) === null || a === void 0 ? void 0 : a.type) !== "globe";
            this.resize(null, x), this._localIdeographFontFamily = c.localIdeographFontFamily, this._validateStyle = c.validateStyle, c.style && this.setStyle(c.style, { localIdeographFontFamily: c.localIdeographFontFamily }), c.attributionControl && this.addControl(new dn(typeof c.attributionControl == "boolean" ? void 0 : c.attributionControl)), c.maplibreLogo && this.addControl(new ud(), c.logoPosition), this.on("style.load", (() => {
              if (x || this._resizeTransform(), this.transform.unmodified) {
                const k = s.S(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(k);
              }
            })), this.on("data", ((k) => {
              this._update(k.dataType === "style"), this.fire(new s.l(`${k.dataType}data`, k));
            })), this.on("dataloading", ((k) => {
              this.fire(new s.l(`${k.dataType}dataloading`, k));
            })), this.on("dataabort", ((k) => {
              this.fire(new s.l("sourcedataabort", k));
            }));
          }
          _getMapId() {
            return this._mapId;
          }
          setGlobalStateProperty(v, e) {
            return this.style.setGlobalStateProperty(v, e), this._update(true);
          }
          getGlobalState() {
            return this.style.getGlobalState();
          }
          addControl(v, e) {
            if (e === void 0 && (e = v.getDefaultPosition ? v.getDefaultPosition() : "top-right"), !v || !v.onAdd) return this.fire(new s.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const a = v.onAdd(this);
            this._controls.push(v);
            const c = this._controlPositions[e];
            return e.indexOf("bottom") !== -1 ? c.insertBefore(a, c.firstChild) : c.appendChild(a), this;
          }
          removeControl(v) {
            if (!v || !v.onRemove) return this.fire(new s.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const e = this._controls.indexOf(v);
            return e > -1 && this._controls.splice(e, 1), v.onRemove(this), this;
          }
          hasControl(v) {
            return this._controls.indexOf(v) > -1;
          }
          coveringTiles(v) {
            return jr(this.transform, v);
          }
          calculateCameraOptionsFromTo(v, e, a, c) {
            return c == null && this.terrain && (c = this.terrain.getElevationForLngLatZoom(a, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(v, e, a, c);
          }
          resize(v, e = true) {
            const [a, c] = this._containerDimensions(), m = this._getClampedPixelRatio(a, c);
            if (this._resizeCanvas(a, c, m), this.painter.resize(a, c, m), this.painter.overLimit()) {
              const x = this.painter.context.gl;
              this._maxCanvasSize = [x.drawingBufferWidth, x.drawingBufferHeight];
              const k = this._getClampedPixelRatio(a, c);
              this._resizeCanvas(a, c, k), this.painter.resize(a, c, k);
            }
            this._resizeTransform(e);
            const _ = !this._moving;
            return _ && (this.stop(), this.fire(new s.l("movestart", v)).fire(new s.l("move", v))), this.fire(new s.l("resize", v)), _ && this.fire(new s.l("moveend", v)), this;
          }
          _resizeTransform(v = true) {
            var e;
            const [a, c] = this._containerDimensions();
            this.transform.resize(a, c, v), (e = this._requestedCameraState) === null || e === void 0 || e.resize(a, c, v);
          }
          _getClampedPixelRatio(v, e) {
            const { 0: a, 1: c } = this._maxCanvasSize, m = this.getPixelRatio(), _ = v * m, x = e * m;
            return Math.min(_ > a ? a / _ : 1, x > c ? c / x : 1) * m;
          }
          getPixelRatio() {
            var v;
            return (v = this._overridePixelRatio) !== null && v !== void 0 ? v : devicePixelRatio;
          }
          setPixelRatio(v) {
            this._overridePixelRatio = v, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(v) {
            return this.transform.setMaxBounds(nr.convert(v)), this._update();
          }
          setMinZoom(v) {
            if ((v = v ?? -2) >= -2 && v <= this.transform.maxZoom) return this.transform.setMinZoom(v), this._update(), this.getZoom() < v && this.setZoom(v), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(v) {
            if ((v = v ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(v), this._update(), this.getZoom() > v && this.setZoom(v), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(v) {
            if ((v = v ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (v >= 0 && v <= this.transform.maxPitch) return this.transform.setMinPitch(v), this._update(), this.getPitch() < v && this.setPitch(v), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(v) {
            if ((v = v ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (v >= this.transform.minPitch) return this.transform.setMaxPitch(v), this._update(), this.getPitch() > v && this.setPitch(v), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(v) {
            return this.transform.setRenderWorldCopies(v), this._update();
          }
          setTransformConstrain(v) {
            return this.transform.setConstrain(v), this._update();
          }
          project(v) {
            return this.transform.locationToScreenPoint(s.U.convert(v), this.style && this.terrain);
          }
          unproject(v) {
            return this.transform.screenPointToLocation(s.P.convert(v), this.terrain);
          }
          isMoving() {
            var v;
            return this._moving || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isMoving());
          }
          isZooming() {
            var v;
            return this._zooming || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isZooming());
          }
          isRotating() {
            var v;
            return this._rotating || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isRotating());
          }
          _createDelegatedListener(v, e, a) {
            if (v === "mouseenter" || v === "mouseover") {
              let c = false;
              return { layers: e, listener: a, delegates: { mousemove: (_) => {
                const x = e.filter(((T) => this.getLayer(T))), k = x.length !== 0 ? this.queryRenderedFeatures(_.point, { layers: x }) : [];
                k.length ? c || (c = true, a.call(this, new Dn(v, this, _.originalEvent, { features: k }))) : c = false;
              }, mouseout: () => {
                c = false;
              } } };
            }
            if (v === "mouseleave" || v === "mouseout") {
              let c = false;
              return { layers: e, listener: a, delegates: { mousemove: (x) => {
                const k = e.filter(((T) => this.getLayer(T)));
                (k.length !== 0 ? this.queryRenderedFeatures(x.point, { layers: k }) : []).length ? c = true : c && (c = false, a.call(this, new Dn(v, this, x.originalEvent)));
              }, mouseout: (x) => {
                c && (c = false, a.call(this, new Dn(v, this, x.originalEvent)));
              } } };
            }
            {
              const c = (m) => {
                const _ = e.filter(((k) => this.getLayer(k))), x = _.length !== 0 ? this.queryRenderedFeatures(m.point, { layers: _ }) : [];
                x.length && (m.features = x, a.call(this, m), delete m.features);
              };
              return { layers: e, listener: a, delegates: { [v]: c } };
            }
          }
          _saveDelegatedListener(v, e) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[v] = this._delegatedListeners[v] || [], this._delegatedListeners[v].push(e);
          }
          _removeDelegatedListener(v, e, a) {
            if (!this._delegatedListeners || !this._delegatedListeners[v]) return;
            const c = this._delegatedListeners[v];
            for (let m = 0; m < c.length; m++) {
              const _ = c[m];
              if (_.listener === a && _.layers.length === e.length && _.layers.every(((x) => e.includes(x)))) {
                for (const x in _.delegates) this.off(x, _.delegates[x]);
                return void c.splice(m, 1);
              }
            }
          }
          on(v, e, a) {
            if (a === void 0) return super.on(v, e);
            const c = typeof e == "string" ? [e] : e, m = this._createDelegatedListener(v, c, a);
            this._saveDelegatedListener(v, m);
            for (const _ in m.delegates) this.on(_, m.delegates[_]);
            return { unsubscribe: () => {
              this._removeDelegatedListener(v, c, a);
            } };
          }
          once(v, e, a) {
            if (a === void 0) return super.once(v, e);
            const c = typeof e == "string" ? [e] : e, m = this._createDelegatedListener(v, c, a);
            for (const _ in m.delegates) {
              const x = m.delegates[_];
              m.delegates[_] = (...k) => {
                this._removeDelegatedListener(v, c, a), x(...k);
              };
            }
            this._saveDelegatedListener(v, m);
            for (const _ in m.delegates) this.once(_, m.delegates[_]);
            return this;
          }
          off(v, e, a) {
            return a === void 0 ? super.off(v, e) : (this._removeDelegatedListener(v, typeof e == "string" ? [e] : e, a), this);
          }
          queryRenderedFeatures(v, e) {
            if (!this.style) return [];
            let a;
            const c = v instanceof s.P || Array.isArray(v), m = c ? v : [[0, 0], [this.transform.width, this.transform.height]];
            if (e = e || (c ? {} : v) || {}, m instanceof s.P || typeof m[0] == "number") a = [s.P.convert(m)];
            else {
              const _ = s.P.convert(m[0]), x = s.P.convert(m[1]);
              a = [_, new s.P(x.x, _.y), x, new s.P(_.x, x.y), _];
            }
            return this.style.queryRenderedFeatures(a, e, this.transform);
          }
          querySourceFeatures(v, e) {
            return this.style.querySourceFeatures(v, e);
          }
          setStyle(v, e) {
            return (e = s.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, e)).diff !== false && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && v ? (this._diffStyle(v, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(v, e));
          }
          setTransformRequest(v) {
            return this._requestManager.setTransformRequest(v), this;
          }
          _getUIString(v) {
            const e = this._locale[v];
            if (e == null) throw new Error(`Missing UI string '${v}'`);
            return e;
          }
          _updateStyle(v, e) {
            var a, c;
            if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(v, e)));
            const m = this.style && e.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!v)), v ? (this.style = new il(this, e || {}), this.style.setEventedParent(this, { style: this.style }), typeof v == "string" ? this.style.loadURL(v, e, m) : this.style.loadJSON(v, e, m), this) : ((c = (a = this.style) === null || a === void 0 ? void 0 : a.projection) === null || c === void 0 || c.destroy(), delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new il(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(v, e) {
            if (typeof v == "string") {
              const a = this._requestManager.transformRequest(v, "Style");
              s.j(a, new AbortController()).then(((c) => {
                this._updateDiff(c.data, e);
              })).catch(((c) => {
                c && this.fire(new s.k(c));
              }));
            } else typeof v == "object" && this._updateDiff(v, e);
          }
          _updateDiff(v, e) {
            try {
              this.style.setState(v, e) && this._update(true);
            } catch (a) {
              s.w(`Unable to perform style diff: ${a.message || a.error || a}.  Rebuilding the style from scratch.`), this._updateStyle(v, e);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : s.w("There is no style added to the map.");
          }
          addSource(v, e) {
            return this._lazyInitEmptyStyle(), this.style.addSource(v, e), this._update(true);
          }
          isSourceLoaded(v) {
            const e = this.style && this.style.tileManagers[v];
            if (e !== void 0) return e.loaded();
            this.fire(new s.k(new Error(`There is no tile manager with ID '${v}'`)));
          }
          setTerrain(v) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), v) {
              const e = this.style.tileManagers[v.source];
              if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${v.source}`);
              this.terrain === null && e.reload();
              for (const a in this.style._layers) {
                const c = this.style._layers[a];
                c.type === "hillshade" && c.source === v.source && s.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), c.type === "color-relief" && c.source === v.source && s.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new am(this.painter, e, v), this.painter.renderToTexture = new fi(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (a) => {
                var c;
                a.dataType === "style" ? this.terrain.tileManager.freeRtt() : a.dataType === "source" && a.tile && (a.sourceId !== v.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((c = a.source) === null || c === void 0 ? void 0 : c.type) === "image" ? this.terrain.tileManager.freeRtt() : this.terrain.tileManager.freeRtt(a.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.tileManager.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new s.l("terrain", { terrain: v })), this;
          }
          getTerrain() {
            var v, e;
            return (e = (v = this.terrain) === null || v === void 0 ? void 0 : v.options) !== null && e !== void 0 ? e : null;
          }
          areTilesLoaded() {
            const v = this.style && this.style.tileManagers;
            for (const e in v) {
              const a = v[e]._tiles;
              for (const c in a) {
                const m = a[c];
                if (m.state !== "loaded" && m.state !== "errored") return false;
              }
            }
            return true;
          }
          removeSource(v) {
            return this.style.removeSource(v), this._update(true);
          }
          getSource(v) {
            return this.style.getSource(v);
          }
          setSourceTileLodParams(v, e, a) {
            if (a) {
              const c = this.getSource(a);
              if (!c) throw new Error(`There is no source with ID "${a}", cannot set LOD parameters`);
              c.calculateTileZoom = Ut(Math.max(1, v), Math.max(1, e));
            } else for (const c in this.style.tileManagers) this.style.tileManagers[c].getSource().calculateTileZoom = Ut(Math.max(1, v), Math.max(1, e));
            return this._update(true), this;
          }
          refreshTiles(v, e) {
            const a = this.style.tileManagers[v];
            if (!a) throw new Error(`There is no tile manager with ID "${v}", cannot refresh tile`);
            e === void 0 ? a.reload(true) : a.refreshTiles(e.map(((c) => new s.a8(c.z, c.x, c.y))));
          }
          addImage(v, e, a = {}) {
            const { pixelRatio: c = 1, sdf: m = false, stretchX: _, stretchY: x, content: k, textFitWidth: T, textFitHeight: R } = a;
            if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || s.b(e))) {
              if (e.width === void 0 || e.height === void 0) return this.fire(new s.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: A, height: N, data: j } = e, G = e;
                return this.style.addImage(v, { data: new s.R({ width: A, height: N }, new Uint8Array(j)), pixelRatio: c, stretchX: _, stretchY: x, content: k, textFitWidth: T, textFitHeight: R, sdf: m, version: 0, userImage: G }), G.onAdd && G.onAdd(this, v), this;
              }
            }
            {
              const { width: A, height: N, data: j } = L.getImageData(e);
              this.style.addImage(v, { data: new s.R({ width: A, height: N }, j), pixelRatio: c, stretchX: _, stretchY: x, content: k, textFitWidth: T, textFitHeight: R, sdf: m, version: 0 });
            }
          }
          updateImage(v, e) {
            const a = this.style.getImage(v);
            if (!a) return this.fire(new s.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const c = e instanceof HTMLImageElement || s.b(e) ? L.getImageData(e) : e, { width: m, height: _, data: x } = c;
            if (m === void 0 || _ === void 0) return this.fire(new s.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (m !== a.data.width || _ !== a.data.height) return this.fire(new s.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const k = !(e instanceof HTMLImageElement || s.b(e));
            return a.data.replace(x, k), this.style.updateImage(v, a), this;
          }
          getImage(v) {
            return this.style.getImage(v);
          }
          hasImage(v) {
            return v ? !!this.style.getImage(v) : (this.fire(new s.k(new Error("Missing required image id"))), false);
          }
          removeImage(v) {
            this.style.removeImage(v);
          }
          loadImage(v) {
            return J.getImage(this._requestManager.transformRequest(v, "Image"), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(v, e) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(v, e), this._update(true);
          }
          moveLayer(v, e) {
            return this.style.moveLayer(v, e), this._update(true);
          }
          removeLayer(v) {
            return this.style.removeLayer(v), this._update(true);
          }
          getLayer(v) {
            return this.style.getLayer(v);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(v, e, a) {
            return this.style.setLayerZoomRange(v, e, a), this._update(true);
          }
          setFilter(v, e, a = {}) {
            return this.style.setFilter(v, e, a), this._update(true);
          }
          getFilter(v) {
            return this.style.getFilter(v);
          }
          setPaintProperty(v, e, a, c = {}) {
            return this.style.setPaintProperty(v, e, a, c), this._update(true);
          }
          getPaintProperty(v, e) {
            return this.style.getPaintProperty(v, e);
          }
          setLayoutProperty(v, e, a, c = {}) {
            return this.style.setLayoutProperty(v, e, a, c), this._update(true);
          }
          getLayoutProperty(v, e) {
            return this.style.getLayoutProperty(v, e);
          }
          setGlyphs(v, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(v, e), this._update(true);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(v, e, a = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(v, e, a, ((c) => {
              c || this._update(true);
            })), this;
          }
          removeSprite(v) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(v), this._update(true);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(v, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(v, e, ((a) => {
              a || this._update(true);
            })), this;
          }
          setLight(v, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(v, e), this._update(true);
          }
          getLight() {
            return this.style.getLight();
          }
          setSky(v, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(v, e), this._update(true);
          }
          getSky() {
            return this.style.getSky();
          }
          setFeatureState(v, e) {
            return this.style.setFeatureState(v, e), this._update();
          }
          removeFeatureState(v, e) {
            return this.style.removeFeatureState(v, e), this._update();
          }
          getFeatureState(v) {
            return this.style.getFeatureState(v);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let v = 0, e = 0;
            return this._container && (v = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [v, e];
          }
          _setupContainer() {
            const v = this._container;
            v.classList.add("maplibregl-map");
            const e = this._canvasContainer = F.create("div", "maplibregl-canvas-container", v);
            this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = F.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const a = this._containerDimensions(), c = this._getClampedPixelRatio(a[0], a[1]);
            this._resizeCanvas(a[0], a[1], c);
            const m = this._controlContainer = F.create("div", "maplibregl-control-container", v), _ = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(((x) => {
              _[x] = F.create("div", `maplibregl-ctrl-${x} `, m);
            })), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _resizeCanvas(v, e, a) {
            this._canvas.width = Math.floor(a * v), this._canvas.height = Math.floor(a * e), this._canvas.style.width = `${v}px`, this._canvas.style.height = `${e}px`;
          }
          _setupPainter() {
            const v = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: true, depth: true, stencil: true, premultipliedAlpha: true });
            let e = null;
            this._canvas.addEventListener("webglcontextcreationerror", ((c) => {
              e = { requestedAttributes: v }, c && (e.statusMessage = c.statusMessage, e.type = c.type);
            }), { once: true });
            let a = null;
            if (a = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, v) : this._canvas.getContext("webgl2", v) || this._canvas.getContext("webgl", v), !a) {
              const c = "Failed to initialize WebGL";
              throw e ? (e.message = c, new Error(JSON.stringify(e))) : new Error(c);
            }
            this.painter = new Zh(a, this.transform), Z.testSupport(a);
          }
          migrateProjection(v, e) {
            super.migrateProjection(v, e), this.painter.transform = v, this.fire(new s.l("projectiontransition", { newProjection: this.style.projection.name }));
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(v) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || v, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(v) {
            return this._update(), this._renderTaskQueue.add(v);
          }
          _cancelRenderFrame(v) {
            this._renderTaskQueue.remove(v);
          }
          _render(v) {
            var e, a, c, m, _;
            const x = this._idleTriggered ? this._fadeDuration : 0, k = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(v), this._removed) return;
            let T = false;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const N = this.transform.zoom, j = z();
              this.style.zoomHistory.update(N, j);
              const G = new s.G(N, { now: j, fadeDuration: x, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), Q = G.crossFadingFactor();
              Q === 1 && Q === this._crossFadingFactor || (T = true, this._crossFadingFactor = Q), this.style.update(G);
            }
            const R = ((a = this.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0 !== k;
            (c = this.style.projection) === null || c === void 0 || c.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((m = this.style.projection) === null || m === void 0 ? void 0 : m.transitionState, (_ = this.style.projection) === null || _ === void 0 ? void 0 : _.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || R) && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.tileManager.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, x, this._crossSourceCollisions, R), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: x, showPadding: this.showPadding }), this.fire(new s.l("render")), this.loaded() && !this._loaded && (this._loaded = true, s.cz.mark(s.cA.load), this.fire(new s.l("load"))), this.style && (this.style.hasTransitions() || T) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const A = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return A || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new s.l("idle")), !this._loaded || this._fullyLoaded || A || (this._fullyLoaded = true, s.cz.mark(s.cA.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var v;
            this._hash && this._hash.remove();
            for (const a of this._controls) a.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, false), J.removeThrottleControl(this._imageQueueHandle), (v = this._resizeObserver) === null || v === void 0 || v.disconnect();
            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            (e == null ? void 0 : e.loseContext) && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), F.remove(this._canvasContainer), F.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, false), this._container.classList.remove("maplibregl-map"), s.cz.clearMetrics(), this._removed = true, this.fire(new s.l("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), L.frame(this._frameRequest, ((v) => {
              s.cz.frame(v), this._frameRequest = null;
              try {
                this._render(v);
              } catch (e) {
                if (!s.cB(e) && !(function(a) {
                  return a.message === $h;
                })(e)) throw e;
              }
            }), (() => {
            })));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(v) {
            this._showTileBoundaries !== v && (this._showTileBoundaries = v, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(v) {
            this._showPadding !== v && (this._showPadding = v, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(v) {
            this._showCollisionBoxes !== v && (this._showCollisionBoxes = v, v ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(v) {
            this._showOverdrawInspector !== v && (this._showOverdrawInspector = v, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(v) {
            this._repaint !== v && (this._repaint = v, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(v) {
            this._vertices = v, this._update();
          }
          get version() {
            return mf;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
          getProjection() {
            return this.style.getProjection();
          }
          setProjection(v) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(v), this._update(true);
          }
        }, p.MapMouseEvent = Dn, p.MapTouchEvent = _n, p.MapWheelEvent = Qh, p.Marker = yl, p.NavigationControl = class {
          constructor(v) {
            this._updateZoomButtons = () => {
              const e = this._map.getZoom(), a = e === this._map.getMaxZoom(), c = e === this._map.getMinZoom();
              this._zoomInButton.disabled = a, this._zoomOutButton.disabled = c, this._zoomInButton.setAttribute("aria-disabled", a.toString()), this._zoomOutButton.setAttribute("aria-disabled", c.toString());
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
            }, this._setButtonTitle = (e, a) => {
              const c = this._map._getUIString(`NavigationControl.${a}`);
              e.title = c, e.setAttribute("aria-label", c);
            }, this.options = s.e({}, Pu, v), this._container = F.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", ((e) => e.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", ((e) => this._map.zoomIn({}, { originalEvent: e }))), F.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", ((e) => this._map.zoomOut({}, { originalEvent: e }))), F.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", ((e) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e }) : this._map.resetNorth({}, { originalEvent: e });
            })), this._compassIcon = F.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(v) {
            return this._map = v, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new cd(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            F.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(v, e) {
            const a = F.create("button", v, this._container);
            return a.type = "button", a.addEventListener("click", e), a;
          }
        }, p.Popup = class extends s.E {
          constructor(v) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "");
            }, this.remove = () => (this._content && F.remove(this._content), this._container && (F.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new s.l("close"))), this), this._onMouseUp = (e) => {
              this._update(e.point);
            }, this._onMouseMove = (e) => {
              this._update(e.point);
            }, this._onDrag = (e) => {
              this._update(e.point);
            }, this._update = (e) => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = F.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = F.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const x of this.options.className.split(" ")) this._container.classList.add(x);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = Tu(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
              const a = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
              let c = this.options.anchor;
              const m = Ru(this.options.offset);
              if (!c) {
                const x = this._container.offsetWidth, k = this._container.offsetHeight;
                let T;
                T = a.y + m.bottom.y < k ? ["top"] : a.y > this._map.transform.height - k ? ["bottom"] : [], a.x < x / 2 ? T.push("left") : a.x > this._map.transform.width - x / 2 && T.push("right"), c = T.length === 0 ? "bottom" : T.join("-");
              }
              let _ = a.add(m[c]);
              this.options.subpixelPositioning || (_ = _.round()), F.setTransform(this._container, `${Va[c]} translate(${_.x}px,${_.y}px)`), Iu(this._container, c, "popup"), this._updateOpacity();
            }, this._onClose = () => {
              this.remove();
            }, this.options = s.e(Object.create(fd), v);
          }
          addTo(v) {
            return this._map && this.remove(), this._map = v, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new s.l("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(v) {
            return this._lngLat = s.U.convert(v), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(v) {
            return this.setDOMContent(document.createTextNode(v));
          }
          setHTML(v) {
            const e = document.createDocumentFragment(), a = document.createElement("body");
            let c;
            for (a.innerHTML = v; c = a.firstChild, c; ) e.appendChild(c);
            return this.setDOMContent(e);
          }
          getMaxWidth() {
            var v;
            return (v = this._container) === null || v === void 0 ? void 0 : v.style.maxWidth;
          }
          setMaxWidth(v) {
            return this.options.maxWidth = v, this._update(), this;
          }
          setDOMContent(v) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = F.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(v), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(v) {
            return this._container && this._container.classList.add(v), this;
          }
          removeClassName(v) {
            return this._container && this._container.classList.remove(v), this;
          }
          setOffset(v) {
            return this.options.offset = v, this._update(), this;
          }
          toggleClassName(v) {
            if (this._container) return this._container.classList.toggle(v);
          }
          setSubpixelPositioning(v) {
            this.options.subpixelPositioning = v;
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = F.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const v = this._container.querySelector(Eu);
            v && v.focus();
          }
        }, p.RasterDEMTileSource = Oe, p.RasterTileSource = at, p.ScaleControl = class {
          constructor(v) {
            this._onMove = () => {
              Mu(this._map, this._container, this.options);
            }, this.setUnit = (e) => {
              this.options.unit = e, Mu(this._map, this._container, this.options);
            }, this.options = Object.assign(Object.assign({}, hd), v);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(v) {
            return this._map = v, this._container = F.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", v.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            F.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, p.ScrollZoomHandler = cf, p.Style = il, p.TerrainControl = class {
          constructor(v) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = v;
          }
          onAdd(v) {
            return this._map = v, this._container = F.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = F.create("button", "maplibregl-ctrl-terrain", this._container), F.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            F.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, p.TwoFingersTouchPitchHandler = sf, p.TwoFingersTouchRotateHandler = Su, p.TwoFingersTouchZoomHandler = af, p.TwoFingersTouchZoomRotateHandler = hf, p.VectorTileSource = ze, p.VideoSource = vt, p.addSourceType = (v, e) => s._(void 0, void 0, void 0, (function* () {
          if (Ai(v)) throw new Error(`A source type called "${v}" already exists.`);
          ((a, c) => {
            ci[a] = c;
          })(v, e);
        })), p.clearPrewarmedResources = function() {
          const v = gt;
          v && (v.isPreloaded() && v.numActive() === 1 ? (v.release(wt), gt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, p.createTileMesh = Ks, p.getMaxParallelImageRequests = function() {
          return s.a.MAX_PARALLEL_IMAGE_REQUESTS;
        }, p.getRTLTextPluginStatus = function() {
          return Y().getRTLTextPluginStatus();
        }, p.getVersion = function() {
          return pd;
        }, p.getWorkerCount = function() {
          return Ft.workerCount;
        }, p.getWorkerUrl = function() {
          return s.a.WORKER_URL;
        }, p.importScriptInWorkers = function(v) {
          return Cr().broadcast("IS", v);
        }, p.isTimeFrozen = function() {
          return $.isFrozen();
        }, p.now = z, p.prewarm = function() {
          Zt().acquire(wt);
        }, p.restoreNow = function() {
          $.restoreNow();
        }, p.setMaxParallelImageRequests = function(v) {
          s.a.MAX_PARALLEL_IMAGE_REQUESTS = v;
        }, p.setNow = function(v) {
          $.setNow(v);
        }, p.setRTLTextPlugin = function(v, e) {
          return Y().setRTLTextPlugin(v, e);
        }, p.setWorkerCount = function(v) {
          Ft.workerCount = v;
        }, p.setWorkerUrl = function(v) {
          s.a.WORKER_URL = v;
        };
      }));
      var g = l;
      return g;
    }));
  })(np)), np.exports;
}
var jl = O6();
/*!
* @indoorequal/vue-maplibre-gl v8.4.2
* (c) 2025 Franois de Metz <francois@2metz.fr>
* @license MIT
*/
const $6 = Symbol("map"), Vl = $6, ph = Symbol("isLoaded"), j6 = Symbol("isInitialized"), y1 = j6, g0 = Symbol("componentId"), v0 = Symbol("sourceId"), b1 = Symbol("sourceLayerRegistry"), N6 = Symbol("marker"), V6 = ["error", "load", "idle", "remove", "render", "resize", "webglcontextlost", "webglcontextrestored", "dataloading", "data", "tiledataloading", "sourcedataloading", "styledataloading", "sourcedata", "styledata", "styleimagemissing", "dataabort", "sourcedataabort", "boxzoomcancel", "boxzoomstart", "boxzoomend", "touchcancel", "touchmove", "touchend", "touchstart", "click", "contextmenu", "dblclick", "mousemove", "mouseup", "mousedown", "mouseout", "mouseover", "movestart", "move", "moveend", "zoomstart", "zoom", "zoomend", "rotatestart", "rotate", "rotateend", "dragstart", "drag", "dragend", "pitchstart", "pitch", "pitchend", "wheel", "terrain", "cooperativegestureprevented"];
function U6(r, i, l, d) {
  return (f) => l.emit(d, { type: f.type, map: i, component: r, event: f });
}
function G6(r, i) {
  const l = jl.LngLat.convert(r), d = jl.LngLat.convert(i);
  return l.lng === d.lng && l.lat === d.lat;
}
var Dp = ((r) => (r.TOP_LEFT = "top-left", r.TOP_RIGHT = "top-right", r.BOTTOM_LEFT = "bottom-left", r.BOTTOM_RIGHT = "bottom-right", r))(Dp || {});
const mh = Object.values(Dp), ty = /* @__PURE__ */ new Map(), q6 = Symbol("default");
function W6(r, i, l = q6) {
  var _a3;
  let d = ty.get(l);
  return d || (d = xw({ isLoaded: false, isMounted: false, language: null }), ty.set(l, d)), d.isLoaded = ((_a3 = i.value) == null ? void 0 : _a3.loaded()) || false, d.isMounted = false, d.component = r, d.map = i.value, d;
}
const x1 = ot({ name: "MglMap", props: { width: { type: [Number, String], default: "100%" }, height: { type: [Number, String], default: "100%" }, attributionControl: { type: [Boolean, Object], default: void 0 }, bearing: { type: Number }, bearingSnap: { type: Number }, bounds: { type: [Array, Object] }, boxZoom: { type: Boolean, default: void 0 }, center: { type: [Array, Object] }, clickTolerance: { type: Number }, collectResourceTiming: { type: Boolean, default: void 0 }, crossSourceCollisions: { type: Boolean, default: void 0 }, dragPan: { type: Boolean, default: void 0 }, dragRotate: { type: Boolean, default: void 0 }, doubleClickZoom: { type: Boolean, default: void 0 }, hash: { type: [Boolean, String], default: void 0 }, fadeDuration: { type: Number }, fitBoundsOptions: { type: Object }, interactive: { type: Boolean, default: void 0 }, keyboard: { type: Boolean, default: void 0 }, locale: { type: Object }, localIdeographFontFamily: { type: String }, logoPosition: { type: [String], validator: (r) => r in Dp }, maxBounds: { type: [Array, Object] }, maxPitch: { type: Number }, maxZoom: { type: Number }, minPitch: { type: Number }, minZoom: { type: Number }, pitch: { type: Number }, pitchWithRotate: { type: Boolean, default: void 0 }, canvasContextAttributes: { type: Object }, refreshExpiredTiles: { type: Boolean, default: void 0 }, renderWorldCopies: { type: Boolean, default: void 0 }, scrollZoom: { type: Boolean, default: void 0 }, mapStyle: { type: [String, Object] }, trackResize: { type: Boolean, default: void 0 }, transformRequest: { type: Function }, transformCameraUpdate: { type: Function }, touchZoomRotate: { type: Boolean, default: void 0 }, touchPitch: { type: Boolean, default: void 0 }, zoom: { type: Number }, maxTileCacheSize: { type: Number }, mapKey: { type: [String, Symbol] }, pixelRatio: { type: Number }, validateStyle: { type: Boolean, default: void 0 }, cooperativeGestures: { type: Boolean } }, emits: ["map:error", "map:load", "map:idle", "map:remove", "map:render", "map:resize", "map:webglcontextlost", "map:webglcontextrestored", "map:dataloading", "map:data", "map:tiledataloading", "map:sourcedataloading", "map:styledataloading", "map:sourcedata", "map:styledata", "map:styleimagemissing", "map:dataabort", "map:sourcedataabort", "map:boxzoomcancel", "map:boxzoomstart", "map:boxzoomend", "map:touchcancel", "map:touchmove", "map:touchend", "map:touchstart", "map:click", "map:contextmenu", "map:dblclick", "map:mousemove", "map:mouseup", "map:mousedown", "map:mouseout", "map:mouseover", "map:movestart", "map:move", "map:moveend", "map:zoomstart", "map:zoom", "map:zoomend", "map:rotatestart", "map:rotate", "map:rotateend", "map:dragstart", "map:drag", "map:dragend", "map:pitchstart", "map:pitch", "map:pitchend", "map:wheel", "map:terrain", "map:cooperativegestureprevented", "map:projectiontransition", "update:center", "update:zoom", "update:pitch", "update:bearing"], slots: Object, setup(r, i) {
  const l = l_(lh()), d = Ca(), f = Ca(), g = Ie(false), p = Ie(false), s = /* @__PURE__ */ new Map(), C = W6(l, f, r.mapKey);
  Xr(Vl, f), Xr(ph, p), Xr(y1, g), Xr(g0, l.uid), Xr(v0, ""), Ht(() => r.bearing, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setBearing(L));
  }), Ht(() => r.bounds, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.fitBounds(L, r.fitBoundsOptions));
  }), Ht(() => r.center, (L) => {
    var _a3, _b2;
    const $ = (_a3 = f.value) == null ? void 0 : _a3.getCenter();
    L && $ && !G6(L, $) && ((_b2 = f.value) == null ? void 0 : _b2.setCenter(L));
  }), Ht(() => r.maxBounds, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setMaxBounds(L));
  }), Ht(() => r.maxPitch, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setMaxPitch(L));
  }), Ht(() => r.maxZoom, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setMaxZoom(L));
  }), Ht(() => r.minPitch, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setMinPitch(L));
  }), Ht(() => r.minZoom, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setMinZoom(L));
  }), Ht(() => r.pitch, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setPitch(L));
  }), Ht(() => r.renderWorldCopies, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setRenderWorldCopies(L));
  }), Ht(() => r.mapStyle, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setStyle(L));
  }), Ht(() => r.transformRequest, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setTransformRequest(L));
  }), Ht(() => r.zoom, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setZoom(L));
  }), Ht(() => r.zoom, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setZoom(L));
  });
  function P() {
    C.isMounted = true;
    const L = { ...r, style: r.mapStyle, container: d.value };
    for (const $ of Object.keys(L)) L[$] === void 0 && delete L[$];
    if (f.value = l_(new jl.Map(L)), C.map = f.value, g.value = true, s.set("__load", () => (p.value = true, C.isLoaded = true)), f.value.on("load", s.get("__load")), s.set("__moveend", () => i.emit("update:center", f.value.getCenter())), f.value.on("moveend", s.get("__moveend")), s.set("__zoomend", () => i.emit("update:zoom", f.value.getZoom())), f.value.on("zoomend", s.get("__zoomend")), s.set("__pitchend", () => i.emit("update:pitch", f.value.getPitch())), f.value.on("pitchend", s.get("__pitchend")), s.set("__rotateend", () => i.emit("update:bearing", f.value.getBearing())), f.value.on("rotateend", s.get("__rotateend")), l.vnode.props) {
      for (const $ of V6) if (l.vnode.props["onMap:" + $]) {
        const z = `map:${$}`, F = U6(l, f.value, i, z);
        s.set($, F), f.value.on($, F);
      }
    }
    f.value.getCanvas().addEventListener("webglcontextlost", D);
  }
  async function M() {
    C.isMounted = false, C.isLoaded = false, p.value = false, f.value && (f.value.getCanvas().removeEventListener("webglcontextlost", D), g.value = false, s.forEach((L, $) => {
      f.value.off($.startsWith("__") ? $.substring(2) : $, L);
    }), f.value.remove());
  }
  function D() {
    M(), Wn(P);
  }
  return Ri(P), Pn(M), i.expose({ map: f }), () => [B("div", { ref: d, style: { height: r.height, width: r.width } }), g.value && i.slots.default ? i.slots.default({}) : void 0];
}, render() {
  return null;
} });
function Z6(r, i, l) {
  Ht(r, (d) => {
    var _a3, _b2;
    d && mh.indexOf(d) === -1 || (((_a3 = i.value) == null ? void 0 : _a3.hasControl(l)) && i.value.removeControl(l), (_b2 = i.value) == null ? void 0 : _b2.addControl(l, d));
  }, { immediate: true });
}
function zp(r, i) {
  const l = ur(Vl), d = ur(y1), f = Ca();
  return f.value = r(), Z6(() => i.position, l, f.value), Pn(() => {
    var _a3;
    return d.value && ((_a3 = l.value) == null ? void 0 : _a3.removeControl(f.value));
  }), { control: f, map: l };
}
class H6 {
  constructor(i, l) {
    __publicField(this, "container");
    this.isAdded = i, this.container = document.createElement("div"), this.setClasses(l);
  }
  getDefaultPosition() {
    return Dp.TOP_LEFT;
  }
  onAdd() {
    return Wn(() => this.isAdded.value = true), this.container;
  }
  onRemove() {
    this.isAdded.value = false, this.container.remove();
  }
  setClasses(i) {
    this.container.className = i;
  }
}
const Fp = ot({ name: "MglCustomControl", props: { position: { type: String, validator: (r) => mh.indexOf(r) !== -1 }, class: { type: String, default: "maplibregl-ctrl maplibregl-ctrl-group" } }, slots: Object, setup(r, { slots: i }) {
  const l = Ie(false), { control: d } = zp(() => new H6(l, r.class), r);
  return Ht(() => r.class, () => d.value.setClasses(r.class)), () => {
    var _a3;
    return l.value ? B(By, { to: d.value.container }, (_a3 = i.default) == null ? void 0 : _a3.call(i, {})) : Pr("custom-component");
  };
}, render() {
  return null;
} }), w1 = ot({ name: "MglFullscreenControl", props: { position: { type: String, validator: (r) => mh.indexOf(r) !== -1 }, container: { type: Object, default: null } }, setup(r) {
  const { control: i, map: l } = zp(() => new jl.FullscreenControl({ container: r.container || void 0 }), r);
  function d() {
    Wn(() => {
      var _a3;
      return (_a3 = l.value) == null ? void 0 : _a3.resize();
    });
  }
  i.value.on("fullscreenstart", d), i.value.on("fullscreenend", d), Pn(() => {
    i.value.off("fullscreenstart", d), i.value.off("fullscreenend", d);
  });
}, render() {
  return null;
} }), C1 = ot({ name: "MglNavigationControl", props: { position: { type: String, validator: (r) => mh.indexOf(r) !== -1 }, showCompass: { type: Boolean, default: true }, showZoom: { type: Boolean, default: true }, visualizePitch: Boolean }, setup(r) {
  zp(() => new jl.NavigationControl({ showCompass: r.showCompass, showZoom: r.showZoom, visualizePitch: r.visualizePitch }), r);
}, render() {
  return null;
} });
var S1 = ((r) => (r.IMPERIAL = "imperial", r.METRIC = "metric", r.NAUTICAL = "nautical", r))(S1 || {});
const X6 = Object.values(S1), k1 = ot({ name: "MglScaleControl", props: { position: { type: String, validator: (r) => mh.indexOf(r) !== -1 }, maxWidth: { type: Number, default: 100 }, unit: { type: String, default: "metric", validator: (r) => X6.indexOf(r) !== -1 } }, setup(r) {
  zp(() => new jl.ScaleControl({ maxWidth: r.maxWidth, unit: r.unit }), r);
}, render() {
  return null;
} }), Y6 = ot({ name: "MglMarker", emits: ["dragstart", "drag", "dragend", "update:coordinates"], props: { coordinates: { type: [Object, Array], required: true }, className: String, offset: [Object, Array], anchor: String, color: String, draggable: Boolean, clickTolerance: Number, rotation: Number, rotationAlignment: String, pitchAlignment: String, scale: Number, opacity: String, opacityWhenCovered: String, subpixelPositioning: { type: Boolean, default: false } }, setup(r, { slots: i, emit: l }) {
  const d = ur(Vl), f = Ca(), g = Ie(), p = Ie(false), s = /* @__PURE__ */ new Map();
  function C(P, M) {
    const D = (L) => {
      M && M(), l(P, L);
    };
    f.value.on(P, D), s.set(P, D);
  }
  return Xr(N6, f), Ri(() => {
    const P = { ...r };
    i.marker && (P.element = g.value), f.value = new jl.Marker(P), f.value.setLngLat(r.coordinates).addTo(d.value), C("dragstart"), C("drag", () => {
      var _a3;
      l("update:coordinates", (_a3 = f.value) == null ? void 0 : _a3.getLngLat());
    }), C("dragend", () => {
      var _a3;
      l("update:coordinates", (_a3 = f.value) == null ? void 0 : _a3.getLngLat());
    }), p.value = true;
  }), Ht(() => r.coordinates, (P) => {
    var _a3;
    return (_a3 = f.value) == null ? void 0 : _a3.setLngLat(P);
  }, { deep: true }), Ht(() => r.draggable, (P) => {
    var _a3;
    return (_a3 = f.value) == null ? void 0 : _a3.setDraggable(P);
  }), Ht(() => r.offset, (P) => {
    var _a3;
    return (_a3 = f.value) == null ? void 0 : _a3.setOffset(P || [0, 0]);
  }), Ht(() => r.pitchAlignment, (P) => {
    var _a3;
    return (_a3 = f.value) == null ? void 0 : _a3.setPitchAlignment(P || "auto");
  }), Ht(() => r.rotation, (P) => {
    var _a3;
    return (_a3 = f.value) == null ? void 0 : _a3.setRotation(P);
  }), Ht(() => r.rotationAlignment, (P) => {
    var _a3;
    return (_a3 = f.value) == null ? void 0 : _a3.setRotationAlignment(P || "auto");
  }), Ht(() => r.opacity, (P) => {
    var _a3;
    return (_a3 = f.value) == null ? void 0 : _a3.setOpacity(P, r.opacityWhenCovered);
  }), Ht(() => r.opacityWhenCovered, (P) => {
    var _a3;
    return (_a3 = f.value) == null ? void 0 : _a3.setOpacity(r.opacity, P);
  }), Ht(() => r.subpixelPositioning, (P) => {
    var _a3;
    return (_a3 = f.value) == null ? void 0 : _a3.setSubpixelPositioning(P);
  }), Ht(() => r.className, (P, M) => {
    var _a3, _b2;
    M && ((_a3 = f.value) == null ? void 0 : _a3.removeClassName(M)), P && ((_b2 = f.value) == null ? void 0 : _b2.addClassName(P));
  }), Pn(() => {
    var _a3;
    s.forEach((P, M) => {
      var _a4;
      (_a4 = f.value) == null ? void 0 : _a4.off(M, P);
    }), (_a3 = f.value) == null ? void 0 : _a3.remove();
  }), () => [B("div", i.default && p.value ? i.default({}) : void 0), B("div", { ref: g }, i.marker ? i.marker() : void 0)];
}, render() {
  return null;
} });
let K6 = class {
  constructor() {
    __publicField(this, "unmountHandlers", /* @__PURE__ */ new Map());
  }
  registerUnmountHandler(i, l) {
    this.unmountHandlers.set(i, l);
  }
  unregisterUnmountHandler(i) {
    this.unmountHandlers.delete(i);
  }
  unmount() {
    this.unmountHandlers.forEach((i) => i());
  }
}, _0 = (_a = class {
  static genSourceOpts(i) {
    const l = { ...i };
    for (const d of Object.keys(l)) (l[d] === void 0 || d === "sourceId") && delete l[d];
    return l;
  }
  static getSourceRef(i, l) {
    const d = typeof l == "string", f = String(i) + (d ? l : "");
    let g = _a.REFS.get(f);
    return g || (g = Ie(d ? null : void 0), _a.REFS.set(f, g)), g;
  }
}, __publicField(_a, "REFS", /* @__PURE__ */ new Map()), _a);
function J6(r, i, l) {
  const d = ur(Vl), f = ur(ph);
  function g() {
    f.value && (d.value.addSource(i.sourceId, _0.genSourceOpts(i)), r.value = d.value.getSource(i.sourceId));
  }
  return Ht(f, g, { immediate: true }), d.value.on("style.load", g), Pn(() => {
    f.value && (l.unmount(), d.value.removeSource(i.sourceId)), d.value.off("style.load", g);
  });
}
const Q6 = ot({ name: "MglGeoJsonSource", props: { sourceId: { type: String, required: true }, data: { type: [Object, String], required: true }, maxzoom: Number, attribution: String, buffer: Number, tolerance: Number, cluster: Boolean, clusterRadius: Number, clusterMaxZoom: Number, clusterMinPoints: Number, clusterProperties: Object, lineMetrics: Boolean, generateId: Boolean, promoteId: [Object, String], filter: [Array, String, Object] }, slots: Object, setup(r, { slots: i }) {
  const l = ur(g0), d = _0.getSourceRef(l, r.sourceId), f = new K6(), g = { ...r, type: "geojson" };
  return Xr(v0, r.sourceId), Xr(b1, f), J6(d, g, f), Ht([bw(r.data) ? r.data : () => r.data, d], ([p, s]) => {
    s == null ? void 0 : s.setData(p || { type: "FeatureCollection", features: [] });
  }, { immediate: true }), () => [Pr("GeoJSON Source"), d.value && i.default ? i.default({}) : void 0];
} }), ta = ["click", "dblclick", "mousedown", "mouseup", "mousemove", "mouseenter", "mouseleave", "mouseover", "mouseout", "contextmenu", "touchstart", "touchend", "touchcancel"];
function Vs() {
  return { layerId: { type: String, required: true }, source: { type: String }, metadata: { type: [Object, Array, String, Number] }, sourceLayer: { type: String }, minzoom: { type: Number }, maxzoom: { type: Number }, filter: { type: Object }, before: { type: String }, layout: { type: Object }, paint: { type: Object } };
}
function e4(r, i, l, d) {
  const f = { id: r, type: i, source: l.source || d, metadata: l.metadata, minzoom: l.minzoom, maxzoom: l.maxzoom, "source-layer": l.sourceLayer, filter: l.filter, paint: l.paint, layout: l.layout };
  for (const g of Object.keys(f)) f[g] === void 0 && delete f[g];
  return f;
}
function t4(r, i, l) {
  if (l.props) for (const d of ta) {
    const f = "on" + d.charAt(0).toUpperCase() + d.substr(1);
    l.props[f] && r.on(d, i, l.props[f]);
  }
}
function r4(r, i, l) {
  if (l.props) for (const d of ta) {
    const f = "on" + d.charAt(0).toUpperCase() + d.substr(1);
    l.props[f] && r.off(d, i, l.props[f]);
  }
}
function P1(r, i) {
  const l = ur(Vl), d = ur(ph), f = ur(b1);
  function g() {
    d.value && (i && r4(l.value, r, i.vnode), l.value.getLayer(r) && l.value.removeLayer(r));
  }
  f.registerUnmountHandler(r, g), Pn(() => {
    f.unregisterUnmountHandler(r), g();
  });
}
ot({ name: "MglBackgroundLayer", props: { layerId: { type: String, required: true }, metadata: [Object, Array, String, Number], minzoom: Number, maxzoom: Number, before: String, layout: Object, paint: Object }, emits: [...ta], setup(r) {
  const i = ur(Vl), l = ur(ph);
  return P1(r.layerId), Ht(() => r.layout, (d) => {
    if (d) for (const [f, g] of Object.entries(d)) i.value.setLayoutProperty(r.layerId, f, g);
  }), Ht(() => r.paint, (d) => {
    if (d) for (const [f, g] of Object.entries(d)) i.value.setPaintProperty(r.layerId, f, g);
  }), Ht(l, (d) => {
    d && i.value.addLayer({ id: r.layerId, type: "background", metadata: r.metadata, minzoom: r.minzoom, maxzoom: r.maxzoom, layout: r.layout, paint: r.paint }, r.before || void 0);
  }, { immediate: true }), () => Pr("Background Layer");
} });
function Us(r, i) {
  const l = ur(v0);
  if (!l && !i.source) return;
  const d = lh(), f = ur(Vl), g = ur(ph), p = ur(g0), s = _0.getSourceRef(p, i.source || l);
  return P1(i.layerId, d), Ht(() => i.minzoom, () => f.value.setLayerZoomRange(i.layerId, i.minzoom || 0, i.maxzoom || 24)), Ht(() => i.maxzoom, () => f.value.setLayerZoomRange(i.layerId, i.minzoom || 0, i.maxzoom || 24)), Ht(() => i.layout, (C) => {
    if (C) for (const [P, M] of Object.entries(C)) f.value.setLayoutProperty(i.layerId, P, M);
  }, { deep: true }), Ht(() => i.paint, (C) => {
    if (C) for (const [P, M] of Object.entries(C)) f.value.setPaintProperty(i.layerId, P, M);
  }, { deep: true }), Ht(() => i.filter, (C) => f.value.setFilter(i.layerId, C), { deep: true }), Ht([g, s], ([C, P]) => {
    C && (P || P === void 0) && (f.value.addLayer(e4(i.layerId, r, i, l), i.before || void 0), t4(f.value, i.layerId, d.vnode));
  }, { immediate: true }), () => Pr(`${r} Layer`);
}
ot({ name: "MglCircleLayer", props: Vs(), emits: [...ta], setup(r) {
  return Us("circle", r);
} });
ot({ name: "MglFillLayer", props: Vs(), emits: [...ta], setup(r) {
  return Us("fill", r);
} });
ot({ name: "MglFillExtrusionLayer", props: Vs(), emits: [...ta], setup(r) {
  return Us("fill-extrusion", r);
} });
ot({ name: "MglHeatmapLayer", props: Vs(), emits: [...ta], setup(r) {
  return Us("heatmap", r);
} });
ot({ name: "MglHillshadeLayer", props: Vs(), emits: [...ta], setup(r) {
  return Us("hillshade", r);
} });
const i4 = ot({ name: "MglLineLayer", props: Vs(), emits: [...ta], setup(r) {
  return Us("line", r);
} });
ot({ name: "MglRasterLayer", props: Vs(), emits: [...ta], setup(r) {
  return Us("raster", r);
} });
ot({ name: "MglSymbolLayer", props: Vs(), emits: [...ta], setup(r) {
  return Us("symbol", r);
} });
const n4 = 0.3, o4 = ot({ __name: "MapCompass", props: os({ pitch: {}, size: {}, tracking: { type: Boolean } }, { bearing: { default: 0 }, bearingModifiers: {} }), emits: os(["toggleTracking"], ["update:bearing"]), setup(r, { emit: i }) {
  Ns((J) => ({ v1c8003b6: H(l).primaryColor, v11ea132b: H(l).modalColor, v1738aa7c: H(l).borderColor, v34c26392: H(l).textColorBase }));
  const l = $s(), d = r, f = cc(r, "bearing"), g = i, p = Ee(() => `transform: rotate(${-f.value % 360}deg)`), s = Ee(() => `transform: rotateX(${Math.min(45, d.pitch ? d.pitch : 0)}deg); transition: all 0.3s ease;`), C = Ee(() => d.size || 40), P = Ee(() => C.value / 6), M = Ee(() => P.value / 2), D = Ee(() => C.value / 8), L = Ee(() => D.value / 2), $ = Ee(() => C.value / 3), z = Ee(() => ({ width: `${P.value}px`, height: `${P.value}px`, top: "0px", left: `calc(50% - ${P.value / 2}px)`, transform: `translateY(-${M.value}px)` })), F = Ee(() => ({ width: `${D.value}px`, height: `${D.value}px`, top: `calc(50% - ${D.value / 2}px)`, right: "0px", transform: `translateX(${L.value}px)` })), Z = Ee(() => ({ width: `${D.value}px`, height: `${D.value}px`, bottom: "0px", left: `calc(50% - ${D.value / 2}px)`, transform: `translateY(${L.value}px)` })), q = Ee(() => ({ width: `${D.value}px`, height: `${D.value}px`, top: `calc(50% - ${D.value / 2}px)`, left: "0px", transform: `translateX(-${L.value}px)` })), K = Ee(() => ({ height: `${$.value}px`, width: "100%", top: `calc(50% - ${$.value / 2}px)`, fontSize: `${$.value}px`, lineHeight: `${$.value}px` })), te = Ee(() => ({ width: `${C.value}px`, height: `${C.value}px` })), re = ["N", "E", "S", "W"], ie = Ee(() => {
    const J = f.value > 0 ? f.value : 360 + f.value;
    return re[Math.round(J % 360 / 90) % 4];
  });
  return Ri(() => {
    const J = document.querySelector(".map-compass");
    J.onclick = () => {
      g("toggleTracking"), d.tracking || (f.value = 0);
    }, J && J.addEventListener("wheel", (we) => {
      if (d.tracking) return;
      we.preventDefault();
      const fe = (f.value + we.deltaY * n4) % 360;
      f.value = Math.round(fe >= 0 ? fe : 360 + fe);
    });
  }), (J, we) => (ct(), $t("div", { style: Sn(s.value) }, [yt("div", { class: Qo(["map-compass", { "tracking-active": d.tracking }]), style: Sn(te.value) }, [yt("div", { class: "compass-panel", style: Sn(p.value) }, [yt("div", { class: "pin north-pin", style: Sn(z.value) }, null, 4), yt("div", { class: "pin east-pin", style: Sn(F.value) }, null, 4), yt("div", { class: "pin south-pin", style: Sn(Z.value) }, null, 4), yt("div", { class: "pin west-pin", style: Sn(q.value) }, null, 4)], 4), yt("span", { class: "compass-orientation-text", style: Sn(K.value) }, Kt(ie.value), 5)], 6)], 4));
} }), a4 = Ni(o4, [["__scopeId", "data-v-0f30b63f"]]), wn = [];
for (let r = 0; r < 256; ++r) wn.push((r + 256).toString(16).slice(1));
function s4(r, i = 0) {
  return (wn[r[i + 0]] + wn[r[i + 1]] + wn[r[i + 2]] + wn[r[i + 3]] + "-" + wn[r[i + 4]] + wn[r[i + 5]] + "-" + wn[r[i + 6]] + wn[r[i + 7]] + "-" + wn[r[i + 8]] + wn[r[i + 9]] + "-" + wn[r[i + 10]] + wn[r[i + 11]] + wn[r[i + 12]] + wn[r[i + 13]] + wn[r[i + 14]] + wn[r[i + 15]]).toLowerCase();
}
let dg;
const l4 = new Uint8Array(16);
function u4() {
  if (!dg) {
    if (typeof crypto > "u" || !crypto.getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    dg = crypto.getRandomValues.bind(crypto);
  }
  return dg(l4);
}
const c4 = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), ry = { randomUUID: c4 };
function Zd(r, i, l) {
  var _a3;
  if (ry.randomUUID && !r) return ry.randomUUID();
  r = r || {};
  const d = r.random ?? ((_a3 = r.rng) == null ? void 0 : _a3.call(r)) ?? u4();
  if (d.length < 16) throw new Error("Random bytes length must be >= 16");
  return d[6] = d[6] & 15 | 64, d[8] = d[8] & 63 | 128, s4(d);
}
function Jo() {
  return { name: "Untitled", description: "A new geographic item", creation_timestamp: Date.now(), modification_timestamp: Date.now(), created_by: "anonymous", modified_by: "anonymous", tags: [] };
}
function d4() {
  return { ...Jo(), version: 1, signature: void 0 };
}
class Ol {
  constructor(i = Zd(), l, d, f) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "routes");
    __publicField(this, "drafts");
    this.id = i, this.routes = l || { id: Zd(), meta: Jo(), routes: [] }, this.drafts = d || { id: Zd(), meta: Jo(), drafts: [] }, this.meta = { ...d4(), ...f };
  }
  toStorage() {
    return { id: this.id, meta: this.meta, routes: this.routes, drafts: this.drafts };
  }
  static fromStorage(i) {
    return new Ol(i.id, i.routes, i.drafts, i.meta);
  }
  clone() {
    return Ol.fromStorage(this.toStorage());
  }
  updateName(i) {
    this.meta.name = i, this.meta.modification_timestamp = Date.now();
  }
  updateDescription(i) {
    this.meta.description = i, this.meta.modification_timestamp = Date.now();
  }
  addTag(i) {
    this.meta.tags.includes(i) || (this.meta.tags.push(i), this.meta.modification_timestamp = Date.now());
  }
  removeTag(i) {
    const l = this.meta.tags.indexOf(i);
    l > -1 && (this.meta.tags.splice(l, 1), this.meta.modification_timestamp = Date.now());
  }
}
class h4 {
  constructor(i = [], l = Zd(), d = Jo()) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "routesInternal");
    this.id = l, this.meta = d || Jo(), this.routesInternal = i;
  }
  get name() {
    return this.meta || (this.meta = Jo()), this.meta.name;
  }
  set name(i) {
    this.meta || (this.meta = Jo()), this.meta.name = i;
  }
  get routes() {
    return Qa(this.routesInternal);
  }
  set routes(i) {
    this.routesInternal = Qa(i);
  }
  findRoute(i) {
    return this.routesInternal.find((l) => l.id === i);
  }
  existRoute(i) {
    return this.routesInternal.some((l) => l.id === i);
  }
  addRoute(i) {
    if (this.existRoute(i.id)) throw new Error(`[CartoSketch.Route] Route ${i.id} already exist`);
    this.routesInternal.push(Qa(i)), this.updateModificationTime();
  }
  updateRoute(i) {
    const l = this.routesInternal.findIndex((d) => d.id === i.id);
    if (l === -1) throw new Error(`[CartoSketch.Route] Route ${i.id} not found`);
    this.routesInternal[l] = Qa(i), this.updateModificationTime();
  }
  removeRoute(i) {
    const l = this.routesInternal.findIndex((d) => d.id === i);
    l !== -1 && (this.routesInternal.splice(l, 1), this.updateModificationTime());
  }
  updateModificationTime() {
    this.meta.modification_timestamp = Date.now();
  }
  exportAsGeoJSON() {
    return { type: "FeatureCollection", features: this.routesInternal.map((i) => i.exportAsGeoJSON()), properties: this.meta };
  }
  exportToStorage() {
    return Object.freeze({ id: this.id, meta: this.meta, routes: this.routesInternal.map((i) => i.exportToStorage()) });
  }
}
class hg {
  constructor(i = Zd(), l = [], d = {}, f) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "properties");
    __publicField(this, "points");
    this.id = i, this.meta = { ...Jo(), record_timespan: 0, ...f }, this.properties = d, this.points = l;
  }
  get name() {
    return this.meta || (this.meta = Jo()), this.meta.name;
  }
  set name(i) {
    this.meta || (this.meta = Jo()), this.meta.name = i;
  }
  get distance() {
    return this.meta.distance || 0;
  }
  set distance(i) {
    this.meta.distance = i;
  }
  get recordTimespan() {
    return this.meta.record_timespan || 0;
  }
  set recordTimespan(i) {
    this.meta.record_timespan = i;
  }
  setPoints(i) {
    this.points = Qa(i), this.updateModificationTime();
  }
  appendPoint(i) {
    this.points.push(Qa(i)), this.updateModificationTime();
  }
  getPoints() {
    return Qa(this.points);
  }
  setProperties(i) {
    const l = Qa(i);
    Object.assign(this.properties, l), this.updateModificationTime();
  }
  updateModificationTime() {
    this.meta.modification_timestamp = Date.now();
  }
  exportAsGeoJSON() {
    return { type: "Feature", properties: { ...this.properties, ...this.meta, description: JSON.stringify({ name: this.meta.name, id: this.id }) }, geometry: { type: "LineString", coordinates: this.points.map((i) => [i.longitude, i.latitude]) } };
  }
  exportToStorage() {
    return Qa({ id: this.id, meta: this.meta, properties: this.properties, points: this.points });
  }
}
var ei = ((r) => (r.MIGRATION_FAILED = "MIGRATION_FAILED", r.INVALID_VERSION = "INVALID_VERSION", r.UNSUPPORTED_VERSION = "UNSUPPORTED_VERSION", r.ROLLBACK_FAILED = "ROLLBACK_FAILED", r.VALIDATION_FAILED = "VALIDATION_FAILED", r.STRATEGY_NOT_FOUND = "STRATEGY_NOT_FOUND", r.DATA_CORRUPTION = "DATA_CORRUPTION", r))(ei || {});
class gi extends ww {
  constructor(i, l = "MIGRATION_FAILED", d) {
    super(i, d);
    __publicField(this, "code");
    __publicField(this, "domain", Cw.GENERIC);
    this.code = l;
  }
}
class _a2 extends gi {
  constructor(i, l = "INVALID_VERSION", d, f, g) {
    super(i, l, g), this.currentVersion = d, this.targetVersion = f;
  }
}
class Gr extends gi {
  constructor(i, l, d, f) {
    super(i, "VALIDATION_FAILED", f), this.field = l, this.value = d;
  }
}
class iy extends gi {
  constructor(i, l, d) {
    super(i, "DATA_CORRUPTION", d), this.corruptedData = l;
  }
}
class f4 extends gi {
  constructor(i, l, d, f) {
    super(i, "ROLLBACK_FAILED", f), this.originalError = l, this.rollbackError = d;
  }
}
class Bd {
  static getCurrentVersion() {
    return this.CURRENT_VERSION;
  }
  static getMinimumSupportedVersion() {
    return this.MIN_SUPPORTED_VERSION;
  }
  static extractVersion(i) {
    try {
      if (typeof i == "object" && i !== null && "version" in i) {
        const l = i.version;
        if (typeof l == "number" && l >= 0) return ji(l);
      }
      if (this.isRouteCollectionFormat(i)) return ji(0);
      if (this.isSketchArrayFormat(i)) return ji(1);
      throw new Error("Unable to determine data version");
    } catch (l) {
      const d = l instanceof _a2 ? l : new _a2(`Failed to extract version from data: ${l}`, ei.INVALID_VERSION, void 0, void 0, l instanceof Error ? l : new Error(String(l)));
      return Fr(d);
    }
  }
  static isRouteCollectionFormat(i) {
    return typeof i == "object" && i !== null && "routes" in i && !("sketches" in i) && Array.isArray(i.routes);
  }
  static isSketchArrayFormat(i) {
    return Array.isArray(i) && i.length > 0 && this.isSketchObject(i[0]);
  }
  static isSketchObject(i) {
    return typeof i == "object" && i !== null && "id" in i && "meta" in i && "routes" in i && "drafts" in i;
  }
  static validateVersion(i) {
    try {
      if (i < this.MIN_SUPPORTED_VERSION) throw new _a2(`Version ${i} is below minimum supported version ${this.MIN_SUPPORTED_VERSION}`, ei.UNSUPPORTED_VERSION, i);
      if (i > this.CURRENT_VERSION) throw new _a2(`Version ${i} is above current version ${this.CURRENT_VERSION}`, ei.UNSUPPORTED_VERSION, i, this.CURRENT_VERSION);
      return ji(void 0);
    } catch (l) {
      const d = l instanceof _a2 ? l : new _a2(`Version validation failed: ${l}`, ei.INVALID_VERSION, i, void 0, l instanceof Error ? l : new Error(String(l)));
      return Fr(d);
    }
  }
  static addVersionMetadata(i, l = this.CURRENT_VERSION) {
    return { ...i, [this.VERSION_KEY]: { version: l, timestamp: Date.now(), description: `Version ${l} data format` } };
  }
  static extractVersionMetadata(i) {
    try {
      if (typeof i == "object" && i !== null && this.VERSION_KEY in i) {
        const l = i[this.VERSION_KEY];
        if (this.isValidVersionInfo(l)) return ji(l);
      }
      return ji(null);
    } catch (l) {
      const d = l instanceof _a2 ? l : new _a2(`Failed to extract version metadata: ${l}`, ei.INVALID_VERSION, void 0, void 0, l instanceof Error ? l : new Error(String(l)));
      return Fr(d);
    }
  }
  static isValidVersionInfo(i) {
    return typeof i == "object" && i !== null && "version" in i && "timestamp" in i && typeof i.version == "number" && typeof i.timestamp == "number";
  }
  static determineMigrationPath(i, l) {
    try {
      const d = this.validateVersion(i);
      if (d.isErr()) throw d.error;
      const f = this.validateVersion(l);
      if (f.isErr()) throw f.error;
      if (i === l) return ji([]);
      const g = [], p = i < l ? 1 : -1;
      for (let s = i; s !== l; s += p) g.push(s + p);
      return ji(g);
    } catch (d) {
      const f = d instanceof _a2 ? d : new _a2(`Failed to determine migration path: ${d}`, ei.INVALID_VERSION, i, l, d instanceof Error ? d : new Error(String(d)));
      return Fr(f);
    }
  }
  static isMigrationNeeded(i) {
    return this.extractVersion(i).map((l) => l !== this.CURRENT_VERSION);
  }
}
__publicField(Bd, "CURRENT_VERSION", 1);
__publicField(Bd, "VERSION_KEY", "_data_version");
__publicField(Bd, "MIN_SUPPORTED_VERSION", 0);
class es {
  static validateSketchData(i) {
    try {
      if (!i || typeof i != "object") throw new Gr("Sketch data must be an object", "data", i);
      const l = i, d = ["id", "meta", "routes", "drafts"];
      for (const g of d) if (!(g in l)) throw new Gr(`Missing required field: ${g}`, g, l[g]);
      if (typeof l.id != "string" || !l.id) throw new Gr("Sketch ID must be a non-empty string", "id", l.id);
      if (!l.meta || typeof l.meta != "object") throw new Gr("Sketch meta must be an object", "meta", l.meta);
      const f = this.validateRouteCollectionData(l.routes);
      if (f.isErr()) throw f.error;
      if (!l.drafts || typeof l.drafts != "object") throw new Gr("Sketch drafts must be an object", "drafts", l.drafts);
      return ji(l);
    } catch (l) {
      if (l instanceof Gr) return Fr(l);
      const d = new Gr(`Unexpected validation error: ${l}`, void 0, i, l instanceof Error ? l : new Error(String(l)));
      return Fr(d);
    }
  }
  static validateRouteCollectionData(i) {
    try {
      if (!i || typeof i != "object") throw new Gr("Route collection data must be an object", "data", i);
      const l = i, d = ["id", "meta", "routes"];
      for (const f of d) if (!(f in l)) throw new Gr(`Missing required field: ${f}`, f, l[f]);
      if (typeof l.id != "string" || !l.id) throw new Gr("Route collection ID must be a non-empty string", "id", l.id);
      if (!l.meta || typeof l.meta != "object") throw new Gr("Route collection meta must be an object", "meta", l.meta);
      if (!Array.isArray(l.routes)) throw new Gr("Routes must be an array", "routes", l.routes);
      for (let f = 0; f < l.routes.length; f++) {
        const g = l.routes[f], p = this.validateRouteItem(g);
        if (p.isErr()) throw new Gr(`Invalid route at index ${f}: ${p.error.message}`, `routes[${f}]`, g, p.error);
      }
      return ji(l);
    } catch (l) {
      if (l instanceof Gr) return Fr(l);
      const d = new Gr(`Unexpected validation error: ${l}`, void 0, i, l instanceof Error ? l : new Error(String(l)));
      return Fr(d);
    }
  }
  static validateRouteItem(i) {
    try {
      if (!i || typeof i != "object") throw new Gr("Route item must be an object", "data", i);
      const l = i, d = ["id", "meta", "properties", "points"];
      for (const f of d) if (!(f in l)) throw new Gr(`Missing required field: ${f}`, f, l[f]);
      if (typeof l.id != "string" || !l.id) throw new Gr("Route item ID must be a non-empty string", "id", l.id);
      if (!Array.isArray(l.points)) throw new Gr("Route points must be an array", "points", l.points);
      for (let f = 0; f < l.points.length; f++) {
        const g = l.points[f];
        if (!g || typeof g != "object") throw new Gr(`Route point at index ${f} must be an object`, `points[${f}]`, g);
        const p = g;
        if (typeof p.latitude != "number" || typeof p.longitude != "number") throw new Gr(`Route point at index ${f} must have numeric latitude and longitude`, `points[${f}]`, g);
      }
      return ji(l);
    } catch (l) {
      if (l instanceof Gr) return Fr(l);
      const d = new Gr(`Unexpected validation error: ${l}`, void 0, i, l instanceof Error ? l : new Error(String(l)));
      return Fr(d);
    }
  }
  static validateSketchArray(i) {
    try {
      if (!Array.isArray(i)) throw new Gr("Sketch array must be an array", "data", i);
      if (i.length === 0) throw new Gr("Sketch array cannot be empty", "data.length", i.length);
      for (let l = 0; l < i.length; l++) {
        const d = i[l], f = this.validateSketchData(d);
        if (f.isErr()) throw new Gr(`Invalid sketch at index ${l}: ${f.error.message}`, `[${l}]`, d, f.error);
      }
      return ji(i);
    } catch (l) {
      if (l instanceof Gr) return Fr(l);
      const d = new Gr(`Unexpected validation error: ${l}`, void 0, i, l instanceof Error ? l : new Error(String(l)));
      return Fr(d);
    }
  }
  static validateData(i, l) {
    switch (l) {
      case "sketch":
        return this.validateSketchData(i);
      case "route-collection":
        return this.validateRouteCollectionData(i);
      case "sketch-array":
        return this.validateSketchArray(i);
      default:
        return Fr(new Gr(`Unknown expected format: ${l}`, "expectedFormat", l));
    }
  }
  static checkDataIntegrity(i, l) {
    try {
      const d = this.validateData(i, l);
      return d.isErr() ? Fr(new iy(`Data validation failed: ${d.error.message}`, i, d.error)) : ji({ isValid: true, errors: [], warnings: [] });
    } catch (d) {
      return Fr(new iy(`Data integrity check failed: ${d}`, i, d instanceof Error ? d : new Error(String(d))));
    }
  }
}
class p4 {
  constructor() {
    __publicField(this, "fromVersion", 0);
    __publicField(this, "toVersion", 1);
    __publicField(this, "name", "route-collection-to-sketch");
  }
  migrate(i) {
    try {
      const l = es.validateRouteCollectionData(i);
      if (l.isErr()) return Fr(new gi(`Invalid route collection data: ${l.error.message}`, ei.VALIDATION_FAILED, l.error));
      const d = l.value, f = new Ol();
      f.meta.name = d.meta.name || "Migrated Routes", f.meta.description = d.meta.description || "Migrated from route collection", f.meta.creation_timestamp = d.meta.creation_timestamp, f.meta.modification_timestamp = Date.now(), f.routes = d;
      const g = [f.toStorage()];
      return ji(g);
    } catch (l) {
      return Fr(new gi(`Route collection to sketch migration failed: ${l}`, ei.MIGRATION_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
  rollback(i) {
    try {
      const l = es.validateSketchArray(i);
      if (l.isErr()) return Fr(new gi(`Invalid sketch array data for rollback: ${l.error.message}`, ei.VALIDATION_FAILED, l.error));
      const d = l.value;
      if (d.length === 0) return Fr(new gi("Cannot rollback: empty sketch array", ei.MIGRATION_FAILED));
      const f = d[0];
      return ji(f.routes);
    } catch (l) {
      return Fr(new gi(`Route collection to sketch rollback failed: ${l}`, ei.ROLLBACK_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
  validateBefore(i) {
    return es.validateRouteCollectionData(i).map(() => {
    }).mapErr((l) => new Gr(`Pre-migration validation failed: ${l.message}`, l.field, l.value, l));
  }
  validateAfter(i) {
    return es.validateSketchArray(i).map(() => {
    }).mapErr((l) => new Gr(`Post-migration validation failed: ${l.message}`, l.field, l.value, l));
  }
}
class m4 {
  constructor() {
    __publicField(this, "fromVersion", 1);
    __publicField(this, "toVersion", 2);
    __publicField(this, "name", "sketch-v1-to-v2");
  }
  migrate() {
    return Fr(new gi("Sketch V1 to V2 migration not yet implemented", ei.STRATEGY_NOT_FOUND));
  }
  validateBefore(i) {
    return es.validateSketchArray(i).map(() => {
    }).mapErr((l) => new Gr(`Pre-migration validation failed: ${l.message}`, l.field, l.value, l));
  }
  validateAfter(i) {
    return Fr(new Gr("Sketch V2 validation not yet implemented", void 0, i));
  }
}
const _g4 = class _g4 {
  static register(i) {
    const l = this.getStrategyKey(i.fromVersion, i.toVersion);
    this.strategies.set(l, i);
  }
  static getStrategy(i, l) {
    const d = this.getStrategyKey(i, l), f = this.strategies.get(d);
    return f ? ji(f) : Fr(new gi(`No migration strategy found for version ${i} to ${l}`, ei.STRATEGY_NOT_FOUND));
  }
  static getAllStrategies() {
    return Array.from(this.strategies.values());
  }
  static hasStrategy(i, l) {
    const d = this.getStrategyKey(i, l);
    return this.strategies.has(d);
  }
  static getStrategyKey(i, l) {
    return `${i}->${l}`;
  }
};
__publicField(_g4, "strategies", /* @__PURE__ */ new Map());
_g4.register(new p4()), _g4.register(new m4());
let g4 = _g4;
class v4 {
  static createStrategy(i, l) {
    return g4.getStrategy(i, l);
  }
  static createStrategiesForPath(i) {
    try {
      const l = [];
      for (let d = 0; d < i.length; d++) {
        const f = d === 0 ? i[0] - 1 : i[d - 1], g = i[d], p = this.createStrategy(f, g);
        if (p.isErr()) return Fr(p.error);
        l.push(p.value);
      }
      return ji(l);
    } catch (l) {
      return Fr(new gi(`Failed to create strategies for migration path: ${l}`, ei.MIGRATION_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
}
class _4 {
  static isMigrationNeeded(i) {
    return Bd.isMigrationNeeded(i);
  }
  static getDataVersion(i) {
    return Bd.extractVersion(i);
  }
  static migrateToCurrent(i, l = {}) {
    return this.migrateToVersion(i, Bd.getCurrentVersion(), l);
  }
  static migrateToVersion(i, l, d = {}) {
    try {
      const f = { ...this.DEFAULT_OPTIONS, ...d }, g = Bd.extractVersion(i);
      if (g.isErr()) return Fr(new gi(`Failed to extract current version: ${g.error.message}`, ei.INVALID_VERSION, g.error));
      const p = g.value;
      if (p === l) return ji({ data: i, fromVersion: p, toVersion: l, migratedVersions: [] });
      const s = Bd.determineMigrationPath(p, l);
      if (s.isErr()) return Fr(new gi(`Failed to determine migration path: ${s.error.message}`, ei.INVALID_VERSION, s.error));
      const C = s.value, P = v4.createStrategiesForPath(C);
      if (P.isErr()) return Fr(P.error);
      const M = P.value;
      if (f.validateBefore) {
        const z = this.validateDataBeforeMigration(i, p);
        if (z.isErr()) return Fr(new gi(`Pre-migration validation failed: ${z.error.message}`, ei.VALIDATION_FAILED, z.error));
      }
      const D = f.enableRollback ? i : void 0;
      let L = i;
      const $ = [];
      for (const z of M) {
        const F = this.executeMigrationWithRetry(z, L, f);
        if (F.isErr()) {
          if (f.enableRollback && D) {
            const Z = this.rollbackToVersion(D);
            if (Z.isErr()) return Fr(new f4(`Migration failed and rollback also failed: ${Z.error.message}`, F.error, Z.error));
          }
          return Fr(F.error);
        }
        L = F.value, $.push(z.toVersion);
      }
      if (f.validateAfter) {
        const z = this.validateDataAfterMigration(L, l);
        if (z.isErr()) return Fr(new gi(`Post-migration validation failed: ${z.error.message}`, ei.VALIDATION_FAILED, z.error));
      }
      return ji({ data: L, fromVersion: p, toVersion: l, migratedVersions: $, rollbackData: f.enableRollback ? D : void 0 });
    } catch (f) {
      return Fr(new gi(`Migration service error: ${f}`, ei.MIGRATION_FAILED, f instanceof Error ? f : new Error(String(f))));
    }
  }
  static executeMigrationWithRetry(i, l, d) {
    let f = null;
    for (let g = 0; g <= (d.maxRetries || 0); g++) {
      try {
        const p = i.migrate(l);
        if (p.isErr()) {
          f = p.error;
          continue;
        }
        if (i.validateAfter) {
          const s = i.validateAfter(p.value);
          if (s.isErr()) {
            f = new gi(`Post-migration validation failed: ${s.error.message}`, ei.VALIDATION_FAILED, s.error);
            continue;
          }
        }
        return ji(p.value);
      } catch (p) {
        f = new gi(`Migration attempt ${g + 1} failed: ${p}`, ei.MIGRATION_FAILED, p instanceof Error ? p : new Error(String(p)));
      }
      g < (d.maxRetries || 0) && d.retryDelay && console.warn(`Migration failed, retrying in ${d.retryDelay}ms...`);
    }
    return Fr(f || new gi("Migration failed after all retry attempts", ei.MIGRATION_FAILED));
  }
  static rollbackToVersion(i) {
    try {
      return ji(i);
    } catch (l) {
      return Fr(new gi(`Rollback failed: ${l}`, ei.ROLLBACK_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
  static validateDataBeforeMigration(i, l) {
    switch (l) {
      case 0:
        return es.validateRouteCollectionData(i).map(() => {
        }).mapErr((d) => new gi(`Route collection validation failed: ${d.message}`, ei.VALIDATION_FAILED, d));
      case 1:
        return es.validateSketchArray(i).map(() => {
        }).mapErr((d) => new gi(`Sketch array validation failed: ${d.message}`, ei.VALIDATION_FAILED, d));
      default:
        return Fr(new gi(`Unknown version for pre-migration validation: ${l}`, ei.VALIDATION_FAILED));
    }
  }
  static validateDataAfterMigration(i, l) {
    switch (l) {
      case 1:
        return es.validateSketchArray(i).map(() => {
        }).mapErr((d) => new gi(`Sketch array validation failed: ${d.message}`, ei.VALIDATION_FAILED, d));
      default:
        return Fr(new gi(`Unknown version for post-migration validation: ${l}`, ei.VALIDATION_FAILED));
    }
  }
  static checkDataIntegrity(i, l) {
    return es.checkDataIntegrity(i, l);
  }
}
__publicField(_4, "DEFAULT_OPTIONS", { validateBefore: true, validateAfter: true, enableRollback: true, maxRetries: 3, retryDelay: 1e3 });
const y0 = r0("sketches", () => {
  const r = Ie([]), i = Ie(null), l = Ie(null), d = Ee(() => {
    if (!i.value) return null;
    const fe = r.value.find((oe) => oe.id === i.value);
    return fe ? new h4(fe.routes.routes.map((oe) => new hg(oe.id, oe.points, oe.properties, oe.meta)), fe.routes.id, fe.routes.meta) : null;
  }), f = Ee(() => d.value ? d.value.routes.map((fe) => ({ id: fe.id, name: fe.name, points: fe.getPoints(), meta: fe.meta })) : []), g = Ee(() => i.value && r.value.find((fe) => fe.id === i.value) || null), p = Ee(() => g.value ? g.value.drafts.drafts : []);
  async function s() {
    const fe = await sb("sketches");
    if (fe) {
      const oe = _4.migrateToCurrent(fe, { validateBefore: true, validateAfter: true, enableRollback: true });
      if (oe.isErr()) {
        console.error("[SketchStore] Data migration failed:", oe.error), await C();
        return;
      }
      const he = oe.value;
      he.migratedVersions.length > 0 && console.info(`[SketchStore] Successfully migrated data from version ${he.fromVersion} to ${he.toVersion}`), Array.isArray(he.data) ? (r.value = he.data.map((_e) => Ol.fromStorage(_e)), r.value.forEach((_e) => {
        _e.routes.routes.forEach(async (Ue) => {
          if (Ue.points.length > 1 && !Ue.meta.distance) try {
            Ue.meta.distance = await Wm(Ue.points);
          } catch (qe) {
            console.warn("Failed to calculate route distance:", qe), Ue.meta.distance = 0;
          }
        });
      }), !i.value && r.value.length > 0 && (i.value = r.value[0].id)) : await C();
    } else await C();
  }
  async function C() {
    const fe = new Ol();
    fe.meta.name = "Default Sketch", r.value = [fe], i.value = fe.id, await go("sketches", r.value.map((oe) => oe.toStorage())), await vo();
  }
  async function P(fe = "New Sketch") {
    const oe = new Ol();
    return oe.meta.name = fe, r.value.push(oe), await go("sketches", r.value.map((he) => he.toStorage())), await vo(), oe;
  }
  async function M(fe, oe) {
    const he = r.value.find((_e) => _e.id === fe);
    he && (oe.name !== void 0 && he.updateName(oe.name), oe.description !== void 0 && he.updateDescription(oe.description), oe.tags !== void 0 && (he.meta.tags.forEach((_e) => he.removeTag(_e)), oe.tags.forEach((_e) => he.addTag(_e))), await go("sketches", r.value.map((_e) => _e.toStorage())), await vo());
  }
  async function D(fe) {
    const oe = r.value.findIndex((he) => he.id === fe);
    oe !== -1 && (r.value.splice(oe, 1), i.value === fe && (i.value = r.value.length > 0 ? r.value[0].id : null), await go("sketches", r.value.map((he) => he.toStorage())), await vo());
  }
  function L(fe) {
    i.value = fe, l.value = null;
  }
  async function $(fe, oe = {}, he = {}) {
    g.value || await C();
    const _e = new hg(void 0, [], oe, he);
    return _e.meta.name = fe, g.value && g.value.routes.routes.push(_e.exportToStorage()), await go("sketches", r.value.map((Ue) => Ue.toStorage())), await vo(), _e;
  }
  async function z(fe) {
    if (!g.value) return;
    const oe = g.value.routes.routes.findIndex((he) => he.id === fe);
    oe !== -1 && (g.value.routes.routes.splice(oe, 1), l.value === fe && (l.value = null), await go("sketches", r.value.map((he) => he.toStorage())), await vo());
  }
  async function F(fe, oe) {
    if (!g.value) return;
    const he = g.value.routes.routes.find((_e) => _e.id === fe);
    if (he) {
      if (he.points.push(oe), he.meta.modification_timestamp = Date.now(), he.points.length > 1) try {
        if (he.meta.distance) {
          const _e = await Wm([he.points[he.points.length - 2], oe]);
          he.meta.distance += _e;
        } else {
          const _e = await Wm(he.points);
          he.meta.distance = _e;
        }
      } catch (_e) {
        console.warn("Failed to calculate route distance:", _e), he.meta.distance || (he.meta.distance = 0);
      }
      await go("sketches", r.value.map((_e) => _e.toStorage())), await vo();
    }
  }
  async function Z(fe, oe) {
    if (!g.value) return;
    const he = g.value.routes.routes.find((_e) => _e.id === fe);
    he && (oe.meta !== void 0 && (he.meta = { ...he.meta, ...oe.meta }), oe.properties !== void 0 && (he.properties = { ...he.properties, ...oe.properties }), he.meta.modification_timestamp = Date.now(), await go("sketches", r.value.map((_e) => _e.toStorage())), await vo());
  }
  async function q(fe) {
    if (!g.value) return;
    const oe = g.value.routes.routes.find((he) => he.id === fe);
    oe && (oe.points = [], oe.meta.modification_timestamp = Date.now(), await go("sketches", r.value.map((he) => he.toStorage())), await vo());
  }
  function K(fe) {
    if (!g.value) return null;
    const oe = g.value.routes.routes.find((he) => he.id === fe);
    return oe ? new hg(oe.id, oe.points, oe.properties, oe.meta) : null;
  }
  function te(fe) {
    l.value = fe;
  }
  async function re(fe, oe = {}, he = {}) {
    g.value || await C();
    const _e = { id: crypto.randomUUID(), meta: { ...Jo(), ...he }, shape: fe, properties: oe };
    return g.value && g.value.drafts.drafts.push(_e), await go("sketches", r.value.map((Ue) => Ue.toStorage())), await vo(), _e;
  }
  async function ie(fe, oe) {
    if (!g.value) return;
    const he = g.value.drafts.drafts.find((_e) => _e.id === fe);
    he && (oe.shape !== void 0 && (he.shape = oe.shape), oe.properties !== void 0 && (he.properties = { ...he.properties, ...oe.properties }), oe.meta !== void 0 && (he.meta = { ...he.meta, ...oe.meta }, he.meta.modification_timestamp = Date.now()), await go("sketches", r.value.map((_e) => _e.toStorage())), await vo());
  }
  async function J(fe) {
    if (!g.value) return;
    const oe = g.value.drafts.drafts.findIndex((he) => he.id === fe);
    oe !== -1 && (g.value.drafts.drafts.splice(oe, 1), await go("sketches", r.value.map((he) => he.toStorage())), await vo());
  }
  function we(fe) {
    return g.value && g.value.drafts.drafts.find((oe) => oe.id === fe) || null;
  }
  return { sketches: r, currentSketchId: i, currentRouteId: l, routeCollection: d, routes: f, currentSketch: g, currentDrafts: p, init: s, createSketch: P, updateSketch: M, deleteSketch: D, setCurrentSketchId: L, addRoute: $, deleteRoute: z, addPointToRoute: F, updateRoute: Z, clearRoutePoints: q, getRouteById: K, setCurrentRouteId: te, addDraft: re, updateDraft: ie, deleteDraft: J, getDraftById: we };
}), T1 = r0("routes", () => {
  const r = y0(), i = Ee(() => r.routeCollection), l = Ee({ get: () => r.currentRouteId, set: (J) => r.setCurrentRouteId(J) }), d = Ie(0);
  Ht(l, (J) => {
    var _a3, _b2;
    J && (d.value = ((_b2 = (_a3 = r.getRouteById(J)) == null ? void 0 : _a3.meta) == null ? void 0 : _b2.record_timespan) ?? 0);
  });
  const f = Ie(false), g = Ie(-1), p = Ie(null);
  let s;
  const C = Ee(() => r.routes);
  function P(J) {
    p.value = J;
  }
  async function M() {
    await r.init();
  }
  async function D(J, we = {}) {
    return await r.addRoute(J, we);
  }
  async function L(J) {
    await r.deleteRoute(J);
  }
  async function $(J, we) {
    await r.addPointToRoute(J, we);
  }
  async function z(J, we) {
    await r.updateRoute(J, we);
  }
  async function F(J) {
    await r.clearRoutePoints(J);
  }
  function Z(J) {
    return r.getRouteById(J);
  }
  function q(J) {
    r.setCurrentRouteId(J);
  }
  function K(J) {
    f.value || !p.value || (f.value = true, J && $(l.value, J), g.value = p.value.addLocationListener((we) => {
      l.value && $(l.value, we);
    }), r.updateRoute(l.value, { meta: { modification_timestamp: Date.now() } }), s = setInterval(async () => {
      const we = r.getRouteById(l.value);
      we.recordTimespan !== void 0 && we.meta.modification_timestamp && (d.value = we.recordTimespan + (Date.now() - we.meta.modification_timestamp), await r.updateRoute(l.value, { meta: { record_timespan: d.value } }));
    }, 100));
  }
  function te() {
    !f.value || !p.value || (g.value !== -1 && (p.value.removeLocationListener(g.value), g.value = -1), s && (clearTimeout(s), s = void 0), f.value = false);
  }
  async function re(J) {
    try {
      if (!p.value) throw new Error("Geolocation service not available");
      if (f.value) te();
      else if (l.value) K();
      else {
        const we = await D(J("trackerView.nameNewRoute"));
        q(we.id), K(p.value.getLastKnownLocation());
      }
    } catch (we) {
      throw console.error(we), we;
    }
  }
  function ie() {
    g.value !== -1 && p.value && (p.value.removeLocationListener(g.value), g.value = -1), f.value = false;
  }
  return { routeCollection: i, routes: C, currentRouteId: l, isRecording: f, watchingHandler: g, currentRouteRecordTimespan: d, setLocator: P, init: M, addRoute: D, deleteRoute: L, addPointToRoute: $, updateRoute: z, clearRoutePoints: F, getRouteById: Z, setCurrentRouteId: q, startRecording: K, stopRecording: te, toggleRecording: re, cleanup: ie };
}), y4 = { class: "upload-container" }, b4 = { class: "action-buttons" }, x4 = ot({ __name: "TextFileUploaderDialog", props: os({ multiple: { type: Boolean }, icon: {}, prompt: {}, types: {} }, { show: { default: false, type: Boolean }, showModifiers: {} }), emits: os(["update:value", "confirm"], ["update:show"]), setup(r, { emit: i }) {
  const l = Ap(), d = r, f = i, g = cc(r, "show");
  let p = [];
  const s = (M) => {
    p = [];
    for (const D of M) {
      const L = D.file;
      if (L) if (d.types.includes(L.type)) {
        const $ = new FileReader();
        $.onload = (z) => {
          var _a3;
          ((_a3 = z.target) == null ? void 0 : _a3.result) && p.push(z.target.result), p.length === M.length && f("update:value", p);
        }, $.readAsText(L);
      } else l.warning(`Skipped file ${D.name} due to unsupported type ${L.type}`);
    }
  }, C = () => {
    f("confirm", p), g.value = false;
  }, P = (M) => {
    var _a3, _b2;
    return d.types.includes(((_a3 = M.file.file) == null ? void 0 : _a3.type) ?? "") ? true : (l.error(`Unsupported file type ${((_b2 = M.file.file) == null ? void 0 : _b2.type) ?? "unknown"}. Supported types: ['${d.types.join("', '")}']`), false);
  };
  return (M, D) => (ct(), gr(H(Kd), { show: g.value, "onUpdate:show": D[2] || (D[2] = (L) => g.value = L), preset: "dialog", title: "Dialog" }, { header: $e(() => [...D[3] || (D[3] = [yr(" File Upload ", -1)])]), default: $e(() => [yt("div", y4, [De(H(L6), { multiple: d.multiple ?? false, onChange: D[0] || (D[0] = ({ fileList: L }) => s(L)), onBeforeUpload: P }, { default: $e(() => [De(H(f1), null, { default: $e(() => [De(H(bi), { size: 36, name: "upload", class: "upload-icon" }, { default: $e(() => [(ct(), gr(_c(d.icon ?? H(Ib))))]), _: 1 }), yt("div", null, Kt(d.prompt ?? "Drag and drop a file here or click to upload"), 1)]), _: 1 })]), _: 1 }, 8, ["multiple"])])]), action: $e(() => [yt("div", b4, [De(H($r), { onClick: D[1] || (D[1] = (L) => g.value = false) }, { default: $e(() => [...D[4] || (D[4] = [yr(" Cancel ", -1)])]), _: 1 }), De(H($r), { type: "primary", onClick: C }, { default: $e(() => [...D[5] || (D[5] = [yr(" Upload ", -1)])]), _: 1 })])]), _: 1 }, 8, ["show"]));
} }), w4 = Ni(x4, [["__scopeId", "data-v-14c5a0c1"]]), C4 = ot({ __name: "MglDrawer", props: os({ position: {} }, { show: { type: Boolean, default: false }, showModifiers: {} }), emits: os(["update:width", "update:height", "click", "contextmenu"], ["update:show"]), setup(r, { emit: i }) {
  Ns((L) => ({ a1b7bba2: H(f).modalColor, v305889d2: H(f).borderRadius, v60287bc6: M.value, v048a7f4c: P.value }));
  const l = r, d = i, f = $s(), g = Sw("route-drawer"), p = Ee(() => l.position || "left"), s = Ee(() => {
    var _a3, _b2, _c2, _d;
    return Math.min(Dg(Math.round((((_b2 = (_a3 = g.value) == null ? void 0 : _a3.parentElement) == null ? void 0 : _b2.clientWidth) ?? 2e3) * 0.4), 320, 640), (((_d = (_c2 = g.value) == null ? void 0 : _c2.parentElement) == null ? void 0 : _d.clientWidth) ?? 1 / 0) - 48);
  }), C = Ee(() => {
    var _a3, _b2, _c2, _d;
    return Math.min(Dg(Math.round((((_b2 = (_a3 = g.value) == null ? void 0 : _a3.parentElement) == null ? void 0 : _b2.clientHeight) ?? 2e3) * 0.4), 320, 640), (((_d = (_c2 = g.value) == null ? void 0 : _c2.parentElement) == null ? void 0 : _d.clientHeight) ?? 1 / 0) - 48);
  }), P = Ee(() => p.value === "left" ? `${-16 - s.value}px` : p.value === "right" ? `${16 + s.value}px` : p.value === "top" ? `${-16 - C.value}px` : p.value === "bottom" ? `${16 + C.value}px` : "0px"), M = Ee(() => p.value === "left" || p.value === "right" ? `${s.value}px` : `${C.value}px`), D = cc(r, "show");
  return Ht(s, () => d("update:width", s.value)), Ht(C, () => d("update:height", C.value)), (L, $) => (ct(), gr(Eo, { name: `slide-${p.value}` }, { default: $e(() => [wa(yt("div", { ref: "route-drawer", class: Qo(["route-drawer", `route-drawer--${p.value}`]), onClick: $[0] || ($[0] = (z) => d("click", z)), onContextmenu: $[1] || ($[1] = (z) => d("contextmenu", z)) }, [yp(L.$slots, "default", {}, void 0, true)], 34), [[ns, D.value]])]), _: 3 }, 8, ["name"]));
} }), S4 = Ni(C4, [["__scopeId", "data-v-72b274a7"]]), k4 = { class: "menu-list" }, P4 = ["onClick", "onContextmenu", "onTouchstart"], T4 = { class: "swipe-container" }, I4 = { style: { height: "fit-content", padding: "8px 12px" } }, M4 = ["onClick"], E4 = { style: { padding: "16px" } }, R4 = 120, A4 = 40, D4 = ot({ __name: "SelectableSwipeableMenuList", props: os({ items: {}, menuOptions: {}, swipeActions: {} }, { selection: { type: String, default: null }, selectionModifiers: {}, multipleSelection: { type: Array, default: () => [] }, multipleSelectionModifiers: {} }), emits: os(["contextmenu"], ["update:selection", "update:multipleSelection"]), setup(r, { emit: i }) {
  Ns((re) => ({ af602246: H(p).hoverColor, v2c598f52: H(p).primaryColor, f032366a: H(p).bodyColor, v6ce963b2: s.value }));
  const l = r, d = cc(r, "selection"), f = cc(r, "multipleSelection"), g = i, p = $s(), s = Ie("0s"), C = Ie({ startX: 0, delta: 0, currentX: 0, containerWidth: 0, activeId: null, leftMax: 0, rightMax: 0 }), P = Ie(false), M = Ie(0), D = Ie(0), L = Ie(null);
  function $(re, ie) {
    C.value.activeId !== ie && q();
    const J = re.touches[0];
    C.value = { startX: J.clientX, delta: C.value.delta ?? 0, currentX: J.clientX, containerWidth: re.currentTarget.offsetWidth, activeId: ie, leftMax: R4, rightMax: A4 };
  }
  function z(re) {
    C.value.activeId && (C.value.currentX = re.touches[0].clientX, C.value.delta += C.value.currentX - C.value.startX, C.value.delta = Dg(C.value.delta, -C.value.leftMax, C.value.rightMax), C.value.startX = re.touches[0].clientX);
  }
  function F() {
    if (!C.value.activeId) return;
    s.value = `${Math.abs(C.value.delta) / C.value.containerWidth * 0.3}s`, setTimeout(() => {
      s.value = "0s";
    }, 300);
    const re = C.value.delta < 0 ? C.value.leftMax : C.value.rightMax;
    C.value.delta = Math.abs(C.value.delta) > re * 0.4 ? Math.sign(C.value.delta) * re : 0, C.value.delta === 0 && Math.abs(C.value.delta) < 5;
  }
  function Z(re, ie) {
    re.stopPropagation(), !(C.value.delta > 5) && (q(), d.value !== ie.id && (d.value = ie.id));
  }
  function q() {
    C.value.delta > 0 || (C.value = { startX: 0, delta: 0, currentX: 0, containerWidth: 0, activeId: null, leftMax: 0, rightMax: 0 });
  }
  function K(re, ie) {
    if (re.stopPropagation(), re.preventDefault(), P.value) {
      P.value = false;
      return;
    }
    L.value = ie, M.value = re.clientX, D.value = re.clientY, P.value = true, g("contextmenu", re, ie);
  }
  function te(re) {
    const ie = [...f.value];
    if (ie.includes(re)) {
      const J = ie.indexOf(re);
      ie.splice(J, 1);
    } else ie.push(re);
    f.value = ie;
  }
  return (re, ie) => (ct(), $t(Wr, null, [yt("div", k4, [(ct(true), $t(Wr, null, on(l.items, (J) => (ct(), $t("div", { key: J.id, class: Qo(["menu-list-item", ...J.id === d.value ? ["active"] : []]), style: Sn({ "touch-action": C.value.activeId === J.id ? "pan-y" : "auto" }), onClick: (we) => Z(we, J), onContextmenu: Hd((we) => K(we, J), ["prevent"]), onTouchstart: (we) => $(we, J.id), onTouchmove: z, onTouchend: F }, [yt("div", T4, [yt("div", { class: "content-col", style: Sn({ transform: `translateX(${C.value.activeId === J.id || C.value.delta > 0 ? C.value.delta : 0}px)`, willChange: C.value.activeId === J.id ? "transform" : "auto", flexDirection: C.value.delta >= 0 || C.value.activeId !== J.id ? "row" : "row-reverse" }) }, [yp(re.$slots, "item", { item: J }, () => [yt("div", I4, [yt("div", null, Kt(J.name ?? "Untitled"), 1)])], true)], 4), yt("div", { class: "actions-col", style: Sn({ width: `${C.value.activeId === J.id && C.value.delta < 0 ? -C.value.delta : 0}px`, visibility: C.value.activeId === J.id && C.value.delta < 0 ? "visible" : "hidden", willChange: C.value.activeId === J.id ? "width" : "auto" }) }, [(ct(true), $t(Wr, null, on(l.swipeActions, (we) => (ct(), $t("button", { key: we.name, class: "menu-action", style: Sn({ background: we.color || H(p).primaryColorSuppl }), onClick: () => {
    we.action(J.id), C.value.activeId = null;
  } }, Kt(we.label), 13, M4))), 128))], 4), yt("div", { class: "select-col", style: Sn({ width: `${C.value.delta > 0 ? C.value.delta : 0}px`, backgroundColor: d.value === J.id ? H(p).primaryColor : "transparent", visibility: C.value.delta > 0 ? "visible" : "hidden" }) }, [yt("div", E4, [De(H(xP), { checked: f.value.includes(J.id), style: Sn({ border: d.value === J.id ? `1px solid ${H(p).bodyColor}` : "none", BorderRadius: d.value === J.id ? H(p).borderRadiusSmall : "none" }), "onUpdate:checked": () => te(J.id) }, null, 8, ["checked", "style", "onUpdate:checked"])])], 4)])], 46, P4))), 128))]), De(H(lb), { show: P.value, x: M.value, y: D.value, options: l.menuOptions.map((J) => {
    var _a3;
    return { ...J, label: ((_a3 = J.label) == null ? void 0 : _a3.value) ?? J.label };
  }), placement: "bottom-start", trigger: "manual", onClick: ie[0] || (ie[0] = (J) => P.value = false), onClickoutside: ie[1] || (ie[1] = (J) => P.value = false) }, null, 8, ["show", "x", "y", "options"])], 64));
} }), z4 = Ni(D4, [["__scopeId", "data-v-b353d352"]]), F4 = { class: "drawer-floating" }, L4 = { class: "drawer-container" }, B4 = { class: "drawer-header" }, O4 = { class: "drawer-title" }, $4 = { class: "drawer-content" }, j4 = { style: { height: "fit-content", padding: "8px 12px", "text-align": "left" } }, N4 = { style: { "font-size": "0.8rem", opacity: "0.7", display: "flex", "flex-direction": "row", gap: "12px" } }, V4 = { key: 0 }, U4 = ot({ __name: "TrackerViewRouteDrawer", props: { show: { type: Boolean, default: false }, showModifiers: {} }, emits: os(["update:width"], ["update:show"]), setup(r, { emit: i }) {
  Ns((fe) => ({ v38b2b83c: H(C).borderRadius, v3ddcb48b: H(C).hoverColor, v485009dd: H(C).primaryColorPressed, v4f454a85: H(C).primaryColor, v73f3b15d: H(C).bodyColor }));
  const d = new bc().isMobile, { t: f } = On(), g = Hb(), p = i, s = T1(), C = $s(), P = cc(r, "show"), M = Ie(false), D = Ie(0), L = Ie(0), $ = Ie(null), z = Ie(false), F = Ie(""), Z = Ie(null), q = [{ label: Ee(() => f("components.trackerViewRouteDrawer.contextMenu.new")), key: "new", props: { onClick: () => {
    M.value = false, s.addRoute(f("components.trackerViewRouteDrawer.nameNewRoute"));
  } } }], K = [{ label: Ee(() => f("components.trackerViewRouteDrawer.contextMenu.rename")), key: "rename", props: { onClick: () => {
    var _a3;
    ((_a3 = $.value) == null ? void 0 : _a3.id) && (F.value = $.value.name || "", z.value = true);
  } } }, { label: Ee(() => f("components.trackerViewRouteDrawer.contextMenu.delete")), key: "delete", props: { onClick: () => {
    $.value && s.deleteRoute($.value.id);
  } } }, { key: "divider-1", type: "divider" }, ...q], te = [{ label: Ee(() => f("components.trackerViewRouteDrawer.contextMenu.rename")), name: "rename", action: (fe) => {
    const oe = s.routes.find((he) => he.id === fe);
    Z.value = fe, F.value = (oe == null ? void 0 : oe.name) || "", z.value = true;
  } }, { label: Ee(() => f("components.trackerViewRouteDrawer.contextMenu.delete")), name: "delete", action: (fe) => s.deleteRoute(fe), color: C.value.errorColorSuppl }];
  function re(fe) {
    if (fe.stopPropagation(), fe.preventDefault(), Z.value = s.currentRouteId, M.value) {
      M.value = false;
      return;
    }
    D.value = fe.clientX, L.value = fe.clientY, M.value = true;
  }
  async function ie(fe) {
    F.value.trim() && (await s.updateRoute(fe, { meta: { name: F.value.trim() } }), z.value = false);
  }
  const J = Ie([]);
  function we() {
    g.warning({ title: f("components.trackerViewRouteDrawer.deleteConfirmation.title"), content: f("components.trackerViewRouteDrawer.deleteConfirmation.prompt"), positiveText: f("components.trackerViewRouteDrawer.deleteConfirmation.yes"), negativeText: f("components.trackerViewRouteDrawer.deleteConfirmation.no"), onPositiveClick: () => {
      J.value.forEach((fe) => {
        s.deleteRoute(fe), J.value = J.value.filter((oe) => oe !== fe);
      });
    } });
  }
  return (fe, oe) => (ct(), $t(Wr, null, [De(S4, { show: P.value, "onUpdate:show": oe[3] || (oe[3] = (he) => P.value = he), position: H(d) ? "bottom" : "left", onClick: oe[4] || (oe[4] = () => H(s).currentRouteId = null), "onUpdate:width": oe[5] || (oe[5] = (he) => p("update:width", he)), onContextmenu: oe[6] || (oe[6] = (he) => re(he)) }, { default: $e(() => [yt("div", F4, [H(d) && P.value ? yp(fe.$slots, "bottom-floating", { key: 0 }, void 0, true) : Pr("", true)]), yt("div", L4, [yt("div", B4, [yt("p", O4, Kt(H(f)("components.trackerViewRouteDrawer.routes")), 1), J.value.length > 0 ? (ct(), gr(H($r), { key: 0, strong: "", secondary: "", circle: "", type: "error", onClick: we }, { icon: $e(() => [De(H(bi), { component: H(Mp) }, null, 8, ["component"])]), _: 1 })) : Pr("", true)]), yt("div", $4, [De(z4, { selection: H(s).currentRouteId, "onUpdate:selection": oe[0] || (oe[0] = (he) => H(s).currentRouteId = he), "multiple-selection": J.value, "onUpdate:multipleSelection": oe[1] || (oe[1] = (he) => J.value = he), items: H(s).routes, "menu-options": K, "swipe-actions": te, onContextmenu: oe[2] || (oe[2] = (he, _e) => {
    Z.value = (_e == null ? void 0 : _e.id) ?? null, $.value = _e ?? null;
  }) }, { item: $e(({ item: he }) => {
    var _a3;
    return [yt("div", j4, [yt("div", null, Kt(he.name ?? H(f)("components.trackerViewRouteDrawer.nameNewRoute")), 1), yt("div", N4, [yt("div", null, Kt(H(f)("components.trackerViewRouteDrawer.points", { num: he.points.length })), 1), he.points.length > 1 && ((_a3 = he.meta) == null ? void 0 : _a3.distance) ? (ct(), $t("div", V4, Kt(H(f)("components.trackerViewRouteDrawer.distance", { distance: H(kw)(he.meta.distance) })), 1)) : Pr("", true)])])];
  }), _: 1 }, 8, ["selection", "multiple-selection", "items"])])])]), _: 3 }, 8, ["show", "position"]), De(H(lb), { show: M.value, x: D.value, y: L.value, options: q.map((he) => ({ ...he, label: he.label.value })), placement: "bottom-start", trigger: "manual", onClickoutside: oe[7] || (oe[7] = (he) => M.value = false) }, null, 8, ["show", "x", "y", "options"]), De(H(Kd), { show: z.value, "onUpdate:show": oe[10] || (oe[10] = (he) => z.value = he), preset: "dialog", title: "Rename Route", "positive-text": "Save", "negative-text": "Cancel", onPositiveClick: oe[11] || (oe[11] = () => {
    Z.value && ie(Z.value);
  }) }, { default: $e(() => [De(H(_o), { value: F.value, "onUpdate:value": oe[8] || (oe[8] = (he) => F.value = he), placeholder: "Enter new route name", onKeyup: oe[9] || (oe[9] = Oy(() => {
    Z.value && ie(Z.value);
  }, ["enter"])) }, null, 8, ["value"])]), _: 1 }, 8, ["show"])], 64));
} }), G4 = Ni(U4, [["__scopeId", "data-v-a6ce157e"]]), I1 = r0("map", () => {
  const r = Ie(7), i = Ie([0, 0]), l = Ie(0), d = Ie(0), f = Ie(false);
  async function g() {
    const L = await sb("mapState");
    L && (r.value = L.zoom, i.value = L.center, l.value = L.bearing, f.value = L.isTrackingOrientation, d.value = L.lastUpdateTime);
  }
  async function p() {
    d.value = Date.now();
    const L = { zoom: r.value, center: i.value, bearing: l.value, isTrackingOrientation: f.value, lastUpdateTime: d.value };
    await go("mapState", JSON.parse(JSON.stringify(L))), await vo();
  }
  function s(L) {
    r.value = L;
  }
  function C(L) {
    i.value = L.toLngLatLike();
  }
  function P(L) {
    l.value = L;
  }
  function M(L) {
    f.value = L;
  }
  function D() {
    r.value = 7, i.value = [0, 0], l.value = 0, f.value = false;
  }
  return Ht([r, i, l, f], p, { deep: true }), { zoom: r, center: i, bearing: l, isTrackingOrientation: f, lastUpdateTime: d, init: g, save: p, setZoom: s, setCenter: C, setBearing: P, setTrackingOrientation: M, resetToDefault: D };
});
function q4() {
  for (const r of Os.handlers) r.callback(360 - Os.bearing);
}
var Os;
((r) => {
  r.bearing = 0;
  let i = false;
  r.handlers = [];
  function l(p) {
    if (!(LC(p.alpha) || typeof p.webkitCompassHeading < "u")) {
      g();
      return;
    }
    r.bearing = p.alpha, typeof p.webkitCompassHeading < "u" && (r.bearing = p.webkitCompassHeading), q4();
  }
  r.updater = l;
  function d(p) {
    const s = r.handlers.length > 0 ? r.handlers[r.handlers.length - 1].id + 1 : 0;
    return r.handlers.push({ callback: p, id: s }), s;
  }
  r.addHandler = d;
  function f() {
    i || (window.addEventListener("deviceorientation", l, true), i = true);
  }
  r.start = f;
  function g() {
    i && (window.removeEventListener("deviceorientation", l, true), i = false);
  }
  r.stop = g;
})(Os || (Os = {}));
function kn() {
  return kn = Object.assign ? Object.assign.bind() : function(r) {
    for (var i = 1; i < arguments.length; i++) {
      var l = arguments[i];
      for (var d in l) ({}).hasOwnProperty.call(l, d) && (r[d] = l[d]);
    }
    return r;
  }, kn.apply(null, arguments);
}
var Ln;
(function(r) {
  r.Commit = "commit", r.Provisional = "provisional", r.Finish = "finish";
})(Ln || (Ln = {}));
const W4 = "https://raw.githubusercontent.com/JamesLMilner/terra-draw/refs/heads/main/assets/markers/marker-blue.png", Ki = { SELECTED: "selected", MID_POINT: "midPoint", SELECTION_POINT_FEATURE_ID: "selectionPointFeatureId", SELECTION_POINT: "selectionPoint" }, ki = { MODE: "mode", CURRENTLY_DRAWING: "currentlyDrawing", EDITED: "edited", CLOSING_POINT: "closingPoint", SNAPPING_POINT: "snappingPoint", COORDINATE_POINT: "coordinatePoint", COORDINATE_POINT_FEATURE_ID: "coordinatePointFeatureId", COORDINATE_POINT_IDS: "coordinatePointIds", PROVISIONAL_COORDINATE_COUNT: "provisionalCoordinateCount", COMMITTED_COORDINATE_COUNT: "committedCoordinateCount", MARKER: "marker" }, op = 10;
function fg(r) {
  return !!(r && typeof r == "object" && r !== null && !Array.isArray(r));
}
function ny(r) {
  return !!(r && typeof r == "object" && "properties" in r && typeof r.properties == "object" && r.properties !== null && "mode" in r.properties);
}
function oy(r) {
  return !!(function(i) {
    return typeof i == "number" && !isNaN(new Date(i).valueOf());
  })(r);
}
const Z4 = "Feature mode property does not match the mode being added to";
var fc;
(function(r) {
  r.Drawing = "drawing", r.Select = "select", r.Static = "static", r.Render = "render";
})(fc || (fc = {}));
const H4 = { rightClick: true, contextMenu: false, leftClick: true, onDragStart: true, onDrag: true, onDragEnd: true };
class Lp {
  get state() {
    return this._state;
  }
  set state(i) {
    throw new Error("Please use the modes lifecycle methods");
  }
  get styles() {
    return this._styles;
  }
  set styles(i) {
    if (typeof i != "object") throw new Error("Styling must be an object");
    this.onStyleChange && this.onStyleChange([], "styling"), this._styles = i;
  }
  registerBehaviors(i) {
  }
  constructor(i, l = false) {
    this._state = "unregistered", this._styles = {}, this.pointerEvents = H4, this.behaviors = [], this.validate = void 0, this.pointerDistance = 40, this.coordinatePrecision = void 0, this.onStyleChange = void 0, this.store = void 0, this.projection = "web-mercator", this.setDoubleClickToZoom = void 0, this.unproject = void 0, this.project = void 0, this.setCursor = void 0, this.type = fc.Drawing, this.mode = "base", l || this.updateOptions(i);
  }
  updateOptions(i) {
    i != null && i.styles && (this.styles = kn({}, this._styles, i.styles)), i != null && i.pointerDistance && (this.pointerDistance = i.pointerDistance), i != null && i.validation && (this.validate = i && i.validation), i != null && i.projection && (this.projection = i.projection), (i == null ? void 0 : i.pointerEvents) !== void 0 && (this.pointerEvents = i.pointerEvents);
  }
  allowPointerEvent(i, l) {
    return typeof i == "boolean" ? i : typeof i != "function" || i(l);
  }
  setDrawing() {
    if (this._state !== "started") throw new Error("Mode must be unregistered or stopped to start");
    this._state = "drawing";
  }
  setStarted() {
    if (this._state !== "stopped" && this._state !== "registered" && this._state !== "drawing" && this._state !== "selecting") throw new Error("Mode must be unregistered or stopped to start");
    this._state = "started", this.setDoubleClickToZoom(false);
  }
  setStopped() {
    if (this._state !== "started") throw new Error("Mode must be started to be stopped");
    this._state = "stopped", this.setDoubleClickToZoom(true);
  }
  register(i) {
    if (this._state !== "unregistered") throw new Error("Can not register unless mode is unregistered");
    this._state = "registered", this.store = i.store, this.store.registerOnChange(i.onChange), this.setDoubleClickToZoom = i.setDoubleClickToZoom, this.project = i.project, this.unproject = i.unproject, this.onSelect = i.onSelect, this.onDeselect = i.onDeselect, this.setCursor = i.setCursor, this.onStyleChange = i.onChange, this.onFinish = i.onFinish, this.coordinatePrecision = i.coordinatePrecision, this.registerBehaviors({ mode: i.mode, store: this.store, project: this.project, unproject: this.unproject, pointerDistance: this.pointerDistance, coordinatePrecision: i.coordinatePrecision, projection: this.projection });
  }
  validateFeature(i) {
    return this.performFeatureValidation(i);
  }
  afterFeatureAdded(i) {
  }
  afterFeatureUpdated(i) {
  }
  performFeatureValidation(i) {
    if (this._state === "unregistered") throw new Error("Mode must be registered");
    const l = (function(d, f) {
      let g;
      if (fg(d)) if (d.id == null) g = "Feature has no id";
      else if (typeof d.id != "string" && typeof d.id != "number") g = "Feature must be string or number as per GeoJSON spec";
      else if (f(d.id)) if (fg(d.geometry)) if (fg(d.properties)) if (typeof d.geometry.type == "string" && ["Polygon", "LineString", "Point"].includes(d.geometry.type)) if (Array.isArray(d.geometry.coordinates)) {
        if (!d.properties.mode || typeof d.properties.mode != "string") return { valid: false, reason: "Feature does not have a valid mode property" };
      } else g = "Feature coordinates is not an array";
      else g = "Feature is not Point, LineString or Polygon";
      else g = "Feature has no properties";
      else g = "Feature has no geometry";
      else g = "Feature must match the id strategy (default is UUID4)";
      else g = "Feature is not object";
      return g ? { valid: false, reason: g } : { valid: true };
    })(i, this.store.idStrategy.isValidId);
    if (this.validate) {
      const d = this.validate(i, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Ln.Provisional });
      return { valid: l.valid && d.valid, reason: d.reason };
    }
    return { valid: l.valid, reason: l.reason };
  }
  validateModeFeature(i, l) {
    const d = this.performFeatureValidation(i);
    return d.valid ? i.properties.mode !== this.mode ? { valid: false, reason: Z4 } : l(i) : { valid: false, reason: d.reason };
  }
  onFinish(i, l) {
  }
  onDeselect(i) {
  }
  onSelect(i) {
  }
  onKeyDown(i) {
  }
  onKeyUp(i) {
  }
  onMouseMove(i) {
  }
  onClick(i) {
  }
  onDragStart(i, l) {
  }
  onDrag(i, l) {
  }
  onDragEnd(i, l) {
  }
  getHexColorStylingValue(i, l, d) {
    return this.getStylingValue(i, l, d);
  }
  getNumericStylingValue(i, l, d) {
    return this.getStylingValue(i, l, d);
  }
  getUrlStylingValue(i, l, d) {
    return this.getStylingValue(i, l, d);
  }
  getStylingValue(i, l, d) {
    return i === void 0 ? l : typeof i == "function" ? i(d) : i;
  }
}
class X4 extends Lp {
  constructor(...i) {
    super(...i), this.type = fc.Select;
  }
}
function ss(r, i) {
  const l = (P) => P * Math.PI / 180, d = l(r[1]), f = l(r[0]), g = l(i[1]), p = g - d, s = l(i[0]) - f, C = Math.sin(p / 2) * Math.sin(p / 2) + Math.cos(d) * Math.cos(g) * Math.sin(s / 2) * Math.sin(s / 2);
  return 2 * Math.atan2(Math.sqrt(C), Math.sqrt(1 - C)) * 6371e3 / 1e3;
}
const M1 = 63710088e-1;
function to(r) {
  return r % 360 * Math.PI / 180;
}
function Y4(r) {
  return r / 6371.0088;
}
function pc(r) {
  return r % (2 * Math.PI) * 180 / Math.PI;
}
function Li(r, i = 9) {
  const l = Math.pow(10, i);
  return Math.round(r * l) / l;
}
const ay = 57.29577951308232, sy = 0.017453292519943295, fp = 6378137, Fi = (r, i) => ({ x: r === 0 ? 0 : r * sy * fp, y: i === 0 ? 0 : Math.log(Math.tan(Math.PI / 4 + i * sy / 2)) * fp }), mc = (r, i) => ({ lng: r === 0 ? 0 : ay * (r / fp), lat: i === 0 ? 0 : (2 * Math.atan(Math.exp(i / fp)) - Math.PI / 2) * ay });
function K4(r) {
  let i;
  if (r.geometry.type === "Polygon") i = r.geometry.coordinates;
  else {
    if (r.geometry.type !== "LineString") throw new Error("Self intersects only accepts Polygons and LineStrings");
    i = [r.geometry.coordinates];
  }
  const l = [];
  for (let g = 0; g < i.length; g++) for (let p = 0; p < i[g].length - 1; p++) for (let s = 0; s < i.length; s++) for (let C = 0; C < i[s].length - 1; C++) f(g, p, s, C);
  return l.length > 0;
  function d(g) {
    return g < 0 || g > 1;
  }
  function f(g, p, s, C) {
    const P = i[g][p], M = i[g][p + 1], D = i[s][C], L = i[s][C + 1], $ = (function(Z, q, K, te) {
      if (Zf(Z, K) || Zf(Z, te) || Zf(q, K) || Zf(te, K)) return null;
      const re = Z[0], ie = Z[1], J = q[0], we = q[1], fe = K[0], oe = K[1], he = te[0], _e = te[1], Ue = (re - J) * (oe - _e) - (ie - we) * (fe - he);
      return Ue === 0 ? null : [((re * we - ie * J) * (fe - he) - (re - J) * (fe * _e - oe * he)) / Ue, ((re * we - ie * J) * (oe - _e) - (ie - we) * (fe * _e - oe * he)) / Ue];
    })(P, M, D, L);
    if ($ === null) return;
    let z, F;
    z = M[0] !== P[0] ? ($[0] - P[0]) / (M[0] - P[0]) : ($[1] - P[1]) / (M[1] - P[1]), F = L[0] !== D[0] ? ($[0] - D[0]) / (L[0] - D[0]) : ($[1] - D[1]) / (L[1] - D[1]), d(z) || d(F) || ($.toString(), l.push($));
  }
}
function Zf(r, i) {
  return r[0] === i[0] && r[1] === i[1];
}
function b0(r, i) {
  return ly(r[0]) <= i && ly(r[1]) <= i;
}
function E1(r) {
  return r.length === 2 && typeof r[0] == "number" && typeof r[1] == "number" && r[0] !== 1 / 0 && r[1] !== 1 / 0 && (l = r[0]) >= -180 && l <= 180 && (i = r[1]) >= -90 && i <= 90;
  var i, l;
}
function ly(r) {
  let i = 1, l = 0;
  for (; Math.round(r * i) / i !== r; ) i *= 10, l++;
  return l;
}
const xa = (r, i) => {
  const { x: l, y: d } = r, { x: f, y: g } = i, p = f - l, s = g - d;
  return Math.sqrt(s * s + p * p);
};
class io {
  constructor({ store: i, mode: l, project: d, unproject: f, pointerDistance: g, coordinatePrecision: p, projection: s }) {
    this.store = void 0, this.mode = void 0, this.project = void 0, this.unproject = void 0, this.pointerDistance = void 0, this.coordinatePrecision = void 0, this.projection = void 0, this.store = i, this.mode = l, this.project = d, this.unproject = f, this.pointerDistance = g, this.coordinatePrecision = p, this.projection = s;
  }
}
function R1({ unproject: r, point: i, pointerDistance: l }) {
  const d = l / 2, { x: f, y: g } = i;
  return { type: "Feature", properties: {}, geometry: { type: "Polygon", coordinates: [[r(f - d, g - d), r(f + d, g - d), r(f + d, g + d), r(f - d, g + d), r(f - d, g - d)].map((p) => [p.lng, p.lat])] } };
}
class pp extends io {
  constructor(i) {
    super(i);
  }
  create(i) {
    const { containerX: l, containerY: d } = i;
    return R1({ unproject: this.unproject, point: { x: l, y: d }, pointerDistance: this.pointerDistance });
  }
}
class mp extends io {
  constructor(i) {
    super(i);
  }
  measure(i, l) {
    const { x: d, y: f } = this.project(l[0], l[1]);
    return xa({ x: d, y: f }, { x: i.containerX, y: i.containerY });
  }
}
let Hg = class extends io {
  constructor(i, l, d) {
    super(i), this.config = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.getSnappableCoordinateFirstClick = (f) => this.getSnappable(f, (g) => !!(g.properties && g.properties.mode === this.mode)).coordinate, this.getSnappableCoordinate = (f, g) => this.getSnappable(f, (p) => !!(p.properties && p.properties.mode === this.mode && p.id !== g)).coordinate, this.config = i, this.pixelDistance = l, this.clickBoundingBox = d;
  }
  getSnappable(i, l) {
    const d = this.clickBoundingBox.create(i), f = this.store.search(d, l), g = { featureId: void 0, featureCoordinateIndex: void 0, coordinate: void 0, minDist: 1 / 0 };
    return f.forEach((p) => {
      let s;
      if (p.geometry.type === "Polygon") s = p.geometry.coordinates[0];
      else {
        if (p.geometry.type !== "LineString") return;
        s = p.geometry.coordinates;
      }
      s.forEach((C, P) => {
        const M = this.pixelDistance.measure(i, C);
        M < g.minDist && M < this.pointerDistance && (g.coordinate = C, g.minDist = M, g.featureId = p.id, g.featureCoordinateIndex = P);
      });
    }), g;
  }
};
function uy(r, i, l) {
  const d = to(r[0]), f = to(r[1]), g = to(l), p = Y4(i), s = Math.asin(Math.sin(f) * Math.cos(p) + Math.cos(f) * Math.sin(p) * Math.cos(g));
  return [pc(d + Math.atan2(Math.sin(g) * Math.sin(p) * Math.cos(f), Math.cos(p) - Math.sin(f) * Math.sin(s))), pc(s)];
}
function cy(r, i) {
  const l = to(r[0]), d = to(i[0]), f = to(r[1]), g = to(i[1]), p = Math.sin(d - l) * Math.cos(g), s = Math.cos(f) * Math.sin(g) - Math.sin(f) * Math.cos(g) * Math.cos(d - l);
  return pc(Math.atan2(p, s));
}
function J4({ x: r, y: i }, { x: l, y: d }) {
  const f = l - r, g = d - i;
  if (f === 0 && g === 0) return 0;
  let p = Math.atan2(g, f);
  return p *= 180 / Math.PI, p > 180 ? p -= 360 : p < -180 && (p += 360), p;
}
function Q4(r, i, l) {
  const d = [], f = r.length;
  let g, p, s, C = 0;
  for (let M = 0; M < r.length && !(i >= C && M === r.length - 1); M++) {
    if (C > i && d.length === 0) {
      if (g = i - C, !g) return d.push(r[M]), d;
      p = cy(r[M], r[M - 1]) - 180, s = uy(r[M], g, p), d.push(s);
    }
    if (C >= l) return g = l - C, g ? (p = cy(r[M], r[M - 1]) - 180, s = uy(r[M], g, p), d.push(s), d) : (d.push(r[M]), d);
    if (C >= i && d.push(r[M]), M === r.length - 1) return d;
    C += ss(r[M], r[M + 1]);
  }
  if (C < i && r.length === f) throw new Error("Start position is beyond line");
  const P = r[r.length - 1];
  return [P, P];
}
function Hf(r) {
  return r * (Math.PI / 180);
}
function dy(r) {
  return r * (180 / Math.PI);
}
class eI extends io {
  constructor(i) {
    super(i), this.config = void 0, this.config = i;
  }
  generateInsertionCoordinates(i, l, d) {
    const f = [i, l];
    let g = 0;
    for (let P = 0; P < f.length - 1; P++) g += ss(f[0], f[1]);
    if (g <= d) return f;
    let p = g / d - 1;
    Number.isInteger(p) || (p = Math.floor(p) + 1);
    const s = [];
    for (let P = 0; P < p; P++) {
      const M = Q4(f, d * P, d * (P + 1));
      s.push(M);
    }
    const C = [];
    for (let P = 0; P < s.length; P++) C.push(s[P][1]);
    return this.limitCoordinates(C);
  }
  generateInsertionGeodesicCoordinates(i, l, d) {
    const f = ss(i, l), g = (function(p, s, C) {
      const P = [], M = Hf(p[1]), D = Hf(p[0]), L = Hf(s[1]), $ = Hf(s[0]);
      C += 1;
      const z = 2 * Math.asin(Math.sqrt(Math.sin((L - M) / 2) ** 2 + Math.cos(M) * Math.cos(L) * Math.sin(($ - D) / 2) ** 2));
      if (z === 0 || isNaN(z)) return P;
      for (let F = 0; F <= C; F++) {
        const Z = F / C, q = Math.sin((1 - Z) * z) / Math.sin(z), K = Math.sin(Z * z) / Math.sin(z), te = q * Math.cos(M) * Math.cos(D) + K * Math.cos(L) * Math.cos($), re = q * Math.cos(M) * Math.sin(D) + K * Math.cos(L) * Math.sin($), ie = q * Math.sin(M) + K * Math.sin(L);
        if (isNaN(te) || isNaN(re) || isNaN(ie)) continue;
        const J = Math.atan2(ie, Math.sqrt(te ** 2 + re ** 2)), we = Math.atan2(re, te);
        isNaN(J) || isNaN(we) || P.push([dy(we), dy(J)]);
      }
      return P.slice(1, -1);
    })(i, l, Math.floor(f / d));
    return this.limitCoordinates(g);
  }
  limitCoordinates(i) {
    return i.map((l) => [Li(l[0], this.config.coordinatePrecision), Li(l[1], this.config.coordinatePrecision)]);
  }
}
function tI(r, i) {
  return r[0] === i[0] && r[1] === i[1];
}
function rI(r, i) {
  if (r.geometry.type !== "LineString") return { valid: false, reason: "Feature is not a LineString" };
  if (r.geometry.coordinates.length < 2) return { valid: false, reason: "Feature has less than 2 coordinates" };
  for (let l = 0; l < r.geometry.coordinates.length; l++) {
    if (!E1(r.geometry.coordinates[l])) return { valid: false, reason: "Feature has invalid coordinates" };
    if (!b0(r.geometry.coordinates[l], i)) return { valid: false, reason: "Feature has coordinates with excessive precision" };
  }
  return { valid: true };
}
function hy(r) {
  return Math.sqrt(Math.pow(r[0], 2) + Math.pow(r[1], 2) + Math.pow(r[2], 2));
}
function Ml(r, i) {
  const l = (function(d, f) {
    const [g, p, s] = d, [C, P, M] = f;
    return g * C + p * P + s * M;
  })(r, i) / (hy(r) * hy(i));
  return Math.acos(Math.min(Math.max(l, -1), 1));
}
function pg(r) {
  const i = to(r[1]), l = to(r[0]);
  return [Math.cos(i) * Math.cos(l), Math.cos(i) * Math.sin(l), Math.sin(i)];
}
function El(r) {
  const [i, l, d] = r, f = pc(Math.asin(d));
  return [pc(Math.atan2(l, i)), f];
}
function iI(r, i, l) {
  const d = pg(r), f = pg(i), g = pg(l), [p, s, C] = g, [P, M, D] = (function(_e, Ue) {
    const [qe, tt, ut] = _e, [mt, St, st] = Ue;
    return [tt * st - ut * St, ut * mt - qe * st, qe * St - tt * mt];
  })(d, f), L = M * C - D * s, $ = D * p - P * C, z = P * s - M * p, F = z * M - $ * D, Z = L * D - z * P, q = $ * P - L * M, K = 1 / Math.sqrt(Math.pow(F, 2) + Math.pow(Z, 2) + Math.pow(q, 2)), te = [F * K, Z * K, q * K], re = [-1 * F * K, -1 * Z * K, -1 * q * K], ie = Ml(d, f), J = Ml(d, te), we = Ml(f, te), fe = Ml(d, re), oe = Ml(f, re);
  let he;
  return he = J < fe && J < oe || we < fe && we < oe ? te : re, Ml(d, he) > ie || Ml(f, he) > ie ? ss(El(he), El(d)) <= ss(El(he), El(f)) ? [El(d), true, false] : [El(f), false, true] : [El(he), false, false];
}
function nI(r, i, l) {
  const d = i.x - r.x, f = i.y - r.y, g = Math.max(0, Math.min(1, ((l.x - r.x) * d + (l.y - r.y) * f) / (d * d + f * f)));
  return { x: r.x + g * d, y: r.y + g * f };
}
class A1 extends io {
  constructor(i, l, d) {
    super(i), this.config = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.getSnappableCoordinateFirstClick = (f) => {
      const g = this.getSnappable(f, (p) => !!(p.properties && p.properties.mode === this.mode));
      return g.coordinate ? [Li(g.coordinate[0], this.config.coordinatePrecision), Li(g.coordinate[1], this.config.coordinatePrecision)] : void 0;
    }, this.getSnappableCoordinate = (f, g) => {
      const p = this.getSnappable(f, (s) => !!(s.properties && s.properties.mode === this.mode && s.id !== g));
      return p.coordinate ? [Li(p.coordinate[0], this.config.coordinatePrecision), Li(p.coordinate[1], this.config.coordinatePrecision)] : void 0;
    }, this.config = i, this.pixelDistance = l, this.clickBoundingBox = d;
  }
  getSnappable(i, l) {
    const d = this.clickBoundingBox.create(i), f = this.store.search(d, l), g = { featureId: void 0, featureCoordinateIndex: void 0, coordinate: void 0, minDistance: 1 / 0 };
    return f.forEach((p) => {
      let s;
      if (p.geometry.type === "Polygon") s = p.geometry.coordinates[0];
      else {
        if (p.geometry.type !== "LineString") return;
        s = p.geometry.coordinates;
      }
      const C = [];
      for (let L = 0; L < s.length - 1; L++) C.push([s[L], s[L + 1]]);
      let P;
      const M = [i.lng, i.lat];
      if (this.config.projection === "web-mercator" ? P = (function(L, $) {
        let z = [1 / 0, 1 / 0], F = 1 / 0, Z = 0;
        for (let q of $) {
          const K = q[0], te = q[1];
          let re, ie = 1 / 0;
          const J = Fi(K[0], K[1]), we = Fi(te[0], te[1]), fe = Fi(L[0], L[1]);
          if (K[0] === L[0] && K[1] === L[1]) re = K;
          else if (te[0] === L[0] && te[1] === L[1]) re = te;
          else {
            const { x: oe, y: he } = nI(J, we, fe), { lng: _e, lat: Ue } = mc(oe, he);
            re = [_e, Ue];
          }
          re && (ie = xa(fe, Fi(re[0], re[1])), ie < F && (z = re, F = ie, Z = $.indexOf(q)));
        }
        return F === 1 / 0 ? void 0 : { coordinate: z, lineIndex: Z, distance: F };
      })(M, C) : this.config.projection === "globe" && (P = (function(L, $) {
        let z = [1 / 0, 1 / 0], F = 1 / 0, Z = 0;
        for (let q of $) {
          const K = q[0], te = q[1];
          let re, ie = 1 / 0;
          K[0] === L[0] && K[1] === L[1] ? re = K : te[0] === L[0] && te[1] === L[1] ? re = te : [re] = iI(K, te, L), re && (ie = ss(L, re), ie < F && (z = re, F = ie, Z = $.indexOf(q)));
        }
        return F === 1 / 0 ? void 0 : { coordinate: z, distance: F, lineIndex: Z };
      })(M, C)), !P) return;
      const D = this.pixelDistance.measure(i, P.coordinate);
      D < g.minDistance && D < this.pointerDistance && (g.featureId = p.id, g.coordinate = [Li(P.coordinate[0], this.config.coordinatePrecision), Li(P.coordinate[1], this.config.coordinatePrecision)], g.featureCoordinateIndex = P.lineIndex, g.minDistance = D);
    }), g;
  }
}
const oI = { cancel: "Escape", finish: "Enter" }, aI = { start: "crosshair", close: "pointer", dragStart: "grabbing", dragEnd: "crosshair" };
class D1 extends Lp {
  constructor(i) {
    super(i, true), this.mode = "linestring", this.currentCoordinate = 0, this.currentId = void 0, this.closingPointId = void 0, this.keyEvents = oI, this.snapping = void 0, this.cursors = aI, this.mouseMove = false, this.insertCoordinates = void 0, this.lastCommittedCoordinates = void 0, this.snappedPointId = void 0, this.lastMouseMoveEvent = void 0, this.editable = false, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedSnapType = void 0, this.editedInsertIndex = void 0, this.editedPointId = void 0, this.coordinateSnapping = void 0, this.insertPoint = void 0, this.lineSnapping = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.updateOptions(i);
  }
  updateOptions(i) {
    super.updateOptions(i), i != null && i.cursors && (this.cursors = kn({}, this.cursors, i.cursors)), i != null && i.snapping && (this.snapping = i.snapping), (i == null ? void 0 : i.keyEvents) === null ? this.keyEvents = { cancel: null, finish: null } : i != null && i.keyEvents && (this.keyEvents = kn({}, this.keyEvents, i.keyEvents)), i != null && i.insertCoordinates && (this.insertCoordinates = i.insertCoordinates), i && i.editable && (this.editable = i.editable);
  }
  updateSnappedCoordinate(i) {
    const l = this.snapCoordinate(i);
    if (l) {
      if (this.snappedPointId) this.store.updateGeometry([{ id: this.snappedPointId, geometry: { type: "Point", coordinates: l } }]);
      else {
        const [d] = this.store.create([{ geometry: { type: "Point", coordinates: l }, properties: { mode: this.mode, [ki.SNAPPING_POINT]: true } }]);
        this.snappedPointId = d;
      }
      i.lng = l[0], i.lat = l[1];
    } else this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0);
    return l;
  }
  close() {
    if (this.currentId === void 0) return;
    const i = this.store.getGeometryCopy(this.currentId);
    i.coordinates.pop(), this.updateGeometries([...i.coordinates], void 0, Ln.Commit), this.store.updateProperty([{ id: this.currentId, property: ki.CURRENTLY_DRAWING, value: void 0 }]);
    const l = this.currentId;
    this.closingPointId && this.store.delete([this.closingPointId]), this.snappedPointId && this.store.delete([this.snappedPointId]), this.currentCoordinate = 0, this.currentId = void 0, this.closingPointId = void 0, this.snappedPointId = void 0, this.lastCommittedCoordinates = void 0, this.state === "drawing" && this.setStarted(), this.onFinish(l, { mode: this.mode, action: "draw" });
  }
  updateGeometries(i, l, d) {
    if (!this.currentId) return;
    const f = { type: "LineString", coordinates: i };
    if (this.validate && !this.validate({ type: "Feature", geometry: f }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: d }).valid) return;
    const g = [{ id: this.currentId, geometry: f }];
    this.closingPointId && l && g.push({ id: this.closingPointId, geometry: { type: "Point", coordinates: l } }), d === "commit" && (this.lastCommittedCoordinates = f.coordinates), this.store.updateGeometry(g);
  }
  generateInsertCoordinates(i, l) {
    if (!this.insertCoordinates || !this.lastCommittedCoordinates) throw new Error("Not able to insert coordinates");
    if (this.insertCoordinates.strategy !== "amount") throw new Error("Strategy does not exist");
    const d = ss(i, l) / (this.insertCoordinates.value + 1);
    let f = [];
    return this.projection === "globe" ? f = this.insertPoint.generateInsertionGeodesicCoordinates(i, l, d) : this.projection === "web-mercator" && (f = this.insertPoint.generateInsertionCoordinates(i, l, d)), f;
  }
  createLine(i) {
    const [l] = this.store.create([{ geometry: { type: "LineString", coordinates: [i, i] }, properties: { mode: this.mode, [ki.CURRENTLY_DRAWING]: true } }]);
    this.lastCommittedCoordinates = [i, i], this.currentId = l, this.currentCoordinate++, this.setDrawing();
  }
  firstUpdateToLine(i) {
    if (!this.currentId) return;
    const l = this.store.getGeometryCopy(this.currentId).coordinates, [d] = this.store.create([{ geometry: { type: "Point", coordinates: [...i] }, properties: { mode: this.mode, [ki.CLOSING_POINT]: true } }]);
    this.closingPointId = d, this.setCursor(this.cursors.close);
    const f = [...l, i];
    this.updateGeometries(f, void 0, Ln.Commit), this.currentCoordinate++;
  }
  updateToLine(i, l) {
    if (!this.currentId) return;
    const d = this.store.getGeometryCopy(this.currentId).coordinates, [f, g] = this.lastCommittedCoordinates ? this.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1] : d[d.length - 2], { x: p, y: s } = this.project(f, g);
    if (xa({ x: p, y: s }, { x: l.x, y: l.y }) < this.pointerDistance) return void this.close();
    this.setCursor(this.cursors.close);
    const C = [...d, i];
    this.updateGeometries(C, d[d.length - 1], Ln.Commit), this.currentCoordinate++;
  }
  registerBehaviors(i) {
    this.coordinateSnapping = new Hg(i, new mp(i), new pp(i)), this.insertPoint = new eI(i), this.clickBoundingBox = new pp(i), this.pixelDistance = new mp(i), this.lineSnapping = new A1(i, this.pixelDistance, this.clickBoundingBox), this.coordinateSnapping = new Hg(i, this.pixelDistance, this.clickBoundingBox);
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.start);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onMouseMove(i) {
    this.mouseMove = true, this.setCursor(this.cursors.start), this.lastMouseMoveEvent = i;
    const l = this.updateSnappedCoordinate(i) || [i.lng, i.lat];
    if (this.currentId === void 0 || this.currentCoordinate === 0) return;
    const d = this.store.getGeometryCopy(this.currentId).coordinates;
    if (d.pop(), this.closingPointId) {
      const [g, p] = d[d.length - 1], { x: s, y: C } = this.project(g, p);
      xa({ x: s, y: C }, { x: i.containerX, y: i.containerY }) < this.pointerDistance && this.setCursor(this.cursors.close);
    }
    let f = [...d, l];
    if (this.insertCoordinates && this.currentId && this.lastCommittedCoordinates) {
      const g = this.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1], p = l;
      if (!tI(g, p)) {
        const s = this.generateInsertCoordinates(g, p);
        f = [...this.lastCommittedCoordinates.slice(0, -1), ...s, l];
      }
    }
    this.updateGeometries(f, void 0, Ln.Provisional);
  }
  onRightClick(i) {
    if (!this.editable || this.state !== "started") return;
    const { featureId: l, featureCoordinateIndex: d } = this.coordinateSnapping.getSnappable(i, (p) => this.lineStringFilter(p));
    if (!l || d === void 0) return;
    const f = this.store.getGeometryCopy(l);
    let g;
    if (f.type === "LineString" && (g = f.coordinates, !(g.length <= 2))) {
      if (g.splice(d, 1), this.validate && !this.validate({ id: l, type: "Feature", geometry: f, properties: {} }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Ln.Commit }).valid) return;
      this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.store.updateGeometry([{ id: l, geometry: f }]), this.onFinish(l, { mode: this.mode, action: "edit" });
    }
  }
  onLeftClick(i) {
    this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0);
    const l = this.snapCoordinate(i) || [i.lng, i.lat];
    this.currentCoordinate === 0 ? this.createLine(l) : this.currentCoordinate === 1 && this.currentId ? this.firstUpdateToLine(l) : this.currentId && this.updateToLine(l, { x: i.containerX, y: i.containerY });
  }
  onClick(i) {
    (i.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, i) || i.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, i) || i.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, i)) && (this.currentCoordinate > 0 && !this.mouseMove && this.onMouseMove(i), this.mouseMove = false, i.button === "right" ? this.onRightClick(i) : i.button === "left" && this.onLeftClick(i));
  }
  onKeyDown() {
  }
  onKeyUp(i) {
    i.key === this.keyEvents.cancel && this.cleanUp(), i.key === this.keyEvents.finish && this.close();
  }
  onDragStart(i, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDragStart, i) || !this.editable) return;
    let d;
    if (this.state === "started") {
      const f = this.lineSnapping.getSnappable(i, (p) => this.lineStringFilter(p));
      f.coordinate && (this.editedSnapType = "line", this.editedFeatureCoordinateIndex = f.featureCoordinateIndex, this.editedFeatureId = f.featureId, d = f.coordinate);
      const g = this.coordinateSnapping.getSnappable(i, (p) => this.lineStringFilter(p));
      g.coordinate && (this.editedSnapType = "coordinate", this.editedFeatureCoordinateIndex = g.featureCoordinateIndex, this.editedFeatureId = g.featureId, d = g.coordinate);
    }
    if (this.editedFeatureId && d) {
      if (!this.editedPointId) {
        const [f] = this.store.create([{ geometry: { type: "Point", coordinates: d }, properties: { mode: this.mode, [ki.EDITED]: true } }]);
        this.editedPointId = f;
      }
      this.setCursor(this.cursors.dragStart), l(false);
    }
  }
  onDrag(i, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDrag, i) || this.editedFeatureId === void 0 || this.editedFeatureCoordinateIndex === void 0) return;
    const d = this.store.getGeometryCopy(this.editedFeatureId);
    this.editedSnapType === "coordinate" || this.editedSnapType === "line" && this.editedInsertIndex !== void 0 ? d.coordinates[this.editedFeatureCoordinateIndex] = [i.lng, i.lat] : this.editedSnapType === "line" && this.editedInsertIndex === void 0 && (this.editedInsertIndex = this.editedFeatureCoordinateIndex + 1, d.coordinates.splice(this.editedInsertIndex, 0, [i.lng, i.lat]), this.editedFeatureCoordinateIndex++);
    const f = { type: "LineString", coordinates: d.coordinates };
    this.validate && !this.validate({ type: "Feature", geometry: f, properties: this.store.getPropertiesCopy(this.editedFeatureId) }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Ln.Provisional }).valid || (this.snapping && this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.store.updateGeometry([{ id: this.editedFeatureId, geometry: f }]), this.editedPointId && this.store.updateGeometry([{ id: this.editedPointId, geometry: { type: "Point", coordinates: [i.lng, i.lat] } }]), this.store.updateProperty([{ id: this.editedFeatureId, property: ki.EDITED, value: true }]));
  }
  onDragEnd(i, l) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, i) && this.editedFeatureId !== void 0 && (this.setCursor(this.cursors.dragEnd), this.editedPointId && (this.store.delete([this.editedPointId]), this.editedPointId = void 0), this.store.updateProperty([{ id: this.editedFeatureId, property: ki.EDITED, value: false }]), this.onFinish(this.editedFeatureId, { mode: this.mode, action: "edit" }), this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedInsertIndex = void 0, this.editedSnapType = void 0, l(true));
  }
  cleanUp() {
    const i = this.currentId, l = this.closingPointId, d = this.snappedPointId;
    this.closingPointId = void 0, this.snappedPointId = void 0, this.currentId = void 0, this.currentCoordinate = 0, this.state === "drawing" && this.setStarted();
    try {
      i !== void 0 && this.store.delete([i]), d !== void 0 && this.store.delete([d]), l !== void 0 && this.store.delete([l]);
    } catch {
    }
  }
  styleFeature(i) {
    const l = kn({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0, markerUrl: void 0, markerHeight: void 0, markerWidth: void 0 });
    if (i.type === "Feature" && i.geometry.type === "LineString" && i.properties.mode === this.mode) return l.lineStringColor = this.getHexColorStylingValue(this.styles.lineStringColor, l.lineStringColor, i), l.lineStringWidth = this.getNumericStylingValue(this.styles.lineStringWidth, l.lineStringWidth, i), l.zIndex = op, l;
    if (i.type === "Feature" && i.geometry.type === "Point" && i.properties.mode === this.mode) {
      const d = i.properties[ki.CLOSING_POINT];
      return l.pointColor = this.getHexColorStylingValue(d ? this.styles.closingPointColor : this.styles.snappingPointColor, l.pointColor, i), l.pointWidth = this.getNumericStylingValue(d ? this.styles.closingPointWidth : this.styles.snappingPointWidth, l.pointWidth, i), l.pointOutlineColor = this.getHexColorStylingValue(d ? this.styles.closingPointOutlineColor : this.styles.snappingPointOutlineColor, "#ffffff", i), l.pointOutlineWidth = this.getNumericStylingValue(d ? this.styles.closingPointOutlineWidth : this.styles.snappingPointOutlineWidth, 2, i), l.zIndex = 50, l;
    }
    return l;
  }
  validateFeature(i) {
    return this.validateModeFeature(i, (l) => rI(l, this.coordinatePrecision));
  }
  lineStringFilter(i) {
    return !!(i.geometry.type === "LineString" && i.properties && i.properties.mode === this.mode);
  }
  snapCoordinate(i) {
    var l, d, f;
    let g;
    if ((l = this.snapping) != null && l.toLine) {
      let p;
      p = this.currentId ? this.lineSnapping.getSnappableCoordinate(i, this.currentId) : this.lineSnapping.getSnappableCoordinateFirstClick(i), p && (g = p);
    }
    return (d = this.snapping) != null && d.toCoordinate && (g = this.currentId ? this.coordinateSnapping.getSnappableCoordinate(i, this.currentId) : this.coordinateSnapping.getSnappableCoordinateFirstClick(i)), (f = this.snapping) != null && f.toCustom && (g = this.snapping.toCustom(i, { currentCoordinate: this.currentCoordinate, currentId: this.currentId, getCurrentGeometrySnapshot: this.currentId ? () => this.store.getGeometryCopy(this.currentId) : () => null, project: this.project, unproject: this.unproject })), g;
  }
  afterFeatureUpdated(i) {
    this.editedFeatureId === i.id && this.editedPointId && (this.store.delete([this.editedPointId]), this.editedPointId = void 0, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedSnapType = void 0), this.snappedPointId && this.lastMouseMoveEvent && this.updateSnappedCoordinate(this.lastMouseMoveEvent), this.currentId === i.id && (this.closingPointId && (this.store.delete([this.closingPointId]), this.closingPointId = void 0), this.currentCoordinate = 0, this.currentId = void 0, this.state === "drawing" && this.setStarted());
  }
}
const sI = "Feature is not a Point", lI = "Feature has invalid coordinates", uI = "Feature has coordinates with excessive precision";
function cI(r, i) {
  return r.geometry.type !== "Point" ? { valid: false, reason: sI } : E1(r.geometry.coordinates) ? b0(r.geometry.coordinates, i) ? { valid: true } : { valid: false, reason: uI } : { valid: false, reason: lI };
}
const dI = { create: "crosshair", dragStart: "grabbing", dragEnd: "crosshair" };
class z1 extends Lp {
  constructor(i) {
    super(i, true), this.mode = "point", this.cursors = dI, this.editable = false, this.editedFeatureId = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.updateOptions(i);
  }
  updateOptions(i) {
    super.updateOptions(i), i != null && i.cursors && (this.cursors = kn({}, this.cursors, i.cursors)), i != null && i.editable && (this.editable = i.editable);
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.create);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onClick(i) {
    i.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, i) || i.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, i) ? this.onRightClick(i) : i.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, i) && this.onLeftClick(i);
  }
  onMouseMove() {
  }
  onKeyDown() {
  }
  onKeyUp() {
  }
  cleanUp() {
    this.editedFeatureId = void 0;
  }
  onDragStart(i, l) {
    if (this.allowPointerEvent(this.pointerEvents.onDragStart, i)) {
      if (this.editable) {
        const d = this.getNearestPointFeature(i);
        this.editedFeatureId = d == null ? void 0 : d.id;
      }
      this.editedFeatureId && (this.setCursor(this.cursors.dragStart), l(false));
    }
  }
  onDrag(i, l) {
    this.allowPointerEvent(this.pointerEvents.onDrag, i) && this.editedFeatureId !== void 0 && (this.validate && !this.validate({ type: "Feature", geometry: { type: "Point", coordinates: [i.lng, i.lat] }, properties: this.store.getPropertiesCopy(this.editedFeatureId) }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Ln.Finish }).valid || (this.store.updateGeometry([{ id: this.editedFeatureId, geometry: { type: "Point", coordinates: [i.lng, i.lat] } }]), this.store.updateProperty([{ id: this.editedFeatureId, property: ki.EDITED, value: true }])));
  }
  onDragEnd(i, l) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, i) && this.editedFeatureId !== void 0 && (this.onFinish(this.editedFeatureId, { mode: this.mode, action: "edit" }), this.setCursor(this.cursors.dragEnd), this.store.updateProperty([{ id: this.editedFeatureId, property: ki.EDITED, value: false }]), this.editedFeatureId = void 0, l(true));
  }
  registerBehaviors(i) {
    this.pixelDistance = new mp(i), this.clickBoundingBox = new pp(i);
  }
  styleFeature(i) {
    const l = kn({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0, markerUrl: void 0, markerHeight: void 0, markerWidth: void 0 });
    if (i.type === "Feature" && i.geometry.type === "Point" && i.properties.mode === this.mode) {
      const d = !!(i.id && this.editedFeatureId === i.id);
      l.pointWidth = this.getNumericStylingValue(d ? this.styles.editedPointWidth : this.styles.pointWidth, l.pointWidth, i), l.pointColor = this.getHexColorStylingValue(d ? this.styles.editedPointColor : this.styles.pointColor, l.pointColor, i), l.pointOutlineColor = this.getHexColorStylingValue(d ? this.styles.editedPointOutlineColor : this.styles.pointOutlineColor, l.pointOutlineColor, i), l.pointOutlineWidth = this.getNumericStylingValue(d ? this.styles.editedPointOutlineWidth : this.styles.pointOutlineWidth, 2, i), l.zIndex = 30;
    }
    return l;
  }
  validateFeature(i) {
    return this.validateModeFeature(i, (l) => cI(l, this.coordinatePrecision));
  }
  onLeftClick(i) {
    const l = { type: "Point", coordinates: [i.lng, i.lat] }, d = { mode: this.mode };
    if (this.validate && !this.validate({ type: "Feature", geometry: l, properties: d }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Ln.Finish }).valid) return;
    const [f] = this.store.create([{ geometry: l, properties: d }]);
    this.onFinish(f, { mode: this.mode, action: "draw" });
  }
  onRightClick(i) {
    if (!this.editable) return;
    const l = this.getNearestPointFeature(i);
    l && this.store.delete([l.id]);
  }
  getNearestPointFeature(i) {
    const l = this.clickBoundingBox.create(i), d = this.store.search(l);
    let f, g = 1 / 0;
    for (let p = 0; p < d.length; p++) {
      const s = d[p];
      if (s.geometry.type !== "Point" || s.properties.mode !== this.mode) continue;
      const C = this.pixelDistance.measure(i, s.geometry.coordinates);
      C > g || C > this.pointerDistance || (g = C, f = s);
    }
    return f;
  }
  afterFeatureUpdated(i) {
    this.editedFeatureId === i.id && (this.editedFeatureId = void 0, this.setCursor(this.cursors.create));
  }
}
class hI extends io {
  constructor(i) {
    super(i);
  }
  createOrUpdate(i) {
    const l = this.store.getGeometryCopy(i), d = this.store.getPropertiesCopy(i);
    let f;
    if (l.type === "Polygon") f = l.coordinates[0].slice(0, -1);
    else {
      if (l.type !== "LineString") return;
      f = l.coordinates;
    }
    const g = this.store.getPropertiesCopy(i), p = g.coordinatePointIds;
    if (p) if (p && p.every((s) => this.store.has(s))) {
      const s = g.coordinatePointIds, C = s.map((P) => this.store.getGeometryCopy(P).coordinates);
      if (s.length !== f.length) {
        this.deleteCoordinatePoints(s);
        const P = this.createPoints(f, d.mode, i);
        this.setFeatureCoordinatePoints(i, P);
      } else f.forEach((P, M) => {
        P[0] === C[M][0] && P[1] === C[M][1] || this.store.updateGeometry([{ id: s[M], geometry: { type: "Point", coordinates: P } }]);
      });
    } else {
      const s = p.filter((P) => this.store.has(P));
      s.length && this.deleteCoordinatePoints(s);
      const C = this.createPoints(f, d.mode, i);
      this.setFeatureCoordinatePoints(i, C);
    }
    else {
      const s = this.createPoints(f, d.mode, i);
      this.setFeatureCoordinatePoints(i, s);
    }
  }
  deletePointsByFeatureIds(i) {
    for (const l of i) this.deleteIfPresent(l);
  }
  getUpdated(i, l) {
    const d = this.store.getPropertiesCopy(i);
    if (d.coordinatePointIds) return d.coordinatePointIds.map((f, g) => ({ id: f, geometry: kn({}, this.store.getGeometryCopy(f), { coordinates: l[g] }) }));
  }
  createPoints(i, l, d) {
    return this.store.create(i.map((f, g) => ({ geometry: { type: "Point", coordinates: f }, properties: { mode: l, [ki.COORDINATE_POINT]: true, [ki.COORDINATE_POINT_FEATURE_ID]: d, index: g } })));
  }
  setFeatureCoordinatePoints(i, l) {
    this.store.updateProperty([{ id: i, property: ki.COORDINATE_POINT_IDS, value: l }]);
  }
  deleteCoordinatePoints(i) {
    const l = i.filter((d) => this.store.has(d));
    this.store.delete(l);
  }
  deleteIfPresent(i) {
    const l = this.store.getPropertiesCopy(i).coordinatePointIds;
    l && (this.deleteCoordinatePoints(l), this.setFeatureCoordinatePoints(i, null));
  }
}
function Xg(r, i) {
  const l = r, d = i, f = to(l[1]), g = to(d[1]);
  let p = to(d[0] - l[0]);
  p > Math.PI && (p -= 2 * Math.PI), p < -Math.PI && (p += 2 * Math.PI);
  const s = Math.log(Math.tan(g / 2 + Math.PI / 4) / Math.tan(f / 2 + Math.PI / 4)), C = (pc(Math.atan2(p, s)) + 360) % 360;
  return C > 180 ? -(360 - C) : C;
}
function F1(r, i, l) {
  let d = i;
  i < 0 && (d = -Math.abs(d));
  const f = d / M1, g = r[0] * Math.PI / 180, p = to(r[1]), s = to(l), C = f * Math.cos(s);
  let P = p + C;
  Math.abs(P) > Math.PI / 2 && (P = P > 0 ? Math.PI - P : -Math.PI - P);
  const M = Math.log(Math.tan(P / 2 + Math.PI / 4) / Math.tan(p / 2 + Math.PI / 4)), D = Math.abs(M) > 1e-11 ? C / M : Math.cos(p), L = [(180 * (g + f * Math.sin(s) / D) / Math.PI + 540) % 360 - 180, 180 * P / Math.PI];
  return L[0] += L[0] - r[0] > 180 ? -360 : r[0] - L[0] > 180 ? 360 : 0, L;
}
function fI(r, i, l, d, f) {
  const g = d(r[0], r[1]), p = d(i[0], i[1]), { lng: s, lat: C } = f((g.x + p.x) / 2, (g.y + p.y) / 2);
  return [Li(s, l), Li(C, l)];
}
function pI(r, i, l) {
  const d = F1(r, 1e3 * ss(r, i) / 2, Xg(r, i));
  return [Li(d[0], l), Li(d[1], l)];
}
function fy({ featureCoords: r, precision: i, unproject: l, project: d, projection: f }) {
  const g = [];
  for (let p = 0; p < r.length - 1; p++) {
    let s;
    if (f === "web-mercator") s = fI(r[p], r[p + 1], i, d, l);
    else {
      if (f !== "globe") throw new Error("Invalid projection");
      s = pI(r[p], r[p + 1], i);
    }
    g.push(s);
  }
  return g;
}
class mI extends io {
  constructor(i, l, d) {
    super(i), this.config = void 0, this.selectionPointBehavior = void 0, this.coordinatePointBehavior = void 0, this._midPoints = [], this.config = i, this.selectionPointBehavior = l, this.coordinatePointBehavior = d;
  }
  get ids() {
    return this._midPoints.concat();
  }
  set ids(i) {
  }
  insert(i, l, d) {
    const f = this.store.getGeometryCopy(l), { midPointFeatureId: g, midPointSegment: p } = this.store.getPropertiesCopy(l), s = this.store.getGeometryCopy(g), C = s.type === "Polygon" ? s.coordinates[0] : s.coordinates;
    C.splice(p + 1, 0, f.coordinates), s.coordinates = s.type === "Polygon" ? [C] : C, this.store.updateGeometry([{ id: g, geometry: s }]), this.store.getPropertiesCopy(i)[ki.COORDINATE_POINT_IDS] && this.coordinatePointBehavior.createOrUpdate(i), this.store.delete([...this._midPoints, ...this.selectionPointBehavior.ids]), this.create(C, g, d), this.selectionPointBehavior.create(C, s.type, g);
  }
  create(i, l, d) {
    if (!this.store.has(l)) throw new Error("Store does not have feature with this id");
    this._midPoints = this.store.create((function(f, g, p, s, C, P) {
      return fy({ featureCoords: f, precision: p, project: s, unproject: C, projection: P }).map((M, D) => ({ geometry: { type: "Point", coordinates: M }, properties: g(D) }));
    })(i, (f) => ({ mode: this.mode, [Ki.MID_POINT]: true, midPointSegment: f, midPointFeatureId: l }), d, this.config.project, this.config.unproject, this.projection));
  }
  delete() {
    this._midPoints.length && (this.store.delete(this._midPoints), this._midPoints = []);
  }
  getUpdated(i) {
    if (this._midPoints.length !== 0) return fy({ featureCoords: i, precision: this.coordinatePrecision, project: this.config.project, unproject: this.config.unproject, projection: this.config.projection }).map((l, d) => ({ id: this._midPoints[d], geometry: { type: "Point", coordinates: l } }));
  }
}
class gI extends io {
  constructor(i) {
    super(i), this._selectionPoints = [];
  }
  get ids() {
    return this._selectionPoints.concat();
  }
  set ids(i) {
  }
  create(i, l, d) {
    this._selectionPoints = this.store.create((function(f, g, p) {
      const s = [], C = g === "Polygon" ? f.length - 1 : f.length;
      for (let P = 0; P < C; P++) s.push({ geometry: { type: "Point", coordinates: f[P] }, properties: p(P) });
      return s;
    })(i, l, (f) => ({ mode: this.mode, index: f, [Ki.SELECTION_POINT]: true, [Ki.SELECTION_POINT_FEATURE_ID]: d })));
  }
  delete() {
    this.ids.length && (this.store.delete(this.ids), this._selectionPoints = []);
  }
  getUpdated(i) {
    if (this._selectionPoints.length !== 0) return this._selectionPoints.map((l, d) => ({ id: l, geometry: { type: "Point", coordinates: i[d] } }));
  }
  getOneUpdated(i, l) {
    if (this._selectionPoints[i] !== void 0) return { id: this._selectionPoints[i], geometry: { type: "Point", coordinates: l } };
  }
}
function L1(r, i) {
  let l = false;
  for (let p = 0, s = i.length; p < s; p++) {
    const C = i[p];
    for (let P = 0, M = C.length, D = M - 1; P < M; D = P++) (f = C[P])[1] > (d = r)[1] != (g = C[D])[1] > d[1] && d[0] < (g[0] - f[0]) * (d[1] - f[1]) / (g[1] - f[1]) + f[0] && (l = !l);
  }
  var d, f, g;
  return l;
}
const Yg = (r, i, l) => {
  const d = (g) => g * g, f = (g, p) => d(g.x - p.x) + d(g.y - p.y);
  return Math.sqrt(((g, p, s) => {
    const C = f(p, s);
    if (C === 0) return f(g, p);
    let P = ((g.x - p.x) * (s.x - p.x) + (g.y - p.y) * (s.y - p.y)) / C;
    return P = Math.max(0, Math.min(1, P)), f(g, { x: p.x + P * (s.x - p.x), y: p.y + P * (s.y - p.y) });
  })(r, i, l));
};
class vI extends io {
  constructor(i, l, d) {
    super(i), this.config = void 0, this.createClickBoundingBox = void 0, this.pixelDistance = void 0, this.config = i, this.createClickBoundingBox = l, this.pixelDistance = d;
  }
  find(i, l) {
    let d, f, g, p, s = 1 / 0, C = 1 / 0, P = 1 / 0;
    const M = this.createClickBoundingBox.create(i), D = this.store.search(M);
    for (let L = 0; L < D.length; L++) {
      const $ = D[L], z = $.geometry;
      if (z.type === "Point") {
        if ($.properties.selectionPoint || $.properties.coordinatePoint || !l && $.properties[Ki.MID_POINT]) continue;
        const F = this.pixelDistance.measure(i, z.coordinates);
        $.properties[Ki.MID_POINT] && F < this.pointerDistance && F < P ? (P = F, g = $) : !$.properties[Ki.MID_POINT] && F < this.pointerDistance && F < s && (s = F, d = $);
      } else if (z.type === "LineString") {
        if (d) continue;
        for (let F = 0; F < z.coordinates.length - 1; F++) {
          const Z = z.coordinates[F], q = z.coordinates[F + 1], K = Yg({ x: i.containerX, y: i.containerY }, this.project(Z[0], Z[1]), this.project(q[0], q[1]));
          K < this.pointerDistance && K < C && (C = K, f = $);
        }
      } else if (z.type === "Polygon") {
        if (d || f) continue;
        L1([i.lng, i.lat], z.coordinates) && (p = $);
      }
    }
    return { clickedFeature: d || f || p, clickedMidPoint: g };
  }
}
class _I extends io {
  constructor(i, l, d, f, g) {
    super(i), this.config = void 0, this.featuresAtCursorEvent = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.draggedFeatureId = null, this.dragPosition = void 0, this.config = i, this.featuresAtCursorEvent = l, this.selectionPoints = d, this.midPoints = f, this.coordinatePoints = g;
  }
  startDragging(i, l) {
    this.draggedFeatureId = l, this.dragPosition = [i.lng, i.lat];
  }
  stopDragging() {
    this.draggedFeatureId = null, this.dragPosition = void 0;
  }
  isDragging() {
    return this.draggedFeatureId !== null;
  }
  canDrag(i, l) {
    const { clickedFeature: d } = this.featuresAtCursorEvent.find(i, true);
    return !(!d || d.id !== l);
  }
  drag(i, l) {
    if (!this.draggedFeatureId) return;
    const d = this.store.getGeometryCopy(this.draggedFeatureId), f = [i.lng, i.lat];
    if (d.type === "Polygon" || d.type === "LineString") {
      let g, p;
      if (d.type === "Polygon" ? (g = d.coordinates[0], p = g.length - 1) : (g = d.coordinates, p = g.length), !this.dragPosition) return false;
      for (let M = 0; M < p; M++) {
        const D = g[M];
        let L, $;
        if (this.config.projection === "web-mercator") {
          const z = Fi(this.dragPosition[0], this.dragPosition[1]), F = Fi(f[0], f[1]), Z = Fi(D[0], D[1]), q = { x: z.x - F.x, y: z.y - F.y }, K = Z.x - q.x, te = Z.y - q.y, { lng: re, lat: ie } = mc(K, te);
          L = re, $ = ie;
        } else {
          const z = [this.dragPosition[0] - f[0], this.dragPosition[1] - f[1]];
          L = D[0] - z[0], $ = D[1] - z[1];
        }
        if (L = Li(L, this.config.coordinatePrecision), $ = Li($, this.config.coordinatePrecision), L > 180 || L < -180 || $ > 90 || $ < -90) return false;
        g[M] = [L, $];
      }
      d.type === "Polygon" && (g[g.length - 1] = [g[0][0], g[0][1]]);
      const s = this.selectionPoints.getUpdated(g) || [], C = this.midPoints.getUpdated(g) || [], P = this.coordinatePoints.getUpdated(this.draggedFeatureId, g) || [];
      if (l && !l({ type: "Feature", id: this.draggedFeatureId, geometry: d, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Ln.Provisional }).valid) return false;
      this.store.updateGeometry([{ id: this.draggedFeatureId, geometry: d }, ...s, ...C, ...P]), this.dragPosition = [i.lng, i.lat];
    } else d.type === "Point" && (this.store.updateGeometry([{ id: this.draggedFeatureId, geometry: { type: "Point", coordinates: f } }]), this.dragPosition = [i.lng, i.lat]);
  }
}
class yI extends io {
  constructor(i, l, d, f, g, p, s) {
    super(i), this.config = void 0, this.pixelDistance = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.coordinateSnapping = void 0, this.lineSnapping = void 0, this.draggedCoordinate = { id: null, index: -1 }, this.config = i, this.pixelDistance = l, this.selectionPoints = d, this.midPoints = f, this.coordinatePoints = g, this.coordinateSnapping = p, this.lineSnapping = s;
  }
  getClosestCoordinate(i, l) {
    const d = { dist: 1 / 0, index: -1, isFirstOrLastPolygonCoord: false };
    let f;
    if (l.type === "LineString") f = l.coordinates;
    else {
      if (l.type !== "Polygon") return d;
      f = l.coordinates[0];
    }
    for (let g = 0; g < f.length; g++) {
      const p = this.pixelDistance.measure(i, f[g]);
      if (p < this.pointerDistance && p < d.dist) {
        const s = l.type === "Polygon" && (g === f.length - 1 || g === 0);
        d.dist = p, d.index = s ? 0 : g, d.isFirstOrLastPolygonCoord = s;
      }
    }
    return d;
  }
  getDraggableIndex(i, l) {
    const d = this.store.getGeometryCopy(l), f = this.getClosestCoordinate(i, d);
    return f.index === -1 ? -1 : f.index;
  }
  snapCoordinate(i, l, d) {
    let f = [i.lng, i.lat];
    const g = (p) => !!(p.properties && p.properties.mode === d.properties.mode && p.id !== this.draggedCoordinate.id);
    if (l != null && l.toLine) {
      let p;
      p = this.lineSnapping.getSnappable(i, g).coordinate, p && (f = p);
    }
    if (l.toCoordinate) {
      let p;
      p = this.coordinateSnapping.getSnappable(i, g).coordinate, p && (f = p);
    }
    if (l != null && l.toCustom) {
      let p;
      p = l.toCustom(i, { currentCoordinate: this.draggedCoordinate.index, currentId: d.id, getCurrentGeometrySnapshot: d.id ? () => this.store.getGeometryCopy(d.id) : () => null, project: this.project, unproject: this.unproject }), p && (f = p);
    }
    return f;
  }
  drag(i, l, d, f) {
    const g = this.draggedCoordinate.id;
    if (g === null) return false;
    const p = this.draggedCoordinate.index, s = this.store.getGeometryCopy(g), C = this.store.getPropertiesCopy(g), P = s.type === "LineString" ? s.coordinates : s.coordinates[0], M = s.type === "Polygon" && (p === P.length - 1 || p === 0), D = { type: "Feature", id: g, geometry: s, properties: C }, L = this.snapCoordinate(i, f, D);
    if (i.lng > 180 || i.lng < -180 || i.lat > 90 || i.lat < -90) return false;
    if (M) {
      const q = P.length - 1;
      P[0] = L, P[q] = L;
    } else P[p] = L;
    const $ = this.selectionPoints.getOneUpdated(p, L), z = $ ? [$] : [], F = this.midPoints.getUpdated(P) || [], Z = this.coordinatePoints.getUpdated(g, P) || [];
    return !(s.type !== "Point" && !l && K4({ geometry: s }) || d && !d(D, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Ln.Provisional }).valid || (this.store.updateGeometry([{ id: g, geometry: s }, ...z, ...F, ...Z]), 0));
  }
  isDragging() {
    return this.draggedCoordinate.id !== null;
  }
  startDragging(i, l) {
    this.draggedCoordinate = { id: i, index: l };
  }
  stopDragging() {
    this.draggedCoordinate = { id: null, index: -1 };
  }
}
function py(r) {
  let i = 0, l = 0, d = 0;
  return (r.geometry.type === "Polygon" ? r.geometry.coordinates[0].slice(0, -1) : r.geometry.coordinates).forEach((f) => {
    i += f[0], l += f[1], d++;
  }, true), [i / d, l / d];
}
const B1 = (r, i) => {
  if (i === 0 || i === 360 || i === -360) return r;
  const l = 0.017453292519943295 * i, d = (r.geometry.type === "Polygon" ? r.geometry.coordinates[0] : r.geometry.coordinates).map(([p, s]) => Fi(p, s)), f = d.reduce((p, s) => ({ x: p.x + s.x, y: p.y + s.y }), { x: 0, y: 0 });
  f.x /= d.length, f.y /= d.length;
  const g = d.map((p) => ({ x: f.x + (p.x - f.x) * Math.cos(l) - (p.y - f.y) * Math.sin(l), y: f.y + (p.x - f.x) * Math.sin(l) + (p.y - f.y) * Math.cos(l) })).map(({ x: p, y: s }) => [mc(p, s).lng, mc(p, s).lat]);
  return r.geometry.type === "Polygon" ? r.geometry.coordinates[0] = g : r.geometry.coordinates = g, r;
};
function Kg(r) {
  const i = (r.geometry.type === "Polygon" ? r.geometry.coordinates[0] : r.geometry.coordinates).map((l) => {
    const { x: d, y: f } = Fi(l[0], l[1]);
    return [d, f];
  });
  return r.geometry.type === "Polygon" ? (function(l) {
    let d = 0, f = 0, g = 0;
    const p = l.length;
    for (let s = 0; s < p - 1; s++) {
      const [C, P] = l[s], [M, D] = l[s + 1], L = C * D - M * P;
      d += L, f += (C + M) * L, g += (P + D) * L;
    }
    return d /= 2, f /= 6 * d, g /= 6 * d, { x: f, y: g };
  })(i) : (function(l) {
    const d = l.length;
    let f = 0, g = 0;
    for (let p = 0; p < d; p++) {
      const [s, C] = l[p];
      f += s, g += C;
    }
    return { x: f / d, y: g / d };
  })(i);
}
class bI extends io {
  constructor(i, l, d, f) {
    super(i), this.config = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.lastBearing = void 0, this.selectedGeometry = void 0, this.selectedGeometryCentroid = void 0, this.selectedGeometryWebMercatorCentroid = void 0, this.config = i, this.selectionPoints = l, this.midPoints = d, this.coordinatePoints = f;
  }
  reset() {
    this.lastBearing = void 0, this.selectedGeometry = void 0, this.selectedGeometryWebMercatorCentroid = void 0, this.selectedGeometryCentroid = void 0;
  }
  rotate(i, l, d) {
    this.selectedGeometry || (this.selectedGeometry = this.store.getGeometryCopy(l));
    const f = this.selectedGeometry;
    if (f.type !== "Polygon" && f.type !== "LineString") return;
    const g = [i.lng, i.lat];
    let p;
    const s = { type: "Feature", geometry: f, properties: {} };
    if (this.config.projection === "web-mercator") {
      this.selectedGeometryWebMercatorCentroid || (this.selectedGeometryWebMercatorCentroid = Kg(s));
      const L = Fi(i.lng, i.lat);
      if (p = J4(this.selectedGeometryWebMercatorCentroid, L), p === 0) return;
      if (!this.lastBearing) return void (this.lastBearing = p);
      B1(s, -(this.lastBearing - p));
    } else {
      if (this.config.projection !== "globe") throw new Error("Unsupported projection");
      if (this.selectedGeometryCentroid || (this.selectedGeometryCentroid = py({ geometry: f })), p = Xg(this.selectedGeometryCentroid, g), !this.lastBearing) return void (this.lastBearing = p + 180);
      (function(L, $) {
        if ($ === 0 || $ === 360 || $ === -360) return L;
        const z = py(L);
        (L.geometry.type === "Polygon" ? L.geometry.coordinates[0] : L.geometry.coordinates).forEach((F) => {
          const Z = Xg(z, F) + $, q = (function(te, re) {
            te[0] += te[0] - re[0] > 180 ? -360 : re[0] - te[0] > 180 ? 360 : 0;
            const ie = M1, J = re[1] * Math.PI / 180, we = te[1] * Math.PI / 180, fe = we - J;
            let oe = Math.abs(te[0] - re[0]) * Math.PI / 180;
            oe > Math.PI && (oe -= 2 * Math.PI);
            const he = Math.log(Math.tan(we / 2 + Math.PI / 4) / Math.tan(J / 2 + Math.PI / 4)), _e = Math.abs(he) > 1e-11 ? fe / he : Math.cos(J);
            return Math.sqrt(fe * fe + _e * _e * oe * oe) * ie;
          })(z, F), K = F1(z, q, Z);
          F[0] = K[0], F[1] = K[1];
        });
      })(s, -(this.lastBearing - (p + 180)));
    }
    const C = f.type === "Polygon" ? f.coordinates[0] : f.coordinates;
    C.forEach((L) => {
      L[0] = Li(L[0], this.coordinatePrecision), L[1] = Li(L[1], this.coordinatePrecision);
    });
    const P = this.midPoints.getUpdated(C) || [], M = this.selectionPoints.getUpdated(C) || [], D = this.coordinatePoints.getUpdated(l, C) || [];
    if (d && !d({ id: l, type: "Feature", geometry: f, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Ln.Provisional })) return false;
    this.store.updateGeometry([{ id: l, geometry: f }, ...M, ...P, ...D]), this.projection === "web-mercator" ? this.lastBearing = p : this.projection === "globe" && (this.lastBearing = p + 180);
  }
}
class xI extends io {
  constructor(i, l) {
    super(i), this.config = void 0, this.dragCoordinateResizeBehavior = void 0, this.config = i, this.dragCoordinateResizeBehavior = l;
  }
  scale(i, l, d) {
    if (!this.dragCoordinateResizeBehavior.isDragging()) {
      const f = this.dragCoordinateResizeBehavior.getDraggableIndex(i, l);
      this.dragCoordinateResizeBehavior.startDragging(l, f);
    }
    this.dragCoordinateResizeBehavior.drag(i, "center-fixed", d);
  }
  reset() {
    this.dragCoordinateResizeBehavior.stopDragging();
  }
}
function O1({ coordinates: r, originX: i, originY: l, xScale: d, yScale: f }) {
  d === 1 && f === 1 || r.forEach((g) => {
    const { x: p, y: s } = Fi(g[0], g[1]), C = i + (p - i) * d, P = l + (s - l) * f, { lng: M, lat: D } = mc(C, P);
    g[0] = M, g[1] = D;
  });
}
class wI extends io {
  constructor(i, l, d, f, g) {
    super(i), this.config = void 0, this.pixelDistance = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.minimumScale = 1e-4, this.draggedCoordinate = { id: null, index: -1 }, this.boundingBoxMaps = { opposite: { 0: 4, 1: 5, 2: 6, 3: 7, 4: 0, 5: 1, 6: 2, 7: 3 } }, this.config = i, this.pixelDistance = l, this.selectionPoints = d, this.midPoints = f, this.coordinatePoints = g;
  }
  getClosestCoordinate(i, l) {
    const d = { dist: 1 / 0, index: -1, isFirstOrLastPolygonCoord: false };
    let f;
    if (l.type === "LineString") f = l.coordinates;
    else {
      if (l.type !== "Polygon") return d;
      f = l.coordinates[0];
    }
    for (let g = 0; g < f.length; g++) {
      const p = this.pixelDistance.measure(i, f[g]);
      if (p < this.pointerDistance && p < d.dist) {
        const s = l.type === "Polygon" && (g === f.length - 1 || g === 0);
        d.dist = p, d.index = s ? 0 : g, d.isFirstOrLastPolygonCoord = s;
      }
    }
    return d;
  }
  isValidDragWebMercator(i, l, d) {
    switch (i) {
      case 0:
        if (l <= 0 || d >= 0) return false;
        break;
      case 1:
        if (d >= 0) return false;
        break;
      case 2:
        if (l >= 0 || d >= 0) return false;
        break;
      case 3:
        if (l >= 0) return false;
        break;
      case 4:
        if (l >= 0 || d <= 0) return false;
        break;
      case 5:
        if (d <= 0) return false;
        break;
      case 6:
        if (l <= 0 || d <= 0) return false;
        break;
      case 7:
        if (l <= 0) return false;
    }
    return true;
  }
  getSelectedFeatureDataWebMercator() {
    if (!this.draggedCoordinate.id || this.draggedCoordinate.index === -1) return null;
    const i = this.getFeature(this.draggedCoordinate.id);
    if (!i) return null;
    const l = this.getNormalisedCoordinates(i.geometry);
    return { boundingBox: this.getBBoxWebMercator(l), feature: i, updatedCoords: l, selectedCoordinate: l[this.draggedCoordinate.index] };
  }
  centerWebMercatorDrag(i) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { feature: d, boundingBox: f, updatedCoords: g, selectedCoordinate: p } = l, s = Kg(d);
    if (!s) return null;
    const C = Fi(p[0], p[1]), { closestBBoxIndex: P } = this.getIndexesWebMercator(f, C), M = Fi(i.lng, i.lat);
    return this.scaleWebMercator({ closestBBoxIndex: P, updatedCoords: g, webMercatorCursor: M, webMercatorSelected: C, webMercatorOrigin: s }), g;
  }
  centerFixedWebMercatorDrag(i) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { feature: d, boundingBox: f, updatedCoords: g, selectedCoordinate: p } = l, s = Kg(d);
    if (!s) return null;
    const C = Fi(p[0], p[1]), { closestBBoxIndex: P } = this.getIndexesWebMercator(f, C), M = Fi(i.lng, i.lat);
    return this.scaleFixedWebMercator({ closestBBoxIndex: P, updatedCoords: g, webMercatorCursor: M, webMercatorSelected: C, webMercatorOrigin: s }), g;
  }
  scaleFixedWebMercator({ closestBBoxIndex: i, webMercatorOrigin: l, webMercatorSelected: d, webMercatorCursor: f, updatedCoords: g }) {
    if (!this.isValidDragWebMercator(i, l.x - f.x, l.y - f.y)) return null;
    let p = xa(l, f) / xa(l, d);
    return p < 0 && (p = this.minimumScale), O1({ coordinates: g, originX: l.x, originY: l.y, xScale: p, yScale: p }), g;
  }
  oppositeFixedWebMercatorDrag(i) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { boundingBox: d, updatedCoords: f, selectedCoordinate: g } = l, p = Fi(g[0], g[1]), { oppositeBboxIndex: s, closestBBoxIndex: C } = this.getIndexesWebMercator(d, p), P = { x: d[s][0], y: d[s][1] }, M = Fi(i.lng, i.lat);
    return this.scaleFixedWebMercator({ closestBBoxIndex: C, updatedCoords: f, webMercatorCursor: M, webMercatorSelected: p, webMercatorOrigin: P }), f;
  }
  oppositeWebMercatorDrag(i) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { boundingBox: d, updatedCoords: f, selectedCoordinate: g } = l, p = Fi(g[0], g[1]), { oppositeBboxIndex: s, closestBBoxIndex: C } = this.getIndexesWebMercator(d, p), P = { x: d[s][0], y: d[s][1] }, M = Fi(i.lng, i.lat);
    return this.scaleWebMercator({ closestBBoxIndex: C, updatedCoords: f, webMercatorCursor: M, webMercatorSelected: p, webMercatorOrigin: P }), f;
  }
  scaleWebMercator({ closestBBoxIndex: i, webMercatorOrigin: l, webMercatorSelected: d, webMercatorCursor: f, updatedCoords: g }) {
    const p = l.x - f.x, s = l.y - f.y;
    if (!this.isValidDragWebMercator(i, p, s)) return null;
    let C = 1;
    p !== 0 && i !== 1 && i !== 5 && (C = 1 - (l.x - d.x - p) / p);
    let P = 1;
    return s !== 0 && i !== 3 && i !== 7 && (P = 1 - (l.y - d.y - s) / s), this.validateScale(C, P) ? (C < 0 && (C = this.minimumScale), P < 0 && (P = this.minimumScale), this.performWebMercatorScale(g, l.x, l.y, C, P), g) : null;
  }
  getFeature(i) {
    if (this.draggedCoordinate.id === null) return null;
    const l = this.store.getGeometryCopy(i);
    return l.type !== "Polygon" && l.type !== "LineString" ? null : { id: i, type: "Feature", geometry: l, properties: {} };
  }
  getNormalisedCoordinates(i) {
    return i.type === "Polygon" ? i.coordinates[0] : i.coordinates;
  }
  validateScale(i, l) {
    const d = !isNaN(i) && l < Number.MAX_SAFE_INTEGER, f = !isNaN(l) && l < Number.MAX_SAFE_INTEGER;
    return d && f;
  }
  performWebMercatorScale(i, l, d, f, g) {
    i.forEach((p) => {
      const { x: s, y: C } = Fi(p[0], p[1]), P = l + (s - l) * f, M = d + (C - d) * g, { lng: D, lat: L } = mc(P, M);
      p[0] = D, p[1] = L;
    });
  }
  getBBoxWebMercator(i) {
    const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    (i = i.map((s) => {
      const { x: C, y: P } = Fi(s[0], s[1]);
      return [C, P];
    })).forEach(([s, C]) => {
      s < l[0] && (l[0] = s), C < l[1] && (l[1] = C), s > l[2] && (l[2] = s), C > l[3] && (l[3] = C);
    });
    const [d, f, g, p] = l;
    return [[d, p], [(d + g) / 2, p], [g, p], [g, p + (f - p) / 2], [g, f], [(d + g) / 2, f], [d, f], [d, p + (f - p) / 2]];
  }
  getIndexesWebMercator(i, l) {
    let d, f = 1 / 0;
    for (let g = 0; g < i.length; g++) {
      const p = xa({ x: l.x, y: l.y }, { x: i[g][0], y: i[g][1] });
      p < f && (d = g, f = p);
    }
    if (d === void 0) throw new Error("No closest coordinate found");
    return { oppositeBboxIndex: this.boundingBoxMaps.opposite[d], closestBBoxIndex: d };
  }
  isDragging() {
    return this.draggedCoordinate.id !== null;
  }
  startDragging(i, l) {
    this.draggedCoordinate = { id: i, index: l };
  }
  stopDragging() {
    this.draggedCoordinate = { id: null, index: -1 };
  }
  getDraggableIndex(i, l) {
    const d = this.store.getGeometryCopy(l), f = this.getClosestCoordinate(i, d);
    return f.index === -1 ? -1 : f.index;
  }
  drag(i, l, d) {
    if (!this.draggedCoordinate.id) return false;
    const f = this.getFeature(this.draggedCoordinate.id);
    if (!f) return false;
    let g = null;
    if (l === "center" ? g = this.centerWebMercatorDrag(i) : l === "opposite" ? g = this.oppositeWebMercatorDrag(i) : l === "center-fixed" ? g = this.centerFixedWebMercatorDrag(i) : l === "opposite-fixed" && (g = this.oppositeFixedWebMercatorDrag(i)), !g) return false;
    for (let M = 0; M < g.length; M++) {
      const D = g[M];
      if (D[0] = Li(D[0], this.coordinatePrecision), D[1] = Li(D[1], this.coordinatePrecision), !b0(D, this.coordinatePrecision)) return false;
    }
    const p = this.midPoints.getUpdated(g) || [], s = this.selectionPoints.getUpdated(g) || [], C = this.coordinatePoints.getUpdated(f.id, g) || [], P = { type: f.geometry.type, coordinates: f.geometry.type === "Polygon" ? [g] : g };
    return !(d && !d({ id: this.draggedCoordinate.id, type: "Feature", geometry: P, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Ln.Provisional }).valid || (this.store.updateGeometry([{ id: this.draggedCoordinate.id, geometry: P }, ...s, ...p, ...C]), 0));
  }
}
const CI = { deselect: "Escape", delete: "Delete", rotate: ["Control", "r"], scale: ["Control", "s"] }, my = { pointerOver: "move", dragStart: "move", dragEnd: "move", insertMidpoint: "crosshair" };
class $1 extends X4 {
  constructor(i) {
    super(i, true), this.mode = "select", this.allowManualDeselection = true, this.dragEventThrottle = 5, this.dragEventCount = 0, this.selected = [], this.flags = {}, this.keyEvents = CI, this.cursors = my, this.validations = {}, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinateSnap = void 0, this.featuresAtMouseEvent = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.dragFeature = void 0, this.dragCoordinate = void 0, this.rotateFeature = void 0, this.scaleFeature = void 0, this.dragCoordinateResizeFeature = void 0, this.coordinatePoints = void 0, this.lineSnap = void 0, this.updateOptions(i);
  }
  updateOptions(i) {
    if (super.updateOptions(i), this.cursors = i && i.cursors ? kn({}, this.cursors, i.cursors) : my, (i == null ? void 0 : i.keyEvents) === null ? this.keyEvents = { deselect: null, delete: null, rotate: null, scale: null } : i != null && i.keyEvents && (this.keyEvents = kn({}, this.keyEvents, i.keyEvents)), (i == null ? void 0 : i.dragEventThrottle) !== void 0 && (this.dragEventThrottle = i.dragEventThrottle), (i == null ? void 0 : i.allowManualDeselection) !== void 0 && (this.allowManualDeselection = i.allowManualDeselection), i != null && i.flags) {
      this.flags = kn({}, this.flags, i.flags), this.validations = {};
      for (const l in this.flags) {
        const d = this.flags[l].feature;
        d && d.validation && (this.validations[l] = d.validation);
      }
    }
  }
  selectFeature(i) {
    this.select(i, false);
  }
  setSelecting() {
    if (this._state !== "started") throw new Error("Mode must be started to move to selecting state");
    this._state = "selecting";
  }
  registerBehaviors(i) {
    this.pixelDistance = new mp(i), this.clickBoundingBox = new pp(i), this.featuresAtMouseEvent = new vI(i, this.clickBoundingBox, this.pixelDistance), this.selectionPoints = new gI(i), this.coordinatePoints = new hI(i), this.midPoints = new mI(i, this.selectionPoints, this.coordinatePoints), this.coordinateSnap = new Hg(i, this.pixelDistance, this.clickBoundingBox), this.lineSnap = new A1(i, this.pixelDistance, this.clickBoundingBox), this.rotateFeature = new bI(i, this.selectionPoints, this.midPoints, this.coordinatePoints), this.dragFeature = new _I(i, this.featuresAtMouseEvent, this.selectionPoints, this.midPoints, this.coordinatePoints), this.dragCoordinate = new yI(i, this.pixelDistance, this.selectionPoints, this.midPoints, this.coordinatePoints, this.coordinateSnap, this.lineSnap), this.dragCoordinateResizeFeature = new wI(i, this.pixelDistance, this.selectionPoints, this.midPoints, this.coordinatePoints), this.scaleFeature = new xI(i, this.dragCoordinateResizeFeature);
  }
  deselectFeature() {
    this.deselect();
  }
  deselect() {
    const i = this.selected.filter((l) => this.store.has(l)).map((l) => ({ id: l, property: Ki.SELECTED, value: false }));
    this.store.updateProperty(i), this.onDeselect(this.selected[0]), this.selected = [], this.selectionPoints.delete(), this.midPoints.delete();
  }
  deleteSelected() {
    this.store.delete(this.selected), this.selected = [];
  }
  onRightClick(i) {
    if (!this.selectionPoints.ids.length) return;
    let l, d = 1 / 0;
    if (this.selectionPoints.ids.forEach((L) => {
      const $ = this.store.getGeometryCopy(L), z = this.pixelDistance.measure(i, $.coordinates);
      z < this.pointerDistance && z < d && (d = z, l = this.store.getPropertiesCopy(L));
    }), !l) return;
    const f = l.selectionPointFeatureId, g = l.index, p = this.store.getPropertiesCopy(f), s = this.flags[p.mode], C = this.validations[p.mode];
    if (!(s && s.feature && s.feature.coordinates && s.feature.coordinates.deletable)) return;
    const P = this.store.getGeometryCopy(f);
    let M;
    if (P.type === "Polygon") {
      if (M = P.coordinates[0], M.length <= 4) return;
    } else if (P.type === "LineString" && (M = P.coordinates, M.length <= 2)) return;
    if (!M || (P.type !== "Polygon" || g !== 0 && g !== M.length - 1 ? M.splice(g, 1) : (M.shift(), M.pop(), M.push([M[0][0], M[0][1]])), C && !C({ id: f, type: "Feature", geometry: P, properties: p }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Ln.Commit }).valid)) return;
    const D = [...this.midPoints.ids, ...this.selectionPoints.ids];
    this.store.delete(D), this.store.updateGeometry([{ id: f, geometry: P }]), p.coordinatePointIds && this.coordinatePoints.createOrUpdate(f), this.selectionPoints.create(M, P.type, f), s && s.feature && s.feature.coordinates && s.feature.coordinates.midpoints && this.midPoints.create(M, f, this.coordinatePrecision);
  }
  select(i, l = true) {
    if (this.selected[0] === i) return;
    const { mode: d } = this.store.getPropertiesCopy(i), f = this.flags[d];
    if (!f || !f.feature) return;
    const g = this.selected[0];
    if (g) {
      if (g === i) return;
      this.deselect();
    }
    l && this.setCursor(this.cursors.pointerOver), this.selected = [i], this.store.updateProperty([{ id: i, property: Ki.SELECTED, value: true }]), this.onSelect(i);
    const { type: p, coordinates: s } = this.store.getGeometryCopy(i);
    if (p !== "LineString" && p !== "Polygon") return;
    const C = p === "LineString" ? s : s[0];
    C && f && f.feature.coordinates && (this.selectionPoints.create(C, p, i), f.feature.coordinates.midpoints && this.midPoints.create(C, i, this.coordinatePrecision));
  }
  onLeftClick(i) {
    const { clickedFeature: l, clickedMidPoint: d } = this.featuresAtMouseEvent.find(i, this.selected.length > 0);
    if (this.selected.length && d) this.midPoints.insert(this.selected[0], d.id, this.coordinatePrecision);
    else if (l && l.id) this.select(l.id, true);
    else if (this.selected.length && this.allowManualDeselection) return void this.deselect();
  }
  start() {
    this.setStarted(), this.setSelecting();
  }
  stop() {
    this.cleanUp(), this.setStarted(), this.setStopped();
  }
  onClick(i) {
    i.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, i) || i.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, i) ? this.onRightClick(i) : i.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, i) && this.onLeftClick(i);
  }
  canScale(i) {
    return this.keyEvents.scale && this.keyEvents.scale.every((l) => i.heldKeys.includes(l));
  }
  canRotate(i) {
    return this.keyEvents.rotate && this.keyEvents.rotate.every((l) => i.heldKeys.includes(l));
  }
  preventDefaultKeyEvent(i) {
    const l = this.canRotate(i), d = this.canScale(i);
    (l || d) && i.preventDefault();
  }
  onKeyDown(i) {
    this.preventDefaultKeyEvent(i);
  }
  onKeyUp(i) {
    if (this.preventDefaultKeyEvent(i), this.keyEvents.delete && i.key === this.keyEvents.delete) {
      if (!this.selected.length) return;
      const l = this.selected[0];
      this.onDeselect(this.selected[0]), this.coordinatePoints.deletePointsByFeatureIds([l]), this.deleteSelected(), this.selectionPoints.delete(), this.midPoints.delete();
    } else this.keyEvents.deselect && i.key === this.keyEvents.deselect && this.cleanUp();
  }
  cleanUp() {
    this.selected.length && this.deselect();
  }
  onDragStart(i, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDragStart, i) || !this.selected.length) return;
    const d = this.store.getPropertiesCopy(this.selected[0]), f = this.flags[d.mode];
    if (!(f && f.feature && (f.feature.draggable || f.feature.coordinates && f.feature.coordinates.draggable || f.feature.coordinates && f.feature.coordinates.resizable || f.feature.coordinates && typeof f.feature.coordinates.midpoints == "object" && f.feature.coordinates.midpoints.draggable))) return;
    this.dragEventCount = 0;
    const g = this.selected[0], p = this.dragCoordinate.getDraggableIndex(i, g);
    if (f && f.feature && f.feature.coordinates && (f.feature.coordinates.draggable || f.feature.coordinates.resizable) && p !== -1) return this.setCursor(this.cursors.dragStart), f.feature.coordinates.resizable ? this.dragCoordinateResizeFeature.startDragging(g, p) : this.dragCoordinate.startDragging(g, p), void l(false);
    if (f && f.feature && f.feature.coordinates && typeof f.feature.coordinates.midpoints == "object" && f.feature.coordinates.midpoints.draggable) {
      const { clickedMidPoint: s } = this.featuresAtMouseEvent.find(i, this.selected.length > 0);
      if (this.selected.length && s) {
        this.midPoints.insert(g, s.id, this.coordinatePrecision);
        const C = this.dragCoordinate.getDraggableIndex(i, g);
        return this.dragCoordinate.startDragging(g, C), void l(false);
      }
    }
    return f && f.feature && f.feature.draggable && this.dragFeature.canDrag(i, g) ? (this.setCursor(this.cursors.dragStart), this.dragFeature.startDragging(i, g), void l(false)) : void 0;
  }
  onDrag(i, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDrag, i)) return;
    const d = this.selected[0];
    if (!d) return;
    const f = this.store.getPropertiesCopy(d), g = this.flags[f.mode], p = (g && g.feature && g.feature.selfIntersectable) === true;
    if (this.dragEventCount++, this.dragEventCount % this.dragEventThrottle == 0) return;
    const s = this.validations[f.mode];
    if (g && g.feature && g.feature.rotateable && this.canRotate(i)) return l(false), void this.rotateFeature.rotate(i, d, s);
    if (g && g.feature && g.feature.scaleable && this.canScale(i)) return l(false), void this.scaleFeature.scale(i, d, s);
    if (this.dragCoordinateResizeFeature.isDragging() && g.feature && g.feature.coordinates && g.feature.coordinates.resizable) {
      if (this.projection === "globe") throw new Error("Globe is currently unsupported projection for resizable");
      return l(false), void this.dragCoordinateResizeFeature.drag(i, g.feature.coordinates.resizable, s);
    }
    if (this.dragCoordinate.isDragging()) {
      var C;
      const P = (C = g.feature) == null || (C = C.coordinates) == null ? void 0 : C.snappable;
      let M = { toCoordinate: false };
      return P === true ? M = { toCoordinate: true } : typeof P == "object" && (M = P), void this.dragCoordinate.drag(i, p, s, M);
    }
    this.dragFeature.isDragging() ? this.dragFeature.drag(i, s) : l(true);
  }
  onDragEnd(i, l) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, i) && (this.setCursor(this.cursors.dragEnd), this.dragCoordinate.isDragging() ? this.onFinish(this.selected[0], { mode: this.mode, action: "dragCoordinate" }) : this.dragFeature.isDragging() ? this.onFinish(this.selected[0], { mode: this.mode, action: "dragFeature" }) : this.dragCoordinateResizeFeature.isDragging() && this.onFinish(this.selected[0], { mode: this.mode, action: "dragCoordinateResize" }), this.dragCoordinate.stopDragging(), this.dragFeature.stopDragging(), this.dragCoordinateResizeFeature.stopDragging(), this.rotateFeature.reset(), this.scaleFeature.reset(), l(true));
  }
  onMouseMove(i) {
    if (!this.selected.length) return void this.setCursor("unset");
    if (this.dragFeature.isDragging()) return;
    let l = false;
    this.midPoints.ids.forEach((g) => {
      if (l) return;
      const p = this.store.getGeometryCopy(g);
      this.pixelDistance.measure(i, p.coordinates) < this.pointerDistance && (l = true);
    });
    let d = false;
    if (this.selectionPoints.ids.forEach((g) => {
      const p = this.store.getGeometryCopy(g);
      this.pixelDistance.measure(i, p.coordinates) < this.pointerDistance && (l = false, d = true);
    }), l) return void this.setCursor(this.cursors.insertMidpoint);
    const { clickedFeature: f } = this.featuresAtMouseEvent.find(i, true);
    this.setCursor(this.selected.length > 0 && (f && f.id === this.selected[0] || d) ? this.cursors.pointerOver : "unset");
  }
  styleFeature(i) {
    const l = kn({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0, markerUrl: void 0, markerHeight: void 0, markerWidth: void 0 });
    if (i.properties.mode === this.mode && i.geometry.type === "Point") {
      if (i.properties[Ki.SELECTION_POINT]) return l.pointColor = this.getHexColorStylingValue(this.styles.selectionPointColor, l.pointColor, i), l.pointOutlineColor = this.getHexColorStylingValue(this.styles.selectionPointOutlineColor, l.pointOutlineColor, i), l.pointWidth = this.getNumericStylingValue(this.styles.selectionPointWidth, l.pointWidth, i), l.pointOutlineWidth = this.getNumericStylingValue(this.styles.selectionPointOutlineWidth, 2, i), l.zIndex = 30, l;
      if (i.properties[Ki.MID_POINT]) return l.pointColor = this.getHexColorStylingValue(this.styles.midPointColor, l.pointColor, i), l.pointOutlineColor = this.getHexColorStylingValue(this.styles.midPointOutlineColor, l.pointOutlineColor, i), l.pointWidth = this.getNumericStylingValue(this.styles.midPointWidth, 4, i), l.pointOutlineWidth = this.getNumericStylingValue(this.styles.midPointOutlineWidth, 2, i), l.zIndex = 50, l;
    } else if (i.properties[Ki.SELECTED]) {
      if (i.geometry.type === "Point" && i.properties[ki.MARKER]) return l.markerUrl = this.getUrlStylingValue(this.styles.selectedMarkerUrl, W4, i), l.markerHeight = this.getNumericStylingValue(this.styles.selectedMarkerHeight, 40, i), l.markerWidth = this.getNumericStylingValue(this.styles.selectedMarkerWidth, 32, i), l;
      if (i.geometry.type === "Polygon") return l.polygonFillColor = this.getHexColorStylingValue(this.styles.selectedPolygonColor, l.polygonFillColor, i), l.polygonOutlineWidth = this.getNumericStylingValue(this.styles.selectedPolygonOutlineWidth, l.polygonOutlineWidth, i), l.polygonOutlineColor = this.getHexColorStylingValue(this.styles.selectedPolygonOutlineColor, l.polygonOutlineColor, i), l.polygonFillOpacity = this.getNumericStylingValue(this.styles.selectedPolygonFillOpacity, l.polygonFillOpacity, i), l.zIndex = op, l;
      if (i.geometry.type === "LineString") return l.lineStringColor = this.getHexColorStylingValue(this.styles.selectedLineStringColor, l.lineStringColor, i), l.lineStringWidth = this.getNumericStylingValue(this.styles.selectedLineStringWidth, l.lineStringWidth, i), l.zIndex = op, l;
      if (i.geometry.type === "Point") return l.pointWidth = this.getNumericStylingValue(this.styles.selectedPointWidth, l.pointWidth, i), l.pointColor = this.getHexColorStylingValue(this.styles.selectedPointColor, l.pointColor, i), l.pointOutlineColor = this.getHexColorStylingValue(this.styles.selectedPointOutlineColor, l.pointOutlineColor, i), l.pointOutlineWidth = this.getNumericStylingValue(this.styles.selectedPointOutlineWidth, l.pointOutlineWidth, i), l.zIndex = op, l;
    }
    return l;
  }
  afterFeatureUpdated(i) {
    if (this.selected.length && i.id === this.selected[0]) {
      var l, d;
      const f = this.flags[i.properties.mode];
      if (f == null || (l = f.feature) == null || !l.coordinates) return;
      const g = i.geometry.type, p = i.id;
      let s;
      if (this.selectionPoints.delete(), this.midPoints.delete(), g === "Polygon") s = i.geometry.coordinates[0];
      else {
        if (g !== "LineString") return;
        s = i.geometry.coordinates;
      }
      this.selectionPoints.create(s, g, p), f != null && (d = f.feature) != null && (d = d.coordinates) != null && d.midpoints && this.midPoints.create(g === "Polygon" ? i.geometry.coordinates[0] : i.geometry.coordinates, p, this.coordinatePrecision);
    }
  }
}
class SI extends Lp {
  constructor(...i) {
    super(...i), this.type = fc.Static, this.mode = "static";
  }
  start() {
  }
  stop() {
  }
  onKeyUp() {
  }
  onKeyDown() {
  }
  onClick() {
  }
  onDragStart() {
  }
  onDrag() {
  }
  onDragEnd() {
  }
  onMouseMove() {
  }
  cleanUp() {
  }
  styleFeature() {
    return kn({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0, markerUrl: void 0, markerHeight: void 0, markerWidth: void 0 });
  }
}
function j1(r, i, l, d, f) {
  for (; d > l; ) {
    if (d - l > 600) {
      const C = d - l + 1, P = i - l + 1, M = Math.log(C), D = 0.5 * Math.exp(2 * M / 3), L = 0.5 * Math.sqrt(M * D * (C - D) / C) * (P - C / 2 < 0 ? -1 : 1);
      j1(r, i, Math.max(l, Math.floor(i - P * D / C + L)), Math.min(d, Math.floor(i + (C - P) * D / C + L)), f);
    }
    const g = r[i];
    let p = l, s = d;
    for (Od(r, l, i), f(r[d], g) > 0 && Od(r, l, d); p < s; ) {
      for (Od(r, p, s), p++, s--; f(r[p], g) < 0; ) p++;
      for (; f(r[s], g) > 0; ) s--;
    }
    f(r[l], g) === 0 ? Od(r, l, s) : (s++, Od(r, s, d)), s <= i && (l = s + 1), i <= s && (d = s - 1);
  }
}
function Od(r, i, l) {
  const d = r[i];
  r[i] = r[l], r[l] = d;
}
function ic(r, i) {
  jd(r, 0, r.children.length, i, r);
}
function jd(r, i, l, d, f) {
  f || (f = sc([])), f.minX = 1 / 0, f.minY = 1 / 0, f.maxX = -1 / 0, f.maxY = -1 / 0;
  for (let g = i; g < l; g++) {
    const p = r.children[g];
    Nd(f, r.leaf ? d(p) : p);
  }
  return f;
}
function Nd(r, i) {
  return r.minX = Math.min(r.minX, i.minX), r.minY = Math.min(r.minY, i.minY), r.maxX = Math.max(r.maxX, i.maxX), r.maxY = Math.max(r.maxY, i.maxY), r;
}
function kI(r, i) {
  return r.minX - i.minX;
}
function PI(r, i) {
  return r.minY - i.minY;
}
function mg(r) {
  return (r.maxX - r.minX) * (r.maxY - r.minY);
}
function Xf(r) {
  return r.maxX - r.minX + (r.maxY - r.minY);
}
function TI(r, i) {
  const l = Math.max(r.minX, i.minX), d = Math.max(r.minY, i.minY), f = Math.min(r.maxX, i.maxX), g = Math.min(r.maxY, i.maxY);
  return Math.max(0, f - l) * Math.max(0, g - d);
}
function gg(r, i) {
  return r.minX <= i.minX && r.minY <= i.minY && i.maxX <= r.maxX && i.maxY <= r.maxY;
}
function Yf(r, i) {
  return i.minX <= r.maxX && i.minY <= r.maxY && i.maxX >= r.minX && i.maxY >= r.minY;
}
function sc(r) {
  return { children: r, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
}
function gy(r, i, l, d, f) {
  const g = [i, l];
  for (; g.length; ) {
    if ((l = g.pop()) - (i = g.pop()) <= d) continue;
    const p = i + Math.ceil((l - i) / d / 2) * d;
    j1(r, p, i, l, f), g.push(i, p, p, l);
  }
}
class II {
  constructor(i) {
    this._maxEntries = void 0, this._minEntries = void 0, this.data = void 0, this._maxEntries = Math.max(4, i), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
  }
  search(i) {
    let l = this.data;
    const d = [];
    if (!Yf(i, l)) return d;
    const f = this.toBBox, g = [];
    for (; l; ) {
      for (let p = 0; p < l.children.length; p++) {
        const s = l.children[p], C = l.leaf ? f(s) : s;
        Yf(i, C) && (l.leaf ? d.push(s) : gg(i, C) ? this._all(s, d) : g.push(s));
      }
      l = g.pop();
    }
    return d;
  }
  collides(i) {
    let l = this.data;
    if (Yf(i, l)) {
      const d = [];
      for (; l; ) {
        for (let f = 0; f < l.children.length; f++) {
          const g = l.children[f], p = l.leaf ? this.toBBox(g) : g;
          if (Yf(i, p)) {
            if (l.leaf || gg(i, p)) return true;
            d.push(g);
          }
        }
        l = d.pop();
      }
    }
    return false;
  }
  load(i) {
    if (i.length < this._minEntries) {
      for (let d = 0; d < i.length; d++) this.insert(i[d]);
      return;
    }
    let l = this._build(i.slice(), 0, i.length - 1, 0);
    if (this.data.children.length) if (this.data.height === l.height) this._splitRoot(this.data, l);
    else {
      if (this.data.height < l.height) {
        const d = this.data;
        this.data = l, l = d;
      }
      this._insert(l, this.data.height - l.height - 1, true);
    }
    else this.data = l;
  }
  insert(i) {
    this._insert(i, this.data.height - 1);
  }
  clear() {
    this.data = sc([]);
  }
  remove(i) {
    let l = this.data;
    const d = this.toBBox(i), f = [], g = [];
    let p, s, C = false;
    for (; l || f.length; ) {
      if (l || (l = f.pop(), s = f[f.length - 1], p = g.pop(), C = true), l.leaf) {
        const P = l.children.indexOf(i);
        P !== -1 && (l.children.splice(P, 1), f.push(l), this._condense(f));
      }
      C || l.leaf || !gg(l, d) ? s ? (p++, l = s.children[p], C = false) : l = null : (f.push(l), g.push(p), p = 0, s = l, l = l.children[0]);
    }
  }
  toBBox(i) {
    return i;
  }
  compareMinX(i, l) {
    return i.minX - l.minX;
  }
  compareMinY(i, l) {
    return i.minY - l.minY;
  }
  _all(i, l) {
    const d = [];
    for (; i; ) i.leaf ? l.push(...i.children) : d.push(...i.children), i = d.pop();
    return l;
  }
  _build(i, l, d, f) {
    const g = d - l + 1;
    let p, s = this._maxEntries;
    if (g <= s) return p = sc(i.slice(l, d + 1)), ic(p, this.toBBox), p;
    f || (f = Math.ceil(Math.log(g) / Math.log(s)), s = Math.ceil(g / Math.pow(s, f - 1))), p = sc([]), p.leaf = false, p.height = f;
    const C = Math.ceil(g / s), P = C * Math.ceil(Math.sqrt(s));
    gy(i, l, d, P, this.compareMinX);
    for (let M = l; M <= d; M += P) {
      const D = Math.min(M + P - 1, d);
      gy(i, M, D, C, this.compareMinY);
      for (let L = M; L <= D; L += C) {
        const $ = Math.min(L + C - 1, D);
        p.children.push(this._build(i, L, $, f - 1));
      }
    }
    return ic(p, this.toBBox), p;
  }
  _chooseSubtree(i, l, d, f) {
    for (; f.push(l), !l.leaf && f.length - 1 !== d; ) {
      let s, C = 1 / 0, P = 1 / 0;
      for (let M = 0; M < l.children.length; M++) {
        const D = l.children[M], L = mg(D), $ = (g = i, p = D, (Math.max(p.maxX, g.maxX) - Math.min(p.minX, g.minX)) * (Math.max(p.maxY, g.maxY) - Math.min(p.minY, g.minY)) - L);
        $ < P ? (P = $, C = L < C ? L : C, s = D) : $ === P && L < C && (C = L, s = D);
      }
      l = s || l.children[0];
    }
    var g, p;
    return l;
  }
  _insert(i, l, d) {
    const f = d ? i : this.toBBox(i), g = [], p = this._chooseSubtree(f, this.data, l, g);
    for (p.children.push(i), Nd(p, f); l >= 0 && g[l].children.length > this._maxEntries; ) this._split(g, l), l--;
    this._adjustParentBBoxes(f, g, l);
  }
  _split(i, l) {
    const d = i[l], f = d.children.length, g = this._minEntries;
    this._chooseSplitAxis(d, g, f);
    const p = this._chooseSplitIndex(d, g, f), s = sc(d.children.splice(p, d.children.length - p));
    s.height = d.height, s.leaf = d.leaf, ic(d, this.toBBox), ic(s, this.toBBox), l ? i[l - 1].children.push(s) : this._splitRoot(d, s);
  }
  _splitRoot(i, l) {
    this.data = sc([i, l]), this.data.height = i.height + 1, this.data.leaf = false, ic(this.data, this.toBBox);
  }
  _chooseSplitIndex(i, l, d) {
    let f, g = 1 / 0, p = 1 / 0;
    for (let s = l; s <= d - l; s++) {
      const C = jd(i, 0, s, this.toBBox), P = jd(i, s, d, this.toBBox), M = TI(C, P), D = mg(C) + mg(P);
      M < g ? (g = M, f = s, p = D < p ? D : p) : M === g && D < p && (p = D, f = s);
    }
    return f || d - l;
  }
  _chooseSplitAxis(i, l, d) {
    const f = i.leaf ? this.compareMinX : kI, g = i.leaf ? this.compareMinY : PI;
    this._allDistMargin(i, l, d, f) < this._allDistMargin(i, l, d, g) && i.children.sort(f);
  }
  _allDistMargin(i, l, d, f) {
    i.children.sort(f);
    const g = this.toBBox, p = jd(i, 0, l, g), s = jd(i, d - l, d, g);
    let C = Xf(p) + Xf(s);
    for (let P = l; P < d - l; P++) {
      const M = i.children[P];
      Nd(p, i.leaf ? g(M) : M), C += Xf(p);
    }
    for (let P = d - l - 1; P >= l; P--) {
      const M = i.children[P];
      Nd(s, i.leaf ? g(M) : M), C += Xf(s);
    }
    return C;
  }
  _adjustParentBBoxes(i, l, d) {
    for (let f = d; f >= 0; f--) Nd(l[f], i);
  }
  _condense(i) {
    for (let l, d = i.length - 1; d >= 0; d--) i[d].children.length === 0 ? d > 0 ? (l = i[d - 1].children, l.splice(l.indexOf(i[d]), 1)) : this.clear() : ic(i[d], this.toBBox);
  }
}
class MI {
  constructor(i) {
    this.tree = void 0, this.idToNode = void 0, this.nodeToId = void 0, this.tree = new II(i && i.maxEntries ? i.maxEntries : 9), this.idToNode = /* @__PURE__ */ new Map(), this.nodeToId = /* @__PURE__ */ new Map();
  }
  setMaps(i, l) {
    this.idToNode.set(i.id, l), this.nodeToId.set(l, i.id);
  }
  toBBox(i) {
    const l = [], d = [];
    let f;
    if (i.geometry.type === "Polygon") f = i.geometry.coordinates[0];
    else if (i.geometry.type === "LineString") f = i.geometry.coordinates;
    else {
      if (i.geometry.type !== "Point") throw new Error("Not a valid feature to turn into a bounding box");
      f = [i.geometry.coordinates];
    }
    for (let s = 0; s < f.length; s++) d.push(f[s][1]), l.push(f[s][0]);
    const g = Math.min(...d), p = Math.max(...d);
    return { minX: Math.min(...l), minY: g, maxX: Math.max(...l), maxY: p };
  }
  insert(i) {
    if (this.idToNode.get(String(i.id))) throw new Error("Feature already exists");
    const l = this.toBBox(i);
    this.setMaps(i, l), this.tree.insert(l);
  }
  load(i) {
    const l = [], d = /* @__PURE__ */ new Set();
    i.forEach((f) => {
      const g = this.toBBox(f);
      if (this.setMaps(f, g), d.has(String(f.id))) throw new Error(`Duplicate feature ID found ${f.id}`);
      d.add(String(f.id)), l.push(g);
    }), this.tree.load(l);
  }
  update(i) {
    this.remove(i.id);
    const l = this.toBBox(i);
    this.setMaps(i, l), this.tree.insert(l);
  }
  remove(i) {
    const l = this.idToNode.get(i);
    if (!l) throw new Error(`${i} not inserted into the spatial index`);
    this.tree.remove(l);
  }
  clear() {
    this.tree.clear();
  }
  search(i) {
    return this.tree.search(this.toBBox(i)).map((l) => this.nodeToId.get(l));
  }
  collides(i) {
    return this.tree.collides(this.toBBox(i));
  }
}
const EI = { getId: () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(r) {
  const i = 16 * Math.random() | 0;
  return (r == "x" ? i : 3 & i | 8).toString(16);
}), isValidId: (r) => typeof r == "string" && r.length === 36 };
class RI {
  constructor(i) {
    this.idStrategy = void 0, this.tracked = void 0, this.spatialIndex = void 0, this.store = void 0, this._onChange = () => {
    }, this.store = {}, this.spatialIndex = new MI(), this.tracked = !i || i.tracked !== false, this.idStrategy = i && i.idStrategy ? i.idStrategy : EI;
  }
  clone(i) {
    return JSON.parse(JSON.stringify(i));
  }
  getId() {
    return this.idStrategy.getId();
  }
  has(i) {
    return !!this.store[i];
  }
  load(i, l, d, f) {
    if (i.length === 0) return [];
    let g = this.clone(i);
    const p = [], s = [];
    g = g.filter((P) => {
      P.id == null && (P.id = this.idStrategy.getId());
      const M = P.id;
      if (l) {
        const D = l(P);
        if (!D.valid) return p.push({ id: M, valid: false, reason: D.reason }), false;
      }
      if (this.tracked) {
        if (P.properties.createdAt) {
          if (!oy(P.properties.createdAt)) return p.push({ id: P.id, valid: false, reason: "createdAt is not a valid numeric timestamp" }), false;
        } else P.properties.createdAt = +/* @__PURE__ */ new Date();
        if (P.properties.updatedAt) {
          if (!oy(P.properties.updatedAt)) return p.push({ id: P.id, valid: false, reason: "updatedAt is not a valid numeric timestamp" }), false;
        } else P.properties.updatedAt = +/* @__PURE__ */ new Date();
      }
      return this.has(M) ? (p.push({ id: M, valid: false, reason: `Feature already exists with this id: ${M}` }), false) : (this.store[M] = P, s.push(P), p.push({ id: M, valid: true }), true);
    }), this.spatialIndex.load(g);
    const C = s.map(({ id: P }) => P);
    return C.length > 0 && (this._onChange(C, "create", f), d && s.forEach((P) => {
      d(P);
    })), p;
  }
  search(i, l) {
    const d = this.spatialIndex.search(i).map((f) => this.store[f]);
    return this.clone(l ? d.filter(l) : d);
  }
  registerOnChange(i) {
    this._onChange = (l, d, f) => {
      i(l, d, f);
    };
  }
  getGeometryCopy(i) {
    const l = this.store[i];
    if (!l) throw new Error(`No feature with this id (${i}), can not get geometry copy`);
    return this.clone(l.geometry);
  }
  getPropertiesCopy(i) {
    const l = this.store[i];
    if (!l) throw new Error(`No feature with this id (${i}), can not get properties copy`);
    return this.clone(l.properties);
  }
  updateProperty(i, l) {
    const d = [];
    i.forEach(({ id: f, property: g, value: p }) => {
      const s = this.store[f];
      if (!s) throw new Error(`No feature with this (${f}), can not update geometry`);
      d.push(f), p === void 0 ? delete s.properties[g] : s.properties[g] = p, this.tracked && (s.properties.updatedAt = +/* @__PURE__ */ new Date());
    }), this._onChange && this._onChange(d, "update", l);
  }
  updateGeometry(i, l) {
    const d = [];
    i.forEach(({ id: f, geometry: g }) => {
      d.push(f);
      const p = this.store[f];
      if (!p) throw new Error(`No feature with this (${f}), can not update geometry`);
      p.geometry = this.clone(g), this.spatialIndex.update(p), this.tracked && (p.properties.updatedAt = +/* @__PURE__ */ new Date());
    }), this._onChange && this._onChange(d, "update", l);
  }
  create(i, l) {
    const d = [];
    return i.forEach(({ geometry: f, properties: g }) => {
      let p, s = kn({}, g);
      this.tracked && (p = +/* @__PURE__ */ new Date(), g ? (s.createdAt = typeof g.createdAt == "number" ? g.createdAt : p, s.updatedAt = typeof g.updatedAt == "number" ? g.updatedAt : p) : s = { createdAt: p, updatedAt: p });
      const C = this.getId(), P = { id: C, type: "Feature", geometry: f, properties: s };
      this.store[C] = P, this.spatialIndex.insert(P), d.push(C);
    }), this._onChange && this._onChange([...d], "create", l), d;
  }
  delete(i, l) {
    i.forEach((d) => {
      if (!this.store[d]) throw new Error(`No feature with id ${d}, can not delete`);
      delete this.store[d], this.spatialIndex.remove(d);
    }), this._onChange && this._onChange([...i], "delete", l);
  }
  copy(i) {
    return this.clone(this.store[i]);
  }
  copyAll() {
    return this.clone(Object.keys(this.store).map((i) => this.store[i]));
  }
  copyAllWhere(i) {
    return this.clone(Object.keys(this.store).map((l) => this.store[l]).filter((l) => l.properties && i(l.properties)));
  }
  clear() {
    this.store = {}, this.spatialIndex.clear();
  }
  size() {
    return Object.keys(this.store).length;
  }
}
class nc {
  constructor({ name: i, callback: l, unregister: d, register: f }) {
    this.name = void 0, this.callback = void 0, this.registered = false, this.register = void 0, this.unregister = void 0, this.name = i, this.register = () => {
      this.registered || (this.registered = true, f(l));
    }, this.unregister = () => {
      this.register && (this.registered = false, d(l));
    }, this.callback = l;
  }
}
var AI = { __proto__: null, TerraDrawBaseAdapter: class {
  constructor(r) {
    this._nextKeyUpIsContextMenu = false, this._lastPointerDownEventTarget = void 0, this._ignoreMismatchedPointerEvents = false, this._minPixelDragDistance = void 0, this._minPixelDragDistanceDrawing = void 0, this._minPixelDragDistanceSelecting = void 0, this._lastDrawEvent = void 0, this._coordinatePrecision = void 0, this._heldKeys = /* @__PURE__ */ new Set(), this._listeners = [], this._dragState = "not-dragging", this._currentModeCallbacks = void 0, this._ignoreMismatchedPointerEvents = typeof r.ignoreMismatchedPointerEvents == "boolean" && r.ignoreMismatchedPointerEvents, this._minPixelDragDistance = typeof r.minPixelDragDistance == "number" ? r.minPixelDragDistance : 1, this._minPixelDragDistanceSelecting = typeof r.minPixelDragDistanceSelecting == "number" ? r.minPixelDragDistanceSelecting : 1, this._minPixelDragDistanceDrawing = typeof r.minPixelDragDistanceDrawing == "number" ? r.minPixelDragDistanceDrawing : 8, this._coordinatePrecision = typeof r.coordinatePrecision == "number" ? r.coordinatePrecision : 9;
  }
  getButton(r) {
    return r.button === -1 ? "neither" : r.button === 0 ? "left" : r.button === 1 ? "middle" : r.button === 2 ? "right" : "neither";
  }
  getMapElementXYPosition(r) {
    const i = this.getMapEventElement(), { left: l, top: d } = i.getBoundingClientRect();
    return { containerX: r.clientX - l, containerY: r.clientY - d };
  }
  getDrawEventFromEvent(r, i = false) {
    const l = this.getLngLatFromEvent(r);
    if (!l) return null;
    const { lng: d, lat: f } = l, { containerX: g, containerY: p } = this.getMapElementXYPosition(r), s = this.getButton(r), C = Array.from(this._heldKeys);
    return { lng: Li(d, this._coordinatePrecision), lat: Li(f, this._coordinatePrecision), containerX: g, containerY: p, button: s, heldKeys: C, isContextMenu: i };
  }
  register(r) {
    this._currentModeCallbacks = r, this._listeners = this.getAdapterListeners(), this._listeners.forEach((i) => {
      i.register();
    });
  }
  getCoordinatePrecision() {
    return this._coordinatePrecision;
  }
  getAdapterListeners() {
    return [new nc({ name: "pointerdown", callback: (r) => {
      if (!this._currentModeCallbacks || !r.isPrimary) return;
      const i = this.getDrawEventFromEvent(r);
      i && (this._dragState = "pre-dragging", this._lastDrawEvent = i, this._lastPointerDownEventTarget = r.target ? r.target : void 0);
    }, register: (r) => {
      this.getMapEventElement().addEventListener("pointerdown", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("pointerdown", r);
    } }), new nc({ name: "pointermove", callback: (r) => {
      if (!this._currentModeCallbacks || !r.isPrimary) return;
      r.preventDefault();
      const i = this.getDrawEventFromEvent(r);
      if (i) if (this._dragState === "not-dragging") this._currentModeCallbacks.onMouseMove(i), this._lastDrawEvent = i;
      else if (this._dragState === "pre-dragging") {
        if (!this._lastDrawEvent) return;
        const l = { x: this._lastDrawEvent.containerX, y: this._lastDrawEvent.containerY }, d = { x: i.containerX, y: i.containerY }, f = this._currentModeCallbacks.getState(), g = xa(l, d);
        let p = false;
        if (p = f === "drawing" ? g < this._minPixelDragDistanceDrawing : f === "selecting" ? g < this._minPixelDragDistanceSelecting : g < this._minPixelDragDistance, p) return;
        this._nextKeyUpIsContextMenu = false, this._dragState = "dragging", this._currentModeCallbacks.onDragStart(i, (s) => {
          this.setDraggability.bind(this)(s);
        });
      } else this._dragState === "dragging" && this._currentModeCallbacks.onDrag(i, (l) => {
        this.setDraggability.bind(this)(l);
      });
    }, register: (r) => {
      this.getMapEventElement().addEventListener("pointermove", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("pointermove", r);
    } }), new nc({ name: "contextmenu", callback: (r) => {
      this._currentModeCallbacks && (r.preventDefault(), this._nextKeyUpIsContextMenu = true);
    }, register: (r) => {
      this.getMapEventElement().addEventListener("contextmenu", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("contextmenu", r);
    } }), new nc({ name: "pointerup", callback: (r) => {
      if (!this._currentModeCallbacks || r.target !== this.getMapEventElement() || this._ignoreMismatchedPointerEvents && this._lastPointerDownEventTarget !== r.target || (this._lastPointerDownEventTarget = void 0, !r.isPrimary)) return;
      const i = this.getDrawEventFromEvent(r);
      i && (this._dragState === "dragging" ? this._currentModeCallbacks.onDragEnd(i, (l) => {
        this.setDraggability.bind(this)(l);
      }) : this._dragState !== "not-dragging" && this._dragState !== "pre-dragging" || (this._nextKeyUpIsContextMenu && (i.isContextMenu = true, this._nextKeyUpIsContextMenu = false), this._currentModeCallbacks.onClick(i)), this._dragState = "not-dragging", this.setDraggability(true));
    }, register: (r) => {
      this.getMapEventElement().addEventListener("pointerup", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("pointerup", r);
    } }), new nc({ name: "keyup", callback: (r) => {
      this._currentModeCallbacks && (this._heldKeys.delete(r.key), this._currentModeCallbacks.onKeyUp({ key: r.key, heldKeys: Array.from(this._heldKeys), preventDefault: () => r.preventDefault() }));
    }, register: (r) => {
      this.getMapEventElement().addEventListener("keyup", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("keyup", r);
    } }), new nc({ name: "keydown", callback: (r) => {
      this._currentModeCallbacks && (this._heldKeys.add(r.key), this._currentModeCallbacks.onKeyDown({ key: r.key, heldKeys: Array.from(this._heldKeys), preventDefault: () => r.preventDefault() }));
    }, register: (r) => {
      this.getMapEventElement().addEventListener("keydown", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("keydown", r);
    } })];
  }
  unregister() {
    this._listeners.forEach((r) => {
      r.unregister();
    }), this.clear(), this._currentModeCallbacks = void 0, this._lastDrawEvent = void 0, this._lastPointerDownEventTarget = void 0, this._nextKeyUpIsContextMenu = false;
  }
} };
function Jg(r) {
  if (r === null || typeof r == "boolean" || typeof r == "string") return true;
  if (r === void 0) return false;
  if (typeof r == "number") return Number.isFinite(r);
  if (typeof r == "bigint" || typeof r == "symbol" || typeof r == "function" || r instanceof RegExp || r instanceof Map || r instanceof Set || r instanceof Date) return false;
  if (typeof r == "object" && r !== null && !Array.isArray(r)) {
    const i = Object.getPrototypeOf(r);
    if (i !== Object.prototype && i !== null) return false;
  }
  if (ArrayBuffer.isView(r) && !(r instanceof DataView)) return false;
  if (Array.isArray(r)) {
    for (const i of r) if (!Jg(i)) return false;
  }
  return typeof r == "object" && Object.keys(r).every((i) => typeof i == "string" && Jg(r[i]));
}
class DI {
  constructor(i) {
    this._modes = void 0, this._mode = void 0, this._adapter = void 0, this._enabled = false, this._store = void 0, this._eventListeners = void 0, this._instanceSelectMode = void 0, this._adapter = i.adapter, this._mode = new SI();
    const l = /* @__PURE__ */ new Set(), d = i.modes.reduce((M, D) => {
      if (l.has(D.mode)) throw new Error(`There is already a ${D.mode} mode provided`);
      return l.add(D.mode), M[D.mode] = D, M;
    }, {}), f = Object.keys(d);
    if (f.length === 0) throw new Error("No modes provided");
    f.forEach((M) => {
      if (d[M].type === fc.Select) {
        if (this._instanceSelectMode) throw new Error("only one type of select mode can be provided");
        this._instanceSelectMode = M;
      }
    }), this._modes = kn({}, d, { static: this._mode }), this._eventListeners = { change: [], select: [], deselect: [], finish: [], ready: [] }, this._store = new RI({ tracked: !!i.tracked, idStrategy: i.idStrategy ? i.idStrategy : void 0 });
    const g = (M) => {
      const D = [], L = this._store.copyAll().filter(($) => !M.includes($.id) || (D.push($), false));
      return { changed: D, unchanged: L };
    }, p = (M, D) => {
      this._enabled && this._eventListeners.finish.forEach((L) => {
        L(M, D);
      });
    }, s = (M, D, L) => {
      if (!this._enabled) return;
      this._eventListeners.change.forEach((F) => {
        F(M, D, L);
      });
      const { changed: $, unchanged: z } = g(M);
      D === "create" ? this._adapter.render({ created: $, deletedIds: [], unchanged: z, updated: [] }, this.getModeStyles()) : D === "update" ? this._adapter.render({ created: [], deletedIds: [], unchanged: z, updated: $ }, this.getModeStyles()) : D === "delete" ? this._adapter.render({ created: [], deletedIds: M, unchanged: z, updated: [] }, this.getModeStyles()) : D === "styling" && this._adapter.render({ created: [], deletedIds: [], unchanged: z, updated: [] }, this.getModeStyles());
    }, C = (M) => {
      if (!this._enabled) return;
      this._eventListeners.select.forEach(($) => {
        $(M);
      });
      const { changed: D, unchanged: L } = g([M]);
      this._adapter.render({ created: [], deletedIds: [], unchanged: L, updated: D }, this.getModeStyles());
    }, P = (M) => {
      if (!this._enabled) return;
      this._eventListeners.deselect.forEach(($) => {
        $();
      });
      const { changed: D, unchanged: L } = g([M]);
      D && this._adapter.render({ created: [], deletedIds: [], unchanged: L, updated: D }, this.getModeStyles());
    };
    Object.keys(this._modes).forEach((M) => {
      this._modes[M].register({ mode: M, store: this._store, setCursor: this._adapter.setCursor.bind(this._adapter), project: this._adapter.project.bind(this._adapter), unproject: this._adapter.unproject.bind(this._adapter), setDoubleClickToZoom: this._adapter.setDoubleClickToZoom.bind(this._adapter), onChange: s, onSelect: C, onDeselect: P, onFinish: p, coordinatePrecision: this._adapter.getCoordinatePrecision() });
    });
  }
  checkEnabled() {
    if (!this._enabled) throw new Error("Terra Draw is not enabled");
  }
  getModeStyles() {
    const i = {};
    return Object.keys(this._modes).forEach((l) => {
      i[l] = (d) => this._instanceSelectMode && d.properties[Ki.SELECTED] ? this._modes[this._instanceSelectMode].styleFeature.bind(this._modes[this._instanceSelectMode])(d) : this._modes[l].styleFeature.bind(this._modes[l])(d);
    }), i;
  }
  featuresAtLocation({ lng: i, lat: l }, d) {
    const f = d && d.pointerDistance !== void 0 ? d.pointerDistance : 30, g = !d || d.ignoreSelectFeatures === void 0 || d.ignoreSelectFeatures, p = !(!d || d.ignoreCoordinatePoints === void 0) && d.ignoreCoordinatePoints, s = !(!d || d.ignoreCurrentlyDrawing === void 0) && d.ignoreCurrentlyDrawing, C = !(!d || d.ignoreClosingPoints === void 0) && d.ignoreClosingPoints, P = !(!d || d.ignoreSnappingPoints === void 0) && d.ignoreSnappingPoints, M = this._adapter.unproject.bind(this._adapter), D = this._adapter.project.bind(this._adapter), L = D(i, l), $ = R1({ unproject: M, point: L, pointerDistance: f });
    return this._store.search($).filter((z) => {
      if (g && (z.properties[Ki.MID_POINT] || z.properties[Ki.SELECTION_POINT]) || p && z.properties[ki.COORDINATE_POINT] || C && z.properties[ki.CLOSING_POINT] || s && z.properties[ki.CURRENTLY_DRAWING] || P && z.properties[ki.SNAPPING_POINT]) return false;
      if (z.geometry.type === "Point") {
        const F = z.geometry.coordinates, Z = D(F[0], F[1]);
        return xa(L, Z) < f;
      }
      if (z.geometry.type === "LineString") {
        const F = z.geometry.coordinates;
        for (let Z = 0; Z < F.length - 1; Z++) {
          const q = F[Z], K = F[Z + 1];
          if (Yg(L, D(q[0], q[1]), D(K[0], K[1])) < f) return true;
        }
        return false;
      }
      if (L1([i, l], z.geometry.coordinates)) return true;
      if (d != null && d.includePolygonsWithinPointerDistance) {
        const F = z.geometry.coordinates;
        for (const Z of F) for (let q = 0; q < Z.length - 1; q++) {
          const K = Z[q], te = Z[q + 1], re = D(K[0], K[1]), ie = D(te[0], te[1]);
          if (Yg(L, re, ie) < f) return true;
        }
      }
      return false;
    }).map((z) => {
      if (d == null || !d.addClosestCoordinateInfoToProperties) return z;
      let F;
      if (z.geometry.type === "Polygon") F = z.geometry.coordinates[0].slice(0, -1);
      else {
        if (z.geometry.type !== "LineString") return z;
        F = z.geometry.coordinates;
      }
      let Z, q = -1, K = 1 / 0;
      for (let te = 0; te < F.length; te++) {
        const re = F[te], ie = xa(D(re[0], re[1]), L);
        ie < K && (q = te, K = ie, Z = re);
      }
      return z.properties.closestCoordinateIndexToEvent = q, z.properties.closestCoordinatePixelDistanceToEvent = K, z.properties.closestCoordinateDistanceKmToEvent = ss(Z, [i, l]), z;
    });
  }
  getSelectModeOrThrow() {
    const i = this.getSelectMode({ switchToSelectMode: true });
    if (!i) throw new Error("No select mode defined in instance");
    return i;
  }
  getSelectMode({ switchToSelectMode: i }) {
    if (this.checkEnabled(), !this._instanceSelectMode) return null;
    const l = this.getMode();
    return i && l !== this._instanceSelectMode && this.setMode(this._instanceSelectMode), this._modes[this._instanceSelectMode];
  }
  isGuidanceFeature(i) {
    return !!(i.properties[Ki.MID_POINT] || i.properties[Ki.SELECTION_POINT] || i.properties[ki.COORDINATE_POINT] || i.properties[ki.SNAPPING_POINT]);
  }
  setModeStyles(i, l) {
    if (this.checkEnabled(), !this._modes[i]) throw new Error("No mode with this name present");
    this._modes[i].styles = l;
  }
  updateModeOptions(i, l) {
    if (this.checkEnabled(), !this._modes[i]) throw new Error("No mode with this name present");
    this._modes[i].updateOptions(l);
  }
  getSnapshot() {
    return this._store.copyAll();
  }
  getSnapshotFeature(i) {
    if (this._store.has(i)) return this._store.copy(i);
  }
  clear() {
    this.checkEnabled(), this._adapter.clear();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(i) {
    throw new Error("Enabled is read only");
  }
  getMode() {
    return this._mode.mode;
  }
  getModeState() {
    return this._mode.state;
  }
  setMode(i) {
    if (this.checkEnabled(), !this._modes[i]) throw new Error("No mode with this name present");
    this._mode.stop(), this._mode = this._modes[i], this._mode.start();
  }
  removeFeatures(i) {
    this.checkEnabled();
    const l = [];
    i.forEach((d) => {
      if (!this._store.has(d)) throw new Error(`No feature with id ${d}, can not delete`);
      const f = this._store.copy(d);
      f.properties[Ki.SELECTED] && this.deselectFeature(d), f.properties[ki.COORDINATE_POINT_IDS] && l.push(...f.properties[ki.COORDINATE_POINT_IDS]);
    }), this._store.delete([...i, ...l], { origin: "api" });
  }
  selectFeature(i) {
    this.getSelectModeOrThrow().selectFeature(i);
  }
  deselectFeature(i) {
    this.getSelectModeOrThrow().deselectFeature(i);
  }
  getFeatureId() {
    return this._store.getId();
  }
  hasFeature(i) {
    return this._store.has(i);
  }
  checkIsReservedProperty(i) {
    return ![...Object.values(Ki), ...Object.values(ki)].includes(i);
  }
  updateFeatureProperties(i, l) {
    if (!this._store.has(i)) throw new Error(`No feature with id ${i} present in store`);
    const d = this._store.copy(i);
    if (this.isGuidanceFeature(d)) throw new Error("Guidance features are not allowed to be updated directly.");
    const f = d.properties.mode;
    if (!this._modes[f]) throw new Error(`No mode with name ${f} present in instance`);
    const g = Object.entries(l);
    g.forEach(([p, s]) => {
      if (!this.checkIsReservedProperty(p)) throw new Error(`You are trying to update a reserved property name: ${p}. Please choose another name.`);
      if (s !== void 0 && !Jg(s)) throw new Error(`Invalid JSON value provided for property ${p}`);
    }), this._store.updateProperty(g.map(([p, s]) => ({ id: d.id, property: p, value: s })), { origin: "api" });
  }
  updateFeatureGeometry(i, l) {
    if (!this._store.has(i)) throw new Error(`No feature with id ${i} present in store`);
    const d = this._store.copy(i);
    if (this.isGuidanceFeature(d)) throw new Error("Guidance features are not allowed to be updated directly.");
    if (!(d && l && l.type && l.coordinates)) throw new Error("Invalid geometry provided");
    if (l.type !== d.geometry.type) throw new Error(`Geometry type mismatch: expected ${d.geometry.type}, got ${l.type}`);
    const f = d.properties.mode, g = this._modes[f];
    if (!g) throw new Error(`No mode with name ${f} present in instance`);
    const p = kn({}, d, { geometry: l }), s = g.validateFeature(p);
    if (!s.valid) throw new Error(`Feature validation failed: ${s.reason || "Unknown reason"}`);
    if (this._store.updateGeometry([{ id: d.id, geometry: l }], { origin: "api" }), g.afterFeatureUpdated) {
      g.afterFeatureUpdated(p);
      const C = p.properties[Ki.SELECTED], P = this.getSelectMode({ switchToSelectMode: false });
      P && C && P.afterFeatureUpdated(p);
    }
  }
  transformFeatureGeometry(i, l) {
    if (!this._store.has(i)) throw new Error(`No feature with id ${i} present in store`);
    let d = this._store.copy(i);
    if (this.isGuidanceFeature(d)) throw new Error("Guidance features are not allowed to be updated directly.");
    const f = d.properties.mode, g = this._modes[f];
    if (!g) throw new Error(`No mode with name ${f} present in instance`);
    let p;
    if (d.geometry.type === "Polygon") p = d.geometry.coordinates[0];
    else {
      if (d.geometry.type !== "LineString") throw new Error(`Feature geometry type ${d.geometry.type} is not supported for transformation`);
      p = d.geometry.coordinates;
    }
    if (l.projection != "web-mercator") throw new Error(`Projection ${l.projection} is not currently supported for transformation`);
    if (l.type === "scale") {
      const { x: s, y: C } = Fi(l.origin[0], l.origin[1]);
      O1({ coordinates: p, originX: s, originY: C, xScale: l.options.xScale || 1, yScale: l.options.yScale || 1 });
    } else l.type === "rotate" && (d = B1(d, l.options.angle || 0), p = d.geometry.type === "Polygon" ? d.geometry.coordinates[0] : d.geometry.coordinates);
    if (p = p.map((s) => [Li(s[0], this._adapter.getCoordinatePrecision()), Li(s[1], this._adapter.getCoordinatePrecision())]), d.geometry.coordinates = d.geometry.type === "Polygon" ? [p] : p, this._store.updateGeometry([{ id: d.id, geometry: d.geometry }], { origin: "api" }), g.afterFeatureUpdated) {
      g.afterFeatureUpdated(d);
      const s = d.properties[Ki.SELECTED], C = this.getSelectMode({ switchToSelectMode: false });
      C && s && C.afterFeatureUpdated(d);
    }
  }
  addFeatures(i) {
    return this.checkEnabled(), i.length === 0 ? [] : this._store.load(i, (l) => {
      if (ny(l)) {
        const d = l.properties.mode, f = this._modes[d];
        if (!f) return { id: l.id, valid: false, reason: `${d} mode is not in the list of instantiated modes` };
        const g = f.validateFeature.bind(f)(l);
        return { id: l.id, valid: g.valid, reason: g.reason ? g.reason : g.valid ? void 0 : "Feature is invalid" };
      }
      return { id: l.id, valid: false, reason: "Mode property does not exist" };
    }, (l) => {
      if (ny(l)) {
        const d = this._modes[l.properties.mode];
        d && d.afterFeatureAdded && d.afterFeatureAdded(l);
      }
    }, { origin: "api" });
  }
  start() {
    this._enabled || (this._enabled = true, this._adapter.register({ onReady: () => {
      this._eventListeners.ready.forEach((i) => {
        i();
      });
    }, getState: () => this._mode.state, onClick: (i) => {
      this._mode.onClick(i);
    }, onMouseMove: (i) => {
      this._mode.onMouseMove(i);
    }, onKeyDown: (i) => {
      this._mode.onKeyDown(i);
    }, onKeyUp: (i) => {
      this._mode.onKeyUp(i);
    }, onDragStart: (i, l) => {
      this._mode.onDragStart(i, l);
    }, onDrag: (i, l) => {
      this._mode.onDrag(i, l);
    }, onDragEnd: (i, l) => {
      this._mode.onDragEnd(i, l);
    }, onClear: () => {
      this._mode.cleanUp(), this._store.clear();
    } }));
  }
  getFeaturesAtLngLat(i, l) {
    const { lng: d, lat: f } = i;
    return this.featuresAtLocation({ lng: d, lat: f }, l);
  }
  getFeaturesAtPointerEvent(i, l) {
    const d = this._adapter.getLngLatFromEvent.bind(this._adapter)(i);
    return d === null ? [] : this.featuresAtLocation(d, l);
  }
  stop() {
    this._enabled && (this._enabled = false, this._adapter.unregister());
  }
  on(i, l) {
    const d = this._eventListeners[i];
    d.includes(l) || d.push(l);
  }
  off(i, l) {
    const d = this._eventListeners[i];
    d.includes(l) && d.splice(d.indexOf(l), 1);
  }
}
const zI = ot({ __name: "MapContainer", props: { styleUrl: {}, geojsonSource: {}, drawerModes: {}, onMapInit: { type: Function }, onMapTouchStart: { type: Function }, onMapTouchEnd: { type: Function }, onMapClick: { type: Function } }, setup(r, { expose: i }) {
  const l = r, d = Ca(null), f = Ca(null), g = T3(), p = I1(), s = On();
  Ht([() => g.settings.mapLanguage, () => s.locale.value], ($) => {
    $ && d.value && C(d.value, $[0] === "interface" ? $[1] : $[0]);
  });
  const C = ($, z) => {
    const F = z === "zh-CN" ? "zh" : "en", Z = ["City labels", "Road labels", "Station labels", "Airport labels", "Continent labels", "Country labels"];
    for (const q of Z) $.setLayoutProperty(q, "text-field", ["get", `name:${F}`]);
  };
  function P($) {
    const z = $.getStyle().layers;
    let F;
    for (let Z = 0; Z < z.length; Z++) {
      const q = z[Z];
      if (q.type === "symbol" && q.layout && typeof q.layout == "object" && "text-field" in q.layout) {
        F = q.id;
        break;
      }
    }
    $.addLayer({ id: "3d-buildings", source: "openfreemap", "source-layer": "building", type: "fill-extrusion", minzoom: 15, filter: ["!=", ["get", "hide_3d"], true], paint: { "fill-extrusion-color": ["interpolate", ["linear"], ["get", "render_height"], 0, "lightgray", 200, "royalblue", 400, "lightblue"], "fill-extrusion-height": ["interpolate", ["linear"], ["zoom"], 15, 0, 16, ["get", "render_height"]], "fill-extrusion-base": ["case", [">=", ["get", "zoom"], 16], ["get", "render_min_height"], 0] } }, F);
  }
  function M($) {
    $.removeLayer("3d-buildings");
  }
  function D($) {
    var _a3, _b2;
    d.value = $.map, (_a3 = d.value) == null ? void 0 : _a3.addSource("openfreemap", { url: "https://tiles.openfreemap.org/planet", type: "vector" }), d.value && C(d.value, s.locale.value), p.isTrackingOrientation && (L(), L()), (_b2 = d.value) == null ? void 0 : _b2.on("click", l.onMapClick), l.onMapInit($);
  }
  const L = /* @__PURE__ */ (() => {
    let $ = null;
    return () => {
      var _a3;
      p.setTrackingOrientation(!p.isTrackingOrientation), p.isTrackingOrientation ? $ = Os.addHandler((z) => {
        var _a4, _b2, _c2, _d;
        if (p.isTrackingOrientation) {
          if (((_a4 = d.value) == null ? void 0 : _a4.isEasing()) || ((_b2 = d.value) == null ? void 0 : _b2.isMoving()) || ((_c2 = d.value) == null ? void 0 : _c2.isRotating()) || ((_d = d.value) == null ? void 0 : _d.isZooming())) return;
          p.setBearing(z);
        }
      }) : $ !== null && ($ = null, p.setBearing(0), (_a3 = d.value) == null ? void 0 : _a3.setBearing(0));
    };
  })();
  return i({ setupBuildingLayer: P, removeBuildingLayer: M, toggleOrientationTracking: L, map: d, draw: f }), ($, z) => (ct(), gr(H(x1), { bearing: H(p).bearing, "onUpdate:bearing": z[0] || (z[0] = (F) => H(p).bearing = F), zoom: H(p).zoom, "onUpdate:zoom": z[1] || (z[1] = (F) => H(p).zoom = F), center: H(p).center, "onUpdate:center": z[2] || (z[2] = (F) => H(p).center = F), "map-style": r.styleUrl, height: "100%", "onMap:load": D, "onMap:touchstart": r.onMapTouchStart, "onMap:touchend": r.onMapTouchEnd }, { default: $e(() => [De(H(Q6), { "source-id": "geojson", data: r.geojsonSource, "line-metrics": true }, { default: $e(() => [De(H(i4), { "layer-id": "geojson", layout: { "line-join": "round", "line-cap": "round" }, paint: { "line-width": 5, "line-gradient": ["interpolate", ["linear"], ["line-progress"], 0, "#00ff00", 0.7, "#00DD00", 0.9, "#00BB00", 1, "#008800"], "line-opacity": 0.8 } })]), _: 1 }, 8, ["data"]), yp($.$slots, "default")]), _: 3 }, 8, ["bearing", "zoom", "center", "map-style", "onMap:touchstart", "onMap:touchend"]));
} }), FI = ot({ __name: "MapControls", setup(r) {
  return (i, l) => (ct(), $t("div", null, [De(H(C1), { position: "top-left" }), De(H(w1), { position: "top-left" }), De(H(k1), { position: "bottom-left" })]));
} }), LI = Ni(FI, [["__scopeId", "data-v-ad570dc0"]]), BI = ["title", "onClick"], OI = ot({ __name: "DrawingTools", props: { activeDrawMethod: {} }, emits: ["update:activeDrawMethod", "setDrawMode"], setup(r, { emit: i }) {
  const { t: l } = On(), f = new bc().isMobile, g = false, p = [{ mode: new z1(), name: l("trackerView.terraDrawTools.point"), icon: u0 }, { mode: new D1(), name: l("trackerView.terraDrawTools.line"), icon: Pb }, { mode: new $1({ allowManualDeselection: true, flags: { point: { feature: { draggable: true } }, polygon: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, linestring: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, freehand: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, circle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, rectangle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } } } }), name: l("trackerView.terraDrawTools.select"), icon: kb }], s = r, C = i, P = (M) => {
    s.activeDrawMethod === M.mode ? (C("setDrawMode", "select"), C("update:activeDrawMethod", "select")) : (C("update:activeDrawMethod", M.mode), C("setDrawMode", M.mode));
  };
  return (M, D) => !H(f) || g ? (ct(), gr(H(Fp), { key: 0, position: "top-right" }, { default: $e(() => [(ct(), $t(Wr, null, on(p, (L) => yt("button", { key: L.name, class: Qo(["btn-control", { active: L.mode.mode === r.activeDrawMethod }]), title: L.name, onClick: ($) => P(L.mode) }, [De(H(bi), { size: 20 }, { default: $e(() => [(ct(), gr(_c(L.icon), { class: "btn-default" }))]), _: 2 }, 1024)], 10, BI)), 64))]), _: 1 })) : Pr("", true);
} }), $I = Ni(OI, [["__scopeId", "data-v-0c23bdfa"]]), jI = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'%20?%3e%3c!DOCTYPE%20svg%20PUBLIC%20'-//W3C//DTD%20SVG%201.1//EN'%20'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg%20width='337pt'%20height='570pt'%20viewBox='0%200%20337%20570'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='%23010101ff'%3e%3c/g%3e%3cg%20id='%23fefefeff'%3e%3cpath%20fill='%23fefefe'%20opacity='1.00'%20d='%20M%20166.30%2034.31%20C%20170.55%2032.66%20175.49%2034.16%20177.91%2038.06%20C%20207.78%2088.56%20237.82%20138.97%20267.41%20189.64%20C%20272.78%20198.93%20278.71%20207.92%20283.33%20217.62%20C%20287.47%20225.84%20291.89%20234.58%20291.29%20244.05%20C%20290.88%20251.07%20284.88%20258.19%20277.33%20256.73%20C%20262.96%20252.68%20250.07%20244.73%20235.92%20240.03%20C%20214.99%20231.74%20192.42%20228.24%20170.00%20227.63%20C%20148.91%20228.22%20127.73%20231.43%20107.84%20238.63%20C%2092.90%20243.30%2079.32%20251.36%2064.47%20256.24%20C%2059.30%20258.15%2052.76%20255.48%2050.66%20250.31%20C%2046.78%20243.23%2049.19%20234.81%2051.89%20227.76%20C%2056.51%20217.17%2062.04%20206.98%2068.16%20197.18%20C%2098.26%20145.68%20128.69%2094.38%20159.14%2043.09%20C%20160.98%2039.80%20162.80%2036.10%20166.30%2034.31%20M%20165.46%2076.51%20C%20161.14%2084.39%20156.35%2091.99%20151.68%2099.66%20C%20146.23%20109.46%20140.40%20119.03%20134.68%20128.66%20C%20119.48%20155.09%20104.18%20181.47%2088.70%20207.74%20C%2086.55%20211.59%2083.58%20214.95%2081.76%20218.99%20C%2081.46%20221.46%2084.20%20221.79%2085.93%20221.02%20C%2093.56%20218.30%20100.92%20214.75%20108.82%20212.83%20C%20115.18%20211.22%20121.55%20209.66%20127.87%20207.89%20C%20150.73%20202.18%20174.79%20200.91%20198.04%20204.96%20C%20208.80%20206.29%20219.05%20209.99%20229.58%20212.41%20C%20237.78%20214.21%20245.35%20217.94%20253.21%20220.76%20C%20254.77%20221.45%20256.47%20221.24%20258.11%20221.06%20C%20258.49%20217.46%20255.67%20214.84%20254.00%20211.98%20C%20250.02%20205.59%20246.07%20199.18%20242.44%20192.58%20C%20220.66%20155.66%20199.60%20118.31%20177.40%2081.64%20C%20175.00%2077.57%20172.96%2073.26%20170.00%2069.54%20C%20168.29%2071.72%20166.77%2074.06%20165.46%2076.51%20Z'%20/%3e%3cpath%20fill='%23fefefe'%20opacity='1.00'%20d='%20M%20151.49%20254.95%20C%20168.99%20253.67%20186.81%20253.49%20204.06%20257.20%20C%20231.32%20262.97%20256.80%20276.81%20276.54%20296.49%20C%20293.71%20313.66%20306.14%20335.33%20313.41%20358.45%20C%20317.29%20371.60%20319.91%20385.24%20319.78%20398.99%20C%20321.35%20441.96%20301.66%20484.35%20269.99%20512.99%20C%20242.00%20538.39%20203.57%20551.09%20166.00%20549.73%20C%20133.58%20548.88%20101.34%20537.42%2076.23%20516.74%20C%2050.26%20494.62%2031.18%20463.95%2024.80%20430.27%20C%2021.58%20416.77%2021.93%20402.83%2022.47%20389.07%20C%2025.30%20359.23%2037.09%20330.28%2055.98%20306.99%20C%2079.44%20278.07%20114.56%20259.24%20151.49%20254.95%20M%20154.41%20286.41%20C%20133.59%20288.80%20113.47%20297.07%2096.91%20309.90%20C%2081.77%20321.39%2070.09%20337.09%2062.38%20354.40%20C%2053.40%20373.52%2050.49%20395.10%2052.40%20416.04%20C%2055.41%20439.33%2065.12%20461.74%2080.46%20479.57%20C%2096.06%20498.43%20118.19%20511.54%20141.99%20516.98%20C%20179.65%20526.00%20222.00%20516.17%20250.33%20489.33%20C%20272.99%20467.84%20287.59%20437.39%20288.11%20405.99%20C%20289.17%20369.33%20272.14%20332.49%20243.21%20309.87%20C%20231.81%20301.36%20219.11%20294.50%20205.43%20290.50%20C%20188.99%20285.41%20171.44%20284.58%20154.41%20286.41%20Z'%20/%3e%3c/g%3e%3cg%20id='%234da0e9ff'%3e%3cpath%20fill='%234da0e9'%20opacity='1.00'%20d='%20M%20165.46%2076.51%20C%20166.77%2074.06%20168.29%2071.72%20170.00%2069.54%20C%20172.96%2073.26%20175.00%2077.57%20177.40%2081.64%20C%20199.60%20118.31%20220.66%20155.66%20242.44%20192.58%20C%20246.07%20199.18%20250.02%20205.59%20254.00%20211.98%20C%20255.67%20214.84%20258.49%20217.46%20258.11%20221.06%20C%20256.47%20221.24%20254.77%20221.45%20253.21%20220.76%20C%20245.35%20217.94%20237.78%20214.21%20229.58%20212.41%20C%20219.05%20209.99%20208.80%20206.29%20198.04%20204.96%20C%20174.79%20200.91%20150.73%20202.18%20127.87%20207.89%20C%20121.55%20209.66%20115.18%20211.22%20108.82%20212.83%20C%20100.92%20214.75%2093.56%20218.30%2085.93%20221.02%20C%2084.20%20221.79%2081.46%20221.46%2081.76%20218.99%20C%2083.58%20214.95%2086.55%20211.59%2088.70%20207.74%20C%20104.18%20181.47%20119.48%20155.09%20134.68%20128.66%20C%20140.40%20119.03%20146.23%20109.46%20151.68%2099.66%20C%20156.35%2091.99%20161.14%2084.39%20165.46%2076.51%20Z'%20/%3e%3cpath%20fill='%234da0e9'%20opacity='1.00'%20d='%20M%20154.41%20286.41%20C%20171.44%20284.58%20188.99%20285.41%20205.43%20290.50%20C%20219.11%20294.50%20231.81%20301.36%20243.21%20309.87%20C%20272.14%20332.49%20289.17%20369.33%20288.11%20405.99%20C%20287.59%20437.39%20272.99%20467.84%20250.33%20489.33%20C%20222.00%20516.17%20179.65%20526.00%20141.99%20516.98%20C%20118.19%20511.54%2096.06%20498.43%2080.46%20479.57%20C%2065.12%20461.74%2055.41%20439.33%2052.40%20416.04%20C%2050.49%20395.10%2053.40%20373.52%2062.38%20354.40%20C%2070.09%20337.09%2081.77%20321.39%2096.91%20309.90%20C%20113.47%20297.07%20133.59%20288.80%20154.41%20286.41%20Z'%20/%3e%3c/g%3e%3c/svg%3e", NI = { style: { filter: "drop-shadow(0px 2px 4px #888)" } }, VI = ["src"], UI = ot({ __name: "LocationMarker", props: { isWatchingCurrentLocation: { type: Boolean }, deviceBearing: {} }, setup(r) {
  const i = ur("geolocation");
  return (l, d) => H(i) && H(i).isServiceRunning() && r.isWatchingCurrentLocation ? (ct(), gr(H(Y6), { key: 0, coordinates: H(i).getLastKnownLocation().toLngLatLike() }, { marker: $e(() => [yt("div", NI, [yt("img", { src: H(jI), style: Sn({ height: "4em", width: "4em", transform: `rotate(${r.deviceBearing}deg)`, "transform-origin": "2em 2.83em" }) }, null, 12, VI)])]), _: 1 }, 8, ["coordinates"])) : Pr("", true);
} }), GI = { style: { "font-family": "monospace", "padding-left": "8px" } }, qI = ot({ __name: "RecordingButton", props: { isRecording: { type: Boolean }, recordTimespan: {}, isRouteDrawerOpen: { type: Boolean } }, emits: ["toggleRecording"], setup(r, { emit: i }) {
  Ns((C) => {
    var _a3, _b2;
    return { v2835388b: (_a3 = H(Gd).Button.common) == null ? void 0 : _a3.primaryColorSuppl, v6cac94de: (_b2 = H(Gd).Button.common) == null ? void 0 : _b2.errorColorSuppl };
  });
  const { t: l } = On(), f = new bc().isMobile, g = false, p = i;
  function s(C) {
    const P = C / 1e3, M = P / 60, D = M / 60, L = P % 60, $ = M % 60, z = D;
    let F = "";
    return Math.floor(z) > 0 && (F += `${String(Math.floor(z))}h `), Math.floor($) > 0 && (F += `${String(Math.floor($))}m `), F += `${String(L.toFixed(1)).padStart(4, "0")}s`, F;
  }
  return (C, P) => H(f) || g ? (ct(), $t("div", { key: 0, class: Qo(["mobile-record-button-container", { "drawer-open": r.isRouteDrawerOpen }]) }, [De(H(ub), { theme: H(Gd) }, { default: $e(() => [De(H($r), { type: r.isRecording ? "error" : "primary", size: "large", class: Qo(["mobile-record-button", r.isRecording ? "recording" : "not-recording"]), onClick: P[0] || (P[0] = (M) => p("toggleRecording")) }, { icon: $e(() => [De(H(bi), { size: 20 }, { default: $e(() => [(ct(), gr(_c(r.isRecording ? H(hS) : H(sS)), { size: r.isRecording ? 16 : 20 }, null, 8, ["size"]))]), _: 1 })]), default: $e(() => [yr(" " + Kt(r.isRecording ? H(l)("trackerView.uiRecordingStatus.on") : H(l)("trackerView.uiRecordingStatus.off")) + " ", 1), yt("p", GI, Kt(r.recordTimespan ? `(${s(r.recordTimespan)})` : ""), 1)]), _: 1 }, 8, ["type", "class"])]), _: 1 }, 8, ["theme"])], 2)) : Pr("", true);
} }), WI = Ni(qI, [["__scopeId", "data-v-bcc27af9"]]), ZI = ot({ __name: "BuildingLayerToggle", props: { isShowingBuildingLayer: { type: Boolean } }, emits: ["toggle"], setup(r, { emit: i }) {
  const l = i, d = () => {
    l("toggle");
  };
  return (f, g) => (ct(), gr(H(Fp), { position: "top-left" }, { default: $e(() => [yt("button", { class: Qo(["btn-control", { active: r.isShowingBuildingLayer }]), onClick: d }, [De(H(bi), { size: 20 }, { default: $e(() => [De(H(UC))]), _: 1 })], 2)]), _: 1 }));
} }), HI = Ni(ZI, [["__scopeId", "data-v-c189f5ba"]]), XI = ot({ __name: "CurrentLocationToggle", props: { locator: {}, isWatchingCurrentLocation: { type: Boolean } }, emits: ["toggle"], setup(r, { emit: i }) {
  const d = new bc().isMobile, f = false, g = i, p = () => {
    g("toggle");
  };
  return (s, C) => (ct(), gr(H(Fp), { position: "top-left" }, { default: $e(() => [H(d) && r.locator.isUsingGPS() || f ? (ct(), $t("button", { key: 0, class: Qo(["btn-control", { active: r.isWatchingCurrentLocation }]), onClick: p }, [De(H(bi), { size: 20 }, { default: $e(() => [De(H(ZC))]), _: 1 })], 2)) : Pr("", true)]), _: 1 }));
} }), YI = Ni(XI, [["__scopeId", "data-v-afaa8b50"]]);
class KI extends AI.TerraDrawBaseAdapter {
  constructor(i) {
    super(i), this._renderBeforeLayerId = void 0, this._prefixId = void 0, this._initialDragPan = void 0, this._initialDragRotate = void 0, this._nextRender = void 0, this._map = void 0, this._container = void 0, this.changedIds = { deletion: false, points: false, linestrings: false, polygons: false, styling: false }, this._map = i.map, this._container = this._map.getContainer(), this._initialDragRotate = this._map.dragRotate.isEnabled(), this._initialDragPan = this._map.dragPan.isEnabled(), this._renderBeforeLayerId = i.renderBelowLayerId, this._prefixId = i.prefixId || "td";
  }
  hashCode(i) {
    let l = 0;
    for (let d = 0; d < i.length; d++) l = (l << 5) - l + i.charCodeAt(d), l |= 0;
    return Math.abs(l);
  }
  resizeImage(i, l, d, f) {
    const g = new Image();
    g.crossOrigin = "anonymous", g.onload = () => {
      const p = document.createElement("canvas");
      p.width = l, p.height = d;
      const s = p.getContext("2d");
      if (!s) throw new Error("Could not get canvas context");
      s.drawImage(g, 0, 0, l, d);
      const C = p.toDataURL();
      f(C);
    }, g.src = i;
  }
  _addGeoJSONSource(i, l) {
    this._map.addSource(i, { type: "geojson", data: { type: "FeatureCollection", features: l }, tolerance: 0 });
  }
  _addFillLayer(i) {
    return this._map.addLayer({ id: i, source: i, type: "fill", layout: { "fill-sort-key": ["get", "zIndex"] }, paint: { "fill-color": ["get", "polygonFillColor"], "fill-opacity": ["get", "polygonFillOpacity"] } });
  }
  _addFillOutlineLayer(i) {
    return this._map.addLayer({ id: i + "-outline", source: i, type: "line", layout: { "line-sort-key": ["get", "zIndex"] }, paint: { "line-width": ["get", "polygonOutlineWidth"], "line-color": ["get", "polygonOutlineColor"] } });
  }
  _addLineLayer(i) {
    return this._map.addLayer({ id: i, source: i, type: "line", layout: { "line-sort-key": ["get", "zIndex"] }, paint: { "line-width": ["get", "lineStringWidth"], "line-color": ["get", "lineStringColor"] } });
  }
  _addPointLayer(i) {
    return this._map.addLayer({ id: i, source: i, type: "circle", layout: { "circle-sort-key": ["get", "zIndex"] }, paint: { "circle-stroke-color": ["get", "pointOutlineColor"], "circle-stroke-width": ["get", "pointOutlineWidth"], "circle-radius": ["get", "pointWidth"], "circle-color": ["get", "pointColor"] } });
  }
  _addMarkerLayer(i) {
    return this._map.addLayer({ id: i + "-marker", source: i, type: "symbol", filter: ["has", "markerId"], layout: { "icon-image": ["image", ["get", "markerId"]], "icon-anchor": "bottom", "icon-allow-overlap": true } });
  }
  _addLayer(i, l) {
    l === "Point" && (this._addPointLayer(i), this._addMarkerLayer(i)), l === "LineString" && this._addLineLayer(i), l === "Polygon" && (this._addFillLayer(i), this._addFillOutlineLayer(i));
  }
  _addGeoJSONLayer(i, l) {
    const d = `${this._prefixId}-${i.toLowerCase()}`;
    return this._addGeoJSONSource(d, l), this._addLayer(d, i), d;
  }
  _setGeoJSONLayerData(i, l) {
    const d = `${this._prefixId}-${i.toLowerCase()}`;
    return this._map.getSource(d).setData({ type: "FeatureCollection", features: l }), d;
  }
  updateChangedIds(i) {
    [...i.updated, ...i.created].forEach((l) => {
      l.geometry.type === "Point" ? this.changedIds.points = true : l.geometry.type === "LineString" ? this.changedIds.linestrings = true : l.geometry.type === "Polygon" && (this.changedIds.polygons = true);
    }), i.deletedIds.length > 0 && (this.changedIds.deletion = true), i.created.length === 0 && i.updated.length === 0 && i.deletedIds.length === 0 && (this.changedIds.styling = true);
  }
  getLngLatFromEvent(i) {
    const { left: l, top: d } = this._container.getBoundingClientRect();
    return this.unproject(i.clientX - l, i.clientY - d);
  }
  getMapEventElement() {
    return this._map.getCanvas();
  }
  setDraggability(i) {
    i ? (this._initialDragRotate && this._map.dragRotate.enable(), this._initialDragPan && this._map.dragPan.enable()) : (this._initialDragRotate && this._map.dragRotate.disable(), this._initialDragPan && this._map.dragPan.disable());
  }
  project(i, l) {
    const { x: d, y: f } = this._map.project({ lng: i, lat: l });
    return { x: d, y: f };
  }
  unproject(i, l) {
    const { lng: d, lat: f } = this._map.unproject({ x: i, y: l });
    return { lng: d, lat: f };
  }
  setCursor(i) {
    const l = this._map.getCanvas();
    i === "unset" ? l.style.removeProperty("cursor") : l.style.cursor = i;
  }
  setDoubleClickToZoom(i) {
    i ? this._map.doubleClickZoom.enable() : this._map.doubleClickZoom.disable();
  }
  render(i, l) {
    this.updateChangedIds(i), this._nextRender && cancelAnimationFrame(this._nextRender), this._nextRender = requestAnimationFrame(() => {
      if (!this._currentModeCallbacks) return;
      const d = [...i.created, ...i.updated, ...i.unchanged], f = [], g = [], p = [];
      for (let M = 0; M < d.length; M++) {
        const D = d[M], { properties: L } = D, $ = l[L.mode](D);
        if (L.zIndex = $.zIndex, L.zIndex = $.zIndex, D.geometry.type === "Point") {
          if (L.pointColor = $.pointColor, L.pointOutlineColor = $.pointOutlineColor, L.pointOutlineWidth = $.pointOutlineWidth, L.pointWidth = $.pointWidth, $.markerUrl && $.markerWidth && $.markerHeight) {
            const z = `marker-${this.hashCode($.markerUrl)}`;
            this._map.hasImage(z) || this.resizeImage($.markerUrl, $.markerWidth, $.markerHeight, (F) => {
              this._map.loadImage(F).then((Z) => {
                this._map.hasImage(z) || this._map.addImage(z, Z.data);
              });
            }), L.markerId = z, L.pointWidth = 0;
          }
          f.push(D);
        } else D.geometry.type === "LineString" ? (L.lineStringColor = $.lineStringColor, L.lineStringWidth = $.lineStringWidth, g.push(D)) : D.geometry.type === "Polygon" && (L.polygonFillColor = $.polygonFillColor, L.polygonFillOpacity = $.polygonFillOpacity, L.polygonOutlineColor = $.polygonOutlineColor, L.polygonOutlineWidth = $.polygonOutlineWidth, p.push(D));
      }
      const s = this.changedIds.deletion || this.changedIds.styling, C = s || this.changedIds.linestrings, P = s || this.changedIds.polygons;
      (s || this.changedIds.points) && this._setGeoJSONLayerData("Point", f), C && this._setGeoJSONLayerData("LineString", g), P && this._setGeoJSONLayerData("Polygon", p), this.changedIds = { points: false, linestrings: false, polygons: false, deletion: false, styling: false };
    });
  }
  clear() {
    this._currentModeCallbacks && (this._currentModeCallbacks.onClear(), this._nextRender && (cancelAnimationFrame(this._nextRender), this._nextRender = void 0), this._setGeoJSONLayerData("Point", []), this._setGeoJSONLayerData("LineString", []), this._setGeoJSONLayerData("Polygon", []));
  }
  getCoordinatePrecision() {
    return super.getCoordinatePrecision();
  }
  unregister() {
    super.unregister(), this.changedIds = { points: false, linestrings: false, polygons: false, deletion: false, styling: false }, this._map.removeLayer(`${this._prefixId}-point`), this._map.removeLayer(`${this._prefixId}-point-marker`), this._map.removeSource(`${this._prefixId}-point`), this._map.removeLayer(`${this._prefixId}-linestring`), this._map.removeSource(`${this._prefixId}-linestring`), this._map.removeLayer(`${this._prefixId}-polygon`), this._map.removeLayer(`${this._prefixId}-polygon-outline`), this._map.removeSource(`${this._prefixId}-polygon`);
  }
  register(i) {
    var l;
    super.register(i);
    const d = this._addGeoJSONLayer("Polygon", []), f = this._addGeoJSONLayer("LineString", []), g = this._addGeoJSONLayer("Point", []);
    var p;
    this._renderBeforeLayerId && (this._map.moveLayer(g, this._renderBeforeLayerId), this._map.moveLayer(f, g), this._map.moveLayer(d + "-outline", f), this._map.moveLayer(d, f)), (l = this._currentModeCallbacks) != null && l.onReady && ((p = this._currentModeCallbacks) == null || p.onReady());
  }
}
const JI = { class: "map-layout-container" }, QI = { class: "map-layout" }, eM = { key: 0, style: { width: "100%", height: "100%" } }, tM = { style: { "z-index": "99", position: "absolute", right: "4px", top: "9em" } }, rM = { key: 1, style: { width: "100%", height: "100%", display: "grid", "place-content": "center" } }, iM = ot({ __name: "TrackerView", setup(r) {
  Ns((gt) => {
    var _a3;
    return { v57fa7490: (_a3 = H(Gd).Button.common) == null ? void 0 : _a3.successColorSuppl, v11a75c8c: H(d).boxShadow3, df9186bc: H(d).borderRadius, v0c1c1d53: H(d).borderColor };
  });
  const l = new bc().isMobile, d = $s(), f = I1(), g = Ap(), p = ur("geolocation"), { t: s } = On(), P = "https://api.maptiler.com/maps/basic-v2/style.json?key=dCeXFrS9lgSF8hm5C6nm", M = Ca(null), D = Ca(null), L = Ie("select"), $ = T1();
  $.setLocator(p);
  const z = ur("noSleep"), F = Ee(() => {
    var _a3;
    return $.currentRouteId ? ((_a3 = $.routes.find((Bt) => Bt.id === $.currentRouteId)) == null ? void 0 : _a3.points) || [] : [];
  }), Z = Ie(false), q = Ee(() => F.value.length > 1 || F.value.length === 0 ? { type: "FeatureCollection", features: [{ type: "Feature", properties: { description: $.currentRouteId }, geometry: { type: "LineString", coordinates: F.value.map((gt) => [gt.longitude, gt.latitude]) } }] } : { type: "FeatureCollection", features: [] }), K = [{ mode: new z1(), name: s("trackerView.terraDrawTools.point"), icon: u0 }, { mode: new D1(), name: s("trackerView.terraDrawTools.line"), icon: Pb }, { mode: new $1({ allowManualDeselection: true, flags: { point: { feature: { draggable: true } }, polygon: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, linestring: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, freehand: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, circle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, rectangle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } } } }), name: s("trackerView.terraDrawTools.select"), icon: kb }], te = Ie(false), re = Ie(true), ie = /* @__PURE__ */ (() => {
    let gt = true;
    return async function() {
      try {
        $.isRecording || (gt = $.currentRouteId === null), await $.toggleRecording(s), !$.isRecording && gt && (_e.value = true, setTimeout(() => {
          _e.value = false;
        }, 3e3)), $.isRecording ? z.enable() : z.disable();
      } catch (Bt) {
        console.error(Bt), z.disable();
      }
    };
  })(), J = Ie(async () => {
  });
  function we() {
    oe.value = false, g.warning("Not implemented yet");
  }
  const fe = Ie(0), oe = Ie(false);
  Ht(oe, (gt) => {
    var _a3;
    const Bt = (_a3 = M.value) == null ? void 0 : _a3.map;
    Bt && Bt.easeTo({ padding: l ? { bottom: gt ? fe.value : 0 } : { left: gt ? fe.value : 0 }, duration: 500 });
  });
  const he = () => oe.value = !oe.value, _e = Ie(false), Ue = Ie(false), qe = Ie(0), tt = Ie(false);
  Ri(async () => {
    await $.init(), await f.init(), Date.now() - f.lastUpdateTime > 6e3 && f.lastUpdateTime !== 0 && f.setCenter(p.getLastKnownLocation()), Os.addHandler((gt) => {
      qe.value = gt;
    }), Os.start(), Ue.value = true;
  });
  const ut = false;
  let mt = 0;
  const St = (gt) => {
    var _a3;
    if (mt = gt, f.isTrackingOrientation) {
      const Bt = (_a3 = M.value) == null ? void 0 : _a3.map;
      if ((Bt == null ? void 0 : Bt.isEasing()) || (Bt == null ? void 0 : Bt.isMoving()) || (Bt == null ? void 0 : Bt.isRotating()) || (Bt == null ? void 0 : Bt.isZooming()) || tt.value) return;
      f.setBearing(gt);
    }
  }, st = /* @__PURE__ */ (() => {
    let gt = null;
    return () => {
      var _a3;
      if (f.setTrackingOrientation(!f.isTrackingOrientation), f.isTrackingOrientation) gt = Os.addHandler(St);
      else if (gt !== null) {
        gt = null, f.setBearing(0);
        const Bt = (_a3 = M.value) == null ? void 0 : _a3.map;
        Bt && Bt.setBearing(0);
      }
    };
  })(), nt = (gt) => {
    D.value = new DI({ adapter: new KI({ map: gt.map }), modes: K.map((Bt) => Bt.mode) }), D.value.start();
  }, ft = () => {
    tt.value = true;
  }, Lt = () => {
    tt.value = false, f.isTrackingOrientation && St(mt);
  }, pt = () => {
    oe.value = false;
  }, wt = (gt) => {
    D.value && (gt === "select" ? (D.value.setMode("select"), L.value = "select") : (L.value = gt, D.value.start(), D.value.setMode(gt)));
  }, Ft = () => {
    var _a3;
    if (re.value = !re.value, re.value) {
      const gt = (_a3 = M.value) == null ? void 0 : _a3.map;
      gt && gt.flyTo({ center: p.getLastKnownLocation().toLngLatLike(), zoom: 18 });
    }
  }, tr = () => {
    var _a3, _b2, _c2;
    te.value = !te.value;
    const gt = (_a3 = M.value) == null ? void 0 : _a3.map;
    gt && (te.value ? (_b2 = M.value) == null ? void 0 : _b2.setupBuildingLayer(gt) : (_c2 = M.value) == null ? void 0 : _c2.removeBuildingLayer(gt));
  };
  return (gt, Bt) => (ct(), $t("div", JI, [yt("div", QI, [De(Eo, { name: "map-load" }, { default: $e(() => [Ue.value ? (ct(), $t("div", eM, [De(zI, { ref_key: "mapContainerRef", ref: M, "style-url": P, "geojson-source": q.value, "drawer-modes": K, "on-map-init": nt, "on-map-touch-start": ft, "on-map-touch-end": Lt, "on-map-click": pt }, { default: $e(() => [De(LI), De(YI, { locator: H(p), "is-watching-current-location": re.value, onToggle: Ft }, null, 8, ["locator", "is-watching-current-location"]), De(HI, { "is-showing-building-layer": te.value, onToggle: tr }, null, 8, ["is-showing-building-layer"]), De($I, { "active-draw-method": L.value, "onUpdate:activeDrawMethod": Bt[0] || (Bt[0] = (Zt) => L.value = Zt), onSetDrawMode: wt }, null, 8, ["active-draw-method"]), De(H(Fp), { position: "bottom-left" }, { default: $e(() => [De(H(n0), { trigger: "manual", show: _e.value }, { trigger: $e(() => [yt("button", { class: Qo(["btn-control", { active: oe.value }]), onClick: he }, [De(H(bi), { size: 24 }, { default: $e(() => [De(H(c0))]), _: 1 })], 2)]), default: $e(() => [yt("span", null, Kt(H(s)("trackerView.uiRouteCheckoutTip")), 1)]), _: 1 }, 8, ["show"])]), _: 1 }), De(UI, { "is-watching-current-location": re.value, "device-bearing": qe.value }, null, 8, ["is-watching-current-location", "device-bearing"])]), _: 1 }, 8, ["geojson-source"]), yt("div", tM, [H(l) || ut ? (ct(), gr(a4, { key: 0, bearing: H(f).bearing, "onUpdate:bearing": Bt[1] || (Bt[1] = (Zt) => H(f).bearing = Zt), tracking: H(f).isTrackingOrientation, onToggleTracking: H(st) }, null, 8, ["bearing", "tracking", "onToggleTracking"])) : Pr("", true)])])) : (ct(), $t("div", rM, [De(H(e6), { size: "large" }, { description: $e(() => [De(H(Ja), null, { default: $e(() => [yr(Kt(H(s)("trackerView.mapLoading")), 1)]), _: 1 })]), _: 1 })]))]), _: 1 })]), De(w4, { show: Z.value, "onUpdate:show": Bt[2] || (Bt[2] = (Zt) => Z.value = Zt), types: ["application/json", "text/plain"], onConfirm: J.value }, null, 8, ["show", "onConfirm"]), De(G4, { show: oe.value, "onUpdate:show": Bt[3] || (Bt[3] = (Zt) => oe.value = Zt), "onUpdate:width": Bt[4] || (Bt[4] = (Zt) => fe.value = Zt) }, { "bottom-floating": $e(() => [De(H(ub), { theme: H(Gd) }, { default: $e(() => [F.value.length > 1 ? (ct(), gr(H($r), { key: 0, size: "large", type: "success", class: "drawer-floating-button", onClick: we }, { default: $e(() => [...Bt[5] || (Bt[5] = [yr(" Follow ", -1)])]), _: 1 })) : Pr("", true)]), _: 1 }, 8, ["theme"])]), _: 1 }, 8, ["show"]), De(WI, { "is-recording": H($).isRecording, "record-timespan": H($).currentRouteRecordTimespan, "is-route-drawer-open": oe.value, onToggleRecording: H(ie) }, null, 8, ["is-recording", "record-timespan", "is-route-drawer-open", "onToggleRecording"])]));
} }), N1 = Ni(iM, [["__scopeId", "data-v-836eb33a"]]), nM = Object.freeze(Object.defineProperty({ __proto__: null, default: N1 }, Symbol.toStringTag, { value: "Module" })), oM = { class: "container" }, aM = { style: { height: "100%", width: "100%", display: "flex", "justify-items": "center" } }, sM = { style: { display: "flex", "flex-direction": "row", "flex-grow": "1" } }, lM = { style: { "font-weight": "500" } }, uM = { style: { display: "flex", "flex-wrap": "wrap", gap: "4px", "margin-left": "24px" } }, cM = ot({ __name: "SketchSelector", props: { list: { type: Array, default: () => [] } }, emits: ["select", "remove"], setup(r, { emit: i }) {
  const { t: l } = On(), d = r, f = i;
  function g(s) {
    f("select", s);
  }
  function p(s) {
    confirm(l("sketchEdit.deleteSketchConfirmation")) && f("remove", s);
  }
  return (s, C) => (ct(), $t("div", oM, [De(H(hh), { class: "select-listview", hoverable: "" }, { default: $e(() => [(ct(true), $t(Wr, null, on(d.list, (P) => (ct(), gr(H(fh), { key: P.id, title: P.name, onClick: (M) => g(P.id) }, { prefix: $e(() => [yt("div", aM, [De(H(bi), { size: "20" }, { default: $e(() => [De(H(Tb))]), _: 1 })])]), suffix: $e(() => [De(H($r), { quaternary: "", circle: "", onClick: Hd((M) => p(P.id), ["stop"]) }, { icon: $e(() => [De(H(bi), null, { default: $e(() => [De(H(Mp))]), _: 1 })]), _: 1 }, 8, ["onClick"])]), default: $e(() => [yt("div", sM, [yt("div", lM, Kt(P.name), 1), yt("div", uM, [(ct(true), $t(Wr, null, on(P.tags, (M) => (ct(), gr(H(xo), { key: M, size: "small", type: "info" }, { default: $e(() => [yr(Kt(M.toLocaleUpperCase()), 1)]), _: 2 }, 1024))), 128))])])]), _: 2 }, 1032, ["title", "onClick"]))), 128))]), _: 1 })]));
} }), dM = Ni(cM, [["__scopeId", "data-v-dc2c6049"]]), hM = ot({ __name: "SelectorDrawer", props: { active: { type: Boolean, default: () => false }, placement: { type: String, default: () => "right" }, list: { type: Array, default: () => [] } }, emits: ["new", "update:active", "remove", "select", "import"], setup(r, { emit: i }) {
  const { t: l } = On(), d = r, f = [{ title: l("sketchEdit.import"), icon: Ib, callback: () => {
    s("import");
  }, secondary: true, iconSize: 17, type: "default" }, { title: l("sketchEdit.new"), icon: Jd, callback: () => s("new"), secondary: true, iconSize: 20, type: "default" }, { title: l("sketchEdit.close"), icon: oS, callback: () => {
    g.value = false;
  }, secondary: true, iconSize: 20, type: "error" }], g = Ie(false), p = Ie(d.placement);
  Ht(d, () => {
    g.value = d.active, p.value = d.placement;
  }, { deep: true }), Ht(g, () => {
    s("update:active", g.value);
  });
  const s = i;
  return (C, P) => (ct(), gr(H(Yb), { show: g.value, "onUpdate:show": P[2] || (P[2] = (M) => g.value = M), width: 502, placement: p.value, "auto-focus": false }, { default: $e(() => [De(H(Kb), { title: H(l)("sketchEdit.cartoSketchLibrary") }, { footer: $e(() => [De(H(mP), null, { default: $e(() => [(ct(), $t(Wr, null, on(f, (M) => De(H($r), { key: M.title, secondary: M.secondary, type: M.type, title: M.title, onClick: M.callback }, { icon: $e(() => [De(H(bi), { size: M.iconSize }, { default: $e(() => [(ct(), gr(_c(M.icon)))]), _: 2 }, 1032, ["size"])]), _: 2 }, 1032, ["secondary", "type", "title", "onClick"])), 64))]), _: 1 })]), default: $e(() => [De(dM, { list: r.list, onRemove: P[0] || (P[0] = (M) => s("remove", M)), onSelect: P[1] || (P[1] = (M) => s("select", M)) }, null, 8, ["list"])]), _: 1 }, 8, ["title"])]), _: 1 }, 8, ["show", "placement"]));
} }), fM = ["title", "onClick"], Kf = 20, pM = ot({ __name: "SketchToolbar", props: { sketchName: {}, draftCount: {}, routeCount: {} }, emits: ["save", "open", "create", "edit-meta"], setup(r, { emit: i }) {
  const { t: l } = On(), d = i, f = [{ title: l("sketchEdit.save"), icon: XC, iconSize: Kf, callback: () => d("save") }, { title: l("sketchEdit.open"), icon: eS, iconSize: Kf, callback: () => d("open") }, { title: l("sketchEdit.newComponent"), icon: Jd, iconSize: Kf, callback: () => d("create") }, { title: l("sketchEdit.editMetadata"), icon: I3, iconSize: Kf, callback: () => d("edit-meta") }];
  return (g, p) => (ct(), gr(H(M_), { justify: "space-between", align: "center" }, { default: $e(() => [De(H(Ja), { strong: "" }, { default: $e(() => [yr(Kt(r.sketchName || H(l)("sketchEdit.noSketchSelectedToolbar")), 1)]), _: 1 }), De(H(M_), { align: "center" }, { default: $e(() => [r.sketchName !== void 0 ? (ct(), gr(H(xo), { key: 0, type: "info", size: "small" }, { default: $e(() => [yr(Kt(r.draftCount || 0) + " " + Kt(H(l)("sketchEdit.drafts")) + ", " + Kt(r.routeCount || 0) + " " + Kt(H(l)("sketchEdit.routes")), 1)]), _: 1 })) : Pr("", true), (ct(), $t(Wr, null, on(f, (s, C) => yt("div", { key: C, title: s.title, class: "tool-tip-item", onClick: s.callback }, [De(H(bi), { size: s.iconSize }, { default: $e(() => [(ct(), gr(_c(s.icon)))]), _: 2 }, 1032, ["size"])], 8, fM)), 64))]), _: 1 })]), _: 1 }));
} }), mM = Ni(pM, [["__scopeId", "data-v-5b012717"]]), gM = { key: 0, class: "empty-state" }, vM = ot({ __name: "ComponentList", props: { components: {}, selectedId: {} }, emits: ["select", "delete", "create"], setup(r, { emit: i }) {
  const { t: l } = On(), d = i;
  return (f, g) => (ct(), $t(Wr, null, [De(H(hh), { hoverable: "" }, { default: $e(() => [(ct(true), $t(Wr, null, on(r.components, (p) => (ct(), gr(H(fh), { key: p.value, class: Qo({ "selected-component": r.selectedId === p.value }), onClick: () => d("select", p.value, p.type) }, { prefix: $e(() => [De(H(bi), { color: p.type === "draft" ? "#007bff" : "#28a745" }, { default: $e(() => [(ct(), gr(_c(p.type === "draft" ? H(Tb) : H(c0))))]), _: 2 }, 1032, ["color"])]), suffix: $e(() => [De(H(VT), { onPositiveClick: (s) => d("delete", p.value, p.type) }, { trigger: $e(() => [De(H($r), { quaternary: "", circle: "", size: "small" }, { default: $e(() => [De(H(bi), null, { default: $e(() => [De(H(Mp))]), _: 1 })]), _: 1 })]), default: $e(() => [yr(" " + Kt(H(l)("sketchEdit.deleteComponent")), 1)]), _: 1 }, 8, ["onPositiveClick"])]), default: $e(() => [yr(" " + Kt(p.label) + " ", 1)]), _: 2 }, 1032, ["class", "onClick"]))), 128))]), _: 1 }), r.components.length === 0 ? (ct(), $t("div", gM, [De(H(Qd), { description: H(l)("sketchEdit.noComponentsYet") }, { extra: $e(() => [De(H($r), { size: "small", onClick: g[0] || (g[0] = (p) => d("create")) }, { default: $e(() => [yr(Kt(H(l)("sketchEdit.createComponent")), 1)]), _: 1 })]), _: 1 }, 8, ["description"])])) : Pr("", true)], 64));
} }), _M = Ni(vM, [["__scopeId", "data-v-3addb8a0"]]), yM = { key: 0, class: "properties-panel" }, bM = { key: 1, style: { height: "100%", width: "100%", display: "flex", "justify-content": "center", "align-items": "center" } }, xM = ot({ __name: "PropertiesPanel", props: { component: {}, type: {} }, emits: ["updateProperties", "updateMeta"], setup(r, { emit: i }) {
  const { t: l } = On(), d = i;
  return (f, g) => r.component ? (ct(), $t("div", yM, [De(H(c6), { type: "line", animated: "", "default-value": "properties" }, { default: $e(() => [De(H(W_), { name: "properties", tab: H(l)("sketchEdit.properties") }, { default: $e(() => [De(H(th), null, { default: $e(() => [De(H(Cn), { label: H(l)("sketchEdit.visible") }, { default: $e(() => [De(H(c1), { value: r.component.properties.visible !== false, "onUpdate:value": g[0] || (g[0] = (p) => d("updateProperties", { visible: p })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), r.type === "draft" ? (ct(), $t(Wr, { key: 0 }, [De(H(Cn), { label: H(l)("sketchEdit.fillColor") }, { default: $e(() => [De(H(ig), { value: r.component.properties.fillColor || "#007bff", "show-alpha": false, "onUpdate:value": g[1] || (g[1] = (p) => d("updateProperties", { fillColor: p })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), De(H(Cn), { label: H(l)("sketchEdit.strokeColor") }, { default: $e(() => [De(H(ig), { value: r.component.properties.strokeColor || "#0056b3", "show-alpha": false, "onUpdate:value": g[2] || (g[2] = (p) => d("updateProperties", { strokeColor: p })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), De(H(Cn), { label: H(l)("sketchEdit.strokeThickness") }, { default: $e(() => [De(H(V_), { value: r.component.properties.strokeThickness || 2, min: 1, max: 10, "onUpdate:value": g[3] || (g[3] = (p) => d("updateProperties", { strokeThickness: p ?? void 0 })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"])], 64)) : Pr("", true), r.type === "route" ? (ct(), $t(Wr, { key: 1 }, [De(H(Cn), { label: H(l)("sketchEdit.strokeColor") }, { default: $e(() => [De(H(ig), { value: r.component.properties.strokeColor || "#28a745", "show-alpha": false, "onUpdate:value": g[4] || (g[4] = (p) => d("updateProperties", { strokeColor: p })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), De(H(Cn), { label: H(l)("sketchEdit.strokeThickness") }, { default: $e(() => [De(H(V_), { value: r.component.properties.strokeThickness || 3, min: 1, max: 10, "onUpdate:value": g[5] || (g[5] = (p) => d("updateProperties", { strokeThickness: p ?? void 0 })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"])], 64)) : Pr("", true)]), _: 1 })]), _: 1 }, 8, ["tab"]), De(H(W_), { name: "metadata", tab: H(l)("sketchEdit.metadata") }, { default: $e(() => [De(H(th), null, { default: $e(() => [De(H(Cn), { label: H(l)("sketchEdit.name") }, { default: $e(() => [De(H(_o), { value: r.component.meta.name, "onUpdate:value": g[6] || (g[6] = (p) => {
    var _a3, _b2;
    return d("updateMeta", { name: p, description: ((_a3 = r.component) == null ? void 0 : _a3.meta.description) ?? "", tags: ((_b2 = r.component) == null ? void 0 : _b2.meta.tags) ?? [] });
  }) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), De(H(Cn), { label: H(l)("sketchEdit.description") }, { default: $e(() => [De(H(_o), { value: r.component.meta.description, type: "textarea", rows: 3, "onUpdate:value": g[7] || (g[7] = (p) => {
    var _a3, _b2;
    return d("updateMeta", { name: ((_a3 = r.component) == null ? void 0 : _a3.meta.name) ?? "", description: p, tags: ((_b2 = r.component) == null ? void 0 : _b2.meta.tags) ?? [] });
  }) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), De(H(Cn), { label: H(l)("sketchEdit.tags") }, { default: $e(() => [De(H(E5), { value: r.component.meta.tags || [], placeholder: H(l)("sketchEdit.addTagPlaceholder"), "onUpdate:value": g[8] || (g[8] = (p) => {
    var _a3, _b2;
    return d("updateMeta", { name: ((_a3 = r.component) == null ? void 0 : _a3.meta.name) ?? "", description: ((_b2 = r.component) == null ? void 0 : _b2.meta.description) ?? "", tags: p });
  }) }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), De(H(Cn), { label: "UUID" }, { default: $e(() => [De(H(_o), { value: r.component.id, style: { "font-family": "monospace" }, readonly: "" }, null, 8, ["value"])]), _: 1 })]), _: 1 })]), _: 1 }, 8, ["tab"])]), _: 1 })])) : (ct(), $t("div", bM, [De(H(Qd), { description: H(l)("sketchEdit.selectComponentToEdit") }, null, 8, ["description"])]));
} }), wM = Ni(xM, [["__scopeId", "data-v-f700b4bc"]]), CM = "dCeXFrS9lgSF8hm5C6nm", SM = `https://api.maptiler.com/maps/basic-v2/style.json?key=${CM}`;
function kM() {
  const r = Ie(7), i = Ca(null), l = Ie([0, 0]);
  function d(p) {
    i.value = p.map;
  }
  function f(p) {
    l.value = p, i.value && i.value.setCenter(p);
  }
  function g(p) {
    r.value = p, i.value && i.value.setZoom(p);
  }
  return { zoom: r, map: i, center: l, styleUrl: SM, initMap: d, setCenter: f, setZoom: g };
}
function PM(r, i) {
  const l = [];
  return r.forEach((d) => {
    l.push({ label: d.meta.name, value: d.id, type: "draft" });
  }), i.forEach((d) => {
    l.push({ label: d.meta.name, value: d.id, type: "route" });
  }), l;
}
function TM() {
  return { type: "Polygon", coordinates: [[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]] };
}
function IM() {
  return { fillColor: "#007bff", strokeColor: "#0056b3", strokeThickness: 2 };
}
function MM() {
  return { strokeColor: "#28a745", strokeThickness: 3 };
}
const EM = { style: { display: "flex", "flex-direction": "row", gap: "8px" } }, RM = { style: { display: "flex", gap: "8px", "margin-bottom": "8px" } }, AM = { class: "sketch-edit-container" }, DM = { class: "grid-layout" }, zM = { class: "meta-info-section" }, FM = { class: "metadata-item" }, LM = { class: "metadata-item" }, BM = ot({ __name: "SketchEdit", props: { liteMode: { type: Boolean }, forceHighDpi: { type: Boolean }, mapType: {}, sketchId: {} }, setup(r) {
  const i = r, { t: l } = On(), d = Ap(), f = y0(), { zoom: g, styleUrl: p, initMap: s } = kM(), C = Ie(false), P = Ie(null), M = Ie(null), D = Ie(false), L = Ie(""), $ = Ie("draft"), z = Ie(false), F = Ie({ name: "", description: "", tags: [], created_by: "", modified_by: "" }), Z = Ie(""), q = Ee(() => f.currentSketch), K = Ee(() => f.currentDrafts), te = Ee(() => {
    var _a3;
    return ((_a3 = q.value) == null ? void 0 : _a3.routes.routes) || [];
  }), re = Ee(() => !!q.value), ie = Ee(() => !P.value || !M.value ? null : M.value === "draft" ? f.getDraftById(P.value) : f.getRouteById(P.value)), J = Ee(() => PM(K.value, te.value));
  async function we() {
    if (q.value) try {
      await f.updateSketch(q.value.id, { name: q.value.meta.name, description: q.value.meta.description, tags: q.value.meta.tags }), d.success(l("sketchEdit.saveSuccess"));
    } catch (st) {
      d.error(l("sketchEdit.saveError")), console.error(st);
    }
  }
  async function fe() {
    const st = prompt(l("sketchEdit.enterSketchName"));
    st && (await f.createSketch(st), C.value = false);
  }
  async function oe() {
    if (!(!L.value.trim() || !q.value)) try {
      if ($.value === "draft") {
        const st = await f.addDraft(TM(), IM(), { name: L.value });
        P.value = st.id, M.value = "draft";
      } else {
        const st = await f.addRoute(L.value, MM());
        P.value = st.id, M.value = "route";
      }
      D.value = false, L.value = "", d.success(l("sketchEdit.componentCreated"));
    } catch (st) {
      d.error(l("sketchEdit.componentCreateError")), console.error(st);
    }
  }
  async function he(st, nt) {
    try {
      nt === "draft" ? await f.deleteDraft(st) : await f.deleteRoute(st), P.value === st && (P.value = null, M.value = null), d.success(l("sketchEdit.componentDeleted"));
    } catch (ft) {
      d.error(l("sketchEdit.componentDeleteError")), console.error(ft);
    }
  }
  async function _e(st) {
    if (!(!ie.value || !M.value)) try {
      M.value === "draft" ? await f.updateDraft(P.value, { properties: st }) : await f.updateRoute(P.value, { properties: st }), d.success(l("sketchEdit.propertiesUpdated"));
    } catch (nt) {
      d.error(l("sketchEdit.propertiesUpdateError")), console.error(nt);
    }
  }
  async function Ue(st) {
    if (!(!ie.value || !M.value)) try {
      M.value === "draft" ? await f.updateDraft(P.value, { meta: st }) : await f.updateRoute(P.value, { name: st.name }), d.success(l("sketchEdit.propertiesUpdated"));
    } catch (nt) {
      d.error(l("sketchEdit.propertiesUpdateError")), console.error(nt);
    }
  }
  function qe() {
    q.value && (F.value = { name: q.value.meta.name, description: q.value.meta.description, tags: [...q.value.meta.tags], created_by: q.value.meta.created_by, modified_by: q.value.meta.modified_by }, z.value = true);
  }
  function tt() {
    Z.value.trim() && !F.value.tags.includes(Z.value.trim()) && (F.value.tags.push(Z.value.trim()), Z.value = "");
  }
  function ut(st) {
    F.value.tags = F.value.tags.filter((nt) => nt !== st);
  }
  async function mt() {
    if (q.value) try {
      await f.updateSketch(q.value.id, { name: F.value.name, description: F.value.description, tags: F.value.tags }), z.value = false, d.success(l("sketchEdit.saveSuccess"));
    } catch (st) {
      d.error(l("sketchEdit.saveError")), console.error(st);
    }
  }
  Ri(() => {
    i.sketchId && f.setCurrentSketchId(i.sketchId);
  }), Ht(() => f.currentSketchId, (st) => {
    st && (P.value = null, M.value = null);
  });
  const St = (st) => new Date(st).toLocaleString();
  return (st, nt) => (ct(), $t(Wr, null, [De(hM, { active: C.value, "onUpdate:active": nt[0] || (nt[0] = (ft) => C.value = ft), list: H(f).sketches.map((ft) => ({ id: ft.id, name: ft.meta.name, tags: ft.meta.tags })), placement: "right", onNew: fe, onRemove: nt[1] || (nt[1] = (ft) => H(f).deleteSketch(ft)), onSelect: nt[2] || (nt[2] = (ft) => H(f).setCurrentSketchId(ft)) }, null, 8, ["active", "list"]), De(H(Kd), { show: D.value, "onUpdate:show": nt[6] || (nt[6] = (ft) => D.value = ft), preset: "dialog", title: H(l)("sketchEdit.createNewComponent") }, { action: $e(() => [De(H($r), { onClick: nt[5] || (nt[5] = (ft) => D.value = false) }, { default: $e(() => [yr(Kt(H(l)("sketchEdit.cancel")), 1)]), _: 1 }), De(H($r), { type: "primary", disabled: !L.value.trim(), onClick: oe }, { default: $e(() => [yr(Kt(H(l)("sketchEdit.create")), 1)]), _: 1 }, 8, ["disabled"])]), default: $e(() => [De(H(th), null, { default: $e(() => [yt("div", EM, [De(H(Cn), { label: H(l)("sketchEdit.name"), style: { "flex-grow": "1" } }, { default: $e(() => [De(H(_o), { value: L.value, "onUpdate:value": nt[3] || (nt[3] = (ft) => L.value = ft), placeholder: H(l)("sketchEdit.enterComponentName") }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), De(H(Cn), { label: H(l)("sketchEdit.type") }, { default: $e(() => [De(H(Bg), { value: $.value, "onUpdate:value": nt[4] || (nt[4] = (ft) => $.value = ft), "consistent-menu-width": false, options: [{ label: H(l)("sketchEdit.draftShape"), value: "draft" }, { label: H(l)("sketchEdit.routePath"), value: "route" }] }, null, 8, ["value", "options"])]), _: 1 }, 8, ["label"])])]), _: 1 })]), _: 1 }, 8, ["show", "title"]), De(H(Kd), { show: z.value, "onUpdate:show": nt[11] || (nt[11] = (ft) => z.value = ft), preset: "dialog", title: H(l)("sketchEdit.editMetadata"), style: { "max-width": "600px" } }, { action: $e(() => [De(H($r), { onClick: nt[10] || (nt[10] = (ft) => z.value = false) }, { default: $e(() => [yr(Kt(H(l)("sketchEdit.cancel")), 1)]), _: 1 }), De(H($r), { type: "primary", disabled: !F.value.name.trim(), onClick: mt }, { default: $e(() => [yr(Kt(H(l)("sketchEdit.save")), 1)]), _: 1 }, 8, ["disabled"])]), default: $e(() => [De(H(th), null, { default: $e(() => [De(H(Cn), { label: H(l)("sketchEdit.name") }, { default: $e(() => [De(H(_o), { value: F.value.name, "onUpdate:value": nt[7] || (nt[7] = (ft) => F.value.name = ft), placeholder: H(l)("sketchEdit.sketchNamePlaceholder") }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), De(H(Cn), { label: H(l)("sketchEdit.description") }, { default: $e(() => [De(H(_o), { value: F.value.description, "onUpdate:value": nt[8] || (nt[8] = (ft) => F.value.description = ft), type: "textarea", placeholder: H(l)("sketchEdit.sketchDescriptionPlaceholder"), rows: 3 }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), De(H(Cn), { label: H(l)("sketchEdit.tags") }, { default: $e(() => [yt("div", RM, [De(H(_o), { value: Z.value, "onUpdate:value": nt[9] || (nt[9] = (ft) => Z.value = ft), placeholder: H(l)("sketchEdit.addTagPlaceholder"), onKeydown: Oy(Hd(tt, ["prevent"]), ["enter"]) }, null, 8, ["value", "placeholder", "onKeydown"]), De(H($r), { onClick: tt }, { default: $e(() => [yr(Kt(H(l)("sketchEdit.add")), 1)]), _: 1 })]), (ct(true), $t(Wr, null, on(F.value.tags, (ft) => (ct(), gr(H(xo), { key: ft, closable: "", style: { "margin-right": "8px", "margin-bottom": "8px" }, onClose: (Lt) => ut(ft) }, { default: $e(() => [yr(Kt(ft), 1)]), _: 2 }, 1032, ["onClose"]))), 128)), F.value.tags.length === 0 ? (ct(), gr(H(Qd), { key: 0, description: H(l)("sketchEdit.noTags"), size: "small" }, null, 8, ["description"])) : Pr("", true)]), _: 1 }, 8, ["label"])]), _: 1 })]), _: 1 }, 8, ["show", "title"]), yt("div", AM, [yt("div", DM, [yt("div", zM, [De(H(Mo), null, { default: $e(() => {
    var _a3;
    return [De(mM, { "sketch-name": (_a3 = q.value) == null ? void 0 : _a3.meta.name, "draft-count": K.value.length, "route-count": te.value.length, onSave: we, onOpen: nt[12] || (nt[12] = (ft) => C.value = true), onCreate: nt[13] || (nt[13] = (ft) => D.value = true), onEditMeta: qe }, null, 8, ["sketch-name", "draft-count", "route-count"])];
  }), _: 1 })]), De(H(q_), { direction: "horizontal", max: 0.8, min: 0.2, "default-size": 0.5, class: "bottom-row-split" }, { 1: $e(() => [De(H(q_), { style: { height: "100%" }, direction: "vertical" }, { 1: $e(() => [De(H(Mo), { style: { height: "100%" }, title: H(l)("sketchEdit.components"), "content-style": "min-height: 0; overflow-y: auto;" }, { "header-extra": $e(() => [De(H($r), { quaternary: "", circle: "", onClick: nt[16] || (nt[16] = (ft) => D.value = true) }, { icon: $e(() => [De(H(Jd))]), _: 1 })]), default: $e(() => [De(_M, { components: J.value, "selected-id": P.value, onSelect: nt[14] || (nt[14] = (ft, Lt) => {
    P.value = ft, M.value = Lt;
  }), onDelete: he, onCreate: nt[15] || (nt[15] = (ft) => D.value = true) }, null, 8, ["components", "selected-id"])]), _: 1 }, 8, ["title"])]), 2: $e(() => [De(H(Mo), { class: "map-container", "content-style": "padding: 0;" }, { default: $e(() => [De(H(x1), { "map-style": H(p), center: [0, 0], zoom: H(g), height: "100%", "onMap:load": H(s) }, { default: $e(() => [De(H(C1), { position: "top-left" }), De(H(k1), { position: "bottom-left" }), De(H(w1), { position: "top-left" })]), _: 1 }, 8, ["map-style", "zoom", "onMap:load"])]), _: 1 })]), _: 1 }), re.value ? Pr("", true) : (ct(), gr(H(Qd), { key: 0, description: H(l)("sketchEdit.noSketchSelected"), size: "huge", style: { height: "100%", "justify-content": "center" } }, { icon: $e(() => [De(H(bi), null, { default: $e(() => [De(H(M3))]), _: 1 })]), extra: $e(() => [De(H($r), { size: "small", onClick: nt[17] || (nt[17] = (ft) => C.value = true) }, { default: $e(() => [yr(Kt(H(l)("sketchEdit.selectSketch")), 1)]), _: 1 })]), _: 1 }, 8, ["description"]))]), 2: $e(() => [De(H(Mo), { class: "component-info-container", "content-style": "min-height: 0; overflow: auto;" }, { footer: $e(() => [ie.value ? (ct(), gr(H(Ja), { key: 0, depth: "3", class: "metadata" }, { default: $e(() => [yt("div", FM, Kt(H(l)("sketchEdit.createdTimeBy", { user: ie.value.meta.created_by, time: St(ie.value.meta.creation_timestamp) })), 1), yt("div", LM, Kt(H(l)("sketchEdit.modifiedTimeBy", { user: ie.value.meta.modified_by, time: St(ie.value.meta.modification_timestamp) })), 1)]), _: 1 })) : Pr("", true)]), default: $e(() => [De(wM, { component: ie.value, type: M.value, onUpdateProperties: _e, onUpdateMeta: nt[18] || (nt[18] = (ft) => Ue(ft)) }, null, 8, ["component", "type"])]), _: 1 })]), _: 1 })])])], 64));
} }), OM = Ni(BM, [["__scopeId", "data-v-b8cdd1f5"]]), $M = { class: "sketch-centre-view" }, jM = { class: "header" }, NM = { class: "title" }, VM = { class: "card-header" }, UM = { key: 0, class: "tags" }, GM = { class: "card-content" }, qM = { class: "meta-info" }, WM = { class: "meta-item" }, ZM = { class: "meta-item" }, HM = { class: "meta-item" }, XM = { key: 0, class: "empty-state" }, YM = ot({ __name: "SketchCentreView", setup(r) {
  Ns((oe) => ({ v460cb2d9: H(fe).bodyColor }));
  const { t: i } = On(), l = Hb(), d = Ap(), f = $s(), g = y0(), p = Ee(() => g.sketches), s = Ee({ get: () => g.currentSketchId, set: (oe) => g.setCurrentSketchId(oe) }), C = (oe) => {
    const he = s.value === oe;
    return { borderColor: he ? f.value.primaryColor : "", borderWidth: he ? "2px" : "1px", padding: he ? "0px" : "1px", zIndex: he ? 0 : 1 };
  }, P = Ie(false), M = Ie(""), D = Ie(""), L = Ie(false), $ = Ie(""), z = async () => {
    await g.init();
  }, F = (oe) => new Date(oe).toLocaleDateString(), Z = (oe) => oe.routes.routes.length, q = (oe) => oe.drafts.drafts.length, K = (oe) => {
    g.setCurrentSketchId(oe);
  }, te = (oe) => {
    $.value = oe, L.value = true;
  }, re = async () => {
    if (!M.value.trim()) {
      d.error(i("sketchCentreView.nameRequired"));
      return;
    }
    const oe = await g.createSketch(M.value);
    await g.updateSketch(oe.id, { description: D.value }), g.setCurrentSketchId(oe.id), P.value = false, M.value = "", D.value = "", d.success(i("sketchCentreView.sketchCreated"));
  }, ie = (oe) => {
    const he = p.value.find((_e) => _e.id === oe);
    he && l.warning({ title: i("sketchCentreView.deleteConfirmation.title"), content: i("sketchCentreView.deleteConfirmation.prompt", { name: he.meta.name }), positiveText: i("sketchCentreView.deleteConfirmation.yes"), negativeText: i("sketchCentreView.deleteConfirmation.no"), onPositiveClick: async () => {
      await g.deleteSketch(oe), d.success(i("sketchCentreView.sketchDeleted"));
    } });
  }, { width: J } = cb(), we = Ee(() => Math.floor(J.value / 360));
  Ri(() => {
    z();
  });
  const fe = $s();
  return (oe, he) => (ct(), $t("div", $M, [yt("div", jM, [yt("h1", NM, Kt(H(i)("sketchCentreView.title")), 1), De(H($r), { type: "primary", secondary: "", circle: "", onClick: he[0] || (he[0] = (_e) => P.value = true) }, { icon: $e(() => [De(H(bi), null, { default: $e(() => [De(H(Jd))]), _: 1 })]), _: 1 })]), De(H(CT), { cols: we.value, "x-gap": 16, "y-gap": 16, responsive: "screen" }, { default: $e(() => [(ct(true), $t(Wr, null, on(p.value, (_e) => (ct(), gr(H(bT), { key: _e.id }, { default: $e(() => [De(H(Mo), { class: Qo(["sketch-card", { selected: s.value === _e.id }]), style: Sn(C(_e.id)), hoverable: "", bordered: "", clickable: "", onClick: (Ue) => K(_e.id) }, { header: $e(() => [yt("div", VM, [De(H(Ja), { class: "sketch-name" }, { default: $e(() => [yr(Kt(_e.meta.name), 1)]), _: 2 }, 1024), _e.meta.tags.length > 0 ? (ct(), $t("div", UM, [(ct(true), $t(Wr, null, on(_e.meta.tags.slice(0, 3), (Ue) => (ct(), gr(H(xo), { key: Ue, size: "small", round: "", type: "info" }, { default: $e(() => [yr(Kt(Ue.toLocaleUpperCase()), 1)]), _: 2 }, 1024))), 128)), _e.meta.tags.length > 3 ? (ct(), gr(H(xo), { key: 0, size: "small", round: "", type: "info" }, { default: $e(() => [yr(" +" + Kt(_e.meta.tags.length - 3), 1)]), _: 2 }, 1024)) : Pr("", true)])) : Pr("", true)])]), "header-extra": $e(() => [De(H(Fs), null, { default: $e(() => [De(H($r), { quaternary: "", circle: "", size: "small", onClick: Hd((Ue) => te(_e.id), ["stop"]) }, { icon: $e(() => [De(H(bi), null, { default: $e(() => [De(H(KC))]), _: 1 })]), _: 1 }, 8, ["onClick"]), De(H($r), { quaternary: "", circle: "", size: "small", onClick: Hd((Ue) => ie(_e.id), ["stop"]) }, { icon: $e(() => [De(H(bi), null, { default: $e(() => [De(H(Mp))]), _: 1 })]), _: 1 }, 8, ["onClick"])]), _: 2 }, 1024)]), default: $e(() => [yt("div", GM, [De(H(Ja), { depth: "3", class: "description" }, { default: $e(() => [yr(Kt(_e.meta.description || H(i)("sketchCentreView.noDescription")), 1)]), _: 2 }, 1024), yt("div", qM, [yt("div", WM, [De(H(bi), { size: 16 }, { default: $e(() => [De(H(qC))]), _: 1 }), De(H(Ja), { depth: "3", style: { "font-size": "12px" } }, { default: $e(() => [yr(Kt(F(_e.meta.creation_timestamp)), 1)]), _: 2 }, 1024)]), yt("div", ZM, [De(H(bi), { size: 16 }, { default: $e(() => [De(H(c0))]), _: 1 }), De(H(Ja), { depth: "3", style: { "font-size": "12px" } }, { default: $e(() => [yr(Kt(Z(_e)) + " " + Kt(H(i)("sketchCentreView.routes")), 1)]), _: 2 }, 1024)]), yt("div", HM, [De(H(bi), { size: 16 }, { default: $e(() => [De(H(Sb))]), _: 1 }), De(H(Ja), { depth: "3", style: { "font-size": "12px" } }, { default: $e(() => [yr(Kt(q(_e)) + " " + Kt(H(i)("sketchCentreView.drafts")), 1)]), _: 2 }, 1024)])])])]), _: 2 }, 1032, ["class", "style", "onClick"])]), _: 2 }, 1024))), 128))]), _: 1 }, 8, ["cols"]), p.value.length === 0 ? (ct(), $t("div", XM, [De(H(bi), { size: "48", depth: "3" }, { default: $e(() => [De(H(u0))]), _: 1 }), De(H(Ja), { depth: "3" }, { default: $e(() => [yr(Kt(H(i)("sketchCentreView.emptyState")), 1)]), _: 1 }), De(H($r), { type: "primary", onClick: he[1] || (he[1] = (_e) => P.value = true) }, { icon: $e(() => [De(H(bi), null, { default: $e(() => [De(H(Jd))]), _: 1 })]), default: $e(() => [yr(" " + Kt(H(i)("sketchCentreView.createFirstSketch")), 1)]), _: 1 })])) : Pr("", true), De(H(Kd), { show: P.value, "onUpdate:show": he[5] || (he[5] = (_e) => P.value = _e), "mask-closable": true, preset: "card", style: { "max-width": "500px" }, title: H(i)("sketchCentreView.newSketch") }, { footer: $e(() => [De(H(Fs), { justify: "end" }, { default: $e(() => [De(H($r), { onClick: he[4] || (he[4] = (_e) => P.value = false) }, { default: $e(() => [yr(Kt(H(i)("sketchCentreView.cancel")), 1)]), _: 1 }), De(H($r), { type: "primary", onClick: re }, { default: $e(() => [yr(Kt(H(i)("sketchCentreView.create")), 1)]), _: 1 })]), _: 1 })]), default: $e(() => [De(H(th), { model: { name: M.value, description: D.value }, "label-placement": "top", "require-mark-placement": "right-hanging" }, { default: $e(() => [De(H(Cn), { label: H(i)("sketchCentreView.sketchName"), required: "" }, { default: $e(() => [De(H(_o), { value: M.value, "onUpdate:value": he[2] || (he[2] = (_e) => M.value = _e), placeholder: H(i)("sketchCentreView.sketchNamePlaceholder") }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), De(H(Cn), { label: H(i)("sketchCentreView.description") }, { default: $e(() => [De(H(_o), { value: D.value, "onUpdate:value": he[3] || (he[3] = (_e) => D.value = _e), type: "textarea", placeholder: H(i)("sketchCentreView.sketchDescriptionPlaceholder"), autosize: { minRows: 3, maxRows: 5 } }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"])]), _: 1 }, 8, ["model"])]), _: 1 }, 8, ["show", "title"]), De(H(Yb), { show: L.value, "onUpdate:show": he[6] || (he[6] = (_e) => L.value = _e), width: 800, placement: "right", "display-directive": "show", height: "100%" }, { default: $e(() => [De(H(Kb), { title: H(i)("sketchCentreView.editSketch"), closable: "", "body-content-style": { padding: 0, height: "100%" } }, { default: $e(() => [$.value ? (ct(), gr(OM, { key: 0, "sketch-id": $.value }, null, 8, ["sketch-id"])) : Pr("", true)]), _: 1 }, 8, ["title"])]), _: 1 }, 8, ["show"])]));
} }), V1 = Ni(YM, [["__scopeId", "data-v-00cdfd4b"]]), KM = Object.freeze(Object.defineProperty({ __proto__: null, default: V1 }, Symbol.toStringTag, { value: "Module" })), vy = {};
function JM(r) {
  let i = vy[r];
  if (i) return i;
  i = vy[r] = [];
  for (let l = 0; l < 128; l++) {
    const d = String.fromCharCode(l);
    i.push(d);
  }
  for (let l = 0; l < r.length; l++) {
    const d = r.charCodeAt(l);
    i[d] = "%" + ("0" + d.toString(16).toUpperCase()).slice(-2);
  }
  return i;
}
function gc(r, i) {
  typeof i != "string" && (i = gc.defaultChars);
  const l = JM(i);
  return r.replace(/(%[a-f0-9]{2})+/gi, function(d) {
    let f = "";
    for (let g = 0, p = d.length; g < p; g += 3) {
      const s = parseInt(d.slice(g + 1, g + 3), 16);
      if (s < 128) {
        f += l[s];
        continue;
      }
      if ((s & 224) === 192 && g + 3 < p) {
        const C = parseInt(d.slice(g + 4, g + 6), 16);
        if ((C & 192) === 128) {
          const P = s << 6 & 1984 | C & 63;
          P < 128 ? f += "\uFFFD\uFFFD" : f += String.fromCharCode(P), g += 3;
          continue;
        }
      }
      if ((s & 240) === 224 && g + 6 < p) {
        const C = parseInt(d.slice(g + 4, g + 6), 16), P = parseInt(d.slice(g + 7, g + 9), 16);
        if ((C & 192) === 128 && (P & 192) === 128) {
          const M = s << 12 & 61440 | C << 6 & 4032 | P & 63;
          M < 2048 || M >= 55296 && M <= 57343 ? f += "\uFFFD\uFFFD\uFFFD" : f += String.fromCharCode(M), g += 6;
          continue;
        }
      }
      if ((s & 248) === 240 && g + 9 < p) {
        const C = parseInt(d.slice(g + 4, g + 6), 16), P = parseInt(d.slice(g + 7, g + 9), 16), M = parseInt(d.slice(g + 10, g + 12), 16);
        if ((C & 192) === 128 && (P & 192) === 128 && (M & 192) === 128) {
          let D = s << 18 & 1835008 | C << 12 & 258048 | P << 6 & 4032 | M & 63;
          D < 65536 || D > 1114111 ? f += "\uFFFD\uFFFD\uFFFD\uFFFD" : (D -= 65536, f += String.fromCharCode(55296 + (D >> 10), 56320 + (D & 1023))), g += 9;
          continue;
        }
      }
      f += "\uFFFD";
    }
    return f;
  });
}
gc.defaultChars = ";/?:@&=+$,#";
gc.componentChars = "";
const _y = {};
function QM(r) {
  let i = _y[r];
  if (i) return i;
  i = _y[r] = [];
  for (let l = 0; l < 128; l++) {
    const d = String.fromCharCode(l);
    /^[0-9a-z]$/i.test(d) ? i.push(d) : i.push("%" + ("0" + l.toString(16).toUpperCase()).slice(-2));
  }
  for (let l = 0; l < r.length; l++) i[r.charCodeAt(l)] = r[l];
  return i;
}
function gh(r, i, l) {
  typeof i != "string" && (l = i, i = gh.defaultChars), typeof l > "u" && (l = true);
  const d = QM(i);
  let f = "";
  for (let g = 0, p = r.length; g < p; g++) {
    const s = r.charCodeAt(g);
    if (l && s === 37 && g + 2 < p && /^[0-9a-f]{2}$/i.test(r.slice(g + 1, g + 3))) {
      f += r.slice(g, g + 3), g += 2;
      continue;
    }
    if (s < 128) {
      f += d[s];
      continue;
    }
    if (s >= 55296 && s <= 57343) {
      if (s >= 55296 && s <= 56319 && g + 1 < p) {
        const C = r.charCodeAt(g + 1);
        if (C >= 56320 && C <= 57343) {
          f += encodeURIComponent(r[g] + r[g + 1]), g++;
          continue;
        }
      }
      f += "%EF%BF%BD";
      continue;
    }
    f += encodeURIComponent(r[g]);
  }
  return f;
}
gh.defaultChars = ";/?:@&=+$,-_.!~*'()#";
gh.componentChars = "-_.!~*'()";
function x0(r) {
  let i = "";
  return i += r.protocol || "", i += r.slashes ? "//" : "", i += r.auth ? r.auth + "@" : "", r.hostname && r.hostname.indexOf(":") !== -1 ? i += "[" + r.hostname + "]" : i += r.hostname || "", i += r.port ? ":" + r.port : "", i += r.pathname || "", i += r.search || "", i += r.hash || "", i;
}
function gp() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
const eE = /^([a-z0-9.+-]+:)/i, tE = /:[0-9]*$/, rE = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, iE = ["<", ">", '"', "`", " ", "\r", `
`, "	"], nE = ["{", "}", "|", "\\", "^", "`"].concat(iE), oE = ["'"].concat(nE), yy = ["%", "/", "?", ";", "#"].concat(oE), by = ["/", "?", "#"], aE = 255, xy = /^[+a-z0-9A-Z_-]{0,63}$/, sE = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, wy = { javascript: true, "javascript:": true }, Cy = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
function w0(r, i) {
  if (r && r instanceof gp) return r;
  const l = new gp();
  return l.parse(r, i), l;
}
gp.prototype.parse = function(r, i) {
  let l, d, f, g = r;
  if (g = g.trim(), !i && r.split("#").length === 1) {
    const P = rE.exec(g);
    if (P) return this.pathname = P[1], P[2] && (this.search = P[2]), this;
  }
  let p = eE.exec(g);
  if (p && (p = p[0], l = p.toLowerCase(), this.protocol = p, g = g.substr(p.length)), (i || p || g.match(/^\/\/[^@\/]+@[^@\/]+/)) && (f = g.substr(0, 2) === "//", f && !(p && wy[p]) && (g = g.substr(2), this.slashes = true)), !wy[p] && (f || p && !Cy[p])) {
    let P = -1;
    for (let z = 0; z < by.length; z++) d = g.indexOf(by[z]), d !== -1 && (P === -1 || d < P) && (P = d);
    let M, D;
    P === -1 ? D = g.lastIndexOf("@") : D = g.lastIndexOf("@", P), D !== -1 && (M = g.slice(0, D), g = g.slice(D + 1), this.auth = M), P = -1;
    for (let z = 0; z < yy.length; z++) d = g.indexOf(yy[z]), d !== -1 && (P === -1 || d < P) && (P = d);
    P === -1 && (P = g.length), g[P - 1] === ":" && P--;
    const L = g.slice(0, P);
    g = g.slice(P), this.parseHost(L), this.hostname = this.hostname || "";
    const $ = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!$) {
      const z = this.hostname.split(/\./);
      for (let F = 0, Z = z.length; F < Z; F++) {
        const q = z[F];
        if (q && !q.match(xy)) {
          let K = "";
          for (let te = 0, re = q.length; te < re; te++) q.charCodeAt(te) > 127 ? K += "x" : K += q[te];
          if (!K.match(xy)) {
            const te = z.slice(0, F), re = z.slice(F + 1), ie = q.match(sE);
            ie && (te.push(ie[1]), re.unshift(ie[2])), re.length && (g = re.join(".") + g), this.hostname = te.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > aE && (this.hostname = ""), $ && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  const s = g.indexOf("#");
  s !== -1 && (this.hash = g.substr(s), g = g.slice(0, s));
  const C = g.indexOf("?");
  return C !== -1 && (this.search = g.substr(C), g = g.slice(0, C)), g && (this.pathname = g), Cy[l] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
gp.prototype.parseHost = function(r) {
  let i = tE.exec(r);
  i && (i = i[0], i !== ":" && (this.port = i.substr(1)), r = r.substr(0, r.length - i.length)), r && (this.hostname = r);
};
const lE = Object.freeze(Object.defineProperty({ __proto__: null, decode: gc, encode: gh, format: x0, parse: w0 }, Symbol.toStringTag, { value: "Module" })), U1 = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, G1 = /[\0-\x1F\x7F-\x9F]/, uE = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/, C0 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, q1 = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/, W1 = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, cE = Object.freeze(Object.defineProperty({ __proto__: null, Any: U1, Cc: G1, Cf: uE, P: C0, S: q1, Z: W1 }, Symbol.toStringTag, { value: "Module" })), dE = new Uint16Array('\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((r) => r.charCodeAt(0))), hE = new Uint16Array("\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((r) => r.charCodeAt(0)));
var vg;
const fE = /* @__PURE__ */ new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]), pE = (vg = String.fromCodePoint) !== null && vg !== void 0 ? vg : function(r) {
  let i = "";
  return r > 65535 && (r -= 65536, i += String.fromCharCode(r >>> 10 & 1023 | 55296), r = 56320 | r & 1023), i += String.fromCharCode(r), i;
};
function mE(r) {
  var i;
  return r >= 55296 && r <= 57343 || r > 1114111 ? 65533 : (i = fE.get(r)) !== null && i !== void 0 ? i : r;
}
var mn;
(function(r) {
  r[r.NUM = 35] = "NUM", r[r.SEMI = 59] = "SEMI", r[r.EQUALS = 61] = "EQUALS", r[r.ZERO = 48] = "ZERO", r[r.NINE = 57] = "NINE", r[r.LOWER_A = 97] = "LOWER_A", r[r.LOWER_F = 102] = "LOWER_F", r[r.LOWER_X = 120] = "LOWER_X", r[r.LOWER_Z = 122] = "LOWER_Z", r[r.UPPER_A = 65] = "UPPER_A", r[r.UPPER_F = 70] = "UPPER_F", r[r.UPPER_Z = 90] = "UPPER_Z";
})(mn || (mn = {}));
const gE = 32;
var Ls;
(function(r) {
  r[r.VALUE_LENGTH = 49152] = "VALUE_LENGTH", r[r.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", r[r.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Ls || (Ls = {}));
function Qg(r) {
  return r >= mn.ZERO && r <= mn.NINE;
}
function vE(r) {
  return r >= mn.UPPER_A && r <= mn.UPPER_F || r >= mn.LOWER_A && r <= mn.LOWER_F;
}
function _E(r) {
  return r >= mn.UPPER_A && r <= mn.UPPER_Z || r >= mn.LOWER_A && r <= mn.LOWER_Z || Qg(r);
}
function yE(r) {
  return r === mn.EQUALS || _E(r);
}
var pn;
(function(r) {
  r[r.EntityStart = 0] = "EntityStart", r[r.NumericStart = 1] = "NumericStart", r[r.NumericDecimal = 2] = "NumericDecimal", r[r.NumericHex = 3] = "NumericHex", r[r.NamedEntity = 4] = "NamedEntity";
})(pn || (pn = {}));
var zs;
(function(r) {
  r[r.Legacy = 0] = "Legacy", r[r.Strict = 1] = "Strict", r[r.Attribute = 2] = "Attribute";
})(zs || (zs = {}));
class bE {
  constructor(i, l, d) {
    this.decodeTree = i, this.emitCodePoint = l, this.errors = d, this.state = pn.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = zs.Strict;
  }
  startEntity(i) {
    this.decodeMode = i, this.state = pn.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  write(i, l) {
    switch (this.state) {
      case pn.EntityStart:
        return i.charCodeAt(l) === mn.NUM ? (this.state = pn.NumericStart, this.consumed += 1, this.stateNumericStart(i, l + 1)) : (this.state = pn.NamedEntity, this.stateNamedEntity(i, l));
      case pn.NumericStart:
        return this.stateNumericStart(i, l);
      case pn.NumericDecimal:
        return this.stateNumericDecimal(i, l);
      case pn.NumericHex:
        return this.stateNumericHex(i, l);
      case pn.NamedEntity:
        return this.stateNamedEntity(i, l);
    }
  }
  stateNumericStart(i, l) {
    return l >= i.length ? -1 : (i.charCodeAt(l) | gE) === mn.LOWER_X ? (this.state = pn.NumericHex, this.consumed += 1, this.stateNumericHex(i, l + 1)) : (this.state = pn.NumericDecimal, this.stateNumericDecimal(i, l));
  }
  addToNumericResult(i, l, d, f) {
    if (l !== d) {
      const g = d - l;
      this.result = this.result * Math.pow(f, g) + parseInt(i.substr(l, g), f), this.consumed += g;
    }
  }
  stateNumericHex(i, l) {
    const d = l;
    for (; l < i.length; ) {
      const f = i.charCodeAt(l);
      if (Qg(f) || vE(f)) l += 1;
      else return this.addToNumericResult(i, d, l, 16), this.emitNumericEntity(f, 3);
    }
    return this.addToNumericResult(i, d, l, 16), -1;
  }
  stateNumericDecimal(i, l) {
    const d = l;
    for (; l < i.length; ) {
      const f = i.charCodeAt(l);
      if (Qg(f)) l += 1;
      else return this.addToNumericResult(i, d, l, 10), this.emitNumericEntity(f, 2);
    }
    return this.addToNumericResult(i, d, l, 10), -1;
  }
  emitNumericEntity(i, l) {
    var d;
    if (this.consumed <= l) return (d = this.errors) === null || d === void 0 || d.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (i === mn.SEMI) this.consumed += 1;
    else if (this.decodeMode === zs.Strict) return 0;
    return this.emitCodePoint(mE(this.result), this.consumed), this.errors && (i !== mn.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  stateNamedEntity(i, l) {
    const { decodeTree: d } = this;
    let f = d[this.treeIndex], g = (f & Ls.VALUE_LENGTH) >> 14;
    for (; l < i.length; l++, this.excess++) {
      const p = i.charCodeAt(l);
      if (this.treeIndex = xE(d, f, this.treeIndex + Math.max(1, g), p), this.treeIndex < 0) return this.result === 0 || this.decodeMode === zs.Attribute && (g === 0 || yE(p)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (f = d[this.treeIndex], g = (f & Ls.VALUE_LENGTH) >> 14, g !== 0) {
        if (p === mn.SEMI) return this.emitNamedEntityData(this.treeIndex, g, this.consumed + this.excess);
        this.decodeMode !== zs.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  emitNotTerminatedNamedEntity() {
    var i;
    const { result: l, decodeTree: d } = this, f = (d[l] & Ls.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(l, f, this.consumed), (i = this.errors) === null || i === void 0 || i.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  emitNamedEntityData(i, l, d) {
    const { decodeTree: f } = this;
    return this.emitCodePoint(l === 1 ? f[i] & ~Ls.VALUE_LENGTH : f[i + 1], d), l === 3 && this.emitCodePoint(f[i + 2], d), d;
  }
  end() {
    var i;
    switch (this.state) {
      case pn.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== zs.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case pn.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case pn.NumericHex:
        return this.emitNumericEntity(0, 3);
      case pn.NumericStart:
        return (i = this.errors) === null || i === void 0 || i.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case pn.EntityStart:
        return 0;
    }
  }
}
function Z1(r) {
  let i = "";
  const l = new bE(r, (d) => i += pE(d));
  return function(f, g) {
    let p = 0, s = 0;
    for (; (s = f.indexOf("&", s)) >= 0; ) {
      i += f.slice(p, s), l.startEntity(g);
      const P = l.write(f, s + 1);
      if (P < 0) {
        p = s + l.end();
        break;
      }
      p = s + P, s = P === 0 ? p + 1 : p;
    }
    const C = i + f.slice(p);
    return i = "", C;
  };
}
function xE(r, i, l, d) {
  const f = (i & Ls.BRANCH_LENGTH) >> 7, g = i & Ls.JUMP_TABLE;
  if (f === 0) return g !== 0 && d === g ? l : -1;
  if (g) {
    const C = d - g;
    return C < 0 || C >= f ? -1 : r[l + C] - 1;
  }
  let p = l, s = p + f - 1;
  for (; p <= s; ) {
    const C = p + s >>> 1, P = r[C];
    if (P < d) p = C + 1;
    else if (P > d) s = C - 1;
    else return r[C + f];
  }
  return -1;
}
const wE = Z1(dE);
Z1(hE);
function H1(r, i = zs.Legacy) {
  return wE(r, i);
}
function CE(r) {
  return Object.prototype.toString.call(r);
}
function S0(r) {
  return CE(r) === "[object String]";
}
const SE = Object.prototype.hasOwnProperty;
function kE(r, i) {
  return SE.call(r, i);
}
function Bp(r) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(l) {
    if (l) {
      if (typeof l != "object") throw new TypeError(l + "must be object");
      Object.keys(l).forEach(function(d) {
        r[d] = l[d];
      });
    }
  }), r;
}
function X1(r, i, l) {
  return [].concat(r.slice(0, i), l, r.slice(i + 1));
}
function k0(r) {
  return !(r >= 55296 && r <= 57343 || r >= 64976 && r <= 65007 || (r & 65535) === 65535 || (r & 65535) === 65534 || r >= 0 && r <= 8 || r === 11 || r >= 14 && r <= 31 || r >= 127 && r <= 159 || r > 1114111);
}
function vp(r) {
  if (r > 65535) {
    r -= 65536;
    const i = 55296 + (r >> 10), l = 56320 + (r & 1023);
    return String.fromCharCode(i, l);
  }
  return String.fromCharCode(r);
}
const Y1 = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g, PE = /&([a-z#][a-z0-9]{1,31});/gi, TE = new RegExp(Y1.source + "|" + PE.source, "gi"), IE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function ME(r, i) {
  if (i.charCodeAt(0) === 35 && IE.test(i)) {
    const d = i[1].toLowerCase() === "x" ? parseInt(i.slice(2), 16) : parseInt(i.slice(1), 10);
    return k0(d) ? vp(d) : r;
  }
  const l = H1(r);
  return l !== r ? l : r;
}
function EE(r) {
  return r.indexOf("\\") < 0 ? r : r.replace(Y1, "$1");
}
function vc(r) {
  return r.indexOf("\\") < 0 && r.indexOf("&") < 0 ? r : r.replace(TE, function(i, l, d) {
    return l || ME(i, d);
  });
}
const RE = /[&<>"]/, AE = /[&<>"]/g, DE = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" };
function zE(r) {
  return DE[r];
}
function js(r) {
  return RE.test(r) ? r.replace(AE, zE) : r;
}
const FE = /[.?*+^$[\]\\(){}|-]/g;
function LE(r) {
  return r.replace(FE, "\\$&");
}
function _i(r) {
  switch (r) {
    case 9:
    case 32:
      return true;
  }
  return false;
}
function nh(r) {
  if (r >= 8192 && r <= 8202) return true;
  switch (r) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return true;
  }
  return false;
}
function oh(r) {
  return C0.test(r) || q1.test(r);
}
function ah(r) {
  switch (r) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function Op(r) {
  return r = r.trim().replace(/\s+/g, " "), "\u1E9E".toLowerCase() === "\u1E7E" && (r = r.replace(//g, "\xDF")), r.toLowerCase().toUpperCase();
}
const BE = { mdurl: lE, ucmicro: cE }, OE = Object.freeze(Object.defineProperty({ __proto__: null, arrayReplaceAt: X1, assign: Bp, escapeHtml: js, escapeRE: LE, fromCodePoint: vp, has: kE, isMdAsciiPunct: ah, isPunctChar: oh, isSpace: _i, isString: S0, isValidEntityCode: k0, isWhiteSpace: nh, lib: BE, normalizeReference: Op, unescapeAll: vc, unescapeMd: EE }, Symbol.toStringTag, { value: "Module" }));
function $E(r, i, l) {
  let d, f, g, p;
  const s = r.posMax, C = r.pos;
  for (r.pos = i + 1, d = 1; r.pos < s; ) {
    if (g = r.src.charCodeAt(r.pos), g === 93 && (d--, d === 0)) {
      f = true;
      break;
    }
    if (p = r.pos, r.md.inline.skipToken(r), g === 91) {
      if (p === r.pos - 1) d++;
      else if (l) return r.pos = C, -1;
    }
  }
  let P = -1;
  return f && (P = r.pos), r.pos = C, P;
}
function jE(r, i, l) {
  let d, f = i;
  const g = { ok: false, pos: 0, str: "" };
  if (r.charCodeAt(f) === 60) {
    for (f++; f < l; ) {
      if (d = r.charCodeAt(f), d === 10 || d === 60) return g;
      if (d === 62) return g.pos = f + 1, g.str = vc(r.slice(i + 1, f)), g.ok = true, g;
      if (d === 92 && f + 1 < l) {
        f += 2;
        continue;
      }
      f++;
    }
    return g;
  }
  let p = 0;
  for (; f < l && (d = r.charCodeAt(f), !(d === 32 || d < 32 || d === 127)); ) {
    if (d === 92 && f + 1 < l) {
      if (r.charCodeAt(f + 1) === 32) break;
      f += 2;
      continue;
    }
    if (d === 40 && (p++, p > 32)) return g;
    if (d === 41) {
      if (p === 0) break;
      p--;
    }
    f++;
  }
  return i === f || p !== 0 || (g.str = vc(r.slice(i, f)), g.pos = f, g.ok = true), g;
}
function NE(r, i, l, d) {
  let f, g = i;
  const p = { ok: false, can_continue: false, pos: 0, str: "", marker: 0 };
  if (d) p.str = d.str, p.marker = d.marker;
  else {
    if (g >= l) return p;
    let s = r.charCodeAt(g);
    if (s !== 34 && s !== 39 && s !== 40) return p;
    i++, g++, s === 40 && (s = 41), p.marker = s;
  }
  for (; g < l; ) {
    if (f = r.charCodeAt(g), f === p.marker) return p.pos = g + 1, p.str += vc(r.slice(i, g)), p.ok = true, p;
    if (f === 40 && p.marker === 41) return p;
    f === 92 && g + 1 < l && g++, g++;
  }
  return p.can_continue = true, p.str += vc(r.slice(i, g)), p;
}
const VE = Object.freeze(Object.defineProperty({ __proto__: null, parseLinkDestination: jE, parseLinkLabel: $E, parseLinkTitle: NE }, Symbol.toStringTag, { value: "Module" })), Pa = {};
Pa.code_inline = function(r, i, l, d, f) {
  const g = r[i];
  return "<code" + f.renderAttrs(g) + ">" + js(g.content) + "</code>";
};
Pa.code_block = function(r, i, l, d, f) {
  const g = r[i];
  return "<pre" + f.renderAttrs(g) + "><code>" + js(r[i].content) + `</code></pre>
`;
};
Pa.fence = function(r, i, l, d, f) {
  const g = r[i], p = g.info ? vc(g.info).trim() : "";
  let s = "", C = "";
  if (p) {
    const M = p.split(/(\s+)/g);
    s = M[0], C = M.slice(2).join("");
  }
  let P;
  if (l.highlight ? P = l.highlight(g.content, s, C) || js(g.content) : P = js(g.content), P.indexOf("<pre") === 0) return P + `
`;
  if (p) {
    const M = g.attrIndex("class"), D = g.attrs ? g.attrs.slice() : [];
    M < 0 ? D.push(["class", l.langPrefix + s]) : (D[M] = D[M].slice(), D[M][1] += " " + l.langPrefix + s);
    const L = { attrs: D };
    return `<pre><code${f.renderAttrs(L)}>${P}</code></pre>
`;
  }
  return `<pre><code${f.renderAttrs(g)}>${P}</code></pre>
`;
};
Pa.image = function(r, i, l, d, f) {
  const g = r[i];
  return g.attrs[g.attrIndex("alt")][1] = f.renderInlineAsText(g.children, l, d), f.renderToken(r, i, l);
};
Pa.hardbreak = function(r, i, l) {
  return l.xhtmlOut ? `<br />
` : `<br>
`;
};
Pa.softbreak = function(r, i, l) {
  return l.breaks ? l.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
Pa.text = function(r, i) {
  return js(r[i].content);
};
Pa.html_block = function(r, i) {
  return r[i].content;
};
Pa.html_inline = function(r, i) {
  return r[i].content;
};
function wc() {
  this.rules = Bp({}, Pa);
}
wc.prototype.renderAttrs = function(i) {
  let l, d, f;
  if (!i.attrs) return "";
  for (f = "", l = 0, d = i.attrs.length; l < d; l++) f += " " + js(i.attrs[l][0]) + '="' + js(i.attrs[l][1]) + '"';
  return f;
};
wc.prototype.renderToken = function(i, l, d) {
  const f = i[l];
  let g = "";
  if (f.hidden) return "";
  f.block && f.nesting !== -1 && l && i[l - 1].hidden && (g += `
`), g += (f.nesting === -1 ? "</" : "<") + f.tag, g += this.renderAttrs(f), f.nesting === 0 && d.xhtmlOut && (g += " /");
  let p = false;
  if (f.block && (p = true, f.nesting === 1 && l + 1 < i.length)) {
    const s = i[l + 1];
    (s.type === "inline" || s.hidden || s.nesting === -1 && s.tag === f.tag) && (p = false);
  }
  return g += p ? `>
` : ">", g;
};
wc.prototype.renderInline = function(r, i, l) {
  let d = "";
  const f = this.rules;
  for (let g = 0, p = r.length; g < p; g++) {
    const s = r[g].type;
    typeof f[s] < "u" ? d += f[s](r, g, i, l, this) : d += this.renderToken(r, g, i);
  }
  return d;
};
wc.prototype.renderInlineAsText = function(r, i, l) {
  let d = "";
  for (let f = 0, g = r.length; f < g; f++) switch (r[f].type) {
    case "text":
      d += r[f].content;
      break;
    case "image":
      d += this.renderInlineAsText(r[f].children, i, l);
      break;
    case "html_inline":
    case "html_block":
      d += r[f].content;
      break;
    case "softbreak":
    case "hardbreak":
      d += `
`;
      break;
  }
  return d;
};
wc.prototype.render = function(r, i, l) {
  let d = "";
  const f = this.rules;
  for (let g = 0, p = r.length; g < p; g++) {
    const s = r[g].type;
    s === "inline" ? d += this.renderInline(r[g].children, i, l) : typeof f[s] < "u" ? d += f[s](r, g, i, l, this) : d += this.renderToken(r, g, i, l);
  }
  return d;
};
function ro() {
  this.__rules__ = [], this.__cache__ = null;
}
ro.prototype.__find__ = function(r) {
  for (let i = 0; i < this.__rules__.length; i++) if (this.__rules__[i].name === r) return i;
  return -1;
};
ro.prototype.__compile__ = function() {
  const r = this, i = [""];
  r.__rules__.forEach(function(l) {
    l.enabled && l.alt.forEach(function(d) {
      i.indexOf(d) < 0 && i.push(d);
    });
  }), r.__cache__ = {}, i.forEach(function(l) {
    r.__cache__[l] = [], r.__rules__.forEach(function(d) {
      d.enabled && (l && d.alt.indexOf(l) < 0 || r.__cache__[l].push(d.fn));
    });
  });
};
ro.prototype.at = function(r, i, l) {
  const d = this.__find__(r), f = l || {};
  if (d === -1) throw new Error("Parser rule not found: " + r);
  this.__rules__[d].fn = i, this.__rules__[d].alt = f.alt || [], this.__cache__ = null;
};
ro.prototype.before = function(r, i, l, d) {
  const f = this.__find__(r), g = d || {};
  if (f === -1) throw new Error("Parser rule not found: " + r);
  this.__rules__.splice(f, 0, { name: i, enabled: true, fn: l, alt: g.alt || [] }), this.__cache__ = null;
};
ro.prototype.after = function(r, i, l, d) {
  const f = this.__find__(r), g = d || {};
  if (f === -1) throw new Error("Parser rule not found: " + r);
  this.__rules__.splice(f + 1, 0, { name: i, enabled: true, fn: l, alt: g.alt || [] }), this.__cache__ = null;
};
ro.prototype.push = function(r, i, l) {
  const d = l || {};
  this.__rules__.push({ name: r, enabled: true, fn: i, alt: d.alt || [] }), this.__cache__ = null;
};
ro.prototype.enable = function(r, i) {
  Array.isArray(r) || (r = [r]);
  const l = [];
  return r.forEach(function(d) {
    const f = this.__find__(d);
    if (f < 0) {
      if (i) return;
      throw new Error("Rules manager: invalid rule name " + d);
    }
    this.__rules__[f].enabled = true, l.push(d);
  }, this), this.__cache__ = null, l;
};
ro.prototype.enableOnly = function(r, i) {
  Array.isArray(r) || (r = [r]), this.__rules__.forEach(function(l) {
    l.enabled = false;
  }), this.enable(r, i);
};
ro.prototype.disable = function(r, i) {
  Array.isArray(r) || (r = [r]);
  const l = [];
  return r.forEach(function(d) {
    const f = this.__find__(d);
    if (f < 0) {
      if (i) return;
      throw new Error("Rules manager: invalid rule name " + d);
    }
    this.__rules__[f].enabled = false, l.push(d);
  }, this), this.__cache__ = null, l;
};
ro.prototype.getRules = function(r) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[r] || [];
};
function ra(r, i, l) {
  this.type = r, this.tag = i, this.attrs = null, this.map = null, this.nesting = l, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = false, this.hidden = false;
}
ra.prototype.attrIndex = function(i) {
  if (!this.attrs) return -1;
  const l = this.attrs;
  for (let d = 0, f = l.length; d < f; d++) if (l[d][0] === i) return d;
  return -1;
};
ra.prototype.attrPush = function(i) {
  this.attrs ? this.attrs.push(i) : this.attrs = [i];
};
ra.prototype.attrSet = function(i, l) {
  const d = this.attrIndex(i), f = [i, l];
  d < 0 ? this.attrPush(f) : this.attrs[d] = f;
};
ra.prototype.attrGet = function(i) {
  const l = this.attrIndex(i);
  let d = null;
  return l >= 0 && (d = this.attrs[l][1]), d;
};
ra.prototype.attrJoin = function(i, l) {
  const d = this.attrIndex(i);
  d < 0 ? this.attrPush([i, l]) : this.attrs[d][1] = this.attrs[d][1] + " " + l;
};
function K1(r, i, l) {
  this.src = r, this.env = l, this.tokens = [], this.inlineMode = false, this.md = i;
}
K1.prototype.Token = ra;
const UE = /\r\n?|\n/g, GE = /\0/g;
function qE(r) {
  let i;
  i = r.src.replace(UE, `
`), i = i.replace(GE, "\uFFFD"), r.src = i;
}
function WE(r) {
  let i;
  r.inlineMode ? (i = new r.Token("inline", "", 0), i.content = r.src, i.map = [0, 1], i.children = [], r.tokens.push(i)) : r.md.block.parse(r.src, r.md, r.env, r.tokens);
}
function ZE(r) {
  const i = r.tokens;
  for (let l = 0, d = i.length; l < d; l++) {
    const f = i[l];
    f.type === "inline" && r.md.inline.parse(f.content, r.md, r.env, f.children);
  }
}
function HE(r) {
  return /^<a[>\s]/i.test(r);
}
function XE(r) {
  return /^<\/a\s*>/i.test(r);
}
function YE(r) {
  const i = r.tokens;
  if (r.md.options.linkify) for (let l = 0, d = i.length; l < d; l++) {
    if (i[l].type !== "inline" || !r.md.linkify.pretest(i[l].content)) continue;
    let f = i[l].children, g = 0;
    for (let p = f.length - 1; p >= 0; p--) {
      const s = f[p];
      if (s.type === "link_close") {
        for (p--; f[p].level !== s.level && f[p].type !== "link_open"; ) p--;
        continue;
      }
      if (s.type === "html_inline" && (HE(s.content) && g > 0 && g--, XE(s.content) && g++), !(g > 0) && s.type === "text" && r.md.linkify.test(s.content)) {
        const C = s.content;
        let P = r.md.linkify.match(C);
        const M = [];
        let D = s.level, L = 0;
        P.length > 0 && P[0].index === 0 && p > 0 && f[p - 1].type === "text_special" && (P = P.slice(1));
        for (let $ = 0; $ < P.length; $++) {
          const z = P[$].url, F = r.md.normalizeLink(z);
          if (!r.md.validateLink(F)) continue;
          let Z = P[$].text;
          P[$].schema ? P[$].schema === "mailto:" && !/^mailto:/i.test(Z) ? Z = r.md.normalizeLinkText("mailto:" + Z).replace(/^mailto:/, "") : Z = r.md.normalizeLinkText(Z) : Z = r.md.normalizeLinkText("http://" + Z).replace(/^http:\/\//, "");
          const q = P[$].index;
          if (q > L) {
            const ie = new r.Token("text", "", 0);
            ie.content = C.slice(L, q), ie.level = D, M.push(ie);
          }
          const K = new r.Token("link_open", "a", 1);
          K.attrs = [["href", F]], K.level = D++, K.markup = "linkify", K.info = "auto", M.push(K);
          const te = new r.Token("text", "", 0);
          te.content = Z, te.level = D, M.push(te);
          const re = new r.Token("link_close", "a", -1);
          re.level = --D, re.markup = "linkify", re.info = "auto", M.push(re), L = P[$].lastIndex;
        }
        if (L < C.length) {
          const $ = new r.Token("text", "", 0);
          $.content = C.slice(L), $.level = D, M.push($);
        }
        i[l].children = f = X1(f, p, M);
      }
    }
  }
}
const J1 = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, KE = /\((c|tm|r)\)/i, JE = /\((c|tm|r)\)/ig, QE = { c: "\xA9", r: "\xAE", tm: "\u2122" };
function eR(r, i) {
  return QE[i.toLowerCase()];
}
function tR(r) {
  let i = 0;
  for (let l = r.length - 1; l >= 0; l--) {
    const d = r[l];
    d.type === "text" && !i && (d.content = d.content.replace(JE, eR)), d.type === "link_open" && d.info === "auto" && i--, d.type === "link_close" && d.info === "auto" && i++;
  }
}
function rR(r) {
  let i = 0;
  for (let l = r.length - 1; l >= 0; l--) {
    const d = r[l];
    d.type === "text" && !i && J1.test(d.content) && (d.content = d.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013")), d.type === "link_open" && d.info === "auto" && i--, d.type === "link_close" && d.info === "auto" && i++;
  }
}
function iR(r) {
  let i;
  if (r.md.options.typographer) for (i = r.tokens.length - 1; i >= 0; i--) r.tokens[i].type === "inline" && (KE.test(r.tokens[i].content) && tR(r.tokens[i].children), J1.test(r.tokens[i].content) && rR(r.tokens[i].children));
}
const nR = /['"]/, Sy = /['"]/g, ky = "\u2019";
function Jf(r, i, l) {
  return r.slice(0, i) + l + r.slice(i + 1);
}
function oR(r, i) {
  let l;
  const d = [];
  for (let f = 0; f < r.length; f++) {
    const g = r[f], p = r[f].level;
    for (l = d.length - 1; l >= 0 && !(d[l].level <= p); l--) ;
    if (d.length = l + 1, g.type !== "text") continue;
    let s = g.content, C = 0, P = s.length;
    e: for (; C < P; ) {
      Sy.lastIndex = C;
      const M = Sy.exec(s);
      if (!M) break;
      let D = true, L = true;
      C = M.index + 1;
      const $ = M[0] === "'";
      let z = 32;
      if (M.index - 1 >= 0) z = s.charCodeAt(M.index - 1);
      else for (l = f - 1; l >= 0 && !(r[l].type === "softbreak" || r[l].type === "hardbreak"); l--) if (r[l].content) {
        z = r[l].content.charCodeAt(r[l].content.length - 1);
        break;
      }
      let F = 32;
      if (C < P) F = s.charCodeAt(C);
      else for (l = f + 1; l < r.length && !(r[l].type === "softbreak" || r[l].type === "hardbreak"); l++) if (r[l].content) {
        F = r[l].content.charCodeAt(0);
        break;
      }
      const Z = ah(z) || oh(String.fromCharCode(z)), q = ah(F) || oh(String.fromCharCode(F)), K = nh(z), te = nh(F);
      if (te ? D = false : q && (K || Z || (D = false)), K ? L = false : Z && (te || q || (L = false)), F === 34 && M[0] === '"' && z >= 48 && z <= 57 && (L = D = false), D && L && (D = Z, L = q), !D && !L) {
        $ && (g.content = Jf(g.content, M.index, ky));
        continue;
      }
      if (L) for (l = d.length - 1; l >= 0; l--) {
        let re = d[l];
        if (d[l].level < p) break;
        if (re.single === $ && d[l].level === p) {
          re = d[l];
          let ie, J;
          $ ? (ie = i.md.options.quotes[2], J = i.md.options.quotes[3]) : (ie = i.md.options.quotes[0], J = i.md.options.quotes[1]), g.content = Jf(g.content, M.index, J), r[re.token].content = Jf(r[re.token].content, re.pos, ie), C += J.length - 1, re.token === f && (C += ie.length - 1), s = g.content, P = s.length, d.length = l;
          continue e;
        }
      }
      D ? d.push({ token: f, pos: M.index, single: $, level: p }) : L && $ && (g.content = Jf(g.content, M.index, ky));
    }
  }
}
function aR(r) {
  if (r.md.options.typographer) for (let i = r.tokens.length - 1; i >= 0; i--) r.tokens[i].type !== "inline" || !nR.test(r.tokens[i].content) || oR(r.tokens[i].children, r);
}
function sR(r) {
  let i, l;
  const d = r.tokens, f = d.length;
  for (let g = 0; g < f; g++) {
    if (d[g].type !== "inline") continue;
    const p = d[g].children, s = p.length;
    for (i = 0; i < s; i++) p[i].type === "text_special" && (p[i].type = "text");
    for (i = l = 0; i < s; i++) p[i].type === "text" && i + 1 < s && p[i + 1].type === "text" ? p[i + 1].content = p[i].content + p[i + 1].content : (i !== l && (p[l] = p[i]), l++);
    i !== l && (p.length = l);
  }
}
const _g = [["normalize", qE], ["block", WE], ["inline", ZE], ["linkify", YE], ["replacements", iR], ["smartquotes", aR], ["text_join", sR]];
function P0() {
  this.ruler = new ro();
  for (let r = 0; r < _g.length; r++) this.ruler.push(_g[r][0], _g[r][1]);
}
P0.prototype.process = function(r) {
  const i = this.ruler.getRules("");
  for (let l = 0, d = i.length; l < d; l++) i[l](r);
};
P0.prototype.State = K1;
function Ta(r, i, l, d) {
  this.src = r, this.md = i, this.env = l, this.tokens = d, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = false, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0;
  const f = this.src;
  for (let g = 0, p = 0, s = 0, C = 0, P = f.length, M = false; p < P; p++) {
    const D = f.charCodeAt(p);
    if (!M) if (_i(D)) {
      s++, D === 9 ? C += 4 - C % 4 : C++;
      continue;
    } else M = true;
    (D === 10 || p === P - 1) && (D !== 10 && p++, this.bMarks.push(g), this.eMarks.push(p), this.tShift.push(s), this.sCount.push(C), this.bsCount.push(0), M = false, s = 0, C = 0, g = p + 1);
  }
  this.bMarks.push(f.length), this.eMarks.push(f.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
Ta.prototype.push = function(r, i, l) {
  const d = new ra(r, i, l);
  return d.block = true, l < 0 && this.level--, d.level = this.level, l > 0 && this.level++, this.tokens.push(d), d;
};
Ta.prototype.isEmpty = function(i) {
  return this.bMarks[i] + this.tShift[i] >= this.eMarks[i];
};
Ta.prototype.skipEmptyLines = function(i) {
  for (let l = this.lineMax; i < l && !(this.bMarks[i] + this.tShift[i] < this.eMarks[i]); i++) ;
  return i;
};
Ta.prototype.skipSpaces = function(i) {
  for (let l = this.src.length; i < l; i++) {
    const d = this.src.charCodeAt(i);
    if (!_i(d)) break;
  }
  return i;
};
Ta.prototype.skipSpacesBack = function(i, l) {
  if (i <= l) return i;
  for (; i > l; ) if (!_i(this.src.charCodeAt(--i))) return i + 1;
  return i;
};
Ta.prototype.skipChars = function(i, l) {
  for (let d = this.src.length; i < d && this.src.charCodeAt(i) === l; i++) ;
  return i;
};
Ta.prototype.skipCharsBack = function(i, l, d) {
  if (i <= d) return i;
  for (; i > d; ) if (l !== this.src.charCodeAt(--i)) return i + 1;
  return i;
};
Ta.prototype.getLines = function(i, l, d, f) {
  if (i >= l) return "";
  const g = new Array(l - i);
  for (let p = 0, s = i; s < l; s++, p++) {
    let C = 0;
    const P = this.bMarks[s];
    let M = P, D;
    for (s + 1 < l || f ? D = this.eMarks[s] + 1 : D = this.eMarks[s]; M < D && C < d; ) {
      const L = this.src.charCodeAt(M);
      if (_i(L)) L === 9 ? C += 4 - (C + this.bsCount[s]) % 4 : C++;
      else if (M - P < this.tShift[s]) C++;
      else break;
      M++;
    }
    C > d ? g[p] = new Array(C - d + 1).join(" ") + this.src.slice(M, D) : g[p] = this.src.slice(M, D);
  }
  return g.join("");
};
Ta.prototype.Token = ra;
const lR = 65536;
function yg(r, i) {
  const l = r.bMarks[i] + r.tShift[i], d = r.eMarks[i];
  return r.src.slice(l, d);
}
function Py(r) {
  const i = [], l = r.length;
  let d = 0, f = r.charCodeAt(d), g = false, p = 0, s = "";
  for (; d < l; ) f === 124 && (g ? (s += r.substring(p, d - 1), p = d) : (i.push(s + r.substring(p, d)), s = "", p = d + 1)), g = f === 92, d++, f = r.charCodeAt(d);
  return i.push(s + r.substring(p)), i;
}
function uR(r, i, l, d) {
  if (i + 2 > l) return false;
  let f = i + 1;
  if (r.sCount[f] < r.blkIndent || r.sCount[f] - r.blkIndent >= 4) return false;
  let g = r.bMarks[f] + r.tShift[f];
  if (g >= r.eMarks[f]) return false;
  const p = r.src.charCodeAt(g++);
  if (p !== 124 && p !== 45 && p !== 58 || g >= r.eMarks[f]) return false;
  const s = r.src.charCodeAt(g++);
  if (s !== 124 && s !== 45 && s !== 58 && !_i(s) || p === 45 && _i(s)) return false;
  for (; g < r.eMarks[f]; ) {
    const re = r.src.charCodeAt(g);
    if (re !== 124 && re !== 45 && re !== 58 && !_i(re)) return false;
    g++;
  }
  let C = yg(r, i + 1), P = C.split("|");
  const M = [];
  for (let re = 0; re < P.length; re++) {
    const ie = P[re].trim();
    if (!ie) {
      if (re === 0 || re === P.length - 1) continue;
      return false;
    }
    if (!/^:?-+:?$/.test(ie)) return false;
    ie.charCodeAt(ie.length - 1) === 58 ? M.push(ie.charCodeAt(0) === 58 ? "center" : "right") : ie.charCodeAt(0) === 58 ? M.push("left") : M.push("");
  }
  if (C = yg(r, i).trim(), C.indexOf("|") === -1 || r.sCount[i] - r.blkIndent >= 4) return false;
  P = Py(C), P.length && P[0] === "" && P.shift(), P.length && P[P.length - 1] === "" && P.pop();
  const D = P.length;
  if (D === 0 || D !== M.length) return false;
  if (d) return true;
  const L = r.parentType;
  r.parentType = "table";
  const $ = r.md.block.ruler.getRules("blockquote"), z = r.push("table_open", "table", 1), F = [i, 0];
  z.map = F;
  const Z = r.push("thead_open", "thead", 1);
  Z.map = [i, i + 1];
  const q = r.push("tr_open", "tr", 1);
  q.map = [i, i + 1];
  for (let re = 0; re < P.length; re++) {
    const ie = r.push("th_open", "th", 1);
    M[re] && (ie.attrs = [["style", "text-align:" + M[re]]]);
    const J = r.push("inline", "", 0);
    J.content = P[re].trim(), J.children = [], r.push("th_close", "th", -1);
  }
  r.push("tr_close", "tr", -1), r.push("thead_close", "thead", -1);
  let K, te = 0;
  for (f = i + 2; f < l && !(r.sCount[f] < r.blkIndent); f++) {
    let re = false;
    for (let J = 0, we = $.length; J < we; J++) if ($[J](r, f, l, true)) {
      re = true;
      break;
    }
    if (re || (C = yg(r, f).trim(), !C) || r.sCount[f] - r.blkIndent >= 4 || (P = Py(C), P.length && P[0] === "" && P.shift(), P.length && P[P.length - 1] === "" && P.pop(), te += D - P.length, te > lR)) break;
    if (f === i + 2) {
      const J = r.push("tbody_open", "tbody", 1);
      J.map = K = [i + 2, 0];
    }
    const ie = r.push("tr_open", "tr", 1);
    ie.map = [f, f + 1];
    for (let J = 0; J < D; J++) {
      const we = r.push("td_open", "td", 1);
      M[J] && (we.attrs = [["style", "text-align:" + M[J]]]);
      const fe = r.push("inline", "", 0);
      fe.content = P[J] ? P[J].trim() : "", fe.children = [], r.push("td_close", "td", -1);
    }
    r.push("tr_close", "tr", -1);
  }
  return K && (r.push("tbody_close", "tbody", -1), K[1] = f), r.push("table_close", "table", -1), F[1] = f, r.parentType = L, r.line = f, true;
}
function cR(r, i, l) {
  if (r.sCount[i] - r.blkIndent < 4) return false;
  let d = i + 1, f = d;
  for (; d < l; ) {
    if (r.isEmpty(d)) {
      d++;
      continue;
    }
    if (r.sCount[d] - r.blkIndent >= 4) {
      d++, f = d;
      continue;
    }
    break;
  }
  r.line = f;
  const g = r.push("code_block", "code", 0);
  return g.content = r.getLines(i, f, 4 + r.blkIndent, false) + `
`, g.map = [i, r.line], true;
}
function dR(r, i, l, d) {
  let f = r.bMarks[i] + r.tShift[i], g = r.eMarks[i];
  if (r.sCount[i] - r.blkIndent >= 4 || f + 3 > g) return false;
  const p = r.src.charCodeAt(f);
  if (p !== 126 && p !== 96) return false;
  let s = f;
  f = r.skipChars(f, p);
  let C = f - s;
  if (C < 3) return false;
  const P = r.src.slice(s, f), M = r.src.slice(f, g);
  if (p === 96 && M.indexOf(String.fromCharCode(p)) >= 0) return false;
  if (d) return true;
  let D = i, L = false;
  for (; D++, !(D >= l || (f = s = r.bMarks[D] + r.tShift[D], g = r.eMarks[D], f < g && r.sCount[D] < r.blkIndent)); ) if (r.src.charCodeAt(f) === p && !(r.sCount[D] - r.blkIndent >= 4) && (f = r.skipChars(f, p), !(f - s < C) && (f = r.skipSpaces(f), !(f < g)))) {
    L = true;
    break;
  }
  C = r.sCount[i], r.line = D + (L ? 1 : 0);
  const $ = r.push("fence", "code", 0);
  return $.info = M, $.content = r.getLines(i + 1, D, C, true), $.markup = P, $.map = [i, r.line], true;
}
function hR(r, i, l, d) {
  let f = r.bMarks[i] + r.tShift[i], g = r.eMarks[i];
  const p = r.lineMax;
  if (r.sCount[i] - r.blkIndent >= 4 || r.src.charCodeAt(f) !== 62) return false;
  if (d) return true;
  const s = [], C = [], P = [], M = [], D = r.md.block.ruler.getRules("blockquote"), L = r.parentType;
  r.parentType = "blockquote";
  let $ = false, z;
  for (z = i; z < l; z++) {
    const te = r.sCount[z] < r.blkIndent;
    if (f = r.bMarks[z] + r.tShift[z], g = r.eMarks[z], f >= g) break;
    if (r.src.charCodeAt(f++) === 62 && !te) {
      let ie = r.sCount[z] + 1, J, we;
      r.src.charCodeAt(f) === 32 ? (f++, ie++, we = false, J = true) : r.src.charCodeAt(f) === 9 ? (J = true, (r.bsCount[z] + ie) % 4 === 3 ? (f++, ie++, we = false) : we = true) : J = false;
      let fe = ie;
      for (s.push(r.bMarks[z]), r.bMarks[z] = f; f < g; ) {
        const oe = r.src.charCodeAt(f);
        if (_i(oe)) oe === 9 ? fe += 4 - (fe + r.bsCount[z] + (we ? 1 : 0)) % 4 : fe++;
        else break;
        f++;
      }
      $ = f >= g, C.push(r.bsCount[z]), r.bsCount[z] = r.sCount[z] + 1 + (J ? 1 : 0), P.push(r.sCount[z]), r.sCount[z] = fe - ie, M.push(r.tShift[z]), r.tShift[z] = f - r.bMarks[z];
      continue;
    }
    if ($) break;
    let re = false;
    for (let ie = 0, J = D.length; ie < J; ie++) if (D[ie](r, z, l, true)) {
      re = true;
      break;
    }
    if (re) {
      r.lineMax = z, r.blkIndent !== 0 && (s.push(r.bMarks[z]), C.push(r.bsCount[z]), M.push(r.tShift[z]), P.push(r.sCount[z]), r.sCount[z] -= r.blkIndent);
      break;
    }
    s.push(r.bMarks[z]), C.push(r.bsCount[z]), M.push(r.tShift[z]), P.push(r.sCount[z]), r.sCount[z] = -1;
  }
  const F = r.blkIndent;
  r.blkIndent = 0;
  const Z = r.push("blockquote_open", "blockquote", 1);
  Z.markup = ">";
  const q = [i, 0];
  Z.map = q, r.md.block.tokenize(r, i, z);
  const K = r.push("blockquote_close", "blockquote", -1);
  K.markup = ">", r.lineMax = p, r.parentType = L, q[1] = r.line;
  for (let te = 0; te < M.length; te++) r.bMarks[te + i] = s[te], r.tShift[te + i] = M[te], r.sCount[te + i] = P[te], r.bsCount[te + i] = C[te];
  return r.blkIndent = F, true;
}
function fR(r, i, l, d) {
  const f = r.eMarks[i];
  if (r.sCount[i] - r.blkIndent >= 4) return false;
  let g = r.bMarks[i] + r.tShift[i];
  const p = r.src.charCodeAt(g++);
  if (p !== 42 && p !== 45 && p !== 95) return false;
  let s = 1;
  for (; g < f; ) {
    const P = r.src.charCodeAt(g++);
    if (P !== p && !_i(P)) return false;
    P === p && s++;
  }
  if (s < 3) return false;
  if (d) return true;
  r.line = i + 1;
  const C = r.push("hr", "hr", 0);
  return C.map = [i, r.line], C.markup = Array(s + 1).join(String.fromCharCode(p)), true;
}
function Ty(r, i) {
  const l = r.eMarks[i];
  let d = r.bMarks[i] + r.tShift[i];
  const f = r.src.charCodeAt(d++);
  if (f !== 42 && f !== 45 && f !== 43) return -1;
  if (d < l) {
    const g = r.src.charCodeAt(d);
    if (!_i(g)) return -1;
  }
  return d;
}
function Iy(r, i) {
  const l = r.bMarks[i] + r.tShift[i], d = r.eMarks[i];
  let f = l;
  if (f + 1 >= d) return -1;
  let g = r.src.charCodeAt(f++);
  if (g < 48 || g > 57) return -1;
  for (; ; ) {
    if (f >= d) return -1;
    if (g = r.src.charCodeAt(f++), g >= 48 && g <= 57) {
      if (f - l >= 10) return -1;
      continue;
    }
    if (g === 41 || g === 46) break;
    return -1;
  }
  return f < d && (g = r.src.charCodeAt(f), !_i(g)) ? -1 : f;
}
function pR(r, i) {
  const l = r.level + 2;
  for (let d = i + 2, f = r.tokens.length - 2; d < f; d++) r.tokens[d].level === l && r.tokens[d].type === "paragraph_open" && (r.tokens[d + 2].hidden = true, r.tokens[d].hidden = true, d += 2);
}
function mR(r, i, l, d) {
  let f, g, p, s, C = i, P = true;
  if (r.sCount[C] - r.blkIndent >= 4 || r.listIndent >= 0 && r.sCount[C] - r.listIndent >= 4 && r.sCount[C] < r.blkIndent) return false;
  let M = false;
  d && r.parentType === "paragraph" && r.sCount[C] >= r.blkIndent && (M = true);
  let D, L, $;
  if (($ = Iy(r, C)) >= 0) {
    if (D = true, p = r.bMarks[C] + r.tShift[C], L = Number(r.src.slice(p, $ - 1)), M && L !== 1) return false;
  } else if (($ = Ty(r, C)) >= 0) D = false;
  else return false;
  if (M && r.skipSpaces($) >= r.eMarks[C]) return false;
  if (d) return true;
  const z = r.src.charCodeAt($ - 1), F = r.tokens.length;
  D ? (s = r.push("ordered_list_open", "ol", 1), L !== 1 && (s.attrs = [["start", L]])) : s = r.push("bullet_list_open", "ul", 1);
  const Z = [C, 0];
  s.map = Z, s.markup = String.fromCharCode(z);
  let q = false;
  const K = r.md.block.ruler.getRules("list"), te = r.parentType;
  for (r.parentType = "list"; C < l; ) {
    g = $, f = r.eMarks[C];
    const re = r.sCount[C] + $ - (r.bMarks[C] + r.tShift[C]);
    let ie = re;
    for (; g < f; ) {
      const ut = r.src.charCodeAt(g);
      if (ut === 9) ie += 4 - (ie + r.bsCount[C]) % 4;
      else if (ut === 32) ie++;
      else break;
      g++;
    }
    const J = g;
    let we;
    J >= f ? we = 1 : we = ie - re, we > 4 && (we = 1);
    const fe = re + we;
    s = r.push("list_item_open", "li", 1), s.markup = String.fromCharCode(z);
    const oe = [C, 0];
    s.map = oe, D && (s.info = r.src.slice(p, $ - 1));
    const he = r.tight, _e = r.tShift[C], Ue = r.sCount[C], qe = r.listIndent;
    if (r.listIndent = r.blkIndent, r.blkIndent = fe, r.tight = true, r.tShift[C] = J - r.bMarks[C], r.sCount[C] = ie, J >= f && r.isEmpty(C + 1) ? r.line = Math.min(r.line + 2, l) : r.md.block.tokenize(r, C, l, true), (!r.tight || q) && (P = false), q = r.line - C > 1 && r.isEmpty(r.line - 1), r.blkIndent = r.listIndent, r.listIndent = qe, r.tShift[C] = _e, r.sCount[C] = Ue, r.tight = he, s = r.push("list_item_close", "li", -1), s.markup = String.fromCharCode(z), C = r.line, oe[1] = C, C >= l || r.sCount[C] < r.blkIndent || r.sCount[C] - r.blkIndent >= 4) break;
    let tt = false;
    for (let ut = 0, mt = K.length; ut < mt; ut++) if (K[ut](r, C, l, true)) {
      tt = true;
      break;
    }
    if (tt) break;
    if (D) {
      if ($ = Iy(r, C), $ < 0) break;
      p = r.bMarks[C] + r.tShift[C];
    } else if ($ = Ty(r, C), $ < 0) break;
    if (z !== r.src.charCodeAt($ - 1)) break;
  }
  return D ? s = r.push("ordered_list_close", "ol", -1) : s = r.push("bullet_list_close", "ul", -1), s.markup = String.fromCharCode(z), Z[1] = C, r.line = C, r.parentType = te, P && pR(r, F), true;
}
function gR(r, i, l, d) {
  let f = r.bMarks[i] + r.tShift[i], g = r.eMarks[i], p = i + 1;
  if (r.sCount[i] - r.blkIndent >= 4 || r.src.charCodeAt(f) !== 91) return false;
  function s(K) {
    const te = r.lineMax;
    if (K >= te || r.isEmpty(K)) return null;
    let re = false;
    if (r.sCount[K] - r.blkIndent > 3 && (re = true), r.sCount[K] < 0 && (re = true), !re) {
      const we = r.md.block.ruler.getRules("reference"), fe = r.parentType;
      r.parentType = "reference";
      let oe = false;
      for (let he = 0, _e = we.length; he < _e; he++) if (we[he](r, K, te, true)) {
        oe = true;
        break;
      }
      if (r.parentType = fe, oe) return null;
    }
    const ie = r.bMarks[K] + r.tShift[K], J = r.eMarks[K];
    return r.src.slice(ie, J + 1);
  }
  let C = r.src.slice(f, g + 1);
  g = C.length;
  let P = -1;
  for (f = 1; f < g; f++) {
    const K = C.charCodeAt(f);
    if (K === 91) return false;
    if (K === 93) {
      P = f;
      break;
    } else if (K === 10) {
      const te = s(p);
      te !== null && (C += te, g = C.length, p++);
    } else if (K === 92 && (f++, f < g && C.charCodeAt(f) === 10)) {
      const te = s(p);
      te !== null && (C += te, g = C.length, p++);
    }
  }
  if (P < 0 || C.charCodeAt(P + 1) !== 58) return false;
  for (f = P + 2; f < g; f++) {
    const K = C.charCodeAt(f);
    if (K === 10) {
      const te = s(p);
      te !== null && (C += te, g = C.length, p++);
    } else if (!_i(K)) break;
  }
  const M = r.md.helpers.parseLinkDestination(C, f, g);
  if (!M.ok) return false;
  const D = r.md.normalizeLink(M.str);
  if (!r.md.validateLink(D)) return false;
  f = M.pos;
  const L = f, $ = p, z = f;
  for (; f < g; f++) {
    const K = C.charCodeAt(f);
    if (K === 10) {
      const te = s(p);
      te !== null && (C += te, g = C.length, p++);
    } else if (!_i(K)) break;
  }
  let F = r.md.helpers.parseLinkTitle(C, f, g);
  for (; F.can_continue; ) {
    const K = s(p);
    if (K === null) break;
    C += K, f = g, g = C.length, p++, F = r.md.helpers.parseLinkTitle(C, f, g, F);
  }
  let Z;
  for (f < g && z !== f && F.ok ? (Z = F.str, f = F.pos) : (Z = "", f = L, p = $); f < g; ) {
    const K = C.charCodeAt(f);
    if (!_i(K)) break;
    f++;
  }
  if (f < g && C.charCodeAt(f) !== 10 && Z) for (Z = "", f = L, p = $; f < g; ) {
    const K = C.charCodeAt(f);
    if (!_i(K)) break;
    f++;
  }
  if (f < g && C.charCodeAt(f) !== 10) return false;
  const q = Op(C.slice(1, P));
  return q ? (d || (typeof r.env.references > "u" && (r.env.references = {}), typeof r.env.references[q] > "u" && (r.env.references[q] = { title: Z, href: D }), r.line = p), true) : false;
}
const vR = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"], _R = "[a-zA-Z_:][a-zA-Z0-9:._-]*", yR = "[^\"'=<>`\\x00-\\x20]+", bR = "'[^']*'", xR = '"[^"]*"', wR = "(?:" + yR + "|" + bR + "|" + xR + ")", CR = "(?:\\s+" + _R + "(?:\\s*=\\s*" + wR + ")?)", Q1 = "<[A-Za-z][A-Za-z0-9\\-]*" + CR + "*\\s*\\/?>", ex = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", SR = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->", kR = "<[?][\\s\\S]*?[?]>", PR = "<![A-Za-z][^>]*>", TR = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", IR = new RegExp("^(?:" + Q1 + "|" + ex + "|" + SR + "|" + kR + "|" + PR + "|" + TR + ")"), MR = new RegExp("^(?:" + Q1 + "|" + ex + ")"), oc = [[/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp("^</?(" + vR.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true], [new RegExp(MR.source + "\\s*$"), /^$/, false]];
function ER(r, i, l, d) {
  let f = r.bMarks[i] + r.tShift[i], g = r.eMarks[i];
  if (r.sCount[i] - r.blkIndent >= 4 || !r.md.options.html || r.src.charCodeAt(f) !== 60) return false;
  let p = r.src.slice(f, g), s = 0;
  for (; s < oc.length && !oc[s][0].test(p); s++) ;
  if (s === oc.length) return false;
  if (d) return oc[s][2];
  let C = i + 1;
  if (!oc[s][1].test(p)) {
    for (; C < l && !(r.sCount[C] < r.blkIndent); C++) if (f = r.bMarks[C] + r.tShift[C], g = r.eMarks[C], p = r.src.slice(f, g), oc[s][1].test(p)) {
      p.length !== 0 && C++;
      break;
    }
  }
  r.line = C;
  const P = r.push("html_block", "", 0);
  return P.map = [i, C], P.content = r.getLines(i, C, r.blkIndent, true), true;
}
function RR(r, i, l, d) {
  let f = r.bMarks[i] + r.tShift[i], g = r.eMarks[i];
  if (r.sCount[i] - r.blkIndent >= 4) return false;
  let p = r.src.charCodeAt(f);
  if (p !== 35 || f >= g) return false;
  let s = 1;
  for (p = r.src.charCodeAt(++f); p === 35 && f < g && s <= 6; ) s++, p = r.src.charCodeAt(++f);
  if (s > 6 || f < g && !_i(p)) return false;
  if (d) return true;
  g = r.skipSpacesBack(g, f);
  const C = r.skipCharsBack(g, 35, f);
  C > f && _i(r.src.charCodeAt(C - 1)) && (g = C), r.line = i + 1;
  const P = r.push("heading_open", "h" + String(s), 1);
  P.markup = "########".slice(0, s), P.map = [i, r.line];
  const M = r.push("inline", "", 0);
  M.content = r.src.slice(f, g).trim(), M.map = [i, r.line], M.children = [];
  const D = r.push("heading_close", "h" + String(s), -1);
  return D.markup = "########".slice(0, s), true;
}
function AR(r, i, l) {
  const d = r.md.block.ruler.getRules("paragraph");
  if (r.sCount[i] - r.blkIndent >= 4) return false;
  const f = r.parentType;
  r.parentType = "paragraph";
  let g = 0, p, s = i + 1;
  for (; s < l && !r.isEmpty(s); s++) {
    if (r.sCount[s] - r.blkIndent > 3) continue;
    if (r.sCount[s] >= r.blkIndent) {
      let $ = r.bMarks[s] + r.tShift[s];
      const z = r.eMarks[s];
      if ($ < z && (p = r.src.charCodeAt($), (p === 45 || p === 61) && ($ = r.skipChars($, p), $ = r.skipSpaces($), $ >= z))) {
        g = p === 61 ? 1 : 2;
        break;
      }
    }
    if (r.sCount[s] < 0) continue;
    let L = false;
    for (let $ = 0, z = d.length; $ < z; $++) if (d[$](r, s, l, true)) {
      L = true;
      break;
    }
    if (L) break;
  }
  if (!g) return false;
  const C = r.getLines(i, s, r.blkIndent, false).trim();
  r.line = s + 1;
  const P = r.push("heading_open", "h" + String(g), 1);
  P.markup = String.fromCharCode(p), P.map = [i, r.line];
  const M = r.push("inline", "", 0);
  M.content = C, M.map = [i, r.line - 1], M.children = [];
  const D = r.push("heading_close", "h" + String(g), -1);
  return D.markup = String.fromCharCode(p), r.parentType = f, true;
}
function DR(r, i, l) {
  const d = r.md.block.ruler.getRules("paragraph"), f = r.parentType;
  let g = i + 1;
  for (r.parentType = "paragraph"; g < l && !r.isEmpty(g); g++) {
    if (r.sCount[g] - r.blkIndent > 3 || r.sCount[g] < 0) continue;
    let P = false;
    for (let M = 0, D = d.length; M < D; M++) if (d[M](r, g, l, true)) {
      P = true;
      break;
    }
    if (P) break;
  }
  const p = r.getLines(i, g, r.blkIndent, false).trim();
  r.line = g;
  const s = r.push("paragraph_open", "p", 1);
  s.map = [i, r.line];
  const C = r.push("inline", "", 0);
  return C.content = p, C.map = [i, r.line], C.children = [], r.push("paragraph_close", "p", -1), r.parentType = f, true;
}
const Qf = [["table", uR, ["paragraph", "reference"]], ["code", cR], ["fence", dR, ["paragraph", "reference", "blockquote", "list"]], ["blockquote", hR, ["paragraph", "reference", "blockquote", "list"]], ["hr", fR, ["paragraph", "reference", "blockquote", "list"]], ["list", mR, ["paragraph", "reference", "blockquote"]], ["reference", gR], ["html_block", ER, ["paragraph", "reference", "blockquote"]], ["heading", RR, ["paragraph", "reference", "blockquote"]], ["lheading", AR], ["paragraph", DR]];
function $p() {
  this.ruler = new ro();
  for (let r = 0; r < Qf.length; r++) this.ruler.push(Qf[r][0], Qf[r][1], { alt: (Qf[r][2] || []).slice() });
}
$p.prototype.tokenize = function(r, i, l) {
  const d = this.ruler.getRules(""), f = d.length, g = r.md.options.maxNesting;
  let p = i, s = false;
  for (; p < l && (r.line = p = r.skipEmptyLines(p), !(p >= l || r.sCount[p] < r.blkIndent)); ) {
    if (r.level >= g) {
      r.line = l;
      break;
    }
    const C = r.line;
    let P = false;
    for (let M = 0; M < f; M++) if (P = d[M](r, p, l, false), P) {
      if (C >= r.line) throw new Error("block rule didn't increment state.line");
      break;
    }
    if (!P) throw new Error("none of the block rules matched");
    r.tight = !s, r.isEmpty(r.line - 1) && (s = true), p = r.line, p < l && r.isEmpty(p) && (s = true, p++, r.line = p);
  }
};
$p.prototype.parse = function(r, i, l, d) {
  if (!r) return;
  const f = new this.State(r, i, l, d);
  this.tokenize(f, f.line, f.lineMax);
};
$p.prototype.State = Ta;
function vh(r, i, l, d) {
  this.src = r, this.env = l, this.md = i, this.tokens = d, this.tokens_meta = Array(d.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = false, this.linkLevel = 0;
}
vh.prototype.pushPending = function() {
  const r = new ra("text", "", 0);
  return r.content = this.pending, r.level = this.pendingLevel, this.tokens.push(r), this.pending = "", r;
};
vh.prototype.push = function(r, i, l) {
  this.pending && this.pushPending();
  const d = new ra(r, i, l);
  let f = null;
  return l < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), d.level = this.level, l > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], f = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(d), this.tokens_meta.push(f), d;
};
vh.prototype.scanDelims = function(r, i) {
  const l = this.posMax, d = this.src.charCodeAt(r), f = r > 0 ? this.src.charCodeAt(r - 1) : 32;
  let g = r;
  for (; g < l && this.src.charCodeAt(g) === d; ) g++;
  const p = g - r, s = g < l ? this.src.charCodeAt(g) : 32, C = ah(f) || oh(String.fromCharCode(f)), P = ah(s) || oh(String.fromCharCode(s)), M = nh(f), D = nh(s), L = !D && (!P || M || C), $ = !M && (!C || D || P);
  return { can_open: L && (i || !$ || C), can_close: $ && (i || !L || P), length: p };
};
vh.prototype.Token = ra;
function zR(r) {
  switch (r) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function FR(r, i) {
  let l = r.pos;
  for (; l < r.posMax && !zR(r.src.charCodeAt(l)); ) l++;
  return l === r.pos ? false : (i || (r.pending += r.src.slice(r.pos, l)), r.pos = l, true);
}
const LR = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function BR(r, i) {
  if (!r.md.options.linkify || r.linkLevel > 0) return false;
  const l = r.pos, d = r.posMax;
  if (l + 3 > d || r.src.charCodeAt(l) !== 58 || r.src.charCodeAt(l + 1) !== 47 || r.src.charCodeAt(l + 2) !== 47) return false;
  const f = r.pending.match(LR);
  if (!f) return false;
  const g = f[1], p = r.md.linkify.matchAtStart(r.src.slice(l - g.length));
  if (!p) return false;
  let s = p.url;
  if (s.length <= g.length) return false;
  s = s.replace(/\*+$/, "");
  const C = r.md.normalizeLink(s);
  if (!r.md.validateLink(C)) return false;
  if (!i) {
    r.pending = r.pending.slice(0, -g.length);
    const P = r.push("link_open", "a", 1);
    P.attrs = [["href", C]], P.markup = "linkify", P.info = "auto";
    const M = r.push("text", "", 0);
    M.content = r.md.normalizeLinkText(s);
    const D = r.push("link_close", "a", -1);
    D.markup = "linkify", D.info = "auto";
  }
  return r.pos += s.length - g.length, true;
}
function OR(r, i) {
  let l = r.pos;
  if (r.src.charCodeAt(l) !== 10) return false;
  const d = r.pending.length - 1, f = r.posMax;
  if (!i) if (d >= 0 && r.pending.charCodeAt(d) === 32) if (d >= 1 && r.pending.charCodeAt(d - 1) === 32) {
    let g = d - 1;
    for (; g >= 1 && r.pending.charCodeAt(g - 1) === 32; ) g--;
    r.pending = r.pending.slice(0, g), r.push("hardbreak", "br", 0);
  } else r.pending = r.pending.slice(0, -1), r.push("softbreak", "br", 0);
  else r.push("softbreak", "br", 0);
  for (l++; l < f && _i(r.src.charCodeAt(l)); ) l++;
  return r.pos = l, true;
}
const T0 = [];
for (let r = 0; r < 256; r++) T0.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(r) {
  T0[r.charCodeAt(0)] = 1;
});
function $R(r, i) {
  let l = r.pos;
  const d = r.posMax;
  if (r.src.charCodeAt(l) !== 92 || (l++, l >= d)) return false;
  let f = r.src.charCodeAt(l);
  if (f === 10) {
    for (i || r.push("hardbreak", "br", 0), l++; l < d && (f = r.src.charCodeAt(l), !!_i(f)); ) l++;
    return r.pos = l, true;
  }
  let g = r.src[l];
  if (f >= 55296 && f <= 56319 && l + 1 < d) {
    const s = r.src.charCodeAt(l + 1);
    s >= 56320 && s <= 57343 && (g += r.src[l + 1], l++);
  }
  const p = "\\" + g;
  if (!i) {
    const s = r.push("text_special", "", 0);
    f < 256 && T0[f] !== 0 ? s.content = g : s.content = p, s.markup = p, s.info = "escape";
  }
  return r.pos = l + 1, true;
}
function jR(r, i) {
  let l = r.pos;
  if (r.src.charCodeAt(l) !== 96) return false;
  const f = l;
  l++;
  const g = r.posMax;
  for (; l < g && r.src.charCodeAt(l) === 96; ) l++;
  const p = r.src.slice(f, l), s = p.length;
  if (r.backticksScanned && (r.backticks[s] || 0) <= f) return i || (r.pending += p), r.pos += s, true;
  let C = l, P;
  for (; (P = r.src.indexOf("`", C)) !== -1; ) {
    for (C = P + 1; C < g && r.src.charCodeAt(C) === 96; ) C++;
    const M = C - P;
    if (M === s) {
      if (!i) {
        const D = r.push("code_inline", "code", 0);
        D.markup = p, D.content = r.src.slice(l, P).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      return r.pos = C, true;
    }
    r.backticks[M] = P;
  }
  return r.backticksScanned = true, i || (r.pending += p), r.pos += s, true;
}
function NR(r, i) {
  const l = r.pos, d = r.src.charCodeAt(l);
  if (i || d !== 126) return false;
  const f = r.scanDelims(r.pos, true);
  let g = f.length;
  const p = String.fromCharCode(d);
  if (g < 2) return false;
  let s;
  g % 2 && (s = r.push("text", "", 0), s.content = p, g--);
  for (let C = 0; C < g; C += 2) s = r.push("text", "", 0), s.content = p + p, r.delimiters.push({ marker: d, length: 0, token: r.tokens.length - 1, end: -1, open: f.can_open, close: f.can_close });
  return r.pos += f.length, true;
}
function My(r, i) {
  let l;
  const d = [], f = i.length;
  for (let g = 0; g < f; g++) {
    const p = i[g];
    if (p.marker !== 126 || p.end === -1) continue;
    const s = i[p.end];
    l = r.tokens[p.token], l.type = "s_open", l.tag = "s", l.nesting = 1, l.markup = "~~", l.content = "", l = r.tokens[s.token], l.type = "s_close", l.tag = "s", l.nesting = -1, l.markup = "~~", l.content = "", r.tokens[s.token - 1].type === "text" && r.tokens[s.token - 1].content === "~" && d.push(s.token - 1);
  }
  for (; d.length; ) {
    const g = d.pop();
    let p = g + 1;
    for (; p < r.tokens.length && r.tokens[p].type === "s_close"; ) p++;
    p--, g !== p && (l = r.tokens[p], r.tokens[p] = r.tokens[g], r.tokens[g] = l);
  }
}
function VR(r) {
  const i = r.tokens_meta, l = r.tokens_meta.length;
  My(r, r.delimiters);
  for (let d = 0; d < l; d++) i[d] && i[d].delimiters && My(r, i[d].delimiters);
}
const tx = { tokenize: NR, postProcess: VR };
function UR(r, i) {
  const l = r.pos, d = r.src.charCodeAt(l);
  if (i || d !== 95 && d !== 42) return false;
  const f = r.scanDelims(r.pos, d === 42);
  for (let g = 0; g < f.length; g++) {
    const p = r.push("text", "", 0);
    p.content = String.fromCharCode(d), r.delimiters.push({ marker: d, length: f.length, token: r.tokens.length - 1, end: -1, open: f.can_open, close: f.can_close });
  }
  return r.pos += f.length, true;
}
function Ey(r, i) {
  const l = i.length;
  for (let d = l - 1; d >= 0; d--) {
    const f = i[d];
    if (f.marker !== 95 && f.marker !== 42 || f.end === -1) continue;
    const g = i[f.end], p = d > 0 && i[d - 1].end === f.end + 1 && i[d - 1].marker === f.marker && i[d - 1].token === f.token - 1 && i[f.end + 1].token === g.token + 1, s = String.fromCharCode(f.marker), C = r.tokens[f.token];
    C.type = p ? "strong_open" : "em_open", C.tag = p ? "strong" : "em", C.nesting = 1, C.markup = p ? s + s : s, C.content = "";
    const P = r.tokens[g.token];
    P.type = p ? "strong_close" : "em_close", P.tag = p ? "strong" : "em", P.nesting = -1, P.markup = p ? s + s : s, P.content = "", p && (r.tokens[i[d - 1].token].content = "", r.tokens[i[f.end + 1].token].content = "", d--);
  }
}
function GR(r) {
  const i = r.tokens_meta, l = r.tokens_meta.length;
  Ey(r, r.delimiters);
  for (let d = 0; d < l; d++) i[d] && i[d].delimiters && Ey(r, i[d].delimiters);
}
const rx = { tokenize: UR, postProcess: GR };
function qR(r, i) {
  let l, d, f, g, p = "", s = "", C = r.pos, P = true;
  if (r.src.charCodeAt(r.pos) !== 91) return false;
  const M = r.pos, D = r.posMax, L = r.pos + 1, $ = r.md.helpers.parseLinkLabel(r, r.pos, true);
  if ($ < 0) return false;
  let z = $ + 1;
  if (z < D && r.src.charCodeAt(z) === 40) {
    for (P = false, z++; z < D && (l = r.src.charCodeAt(z), !(!_i(l) && l !== 10)); z++) ;
    if (z >= D) return false;
    if (C = z, f = r.md.helpers.parseLinkDestination(r.src, z, r.posMax), f.ok) {
      for (p = r.md.normalizeLink(f.str), r.md.validateLink(p) ? z = f.pos : p = "", C = z; z < D && (l = r.src.charCodeAt(z), !(!_i(l) && l !== 10)); z++) ;
      if (f = r.md.helpers.parseLinkTitle(r.src, z, r.posMax), z < D && C !== z && f.ok) for (s = f.str, z = f.pos; z < D && (l = r.src.charCodeAt(z), !(!_i(l) && l !== 10)); z++) ;
    }
    (z >= D || r.src.charCodeAt(z) !== 41) && (P = true), z++;
  }
  if (P) {
    if (typeof r.env.references > "u") return false;
    if (z < D && r.src.charCodeAt(z) === 91 ? (C = z + 1, z = r.md.helpers.parseLinkLabel(r, z), z >= 0 ? d = r.src.slice(C, z++) : z = $ + 1) : z = $ + 1, d || (d = r.src.slice(L, $)), g = r.env.references[Op(d)], !g) return r.pos = M, false;
    p = g.href, s = g.title;
  }
  if (!i) {
    r.pos = L, r.posMax = $;
    const F = r.push("link_open", "a", 1), Z = [["href", p]];
    F.attrs = Z, s && Z.push(["title", s]), r.linkLevel++, r.md.inline.tokenize(r), r.linkLevel--, r.push("link_close", "a", -1);
  }
  return r.pos = z, r.posMax = D, true;
}
function WR(r, i) {
  let l, d, f, g, p, s, C, P, M = "";
  const D = r.pos, L = r.posMax;
  if (r.src.charCodeAt(r.pos) !== 33 || r.src.charCodeAt(r.pos + 1) !== 91) return false;
  const $ = r.pos + 2, z = r.md.helpers.parseLinkLabel(r, r.pos + 1, false);
  if (z < 0) return false;
  if (g = z + 1, g < L && r.src.charCodeAt(g) === 40) {
    for (g++; g < L && (l = r.src.charCodeAt(g), !(!_i(l) && l !== 10)); g++) ;
    if (g >= L) return false;
    for (P = g, s = r.md.helpers.parseLinkDestination(r.src, g, r.posMax), s.ok && (M = r.md.normalizeLink(s.str), r.md.validateLink(M) ? g = s.pos : M = ""), P = g; g < L && (l = r.src.charCodeAt(g), !(!_i(l) && l !== 10)); g++) ;
    if (s = r.md.helpers.parseLinkTitle(r.src, g, r.posMax), g < L && P !== g && s.ok) for (C = s.str, g = s.pos; g < L && (l = r.src.charCodeAt(g), !(!_i(l) && l !== 10)); g++) ;
    else C = "";
    if (g >= L || r.src.charCodeAt(g) !== 41) return r.pos = D, false;
    g++;
  } else {
    if (typeof r.env.references > "u") return false;
    if (g < L && r.src.charCodeAt(g) === 91 ? (P = g + 1, g = r.md.helpers.parseLinkLabel(r, g), g >= 0 ? f = r.src.slice(P, g++) : g = z + 1) : g = z + 1, f || (f = r.src.slice($, z)), p = r.env.references[Op(f)], !p) return r.pos = D, false;
    M = p.href, C = p.title;
  }
  if (!i) {
    d = r.src.slice($, z);
    const F = [];
    r.md.inline.parse(d, r.md, r.env, F);
    const Z = r.push("image", "img", 0), q = [["src", M], ["alt", ""]];
    Z.attrs = q, Z.children = F, Z.content = d, C && q.push(["title", C]);
  }
  return r.pos = g, r.posMax = L, true;
}
const ZR = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, HR = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function XR(r, i) {
  let l = r.pos;
  if (r.src.charCodeAt(l) !== 60) return false;
  const d = r.pos, f = r.posMax;
  for (; ; ) {
    if (++l >= f) return false;
    const p = r.src.charCodeAt(l);
    if (p === 60) return false;
    if (p === 62) break;
  }
  const g = r.src.slice(d + 1, l);
  if (HR.test(g)) {
    const p = r.md.normalizeLink(g);
    if (!r.md.validateLink(p)) return false;
    if (!i) {
      const s = r.push("link_open", "a", 1);
      s.attrs = [["href", p]], s.markup = "autolink", s.info = "auto";
      const C = r.push("text", "", 0);
      C.content = r.md.normalizeLinkText(g);
      const P = r.push("link_close", "a", -1);
      P.markup = "autolink", P.info = "auto";
    }
    return r.pos += g.length + 2, true;
  }
  if (ZR.test(g)) {
    const p = r.md.normalizeLink("mailto:" + g);
    if (!r.md.validateLink(p)) return false;
    if (!i) {
      const s = r.push("link_open", "a", 1);
      s.attrs = [["href", p]], s.markup = "autolink", s.info = "auto";
      const C = r.push("text", "", 0);
      C.content = r.md.normalizeLinkText(g);
      const P = r.push("link_close", "a", -1);
      P.markup = "autolink", P.info = "auto";
    }
    return r.pos += g.length + 2, true;
  }
  return false;
}
function YR(r) {
  return /^<a[>\s]/i.test(r);
}
function KR(r) {
  return /^<\/a\s*>/i.test(r);
}
function JR(r) {
  const i = r | 32;
  return i >= 97 && i <= 122;
}
function QR(r, i) {
  if (!r.md.options.html) return false;
  const l = r.posMax, d = r.pos;
  if (r.src.charCodeAt(d) !== 60 || d + 2 >= l) return false;
  const f = r.src.charCodeAt(d + 1);
  if (f !== 33 && f !== 63 && f !== 47 && !JR(f)) return false;
  const g = r.src.slice(d).match(IR);
  if (!g) return false;
  if (!i) {
    const p = r.push("html_inline", "", 0);
    p.content = g[0], YR(p.content) && r.linkLevel++, KR(p.content) && r.linkLevel--;
  }
  return r.pos += g[0].length, true;
}
const eA = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, tA = /^&([a-z][a-z0-9]{1,31});/i;
function rA(r, i) {
  const l = r.pos, d = r.posMax;
  if (r.src.charCodeAt(l) !== 38 || l + 1 >= d) return false;
  if (r.src.charCodeAt(l + 1) === 35) {
    const g = r.src.slice(l).match(eA);
    if (g) {
      if (!i) {
        const p = g[1][0].toLowerCase() === "x" ? parseInt(g[1].slice(1), 16) : parseInt(g[1], 10), s = r.push("text_special", "", 0);
        s.content = k0(p) ? vp(p) : vp(65533), s.markup = g[0], s.info = "entity";
      }
      return r.pos += g[0].length, true;
    }
  } else {
    const g = r.src.slice(l).match(tA);
    if (g) {
      const p = H1(g[0]);
      if (p !== g[0]) {
        if (!i) {
          const s = r.push("text_special", "", 0);
          s.content = p, s.markup = g[0], s.info = "entity";
        }
        return r.pos += g[0].length, true;
      }
    }
  }
  return false;
}
function Ry(r) {
  const i = {}, l = r.length;
  if (!l) return;
  let d = 0, f = -2;
  const g = [];
  for (let p = 0; p < l; p++) {
    const s = r[p];
    if (g.push(0), (r[d].marker !== s.marker || f !== s.token - 1) && (d = p), f = s.token, s.length = s.length || 0, !s.close) continue;
    i.hasOwnProperty(s.marker) || (i[s.marker] = [-1, -1, -1, -1, -1, -1]);
    const C = i[s.marker][(s.open ? 3 : 0) + s.length % 3];
    let P = d - g[d] - 1, M = P;
    for (; P > C; P -= g[P] + 1) {
      const D = r[P];
      if (D.marker === s.marker && D.open && D.end < 0) {
        let L = false;
        if ((D.close || s.open) && (D.length + s.length) % 3 === 0 && (D.length % 3 !== 0 || s.length % 3 !== 0) && (L = true), !L) {
          const $ = P > 0 && !r[P - 1].open ? g[P - 1] + 1 : 0;
          g[p] = p - P + $, g[P] = $, s.open = false, D.end = p, D.close = false, M = -1, f = -2;
          break;
        }
      }
    }
    M !== -1 && (i[s.marker][(s.open ? 3 : 0) + (s.length || 0) % 3] = M);
  }
}
function iA(r) {
  const i = r.tokens_meta, l = r.tokens_meta.length;
  Ry(r.delimiters);
  for (let d = 0; d < l; d++) i[d] && i[d].delimiters && Ry(i[d].delimiters);
}
function nA(r) {
  let i, l, d = 0;
  const f = r.tokens, g = r.tokens.length;
  for (i = l = 0; i < g; i++) f[i].nesting < 0 && d--, f[i].level = d, f[i].nesting > 0 && d++, f[i].type === "text" && i + 1 < g && f[i + 1].type === "text" ? f[i + 1].content = f[i].content + f[i + 1].content : (i !== l && (f[l] = f[i]), l++);
  i !== l && (f.length = l);
}
const bg = [["text", FR], ["linkify", BR], ["newline", OR], ["escape", $R], ["backticks", jR], ["strikethrough", tx.tokenize], ["emphasis", rx.tokenize], ["link", qR], ["image", WR], ["autolink", XR], ["html_inline", QR], ["entity", rA]], xg = [["balance_pairs", iA], ["strikethrough", tx.postProcess], ["emphasis", rx.postProcess], ["fragments_join", nA]];
function _h() {
  this.ruler = new ro();
  for (let r = 0; r < bg.length; r++) this.ruler.push(bg[r][0], bg[r][1]);
  this.ruler2 = new ro();
  for (let r = 0; r < xg.length; r++) this.ruler2.push(xg[r][0], xg[r][1]);
}
_h.prototype.skipToken = function(r) {
  const i = r.pos, l = this.ruler.getRules(""), d = l.length, f = r.md.options.maxNesting, g = r.cache;
  if (typeof g[i] < "u") {
    r.pos = g[i];
    return;
  }
  let p = false;
  if (r.level < f) {
    for (let s = 0; s < d; s++) if (r.level++, p = l[s](r, true), r.level--, p) {
      if (i >= r.pos) throw new Error("inline rule didn't increment state.pos");
      break;
    }
  } else r.pos = r.posMax;
  p || r.pos++, g[i] = r.pos;
};
_h.prototype.tokenize = function(r) {
  const i = this.ruler.getRules(""), l = i.length, d = r.posMax, f = r.md.options.maxNesting;
  for (; r.pos < d; ) {
    const g = r.pos;
    let p = false;
    if (r.level < f) {
      for (let s = 0; s < l; s++) if (p = i[s](r, false), p) {
        if (g >= r.pos) throw new Error("inline rule didn't increment state.pos");
        break;
      }
    }
    if (p) {
      if (r.pos >= d) break;
      continue;
    }
    r.pending += r.src[r.pos++];
  }
  r.pending && r.pushPending();
};
_h.prototype.parse = function(r, i, l, d) {
  const f = new this.State(r, i, l, d);
  this.tokenize(f);
  const g = this.ruler2.getRules(""), p = g.length;
  for (let s = 0; s < p; s++) g[s](f);
};
_h.prototype.State = vh;
function oA(r) {
  const i = {};
  r = r || {}, i.src_Any = U1.source, i.src_Cc = G1.source, i.src_Z = W1.source, i.src_P = C0.source, i.src_ZPCc = [i.src_Z, i.src_P, i.src_Cc].join("|"), i.src_ZCc = [i.src_Z, i.src_Cc].join("|");
  const l = "[><\uFF5C]";
  return i.src_pseudo_letter = "(?:(?!" + l + "|" + i.src_ZPCc + ")" + i.src_Any + ")", i.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", i.src_auth = "(?:(?:(?!" + i.src_ZCc + "|[@/\\[\\]()]).)+@)?", i.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", i.src_host_terminator = "(?=$|" + l + "|" + i.src_ZPCc + ")(?!" + (r["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + i.src_ZPCc + "))", i.src_path = "(?:[/?#](?:(?!" + i.src_ZCc + "|" + l + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + i.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + i.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + i.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + i.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + i.src_ZCc + "|[']).)+\\'|\\'(?=" + i.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + i.src_ZCc + "|[.]|$)|" + (r["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + i.src_ZCc + "|$)|;(?!" + i.src_ZCc + "|$)|\\!+(?!" + i.src_ZCc + "|[!]|$)|\\?(?!" + i.src_ZCc + "|[?]|$))+|\\/)?", i.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', i.src_xn = "xn--[a-z0-9\\-]{1,59}", i.src_domain_root = "(?:" + i.src_xn + "|" + i.src_pseudo_letter + "{1,63})", i.src_domain = "(?:" + i.src_xn + "|(?:" + i.src_pseudo_letter + ")|(?:" + i.src_pseudo_letter + "(?:-|" + i.src_pseudo_letter + "){0,61}" + i.src_pseudo_letter + "))", i.src_host = "(?:(?:(?:(?:" + i.src_domain + ")\\.)*" + i.src_domain + "))", i.tpl_host_fuzzy = "(?:" + i.src_ip4 + "|(?:(?:(?:" + i.src_domain + ")\\.)+(?:%TLDS%)))", i.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + i.src_domain + ")\\.)+(?:%TLDS%))", i.src_host_strict = i.src_host + i.src_host_terminator, i.tpl_host_fuzzy_strict = i.tpl_host_fuzzy + i.src_host_terminator, i.src_host_port_strict = i.src_host + i.src_port + i.src_host_terminator, i.tpl_host_port_fuzzy_strict = i.tpl_host_fuzzy + i.src_port + i.src_host_terminator, i.tpl_host_port_no_ip_fuzzy_strict = i.tpl_host_no_ip_fuzzy + i.src_port + i.src_host_terminator, i.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + i.src_ZPCc + "|>|$))", i.tpl_email_fuzzy = "(^|" + l + '|"|\\(|' + i.src_ZCc + ")(" + i.src_email_name + "@" + i.tpl_host_fuzzy_strict + ")", i.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + i.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + i.tpl_host_port_fuzzy_strict + i.src_path + ")", i.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + i.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + i.tpl_host_port_no_ip_fuzzy_strict + i.src_path + ")", i;
}
function e0(r) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(l) {
    l && Object.keys(l).forEach(function(d) {
      r[d] = l[d];
    });
  }), r;
}
function jp(r) {
  return Object.prototype.toString.call(r);
}
function aA(r) {
  return jp(r) === "[object String]";
}
function sA(r) {
  return jp(r) === "[object Object]";
}
function lA(r) {
  return jp(r) === "[object RegExp]";
}
function Ay(r) {
  return jp(r) === "[object Function]";
}
function uA(r) {
  return r.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
const ix = { fuzzyLink: true, fuzzyEmail: true, fuzzyIP: false };
function cA(r) {
  return Object.keys(r || {}).reduce(function(i, l) {
    return i || ix.hasOwnProperty(l);
  }, false);
}
const dA = { "http:": { validate: function(r, i, l) {
  const d = r.slice(i);
  return l.re.http || (l.re.http = new RegExp("^\\/\\/" + l.re.src_auth + l.re.src_host_port_strict + l.re.src_path, "i")), l.re.http.test(d) ? d.match(l.re.http)[0].length : 0;
} }, "https:": "http:", "ftp:": "http:", "//": { validate: function(r, i, l) {
  const d = r.slice(i);
  return l.re.no_http || (l.re.no_http = new RegExp("^" + l.re.src_auth + "(?:localhost|(?:(?:" + l.re.src_domain + ")\\.)+" + l.re.src_domain_root + ")" + l.re.src_port + l.re.src_host_terminator + l.re.src_path, "i")), l.re.no_http.test(d) ? i >= 3 && r[i - 3] === ":" || i >= 3 && r[i - 3] === "/" ? 0 : d.match(l.re.no_http)[0].length : 0;
} }, "mailto:": { validate: function(r, i, l) {
  const d = r.slice(i);
  return l.re.mailto || (l.re.mailto = new RegExp("^" + l.re.src_email_name + "@" + l.re.src_host_strict, "i")), l.re.mailto.test(d) ? d.match(l.re.mailto)[0].length : 0;
} } }, hA = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", fA = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
function pA(r) {
  r.__index__ = -1, r.__text_cache__ = "";
}
function mA(r) {
  return function(i, l) {
    const d = i.slice(l);
    return r.test(d) ? d.match(r)[0].length : 0;
  };
}
function Dy() {
  return function(r, i) {
    i.normalize(r);
  };
}
function _p(r) {
  const i = r.re = oA(r.__opts__), l = r.__tlds__.slice();
  r.onCompile(), r.__tlds_replaced__ || l.push(hA), l.push(i.src_xn), i.src_tlds = l.join("|");
  function d(s) {
    return s.replace("%TLDS%", i.src_tlds);
  }
  i.email_fuzzy = RegExp(d(i.tpl_email_fuzzy), "i"), i.link_fuzzy = RegExp(d(i.tpl_link_fuzzy), "i"), i.link_no_ip_fuzzy = RegExp(d(i.tpl_link_no_ip_fuzzy), "i"), i.host_fuzzy_test = RegExp(d(i.tpl_host_fuzzy_test), "i");
  const f = [];
  r.__compiled__ = {};
  function g(s, C) {
    throw new Error('(LinkifyIt) Invalid schema "' + s + '": ' + C);
  }
  Object.keys(r.__schemas__).forEach(function(s) {
    const C = r.__schemas__[s];
    if (C === null) return;
    const P = { validate: null, link: null };
    if (r.__compiled__[s] = P, sA(C)) {
      lA(C.validate) ? P.validate = mA(C.validate) : Ay(C.validate) ? P.validate = C.validate : g(s, C), Ay(C.normalize) ? P.normalize = C.normalize : C.normalize ? g(s, C) : P.normalize = Dy();
      return;
    }
    if (aA(C)) {
      f.push(s);
      return;
    }
    g(s, C);
  }), f.forEach(function(s) {
    r.__compiled__[r.__schemas__[s]] && (r.__compiled__[s].validate = r.__compiled__[r.__schemas__[s]].validate, r.__compiled__[s].normalize = r.__compiled__[r.__schemas__[s]].normalize);
  }), r.__compiled__[""] = { validate: null, normalize: Dy() };
  const p = Object.keys(r.__compiled__).filter(function(s) {
    return s.length > 0 && r.__compiled__[s];
  }).map(uA).join("|");
  r.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + i.src_ZPCc + "))(" + p + ")", "i"), r.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + i.src_ZPCc + "))(" + p + ")", "ig"), r.re.schema_at_start = RegExp("^" + r.re.schema_search.source, "i"), r.re.pretest = RegExp("(" + r.re.schema_test.source + ")|(" + r.re.host_fuzzy_test.source + ")|@", "i"), pA(r);
}
function gA(r, i) {
  const l = r.__index__, d = r.__last_index__, f = r.__text_cache__.slice(l, d);
  this.schema = r.__schema__.toLowerCase(), this.index = l + i, this.lastIndex = d + i, this.raw = f, this.text = f, this.url = f;
}
function t0(r, i) {
  const l = new gA(r, i);
  return r.__compiled__[l.schema].normalize(l, r), l;
}
function wo(r, i) {
  if (!(this instanceof wo)) return new wo(r, i);
  i || cA(r) && (i = r, r = {}), this.__opts__ = e0({}, ix, i), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = e0({}, dA, r), this.__compiled__ = {}, this.__tlds__ = fA, this.__tlds_replaced__ = false, this.re = {}, _p(this);
}
wo.prototype.add = function(i, l) {
  return this.__schemas__[i] = l, _p(this), this;
};
wo.prototype.set = function(i) {
  return this.__opts__ = e0(this.__opts__, i), this;
};
wo.prototype.test = function(i) {
  if (this.__text_cache__ = i, this.__index__ = -1, !i.length) return false;
  let l, d, f, g, p, s, C, P, M;
  if (this.re.schema_test.test(i)) {
    for (C = this.re.schema_search, C.lastIndex = 0; (l = C.exec(i)) !== null; ) if (g = this.testSchemaAt(i, l[2], C.lastIndex), g) {
      this.__schema__ = l[2], this.__index__ = l.index + l[1].length, this.__last_index__ = l.index + l[0].length + g;
      break;
    }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (P = i.search(this.re.host_fuzzy_test), P >= 0 && (this.__index__ < 0 || P < this.__index__) && (d = i.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (p = d.index + d[1].length, (this.__index__ < 0 || p < this.__index__) && (this.__schema__ = "", this.__index__ = p, this.__last_index__ = d.index + d[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (M = i.indexOf("@"), M >= 0 && (f = i.match(this.re.email_fuzzy)) !== null && (p = f.index + f[1].length, s = f.index + f[0].length, (this.__index__ < 0 || p < this.__index__ || p === this.__index__ && s > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = p, this.__last_index__ = s))), this.__index__ >= 0;
};
wo.prototype.pretest = function(i) {
  return this.re.pretest.test(i);
};
wo.prototype.testSchemaAt = function(i, l, d) {
  return this.__compiled__[l.toLowerCase()] ? this.__compiled__[l.toLowerCase()].validate(i, d, this) : 0;
};
wo.prototype.match = function(i) {
  const l = [];
  let d = 0;
  this.__index__ >= 0 && this.__text_cache__ === i && (l.push(t0(this, d)), d = this.__last_index__);
  let f = d ? i.slice(d) : i;
  for (; this.test(f); ) l.push(t0(this, d)), f = f.slice(this.__last_index__), d += this.__last_index__;
  return l.length ? l : null;
};
wo.prototype.matchAtStart = function(i) {
  if (this.__text_cache__ = i, this.__index__ = -1, !i.length) return null;
  const l = this.re.schema_at_start.exec(i);
  if (!l) return null;
  const d = this.testSchemaAt(i, l[2], l[0].length);
  return d ? (this.__schema__ = l[2], this.__index__ = l.index + l[1].length, this.__last_index__ = l.index + l[0].length + d, t0(this, 0)) : null;
};
wo.prototype.tlds = function(i, l) {
  return i = Array.isArray(i) ? i : [i], l ? (this.__tlds__ = this.__tlds__.concat(i).sort().filter(function(d, f, g) {
    return d !== g[f - 1];
  }).reverse(), _p(this), this) : (this.__tlds__ = i.slice(), this.__tlds_replaced__ = true, _p(this), this);
};
wo.prototype.normalize = function(i) {
  i.schema || (i.url = "http://" + i.url), i.schema === "mailto:" && !/^mailto:/i.test(i.url) && (i.url = "mailto:" + i.url);
};
wo.prototype.onCompile = function() {
};
const uc = 2147483647, ya = 36, I0 = 1, sh = 26, vA = 38, _A = 700, nx = 72, ox = 128, ax = "-", yA = /^xn--/, bA = /[^\0-\x7F]/, xA = /[\x2E\u3002\uFF0E\uFF61]/g, wA = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, wg = ya - I0, ba = Math.floor, Cg = String.fromCharCode;
function As(r) {
  throw new RangeError(wA[r]);
}
function CA(r, i) {
  const l = [];
  let d = r.length;
  for (; d--; ) l[d] = i(r[d]);
  return l;
}
function sx(r, i) {
  const l = r.split("@");
  let d = "";
  l.length > 1 && (d = l[0] + "@", r = l[1]), r = r.replace(xA, ".");
  const f = r.split("."), g = CA(f, i).join(".");
  return d + g;
}
function lx(r) {
  const i = [];
  let l = 0;
  const d = r.length;
  for (; l < d; ) {
    const f = r.charCodeAt(l++);
    if (f >= 55296 && f <= 56319 && l < d) {
      const g = r.charCodeAt(l++);
      (g & 64512) == 56320 ? i.push(((f & 1023) << 10) + (g & 1023) + 65536) : (i.push(f), l--);
    } else i.push(f);
  }
  return i;
}
const SA = (r) => String.fromCodePoint(...r), kA = function(r) {
  return r >= 48 && r < 58 ? 26 + (r - 48) : r >= 65 && r < 91 ? r - 65 : r >= 97 && r < 123 ? r - 97 : ya;
}, zy = function(r, i) {
  return r + 22 + 75 * (r < 26) - ((i != 0) << 5);
}, ux = function(r, i, l) {
  let d = 0;
  for (r = l ? ba(r / _A) : r >> 1, r += ba(r / i); r > wg * sh >> 1; d += ya) r = ba(r / wg);
  return ba(d + (wg + 1) * r / (r + vA));
}, cx = function(r) {
  const i = [], l = r.length;
  let d = 0, f = ox, g = nx, p = r.lastIndexOf(ax);
  p < 0 && (p = 0);
  for (let s = 0; s < p; ++s) r.charCodeAt(s) >= 128 && As("not-basic"), i.push(r.charCodeAt(s));
  for (let s = p > 0 ? p + 1 : 0; s < l; ) {
    const C = d;
    for (let M = 1, D = ya; ; D += ya) {
      s >= l && As("invalid-input");
      const L = kA(r.charCodeAt(s++));
      L >= ya && As("invalid-input"), L > ba((uc - d) / M) && As("overflow"), d += L * M;
      const $ = D <= g ? I0 : D >= g + sh ? sh : D - g;
      if (L < $) break;
      const z = ya - $;
      M > ba(uc / z) && As("overflow"), M *= z;
    }
    const P = i.length + 1;
    g = ux(d - C, P, C == 0), ba(d / P) > uc - f && As("overflow"), f += ba(d / P), d %= P, i.splice(d++, 0, f);
  }
  return String.fromCodePoint(...i);
}, dx = function(r) {
  const i = [];
  r = lx(r);
  const l = r.length;
  let d = ox, f = 0, g = nx;
  for (const C of r) C < 128 && i.push(Cg(C));
  const p = i.length;
  let s = p;
  for (p && i.push(ax); s < l; ) {
    let C = uc;
    for (const M of r) M >= d && M < C && (C = M);
    const P = s + 1;
    C - d > ba((uc - f) / P) && As("overflow"), f += (C - d) * P, d = C;
    for (const M of r) if (M < d && ++f > uc && As("overflow"), M === d) {
      let D = f;
      for (let L = ya; ; L += ya) {
        const $ = L <= g ? I0 : L >= g + sh ? sh : L - g;
        if (D < $) break;
        const z = D - $, F = ya - $;
        i.push(Cg(zy($ + z % F, 0))), D = ba(z / F);
      }
      i.push(Cg(zy(D, 0))), g = ux(f, P, s === p), f = 0, ++s;
    }
    ++f, ++d;
  }
  return i.join("");
}, PA = function(r) {
  return sx(r, function(i) {
    return yA.test(i) ? cx(i.slice(4).toLowerCase()) : i;
  });
}, TA = function(r) {
  return sx(r, function(i) {
    return bA.test(i) ? "xn--" + dx(i) : i;
  });
}, hx = { version: "2.3.1", ucs2: { decode: lx, encode: SA }, decode: cx, encode: dx, toASCII: TA, toUnicode: PA }, IA = { options: { html: false, xhtmlOut: false, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 100 }, components: { core: {}, block: {}, inline: {} } }, MA = { options: { html: false, xhtmlOut: false, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 20 }, components: { core: { rules: ["normalize", "block", "inline", "text_join"] }, block: { rules: ["paragraph"] }, inline: { rules: ["text"], rules2: ["balance_pairs", "fragments_join"] } } }, EA = { options: { html: true, xhtmlOut: true, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 20 }, components: { core: { rules: ["normalize", "block", "inline", "text_join"] }, block: { rules: ["blockquote", "code", "fence", "heading", "hr", "html_block", "lheading", "list", "reference", "paragraph"] }, inline: { rules: ["autolink", "backticks", "emphasis", "entity", "escape", "html_inline", "image", "link", "newline", "text"], rules2: ["balance_pairs", "emphasis", "fragments_join"] } } }, RA = { default: IA, zero: MA, commonmark: EA }, AA = /^(vbscript|javascript|file|data):/, DA = /^data:image\/(gif|png|jpeg|webp);/;
function zA(r) {
  const i = r.trim().toLowerCase();
  return AA.test(i) ? DA.test(i) : true;
}
const fx = ["http:", "https:", "mailto:"];
function FA(r) {
  const i = w0(r, true);
  if (i.hostname && (!i.protocol || fx.indexOf(i.protocol) >= 0)) try {
    i.hostname = hx.toASCII(i.hostname);
  } catch {
  }
  return gh(x0(i));
}
function LA(r) {
  const i = w0(r, true);
  if (i.hostname && (!i.protocol || fx.indexOf(i.protocol) >= 0)) try {
    i.hostname = hx.toUnicode(i.hostname);
  } catch {
  }
  return gc(x0(i), gc.defaultChars + "%");
}
function Ro(r, i) {
  if (!(this instanceof Ro)) return new Ro(r, i);
  i || S0(r) || (i = r || {}, r = "default"), this.inline = new _h(), this.block = new $p(), this.core = new P0(), this.renderer = new wc(), this.linkify = new wo(), this.validateLink = zA, this.normalizeLink = FA, this.normalizeLinkText = LA, this.utils = OE, this.helpers = Bp({}, VE), this.options = {}, this.configure(r), i && this.set(i);
}
Ro.prototype.set = function(r) {
  return Bp(this.options, r), this;
};
Ro.prototype.configure = function(r) {
  const i = this;
  if (S0(r)) {
    const l = r;
    if (r = RA[l], !r) throw new Error('Wrong `markdown-it` preset "' + l + '", check name');
  }
  if (!r) throw new Error("Wrong `markdown-it` preset, can't be empty");
  return r.options && i.set(r.options), r.components && Object.keys(r.components).forEach(function(l) {
    r.components[l].rules && i[l].ruler.enableOnly(r.components[l].rules), r.components[l].rules2 && i[l].ruler2.enableOnly(r.components[l].rules2);
  }), this;
};
Ro.prototype.enable = function(r, i) {
  let l = [];
  Array.isArray(r) || (r = [r]), ["core", "block", "inline"].forEach(function(f) {
    l = l.concat(this[f].ruler.enable(r, true));
  }, this), l = l.concat(this.inline.ruler2.enable(r, true));
  const d = r.filter(function(f) {
    return l.indexOf(f) < 0;
  });
  if (d.length && !i) throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + d);
  return this;
};
Ro.prototype.disable = function(r, i) {
  let l = [];
  Array.isArray(r) || (r = [r]), ["core", "block", "inline"].forEach(function(f) {
    l = l.concat(this[f].ruler.disable(r, true));
  }, this), l = l.concat(this.inline.ruler2.disable(r, true));
  const d = r.filter(function(f) {
    return l.indexOf(f) < 0;
  });
  if (d.length && !i) throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + d);
  return this;
};
Ro.prototype.use = function(r) {
  const i = [this].concat(Array.prototype.slice.call(arguments, 1));
  return r.apply(r, i), this;
};
Ro.prototype.parse = function(r, i) {
  if (typeof r != "string") throw new Error("Input data should be a String");
  const l = new this.core.State(r, this, i);
  return this.core.process(l), l.tokens;
};
Ro.prototype.render = function(r, i) {
  return i = i || {}, this.renderer.render(this.parse(r, i), this.options, i);
};
Ro.prototype.parseInline = function(r, i) {
  const l = new this.core.State(r, this, i);
  return l.inlineMode = true, this.core.process(l), l.tokens;
};
Ro.prototype.renderInline = function(r, i) {
  return i = i || {}, this.renderer.render(this.parseInline(r, i), this.options, i);
};
const Fy = ot((r) => {
  const i = Ca(new Ro(r.options ?? {}));
  for (const d of r.plugins ?? []) i.value.use(d);
  const l = Ee(() => i.value.render(r.source));
  return () => B("div", { innerHTML: l.value });
}, { props: ["source", "options", "plugins"] }), BA = `Copyright (C) 2024-Present Heyan Zhu, LZ (lziii180511) , and the Trackmaker contributers. 

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see [https://www.gnu.org/licenses/](https://www.gnu.org/licenses/).
`, OA = { class: "about-view" }, $A = { id: "project", class: "section project-section" }, jA = { class: "project-header" }, NA = { class: "project-description" }, VA = { id: "data-sources", class: "section data-sources" }, UA = ["href"], GA = { id: "credits", class: "section credits-section" }, qA = { class: "credit-content" }, WA = { key: 1 }, ZA = { class: "license-text" }, HA = { class: "credit-links" }, XA = ["href"], YA = ["href"], KA = { __name: "AboutView", setup(r) {
  Ns((C) => ({ v1e81317d: `${s.value}px` }));
  const i = $s(), { t: l } = On(), d = Ie(false), f = () => {
    d.value = window.innerWidth >= 700;
  };
  Ri(() => {
    f(), window.addEventListener("resize", f);
  }), $y(() => {
    window.removeEventListener("resize", f);
  });
  const g = Ie(new URL("" + new URL("../favicon.svg", import.meta.url).href, import.meta.url).href), p = (C) => C.trim().replace(/\n([\s]*)\n/, `

`).split(`

`).map((P) => P.split(`
`).map((M) => M.trim()).join(" ")).join(`

`).trim(), s = Ie(20);
  return (C, P) => (ct(), $t("div", OA, [d.value ? (ct(), gr(H(Ob), { key: 0, class: "page-anchor", "show-rail": true, "show-background": true }, { default: $e(() => [De(H(rp), { title: H(l)("aboutView.sections.project"), href: "#project" }, null, 8, ["title"]), De(H(rp), { title: H(l)("aboutView.sections.dataSource"), href: "#data-sources" }, null, 8, ["title"]), De(H(rp), { title: H(l)("aboutView.sections.credits"), href: "#credits" }, null, 8, ["title"])]), _: 1 })) : Pr("", true), yt("section", $A, [De(H(Mo), null, { default: $e(() => [yt("div", jA, [De(H(a1), { width: "100", src: g.value, "preview-disabled": "" }, null, 8, ["src"]), De(H(p6), null, { default: $e(() => [...P[0] || (P[0] = [yr("Trackmaker", -1)])]), _: 1 })]), yt("p", NA, Kt(H(l)("aboutView.description")), 1), De(H(P_), { class: "license-collapse" }, { default: $e(() => [De(H(T_), { title: "License", name: "license" }, { header: $e(() => [De(H(Fs), null, { default: $e(() => [De(H(qf), null, { default: $e(() => [...P[1] || (P[1] = [yr("License", -1)])]), _: 1 }), De(H(xo), { type: "info", round: "", size: "small" }, { default: $e(() => [...P[2] || (P[2] = [yr(" GPL ", -1)])]), _: 1 })]), _: 1 })]), default: $e(() => [De(H(Fy), { source: H(BA), class: "license-text" }, null, 8, ["source"])]), _: 1 })]), _: 1 })]), _: 1 })]), yt("section", VA, [De(H(Mo), null, { header: $e(() => [yr(Kt(H(l)("aboutView.sections.dataSource")), 1)]), footer: $e(() => [De(H(Fy), { source: H(l)("aboutView.mapInaccuracyDeclaration"), class: "markdown-resource" }, null, 8, ["source"])]), default: $e(() => [De(H(hh), null, { default: $e(() => [(ct(true), $t(Wr, null, on(H(Pw), (M) => (ct(), gr(H(fh), { key: M.id }, { default: $e(() => [De(H(Fs), null, { default: $e(() => [De(H(qf), null, { default: $e(() => [yr(Kt(M.name), 1)]), _: 2 }, 1024), M.license ? (ct(), gr(H(xo), { key: 0, type: "info", round: "", size: "small" }, { default: $e(() => [yr(Kt(M.license), 1)]), _: 2 }, 1024)) : Pr("", true)]), _: 2 }, 1024)]), suffix: $e(() => [yt("a", { href: M.url, class: "external-link" }, [De(H(bi), { size: s.value, color: H(i).textColor1 }, { default: $e(() => [De(H(y_))]), _: 1 }, 8, ["size", "color"])], 8, UA)]), _: 2 }, 1024))), 128))]), _: 1 })]), _: 1 })]), yt("section", GA, [De(H(Mo), { hoverable: "" }, { header: $e(() => [yr(Kt(H(l)("aboutView.sections.credits")), 1)]), default: $e(() => [De(H(qf), null, { default: $e(() => [yr(Kt(H(l)("aboutView.creditIntro")), 1)]), _: 1 }), De(H(P_), { accordion: "", class: "credits-list", "trigger-areas": ["arrow", "main"] }, { default: $e(() => [(ct(true), $t(Wr, null, on(H(Tw).sort((M, D) => M.name.localeCompare(D.name)), (M) => (ct(), gr(H(T_), { key: M.id, title: M.name, name: M.id }, { header: $e(() => [De(H(Fs), null, { default: $e(() => [yr(Kt(M.name) + " ", 1), M.licenseType.trim() ? (ct(), gr(H(Fs), { key: 0 }, { default: $e(() => [(ct(true), $t(Wr, null, on(M.licenseType.trim().split(",").map((D) => D.trim()), (D) => (ct(), gr(H(xo), { key: D, round: "", type: "info", size: "small" }, { default: $e(() => [yr(Kt(D), 1)]), _: 2 }, 1024))), 128))]), _: 2 }, 1024)) : Pr("", true)]), _: 2 }, 1024)]), "header-extra": $e(() => [yt("div", HA, [M.homepage ? (ct(), $t("a", { key: 0, href: M.homepage }, [De(H(bi), { size: s.value, color: H(i).textColor1 }, { default: $e(() => [De(H(y_))]), _: 1 }, 8, ["size", "color"])], 8, XA)) : Pr("", true), M.url ? (ct(), $t("a", { key: 1, href: M.url }, [De(H(bi), { size: s.value, color: H(i).textColor1 }, { default: $e(() => [M.url.includes("github") ? (ct(), gr(H(NC), { key: 0 })) : (ct(), gr(H(Sb), { key: 1 }))]), _: 2 }, 1032, ["size", "color"])], 8, YA)) : Pr("", true)])]), default: $e(() => [yt("div", qA, [yt("p", null, Kt(M.description), 1), M.license.trim() ? (ct(), gr(H(Xb), { key: 0 })) : Pr("", true), M.license ? (ct(), $t("div", WA, [De(H(qf), null, { default: $e(() => [...P[3] || (P[3] = [yt("strong", null, "License:", -1)])]), _: 1 }), yt("div", ZA, [yt("pre", null, Kt(p(M.license)), 1)])])) : Pr("", true)])]), _: 2 }, 1032, ["title", "name"]))), 128))]), _: 1 })]), _: 1 })])]));
} }, px = Ni(KA, [["__scopeId", "data-v-e19031a0"]]), JA = Object.freeze(Object.defineProperty({ __proto__: null, default: px }, Symbol.toStringTag, { value: "Module" })), QA = { class: "settings-view" }, e8 = { class: "settings-layout" }, t8 = { class: "settings-content" }, r8 = { style: { display: "flex", "flex-direction": "row", "justify-content": "space-between", "align-items": "center", "min-width": "0" } }, i8 = { key: 0 }, n8 = { key: 1 }, o8 = { key: 2 }, a8 = { key: 3 }, s8 = { key: 0, class: "settings-nav" }, l8 = ot({ __name: "SettingsView", setup(r) {
  const i = new bc(), l = E3(), d = Ee(() => i.isMobile), { width: f } = cb(), g = Ee(() => f.value < 800), p = Ee(() => f.value < 680), { t: s, availableLocales: C } = On(), P = ur("settings"), M = Ee(() => [{ title: "appearance", items: [{ title: "theme", type: "radio", items: [{ value: "light", label: s("settings.appearance.theme.options.light") }, { value: "dark", label: s("settings.appearance.theme.options.dark") }, { value: "system", label: s("settings.appearance.theme.options.system") }] }] }, { title: "geolocation", items: [{ title: "watchCompatibilityMode", type: "checkbox" }, { title: "geolocationCorrection", type: "checkbox" }] }, { title: "language", items: [{ title: "interfaceLanguage", type: "select", items: C.map(($) => ({ value: $, label: s(`settings.language.interfaceLanguage.options.${$}`) })) }, { title: "mapLanguage", type: "select", items: C.map(($) => ({ value: $, label: s(`settings.language.mapLanguage.options.${$}`) })).concat([{ value: "interface", label: s("settings.language.mapLanguage.options.interface") }]) }] }, { title: "tools", items: [{ title: "apiDetection", type: "button" }, { title: "imuOrientationTesting", type: "button" }] }]), D = () => {
    l.push("/api-detection");
  }, L = () => {
    l.push("/sensor-demo");
  };
  return Ri(() => {
    P.init();
  }), ($, z) => (ct(), $t("div", QA, [yt("div", e8, [yt("div", t8, [(ct(true), $t(Wr, null, on(M.value, (F) => (ct(), gr(H(Mo), { id: "appearance", key: F.title, title: $.$t(`settings.${F.title}.title`) }, { default: $e(() => [De(H(hh), null, { default: $e(() => [(ct(true), $t(Wr, null, on(F.items, (Z) => (ct(), gr(H(fh), { key: Z.title }, { default: $e(() => [yt("div", r8, [De(H(Zb), { style: { "white-space": "nowrap" }, tooltip: { trigger: d.value ? "click" : "hover" } }, { tooltip: $e(() => [yr(Kt(Z.items || Z.type === "button" ? $.$t(`settings.${F.title}.${Z.title}.title`) : $.$t(`settings.${F.title}.${Z.title}`)), 1)]), default: $e(() => [yr(Kt(Z.items || Z.type === "button" ? $.$t(`settings.${F.title}.${Z.title}.title`) : $.$t(`settings.${F.title}.${Z.title}`)) + " ", 1)]), _: 2 }, 1032, ["tooltip"]), Z.type === "radio" ? (ct(), $t("div", i8, [g.value ? (ct(), gr(H(Bg), { key: 1, value: H(P).settings[Z.title], "onUpdate:value": (q) => H(P).settings[Z.title] = q, options: Z.items, "consistent-menu-width": false }, null, 8, ["value", "onUpdate:value", "options"])) : (ct(), gr(H(a5), { key: 0, value: H(P).settings[Z.title], "onUpdate:value": (q) => H(P).settings[Z.title] = q }, { default: $e(() => [(ct(true), $t(Wr, null, on(Z.items, (q) => (ct(), gr(H(r5), { key: q.value, value: q.value, label: q.label, checked: H(P).settings[Z.title] === q.value }, null, 8, ["value", "label", "checked"]))), 128))]), _: 2 }, 1032, ["value", "onUpdate:value"]))])) : Z.type === "select" ? (ct(), $t("div", n8, [De(H(Bg), { value: H(P).settings[Z.title], "onUpdate:value": (q) => H(P).settings[Z.title] = q, options: Z.items, "consistent-menu-width": false }, null, 8, ["value", "onUpdate:value", "options"])])) : Z.type === "checkbox" ? (ct(), $t("div", o8, [De(H(c1), { value: H(P).settings[Z.title], "onUpdate:value": (q) => H(P).settings[Z.title] = q }, null, 8, ["value", "onUpdate:value"])])) : Z.type === "button" ? (ct(), $t("div", a8, [De(H($r), { type: "primary", onClick: (q) => Z.title === "apiDetection" ? D() : L() }, { default: $e(() => [yr(Kt($.$t(`settings.${F.title}.${Z.title}.button`)), 1)]), _: 2 }, 1032, ["onClick"])])) : Pr("", true)])]), _: 2 }, 1024))), 128))]), _: 2 }, 1024)]), _: 2 }, 1032, ["title"]))), 128))]), p.value ? Pr("", true) : (ct(), $t("div", s8, [De(H(Ob), { "show-rail": true, style: { width: "128px" } }, { default: $e(() => [(ct(true), $t(Wr, null, on(M.value, (F) => (ct(), gr(H(rp), { key: F.title, title: $.$t(`settings.${F.title}.title`), href: `#${F.title.toLowerCase()}` }, null, 8, ["title", "href"]))), 128))]), _: 1 })]))])]));
} }), mx = Ni(l8, [["__scopeId", "data-v-8793c34f"]]), u8 = Object.freeze(Object.defineProperty({ __proto__: null, default: mx }, Symbol.toStringTag, { value: "Module" })), c8 = { class: "api-detection-view" }, d8 = { class: "api-detection-content" }, h8 = { class: "api-status-item" }, f8 = { class: "api-name" }, p8 = { key: 0, class: "api-details" }, m8 = { key: 1, class: "api-error" }, g8 = ot({ __name: "ApiDetectionView", setup(r) {
  const { t: i } = On(), l = Ie([{ name: "fetch", available: false }, { name: "geolocation", available: false }, { name: "performance", available: false }, { name: "permission", available: false }, { name: "deviceorientation", available: false }, { name: "devicemotion", available: false }]), d = () => {
    try {
      l.value[0].available = typeof fetch < "u", l.value[0].details = l.value[0].available ? i("apiDetection.descriptions.fetch.available") : i("apiDetection.descriptions.fetch.unavailable");
    } catch (f) {
      l.value[0].available = false, l.value[0].error = f instanceof Error ? f.message : "Unknown error";
    }
    try {
      l.value[1].available = "geolocation" in navigator, l.value[1].details = l.value[1].available ? i("apiDetection.descriptions.geolocation.available") : i("apiDetection.descriptions.geolocation.unavailable");
    } catch (f) {
      l.value[1].available = false, l.value[1].error = f instanceof Error ? f.message : "Unknown error";
    }
    try {
      l.value[2].available = "performance" in window, l.value[2].details = l.value[2].available ? i("apiDetection.descriptions.performance.available") : i("apiDetection.descriptions.performance.unavailable");
    } catch (f) {
      l.value[2].available = false, l.value[2].error = f instanceof Error ? f.message : "Unknown error";
    }
    try {
      l.value[3].available = "permissions" in navigator, l.value[3].details = l.value[3].available ? i("apiDetection.descriptions.permission.available") : i("apiDetection.descriptions.permission.unavailable");
    } catch (f) {
      l.value[3].available = false, l.value[3].error = f instanceof Error ? f.message : "Unknown error";
    }
    try {
      l.value[4].available = "DeviceOrientationEvent" in window, l.value[4].details = l.value[4].available ? i("apiDetection.descriptions.deviceorientation.available") : i("apiDetection.descriptions.deviceorientation.unavailable");
    } catch (f) {
      l.value[4].available = false, l.value[4].error = f instanceof Error ? f.message : "Unknown error";
    }
    try {
      l.value[5].available = "DeviceMotionEvent" in window, l.value[5].details = l.value[5].available ? i("apiDetection.descriptions.devicemotion.available") : i("apiDetection.descriptions.devicemotion.unavailable");
    } catch (f) {
      l.value[5].available = false, l.value[5].error = f instanceof Error ? f.message : "Unknown error";
    }
  };
  return Ri(() => {
    d();
  }), (f, g) => (ct(), $t("div", c8, [yt("div", d8, [De(H(Fs), { vertical: "", size: "large" }, { default: $e(() => [De(H(Mo), { title: f.$t("apiDetection.title") }, { default: $e(() => [De(H(Lg), { type: "info", "show-icon": false }, { default: $e(() => [yr(Kt(f.$t("apiDetection.description")), 1)]), _: 1 }), De(H(Xb), { horizontal: "" }), De(H(hh), null, { default: $e(() => [(ct(true), $t(Wr, null, on(l.value, (p) => (ct(), gr(H(fh), { key: p.name }, { default: $e(() => [yt("div", h8, [yt("div", f8, Kt(f.$t(`apiDetection.apis.${p.name}`)), 1), De(H(xo), { type: p.available ? "success" : "error", bordered: false }, { default: $e(() => [yr(Kt(p.available ? f.$t("apiDetection.available") : f.$t("apiDetection.unavailable")), 1)]), _: 2 }, 1032, ["type"])]), p.details ? (ct(), $t("div", p8, [De(H(Zb), null, { default: $e(() => [yr(Kt(p.details), 1)]), _: 2 }, 1024)])) : Pr("", true), p.error ? (ct(), $t("div", m8, Kt(f.$t("apiDetection.error")) + ": " + Kt(p.error), 1)) : Pr("", true)]), _: 2 }, 1024))), 128))]), _: 1 })]), _: 1 }, 8, ["title"])]), _: 1 })])]));
} }), gx = Ni(g8, [["__scopeId", "data-v-485d4d3d"]]), v8 = Object.freeze(Object.defineProperty({ __proto__: null, default: gx }, Symbol.toStringTag, { value: "Module" })), _8 = { class: "sensor-demo-view" }, y8 = { class: "demo-container" }, b8 = { key: 1, class: "data-section" }, x8 = { class: "orientation-stats" }, w8 = { class: "orientation-row" }, C8 = { class: "orientation-row" }, S8 = { key: 1, class: "data-section" }, k8 = { key: 0, class: "sensor-subsection" }, P8 = { class: "xyz-row" }, T8 = { class: "other-stats-row" }, I8 = { key: 1, class: "sensor-subsection" }, M8 = { class: "xyz-row" }, E8 = { class: "other-stats-row" }, R8 = ot({ __name: "SensorTestView", setup(r) {
  const { t: i } = On(), l = Ie(null), d = Ie(null), f = Ie(null), g = Ie(null), p = Ie(null), s = Ie(null), C = Ie(null), P = Ie(null), M = Ee(() => l.value ? l.value.webkitCompassHeading || 360 - l.value.alpha : 0), D = Ee(() => l.value ? Math.sqrt(l.value.beta ** 2 + l.value.gamma ** 2) : 0), L = Ee(() => f.value ? Math.sqrt(f.value.x ** 2 + f.value.y ** 2 + f.value.z ** 2) : 0), $ = Ee(() => g.value ? Math.sqrt(g.value.x ** 2 + g.value.y ** 2 + g.value.z ** 2) : 0);
  Ri(async () => {
    await z();
  }), $y(() => {
    q();
  });
  async function z() {
    try {
      const K = await va.initialize();
      if (K.isErr()) {
        console.error("Failed to initialize IMU manager:", K.error), C.value = "IMU manager initialization failed", P.value = "IMU manager initialization failed";
        return;
      }
      await F(), await Z();
      const te = va.getLastKnownOrientation();
      te && (l.value = te);
      const re = va.getLastKnownMotion();
      re && (f.value = re.acceleration, g.value = re.gyroscope);
    } catch (K) {
      console.error("Error initializing IMU manager:", K), C.value = "Initialization error", P.value = "Initialization error";
    }
  }
  async function F() {
    try {
      const K = await va.startOrientationUpdates((te) => {
        l.value = te, C.value = null;
      });
      K.isOk() ? (d.value = K.value, C.value = null) : C.value = `Start failed: ${K.error.message}`;
    } catch (K) {
      C.value = `Error: ${K instanceof Error ? K.message : "Unknown error"}`;
    }
  }
  async function Z() {
    try {
      const K = await va.startAccelerationUpdates({ normalizeToENU: true }, (re) => {
        f.value = re, P.value = null;
      });
      if (K.isErr()) {
        P.value = `Acceleration start failed: ${K.error.message}`;
        return;
      }
      const te = await va.startGyroscopeUpdates({ normalizeToENU: false }, (re) => {
        g.value = re, P.value = null;
      });
      if (te.isErr()) {
        K.isOk() && va.stopAccelerationUpdates(K.value), P.value = `Gyroscope start failed: ${te.error.message}`;
        return;
      }
      p.value = K.value, s.value = te.value, P.value = null;
    } catch (K) {
      P.value = `Error: ${K instanceof Error ? K.message : "Unknown error"}`;
    }
  }
  function q() {
    d.value !== null && va.stopOrientationUpdates(d.value), p.value !== null && va.stopAccelerationUpdates(p.value), s.value !== null && va.stopGyroscopeUpdates(s.value);
  }
  return (K, te) => (ct(), $t("div", _8, [yt("div", y8, [De(H(Mo), { title: H(i)("sensorTest.deviceOrientation.title"), class: "sensor-card" }, { default: $e(() => [C.value ? (ct(), gr(H(Lg), { key: 0, type: "error", title: C.value, style: { "margin-top": "16px" } }, null, 8, ["title"])) : Pr("", true), l.value ? (ct(), $t("div", b8, [yt("div", x8, [yt("div", w8, [De(H(Qn), { label: H(i)("sensorTest.deviceOrientation.compassHeading"), value: M.value.toFixed(1), suffix: "\xB0" }, null, 8, ["label", "value"]), De(H(Qn), { label: H(i)("sensorTest.deviceOrientation.alpha"), value: l.value.alpha.toFixed(1), suffix: "\xB0" }, null, 8, ["label", "value"]), De(H(Qn), { label: H(i)("sensorTest.deviceOrientation.beta"), value: l.value.beta.toFixed(1), suffix: "\xB0" }, null, 8, ["label", "value"])]), yt("div", C8, [De(H(Qn), { label: H(i)("sensorTest.deviceOrientation.gamma"), value: l.value.gamma.toFixed(1), suffix: "\xB0" }, null, 8, ["label", "value"]), De(H(Qn), { label: H(i)("sensorTest.deviceOrientation.tiltAngle"), value: D.value.toFixed(1), suffix: "\xB0" }, null, 8, ["label", "value"]), l.value.webkitCompassHeading ? (ct(), gr(H(Qn), { key: 0, label: H(i)("sensorTest.deviceOrientation.iosHeading"), value: l.value.webkitCompassHeading.toFixed(1), suffix: "\xB0" }, null, 8, ["label", "value"])) : Pr("", true)])])])) : Pr("", true)]), _: 1 }, 8, ["title"]), De(H(Mo), { title: H(i)("sensorTest.deviceMotion.title"), class: "sensor-card" }, { default: $e(() => [P.value ? (ct(), gr(H(Lg), { key: 0, type: "error", title: P.value, style: { "margin-top": "16px" } }, null, 8, ["title"])) : Pr("", true), f.value || g.value ? (ct(), $t("div", S8, [f.value ? (ct(), $t("div", k8, [yt("h4", null, Kt(H(i)("sensorTest.deviceMotion.acceleration.title")), 1), yt("div", P8, [De(H(Qn), { label: H(i)("sensorTest.deviceMotion.acceleration.x"), value: f.value.x.toFixed(3), suffix: "m/s\xB2" }, null, 8, ["label", "value"]), De(H(Qn), { label: H(i)("sensorTest.deviceMotion.acceleration.y"), value: f.value.y.toFixed(3), suffix: "m/s\xB2" }, null, 8, ["label", "value"]), De(H(Qn), { label: H(i)("sensorTest.deviceMotion.acceleration.z"), value: f.value.z.toFixed(3), suffix: "m/s\xB2" }, null, 8, ["label", "value"])]), yt("div", T8, [De(H(Qn), { label: H(i)("sensorTest.deviceMotion.acceleration.magnitude"), value: L.value.toFixed(3), suffix: "m/s\xB2" }, null, 8, ["label", "value"])])])) : Pr("", true), g.value ? (ct(), $t("div", I8, [yt("h4", null, Kt(H(i)("sensorTest.deviceMotion.gyroscope.title")), 1), yt("div", M8, [De(H(Qn), { label: H(i)("sensorTest.deviceMotion.gyroscope.x"), value: g.value.x.toFixed(3), suffix: "rad/s" }, null, 8, ["label", "value"]), De(H(Qn), { label: H(i)("sensorTest.deviceMotion.gyroscope.y"), value: g.value.y.toFixed(3), suffix: "rad/s" }, null, 8, ["label", "value"]), De(H(Qn), { label: H(i)("sensorTest.deviceMotion.gyroscope.z"), value: g.value.z.toFixed(3), suffix: "rad/s" }, null, 8, ["label", "value"])]), yt("div", E8, [De(H(Qn), { label: H(i)("sensorTest.deviceMotion.gyroscope.rotationSpeed"), value: $.value.toFixed(3), suffix: "rad/s" }, null, 8, ["label", "value"])])])) : Pr("", true)])) : Pr("", true)]), _: 1 }, 8, ["title"])])]));
} }), vx = Ni(R8, [["__scopeId", "data-v-7bfe3fd7"]]), A8 = Object.freeze(Object.defineProperty({ __proto__: null, default: vx }, Symbol.toStringTag, { value: "Module" })), O8 = R3({ history: A3("./"), routes: [{ path: "/", redirect: "/tracker" }, { path: "/tracker", name: "Tracker", component: Ku() ? N1 : () => Yu(() => Promise.resolve().then(() => nM), void 0, import.meta.url), meta: { timeout: 5e3 } }, { path: "/sketch-centre", name: "sketchCentre", component: Ku() ? V1 : () => Yu(() => Promise.resolve().then(() => KM), void 0, import.meta.url) }, { path: "/about", name: "about", component: Ku() ? px : () => Yu(() => Promise.resolve().then(() => JA), void 0, import.meta.url) }, { path: "/settings", name: "settings", component: Ku() ? mx : () => Yu(() => Promise.resolve().then(() => u8), void 0, import.meta.url) }, { path: "/api-detection", name: "apiDetection", component: Ku() ? gx : () => Yu(() => Promise.resolve().then(() => v8), void 0, import.meta.url) }, { path: "/sensor-demo", name: "sensorDemo", component: Ku() ? vx : () => Yu(() => Promise.resolve().then(() => A8), void 0, import.meta.url) }] });
export {
  O8 as default
};
