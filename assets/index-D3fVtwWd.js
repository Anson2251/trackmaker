var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a;
import { E as Nf, G as Uw, d as st, c as Yt, o as St, a as Tt, H as Qd, j as ze, b as Ae, f as Sn, i as fr, I as eh, q as ar, k as Qi, p as Yr, h as F, m as Ya, J as qw, L as xy, t as Dt, M as Ka, B as Io, N as Vn, F as Gr, w as po, O as ma, P as Gw, Q as sg, R as Ww, S as gs, U as Zw, T as wy, V as Gv, W as Tl, x as Xr, X as Hw, g as Xw, Y as Ga, Z as Yw, $ as Kw, a0 as $i, a1 as zr, a2 as Cy, a3 as Mm, a4 as Il, a5 as Od, C as Cr, y as qe, s as Ne, v as te, z as Pr, D as Ku, A as ir, _ as go, u as oc, a6 as Jw, n as bl, a7 as Og, a8 as hn, a9 as $d, aa as Qw, ab as Sy, l as e2, ac as t2, ad as r2, ae as vf, af as _f } from "./index-BCkfpx1l.js";
import { u as Eo } from "./vue-i18n-DoTloKBc.js";
import { bq as i2, br as ky, bs as n2, b0 as _i, b3 as xl, bt as Py, bu as Dd, bv as Ty, bw as Ji, bx as Nn, by as ep, bz as Em, aT as Iy, a4 as ue, a7 as Ue, ac as Tr, bA as ac, b1 as jd, bB as ga, a3 as Ge, a6 as Re, a8 as Nd, a9 as tp, bC as Un, aj as Nr, af as Kt, B as o2, ag as jt, ah as mi, aa as vl, bD as $g, a_ as pi, bE as rp, bF as Ci, ai as ip, bG as th, ae as Rn, bH as a2, bI as s2, bJ as To, bK as wl, bL as l2, ab as np, bM as u2, bN as Wv, b9 as Ot, R as An, bO as c2, b7 as Zv, bi as jg, bP as d2, a5 as Vf, ap as op, bQ as h2, al as Ng, am as ap, ao as Vg, an as Ug, bR as My, T as lg, bS as f2, bT as ug, bU as p2, bV as m2, b5 as Zi, bW as va, bX as En, bY as Hn, bZ as sp, b_ as g2, b$ as Ey, c0 as Ry, c1 as v2, $ as Ml, c2 as _2, c3 as y2, c4 as b2, c5 as x2, c6 as Zo, r as qo, c7 as Ha, c8 as Cl, c9 as Ff, ca as Xa, cb as _s, cc as xs, cd as Xu, ce as Sl, cf as Ay, cg, ch as dg, ci as hg, cj as zd, ck as fg, cl as pg, cm as mg, cn as Uf, co as Dy, cp as zy, cq as Fy, cr as Ju, cs as qf, ct as w2, cu as lp, cv as Ly, bg as Vr, cw as C2, b6 as Gf, b4 as S2, cx as k2, cy as kl, cz as P2, a$ as By, cA as Oy, cB as T2, a0 as I2, aq as M2, cC as E2, cD as R2, cE as qg, cF as A2, cG as D2, cH as z2, cI as F2, c as rh, cJ as Wf, cK as $y, cL as jy, cM as L2, cN as Go, cO as B2, cP as O2, cQ as $2, cR as Ny, cS as j2, cT as N2, cU as Vy, cV as Uy, cW as V2, cX as U2, cY as q2, cZ as Hv, c_ as G2, X as qy, c$ as W2, d0 as Z2, d1 as H2, d2 as X2, d3 as Y2, d4 as K2, d5 as Rm, d6 as J2, d7 as Q2, d8 as Gy, d9 as Xv, da as eC, aV as Yv, db as tC, dc as ko, dd as Po, bh as Ii, U as Vd, b2 as Wy, bd as Gg, bo as wd, bc as rC, bm as Zy, bf as qa, bp as Kv, bn as iC, de as Wa, bk as nC, be as Hy, df as oC, dg as aC } from "./platform-ICJpkdTC.js";
var sC = /\s/;
function lC(r) {
  for (var i = r.length; i-- && sC.test(r.charAt(i)); ) ;
  return i;
}
var uC = /^\s+/;
function cC(r) {
  return r && r.slice(0, lC(r) + 1).replace(uC, "");
}
var Jv = NaN, dC = /^[-+]0x[0-9a-f]+$/i, hC = /^0b[01]+$/i, fC = /^0o[0-7]+$/i, pC = parseInt;
function Fd(r) {
  if (typeof r == "number") return r;
  if (i2(r)) return Jv;
  if (Nf(r)) {
    var i = typeof r.valueOf == "function" ? r.valueOf() : r;
    r = Nf(i) ? i + "" : i;
  }
  if (typeof r != "string") return r === 0 ? r : +r;
  r = cC(r);
  var l = hC.test(r);
  return l || fC.test(r) ? pC(r.slice(2), l ? 2 : 8) : dC.test(r) ? Jv : +r;
}
function mC(r, i, l, d) {
  for (var f = -1, g = r == null ? 0 : r.length; ++f < g; ) l = i(l, r[f], f, r);
  return l;
}
function gC(r) {
  return function(i) {
    return r == null ? void 0 : r[i];
  };
}
var vC = { \u00C0: "A", \u00C1: "A", \u00C2: "A", \u00C3: "A", \u00C4: "A", \u00C5: "A", \u00E0: "a", \u00E1: "a", \u00E2: "a", \u00E3: "a", \u00E4: "a", \u00E5: "a", \u00C7: "C", \u00E7: "c", \u00D0: "D", \u00F0: "d", \u00C8: "E", \u00C9: "E", \u00CA: "E", \u00CB: "E", \u00E8: "e", \u00E9: "e", \u00EA: "e", \u00EB: "e", \u00CC: "I", \u00CD: "I", \u00CE: "I", \u00CF: "I", \u00EC: "i", \u00ED: "i", \u00EE: "i", \u00EF: "i", \u00D1: "N", \u00F1: "n", \u00D2: "O", \u00D3: "O", \u00D4: "O", \u00D5: "O", \u00D6: "O", \u00D8: "O", \u00F2: "o", \u00F3: "o", \u00F4: "o", \u00F5: "o", \u00F6: "o", \u00F8: "o", \u00D9: "U", \u00DA: "U", \u00DB: "U", \u00DC: "U", \u00F9: "u", \u00FA: "u", \u00FB: "u", \u00FC: "u", \u00DD: "Y", \u00FD: "y", \u00FF: "y", \u00C6: "Ae", \u00E6: "ae", \u00DE: "Th", \u00FE: "th", \u00DF: "ss", \u0100: "A", \u0102: "A", \u0104: "A", \u0101: "a", \u0103: "a", \u0105: "a", \u0106: "C", \u0108: "C", \u010A: "C", \u010C: "C", \u0107: "c", \u0109: "c", \u010B: "c", \u010D: "c", \u010E: "D", \u0110: "D", \u010F: "d", \u0111: "d", \u0112: "E", \u0114: "E", \u0116: "E", \u0118: "E", \u011A: "E", \u0113: "e", \u0115: "e", \u0117: "e", \u0119: "e", \u011B: "e", \u011C: "G", \u011E: "G", \u0120: "G", \u0122: "G", \u011D: "g", \u011F: "g", \u0121: "g", \u0123: "g", \u0124: "H", \u0126: "H", \u0125: "h", \u0127: "h", \u0128: "I", \u012A: "I", \u012C: "I", \u012E: "I", \u0130: "I", \u0129: "i", \u012B: "i", \u012D: "i", \u012F: "i", \u0131: "i", \u0134: "J", \u0135: "j", \u0136: "K", \u0137: "k", \u0138: "k", \u0139: "L", \u013B: "L", \u013D: "L", \u013F: "L", \u0141: "L", \u013A: "l", \u013C: "l", \u013E: "l", \u0140: "l", \u0142: "l", \u0143: "N", \u0145: "N", \u0147: "N", \u014A: "N", \u0144: "n", \u0146: "n", \u0148: "n", \u014B: "n", \u014C: "O", \u014E: "O", \u0150: "O", \u014D: "o", \u014F: "o", \u0151: "o", \u0154: "R", \u0156: "R", \u0158: "R", \u0155: "r", \u0157: "r", \u0159: "r", \u015A: "S", \u015C: "S", \u015E: "S", \u0160: "S", \u015B: "s", \u015D: "s", \u015F: "s", \u0161: "s", \u0162: "T", \u0164: "T", \u0166: "T", \u0163: "t", \u0165: "t", \u0167: "t", \u0168: "U", \u016A: "U", \u016C: "U", \u016E: "U", \u0170: "U", \u0172: "U", \u0169: "u", \u016B: "u", \u016D: "u", \u016F: "u", \u0171: "u", \u0173: "u", \u0174: "W", \u0175: "w", \u0176: "Y", \u0177: "y", \u0178: "Y", \u0179: "Z", \u017B: "Z", \u017D: "Z", \u017A: "z", \u017C: "z", \u017E: "z", \u0132: "IJ", \u0133: "ij", \u0152: "Oe", \u0153: "oe", \u0149: "'n", \u017F: "s" }, _C = gC(vC), yC = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, bC = "\\u0300-\\u036f", xC = "\\ufe20-\\ufe2f", wC = "\\u20d0-\\u20ff", CC = bC + xC + wC, SC = "[" + CC + "]", kC = RegExp(SC, "g");
function PC(r) {
  return r = ky(r), r && r.replace(yC, _C).replace(kC, "");
}
var TC = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function IC(r) {
  return r.match(TC) || [];
}
var MC = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function EC(r) {
  return MC.test(r);
}
var Xy = "\\ud800-\\udfff", RC = "\\u0300-\\u036f", AC = "\\ufe20-\\ufe2f", DC = "\\u20d0-\\u20ff", zC = RC + AC + DC, Yy = "\\u2700-\\u27bf", Ky = "a-z\\xdf-\\xf6\\xf8-\\xff", FC = "\\xac\\xb1\\xd7\\xf7", LC = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", BC = "\\u2000-\\u206f", OC = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Jy = "A-Z\\xc0-\\xd6\\xd8-\\xde", $C = "\\ufe0e\\ufe0f", Qy = FC + LC + BC + OC, eb = "['\u2019]", Qv = "[" + Qy + "]", jC = "[" + zC + "]", tb = "\\d+", NC = "[" + Yy + "]", rb = "[" + Ky + "]", ib = "[^" + Xy + Qy + tb + Yy + Ky + Jy + "]", VC = "\\ud83c[\\udffb-\\udfff]", UC = "(?:" + jC + "|" + VC + ")", qC = "[^" + Xy + "]", nb = "(?:\\ud83c[\\udde6-\\uddff]){2}", ob = "[\\ud800-\\udbff][\\udc00-\\udfff]", Zu = "[" + Jy + "]", GC = "\\u200d", e_ = "(?:" + rb + "|" + ib + ")", WC = "(?:" + Zu + "|" + ib + ")", t_ = "(?:" + eb + "(?:d|ll|m|re|s|t|ve))?", r_ = "(?:" + eb + "(?:D|LL|M|RE|S|T|VE))?", ab = UC + "?", sb = "[" + $C + "]?", ZC = "(?:" + GC + "(?:" + [qC, nb, ob].join("|") + ")" + sb + ab + ")*", HC = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", XC = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", YC = sb + ab + ZC, KC = "(?:" + [NC, nb, ob].join("|") + ")" + YC, JC = RegExp([Zu + "?" + rb + "+" + t_ + "(?=" + [Qv, Zu, "$"].join("|") + ")", WC + "+" + r_ + "(?=" + [Qv, Zu + e_, "$"].join("|") + ")", Zu + "?" + e_ + "+" + t_, Zu + "+" + r_, XC, HC, tb, KC].join("|"), "g");
function QC(r) {
  return r.match(JC) || [];
}
function e3(r, i, l) {
  return r = ky(r), i = i, i === void 0 ? EC(r) ? QC(r) : IC(r) : r.match(i) || [];
}
var t3 = "['\u2019]", r3 = RegExp(t3, "g");
function i3(r) {
  return function(i) {
    return mC(e3(PC(i).replace(r3, "")), r, "");
  };
}
function n3(r, i, l) {
  return r === r && (l !== void 0 && (r = r <= l ? r : l), i !== void 0 && (r = r >= i ? r : i)), r;
}
function gg(r, i, l) {
  return l === void 0 && (l = i, i = void 0), l !== void 0 && (l = Fd(l), l = l === l ? l : 0), i !== void 0 && (i = Fd(i), i = i === i ? i : 0), n3(Fd(r), i, l);
}
var Am = function() {
  return Uw.Date.now();
}, o3 = "Expected a function", a3 = Math.max, s3 = Math.min;
function l3(r, i, l) {
  var d, f, g, m, s, C, T = 0, M = false, z = false, L = true;
  if (typeof r != "function") throw new TypeError(o3);
  i = Fd(i) || 0, Nf(l) && (M = !!l.leading, z = "maxWait" in l, g = z ? a3(Fd(l.maxWait) || 0, i) : g, L = "trailing" in l ? !!l.trailing : L);
  function A(J) {
    var Se = d, fe = f;
    return d = f = void 0, T = J, m = r.apply(fe, Se), m;
  }
  function O(J) {
    return T = J, s = setTimeout(W, i), M ? A(J) : m;
  }
  function V(J) {
    var Se = J - C, fe = J - T, oe = i - Se;
    return z ? s3(oe, g - fe) : oe;
  }
  function X(J) {
    var Se = J - C, fe = J - T;
    return C === void 0 || Se >= i || Se < 0 || z && fe >= g;
  }
  function W() {
    var J = Am();
    if (X(J)) return K(J);
    s = setTimeout(W, V(J));
  }
  function K(J) {
    return s = void 0, L && d ? A(J) : (d = f = void 0, m);
  }
  function ie() {
    s !== void 0 && clearTimeout(s), T = 0, d = C = f = s = void 0;
  }
  function ee() {
    return s === void 0 ? m : K(Am());
  }
  function re() {
    var J = Am(), Se = X(J);
    if (d = arguments, f = this, C = J, Se) {
      if (s === void 0) return O(C);
      if (z) return clearTimeout(s), s = setTimeout(W, i), A(C);
    }
    return s === void 0 && (s = setTimeout(W, i)), m;
  }
  return re.cancel = ie, re.flush = ee, re;
}
var u3 = i3(function(r, i, l) {
  return r + (l ? "-" : "") + i.toLowerCase();
}), c3 = "Expected a function";
function d3(r, i, l) {
  var d = true, f = true;
  if (typeof r != "function") throw new TypeError(c3);
  return Nf(l) && (d = "leading" in l ? !!l.leading : d, f = "trailing" in l ? !!l.trailing : f), l3(r, i, { leading: d, maxWait: i, trailing: f });
}
const h3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, f3 = st({ name: "BrandGithub", render: function(i, l) {
  return St(), Yt("svg", h3, l[0] || (l[0] = [Tt("path", { d: "M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2c2.8-.3 5.5-1.4 5.5-6a4.6 4.6 0 0 0-1.3-3.2a4.2 4.2 0 0 0-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3 0 0 0-6.2 0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2 0 0 0-.1 3.2A4.6 4.6 0 0 0 4 9.5c0 4.6 2.7 5.7 5.5 6c-.6.6-.6 1.2-.5 2V21", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), p3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, m3 = st({ name: "Calendar", render: function(i, l) {
  return St(), Yt("svg", p3, l[0] || (l[0] = [Qd('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="5" width="16" height="16" rx="2"></rect><path d="M16 3v4"></path><path d="M8 3v4"></path><path d="M4 11h16"></path><path d="M11 15h1"></path><path d="M12 15v3"></path></g>', 1)]));
} }), g3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, v3 = st({ name: "DeviceFloppy", render: function(i, l) {
  return St(), Yt("svg", g3, l[0] || (l[0] = [Tt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [Tt("path", { d: "M6 4h10l4 4v10a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2" }), Tt("circle", { cx: "12", cy: "14", r: "2" }), Tt("path", { d: "M14 4v4H8V4" })], -1)]));
} }), _3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, y3 = st({ name: "Edit", render: function(i, l) {
  return St(), Yt("svg", _3, l[0] || (l[0] = [Tt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [Tt("path", { d: "M9 7H6a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h9a2 2 0 0 0 2-2v-3" }), Tt("path", { d: "M9 15h3l8.5-8.5a1.5 1.5 0 0 0-3-3L9 12v3" }), Tt("path", { d: "M16 5l3 3" })], -1)]));
} }), b3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, lb = st({ name: "FileText", render: function(i, l) {
  return St(), Yt("svg", b3, l[0] || (l[0] = [Qd('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 3v4a1 1 0 0 0 1 1h4"></path><path d="M17 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7l5 5v11a2 2 0 0 1-2 2z"></path><path d="M9 9h1"></path><path d="M9 13h6"></path><path d="M9 17h6"></path></g>', 1)]));
} }), x3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, w3 = st({ name: "Folder", render: function(i, l) {
  return St(), Yt("svg", x3, l[0] || (l[0] = [Tt("path", { d: "M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), C3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, S3 = st({ name: "HandFinger", render: function(i, l) {
  return St(), Yt("svg", C3, l[0] || (l[0] = [Qd('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 13V4.5a1.5 1.5 0 0 1 3 0V12"></path><path d="M11 11.5v-2a1.5 1.5 0 1 1 3 0V12"></path><path d="M14 10.5a1.5 1.5 0 0 1 3 0V12"></path><path d="M17 11.5a1.5 1.5 0 0 1 3 0V16a6 6 0 0 1-6 6h-2h.208a6 6 0 0 1-5.012-2.7A69.74 69.74 0 0 1 7 19c-.312-.479-1.407-2.388-3.286-5.728a1.5 1.5 0 0 1 .536-2.022a1.867 1.867 0 0 1 2.28.28L8 13"></path></g>', 1)]));
} }), k3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, P3 = st({ name: "Line", render: function(i, l) {
  return St(), Yt("svg", k3, l[0] || (l[0] = [Tt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [Tt("circle", { cx: "6", cy: "18", r: "2" }), Tt("circle", { cx: "18", cy: "6", r: "2" }), Tt("path", { d: "M7.5 16.5l9-9" })], -1)]));
} }), T3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, i_ = st({ name: "Link", render: function(i, l) {
  return St(), Yt("svg", T3, l[0] || (l[0] = [Tt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [Tt("path", { d: "M10 14a3.5 3.5 0 0 0 5 0l4-4a3.5 3.5 0 0 0-5-5l-.5.5" }), Tt("path", { d: "M14 10a3.5 3.5 0 0 0-5 0l-4 4a3.5 3.5 0 0 0 5 5l.5-.5" })], -1)]));
} }), I3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, M3 = st({ name: "Minus", render: function(i, l) {
  return St(), Yt("svg", I3, l[0] || (l[0] = [Tt("path", { d: "M5 12h14", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), E3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, R3 = st({ name: "PlayerRecord", render: function(i, l) {
  return St(), Yt("svg", E3, l[0] || (l[0] = [Tt("circle", { cx: "12", cy: "12", r: "7", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), A3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Ud = st({ name: "Plus", render: function(i, l) {
  return St(), Yt("svg", A3, l[0] || (l[0] = [Tt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [Tt("path", { d: "M12 5v14" }), Tt("path", { d: "M5 12h14" })], -1)]));
} }), D3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Wg = st({ name: "Route", render: function(i, l) {
  return St(), Yt("svg", D3, l[0] || (l[0] = [Tt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [Tt("circle", { cx: "6", cy: "19", r: "2" }), Tt("circle", { cx: "18", cy: "5", r: "2" }), Tt("path", { d: "M12 19h4.5a3.5 3.5 0 0 0 0-7h-8a3.5 3.5 0 0 1 0-7H12" })], -1)]));
} }), z3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, ub = st({ name: "Shape", render: function(i, l) {
  return St(), Yt("svg", z3, l[0] || (l[0] = [Qd('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="5" cy="5" r="2"></circle><circle cx="19" cy="5" r="2"></circle><circle cx="5" cy="19" r="2"></circle><circle cx="19" cy="19" r="2"></circle><path d="M5 7v10"></path><path d="M7 5h10"></path><path d="M7 19h10"></path><path d="M19 7v10"></path></g>', 1)]));
} }), F3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, L3 = st({ name: "Square", render: function(i, l) {
  return St(), Yt("svg", F3, l[0] || (l[0] = [Tt("rect", { x: "4", y: "4", width: "16", height: "16", rx: "2", fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, null, -1)]));
} }), B3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, up = st({ name: "Trash", render: function(i, l) {
  return St(), Yt("svg", B3, l[0] || (l[0] = [Qd('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 7h16"></path><path d="M10 11v6"></path><path d="M14 11v6"></path><path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2l1-12"></path><path d="M9 7V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3"></path></g>', 1)]));
} }), O3 = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, cb = st({ name: "Upload", render: function(i, l) {
  return St(), Yt("svg", O3, l[0] || (l[0] = [Tt("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [Tt("path", { d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2" }), Tt("path", { d: "M7 9l5-5l5 5" }), Tt("path", { d: "M12 4v12" })], -1)]));
} });
function db(r) {
  return typeof r == "string" ? document.querySelector(r) : typeof r == "function" ? r() : r;
}
function $3(r) {
  if (typeof r == "number") return { "": r.toString() };
  const i = {};
  return r.split(/ +/).forEach((l) => {
    if (l === "") return;
    const [d, f] = l.split(":");
    f === void 0 ? i[""] = d : i[d] = f;
  }), i;
}
function $u(r, i) {
  var l;
  if (r == null) return;
  const d = $3(r);
  if (i === void 0) return d[""];
  if (typeof i == "string") return (l = d[i]) !== null && l !== void 0 ? l : d[""];
  if (Array.isArray(i)) {
    for (let f = i.length - 1; f >= 0; --f) {
      const g = i[f];
      if (g in d) return d[g];
    }
    return d[""];
  } else {
    let f, g = -1;
    return Object.keys(d).forEach((m) => {
      const s = Number(m);
      !Number.isNaN(s) && i >= s && s >= g && (g = s, f = d[m]);
    }), f;
  }
}
const j3 = { xs: 0, s: 640, m: 1024, l: 1280, xl: 1536, "2xl": 1920 };
function N3(r) {
  return `(min-width: ${r}px)`;
}
const Cd = {};
function V3(r = j3) {
  if (!n2) return ze(() => []);
  if (typeof window.matchMedia != "function") return ze(() => []);
  const i = Ae({}), l = Object.keys(r), d = (f, g) => {
    f.matches ? i.value[g] = true : i.value[g] = false;
  };
  return l.forEach((f) => {
    const g = r[f];
    let m, s;
    Cd[g] === void 0 ? (m = window.matchMedia(N3(g)), m.addEventListener ? m.addEventListener("change", (C) => {
      s.forEach((T) => {
        T(C, f);
      });
    }) : m.addListener && m.addListener((C) => {
      s.forEach((T) => {
        T(C, f);
      });
    }), s = /* @__PURE__ */ new Set(), Cd[g] = { mql: m, cbs: s }) : (m = Cd[g].mql, s = Cd[g].cbs), s.add(d), m.matches && s.forEach((C) => {
      C(m, f);
    });
  }), Sn(() => {
    l.forEach((f) => {
      const { cbs: g } = Cd[r[f]];
      g.has(d) && g.delete(d);
    });
  }), ze(() => {
    const { value: f } = i;
    return l.filter((g) => f[g]);
  });
}
function U3(r, i, l) {
  var d;
  const f = fr(r, null);
  if (f === null) return;
  const g = (d = eh()) === null || d === void 0 ? void 0 : d.proxy;
  ar(l, m), m(l.value), Sn(() => {
    m(void 0, l.value);
  });
  function m(T, M) {
    if (!f) return;
    const z = f[i];
    M !== void 0 && s(z, M), T !== void 0 && C(z, T);
  }
  function s(T, M) {
    T[M] || (T[M] = []), T[M].splice(T[M].findIndex((z) => z === g), 1);
  }
  function C(T, M) {
    T[M] || (T[M] = []), ~T[M].findIndex((z) => z === g) || T[M].push(g);
  }
}
function q3(r, i, l) {
  const d = fr(r, null);
  d !== null && (i in d || (d[i] = []), d[i].push(l.value), ar(l, (f, g) => {
    const m = d[i], s = m.findIndex((C) => C === g);
    ~s && m.splice(s, 1), m.push(f);
  }), Sn(() => {
    const f = d[i], g = f.findIndex((m) => m === l.value);
    ~g && f.splice(g, 1);
  }));
}
function G3(r, i, l) {
  const d = fr(r, null);
  d !== null && (i in d || (d[i] = []), Qi(() => {
    const f = l();
    f && d[i].push(f);
  }), Sn(() => {
    const f = d[i], g = l(), m = f.findIndex((s) => s === g);
    ~m && f.splice(m, 1);
  }));
}
function n_(r) {
  return r & -r;
}
class hb {
  constructor(i, l) {
    this.l = i, this.min = l;
    const d = new Array(i + 1);
    for (let f = 0; f < i + 1; ++f) d[f] = 0;
    this.ft = d;
  }
  add(i, l) {
    if (l === 0) return;
    const { l: d, ft: f } = this;
    for (i += 1; i <= d; ) f[i] += l, i += n_(i);
  }
  get(i) {
    return this.sum(i + 1) - this.sum(i);
  }
  sum(i) {
    if (i === void 0 && (i = this.l), i <= 0) return 0;
    const { ft: l, min: d, l: f } = this;
    if (i > f) throw new Error("[FinweckTree.sum]: `i` is larger than length.");
    let g = i * d;
    for (; i > 0; ) g += l[i], i -= n_(i);
    return g;
  }
  getBound(i) {
    let l = 0, d = this.l;
    for (; d > l; ) {
      const f = Math.floor((l + d) / 2), g = this.sum(f);
      if (g > i) {
        d = f;
        continue;
      } else if (g < i) {
        if (l === f) return this.sum(l + 1) <= i ? l + 1 : f;
        l = f;
      } else return f;
    }
    return l;
  }
}
let yf;
function W3() {
  return typeof document > "u" ? false : (yf === void 0 && ("matchMedia" in window ? yf = window.matchMedia("(pointer:coarse)").matches : yf = false), yf);
}
let Dm;
function o_() {
  return typeof document > "u" ? 1 : (Dm === void 0 && (Dm = "chrome" in window ? window.devicePixelRatio : 1), Dm);
}
const fb = "VVirtualListXScroll";
function Z3({ columnsRef: r, renderColRef: i, renderItemWithColsRef: l }) {
  const d = Ae(0), f = Ae(0), g = ze(() => {
    const T = r.value;
    if (T.length === 0) return null;
    const M = new hb(T.length, 0);
    return T.forEach((z, L) => {
      M.add(L, z.width);
    }), M;
  }), m = _i(() => {
    const T = g.value;
    return T !== null ? Math.max(T.getBound(f.value) - 1, 0) : 0;
  }), s = (T) => {
    const M = g.value;
    return M !== null ? M.sum(T) : 0;
  }, C = _i(() => {
    const T = g.value;
    return T !== null ? Math.min(T.getBound(f.value + d.value) + 1, r.value.length - 1) : 0;
  });
  return Yr(fb, { startIndexRef: m, endIndexRef: C, columnsRef: r, renderColRef: i, renderItemWithColsRef: l, getLeft: s }), { listWidthRef: d, scrollLeftRef: f };
}
const a_ = st({ name: "VirtualListRow", props: { index: { type: Number, required: true }, item: { type: Object, required: true } }, setup() {
  const { startIndexRef: r, endIndexRef: i, columnsRef: l, getLeft: d, renderColRef: f, renderItemWithColsRef: g } = fr(fb);
  return { startIndex: r, endIndex: i, columns: l, renderCol: f, renderItemWithCols: g, getLeft: d };
}, render() {
  const { startIndex: r, endIndex: i, columns: l, renderCol: d, renderItemWithCols: f, getLeft: g, item: m } = this;
  if (f != null) return f({ itemIndex: this.index, startColIndex: r, endColIndex: i, allColumns: l, item: m, getLeft: g });
  if (d != null) {
    const s = [];
    for (let C = r; C <= i; ++C) {
      const T = l[C];
      s.push(d({ column: T, left: g(C), item: m }));
    }
    return s;
  }
  return null;
} }), H3 = Dd(".v-vl", { maxHeight: "inherit", height: "100%", overflow: "auto", minWidth: "1px" }, [Dd("&:not(.v-vl--show-scrollbar)", { scrollbarWidth: "none" }, [Dd("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", { width: 0, height: 0, display: "none" })])]), X3 = st({ name: "VirtualList", inheritAttrs: false, props: { showScrollbar: { type: Boolean, default: true }, columns: { type: Array, default: () => [] }, renderCol: Function, renderItemWithCols: Function, items: { type: Array, default: () => [] }, itemSize: { type: Number, required: true }, itemResizable: Boolean, itemsStyle: [String, Object], visibleItemsTag: { type: [String, Object], default: "div" }, visibleItemsProps: Object, ignoreItemResize: Boolean, onScroll: Function, onWheel: Function, onResize: Function, defaultScrollKey: [Number, String], defaultScrollIndex: Number, keyField: { type: String, default: "key" }, paddingTop: { type: [Number, String], default: 0 }, paddingBottom: { type: [Number, String], default: 0 } }, setup(r) {
  const i = Py();
  H3.mount({ id: "vueuc/virtual-list", head: true, anchorMetaName: Ty, ssr: i }), Qi(() => {
    const { defaultScrollIndex: Ve, defaultScrollKey: Ke } = r;
    Ve != null ? X({ index: Ve }) : Ke != null && X({ key: Ke });
  });
  let l = false, d = false;
  qw(() => {
    if (l = false, !d) {
      d = true;
      return;
    }
    X({ top: A.value, left: m.value });
  }), xy(() => {
    l = true, d || (d = true);
  });
  const f = _i(() => {
    if (r.renderCol == null && r.renderItemWithCols == null || r.columns.length === 0) return;
    let Ve = 0;
    return r.columns.forEach((Ke) => {
      Ve += Ke.width;
    }), Ve;
  }), g = ze(() => {
    const Ve = /* @__PURE__ */ new Map(), { keyField: Ke } = r;
    return r.items.forEach((lt, vt) => {
      Ve.set(lt[Ke], vt);
    }), Ve;
  }), { scrollLeftRef: m, listWidthRef: s } = Z3({ columnsRef: Dt(r, "columns"), renderColRef: Dt(r, "renderCol"), renderItemWithColsRef: Dt(r, "renderItemWithCols") }), C = Ae(null), T = Ae(void 0), M = /* @__PURE__ */ new Map(), z = ze(() => {
    const { items: Ve, itemSize: Ke, keyField: lt } = r, vt = new hb(Ve.length, Ke);
    return Ve.forEach((wt, at) => {
      const et = wt[lt], ht = M.get(et);
      ht !== void 0 && vt.add(at, ht);
    }), vt;
  }), L = Ae(0), A = Ae(0), O = _i(() => Math.max(z.value.getBound(A.value - Ji(r.paddingTop)) - 1, 0)), V = ze(() => {
    const { value: Ve } = T;
    if (Ve === void 0) return [];
    const { items: Ke, itemSize: lt } = r, vt = O.value, wt = Math.min(vt + Math.ceil(Ve / lt + 1), Ke.length - 1), at = [];
    for (let et = vt; et <= wt; ++et) at.push(Ke[et]);
    return at;
  }), X = (Ve, Ke) => {
    if (typeof Ve == "number") {
      ee(Ve, Ke, "auto");
      return;
    }
    const { left: lt, top: vt, index: wt, key: at, position: et, behavior: ht, debounce: yt = true } = Ve;
    if (lt !== void 0 || vt !== void 0) ee(lt, vt, ht);
    else if (wt !== void 0) ie(wt, ht, yt);
    else if (at !== void 0) {
      const nt = g.value.get(at);
      nt !== void 0 && ie(nt, ht, yt);
    } else et === "bottom" ? ee(0, Number.MAX_SAFE_INTEGER, ht) : et === "top" && ee(0, 0, ht);
  };
  let W, K = null;
  function ie(Ve, Ke, lt) {
    const { value: vt } = z, wt = vt.sum(Ve) + Ji(r.paddingTop);
    if (!lt) C.value.scrollTo({ left: 0, top: wt, behavior: Ke });
    else {
      W = Ve, K !== null && window.clearTimeout(K), K = window.setTimeout(() => {
        W = void 0, K = null;
      }, 16);
      const { scrollTop: at, offsetHeight: et } = C.value;
      if (wt > at) {
        const ht = vt.get(Ve);
        wt + ht <= at + et || C.value.scrollTo({ left: 0, top: wt + ht - et, behavior: Ke });
      } else C.value.scrollTo({ left: 0, top: wt, behavior: Ke });
    }
  }
  function ee(Ve, Ke, lt) {
    C.value.scrollTo({ left: Ve, top: Ke, behavior: lt });
  }
  function re(Ve, Ke) {
    var lt, vt, wt;
    if (l || r.ignoreItemResize || je(Ke.target)) return;
    const { value: at } = z, et = g.value.get(Ve), ht = at.get(et), yt = (wt = (vt = (lt = Ke.borderBoxSize) === null || lt === void 0 ? void 0 : lt[0]) === null || vt === void 0 ? void 0 : vt.blockSize) !== null && wt !== void 0 ? wt : Ke.contentRect.height;
    if (yt === ht) return;
    yt - r.itemSize === 0 ? M.delete(Ve) : M.set(Ve, yt - r.itemSize);
    const ut = yt - ht;
    if (ut === 0) return;
    at.add(et, ut);
    const Ft = C.value;
    if (Ft != null) {
      if (W === void 0) {
        const Ht = at.sum(et);
        Ft.scrollTop > Ht && Ft.scrollBy(0, ut);
      } else if (et < W) Ft.scrollBy(0, ut);
      else if (et === W) {
        const Ht = at.sum(et);
        yt + Ht > Ft.scrollTop + Ft.offsetHeight && Ft.scrollBy(0, ut);
      }
      be();
    }
    L.value++;
  }
  const J = !W3();
  let Se = false;
  function fe(Ve) {
    var Ke;
    (Ke = r.onScroll) === null || Ke === void 0 || Ke.call(r, Ve), (!J || !Se) && be();
  }
  function oe(Ve) {
    var Ke;
    if ((Ke = r.onWheel) === null || Ke === void 0 || Ke.call(r, Ve), J) {
      const lt = C.value;
      if (lt != null) {
        if (Ve.deltaX === 0 && (lt.scrollTop === 0 && Ve.deltaY <= 0 || lt.scrollTop + lt.offsetHeight >= lt.scrollHeight && Ve.deltaY >= 0)) return;
        Ve.preventDefault(), lt.scrollTop += Ve.deltaY / o_(), lt.scrollLeft += Ve.deltaX / o_(), be(), Se = true, ep(() => {
          Se = false;
        });
      }
    }
  }
  function he(Ve) {
    if (l || je(Ve.target)) return;
    if (r.renderCol == null && r.renderItemWithCols == null) {
      if (Ve.contentRect.height === T.value) return;
    } else if (Ve.contentRect.height === T.value && Ve.contentRect.width === s.value) return;
    T.value = Ve.contentRect.height, s.value = Ve.contentRect.width;
    const { onResize: Ke } = r;
    Ke !== void 0 && Ke(Ve);
  }
  function be() {
    const { value: Ve } = C;
    Ve != null && (A.value = Ve.scrollTop, m.value = Ve.scrollLeft);
  }
  function je(Ve) {
    let Ke = Ve;
    for (; Ke !== null; ) {
      if (Ke.style.display === "none") return true;
      Ke = Ke.parentElement;
    }
    return false;
  }
  return { listHeight: T, listStyle: { overflow: "auto" }, keyToIndex: g, itemsStyle: ze(() => {
    const { itemResizable: Ve } = r, Ke = Nn(z.value.sum());
    return L.value, [r.itemsStyle, { boxSizing: "content-box", width: Nn(f.value), height: Ve ? "" : Ke, minHeight: Ve ? Ke : "", paddingTop: Nn(r.paddingTop), paddingBottom: Nn(r.paddingBottom) }];
  }), visibleItemsStyle: ze(() => (L.value, { transform: `translateY(${Nn(z.value.sum(O.value))})` })), viewportItems: V, listElRef: C, itemsElRef: Ae(null), scrollTo: X, handleListResize: he, handleListScroll: fe, handleListWheel: oe, handleItemResize: re };
}, render() {
  const { itemResizable: r, keyField: i, keyToIndex: l, visibleItemsTag: d } = this;
  return F(xl, { onResize: this.handleListResize }, { default: () => {
    var f, g;
    return F("div", Ya(this.$attrs, { class: ["v-vl", this.showScrollbar && "v-vl--show-scrollbar"], onScroll: this.handleListScroll, onWheel: this.handleListWheel, ref: "listElRef" }), [this.items.length !== 0 ? F("div", { ref: "itemsElRef", class: "v-vl-items", style: this.itemsStyle }, [F(d, Object.assign({ class: "v-vl-visible-items", style: this.visibleItemsStyle }, this.visibleItemsProps), { default: () => {
      const { renderCol: m, renderItemWithCols: s } = this;
      return this.viewportItems.map((C) => {
        const T = C[i], M = l.get(T), z = m != null ? F(a_, { index: M, item: C }) : void 0, L = s != null ? F(a_, { index: M, item: C }) : void 0, A = this.$slots.default({ item: C, renderedCols: z, renderedItemWithCols: L, index: M })[0];
        return r ? F(xl, { key: T, onResize: (O) => this.handleItemResize(T, O) }, { default: () => A }) : (A.key = T, A);
      });
    } })]) : (g = (f = this.$slots).empty) === null || g === void 0 ? void 0 : g.call(f)]);
  } });
} }), Y3 = Dd(".v-x-scroll", { overflow: "auto", scrollbarWidth: "none" }, [Dd("&::-webkit-scrollbar", { width: 0, height: 0 })]), K3 = st({ name: "XScroll", props: { disabled: Boolean, onScroll: Function }, setup() {
  const r = Ae(null);
  function i(f) {
    !(f.currentTarget.offsetWidth < f.currentTarget.scrollWidth) || f.deltaY === 0 || (f.currentTarget.scrollLeft += f.deltaY + f.deltaX, f.preventDefault());
  }
  const l = Py();
  return Y3.mount({ id: "vueuc/x-scroll", head: true, anchorMetaName: Ty, ssr: l }), Object.assign({ selfRef: r, handleWheel: i }, { scrollTo(...f) {
    var g;
    (g = r.value) === null || g === void 0 || g.scrollTo(...f);
  } });
}, render() {
  return F("div", { ref: "selfRef", onScroll: this.onScroll, onWheel: this.disabled ? void 0 : this.handleWheel, class: "v-x-scroll" }, this.$slots);
} });
function pb(r, i) {
  i && (Qi(() => {
    const { value: l } = r;
    l && Em.registerHandler(l, i);
  }), ar(r, (l, d) => {
    d && Em.unregisterHandler(d);
  }, { deep: false }), Sn(() => {
    const { value: l } = r;
    l && Em.unregisterHandler(l);
  }));
}
function mb(r, i) {
  if (!r) return;
  const l = document.createElement("a");
  l.href = r, i !== void 0 && (l.download = i), document.body.appendChild(l), l.click(), document.body.removeChild(l);
}
function vg(r) {
  switch (typeof r) {
    case "string":
      return r || void 0;
    case "number":
      return String(r);
    default:
      return;
  }
}
const J3 = { tiny: "mini", small: "tiny", medium: "small", large: "medium", huge: "large" };
function Q3(r) {
  const i = J3[r];
  if (i === void 0) throw new Error(`${r} has no smaller size.`);
  return i;
}
function cp(r, i = "default", l = []) {
  const f = r.$slots[i];
  return f === void 0 ? l : f();
}
function eS(r) {
  var i;
  const l = (i = r.dirs) === null || i === void 0 ? void 0 : i.find(({ dir: d }) => d === Ka);
  return !!(l && l.value === false);
}
function zm(r) {
  const i = r.filter((l) => l !== void 0);
  if (i.length !== 0) return i.length === 1 ? i[0] : (l) => {
    r.forEach((d) => {
      d && d(l);
    });
  };
}
const tS = { name: "en-US", global: { undo: "Undo", redo: "Redo", confirm: "Confirm", clear: "Clear" }, Popconfirm: { positiveText: "Confirm", negativeText: "Cancel" }, Cascader: { placeholder: "Please Select", loading: "Loading", loadingRequiredMessage: (r) => `Please load all ${r}'s descendants before checking it.` }, Time: { dateFormat: "yyyy-MM-dd", dateTimeFormat: "yyyy-MM-dd HH:mm:ss" }, DatePicker: { yearFormat: "yyyy", monthFormat: "MMM", dayFormat: "eeeeee", yearTypeFormat: "yyyy", monthTypeFormat: "yyyy-MM", dateFormat: "yyyy-MM-dd", dateTimeFormat: "yyyy-MM-dd HH:mm:ss", quarterFormat: "yyyy-qqq", weekFormat: "YYYY-w", clear: "Clear", now: "Now", confirm: "Confirm", selectTime: "Select Time", selectDate: "Select Date", datePlaceholder: "Select Date", datetimePlaceholder: "Select Date and Time", monthPlaceholder: "Select Month", yearPlaceholder: "Select Year", quarterPlaceholder: "Select Quarter", weekPlaceholder: "Select Week", startDatePlaceholder: "Start Date", endDatePlaceholder: "End Date", startDatetimePlaceholder: "Start Date and Time", endDatetimePlaceholder: "End Date and Time", startMonthPlaceholder: "Start Month", endMonthPlaceholder: "End Month", monthBeforeYear: true, firstDayOfWeek: 6, today: "Today" }, DataTable: { checkTableAll: "Select all in the table", uncheckTableAll: "Unselect all in the table", confirm: "Confirm", clear: "Clear" }, LegacyTransfer: { sourceTitle: "Source", targetTitle: "Target" }, Transfer: { selectAll: "Select all", unselectAll: "Unselect all", clearAll: "Clear", total: (r) => `Total ${r} items`, selected: (r) => `${r} items selected` }, Empty: { description: "No Data" }, Select: { placeholder: "Please Select" }, TimePicker: { placeholder: "Select Time", positiveText: "OK", negativeText: "Cancel", now: "Now", clear: "Clear" }, Pagination: { goto: "Goto", selectionSuffix: "page" }, DynamicTags: { add: "Add" }, Log: { loading: "Loading" }, Input: { placeholder: "Please Input" }, InputNumber: { placeholder: "Please Input" }, DynamicInput: { create: "Create" }, ThemeEditor: { title: "Theme Editor", clearAllVars: "Clear All Variables", clearSearch: "Clear Search", filterCompName: "Filter Component Name", filterVarName: "Filter Variable Name", import: "Import", export: "Export", restore: "Reset to Default" }, Image: { tipPrevious: "Previous picture (\u2190)", tipNext: "Next picture (\u2192)", tipCounterclockwise: "Counterclockwise", tipClockwise: "Clockwise", tipZoomOut: "Zoom out", tipZoomIn: "Zoom in", tipDownload: "Download", tipClose: "Close (Esc)", tipOriginalSize: "Zoom to original size" }, Heatmap: { less: "less", more: "more", monthFormat: "MMM", weekdayFormat: "eee" } };
function Fm(r) {
  return (i = {}) => {
    const l = i.width ? String(i.width) : r.defaultWidth;
    return r.formats[l] || r.formats[r.defaultWidth];
  };
}
function Sd(r) {
  return (i, l) => {
    const d = (l == null ? void 0 : l.context) ? String(l.context) : "standalone";
    let f;
    if (d === "formatting" && r.formattingValues) {
      const m = r.defaultFormattingWidth || r.defaultWidth, s = (l == null ? void 0 : l.width) ? String(l.width) : m;
      f = r.formattingValues[s] || r.formattingValues[m];
    } else {
      const m = r.defaultWidth, s = (l == null ? void 0 : l.width) ? String(l.width) : r.defaultWidth;
      f = r.values[s] || r.values[m];
    }
    const g = r.argumentCallback ? r.argumentCallback(i) : i;
    return f[g];
  };
}
function kd(r) {
  return (i, l = {}) => {
    const d = l.width, f = d && r.matchPatterns[d] || r.matchPatterns[r.defaultMatchWidth], g = i.match(f);
    if (!g) return null;
    const m = g[0], s = d && r.parsePatterns[d] || r.parsePatterns[r.defaultParseWidth], C = Array.isArray(s) ? iS(s, (z) => z.test(m)) : rS(s, (z) => z.test(m));
    let T;
    T = r.valueCallback ? r.valueCallback(C) : C, T = l.valueCallback ? l.valueCallback(T) : T;
    const M = i.slice(m.length);
    return { value: T, rest: M };
  };
}
function rS(r, i) {
  for (const l in r) if (Object.prototype.hasOwnProperty.call(r, l) && i(r[l])) return l;
}
function iS(r, i) {
  for (let l = 0; l < r.length; l++) if (i(r[l])) return l;
}
function nS(r) {
  return (i, l = {}) => {
    const d = i.match(r.matchPattern);
    if (!d) return null;
    const f = d[0], g = i.match(r.parsePattern);
    if (!g) return null;
    let m = r.valueCallback ? r.valueCallback(g[0]) : g[0];
    m = l.valueCallback ? l.valueCallback(m) : m;
    const s = i.slice(f.length);
    return { value: m, rest: s };
  };
}
const oS = { lessThanXSeconds: { one: "less than a second", other: "less than {{count}} seconds" }, xSeconds: { one: "1 second", other: "{{count}} seconds" }, halfAMinute: "half a minute", lessThanXMinutes: { one: "less than a minute", other: "less than {{count}} minutes" }, xMinutes: { one: "1 minute", other: "{{count}} minutes" }, aboutXHours: { one: "about 1 hour", other: "about {{count}} hours" }, xHours: { one: "1 hour", other: "{{count}} hours" }, xDays: { one: "1 day", other: "{{count}} days" }, aboutXWeeks: { one: "about 1 week", other: "about {{count}} weeks" }, xWeeks: { one: "1 week", other: "{{count}} weeks" }, aboutXMonths: { one: "about 1 month", other: "about {{count}} months" }, xMonths: { one: "1 month", other: "{{count}} months" }, aboutXYears: { one: "about 1 year", other: "about {{count}} years" }, xYears: { one: "1 year", other: "{{count}} years" }, overXYears: { one: "over 1 year", other: "over {{count}} years" }, almostXYears: { one: "almost 1 year", other: "almost {{count}} years" } }, aS = (r, i, l) => {
  let d;
  const f = oS[r];
  return typeof f == "string" ? d = f : i === 1 ? d = f.one : d = f.other.replace("{{count}}", i.toString()), (l == null ? void 0 : l.addSuffix) ? l.comparison && l.comparison > 0 ? "in " + d : d + " ago" : d;
}, sS = { lastWeek: "'last' eeee 'at' p", yesterday: "'yesterday at' p", today: "'today at' p", tomorrow: "'tomorrow at' p", nextWeek: "eeee 'at' p", other: "P" }, lS = (r, i, l, d) => sS[r], uS = { narrow: ["B", "A"], abbreviated: ["BC", "AD"], wide: ["Before Christ", "Anno Domini"] }, cS = { narrow: ["1", "2", "3", "4"], abbreviated: ["Q1", "Q2", "Q3", "Q4"], wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"] }, dS = { narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, hS = { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, fS = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" } }, pS = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" } }, mS = (r, i) => {
  const l = Number(r), d = l % 100;
  if (d > 20 || d < 10) switch (d % 10) {
    case 1:
      return l + "st";
    case 2:
      return l + "nd";
    case 3:
      return l + "rd";
  }
  return l + "th";
}, gS = { ordinalNumber: mS, era: Sd({ values: uS, defaultWidth: "wide" }), quarter: Sd({ values: cS, defaultWidth: "wide", argumentCallback: (r) => r - 1 }), month: Sd({ values: dS, defaultWidth: "wide" }), day: Sd({ values: hS, defaultWidth: "wide" }), dayPeriod: Sd({ values: fS, defaultWidth: "wide", formattingValues: pS, defaultFormattingWidth: "wide" }) }, vS = /^(\d+)(th|st|nd|rd)?/i, _S = /\d+/i, yS = { narrow: /^(b|a)/i, abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i, wide: /^(before christ|before common era|anno domini|common era)/i }, bS = { any: [/^b/i, /^(a|c)/i] }, xS = { narrow: /^[1234]/i, abbreviated: /^q[1234]/i, wide: /^[1234](th|st|nd|rd)? quarter/i }, wS = { any: [/1/i, /2/i, /3/i, /4/i] }, CS = { narrow: /^[jfmasond]/i, abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i, wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i }, SS = { narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i], any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i] }, kS = { narrow: /^[smtwf]/i, short: /^(su|mo|tu|we|th|fr|sa)/i, abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i, wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i }, PS = { narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i], any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i] }, TS = { narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i, any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i }, IS = { any: { am: /^a/i, pm: /^p/i, midnight: /^mi/i, noon: /^no/i, morning: /morning/i, afternoon: /afternoon/i, evening: /evening/i, night: /night/i } }, MS = { ordinalNumber: nS({ matchPattern: vS, parsePattern: _S, valueCallback: (r) => parseInt(r, 10) }), era: kd({ matchPatterns: yS, defaultMatchWidth: "wide", parsePatterns: bS, defaultParseWidth: "any" }), quarter: kd({ matchPatterns: xS, defaultMatchWidth: "wide", parsePatterns: wS, defaultParseWidth: "any", valueCallback: (r) => r + 1 }), month: kd({ matchPatterns: CS, defaultMatchWidth: "wide", parsePatterns: SS, defaultParseWidth: "any" }), day: kd({ matchPatterns: kS, defaultMatchWidth: "wide", parsePatterns: PS, defaultParseWidth: "any" }), dayPeriod: kd({ matchPatterns: TS, defaultMatchWidth: "any", parsePatterns: IS, defaultParseWidth: "any" }) }, ES = { full: "EEEE, MMMM do, y", long: "MMMM do, y", medium: "MMM d, y", short: "MM/dd/yyyy" }, RS = { full: "h:mm:ss a zzzz", long: "h:mm:ss a z", medium: "h:mm:ss a", short: "h:mm a" }, AS = { full: "{{date}} 'at' {{time}}", long: "{{date}} 'at' {{time}}", medium: "{{date}}, {{time}}", short: "{{date}}, {{time}}" }, DS = { date: Fm({ formats: ES, defaultWidth: "full" }), time: Fm({ formats: RS, defaultWidth: "full" }), dateTime: Fm({ formats: AS, defaultWidth: "full" }) }, zS = { code: "en-US", formatDistance: aS, formatLong: DS, formatRelative: lS, localize: gS, match: MS, options: { weekStartsOn: 0, firstWeekContainsDate: 1 } }, FS = { name: "en-US", locale: zS };
function Ja(r) {
  const { mergedLocaleRef: i, mergedDateLocaleRef: l } = fr(Iy, null) || {}, d = ze(() => {
    var g, m;
    return (m = (g = i == null ? void 0 : i.value) === null || g === void 0 ? void 0 : g[r]) !== null && m !== void 0 ? m : tS[r];
  });
  return { dateLocaleRef: ze(() => {
    var g;
    return (g = l == null ? void 0 : l.value) !== null && g !== void 0 ? g : FS;
  }), localeRef: d };
}
const LS = ue("affix", [Ue("affixed", { position: "fixed" }, [Ue("absolute-positioned", { position: "absolute" })])]);
function BS(r) {
  return r instanceof HTMLElement ? r.scrollTop : window.scrollY;
}
function OS(r) {
  return r instanceof HTMLElement ? r.getBoundingClientRect() : { top: 0, bottom: window.innerHeight };
}
const Zg = { listenTo: [String, Object, Function], top: Number, bottom: Number, triggerTop: Number, triggerBottom: Number, position: { type: String, default: "fixed" }, offsetTop: { type: Number, validator: () => true, default: void 0 }, offsetBottom: { type: Number, validator: () => true, default: void 0 }, target: { type: Function, validator: () => true, default: void 0 } }, $S = jd(Zg), jS = st({ name: "Affix", props: Zg, setup(r) {
  const { mergedClsPrefixRef: i } = Tr(r);
  ac("-affix", LS, i);
  let l = null;
  const d = Ae(false), f = Ae(false), g = Ae(null), m = Ae(null), s = ze(() => f.value || d.value), C = ze(() => {
    var X, W;
    return (W = (X = r.triggerTop) !== null && X !== void 0 ? X : r.offsetTop) !== null && W !== void 0 ? W : r.top;
  }), T = ze(() => {
    var X, W;
    return (W = (X = r.top) !== null && X !== void 0 ? X : r.triggerTop) !== null && W !== void 0 ? W : r.offsetTop;
  }), M = ze(() => {
    var X, W;
    return (W = (X = r.bottom) !== null && X !== void 0 ? X : r.triggerBottom) !== null && W !== void 0 ? W : r.offsetBottom;
  }), z = ze(() => {
    var X, W;
    return (W = (X = r.triggerBottom) !== null && X !== void 0 ? X : r.offsetBottom) !== null && W !== void 0 ? W : r.bottom;
  }), L = Ae(null), A = () => {
    const { target: X, listenTo: W } = r;
    X ? l = X() : W ? l = db(W) : l = document, l && (l.addEventListener("scroll", O), O());
  };
  function O() {
    ep(V);
  }
  function V() {
    const { value: X } = L;
    if (!l || !X) return;
    const W = BS(l);
    if (s.value) {
      m.value !== null && W < m.value && (d.value = false, m.value = null), g.value !== null && W > g.value && (f.value = false, g.value = null);
      return;
    }
    const K = OS(l), ie = X.getBoundingClientRect(), ee = ie.top - K.top, re = K.bottom - ie.bottom, J = C.value, Se = z.value;
    J !== void 0 && ee <= J ? (d.value = true, m.value = W - (J - ee)) : (d.value = false, m.value = null), Se !== void 0 && re <= Se ? (f.value = true, g.value = W + Se - re) : (f.value = false, g.value = null);
  }
  return Qi(() => {
    A();
  }), Sn(() => {
    l && l.removeEventListener("scroll", O);
  }), { selfRef: L, affixed: s, mergedClsPrefix: i, mergedstyle: ze(() => {
    const X = {};
    return d.value && C.value !== void 0 && T.value !== void 0 && (X.top = `${T.value}px`), f.value && z.value !== void 0 && M.value !== void 0 && (X.bottom = `${M.value}px`), X;
  }) };
}, render() {
  const { mergedClsPrefix: r } = this;
  return F("div", { ref: "selfRef", class: [`${r}-affix`, { [`${r}-affix--affixed`]: this.affixed, [`${r}-affix--absolute-positioned`]: this.position === "absolute" }], style: this.mergedstyle }, this.$slots);
} }), dp = st({ name: "Add", render() {
  return F("svg", { width: "512", height: "512", viewBox: "0 0 512 512", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M256 112V400M400 256H112", stroke: "currentColor", "stroke-width": "32", "stroke-linecap": "round", "stroke-linejoin": "round" }));
} }), NS = ga("attach", () => F("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, F("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, F("g", { fill: "currentColor", "fill-rule": "nonzero" }, F("path", { d: "M3.25735931,8.70710678 L7.85355339,4.1109127 C8.82986412,3.13460197 10.4127766,3.13460197 11.3890873,4.1109127 C12.365398,5.08722343 12.365398,6.67013588 11.3890873,7.64644661 L6.08578644,12.9497475 C5.69526215,13.3402718 5.06209717,13.3402718 4.67157288,12.9497475 C4.28104858,12.5592232 4.28104858,11.9260582 4.67157288,11.5355339 L9.97487373,6.23223305 C10.1701359,6.0369709 10.1701359,5.72038841 9.97487373,5.52512627 C9.77961159,5.32986412 9.4630291,5.32986412 9.26776695,5.52512627 L3.96446609,10.8284271 C3.18341751,11.6094757 3.18341751,12.8758057 3.96446609,13.6568542 C4.74551468,14.4379028 6.01184464,14.4379028 6.79289322,13.6568542 L12.0961941,8.35355339 C13.4630291,6.98671837 13.4630291,4.77064094 12.0961941,3.40380592 C10.7293591,2.0369709 8.51328163,2.0369709 7.14644661,3.40380592 L2.55025253,8 C2.35499039,8.19526215 2.35499039,8.51184464 2.55025253,8.70710678 C2.74551468,8.90236893 3.06209717,8.90236893 3.25735931,8.70710678 Z" }))))), VS = ga("cancel", () => F("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, F("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, F("g", { fill: "currentColor", "fill-rule": "nonzero" }, F("path", { d: "M2.58859116,2.7156945 L2.64644661,2.64644661 C2.82001296,2.47288026 3.08943736,2.45359511 3.2843055,2.58859116 L3.35355339,2.64644661 L8,7.293 L12.6464466,2.64644661 C12.8417088,2.45118446 13.1582912,2.45118446 13.3535534,2.64644661 C13.5488155,2.84170876 13.5488155,3.15829124 13.3535534,3.35355339 L8.707,8 L13.3535534,12.6464466 C13.5271197,12.820013 13.5464049,13.0894374 13.4114088,13.2843055 L13.3535534,13.3535534 C13.179987,13.5271197 12.9105626,13.5464049 12.7156945,13.4114088 L12.6464466,13.3535534 L8,8.707 L3.35355339,13.3535534 C3.15829124,13.5488155 2.84170876,13.5488155 2.64644661,13.3535534 C2.45118446,13.1582912 2.45118446,12.8417088 2.64644661,12.6464466 L7.293,8 L2.64644661,3.35355339 C2.47288026,3.17998704 2.45359511,2.91056264 2.58859116,2.7156945 L2.64644661,2.64644661 L2.58859116,2.7156945 Z" }))))), US = st({ name: "Checkmark", render() {
  return F("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16" }, F("g", { fill: "none" }, F("path", { d: "M14.046 3.486a.75.75 0 0 1-.032 1.06l-7.93 7.474a.85.85 0 0 1-1.188-.022l-2.68-2.72a.75.75 0 1 1 1.068-1.053l2.234 2.267l7.468-7.038a.75.75 0 0 1 1.06.032z", fill: "currentColor" })));
} }), qS = st({ name: "ChevronDown", render() {
  return F("svg", { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M3.14645 5.64645C3.34171 5.45118 3.65829 5.45118 3.85355 5.64645L8 9.79289L12.1464 5.64645C12.3417 5.45118 12.6583 5.45118 12.8536 5.64645C13.0488 5.84171 13.0488 6.15829 12.8536 6.35355L8.35355 10.8536C8.15829 11.0488 7.84171 11.0488 7.64645 10.8536L3.14645 6.35355C2.95118 6.15829 2.95118 5.84171 3.14645 5.64645Z", fill: "currentColor" }));
} }), GS = st({ name: "ChevronLeft", render() {
  return F("svg", { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M10.3536 3.14645C10.5488 3.34171 10.5488 3.65829 10.3536 3.85355L6.20711 8L10.3536 12.1464C10.5488 12.3417 10.5488 12.6583 10.3536 12.8536C10.1583 13.0488 9.84171 13.0488 9.64645 12.8536L5.14645 8.35355C4.95118 8.15829 4.95118 7.84171 5.14645 7.64645L9.64645 3.14645C9.84171 2.95118 10.1583 2.95118 10.3536 3.14645Z", fill: "currentColor" }));
} }), WS = ga("clear", () => F("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, F("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, F("g", { fill: "currentColor", "fill-rule": "nonzero" }, F("path", { d: "M8,2 C11.3137085,2 14,4.6862915 14,8 C14,11.3137085 11.3137085,14 8,14 C4.6862915,14 2,11.3137085 2,8 C2,4.6862915 4.6862915,2 8,2 Z M6.5343055,5.83859116 C6.33943736,5.70359511 6.07001296,5.72288026 5.89644661,5.89644661 L5.89644661,5.89644661 L5.83859116,5.9656945 C5.70359511,6.16056264 5.72288026,6.42998704 5.89644661,6.60355339 L5.89644661,6.60355339 L7.293,8 L5.89644661,9.39644661 L5.83859116,9.4656945 C5.70359511,9.66056264 5.72288026,9.92998704 5.89644661,10.1035534 L5.89644661,10.1035534 L5.9656945,10.1614088 C6.16056264,10.2964049 6.42998704,10.2771197 6.60355339,10.1035534 L6.60355339,10.1035534 L8,8.707 L9.39644661,10.1035534 L9.4656945,10.1614088 C9.66056264,10.2964049 9.92998704,10.2771197 10.1035534,10.1035534 L10.1035534,10.1035534 L10.1614088,10.0343055 C10.2964049,9.83943736 10.2771197,9.57001296 10.1035534,9.39644661 L10.1035534,9.39644661 L8.707,8 L10.1035534,6.60355339 L10.1614088,6.5343055 C10.2964049,6.33943736 10.2771197,6.07001296 10.1035534,5.89644661 L10.1035534,5.89644661 L10.0343055,5.83859116 C9.83943736,5.70359511 9.57001296,5.72288026 9.39644661,5.89644661 L9.39644661,5.89644661 L8,7.293 L6.60355339,5.89644661 Z" }))))), gb = ga("download", () => F("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, F("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" }, F("g", { fill: "currentColor", "fill-rule": "nonzero" }, F("path", { d: "M3.5,13 L12.5,13 C12.7761424,13 13,13.2238576 13,13.5 C13,13.7454599 12.8231248,13.9496084 12.5898756,13.9919443 L12.5,14 L3.5,14 C3.22385763,14 3,13.7761424 3,13.5 C3,13.2545401 3.17687516,13.0503916 3.41012437,13.0080557 L3.5,13 L12.5,13 L3.5,13 Z M7.91012437,1.00805567 L8,1 C8.24545989,1 8.44960837,1.17687516 8.49194433,1.41012437 L8.5,1.5 L8.5,10.292 L11.1819805,7.6109127 C11.3555469,7.43734635 11.6249713,7.4180612 11.8198394,7.55305725 L11.8890873,7.6109127 C12.0626536,7.78447906 12.0819388,8.05390346 11.9469427,8.2487716 L11.8890873,8.31801948 L8.35355339,11.8535534 C8.17998704,12.0271197 7.91056264,12.0464049 7.7156945,11.9114088 L7.64644661,11.8535534 L4.1109127,8.31801948 C3.91565056,8.12275734 3.91565056,7.80617485 4.1109127,7.6109127 C4.28447906,7.43734635 4.55390346,7.4180612 4.7487716,7.55305725 L4.81801948,7.6109127 L7.5,10.292 L7.5,1.5 C7.5,1.25454011 7.67687516,1.05039163 7.91012437,1.00805567 L8,1 L7.91012437,1.00805567 Z" }))))), ZS = st({ name: "Empty", render() {
  return F("svg", { viewBox: "0 0 28 28", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M26 7.5C26 11.0899 23.0899 14 19.5 14C15.9101 14 13 11.0899 13 7.5C13 3.91015 15.9101 1 19.5 1C23.0899 1 26 3.91015 26 7.5ZM16.8536 4.14645C16.6583 3.95118 16.3417 3.95118 16.1464 4.14645C15.9512 4.34171 15.9512 4.65829 16.1464 4.85355L18.7929 7.5L16.1464 10.1464C15.9512 10.3417 15.9512 10.6583 16.1464 10.8536C16.3417 11.0488 16.6583 11.0488 16.8536 10.8536L19.5 8.20711L22.1464 10.8536C22.3417 11.0488 22.6583 11.0488 22.8536 10.8536C23.0488 10.6583 23.0488 10.3417 22.8536 10.1464L20.2071 7.5L22.8536 4.85355C23.0488 4.65829 23.0488 4.34171 22.8536 4.14645C22.6583 3.95118 22.3417 3.95118 22.1464 4.14645L19.5 6.79289L16.8536 4.14645Z", fill: "currentColor" }), F("path", { d: "M25 22.75V12.5991C24.5572 13.0765 24.053 13.4961 23.5 13.8454V16H17.5L17.3982 16.0068C17.0322 16.0565 16.75 16.3703 16.75 16.75C16.75 18.2688 15.5188 19.5 14 19.5C12.4812 19.5 11.25 18.2688 11.25 16.75L11.2432 16.6482C11.1935 16.2822 10.8797 16 10.5 16H4.5V7.25C4.5 6.2835 5.2835 5.5 6.25 5.5H12.2696C12.4146 4.97463 12.6153 4.47237 12.865 4H6.25C4.45507 4 3 5.45507 3 7.25V22.75C3 24.5449 4.45507 26 6.25 26H21.75C23.5449 26 25 24.5449 25 22.75ZM4.5 22.75V17.5H9.81597L9.85751 17.7041C10.2905 19.5919 11.9808 21 14 21L14.215 20.9947C16.2095 20.8953 17.842 19.4209 18.184 17.5H23.5V22.75C23.5 23.7165 22.7165 24.5 21.75 24.5H6.25C5.2835 24.5 4.5 23.7165 4.5 22.75Z", fill: "currentColor" }));
} }), vb = st({ name: "Eye", render() {
  return F("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, F("path", { d: "M255.66 112c-77.94 0-157.89 45.11-220.83 135.33a16 16 0 0 0-.27 17.77C82.92 340.8 161.8 400 255.66 400c92.84 0 173.34-59.38 221.79-135.25a16.14 16.14 0 0 0 0-17.47C428.89 172.28 347.8 112 255.66 112z", fill: "none", stroke: "currentColor", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "32" }), F("circle", { cx: "256", cy: "256", r: "80", fill: "none", stroke: "currentColor", "stroke-miterlimit": "10", "stroke-width": "32" }));
} }), HS = st({ name: "EyeOff", render() {
  return F("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, F("path", { d: "M432 448a15.92 15.92 0 0 1-11.31-4.69l-352-352a16 16 0 0 1 22.62-22.62l352 352A16 16 0 0 1 432 448z", fill: "currentColor" }), F("path", { d: "M255.66 384c-41.49 0-81.5-12.28-118.92-36.5c-34.07-22-64.74-53.51-88.7-91v-.08c19.94-28.57 41.78-52.73 65.24-72.21a2 2 0 0 0 .14-2.94L93.5 161.38a2 2 0 0 0-2.71-.12c-24.92 21-48.05 46.76-69.08 76.92a31.92 31.92 0 0 0-.64 35.54c26.41 41.33 60.4 76.14 98.28 100.65C162 402 207.9 416 255.66 416a239.13 239.13 0 0 0 75.8-12.58a2 2 0 0 0 .77-3.31l-21.58-21.58a4 4 0 0 0-3.83-1a204.8 204.8 0 0 1-51.16 6.47z", fill: "currentColor" }), F("path", { d: "M490.84 238.6c-26.46-40.92-60.79-75.68-99.27-100.53C349 110.55 302 96 255.66 96a227.34 227.34 0 0 0-74.89 12.83a2 2 0 0 0-.75 3.31l21.55 21.55a4 4 0 0 0 3.88 1a192.82 192.82 0 0 1 50.21-6.69c40.69 0 80.58 12.43 118.55 37c34.71 22.4 65.74 53.88 89.76 91a.13.13 0 0 1 0 .16a310.72 310.72 0 0 1-64.12 72.73a2 2 0 0 0-.15 2.95l19.9 19.89a2 2 0 0 0 2.7.13a343.49 343.49 0 0 0 68.64-78.48a32.2 32.2 0 0 0-.1-34.78z", fill: "currentColor" }), F("path", { d: "M256 160a95.88 95.88 0 0 0-21.37 2.4a2 2 0 0 0-1 3.38l112.59 112.56a2 2 0 0 0 3.38-1A96 96 0 0 0 256 160z", fill: "currentColor" }), F("path", { d: "M165.78 233.66a2 2 0 0 0-3.38 1a96 96 0 0 0 115 115a2 2 0 0 0 1-3.38z", fill: "currentColor" }));
} }), XS = st({ name: "Remove", render() {
  return F("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, F("line", { x1: "400", y1: "256", x2: "112", y2: "256", style: `
        fill: none;
        stroke: currentColor;
        stroke-linecap: round;
        stroke-linejoin: round;
        stroke-width: 32px;
      ` }));
} }), YS = st({ name: "ResizeSmall", render() {
  return F("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20" }, F("g", { fill: "none" }, F("path", { d: "M5.5 4A1.5 1.5 0 0 0 4 5.5v1a.5.5 0 0 1-1 0v-1A2.5 2.5 0 0 1 5.5 3h1a.5.5 0 0 1 0 1h-1zM16 5.5A1.5 1.5 0 0 0 14.5 4h-1a.5.5 0 0 1 0-1h1A2.5 2.5 0 0 1 17 5.5v1a.5.5 0 0 1-1 0v-1zm0 9a1.5 1.5 0 0 1-1.5 1.5h-1a.5.5 0 0 0 0 1h1a2.5 2.5 0 0 0 2.5-2.5v-1a.5.5 0 0 0-1 0v1zm-12 0A1.5 1.5 0 0 0 5.5 16h1.25a.5.5 0 0 1 0 1H5.5A2.5 2.5 0 0 1 3 14.5v-1.25a.5.5 0 0 1 1 0v1.25zM8.5 7A1.5 1.5 0 0 0 7 8.5v3A1.5 1.5 0 0 0 8.5 13h3a1.5 1.5 0 0 0 1.5-1.5v-3A1.5 1.5 0 0 0 11.5 7h-3zM8 8.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3z", fill: "currentColor" })));
} }), KS = ga("retry", () => F("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, F("path", { d: "M320,146s24.36-12-64-12A160,160,0,1,0,416,294", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-miterlimit: 10; stroke-width: 32px;" }), F("polyline", { points: "256 58 336 138 256 218", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }))), JS = ga("rotateClockwise", () => F("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M3 10C3 6.13401 6.13401 3 10 3C13.866 3 17 6.13401 17 10C17 12.7916 15.3658 15.2026 13 16.3265V14.5C13 14.2239 12.7761 14 12.5 14C12.2239 14 12 14.2239 12 14.5V17.5C12 17.7761 12.2239 18 12.5 18H15.5C15.7761 18 16 17.7761 16 17.5C16 17.2239 15.7761 17 15.5 17H13.8758C16.3346 15.6357 18 13.0128 18 10C18 5.58172 14.4183 2 10 2C5.58172 2 2 5.58172 2 10C2 10.2761 2.22386 10.5 2.5 10.5C2.77614 10.5 3 10.2761 3 10Z", fill: "currentColor" }), F("path", { d: "M10 12C11.1046 12 12 11.1046 12 10C12 8.89543 11.1046 8 10 8C8.89543 8 8 8.89543 8 10C8 11.1046 8.89543 12 10 12ZM10 11C9.44772 11 9 10.5523 9 10C9 9.44772 9.44772 9 10 9C10.5523 9 11 9.44772 11 10C11 10.5523 10.5523 11 10 11Z", fill: "currentColor" }))), QS = ga("rotateClockwise", () => F("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M17 10C17 6.13401 13.866 3 10 3C6.13401 3 3 6.13401 3 10C3 12.7916 4.63419 15.2026 7 16.3265V14.5C7 14.2239 7.22386 14 7.5 14C7.77614 14 8 14.2239 8 14.5V17.5C8 17.7761 7.77614 18 7.5 18H4.5C4.22386 18 4 17.7761 4 17.5C4 17.2239 4.22386 17 4.5 17H6.12422C3.66539 15.6357 2 13.0128 2 10C2 5.58172 5.58172 2 10 2C14.4183 2 18 5.58172 18 10C18 10.2761 17.7761 10.5 17.5 10.5C17.2239 10.5 17 10.2761 17 10Z", fill: "currentColor" }), F("path", { d: "M10 12C8.89543 12 8 11.1046 8 10C8 8.89543 8.89543 8 10 8C11.1046 8 12 8.89543 12 10C12 11.1046 11.1046 12 10 12ZM10 11C10.5523 11 11 10.5523 11 10C11 9.44772 10.5523 9 10 9C9.44772 9 9 9.44772 9 10C9 10.5523 9.44772 11 10 11Z", fill: "currentColor" }))), ek = ga("trash", () => F("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, F("path", { d: "M432,144,403.33,419.74A32,32,0,0,1,371.55,448H140.46a32,32,0,0,1-31.78-28.26L80,144", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), F("rect", { x: "32", y: "64", width: "448", height: "80", rx: "16", ry: "16", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), F("line", { x1: "312", y1: "240", x2: "200", y2: "352", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }), F("line", { x1: "312", y1: "352", x2: "200", y2: "240", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }))), tk = ga("zoomIn", () => F("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M11.5 8.5C11.5 8.22386 11.2761 8 11 8H9V6C9 5.72386 8.77614 5.5 8.5 5.5C8.22386 5.5 8 5.72386 8 6V8H6C5.72386 8 5.5 8.22386 5.5 8.5C5.5 8.77614 5.72386 9 6 9H8V11C8 11.2761 8.22386 11.5 8.5 11.5C8.77614 11.5 9 11.2761 9 11V9H11C11.2761 9 11.5 8.77614 11.5 8.5Z", fill: "currentColor" }), F("path", { d: "M8.5 3C11.5376 3 14 5.46243 14 8.5C14 9.83879 13.5217 11.0659 12.7266 12.0196L16.8536 16.1464C17.0488 16.3417 17.0488 16.6583 16.8536 16.8536C16.68 17.0271 16.4106 17.0464 16.2157 16.9114L16.1464 16.8536L12.0196 12.7266C11.0659 13.5217 9.83879 14 8.5 14C5.46243 14 3 11.5376 3 8.5C3 5.46243 5.46243 3 8.5 3ZM8.5 4C6.01472 4 4 6.01472 4 8.5C4 10.9853 6.01472 13 8.5 13C10.9853 13 13 10.9853 13 8.5C13 6.01472 10.9853 4 8.5 4Z", fill: "currentColor" }))), rk = ga("zoomOut", () => F("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M11 8C11.2761 8 11.5 8.22386 11.5 8.5C11.5 8.77614 11.2761 9 11 9H6C5.72386 9 5.5 8.77614 5.5 8.5C5.5 8.22386 5.72386 8 6 8H11Z", fill: "currentColor" }), F("path", { d: "M14 8.5C14 5.46243 11.5376 3 8.5 3C5.46243 3 3 5.46243 3 8.5C3 11.5376 5.46243 14 8.5 14C9.83879 14 11.0659 13.5217 12.0196 12.7266L16.1464 16.8536L16.2157 16.9114C16.4106 17.0464 16.68 17.0271 16.8536 16.8536C17.0488 16.6583 17.0488 16.3417 16.8536 16.1464L12.7266 12.0196C13.5217 11.0659 14 9.83879 14 8.5ZM4 8.5C4 6.01472 6.01472 4 8.5 4C10.9853 4 13 6.01472 13 8.5C13 10.9853 10.9853 13 8.5 13C6.01472 13 4 10.9853 4 8.5Z", fill: "currentColor" }))), ik = ue("base-clear", `
 flex-shrink: 0;
 height: 1em;
 width: 1em;
 position: relative;
`, [Ge(">", [Re("clear", `
 font-size: var(--n-clear-size);
 height: 1em;
 width: 1em;
 cursor: pointer;
 color: var(--n-clear-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 `, [Ge("&:hover", `
 color: var(--n-clear-color-hover)!important;
 `), Ge("&:active", `
 color: var(--n-clear-color-pressed)!important;
 `)]), Re("placeholder", `
 display: flex;
 `), Re("clear, placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [Nd({ originalTransform: "translateX(-50%) translateY(-50%)", left: "50%", top: "50%" })])])]), _g = st({ name: "BaseClear", props: { clsPrefix: { type: String, required: true }, show: Boolean, onClear: Function }, setup(r) {
  return ac("-base-clear", ik, Dt(r, "clsPrefix")), { handleMouseDown(i) {
    i.preventDefault();
  } };
}, render() {
  const { clsPrefix: r } = this;
  return F("div", { class: `${r}-base-clear` }, F(tp, null, { default: () => {
    var i, l;
    return this.show ? F("div", { key: "dismiss", class: `${r}-base-clear__clear`, onClick: this.onClear, onMousedown: this.handleMouseDown, "data-clear": true }, Un(this.$slots.icon, () => [F(Nr, { clsPrefix: r }, { default: () => F(WS, null) })])) : F("div", { key: "icon", class: `${r}-base-clear__placeholder` }, (l = (i = this.$slots).placeholder) === null || l === void 0 ? void 0 : l.call(i));
  } }));
} }), nk = st({ props: { onFocus: Function, onBlur: Function }, setup(r) {
  return () => F("div", { style: "width: 0; height: 0", tabindex: 0, onFocus: r.onFocus, onBlur: r.onBlur });
} }), ok = ue("empty", `
 display: flex;
 flex-direction: column;
 align-items: center;
 font-size: var(--n-font-size);
`, [Re("icon", `
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 line-height: var(--n-icon-size);
 color: var(--n-icon-color);
 transition:
 color .3s var(--n-bezier);
 `, [Ge("+", [Re("description", `
 margin-top: 8px;
 `)])]), Re("description", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), Re("extra", `
 text-align: center;
 transition: color .3s var(--n-bezier);
 margin-top: 12px;
 color: var(--n-extra-text-color);
 `)]), ak = Object.assign(Object.assign({}, Kt.props), { description: String, showDescription: { type: Boolean, default: true }, showIcon: { type: Boolean, default: true }, size: { type: String, default: "medium" }, renderIcon: Function }), qd = st({ name: "Empty", props: ak, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l, mergedComponentPropsRef: d } = Tr(r), f = Kt("Empty", "-empty", ok, o2, r, i), { localeRef: g } = Ja("Empty"), m = ze(() => {
    var M, z, L;
    return (M = r.description) !== null && M !== void 0 ? M : (L = (z = d == null ? void 0 : d.value) === null || z === void 0 ? void 0 : z.Empty) === null || L === void 0 ? void 0 : L.description;
  }), s = ze(() => {
    var M, z;
    return ((z = (M = d == null ? void 0 : d.value) === null || M === void 0 ? void 0 : M.Empty) === null || z === void 0 ? void 0 : z.renderIcon) || (() => F(ZS, null));
  }), C = ze(() => {
    const { size: M } = r, { common: { cubicBezierEaseInOut: z }, self: { [jt("iconSize", M)]: L, [jt("fontSize", M)]: A, textColor: O, iconColor: V, extraTextColor: X } } = f.value;
    return { "--n-icon-size": L, "--n-font-size": A, "--n-bezier": z, "--n-text-color": O, "--n-icon-color": V, "--n-extra-text-color": X };
  }), T = l ? mi("empty", ze(() => {
    let M = "";
    const { size: z } = r;
    return M += z[0], M;
  }), C, r) : void 0;
  return { mergedClsPrefix: i, mergedRenderIcon: s, localizedDescription: ze(() => m.value || g.value.description), cssVars: l ? void 0 : C, themeClass: T == null ? void 0 : T.themeClass, onRender: T == null ? void 0 : T.onRender };
}, render() {
  const { $slots: r, mergedClsPrefix: i, onRender: l } = this;
  return l == null ? void 0 : l(), F("div", { class: [`${i}-empty`, this.themeClass], style: this.cssVars }, this.showIcon ? F("div", { class: `${i}-empty__icon` }, r.icon ? r.icon() : F(Nr, { clsPrefix: i }, { default: this.mergedRenderIcon })) : null, this.showDescription ? F("div", { class: `${i}-empty__description` }, r.default ? r.default() : this.localizedDescription) : null, r.extra ? F("div", { class: `${i}-empty__extra` }, r.extra()) : null);
} }), s_ = st({ name: "NBaseSelectGroupHeader", props: { clsPrefix: { type: String, required: true }, tmNode: { type: Object, required: true } }, setup() {
  const { renderLabelRef: r, renderOptionRef: i, labelFieldRef: l, nodePropsRef: d } = fr($g);
  return { labelField: l, nodeProps: d, renderLabel: r, renderOption: i };
}, render() {
  const { clsPrefix: r, renderLabel: i, renderOption: l, nodeProps: d, tmNode: { rawNode: f } } = this, g = d == null ? void 0 : d(f), m = i ? i(f, false) : vl(f[this.labelField], f, false), s = F("div", Object.assign({}, g, { class: [`${r}-base-select-group-header`, g == null ? void 0 : g.class] }), m);
  return f.render ? f.render({ node: s, option: f }) : l ? l({ node: s, option: f, selected: false }) : s;
} });
function sk(r, i) {
  return F(Io, { name: "fade-in-scale-up-transition" }, { default: () => r ? F(Nr, { clsPrefix: i, class: `${i}-base-select-option__check` }, { default: () => F(US) }) : null });
}
const l_ = st({ name: "NBaseSelectOption", props: { clsPrefix: { type: String, required: true }, tmNode: { type: Object, required: true } }, setup(r) {
  const { valueRef: i, pendingTmNodeRef: l, multipleRef: d, valueSetRef: f, renderLabelRef: g, renderOptionRef: m, labelFieldRef: s, valueFieldRef: C, showCheckmarkRef: T, nodePropsRef: M, handleOptionClick: z, handleOptionMouseEnter: L } = fr($g), A = _i(() => {
    const { value: W } = l;
    return W ? r.tmNode.key === W.key : false;
  });
  function O(W) {
    const { tmNode: K } = r;
    K.disabled || z(W, K);
  }
  function V(W) {
    const { tmNode: K } = r;
    K.disabled || L(W, K);
  }
  function X(W) {
    const { tmNode: K } = r, { value: ie } = A;
    K.disabled || ie || L(W, K);
  }
  return { multiple: d, isGrouped: _i(() => {
    const { tmNode: W } = r, { parent: K } = W;
    return K && K.rawNode.type === "group";
  }), showCheckmark: T, nodeProps: M, isPending: A, isSelected: _i(() => {
    const { value: W } = i, { value: K } = d;
    if (W === null) return false;
    const ie = r.tmNode.rawNode[C.value];
    if (K) {
      const { value: ee } = f;
      return ee.has(ie);
    } else return W === ie;
  }), labelField: s, renderLabel: g, renderOption: m, handleMouseMove: X, handleMouseEnter: V, handleClick: O };
}, render() {
  const { clsPrefix: r, tmNode: { rawNode: i }, isSelected: l, isPending: d, isGrouped: f, showCheckmark: g, nodeProps: m, renderOption: s, renderLabel: C, handleClick: T, handleMouseEnter: M, handleMouseMove: z } = this, L = sk(l, r), A = C ? [C(i, l), g && L] : [vl(i[this.labelField], i, l), g && L], O = m == null ? void 0 : m(i), V = F("div", Object.assign({}, O, { class: [`${r}-base-select-option`, i.class, O == null ? void 0 : O.class, { [`${r}-base-select-option--disabled`]: i.disabled, [`${r}-base-select-option--selected`]: l, [`${r}-base-select-option--grouped`]: f, [`${r}-base-select-option--pending`]: d, [`${r}-base-select-option--show-checkmark`]: g }], style: [(O == null ? void 0 : O.style) || "", i.style || ""], onClick: zm([T, O == null ? void 0 : O.onClick]), onMouseenter: zm([M, O == null ? void 0 : O.onMouseenter]), onMousemove: zm([z, O == null ? void 0 : O.onMousemove]) }), F("div", { class: `${r}-base-select-option__content` }, A));
  return i.render ? i.render({ node: V, option: i, selected: l }) : s ? s({ node: V, option: i, selected: l }) : V;
} }), lk = ue("base-select-menu", `
 line-height: 1.5;
 outline: none;
 z-index: 0;
 position: relative;
 border-radius: var(--n-border-radius);
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-color);
`, [ue("scrollbar", `
 max-height: var(--n-height);
 `), ue("virtual-list", `
 max-height: var(--n-height);
 `), ue("base-select-option", `
 min-height: var(--n-option-height);
 font-size: var(--n-option-font-size);
 display: flex;
 align-items: center;
 `, [Re("content", `
 z-index: 1;
 white-space: nowrap;
 text-overflow: ellipsis;
 overflow: hidden;
 `)]), ue("base-select-group-header", `
 min-height: var(--n-option-height);
 font-size: .93em;
 display: flex;
 align-items: center;
 `), ue("base-select-menu-option-wrapper", `
 position: relative;
 width: 100%;
 `), Re("loading, empty", `
 display: flex;
 padding: 12px 32px;
 flex: 1;
 justify-content: center;
 `), Re("loading", `
 color: var(--n-loading-color);
 font-size: var(--n-loading-size);
 `), Re("header", `
 padding: 8px var(--n-option-padding-left);
 font-size: var(--n-option-font-size);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), Re("action", `
 padding: 8px var(--n-option-padding-left);
 font-size: var(--n-option-font-size);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 border-top: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), ue("base-select-group-header", `
 position: relative;
 cursor: default;
 padding: var(--n-option-padding);
 color: var(--n-group-header-text-color);
 `), ue("base-select-option", `
 cursor: pointer;
 position: relative;
 padding: var(--n-option-padding);
 transition:
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 box-sizing: border-box;
 color: var(--n-option-text-color);
 opacity: 1;
 `, [Ue("show-checkmark", `
 padding-right: calc(var(--n-option-padding-right) + 20px);
 `), Ge("&::before", `
 content: "";
 position: absolute;
 left: 4px;
 right: 4px;
 top: 0;
 bottom: 0;
 border-radius: var(--n-border-radius);
 transition: background-color .3s var(--n-bezier);
 `), Ge("&:active", `
 color: var(--n-option-text-color-pressed);
 `), Ue("grouped", `
 padding-left: calc(var(--n-option-padding-left) * 1.5);
 `), Ue("pending", [Ge("&::before", `
 background-color: var(--n-option-color-pending);
 `)]), Ue("selected", `
 color: var(--n-option-text-color-active);
 `, [Ge("&::before", `
 background-color: var(--n-option-color-active);
 `), Ue("pending", [Ge("&::before", `
 background-color: var(--n-option-color-active-pending);
 `)])]), Ue("disabled", `
 cursor: not-allowed;
 `, [pi("selected", `
 color: var(--n-option-text-color-disabled);
 `), Ue("selected", `
 opacity: var(--n-option-opacity-disabled);
 `)]), Re("check", `
 font-size: 16px;
 position: absolute;
 right: calc(var(--n-option-padding-right) - 4px);
 top: calc(50% - 7px);
 color: var(--n-option-check-color);
 transition: color .3s var(--n-bezier);
 `, [rp({ enterScale: "0.5" })])])]), uk = st({ name: "InternalSelectMenu", props: Object.assign(Object.assign({}, Kt.props), { clsPrefix: { type: String, required: true }, scrollable: { type: Boolean, default: true }, treeMate: { type: Object, required: true }, multiple: Boolean, size: { type: String, default: "medium" }, value: { type: [String, Number, Array], default: null }, autoPending: Boolean, virtualScroll: { type: Boolean, default: true }, show: { type: Boolean, default: true }, labelField: { type: String, default: "label" }, valueField: { type: String, default: "value" }, loading: Boolean, focusable: Boolean, renderLabel: Function, renderOption: Function, nodeProps: Function, showCheckmark: { type: Boolean, default: true }, onMousedown: Function, onScroll: Function, onFocus: Function, onBlur: Function, onKeyup: Function, onKeydown: Function, onTabOut: Function, onMouseenter: Function, onMouseleave: Function, onResize: Function, resetMenuOnOptionsChange: { type: Boolean, default: true }, inlineThemeDisabled: Boolean, onToggle: Function }), setup(r) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Tr(r), d = Rn("InternalSelectMenu", l, i), f = Kt("InternalSelectMenu", "-internal-select-menu", lk, a2, r, Dt(r, "clsPrefix")), g = Ae(null), m = Ae(null), s = Ae(null), C = ze(() => r.treeMate.getFlattenedNodes()), T = ze(() => s2(C.value)), M = Ae(null);
  function z() {
    const { treeMate: nt } = r;
    let ut = null;
    const { value: Ft } = r;
    Ft === null ? ut = nt.getFirstAvailableNode() : (r.multiple ? ut = nt.getNode((Ft || [])[(Ft || []).length - 1]) : ut = nt.getNode(Ft), (!ut || ut.disabled) && (ut = nt.getFirstAvailableNode())), Ke(ut || null);
  }
  function L() {
    const { value: nt } = M;
    nt && !r.treeMate.getNode(nt.key) && (M.value = null);
  }
  let A;
  ar(() => r.show, (nt) => {
    nt ? A = ar(() => r.treeMate, () => {
      r.resetMenuOnOptionsChange ? (r.autoPending ? z() : L(), Vn(lt)) : L();
    }, { immediate: true }) : A == null ? void 0 : A();
  }, { immediate: true }), Sn(() => {
    A == null ? void 0 : A();
  });
  const O = ze(() => Ji(f.value.self[jt("optionHeight", r.size)])), V = ze(() => To(f.value.self[jt("padding", r.size)])), X = ze(() => r.multiple && Array.isArray(r.value) ? new Set(r.value) : /* @__PURE__ */ new Set()), W = ze(() => {
    const nt = C.value;
    return nt && nt.length === 0;
  });
  function K(nt) {
    const { onToggle: ut } = r;
    ut && ut(nt);
  }
  function ie(nt) {
    const { onScroll: ut } = r;
    ut && ut(nt);
  }
  function ee(nt) {
    var ut;
    (ut = s.value) === null || ut === void 0 || ut.sync(), ie(nt);
  }
  function re() {
    var nt;
    (nt = s.value) === null || nt === void 0 || nt.sync();
  }
  function J() {
    const { value: nt } = M;
    return nt || null;
  }
  function Se(nt, ut) {
    ut.disabled || Ke(ut, false);
  }
  function fe(nt, ut) {
    ut.disabled || K(ut);
  }
  function oe(nt) {
    var ut;
    wl(nt, "action") || (ut = r.onKeyup) === null || ut === void 0 || ut.call(r, nt);
  }
  function he(nt) {
    var ut;
    wl(nt, "action") || (ut = r.onKeydown) === null || ut === void 0 || ut.call(r, nt);
  }
  function be(nt) {
    var ut;
    (ut = r.onMousedown) === null || ut === void 0 || ut.call(r, nt), !r.focusable && nt.preventDefault();
  }
  function je() {
    const { value: nt } = M;
    nt && Ke(nt.getNext({ loop: true }), true);
  }
  function Ve() {
    const { value: nt } = M;
    nt && Ke(nt.getPrev({ loop: true }), true);
  }
  function Ke(nt, ut = false) {
    M.value = nt, ut && lt();
  }
  function lt() {
    var nt, ut;
    const Ft = M.value;
    if (!Ft) return;
    const Ht = T.value(Ft.key);
    Ht !== null && (r.virtualScroll ? (nt = m.value) === null || nt === void 0 || nt.scrollTo({ index: Ht }) : (ut = s.value) === null || ut === void 0 || ut.scrollTo({ index: Ht, elSize: O.value }));
  }
  function vt(nt) {
    var ut, Ft;
    !((ut = g.value) === null || ut === void 0) && ut.contains(nt.target) && ((Ft = r.onFocus) === null || Ft === void 0 || Ft.call(r, nt));
  }
  function wt(nt) {
    var ut, Ft;
    !((ut = g.value) === null || ut === void 0) && ut.contains(nt.relatedTarget) || (Ft = r.onBlur) === null || Ft === void 0 || Ft.call(r, nt);
  }
  Yr($g, { handleOptionMouseEnter: Se, handleOptionClick: fe, valueSetRef: X, pendingTmNodeRef: M, nodePropsRef: Dt(r, "nodeProps"), showCheckmarkRef: Dt(r, "showCheckmark"), multipleRef: Dt(r, "multiple"), valueRef: Dt(r, "value"), renderLabelRef: Dt(r, "renderLabel"), renderOptionRef: Dt(r, "renderOption"), labelFieldRef: Dt(r, "labelField"), valueFieldRef: Dt(r, "valueField") }), Yr(l2, g), Qi(() => {
    const { value: nt } = s;
    nt && nt.sync();
  });
  const at = ze(() => {
    const { size: nt } = r, { common: { cubicBezierEaseInOut: ut }, self: { height: Ft, borderRadius: Ht, color: zt, groupHeaderTextColor: pr, actionDividerColor: Qt, optionTextColorPressed: tr, optionTextColor: xr, optionTextColorDisabled: Mr, optionTextColorActive: rr, optionOpacityDisabled: sr, optionCheckColor: Gt, actionTextColor: Dr, optionColorPending: wr, optionColorActive: Ct, loadingColor: Ee, loadingSize: ot, optionColorActivePending: Le, [jt("optionFontSize", nt)]: Ye, [jt("optionHeight", nt)]: ft, [jt("optionPadding", nt)]: bt } } = f.value;
    return { "--n-height": Ft, "--n-action-divider-color": Qt, "--n-action-text-color": Dr, "--n-bezier": ut, "--n-border-radius": Ht, "--n-color": zt, "--n-option-font-size": Ye, "--n-group-header-text-color": pr, "--n-option-check-color": Gt, "--n-option-color-pending": wr, "--n-option-color-active": Ct, "--n-option-color-active-pending": Le, "--n-option-height": ft, "--n-option-opacity-disabled": sr, "--n-option-text-color": xr, "--n-option-text-color-active": rr, "--n-option-text-color-disabled": Mr, "--n-option-text-color-pressed": tr, "--n-option-padding": bt, "--n-option-padding-left": To(bt, "left"), "--n-option-padding-right": To(bt, "right"), "--n-loading-color": Ee, "--n-loading-size": ot };
  }), { inlineThemeDisabled: et } = r, ht = et ? mi("internal-select-menu", ze(() => r.size[0]), at, r) : void 0, yt = { selfRef: g, next: je, prev: Ve, getPendingTmNode: J };
  return pb(g, r.onResize), Object.assign({ mergedTheme: f, mergedClsPrefix: i, rtlEnabled: d, virtualListRef: m, scrollbarRef: s, itemSize: O, padding: V, flattenedNodes: C, empty: W, virtualListContainer() {
    const { value: nt } = m;
    return nt == null ? void 0 : nt.listElRef;
  }, virtualListContent() {
    const { value: nt } = m;
    return nt == null ? void 0 : nt.itemsElRef;
  }, doScroll: ie, handleFocusin: vt, handleFocusout: wt, handleKeyUp: oe, handleKeyDown: he, handleMouseDown: be, handleVirtualListResize: re, handleVirtualListScroll: ee, cssVars: et ? void 0 : at, themeClass: ht == null ? void 0 : ht.themeClass, onRender: ht == null ? void 0 : ht.onRender }, yt);
}, render() {
  const { $slots: r, virtualScroll: i, clsPrefix: l, mergedTheme: d, themeClass: f, onRender: g } = this;
  return g == null ? void 0 : g(), F("div", { ref: "selfRef", tabindex: this.focusable ? 0 : -1, class: [`${l}-base-select-menu`, this.rtlEnabled && `${l}-base-select-menu--rtl`, f, this.multiple && `${l}-base-select-menu--multiple`], style: this.cssVars, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onKeyup: this.handleKeyUp, onKeydown: this.handleKeyDown, onMousedown: this.handleMouseDown, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave }, Ci(r.header, (m) => m && F("div", { class: `${l}-base-select-menu__header`, "data-header": true, key: "header" }, m)), this.loading ? F("div", { class: `${l}-base-select-menu__loading` }, F(ip, { clsPrefix: l, strokeWidth: 20 })) : this.empty ? F("div", { class: `${l}-base-select-menu__empty`, "data-empty": true }, Un(r.empty, () => [F(qd, { theme: d.peers.Empty, themeOverrides: d.peerOverrides.Empty, size: this.size })])) : F(th, { ref: "scrollbarRef", theme: d.peers.Scrollbar, themeOverrides: d.peerOverrides.Scrollbar, scrollable: this.scrollable, container: i ? this.virtualListContainer : void 0, content: i ? this.virtualListContent : void 0, onScroll: i ? void 0 : this.doScroll }, { default: () => i ? F(X3, { ref: "virtualListRef", class: `${l}-virtual-list`, items: this.flattenedNodes, itemSize: this.itemSize, showScrollbar: false, paddingTop: this.padding.top, paddingBottom: this.padding.bottom, onResize: this.handleVirtualListResize, onScroll: this.handleVirtualListScroll, itemResizable: true }, { default: ({ item: m }) => m.isGroup ? F(s_, { key: m.key, clsPrefix: l, tmNode: m }) : m.ignored ? null : F(l_, { clsPrefix: l, key: m.key, tmNode: m }) }) : F("div", { class: `${l}-base-select-menu-option-wrapper`, style: { paddingTop: this.padding.top, paddingBottom: this.padding.bottom } }, this.flattenedNodes.map((m) => m.isGroup ? F(s_, { key: m.key, clsPrefix: l, tmNode: m }) : F(l_, { clsPrefix: l, key: m.key, tmNode: m }))) }), Ci(r.action, (m) => m && [F("div", { class: `${l}-base-select-menu__action`, "data-action": true, key: "action" }, m), F(nk, { onFocus: this.onTabOut, key: "focus-detector" })]));
} }), _b = { color: Object, type: { type: String, default: "default" }, round: Boolean, size: { type: String, default: "medium" }, closable: Boolean, disabled: { type: Boolean, default: void 0 } }, ck = ue("tag", `
 --n-close-margin: var(--n-close-margin-top) var(--n-close-margin-right) var(--n-close-margin-bottom) var(--n-close-margin-left);
 white-space: nowrap;
 position: relative;
 box-sizing: border-box;
 cursor: default;
 display: inline-flex;
 align-items: center;
 flex-wrap: nowrap;
 padding: var(--n-padding);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition: 
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 line-height: 1;
 height: var(--n-height);
 font-size: var(--n-font-size);
`, [Ue("strong", `
 font-weight: var(--n-font-weight-strong);
 `), Re("border", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 border: var(--n-border);
 transition: border-color .3s var(--n-bezier);
 `), Re("icon", `
 display: flex;
 margin: 0 4px 0 0;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 font-size: var(--n-avatar-size-override);
 `), Re("avatar", `
 display: flex;
 margin: 0 6px 0 0;
 `), Re("close", `
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), Ue("round", `
 padding: 0 calc(var(--n-height) / 3);
 border-radius: calc(var(--n-height) / 2);
 `, [Re("icon", `
 margin: 0 4px 0 calc((var(--n-height) - 8px) / -2);
 `), Re("avatar", `
 margin: 0 6px 0 calc((var(--n-height) - 8px) / -2);
 `), Ue("closable", `
 padding: 0 calc(var(--n-height) / 4) 0 calc(var(--n-height) / 3);
 `)]), Ue("icon, avatar", [Ue("round", `
 padding: 0 calc(var(--n-height) / 3) 0 calc(var(--n-height) / 2);
 `)]), Ue("disabled", `
 cursor: not-allowed !important;
 opacity: var(--n-opacity-disabled);
 `), Ue("checkable", `
 cursor: pointer;
 box-shadow: none;
 color: var(--n-text-color-checkable);
 background-color: var(--n-color-checkable);
 `, [pi("disabled", [Ge("&:hover", "background-color: var(--n-color-hover-checkable);", [pi("checked", "color: var(--n-text-color-hover-checkable);")]), Ge("&:active", "background-color: var(--n-color-pressed-checkable);", [pi("checked", "color: var(--n-text-color-pressed-checkable);")])]), Ue("checked", `
 color: var(--n-text-color-checked);
 background-color: var(--n-color-checked);
 `, [pi("disabled", [Ge("&:hover", "background-color: var(--n-color-checked-hover);"), Ge("&:active", "background-color: var(--n-color-checked-pressed);")])])])]), dk = Object.assign(Object.assign(Object.assign({}, Kt.props), _b), { bordered: { type: Boolean, default: void 0 }, checked: Boolean, checkable: Boolean, strong: Boolean, triggerClickOnClose: Boolean, onClose: [Array, Function], onMouseenter: Function, onMouseleave: Function, "onUpdate:checked": Function, onUpdateChecked: Function, internalCloseFocusable: { type: Boolean, default: true }, internalCloseIsButtonTag: { type: Boolean, default: true }, onCheckedChange: Function }), hk = An("n-tag"), Mo = st({ name: "Tag", props: dk, slots: Object, setup(r) {
  const i = Ae(null), { mergedBorderedRef: l, mergedClsPrefixRef: d, inlineThemeDisabled: f, mergedRtlRef: g } = Tr(r), m = Kt("Tag", "-tag", ck, u2, r, d);
  Yr(hk, { roundRef: Dt(r, "round") });
  function s() {
    if (!r.disabled && r.checkable) {
      const { checked: A, onCheckedChange: O, onUpdateChecked: V, "onUpdate:checked": X } = r;
      V && V(!A), X && X(!A), O && O(!A);
    }
  }
  function C(A) {
    if (r.triggerClickOnClose || A.stopPropagation(), !r.disabled) {
      const { onClose: O } = r;
      O && Ot(O, A);
    }
  }
  const T = { setTextContent(A) {
    const { value: O } = i;
    O && (O.textContent = A);
  } }, M = Rn("Tag", g, d), z = ze(() => {
    const { type: A, size: O, color: { color: V, textColor: X } = {} } = r, { common: { cubicBezierEaseInOut: W }, self: { padding: K, closeMargin: ie, borderRadius: ee, opacityDisabled: re, textColorCheckable: J, textColorHoverCheckable: Se, textColorPressedCheckable: fe, textColorChecked: oe, colorCheckable: he, colorHoverCheckable: be, colorPressedCheckable: je, colorChecked: Ve, colorCheckedHover: Ke, colorCheckedPressed: lt, closeBorderRadius: vt, fontWeightStrong: wt, [jt("colorBordered", A)]: at, [jt("closeSize", O)]: et, [jt("closeIconSize", O)]: ht, [jt("fontSize", O)]: yt, [jt("height", O)]: nt, [jt("color", A)]: ut, [jt("textColor", A)]: Ft, [jt("border", A)]: Ht, [jt("closeIconColor", A)]: zt, [jt("closeIconColorHover", A)]: pr, [jt("closeIconColorPressed", A)]: Qt, [jt("closeColorHover", A)]: tr, [jt("closeColorPressed", A)]: xr } } = m.value, Mr = To(ie);
    return { "--n-font-weight-strong": wt, "--n-avatar-size-override": `calc(${nt} - 8px)`, "--n-bezier": W, "--n-border-radius": ee, "--n-border": Ht, "--n-close-icon-size": ht, "--n-close-color-pressed": xr, "--n-close-color-hover": tr, "--n-close-border-radius": vt, "--n-close-icon-color": zt, "--n-close-icon-color-hover": pr, "--n-close-icon-color-pressed": Qt, "--n-close-icon-color-disabled": zt, "--n-close-margin-top": Mr.top, "--n-close-margin-right": Mr.right, "--n-close-margin-bottom": Mr.bottom, "--n-close-margin-left": Mr.left, "--n-close-size": et, "--n-color": V || (l.value ? at : ut), "--n-color-checkable": he, "--n-color-checked": Ve, "--n-color-checked-hover": Ke, "--n-color-checked-pressed": lt, "--n-color-hover-checkable": be, "--n-color-pressed-checkable": je, "--n-font-size": yt, "--n-height": nt, "--n-opacity-disabled": re, "--n-padding": K, "--n-text-color": X || Ft, "--n-text-color-checkable": J, "--n-text-color-checked": oe, "--n-text-color-hover-checkable": Se, "--n-text-color-pressed-checkable": fe };
  }), L = f ? mi("tag", ze(() => {
    let A = "";
    const { type: O, size: V, color: { color: X, textColor: W } = {} } = r;
    return A += O[0], A += V[0], X && (A += `a${Wv(X)}`), W && (A += `b${Wv(W)}`), l.value && (A += "c"), A;
  }), z, r) : void 0;
  return Object.assign(Object.assign({}, T), { rtlEnabled: M, mergedClsPrefix: d, contentRef: i, mergedBordered: l, handleClick: s, handleCloseClick: C, cssVars: f ? void 0 : z, themeClass: L == null ? void 0 : L.themeClass, onRender: L == null ? void 0 : L.onRender });
}, render() {
  var r, i;
  const { mergedClsPrefix: l, rtlEnabled: d, closable: f, color: { borderColor: g } = {}, round: m, onRender: s, $slots: C } = this;
  s == null ? void 0 : s();
  const T = Ci(C.avatar, (z) => z && F("div", { class: `${l}-tag__avatar` }, z)), M = Ci(C.icon, (z) => z && F("div", { class: `${l}-tag__icon` }, z));
  return F("div", { class: [`${l}-tag`, this.themeClass, { [`${l}-tag--rtl`]: d, [`${l}-tag--strong`]: this.strong, [`${l}-tag--disabled`]: this.disabled, [`${l}-tag--checkable`]: this.checkable, [`${l}-tag--checked`]: this.checkable && this.checked, [`${l}-tag--round`]: m, [`${l}-tag--avatar`]: T, [`${l}-tag--icon`]: M, [`${l}-tag--closable`]: f }], style: this.cssVars, onClick: this.handleClick, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave }, M || T, F("span", { class: `${l}-tag__content`, ref: "contentRef" }, (i = (r = this.$slots).default) === null || i === void 0 ? void 0 : i.call(r)), !this.checkable && f ? F(np, { clsPrefix: l, class: `${l}-tag__close`, disabled: this.disabled, onClick: this.handleCloseClick, focusable: this.internalCloseFocusable, round: m, isButtonTag: this.internalCloseIsButtonTag, absolute: true }) : null, !this.checkable && this.mergedBordered ? F("div", { class: `${l}-tag__border`, style: { borderColor: g } }) : null);
} }), yb = st({ name: "InternalSelectionSuffix", props: { clsPrefix: { type: String, required: true }, showArrow: { type: Boolean, default: void 0 }, showClear: { type: Boolean, default: void 0 }, loading: { type: Boolean, default: false }, onClear: Function }, setup(r, { slots: i }) {
  return () => {
    const { clsPrefix: l } = r;
    return F(ip, { clsPrefix: l, class: `${l}-base-suffix`, strokeWidth: 24, scale: 0.85, show: r.loading }, { default: () => r.showArrow ? F(_g, { clsPrefix: l, show: r.showClear, onClear: r.onClear }, { placeholder: () => F(Nr, { clsPrefix: l, class: `${l}-base-suffix__arrow` }, { default: () => Un(i.default, () => [F(qS, null)]) }) }) : null });
  };
} }), fk = Ge([ue("base-selection", `
 --n-padding-single: var(--n-padding-single-top) var(--n-padding-single-right) var(--n-padding-single-bottom) var(--n-padding-single-left);
 --n-padding-multiple: var(--n-padding-multiple-top) var(--n-padding-multiple-right) var(--n-padding-multiple-bottom) var(--n-padding-multiple-left);
 position: relative;
 z-index: auto;
 box-shadow: none;
 width: 100%;
 max-width: 100%;
 display: inline-block;
 vertical-align: bottom;
 border-radius: var(--n-border-radius);
 min-height: var(--n-height);
 line-height: 1.5;
 font-size: var(--n-font-size);
 `, [ue("base-loading", `
 color: var(--n-loading-color);
 `), ue("base-selection-tags", "min-height: var(--n-height);"), Re("border, state-border", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border: var(--n-border);
 border-radius: inherit;
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), Re("state-border", `
 z-index: 1;
 border-color: #0000;
 `), ue("base-suffix", `
 cursor: pointer;
 position: absolute;
 top: 50%;
 transform: translateY(-50%);
 right: 10px;
 `, [Re("arrow", `
 font-size: var(--n-arrow-size);
 color: var(--n-arrow-color);
 transition: color .3s var(--n-bezier);
 `)]), ue("base-selection-overlay", `
 display: flex;
 align-items: center;
 white-space: nowrap;
 pointer-events: none;
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 padding: var(--n-padding-single);
 transition: color .3s var(--n-bezier);
 `, [Re("wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 overflow: hidden;
 text-overflow: ellipsis;
 `)]), ue("base-selection-placeholder", `
 color: var(--n-placeholder-color);
 `, [Re("inner", `
 max-width: 100%;
 overflow: hidden;
 `)]), ue("base-selection-tags", `
 cursor: pointer;
 outline: none;
 box-sizing: border-box;
 position: relative;
 z-index: auto;
 display: flex;
 padding: var(--n-padding-multiple);
 flex-wrap: wrap;
 align-items: center;
 width: 100%;
 vertical-align: bottom;
 background-color: var(--n-color);
 border-radius: inherit;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), ue("base-selection-label", `
 height: var(--n-height);
 display: inline-flex;
 width: 100%;
 vertical-align: bottom;
 cursor: pointer;
 outline: none;
 z-index: auto;
 box-sizing: border-box;
 position: relative;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: inherit;
 background-color: var(--n-color);
 align-items: center;
 `, [ue("base-selection-input", `
 font-size: inherit;
 line-height: inherit;
 outline: none;
 cursor: pointer;
 box-sizing: border-box;
 border:none;
 width: 100%;
 padding: var(--n-padding-single);
 background-color: #0000;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 caret-color: var(--n-caret-color);
 `, [Re("content", `
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap; 
 `)]), Re("render-label", `
 color: var(--n-text-color);
 `)]), pi("disabled", [Ge("&:hover", [Re("state-border", `
 box-shadow: var(--n-box-shadow-hover);
 border: var(--n-border-hover);
 `)]), Ue("focus", [Re("state-border", `
 box-shadow: var(--n-box-shadow-focus);
 border: var(--n-border-focus);
 `)]), Ue("active", [Re("state-border", `
 box-shadow: var(--n-box-shadow-active);
 border: var(--n-border-active);
 `), ue("base-selection-label", "background-color: var(--n-color-active);"), ue("base-selection-tags", "background-color: var(--n-color-active);")])]), Ue("disabled", "cursor: not-allowed;", [Re("arrow", `
 color: var(--n-arrow-color-disabled);
 `), ue("base-selection-label", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [ue("base-selection-input", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 `), Re("render-label", `
 color: var(--n-text-color-disabled);
 `)]), ue("base-selection-tags", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `), ue("base-selection-placeholder", `
 cursor: not-allowed;
 color: var(--n-placeholder-color-disabled);
 `)]), ue("base-selection-input-tag", `
 height: calc(var(--n-height) - 6px);
 line-height: calc(var(--n-height) - 6px);
 outline: none;
 display: none;
 position: relative;
 margin-bottom: 3px;
 max-width: 100%;
 vertical-align: bottom;
 `, [Re("input", `
 font-size: inherit;
 font-family: inherit;
 min-width: 1px;
 padding: 0;
 background-color: #0000;
 outline: none;
 border: none;
 max-width: 100%;
 overflow: hidden;
 width: 1em;
 line-height: inherit;
 cursor: pointer;
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 `), Re("mirror", `
 position: absolute;
 left: 0;
 top: 0;
 white-space: pre;
 visibility: hidden;
 user-select: none;
 -webkit-user-select: none;
 opacity: 0;
 `)]), ["warning", "error"].map((r) => Ue(`${r}-status`, [Re("state-border", `border: var(--n-border-${r});`), pi("disabled", [Ge("&:hover", [Re("state-border", `
 box-shadow: var(--n-box-shadow-hover-${r});
 border: var(--n-border-hover-${r});
 `)]), Ue("active", [Re("state-border", `
 box-shadow: var(--n-box-shadow-active-${r});
 border: var(--n-border-active-${r});
 `), ue("base-selection-label", `background-color: var(--n-color-active-${r});`), ue("base-selection-tags", `background-color: var(--n-color-active-${r});`)]), Ue("focus", [Re("state-border", `
 box-shadow: var(--n-box-shadow-focus-${r});
 border: var(--n-border-focus-${r});
 `)])])]))]), ue("base-selection-popover", `
 margin-bottom: -3px;
 display: flex;
 flex-wrap: wrap;
 margin-right: -8px;
 `), ue("base-selection-tag-wrapper", `
 max-width: 100%;
 display: inline-flex;
 padding: 0 7px 3px 0;
 `, [Ge("&:last-child", "padding-right: 0;"), ue("tag", `
 font-size: 14px;
 max-width: 100%;
 `, [Re("content", `
 line-height: 1.25;
 text-overflow: ellipsis;
 overflow: hidden;
 `)])])]), pk = st({ name: "InternalSelection", props: Object.assign(Object.assign({}, Kt.props), { clsPrefix: { type: String, required: true }, bordered: { type: Boolean, default: void 0 }, active: Boolean, pattern: { type: String, default: "" }, placeholder: String, selectedOption: { type: Object, default: null }, selectedOptions: { type: Array, default: null }, labelField: { type: String, default: "label" }, valueField: { type: String, default: "value" }, multiple: Boolean, filterable: Boolean, clearable: Boolean, disabled: Boolean, size: { type: String, default: "medium" }, loading: Boolean, autofocus: Boolean, showArrow: { type: Boolean, default: true }, inputProps: Object, focused: Boolean, renderTag: Function, onKeydown: Function, onClick: Function, onBlur: Function, onFocus: Function, onDeleteOption: Function, maxTagCount: [String, Number], ellipsisTagPopoverProps: Object, onClear: Function, onPatternInput: Function, onPatternFocus: Function, onPatternBlur: Function, renderLabel: Function, status: String, inlineThemeDisabled: Boolean, ignoreComposition: { type: Boolean, default: true }, onResize: Function }), setup(r) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Tr(r), d = Rn("InternalSelection", l, i), f = Ae(null), g = Ae(null), m = Ae(null), s = Ae(null), C = Ae(null), T = Ae(null), M = Ae(null), z = Ae(null), L = Ae(null), A = Ae(null), O = Ae(false), V = Ae(false), X = Ae(false), W = Kt("InternalSelection", "-internal-selection", fk, d2, r, Dt(r, "clsPrefix")), K = ze(() => r.clearable && !r.disabled && (X.value || r.active)), ie = ze(() => r.selectedOption ? r.renderTag ? r.renderTag({ option: r.selectedOption, handleClose: () => {
  } }) : r.renderLabel ? r.renderLabel(r.selectedOption, true) : vl(r.selectedOption[r.labelField], r.selectedOption, true) : r.placeholder), ee = ze(() => {
    const tt = r.selectedOption;
    if (tt) return tt[r.labelField];
  }), re = ze(() => r.multiple ? !!(Array.isArray(r.selectedOptions) && r.selectedOptions.length) : r.selectedOption !== null);
  function J() {
    var tt;
    const { value: mt } = f;
    if (mt) {
      const { value: Zt } = g;
      Zt && (Zt.style.width = `${mt.offsetWidth}px`, r.maxTagCount !== "responsive" && ((tt = L.value) === null || tt === void 0 || tt.sync({ showAllItemsBeforeCalculate: false })));
    }
  }
  function Se() {
    const { value: tt } = A;
    tt && (tt.style.display = "none");
  }
  function fe() {
    const { value: tt } = A;
    tt && (tt.style.display = "inline-block");
  }
  ar(Dt(r, "active"), (tt) => {
    tt || Se();
  }), ar(Dt(r, "pattern"), () => {
    r.multiple && Vn(J);
  });
  function oe(tt) {
    const { onFocus: mt } = r;
    mt && mt(tt);
  }
  function he(tt) {
    const { onBlur: mt } = r;
    mt && mt(tt);
  }
  function be(tt) {
    const { onDeleteOption: mt } = r;
    mt && mt(tt);
  }
  function je(tt) {
    const { onClear: mt } = r;
    mt && mt(tt);
  }
  function Ve(tt) {
    const { onPatternInput: mt } = r;
    mt && mt(tt);
  }
  function Ke(tt) {
    var mt;
    (!tt.relatedTarget || !(!((mt = m.value) === null || mt === void 0) && mt.contains(tt.relatedTarget))) && oe(tt);
  }
  function lt(tt) {
    var mt;
    !((mt = m.value) === null || mt === void 0) && mt.contains(tt.relatedTarget) || he(tt);
  }
  function vt(tt) {
    je(tt);
  }
  function wt() {
    X.value = true;
  }
  function at() {
    X.value = false;
  }
  function et(tt) {
    !r.active || !r.filterable || tt.target !== g.value && tt.preventDefault();
  }
  function ht(tt) {
    be(tt);
  }
  const yt = Ae(false);
  function nt(tt) {
    if (tt.key === "Backspace" && !yt.value && !r.pattern.length) {
      const { selectedOptions: mt } = r;
      (mt == null ? void 0 : mt.length) && ht(mt[mt.length - 1]);
    }
  }
  let ut = null;
  function Ft(tt) {
    const { value: mt } = f;
    if (mt) {
      const Zt = tt.target.value;
      mt.textContent = Zt, J();
    }
    r.ignoreComposition && yt.value ? ut = tt : Ve(tt);
  }
  function Ht() {
    yt.value = true;
  }
  function zt() {
    yt.value = false, r.ignoreComposition && Ve(ut), ut = null;
  }
  function pr(tt) {
    var mt;
    V.value = true, (mt = r.onPatternFocus) === null || mt === void 0 || mt.call(r, tt);
  }
  function Qt(tt) {
    var mt;
    V.value = false, (mt = r.onPatternBlur) === null || mt === void 0 || mt.call(r, tt);
  }
  function tr() {
    var tt, mt;
    if (r.filterable) V.value = false, (tt = T.value) === null || tt === void 0 || tt.blur(), (mt = g.value) === null || mt === void 0 || mt.blur();
    else if (r.multiple) {
      const { value: Zt } = s;
      Zt == null ? void 0 : Zt.blur();
    } else {
      const { value: Zt } = C;
      Zt == null ? void 0 : Zt.blur();
    }
  }
  function xr() {
    var tt, mt, Zt;
    r.filterable ? (V.value = false, (tt = T.value) === null || tt === void 0 || tt.focus()) : r.multiple ? (mt = s.value) === null || mt === void 0 || mt.focus() : (Zt = C.value) === null || Zt === void 0 || Zt.focus();
  }
  function Mr() {
    const { value: tt } = g;
    tt && (fe(), tt.focus());
  }
  function rr() {
    const { value: tt } = g;
    tt && tt.blur();
  }
  function sr(tt) {
    const { value: mt } = M;
    mt && mt.setTextContent(`+${tt}`);
  }
  function Gt() {
    const { value: tt } = z;
    return tt;
  }
  function Dr() {
    return g.value;
  }
  let wr = null;
  function Ct() {
    wr !== null && window.clearTimeout(wr);
  }
  function Ee() {
    r.active || (Ct(), wr = window.setTimeout(() => {
      re.value && (O.value = true);
    }, 100));
  }
  function ot() {
    Ct();
  }
  function Le(tt) {
    tt || (Ct(), O.value = false);
  }
  ar(re, (tt) => {
    tt || (O.value = false);
  }), Qi(() => {
    po(() => {
      const tt = T.value;
      tt && (r.disabled ? tt.removeAttribute("tabindex") : tt.tabIndex = V.value ? -1 : 0);
    });
  }), pb(m, r.onResize);
  const { inlineThemeDisabled: Ye } = r, ft = ze(() => {
    const { size: tt } = r, { common: { cubicBezierEaseInOut: mt }, self: { fontWeight: Zt, borderRadius: ri, color: Si, placeholderColor: Fe, textColor: Z, paddingSingle: H, paddingMultiple: ne, caretColor: xe, colorDisabled: ke, textColorDisabled: De, placeholderColorDisabled: de, colorActive: ve, boxShadowFocus: $e, boxShadowActive: it, boxShadowHover: Xe, border: xt, borderFocus: Te, borderHover: $t, borderActive: er, arrowColor: Nt, arrowColorDisabled: ur, loadingColor: Br, colorActiveWarning: Kr, boxShadowFocusWarning: Jr, boxShadowActiveWarning: ii, boxShadowHoverWarning: gr, borderWarning: vr, borderFocusWarning: Wr, borderHoverWarning: ge, borderActiveWarning: dt, colorActiveError: Bt, boxShadowFocusError: Er, boxShadowActiveError: $r, boxShadowHoverError: gt, borderError: cr, borderFocusError: lr, borderHoverError: ni, borderActiveError: fn, clearColor: tn, clearColorHover: dr, clearColorPressed: Yo, clearSize: qn, arrowSize: Ko, [jt("height", tt)]: kn, [jt("fontSize", tt)]: vo } } = W.value, Zr = To(H), Jn = To(ne);
    return { "--n-bezier": mt, "--n-border": xt, "--n-border-active": er, "--n-border-focus": Te, "--n-border-hover": $t, "--n-border-radius": ri, "--n-box-shadow-active": it, "--n-box-shadow-focus": $e, "--n-box-shadow-hover": Xe, "--n-caret-color": xe, "--n-color": Si, "--n-color-active": ve, "--n-color-disabled": ke, "--n-font-size": vo, "--n-height": kn, "--n-padding-single-top": Zr.top, "--n-padding-multiple-top": Jn.top, "--n-padding-single-right": Zr.right, "--n-padding-multiple-right": Jn.right, "--n-padding-single-left": Zr.left, "--n-padding-multiple-left": Jn.left, "--n-padding-single-bottom": Zr.bottom, "--n-padding-multiple-bottom": Jn.bottom, "--n-placeholder-color": Fe, "--n-placeholder-color-disabled": de, "--n-text-color": Z, "--n-text-color-disabled": De, "--n-arrow-color": Nt, "--n-arrow-color-disabled": ur, "--n-loading-color": Br, "--n-color-active-warning": Kr, "--n-box-shadow-focus-warning": Jr, "--n-box-shadow-active-warning": ii, "--n-box-shadow-hover-warning": gr, "--n-border-warning": vr, "--n-border-focus-warning": Wr, "--n-border-hover-warning": ge, "--n-border-active-warning": dt, "--n-color-active-error": Bt, "--n-box-shadow-focus-error": Er, "--n-box-shadow-active-error": $r, "--n-box-shadow-hover-error": gt, "--n-border-error": cr, "--n-border-focus-error": lr, "--n-border-hover-error": ni, "--n-border-active-error": fn, "--n-clear-size": qn, "--n-clear-color": tn, "--n-clear-color-hover": dr, "--n-clear-color-pressed": Yo, "--n-arrow-size": Ko, "--n-font-weight": Zt };
  }), bt = Ye ? mi("internal-selection", ze(() => r.size[0]), ft, r) : void 0;
  return { mergedTheme: W, mergedClearable: K, mergedClsPrefix: i, rtlEnabled: d, patternInputFocused: V, filterablePlaceholder: ie, label: ee, selected: re, showTagsPanel: O, isComposing: yt, counterRef: M, counterWrapperRef: z, patternInputMirrorRef: f, patternInputRef: g, selfRef: m, multipleElRef: s, singleElRef: C, patternInputWrapperRef: T, overflowRef: L, inputTagElRef: A, handleMouseDown: et, handleFocusin: Ke, handleClear: vt, handleMouseEnter: wt, handleMouseLeave: at, handleDeleteOption: ht, handlePatternKeyDown: nt, handlePatternInputInput: Ft, handlePatternInputBlur: Qt, handlePatternInputFocus: pr, handleMouseEnterCounter: Ee, handleMouseLeaveCounter: ot, handleFocusout: lt, handleCompositionEnd: zt, handleCompositionStart: Ht, onPopoverUpdateShow: Le, focus: xr, focusInput: Mr, blur: tr, blurInput: rr, updateCounter: sr, getCounter: Gt, getTail: Dr, renderLabel: r.renderLabel, cssVars: Ye ? void 0 : ft, themeClass: bt == null ? void 0 : bt.themeClass, onRender: bt == null ? void 0 : bt.onRender };
}, render() {
  const { status: r, multiple: i, size: l, disabled: d, filterable: f, maxTagCount: g, bordered: m, clsPrefix: s, ellipsisTagPopoverProps: C, onRender: T, renderTag: M, renderLabel: z } = this;
  T == null ? void 0 : T();
  const L = g === "responsive", A = typeof g == "number", O = L || A, V = F(c2, null, { default: () => F(yb, { clsPrefix: s, loading: this.loading, showArrow: this.showArrow, showClear: this.mergedClearable && this.selected, onClear: this.handleClear }, { default: () => {
    var W, K;
    return (K = (W = this.$slots).arrow) === null || K === void 0 ? void 0 : K.call(W);
  } }) });
  let X;
  if (i) {
    const { labelField: W } = this, K = (Ve) => F("div", { class: `${s}-base-selection-tag-wrapper`, key: Ve.value }, M ? M({ option: Ve, handleClose: () => {
      this.handleDeleteOption(Ve);
    } }) : F(Mo, { size: l, closable: !Ve.disabled, disabled: d, onClose: () => {
      this.handleDeleteOption(Ve);
    }, internalCloseIsButtonTag: false, internalCloseFocusable: false }, { default: () => z ? z(Ve, true) : vl(Ve[W], Ve, true) })), ie = () => (A ? this.selectedOptions.slice(0, g) : this.selectedOptions).map(K), ee = f ? F("div", { class: `${s}-base-selection-input-tag`, ref: "inputTagElRef", key: "__input-tag__" }, F("input", Object.assign({}, this.inputProps, { ref: "patternInputRef", tabindex: -1, disabled: d, value: this.pattern, autofocus: this.autofocus, class: `${s}-base-selection-input-tag__input`, onBlur: this.handlePatternInputBlur, onFocus: this.handlePatternInputFocus, onKeydown: this.handlePatternKeyDown, onInput: this.handlePatternInputInput, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd })), F("span", { ref: "patternInputMirrorRef", class: `${s}-base-selection-input-tag__mirror` }, this.pattern)) : null, re = L ? () => F("div", { class: `${s}-base-selection-tag-wrapper`, ref: "counterWrapperRef" }, F(Mo, { size: l, ref: "counterRef", onMouseenter: this.handleMouseEnterCounter, onMouseleave: this.handleMouseLeaveCounter, disabled: d })) : void 0;
    let J;
    if (A) {
      const Ve = this.selectedOptions.length - g;
      Ve > 0 && (J = F("div", { class: `${s}-base-selection-tag-wrapper`, key: "__counter__" }, F(Mo, { size: l, ref: "counterRef", onMouseenter: this.handleMouseEnterCounter, disabled: d }, { default: () => `+${Ve}` })));
    }
    const Se = L ? f ? F(Zv, { ref: "overflowRef", updateCounter: this.updateCounter, getCounter: this.getCounter, getTail: this.getTail, style: { width: "100%", display: "flex", overflow: "hidden" } }, { default: ie, counter: re, tail: () => ee }) : F(Zv, { ref: "overflowRef", updateCounter: this.updateCounter, getCounter: this.getCounter, style: { width: "100%", display: "flex", overflow: "hidden" } }, { default: ie, counter: re }) : A && J ? ie().concat(J) : ie(), fe = O ? () => F("div", { class: `${s}-base-selection-popover` }, L ? ie() : this.selectedOptions.map(K)) : void 0, oe = O ? Object.assign({ show: this.showTagsPanel, trigger: "hover", overlap: true, placement: "top", width: "trigger", onUpdateShow: this.onPopoverUpdateShow, theme: this.mergedTheme.peers.Popover, themeOverrides: this.mergedTheme.peerOverrides.Popover }, C) : null, be = (this.selected ? false : this.active ? !this.pattern && !this.isComposing : true) ? F("div", { class: `${s}-base-selection-placeholder ${s}-base-selection-overlay` }, F("div", { class: `${s}-base-selection-placeholder__inner` }, this.placeholder)) : null, je = f ? F("div", { ref: "patternInputWrapperRef", class: `${s}-base-selection-tags` }, Se, L ? null : ee, V) : F("div", { ref: "multipleElRef", class: `${s}-base-selection-tags`, tabindex: d ? void 0 : 0 }, Se, V);
    X = F(Gr, null, O ? F(jg, Object.assign({}, oe, { scrollable: true, style: "max-height: calc(var(--v-target-height) * 6.6);" }), { trigger: () => je, default: fe }) : je, be);
  } else if (f) {
    const W = this.pattern || this.isComposing, K = this.active ? !W : !this.selected, ie = this.active ? false : this.selected;
    X = F("div", { ref: "patternInputWrapperRef", class: `${s}-base-selection-label`, title: this.patternInputFocused ? void 0 : vg(this.label) }, F("input", Object.assign({}, this.inputProps, { ref: "patternInputRef", class: `${s}-base-selection-input`, value: this.active ? this.pattern : "", placeholder: "", readonly: d, disabled: d, tabindex: -1, autofocus: this.autofocus, onFocus: this.handlePatternInputFocus, onBlur: this.handlePatternInputBlur, onInput: this.handlePatternInputInput, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd })), ie ? F("div", { class: `${s}-base-selection-label__render-label ${s}-base-selection-overlay`, key: "input" }, F("div", { class: `${s}-base-selection-overlay__wrapper` }, M ? M({ option: this.selectedOption, handleClose: () => {
    } }) : z ? z(this.selectedOption, true) : vl(this.label, this.selectedOption, true))) : null, K ? F("div", { class: `${s}-base-selection-placeholder ${s}-base-selection-overlay`, key: "placeholder" }, F("div", { class: `${s}-base-selection-overlay__wrapper` }, this.filterablePlaceholder)) : null, V);
  } else X = F("div", { ref: "singleElRef", class: `${s}-base-selection-label`, tabindex: this.disabled ? void 0 : 0 }, this.label !== void 0 ? F("div", { class: `${s}-base-selection-input`, title: vg(this.label), key: "input" }, F("div", { class: `${s}-base-selection-input__content` }, M ? M({ option: this.selectedOption, handleClose: () => {
  } }) : z ? z(this.selectedOption, true) : vl(this.label, this.selectedOption, true))) : F("div", { class: `${s}-base-selection-placeholder ${s}-base-selection-overlay`, key: "placeholder" }, F("div", { class: `${s}-base-selection-placeholder__inner` }, this.placeholder)), V);
  return F("div", { ref: "selfRef", class: [`${s}-base-selection`, this.rtlEnabled && `${s}-base-selection--rtl`, this.themeClass, r && `${s}-base-selection--${r}-status`, { [`${s}-base-selection--active`]: this.active, [`${s}-base-selection--selected`]: this.selected || this.active && this.pattern, [`${s}-base-selection--disabled`]: this.disabled, [`${s}-base-selection--multiple`]: this.multiple, [`${s}-base-selection--focus`]: this.focused }], style: this.cssVars, onClick: this.onClick, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onKeydown: this.onKeydown, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onMousedown: this.handleMouseDown }, X, m ? F("div", { class: `${s}-base-selection__border` }) : null, m ? F("div", { class: `${s}-base-selection__state-border` }) : null);
} }), mk = ue("alert", `
 line-height: var(--n-line-height);
 border-radius: var(--n-border-radius);
 position: relative;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-color);
 text-align: start;
 word-break: break-word;
`, [Re("border", `
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 transition: border-color .3s var(--n-bezier);
 border: var(--n-border);
 pointer-events: none;
 `), Ue("closable", [ue("alert-body", [Re("title", `
 padding-right: 24px;
 `)])]), Re("icon", { color: "var(--n-icon-color)" }), ue("alert-body", { padding: "var(--n-padding)" }, [Re("title", { color: "var(--n-title-text-color)" }), Re("content", { color: "var(--n-content-text-color)" })]), Vf({ originalTransition: "transform .3s var(--n-bezier)", enterToProps: { transform: "scale(1)" }, leaveToProps: { transform: "scale(0.9)" } }), Re("icon", `
 position: absolute;
 left: 0;
 top: 0;
 align-items: center;
 justify-content: center;
 display: flex;
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 margin: var(--n-icon-margin);
 `), Re("close", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 position: absolute;
 right: 0;
 top: 0;
 margin: var(--n-close-margin);
 `), Ue("show-icon", [ue("alert-body", { paddingLeft: "calc(var(--n-icon-margin-left) + var(--n-icon-size) + var(--n-icon-margin-right))" })]), Ue("right-adjust", [ue("alert-body", { paddingRight: "calc(var(--n-close-size) + var(--n-padding) + 2px)" })]), ue("alert-body", `
 border-radius: var(--n-border-radius);
 transition: border-color .3s var(--n-bezier);
 `, [Re("title", `
 transition: color .3s var(--n-bezier);
 font-size: 16px;
 line-height: 19px;
 font-weight: var(--n-title-font-weight);
 `, [Ge("& +", [Re("content", { marginTop: "9px" })])]), Re("content", { transition: "color .3s var(--n-bezier)", fontSize: "var(--n-font-size)" })]), Re("icon", { transition: "color .3s var(--n-bezier)" })]), gk = Object.assign(Object.assign({}, Kt.props), { title: String, showIcon: { type: Boolean, default: true }, type: { type: String, default: "default" }, bordered: { type: Boolean, default: true }, closable: Boolean, onClose: Function, onAfterLeave: Function, onAfterHide: Function }), vk = st({ name: "Alert", inheritAttrs: false, props: gk, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, mergedBorderedRef: l, inlineThemeDisabled: d, mergedRtlRef: f } = Tr(r), g = Kt("Alert", "-alert", mk, h2, r, i), m = Rn("Alert", f, i), s = ze(() => {
    const { common: { cubicBezierEaseInOut: A }, self: O } = g.value, { fontSize: V, borderRadius: X, titleFontWeight: W, lineHeight: K, iconSize: ie, iconMargin: ee, iconMarginRtl: re, closeIconSize: J, closeBorderRadius: Se, closeSize: fe, closeMargin: oe, closeMarginRtl: he, padding: be } = O, { type: je } = r, { left: Ve, right: Ke } = To(ee);
    return { "--n-bezier": A, "--n-color": O[jt("color", je)], "--n-close-icon-size": J, "--n-close-border-radius": Se, "--n-close-color-hover": O[jt("closeColorHover", je)], "--n-close-color-pressed": O[jt("closeColorPressed", je)], "--n-close-icon-color": O[jt("closeIconColor", je)], "--n-close-icon-color-hover": O[jt("closeIconColorHover", je)], "--n-close-icon-color-pressed": O[jt("closeIconColorPressed", je)], "--n-icon-color": O[jt("iconColor", je)], "--n-border": O[jt("border", je)], "--n-title-text-color": O[jt("titleTextColor", je)], "--n-content-text-color": O[jt("contentTextColor", je)], "--n-line-height": K, "--n-border-radius": X, "--n-font-size": V, "--n-title-font-weight": W, "--n-icon-size": ie, "--n-icon-margin": ee, "--n-icon-margin-rtl": re, "--n-close-size": fe, "--n-close-margin": oe, "--n-close-margin-rtl": he, "--n-padding": be, "--n-icon-margin-left": Ve, "--n-icon-margin-right": Ke };
  }), C = d ? mi("alert", ze(() => r.type[0]), s, r) : void 0, T = Ae(true), M = () => {
    const { onAfterLeave: A, onAfterHide: O } = r;
    A && A(), O && O();
  };
  return { rtlEnabled: m, mergedClsPrefix: i, mergedBordered: l, visible: T, handleCloseClick: () => {
    var A;
    Promise.resolve((A = r.onClose) === null || A === void 0 ? void 0 : A.call(r)).then((O) => {
      O !== false && (T.value = false);
    });
  }, handleAfterLeave: () => {
    M();
  }, mergedTheme: g, cssVars: d ? void 0 : s, themeClass: C == null ? void 0 : C.themeClass, onRender: C == null ? void 0 : C.onRender };
}, render() {
  var r;
  return (r = this.onRender) === null || r === void 0 || r.call(this), F(op, { onAfterLeave: this.handleAfterLeave }, { default: () => {
    const { mergedClsPrefix: i, $slots: l } = this, d = { class: [`${i}-alert`, this.themeClass, this.closable && `${i}-alert--closable`, this.showIcon && `${i}-alert--show-icon`, !this.title && this.closable && `${i}-alert--right-adjust`, this.rtlEnabled && `${i}-alert--rtl`], style: this.cssVars, role: "alert" };
    return this.visible ? F("div", Object.assign({}, Ya(this.$attrs, d)), this.closable && F(np, { clsPrefix: i, class: `${i}-alert__close`, onClick: this.handleCloseClick }), this.bordered && F("div", { class: `${i}-alert__border` }), this.showIcon && F("div", { class: `${i}-alert__icon`, "aria-hidden": "true" }, Un(l.icon, () => [F(Nr, { clsPrefix: i }, { default: () => {
      switch (this.type) {
        case "success":
          return F(Ug, null);
        case "info":
          return F(Vg, null);
        case "warning":
          return F(ap, null);
        case "error":
          return F(Ng, null);
        default:
          return null;
      }
    } })])), F("div", { class: [`${i}-alert-body`, this.mergedBordered && `${i}-alert-body--bordered`] }, Ci(l.header, (f) => {
      const g = f || this.title;
      return g ? F("div", { class: `${i}-alert-body__title` }, g) : null;
    }), l.default && F("div", { class: `${i}-alert-body__content` }, l))) : null;
  } });
} }), Lf = An("n-anchor"), _k = { title: String, href: String }, Bf = st({ name: "AnchorLink", props: _k, slots: Object, setup(r, { slots: i }) {
  const l = Ae(null), d = fr(Lf), f = Dt(r, "href"), g = _i(() => f.value && f.value === d.activeHref.value);
  q3(Lf, "collectedLinkHrefs", f), G3(Lf, "titleEls", () => l.value), ar(g, (s) => {
    s && l.value && d.updateBarPosition(l.value);
  });
  function m() {
    r.href !== void 0 && d.setActiveHref(r.href);
  }
  return () => {
    var s;
    const { value: C } = d.mergedClsPrefix;
    return F("div", { class: [`${C}-anchor-link`, g.value && `${C}-anchor-link--active`] }, F("a", { ref: l, class: [`${C}-anchor-link__title`], href: r.href, title: vg(r.title), onClick: m }, { default: () => Un(i.title, () => [r.title]) }), (s = i.default) === null || s === void 0 ? void 0 : s.call(i));
  };
} });
function yk(r, i) {
  const { top: l, height: d } = r.getBoundingClientRect(), f = i instanceof HTMLElement ? i.getBoundingClientRect().top : 0;
  return { top: l - f, height: d };
}
const Hg = { type: { type: String, default: "rail" }, showRail: { type: Boolean, default: true }, showBackground: { type: Boolean, default: true }, bound: { type: Number, default: 12 }, internalScrollable: Boolean, ignoreGap: Boolean, offsetTarget: [String, Object, Function] }, bk = jd(Hg), xk = st({ name: "BaseAnchor", props: Object.assign(Object.assign({}, Hg), { mergedClsPrefix: { type: String, required: true } }), setup(r) {
  const i = [], l = [], d = Ae(null), f = Ae(null), g = Ae(null), m = Ae(null);
  let s = false;
  const C = ze(() => r.type === "block"), T = ze(() => !C.value && r.showRail);
  function M() {
    const { value: K } = g, { value: ie } = f;
    K && (K.style.transition = "none"), ie && (ie.style.transition = "none"), l && l.forEach((ee) => {
      ee.style.transition = "none";
    }), Vn(() => {
      const { value: ee } = g, { value: re } = f;
      ee && (ee.offsetWidth, ee.style.transition = ""), re && (re.offsetWidth, re.style.transition = ""), l && l.forEach((J) => {
        J.offsetWidth, J.style.transition = "";
      });
    });
  }
  function z(K, ie = true) {
    const { value: ee } = g, { value: re } = f, { value: J } = m;
    if (!J || !ee) return;
    ie || (ee.style.transition = "none", re && (re.style.transition = "none"));
    const { offsetHeight: Se, offsetWidth: fe } = K, { top: oe, left: he } = K.getBoundingClientRect(), { top: be, left: je } = J.getBoundingClientRect(), Ve = oe - be, Ke = he - je;
    ee.style.top = `${Ve}px`, ee.style.height = `${Se}px`, re && (re.style.top = `${Ve}px`, re.style.height = `${Se}px`, re.style.maxWidth = `${fe + Ke}px`), ee.offsetHeight, re && re.offsetHeight, ie || (ee.style.transition = "", re && (re.style.transition = ""));
  }
  let L, A = false, O = false;
  const V = () => {
    if (O) A = true;
    else {
      if (s) return;
      W(true), O = true, clearTimeout(L), L = setTimeout(() => {
        O = false, A && (A = false, V());
      }, 128);
    }
  };
  function X(K, ie = true) {
    const ee = /^#([^#]+)$/.exec(K);
    if (!ee) return;
    const re = document.getElementById(ee[1]);
    re && (s = true, d.value = K, re.scrollIntoView(), ie || M(), A = false, setTimeout(() => {
      s = false;
    }, 0));
  }
  function W(K = true) {
    var ie;
    const ee = [], re = db((ie = r.offsetTarget) !== null && ie !== void 0 ? ie : document);
    i.forEach((he) => {
      const be = /#([^#]+)$/.exec(he);
      if (!be) return;
      const je = document.getElementById(be[1]);
      if (je && re) {
        const { top: Ve, height: Ke } = yk(je, re);
        ee.push({ top: Ve, height: Ke, href: he });
      }
    }), ee.sort((he, be) => he.top > be.top ? 1 : (he.top === be.top && he.height < be.height, -1));
    const J = d.value, { bound: Se, ignoreGap: fe } = r, oe = ee.reduce((he, be) => be.top + be.height < 0 ? fe ? be : he : be.top <= Se ? he === null ? be : be.top === he.top ? be.href === J ? be : he : be.top > he.top ? be : he : he, null);
    K || M(), oe ? d.value = oe.href : d.value = null;
  }
  return Yr(Lf, { activeHref: d, mergedClsPrefix: Dt(r, "mergedClsPrefix"), updateBarPosition: z, setActiveHref: X, collectedLinkHrefs: i, titleEls: l }), Qi(() => {
    document.addEventListener("scroll", V, true), X(window.location.hash), W(false);
  }), My(() => {
    X(window.location.hash), W(false);
  }), Sn(() => {
    clearTimeout(L), document.removeEventListener("scroll", V, true);
  }), ar(d, (K) => {
    if (K === null) {
      const { value: ie } = f;
      ie && !C.value && (ie.style.maxWidth = "0");
    }
  }), { selfRef: m, barRef: g, slotRef: f, setActiveHref: X, activeHref: d, isBlockType: C, mergedShowRail: T };
}, render() {
  var r;
  const { mergedClsPrefix: i, mergedShowRail: l, isBlockType: d, $slots: f } = this, g = F("div", { class: [`${i}-anchor`, d && `${i}-anchor--block`, l && `${i}-anchor--show-rail`], ref: "selfRef" }, l && this.showBackground ? F("div", { ref: "slotRef", class: `${i}-anchor-link-background` }) : null, l ? F("div", { class: `${i}-anchor-rail` }, F("div", { ref: "barRef", class: [`${i}-anchor-rail__bar`, this.activeHref !== null && `${i}-anchor-rail__bar--active`] })) : null, (r = f.default) === null || r === void 0 ? void 0 : r.call(f));
  return this.internalScrollable ? F(th, null, { default: () => g }) : g;
} }), wk = ue("anchor", `
 position: relative;
`, [pi("block", `
 padding-left: var(--n-rail-width);
 `, [ue("anchor-link", [Ge("+, >", [ue("anchor-link", `
 margin-top: .5em;
 `)])]), ue("anchor-link-background", `
 max-width: 0;
 border-top-right-radius: 10.5px;
 border-bottom-right-radius: 10.5px;
 `), pi("show-rail", [Ge(">", [ue("anchor-link", "padding-left: 0;")])])]), Ue("block", [ue("anchor-link", `
 margin-bottom: 4px;
 padding: 2px 8px;
 transition: background-color .3s var(--n-bezier);
 background-color: transparent;
 border-radius: var(--n-link-border-radius);
 `, [Ue("active", `
 background-color: var(--n-link-color);
 `)])]), ue("anchor-link-background", `
 position: absolute;
 left: calc(var(--n-rail-width) / 2);
 width: 100%;
 background-color: var(--n-link-color);
 transition:
 top .15s var(--n-bezier),
 max-width .15s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), ue("anchor-rail", `
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 width: var(--n-rail-width);
 border-radius: calc(var(--n-rail-width) / 2);
 overflow: hidden;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [Re("bar", `
 position: absolute;
 left: 0;
 width: var(--n-rail-width);
 height: 21px;
 background-color: #0000;
 transition: 
 top .15s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [Ue("active", { backgroundColor: "var(--n-rail-color-active)" })])]), ue("anchor-link", `
 padding: var(--n-link-padding);
 position: relative;
 line-height: 1.5;
 font-size: var(--n-link-font-size);
 min-height: 1.5em;
 display: flex;
 flex-direction: column;
 `, [Ue("active", [Ge(">", [Re("title", `
 color: var(--n-link-text-color-active);
 `)])]), Re("title", `
 outline: none;
 max-width: 100%;
 text-decoration: none;
 white-space: nowrap;
 text-overflow: ellipsis;
 overflow: hidden;
 cursor: pointer;
 display: inline-block;
 padding-right: 16px;
 transition: color .3s var(--n-bezier);
 color: var(--n-link-text-color);
 `, [Ge("&:hover, &:focus", `
 color: var(--n-link-text-color-hover);
 `), Ge("&:active", `
 color: var(--n-link-text-color-pressed);
 `)])])]), Ck = Object.assign(Object.assign(Object.assign(Object.assign({}, Kt.props), { affix: Boolean }), Zg), Hg), bb = st({ name: "Anchor", props: Ck, setup(r, { slots: i }) {
  const { mergedClsPrefixRef: l, inlineThemeDisabled: d } = Tr(r), f = Kt("Anchor", "-anchor", wk, f2, r, l), g = Ae(null), m = ze(() => {
    const { self: { railColor: C, linkColor: T, railColorActive: M, linkTextColor: z, linkTextColorHover: L, linkTextColorPressed: A, linkTextColorActive: O, linkFontSize: V, railWidth: X, linkPadding: W, borderRadius: K }, common: { cubicBezierEaseInOut: ie } } = f.value;
    return { "--n-link-border-radius": K, "--n-link-color": T, "--n-link-font-size": V, "--n-link-text-color": z, "--n-link-text-color-hover": L, "--n-link-text-color-active": O, "--n-link-text-color-pressed": A, "--n-link-padding": W, "--n-bezier": ie, "--n-rail-color": C, "--n-rail-color-active": M, "--n-rail-width": X };
  }), s = d ? mi("anchor", void 0, m, r) : void 0;
  return { scrollTo(C) {
    var T;
    (T = g.value) === null || T === void 0 || T.setActiveHref(C);
  }, renderAnchor: () => (s == null ? void 0 : s.onRender(), F(xk, Object.assign({ ref: g, style: d ? void 0 : m.value, class: s == null ? void 0 : s.themeClass.value }, lg(r, bk), { mergedClsPrefix: l.value }), i)) };
}, render() {
  return this.affix ? F(jS, Object.assign({}, lg(this, $S)), { default: this.renderAnchor }) : this.renderAnchor();
} }), xb = An("n-input"), Sk = ue("input", `
 max-width: 100%;
 cursor: text;
 line-height: 1.5;
 z-index: auto;
 outline: none;
 box-sizing: border-box;
 position: relative;
 display: inline-flex;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color .3s var(--n-bezier);
 font-size: var(--n-font-size);
 font-weight: var(--n-font-weight);
 --n-padding-vertical: calc((var(--n-height) - 1.5 * var(--n-font-size)) / 2);
`, [Re("input, textarea", `
 overflow: hidden;
 flex-grow: 1;
 position: relative;
 `), Re("input-el, textarea-el, input-mirror, textarea-mirror, separator, placeholder", `
 box-sizing: border-box;
 font-size: inherit;
 line-height: 1.5;
 font-family: inherit;
 border: none;
 outline: none;
 background-color: #0000;
 text-align: inherit;
 transition:
 -webkit-text-fill-color .3s var(--n-bezier),
 caret-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 `), Re("input-el, textarea-el", `
 -webkit-appearance: none;
 scrollbar-width: none;
 width: 100%;
 min-width: 0;
 text-decoration-color: var(--n-text-decoration-color);
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 background-color: transparent;
 `, [Ge("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), Ge("&::placeholder", `
 color: #0000;
 -webkit-text-fill-color: transparent !important;
 `), Ge("&:-webkit-autofill ~", [Re("placeholder", "display: none;")])]), Ue("round", [pi("textarea", "border-radius: calc(var(--n-height) / 2);")]), Re("placeholder", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: hidden;
 color: var(--n-placeholder-color);
 `, [Ge("span", `
 width: 100%;
 display: inline-block;
 `)]), Ue("textarea", [Re("placeholder", "overflow: visible;")]), pi("autosize", "width: 100%;"), Ue("autosize", [Re("textarea-el, input-el", `
 position: absolute;
 top: 0;
 left: 0;
 height: 100%;
 `)]), ue("input-wrapper", `
 overflow: hidden;
 display: inline-flex;
 flex-grow: 1;
 position: relative;
 padding-left: var(--n-padding-left);
 padding-right: var(--n-padding-right);
 `), Re("input-mirror", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre;
 pointer-events: none;
 `), Re("input-el", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [Ge("&[type=password]::-ms-reveal", "display: none;"), Ge("+", [Re("placeholder", `
 display: flex;
 align-items: center; 
 `)])]), pi("textarea", [Re("placeholder", "white-space: nowrap;")]), Re("eye", `
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `), Ue("textarea", "width: 100%;", [ue("input-word-count", `
 position: absolute;
 right: var(--n-padding-right);
 bottom: var(--n-padding-vertical);
 `), Ue("resizable", [ue("input-wrapper", `
 resize: vertical;
 min-height: var(--n-height);
 `)]), Re("textarea-el, textarea-mirror, placeholder", `
 height: 100%;
 padding-left: 0;
 padding-right: 0;
 padding-top: var(--n-padding-vertical);
 padding-bottom: var(--n-padding-vertical);
 word-break: break-word;
 display: inline-block;
 vertical-align: bottom;
 box-sizing: border-box;
 line-height: var(--n-line-height-textarea);
 margin: 0;
 resize: none;
 white-space: pre-wrap;
 scroll-padding-block-end: var(--n-padding-vertical);
 `), Re("textarea-mirror", `
 width: 100%;
 pointer-events: none;
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre-wrap;
 overflow-wrap: break-word;
 `)]), Ue("pair", [Re("input-el, placeholder", "text-align: center;"), Re("separator", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 white-space: nowrap;
 `, [ue("icon", `
 color: var(--n-icon-color);
 `), ue("base-icon", `
 color: var(--n-icon-color);
 `)])]), Ue("disabled", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [Re("border", "border: var(--n-border-disabled);"), Re("input-el, textarea-el", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 text-decoration-color: var(--n-text-color-disabled);
 `), Re("placeholder", "color: var(--n-placeholder-color-disabled);"), Re("separator", "color: var(--n-text-color-disabled);", [ue("icon", `
 color: var(--n-icon-color-disabled);
 `), ue("base-icon", `
 color: var(--n-icon-color-disabled);
 `)]), ue("input-word-count", `
 color: var(--n-count-text-color-disabled);
 `), Re("suffix, prefix", "color: var(--n-text-color-disabled);", [ue("icon", `
 color: var(--n-icon-color-disabled);
 `), ue("internal-icon", `
 color: var(--n-icon-color-disabled);
 `)])]), pi("disabled", [Re("eye", `
 color: var(--n-icon-color);
 cursor: pointer;
 `, [Ge("&:hover", `
 color: var(--n-icon-color-hover);
 `), Ge("&:active", `
 color: var(--n-icon-color-pressed);
 `)]), Ge("&:hover", [Re("state-border", "border: var(--n-border-hover);")]), Ue("focus", "background-color: var(--n-color-focus);", [Re("state-border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), Re("border, state-border", `
 box-sizing: border-box;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border-radius: inherit;
 border: var(--n-border);
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), Re("state-border", `
 border-color: #0000;
 z-index: 1;
 `), Re("prefix", "margin-right: 4px;"), Re("suffix", `
 margin-left: 4px;
 `), Re("suffix, prefix", `
 transition: color .3s var(--n-bezier);
 flex-wrap: nowrap;
 flex-shrink: 0;
 line-height: var(--n-height);
 white-space: nowrap;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 color: var(--n-suffix-text-color);
 `, [ue("base-loading", `
 font-size: var(--n-icon-size);
 margin: 0 2px;
 color: var(--n-loading-color);
 `), ue("base-clear", `
 font-size: var(--n-icon-size);
 `, [Re("placeholder", [ue("base-icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)])]), Ge(">", [ue("icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)]), ue("base-icon", `
 font-size: var(--n-icon-size);
 `)]), ue("input-word-count", `
 pointer-events: none;
 line-height: 1.5;
 font-size: .85em;
 color: var(--n-count-text-color);
 transition: color .3s var(--n-bezier);
 margin-left: 4px;
 font-variant: tabular-nums;
 `), ["warning", "error"].map((r) => Ue(`${r}-status`, [pi("disabled", [ue("base-loading", `
 color: var(--n-loading-color-${r})
 `), Re("input-el, textarea-el", `
 caret-color: var(--n-caret-color-${r});
 `), Re("state-border", `
 border: var(--n-border-${r});
 `), Ge("&:hover", [Re("state-border", `
 border: var(--n-border-hover-${r});
 `)]), Ge("&:focus", `
 background-color: var(--n-color-focus-${r});
 `, [Re("state-border", `
 box-shadow: var(--n-box-shadow-focus-${r});
 border: var(--n-border-focus-${r});
 `)]), Ue("focus", `
 background-color: var(--n-color-focus-${r});
 `, [Re("state-border", `
 box-shadow: var(--n-box-shadow-focus-${r});
 border: var(--n-border-focus-${r});
 `)])])]))]), kk = ue("input", [Ue("disabled", [Re("input-el, textarea-el", `
 -webkit-text-fill-color: var(--n-text-color-disabled);
 `)])]);
function Pk(r) {
  let i = 0;
  for (const l of r) i++;
  return i;
}
function bf(r) {
  return r === "" || r == null;
}
function Tk(r) {
  const i = Ae(null);
  function l() {
    const { value: g } = r;
    if (!(g == null ? void 0 : g.focus)) {
      f();
      return;
    }
    const { selectionStart: m, selectionEnd: s, value: C } = g;
    if (m == null || s == null) {
      f();
      return;
    }
    i.value = { start: m, end: s, beforeText: C.slice(0, m), afterText: C.slice(s) };
  }
  function d() {
    var g;
    const { value: m } = i, { value: s } = r;
    if (!m || !s) return;
    const { value: C } = s, { start: T, beforeText: M, afterText: z } = m;
    let L = C.length;
    if (C.endsWith(z)) L = C.length - z.length;
    else if (C.startsWith(M)) L = M.length;
    else {
      const A = M[T - 1], O = C.indexOf(A, T - 1);
      O !== -1 && (L = O + 1);
    }
    (g = s.setSelectionRange) === null || g === void 0 || g.call(s, L, L);
  }
  function f() {
    i.value = null;
  }
  return ar(r, f), { recordCursor: l, restoreCursor: d };
}
const u_ = st({ name: "InputWordCount", setup(r, { slots: i }) {
  const { mergedValueRef: l, maxlengthRef: d, mergedClsPrefixRef: f, countGraphemesRef: g } = fr(xb), m = ze(() => {
    const { value: s } = l;
    return s === null || Array.isArray(s) ? 0 : (g.value || Pk)(s);
  });
  return () => {
    const { value: s } = d, { value: C } = l;
    return F("span", { class: `${f.value}-input-word-count` }, ug(i.default, { value: C === null || Array.isArray(C) ? "" : C }, () => [s === void 0 ? m.value : `${m.value} / ${s}`]));
  };
} }), Ik = Object.assign(Object.assign({}, Kt.props), { bordered: { type: Boolean, default: void 0 }, type: { type: String, default: "text" }, placeholder: [Array, String], defaultValue: { type: [String, Array], default: null }, value: [String, Array], disabled: { type: Boolean, default: void 0 }, size: String, rows: { type: [Number, String], default: 3 }, round: Boolean, minlength: [String, Number], maxlength: [String, Number], clearable: Boolean, autosize: { type: [Boolean, Object], default: false }, pair: Boolean, separator: String, readonly: { type: [String, Boolean], default: false }, passivelyActivated: Boolean, showPasswordOn: String, stateful: { type: Boolean, default: true }, autofocus: Boolean, inputProps: Object, resizable: { type: Boolean, default: true }, showCount: Boolean, loading: { type: Boolean, default: void 0 }, allowInput: Function, renderCount: Function, onMousedown: Function, onKeydown: Function, onKeyup: [Function, Array], onInput: [Function, Array], onFocus: [Function, Array], onBlur: [Function, Array], onClick: [Function, Array], onChange: [Function, Array], onClear: [Function, Array], countGraphemes: Function, status: String, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], textDecoration: [String, Array], attrSize: { type: Number, default: 20 }, onInputBlur: [Function, Array], onInputFocus: [Function, Array], onDeactivate: [Function, Array], onActivate: [Function, Array], onWrapperFocus: [Function, Array], onWrapperBlur: [Function, Array], internalDeactivateOnEnter: Boolean, internalForceFocus: Boolean, internalLoadingBeforeSuffix: { type: Boolean, default: true }, showPasswordToggle: Boolean }), ho = st({ name: "Input", props: Ik, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, mergedBorderedRef: l, inlineThemeDisabled: d, mergedRtlRef: f } = Tr(r), g = Kt("Input", "-input", Sk, p2, r, i);
  m2 && ac("-input-safari", kk, i);
  const m = Ae(null), s = Ae(null), C = Ae(null), T = Ae(null), M = Ae(null), z = Ae(null), L = Ae(null), A = Tk(L), O = Ae(null), { localeRef: V } = Ja("Input"), X = Ae(r.defaultValue), W = Dt(r, "value"), K = Zi(W, X), ie = va(r), { mergedSizeRef: ee, mergedDisabledRef: re, mergedStatusRef: J } = ie, Se = Ae(false), fe = Ae(false), oe = Ae(false), he = Ae(false);
  let be = null;
  const je = ze(() => {
    const { placeholder: ge, pair: dt } = r;
    return dt ? Array.isArray(ge) ? ge : ge === void 0 ? ["", ""] : [ge, ge] : ge === void 0 ? [V.value.placeholder] : [ge];
  }), Ve = ze(() => {
    const { value: ge } = oe, { value: dt } = K, { value: Bt } = je;
    return !ge && (bf(dt) || Array.isArray(dt) && bf(dt[0])) && Bt[0];
  }), Ke = ze(() => {
    const { value: ge } = oe, { value: dt } = K, { value: Bt } = je;
    return !ge && Bt[1] && (bf(dt) || Array.isArray(dt) && bf(dt[1]));
  }), lt = _i(() => r.internalForceFocus || Se.value), vt = _i(() => {
    if (re.value || r.readonly || !r.clearable || !lt.value && !fe.value) return false;
    const { value: ge } = K, { value: dt } = lt;
    return r.pair ? !!(Array.isArray(ge) && (ge[0] || ge[1])) && (fe.value || dt) : !!ge && (fe.value || dt);
  }), wt = ze(() => {
    const { showPasswordOn: ge } = r;
    if (ge) return ge;
    if (r.showPasswordToggle) return "click";
  }), at = Ae(false), et = ze(() => {
    const { textDecoration: ge } = r;
    return ge ? Array.isArray(ge) ? ge.map((dt) => ({ textDecoration: dt })) : [{ textDecoration: ge }] : ["", ""];
  }), ht = Ae(void 0), yt = () => {
    var ge, dt;
    if (r.type === "textarea") {
      const { autosize: Bt } = r;
      if (Bt && (ht.value = (dt = (ge = O.value) === null || ge === void 0 ? void 0 : ge.$el) === null || dt === void 0 ? void 0 : dt.offsetWidth), !s.value || typeof Bt == "boolean") return;
      const { paddingTop: Er, paddingBottom: $r, lineHeight: gt } = window.getComputedStyle(s.value), cr = Number(Er.slice(0, -2)), lr = Number($r.slice(0, -2)), ni = Number(gt.slice(0, -2)), { value: fn } = C;
      if (!fn) return;
      if (Bt.minRows) {
        const tn = Math.max(Bt.minRows, 1), dr = `${cr + lr + ni * tn}px`;
        fn.style.minHeight = dr;
      }
      if (Bt.maxRows) {
        const tn = `${cr + lr + ni * Bt.maxRows}px`;
        fn.style.maxHeight = tn;
      }
    }
  }, nt = ze(() => {
    const { maxlength: ge } = r;
    return ge === void 0 ? void 0 : Number(ge);
  });
  Qi(() => {
    const { value: ge } = K;
    Array.isArray(ge) || er(ge);
  });
  const ut = eh().proxy;
  function Ft(ge, dt) {
    const { onUpdateValue: Bt, "onUpdate:value": Er, onInput: $r } = r, { nTriggerFormInput: gt } = ie;
    Bt && Ot(Bt, ge, dt), Er && Ot(Er, ge, dt), $r && Ot($r, ge, dt), X.value = ge, gt();
  }
  function Ht(ge, dt) {
    const { onChange: Bt } = r, { nTriggerFormChange: Er } = ie;
    Bt && Ot(Bt, ge, dt), X.value = ge, Er();
  }
  function zt(ge) {
    const { onBlur: dt } = r, { nTriggerFormBlur: Bt } = ie;
    dt && Ot(dt, ge), Bt();
  }
  function pr(ge) {
    const { onFocus: dt } = r, { nTriggerFormFocus: Bt } = ie;
    dt && Ot(dt, ge), Bt();
  }
  function Qt(ge) {
    const { onClear: dt } = r;
    dt && Ot(dt, ge);
  }
  function tr(ge) {
    const { onInputBlur: dt } = r;
    dt && Ot(dt, ge);
  }
  function xr(ge) {
    const { onInputFocus: dt } = r;
    dt && Ot(dt, ge);
  }
  function Mr() {
    const { onDeactivate: ge } = r;
    ge && Ot(ge);
  }
  function rr() {
    const { onActivate: ge } = r;
    ge && Ot(ge);
  }
  function sr(ge) {
    const { onClick: dt } = r;
    dt && Ot(dt, ge);
  }
  function Gt(ge) {
    const { onWrapperFocus: dt } = r;
    dt && Ot(dt, ge);
  }
  function Dr(ge) {
    const { onWrapperBlur: dt } = r;
    dt && Ot(dt, ge);
  }
  function wr() {
    oe.value = true;
  }
  function Ct(ge) {
    oe.value = false, ge.target === z.value ? Ee(ge, 1) : Ee(ge, 0);
  }
  function Ee(ge, dt = 0, Bt = "input") {
    const Er = ge.target.value;
    if (er(Er), ge instanceof InputEvent && !ge.isComposing && (oe.value = false), r.type === "textarea") {
      const { value: gt } = O;
      gt && gt.syncUnifiedContainer();
    }
    if (be = Er, oe.value) return;
    A.recordCursor();
    const $r = ot(Er);
    if ($r) if (!r.pair) Bt === "input" ? Ft(Er, { source: dt }) : Ht(Er, { source: dt });
    else {
      let { value: gt } = K;
      Array.isArray(gt) ? gt = [gt[0], gt[1]] : gt = ["", ""], gt[dt] = Er, Bt === "input" ? Ft(gt, { source: dt }) : Ht(gt, { source: dt });
    }
    ut.$forceUpdate(), $r || Vn(A.restoreCursor);
  }
  function ot(ge) {
    const { countGraphemes: dt, maxlength: Bt, minlength: Er } = r;
    if (dt) {
      let gt;
      if (Bt !== void 0 && (gt === void 0 && (gt = dt(ge)), gt > Number(Bt)) || Er !== void 0 && (gt === void 0 && (gt = dt(ge)), gt < Number(Bt))) return false;
    }
    const { allowInput: $r } = r;
    return typeof $r == "function" ? $r(ge) : true;
  }
  function Le(ge) {
    tr(ge), ge.relatedTarget === m.value && Mr(), ge.relatedTarget !== null && (ge.relatedTarget === M.value || ge.relatedTarget === z.value || ge.relatedTarget === s.value) || (he.value = false), tt(ge, "blur"), L.value = null;
  }
  function Ye(ge, dt) {
    xr(ge), Se.value = true, he.value = true, rr(), tt(ge, "focus"), dt === 0 ? L.value = M.value : dt === 1 ? L.value = z.value : dt === 2 && (L.value = s.value);
  }
  function ft(ge) {
    r.passivelyActivated && (Dr(ge), tt(ge, "blur"));
  }
  function bt(ge) {
    r.passivelyActivated && (Se.value = true, Gt(ge), tt(ge, "focus"));
  }
  function tt(ge, dt) {
    ge.relatedTarget !== null && (ge.relatedTarget === M.value || ge.relatedTarget === z.value || ge.relatedTarget === s.value || ge.relatedTarget === m.value) || (dt === "focus" ? (pr(ge), Se.value = true) : dt === "blur" && (zt(ge), Se.value = false));
  }
  function mt(ge, dt) {
    Ee(ge, dt, "change");
  }
  function Zt(ge) {
    sr(ge);
  }
  function ri(ge) {
    Qt(ge), Si();
  }
  function Si() {
    r.pair ? (Ft(["", ""], { source: "clear" }), Ht(["", ""], { source: "clear" })) : (Ft("", { source: "clear" }), Ht("", { source: "clear" }));
  }
  function Fe(ge) {
    const { onMousedown: dt } = r;
    dt && dt(ge);
    const { tagName: Bt } = ge.target;
    if (Bt !== "INPUT" && Bt !== "TEXTAREA") {
      if (r.resizable) {
        const { value: Er } = m;
        if (Er) {
          const { left: $r, top: gt, width: cr, height: lr } = Er.getBoundingClientRect(), ni = 14;
          if ($r + cr - ni < ge.clientX && ge.clientX < $r + cr && gt + lr - ni < ge.clientY && ge.clientY < gt + lr) return;
        }
      }
      ge.preventDefault(), Se.value || $e();
    }
  }
  function Z() {
    var ge;
    fe.value = true, r.type === "textarea" && ((ge = O.value) === null || ge === void 0 || ge.handleMouseEnterWrapper());
  }
  function H() {
    var ge;
    fe.value = false, r.type === "textarea" && ((ge = O.value) === null || ge === void 0 || ge.handleMouseLeaveWrapper());
  }
  function ne() {
    re.value || wt.value === "click" && (at.value = !at.value);
  }
  function xe(ge) {
    if (re.value) return;
    ge.preventDefault();
    const dt = (Er) => {
      Er.preventDefault(), Hn("mouseup", document, dt);
    };
    if (En("mouseup", document, dt), wt.value !== "mousedown") return;
    at.value = true;
    const Bt = () => {
      at.value = false, Hn("mouseup", document, Bt);
    };
    En("mouseup", document, Bt);
  }
  function ke(ge) {
    r.onKeyup && Ot(r.onKeyup, ge);
  }
  function De(ge) {
    switch (r.onKeydown && Ot(r.onKeydown, ge), ge.key) {
      case "Escape":
        ve();
        break;
      case "Enter":
        de(ge);
        break;
    }
  }
  function de(ge) {
    var dt, Bt;
    if (r.passivelyActivated) {
      const { value: Er } = he;
      if (Er) {
        r.internalDeactivateOnEnter && ve();
        return;
      }
      ge.preventDefault(), r.type === "textarea" ? (dt = s.value) === null || dt === void 0 || dt.focus() : (Bt = M.value) === null || Bt === void 0 || Bt.focus();
    }
  }
  function ve() {
    r.passivelyActivated && (he.value = false, Vn(() => {
      var ge;
      (ge = m.value) === null || ge === void 0 || ge.focus();
    }));
  }
  function $e() {
    var ge, dt, Bt;
    re.value || (r.passivelyActivated ? (ge = m.value) === null || ge === void 0 || ge.focus() : ((dt = s.value) === null || dt === void 0 || dt.focus(), (Bt = M.value) === null || Bt === void 0 || Bt.focus()));
  }
  function it() {
    var ge;
    !((ge = m.value) === null || ge === void 0) && ge.contains(document.activeElement) && document.activeElement.blur();
  }
  function Xe() {
    var ge, dt;
    (ge = s.value) === null || ge === void 0 || ge.select(), (dt = M.value) === null || dt === void 0 || dt.select();
  }
  function xt() {
    re.value || (s.value ? s.value.focus() : M.value && M.value.focus());
  }
  function Te() {
    const { value: ge } = m;
    (ge == null ? void 0 : ge.contains(document.activeElement)) && ge !== document.activeElement && ve();
  }
  function $t(ge) {
    if (r.type === "textarea") {
      const { value: dt } = s;
      dt == null ? void 0 : dt.scrollTo(ge);
    } else {
      const { value: dt } = M;
      dt == null ? void 0 : dt.scrollTo(ge);
    }
  }
  function er(ge) {
    const { type: dt, pair: Bt, autosize: Er } = r;
    if (!Bt && Er) if (dt === "textarea") {
      const { value: $r } = C;
      $r && ($r.textContent = `${ge ?? ""}\r
`);
    } else {
      const { value: $r } = T;
      $r && (ge ? $r.textContent = ge : $r.innerHTML = "&nbsp;");
    }
  }
  function Nt() {
    yt();
  }
  const ur = Ae({ top: "0" });
  function Br(ge) {
    var dt;
    const { scrollTop: Bt } = ge.target;
    ur.value.top = `${-Bt}px`, (dt = O.value) === null || dt === void 0 || dt.syncUnifiedContainer();
  }
  let Kr = null;
  po(() => {
    const { autosize: ge, type: dt } = r;
    ge && dt === "textarea" ? Kr = ar(K, (Bt) => {
      !Array.isArray(Bt) && Bt !== be && er(Bt);
    }) : Kr == null ? void 0 : Kr();
  });
  let Jr = null;
  po(() => {
    r.type === "textarea" ? Jr = ar(K, (ge) => {
      var dt;
      !Array.isArray(ge) && ge !== be && ((dt = O.value) === null || dt === void 0 || dt.syncUnifiedContainer());
    }) : Jr == null ? void 0 : Jr();
  }), Yr(xb, { mergedValueRef: K, maxlengthRef: nt, mergedClsPrefixRef: i, countGraphemesRef: Dt(r, "countGraphemes") });
  const ii = { wrapperElRef: m, inputElRef: M, textareaElRef: s, isCompositing: oe, clear: Si, focus: $e, blur: it, select: Xe, deactivate: Te, activate: xt, scrollTo: $t }, gr = Rn("Input", f, i), vr = ze(() => {
    const { value: ge } = ee, { common: { cubicBezierEaseInOut: dt }, self: { color: Bt, borderRadius: Er, textColor: $r, caretColor: gt, caretColorError: cr, caretColorWarning: lr, textDecorationColor: ni, border: fn, borderDisabled: tn, borderHover: dr, borderFocus: Yo, placeholderColor: qn, placeholderColorDisabled: Ko, lineHeightTextarea: kn, colorDisabled: vo, colorFocus: Zr, textColorDisabled: Jn, boxShadowFocus: rn, iconSize: Ur, colorFocusWarning: Rl, boxShadowFocusWarning: ba, borderWarning: Ps, borderFocusWarning: _o, borderHoverWarning: yo, colorFocusError: Ts, boxShadowFocusError: Al, borderError: Dl, borderFocusError: Jo, borderHoverError: zl, clearSize: dc, clearColor: hc, clearColorHover: fc, clearColorPressed: Is, iconColor: Qo, iconColorDisabled: Ms, suffixTextColor: Es, countTextColor: ea, countTextColorDisabled: Rs, iconColorHover: As, iconColorPressed: pc, loadingColor: ta, loadingColorError: xa, loadingColorWarning: Dn, fontWeight: yr, [jt("padding", ge)]: Ao, [jt("fontSize", ge)]: bo, [jt("height", ge)]: Qn } } = g.value, { left: Do, right: br } = To(Ao);
    return { "--n-bezier": dt, "--n-count-text-color": ea, "--n-count-text-color-disabled": Rs, "--n-color": Bt, "--n-font-size": bo, "--n-font-weight": yr, "--n-border-radius": Er, "--n-height": Qn, "--n-padding-left": Do, "--n-padding-right": br, "--n-text-color": $r, "--n-caret-color": gt, "--n-text-decoration-color": ni, "--n-border": fn, "--n-border-disabled": tn, "--n-border-hover": dr, "--n-border-focus": Yo, "--n-placeholder-color": qn, "--n-placeholder-color-disabled": Ko, "--n-icon-size": Ur, "--n-line-height-textarea": kn, "--n-color-disabled": vo, "--n-color-focus": Zr, "--n-text-color-disabled": Jn, "--n-box-shadow-focus": rn, "--n-loading-color": ta, "--n-caret-color-warning": lr, "--n-color-focus-warning": Rl, "--n-box-shadow-focus-warning": ba, "--n-border-warning": Ps, "--n-border-focus-warning": _o, "--n-border-hover-warning": yo, "--n-loading-color-warning": Dn, "--n-caret-color-error": cr, "--n-color-focus-error": Ts, "--n-box-shadow-focus-error": Al, "--n-border-error": Dl, "--n-border-focus-error": Jo, "--n-border-hover-error": zl, "--n-loading-color-error": xa, "--n-clear-color": hc, "--n-clear-size": dc, "--n-clear-color-hover": fc, "--n-clear-color-pressed": Is, "--n-icon-color": Qo, "--n-icon-color-hover": As, "--n-icon-color-pressed": pc, "--n-icon-color-disabled": Ms, "--n-suffix-text-color": Es };
  }), Wr = d ? mi("input", ze(() => {
    const { value: ge } = ee;
    return ge[0];
  }), vr, r) : void 0;
  return Object.assign(Object.assign({}, ii), { wrapperElRef: m, inputElRef: M, inputMirrorElRef: T, inputEl2Ref: z, textareaElRef: s, textareaMirrorElRef: C, textareaScrollbarInstRef: O, rtlEnabled: gr, uncontrolledValue: X, mergedValue: K, passwordVisible: at, mergedPlaceholder: je, showPlaceholder1: Ve, showPlaceholder2: Ke, mergedFocus: lt, isComposing: oe, activated: he, showClearButton: vt, mergedSize: ee, mergedDisabled: re, textDecorationStyle: et, mergedClsPrefix: i, mergedBordered: l, mergedShowPasswordOn: wt, placeholderStyle: ur, mergedStatus: J, textAreaScrollContainerWidth: ht, handleTextAreaScroll: Br, handleCompositionStart: wr, handleCompositionEnd: Ct, handleInput: Ee, handleInputBlur: Le, handleInputFocus: Ye, handleWrapperBlur: ft, handleWrapperFocus: bt, handleMouseEnter: Z, handleMouseLeave: H, handleMouseDown: Fe, handleChange: mt, handleClick: Zt, handleClear: ri, handlePasswordToggleClick: ne, handlePasswordToggleMousedown: xe, handleWrapperKeydown: De, handleWrapperKeyup: ke, handleTextAreaMirrorResize: Nt, getTextareaScrollContainer: () => s.value, mergedTheme: g, cssVars: d ? void 0 : vr, themeClass: Wr == null ? void 0 : Wr.themeClass, onRender: Wr == null ? void 0 : Wr.onRender });
}, render() {
  var r, i, l, d, f, g, m;
  const { mergedClsPrefix: s, mergedStatus: C, themeClass: T, type: M, countGraphemes: z, onRender: L } = this, A = this.$slots;
  return L == null ? void 0 : L(), F("div", { ref: "wrapperElRef", class: [`${s}-input`, T, C && `${s}-input--${C}-status`, { [`${s}-input--rtl`]: this.rtlEnabled, [`${s}-input--disabled`]: this.mergedDisabled, [`${s}-input--textarea`]: M === "textarea", [`${s}-input--resizable`]: this.resizable && !this.autosize, [`${s}-input--autosize`]: this.autosize, [`${s}-input--round`]: this.round && M !== "textarea", [`${s}-input--pair`]: this.pair, [`${s}-input--focus`]: this.mergedFocus, [`${s}-input--stateful`]: this.stateful }], style: this.cssVars, tabindex: !this.mergedDisabled && this.passivelyActivated && !this.activated ? 0 : void 0, onFocus: this.handleWrapperFocus, onBlur: this.handleWrapperBlur, onClick: this.handleClick, onMousedown: this.handleMouseDown, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd, onKeyup: this.handleWrapperKeyup, onKeydown: this.handleWrapperKeydown }, F("div", { class: `${s}-input-wrapper` }, Ci(A.prefix, (O) => O && F("div", { class: `${s}-input__prefix` }, O)), M === "textarea" ? F(th, { ref: "textareaScrollbarInstRef", class: `${s}-input__textarea`, container: this.getTextareaScrollContainer, theme: (i = (r = this.theme) === null || r === void 0 ? void 0 : r.peers) === null || i === void 0 ? void 0 : i.Scrollbar, themeOverrides: (d = (l = this.themeOverrides) === null || l === void 0 ? void 0 : l.peers) === null || d === void 0 ? void 0 : d.Scrollbar, triggerDisplayManually: true, useUnifiedContainer: true, internalHoistYRail: true }, { default: () => {
    var O, V;
    const { textAreaScrollContainerWidth: X } = this, W = { width: this.autosize && X && `${X}px` };
    return F(Gr, null, F("textarea", Object.assign({}, this.inputProps, { ref: "textareaElRef", class: [`${s}-input__textarea-el`, (O = this.inputProps) === null || O === void 0 ? void 0 : O.class], autofocus: this.autofocus, rows: Number(this.rows), placeholder: this.placeholder, value: this.mergedValue, disabled: this.mergedDisabled, maxlength: z ? void 0 : this.maxlength, minlength: z ? void 0 : this.minlength, readonly: this.readonly, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, style: [this.textDecorationStyle[0], (V = this.inputProps) === null || V === void 0 ? void 0 : V.style, W], onBlur: this.handleInputBlur, onFocus: (K) => {
      this.handleInputFocus(K, 2);
    }, onInput: this.handleInput, onChange: this.handleChange, onScroll: this.handleTextAreaScroll })), this.showPlaceholder1 ? F("div", { class: `${s}-input__placeholder`, style: [this.placeholderStyle, W], key: "placeholder" }, this.mergedPlaceholder[0]) : null, this.autosize ? F(xl, { onResize: this.handleTextAreaMirrorResize }, { default: () => F("div", { ref: "textareaMirrorElRef", class: `${s}-input__textarea-mirror`, key: "mirror" }) }) : null);
  } }) : F("div", { class: `${s}-input__input` }, F("input", Object.assign({ type: M === "password" && this.mergedShowPasswordOn && this.passwordVisible ? "text" : M }, this.inputProps, { ref: "inputElRef", class: [`${s}-input__input-el`, (f = this.inputProps) === null || f === void 0 ? void 0 : f.class], style: [this.textDecorationStyle[0], (g = this.inputProps) === null || g === void 0 ? void 0 : g.style], tabindex: this.passivelyActivated && !this.activated ? -1 : (m = this.inputProps) === null || m === void 0 ? void 0 : m.tabindex, placeholder: this.mergedPlaceholder[0], disabled: this.mergedDisabled, maxlength: z ? void 0 : this.maxlength, minlength: z ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[0] : this.mergedValue, readonly: this.readonly, autofocus: this.autofocus, size: this.attrSize, onBlur: this.handleInputBlur, onFocus: (O) => {
    this.handleInputFocus(O, 0);
  }, onInput: (O) => {
    this.handleInput(O, 0);
  }, onChange: (O) => {
    this.handleChange(O, 0);
  } })), this.showPlaceholder1 ? F("div", { class: `${s}-input__placeholder` }, F("span", null, this.mergedPlaceholder[0])) : null, this.autosize ? F("div", { class: `${s}-input__input-mirror`, key: "mirror", ref: "inputMirrorElRef" }, "\xA0") : null), !this.pair && Ci(A.suffix, (O) => O || this.clearable || this.showCount || this.mergedShowPasswordOn || this.loading !== void 0 ? F("div", { class: `${s}-input__suffix` }, [Ci(A["clear-icon-placeholder"], (V) => (this.clearable || V) && F(_g, { clsPrefix: s, show: this.showClearButton, onClear: this.handleClear }, { placeholder: () => V, icon: () => {
    var X, W;
    return (W = (X = this.$slots)["clear-icon"]) === null || W === void 0 ? void 0 : W.call(X);
  } })), this.internalLoadingBeforeSuffix ? null : O, this.loading !== void 0 ? F(yb, { clsPrefix: s, loading: this.loading, showArrow: false, showClear: false, style: this.cssVars }) : null, this.internalLoadingBeforeSuffix ? O : null, this.showCount && this.type !== "textarea" ? F(u_, null, { default: (V) => {
    var X;
    const { renderCount: W } = this;
    return W ? W(V) : (X = A.count) === null || X === void 0 ? void 0 : X.call(A, V);
  } }) : null, this.mergedShowPasswordOn && this.type === "password" ? F("div", { class: `${s}-input__eye`, onMousedown: this.handlePasswordToggleMousedown, onClick: this.handlePasswordToggleClick }, this.passwordVisible ? Un(A["password-visible-icon"], () => [F(Nr, { clsPrefix: s }, { default: () => F(vb, null) })]) : Un(A["password-invisible-icon"], () => [F(Nr, { clsPrefix: s }, { default: () => F(HS, null) })])) : null]) : null)), this.pair ? F("span", { class: `${s}-input__separator` }, Un(A.separator, () => [this.separator])) : null, this.pair ? F("div", { class: `${s}-input-wrapper` }, F("div", { class: `${s}-input__input` }, F("input", { ref: "inputEl2Ref", type: this.type, class: `${s}-input__input-el`, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, placeholder: this.mergedPlaceholder[1], disabled: this.mergedDisabled, maxlength: z ? void 0 : this.maxlength, minlength: z ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[1] : void 0, readonly: this.readonly, style: this.textDecorationStyle[1], onBlur: this.handleInputBlur, onFocus: (O) => {
    this.handleInputFocus(O, 1);
  }, onInput: (O) => {
    this.handleInput(O, 1);
  }, onChange: (O) => {
    this.handleChange(O, 1);
  } }), this.showPlaceholder2 ? F("div", { class: `${s}-input__placeholder` }, F("span", null, this.mergedPlaceholder[1])) : null), Ci(A.suffix, (O) => (this.clearable || O) && F("div", { class: `${s}-input__suffix` }, [this.clearable && F(_g, { clsPrefix: s, show: this.showClearButton, onClear: this.handleClear }, { icon: () => {
    var V;
    return (V = A["clear-icon"]) === null || V === void 0 ? void 0 : V.call(A);
  }, placeholder: () => {
    var V;
    return (V = A["clear-icon-placeholder"]) === null || V === void 0 ? void 0 : V.call(A);
  } }), O]))) : null, this.mergedBordered ? F("div", { class: `${s}-input__border` }) : null, this.mergedBordered ? F("div", { class: `${s}-input__state-border` }) : null, this.showCount && M === "textarea" ? F(u_, null, { default: (O) => {
    var V;
    const { renderCount: X } = this;
    return X ? X(O) : (V = A.count) === null || V === void 0 ? void 0 : V.call(A, O);
  } }) : null);
} }), Mk = ue("input-group", `
 display: inline-flex;
 width: 100%;
 flex-wrap: nowrap;
 vertical-align: bottom;
`, [Ge(">", [ue("input", [Ge("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), Ge("&:not(:first-child)", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 margin-left: -1px!important;
 `)]), ue("button", [Ge("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `, [Re("state-border, border", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `)]), Ge("&:not(:first-child)", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `, [Re("state-border, border", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `)])]), Ge("*", [Ge("&:not(:last-child)", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `, [Ge(">", [ue("input", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), ue("base-selection", [ue("base-selection-label", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), ue("base-selection-tags", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), Re("box-shadow, border, state-border", `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `)])])]), Ge("&:not(:first-child)", `
 margin-left: -1px!important;
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `, [Ge(">", [ue("input", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), ue("base-selection", [ue("base-selection-label", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), ue("base-selection-tags", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), Re("box-shadow, border, state-border", `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `)])])])])])]), Ek = {}, Rk = st({ name: "InputGroup", props: Ek, setup(r) {
  const { mergedClsPrefixRef: i } = Tr(r);
  return ac("-input-group", Mk, i), { mergedClsPrefix: i };
}, render() {
  const { mergedClsPrefix: r } = this;
  return F("div", { class: `${r}-input-group` }, this.$slots);
} });
function Zf(r) {
  return r.type === "group";
}
function wb(r) {
  return r.type === "ignored";
}
function Lm(r, i) {
  try {
    return !!(1 + i.toString().toLowerCase().indexOf(r.trim().toLowerCase()));
  } catch {
    return false;
  }
}
function Ak(r, i) {
  return { getIsGroup: Zf, getIgnored: wb, getKey(d) {
    return Zf(d) ? d.name || d.key || "key-required" : d[r];
  }, getChildren(d) {
    return d[i];
  } };
}
function Dk(r, i, l, d) {
  if (!i) return r;
  function f(g) {
    if (!Array.isArray(g)) return [];
    const m = [];
    for (const s of g) if (Zf(s)) {
      const C = f(s[d]);
      C.length && m.push(Object.assign({}, s, { [d]: C }));
    } else {
      if (wb(s)) continue;
      i(l, s) && m.push(s);
    }
    return m;
  }
  return f(r);
}
function zk(r, i, l) {
  const d = /* @__PURE__ */ new Map();
  return r.forEach((f) => {
    Zf(f) ? f[l].forEach((g) => {
      d.set(g[i], g);
    }) : d.set(f[i], f);
  }), d;
}
const Fk = sp && "loading" in document.createElement("img");
function Lk(r = {}) {
  var i;
  const { root: l = null } = r;
  return { hash: `${r.rootMargin || "0px 0px 0px 0px"}-${Array.isArray(r.threshold) ? r.threshold.join(",") : (i = r.threshold) !== null && i !== void 0 ? i : "0"}`, options: Object.assign(Object.assign({}, r), { root: (typeof l == "string" ? document.querySelector(l) : l) || document.documentElement }) };
}
const Bm = /* @__PURE__ */ new WeakMap(), Om = /* @__PURE__ */ new WeakMap(), $m = /* @__PURE__ */ new WeakMap(), Bk = (r, i, l) => {
  if (!r) return () => {
  };
  const d = Lk(i), { root: f } = d.options;
  let g;
  const m = Bm.get(f);
  m ? g = m : (g = /* @__PURE__ */ new Map(), Bm.set(f, g));
  let s, C;
  g.has(d.hash) ? (C = g.get(d.hash), C[1].has(r) || (s = C[0], C[1].add(r), s.observe(r))) : (s = new IntersectionObserver((z) => {
    z.forEach((L) => {
      if (L.isIntersecting) {
        const A = Om.get(L.target), O = $m.get(L.target);
        A && A(), O && (O.value = true);
      }
    });
  }, d.options), s.observe(r), C = [s, /* @__PURE__ */ new Set([r])], g.set(d.hash, C));
  let T = false;
  const M = () => {
    T || (Om.delete(r), $m.delete(r), T = true, C[1].has(r) && (C[0].unobserve(r), C[1].delete(r)), C[1].size <= 0 && g.delete(d.hash), g.size || Bm.delete(f));
  };
  return Om.set(r, M), $m.set(r, l), M;
}, Ti = "0!important", Cb = "-1px!important";
function ju(r) {
  return Ue(`${r}-type`, [Ge("& +", [ue("button", {}, [Ue(`${r}-type`, [Re("border", { borderLeftWidth: Ti }), Re("state-border", { left: Cb })])])])]);
}
function Nu(r) {
  return Ue(`${r}-type`, [Ge("& +", [ue("button", [Ue(`${r}-type`, [Re("border", { borderTopWidth: Ti }), Re("state-border", { top: Cb })])])])]);
}
const Ok = ue("button-group", `
 flex-wrap: nowrap;
 display: inline-flex;
 position: relative;
`, [pi("vertical", { flexDirection: "row" }, [pi("rtl", [ue("button", [Ge("&:first-child:not(:last-child)", `
 margin-right: ${Ti};
 border-top-right-radius: ${Ti};
 border-bottom-right-radius: ${Ti};
 `), Ge("&:last-child:not(:first-child)", `
 margin-left: ${Ti};
 border-top-left-radius: ${Ti};
 border-bottom-left-radius: ${Ti};
 `), Ge("&:not(:first-child):not(:last-child)", `
 margin-left: ${Ti};
 margin-right: ${Ti};
 border-radius: ${Ti};
 `), ju("default"), Ue("ghost", [ju("primary"), ju("info"), ju("success"), ju("warning"), ju("error")])])])]), Ue("vertical", { flexDirection: "column" }, [ue("button", [Ge("&:first-child:not(:last-child)", `
 margin-bottom: ${Ti};
 margin-left: ${Ti};
 margin-right: ${Ti};
 border-bottom-left-radius: ${Ti};
 border-bottom-right-radius: ${Ti};
 `), Ge("&:last-child:not(:first-child)", `
 margin-top: ${Ti};
 margin-left: ${Ti};
 margin-right: ${Ti};
 border-top-left-radius: ${Ti};
 border-top-right-radius: ${Ti};
 `), Ge("&:not(:first-child):not(:last-child)", `
 margin: ${Ti};
 border-radius: ${Ti};
 `), Nu("default"), Ue("ghost", [Nu("primary"), Nu("info"), Nu("success"), Nu("warning"), Nu("error")])])])]), $k = { size: { type: String, default: void 0 }, vertical: Boolean }, jk = st({ name: "ButtonGroup", props: $k, setup(r) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Tr(r);
  return ac("-button-group", Ok, i), Yr(g2, r), { rtlEnabled: Rn("ButtonGroup", l, i), mergedClsPrefix: i };
}, render() {
  const { mergedClsPrefix: r } = this;
  return F("div", { class: [`${r}-button-group`, this.rtlEnabled && `${r}-button-group--rtl`, this.vertical && `${r}-button-group--vertical`], role: "group" }, this.$slots);
} }), Nk = An("n-checkbox-group"), Vk = () => F("svg", { viewBox: "0 0 64 64", class: "check-icon" }, F("path", { d: "M50.42,16.76L22.34,39.45l-8.1-11.46c-1.12-1.58-3.3-1.96-4.88-0.84c-1.58,1.12-1.95,3.3-0.84,4.88l10.26,14.51  c0.56,0.79,1.42,1.31,2.38,1.45c0.16,0.02,0.32,0.03,0.48,0.03c0.8,0,1.57-0.27,2.2-0.78l30.99-25.03c1.5-1.21,1.74-3.42,0.52-4.92  C54.13,15.78,51.93,15.55,50.42,16.76z" })), Uk = () => F("svg", { viewBox: "0 0 100 100", class: "line-icon" }, F("path", { d: "M80.2,55.5H21.4c-2.8,0-5.1-2.5-5.1-5.5l0,0c0-3,2.3-5.5,5.1-5.5h58.7c2.8,0,5.1,2.5,5.1,5.5l0,0C85.2,53.1,82.9,55.5,80.2,55.5z" })), qk = Ge([ue("checkbox", `
 font-size: var(--n-font-size);
 outline: none;
 cursor: pointer;
 display: inline-flex;
 flex-wrap: nowrap;
 align-items: flex-start;
 word-break: break-word;
 line-height: var(--n-size);
 --n-merged-color-table: var(--n-color-table);
 `, [Ue("show-label", "line-height: var(--n-label-line-height);"), Ge("&:hover", [ue("checkbox-box", [Re("border", "border: var(--n-border-checked);")])]), Ge("&:focus:not(:active)", [ue("checkbox-box", [Re("border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), Ue("inside-table", [ue("checkbox-box", `
 background-color: var(--n-merged-color-table);
 `)]), Ue("checked", [ue("checkbox-box", `
 background-color: var(--n-color-checked);
 `, [ue("checkbox-icon", [Ge(".check-icon", `
 opacity: 1;
 transform: scale(1);
 `)])])]), Ue("indeterminate", [ue("checkbox-box", [ue("checkbox-icon", [Ge(".check-icon", `
 opacity: 0;
 transform: scale(.5);
 `), Ge(".line-icon", `
 opacity: 1;
 transform: scale(1);
 `)])])]), Ue("checked, indeterminate", [Ge("&:focus:not(:active)", [ue("checkbox-box", [Re("border", `
 border: var(--n-border-checked);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), ue("checkbox-box", `
 background-color: var(--n-color-checked);
 border-left: 0;
 border-top: 0;
 `, [Re("border", { border: "var(--n-border-checked)" })])]), Ue("disabled", { cursor: "not-allowed" }, [Ue("checked", [ue("checkbox-box", `
 background-color: var(--n-color-disabled-checked);
 `, [Re("border", { border: "var(--n-border-disabled-checked)" }), ue("checkbox-icon", [Ge(".check-icon, .line-icon", { fill: "var(--n-check-mark-color-disabled-checked)" })])])]), ue("checkbox-box", `
 background-color: var(--n-color-disabled);
 `, [Re("border", `
 border: var(--n-border-disabled);
 `), ue("checkbox-icon", [Ge(".check-icon, .line-icon", `
 fill: var(--n-check-mark-color-disabled);
 `)])]), Re("label", `
 color: var(--n-text-color-disabled);
 `)]), ue("checkbox-box-wrapper", `
 position: relative;
 width: var(--n-size);
 flex-shrink: 0;
 flex-grow: 0;
 user-select: none;
 -webkit-user-select: none;
 `), ue("checkbox-box", `
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 height: var(--n-size);
 width: var(--n-size);
 display: inline-block;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color 0.3s var(--n-bezier);
 `, [Re("border", `
 transition:
 border-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border: var(--n-border);
 `), ue("checkbox-icon", `
 display: flex;
 align-items: center;
 justify-content: center;
 position: absolute;
 left: 1px;
 right: 1px;
 top: 1px;
 bottom: 1px;
 `, [Ge(".check-icon, .line-icon", `
 width: 100%;
 fill: var(--n-check-mark-color);
 opacity: 0;
 transform: scale(0.5);
 transform-origin: center;
 transition:
 fill 0.3s var(--n-bezier),
 transform 0.3s var(--n-bezier),
 opacity 0.3s var(--n-bezier),
 border-color 0.3s var(--n-bezier);
 `), Nd({ left: "1px", top: "1px" })])]), Re("label", `
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 user-select: none;
 -webkit-user-select: none;
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 `, [Ge("&:empty", { display: "none" })])]), Ey(ue("checkbox", `
 --n-merged-color-table: var(--n-color-table-modal);
 `)), Ry(ue("checkbox", `
 --n-merged-color-table: var(--n-color-table-popover);
 `))]), Gk = Object.assign(Object.assign({}, Kt.props), { size: String, checked: { type: [Boolean, String, Number], default: void 0 }, defaultChecked: { type: [Boolean, String, Number], default: false }, value: [String, Number], disabled: { type: Boolean, default: void 0 }, indeterminate: Boolean, label: String, focusable: { type: Boolean, default: true }, checkedValue: { type: [Boolean, String, Number], default: true }, uncheckedValue: { type: [Boolean, String, Number], default: false }, "onUpdate:checked": [Function, Array], onUpdateChecked: [Function, Array], privateInsideTable: Boolean, onChange: [Function, Array] }), Wk = st({ name: "Checkbox", props: Gk, setup(r) {
  const i = fr(Nk, null), l = Ae(null), { mergedClsPrefixRef: d, inlineThemeDisabled: f, mergedRtlRef: g } = Tr(r), m = Ae(r.defaultChecked), s = Dt(r, "checked"), C = Zi(s, m), T = _i(() => {
    if (i) {
      const J = i.valueSetRef.value;
      return J && r.value !== void 0 ? J.has(r.value) : false;
    } else return C.value === r.checkedValue;
  }), M = va(r, { mergedSize(J) {
    const { size: Se } = r;
    if (Se !== void 0) return Se;
    if (i) {
      const { value: fe } = i.mergedSizeRef;
      if (fe !== void 0) return fe;
    }
    if (J) {
      const { mergedSize: fe } = J;
      if (fe !== void 0) return fe.value;
    }
    return "medium";
  }, mergedDisabled(J) {
    const { disabled: Se } = r;
    if (Se !== void 0) return Se;
    if (i) {
      if (i.disabledRef.value) return true;
      const { maxRef: { value: fe }, checkedCountRef: oe } = i;
      if (fe !== void 0 && oe.value >= fe && !T.value) return true;
      const { minRef: { value: he } } = i;
      if (he !== void 0 && oe.value <= he && T.value) return true;
    }
    return J ? J.disabled.value : false;
  } }), { mergedDisabledRef: z, mergedSizeRef: L } = M, A = Kt("Checkbox", "-checkbox", qk, v2, r, d);
  function O(J) {
    if (i && r.value !== void 0) i.toggleCheckbox(!T.value, r.value);
    else {
      const { onChange: Se, "onUpdate:checked": fe, onUpdateChecked: oe } = r, { nTriggerFormInput: he, nTriggerFormChange: be } = M, je = T.value ? r.uncheckedValue : r.checkedValue;
      fe && Ot(fe, je, J), oe && Ot(oe, je, J), Se && Ot(Se, je, J), he(), be(), m.value = je;
    }
  }
  function V(J) {
    z.value || O(J);
  }
  function X(J) {
    if (!z.value) switch (J.key) {
      case " ":
      case "Enter":
        O(J);
    }
  }
  function W(J) {
    switch (J.key) {
      case " ":
        J.preventDefault();
    }
  }
  const K = { focus: () => {
    var J;
    (J = l.value) === null || J === void 0 || J.focus();
  }, blur: () => {
    var J;
    (J = l.value) === null || J === void 0 || J.blur();
  } }, ie = Rn("Checkbox", g, d), ee = ze(() => {
    const { value: J } = L, { common: { cubicBezierEaseInOut: Se }, self: { borderRadius: fe, color: oe, colorChecked: he, colorDisabled: be, colorTableHeader: je, colorTableHeaderModal: Ve, colorTableHeaderPopover: Ke, checkMarkColor: lt, checkMarkColorDisabled: vt, border: wt, borderFocus: at, borderDisabled: et, borderChecked: ht, boxShadowFocus: yt, textColor: nt, textColorDisabled: ut, checkMarkColorDisabledChecked: Ft, colorDisabledChecked: Ht, borderDisabledChecked: zt, labelPadding: pr, labelLineHeight: Qt, labelFontWeight: tr, [jt("fontSize", J)]: xr, [jt("size", J)]: Mr } } = A.value;
    return { "--n-label-line-height": Qt, "--n-label-font-weight": tr, "--n-size": Mr, "--n-bezier": Se, "--n-border-radius": fe, "--n-border": wt, "--n-border-checked": ht, "--n-border-focus": at, "--n-border-disabled": et, "--n-border-disabled-checked": zt, "--n-box-shadow-focus": yt, "--n-color": oe, "--n-color-checked": he, "--n-color-table": je, "--n-color-table-modal": Ve, "--n-color-table-popover": Ke, "--n-color-disabled": be, "--n-color-disabled-checked": Ht, "--n-text-color": nt, "--n-text-color-disabled": ut, "--n-check-mark-color": lt, "--n-check-mark-color-disabled": vt, "--n-check-mark-color-disabled-checked": Ft, "--n-font-size": xr, "--n-label-padding": pr };
  }), re = f ? mi("checkbox", ze(() => L.value[0]), ee, r) : void 0;
  return Object.assign(M, K, { rtlEnabled: ie, selfRef: l, mergedClsPrefix: d, mergedDisabled: z, renderedChecked: T, mergedTheme: A, labelId: Ml(), handleClick: V, handleKeyUp: X, handleKeyDown: W, cssVars: f ? void 0 : ee, themeClass: re == null ? void 0 : re.themeClass, onRender: re == null ? void 0 : re.onRender });
}, render() {
  var r;
  const { $slots: i, renderedChecked: l, mergedDisabled: d, indeterminate: f, privateInsideTable: g, cssVars: m, labelId: s, label: C, mergedClsPrefix: T, focusable: M, handleKeyUp: z, handleKeyDown: L, handleClick: A } = this;
  (r = this.onRender) === null || r === void 0 || r.call(this);
  const O = Ci(i.default, (V) => C || V ? F("span", { class: `${T}-checkbox__label`, id: s }, C || V) : null);
  return F("div", { ref: "selfRef", class: [`${T}-checkbox`, this.themeClass, this.rtlEnabled && `${T}-checkbox--rtl`, l && `${T}-checkbox--checked`, d && `${T}-checkbox--disabled`, f && `${T}-checkbox--indeterminate`, g && `${T}-checkbox--inside-table`, O && `${T}-checkbox--show-label`], tabindex: d || !M ? void 0 : 0, role: "checkbox", "aria-checked": f ? "mixed" : l, "aria-labelledby": s, style: m, onKeyup: z, onKeydown: L, onClick: A, onMousedown: () => {
    En("selectstart", window, (V) => {
      V.preventDefault();
    }, { once: true });
  } }, F("div", { class: `${T}-checkbox-box-wrapper` }, "\xA0", F("div", { class: `${T}-checkbox-box` }, F(tp, null, { default: () => this.indeterminate ? F("div", { key: "indeterminate", class: `${T}-checkbox-icon` }, Uk()) : F("div", { key: "check", class: `${T}-checkbox-icon` }, Vk()) }), F("div", { class: `${T}-checkbox-box__border` }))), O);
} }), Zk = ue("collapse", "width: 100%;", [ue("collapse-item", `
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 margin: var(--n-item-margin);
 `, [Ue("disabled", [Re("header", "cursor: not-allowed;", [Re("header-main", `
 color: var(--n-title-text-color-disabled);
 `), ue("collapse-item-arrow", `
 color: var(--n-arrow-color-disabled);
 `)])]), ue("collapse-item", "margin-left: 32px;"), Ge("&:first-child", "margin-top: 0;"), Ge("&:first-child >", [Re("header", "padding-top: 0;")]), Ue("left-arrow-placement", [Re("header", [ue("collapse-item-arrow", "margin-right: 4px;")])]), Ue("right-arrow-placement", [Re("header", [ue("collapse-item-arrow", "margin-left: 4px;")])]), Re("content-wrapper", [Re("content-inner", "padding-top: 16px;"), Vf({ duration: "0.15s" })]), Ue("active", [Re("header", [Ue("active", [ue("collapse-item-arrow", "transform: rotate(90deg);")])])]), Ge("&:not(:first-child)", "border-top: 1px solid var(--n-divider-color);"), pi("disabled", [Ue("trigger-area-main", [Re("header", [Re("header-main", "cursor: pointer;"), ue("collapse-item-arrow", "cursor: default;")])]), Ue("trigger-area-arrow", [Re("header", [ue("collapse-item-arrow", "cursor: pointer;")])]), Ue("trigger-area-extra", [Re("header", [Re("header-extra", "cursor: pointer;")])])]), Re("header", `
 font-size: var(--n-title-font-size);
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition: color .3s var(--n-bezier);
 position: relative;
 padding: var(--n-title-padding);
 color: var(--n-title-text-color);
 `, [Re("header-main", `
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 flex: 1;
 color: var(--n-title-text-color);
 `), Re("header-extra", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), ue("collapse-item-arrow", `
 display: flex;
 transition:
 transform .15s var(--n-bezier),
 color .3s var(--n-bezier);
 font-size: 18px;
 color: var(--n-arrow-color);
 `)])])]), Hk = Object.assign(Object.assign({}, Kt.props), { defaultExpandedNames: { type: [Array, String], default: null }, expandedNames: [Array, String], arrowPlacement: { type: String, default: "left" }, accordion: { type: Boolean, default: false }, displayDirective: { type: String, default: "if" }, triggerAreas: { type: Array, default: () => ["main", "extra", "arrow"] }, onItemHeaderClick: [Function, Array], "onUpdate:expandedNames": [Function, Array], onUpdateExpandedNames: [Function, Array], onExpandedNamesChange: { type: [Function, Array], validator: () => true, default: void 0 } }), Sb = An("n-collapse"), c_ = st({ name: "Collapse", props: Hk, slots: Object, setup(r, { slots: i }) {
  const { mergedClsPrefixRef: l, inlineThemeDisabled: d, mergedRtlRef: f } = Tr(r), g = Ae(r.defaultExpandedNames), m = ze(() => r.expandedNames), s = Zi(m, g), C = Kt("Collapse", "-collapse", Zk, _2, r, l);
  function T(V) {
    const { "onUpdate:expandedNames": X, onUpdateExpandedNames: W, onExpandedNamesChange: K } = r;
    W && Ot(W, V), X && Ot(X, V), K && Ot(K, V), g.value = V;
  }
  function M(V) {
    const { onItemHeaderClick: X } = r;
    X && Ot(X, V);
  }
  function z(V, X, W) {
    const { accordion: K } = r, { value: ie } = s;
    if (K) V ? (T([X]), M({ name: X, expanded: true, event: W })) : (T([]), M({ name: X, expanded: false, event: W }));
    else if (!Array.isArray(ie)) T([X]), M({ name: X, expanded: true, event: W });
    else {
      const ee = ie.slice(), re = ee.findIndex((J) => X === J);
      ~re ? (ee.splice(re, 1), T(ee), M({ name: X, expanded: false, event: W })) : (ee.push(X), T(ee), M({ name: X, expanded: true, event: W }));
    }
  }
  Yr(Sb, { props: r, mergedClsPrefixRef: l, expandedNamesRef: s, slots: i, toggleItem: z });
  const L = Rn("Collapse", f, l), A = ze(() => {
    const { common: { cubicBezierEaseInOut: V }, self: { titleFontWeight: X, dividerColor: W, titlePadding: K, titleTextColor: ie, titleTextColorDisabled: ee, textColor: re, arrowColor: J, fontSize: Se, titleFontSize: fe, arrowColorDisabled: oe, itemMargin: he } } = C.value;
    return { "--n-font-size": Se, "--n-bezier": V, "--n-text-color": re, "--n-divider-color": W, "--n-title-padding": K, "--n-title-font-size": fe, "--n-title-text-color": ie, "--n-title-text-color-disabled": ee, "--n-title-font-weight": X, "--n-arrow-color": J, "--n-arrow-color-disabled": oe, "--n-item-margin": he };
  }), O = d ? mi("collapse", void 0, A, r) : void 0;
  return { rtlEnabled: L, mergedTheme: C, mergedClsPrefix: l, cssVars: d ? void 0 : A, themeClass: O == null ? void 0 : O.themeClass, onRender: O == null ? void 0 : O.onRender };
}, render() {
  var r;
  return (r = this.onRender) === null || r === void 0 || r.call(this), F("div", { class: [`${this.mergedClsPrefix}-collapse`, this.rtlEnabled && `${this.mergedClsPrefix}-collapse--rtl`, this.themeClass], style: this.cssVars }, this.$slots);
} }), Xk = st({ name: "CollapseItemContent", props: { displayDirective: { type: String, required: true }, show: Boolean, clsPrefix: { type: String, required: true } }, setup(r) {
  return { onceTrue: y2(Dt(r, "show")) };
}, render() {
  return F(op, null, { default: () => {
    const { show: r, displayDirective: i, onceTrue: l, clsPrefix: d } = this, f = i === "show" && l, g = F("div", { class: `${d}-collapse-item__content-wrapper` }, F("div", { class: `${d}-collapse-item__content-inner` }, this.$slots));
    return f ? ma(g, [[Ka, r]]) : r ? g : null;
  } });
} }), Yk = { title: String, name: [String, Number], disabled: Boolean, displayDirective: String }, d_ = st({ name: "CollapseItem", props: Yk, setup(r) {
  const { mergedRtlRef: i } = Tr(r), l = Ml(), d = _i(() => {
    var z;
    return (z = r.name) !== null && z !== void 0 ? z : l;
  }), f = fr(Sb);
  f || Zo("collapse-item", "`n-collapse-item` must be placed inside `n-collapse`.");
  const { expandedNamesRef: g, props: m, mergedClsPrefixRef: s, slots: C } = f, T = ze(() => {
    const { value: z } = g;
    if (Array.isArray(z)) {
      const { value: L } = d;
      return !~z.findIndex((A) => A === L);
    } else if (z) {
      const { value: L } = d;
      return L !== z;
    }
    return true;
  });
  return { rtlEnabled: Rn("Collapse", i, s), collapseSlots: C, randomName: l, mergedClsPrefix: s, collapsed: T, triggerAreas: Dt(m, "triggerAreas"), mergedDisplayDirective: ze(() => {
    const { displayDirective: z } = r;
    return z || m.displayDirective;
  }), arrowPlacement: ze(() => m.arrowPlacement), handleClick(z) {
    let L = "main";
    wl(z, "arrow") && (L = "arrow"), wl(z, "extra") && (L = "extra"), m.triggerAreas.includes(L) && f && !r.disabled && f.toggleItem(T.value, d.value, z);
  } };
}, render() {
  const { collapseSlots: r, $slots: i, arrowPlacement: l, collapsed: d, mergedDisplayDirective: f, mergedClsPrefix: g, disabled: m, triggerAreas: s } = this, C = ug(i.header, { collapsed: d }, () => [this.title]), T = i["header-extra"] || r["header-extra"], M = i.arrow || r.arrow;
  return F("div", { class: [`${g}-collapse-item`, `${g}-collapse-item--${l}-arrow-placement`, m && `${g}-collapse-item--disabled`, !d && `${g}-collapse-item--active`, s.map((z) => `${g}-collapse-item--trigger-area-${z}`)] }, F("div", { class: [`${g}-collapse-item__header`, !d && `${g}-collapse-item__header--active`] }, F("div", { class: `${g}-collapse-item__header-main`, onClick: this.handleClick }, l === "right" && C, F("div", { class: `${g}-collapse-item-arrow`, key: this.rtlEnabled ? 0 : 1, "data-arrow": true }, ug(M, { collapsed: d }, () => [F(Nr, { clsPrefix: g }, { default: () => this.rtlEnabled ? F(GS, null) : F(b2, null) })])), l === "left" && C), x2(T, { collapsed: d }, (z) => F("div", { class: `${g}-collapse-item__header-extra`, onClick: this.handleClick, "data-extra": true }, z))), F(Xk, { clsPrefix: g, displayDirective: f, show: !d }, i));
} });
function Kk(r, i) {
  switch (r[0]) {
    case "hex":
      return i ? "#000000FF" : "#000000";
    case "rgb":
      return i ? "rgba(0, 0, 0, 1)" : "rgb(0, 0, 0)";
    case "hsl":
      return i ? "hsla(0, 0%, 0%, 1)" : "hsl(0, 0%, 0%)";
    case "hsv":
      return i ? "hsva(0, 0%, 0%, 1)" : "hsv(0, 0%, 0%)";
  }
  return "#000000";
}
function Gd(r) {
  return r === null ? null : /^ *#/.test(r) ? "hex" : r.includes("rgb") ? "rgb" : r.includes("hsl") ? "hsl" : r.includes("hsv") ? "hsv" : null;
}
function Jk(r, i = [255, 255, 255], l = "AA") {
  const [d, f, g, m] = qo(Ha(r));
  if (m === 1) {
    const A = xf([d, f, g]), O = xf(i);
    return (Math.max(A, O) + 0.05) / (Math.min(A, O) + 0.05) >= (l === "AA" ? 4.5 : 7);
  }
  const s = Math.round(d * m + i[0] * (1 - m)), C = Math.round(f * m + i[1] * (1 - m)), T = Math.round(g * m + i[2] * (1 - m)), M = xf([s, C, T]), z = xf(i);
  return (Math.max(M, z) + 0.05) / (Math.min(M, z) + 0.05) >= (l === "AA" ? 4.5 : 7);
}
function xf(r) {
  const [i, l, d] = r.map((f) => (f /= 255, f <= 0.03928 ? f / 12.92 : Math.pow((f + 0.055) / 1.055, 2.4)));
  return 0.2126 * i + 0.7152 * l + 0.0722 * d;
}
function Qk(r) {
  return r = Math.round(r), r >= 360 ? 359 : r < 0 ? 0 : r;
}
function eP(r) {
  return r = Math.round(r * 100) / 100, r > 1 ? 1 : r < 0 ? 0 : r;
}
const tP = { rgb: { hex(r) {
  return xs(qo(r));
}, hsl(r) {
  const [i, l, d, f] = qo(r);
  return Ha([...hg(i, l, d), f]);
}, hsv(r) {
  const [i, l, d, f] = qo(r);
  return Sl([...dg(i, l, d), f]);
} }, hex: { rgb(r) {
  return Xa(qo(r));
}, hsl(r) {
  const [i, l, d, f] = qo(r);
  return Ha([...hg(i, l, d), f]);
}, hsv(r) {
  const [i, l, d, f] = qo(r);
  return Sl([...dg(i, l, d), f]);
} }, hsl: { hex(r) {
  const [i, l, d, f] = Xu(r);
  return xs([...cg(i, l, d), f]);
}, rgb(r) {
  const [i, l, d, f] = Xu(r);
  return Xa([...cg(i, l, d), f]);
}, hsv(r) {
  const [i, l, d, f] = Xu(r);
  return Sl([...Ay(i, l, d), f]);
} }, hsv: { hex(r) {
  const [i, l, d, f] = Cl(r);
  return xs([..._s(i, l, d), f]);
}, rgb(r) {
  const [i, l, d, f] = Cl(r);
  return Xa([..._s(i, l, d), f]);
}, hsl(r) {
  const [i, l, d, f] = Cl(r);
  return Ha([...Ff(i, l, d), f]);
} } };
function kb(r, i, l) {
  return l = l || Gd(r), l ? l === i ? r : tP[l][i](r) : null;
}
const Pd = "12px", rP = 12, fl = "6px", iP = st({ name: "AlphaSlider", props: { clsPrefix: { type: String, required: true }, rgba: { type: Array, default: null }, alpha: { type: Number, default: 0 }, onUpdateAlpha: { type: Function, required: true }, onComplete: Function }, setup(r) {
  const i = Ae(null);
  function l(g) {
    !i.value || !r.rgba || (En("mousemove", document, d), En("mouseup", document, f), d(g));
  }
  function d(g) {
    const { value: m } = i;
    if (!m) return;
    const { width: s, left: C } = m.getBoundingClientRect(), T = (g.clientX - C) / (s - rP);
    r.onUpdateAlpha(eP(T));
  }
  function f() {
    var g;
    Hn("mousemove", document, d), Hn("mouseup", document, f), (g = r.onComplete) === null || g === void 0 || g.call(r);
  }
  return { railRef: i, railBackgroundImage: ze(() => {
    const { rgba: g } = r;
    return g ? `linear-gradient(to right, rgba(${g[0]}, ${g[1]}, ${g[2]}, 0) 0%, rgba(${g[0]}, ${g[1]}, ${g[2]}, 1) 100%)` : "";
  }), handleMouseDown: l };
}, render() {
  const { clsPrefix: r } = this;
  return F("div", { class: `${r}-color-picker-slider`, ref: "railRef", style: { height: Pd, borderRadius: fl }, onMousedown: this.handleMouseDown }, F("div", { style: { borderRadius: fl, position: "absolute", left: 0, right: 0, top: 0, bottom: 0, overflow: "hidden" } }, F("div", { class: `${r}-color-picker-checkboard` }), F("div", { class: `${r}-color-picker-slider__image`, style: { backgroundImage: this.railBackgroundImage } })), this.rgba && F("div", { style: { position: "absolute", left: fl, right: fl, top: 0, bottom: 0 } }, F("div", { class: `${r}-color-picker-handle`, style: { left: `calc(${this.alpha * 100}% - ${fl})`, borderRadius: fl, width: Pd, height: Pd } }, F("div", { class: `${r}-color-picker-handle__fill`, style: { backgroundColor: Xa(this.rgba), borderRadius: fl, width: Pd, height: Pd } }))));
} }), Xg = An("n-color-picker");
function nP(r) {
  return /^\d{1,3}\.?\d*$/.test(r.trim()) ? Math.max(0, Math.min(Number.parseInt(r), 255)) : false;
}
function oP(r) {
  return /^\d{1,3}\.?\d*$/.test(r.trim()) ? Math.max(0, Math.min(Number.parseInt(r), 360)) : false;
}
function aP(r) {
  return /^\d{1,3}\.?\d*$/.test(r.trim()) ? Math.max(0, Math.min(Number.parseInt(r), 100)) : false;
}
function sP(r) {
  const i = r.trim();
  return /^#[0-9a-fA-F]+$/.test(i) ? [4, 5, 7, 9].includes(i.length) : false;
}
function lP(r) {
  return /^\d{1,3}\.?\d*%$/.test(r.trim()) ? Math.max(0, Math.min(Number.parseInt(r) / 100, 100)) : false;
}
const uP = { paddingSmall: "0 4px" }, h_ = st({ name: "ColorInputUnit", props: { label: { type: String, required: true }, value: { type: [Number, String], default: null }, showAlpha: Boolean, onUpdateValue: { type: Function, required: true } }, setup(r) {
  const i = Ae(""), { themeRef: l } = fr(Xg, null);
  po(() => {
    i.value = d();
  });
  function d() {
    const { value: m } = r;
    if (m === null) return "";
    const { label: s } = r;
    return s === "HEX" ? m : s === "A" ? `${Math.floor(m * 100)}%` : String(Math.floor(m));
  }
  function f(m) {
    i.value = m;
  }
  function g(m) {
    let s, C;
    switch (r.label) {
      case "HEX":
        C = sP(m), C && r.onUpdateValue(m), i.value = d();
        break;
      case "H":
        s = oP(m), s === false ? i.value = d() : r.onUpdateValue(s);
        break;
      case "S":
      case "L":
      case "V":
        s = aP(m), s === false ? i.value = d() : r.onUpdateValue(s);
        break;
      case "A":
        s = lP(m), s === false ? i.value = d() : r.onUpdateValue(s);
        break;
      case "R":
      case "G":
      case "B":
        s = nP(m), s === false ? i.value = d() : r.onUpdateValue(s);
        break;
    }
  }
  return { mergedTheme: l, inputValue: i, handleInputChange: g, handleInputUpdateValue: f };
}, render() {
  const { mergedTheme: r } = this;
  return F(ho, { size: "small", placeholder: this.label, theme: r.peers.Input, themeOverrides: r.peerOverrides.Input, builtinThemeOverrides: uP, value: this.inputValue, onUpdateValue: this.handleInputUpdateValue, onChange: this.handleInputChange, style: this.label === "A" ? "flex-grow: 1.25;" : "" });
} }), cP = st({ name: "ColorInput", props: { clsPrefix: { type: String, required: true }, mode: { type: String, required: true }, modes: { type: Array, required: true }, showAlpha: { type: Boolean, required: true }, value: { type: String, default: null }, valueArr: { type: Array, default: null }, onUpdateValue: { type: Function, required: true }, onUpdateMode: { type: Function, required: true } }, setup(r) {
  return { handleUnitUpdateValue(i, l) {
    const { showAlpha: d } = r;
    if (r.mode === "hex") {
      r.onUpdateValue((d ? xs : zd)(l));
      return;
    }
    let f;
    switch (r.valueArr === null ? f = [0, 0, 0, 0] : f = Array.from(r.valueArr), r.mode) {
      case "hsv":
        f[i] = l, r.onUpdateValue((d ? Sl : mg)(f));
        break;
      case "rgb":
        f[i] = l, r.onUpdateValue((d ? Xa : pg)(f));
        break;
      case "hsl":
        f[i] = l, r.onUpdateValue((d ? Ha : fg)(f));
        break;
    }
  } };
}, render() {
  const { clsPrefix: r, modes: i } = this;
  return F("div", { class: `${r}-color-picker-input` }, F("div", { class: `${r}-color-picker-input__mode`, onClick: this.onUpdateMode, style: { cursor: i.length === 1 ? "" : "pointer" } }, this.mode.toUpperCase() + (this.showAlpha ? "A" : "")), F(Rk, null, { default: () => {
    const { mode: l, valueArr: d, showAlpha: f } = this;
    if (l === "hex") {
      let g = null;
      try {
        g = d === null ? null : (f ? xs : zd)(d);
      } catch {
      }
      return F(h_, { label: "HEX", showAlpha: f, value: g, onUpdateValue: (m) => {
        this.handleUnitUpdateValue(0, m);
      } });
    }
    return (l + (f ? "a" : "")).split("").map((g, m) => F(h_, { label: g.toUpperCase(), value: d === null ? null : d[m], onUpdateValue: (s) => {
      this.handleUnitUpdateValue(m, s);
    } }));
  } }));
} });
function dP(r, i) {
  if (i === "hsv") {
    const [l, d, f, g] = Cl(r);
    return Xa([..._s(l, d, f), g]);
  }
  return r;
}
function hP(r) {
  const i = document.createElement("canvas").getContext("2d");
  return i ? (i.fillStyle = r, i.fillStyle) : "#000000";
}
const fP = st({ name: "ColorPickerSwatches", props: { clsPrefix: { type: String, required: true }, mode: { type: String, required: true }, swatches: { type: Array, required: true }, onUpdateColor: { type: Function, required: true } }, setup(r) {
  const i = ze(() => r.swatches.map((g) => {
    const m = Gd(g);
    return { value: g, mode: m, legalValue: dP(g, m) };
  }));
  function l(g) {
    const { mode: m } = r;
    let { value: s, mode: C } = g;
    return C || (C = "hex", /^[a-zA-Z]+$/.test(s) ? s = hP(s) : (Uf("color-picker", `color ${s} in swatches is invalid.`), s = "#000000")), C === m ? s : kb(s, m, C);
  }
  function d(g) {
    r.onUpdateColor(l(g));
  }
  function f(g, m) {
    g.key === "Enter" && d(m);
  }
  return { parsedSwatchesRef: i, handleSwatchSelect: d, handleSwatchKeyDown: f };
}, render() {
  const { clsPrefix: r } = this;
  return F("div", { class: `${r}-color-picker-swatches` }, this.parsedSwatchesRef.map((i) => F("div", { class: `${r}-color-picker-swatch`, tabindex: 0, onClick: () => {
    this.handleSwatchSelect(i);
  }, onKeydown: (l) => {
    this.handleSwatchKeyDown(l, i);
  } }, F("div", { class: `${r}-color-picker-swatch__fill`, style: { background: i.legalValue } }))));
} }), pP = st({ name: "ColorPickerTrigger", slots: Object, props: { clsPrefix: { type: String, required: true }, value: { type: String, default: null }, hsla: { type: Array, default: null }, disabled: Boolean, onClick: Function }, setup(r) {
  const { colorPickerSlots: i, renderLabelRef: l } = fr(Xg, null);
  return () => {
    const { hsla: d, value: f, clsPrefix: g, onClick: m, disabled: s } = r, C = i.label || l.value;
    return F("div", { class: [`${g}-color-picker-trigger`, s && `${g}-color-picker-trigger--disabled`], onClick: s ? void 0 : m }, F("div", { class: `${g}-color-picker-trigger__fill` }, F("div", { class: `${g}-color-picker-checkboard` }), F("div", { style: { position: "absolute", left: 0, right: 0, top: 0, bottom: 0, backgroundColor: d ? Ha(d) : "" } }), f && d ? F("div", { class: `${g}-color-picker-trigger__value`, style: { color: Jk(d) ? "white" : "black" } }, C ? C(f) : f) : null));
  };
} }), mP = st({ name: "ColorPreview", props: { clsPrefix: { type: String, required: true }, mode: { type: String, required: true }, color: { type: String, default: null, validator: (r) => {
  const i = Gd(r);
  return !!(!r || i && i !== "hsv");
} }, onUpdateColor: { type: Function, required: true } }, setup(r) {
  function i(l) {
    var d;
    const f = l.target.value;
    (d = r.onUpdateColor) === null || d === void 0 || d.call(r, kb(f.toUpperCase(), r.mode, "hex")), l.stopPropagation();
  }
  return { handleChange: i };
}, render() {
  const { clsPrefix: r } = this;
  return F("div", { class: `${r}-color-picker-preview__preview` }, F("span", { class: `${r}-color-picker-preview__fill`, style: { background: this.color || "#000000" } }), F("input", { class: `${r}-color-picker-preview__input`, type: "color", value: this.color, onChange: this.handleChange }));
} }), Vu = "12px", gP = 12, pl = "6px", vP = 6, _P = "linear-gradient(90deg,red,#ff0 16.66%,#0f0 33.33%,#0ff 50%,#00f 66.66%,#f0f 83.33%,red)", yP = st({ name: "HueSlider", props: { clsPrefix: { type: String, required: true }, hue: { type: Number, required: true }, onUpdateHue: { type: Function, required: true }, onComplete: Function }, setup(r) {
  const i = Ae(null);
  function l(g) {
    i.value && (En("mousemove", document, d), En("mouseup", document, f), d(g));
  }
  function d(g) {
    const { value: m } = i;
    if (!m) return;
    const { width: s, left: C } = m.getBoundingClientRect(), T = Qk((g.clientX - C - vP) / (s - gP) * 360);
    r.onUpdateHue(T);
  }
  function f() {
    var g;
    Hn("mousemove", document, d), Hn("mouseup", document, f), (g = r.onComplete) === null || g === void 0 || g.call(r);
  }
  return { railRef: i, handleMouseDown: l };
}, render() {
  const { clsPrefix: r } = this;
  return F("div", { class: `${r}-color-picker-slider`, style: { height: Vu, borderRadius: pl } }, F("div", { ref: "railRef", style: { boxShadow: "inset 0 0 2px 0 rgba(0, 0, 0, .24)", boxSizing: "border-box", backgroundImage: _P, height: Vu, borderRadius: pl, position: "relative" }, onMousedown: this.handleMouseDown }, F("div", { style: { position: "absolute", left: pl, right: pl, top: 0, bottom: 0 } }, F("div", { class: `${r}-color-picker-handle`, style: { left: `calc((${this.hue}%) / 359 * 100 - ${pl})`, borderRadius: pl, width: Vu, height: Vu } }, F("div", { class: `${r}-color-picker-handle__fill`, style: { backgroundColor: `hsl(${this.hue}, 100%, 50%)`, borderRadius: pl, width: Vu, height: Vu } })))));
} }), wf = "12px", Cf = "6px", bP = st({ name: "Pallete", props: { clsPrefix: { type: String, required: true }, rgba: { type: Array, default: null }, displayedHue: { type: Number, required: true }, displayedSv: { type: Array, required: true }, onUpdateSV: { type: Function, required: true }, onComplete: Function }, setup(r) {
  const i = Ae(null);
  function l(g) {
    i.value && (En("mousemove", document, d), En("mouseup", document, f), d(g));
  }
  function d(g) {
    const { value: m } = i;
    if (!m) return;
    const { width: s, height: C, left: T, bottom: M } = m.getBoundingClientRect(), z = (M - g.clientY) / C, L = (g.clientX - T) / s, A = 100 * (L > 1 ? 1 : L < 0 ? 0 : L), O = 100 * (z > 1 ? 1 : z < 0 ? 0 : z);
    r.onUpdateSV(A, O);
  }
  function f() {
    var g;
    Hn("mousemove", document, d), Hn("mouseup", document, f), (g = r.onComplete) === null || g === void 0 || g.call(r);
  }
  return { palleteRef: i, handleColor: ze(() => {
    const { rgba: g } = r;
    return g ? `rgb(${g[0]}, ${g[1]}, ${g[2]})` : "";
  }), handleMouseDown: l };
}, render() {
  const { clsPrefix: r } = this;
  return F("div", { class: `${r}-color-picker-pallete`, onMousedown: this.handleMouseDown, ref: "palleteRef" }, F("div", { class: `${r}-color-picker-pallete__layer`, style: { backgroundImage: `linear-gradient(90deg, white, hsl(${this.displayedHue}, 100%, 50%))` } }), F("div", { class: `${r}-color-picker-pallete__layer ${r}-color-picker-pallete__layer--shadowed`, style: { backgroundImage: "linear-gradient(180deg, rgba(0, 0, 0, 0%), rgba(0, 0, 0, 100%))" } }), this.rgba && F("div", { class: `${r}-color-picker-handle`, style: { width: wf, height: wf, borderRadius: Cf, left: `calc(${this.displayedSv[0]}% - ${Cf})`, bottom: `calc(${this.displayedSv[1]}% - ${Cf})` } }, F("div", { class: `${r}-color-picker-handle__fill`, style: { backgroundColor: this.handleColor, borderRadius: Cf, width: wf, height: wf } })));
} }), xP = Ge([ue("color-picker", `
 display: inline-block;
 box-sizing: border-box;
 height: var(--n-height);
 font-size: var(--n-font-size);
 width: 100%;
 position: relative;
 `), ue("color-picker-panel", `
 margin: 4px 0;
 width: 240px;
 font-size: var(--n-panel-font-size);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 `, [rp(), ue("input", `
 text-align: center;
 `)]), ue("color-picker-checkboard", `
 background: white; 
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [Ge("&::after", `
 background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
 background-size: 12px 12px;
 background-position: 0 0, 0 6px, 6px -6px, -6px 0px;
 background-repeat: repeat;
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), ue("color-picker-slider", `
 margin-bottom: 8px;
 position: relative;
 box-sizing: border-box;
 `, [Re("image", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `), Ge("&::after", `
 content: "";
 position: absolute;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
 pointer-events: none;
 `)]), ue("color-picker-handle", `
 z-index: 1;
 box-shadow: 0 0 2px 0 rgba(0, 0, 0, .45);
 position: absolute;
 background-color: white;
 overflow: hidden;
 `, [Re("fill", `
 box-sizing: border-box;
 border: 2px solid white;
 `)]), ue("color-picker-pallete", `
 height: 180px;
 position: relative;
 margin-bottom: 8px;
 cursor: crosshair;
 `, [Re("layer", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [Ue("shadowed", `
 box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
 `)])]), ue("color-picker-preview", `
 display: flex;
 `, [Re("sliders", `
 flex: 1 0 auto;
 `), Re("preview", `
 position: relative;
 height: 30px;
 width: 30px;
 margin: 0 0 8px 6px;
 border-radius: 50%;
 box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
 overflow: hidden;
 `), Re("fill", `
 display: block;
 width: 30px;
 height: 30px;
 `), Re("input", `
 position: absolute;
 top: 0;
 left: 0;
 width: 30px;
 height: 30px;
 opacity: 0;
 z-index: 1;
 `)]), ue("color-picker-input", `
 display: flex;
 align-items: center;
 `, [ue("input", `
 flex-grow: 1;
 flex-basis: 0;
 `), Re("mode", `
 width: 72px;
 text-align: center;
 `)]), ue("color-picker-control", `
 padding: 12px;
 `), ue("color-picker-action", `
 display: flex;
 margin-top: -4px;
 border-top: 1px solid var(--n-divider-color);
 padding: 8px 12px;
 justify-content: flex-end;
 `, [ue("button", "margin-left: 8px;")]), ue("color-picker-trigger", `
 border: var(--n-border);
 height: 100%;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 transition: border-color .3s var(--n-bezier);
 cursor: pointer;
 `, [Re("value", `
 white-space: nowrap;
 position: relative;
 `), Re("fill", `
 border-radius: var(--n-border-radius);
 position: absolute;
 display: flex;
 align-items: center;
 justify-content: center;
 left: 4px;
 right: 4px;
 top: 4px;
 bottom: 4px;
 `), Ue("disabled", "cursor: not-allowed"), ue("color-picker-checkboard", `
 border-radius: var(--n-border-radius);
 `, [Ge("&::after", `
 --n-block-size: calc((var(--n-height) - 8px) / 3);
 background-size: calc(var(--n-block-size) * 2) calc(var(--n-block-size) * 2);
 background-position: 0 0, 0 var(--n-block-size), var(--n-block-size) calc(-1 * var(--n-block-size)), calc(-1 * var(--n-block-size)) 0px; 
 `)])]), ue("color-picker-swatches", `
 display: grid;
 grid-gap: 8px;
 flex-wrap: wrap;
 position: relative;
 grid-template-columns: repeat(auto-fill, 18px);
 margin-top: 10px;
 `, [ue("color-picker-swatch", `
 width: 18px;
 height: 18px;
 background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
 background-size: 8px 8px;
 background-position: 0px 0, 0px 4px, 4px -4px, -4px 0px;
 background-repeat: repeat;
 `, [Re("fill", `
 position: relative;
 width: 100%;
 height: 100%;
 border-radius: 3px;
 box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
 cursor: pointer;
 `), Ge("&:focus", `
 outline: none;
 `, [Re("fill", [Ge("&::after", `
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 background: inherit;
 filter: blur(2px);
 content: "";
 `)])])])])]), wP = Object.assign(Object.assign({}, Kt.props), { value: String, show: { type: Boolean, default: void 0 }, defaultShow: Boolean, defaultValue: String, modes: { type: Array, default: () => ["rgb", "hex", "hsl"] }, placement: { type: String, default: "bottom-start" }, to: Ju.propTo, showAlpha: { type: Boolean, default: true }, showPreview: Boolean, swatches: Array, disabled: { type: Boolean, default: void 0 }, actions: { type: Array, default: null }, internalActions: Array, size: String, renderLabel: Function, onComplete: Function, onConfirm: Function, onClear: Function, "onUpdate:show": [Function, Array], onUpdateShow: [Function, Array], "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array] }), jm = st({ name: "ColorPicker", props: wP, slots: Object, setup(r, { slots: i }) {
  const l = Ae(null);
  let d = null;
  const f = va(r), { mergedSizeRef: g, mergedDisabledRef: m } = f, { localeRef: s } = Ja("global"), { mergedClsPrefixRef: C, namespaceRef: T, inlineThemeDisabled: M } = Tr(r), z = Kt("ColorPicker", "-color-picker", xP, w2, r, C);
  Yr(Xg, { themeRef: z, renderLabelRef: Dt(r, "renderLabel"), colorPickerSlots: i });
  const L = Ae(r.defaultShow), A = Zi(Dt(r, "show"), L);
  function O(Ee) {
    const { onUpdateShow: ot, "onUpdate:show": Le } = r;
    ot && Ot(ot, Ee), Le && Ot(Le, Ee), L.value = Ee;
  }
  const { defaultValue: V } = r, X = Ae(V === void 0 ? Kk(r.modes, r.showAlpha) : V), W = Zi(Dt(r, "value"), X), K = Ae([W.value]), ie = Ae(0), ee = ze(() => Gd(W.value)), { modes: re } = r, J = Ae(Gd(W.value) || re[0] || "rgb");
  function Se() {
    const { modes: Ee } = r, { value: ot } = J, Le = Ee.findIndex((Ye) => Ye === ot);
    ~Le ? J.value = Ee[(Le + 1) % Ee.length] : J.value = "rgb";
  }
  let fe, oe, he, be, je, Ve, Ke, lt;
  const vt = ze(() => {
    const { value: Ee } = W;
    if (!Ee) return null;
    switch (ee.value) {
      case "hsv":
        return Cl(Ee);
      case "hsl":
        return [fe, oe, he, lt] = Xu(Ee), [...Ay(fe, oe, he), lt];
      case "rgb":
      case "hex":
        return [je, Ve, Ke, lt] = qo(Ee), [...dg(je, Ve, Ke), lt];
    }
  }), wt = ze(() => {
    const { value: Ee } = W;
    if (!Ee) return null;
    switch (ee.value) {
      case "rgb":
      case "hex":
        return qo(Ee);
      case "hsv":
        return [fe, oe, be, lt] = Cl(Ee), [..._s(fe, oe, be), lt];
      case "hsl":
        return [fe, oe, he, lt] = Xu(Ee), [...cg(fe, oe, he), lt];
    }
  }), at = ze(() => {
    const { value: Ee } = W;
    if (!Ee) return null;
    switch (ee.value) {
      case "hsl":
        return Xu(Ee);
      case "hsv":
        return [fe, oe, be, lt] = Cl(Ee), [...Ff(fe, oe, be), lt];
      case "rgb":
      case "hex":
        return [je, Ve, Ke, lt] = qo(Ee), [...hg(je, Ve, Ke), lt];
    }
  }), et = ze(() => {
    switch (J.value) {
      case "rgb":
      case "hex":
        return wt.value;
      case "hsv":
        return vt.value;
      case "hsl":
        return at.value;
    }
  }), ht = Ae(0), yt = Ae(1), nt = Ae([0, 0]);
  function ut(Ee, ot) {
    const { value: Le } = vt, Ye = ht.value, ft = Le ? Le[3] : 1;
    nt.value = [Ee, ot];
    const { showAlpha: bt } = r;
    switch (J.value) {
      case "hsv":
        zt((bt ? Sl : mg)([Ye, Ee, ot, ft]), "cursor");
        break;
      case "hsl":
        zt((bt ? Ha : fg)([...Ff(Ye, Ee, ot), ft]), "cursor");
        break;
      case "rgb":
        zt((bt ? Xa : pg)([..._s(Ye, Ee, ot), ft]), "cursor");
        break;
      case "hex":
        zt((bt ? xs : zd)([..._s(Ye, Ee, ot), ft]), "cursor");
        break;
    }
  }
  function Ft(Ee) {
    ht.value = Ee;
    const { value: ot } = vt;
    if (!ot) return;
    const [, Le, Ye, ft] = ot, { showAlpha: bt } = r;
    switch (J.value) {
      case "hsv":
        zt((bt ? Sl : mg)([Ee, Le, Ye, ft]), "cursor");
        break;
      case "rgb":
        zt((bt ? Xa : pg)([..._s(Ee, Le, Ye), ft]), "cursor");
        break;
      case "hex":
        zt((bt ? xs : zd)([..._s(Ee, Le, Ye), ft]), "cursor");
        break;
      case "hsl":
        zt((bt ? Ha : fg)([...Ff(Ee, Le, Ye), ft]), "cursor");
        break;
    }
  }
  function Ht(Ee) {
    switch (J.value) {
      case "hsv":
        [fe, oe, be] = vt.value, zt(Sl([fe, oe, be, Ee]), "cursor");
        break;
      case "rgb":
        [je, Ve, Ke] = wt.value, zt(Xa([je, Ve, Ke, Ee]), "cursor");
        break;
      case "hex":
        [je, Ve, Ke] = wt.value, zt(xs([je, Ve, Ke, Ee]), "cursor");
        break;
      case "hsl":
        [fe, oe, he] = at.value, zt(Ha([fe, oe, he, Ee]), "cursor");
        break;
    }
    yt.value = Ee;
  }
  function zt(Ee, ot) {
    ot === "cursor" ? d = Ee : d = null;
    const { nTriggerFormChange: Le, nTriggerFormInput: Ye } = f, { onUpdateValue: ft, "onUpdate:value": bt } = r;
    ft && Ot(ft, Ee), bt && Ot(bt, Ee), Le(), Ye(), X.value = Ee;
  }
  function pr(Ee) {
    zt(Ee, "input"), Vn(Qt);
  }
  function Qt(Ee = true) {
    const { value: ot } = W;
    if (ot) {
      const { nTriggerFormChange: Le, nTriggerFormInput: Ye } = f, { onComplete: ft } = r;
      ft && ft(ot);
      const { value: bt } = K, { value: tt } = ie;
      Ee && (bt.splice(tt + 1, bt.length, ot), ie.value = tt + 1), Le(), Ye();
    }
  }
  function tr() {
    const { value: Ee } = ie;
    Ee - 1 < 0 || (zt(K.value[Ee - 1], "input"), Qt(false), ie.value = Ee - 1);
  }
  function xr() {
    const { value: Ee } = ie;
    Ee < 0 || Ee + 1 >= K.value.length || (zt(K.value[Ee + 1], "input"), Qt(false), ie.value = Ee + 1);
  }
  function Mr() {
    zt(null, "input");
    const { onClear: Ee } = r;
    Ee && Ee(), O(false);
  }
  function rr() {
    const { value: Ee } = W, { onConfirm: ot } = r;
    ot && ot(Ee), O(false);
  }
  const sr = ze(() => ie.value >= 1), Gt = ze(() => {
    const { value: Ee } = K;
    return Ee.length > 1 && ie.value < Ee.length - 1;
  });
  ar(A, (Ee) => {
    Ee || (K.value = [W.value], ie.value = 0);
  }), po(() => {
    if (!(d && d === W.value)) {
      const { value: Ee } = vt;
      Ee && (ht.value = Ee[0], yt.value = Ee[3], nt.value = [Ee[1], Ee[2]]);
    }
    d = null;
  });
  const Dr = ze(() => {
    const { value: Ee } = g, { common: { cubicBezierEaseInOut: ot }, self: { textColor: Le, color: Ye, panelFontSize: ft, boxShadow: bt, border: tt, borderRadius: mt, dividerColor: Zt, [jt("height", Ee)]: ri, [jt("fontSize", Ee)]: Si } } = z.value;
    return { "--n-bezier": ot, "--n-text-color": Le, "--n-color": Ye, "--n-panel-font-size": ft, "--n-font-size": Si, "--n-box-shadow": bt, "--n-border": tt, "--n-border-radius": mt, "--n-height": ri, "--n-divider-color": Zt };
  }), wr = M ? mi("color-picker", ze(() => g.value[0]), Dr, r) : void 0;
  function Ct() {
    var Ee;
    const { value: ot } = wt, { value: Le } = ht, { internalActions: Ye, modes: ft, actions: bt } = r, { value: tt } = z, { value: mt } = C;
    return F("div", { class: [`${mt}-color-picker-panel`, wr == null ? void 0 : wr.themeClass.value], onDragstart: (Zt) => {
      Zt.preventDefault();
    }, style: M ? void 0 : Dr.value }, F("div", { class: `${mt}-color-picker-control` }, F(bP, { clsPrefix: mt, rgba: ot, displayedHue: Le, displayedSv: nt.value, onUpdateSV: ut, onComplete: Qt }), F("div", { class: `${mt}-color-picker-preview` }, F("div", { class: `${mt}-color-picker-preview__sliders` }, F(yP, { clsPrefix: mt, hue: Le, onUpdateHue: Ft, onComplete: Qt }), r.showAlpha ? F(iP, { clsPrefix: mt, rgba: ot, alpha: yt.value, onUpdateAlpha: Ht, onComplete: Qt }) : null), r.showPreview ? F(mP, { clsPrefix: mt, mode: J.value, color: wt.value && zd(wt.value), onUpdateColor: (Zt) => {
      zt(Zt, "input");
    } }) : null), F(cP, { clsPrefix: mt, showAlpha: r.showAlpha, mode: J.value, modes: ft, onUpdateMode: Se, value: W.value, valueArr: et.value, onUpdateValue: pr }), ((Ee = r.swatches) === null || Ee === void 0 ? void 0 : Ee.length) && F(fP, { clsPrefix: mt, mode: J.value, swatches: r.swatches, onUpdateColor: (Zt) => {
      zt(Zt, "input");
    } })), (bt == null ? void 0 : bt.length) ? F("div", { class: `${mt}-color-picker-action` }, bt.includes("confirm") && F(Vr, { size: "small", onClick: rr, theme: tt.peers.Button, themeOverrides: tt.peerOverrides.Button }, { default: () => s.value.confirm }), bt.includes("clear") && F(Vr, { size: "small", onClick: Mr, disabled: !W.value, theme: tt.peers.Button, themeOverrides: tt.peerOverrides.Button }, { default: () => s.value.clear })) : null, i.action ? F("div", { class: `${mt}-color-picker-action` }, { default: i.action }) : Ye ? F("div", { class: `${mt}-color-picker-action` }, Ye.includes("undo") && F(Vr, { size: "small", onClick: tr, disabled: !sr.value, theme: tt.peers.Button, themeOverrides: tt.peerOverrides.Button }, { default: () => s.value.undo }), Ye.includes("redo") && F(Vr, { size: "small", onClick: xr, disabled: !Gt.value, theme: tt.peers.Button, themeOverrides: tt.peerOverrides.Button }, { default: () => s.value.redo })) : null);
  }
  return { mergedClsPrefix: C, namespace: T, selfRef: l, hsla: at, rgba: wt, mergedShow: A, mergedDisabled: m, isMounted: lp(), adjustedTo: Ju(r), mergedValue: W, handleTriggerClick() {
    O(true);
  }, handleClickOutside(Ee) {
    var ot;
    !((ot = l.value) === null || ot === void 0) && ot.contains(Ly(Ee)) || O(false);
  }, renderPanel: Ct, cssVars: M ? void 0 : Dr, themeClass: wr == null ? void 0 : wr.themeClass, onRender: wr == null ? void 0 : wr.onRender };
}, render() {
  const { mergedClsPrefix: r, onRender: i } = this;
  return i == null ? void 0 : i(), F("div", { class: [this.themeClass, `${r}-color-picker`], ref: "selfRef", style: this.cssVars }, F(Dy, null, { default: () => [F(zy, null, { default: () => F(pP, { clsPrefix: r, value: this.mergedValue, hsla: this.hsla, disabled: this.mergedDisabled, onClick: this.handleTriggerClick }) }), F(Fy, { placement: this.placement, show: this.mergedShow, containerClass: this.namespace, teleportDisabled: this.adjustedTo === Ju.tdkey, to: this.adjustedTo }, { default: () => F(Io, { name: "fade-in-scale-up-transition", appear: this.isMounted }, { default: () => this.mergedShow ? ma(this.renderPanel(), [[qf, this.handleClickOutside, void 0, { capture: true }]]) : null }) })] }));
} }), CP = Ge([ue("select", `
 z-index: auto;
 outline: none;
 width: 100%;
 position: relative;
 font-weight: var(--n-font-weight);
 `), ue("select-menu", `
 margin: 4px 0;
 box-shadow: var(--n-menu-box-shadow);
 `, [rp({ originalTransition: "background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)" })])]), SP = Object.assign(Object.assign({}, Kt.props), { to: Ju.propTo, bordered: { type: Boolean, default: void 0 }, clearable: Boolean, clearFilterAfterSelect: { type: Boolean, default: true }, options: { type: Array, default: () => [] }, defaultValue: { type: [String, Number, Array], default: null }, keyboard: { type: Boolean, default: true }, value: [String, Number, Array], placeholder: String, menuProps: Object, multiple: Boolean, size: String, menuSize: { type: String }, filterable: Boolean, disabled: { type: Boolean, default: void 0 }, remote: Boolean, loading: Boolean, filter: Function, placement: { type: String, default: "bottom-start" }, widthMode: { type: String, default: "trigger" }, tag: Boolean, onCreate: Function, fallbackOption: { type: [Function, Boolean], default: void 0 }, show: { type: Boolean, default: void 0 }, showArrow: { type: Boolean, default: true }, maxTagCount: [Number, String], ellipsisTagPopoverProps: Object, consistentMenuWidth: { type: Boolean, default: true }, virtualScroll: { type: Boolean, default: true }, labelField: { type: String, default: "label" }, valueField: { type: String, default: "value" }, childrenField: { type: String, default: "children" }, renderLabel: Function, renderOption: Function, renderTag: Function, "onUpdate:value": [Function, Array], inputProps: Object, nodeProps: Function, ignoreComposition: { type: Boolean, default: true }, showOnFocus: Boolean, onUpdateValue: [Function, Array], onBlur: [Function, Array], onClear: [Function, Array], onFocus: [Function, Array], onScroll: [Function, Array], onSearch: [Function, Array], onUpdateShow: [Function, Array], "onUpdate:show": [Function, Array], displayDirective: { type: String, default: "show" }, resetMenuOnOptionsChange: { type: Boolean, default: true }, status: String, showCheckmark: { type: Boolean, default: true }, onChange: [Function, Array], items: Array }), yg = st({ name: "Select", props: SP, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, mergedBorderedRef: l, namespaceRef: d, inlineThemeDisabled: f } = Tr(r), g = Kt("Select", "-select", CP, C2, r, i), m = Ae(r.defaultValue), s = Dt(r, "value"), C = Zi(s, m), T = Ae(false), M = Ae(""), z = Gf(r, ["items", "options"]), L = Ae([]), A = Ae([]), O = ze(() => A.value.concat(L.value).concat(z.value)), V = ze(() => {
    const { filter: de } = r;
    if (de) return de;
    const { labelField: ve, valueField: $e } = r;
    return (it, Xe) => {
      if (!Xe) return false;
      const xt = Xe[ve];
      if (typeof xt == "string") return Lm(it, xt);
      const Te = Xe[$e];
      return typeof Te == "string" ? Lm(it, Te) : typeof Te == "number" ? Lm(it, String(Te)) : false;
    };
  }), X = ze(() => {
    if (r.remote) return z.value;
    {
      const { value: de } = O, { value: ve } = M;
      return !ve.length || !r.filterable ? de : Dk(de, V.value, ve, r.childrenField);
    }
  }), W = ze(() => {
    const { valueField: de, childrenField: ve } = r, $e = Ak(de, ve);
    return S2(X.value, $e);
  }), K = ze(() => zk(O.value, r.valueField, r.childrenField)), ie = Ae(false), ee = Zi(Dt(r, "show"), ie), re = Ae(null), J = Ae(null), Se = Ae(null), { localeRef: fe } = Ja("Select"), oe = ze(() => {
    var de;
    return (de = r.placeholder) !== null && de !== void 0 ? de : fe.value.placeholder;
  }), he = [], be = Ae(/* @__PURE__ */ new Map()), je = ze(() => {
    const { fallbackOption: de } = r;
    if (de === void 0) {
      const { labelField: ve, valueField: $e } = r;
      return (it) => ({ [ve]: String(it), [$e]: it });
    }
    return de === false ? false : (ve) => Object.assign(de(ve), { value: ve });
  });
  function Ve(de) {
    const ve = r.remote, { value: $e } = be, { value: it } = K, { value: Xe } = je, xt = [];
    return de.forEach((Te) => {
      if (it.has(Te)) xt.push(it.get(Te));
      else if (ve && $e.has(Te)) xt.push($e.get(Te));
      else if (Xe) {
        const $t = Xe(Te);
        $t && xt.push($t);
      }
    }), xt;
  }
  const Ke = ze(() => {
    if (r.multiple) {
      const { value: de } = C;
      return Array.isArray(de) ? Ve(de) : [];
    }
    return null;
  }), lt = ze(() => {
    const { value: de } = C;
    return !r.multiple && !Array.isArray(de) ? de === null ? null : Ve([de])[0] || null : null;
  }), vt = va(r), { mergedSizeRef: wt, mergedDisabledRef: at, mergedStatusRef: et } = vt;
  function ht(de, ve) {
    const { onChange: $e, "onUpdate:value": it, onUpdateValue: Xe } = r, { nTriggerFormChange: xt, nTriggerFormInput: Te } = vt;
    $e && Ot($e, de, ve), Xe && Ot(Xe, de, ve), it && Ot(it, de, ve), m.value = de, xt(), Te();
  }
  function yt(de) {
    const { onBlur: ve } = r, { nTriggerFormBlur: $e } = vt;
    ve && Ot(ve, de), $e();
  }
  function nt() {
    const { onClear: de } = r;
    de && Ot(de);
  }
  function ut(de) {
    const { onFocus: ve, showOnFocus: $e } = r, { nTriggerFormFocus: it } = vt;
    ve && Ot(ve, de), it(), $e && Qt();
  }
  function Ft(de) {
    const { onSearch: ve } = r;
    ve && Ot(ve, de);
  }
  function Ht(de) {
    const { onScroll: ve } = r;
    ve && Ot(ve, de);
  }
  function zt() {
    var de;
    const { remote: ve, multiple: $e } = r;
    if (ve) {
      const { value: it } = be;
      if ($e) {
        const { valueField: Xe } = r;
        (de = Ke.value) === null || de === void 0 || de.forEach((xt) => {
          it.set(xt[Xe], xt);
        });
      } else {
        const Xe = lt.value;
        Xe && it.set(Xe[r.valueField], Xe);
      }
    }
  }
  function pr(de) {
    const { onUpdateShow: ve, "onUpdate:show": $e } = r;
    ve && Ot(ve, de), $e && Ot($e, de), ie.value = de;
  }
  function Qt() {
    at.value || (pr(true), ie.value = true, r.filterable && H());
  }
  function tr() {
    pr(false);
  }
  function xr() {
    M.value = "", A.value = he;
  }
  const Mr = Ae(false);
  function rr() {
    r.filterable && (Mr.value = true);
  }
  function sr() {
    r.filterable && (Mr.value = false, ee.value || xr());
  }
  function Gt() {
    at.value || (ee.value ? r.filterable ? H() : tr() : Qt());
  }
  function Dr(de) {
    var ve, $e;
    !(($e = (ve = Se.value) === null || ve === void 0 ? void 0 : ve.selfRef) === null || $e === void 0) && $e.contains(de.relatedTarget) || (T.value = false, yt(de), tr());
  }
  function wr(de) {
    ut(de), T.value = true;
  }
  function Ct() {
    T.value = true;
  }
  function Ee(de) {
    var ve;
    !((ve = re.value) === null || ve === void 0) && ve.$el.contains(de.relatedTarget) || (T.value = false, yt(de), tr());
  }
  function ot() {
    var de;
    (de = re.value) === null || de === void 0 || de.focus(), tr();
  }
  function Le(de) {
    var ve;
    ee.value && (!((ve = re.value) === null || ve === void 0) && ve.$el.contains(Ly(de)) || tr());
  }
  function Ye(de) {
    if (!Array.isArray(de)) return [];
    if (je.value) return Array.from(de);
    {
      const { remote: ve } = r, { value: $e } = K;
      if (ve) {
        const { value: it } = be;
        return de.filter((Xe) => $e.has(Xe) || it.has(Xe));
      } else return de.filter((it) => $e.has(it));
    }
  }
  function ft(de) {
    bt(de.rawNode);
  }
  function bt(de) {
    if (at.value) return;
    const { tag: ve, remote: $e, clearFilterAfterSelect: it, valueField: Xe } = r;
    if (ve && !$e) {
      const { value: xt } = A, Te = xt[0] || null;
      if (Te) {
        const $t = L.value;
        $t.length ? $t.push(Te) : L.value = [Te], A.value = he;
      }
    }
    if ($e && be.value.set(de[Xe], de), r.multiple) {
      const xt = Ye(C.value), Te = xt.findIndex(($t) => $t === de[Xe]);
      if (~Te) {
        if (xt.splice(Te, 1), ve && !$e) {
          const $t = tt(de[Xe]);
          ~$t && (L.value.splice($t, 1), it && (M.value = ""));
        }
      } else xt.push(de[Xe]), it && (M.value = "");
      ht(xt, Ve(xt));
    } else {
      if (ve && !$e) {
        const xt = tt(de[Xe]);
        ~xt ? L.value = [L.value[xt]] : L.value = he;
      }
      Z(), tr(), ht(de[Xe], de);
    }
  }
  function tt(de) {
    return L.value.findIndex(($e) => $e[r.valueField] === de);
  }
  function mt(de) {
    ee.value || Qt();
    const { value: ve } = de.target;
    M.value = ve;
    const { tag: $e, remote: it } = r;
    if (Ft(ve), $e && !it) {
      if (!ve) {
        A.value = he;
        return;
      }
      const { onCreate: Xe } = r, xt = Xe ? Xe(ve) : { [r.labelField]: ve, [r.valueField]: ve }, { valueField: Te, labelField: $t } = r;
      z.value.some((er) => er[Te] === xt[Te] || er[$t] === xt[$t]) || L.value.some((er) => er[Te] === xt[Te] || er[$t] === xt[$t]) ? A.value = he : A.value = [xt];
    }
  }
  function Zt(de) {
    de.stopPropagation();
    const { multiple: ve } = r;
    !ve && r.filterable && tr(), nt(), ve ? ht([], []) : ht(null, null);
  }
  function ri(de) {
    !wl(de, "action") && !wl(de, "empty") && !wl(de, "header") && de.preventDefault();
  }
  function Si(de) {
    Ht(de);
  }
  function Fe(de) {
    var ve, $e, it, Xe, xt;
    if (!r.keyboard) {
      de.preventDefault();
      return;
    }
    switch (de.key) {
      case " ":
        if (r.filterable) break;
        de.preventDefault();
      case "Enter":
        if (!(!((ve = re.value) === null || ve === void 0) && ve.isComposing)) {
          if (ee.value) {
            const Te = ($e = Se.value) === null || $e === void 0 ? void 0 : $e.getPendingTmNode();
            Te ? ft(Te) : r.filterable || (tr(), Z());
          } else if (Qt(), r.tag && Mr.value) {
            const Te = A.value[0];
            if (Te) {
              const $t = Te[r.valueField], { value: er } = C;
              r.multiple && Array.isArray(er) && er.includes($t) || bt(Te);
            }
          }
        }
        de.preventDefault();
        break;
      case "ArrowUp":
        if (de.preventDefault(), r.loading) return;
        ee.value && ((it = Se.value) === null || it === void 0 || it.prev());
        break;
      case "ArrowDown":
        if (de.preventDefault(), r.loading) return;
        ee.value ? (Xe = Se.value) === null || Xe === void 0 || Xe.next() : Qt();
        break;
      case "Escape":
        ee.value && (k2(de), tr()), (xt = re.value) === null || xt === void 0 || xt.focus();
        break;
    }
  }
  function Z() {
    var de;
    (de = re.value) === null || de === void 0 || de.focus();
  }
  function H() {
    var de;
    (de = re.value) === null || de === void 0 || de.focusInput();
  }
  function ne() {
    var de;
    ee.value && ((de = J.value) === null || de === void 0 || de.syncPosition());
  }
  zt(), ar(Dt(r, "options"), zt);
  const xe = { focus: () => {
    var de;
    (de = re.value) === null || de === void 0 || de.focus();
  }, focusInput: () => {
    var de;
    (de = re.value) === null || de === void 0 || de.focusInput();
  }, blur: () => {
    var de;
    (de = re.value) === null || de === void 0 || de.blur();
  }, blurInput: () => {
    var de;
    (de = re.value) === null || de === void 0 || de.blurInput();
  } }, ke = ze(() => {
    const { self: { menuBoxShadow: de } } = g.value;
    return { "--n-menu-box-shadow": de };
  }), De = f ? mi("select", void 0, ke, r) : void 0;
  return Object.assign(Object.assign({}, xe), { mergedStatus: et, mergedClsPrefix: i, mergedBordered: l, namespace: d, treeMate: W, isMounted: lp(), triggerRef: re, menuRef: Se, pattern: M, uncontrolledShow: ie, mergedShow: ee, adjustedTo: Ju(r), uncontrolledValue: m, mergedValue: C, followerRef: J, localizedPlaceholder: oe, selectedOption: lt, selectedOptions: Ke, mergedSize: wt, mergedDisabled: at, focused: T, activeWithoutMenuOpen: Mr, inlineThemeDisabled: f, onTriggerInputFocus: rr, onTriggerInputBlur: sr, handleTriggerOrMenuResize: ne, handleMenuFocus: Ct, handleMenuBlur: Ee, handleMenuTabOut: ot, handleTriggerClick: Gt, handleToggle: ft, handleDeleteOption: bt, handlePatternInput: mt, handleClear: Zt, handleTriggerBlur: Dr, handleTriggerFocus: wr, handleKeydown: Fe, handleMenuAfterLeave: xr, handleMenuClickOutside: Le, handleMenuScroll: Si, handleMenuKeydown: Fe, handleMenuMousedown: ri, mergedTheme: g, cssVars: f ? void 0 : ke, themeClass: De == null ? void 0 : De.themeClass, onRender: De == null ? void 0 : De.onRender });
}, render() {
  return F("div", { class: `${this.mergedClsPrefix}-select` }, F(Dy, null, { default: () => [F(zy, null, { default: () => F(pk, { ref: "triggerRef", inlineThemeDisabled: this.inlineThemeDisabled, status: this.mergedStatus, inputProps: this.inputProps, clsPrefix: this.mergedClsPrefix, showArrow: this.showArrow, maxTagCount: this.maxTagCount, ellipsisTagPopoverProps: this.ellipsisTagPopoverProps, bordered: this.mergedBordered, active: this.activeWithoutMenuOpen || this.mergedShow, pattern: this.pattern, placeholder: this.localizedPlaceholder, selectedOption: this.selectedOption, selectedOptions: this.selectedOptions, multiple: this.multiple, renderTag: this.renderTag, renderLabel: this.renderLabel, filterable: this.filterable, clearable: this.clearable, disabled: this.mergedDisabled, size: this.mergedSize, theme: this.mergedTheme.peers.InternalSelection, labelField: this.labelField, valueField: this.valueField, themeOverrides: this.mergedTheme.peerOverrides.InternalSelection, loading: this.loading, focused: this.focused, onClick: this.handleTriggerClick, onDeleteOption: this.handleDeleteOption, onPatternInput: this.handlePatternInput, onClear: this.handleClear, onBlur: this.handleTriggerBlur, onFocus: this.handleTriggerFocus, onKeydown: this.handleKeydown, onPatternBlur: this.onTriggerInputBlur, onPatternFocus: this.onTriggerInputFocus, onResize: this.handleTriggerOrMenuResize, ignoreComposition: this.ignoreComposition }, { arrow: () => {
    var r, i;
    return [(i = (r = this.$slots).arrow) === null || i === void 0 ? void 0 : i.call(r)];
  } }) }), F(Fy, { ref: "followerRef", show: this.mergedShow, to: this.adjustedTo, teleportDisabled: this.adjustedTo === Ju.tdkey, containerClass: this.namespace, width: this.consistentMenuWidth ? "target" : void 0, minWidth: "target", placement: this.placement }, { default: () => F(Io, { name: "fade-in-scale-up-transition", appear: this.isMounted, onAfterLeave: this.handleMenuAfterLeave }, { default: () => {
    var r, i, l;
    return this.mergedShow || this.displayDirective === "show" ? ((r = this.onRender) === null || r === void 0 || r.call(this), ma(F(uk, Object.assign({}, this.menuProps, { ref: "menuRef", onResize: this.handleTriggerOrMenuResize, inlineThemeDisabled: this.inlineThemeDisabled, virtualScroll: this.consistentMenuWidth && this.virtualScroll, class: [`${this.mergedClsPrefix}-select-menu`, this.themeClass, (i = this.menuProps) === null || i === void 0 ? void 0 : i.class], clsPrefix: this.mergedClsPrefix, focusable: true, labelField: this.labelField, valueField: this.valueField, autoPending: true, nodeProps: this.nodeProps, theme: this.mergedTheme.peers.InternalSelectMenu, themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu, treeMate: this.treeMate, multiple: this.multiple, size: this.menuSize, renderOption: this.renderOption, renderLabel: this.renderLabel, value: this.mergedValue, style: [(l = this.menuProps) === null || l === void 0 ? void 0 : l.style, this.cssVars], onToggle: this.handleToggle, onScroll: this.handleMenuScroll, onFocus: this.handleMenuFocus, onBlur: this.handleMenuBlur, onKeydown: this.handleMenuKeydown, onTabOut: this.handleMenuTabOut, onMousedown: this.handleMenuMousedown, show: this.mergedShow, showCheckmark: this.showCheckmark, resetMenuOnOptionsChange: this.resetMenuOnOptionsChange }), { empty: () => {
      var d, f;
      return [(f = (d = this.$slots).empty) === null || f === void 0 ? void 0 : f.call(d)];
    }, header: () => {
      var d, f;
      return [(f = (d = this.$slots).header) === null || f === void 0 ? void 0 : f.call(d)];
    }, action: () => {
      var d, f;
      return [(f = (d = this.$slots).action) === null || f === void 0 ? void 0 : f.call(d)];
    } }), this.displayDirective === "show" ? [[Ka, this.mergedShow], [qf, this.handleMenuClickOutside, void 0, { capture: true }]] : [[qf, this.handleMenuClickOutside, void 0, { capture: true }]])) : null;
  } }) })] }));
} }), kP = { name: String, value: { type: [String, Number, Boolean], default: "on" }, checked: { type: Boolean, default: void 0 }, defaultChecked: Boolean, disabled: { type: Boolean, default: void 0 }, label: String, size: String, onUpdateChecked: [Function, Array], "onUpdate:checked": [Function, Array], checkedValue: { type: Boolean, default: void 0 } }, Pb = An("n-radio-group");
function PP(r) {
  const i = fr(Pb, null), l = va(r, { mergedSize(K) {
    const { size: ie } = r;
    if (ie !== void 0) return ie;
    if (i) {
      const { mergedSizeRef: { value: ee } } = i;
      if (ee !== void 0) return ee;
    }
    return K ? K.mergedSize.value : "medium";
  }, mergedDisabled(K) {
    return !!(r.disabled || (i == null ? void 0 : i.disabledRef.value) || (K == null ? void 0 : K.disabled.value));
  } }), { mergedSizeRef: d, mergedDisabledRef: f } = l, g = Ae(null), m = Ae(null), s = Ae(r.defaultChecked), C = Dt(r, "checked"), T = Zi(C, s), M = _i(() => i ? i.valueRef.value === r.value : T.value), z = _i(() => {
    const { name: K } = r;
    if (K !== void 0) return K;
    if (i) return i.nameRef.value;
  }), L = Ae(false);
  function A() {
    if (i) {
      const { doUpdateValue: K } = i, { value: ie } = r;
      Ot(K, ie);
    } else {
      const { onUpdateChecked: K, "onUpdate:checked": ie } = r, { nTriggerFormInput: ee, nTriggerFormChange: re } = l;
      K && Ot(K, true), ie && Ot(ie, true), ee(), re(), s.value = true;
    }
  }
  function O() {
    f.value || M.value || A();
  }
  function V() {
    O(), g.value && (g.value.checked = M.value);
  }
  function X() {
    L.value = false;
  }
  function W() {
    L.value = true;
  }
  return { mergedClsPrefix: i ? i.mergedClsPrefixRef : Tr(r).mergedClsPrefixRef, inputRef: g, labelRef: m, mergedName: z, mergedDisabled: f, renderSafeChecked: M, focus: L, mergedSize: d, handleRadioInputChange: V, handleRadioInputBlur: X, handleRadioInputFocus: W };
}
const TP = st({ name: "RadioButton", props: kP, setup: PP, render() {
  const { mergedClsPrefix: r } = this;
  return F("label", { class: [`${r}-radio-button`, this.mergedDisabled && `${r}-radio-button--disabled`, this.renderSafeChecked && `${r}-radio-button--checked`, this.focus && [`${r}-radio-button--focus`]] }, F("input", { ref: "inputRef", type: "radio", class: `${r}-radio-input`, value: this.value, name: this.mergedName, checked: this.renderSafeChecked, disabled: this.mergedDisabled, onChange: this.handleRadioInputChange, onFocus: this.handleRadioInputFocus, onBlur: this.handleRadioInputBlur }), F("div", { class: `${r}-radio-button__state-border` }), Ci(this.$slots.default, (i) => !i && !this.label ? null : F("div", { ref: "labelRef", class: `${r}-radio__label` }, i || this.label)));
} }), IP = ue("radio-group", `
 display: inline-block;
 font-size: var(--n-font-size);
`, [Re("splitor", `
 display: inline-block;
 vertical-align: bottom;
 width: 1px;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 background: var(--n-button-border-color);
 `, [Ue("checked", { backgroundColor: "var(--n-button-border-color-active)" }), Ue("disabled", { opacity: "var(--n-opacity-disabled)" })]), Ue("button-group", `
 white-space: nowrap;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [ue("radio-button", { height: "var(--n-height)", lineHeight: "var(--n-height)" }), Re("splitor", { height: "var(--n-height)" })]), ue("radio-button", `
 vertical-align: bottom;
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-block;
 box-sizing: border-box;
 padding-left: 14px;
 padding-right: 14px;
 white-space: nowrap;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background: var(--n-button-color);
 color: var(--n-button-text-color);
 border-top: 1px solid var(--n-button-border-color);
 border-bottom: 1px solid var(--n-button-border-color);
 `, [ue("radio-input", `
 pointer-events: none;
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 `), Re("state-border", `
 z-index: 1;
 pointer-events: none;
 position: absolute;
 box-shadow: var(--n-button-box-shadow);
 transition: box-shadow .3s var(--n-bezier);
 left: -1px;
 bottom: -1px;
 right: -1px;
 top: -1px;
 `), Ge("&:first-child", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 border-left: 1px solid var(--n-button-border-color);
 `, [Re("state-border", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 `)]), Ge("&:last-child", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 border-right: 1px solid var(--n-button-border-color);
 `, [Re("state-border", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 `)]), pi("disabled", `
 cursor: pointer;
 `, [Ge("&:hover", [Re("state-border", `
 transition: box-shadow .3s var(--n-bezier);
 box-shadow: var(--n-button-box-shadow-hover);
 `), pi("checked", { color: "var(--n-button-text-color-hover)" })]), Ue("focus", [Ge("&:not(:active)", [Re("state-border", { boxShadow: "var(--n-button-box-shadow-focus)" })])])]), Ue("checked", `
 background: var(--n-button-color-active);
 color: var(--n-button-text-color-active);
 border-color: var(--n-button-border-color-active);
 `), Ue("disabled", `
 cursor: not-allowed;
 opacity: var(--n-opacity-disabled);
 `)])]);
function MP(r, i, l) {
  var d;
  const f = [];
  let g = false;
  for (let m = 0; m < r.length; ++m) {
    const s = r[m], C = (d = s.type) === null || d === void 0 ? void 0 : d.name;
    C === "RadioButton" && (g = true);
    const T = s.props;
    if (C !== "RadioButton") {
      f.push(s);
      continue;
    }
    if (m === 0) f.push(s);
    else {
      const M = f[f.length - 1].props, z = i === M.value, L = M.disabled, A = i === T.value, O = T.disabled, V = (z ? 2 : 0) + (L ? 0 : 1), X = (A ? 2 : 0) + (O ? 0 : 1), W = { [`${l}-radio-group__splitor--disabled`]: L, [`${l}-radio-group__splitor--checked`]: z }, K = { [`${l}-radio-group__splitor--disabled`]: O, [`${l}-radio-group__splitor--checked`]: A }, ie = V < X ? K : W;
      f.push(F("div", { class: [`${l}-radio-group__splitor`, ie] }), s);
    }
  }
  return { children: f, isButtonGroup: g };
}
const EP = Object.assign(Object.assign({}, Kt.props), { name: String, value: [String, Number, Boolean], defaultValue: { type: [String, Number, Boolean], default: null }, size: String, disabled: { type: Boolean, default: void 0 }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array] }), RP = st({ name: "RadioGroup", props: EP, setup(r) {
  const i = Ae(null), { mergedSizeRef: l, mergedDisabledRef: d, nTriggerFormChange: f, nTriggerFormInput: g, nTriggerFormBlur: m, nTriggerFormFocus: s } = va(r), { mergedClsPrefixRef: C, inlineThemeDisabled: T, mergedRtlRef: M } = Tr(r), z = Kt("Radio", "-radio-group", IP, P2, r, C), L = Ae(r.defaultValue), A = Dt(r, "value"), O = Zi(A, L);
  function V(re) {
    const { onUpdateValue: J, "onUpdate:value": Se } = r;
    J && Ot(J, re), Se && Ot(Se, re), L.value = re, f(), g();
  }
  function X(re) {
    const { value: J } = i;
    J && (J.contains(re.relatedTarget) || s());
  }
  function W(re) {
    const { value: J } = i;
    J && (J.contains(re.relatedTarget) || m());
  }
  Yr(Pb, { mergedClsPrefixRef: C, nameRef: Dt(r, "name"), valueRef: O, disabledRef: d, mergedSizeRef: l, doUpdateValue: V });
  const K = Rn("Radio", M, C), ie = ze(() => {
    const { value: re } = l, { common: { cubicBezierEaseInOut: J }, self: { buttonBorderColor: Se, buttonBorderColorActive: fe, buttonBorderRadius: oe, buttonBoxShadow: he, buttonBoxShadowFocus: be, buttonBoxShadowHover: je, buttonColor: Ve, buttonColorActive: Ke, buttonTextColor: lt, buttonTextColorActive: vt, buttonTextColorHover: wt, opacityDisabled: at, [jt("buttonHeight", re)]: et, [jt("fontSize", re)]: ht } } = z.value;
    return { "--n-font-size": ht, "--n-bezier": J, "--n-button-border-color": Se, "--n-button-border-color-active": fe, "--n-button-border-radius": oe, "--n-button-box-shadow": he, "--n-button-box-shadow-focus": be, "--n-button-box-shadow-hover": je, "--n-button-color": Ve, "--n-button-color-active": Ke, "--n-button-text-color": lt, "--n-button-text-color-hover": wt, "--n-button-text-color-active": vt, "--n-height": et, "--n-opacity-disabled": at };
  }), ee = T ? mi("radio-group", ze(() => l.value[0]), ie, r) : void 0;
  return { selfElRef: i, rtlEnabled: K, mergedClsPrefix: C, mergedValue: O, handleFocusout: W, handleFocusin: X, cssVars: T ? void 0 : ie, themeClass: ee == null ? void 0 : ee.themeClass, onRender: ee == null ? void 0 : ee.onRender };
}, render() {
  var r;
  const { mergedValue: i, mergedClsPrefix: l, handleFocusin: d, handleFocusout: f } = this, { children: g, isButtonGroup: m } = MP(kl(cp(this)), i, l);
  return (r = this.onRender) === null || r === void 0 || r.call(this), F("div", { onFocusin: d, onFocusout: f, ref: "selfElRef", class: [`${l}-radio-group`, this.rtlEnabled && `${l}-radio-group--rtl`, this.themeClass, m && `${l}-radio-group--button-group`], style: this.cssVars }, g);
} }), Tb = ue("ellipsis", { overflow: "hidden" }, [pi("line-clamp", `
 white-space: nowrap;
 display: inline-block;
 vertical-align: bottom;
 max-width: 100%;
 `), Ue("line-clamp", `
 display: -webkit-inline-box;
 -webkit-box-orient: vertical;
 `), Ue("cursor-pointer", `
 cursor: pointer;
 `)]);
function bg(r) {
  return `${r}-ellipsis--line-clamp`;
}
function xg(r, i) {
  return `${r}-ellipsis--cursor-${i}`;
}
const Ib = Object.assign(Object.assign({}, Kt.props), { expandTrigger: String, lineClamp: [Number, String], tooltip: { type: [Boolean, Object], default: true } }), AP = st({ name: "Ellipsis", inheritAttrs: false, props: Ib, slots: Object, setup(r, { slots: i, attrs: l }) {
  const d = Oy(), f = Kt("Ellipsis", "-ellipsis", Tb, T2, r, d), g = Ae(null), m = Ae(null), s = Ae(null), C = Ae(false), T = ze(() => {
    const { lineClamp: X } = r, { value: W } = C;
    return X !== void 0 ? { textOverflow: "", "-webkit-line-clamp": W ? "" : X } : { textOverflow: W ? "" : "ellipsis", "-webkit-line-clamp": "" };
  });
  function M() {
    let X = false;
    const { value: W } = C;
    if (W) return true;
    const { value: K } = g;
    if (K) {
      const { lineClamp: ie } = r;
      if (A(K), ie !== void 0) X = K.scrollHeight <= K.offsetHeight;
      else {
        const { value: ee } = m;
        ee && (X = ee.getBoundingClientRect().width <= K.getBoundingClientRect().width);
      }
      O(K, X);
    }
    return X;
  }
  const z = ze(() => r.expandTrigger === "click" ? () => {
    var X;
    const { value: W } = C;
    W && ((X = s.value) === null || X === void 0 || X.setShow(false)), C.value = !W;
  } : void 0);
  xy(() => {
    var X;
    r.tooltip && ((X = s.value) === null || X === void 0 || X.setShow(false));
  });
  const L = () => F("span", Object.assign({}, Ya(l, { class: [`${d.value}-ellipsis`, r.lineClamp !== void 0 ? bg(d.value) : void 0, r.expandTrigger === "click" ? xg(d.value, "pointer") : void 0], style: T.value }), { ref: "triggerRef", onClick: z.value, onMouseenter: r.expandTrigger === "click" ? M : void 0 }), r.lineClamp ? i : F("span", { ref: "triggerInnerRef" }, i));
  function A(X) {
    if (!X) return;
    const W = T.value, K = bg(d.value);
    r.lineClamp !== void 0 ? V(X, K, "add") : V(X, K, "remove");
    for (const ie in W) X.style[ie] !== W[ie] && (X.style[ie] = W[ie]);
  }
  function O(X, W) {
    const K = xg(d.value, "pointer");
    r.expandTrigger === "click" && !W ? V(X, K, "add") : V(X, K, "remove");
  }
  function V(X, W, K) {
    K === "add" ? X.classList.contains(W) || X.classList.add(W) : X.classList.contains(W) && X.classList.remove(W);
  }
  return { mergedTheme: f, triggerRef: g, triggerInnerRef: m, tooltipRef: s, handleClick: z, renderTrigger: L, getTooltipDisabled: M };
}, render() {
  var r;
  const { tooltip: i, renderTrigger: l, $slots: d } = this;
  if (i) {
    const { mergedTheme: f } = this;
    return F(By, Object.assign({ ref: "tooltipRef", placement: "top" }, i, { getDisabled: this.getTooltipDisabled, theme: f.peers.Tooltip, themeOverrides: f.peerOverrides.Tooltip }), { trigger: l, default: (r = d.tooltip) !== null && r !== void 0 ? r : d.default });
  } else return l();
} }), DP = st({ name: "PerformantEllipsis", props: Ib, inheritAttrs: false, setup(r, { attrs: i, slots: l }) {
  const d = Ae(false), f = Oy();
  return ac("-ellipsis", Tb, f), { mouseEntered: d, renderTrigger: () => {
    const { lineClamp: m } = r, s = f.value;
    return F("span", Object.assign({}, Ya(i, { class: [`${s}-ellipsis`, m !== void 0 ? bg(s) : void 0, r.expandTrigger === "click" ? xg(s, "pointer") : void 0], style: m === void 0 ? { textOverflow: "ellipsis" } : { "-webkit-line-clamp": m } }), { onMouseenter: () => {
      d.value = true;
    } }), m ? l : F("span", null, l));
  } };
}, render() {
  return this.mouseEntered ? F(AP, Ya({}, this.$attrs, this.$props), this.$slots) : this.renderTrigger();
} });
function Mb() {
  const r = fr(I2, null);
  return r === null && Zo("use-dialog", "No outer <n-dialog-provider /> founded."), r;
}
function hp() {
  const r = fr(M2, null);
  return r === null && Zo("use-message", "No outer <n-message-provider /> founded. See prerequisite in https://www.naiveui.com/en-US/os-theme/components/message for more details. If you want to use `useMessage` outside setup, please check https://www.naiveui.com/zh-CN/os-theme/components/message#Q-&-A."), r;
}
const zP = ue("divider", `
 position: relative;
 display: flex;
 width: 100%;
 box-sizing: border-box;
 font-size: 16px;
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
`, [pi("vertical", `
 margin-top: 24px;
 margin-bottom: 24px;
 `, [pi("no-title", `
 display: flex;
 align-items: center;
 `)]), Re("title", `
 display: flex;
 align-items: center;
 margin-left: 12px;
 margin-right: 12px;
 white-space: nowrap;
 font-weight: var(--n-font-weight);
 `), Ue("title-position-left", [Re("line", [Ue("left", { width: "28px" })])]), Ue("title-position-right", [Re("line", [Ue("right", { width: "28px" })])]), Ue("dashed", [Re("line", `
 background-color: #0000;
 height: 0px;
 width: 100%;
 border-style: dashed;
 border-width: 1px 0 0;
 `)]), Ue("vertical", `
 display: inline-block;
 height: 1em;
 margin: 0 8px;
 vertical-align: middle;
 width: 1px;
 `), Re("line", `
 border: none;
 transition: background-color .3s var(--n-bezier), border-color .3s var(--n-bezier);
 height: 1px;
 width: 100%;
 margin: 0;
 `), pi("dashed", [Re("line", { backgroundColor: "var(--n-color)" })]), Ue("dashed", [Re("line", { borderColor: "var(--n-color)" })]), Ue("vertical", { backgroundColor: "var(--n-color)" })]), FP = Object.assign(Object.assign({}, Kt.props), { titlePlacement: { type: String, default: "center" }, dashed: Boolean, vertical: Boolean }), LP = st({ name: "Divider", props: FP, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Tr(r), d = Kt("Divider", "-divider", zP, E2, r, i), f = ze(() => {
    const { common: { cubicBezierEaseInOut: m }, self: { color: s, textColor: C, fontWeight: T } } = d.value;
    return { "--n-bezier": m, "--n-color": s, "--n-text-color": C, "--n-font-weight": T };
  }), g = l ? mi("divider", void 0, f, r) : void 0;
  return { mergedClsPrefix: i, cssVars: l ? void 0 : f, themeClass: g == null ? void 0 : g.themeClass, onRender: g == null ? void 0 : g.onRender };
}, render() {
  var r;
  const { $slots: i, titlePlacement: l, vertical: d, dashed: f, cssVars: g, mergedClsPrefix: m } = this;
  return (r = this.onRender) === null || r === void 0 || r.call(this), F("div", { role: "separator", class: [`${m}-divider`, this.themeClass, { [`${m}-divider--vertical`]: d, [`${m}-divider--no-title`]: !i.default, [`${m}-divider--dashed`]: f, [`${m}-divider--title-position-${l}`]: i.default && l }], style: g }, d ? null : F("div", { class: `${m}-divider__line ${m}-divider__line--left` }), !d && i.default ? F(Gr, null, F("div", { class: `${m}-divider__title` }, this.$slots), F("div", { class: `${m}-divider__line ${m}-divider__line--right` })) : null);
} }), BP = st({ name: "NDrawerContent", inheritAttrs: false, props: { blockScroll: Boolean, show: { type: Boolean, default: void 0 }, displayDirective: { type: String, required: true }, placement: { type: String, required: true }, contentClass: String, contentStyle: [Object, String], nativeScrollbar: { type: Boolean, required: true }, scrollbarProps: Object, trapFocus: { type: Boolean, default: true }, autoFocus: { type: Boolean, default: true }, showMask: { type: [Boolean, String], required: true }, maxWidth: Number, maxHeight: Number, minWidth: Number, minHeight: Number, resizable: Boolean, onClickoutside: Function, onAfterLeave: Function, onAfterEnter: Function, onEsc: Function }, setup(r) {
  const i = Ae(!!r.show), l = Ae(null), d = fr(qg);
  let f = 0, g = "", m = null;
  const s = Ae(false), C = Ae(false), T = ze(() => r.placement === "top" || r.placement === "bottom"), { mergedClsPrefixRef: M, mergedRtlRef: z } = Tr(r), L = Rn("Drawer", z, M), A = J, O = (oe) => {
    C.value = true, f = T.value ? oe.clientY : oe.clientX, g = document.body.style.cursor, document.body.style.cursor = T.value ? "ns-resize" : "ew-resize", document.body.addEventListener("mousemove", re), document.body.addEventListener("mouseleave", A), document.body.addEventListener("mouseup", J);
  }, V = () => {
    m !== null && (window.clearTimeout(m), m = null), C.value ? s.value = true : m = window.setTimeout(() => {
      s.value = true;
    }, 300);
  }, X = () => {
    m !== null && (window.clearTimeout(m), m = null), s.value = false;
  }, { doUpdateHeight: W, doUpdateWidth: K } = d, ie = (oe) => {
    const { maxWidth: he } = r;
    if (he && oe > he) return he;
    const { minWidth: be } = r;
    return be && oe < be ? be : oe;
  }, ee = (oe) => {
    const { maxHeight: he } = r;
    if (he && oe > he) return he;
    const { minHeight: be } = r;
    return be && oe < be ? be : oe;
  };
  function re(oe) {
    var he, be;
    if (C.value) if (T.value) {
      let je = ((he = l.value) === null || he === void 0 ? void 0 : he.offsetHeight) || 0;
      const Ve = f - oe.clientY;
      je += r.placement === "bottom" ? Ve : -Ve, je = ee(je), W(je), f = oe.clientY;
    } else {
      let je = ((be = l.value) === null || be === void 0 ? void 0 : be.offsetWidth) || 0;
      const Ve = f - oe.clientX;
      je += r.placement === "right" ? Ve : -Ve, je = ie(je), K(je), f = oe.clientX;
    }
  }
  function J() {
    C.value && (f = 0, C.value = false, document.body.style.cursor = g, document.body.removeEventListener("mousemove", re), document.body.removeEventListener("mouseup", J), document.body.removeEventListener("mouseleave", A));
  }
  po(() => {
    r.show && (i.value = true);
  }), ar(() => r.show, (oe) => {
    oe || J();
  }), Sn(() => {
    J();
  });
  const Se = ze(() => {
    const { show: oe } = r, he = [[Ka, oe]];
    return r.showMask || he.push([qf, r.onClickoutside, void 0, { capture: true }]), he;
  });
  function fe() {
    var oe;
    i.value = false, (oe = r.onAfterLeave) === null || oe === void 0 || oe.call(r);
  }
  return A2(ze(() => r.blockScroll && i.value)), Yr(D2, l), Yr(z2, null), Yr(F2, null), { bodyRef: l, rtlEnabled: L, mergedClsPrefix: d.mergedClsPrefixRef, isMounted: d.isMountedRef, mergedTheme: d.mergedThemeRef, displayed: i, transitionName: ze(() => ({ right: "slide-in-from-right-transition", left: "slide-in-from-left-transition", top: "slide-in-from-top-transition", bottom: "slide-in-from-bottom-transition" })[r.placement]), handleAfterLeave: fe, bodyDirectives: Se, handleMousedownResizeTrigger: O, handleMouseenterResizeTrigger: V, handleMouseleaveResizeTrigger: X, isDragging: C, isHoverOnResizeTrigger: s };
}, render() {
  const { $slots: r, mergedClsPrefix: i } = this;
  return this.displayDirective === "show" || this.displayed || this.show ? ma(F("div", { role: "none" }, F(R2, { disabled: !this.showMask || !this.trapFocus, active: this.show, autoFocus: this.autoFocus, onEsc: this.onEsc }, { default: () => F(Io, { name: this.transitionName, appear: this.isMounted, onAfterEnter: this.onAfterEnter, onAfterLeave: this.handleAfterLeave }, { default: () => ma(F("div", Ya(this.$attrs, { role: "dialog", ref: "bodyRef", "aria-modal": "true", class: [`${i}-drawer`, this.rtlEnabled && `${i}-drawer--rtl`, `${i}-drawer--${this.placement}-placement`, this.isDragging && `${i}-drawer--unselectable`, this.nativeScrollbar && `${i}-drawer--native-scrollbar`] }), [this.resizable ? F("div", { class: [`${i}-drawer__resize-trigger`, (this.isDragging || this.isHoverOnResizeTrigger) && `${i}-drawer__resize-trigger--hover`], onMouseenter: this.handleMouseenterResizeTrigger, onMouseleave: this.handleMouseleaveResizeTrigger, onMousedown: this.handleMousedownResizeTrigger }) : null, this.nativeScrollbar ? F("div", { class: [`${i}-drawer-content-wrapper`, this.contentClass], style: this.contentStyle, role: "none" }, r) : F(th, Object.assign({}, this.scrollbarProps, { contentStyle: this.contentStyle, contentClass: [`${i}-drawer-content-wrapper`, this.contentClass], theme: this.mergedTheme.peers.Scrollbar, themeOverrides: this.mergedTheme.peerOverrides.Scrollbar }), r)]), this.bodyDirectives) }) })), [[Ka, this.displayDirective === "if" || this.displayed || this.show]]) : null;
} }), { cubicBezierEaseIn: OP, cubicBezierEaseOut: $P } = rh;
function jP({ duration: r = "0.3s", leaveDuration: i = "0.2s", name: l = "slide-in-from-bottom" } = {}) {
  return [Ge(`&.${l}-transition-leave-active`, { transition: `transform ${i} ${OP}` }), Ge(`&.${l}-transition-enter-active`, { transition: `transform ${r} ${$P}` }), Ge(`&.${l}-transition-enter-to`, { transform: "translateY(0)" }), Ge(`&.${l}-transition-enter-from`, { transform: "translateY(100%)" }), Ge(`&.${l}-transition-leave-from`, { transform: "translateY(0)" }), Ge(`&.${l}-transition-leave-to`, { transform: "translateY(100%)" })];
}
const { cubicBezierEaseIn: NP, cubicBezierEaseOut: VP } = rh;
function UP({ duration: r = "0.3s", leaveDuration: i = "0.2s", name: l = "slide-in-from-left" } = {}) {
  return [Ge(`&.${l}-transition-leave-active`, { transition: `transform ${i} ${NP}` }), Ge(`&.${l}-transition-enter-active`, { transition: `transform ${r} ${VP}` }), Ge(`&.${l}-transition-enter-to`, { transform: "translateX(0)" }), Ge(`&.${l}-transition-enter-from`, { transform: "translateX(-100%)" }), Ge(`&.${l}-transition-leave-from`, { transform: "translateX(0)" }), Ge(`&.${l}-transition-leave-to`, { transform: "translateX(-100%)" })];
}
const { cubicBezierEaseIn: qP, cubicBezierEaseOut: GP } = rh;
function WP({ duration: r = "0.3s", leaveDuration: i = "0.2s", name: l = "slide-in-from-right" } = {}) {
  return [Ge(`&.${l}-transition-leave-active`, { transition: `transform ${i} ${qP}` }), Ge(`&.${l}-transition-enter-active`, { transition: `transform ${r} ${GP}` }), Ge(`&.${l}-transition-enter-to`, { transform: "translateX(0)" }), Ge(`&.${l}-transition-enter-from`, { transform: "translateX(100%)" }), Ge(`&.${l}-transition-leave-from`, { transform: "translateX(0)" }), Ge(`&.${l}-transition-leave-to`, { transform: "translateX(100%)" })];
}
const { cubicBezierEaseIn: ZP, cubicBezierEaseOut: HP } = rh;
function XP({ duration: r = "0.3s", leaveDuration: i = "0.2s", name: l = "slide-in-from-top" } = {}) {
  return [Ge(`&.${l}-transition-leave-active`, { transition: `transform ${i} ${ZP}` }), Ge(`&.${l}-transition-enter-active`, { transition: `transform ${r} ${HP}` }), Ge(`&.${l}-transition-enter-to`, { transform: "translateY(0)" }), Ge(`&.${l}-transition-enter-from`, { transform: "translateY(-100%)" }), Ge(`&.${l}-transition-leave-from`, { transform: "translateY(0)" }), Ge(`&.${l}-transition-leave-to`, { transform: "translateY(-100%)" })];
}
const YP = Ge([ue("drawer", `
 word-break: break-word;
 line-height: var(--n-line-height);
 position: absolute;
 pointer-events: all;
 box-shadow: var(--n-box-shadow);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background-color: var(--n-color);
 color: var(--n-text-color);
 box-sizing: border-box;
 `, [WP(), UP(), XP(), jP(), Ue("unselectable", `
 user-select: none; 
 -webkit-user-select: none;
 `), Ue("native-scrollbar", [ue("drawer-content-wrapper", `
 overflow: auto;
 height: 100%;
 `)]), Re("resize-trigger", `
 position: absolute;
 background-color: #0000;
 transition: background-color .3s var(--n-bezier);
 `, [Ue("hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `)]), ue("drawer-content-wrapper", `
 box-sizing: border-box;
 `), ue("drawer-content", `
 height: 100%;
 display: flex;
 flex-direction: column;
 `, [Ue("native-scrollbar", [ue("drawer-body-content-wrapper", `
 height: 100%;
 overflow: auto;
 `)]), ue("drawer-body", `
 flex: 1 0 0;
 overflow: hidden;
 `), ue("drawer-body-content-wrapper", `
 box-sizing: border-box;
 padding: var(--n-body-padding);
 `), ue("drawer-header", `
 font-weight: var(--n-title-font-weight);
 line-height: 1;
 font-size: var(--n-title-font-size);
 color: var(--n-title-text-color);
 padding: var(--n-header-padding);
 transition: border .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-divider-color);
 border-bottom: var(--n-header-border-bottom);
 display: flex;
 justify-content: space-between;
 align-items: center;
 `, [Re("main", `
 flex: 1;
 `), Re("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), ue("drawer-footer", `
 display: flex;
 justify-content: flex-end;
 border-top: var(--n-footer-border-top);
 transition: border .3s var(--n-bezier);
 padding: var(--n-footer-padding);
 `)]), Ue("right-placement", `
 top: 0;
 bottom: 0;
 right: 0;
 border-top-left-radius: var(--n-border-radius);
 border-bottom-left-radius: var(--n-border-radius);
 `, [Re("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 left: 0;
 transform: translateX(-1.5px);
 cursor: ew-resize;
 `)]), Ue("left-placement", `
 top: 0;
 bottom: 0;
 left: 0;
 border-top-right-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [Re("resize-trigger", `
 width: 3px;
 height: 100%;
 top: 0;
 right: 0;
 transform: translateX(1.5px);
 cursor: ew-resize;
 `)]), Ue("top-placement", `
 top: 0;
 left: 0;
 right: 0;
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [Re("resize-trigger", `
 width: 100%;
 height: 3px;
 bottom: 0;
 left: 0;
 transform: translateY(1.5px);
 cursor: ns-resize;
 `)]), Ue("bottom-placement", `
 left: 0;
 bottom: 0;
 right: 0;
 border-top-left-radius: var(--n-border-radius);
 border-top-right-radius: var(--n-border-radius);
 `, [Re("resize-trigger", `
 width: 100%;
 height: 3px;
 top: 0;
 left: 0;
 transform: translateY(-1.5px);
 cursor: ns-resize;
 `)])]), Ge("body", [Ge(">", [ue("drawer-container", `
 position: fixed;
 `)])]), ue("drawer-container", `
 position: relative;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 `, [Ge("> *", `
 pointer-events: all;
 `)]), ue("drawer-mask", `
 background-color: rgba(0, 0, 0, .3);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [Ue("invisible", `
 background-color: rgba(0, 0, 0, 0)
 `), Wf({ enterDuration: "0.2s", leaveDuration: "0.2s", enterCubicBezier: "var(--n-bezier-in)", leaveCubicBezier: "var(--n-bezier-out)" })])]), KP = Object.assign(Object.assign({}, Kt.props), { show: Boolean, width: [Number, String], height: [Number, String], placement: { type: String, default: "right" }, maskClosable: { type: Boolean, default: true }, showMask: { type: [Boolean, String], default: true }, to: [String, Object], displayDirective: { type: String, default: "if" }, nativeScrollbar: { type: Boolean, default: true }, zIndex: Number, onMaskClick: Function, scrollbarProps: Object, contentClass: String, contentStyle: [Object, String], trapFocus: { type: Boolean, default: true }, onEsc: Function, autoFocus: { type: Boolean, default: true }, closeOnEsc: { type: Boolean, default: true }, blockScroll: { type: Boolean, default: true }, maxWidth: Number, maxHeight: Number, minWidth: Number, minHeight: Number, resizable: Boolean, defaultWidth: { type: [Number, String], default: 251 }, defaultHeight: { type: [Number, String], default: 251 }, onUpdateWidth: [Function, Array], onUpdateHeight: [Function, Array], "onUpdate:width": [Function, Array], "onUpdate:height": [Function, Array], "onUpdate:show": [Function, Array], onUpdateShow: [Function, Array], onAfterEnter: Function, onAfterLeave: Function, drawerStyle: [String, Object], drawerClass: String, target: null, onShow: Function, onHide: Function }), Eb = st({ name: "Drawer", inheritAttrs: false, props: KP, setup(r) {
  const { mergedClsPrefixRef: i, namespaceRef: l, inlineThemeDisabled: d } = Tr(r), f = lp(), g = Kt("Drawer", "-drawer", YP, L2, r, i), m = Ae(r.defaultWidth), s = Ae(r.defaultHeight), C = Zi(Dt(r, "width"), m), T = Zi(Dt(r, "height"), s), M = ze(() => {
    const { placement: J } = r;
    return J === "top" || J === "bottom" ? "" : Go(C.value);
  }), z = ze(() => {
    const { placement: J } = r;
    return J === "left" || J === "right" ? "" : Go(T.value);
  }), L = (J) => {
    const { onUpdateWidth: Se, "onUpdate:width": fe } = r;
    Se && Ot(Se, J), fe && Ot(fe, J), m.value = J;
  }, A = (J) => {
    const { onUpdateHeight: Se, "onUpdate:width": fe } = r;
    Se && Ot(Se, J), fe && Ot(fe, J), s.value = J;
  }, O = ze(() => [{ width: M.value, height: z.value }, r.drawerStyle || ""]);
  function V(J) {
    const { onMaskClick: Se, maskClosable: fe } = r;
    fe && ie(false), Se && Se(J);
  }
  function X(J) {
    V(J);
  }
  const W = B2();
  function K(J) {
    var Se;
    (Se = r.onEsc) === null || Se === void 0 || Se.call(r), r.show && r.closeOnEsc && O2(J) && (W.value || ie(false));
  }
  function ie(J) {
    const { onHide: Se, onUpdateShow: fe, "onUpdate:show": oe } = r;
    fe && Ot(fe, J), oe && Ot(oe, J), Se && !J && Ot(Se, J);
  }
  Yr(qg, { isMountedRef: f, mergedThemeRef: g, mergedClsPrefixRef: i, doUpdateShow: ie, doUpdateHeight: A, doUpdateWidth: L });
  const ee = ze(() => {
    const { common: { cubicBezierEaseInOut: J, cubicBezierEaseIn: Se, cubicBezierEaseOut: fe }, self: { color: oe, textColor: he, boxShadow: be, lineHeight: je, headerPadding: Ve, footerPadding: Ke, borderRadius: lt, bodyPadding: vt, titleFontSize: wt, titleTextColor: at, titleFontWeight: et, headerBorderBottom: ht, footerBorderTop: yt, closeIconColor: nt, closeIconColorHover: ut, closeIconColorPressed: Ft, closeColorHover: Ht, closeColorPressed: zt, closeIconSize: pr, closeSize: Qt, closeBorderRadius: tr, resizableTriggerColorHover: xr } } = g.value;
    return { "--n-line-height": je, "--n-color": oe, "--n-border-radius": lt, "--n-text-color": he, "--n-box-shadow": be, "--n-bezier": J, "--n-bezier-out": fe, "--n-bezier-in": Se, "--n-header-padding": Ve, "--n-body-padding": vt, "--n-footer-padding": Ke, "--n-title-text-color": at, "--n-title-font-size": wt, "--n-title-font-weight": et, "--n-header-border-bottom": ht, "--n-footer-border-top": yt, "--n-close-icon-color": nt, "--n-close-icon-color-hover": ut, "--n-close-icon-color-pressed": Ft, "--n-close-size": Qt, "--n-close-color-hover": Ht, "--n-close-color-pressed": zt, "--n-close-icon-size": pr, "--n-close-border-radius": tr, "--n-resize-trigger-color-hover": xr };
  }), re = d ? mi("drawer", void 0, ee, r) : void 0;
  return { mergedClsPrefix: i, namespace: l, mergedBodyStyle: O, handleOutsideClick: X, handleMaskClick: V, handleEsc: K, mergedTheme: g, cssVars: d ? void 0 : ee, themeClass: re == null ? void 0 : re.themeClass, onRender: re == null ? void 0 : re.onRender, isMounted: f };
}, render() {
  const { mergedClsPrefix: r } = this;
  return F(jy, { to: this.to, show: this.show }, { default: () => {
    var i;
    return (i = this.onRender) === null || i === void 0 || i.call(this), ma(F("div", { class: [`${r}-drawer-container`, this.namespace, this.themeClass], style: this.cssVars, role: "none" }, this.showMask ? F(Io, { name: "fade-in-transition", appear: this.isMounted }, { default: () => this.show ? F("div", { "aria-hidden": true, class: [`${r}-drawer-mask`, this.showMask === "transparent" && `${r}-drawer-mask--invisible`], onClick: this.handleMaskClick }) : null }) : null, F(BP, Object.assign({}, this.$attrs, { class: [this.drawerClass, this.$attrs.class], style: [this.mergedBodyStyle, this.$attrs.style], blockScroll: this.blockScroll, contentStyle: this.contentStyle, contentClass: this.contentClass, placement: this.placement, scrollbarProps: this.scrollbarProps, show: this.show, displayDirective: this.displayDirective, nativeScrollbar: this.nativeScrollbar, onAfterEnter: this.onAfterEnter, onAfterLeave: this.onAfterLeave, trapFocus: this.trapFocus, autoFocus: this.autoFocus, resizable: this.resizable, maxHeight: this.maxHeight, minHeight: this.minHeight, maxWidth: this.maxWidth, minWidth: this.minWidth, showMask: this.showMask, onEsc: this.handleEsc, onClickoutside: this.handleOutsideClick }), this.$slots)), [[$y, { zIndex: this.zIndex, enabled: this.show }]]);
  } });
} }), JP = { title: String, headerClass: String, headerStyle: [Object, String], footerClass: String, footerStyle: [Object, String], bodyClass: String, bodyStyle: [Object, String], bodyContentClass: String, bodyContentStyle: [Object, String], nativeScrollbar: { type: Boolean, default: true }, scrollbarProps: Object, closable: Boolean }, Rb = st({ name: "DrawerContent", props: JP, slots: Object, setup() {
  const r = fr(qg, null);
  r || Zo("drawer-content", "`n-drawer-content` must be placed inside `n-drawer`.");
  const { doUpdateShow: i } = r;
  function l() {
    i(false);
  }
  return { handleCloseClick: l, mergedTheme: r.mergedThemeRef, mergedClsPrefix: r.mergedClsPrefixRef };
}, render() {
  const { title: r, mergedClsPrefix: i, nativeScrollbar: l, mergedTheme: d, bodyClass: f, bodyStyle: g, bodyContentClass: m, bodyContentStyle: s, headerClass: C, headerStyle: T, footerClass: M, footerStyle: z, scrollbarProps: L, closable: A, $slots: O } = this;
  return F("div", { role: "none", class: [`${i}-drawer-content`, l && `${i}-drawer-content--native-scrollbar`] }, O.header || r || A ? F("div", { class: [`${i}-drawer-header`, C], style: T, role: "none" }, F("div", { class: `${i}-drawer-header__main`, role: "heading", "aria-level": "1" }, O.header !== void 0 ? O.header() : r), A && F(np, { onClick: this.handleCloseClick, clsPrefix: i, class: `${i}-drawer-header__close`, absolute: true })) : null, l ? F("div", { class: [`${i}-drawer-body`, f], style: g, role: "none" }, F("div", { class: [`${i}-drawer-body-content-wrapper`, m], style: s, role: "none" }, O)) : F(th, Object.assign({ themeOverrides: d.peerOverrides.Scrollbar, theme: d.peers.Scrollbar }, L, { class: `${i}-drawer-body`, contentClass: [`${i}-drawer-body-content-wrapper`, m], contentStyle: s }), O), O.footer ? F("div", { class: [`${i}-drawer-footer`, M], style: z, role: "none" }, O.footer()) : null);
} });
let Nm;
function QP() {
  if (!sp) return true;
  if (Nm === void 0) {
    const r = document.createElement("div");
    r.style.display = "flex", r.style.flexDirection = "column", r.style.rowGap = "1px", r.appendChild(document.createElement("div")), r.appendChild(document.createElement("div")), document.body.appendChild(r);
    const i = r.scrollHeight === 1;
    return document.body.removeChild(r), Nm = i;
  }
  return Nm;
}
const eT = Object.assign(Object.assign({}, Kt.props), { align: String, justify: { type: String, default: "start" }, inline: Boolean, vertical: Boolean, reverse: Boolean, size: { type: [String, Number, Array], default: "medium" }, wrapItem: { type: Boolean, default: true }, itemClass: String, itemStyle: [String, Object], wrap: { type: Boolean, default: true }, internalUseGap: { type: Boolean, default: void 0 } }), _l = st({ name: "Space", props: eT, setup(r) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Tr(r), d = Kt("Space", "-space", void 0, $2, r, i), f = Rn("Space", l, i);
  return { useGap: QP(), rtlEnabled: f, mergedClsPrefix: i, margin: ze(() => {
    const { size: g } = r;
    if (Array.isArray(g)) return { horizontal: g[0], vertical: g[1] };
    if (typeof g == "number") return { horizontal: g, vertical: g };
    const { self: { [jt("gap", g)]: m } } = d.value, { row: s, col: C } = Ny(m);
    return { horizontal: Ji(C), vertical: Ji(s) };
  }) };
}, render() {
  const { vertical: r, reverse: i, align: l, inline: d, justify: f, itemClass: g, itemStyle: m, margin: s, wrap: C, mergedClsPrefix: T, rtlEnabled: M, useGap: z, wrapItem: L, internalUseGap: A } = this, O = kl(cp(this), false);
  if (!O.length) return null;
  const V = `${s.horizontal}px`, X = `${s.horizontal / 2}px`, W = `${s.vertical}px`, K = `${s.vertical / 2}px`, ie = O.length - 1, ee = f.startsWith("space-");
  return F("div", { role: "none", class: [`${T}-space`, M && `${T}-space--rtl`], style: { display: d ? "inline-flex" : "flex", flexDirection: r && !i ? "column" : r && i ? "column-reverse" : !r && i ? "row-reverse" : "row", justifyContent: ["start", "end"].includes(f) ? `flex-${f}` : f, flexWrap: !C || r ? "nowrap" : "wrap", marginTop: z || r ? "" : `-${K}`, marginBottom: z || r ? "" : `-${K}`, alignItems: l, gap: z ? `${s.vertical}px ${s.horizontal}px` : "" } }, !L && (z || A) ? O : O.map((re, J) => re.type === Gw ? re : F("div", { role: "none", class: g, style: [m, { maxWidth: "100%" }, z ? "" : r ? { marginBottom: J !== ie ? W : "" } : M ? { marginLeft: ee ? f === "space-between" && J === ie ? "" : X : J !== ie ? V : "", marginRight: ee ? f === "space-between" && J === 0 ? "" : X : "", paddingTop: K, paddingBottom: K } : { marginRight: ee ? f === "space-between" && J === ie ? "" : X : J !== ie ? V : "", marginLeft: ee ? f === "space-between" && J === 0 ? "" : X : "", paddingTop: K, paddingBottom: K }] }, re)));
} }), tT = ue("dynamic-tags", [ue("input", { minWidth: "var(--n-input-width)" })]), rT = Object.assign(Object.assign(Object.assign({}, Kt.props), _b), { size: { type: String, default: "medium" }, closable: { type: Boolean, default: true }, defaultValue: { type: Array, default: () => [] }, value: Array, inputClass: String, inputStyle: [String, Object], inputProps: Object, max: Number, tagClass: String, tagStyle: [String, Object], renderTag: Function, onCreate: { type: Function, default: (r) => r }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onChange: [Function, Array] }), iT = st({ name: "DynamicTags", props: rT, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Tr(r), { localeRef: d } = Ja("DynamicTags"), f = va(r), { mergedDisabledRef: g } = f, m = Ae(""), s = Ae(false), C = Ae(true), T = Ae(null), M = Kt("DynamicTags", "-dynamic-tags", tT, j2, r, i), z = Ae(r.defaultValue), L = Dt(r, "value"), A = Zi(L, z), O = ze(() => d.value.add), V = ze(() => Q3(r.size)), X = ze(() => g.value || !!r.max && A.value.length >= r.max);
  function W(oe) {
    const { onChange: he, "onUpdate:value": be, onUpdateValue: je } = r, { nTriggerFormInput: Ve, nTriggerFormChange: Ke } = f;
    he && Ot(he, oe), je && Ot(je, oe), be && Ot(be, oe), z.value = oe, Ve(), Ke();
  }
  function K(oe) {
    const he = A.value.slice(0);
    he.splice(oe, 1), W(he);
  }
  function ie(oe) {
    switch (oe.key) {
      case "Enter":
        ee();
    }
  }
  function ee(oe) {
    const he = oe ?? m.value;
    if (he) {
      const be = A.value.slice(0);
      be.push(r.onCreate(he)), W(be);
    }
    s.value = false, C.value = true, m.value = "";
  }
  function re() {
    ee();
  }
  function J() {
    s.value = true, Vn(() => {
      var oe;
      (oe = T.value) === null || oe === void 0 || oe.focus(), C.value = false;
    });
  }
  const Se = ze(() => {
    const { self: { inputWidth: oe } } = M.value;
    return { "--n-input-width": oe };
  }), fe = l ? mi("dynamic-tags", void 0, Se, r) : void 0;
  return { mergedClsPrefix: i, inputInstRef: T, localizedAdd: O, inputSize: V, inputValue: m, showInput: s, inputForceFocused: C, mergedValue: A, mergedDisabled: g, triggerDisabled: X, handleInputKeyDown: ie, handleAddClick: J, handleInputBlur: re, handleCloseClick: K, handleInputConfirm: ee, mergedTheme: M, cssVars: l ? void 0 : Se, themeClass: fe == null ? void 0 : fe.themeClass, onRender: fe == null ? void 0 : fe.onRender };
}, render() {
  const { mergedTheme: r, cssVars: i, mergedClsPrefix: l, onRender: d, renderTag: f } = this;
  return d == null ? void 0 : d(), F(_l, { class: [`${l}-dynamic-tags`, this.themeClass], size: "small", style: i, theme: r.peers.Space, themeOverrides: r.peerOverrides.Space, itemStyle: "display: flex;" }, { default: () => {
    const { mergedTheme: g, tagClass: m, tagStyle: s, type: C, round: T, size: M, color: z, closable: L, mergedDisabled: A, showInput: O, inputValue: V, inputClass: X, inputStyle: W, inputSize: K, inputForceFocused: ie, triggerDisabled: ee, handleInputKeyDown: re, handleInputBlur: J, handleAddClick: Se, handleCloseClick: fe, handleInputConfirm: oe, $slots: he } = this;
    return this.mergedValue.map((be, je) => f ? f(be, je) : F(Mo, { key: je, theme: g.peers.Tag, themeOverrides: g.peerOverrides.Tag, class: m, style: s, type: C, round: T, size: M, color: z, closable: L, disabled: A, onClose: () => {
      fe(je);
    } }, { default: () => typeof be == "string" ? be : be.label })).concat(O ? he.input ? he.input({ submit: oe, deactivate: J }) : F(ho, Object.assign({ placeholder: "", size: K, style: W, class: X, autosize: true }, this.inputProps, { ref: "inputInstRef", value: V, onUpdateValue: (be) => {
      this.inputValue = be;
    }, theme: g.peers.Input, themeOverrides: g.peerOverrides.Input, onKeydown: re, onBlur: J, internalForceFocus: ie })) : he.trigger ? he.trigger({ activate: Se, disabled: ee }) : F(Vr, { dashed: true, disabled: ee, theme: g.peers.Button, themeOverrides: g.peerOverrides.Button, size: K, onClick: Se }, { icon: () => F(Nr, { clsPrefix: l }, { default: () => F(dp, null) }) }));
  } });
} }), nT = Object.assign(Object.assign({}, Kt.props), { align: String, justify: { type: String, default: "start" }, inline: Boolean, vertical: Boolean, reverse: Boolean, size: { type: [String, Number, Array], default: "medium" }, wrap: { type: Boolean, default: true } }), f_ = st({ name: "Flex", props: nT, setup(r) {
  const { mergedClsPrefixRef: i, mergedRtlRef: l } = Tr(r), d = Kt("Flex", "-flex", void 0, N2, r, i);
  return { rtlEnabled: Rn("Flex", l, i), mergedClsPrefix: i, margin: ze(() => {
    const { size: g } = r;
    if (Array.isArray(g)) return { horizontal: g[0], vertical: g[1] };
    if (typeof g == "number") return { horizontal: g, vertical: g };
    const { self: { [jt("gap", g)]: m } } = d.value, { row: s, col: C } = Ny(m);
    return { horizontal: Ji(C), vertical: Ji(s) };
  }) };
}, render() {
  const { vertical: r, reverse: i, align: l, inline: d, justify: f, margin: g, wrap: m, mergedClsPrefix: s, rtlEnabled: C } = this, T = kl(cp(this), false);
  return T.length ? F("div", { role: "none", class: [`${s}-flex`, C && `${s}-flex--rtl`], style: { display: d ? "inline-flex" : "flex", flexDirection: r && !i ? "column" : r && i ? "column-reverse" : !r && i ? "row-reverse" : "row", justifyContent: f, flexWrap: !m || r ? "nowrap" : "wrap", alignItems: l, gap: `${g.vertical}px ${g.horizontal}px` } }, T) : null;
} }), ih = An("n-form"), Ab = An("n-form-item-insts"), oT = ue("form", [Ue("inline", `
 width: 100%;
 display: inline-flex;
 align-items: flex-start;
 align-content: space-around;
 `, [ue("form-item", { width: "auto", marginRight: "18px" }, [Ge("&:last-child", { marginRight: 0 })])])]);
var aT = function(r, i, l, d) {
  function f(g) {
    return g instanceof l ? g : new l(function(m) {
      m(g);
    });
  }
  return new (l || (l = Promise))(function(g, m) {
    function s(M) {
      try {
        T(d.next(M));
      } catch (z) {
        m(z);
      }
    }
    function C(M) {
      try {
        T(d.throw(M));
      } catch (z) {
        m(z);
      }
    }
    function T(M) {
      M.done ? g(M.value) : f(M.value).then(s, C);
    }
    T((d = d.apply(r, i || [])).next());
  });
};
const sT = Object.assign(Object.assign({}, Kt.props), { inline: Boolean, labelWidth: [Number, String], labelAlign: String, labelPlacement: { type: String, default: "top" }, model: { type: Object, default: () => {
} }, rules: Object, disabled: Boolean, size: String, showRequireMark: { type: Boolean, default: void 0 }, requireMarkPlacement: String, showFeedback: { type: Boolean, default: true }, onSubmit: { type: Function, default: (r) => {
  r.preventDefault();
} }, showLabel: { type: Boolean, default: void 0 }, validateMessages: Object }), Wd = st({ name: "Form", props: sT, setup(r) {
  const { mergedClsPrefixRef: i } = Tr(r);
  Kt("Form", "-form", oT, Vy, r, i);
  const l = {}, d = Ae(void 0), f = (C) => {
    const T = d.value;
    (T === void 0 || C >= T) && (d.value = C);
  };
  function g(C) {
    return aT(this, arguments, void 0, function* (T, M = () => true) {
      return yield new Promise((z, L) => {
        const A = [];
        for (const O of jd(l)) {
          const V = l[O];
          for (const X of V) X.path && A.push(X.internalValidate(null, M));
        }
        Promise.all(A).then((O) => {
          const V = O.some((K) => !K.valid), X = [], W = [];
          O.forEach((K) => {
            var ie, ee;
            !((ie = K.errors) === null || ie === void 0) && ie.length && X.push(K.errors), !((ee = K.warnings) === null || ee === void 0) && ee.length && W.push(K.warnings);
          }), T && T(X.length ? X : void 0, { warnings: W.length ? W : void 0 }), V ? L(X.length ? X : void 0) : z({ warnings: W.length ? W : void 0 });
        });
      });
    });
  }
  function m() {
    for (const C of jd(l)) {
      const T = l[C];
      for (const M of T) M.restoreValidation();
    }
  }
  return Yr(ih, { props: r, maxChildLabelWidthRef: d, deriveMaxChildLabelWidth: f }), Yr(Ab, { formItems: l }), Object.assign({ validate: g, restoreValidation: m }, { mergedClsPrefix: i });
}, render() {
  const { mergedClsPrefix: r } = this;
  return F("form", { class: [`${r}-form`, this.inline && `${r}-form--inline`], onSubmit: this.onSubmit }, this.$slots);
} });
function yl() {
  return yl = Object.assign ? Object.assign.bind() : function(r) {
    for (var i = 1; i < arguments.length; i++) {
      var l = arguments[i];
      for (var d in l) Object.prototype.hasOwnProperty.call(l, d) && (r[d] = l[d]);
    }
    return r;
  }, yl.apply(this, arguments);
}
function lT(r, i) {
  r.prototype = Object.create(i.prototype), r.prototype.constructor = r, Zd(r, i);
}
function wg(r) {
  return wg = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
    return l.__proto__ || Object.getPrototypeOf(l);
  }, wg(r);
}
function Zd(r, i) {
  return Zd = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, f) {
    return d.__proto__ = f, d;
  }, Zd(r, i);
}
function uT() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return false;
  if (typeof Proxy == "function") return true;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), true;
  } catch {
    return false;
  }
}
function Of(r, i, l) {
  return uT() ? Of = Reflect.construct.bind() : Of = function(f, g, m) {
    var s = [null];
    s.push.apply(s, g);
    var C = Function.bind.apply(f, s), T = new C();
    return m && Zd(T, m.prototype), T;
  }, Of.apply(null, arguments);
}
function cT(r) {
  return Function.toString.call(r).indexOf("[native code]") !== -1;
}
function Cg(r) {
  var i = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return Cg = function(d) {
    if (d === null || !cT(d)) return d;
    if (typeof d != "function") throw new TypeError("Super expression must either be null or a function");
    if (typeof i < "u") {
      if (i.has(d)) return i.get(d);
      i.set(d, f);
    }
    function f() {
      return Of(d, arguments, wg(this).constructor);
    }
    return f.prototype = Object.create(d.prototype, { constructor: { value: f, enumerable: false, writable: true, configurable: true } }), Zd(f, d);
  }, Cg(r);
}
var dT = /%[sdj%]/g, hT = function() {
};
function Sg(r) {
  if (!r || !r.length) return null;
  var i = {};
  return r.forEach(function(l) {
    var d = l.field;
    i[d] = i[d] || [], i[d].push(l);
  }), i;
}
function fo(r) {
  for (var i = arguments.length, l = new Array(i > 1 ? i - 1 : 0), d = 1; d < i; d++) l[d - 1] = arguments[d];
  var f = 0, g = l.length;
  if (typeof r == "function") return r.apply(null, l);
  if (typeof r == "string") {
    var m = r.replace(dT, function(s) {
      if (s === "%%") return "%";
      if (f >= g) return s;
      switch (s) {
        case "%s":
          return String(l[f++]);
        case "%d":
          return Number(l[f++]);
        case "%j":
          try {
            return JSON.stringify(l[f++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return s;
      }
    });
    return m;
  }
  return r;
}
function fT(r) {
  return r === "string" || r === "url" || r === "hex" || r === "email" || r === "date" || r === "pattern";
}
function en(r, i) {
  return !!(r == null || i === "array" && Array.isArray(r) && !r.length || fT(i) && typeof r == "string" && !r);
}
function pT(r, i, l) {
  var d = [], f = 0, g = r.length;
  function m(s) {
    d.push.apply(d, s || []), f++, f === g && l(d);
  }
  r.forEach(function(s) {
    i(s, m);
  });
}
function p_(r, i, l) {
  var d = 0, f = r.length;
  function g(m) {
    if (m && m.length) {
      l(m);
      return;
    }
    var s = d;
    d = d + 1, s < f ? i(r[s], g) : l([]);
  }
  g([]);
}
function mT(r) {
  var i = [];
  return Object.keys(r).forEach(function(l) {
    i.push.apply(i, r[l] || []);
  }), i;
}
var m_ = (function(r) {
  lT(i, r);
  function i(l, d) {
    var f;
    return f = r.call(this, "Async Validation Error") || this, f.errors = l, f.fields = d, f;
  }
  return i;
})(Cg(Error));
function gT(r, i, l, d, f) {
  if (i.first) {
    var g = new Promise(function(L, A) {
      var O = function(W) {
        return d(W), W.length ? A(new m_(W, Sg(W))) : L(f);
      }, V = mT(r);
      p_(V, l, O);
    });
    return g.catch(function(L) {
      return L;
    }), g;
  }
  var m = i.firstFields === true ? Object.keys(r) : i.firstFields || [], s = Object.keys(r), C = s.length, T = 0, M = [], z = new Promise(function(L, A) {
    var O = function(X) {
      if (M.push.apply(M, X), T++, T === C) return d(M), M.length ? A(new m_(M, Sg(M))) : L(f);
    };
    s.length || (d(M), L(f)), s.forEach(function(V) {
      var X = r[V];
      m.indexOf(V) !== -1 ? p_(X, l, O) : pT(X, l, O);
    });
  });
  return z.catch(function(L) {
    return L;
  }), z;
}
function vT(r) {
  return !!(r && r.message !== void 0);
}
function _T(r, i) {
  for (var l = r, d = 0; d < i.length; d++) {
    if (l == null) return l;
    l = l[i[d]];
  }
  return l;
}
function g_(r, i) {
  return function(l) {
    var d;
    return r.fullFields ? d = _T(i, r.fullFields) : d = i[l.field || r.fullField], vT(l) ? (l.field = l.field || r.fullField, l.fieldValue = d, l) : { message: typeof l == "function" ? l() : l, fieldValue: d, field: l.field || r.fullField };
  };
}
function v_(r, i) {
  if (i) {
    for (var l in i) if (i.hasOwnProperty(l)) {
      var d = i[l];
      typeof d == "object" && typeof r[l] == "object" ? r[l] = yl({}, r[l], d) : r[l] = d;
    }
  }
  return r;
}
var Db = function(i, l, d, f, g, m) {
  i.required && (!d.hasOwnProperty(i.field) || en(l, m || i.type)) && f.push(fo(g.messages.required, i.fullField));
}, yT = function(i, l, d, f, g) {
  (/^\s+$/.test(l) || l === "") && f.push(fo(g.messages.whitespace, i.fullField));
}, Sf, bT = (function() {
  if (Sf) return Sf;
  var r = "[a-fA-F\\d:]", i = function(ee) {
    return ee && ee.includeBoundaries ? "(?:(?<=\\s|^)(?=" + r + ")|(?<=" + r + ")(?=\\s|$))" : "";
  }, l = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", d = "[a-fA-F\\d]{1,4}", f = (`
(?:
(?:` + d + ":){7}(?:" + d + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + d + ":){6}(?:" + l + "|:" + d + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + d + ":){5}(?::" + l + "|(?::" + d + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + d + ":){4}(?:(?::" + d + "){0,1}:" + l + "|(?::" + d + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + d + ":){3}(?:(?::" + d + "){0,2}:" + l + "|(?::" + d + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + d + ":){2}(?:(?::" + d + "){0,3}:" + l + "|(?::" + d + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + d + ":){1}(?:(?::" + d + "){0,4}:" + l + "|(?::" + d + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + d + "){0,5}:" + l + "|(?::" + d + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), g = new RegExp("(?:^" + l + "$)|(?:^" + f + "$)"), m = new RegExp("^" + l + "$"), s = new RegExp("^" + f + "$"), C = function(ee) {
    return ee && ee.exact ? g : new RegExp("(?:" + i(ee) + l + i(ee) + ")|(?:" + i(ee) + f + i(ee) + ")", "g");
  };
  C.v4 = function(ie) {
    return ie && ie.exact ? m : new RegExp("" + i(ie) + l + i(ie), "g");
  }, C.v6 = function(ie) {
    return ie && ie.exact ? s : new RegExp("" + i(ie) + f + i(ie), "g");
  };
  var T = "(?:(?:[a-z]+:)?//)", M = "(?:\\S+(?::\\S*)?@)?", z = C.v4().source, L = C.v6().source, A = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", O = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", V = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", X = "(?::\\d{2,5})?", W = '(?:[/?#][^\\s"]*)?', K = "(?:" + T + "|www\\.)" + M + "(?:localhost|" + z + "|" + L + "|" + A + O + V + ")" + X + W;
  return Sf = new RegExp("(?:^" + K + "$)", "i"), Sf;
}), __ = { email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/, hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i }, Ed = { integer: function(i) {
  return Ed.number(i) && parseInt(i, 10) === i;
}, float: function(i) {
  return Ed.number(i) && !Ed.integer(i);
}, array: function(i) {
  return Array.isArray(i);
}, regexp: function(i) {
  if (i instanceof RegExp) return true;
  try {
    return !!new RegExp(i);
  } catch {
    return false;
  }
}, date: function(i) {
  return typeof i.getTime == "function" && typeof i.getMonth == "function" && typeof i.getYear == "function" && !isNaN(i.getTime());
}, number: function(i) {
  return isNaN(i) ? false : typeof i == "number";
}, object: function(i) {
  return typeof i == "object" && !Ed.array(i);
}, method: function(i) {
  return typeof i == "function";
}, email: function(i) {
  return typeof i == "string" && i.length <= 320 && !!i.match(__.email);
}, url: function(i) {
  return typeof i == "string" && i.length <= 2048 && !!i.match(bT());
}, hex: function(i) {
  return typeof i == "string" && !!i.match(__.hex);
} }, xT = function(i, l, d, f, g) {
  if (i.required && l === void 0) {
    Db(i, l, d, f, g);
    return;
  }
  var m = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], s = i.type;
  m.indexOf(s) > -1 ? Ed[s](l) || f.push(fo(g.messages.types[s], i.fullField, i.type)) : s && typeof l !== i.type && f.push(fo(g.messages.types[s], i.fullField, i.type));
}, wT = function(i, l, d, f, g) {
  var m = typeof i.len == "number", s = typeof i.min == "number", C = typeof i.max == "number", T = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, M = l, z = null, L = typeof l == "number", A = typeof l == "string", O = Array.isArray(l);
  if (L ? z = "number" : A ? z = "string" : O && (z = "array"), !z) return false;
  O && (M = l.length), A && (M = l.replace(T, "_").length), m ? M !== i.len && f.push(fo(g.messages[z].len, i.fullField, i.len)) : s && !C && M < i.min ? f.push(fo(g.messages[z].min, i.fullField, i.min)) : C && !s && M > i.max ? f.push(fo(g.messages[z].max, i.fullField, i.max)) : s && C && (M < i.min || M > i.max) && f.push(fo(g.messages[z].range, i.fullField, i.min, i.max));
}, Uu = "enum", CT = function(i, l, d, f, g) {
  i[Uu] = Array.isArray(i[Uu]) ? i[Uu] : [], i[Uu].indexOf(l) === -1 && f.push(fo(g.messages[Uu], i.fullField, i[Uu].join(", ")));
}, ST = function(i, l, d, f, g) {
  if (i.pattern) {
    if (i.pattern instanceof RegExp) i.pattern.lastIndex = 0, i.pattern.test(l) || f.push(fo(g.messages.pattern.mismatch, i.fullField, l, i.pattern));
    else if (typeof i.pattern == "string") {
      var m = new RegExp(i.pattern);
      m.test(l) || f.push(fo(g.messages.pattern.mismatch, i.fullField, l, i.pattern));
    }
  }
}, Lr = { required: Db, whitespace: yT, type: xT, range: wT, enum: CT, pattern: ST }, kT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l, "string") && !i.required) return d();
    Lr.required(i, l, f, m, g, "string"), en(l, "string") || (Lr.type(i, l, f, m, g), Lr.range(i, l, f, m, g), Lr.pattern(i, l, f, m, g), i.whitespace === true && Lr.whitespace(i, l, f, m, g));
  }
  d(m);
}, PT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l) && !i.required) return d();
    Lr.required(i, l, f, m, g), l !== void 0 && Lr.type(i, l, f, m, g);
  }
  d(m);
}, TT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (l === "" && (l = void 0), en(l) && !i.required) return d();
    Lr.required(i, l, f, m, g), l !== void 0 && (Lr.type(i, l, f, m, g), Lr.range(i, l, f, m, g));
  }
  d(m);
}, IT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l) && !i.required) return d();
    Lr.required(i, l, f, m, g), l !== void 0 && Lr.type(i, l, f, m, g);
  }
  d(m);
}, MT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l) && !i.required) return d();
    Lr.required(i, l, f, m, g), en(l) || Lr.type(i, l, f, m, g);
  }
  d(m);
}, ET = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l) && !i.required) return d();
    Lr.required(i, l, f, m, g), l !== void 0 && (Lr.type(i, l, f, m, g), Lr.range(i, l, f, m, g));
  }
  d(m);
}, RT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l) && !i.required) return d();
    Lr.required(i, l, f, m, g), l !== void 0 && (Lr.type(i, l, f, m, g), Lr.range(i, l, f, m, g));
  }
  d(m);
}, AT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (l == null && !i.required) return d();
    Lr.required(i, l, f, m, g, "array"), l != null && (Lr.type(i, l, f, m, g), Lr.range(i, l, f, m, g));
  }
  d(m);
}, DT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l) && !i.required) return d();
    Lr.required(i, l, f, m, g), l !== void 0 && Lr.type(i, l, f, m, g);
  }
  d(m);
}, zT = "enum", FT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l) && !i.required) return d();
    Lr.required(i, l, f, m, g), l !== void 0 && Lr[zT](i, l, f, m, g);
  }
  d(m);
}, LT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l, "string") && !i.required) return d();
    Lr.required(i, l, f, m, g), en(l, "string") || Lr.pattern(i, l, f, m, g);
  }
  d(m);
}, BT = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l, "date") && !i.required) return d();
    if (Lr.required(i, l, f, m, g), !en(l, "date")) {
      var C;
      l instanceof Date ? C = l : C = new Date(l), Lr.type(i, C, f, m, g), C && Lr.range(i, C.getTime(), f, m, g);
    }
  }
  d(m);
}, OT = function(i, l, d, f, g) {
  var m = [], s = Array.isArray(l) ? "array" : typeof l;
  Lr.required(i, l, f, m, g, s), d(m);
}, Vm = function(i, l, d, f, g) {
  var m = i.type, s = [], C = i.required || !i.required && f.hasOwnProperty(i.field);
  if (C) {
    if (en(l, m) && !i.required) return d();
    Lr.required(i, l, f, s, g, m), en(l, m) || Lr.type(i, l, f, s, g);
  }
  d(s);
}, $T = function(i, l, d, f, g) {
  var m = [], s = i.required || !i.required && f.hasOwnProperty(i.field);
  if (s) {
    if (en(l) && !i.required) return d();
    Lr.required(i, l, f, m, g);
  }
  d(m);
}, Ld = { string: kT, method: PT, number: TT, boolean: IT, regexp: MT, integer: ET, float: RT, array: AT, object: DT, enum: FT, pattern: LT, date: BT, url: Vm, hex: Vm, email: Vm, required: OT, any: $T };
function kg() {
  return { default: "Validation error on field %s", required: "%s is required", enum: "%s must be one of %s", whitespace: "%s cannot be empty", date: { format: "%s date %s is invalid for format %s", parse: "%s date could not be parsed, %s is invalid ", invalid: "%s date %s is invalid" }, types: { string: "%s is not a %s", method: "%s is not a %s (function)", array: "%s is not an %s", object: "%s is not an %s", number: "%s is not a %s", date: "%s is not a %s", boolean: "%s is not a %s", integer: "%s is not an %s", float: "%s is not a %s", regexp: "%s is not a valid %s", email: "%s is not a valid %s", url: "%s is not a valid %s", hex: "%s is not a valid %s" }, string: { len: "%s must be exactly %s characters", min: "%s must be at least %s characters", max: "%s cannot be longer than %s characters", range: "%s must be between %s and %s characters" }, number: { len: "%s must equal %s", min: "%s cannot be less than %s", max: "%s cannot be greater than %s", range: "%s must be between %s and %s" }, array: { len: "%s must be exactly %s in length", min: "%s cannot be less than %s in length", max: "%s cannot be greater than %s in length", range: "%s must be between %s and %s in length" }, pattern: { mismatch: "%s value %s does not match pattern %s" }, clone: function() {
    var i = JSON.parse(JSON.stringify(this));
    return i.clone = this.clone, i;
  } };
}
var Pg = kg(), Qu = (function() {
  function r(l) {
    this.rules = null, this._messages = Pg, this.define(l);
  }
  var i = r.prototype;
  return i.define = function(d) {
    var f = this;
    if (!d) throw new Error("Cannot configure a schema with no rules");
    if (typeof d != "object" || Array.isArray(d)) throw new Error("Rules must be an object");
    this.rules = {}, Object.keys(d).forEach(function(g) {
      var m = d[g];
      f.rules[g] = Array.isArray(m) ? m : [m];
    });
  }, i.messages = function(d) {
    return d && (this._messages = v_(kg(), d)), this._messages;
  }, i.validate = function(d, f, g) {
    var m = this;
    f === void 0 && (f = {}), g === void 0 && (g = function() {
    });
    var s = d, C = f, T = g;
    if (typeof C == "function" && (T = C, C = {}), !this.rules || Object.keys(this.rules).length === 0) return T && T(null, s), Promise.resolve(s);
    function M(V) {
      var X = [], W = {};
      function K(ee) {
        if (Array.isArray(ee)) {
          var re;
          X = (re = X).concat.apply(re, ee);
        } else X.push(ee);
      }
      for (var ie = 0; ie < V.length; ie++) K(V[ie]);
      X.length ? (W = Sg(X), T(X, W)) : T(null, s);
    }
    if (C.messages) {
      var z = this.messages();
      z === Pg && (z = kg()), v_(z, C.messages), C.messages = z;
    } else C.messages = this.messages();
    var L = {}, A = C.keys || Object.keys(this.rules);
    A.forEach(function(V) {
      var X = m.rules[V], W = s[V];
      X.forEach(function(K) {
        var ie = K;
        typeof ie.transform == "function" && (s === d && (s = yl({}, s)), W = s[V] = ie.transform(W)), typeof ie == "function" ? ie = { validator: ie } : ie = yl({}, ie), ie.validator = m.getValidationMethod(ie), ie.validator && (ie.field = V, ie.fullField = ie.fullField || V, ie.type = m.getType(ie), L[V] = L[V] || [], L[V].push({ rule: ie, value: W, source: s, field: V }));
      });
    });
    var O = {};
    return gT(L, C, function(V, X) {
      var _a3;
      var W = V.rule, K = (W.type === "object" || W.type === "array") && (typeof W.fields == "object" || typeof W.defaultField == "object");
      K = K && (W.required || !W.required && V.value), W.field = V.field;
      function ie(J, Se) {
        return yl({}, Se, { fullField: W.fullField + "." + J, fullFields: W.fullFields ? [].concat(W.fullFields, [J]) : [J] });
      }
      function ee(J) {
        J === void 0 && (J = []);
        var Se = Array.isArray(J) ? J : [J];
        !C.suppressWarning && Se.length && r.warning("async-validator:", Se), Se.length && W.message !== void 0 && (Se = [].concat(W.message));
        var fe = Se.map(g_(W, s));
        if (C.first && fe.length) return O[W.field] = 1, X(fe);
        if (!K) X(fe);
        else {
          if (W.required && !V.value) return W.message !== void 0 ? fe = [].concat(W.message).map(g_(W, s)) : C.error && (fe = [C.error(W, fo(C.messages.required, W.field))]), X(fe);
          var oe = {};
          W.defaultField && Object.keys(V.value).map(function(je) {
            oe[je] = W.defaultField;
          }), oe = yl({}, oe, V.rule.fields);
          var he = {};
          Object.keys(oe).forEach(function(je) {
            var Ve = oe[je], Ke = Array.isArray(Ve) ? Ve : [Ve];
            he[je] = Ke.map(ie.bind(null, je));
          });
          var be = new r(he);
          be.messages(C.messages), V.rule.options && (V.rule.options.messages = C.messages, V.rule.options.error = C.error), be.validate(V.value, V.rule.options || C, function(je) {
            var Ve = [];
            fe && fe.length && Ve.push.apply(Ve, fe), je && je.length && Ve.push.apply(Ve, je), X(Ve.length ? Ve : null);
          });
        }
      }
      var re;
      if (W.asyncValidator) re = W.asyncValidator(W, V.value, ee, V.source, C);
      else if (W.validator) {
        try {
          re = W.validator(W, V.value, ee, V.source, C);
        } catch (J) {
          (_a3 = console.error) == null ? void 0 : _a3.call(console, J), C.suppressValidatorError || setTimeout(function() {
            throw J;
          }, 0), ee(J.message);
        }
        re === true ? ee() : re === false ? ee(typeof W.message == "function" ? W.message(W.fullField || W.field) : W.message || (W.fullField || W.field) + " fails") : re instanceof Array ? ee(re) : re instanceof Error && ee(re.message);
      }
      re && re.then && re.then(function() {
        return ee();
      }, function(J) {
        return ee(J);
      });
    }, function(V) {
      M(V);
    }, s);
  }, i.getType = function(d) {
    if (d.type === void 0 && d.pattern instanceof RegExp && (d.type = "pattern"), typeof d.validator != "function" && d.type && !Ld.hasOwnProperty(d.type)) throw new Error(fo("Unknown rule type %s", d.type));
    return d.type || "string";
  }, i.getValidationMethod = function(d) {
    if (typeof d.validator == "function") return d.validator;
    var f = Object.keys(d), g = f.indexOf("message");
    return g !== -1 && f.splice(g, 1), f.length === 1 && f[0] === "required" ? Ld.required : Ld[this.getType(d)] || void 0;
  }, r;
})();
Qu.register = function(i, l) {
  if (typeof l != "function") throw new Error("Cannot register a validator by type, validator is not a function");
  Ld[i] = l;
};
Qu.warning = hT;
Qu.messages = Pg;
Qu.validators = Ld;
const { cubicBezierEaseInOut: y_ } = rh;
function jT({ name: r = "fade-down", fromOffset: i = "-4px", enterDuration: l = ".3s", leaveDuration: d = ".3s", enterCubicBezier: f = y_, leaveCubicBezier: g = y_ } = {}) {
  return [Ge(`&.${r}-transition-enter-from, &.${r}-transition-leave-to`, { opacity: 0, transform: `translateY(${i})` }), Ge(`&.${r}-transition-enter-to, &.${r}-transition-leave-from`, { opacity: 1, transform: "translateY(0)" }), Ge(`&.${r}-transition-leave-active`, { transition: `opacity ${d} ${g}, transform ${d} ${g}` }), Ge(`&.${r}-transition-enter-active`, { transition: `opacity ${l} ${f}, transform ${l} ${f}` })];
}
const NT = ue("form-item", `
 display: grid;
 line-height: var(--n-line-height);
`, [ue("form-item-label", `
 grid-area: label;
 align-items: center;
 line-height: 1.25;
 text-align: var(--n-label-text-align);
 font-size: var(--n-label-font-size);
 min-height: var(--n-label-height);
 padding: var(--n-label-padding);
 color: var(--n-label-text-color);
 transition: color .3s var(--n-bezier);
 box-sizing: border-box;
 font-weight: var(--n-label-font-weight);
 `, [Re("asterisk", `
 white-space: nowrap;
 user-select: none;
 -webkit-user-select: none;
 color: var(--n-asterisk-color);
 transition: color .3s var(--n-bezier);
 `), Re("asterisk-placeholder", `
 grid-area: mark;
 user-select: none;
 -webkit-user-select: none;
 visibility: hidden; 
 `)]), ue("form-item-blank", `
 grid-area: blank;
 min-height: var(--n-blank-height);
 `), Ue("auto-label-width", [ue("form-item-label", "white-space: nowrap;")]), Ue("left-labelled", `
 grid-template-areas:
 "label blank"
 "label feedback";
 grid-template-columns: auto minmax(0, 1fr);
 grid-template-rows: auto 1fr;
 align-items: flex-start;
 `, [ue("form-item-label", `
 display: grid;
 grid-template-columns: 1fr auto;
 min-height: var(--n-blank-height);
 height: auto;
 box-sizing: border-box;
 flex-shrink: 0;
 flex-grow: 0;
 `, [Ue("reverse-columns-space", `
 grid-template-columns: auto 1fr;
 `), Ue("left-mark", `
 grid-template-areas:
 "mark text"
 ". text";
 `), Ue("right-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), Ue("right-hanging-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), Re("text", `
 grid-area: text; 
 `), Re("asterisk", `
 grid-area: mark; 
 align-self: end;
 `)])]), Ue("top-labelled", `
 grid-template-areas:
 "label"
 "blank"
 "feedback";
 grid-template-rows: minmax(var(--n-label-height), auto) 1fr;
 grid-template-columns: minmax(0, 100%);
 `, [Ue("no-label", `
 grid-template-areas:
 "blank"
 "feedback";
 grid-template-rows: 1fr;
 `), ue("form-item-label", `
 display: flex;
 align-items: flex-start;
 justify-content: var(--n-label-text-align);
 `)]), ue("form-item-blank", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 position: relative;
 `), ue("form-item-feedback-wrapper", `
 grid-area: feedback;
 box-sizing: border-box;
 min-height: var(--n-feedback-height);
 font-size: var(--n-feedback-font-size);
 line-height: 1.25;
 transform-origin: top left;
 `, [Ge("&:not(:empty)", `
 padding: var(--n-feedback-padding);
 `), ue("form-item-feedback", { transition: "color .3s var(--n-bezier)", color: "var(--n-feedback-text-color)" }, [Ue("warning", { color: "var(--n-feedback-text-color-warning)" }), Ue("error", { color: "var(--n-feedback-text-color-error)" }), jT({ fromOffset: "-3px", enterDuration: ".3s", leaveDuration: ".2s" })])])]);
function VT(r) {
  const i = fr(ih, null);
  return { mergedSize: ze(() => r.size !== void 0 ? r.size : (i == null ? void 0 : i.props.size) !== void 0 ? i.props.size : "medium") };
}
function UT(r) {
  const i = fr(ih, null), l = ze(() => {
    const { labelPlacement: O } = r;
    return O !== void 0 ? O : (i == null ? void 0 : i.props.labelPlacement) ? i.props.labelPlacement : "top";
  }), d = ze(() => l.value === "left" && (r.labelWidth === "auto" || (i == null ? void 0 : i.props.labelWidth) === "auto")), f = ze(() => {
    if (l.value === "top") return;
    const { labelWidth: O } = r;
    if (O !== void 0 && O !== "auto") return Go(O);
    if (d.value) {
      const V = i == null ? void 0 : i.maxChildLabelWidthRef.value;
      return V !== void 0 ? Go(V) : void 0;
    }
    if ((i == null ? void 0 : i.props.labelWidth) !== void 0) return Go(i.props.labelWidth);
  }), g = ze(() => {
    const { labelAlign: O } = r;
    if (O) return O;
    if (i == null ? void 0 : i.props.labelAlign) return i.props.labelAlign;
  }), m = ze(() => {
    var O;
    return [(O = r.labelProps) === null || O === void 0 ? void 0 : O.style, r.labelStyle, { width: f.value }];
  }), s = ze(() => {
    const { showRequireMark: O } = r;
    return O !== void 0 ? O : i == null ? void 0 : i.props.showRequireMark;
  }), C = ze(() => {
    const { requireMarkPlacement: O } = r;
    return O !== void 0 ? O : (i == null ? void 0 : i.props.requireMarkPlacement) || "right";
  }), T = Ae(false), M = Ae(false), z = ze(() => {
    const { validationStatus: O } = r;
    if (O !== void 0) return O;
    if (T.value) return "error";
    if (M.value) return "warning";
  }), L = ze(() => {
    const { showFeedback: O } = r;
    return O !== void 0 ? O : (i == null ? void 0 : i.props.showFeedback) !== void 0 ? i.props.showFeedback : true;
  }), A = ze(() => {
    const { showLabel: O } = r;
    return O !== void 0 ? O : (i == null ? void 0 : i.props.showLabel) !== void 0 ? i.props.showLabel : true;
  });
  return { validationErrored: T, validationWarned: M, mergedLabelStyle: m, mergedLabelPlacement: l, mergedLabelAlign: g, mergedShowRequireMark: s, mergedRequireMarkPlacement: C, mergedValidationStatus: z, mergedShowFeedback: L, mergedShowLabel: A, isAutoLabelWidth: d };
}
function qT(r) {
  const i = fr(ih, null), l = ze(() => {
    const { rulePath: m } = r;
    if (m !== void 0) return m;
    const { path: s } = r;
    if (s !== void 0) return s;
  }), d = ze(() => {
    const m = [], { rule: s } = r;
    if (s !== void 0 && (Array.isArray(s) ? m.push(...s) : m.push(s)), i) {
      const { rules: C } = i.props, { value: T } = l;
      if (C !== void 0 && T !== void 0) {
        const M = Uy(C, T);
        M !== void 0 && (Array.isArray(M) ? m.push(...M) : m.push(M));
      }
    }
    return m;
  }), f = ze(() => d.value.some((m) => m.required)), g = ze(() => f.value || r.required);
  return { mergedRules: d, mergedRequired: g };
}
var b_ = function(r, i, l, d) {
  function f(g) {
    return g instanceof l ? g : new l(function(m) {
      m(g);
    });
  }
  return new (l || (l = Promise))(function(g, m) {
    function s(M) {
      try {
        T(d.next(M));
      } catch (z) {
        m(z);
      }
    }
    function C(M) {
      try {
        T(d.throw(M));
      } catch (z) {
        m(z);
      }
    }
    function T(M) {
      M.done ? g(M.value) : f(M.value).then(s, C);
    }
    T((d = d.apply(r, i || [])).next());
  });
};
const GT = Object.assign(Object.assign({}, Kt.props), { label: String, labelWidth: [Number, String], labelStyle: [String, Object], labelAlign: String, labelPlacement: String, path: String, first: Boolean, rulePath: String, required: Boolean, showRequireMark: { type: Boolean, default: void 0 }, requireMarkPlacement: String, showFeedback: { type: Boolean, default: void 0 }, rule: [Object, Array], size: String, ignorePathChange: Boolean, validationStatus: String, feedback: String, feedbackClass: String, feedbackStyle: [String, Object], showLabel: { type: Boolean, default: void 0 }, labelProps: Object, contentClass: String, contentStyle: [String, Object] });
function x_(r, i) {
  return (...l) => {
    try {
      const d = r(...l);
      return !i && (typeof d == "boolean" || d instanceof Error || Array.isArray(d)) || (d == null ? void 0 : d.then) ? d : (d === void 0 || Uf("form-item/validate", `You return a ${typeof d} typed value in the validator method, which is not recommended. Please use ${i ? "`Promise`" : "`boolean`, `Error` or `Promise`"} typed value instead.`), true);
    } catch (d) {
      Uf("form-item/validate", "An error is catched in the validation, so the validation won't be done. Your callback in `validate` method of `n-form` or `n-form-item` won't be called in this validation."), console.error(d);
      return;
    }
  };
}
const wn = st({ name: "FormItem", props: GT, setup(r) {
  U3(Ab, "formItems", Dt(r, "path"));
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Tr(r), d = fr(ih, null), f = VT(r), g = UT(r), { validationErrored: m, validationWarned: s } = g, { mergedRequired: C, mergedRules: T } = qT(r), { mergedSize: M } = f, { mergedLabelPlacement: z, mergedLabelAlign: L, mergedRequireMarkPlacement: A } = g, O = Ae([]), V = Ae(Ml()), X = d ? Dt(d.props, "disabled") : Ae(false), W = Kt("Form", "-form-item", NT, Vy, r, i);
  ar(Dt(r, "path"), () => {
    r.ignorePathChange || K();
  });
  function K() {
    O.value = [], m.value = false, s.value = false, r.feedback && (V.value = Ml());
  }
  const ie = (...Ke) => b_(this, [...Ke], void 0, function* (lt = null, vt = () => true, wt = { suppressWarning: true }) {
    const { path: at } = r;
    wt ? wt.first || (wt.first = r.first) : wt = {};
    const { value: et } = T, ht = d ? Uy(d.props.model, at || "") : void 0, yt = {}, nt = {}, ut = (lt ? et.filter((rr) => Array.isArray(rr.trigger) ? rr.trigger.includes(lt) : rr.trigger === lt) : et).filter(vt).map((rr, sr) => {
      const Gt = Object.assign({}, rr);
      if (Gt.validator && (Gt.validator = x_(Gt.validator, false)), Gt.asyncValidator && (Gt.asyncValidator = x_(Gt.asyncValidator, true)), Gt.renderMessage) {
        const Dr = `__renderMessage__${sr}`;
        nt[Dr] = Gt.message, Gt.message = Dr, yt[Dr] = Gt.renderMessage;
      }
      return Gt;
    }), Ft = ut.filter((rr) => rr.level !== "warning"), Ht = ut.filter((rr) => rr.level === "warning"), zt = { valid: true, errors: void 0, warnings: void 0 };
    if (!ut.length) return zt;
    const pr = at ?? "__n_no_path__", Qt = new Qu({ [pr]: Ft }), tr = new Qu({ [pr]: Ht }), { validateMessages: xr } = (d == null ? void 0 : d.props) || {};
    xr && (Qt.messages(xr), tr.messages(xr));
    const Mr = (rr) => {
      O.value = rr.map((sr) => {
        const Gt = (sr == null ? void 0 : sr.message) || "";
        return { key: Gt, render: () => Gt.startsWith("__renderMessage__") ? yt[Gt]() : Gt };
      }), rr.forEach((sr) => {
        var Gt;
        !((Gt = sr.message) === null || Gt === void 0) && Gt.startsWith("__renderMessage__") && (sr.message = nt[sr.message]);
      });
    };
    if (Ft.length) {
      const rr = yield new Promise((sr) => {
        Qt.validate({ [pr]: ht }, wt, sr);
      });
      (rr == null ? void 0 : rr.length) && (zt.valid = false, zt.errors = rr, Mr(rr));
    }
    if (Ht.length && !zt.errors) {
      const rr = yield new Promise((sr) => {
        tr.validate({ [pr]: ht }, wt, sr);
      });
      (rr == null ? void 0 : rr.length) && (Mr(rr), zt.warnings = rr);
    }
    return !zt.errors && !zt.warnings ? K() : (m.value = !!zt.errors, s.value = !!zt.warnings), zt;
  });
  function ee() {
    ie("blur");
  }
  function re() {
    ie("change");
  }
  function J() {
    ie("focus");
  }
  function Se() {
    ie("input");
  }
  function fe(Ke, lt) {
    return b_(this, void 0, void 0, function* () {
      let vt, wt, at, et;
      return typeof Ke == "string" ? (vt = Ke, wt = lt) : Ke !== null && typeof Ke == "object" && (vt = Ke.trigger, wt = Ke.callback, at = Ke.shouldRuleBeApplied, et = Ke.options), yield new Promise((ht, yt) => {
        ie(vt, at, et).then(({ valid: nt, errors: ut, warnings: Ft }) => {
          nt ? (wt && wt(void 0, { warnings: Ft }), ht({ warnings: Ft })) : (wt && wt(ut, { warnings: Ft }), yt(ut));
        });
      });
    });
  }
  Yr(V2, { path: Dt(r, "path"), disabled: X, mergedSize: f.mergedSize, mergedValidationStatus: g.mergedValidationStatus, restoreValidation: K, handleContentBlur: ee, handleContentChange: re, handleContentFocus: J, handleContentInput: Se });
  const oe = { validate: fe, restoreValidation: K, internalValidate: ie }, he = Ae(null);
  Qi(() => {
    if (!g.isAutoLabelWidth.value) return;
    const Ke = he.value;
    if (Ke !== null) {
      const lt = Ke.style.whiteSpace;
      Ke.style.whiteSpace = "nowrap", Ke.style.width = "", d == null ? void 0 : d.deriveMaxChildLabelWidth(Number(getComputedStyle(Ke).width.slice(0, -2))), Ke.style.whiteSpace = lt;
    }
  });
  const be = ze(() => {
    var Ke;
    const { value: lt } = M, { value: vt } = z, wt = vt === "top" ? "vertical" : "horizontal", { common: { cubicBezierEaseInOut: at }, self: { labelTextColor: et, asteriskColor: ht, lineHeight: yt, feedbackTextColor: nt, feedbackTextColorWarning: ut, feedbackTextColorError: Ft, feedbackPadding: Ht, labelFontWeight: zt, [jt("labelHeight", lt)]: pr, [jt("blankHeight", lt)]: Qt, [jt("feedbackFontSize", lt)]: tr, [jt("feedbackHeight", lt)]: xr, [jt("labelPadding", wt)]: Mr, [jt("labelTextAlign", wt)]: rr, [jt(jt("labelFontSize", vt), lt)]: sr } } = W.value;
    let Gt = (Ke = L.value) !== null && Ke !== void 0 ? Ke : rr;
    return vt === "top" && (Gt = Gt === "right" ? "flex-end" : "flex-start"), { "--n-bezier": at, "--n-line-height": yt, "--n-blank-height": Qt, "--n-label-font-size": sr, "--n-label-text-align": Gt, "--n-label-height": pr, "--n-label-padding": Mr, "--n-label-font-weight": zt, "--n-asterisk-color": ht, "--n-label-text-color": et, "--n-feedback-padding": Ht, "--n-feedback-font-size": tr, "--n-feedback-height": xr, "--n-feedback-text-color": nt, "--n-feedback-text-color-warning": ut, "--n-feedback-text-color-error": Ft };
  }), je = l ? mi("form-item", ze(() => {
    var Ke;
    return `${M.value[0]}${z.value[0]}${((Ke = L.value) === null || Ke === void 0 ? void 0 : Ke[0]) || ""}`;
  }), be, r) : void 0, Ve = ze(() => z.value === "left" && A.value === "left" && L.value === "left");
  return Object.assign(Object.assign(Object.assign(Object.assign({ labelElementRef: he, mergedClsPrefix: i, mergedRequired: C, feedbackId: V, renderExplains: O, reverseColSpace: Ve }, g), f), oe), { cssVars: l ? void 0 : be, themeClass: je == null ? void 0 : je.themeClass, onRender: je == null ? void 0 : je.onRender });
}, render() {
  const { $slots: r, mergedClsPrefix: i, mergedShowLabel: l, mergedShowRequireMark: d, mergedRequireMarkPlacement: f, onRender: g } = this, m = d !== void 0 ? d : this.mergedRequired;
  g == null ? void 0 : g();
  const s = () => {
    const C = this.$slots.label ? this.$slots.label() : this.label;
    if (!C) return null;
    const T = F("span", { class: `${i}-form-item-label__text` }, C), M = m ? F("span", { class: `${i}-form-item-label__asterisk` }, f !== "left" ? "\xA0*" : "*\xA0") : f === "right-hanging" && F("span", { class: `${i}-form-item-label__asterisk-placeholder` }, "\xA0*"), { labelProps: z } = this;
    return F("label", Object.assign({}, z, { class: [z == null ? void 0 : z.class, `${i}-form-item-label`, `${i}-form-item-label--${f}-mark`, this.reverseColSpace && `${i}-form-item-label--reverse-columns-space`], style: this.mergedLabelStyle, ref: "labelElementRef" }), f === "left" ? [M, T] : [T, M]);
  };
  return F("div", { class: [`${i}-form-item`, this.themeClass, `${i}-form-item--${this.mergedSize}-size`, `${i}-form-item--${this.mergedLabelPlacement}-labelled`, this.isAutoLabelWidth && `${i}-form-item--auto-label-width`, !l && `${i}-form-item--no-label`], style: this.cssVars }, l && s(), F("div", { class: [`${i}-form-item-blank`, this.contentClass, this.mergedValidationStatus && `${i}-form-item-blank--${this.mergedValidationStatus}`], style: this.contentStyle }, r), this.mergedShowFeedback ? F("div", { key: this.feedbackId, style: this.feedbackStyle, class: [`${i}-form-item-feedback-wrapper`, this.feedbackClass] }, F(Io, { name: "fade-down-transition", mode: "out-in" }, { default: () => {
    const { mergedValidationStatus: C } = this;
    return Ci(r.feedback, (T) => {
      var M;
      const { feedback: z } = this, L = T || z ? F("div", { key: "__feedback__", class: `${i}-form-item-feedback__line` }, T || z) : this.renderExplains.length ? (M = this.renderExplains) === null || M === void 0 ? void 0 : M.map(({ key: A, render: O }) => F("div", { key: A, class: `${i}-form-item-feedback__line` }, O())) : null;
      return L ? C === "warning" ? F("div", { key: "controlled-warning", class: `${i}-form-item-feedback ${i}-form-item-feedback--warning` }, L) : C === "error" ? F("div", { key: "controlled-error", class: `${i}-form-item-feedback ${i}-form-item-feedback--error` }, L) : C === "success" ? F("div", { key: "controlled-success", class: `${i}-form-item-feedback ${i}-form-item-feedback--success` }, L) : F("div", { key: "controlled-default", class: `${i}-form-item-feedback` }, L) : null;
    });
  } })) : null);
} }), w_ = 1, zb = An("n-grid"), Fb = 1, WT = { span: { type: [Number, String], default: Fb }, offset: { type: [Number, String], default: 0 }, suffix: Boolean, privateOffset: Number, privateSpan: Number, privateColStart: Number, privateShow: { type: Boolean, default: true } }, ZT = st({ __GRID_ITEM__: true, name: "GridItem", alias: ["Gi"], props: WT, setup() {
  const { isSsrRef: r, xGapRef: i, itemStyleRef: l, overflowRef: d, layoutShiftDisabledRef: f } = fr(zb), g = eh();
  return { overflow: d, itemStyle: l, layoutShiftDisabled: f, mergedXGap: ze(() => Nn(i.value || 0)), deriveStyle: () => {
    r.value;
    const { privateSpan: m = Fb, privateShow: s = true, privateColStart: C = void 0, privateOffset: T = 0 } = g.vnode.props, { value: M } = i, z = Nn(M || 0);
    return { display: s ? "" : "none", gridColumn: `${C ?? `span ${m}`} / span ${m}`, marginLeft: T ? `calc((100% - (${m} - 1) * ${z}) / ${m} * ${T} + ${z} * ${T})` : "" };
  } };
}, render() {
  var r, i;
  if (this.layoutShiftDisabled) {
    const { span: l, offset: d, mergedXGap: f } = this;
    return F("div", { style: { gridColumn: `span ${l} / span ${l}`, marginLeft: d ? `calc((100% - (${l} - 1) * ${f}) / ${l} * ${d} + ${f} * ${d})` : "" } }, this.$slots);
  }
  return F("div", { style: [this.itemStyle, this.deriveStyle()] }, (i = (r = this.$slots).default) === null || i === void 0 ? void 0 : i.call(r, { overflow: this.overflow }));
} }), HT = { xs: 0, s: 640, m: 1024, l: 1280, xl: 1536, xxl: 1920 }, Lb = 24, Um = "__ssr__", XT = { layoutShiftDisabled: Boolean, responsive: { type: [String, Boolean], default: "self" }, cols: { type: [Number, String], default: Lb }, itemResponsive: Boolean, collapsed: Boolean, collapsedRows: { type: Number, default: 1 }, itemStyle: [Object, String], xGap: { type: [Number, String], default: 0 }, yGap: { type: [Number, String], default: 0 } }, YT = st({ name: "Grid", inheritAttrs: false, props: XT, setup(r) {
  const { mergedClsPrefixRef: i, mergedBreakpointsRef: l } = Tr(r), d = /^\d+$/, f = Ae(void 0), g = V3((l == null ? void 0 : l.value) || HT), m = _i(() => !!(r.itemResponsive || !d.test(r.cols.toString()) || !d.test(r.xGap.toString()) || !d.test(r.yGap.toString()))), s = ze(() => {
    if (m.value) return r.responsive === "self" ? f.value : g.value;
  }), C = _i(() => {
    var W;
    return (W = Number($u(r.cols.toString(), s.value))) !== null && W !== void 0 ? W : Lb;
  }), T = _i(() => $u(r.xGap.toString(), s.value)), M = _i(() => $u(r.yGap.toString(), s.value)), z = (W) => {
    f.value = W.contentRect.width;
  }, L = (W) => {
    ep(z, W);
  }, A = Ae(false), O = ze(() => {
    if (r.responsive === "self") return L;
  }), V = Ae(false), X = Ae();
  return Qi(() => {
    const { value: W } = X;
    W && W.hasAttribute(Um) && (W.removeAttribute(Um), V.value = true);
  }), Yr(zb, { layoutShiftDisabledRef: Dt(r, "layoutShiftDisabled"), isSsrRef: V, itemStyleRef: Dt(r, "itemStyle"), xGapRef: T, overflowRef: A }), { isSsr: !sp, contentEl: X, mergedClsPrefix: i, style: ze(() => r.layoutShiftDisabled ? { width: "100%", display: "grid", gridTemplateColumns: `repeat(${r.cols}, minmax(0, 1fr))`, columnGap: Nn(r.xGap), rowGap: Nn(r.yGap) } : { width: "100%", display: "grid", gridTemplateColumns: `repeat(${C.value}, minmax(0, 1fr))`, columnGap: Nn(T.value), rowGap: Nn(M.value) }), isResponsive: m, responsiveQuery: s, responsiveCols: C, handleResize: O, overflow: A };
}, render() {
  if (this.layoutShiftDisabled) return F("div", Ya({ ref: "contentEl", class: `${this.mergedClsPrefix}-grid`, style: this.style }, this.$attrs), this.$slots);
  const r = () => {
    var i, l, d, f, g, m, s;
    this.overflow = false;
    const C = kl(cp(this)), T = [], { collapsed: M, collapsedRows: z, responsiveCols: L, responsiveQuery: A } = this;
    C.forEach((K) => {
      var ie, ee, re, J, Se;
      if (((ie = K == null ? void 0 : K.type) === null || ie === void 0 ? void 0 : ie.__GRID_ITEM__) !== true) return;
      if (eS(K)) {
        const he = sg(K);
        he.props ? he.props.privateShow = false : he.props = { privateShow: false }, T.push({ child: he, rawChildSpan: 0 });
        return;
      }
      K.dirs = ((ee = K.dirs) === null || ee === void 0 ? void 0 : ee.filter(({ dir: he }) => he !== Ka)) || null, ((re = K.dirs) === null || re === void 0 ? void 0 : re.length) === 0 && (K.dirs = null);
      const fe = sg(K), oe = Number((Se = $u((J = fe.props) === null || J === void 0 ? void 0 : J.span, A)) !== null && Se !== void 0 ? Se : w_);
      oe !== 0 && T.push({ child: fe, rawChildSpan: oe });
    });
    let O = 0;
    const V = (i = T[T.length - 1]) === null || i === void 0 ? void 0 : i.child;
    if (V == null ? void 0 : V.props) {
      const K = (l = V.props) === null || l === void 0 ? void 0 : l.suffix;
      K !== void 0 && K !== false && (O = Number((f = $u((d = V.props) === null || d === void 0 ? void 0 : d.span, A)) !== null && f !== void 0 ? f : w_), V.props.privateSpan = O, V.props.privateColStart = L + 1 - O, V.props.privateShow = (g = V.props.privateShow) !== null && g !== void 0 ? g : true);
    }
    let X = 0, W = false;
    for (const { child: K, rawChildSpan: ie } of T) {
      if (W && (this.overflow = true), !W) {
        const ee = Number((s = $u((m = K.props) === null || m === void 0 ? void 0 : m.offset, A)) !== null && s !== void 0 ? s : 0), re = Math.min(ie + ee, L);
        if (K.props ? (K.props.privateSpan = re, K.props.privateOffset = ee) : K.props = { privateSpan: re, privateOffset: ee }, M) {
          const J = X % L;
          re + J > L && (X += L - J), re + X + O > z * L ? W = true : X += re;
        }
      }
      W && (K.props ? K.props.privateShow !== true && (K.props.privateShow = false) : K.props = { privateShow: false });
    }
    return F("div", Ya({ ref: "contentEl", class: `${this.mergedClsPrefix}-grid`, style: this.style, [Um]: this.isSsr || void 0 }, this.$attrs), T.map(({ child: K }) => K));
  };
  return this.isResponsive && this.responsive === "self" ? F(xl, { onResize: this.handleResize }, { default: r }) : r();
} });
function KT() {
  return F("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M6 5C5.75454 5 5.55039 5.17688 5.50806 5.41012L5.5 5.5V14.5C5.5 14.7761 5.72386 15 6 15C6.24546 15 6.44961 14.8231 6.49194 14.5899L6.5 14.5V5.5C6.5 5.22386 6.27614 5 6 5ZM13.8536 5.14645C13.68 4.97288 13.4106 4.9536 13.2157 5.08859L13.1464 5.14645L8.64645 9.64645C8.47288 9.82001 8.4536 10.0894 8.58859 10.2843L8.64645 10.3536L13.1464 14.8536C13.3417 15.0488 13.6583 15.0488 13.8536 14.8536C14.0271 14.68 14.0464 14.4106 13.9114 14.2157L13.8536 14.1464L9.70711 10L13.8536 5.85355C14.0488 5.65829 14.0488 5.34171 13.8536 5.14645Z", fill: "currentColor" }));
}
function JT() {
  return F("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M13.5 5C13.7455 5 13.9496 5.17688 13.9919 5.41012L14 5.5V14.5C14 14.7761 13.7761 15 13.5 15C13.2545 15 13.0504 14.8231 13.0081 14.5899L13 14.5V5.5C13 5.22386 13.2239 5 13.5 5ZM5.64645 5.14645C5.82001 4.97288 6.08944 4.9536 6.28431 5.08859L6.35355 5.14645L10.8536 9.64645C11.0271 9.82001 11.0464 10.0894 10.9114 10.2843L10.8536 10.3536L6.35355 14.8536C6.15829 15.0488 5.84171 15.0488 5.64645 14.8536C5.47288 14.68 5.4536 14.4106 5.58859 14.2157L5.64645 14.1464L9.79289 10L5.64645 5.85355C5.45118 5.65829 5.45118 5.34171 5.64645 5.14645Z", fill: "currentColor" }));
}
function QT() {
  return F("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { d: "M4.089 4.216l.057-.07a.5.5 0 0 1 .638-.057l.07.057L10 9.293l5.146-5.147a.5.5 0 0 1 .638-.057l.07.057a.5.5 0 0 1 .057.638l-.057.07L10.707 10l5.147 5.146a.5.5 0 0 1 .057.638l-.057.07a.5.5 0 0 1-.638.057l-.07-.057L10 10.707l-5.146 5.147a.5.5 0 0 1-.638.057l-.07-.057a.5.5 0 0 1-.057-.638l.057-.07L9.293 10L4.146 4.854a.5.5 0 0 1-.057-.638l.057-.07l-.057.07z", fill: "currentColor" }));
}
const Yg = Object.assign(Object.assign({}, Kt.props), { onPreviewPrev: Function, onPreviewNext: Function, showToolbar: { type: Boolean, default: true }, showToolbarTooltip: Boolean, renderToolbar: Function }), Bb = An("n-image"), e5 = Ge([Ge("body >", [ue("image-container", "position: fixed;")]), ue("image-preview-container", `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 `), ue("image-preview-overlay", `
 z-index: -1;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 background: rgba(0, 0, 0, .3);
 `, [Wf()]), ue("image-preview-toolbar", `
 z-index: 1;
 position: absolute;
 left: 50%;
 transform: translateX(-50%);
 border-radius: var(--n-toolbar-border-radius);
 height: 48px;
 bottom: 40px;
 padding: 0 12px;
 background: var(--n-toolbar-color);
 box-shadow: var(--n-toolbar-box-shadow);
 color: var(--n-toolbar-icon-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [ue("base-icon", `
 padding: 0 8px;
 font-size: 28px;
 cursor: pointer;
 `), Wf()]), ue("image-preview-wrapper", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 pointer-events: none;
 `, [rp()]), ue("image-preview", `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: all;
 margin: auto;
 max-height: calc(100vh - 32px);
 max-width: calc(100vw - 32px);
 transition: transform .3s var(--n-bezier);
 `), ue("image", `
 display: inline-flex;
 max-height: 100%;
 max-width: 100%;
 `, [pi("preview-disabled", `
 cursor: pointer;
 `), Ge("img", `
 border-radius: inherit;
 `)])]), kf = 32, t5 = Object.assign(Object.assign({}, Yg), { src: String, show: { type: Boolean, default: void 0 }, defaultShow: Boolean, "onUpdate:show": [Function, Array], onUpdateShow: [Function, Array], onNext: Function, onPrev: Function, onClose: [Function, Array] }), Ob = st({ name: "ImagePreview", props: t5, setup(r) {
  const { src: i } = Ww(r), { mergedClsPrefixRef: l } = Tr(r), d = Kt("Image", "-image", e5, U2, r, l);
  let f = null;
  const g = Ae(null), m = Ae(null), s = Ae(false), { localeRef: C } = Ja("Image"), T = Ae(r.defaultShow), M = Dt(r, "show"), z = Zi(M, T);
  function L() {
    const { value: Ee } = m;
    if (!f || !Ee) return;
    const { style: ot } = Ee, Le = f.getBoundingClientRect(), Ye = Le.left + Le.width / 2, ft = Le.top + Le.height / 2;
    ot.transformOrigin = `${Ye}px ${ft}px`;
  }
  function A(Ee) {
    var ot, Le;
    switch (Ee.key) {
      case " ":
        Ee.preventDefault();
        break;
      case "ArrowLeft":
        (ot = r.onPrev) === null || ot === void 0 || ot.call(r);
        break;
      case "ArrowRight":
        (Le = r.onNext) === null || Le === void 0 || Le.call(r);
        break;
      case "ArrowUp":
        Ee.preventDefault(), zt();
        break;
      case "ArrowDown":
        Ee.preventDefault(), pr();
        break;
      case "Escape":
        xr();
        break;
    }
  }
  function O(Ee) {
    const { onUpdateShow: ot, "onUpdate:show": Le } = r;
    ot && Ot(ot, Ee), Le && Ot(Le, Ee), T.value = Ee, s.value = true;
  }
  ar(z, (Ee) => {
    Ee ? En("keydown", document, A) : Hn("keydown", document, A);
  }), Sn(() => {
    Hn("keydown", document, A);
  });
  let V = 0, X = 0, W = 0, K = 0, ie = 0, ee = 0, re = 0, J = 0, Se = false;
  function fe(Ee) {
    const { clientX: ot, clientY: Le } = Ee;
    W = ot - V, K = Le - X, ep(tr);
  }
  function oe(Ee) {
    const { mouseUpClientX: ot, mouseUpClientY: Le, mouseDownClientX: Ye, mouseDownClientY: ft } = Ee, bt = Ye - ot, tt = ft - Le, mt = `vertical${tt > 0 ? "Top" : "Bottom"}`, Zt = `horizontal${bt > 0 ? "Left" : "Right"}`;
    return { moveVerticalDirection: mt, moveHorizontalDirection: Zt, deltaHorizontal: bt, deltaVertical: tt };
  }
  function he(Ee) {
    const { value: ot } = g;
    if (!ot) return { offsetX: 0, offsetY: 0 };
    const Le = ot.getBoundingClientRect(), { moveVerticalDirection: Ye, moveHorizontalDirection: ft, deltaHorizontal: bt, deltaVertical: tt } = Ee || {};
    let mt = 0, Zt = 0;
    return Le.width <= window.innerWidth ? mt = 0 : Le.left > 0 ? mt = (Le.width - window.innerWidth) / 2 : Le.right < window.innerWidth ? mt = -(Le.width - window.innerWidth) / 2 : ft === "horizontalRight" ? mt = Math.min((Le.width - window.innerWidth) / 2, ie - (bt ?? 0)) : mt = Math.max(-((Le.width - window.innerWidth) / 2), ie - (bt ?? 0)), Le.height <= window.innerHeight ? Zt = 0 : Le.top > 0 ? Zt = (Le.height - window.innerHeight) / 2 : Le.bottom < window.innerHeight ? Zt = -(Le.height - window.innerHeight) / 2 : Ye === "verticalBottom" ? Zt = Math.min((Le.height - window.innerHeight) / 2, ee - (tt ?? 0)) : Zt = Math.max(-((Le.height - window.innerHeight) / 2), ee - (tt ?? 0)), { offsetX: mt, offsetY: Zt };
  }
  function be(Ee) {
    Hn("mousemove", document, fe), Hn("mouseup", document, be);
    const { clientX: ot, clientY: Le } = Ee;
    Se = false;
    const Ye = oe({ mouseUpClientX: ot, mouseUpClientY: Le, mouseDownClientX: re, mouseDownClientY: J }), ft = he(Ye);
    W = ft.offsetX, K = ft.offsetY, tr();
  }
  const je = fr(Bb, null);
  function Ve(Ee) {
    var ot, Le;
    if ((Le = (ot = je == null ? void 0 : je.previewedImgPropsRef.value) === null || ot === void 0 ? void 0 : ot.onMousedown) === null || Le === void 0 || Le.call(ot, Ee), Ee.button !== 0) return;
    const { clientX: Ye, clientY: ft } = Ee;
    Se = true, V = Ye - W, X = ft - K, ie = W, ee = K, re = Ye, J = ft, tr(), En("mousemove", document, fe), En("mouseup", document, be);
  }
  const Ke = 1.5;
  let lt = 0, vt = 1, wt = 0;
  function at(Ee) {
    var ot, Le;
    (Le = (ot = je == null ? void 0 : je.previewedImgPropsRef.value) === null || ot === void 0 ? void 0 : ot.onDblclick) === null || Le === void 0 || Le.call(ot, Ee);
    const Ye = Ht();
    vt = vt === Ye ? 1 : Ye, tr();
  }
  function et() {
    vt = 1, lt = 0;
  }
  function ht() {
    var Ee;
    et(), wt = 0, (Ee = r.onPrev) === null || Ee === void 0 || Ee.call(r);
  }
  function yt() {
    var Ee;
    et(), wt = 0, (Ee = r.onNext) === null || Ee === void 0 || Ee.call(r);
  }
  function nt() {
    wt -= 90, tr();
  }
  function ut() {
    wt += 90, tr();
  }
  function Ft() {
    const { value: Ee } = g;
    if (!Ee) return 1;
    const { innerWidth: ot, innerHeight: Le } = window, Ye = Math.max(1, Ee.naturalHeight / (Le - kf)), ft = Math.max(1, Ee.naturalWidth / (ot - kf));
    return Math.max(3, Ye * 2, ft * 2);
  }
  function Ht() {
    const { value: Ee } = g;
    if (!Ee) return 1;
    const { innerWidth: ot, innerHeight: Le } = window, Ye = Ee.naturalHeight / (Le - kf), ft = Ee.naturalWidth / (ot - kf);
    return Ye < 1 && ft < 1 ? 1 : Math.max(Ye, ft);
  }
  function zt() {
    const Ee = Ft();
    vt < Ee && (lt += 1, vt = Math.min(Ee, Math.pow(Ke, lt)), tr());
  }
  function pr() {
    if (vt > 0.5) {
      const Ee = vt;
      lt -= 1, vt = Math.max(0.5, Math.pow(Ke, lt));
      const ot = Ee - vt;
      tr(false);
      const Le = he();
      vt += ot, tr(false), vt -= ot, W = Le.offsetX, K = Le.offsetY, tr();
    }
  }
  function Qt() {
    const Ee = i.value;
    Ee && mb(Ee, void 0);
  }
  function tr(Ee = true) {
    var ot;
    const { value: Le } = g;
    if (!Le) return;
    const { style: Ye } = Le, ft = gs((ot = je == null ? void 0 : je.previewedImgPropsRef.value) === null || ot === void 0 ? void 0 : ot.style);
    let bt = "";
    if (typeof ft == "string") bt = `${ft};`;
    else for (const mt in ft) bt += `${u3(mt)}: ${ft[mt]};`;
    const tt = `transform-origin: center; transform: translateX(${W}px) translateY(${K}px) rotate(${wt}deg) scale(${vt});`;
    Se ? Ye.cssText = `${bt}cursor: grabbing; transition: none;${tt}` : Ye.cssText = `${bt}cursor: grab;${tt}${Ee ? "" : "transition: none;"}`, Ee || Le.offsetHeight;
  }
  function xr() {
    if (z.value) {
      const { onClose: Ee } = r;
      Ee && Ot(Ee), O(false), T.value = false;
    }
  }
  function Mr() {
    vt = Ht(), lt = Math.ceil(Math.log(vt) / Math.log(Ke)), W = 0, K = 0, tr();
  }
  const rr = { setThumbnailEl: (Ee) => {
    f = Ee;
  } };
  function sr(Ee, ot) {
    if (r.showToolbarTooltip) {
      const { value: Le } = d;
      return F(By, { to: false, theme: Le.peers.Tooltip, themeOverrides: Le.peerOverrides.Tooltip, keepAliveOnHover: false }, { default: () => C.value[ot], trigger: () => Ee });
    } else return Ee;
  }
  const Gt = ze(() => {
    const { common: { cubicBezierEaseInOut: Ee }, self: { toolbarIconColor: ot, toolbarBorderRadius: Le, toolbarBoxShadow: Ye, toolbarColor: ft } } = d.value;
    return { "--n-bezier": Ee, "--n-toolbar-icon-color": ot, "--n-toolbar-color": ft, "--n-toolbar-border-radius": Le, "--n-toolbar-box-shadow": Ye };
  }), { inlineThemeDisabled: Dr } = Tr(), wr = Dr ? mi("image-preview", void 0, Gt, r) : void 0;
  function Ct(Ee) {
    Ee.preventDefault();
  }
  return Object.assign({ clsPrefix: l, previewRef: g, previewWrapperRef: m, previewSrc: i, mergedShow: z, appear: lp(), displayed: s, previewedImgProps: je == null ? void 0 : je.previewedImgPropsRef, handleWheel: Ct, handlePreviewMousedown: Ve, handlePreviewDblclick: at, syncTransformOrigin: L, handleAfterLeave: () => {
    et(), wt = 0, s.value = false;
  }, handleDragStart: (Ee) => {
    var ot, Le;
    (Le = (ot = je == null ? void 0 : je.previewedImgPropsRef.value) === null || ot === void 0 ? void 0 : ot.onDragstart) === null || Le === void 0 || Le.call(ot, Ee), Ee.preventDefault();
  }, zoomIn: zt, zoomOut: pr, handleDownloadClick: Qt, rotateCounterclockwise: nt, rotateClockwise: ut, handleSwitchPrev: ht, handleSwitchNext: yt, withTooltip: sr, resizeToOrignalImageSize: Mr, cssVars: Dr ? void 0 : Gt, themeClass: wr == null ? void 0 : wr.themeClass, onRender: wr == null ? void 0 : wr.onRender, doUpdateShow: O, close: xr }, rr);
}, render() {
  var r, i;
  const { clsPrefix: l, renderToolbar: d, withTooltip: f } = this, g = f(F(Nr, { clsPrefix: l, onClick: this.handleSwitchPrev }, { default: KT }), "tipPrevious"), m = f(F(Nr, { clsPrefix: l, onClick: this.handleSwitchNext }, { default: JT }), "tipNext"), s = f(F(Nr, { clsPrefix: l, onClick: this.rotateCounterclockwise }, { default: () => F(QS, null) }), "tipCounterclockwise"), C = f(F(Nr, { clsPrefix: l, onClick: this.rotateClockwise }, { default: () => F(JS, null) }), "tipClockwise"), T = f(F(Nr, { clsPrefix: l, onClick: this.resizeToOrignalImageSize }, { default: () => F(YS, null) }), "tipOriginalSize"), M = f(F(Nr, { clsPrefix: l, onClick: this.zoomOut }, { default: () => F(rk, null) }), "tipZoomOut"), z = f(F(Nr, { clsPrefix: l, onClick: this.handleDownloadClick }, { default: () => F(gb, null) }), "tipDownload"), L = f(F(Nr, { clsPrefix: l, onClick: () => this.close() }, { default: QT }), "tipClose"), A = f(F(Nr, { clsPrefix: l, onClick: this.zoomIn }, { default: () => F(tk, null) }), "tipZoomIn");
  return F(Gr, null, (i = (r = this.$slots).default) === null || i === void 0 ? void 0 : i.call(r), F(jy, { show: this.mergedShow }, { default: () => {
    var O;
    return this.mergedShow || this.displayed ? ((O = this.onRender) === null || O === void 0 || O.call(this), ma(F("div", { ref: "containerRef", class: [`${l}-image-preview-container`, this.themeClass], style: this.cssVars, onWheel: this.handleWheel }, F(Io, { name: "fade-in-transition", appear: this.appear }, { default: () => this.mergedShow ? F("div", { class: `${l}-image-preview-overlay`, onClick: () => this.close() }) : null }), this.showToolbar ? F(Io, { name: "fade-in-transition", appear: this.appear }, { default: () => this.mergedShow ? F("div", { class: `${l}-image-preview-toolbar` }, d ? d({ nodes: { prev: g, next: m, rotateCounterclockwise: s, rotateClockwise: C, resizeToOriginalSize: T, zoomOut: M, zoomIn: A, download: z, close: L } }) : F(Gr, null, this.onPrev ? F(Gr, null, g, m) : null, s, C, T, M, A, z, L)) : null }) : null, F(Io, { name: "fade-in-scale-up-transition", onAfterLeave: this.handleAfterLeave, appear: this.appear, onEnter: this.syncTransformOrigin, onBeforeLeave: this.syncTransformOrigin }, { default: () => {
      const { previewedImgProps: V = {} } = this;
      return ma(F("div", { class: `${l}-image-preview-wrapper`, ref: "previewWrapperRef" }, F("img", Object.assign({}, V, { draggable: false, onMousedown: this.handlePreviewMousedown, onDblclick: this.handlePreviewDblclick, class: [`${l}-image-preview`, V.class], key: this.previewSrc, src: this.previewSrc, ref: "previewRef", onDragstart: this.handleDragStart }))), [[Ka, this.mergedShow]]);
    } })), [[$y, { enabled: this.mergedShow }]])) : null;
  } }));
} }), $b = An("n-image-group"), r5 = Object.assign(Object.assign({}, Yg), { srcList: Array, current: Number, defaultCurrent: { type: Number, default: 0 }, show: { type: Boolean, default: void 0 }, defaultShow: Boolean, onUpdateShow: [Function, Array], "onUpdate:show": [Function, Array], onUpdateCurrent: [Function, Array], "onUpdate:current": [Function, Array] }), i5 = st({ name: "ImageGroup", props: r5, setup(r) {
  const { mergedClsPrefixRef: i } = Tr(r), l = `c${Ml()}`, d = Ae(null), f = Ae(r.defaultShow), g = Dt(r, "show"), m = Zi(g, f), s = Ae(/* @__PURE__ */ new Map()), C = ze(() => {
    if (r.srcList) {
      const fe = /* @__PURE__ */ new Map();
      return r.srcList.forEach((oe, he) => {
        fe.set(`p${he}`, oe);
      }), fe;
    }
    return s.value;
  }), T = ze(() => Array.from(C.value.keys())), M = () => T.value.length;
  function z(fe, oe) {
    r.srcList && Zo("image-group", "`n-image` can't be placed inside `n-image-group` when image group's `src-list` prop is set.");
    const he = `r${fe}`;
    return s.value.has(`r${he}`) || s.value.set(he, oe), function() {
      s.value.has(he) || s.value.delete(he);
    };
  }
  const L = Ae(r.defaultCurrent), A = Dt(r, "current"), O = Zi(A, L), V = (fe) => {
    if (fe !== O.value) {
      const { onUpdateCurrent: oe, "onUpdate:current": he } = r;
      oe && Ot(oe, fe), he && Ot(he, fe), L.value = fe;
    }
  }, X = ze(() => T.value[O.value]), W = (fe) => {
    const oe = T.value.indexOf(fe);
    oe !== O.value && V(oe);
  }, K = ze(() => C.value.get(X.value));
  function ie(fe) {
    const { onUpdateShow: oe, "onUpdate:show": he } = r;
    oe && Ot(oe, fe), he && Ot(he, fe), f.value = fe;
  }
  function ee() {
    ie(false);
  }
  const re = ze(() => {
    const fe = (he, be) => {
      for (let je = he; je <= be; je++) {
        const Ve = T.value[je];
        if (C.value.get(Ve)) return je;
      }
    }, oe = fe(O.value + 1, M() - 1);
    return oe === void 0 ? fe(0, O.value - 1) : oe;
  }), J = ze(() => {
    const fe = (he, be) => {
      for (let je = he; je >= be; je--) {
        const Ve = T.value[je];
        if (C.value.get(Ve)) return je;
      }
    }, oe = fe(O.value - 1, 0);
    return oe === void 0 ? fe(M() - 1, O.value + 1) : oe;
  });
  function Se(fe) {
    var oe, he;
    fe === 1 ? (J.value !== void 0 && V(re.value), (oe = r.onPreviewNext) === null || oe === void 0 || oe.call(r)) : (re.value !== void 0 && V(J.value), (he = r.onPreviewPrev) === null || he === void 0 || he.call(r));
  }
  return Yr($b, { mergedClsPrefixRef: i, registerImageUrl: z, setThumbnailEl: (fe) => {
    var oe;
    (oe = d.value) === null || oe === void 0 || oe.setThumbnailEl(fe);
  }, toggleShow: (fe) => {
    ie(true), W(fe);
  }, groupId: l, renderToolbarRef: Dt(r, "renderToolbar") }), { mergedClsPrefix: i, previewInstRef: d, mergedShow: m, src: K, onClose: ee, next: () => {
    Se(1);
  }, prev: () => {
    Se(-1);
  } };
}, render() {
  return F(Ob, { theme: this.theme, themeOverrides: this.themeOverrides, ref: "previewInstRef", onPrev: this.prev, onNext: this.next, src: this.src, show: this.mergedShow, showToolbar: this.showToolbar, showToolbarTooltip: this.showToolbarTooltip, renderToolbar: this.renderToolbar, onClose: this.onClose }, this.$slots);
} }), n5 = Object.assign({ alt: String, height: [String, Number], imgProps: Object, previewedImgProps: Object, lazy: Boolean, intersectionObserverOptions: Object, objectFit: { type: String, default: "fill" }, previewSrc: String, fallbackSrc: String, width: [String, Number], src: String, previewDisabled: Boolean, loadDescription: String, onError: Function, onLoad: Function }, Yg);
let o5 = 0;
const jb = st({ name: "Image", props: n5, slots: Object, inheritAttrs: false, setup(r) {
  const i = Ae(null), l = Ae(false), d = Ae(null), f = fr($b, null), { mergedClsPrefixRef: g } = f || Tr(r), m = ze(() => r.previewSrc || r.src), s = Ae(false), C = o5++, T = () => {
    if (r.previewDisabled || l.value) return;
    if (f) {
      f.setThumbnailEl(i.value), f.toggleShow(`r${C}`);
      return;
    }
    const { value: V } = d;
    V && (V.setThumbnailEl(i.value), s.value = true);
  }, M = { click: () => {
    T();
  }, showPreview: T }, z = Ae(!r.lazy);
  Qi(() => {
    var V;
    (V = i.value) === null || V === void 0 || V.setAttribute("data-group-id", (f == null ? void 0 : f.groupId) || "");
  }), Qi(() => {
    if (r.lazy && r.intersectionObserverOptions) {
      let V;
      const X = po(() => {
        V == null ? void 0 : V(), V = void 0, V = Bk(i.value, r.intersectionObserverOptions, z);
      });
      Sn(() => {
        X(), V == null ? void 0 : V();
      });
    }
  }), po(() => {
    var V;
    r.src || ((V = r.imgProps) === null || V === void 0 || V.src), l.value = false;
  }), po((V) => {
    var X;
    const W = (X = f == null ? void 0 : f.registerImageUrl) === null || X === void 0 ? void 0 : X.call(f, C, m.value || "");
    V(() => {
      W == null ? void 0 : W();
    });
  });
  function L(V) {
    var X, W;
    M.showPreview(), (W = (X = r.imgProps) === null || X === void 0 ? void 0 : X.onClick) === null || W === void 0 || W.call(X, V);
  }
  function A() {
    s.value = false;
  }
  const O = Ae(false);
  return Yr(Bb, { previewedImgPropsRef: Dt(r, "previewedImgProps") }), Object.assign({ mergedClsPrefix: g, groupId: f == null ? void 0 : f.groupId, previewInstRef: d, imageRef: i, mergedPreviewSrc: m, showError: l, shouldStartLoading: z, loaded: O, mergedOnClick: (V) => {
    L(V);
  }, onPreviewClose: A, mergedOnError: (V) => {
    if (!z.value) return;
    l.value = true;
    const { onError: X, imgProps: { onError: W } = {} } = r;
    X == null ? void 0 : X(V), W == null ? void 0 : W(V);
  }, mergedOnLoad: (V) => {
    const { onLoad: X, imgProps: { onLoad: W } = {} } = r;
    X == null ? void 0 : X(V), W == null ? void 0 : W(V), O.value = true;
  }, previewShow: s }, M);
}, render() {
  var r, i;
  const { mergedClsPrefix: l, imgProps: d = {}, loaded: f, $attrs: g, lazy: m } = this, s = Un(this.$slots.error, () => []), C = (i = (r = this.$slots).placeholder) === null || i === void 0 ? void 0 : i.call(r), T = this.src || d.src, M = this.showError && s.length ? s : F("img", Object.assign(Object.assign({}, d), { ref: "imageRef", width: this.width || d.width, height: this.height || d.height, src: this.showError ? this.fallbackSrc : m && this.intersectionObserverOptions ? this.shouldStartLoading ? T : void 0 : T, alt: this.alt || d.alt, "aria-label": this.alt || d.alt, onClick: this.mergedOnClick, onError: this.mergedOnError, onLoad: this.mergedOnLoad, loading: Fk && m && !this.intersectionObserverOptions ? "lazy" : "eager", style: [d.style || "", C && !f ? { height: "0", width: "0", visibility: "hidden" } : "", { objectFit: this.objectFit }], "data-error": this.showError, "data-preview-src": this.previewSrc || this.src }));
  return F("div", Object.assign({}, g, { role: "none", class: [g.class, `${l}-image`, (this.previewDisabled || this.showError) && `${l}-image--preview-disabled`] }), this.groupId ? M : F(Ob, { theme: this.theme, themeOverrides: this.themeOverrides, ref: "previewInstRef", showToolbar: this.showToolbar, showToolbarTooltip: this.showToolbarTooltip, renderToolbar: this.renderToolbar, src: this.mergedPreviewSrc, show: !this.previewDisabled && this.previewShow, onClose: this.onPreviewClose }, { default: () => M }), !f && C);
} }), a5 = Ge([ue("input-number-suffix", `
 display: inline-block;
 margin-right: 10px;
 `), ue("input-number-prefix", `
 display: inline-block;
 margin-left: 10px;
 `)]);
function s5(r) {
  return r == null || typeof r == "string" && r.trim() === "" ? null : Number(r);
}
function l5(r) {
  return r.includes(".") && (/^(-)?\d+.*(\.|0)$/.test(r) || /^-?\d*$/.test(r)) || r === "-" || r === "-0";
}
function qm(r) {
  return r == null ? true : !Number.isNaN(r);
}
function C_(r, i) {
  return typeof r != "number" ? "" : i === void 0 ? String(r) : r.toFixed(i);
}
function Gm(r) {
  if (r === null) return null;
  if (typeof r == "number") return r;
  {
    const i = Number(r);
    return Number.isNaN(i) ? null : i;
  }
}
const S_ = 800, k_ = 100, u5 = Object.assign(Object.assign({}, Kt.props), { autofocus: Boolean, loading: { type: Boolean, default: void 0 }, placeholder: String, defaultValue: { type: Number, default: null }, value: Number, step: { type: [Number, String], default: 1 }, min: [Number, String], max: [Number, String], size: String, disabled: { type: Boolean, default: void 0 }, validator: Function, bordered: { type: Boolean, default: void 0 }, showButton: { type: Boolean, default: true }, buttonPlacement: { type: String, default: "right" }, inputProps: Object, readonly: Boolean, clearable: Boolean, keyboard: { type: Object, default: {} }, updateValueOnInput: { type: Boolean, default: true }, round: { type: Boolean, default: void 0 }, parse: Function, format: Function, precision: Number, status: String, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onFocus: [Function, Array], onBlur: [Function, Array], onClear: [Function, Array], onChange: [Function, Array] }), P_ = st({ name: "InputNumber", props: u5, slots: Object, setup(r) {
  const { mergedBorderedRef: i, mergedClsPrefixRef: l, mergedRtlRef: d } = Tr(r), f = Kt("InputNumber", "-input-number", a5, q2, r, l), { localeRef: g } = Ja("InputNumber"), m = va(r), { mergedSizeRef: s, mergedDisabledRef: C, mergedStatusRef: T } = m, M = Ae(null), z = Ae(null), L = Ae(null), A = Ae(r.defaultValue), O = Dt(r, "value"), V = Zi(O, A), X = Ae(""), W = (Ct) => {
    const Ee = String(Ct).split(".")[1];
    return Ee ? Ee.length : 0;
  }, K = (Ct) => {
    const Ee = [r.min, r.max, r.step, Ct].map((ot) => ot === void 0 ? 0 : W(ot));
    return Math.max(...Ee);
  }, ie = _i(() => {
    const { placeholder: Ct } = r;
    return Ct !== void 0 ? Ct : g.value.placeholder;
  }), ee = _i(() => {
    const Ct = Gm(r.step);
    return Ct !== null ? Ct === 0 ? 1 : Math.abs(Ct) : 1;
  }), re = _i(() => {
    const Ct = Gm(r.min);
    return Ct !== null ? Ct : null;
  }), J = _i(() => {
    const Ct = Gm(r.max);
    return Ct !== null ? Ct : null;
  }), Se = () => {
    const { value: Ct } = V;
    if (qm(Ct)) {
      const { format: Ee, precision: ot } = r;
      Ee ? X.value = Ee(Ct) : Ct === null || ot === void 0 || W(Ct) > ot ? X.value = C_(Ct, void 0) : X.value = C_(Ct, ot);
    } else X.value = String(Ct);
  };
  Se();
  const fe = (Ct) => {
    const { value: Ee } = V;
    if (Ct === Ee) {
      Se();
      return;
    }
    const { "onUpdate:value": ot, onUpdateValue: Le, onChange: Ye } = r, { nTriggerFormInput: ft, nTriggerFormChange: bt } = m;
    Ye && Ot(Ye, Ct), Le && Ot(Le, Ct), ot && Ot(ot, Ct), A.value = Ct, ft(), bt();
  }, oe = ({ offset: Ct, doUpdateIfValid: Ee, fixPrecision: ot, isInputing: Le }) => {
    const { value: Ye } = X;
    if (Le && l5(Ye)) return false;
    const ft = (r.parse || s5)(Ye);
    if (ft === null) return Ee && fe(null), null;
    if (qm(ft)) {
      const bt = W(ft), { precision: tt } = r;
      if (tt !== void 0 && tt < bt && !ot) return false;
      let mt = Number.parseFloat((ft + Ct).toFixed(tt ?? K(ft)));
      if (qm(mt)) {
        const { value: Zt } = J, { value: ri } = re;
        if (Zt !== null && mt > Zt) {
          if (!Ee || Le) return false;
          mt = Zt;
        }
        if (ri !== null && mt < ri) {
          if (!Ee || Le) return false;
          mt = ri;
        }
        return r.validator && !r.validator(mt) ? false : (Ee && fe(mt), mt);
      }
    }
    return false;
  }, he = _i(() => oe({ offset: 0, doUpdateIfValid: false, isInputing: false, fixPrecision: false }) === false), be = _i(() => {
    const { value: Ct } = V;
    if (r.validator && Ct === null) return false;
    const { value: Ee } = ee;
    return oe({ offset: -Ee, doUpdateIfValid: false, isInputing: false, fixPrecision: false }) !== false;
  }), je = _i(() => {
    const { value: Ct } = V;
    if (r.validator && Ct === null) return false;
    const { value: Ee } = ee;
    return oe({ offset: +Ee, doUpdateIfValid: false, isInputing: false, fixPrecision: false }) !== false;
  });
  function Ve(Ct) {
    const { onFocus: Ee } = r, { nTriggerFormFocus: ot } = m;
    Ee && Ot(Ee, Ct), ot();
  }
  function Ke(Ct) {
    var Ee, ot;
    if (Ct.target === ((Ee = M.value) === null || Ee === void 0 ? void 0 : Ee.wrapperElRef)) return;
    const Le = oe({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true });
    if (Le !== false) {
      const bt = (ot = M.value) === null || ot === void 0 ? void 0 : ot.inputElRef;
      bt && (bt.value = String(Le || "")), V.value === Le && Se();
    } else Se();
    const { onBlur: Ye } = r, { nTriggerFormBlur: ft } = m;
    Ye && Ot(Ye, Ct), ft(), Vn(() => {
      Se();
    });
  }
  function lt(Ct) {
    const { onClear: Ee } = r;
    Ee && Ot(Ee, Ct);
  }
  function vt() {
    const { value: Ct } = je;
    if (!Ct) {
      Qt();
      return;
    }
    const { value: Ee } = V;
    if (Ee === null) r.validator || fe(ht());
    else {
      const { value: ot } = ee;
      oe({ offset: ot, doUpdateIfValid: true, isInputing: false, fixPrecision: true });
    }
  }
  function wt() {
    const { value: Ct } = be;
    if (!Ct) {
      zt();
      return;
    }
    const { value: Ee } = V;
    if (Ee === null) r.validator || fe(ht());
    else {
      const { value: ot } = ee;
      oe({ offset: -ot, doUpdateIfValid: true, isInputing: false, fixPrecision: true });
    }
  }
  const at = Ve, et = Ke;
  function ht() {
    if (r.validator) return null;
    const { value: Ct } = re, { value: Ee } = J;
    return Ct !== null ? Math.max(0, Ct) : Ee !== null ? Math.min(0, Ee) : 0;
  }
  function yt(Ct) {
    lt(Ct), fe(null);
  }
  function nt(Ct) {
    var Ee, ot, Le;
    !((Ee = L.value) === null || Ee === void 0) && Ee.$el.contains(Ct.target) && Ct.preventDefault(), !((ot = z.value) === null || ot === void 0) && ot.$el.contains(Ct.target) && Ct.preventDefault(), (Le = M.value) === null || Le === void 0 || Le.activate();
  }
  let ut = null, Ft = null, Ht = null;
  function zt() {
    Ht && (window.clearTimeout(Ht), Ht = null), ut && (window.clearInterval(ut), ut = null);
  }
  let pr = null;
  function Qt() {
    pr && (window.clearTimeout(pr), pr = null), Ft && (window.clearInterval(Ft), Ft = null);
  }
  function tr() {
    zt(), Ht = window.setTimeout(() => {
      ut = window.setInterval(() => {
        wt();
      }, k_);
    }, S_), En("mouseup", document, zt, { once: true });
  }
  function xr() {
    Qt(), pr = window.setTimeout(() => {
      Ft = window.setInterval(() => {
        vt();
      }, k_);
    }, S_), En("mouseup", document, Qt, { once: true });
  }
  const Mr = () => {
    Ft || vt();
  }, rr = () => {
    ut || wt();
  };
  function sr(Ct) {
    var Ee, ot;
    if (Ct.key === "Enter") {
      if (Ct.target === ((Ee = M.value) === null || Ee === void 0 ? void 0 : Ee.wrapperElRef)) return;
      oe({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true }) !== false && ((ot = M.value) === null || ot === void 0 || ot.deactivate());
    } else if (Ct.key === "ArrowUp") {
      if (!je.value || r.keyboard.ArrowUp === false) return;
      Ct.preventDefault(), oe({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true }) !== false && vt();
    } else if (Ct.key === "ArrowDown") {
      if (!be.value || r.keyboard.ArrowDown === false) return;
      Ct.preventDefault(), oe({ offset: 0, doUpdateIfValid: true, isInputing: false, fixPrecision: true }) !== false && wt();
    }
  }
  function Gt(Ct) {
    X.value = Ct, r.updateValueOnInput && !r.format && !r.parse && r.precision === void 0 && oe({ offset: 0, doUpdateIfValid: true, isInputing: true, fixPrecision: false });
  }
  ar(V, () => {
    Se();
  });
  const Dr = { focus: () => {
    var Ct;
    return (Ct = M.value) === null || Ct === void 0 ? void 0 : Ct.focus();
  }, blur: () => {
    var Ct;
    return (Ct = M.value) === null || Ct === void 0 ? void 0 : Ct.blur();
  }, select: () => {
    var Ct;
    return (Ct = M.value) === null || Ct === void 0 ? void 0 : Ct.select();
  } }, wr = Rn("InputNumber", d, l);
  return Object.assign(Object.assign({}, Dr), { rtlEnabled: wr, inputInstRef: M, minusButtonInstRef: z, addButtonInstRef: L, mergedClsPrefix: l, mergedBordered: i, uncontrolledValue: A, mergedValue: V, mergedPlaceholder: ie, displayedValueInvalid: he, mergedSize: s, mergedDisabled: C, displayedValue: X, addable: je, minusable: be, mergedStatus: T, handleFocus: at, handleBlur: et, handleClear: yt, handleMouseDown: nt, handleAddClick: Mr, handleMinusClick: rr, handleAddMousedown: xr, handleMinusMousedown: tr, handleKeyDown: sr, handleUpdateDisplayedValue: Gt, mergedTheme: f, inputThemeOverrides: { paddingSmall: "0 8px 0 10px", paddingMedium: "0 8px 0 12px", paddingLarge: "0 8px 0 14px" }, buttonThemeOverrides: ze(() => {
    const { self: { iconColorDisabled: Ct } } = f.value, [Ee, ot, Le, Ye] = qo(Ct);
    return { textColorTextDisabled: `rgb(${Ee}, ${ot}, ${Le})`, opacityDisabled: `${Ye}` };
  }) });
}, render() {
  const { mergedClsPrefix: r, $slots: i } = this, l = () => F(Hv, { text: true, disabled: !this.minusable || this.mergedDisabled || this.readonly, focusable: false, theme: this.mergedTheme.peers.Button, themeOverrides: this.mergedTheme.peerOverrides.Button, builtinThemeOverrides: this.buttonThemeOverrides, onClick: this.handleMinusClick, onMousedown: this.handleMinusMousedown, ref: "minusButtonInstRef" }, { icon: () => Un(i["minus-icon"], () => [F(Nr, { clsPrefix: r }, { default: () => F(XS, null) })]) }), d = () => F(Hv, { text: true, disabled: !this.addable || this.mergedDisabled || this.readonly, focusable: false, theme: this.mergedTheme.peers.Button, themeOverrides: this.mergedTheme.peerOverrides.Button, builtinThemeOverrides: this.buttonThemeOverrides, onClick: this.handleAddClick, onMousedown: this.handleAddMousedown, ref: "addButtonInstRef" }, { icon: () => Un(i["add-icon"], () => [F(Nr, { clsPrefix: r }, { default: () => F(dp, null) })]) });
  return F("div", { class: [`${r}-input-number`, this.rtlEnabled && `${r}-input-number--rtl`] }, F(ho, { ref: "inputInstRef", autofocus: this.autofocus, status: this.mergedStatus, bordered: this.mergedBordered, loading: this.loading, value: this.displayedValue, onUpdateValue: this.handleUpdateDisplayedValue, theme: this.mergedTheme.peers.Input, themeOverrides: this.mergedTheme.peerOverrides.Input, builtinThemeOverrides: this.inputThemeOverrides, size: this.mergedSize, placeholder: this.mergedPlaceholder, disabled: this.mergedDisabled, readonly: this.readonly, round: this.round, textDecoration: this.displayedValueInvalid ? "line-through" : void 0, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeydown: this.handleKeyDown, onMousedown: this.handleMouseDown, onClear: this.handleClear, clearable: this.clearable, inputProps: this.inputProps, internalLoadingBeforeSuffix: true }, { prefix: () => {
    var f;
    return this.showButton && this.buttonPlacement === "both" ? [l(), Ci(i.prefix, (g) => g ? F("span", { class: `${r}-input-number-prefix` }, g) : null)] : (f = i.prefix) === null || f === void 0 ? void 0 : f.call(i);
  }, suffix: () => {
    var f;
    return this.showButton ? [Ci(i.suffix, (g) => g ? F("span", { class: `${r}-input-number-suffix` }, g) : null), this.buttonPlacement === "right" ? l() : null, d()] : (f = i.suffix) === null || f === void 0 ? void 0 : f.call(i);
  } }));
} }), c5 = Ge([ue("list", `
 --n-merged-border-color: var(--n-border-color);
 --n-merged-color: var(--n-color);
 --n-merged-color-hover: var(--n-color-hover);
 margin: 0;
 font-size: var(--n-font-size);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 padding: 0;
 list-style-type: none;
 color: var(--n-text-color);
 background-color: var(--n-merged-color);
 `, [Ue("show-divider", [ue("list-item", [Ge("&:not(:last-child)", [Re("divider", `
 background-color: var(--n-merged-border-color);
 `)])])]), Ue("clickable", [ue("list-item", `
 cursor: pointer;
 `)]), Ue("bordered", `
 border: 1px solid var(--n-merged-border-color);
 border-radius: var(--n-border-radius);
 `), Ue("hoverable", [ue("list-item", `
 border-radius: var(--n-border-radius);
 `, [Ge("&:hover", `
 background-color: var(--n-merged-color-hover);
 `, [Re("divider", `
 background-color: transparent;
 `)])])]), Ue("bordered, hoverable", [ue("list-item", `
 padding: 12px 20px;
 `), Re("header, footer", `
 padding: 12px 20px;
 `)]), Re("header, footer", `
 padding: 12px 0;
 box-sizing: border-box;
 transition: border-color .3s var(--n-bezier);
 `, [Ge("&:not(:last-child)", `
 border-bottom: 1px solid var(--n-merged-border-color);
 `)]), ue("list-item", `
 position: relative;
 padding: 12px 0; 
 box-sizing: border-box;
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [Re("prefix", `
 margin-right: 20px;
 flex: 0;
 `), Re("suffix", `
 margin-left: 20px;
 flex: 0;
 `), Re("main", `
 flex: 1;
 `), Re("divider", `
 height: 1px;
 position: absolute;
 bottom: 0;
 left: 0;
 right: 0;
 background-color: transparent;
 transition: background-color .3s var(--n-bezier);
 pointer-events: none;
 `)])]), Ey(ue("list", `
 --n-merged-color-hover: var(--n-color-hover-modal);
 --n-merged-color: var(--n-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 `)), Ry(ue("list", `
 --n-merged-color-hover: var(--n-color-hover-popover);
 --n-merged-color: var(--n-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 `))]), d5 = Object.assign(Object.assign({}, Kt.props), { size: { type: String, default: "medium" }, bordered: Boolean, clickable: Boolean, hoverable: Boolean, showDivider: { type: Boolean, default: true } }), Nb = An("n-list"), fp = st({ name: "List", props: d5, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l, mergedRtlRef: d } = Tr(r), f = Rn("List", d, i), g = Kt("List", "-list", c5, G2, r, i);
  Yr(Nb, { showDividerRef: Dt(r, "showDivider"), mergedClsPrefixRef: i });
  const m = ze(() => {
    const { common: { cubicBezierEaseInOut: C }, self: { fontSize: T, textColor: M, color: z, colorModal: L, colorPopover: A, borderColor: O, borderColorModal: V, borderColorPopover: X, borderRadius: W, colorHover: K, colorHoverModal: ie, colorHoverPopover: ee } } = g.value;
    return { "--n-font-size": T, "--n-bezier": C, "--n-text-color": M, "--n-color": z, "--n-border-radius": W, "--n-border-color": O, "--n-border-color-modal": V, "--n-border-color-popover": X, "--n-color-modal": L, "--n-color-popover": A, "--n-color-hover": K, "--n-color-hover-modal": ie, "--n-color-hover-popover": ee };
  }), s = l ? mi("list", void 0, m, r) : void 0;
  return { mergedClsPrefix: i, rtlEnabled: f, cssVars: l ? void 0 : m, themeClass: s == null ? void 0 : s.themeClass, onRender: s == null ? void 0 : s.onRender };
}, render() {
  var r;
  const { $slots: i, mergedClsPrefix: l, onRender: d } = this;
  return d == null ? void 0 : d(), F("ul", { class: [`${l}-list`, this.rtlEnabled && `${l}-list--rtl`, this.bordered && `${l}-list--bordered`, this.showDivider && `${l}-list--show-divider`, this.hoverable && `${l}-list--hoverable`, this.clickable && `${l}-list--clickable`, this.themeClass], style: this.cssVars }, i.header ? F("div", { class: `${l}-list__header` }, i.header()) : null, (r = i.default) === null || r === void 0 ? void 0 : r.call(i), i.footer ? F("div", { class: `${l}-list__footer` }, i.footer()) : null);
} }), pp = st({ name: "ListItem", slots: Object, setup() {
  const r = fr(Nb, null);
  return r || Zo("list-item", "`n-list-item` must be placed in `n-list`."), { showDivider: r.showDividerRef, mergedClsPrefix: r.mergedClsPrefixRef };
}, render() {
  const { $slots: r, mergedClsPrefix: i } = this;
  return F("li", { class: `${i}-list-item` }, r.prefix ? F("div", { class: `${i}-list-item__prefix` }, r.prefix()) : null, r.default ? F("div", { class: `${i}-list-item__main` }, r) : null, r.suffix ? F("div", { class: `${i}-list-item__suffix` }, r.suffix()) : null, this.showDivider && F("div", { class: `${i}-list-item__divider` }));
} }), Vb = An("n-popconfirm"), Ub = { positiveText: String, negativeText: String, showIcon: { type: Boolean, default: true }, onPositiveClick: { type: Function, required: true }, onNegativeClick: { type: Function, required: true } }, T_ = jd(Ub), h5 = st({ name: "NPopconfirmPanel", props: Ub, setup(r) {
  const { localeRef: i } = Ja("Popconfirm"), { inlineThemeDisabled: l } = Tr(), { mergedClsPrefixRef: d, mergedThemeRef: f, props: g } = fr(Vb), m = ze(() => {
    const { common: { cubicBezierEaseInOut: C }, self: { fontSize: T, iconSize: M, iconColor: z } } = f.value;
    return { "--n-bezier": C, "--n-font-size": T, "--n-icon-size": M, "--n-icon-color": z };
  }), s = l ? mi("popconfirm-panel", void 0, m, g) : void 0;
  return Object.assign(Object.assign({}, Ja("Popconfirm")), { mergedClsPrefix: d, cssVars: l ? void 0 : m, localizedPositiveText: ze(() => r.positiveText || i.value.positiveText), localizedNegativeText: ze(() => r.negativeText || i.value.negativeText), positiveButtonProps: Dt(g, "positiveButtonProps"), negativeButtonProps: Dt(g, "negativeButtonProps"), handlePositiveClick(C) {
    r.onPositiveClick(C);
  }, handleNegativeClick(C) {
    r.onNegativeClick(C);
  }, themeClass: s == null ? void 0 : s.themeClass, onRender: s == null ? void 0 : s.onRender });
}, render() {
  var r;
  const { mergedClsPrefix: i, showIcon: l, $slots: d } = this, f = Un(d.action, () => this.negativeText === null && this.positiveText === null ? [] : [this.negativeText !== null && F(Vr, Object.assign({ size: "small", onClick: this.handleNegativeClick }, this.negativeButtonProps), { default: () => this.localizedNegativeText }), this.positiveText !== null && F(Vr, Object.assign({ size: "small", type: "primary", onClick: this.handlePositiveClick }, this.positiveButtonProps), { default: () => this.localizedPositiveText })]);
  return (r = this.onRender) === null || r === void 0 || r.call(this), F("div", { class: [`${i}-popconfirm__panel`, this.themeClass], style: this.cssVars }, Ci(d.default, (g) => l || g ? F("div", { class: `${i}-popconfirm__body` }, l ? F("div", { class: `${i}-popconfirm__icon` }, Un(d.icon, () => [F(Nr, { clsPrefix: i }, { default: () => F(ap, null) })])) : null, g) : null), f ? F("div", { class: [`${i}-popconfirm__action`] }, f) : null);
} }), f5 = ue("popconfirm", [Re("body", `
 font-size: var(--n-font-size);
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 position: relative;
 `, [Re("icon", `
 display: flex;
 font-size: var(--n-icon-size);
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 margin: 0 8px 0 0;
 `)]), Re("action", `
 display: flex;
 justify-content: flex-end;
 `, [Ge("&:not(:first-child)", "margin-top: 8px"), ue("button", [Ge("&:not(:last-child)", "margin-right: 8px;")])])]), p5 = Object.assign(Object.assign(Object.assign({}, Kt.props), Z2), { positiveText: String, negativeText: String, showIcon: { type: Boolean, default: true }, trigger: { type: String, default: "click" }, positiveButtonProps: Object, negativeButtonProps: Object, onPositiveClick: Function, onNegativeClick: Function }), m5 = st({ name: "Popconfirm", props: p5, slots: Object, __popover__: true, setup(r) {
  const { mergedClsPrefixRef: i } = Tr(), l = Kt("Popconfirm", "-popconfirm", f5, W2, r, i), d = Ae(null);
  function f(s) {
    var C;
    if (!(!((C = d.value) === null || C === void 0) && C.getMergedShow())) return;
    const { onPositiveClick: T, "onUpdate:show": M } = r;
    Promise.resolve(T ? T(s) : true).then((z) => {
      var L;
      z !== false && ((L = d.value) === null || L === void 0 || L.setShow(false), M && Ot(M, false));
    });
  }
  function g(s) {
    var C;
    if (!(!((C = d.value) === null || C === void 0) && C.getMergedShow())) return;
    const { onNegativeClick: T, "onUpdate:show": M } = r;
    Promise.resolve(T ? T(s) : true).then((z) => {
      var L;
      z !== false && ((L = d.value) === null || L === void 0 || L.setShow(false), M && Ot(M, false));
    });
  }
  return Yr(Vb, { mergedThemeRef: l, mergedClsPrefixRef: i, props: r }), { setShow(s) {
    var C;
    (C = d.value) === null || C === void 0 || C.setShow(s);
  }, syncPosition() {
    var s;
    (s = d.value) === null || s === void 0 || s.syncPosition();
  }, mergedTheme: l, popoverInstRef: d, handlePositiveClick: f, handleNegativeClick: g };
}, render() {
  const { $slots: r, $props: i, mergedTheme: l } = this;
  return F(jg, Object.assign({}, qy(i, T_), { theme: l.peers.Popover, themeOverrides: l.peerOverrides.Popover, internalExtraClass: ["popconfirm"], ref: "popoverInstRef" }), { trigger: r.trigger, default: () => {
    const d = lg(i, T_);
    return F(h5, Object.assign({}, d, { onPositiveClick: this.handlePositiveClick, onNegativeClick: this.handleNegativeClick }), r);
  } });
} }), g5 = { success: F(Ug, null), error: F(Ng, null), warning: F(ap, null), info: F(Vg, null) }, v5 = st({ name: "ProgressCircle", props: { clsPrefix: { type: String, required: true }, status: { type: String, required: true }, strokeWidth: { type: Number, required: true }, fillColor: [String, Object], railColor: String, railStyle: [String, Object], percentage: { type: Number, default: 0 }, offsetDegree: { type: Number, default: 0 }, showIndicator: { type: Boolean, required: true }, indicatorTextColor: String, unit: String, viewBoxWidth: { type: Number, required: true }, gapDegree: { type: Number, required: true }, gapOffsetDegree: { type: Number, default: 0 } }, setup(r, { slots: i }) {
  const l = ze(() => {
    const g = "gradient", { fillColor: m } = r;
    return typeof m == "object" ? `${g}-${H2(JSON.stringify(m))}` : g;
  });
  function d(g, m, s, C) {
    const { gapDegree: T, viewBoxWidth: M, strokeWidth: z } = r, L = 50, A = 0, O = L, V = 0, X = 2 * L, W = 50 + z / 2, K = `M ${W},${W} m ${A},${O}
      a ${L},${L} 0 1 1 ${V},${-X}
      a ${L},${L} 0 1 1 ${-V},${X}`, ie = Math.PI * 2 * L, ee = { stroke: C === "rail" ? s : typeof r.fillColor == "object" ? `url(#${l.value})` : s, strokeDasharray: `${g / 100 * (ie - T)}px ${M * 8}px`, strokeDashoffset: `-${T / 2}px`, transformOrigin: m ? "center" : void 0, transform: m ? `rotate(${m}deg)` : void 0 };
    return { pathString: K, pathStyle: ee };
  }
  const f = () => {
    const g = typeof r.fillColor == "object", m = g ? r.fillColor.stops[0] : "", s = g ? r.fillColor.stops[1] : "";
    return g && F("defs", null, F("linearGradient", { id: l.value, x1: "0%", y1: "100%", x2: "100%", y2: "0%" }, F("stop", { offset: "0%", "stop-color": m }), F("stop", { offset: "100%", "stop-color": s })));
  };
  return () => {
    const { fillColor: g, railColor: m, strokeWidth: s, offsetDegree: C, status: T, percentage: M, showIndicator: z, indicatorTextColor: L, unit: A, gapOffsetDegree: O, clsPrefix: V } = r, { pathString: X, pathStyle: W } = d(100, 0, m, "rail"), { pathString: K, pathStyle: ie } = d(M, C, g, "fill"), ee = 100 + s;
    return F("div", { class: `${V}-progress-content`, role: "none" }, F("div", { class: `${V}-progress-graph`, "aria-hidden": true }, F("div", { class: `${V}-progress-graph-circle`, style: { transform: O ? `rotate(${O}deg)` : void 0 } }, F("svg", { viewBox: `0 0 ${ee} ${ee}` }, f(), F("g", null, F("path", { class: `${V}-progress-graph-circle-rail`, d: X, "stroke-width": s, "stroke-linecap": "round", fill: "none", style: W })), F("g", null, F("path", { class: [`${V}-progress-graph-circle-fill`, M === 0 && `${V}-progress-graph-circle-fill--empty`], d: K, "stroke-width": s, "stroke-linecap": "round", fill: "none", style: ie }))))), z ? F("div", null, i.default ? F("div", { class: `${V}-progress-custom-content`, role: "none" }, i.default()) : T !== "default" ? F("div", { class: `${V}-progress-icon`, "aria-hidden": true }, F(Nr, { clsPrefix: V }, { default: () => g5[T] })) : F("div", { class: `${V}-progress-text`, style: { color: L }, role: "none" }, F("span", { class: `${V}-progress-text__percentage` }, M), F("span", { class: `${V}-progress-text__unit` }, A))) : null);
  };
} }), _5 = { success: F(Ug, null), error: F(Ng, null), warning: F(ap, null), info: F(Vg, null) }, y5 = st({ name: "ProgressLine", props: { clsPrefix: { type: String, required: true }, percentage: { type: Number, default: 0 }, railColor: String, railStyle: [String, Object], fillColor: [String, Object], status: { type: String, required: true }, indicatorPlacement: { type: String, required: true }, indicatorTextColor: String, unit: { type: String, default: "%" }, processing: { type: Boolean, required: true }, showIndicator: { type: Boolean, required: true }, height: [String, Number], railBorderRadius: [String, Number], fillBorderRadius: [String, Number] }, setup(r, { slots: i }) {
  const l = ze(() => Go(r.height)), d = ze(() => {
    var m, s;
    return typeof r.fillColor == "object" ? `linear-gradient(to right, ${(m = r.fillColor) === null || m === void 0 ? void 0 : m.stops[0]} , ${(s = r.fillColor) === null || s === void 0 ? void 0 : s.stops[1]})` : r.fillColor;
  }), f = ze(() => r.railBorderRadius !== void 0 ? Go(r.railBorderRadius) : r.height !== void 0 ? Go(r.height, { c: 0.5 }) : ""), g = ze(() => r.fillBorderRadius !== void 0 ? Go(r.fillBorderRadius) : r.railBorderRadius !== void 0 ? Go(r.railBorderRadius) : r.height !== void 0 ? Go(r.height, { c: 0.5 }) : "");
  return () => {
    const { indicatorPlacement: m, railColor: s, railStyle: C, percentage: T, unit: M, indicatorTextColor: z, status: L, showIndicator: A, processing: O, clsPrefix: V } = r;
    return F("div", { class: `${V}-progress-content`, role: "none" }, F("div", { class: `${V}-progress-graph`, "aria-hidden": true }, F("div", { class: [`${V}-progress-graph-line`, { [`${V}-progress-graph-line--indicator-${m}`]: true }] }, F("div", { class: `${V}-progress-graph-line-rail`, style: [{ backgroundColor: s, height: l.value, borderRadius: f.value }, C] }, F("div", { class: [`${V}-progress-graph-line-fill`, O && `${V}-progress-graph-line-fill--processing`], style: { maxWidth: `${r.percentage}%`, background: d.value, height: l.value, lineHeight: l.value, borderRadius: g.value } }, m === "inside" ? F("div", { class: `${V}-progress-graph-line-indicator`, style: { color: z } }, i.default ? i.default() : `${T}${M}`) : null)))), A && m === "outside" ? F("div", null, i.default ? F("div", { class: `${V}-progress-custom-content`, style: { color: z }, role: "none" }, i.default()) : L === "default" ? F("div", { role: "none", class: `${V}-progress-icon ${V}-progress-icon--as-text`, style: { color: z } }, T, M) : F("div", { class: `${V}-progress-icon`, "aria-hidden": true }, F(Nr, { clsPrefix: V }, { default: () => _5[L] }))) : null);
  };
} });
function I_(r, i, l = 100) {
  return `m ${l / 2} ${l / 2 - r} a ${r} ${r} 0 1 1 0 ${2 * r} a ${r} ${r} 0 1 1 0 -${2 * r}`;
}
const b5 = st({ name: "ProgressMultipleCircle", props: { clsPrefix: { type: String, required: true }, viewBoxWidth: { type: Number, required: true }, percentage: { type: Array, default: [0] }, strokeWidth: { type: Number, required: true }, circleGap: { type: Number, required: true }, showIndicator: { type: Boolean, required: true }, fillColor: { type: Array, default: () => [] }, railColor: { type: Array, default: () => [] }, railStyle: { type: Array, default: () => [] } }, setup(r, { slots: i }) {
  const l = ze(() => r.percentage.map((g, m) => `${Math.PI * g / 100 * (r.viewBoxWidth / 2 - r.strokeWidth / 2 * (1 + 2 * m) - r.circleGap * m) * 2}, ${r.viewBoxWidth * 8}`)), d = (f, g) => {
    const m = r.fillColor[g], s = typeof m == "object" ? m.stops[0] : "", C = typeof m == "object" ? m.stops[1] : "";
    return typeof r.fillColor[g] == "object" && F("linearGradient", { id: `gradient-${g}`, x1: "100%", y1: "0%", x2: "0%", y2: "100%" }, F("stop", { offset: "0%", "stop-color": s }), F("stop", { offset: "100%", "stop-color": C }));
  };
  return () => {
    const { viewBoxWidth: f, strokeWidth: g, circleGap: m, showIndicator: s, fillColor: C, railColor: T, railStyle: M, percentage: z, clsPrefix: L } = r;
    return F("div", { class: `${L}-progress-content`, role: "none" }, F("div", { class: `${L}-progress-graph`, "aria-hidden": true }, F("div", { class: `${L}-progress-graph-circle` }, F("svg", { viewBox: `0 0 ${f} ${f}` }, F("defs", null, z.map((A, O) => d(A, O))), z.map((A, O) => F("g", { key: O }, F("path", { class: `${L}-progress-graph-circle-rail`, d: I_(f / 2 - g / 2 * (1 + 2 * O) - m * O, g, f), "stroke-width": g, "stroke-linecap": "round", fill: "none", style: [{ strokeDashoffset: 0, stroke: T[O] }, M[O]] }), F("path", { class: [`${L}-progress-graph-circle-fill`, A === 0 && `${L}-progress-graph-circle-fill--empty`], d: I_(f / 2 - g / 2 * (1 + 2 * O) - m * O, g, f), "stroke-width": g, "stroke-linecap": "round", fill: "none", style: { strokeDasharray: l.value[O], strokeDashoffset: 0, stroke: typeof C[O] == "object" ? `url(#gradient-${O})` : C[O] } })))))), s && i.default ? F("div", null, F("div", { class: `${L}-progress-text` }, i.default())) : null);
  };
} }), x5 = Ge([ue("progress", { display: "inline-block" }, [ue("progress-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 `), Ue("line", `
 width: 100%;
 display: block;
 `, [ue("progress-content", `
 display: flex;
 align-items: center;
 `, [ue("progress-graph", { flex: 1 })]), ue("progress-custom-content", { marginLeft: "14px" }), ue("progress-icon", `
 width: 30px;
 padding-left: 14px;
 height: var(--n-icon-size-line);
 line-height: var(--n-icon-size-line);
 font-size: var(--n-icon-size-line);
 `, [Ue("as-text", `
 color: var(--n-text-color-line-outer);
 text-align: center;
 width: 40px;
 font-size: var(--n-font-size);
 padding-left: 4px;
 transition: color .3s var(--n-bezier);
 `)])]), Ue("circle, dashboard", { width: "120px" }, [ue("progress-custom-content", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `), ue("progress-text", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: inherit;
 font-size: var(--n-font-size-circle);
 color: var(--n-text-color-circle);
 font-weight: var(--n-font-weight-circle);
 transition: color .3s var(--n-bezier);
 white-space: nowrap;
 `), ue("progress-icon", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: var(--n-icon-color);
 font-size: var(--n-icon-size-circle);
 `)]), Ue("multiple-circle", `
 width: 200px;
 color: inherit;
 `, [ue("progress-text", `
 font-weight: var(--n-font-weight-circle);
 color: var(--n-text-color-circle);
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `)]), ue("progress-content", { position: "relative" }), ue("progress-graph", { position: "relative" }, [ue("progress-graph-circle", [Ge("svg", { verticalAlign: "bottom" }), ue("progress-graph-circle-fill", `
 stroke: var(--n-fill-color);
 transition:
 opacity .3s var(--n-bezier),
 stroke .3s var(--n-bezier),
 stroke-dasharray .3s var(--n-bezier);
 `, [Ue("empty", { opacity: 0 })]), ue("progress-graph-circle-rail", `
 transition: stroke .3s var(--n-bezier);
 overflow: hidden;
 stroke: var(--n-rail-color);
 `)]), ue("progress-graph-line", [Ue("indicator-inside", [ue("progress-graph-line-rail", `
 height: 16px;
 line-height: 16px;
 border-radius: 10px;
 `, [ue("progress-graph-line-fill", `
 height: inherit;
 border-radius: 10px;
 `), ue("progress-graph-line-indicator", `
 background: #0000;
 white-space: nowrap;
 text-align: right;
 margin-left: 14px;
 margin-right: 14px;
 height: inherit;
 font-size: 12px;
 color: var(--n-text-color-line-inner);
 transition: color .3s var(--n-bezier);
 `)])]), Ue("indicator-inside-label", `
 height: 16px;
 display: flex;
 align-items: center;
 `, [ue("progress-graph-line-rail", `
 flex: 1;
 transition: background-color .3s var(--n-bezier);
 `), ue("progress-graph-line-indicator", `
 background: var(--n-fill-color);
 font-size: 12px;
 transform: translateZ(0);
 display: flex;
 vertical-align: middle;
 height: 16px;
 line-height: 16px;
 padding: 0 10px;
 border-radius: 10px;
 position: absolute;
 white-space: nowrap;
 color: var(--n-text-color-line-inner);
 transition:
 right .2s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `)]), ue("progress-graph-line-rail", `
 position: relative;
 overflow: hidden;
 height: var(--n-rail-height);
 border-radius: 5px;
 background-color: var(--n-rail-color);
 transition: background-color .3s var(--n-bezier);
 `, [ue("progress-graph-line-fill", `
 background: var(--n-fill-color);
 position: relative;
 border-radius: 5px;
 height: inherit;
 width: 100%;
 max-width: 0%;
 transition:
 background-color .3s var(--n-bezier),
 max-width .2s var(--n-bezier);
 `, [Ue("processing", [Ge("&::after", `
 content: "";
 background-image: var(--n-line-bg-processing);
 animation: progress-processing-animation 2s var(--n-bezier) infinite;
 `)])])])])])]), Ge("@keyframes progress-processing-animation", `
 0% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 100%;
 opacity: 1;
 }
 66% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 100% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 `)]), w5 = Object.assign(Object.assign({}, Kt.props), { processing: Boolean, type: { type: String, default: "line" }, gapDegree: Number, gapOffsetDegree: Number, status: { type: String, default: "default" }, railColor: [String, Array], railStyle: [String, Array], color: [String, Array, Object], viewBoxWidth: { type: Number, default: 100 }, strokeWidth: { type: Number, default: 7 }, percentage: [Number, Array], unit: { type: String, default: "%" }, showIndicator: { type: Boolean, default: true }, indicatorPosition: { type: String, default: "outside" }, indicatorPlacement: { type: String, default: "outside" }, indicatorTextColor: String, circleGap: { type: Number, default: 1 }, height: Number, borderRadius: [String, Number], fillBorderRadius: [String, Number], offsetDegree: Number }), C5 = st({ name: "Progress", props: w5, setup(r) {
  const i = ze(() => r.indicatorPlacement || r.indicatorPosition), l = ze(() => {
    if (r.gapDegree || r.gapDegree === 0) return r.gapDegree;
    if (r.type === "dashboard") return 75;
  }), { mergedClsPrefixRef: d, inlineThemeDisabled: f } = Tr(r), g = Kt("Progress", "-progress", x5, X2, r, d), m = ze(() => {
    const { status: C } = r, { common: { cubicBezierEaseInOut: T }, self: { fontSize: M, fontSizeCircle: z, railColor: L, railHeight: A, iconSizeCircle: O, iconSizeLine: V, textColorCircle: X, textColorLineInner: W, textColorLineOuter: K, lineBgProcessing: ie, fontWeightCircle: ee, [jt("iconColor", C)]: re, [jt("fillColor", C)]: J } } = g.value;
    return { "--n-bezier": T, "--n-fill-color": J, "--n-font-size": M, "--n-font-size-circle": z, "--n-font-weight-circle": ee, "--n-icon-color": re, "--n-icon-size-circle": O, "--n-icon-size-line": V, "--n-line-bg-processing": ie, "--n-rail-color": L, "--n-rail-height": A, "--n-text-color-circle": X, "--n-text-color-line-inner": W, "--n-text-color-line-outer": K };
  }), s = f ? mi("progress", ze(() => r.status[0]), m, r) : void 0;
  return { mergedClsPrefix: d, mergedIndicatorPlacement: i, gapDeg: l, cssVars: f ? void 0 : m, themeClass: s == null ? void 0 : s.themeClass, onRender: s == null ? void 0 : s.onRender };
}, render() {
  const { type: r, cssVars: i, indicatorTextColor: l, showIndicator: d, status: f, railColor: g, railStyle: m, color: s, percentage: C, viewBoxWidth: T, strokeWidth: M, mergedIndicatorPlacement: z, unit: L, borderRadius: A, fillBorderRadius: O, height: V, processing: X, circleGap: W, mergedClsPrefix: K, gapDeg: ie, gapOffsetDegree: ee, themeClass: re, $slots: J, onRender: Se } = this;
  return Se == null ? void 0 : Se(), F("div", { class: [re, `${K}-progress`, `${K}-progress--${r}`, `${K}-progress--${f}`], style: i, "aria-valuemax": 100, "aria-valuemin": 0, "aria-valuenow": C, role: r === "circle" || r === "line" || r === "dashboard" ? "progressbar" : "none" }, r === "circle" || r === "dashboard" ? F(v5, { clsPrefix: K, status: f, showIndicator: d, indicatorTextColor: l, railColor: g, fillColor: s, railStyle: m, offsetDegree: this.offsetDegree, percentage: C, viewBoxWidth: T, strokeWidth: M, gapDegree: ie === void 0 ? r === "dashboard" ? 75 : 0 : ie, gapOffsetDegree: ee, unit: L }, J) : r === "line" ? F(y5, { clsPrefix: K, status: f, showIndicator: d, indicatorTextColor: l, railColor: g, fillColor: s, railStyle: m, percentage: C, processing: X, indicatorPlacement: z, unit: L, fillBorderRadius: O, railBorderRadius: A, height: V }, J) : r === "multiple-circle" ? F(b5, { clsPrefix: K, strokeWidth: M, railColor: g, fillColor: s, railStyle: m, viewBoxWidth: T, percentage: C, showIndicator: d, circleGap: W }, J) : null);
} }), S5 = Ge([Ge("@keyframes spin-rotate", `
 from {
 transform: rotate(0);
 }
 to {
 transform: rotate(360deg);
 }
 `), ue("spin-container", `
 position: relative;
 `, [ue("spin-body", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [Wf()])]), ue("spin-body", `
 display: inline-flex;
 align-items: center;
 justify-content: center;
 flex-direction: column;
 `), ue("spin", `
 display: inline-flex;
 height: var(--n-size);
 width: var(--n-size);
 font-size: var(--n-size);
 color: var(--n-color);
 `, [Ue("rotate", `
 animation: spin-rotate 2s linear infinite;
 `)]), ue("spin-description", `
 display: inline-block;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 margin-top: 8px;
 `), ue("spin-content", `
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 pointer-events: all;
 `, [Ue("spinning", `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: none;
 opacity: var(--n-opacity-spinning);
 `)])]), k5 = { small: 20, medium: 18, large: 16 }, P5 = Object.assign(Object.assign({}, Kt.props), { contentClass: String, contentStyle: [Object, String], description: String, stroke: String, size: { type: [String, Number], default: "medium" }, show: { type: Boolean, default: true }, strokeWidth: Number, rotate: { type: Boolean, default: true }, spinning: { type: Boolean, validator: () => true, default: void 0 }, delay: Number }), T5 = st({ name: "Spin", props: P5, slots: Object, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Tr(r), d = Kt("Spin", "-spin", S5, Y2, r, i), f = ze(() => {
    const { size: C } = r, { common: { cubicBezierEaseInOut: T }, self: M } = d.value, { opacitySpinning: z, color: L, textColor: A } = M, O = typeof C == "number" ? Nn(C) : M[jt("size", C)];
    return { "--n-bezier": T, "--n-opacity-spinning": z, "--n-size": O, "--n-color": L, "--n-text-color": A };
  }), g = l ? mi("spin", ze(() => {
    const { size: C } = r;
    return typeof C == "number" ? String(C) : C[0];
  }), f, r) : void 0, m = Gf(r, ["spinning", "show"]), s = Ae(false);
  return po((C) => {
    let T;
    if (m.value) {
      const { delay: M } = r;
      if (M) {
        T = window.setTimeout(() => {
          s.value = true;
        }, M), C(() => {
          clearTimeout(T);
        });
        return;
      }
    }
    s.value = m.value;
  }), { mergedClsPrefix: i, active: s, mergedStrokeWidth: ze(() => {
    const { strokeWidth: C } = r;
    if (C !== void 0) return C;
    const { size: T } = r;
    return k5[typeof T == "number" ? "medium" : T];
  }), cssVars: l ? void 0 : f, themeClass: g == null ? void 0 : g.themeClass, onRender: g == null ? void 0 : g.onRender };
}, render() {
  var r, i;
  const { $slots: l, mergedClsPrefix: d, description: f } = this, g = l.icon && this.rotate, m = (f || l.description) && F("div", { class: `${d}-spin-description` }, f || ((r = l.description) === null || r === void 0 ? void 0 : r.call(l))), s = l.icon ? F("div", { class: [`${d}-spin-body`, this.themeClass] }, F("div", { class: [`${d}-spin`, g && `${d}-spin--rotate`], style: l.default ? "" : this.cssVars }, l.icon()), m) : F("div", { class: [`${d}-spin-body`, this.themeClass] }, F(ip, { clsPrefix: d, style: l.default ? "" : this.cssVars, stroke: this.stroke, "stroke-width": this.mergedStrokeWidth, class: `${d}-spin` }), m);
  return (i = this.onRender) === null || i === void 0 || i.call(this), l.default ? F("div", { class: [`${d}-spin-container`, this.themeClass], style: this.cssVars }, F("div", { class: [`${d}-spin-content`, this.active && `${d}-spin-content--spinning`, this.contentClass], style: this.contentStyle }, l), F(Io, { name: "fade-in-transition" }, { default: () => this.active ? s : null })) : s;
} }), I5 = ue("split", `
 display: flex;
 width: 100%;
 height: 100%;
`, [Ue("horizontal", `
 flex-direction: row;
 `), Ue("vertical", `
 flex-direction: column;
 `), ue("split-pane-1", `
 overflow: hidden;
 `), ue("split-pane-2", `
 overflow: hidden;
 flex: 1;
 `), Re("resize-trigger", `
 background-color: var(--n-resize-trigger-color);
 transition: background-color .3s var(--n-bezier);
 `, [Ue("hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `), Ge("&:hover", `
 background-color: var(--n-resize-trigger-color-hover);
 `)])]), M5 = Object.assign(Object.assign({}, Kt.props), { direction: { type: String, default: "horizontal" }, resizeTriggerSize: { type: Number, default: 3 }, disabled: Boolean, defaultSize: { type: [String, Number], default: 0.5 }, "onUpdate:size": [Function, Array], onUpdateSize: [Function, Array], size: [String, Number], min: { type: [String, Number], default: 0 }, max: { type: [String, Number], default: 1 }, pane1Class: String, pane1Style: [Object, String], pane2Class: String, pane2Style: [Object, String], onDragStart: Function, onDragMove: Function, onDragEnd: Function, watchProps: Array }), M_ = st({ name: "Split", props: M5, slots: Object, setup(r) {
  var i;
  const { mergedClsPrefixRef: l, inlineThemeDisabled: d } = Tr(r), f = Kt("Split", "-split", I5, K2, r, l), g = ze(() => {
    const { common: { cubicBezierEaseInOut: ie }, self: { resizableTriggerColor: ee, resizableTriggerColorHover: re } } = f.value;
    return { "--n-bezier": ie, "--n-resize-trigger-color": ee, "--n-resize-trigger-color-hover": re };
  }), m = Ae(null), s = Ae(false), C = Dt(r, "size"), T = Ae(r.defaultSize);
  !((i = r.watchProps) === null || i === void 0) && i.includes("defaultSize") && po(() => T.value = r.defaultSize);
  const M = (ie) => {
    const ee = r["onUpdate:size"];
    r.onUpdateSize && Ot(r.onUpdateSize, ie), ee && Ot(ee, ie), T.value = ie;
  }, z = Zi(C, T), L = ze(() => {
    const ie = z.value;
    if (typeof ie == "string") return { flex: `0 0 ${ie}` };
    if (typeof ie == "number") {
      const ee = ie * 100;
      return { flex: `0 0 calc(${ee}% - ${r.resizeTriggerSize * ee / 100}px)` };
    }
  }), A = ze(() => r.direction === "horizontal" ? { width: `${r.resizeTriggerSize}px`, height: "100%" } : { width: "100%", height: `${r.resizeTriggerSize}px` }), O = ze(() => {
    const ie = r.direction === "horizontal";
    return { width: ie ? `${r.resizeTriggerSize}px` : "", height: ie ? "" : `${r.resizeTriggerSize}px`, cursor: r.direction === "horizontal" ? "col-resize" : "row-resize" };
  });
  let V = 0;
  const X = (ie) => {
    ie.preventDefault(), s.value = true, r.onDragStart && r.onDragStart(ie);
    const ee = "mousemove", re = "mouseup", J = (oe) => {
      W(oe), r.onDragMove && r.onDragMove(oe);
    }, Se = () => {
      Hn(ee, document, J), Hn(re, document, Se), s.value = false, r.onDragEnd && r.onDragEnd(ie), document.body.style.cursor = "";
    };
    document.body.style.cursor = O.value.cursor, En(ee, document, J), En(re, document, Se);
    const fe = m.value;
    if (fe) {
      const oe = fe.getBoundingClientRect();
      r.direction === "horizontal" ? V = ie.clientX - oe.left : V = oe.top - ie.clientY;
    }
    W(ie);
  };
  function W(ie) {
    var ee, re;
    const J = (re = (ee = m.value) === null || ee === void 0 ? void 0 : ee.parentElement) === null || re === void 0 ? void 0 : re.getBoundingClientRect();
    if (!J) return;
    const { direction: Se } = r, fe = J.width - r.resizeTriggerSize, oe = J.height - r.resizeTriggerSize, he = Se === "horizontal" ? fe : oe, be = Se === "horizontal" ? ie.clientX - J.left - V : ie.clientY - J.top + V, { min: je, max: Ve } = r, Ke = typeof je == "string" ? Ji(je) : je * he, lt = typeof Ve == "string" ? Ji(Ve) : Ve * he;
    let vt = be;
    vt = Math.max(vt, Ke), vt = Math.min(vt, lt, he), typeof z.value == "string" ? M(`${vt}px`) : M(vt / he);
  }
  const K = d ? mi("split", void 0, g, r) : void 0;
  return { themeClass: K == null ? void 0 : K.themeClass, onRender: K == null ? void 0 : K.onRender, cssVars: d ? void 0 : g, resizeTriggerElRef: m, isDragging: s, mergedClsPrefix: l, resizeTriggerWrapperStyle: O, resizeTriggerStyle: A, handleMouseDown: X, firstPaneStyle: L };
}, render() {
  var r, i, l, d, f;
  return (r = this.onRender) === null || r === void 0 || r.call(this), F("div", { class: [`${this.mergedClsPrefix}-split`, `${this.mergedClsPrefix}-split--${this.direction}`, this.themeClass], style: this.cssVars }, F("div", { class: [`${this.mergedClsPrefix}-split-pane-1`, this.pane1Class], style: [this.firstPaneStyle, this.pane1Style] }, (l = (i = this.$slots)[1]) === null || l === void 0 ? void 0 : l.call(i)), !this.disabled && F("div", { ref: "resizeTriggerElRef", class: `${this.mergedClsPrefix}-split__resize-trigger-wrapper`, style: this.resizeTriggerWrapperStyle, onMousedown: this.handleMouseDown }, Un(this.$slots["resize-trigger"], () => [F("div", { style: this.resizeTriggerStyle, class: [`${this.mergedClsPrefix}-split__resize-trigger`, this.isDragging && `${this.mergedClsPrefix}-split__resize-trigger--hover`] })])), F("div", { class: [`${this.mergedClsPrefix}-split-pane-2`, this.pane2Class], style: this.pane2Style }, (f = (d = this.$slots)[2]) === null || f === void 0 ? void 0 : f.call(d)));
} }), E5 = ue("switch", `
 height: var(--n-height);
 min-width: var(--n-width);
 vertical-align: middle;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 outline: none;
 justify-content: center;
 align-items: center;
`, [Re("children-placeholder", `
 height: var(--n-rail-height);
 display: flex;
 flex-direction: column;
 overflow: hidden;
 pointer-events: none;
 visibility: hidden;
 `), Re("rail-placeholder", `
 display: flex;
 flex-wrap: none;
 `), Re("button-placeholder", `
 width: calc(1.75 * var(--n-rail-height));
 height: var(--n-rail-height);
 `), ue("base-loading", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 font-size: calc(var(--n-button-width) - 4px);
 color: var(--n-loading-color);
 transition: color .3s var(--n-bezier);
 `, [Nd({ left: "50%", top: "50%", originalTransform: "translateX(-50%) translateY(-50%)" })]), Re("checked, unchecked", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 box-sizing: border-box;
 position: absolute;
 white-space: nowrap;
 top: 0;
 bottom: 0;
 display: flex;
 align-items: center;
 line-height: 1;
 `), Re("checked", `
 right: 0;
 padding-right: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), Re("unchecked", `
 left: 0;
 justify-content: flex-end;
 padding-left: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), Ge("&:focus", [Re("rail", `
 box-shadow: var(--n-box-shadow-focus);
 `)]), Ue("round", [Re("rail", "border-radius: calc(var(--n-rail-height) / 2);", [Re("button", "border-radius: calc(var(--n-button-height) / 2);")])]), pi("disabled", [pi("icon", [Ue("rubber-band", [Ue("pressed", [Re("rail", [Re("button", "max-width: var(--n-button-width-pressed);")])]), Re("rail", [Ge("&:active", [Re("button", "max-width: var(--n-button-width-pressed);")])]), Ue("active", [Ue("pressed", [Re("rail", [Re("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])]), Re("rail", [Ge("&:active", [Re("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])])])])])]), Ue("active", [Re("rail", [Re("button", "left: calc(100% - var(--n-button-width) - var(--n-offset))")])]), Re("rail", `
 overflow: hidden;
 height: var(--n-rail-height);
 min-width: var(--n-rail-width);
 border-radius: var(--n-rail-border-radius);
 cursor: pointer;
 position: relative;
 transition:
 opacity .3s var(--n-bezier),
 background .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [Re("button-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 font-size: calc(var(--n-button-height) - 4px);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 line-height: 1;
 `, [Nd()]), Re("button", `
 align-items: center; 
 top: var(--n-offset);
 left: var(--n-offset);
 height: var(--n-button-height);
 width: var(--n-button-width-pressed);
 max-width: var(--n-button-width);
 border-radius: var(--n-button-border-radius);
 background-color: var(--n-button-color);
 box-shadow: var(--n-button-box-shadow);
 box-sizing: border-box;
 cursor: inherit;
 content: "";
 position: absolute;
 transition:
 background-color .3s var(--n-bezier),
 left .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 max-width .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `)]), Ue("active", [Re("rail", "background-color: var(--n-rail-color-active);")]), Ue("loading", [Re("rail", `
 cursor: wait;
 `)]), Ue("disabled", [Re("rail", `
 cursor: not-allowed;
 opacity: .5;
 `)])]), R5 = Object.assign(Object.assign({}, Kt.props), { size: { type: String, default: "medium" }, value: { type: [String, Number, Boolean], default: void 0 }, loading: Boolean, defaultValue: { type: [String, Number, Boolean], default: false }, disabled: { type: Boolean, default: void 0 }, round: { type: Boolean, default: true }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], checkedValue: { type: [String, Number, Boolean], default: true }, uncheckedValue: { type: [String, Number, Boolean], default: false }, railStyle: Function, rubberBand: { type: Boolean, default: true }, onChange: [Function, Array] });
let Td;
const qb = st({ name: "Switch", props: R5, slots: Object, setup(r) {
  Td === void 0 && (typeof CSS < "u" ? typeof CSS.supports < "u" ? Td = CSS.supports("width", "max(1px)") : Td = false : Td = true);
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Tr(r), d = Kt("Switch", "-switch", E5, J2, r, i), f = va(r), { mergedSizeRef: g, mergedDisabledRef: m } = f, s = Ae(r.defaultValue), C = Dt(r, "value"), T = Zi(C, s), M = ze(() => T.value === r.checkedValue), z = Ae(false), L = Ae(false), A = ze(() => {
    const { railStyle: fe } = r;
    if (fe) return fe({ focused: L.value, checked: M.value });
  });
  function O(fe) {
    const { "onUpdate:value": oe, onChange: he, onUpdateValue: be } = r, { nTriggerFormInput: je, nTriggerFormChange: Ve } = f;
    oe && Ot(oe, fe), be && Ot(be, fe), he && Ot(he, fe), s.value = fe, je(), Ve();
  }
  function V() {
    const { nTriggerFormFocus: fe } = f;
    fe();
  }
  function X() {
    const { nTriggerFormBlur: fe } = f;
    fe();
  }
  function W() {
    r.loading || m.value || (T.value !== r.checkedValue ? O(r.checkedValue) : O(r.uncheckedValue));
  }
  function K() {
    L.value = true, V();
  }
  function ie() {
    L.value = false, X(), z.value = false;
  }
  function ee(fe) {
    r.loading || m.value || fe.key === " " && (T.value !== r.checkedValue ? O(r.checkedValue) : O(r.uncheckedValue), z.value = false);
  }
  function re(fe) {
    r.loading || m.value || fe.key === " " && (fe.preventDefault(), z.value = true);
  }
  const J = ze(() => {
    const { value: fe } = g, { self: { opacityDisabled: oe, railColor: he, railColorActive: be, buttonBoxShadow: je, buttonColor: Ve, boxShadowFocus: Ke, loadingColor: lt, textColor: vt, iconColor: wt, [jt("buttonHeight", fe)]: at, [jt("buttonWidth", fe)]: et, [jt("buttonWidthPressed", fe)]: ht, [jt("railHeight", fe)]: yt, [jt("railWidth", fe)]: nt, [jt("railBorderRadius", fe)]: ut, [jt("buttonBorderRadius", fe)]: Ft }, common: { cubicBezierEaseInOut: Ht } } = d.value;
    let zt, pr, Qt;
    return Td ? (zt = `calc((${yt} - ${at}) / 2)`, pr = `max(${yt}, ${at})`, Qt = `max(${nt}, calc(${nt} + ${at} - ${yt}))`) : (zt = Nn((Ji(yt) - Ji(at)) / 2), pr = Nn(Math.max(Ji(yt), Ji(at))), Qt = Ji(yt) > Ji(at) ? nt : Nn(Ji(nt) + Ji(at) - Ji(yt))), { "--n-bezier": Ht, "--n-button-border-radius": Ft, "--n-button-box-shadow": je, "--n-button-color": Ve, "--n-button-width": et, "--n-button-width-pressed": ht, "--n-button-height": at, "--n-height": pr, "--n-offset": zt, "--n-opacity-disabled": oe, "--n-rail-border-radius": ut, "--n-rail-color": he, "--n-rail-color-active": be, "--n-rail-height": yt, "--n-rail-width": nt, "--n-width": Qt, "--n-box-shadow-focus": Ke, "--n-loading-color": lt, "--n-text-color": vt, "--n-icon-color": wt };
  }), Se = l ? mi("switch", ze(() => g.value[0]), J, r) : void 0;
  return { handleClick: W, handleBlur: ie, handleFocus: K, handleKeyup: ee, handleKeydown: re, mergedRailStyle: A, pressed: z, mergedClsPrefix: i, mergedValue: T, checked: M, mergedDisabled: m, cssVars: l ? void 0 : J, themeClass: Se == null ? void 0 : Se.themeClass, onRender: Se == null ? void 0 : Se.onRender };
}, render() {
  const { mergedClsPrefix: r, mergedDisabled: i, checked: l, mergedRailStyle: d, onRender: f, $slots: g } = this;
  f == null ? void 0 : f();
  const { checked: m, unchecked: s, icon: C, "checked-icon": T, "unchecked-icon": M } = g, z = !(Rm(C) && Rm(T) && Rm(M));
  return F("div", { role: "switch", "aria-checked": l, class: [`${r}-switch`, this.themeClass, z && `${r}-switch--icon`, l && `${r}-switch--active`, i && `${r}-switch--disabled`, this.round && `${r}-switch--round`, this.loading && `${r}-switch--loading`, this.pressed && `${r}-switch--pressed`, this.rubberBand && `${r}-switch--rubber-band`], tabindex: this.mergedDisabled ? void 0 : 0, style: this.cssVars, onClick: this.handleClick, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyup: this.handleKeyup, onKeydown: this.handleKeydown }, F("div", { class: `${r}-switch__rail`, "aria-hidden": "true", style: d }, Ci(m, (L) => Ci(s, (A) => L || A ? F("div", { "aria-hidden": true, class: `${r}-switch__children-placeholder` }, F("div", { class: `${r}-switch__rail-placeholder` }, F("div", { class: `${r}-switch__button-placeholder` }), L), F("div", { class: `${r}-switch__rail-placeholder` }, F("div", { class: `${r}-switch__button-placeholder` }), A)) : null)), F("div", { class: `${r}-switch__button` }, Ci(C, (L) => Ci(T, (A) => Ci(M, (O) => F(tp, null, { default: () => this.loading ? F(ip, { key: "loading", clsPrefix: r, strokeWidth: 20 }) : this.checked && (A || L) ? F("div", { class: `${r}-switch__button-icon`, key: A ? "checked-icon" : "icon" }, A || L) : !this.checked && (O || L) ? F("div", { class: `${r}-switch__button-icon`, key: O ? "unchecked-icon" : "icon" }, O || L) : null })))), Ci(m, (L) => L && F("div", { key: "checked", class: `${r}-switch__checked` }, L)), Ci(s, (L) => L && F("div", { key: "unchecked", class: `${r}-switch__unchecked` }, L)))));
} }), Kg = An("n-tabs"), Gb = { tab: [String, Number, Object, Function], name: { type: [String, Number], required: true }, disabled: Boolean, displayDirective: { type: String, default: "if" }, closable: { type: Boolean, default: void 0 }, tabProps: Object, label: [String, Number, Object, Function] }, E_ = st({ __TAB_PANE__: true, name: "TabPane", alias: ["TabPanel"], props: Gb, slots: Object, setup(r) {
  const i = fr(Kg, null);
  return i || Zo("tab-pane", "`n-tab-pane` must be placed inside `n-tabs`."), { style: i.paneStyleRef, class: i.paneClassRef, mergedClsPrefix: i.mergedClsPrefixRef };
}, render() {
  return F("div", { class: [`${this.mergedClsPrefix}-tab-pane`, this.class], style: this.style }, this.$slots);
} }), A5 = Object.assign({ internalLeftPadded: Boolean, internalAddable: Boolean, internalCreatedByPane: Boolean }, qy(Gb, ["displayDirective"])), Tg = st({ __TAB__: true, inheritAttrs: false, name: "Tab", props: A5, setup(r) {
  const { mergedClsPrefixRef: i, valueRef: l, typeRef: d, closableRef: f, tabStyleRef: g, addTabStyleRef: m, tabClassRef: s, addTabClassRef: C, tabChangeIdRef: T, onBeforeLeaveRef: M, triggerRef: z, handleAdd: L, activateTab: A, handleClose: O } = fr(Kg);
  return { trigger: z, mergedClosable: ze(() => {
    if (r.internalAddable) return false;
    const { closable: V } = r;
    return V === void 0 ? f.value : V;
  }), style: g, addStyle: m, tabClass: s, addTabClass: C, clsPrefix: i, value: l, type: d, handleClose(V) {
    V.stopPropagation(), !r.disabled && O(r.name);
  }, activateTab() {
    if (r.disabled) return;
    if (r.internalAddable) {
      L();
      return;
    }
    const { name: V } = r, X = ++T.id;
    if (V !== l.value) {
      const { value: W } = M;
      W ? Promise.resolve(W(r.name, l.value)).then((K) => {
        K && T.id === X && A(V);
      }) : A(V);
    }
  } };
}, render() {
  const { internalAddable: r, clsPrefix: i, name: l, disabled: d, label: f, tab: g, value: m, mergedClosable: s, trigger: C, $slots: { default: T } } = this, M = f ?? g;
  return F("div", { class: `${i}-tabs-tab-wrapper` }, this.internalLeftPadded ? F("div", { class: `${i}-tabs-tab-pad` }) : null, F("div", Object.assign({ key: l, "data-name": l, "data-disabled": d ? true : void 0 }, Ya({ class: [`${i}-tabs-tab`, m === l && `${i}-tabs-tab--active`, d && `${i}-tabs-tab--disabled`, s && `${i}-tabs-tab--closable`, r && `${i}-tabs-tab--addable`, r ? this.addTabClass : this.tabClass], onClick: C === "click" ? this.activateTab : void 0, onMouseenter: C === "hover" ? this.activateTab : void 0, style: r ? this.addStyle : this.style }, this.internalCreatedByPane ? this.tabProps || {} : this.$attrs)), F("span", { class: `${i}-tabs-tab__label` }, r ? F(Gr, null, F("div", { class: `${i}-tabs-tab__height-placeholder` }, "\xA0"), F(Nr, { clsPrefix: i }, { default: () => F(dp, null) })) : T ? T() : typeof M == "object" ? M : vl(M ?? l)), s && this.type === "card" ? F(np, { clsPrefix: i, class: `${i}-tabs-tab__close`, onClick: this.handleClose, disabled: d }) : null));
} }), D5 = ue("tabs", `
 box-sizing: border-box;
 width: 100%;
 display: flex;
 flex-direction: column;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
`, [Ue("segment-type", [ue("tabs-rail", [Ge("&.transition-disabled", [ue("tabs-capsule", `
 transition: none;
 `)])])]), Ue("top", [ue("tab-pane", `
 padding: var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left);
 `)]), Ue("left", [ue("tab-pane", `
 padding: var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left) var(--n-pane-padding-top);
 `)]), Ue("left, right", `
 flex-direction: row;
 `, [ue("tabs-bar", `
 width: 2px;
 right: 0;
 transition:
 top .2s var(--n-bezier),
 max-height .2s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), ue("tabs-tab", `
 padding: var(--n-tab-padding-vertical); 
 `)]), Ue("right", `
 flex-direction: row-reverse;
 `, [ue("tab-pane", `
 padding: var(--n-pane-padding-left) var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom);
 `), ue("tabs-bar", `
 left: 0;
 `)]), Ue("bottom", `
 flex-direction: column-reverse;
 justify-content: flex-end;
 `, [ue("tab-pane", `
 padding: var(--n-pane-padding-bottom) var(--n-pane-padding-right) var(--n-pane-padding-top) var(--n-pane-padding-left);
 `), ue("tabs-bar", `
 top: 0;
 `)]), ue("tabs-rail", `
 position: relative;
 padding: 3px;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 background-color: var(--n-color-segment);
 transition: background-color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [ue("tabs-capsule", `
 border-radius: var(--n-tab-border-radius);
 position: absolute;
 pointer-events: none;
 background-color: var(--n-tab-color-segment);
 box-shadow: 0 1px 3px 0 rgba(0, 0, 0, .08);
 transition: transform 0.3s var(--n-bezier);
 `), ue("tabs-tab-wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [ue("tabs-tab", `
 overflow: hidden;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [Ue("active", `
 font-weight: var(--n-font-weight-strong);
 color: var(--n-tab-text-color-active);
 `), Ge("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])])]), Ue("flex", [ue("tabs-nav", `
 width: 100%;
 position: relative;
 `, [ue("tabs-wrapper", `
 width: 100%;
 `, [ue("tabs-tab", `
 margin-right: 0;
 `)])])]), ue("tabs-nav", `
 box-sizing: border-box;
 line-height: 1.5;
 display: flex;
 transition: border-color .3s var(--n-bezier);
 `, [Re("prefix, suffix", `
 display: flex;
 align-items: center;
 `), Re("prefix", "padding-right: 16px;"), Re("suffix", "padding-left: 16px;")]), Ue("top, bottom", [Ge(">", [ue("tabs-nav", [ue("tabs-nav-scroll-wrapper", [Ge("&::before", `
 top: 0;
 bottom: 0;
 left: 0;
 width: 20px;
 `), Ge("&::after", `
 top: 0;
 bottom: 0;
 right: 0;
 width: 20px;
 `), Ue("shadow-start", [Ge("&::before", `
 box-shadow: inset 10px 0 8px -8px rgba(0, 0, 0, .12);
 `)]), Ue("shadow-end", [Ge("&::after", `
 box-shadow: inset -10px 0 8px -8px rgba(0, 0, 0, .12);
 `)])])])])]), Ue("left, right", [ue("tabs-nav-scroll-content", `
 flex-direction: column;
 `), Ge(">", [ue("tabs-nav", [ue("tabs-nav-scroll-wrapper", [Ge("&::before", `
 top: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), Ge("&::after", `
 bottom: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), Ue("shadow-start", [Ge("&::before", `
 box-shadow: inset 0 10px 8px -8px rgba(0, 0, 0, .12);
 `)]), Ue("shadow-end", [Ge("&::after", `
 box-shadow: inset 0 -10px 8px -8px rgba(0, 0, 0, .12);
 `)])])])])]), ue("tabs-nav-scroll-wrapper", `
 flex: 1;
 position: relative;
 overflow: hidden;
 `, [ue("tabs-nav-y-scroll", `
 height: 100%;
 width: 100%;
 overflow-y: auto; 
 scrollbar-width: none;
 `, [Ge("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `)]), Ge("&::before, &::after", `
 transition: box-shadow .3s var(--n-bezier);
 pointer-events: none;
 content: "";
 position: absolute;
 z-index: 1;
 `)]), ue("tabs-nav-scroll-content", `
 display: flex;
 position: relative;
 min-width: 100%;
 min-height: 100%;
 width: fit-content;
 box-sizing: border-box;
 `), ue("tabs-wrapper", `
 display: inline-flex;
 flex-wrap: nowrap;
 position: relative;
 `), ue("tabs-tab-wrapper", `
 display: flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 flex-grow: 0;
 `), ue("tabs-tab", `
 cursor: pointer;
 white-space: nowrap;
 flex-wrap: nowrap;
 display: inline-flex;
 align-items: center;
 color: var(--n-tab-text-color);
 font-size: var(--n-tab-font-size);
 background-clip: padding-box;
 padding: var(--n-tab-padding);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [Ue("disabled", { cursor: "not-allowed" }), Re("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), Re("label", `
 display: flex;
 align-items: center;
 z-index: 1;
 `)]), ue("tabs-bar", `
 position: absolute;
 bottom: 0;
 height: 2px;
 border-radius: 1px;
 background-color: var(--n-bar-color);
 transition:
 left .2s var(--n-bezier),
 max-width .2s var(--n-bezier),
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [Ge("&.transition-disabled", `
 transition: none;
 `), Ue("disabled", `
 background-color: var(--n-tab-text-color-disabled)
 `)]), ue("tabs-pane-wrapper", `
 position: relative;
 overflow: hidden;
 transition: max-height .2s var(--n-bezier);
 `), ue("tab-pane", `
 color: var(--n-pane-text-color);
 width: 100%;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .2s var(--n-bezier);
 left: 0;
 right: 0;
 top: 0;
 `, [Ge("&.next-transition-leave-active, &.prev-transition-leave-active, &.next-transition-enter-active, &.prev-transition-enter-active", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .2s var(--n-bezier),
 opacity .2s var(--n-bezier);
 `), Ge("&.next-transition-leave-active, &.prev-transition-leave-active", `
 position: absolute;
 `), Ge("&.next-transition-enter-from, &.prev-transition-leave-to", `
 transform: translateX(32px);
 opacity: 0;
 `), Ge("&.next-transition-leave-to, &.prev-transition-enter-from", `
 transform: translateX(-32px);
 opacity: 0;
 `), Ge("&.next-transition-leave-from, &.next-transition-enter-to, &.prev-transition-leave-from, &.prev-transition-enter-to", `
 transform: translateX(0);
 opacity: 1;
 `)]), ue("tabs-tab-pad", `
 box-sizing: border-box;
 width: var(--n-tab-gap);
 flex-grow: 0;
 flex-shrink: 0;
 `), Ue("line-type, bar-type", [ue("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 box-sizing: border-box;
 vertical-align: bottom;
 `, [Ge("&:hover", { color: "var(--n-tab-text-color-hover)" }), Ue("active", `
 color: var(--n-tab-text-color-active);
 font-weight: var(--n-tab-font-weight-active);
 `), Ue("disabled", { color: "var(--n-tab-text-color-disabled)" })])]), ue("tabs-nav", [Ue("line-type", [Ue("top", [Re("prefix, suffix", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), ue("tabs-nav-scroll-content", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), ue("tabs-bar", `
 bottom: -1px;
 `)]), Ue("left", [Re("prefix, suffix", `
 border-right: 1px solid var(--n-tab-border-color);
 `), ue("tabs-nav-scroll-content", `
 border-right: 1px solid var(--n-tab-border-color);
 `), ue("tabs-bar", `
 right: -1px;
 `)]), Ue("right", [Re("prefix, suffix", `
 border-left: 1px solid var(--n-tab-border-color);
 `), ue("tabs-nav-scroll-content", `
 border-left: 1px solid var(--n-tab-border-color);
 `), ue("tabs-bar", `
 left: -1px;
 `)]), Ue("bottom", [Re("prefix, suffix", `
 border-top: 1px solid var(--n-tab-border-color);
 `), ue("tabs-nav-scroll-content", `
 border-top: 1px solid var(--n-tab-border-color);
 `), ue("tabs-bar", `
 top: -1px;
 `)]), Re("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 `), ue("tabs-nav-scroll-content", `
 transition: border-color .3s var(--n-bezier);
 `), ue("tabs-bar", `
 border-radius: 0;
 `)]), Ue("card-type", [Re("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 `), ue("tabs-pad", `
 flex-grow: 1;
 transition: border-color .3s var(--n-bezier);
 `), ue("tabs-tab-pad", `
 transition: border-color .3s var(--n-bezier);
 `), ue("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 border: 1px solid var(--n-tab-border-color);
 background-color: var(--n-tab-color);
 box-sizing: border-box;
 position: relative;
 vertical-align: bottom;
 display: flex;
 justify-content: space-between;
 font-size: var(--n-tab-font-size);
 color: var(--n-tab-text-color);
 `, [Ue("addable", `
 padding-left: 8px;
 padding-right: 8px;
 font-size: 16px;
 justify-content: center;
 `, [Re("height-placeholder", `
 width: 0;
 font-size: var(--n-tab-font-size);
 `), pi("disabled", [Ge("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])]), Ue("closable", "padding-right: 8px;"), Ue("active", `
 background-color: #0000;
 font-weight: var(--n-tab-font-weight-active);
 color: var(--n-tab-text-color-active);
 `), Ue("disabled", "color: var(--n-tab-text-color-disabled);")])]), Ue("left, right", `
 flex-direction: column; 
 `, [Re("prefix, suffix", `
 padding: var(--n-tab-padding-vertical);
 `), ue("tabs-wrapper", `
 flex-direction: column;
 `), ue("tabs-tab-wrapper", `
 flex-direction: column;
 `, [ue("tabs-tab-pad", `
 height: var(--n-tab-gap-vertical);
 width: 100%;
 `)])]), Ue("top", [Ue("card-type", [ue("tabs-scroll-padding", "border-bottom: 1px solid var(--n-tab-border-color);"), Re("prefix, suffix", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), ue("tabs-tab", `
 border-top-left-radius: var(--n-tab-border-radius);
 border-top-right-radius: var(--n-tab-border-radius);
 `, [Ue("active", `
 border-bottom: 1px solid #0000;
 `)]), ue("tabs-tab-pad", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), ue("tabs-pad", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `)])]), Ue("left", [Ue("card-type", [ue("tabs-scroll-padding", "border-right: 1px solid var(--n-tab-border-color);"), Re("prefix, suffix", `
 border-right: 1px solid var(--n-tab-border-color);
 `), ue("tabs-tab", `
 border-top-left-radius: var(--n-tab-border-radius);
 border-bottom-left-radius: var(--n-tab-border-radius);
 `, [Ue("active", `
 border-right: 1px solid #0000;
 `)]), ue("tabs-tab-pad", `
 border-right: 1px solid var(--n-tab-border-color);
 `), ue("tabs-pad", `
 border-right: 1px solid var(--n-tab-border-color);
 `)])]), Ue("right", [Ue("card-type", [ue("tabs-scroll-padding", "border-left: 1px solid var(--n-tab-border-color);"), Re("prefix, suffix", `
 border-left: 1px solid var(--n-tab-border-color);
 `), ue("tabs-tab", `
 border-top-right-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [Ue("active", `
 border-left: 1px solid #0000;
 `)]), ue("tabs-tab-pad", `
 border-left: 1px solid var(--n-tab-border-color);
 `), ue("tabs-pad", `
 border-left: 1px solid var(--n-tab-border-color);
 `)])]), Ue("bottom", [Ue("card-type", [ue("tabs-scroll-padding", "border-top: 1px solid var(--n-tab-border-color);"), Re("prefix, suffix", `
 border-top: 1px solid var(--n-tab-border-color);
 `), ue("tabs-tab", `
 border-bottom-left-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [Ue("active", `
 border-top: 1px solid #0000;
 `)]), ue("tabs-tab-pad", `
 border-top: 1px solid var(--n-tab-border-color);
 `), ue("tabs-pad", `
 border-top: 1px solid var(--n-tab-border-color);
 `)])])])]), Wm = d3, z5 = Object.assign(Object.assign({}, Kt.props), { value: [String, Number], defaultValue: [String, Number], trigger: { type: String, default: "click" }, type: { type: String, default: "bar" }, closable: Boolean, justifyContent: String, size: { type: String, default: "medium" }, placement: { type: String, default: "top" }, tabStyle: [String, Object], tabClass: String, addTabStyle: [String, Object], addTabClass: String, barWidth: Number, paneClass: String, paneStyle: [String, Object], paneWrapperClass: String, paneWrapperStyle: [String, Object], addable: [Boolean, Object], tabsPadding: { type: Number, default: 0 }, animated: Boolean, onBeforeLeave: Function, onAdd: Function, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onClose: [Function, Array], labelSize: String, activeName: [String, Number], onActiveNameChange: [Function, Array] }), F5 = st({ name: "Tabs", props: z5, slots: Object, setup(r, { slots: i }) {
  var l, d, f, g;
  const { mergedClsPrefixRef: m, inlineThemeDisabled: s } = Tr(r), C = Kt("Tabs", "-tabs", D5, Q2, r, m), T = Ae(null), M = Ae(null), z = Ae(null), L = Ae(null), A = Ae(null), O = Ae(null), V = Ae(true), X = Ae(true), W = Gf(r, ["labelSize", "size"]), K = Gf(r, ["activeName", "value"]), ie = Ae((d = (l = K.value) !== null && l !== void 0 ? l : r.defaultValue) !== null && d !== void 0 ? d : i.default ? (g = (f = kl(i.default())[0]) === null || f === void 0 ? void 0 : f.props) === null || g === void 0 ? void 0 : g.name : null), ee = Zi(K, ie), re = { id: 0 }, J = ze(() => {
    if (!(!r.justifyContent || r.type === "card")) return { display: "flex", justifyContent: r.justifyContent };
  });
  ar(ee, () => {
    re.id = 0, be(), je();
  });
  function Se() {
    var Le;
    const { value: Ye } = ee;
    return Ye === null ? null : (Le = T.value) === null || Le === void 0 ? void 0 : Le.querySelector(`[data-name="${Ye}"]`);
  }
  function fe(Le) {
    if (r.type === "card") return;
    const { value: Ye } = M;
    if (!Ye) return;
    const ft = Ye.style.opacity === "0";
    if (Le) {
      const bt = `${m.value}-tabs-bar--disabled`, { barWidth: tt, placement: mt } = r;
      if (Le.dataset.disabled === "true" ? Ye.classList.add(bt) : Ye.classList.remove(bt), ["top", "bottom"].includes(mt)) {
        if (he(["top", "maxHeight", "height"]), typeof tt == "number" && Le.offsetWidth >= tt) {
          const Zt = Math.floor((Le.offsetWidth - tt) / 2) + Le.offsetLeft;
          Ye.style.left = `${Zt}px`, Ye.style.maxWidth = `${tt}px`;
        } else Ye.style.left = `${Le.offsetLeft}px`, Ye.style.maxWidth = `${Le.offsetWidth}px`;
        Ye.style.width = "8192px", ft && (Ye.style.transition = "none"), Ye.offsetWidth, ft && (Ye.style.transition = "", Ye.style.opacity = "1");
      } else {
        if (he(["left", "maxWidth", "width"]), typeof tt == "number" && Le.offsetHeight >= tt) {
          const Zt = Math.floor((Le.offsetHeight - tt) / 2) + Le.offsetTop;
          Ye.style.top = `${Zt}px`, Ye.style.maxHeight = `${tt}px`;
        } else Ye.style.top = `${Le.offsetTop}px`, Ye.style.maxHeight = `${Le.offsetHeight}px`;
        Ye.style.height = "8192px", ft && (Ye.style.transition = "none"), Ye.offsetHeight, ft && (Ye.style.transition = "", Ye.style.opacity = "1");
      }
    }
  }
  function oe() {
    if (r.type === "card") return;
    const { value: Le } = M;
    Le && (Le.style.opacity = "0");
  }
  function he(Le) {
    const { value: Ye } = M;
    if (Ye) for (const ft of Le) Ye.style[ft] = "";
  }
  function be() {
    if (r.type === "card") return;
    const Le = Se();
    Le ? fe(Le) : oe();
  }
  function je() {
    var Le;
    const Ye = (Le = A.value) === null || Le === void 0 ? void 0 : Le.$el;
    if (!Ye) return;
    const ft = Se();
    if (!ft) return;
    const { scrollLeft: bt, offsetWidth: tt } = Ye, { offsetLeft: mt, offsetWidth: Zt } = ft;
    bt > mt ? Ye.scrollTo({ top: 0, left: mt, behavior: "smooth" }) : mt + Zt > bt + tt && Ye.scrollTo({ top: 0, left: mt + Zt - tt, behavior: "smooth" });
  }
  const Ve = Ae(null);
  let Ke = 0, lt = null;
  function vt(Le) {
    const Ye = Ve.value;
    if (Ye) {
      Ke = Le.getBoundingClientRect().height;
      const ft = `${Ke}px`, bt = () => {
        Ye.style.height = ft, Ye.style.maxHeight = ft;
      };
      lt ? (bt(), lt(), lt = null) : lt = bt;
    }
  }
  function wt(Le) {
    const Ye = Ve.value;
    if (Ye) {
      const ft = Le.getBoundingClientRect().height, bt = () => {
        document.body.offsetHeight, Ye.style.maxHeight = `${ft}px`, Ye.style.height = `${Math.max(Ke, ft)}px`;
      };
      lt ? (lt(), lt = null, bt()) : lt = bt;
    }
  }
  function at() {
    const Le = Ve.value;
    if (Le) {
      Le.style.maxHeight = "", Le.style.height = "";
      const { paneWrapperStyle: Ye } = r;
      if (typeof Ye == "string") Le.style.cssText = Ye;
      else if (Ye) {
        const { maxHeight: ft, height: bt } = Ye;
        ft !== void 0 && (Le.style.maxHeight = ft), bt !== void 0 && (Le.style.height = bt);
      }
    }
  }
  const et = { value: [] }, ht = Ae("next");
  function yt(Le) {
    const Ye = ee.value;
    let ft = "next";
    for (const bt of et.value) {
      if (bt === Ye) break;
      if (bt === Le) {
        ft = "prev";
        break;
      }
    }
    ht.value = ft, nt(Le);
  }
  function nt(Le) {
    const { onActiveNameChange: Ye, onUpdateValue: ft, "onUpdate:value": bt } = r;
    Ye && Ot(Ye, Le), ft && Ot(ft, Le), bt && Ot(bt, Le), ie.value = Le;
  }
  function ut(Le) {
    const { onClose: Ye } = r;
    Ye && Ot(Ye, Le);
  }
  function Ft() {
    const { value: Le } = M;
    if (!Le) return;
    const Ye = "transition-disabled";
    Le.classList.add(Ye), be(), Le.classList.remove(Ye);
  }
  const Ht = Ae(null);
  function zt({ transitionDisabled: Le }) {
    const Ye = T.value;
    if (!Ye) return;
    Le && Ye.classList.add("transition-disabled");
    const ft = Se();
    ft && Ht.value && (Ht.value.style.width = `${ft.offsetWidth}px`, Ht.value.style.height = `${ft.offsetHeight}px`, Ht.value.style.transform = `translateX(${ft.offsetLeft - Ji(getComputedStyle(Ye).paddingLeft)}px)`, Le && Ht.value.offsetWidth), Le && Ye.classList.remove("transition-disabled");
  }
  ar([ee], () => {
    r.type === "segment" && Vn(() => {
      zt({ transitionDisabled: false });
    });
  }), Qi(() => {
    r.type === "segment" && zt({ transitionDisabled: true });
  });
  let pr = 0;
  function Qt(Le) {
    var Ye;
    if (Le.contentRect.width === 0 && Le.contentRect.height === 0 || pr === Le.contentRect.width) return;
    pr = Le.contentRect.width;
    const { type: ft } = r;
    if ((ft === "line" || ft === "bar") && Ft(), ft !== "segment") {
      const { placement: bt } = r;
      Gt((bt === "top" || bt === "bottom" ? (Ye = A.value) === null || Ye === void 0 ? void 0 : Ye.$el : O.value) || null);
    }
  }
  const tr = Wm(Qt, 64);
  ar([() => r.justifyContent, () => r.size], () => {
    Vn(() => {
      const { type: Le } = r;
      (Le === "line" || Le === "bar") && Ft();
    });
  });
  const xr = Ae(false);
  function Mr(Le) {
    var Ye;
    const { target: ft, contentRect: { width: bt, height: tt } } = Le, mt = ft.parentElement.parentElement.offsetWidth, Zt = ft.parentElement.parentElement.offsetHeight, { placement: ri } = r;
    if (!xr.value) ri === "top" || ri === "bottom" ? mt < bt && (xr.value = true) : Zt < tt && (xr.value = true);
    else {
      const { value: Si } = L;
      if (!Si) return;
      ri === "top" || ri === "bottom" ? mt - bt > Si.$el.offsetWidth && (xr.value = false) : Zt - tt > Si.$el.offsetHeight && (xr.value = false);
    }
    Gt(((Ye = A.value) === null || Ye === void 0 ? void 0 : Ye.$el) || null);
  }
  const rr = Wm(Mr, 64);
  function sr() {
    const { onAdd: Le } = r;
    Le && Le(), Vn(() => {
      const Ye = Se(), { value: ft } = A;
      !Ye || !ft || ft.scrollTo({ left: Ye.offsetLeft, top: 0, behavior: "smooth" });
    });
  }
  function Gt(Le) {
    if (!Le) return;
    const { placement: Ye } = r;
    if (Ye === "top" || Ye === "bottom") {
      const { scrollLeft: ft, scrollWidth: bt, offsetWidth: tt } = Le;
      V.value = ft <= 0, X.value = ft + tt >= bt;
    } else {
      const { scrollTop: ft, scrollHeight: bt, offsetHeight: tt } = Le;
      V.value = ft <= 0, X.value = ft + tt >= bt;
    }
  }
  const Dr = Wm((Le) => {
    Gt(Le.target);
  }, 64);
  Yr(Kg, { triggerRef: Dt(r, "trigger"), tabStyleRef: Dt(r, "tabStyle"), tabClassRef: Dt(r, "tabClass"), addTabStyleRef: Dt(r, "addTabStyle"), addTabClassRef: Dt(r, "addTabClass"), paneClassRef: Dt(r, "paneClass"), paneStyleRef: Dt(r, "paneStyle"), mergedClsPrefixRef: m, typeRef: Dt(r, "type"), closableRef: Dt(r, "closable"), valueRef: ee, tabChangeIdRef: re, onBeforeLeaveRef: Dt(r, "onBeforeLeave"), activateTab: yt, handleClose: ut, handleAdd: sr }), My(() => {
    be(), je();
  }), po(() => {
    const { value: Le } = z;
    if (!Le) return;
    const { value: Ye } = m, ft = `${Ye}-tabs-nav-scroll-wrapper--shadow-start`, bt = `${Ye}-tabs-nav-scroll-wrapper--shadow-end`;
    V.value ? Le.classList.remove(ft) : Le.classList.add(ft), X.value ? Le.classList.remove(bt) : Le.classList.add(bt);
  });
  const wr = { syncBarPosition: () => {
    be();
  } }, Ct = () => {
    zt({ transitionDisabled: true });
  }, Ee = ze(() => {
    const { value: Le } = W, { type: Ye } = r, ft = { card: "Card", bar: "Bar", line: "Line", segment: "Segment" }[Ye], bt = `${Le}${ft}`, { self: { barColor: tt, closeIconColor: mt, closeIconColorHover: Zt, closeIconColorPressed: ri, tabColor: Si, tabBorderColor: Fe, paneTextColor: Z, tabFontWeight: H, tabBorderRadius: ne, tabFontWeightActive: xe, colorSegment: ke, fontWeightStrong: De, tabColorSegment: de, closeSize: ve, closeIconSize: $e, closeColorHover: it, closeColorPressed: Xe, closeBorderRadius: xt, [jt("panePadding", Le)]: Te, [jt("tabPadding", bt)]: $t, [jt("tabPaddingVertical", bt)]: er, [jt("tabGap", bt)]: Nt, [jt("tabGap", `${bt}Vertical`)]: ur, [jt("tabTextColor", Ye)]: Br, [jt("tabTextColorActive", Ye)]: Kr, [jt("tabTextColorHover", Ye)]: Jr, [jt("tabTextColorDisabled", Ye)]: ii, [jt("tabFontSize", Le)]: gr }, common: { cubicBezierEaseInOut: vr } } = C.value;
    return { "--n-bezier": vr, "--n-color-segment": ke, "--n-bar-color": tt, "--n-tab-font-size": gr, "--n-tab-text-color": Br, "--n-tab-text-color-active": Kr, "--n-tab-text-color-disabled": ii, "--n-tab-text-color-hover": Jr, "--n-pane-text-color": Z, "--n-tab-border-color": Fe, "--n-tab-border-radius": ne, "--n-close-size": ve, "--n-close-icon-size": $e, "--n-close-color-hover": it, "--n-close-color-pressed": Xe, "--n-close-border-radius": xt, "--n-close-icon-color": mt, "--n-close-icon-color-hover": Zt, "--n-close-icon-color-pressed": ri, "--n-tab-color": Si, "--n-tab-font-weight": H, "--n-tab-font-weight-active": xe, "--n-tab-padding": $t, "--n-tab-padding-vertical": er, "--n-tab-gap": Nt, "--n-tab-gap-vertical": ur, "--n-pane-padding-left": To(Te, "left"), "--n-pane-padding-right": To(Te, "right"), "--n-pane-padding-top": To(Te, "top"), "--n-pane-padding-bottom": To(Te, "bottom"), "--n-font-weight-strong": De, "--n-tab-color-segment": de };
  }), ot = s ? mi("tabs", ze(() => `${W.value[0]}${r.type[0]}`), Ee, r) : void 0;
  return Object.assign({ mergedClsPrefix: m, mergedValue: ee, renderedNames: /* @__PURE__ */ new Set(), segmentCapsuleElRef: Ht, tabsPaneWrapperRef: Ve, tabsElRef: T, barElRef: M, addTabInstRef: L, xScrollInstRef: A, scrollWrapperElRef: z, addTabFixed: xr, tabWrapperStyle: J, handleNavResize: tr, mergedSize: W, handleScroll: Dr, handleTabsResize: rr, cssVars: s ? void 0 : Ee, themeClass: ot == null ? void 0 : ot.themeClass, animationDirection: ht, renderNameListRef: et, yScrollElRef: O, handleSegmentResize: Ct, onAnimationBeforeLeave: vt, onAnimationEnter: wt, onAnimationAfterEnter: at, onRender: ot == null ? void 0 : ot.onRender }, wr);
}, render() {
  const { mergedClsPrefix: r, type: i, placement: l, addTabFixed: d, addable: f, mergedSize: g, renderNameListRef: m, onRender: s, paneWrapperClass: C, paneWrapperStyle: T, $slots: { default: M, prefix: z, suffix: L } } = this;
  s == null ? void 0 : s();
  const A = M ? kl(M()).filter((re) => re.type.__TAB_PANE__ === true) : [], O = M ? kl(M()).filter((re) => re.type.__TAB__ === true) : [], V = !O.length, X = i === "card", W = i === "segment", K = !X && !W && this.justifyContent;
  m.value = [];
  const ie = () => {
    const re = F("div", { style: this.tabWrapperStyle, class: `${r}-tabs-wrapper` }, K ? null : F("div", { class: `${r}-tabs-scroll-padding`, style: l === "top" || l === "bottom" ? { width: `${this.tabsPadding}px` } : { height: `${this.tabsPadding}px` } }), V ? A.map((J, Se) => (m.value.push(J.props.name), Zm(F(Tg, Object.assign({}, J.props, { internalCreatedByPane: true, internalLeftPadded: Se !== 0 && (!K || K === "center" || K === "start" || K === "end") }), J.children ? { default: J.children.tab } : void 0)))) : O.map((J, Se) => (m.value.push(J.props.name), Zm(Se !== 0 && !K ? D_(J) : J))), !d && f && X ? A_(f, (V ? A.length : O.length) !== 0) : null, K ? null : F("div", { class: `${r}-tabs-scroll-padding`, style: { width: `${this.tabsPadding}px` } }));
    return F("div", { ref: "tabsElRef", class: `${r}-tabs-nav-scroll-content` }, X && f ? F(xl, { onResize: this.handleTabsResize }, { default: () => re }) : re, X ? F("div", { class: `${r}-tabs-pad` }) : null, X ? null : F("div", { ref: "barElRef", class: `${r}-tabs-bar` }));
  }, ee = W ? "top" : l;
  return F("div", { class: [`${r}-tabs`, this.themeClass, `${r}-tabs--${i}-type`, `${r}-tabs--${g}-size`, K && `${r}-tabs--flex`, `${r}-tabs--${ee}`], style: this.cssVars }, F("div", { class: [`${r}-tabs-nav--${i}-type`, `${r}-tabs-nav--${ee}`, `${r}-tabs-nav`] }, Ci(z, (re) => re && F("div", { class: `${r}-tabs-nav__prefix` }, re)), W ? F(xl, { onResize: this.handleSegmentResize }, { default: () => F("div", { class: `${r}-tabs-rail`, ref: "tabsElRef" }, F("div", { class: `${r}-tabs-capsule`, ref: "segmentCapsuleElRef" }, F("div", { class: `${r}-tabs-wrapper` }, F("div", { class: `${r}-tabs-tab` }))), V ? A.map((re, J) => (m.value.push(re.props.name), F(Tg, Object.assign({}, re.props, { internalCreatedByPane: true, internalLeftPadded: J !== 0 }), re.children ? { default: re.children.tab } : void 0))) : O.map((re, J) => (m.value.push(re.props.name), J === 0 ? re : D_(re)))) }) : F(xl, { onResize: this.handleNavResize }, { default: () => F("div", { class: `${r}-tabs-nav-scroll-wrapper`, ref: "scrollWrapperElRef" }, ["top", "bottom"].includes(ee) ? F(K3, { ref: "xScrollInstRef", onScroll: this.handleScroll }, { default: ie }) : F("div", { class: `${r}-tabs-nav-y-scroll`, onScroll: this.handleScroll, ref: "yScrollElRef" }, ie())) }), d && f && X ? A_(f, true) : null, Ci(L, (re) => re && F("div", { class: `${r}-tabs-nav__suffix` }, re))), V && (this.animated && (ee === "top" || ee === "bottom") ? F("div", { ref: "tabsPaneWrapperRef", style: T, class: [`${r}-tabs-pane-wrapper`, C] }, R_(A, this.mergedValue, this.renderedNames, this.onAnimationBeforeLeave, this.onAnimationEnter, this.onAnimationAfterEnter, this.animationDirection)) : R_(A, this.mergedValue, this.renderedNames)));
} });
function R_(r, i, l, d, f, g, m) {
  const s = [];
  return r.forEach((C) => {
    const { name: T, displayDirective: M, "display-directive": z } = C.props, L = (O) => M === O || z === O, A = i === T;
    if (C.key !== void 0 && (C.key = T), A || L("show") || L("show:lazy") && l.has(T)) {
      l.has(T) || l.add(T);
      const O = !L("if");
      s.push(O ? ma(C, [[Ka, A]]) : C);
    }
  }), m ? F(Zw, { name: `${m}-transition`, onBeforeLeave: d, onEnter: f, onAfterEnter: g }, { default: () => s }) : s;
}
function A_(r, i) {
  return F(Tg, { ref: "addTabInstRef", key: "__addable", name: "__addable", internalCreatedByPane: true, internalAddable: true, internalLeftPadded: i, disabled: typeof r == "object" && r.disabled });
}
function D_(r) {
  const i = sg(r);
  return i.props ? i.props.internalLeftPadded = true : i.props = { internalLeftPadded: true }, i;
}
function Zm(r) {
  return Array.isArray(r.dynamicProps) ? r.dynamicProps.includes("internalLeftPadded") || r.dynamicProps.push("internalLeftPadded") : r.dynamicProps = ["internalLeftPadded"], r;
}
const L5 = ue("h", `
 font-size: var(--n-font-size);
 font-weight: var(--n-font-weight);
 margin: var(--n-margin);
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
`, [Ge("&:first-child", { marginTop: 0 }), Ue("prefix-bar", { position: "relative", paddingLeft: "var(--n-prefix-width)" }, [Ue("align-text", { paddingLeft: 0 }, [Ge("&::before", { left: "calc(-1 * var(--n-prefix-width))" })]), Ge("&::before", `
 content: "";
 width: var(--n-bar-width);
 border-radius: calc(var(--n-bar-width) / 2);
 transition: background-color .3s var(--n-bezier);
 left: 0;
 top: 0;
 bottom: 0;
 position: absolute;
 `), Ge("&::before", { backgroundColor: "var(--n-bar-color)" })])]), B5 = Object.assign(Object.assign({}, Kt.props), { type: { type: String, default: "default" }, prefix: String, alignText: Boolean }), O5 = (r) => st({ name: `H${r}`, props: B5, setup(i) {
  const { mergedClsPrefixRef: l, inlineThemeDisabled: d } = Tr(i), f = Kt("Typography", "-h", L5, Gy, i, l), g = ze(() => {
    const { type: s } = i, { common: { cubicBezierEaseInOut: C }, self: { headerFontWeight: T, headerTextColor: M, [jt("headerPrefixWidth", r)]: z, [jt("headerFontSize", r)]: L, [jt("headerMargin", r)]: A, [jt("headerBarWidth", r)]: O, [jt("headerBarColor", s)]: V } } = f.value;
    return { "--n-bezier": C, "--n-font-size": L, "--n-margin": A, "--n-bar-color": V, "--n-bar-width": O, "--n-font-weight": T, "--n-text-color": M, "--n-prefix-width": z };
  }), m = d ? mi(`h${r}`, ze(() => i.type[0]), g, i) : void 0;
  return { mergedClsPrefix: l, cssVars: d ? void 0 : g, themeClass: m == null ? void 0 : m.themeClass, onRender: m == null ? void 0 : m.onRender };
}, render() {
  var i;
  const { prefix: l, alignText: d, mergedClsPrefix: f, cssVars: g, $slots: m } = this;
  return (i = this.onRender) === null || i === void 0 || i.call(this), F(`h${r}`, { class: [`${f}-h`, `${f}-h${r}`, this.themeClass, { [`${f}-h--prefix-bar`]: l, [`${f}-h--align-text`]: d }], style: g }, m);
} }), $5 = O5("1"), j5 = ue("p", `
 box-sizing: border-box;
 transition: color .3s var(--n-bezier);
 margin: var(--n-margin);
 font-size: var(--n-font-size);
 line-height: var(--n-line-height);
 color: var(--n-text-color);
`, [Ge("&:first-child", "margin-top: 0;"), Ge("&:last-child", "margin-bottom: 0;")]), N5 = Object.assign(Object.assign({}, Kt.props), { depth: [String, Number] }), Pf = st({ name: "P", props: N5, setup(r) {
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l } = Tr(r), d = Kt("Typography", "-p", j5, Gy, r, i), f = ze(() => {
    const { depth: m } = r, s = m || "1", { common: { cubicBezierEaseInOut: C }, self: { pFontSize: T, pLineHeight: M, pMargin: z, pTextColor: L, [`pTextColor${s}Depth`]: A } } = d.value;
    return { "--n-bezier": C, "--n-font-size": T, "--n-line-height": M, "--n-margin": z, "--n-text-color": m === void 0 ? L : A };
  }), g = l ? mi("p", ze(() => `${r.depth || ""}`), f, r) : void 0;
  return { mergedClsPrefix: i, cssVars: l ? void 0 : f, themeClass: g == null ? void 0 : g.themeClass, onRender: g == null ? void 0 : g.onRender };
}, render() {
  var r;
  return (r = this.onRender) === null || r === void 0 || r.call(this), F("p", { class: [`${this.mergedClsPrefix}-p`, this.themeClass], style: this.cssVars }, this.$slots);
} }), sc = An("n-upload"), V5 = Ge([ue("upload", "width: 100%;", [Ue("dragger-inside", [ue("upload-trigger", `
 display: block;
 `)]), Ue("drag-over", [ue("upload-dragger", `
 border: var(--n-dragger-border-hover);
 `)])]), ue("upload-dragger", `
 cursor: pointer;
 box-sizing: border-box;
 width: 100%;
 text-align: center;
 border-radius: var(--n-border-radius);
 padding: 24px;
 opacity: 1;
 transition:
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 background-color: var(--n-dragger-color);
 border: var(--n-dragger-border);
 `, [Ge("&:hover", `
 border: var(--n-dragger-border-hover);
 `), Ue("disabled", `
 cursor: not-allowed;
 `)]), ue("upload-trigger", `
 display: inline-block;
 box-sizing: border-box;
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [Ge("+", [ue("upload-file-list", "margin-top: 8px;")]), Ue("disabled", `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `), Ue("image-card", `
 width: 96px;
 height: 96px;
 `, [ue("base-icon", `
 font-size: 24px;
 `), ue("upload-dragger", `
 padding: 0;
 height: 100%;
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `)])]), ue("upload-file-list", `
 line-height: var(--n-line-height);
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [Ge("a, img", "outline: none;"), Ue("disabled", `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `, [ue("upload-file", "cursor: not-allowed;")]), Ue("grid", `
 display: grid;
 grid-template-columns: repeat(auto-fill, 96px);
 grid-gap: 8px;
 margin-top: 0;
 `), ue("upload-file", `
 display: block;
 box-sizing: border-box;
 cursor: default;
 padding: 0px 12px 0 6px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `, [Vf(), ue("progress", [Vf({ foldPadding: true })]), Ge("&:hover", `
 background-color: var(--n-item-color-hover);
 `, [ue("upload-file-info", [Re("action", `
 opacity: 1;
 `)])]), Ue("image-type", `
 border-radius: var(--n-border-radius);
 text-decoration: underline;
 text-decoration-color: #0000;
 `, [ue("upload-file-info", `
 padding-top: 0px;
 padding-bottom: 0px;
 width: 100%;
 height: 100%;
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 6px 0;
 `, [ue("progress", `
 padding: 2px 0;
 margin-bottom: 0;
 `), Re("name", `
 padding: 0 8px;
 `), Re("thumbnail", `
 width: 32px;
 height: 32px;
 font-size: 28px;
 display: flex;
 justify-content: center;
 align-items: center;
 `, [Ge("img", `
 width: 100%;
 `)])])]), Ue("text-type", [ue("progress", `
 box-sizing: border-box;
 padding-bottom: 6px;
 margin-bottom: 6px;
 `)]), Ue("image-card-type", `
 position: relative;
 width: 96px;
 height: 96px;
 border: var(--n-item-border-image-card);
 border-radius: var(--n-border-radius);
 padding: 0;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: border-color .3s var(--n-bezier), background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 overflow: hidden;
 `, [ue("progress", `
 position: absolute;
 left: 8px;
 bottom: 8px;
 right: 8px;
 width: unset;
 `), ue("upload-file-info", `
 padding: 0;
 width: 100%;
 height: 100%;
 `, [Re("thumbnail", `
 width: 100%;
 height: 100%;
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 font-size: 36px;
 `, [Ge("img", `
 width: 100%;
 `)])]), Ge("&::before", `
 position: absolute;
 z-index: 1;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 opacity: 0;
 transition: opacity .2s var(--n-bezier);
 content: "";
 `), Ge("&:hover", [Ge("&::before", "opacity: 1;"), ue("upload-file-info", [Re("thumbnail", "opacity: .12;")])])]), Ue("error-status", [Ge("&:hover", `
 background-color: var(--n-item-color-hover-error);
 `), ue("upload-file-info", [Re("name", "color: var(--n-item-text-color-error);"), Re("thumbnail", "color: var(--n-item-text-color-error);")]), Ue("image-card-type", `
 border: var(--n-item-border-image-card-error);
 `)]), Ue("with-url", `
 cursor: pointer;
 `, [ue("upload-file-info", [Re("name", `
 color: var(--n-item-text-color-success);
 text-decoration-color: var(--n-item-text-color-success);
 `, [Ge("a", `
 text-decoration: underline;
 `)])])]), ue("upload-file-info", `
 position: relative;
 padding-top: 6px;
 padding-bottom: 6px;
 display: flex;
 flex-wrap: nowrap;
 `, [Re("thumbnail", `
 font-size: 18px;
 opacity: 1;
 transition: opacity .2s var(--n-bezier);
 color: var(--n-item-icon-color);
 `, [ue("base-icon", `
 margin-right: 2px;
 vertical-align: middle;
 transition: color .3s var(--n-bezier);
 `)]), Re("action", `
 padding-top: inherit;
 padding-bottom: inherit;
 position: absolute;
 right: 0;
 top: 0;
 bottom: 0;
 width: 80px;
 display: flex;
 align-items: center;
 transition: opacity .2s var(--n-bezier);
 justify-content: flex-end;
 opacity: 0;
 `, [ue("button", [Ge("&:not(:last-child)", { marginRight: "4px" }), ue("base-icon", [Ge("svg", [Nd()])])]), Ue("image-type", `
 position: relative;
 max-width: 80px;
 width: auto;
 `), Ue("image-card-type", `
 z-index: 2;
 position: absolute;
 width: 100%;
 height: 100%;
 left: 0;
 right: 0;
 bottom: 0;
 top: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 `)]), Re("name", `
 color: var(--n-item-text-color);
 flex: 1;
 display: flex;
 justify-content: center;
 text-overflow: ellipsis;
 overflow: hidden;
 flex-direction: column;
 text-decoration-color: #0000;
 font-size: var(--n-font-size);
 transition:
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier); 
 `, [Ge("a", `
 color: inherit;
 text-decoration: underline;
 `)])])])]), ue("upload-file-input", `
 display: none;
 width: 0;
 height: 0;
 opacity: 0;
 `)]), Wb = "__UPLOAD_DRAGGER__", Zb = st({ name: "UploadDragger", [Wb]: true, setup(r, { slots: i }) {
  const l = fr(sc, null);
  return l || Zo("upload-dragger", "`n-upload-dragger` must be placed inside `n-upload`."), () => {
    const { mergedClsPrefixRef: { value: d }, mergedDisabledRef: { value: f }, maxReachedRef: { value: g } } = l;
    return F("div", { class: [`${d}-upload-dragger`, (f || g) && `${d}-upload-dragger--disabled`] }, i);
  };
} });
function U5() {
  return F("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 28 28" }, F("g", { fill: "none" }, F("path", { d: "M21.75 3A3.25 3.25 0 0 1 25 6.25v15.5A3.25 3.25 0 0 1 21.75 25H6.25A3.25 3.25 0 0 1 3 21.75V6.25A3.25 3.25 0 0 1 6.25 3h15.5zm.583 20.4l-7.807-7.68a.75.75 0 0 0-.968-.07l-.084.07l-7.808 7.68c.183.065.38.1.584.1h15.5c.204 0 .4-.035.583-.1l-7.807-7.68l7.807 7.68zM21.75 4.5H6.25A1.75 1.75 0 0 0 4.5 6.25v15.5c0 .208.036.408.103.593l7.82-7.692a2.25 2.25 0 0 1 3.026-.117l.129.117l7.82 7.692c.066-.185.102-.385.102-.593V6.25a1.75 1.75 0 0 0-1.75-1.75zm-3.25 3a2.5 2.5 0 1 1 0 5a2.5 2.5 0 0 1 0-5zm0 1.5a1 1 0 1 0 0 2a1 1 0 0 0 0-2z", fill: "currentColor" })));
}
function q5() {
  return F("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 28 28" }, F("g", { fill: "none" }, F("path", { d: "M6.4 2A2.4 2.4 0 0 0 4 4.4v19.2A2.4 2.4 0 0 0 6.4 26h15.2a2.4 2.4 0 0 0 2.4-2.4V11.578c0-.729-.29-1.428-.805-1.944l-6.931-6.931A2.4 2.4 0 0 0 14.567 2H6.4zm-.9 2.4a.9.9 0 0 1 .9-.9H14V10a2 2 0 0 0 2 2h6.5v11.6a.9.9 0 0 1-.9.9H6.4a.9.9 0 0 1-.9-.9V4.4zm16.44 6.1H16a.5.5 0 0 1-.5-.5V4.06l6.44 6.44z", fill: "currentColor" })));
}
const G5 = st({ name: "UploadProgress", props: { show: Boolean, percentage: { type: Number, required: true }, status: { type: String, required: true } }, setup() {
  return { mergedTheme: fr(sc).mergedThemeRef };
}, render() {
  return F(op, null, { default: () => this.show ? F(C5, { type: "line", showIndicator: false, percentage: this.percentage, status: this.status, height: 2, theme: this.mergedTheme.peers.Progress, themeOverrides: this.mergedTheme.peerOverrides.Progress }) : null });
} });
var Ig = function(r, i, l, d) {
  function f(g) {
    return g instanceof l ? g : new l(function(m) {
      m(g);
    });
  }
  return new (l || (l = Promise))(function(g, m) {
    function s(M) {
      try {
        T(d.next(M));
      } catch (z) {
        m(z);
      }
    }
    function C(M) {
      try {
        T(d.throw(M));
      } catch (z) {
        m(z);
      }
    }
    function T(M) {
      M.done ? g(M.value) : f(M.value).then(s, C);
    }
    T((d = d.apply(r, i || [])).next());
  });
};
function Hb(r) {
  return r.includes("image/");
}
function z_(r = "") {
  const i = r.split("/"), d = i[i.length - 1].split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(d) || [""])[0];
}
const F_ = /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i, Xb = (r) => {
  if (r.type) return Hb(r.type);
  const i = z_(r.name || "");
  if (F_.test(i)) return true;
  const l = r.thumbnailUrl || r.url || "", d = z_(l);
  return !!(/^data:image\//.test(l) || F_.test(d));
};
function W5(r) {
  return Ig(this, void 0, void 0, function* () {
    return yield new Promise((i) => {
      if (!r.type || !Hb(r.type)) {
        i("");
        return;
      }
      i(window.URL.createObjectURL(r));
    });
  });
}
const Z5 = sp && window.FileReader && window.File;
function H5(r) {
  return r.isDirectory;
}
function X5(r) {
  return r.isFile;
}
function Y5(r, i) {
  return Ig(this, void 0, void 0, function* () {
    const l = [];
    function d(f) {
      return Ig(this, void 0, void 0, function* () {
        for (const g of f) if (g) {
          if (i && H5(g)) {
            const m = g.createReader();
            let s = [], C;
            try {
              do
                C = yield new Promise((T, M) => {
                  m.readEntries(T, M);
                }), s = s.concat(C);
              while (C.length > 0);
            } catch (T) {
              Xv("upload", "error happens when handling directory upload", T);
            }
            yield d(s);
          } else if (X5(g)) try {
            const m = yield new Promise((s, C) => {
              g.file(s, C);
            });
            l.push({ file: m, entry: g, source: "dnd" });
          } catch (m) {
            Xv("upload", "error happens when handling file upload", m);
          }
        }
      });
    }
    return yield d(r), l;
  });
}
function Hd(r) {
  const { id: i, name: l, percentage: d, status: f, url: g, file: m, thumbnailUrl: s, type: C, fullPath: T, batchId: M } = r;
  return { id: i, name: l, percentage: d ?? null, status: f, url: g ?? null, file: m ?? null, thumbnailUrl: s ?? null, type: C ?? null, fullPath: T ?? null, batchId: M ?? null };
}
function K5(r, i, l) {
  return r = r.toLowerCase(), i = i.toLocaleLowerCase(), l = l.toLocaleLowerCase(), l.split(",").map((f) => f.trim()).filter(Boolean).some((f) => {
    if (f.startsWith(".")) {
      if (r.endsWith(f)) return true;
    } else if (f.includes("/")) {
      const [g, m] = i.split("/"), [s, C] = f.split("/");
      if ((s === "*" || g && s && s === g) && (C === "*" || m && C && C === m)) return true;
    } else return true;
    return false;
  });
}
var L_ = function(r, i, l, d) {
  function f(g) {
    return g instanceof l ? g : new l(function(m) {
      m(g);
    });
  }
  return new (l || (l = Promise))(function(g, m) {
    function s(M) {
      try {
        T(d.next(M));
      } catch (z) {
        m(z);
      }
    }
    function C(M) {
      try {
        T(d.throw(M));
      } catch (z) {
        m(z);
      }
    }
    function T(M) {
      M.done ? g(M.value) : f(M.value).then(s, C);
    }
    T((d = d.apply(r, i || [])).next());
  });
};
const Tf = { paddingMedium: "0 3px", heightMedium: "24px", iconSizeMedium: "18px" }, J5 = st({ name: "UploadFile", props: { clsPrefix: { type: String, required: true }, file: { type: Object, required: true }, listType: { type: String, required: true }, index: { type: Number, required: true } }, setup(r) {
  const i = fr(sc), l = Ae(null), d = Ae(""), f = ze(() => {
    const { file: re } = r;
    return re.status === "finished" ? "success" : re.status === "error" ? "error" : "info";
  }), g = ze(() => {
    const { file: re } = r;
    if (re.status === "error") return "error";
  }), m = ze(() => {
    const { file: re } = r;
    return re.status === "uploading";
  }), s = ze(() => {
    if (!i.showCancelButtonRef.value) return false;
    const { file: re } = r;
    return ["uploading", "pending", "error"].includes(re.status);
  }), C = ze(() => {
    if (!i.showRemoveButtonRef.value) return false;
    const { file: re } = r;
    return ["finished"].includes(re.status);
  }), T = ze(() => {
    if (!i.showDownloadButtonRef.value) return false;
    const { file: re } = r;
    return ["finished"].includes(re.status);
  }), M = ze(() => {
    if (!i.showRetryButtonRef.value) return false;
    const { file: re } = r;
    return ["error"].includes(re.status);
  }), z = _i(() => d.value || r.file.thumbnailUrl || r.file.url), L = ze(() => {
    if (!i.showPreviewButtonRef.value) return false;
    const { file: { status: re }, listType: J } = r;
    return ["finished"].includes(re) && z.value && J === "image-card";
  });
  function A() {
    return L_(this, void 0, void 0, function* () {
      const re = i.onRetryRef.value;
      re && (yield re({ file: r.file })) === false || i.submit(r.file.id);
    });
  }
  function O(re) {
    re.preventDefault();
    const { file: J } = r;
    ["finished", "pending", "error"].includes(J.status) ? X(J) : ["uploading"].includes(J.status) ? K(J) : Uf("upload", "The button clicked type is unknown.");
  }
  function V(re) {
    re.preventDefault(), W(r.file);
  }
  function X(re) {
    const { xhrMap: J, doChange: Se, onRemoveRef: { value: fe }, mergedFileListRef: { value: oe } } = i;
    Promise.resolve(fe ? fe({ file: Object.assign({}, re), fileList: oe, index: r.index }) : true).then((he) => {
      if (he === false) return;
      const be = Object.assign({}, re, { status: "removed" });
      J.delete(re.id), Se(be, void 0, { remove: true });
    });
  }
  function W(re) {
    const { onDownloadRef: { value: J }, customDownloadRef: { value: Se } } = i;
    Promise.resolve(J ? J(Object.assign({}, re)) : true).then((fe) => {
      fe !== false && (Se ? Se(Object.assign({}, re)) : mb(re.url, re.name));
    });
  }
  function K(re) {
    const { xhrMap: J } = i, Se = J.get(re.id);
    Se == null ? void 0 : Se.abort(), X(Object.assign({}, re));
  }
  function ie(re) {
    const { onPreviewRef: { value: J } } = i;
    if (J) J(r.file, { event: re });
    else if (r.listType === "image-card") {
      const { value: Se } = l;
      if (!Se) return;
      Se.showPreview();
    }
  }
  const ee = () => L_(this, void 0, void 0, function* () {
    const { listType: re } = r;
    re !== "image" && re !== "image-card" || i.shouldUseThumbnailUrlRef.value(r.file) && (d.value = yield i.getFileThumbnailUrlResolver(r.file));
  });
  return po(() => {
    ee();
  }), { mergedTheme: i.mergedThemeRef, progressStatus: f, buttonType: g, showProgress: m, disabled: i.mergedDisabledRef, showCancelButton: s, showRemoveButton: C, showDownloadButton: T, showRetryButton: M, showPreviewButton: L, mergedThumbnailUrl: z, shouldUseThumbnailUrl: i.shouldUseThumbnailUrlRef, renderIcon: i.renderIconRef, imageRef: l, handleRemoveOrCancelClick: O, handleDownloadClick: V, handleRetryClick: A, handlePreviewClick: ie };
}, render() {
  const { clsPrefix: r, mergedTheme: i, listType: l, file: d, renderIcon: f } = this;
  let g;
  const m = l === "image";
  m || l === "image-card" ? g = !this.shouldUseThumbnailUrl(d) || !this.mergedThumbnailUrl ? F("span", { class: `${r}-upload-file-info__thumbnail` }, f ? f(d) : Xb(d) ? F(Nr, { clsPrefix: r }, { default: U5 }) : F(Nr, { clsPrefix: r }, { default: q5 })) : F("a", { rel: "noopener noreferer", target: "_blank", href: d.url || void 0, class: `${r}-upload-file-info__thumbnail`, onClick: this.handlePreviewClick }, l === "image-card" ? F(jb, { src: this.mergedThumbnailUrl || void 0, previewSrc: d.url || void 0, alt: d.name, ref: "imageRef" }) : F("img", { src: this.mergedThumbnailUrl || void 0, alt: d.name })) : g = F("span", { class: `${r}-upload-file-info__thumbnail` }, f ? f(d) : F(Nr, { clsPrefix: r }, { default: () => F(NS, null) }));
  const C = F(G5, { show: this.showProgress, percentage: d.percentage || 0, status: this.progressStatus }), T = l === "text" || l === "image";
  return F("div", { class: [`${r}-upload-file`, `${r}-upload-file--${this.progressStatus}-status`, d.url && d.status !== "error" && l !== "image-card" && `${r}-upload-file--with-url`, `${r}-upload-file--${l}-type`] }, F("div", { class: `${r}-upload-file-info` }, g, F("div", { class: `${r}-upload-file-info__name` }, T && (d.url && d.status !== "error" ? F("a", { rel: "noopener noreferer", target: "_blank", href: d.url || void 0, onClick: this.handlePreviewClick }, d.name) : F("span", { onClick: this.handlePreviewClick }, d.name)), m && C), F("div", { class: [`${r}-upload-file-info__action`, `${r}-upload-file-info__action--${l}-type`] }, this.showPreviewButton ? F(Vr, { key: "preview", quaternary: true, type: this.buttonType, onClick: this.handlePreviewClick, theme: i.peers.Button, themeOverrides: i.peerOverrides.Button, builtinThemeOverrides: Tf }, { icon: () => F(Nr, { clsPrefix: r }, { default: () => F(vb, null) }) }) : null, (this.showRemoveButton || this.showCancelButton) && !this.disabled && F(Vr, { key: "cancelOrTrash", theme: i.peers.Button, themeOverrides: i.peerOverrides.Button, quaternary: true, builtinThemeOverrides: Tf, type: this.buttonType, onClick: this.handleRemoveOrCancelClick }, { icon: () => F(tp, null, { default: () => this.showRemoveButton ? F(Nr, { clsPrefix: r, key: "trash" }, { default: () => F(ek, null) }) : F(Nr, { clsPrefix: r, key: "cancel" }, { default: () => F(VS, null) }) }) }), this.showRetryButton && !this.disabled && F(Vr, { key: "retry", quaternary: true, type: this.buttonType, onClick: this.handleRetryClick, theme: i.peers.Button, themeOverrides: i.peerOverrides.Button, builtinThemeOverrides: Tf }, { icon: () => F(Nr, { clsPrefix: r }, { default: () => F(KS, null) }) }), this.showDownloadButton ? F(Vr, { key: "download", quaternary: true, type: this.buttonType, onClick: this.handleDownloadClick, theme: i.peers.Button, themeOverrides: i.peerOverrides.Button, builtinThemeOverrides: Tf }, { icon: () => F(Nr, { clsPrefix: r }, { default: () => F(gb, null) }) }) : null)), !m && C);
} }), Yb = st({ name: "UploadTrigger", props: { abstract: Boolean }, slots: Object, setup(r, { slots: i }) {
  const l = fr(sc, null);
  l || Zo("upload-trigger", "`n-upload-trigger` must be placed inside `n-upload`.");
  const { mergedClsPrefixRef: d, mergedDisabledRef: f, maxReachedRef: g, listTypeRef: m, dragOverRef: s, openOpenFileDialog: C, draggerInsideRef: T, handleFileAddition: M, mergedDirectoryDndRef: z, triggerClassRef: L, triggerStyleRef: A } = l, O = ze(() => m.value === "image-card");
  function V() {
    f.value || g.value || C();
  }
  function X(ee) {
    ee.preventDefault(), s.value = true;
  }
  function W(ee) {
    ee.preventDefault(), s.value = true;
  }
  function K(ee) {
    ee.preventDefault(), s.value = false;
  }
  function ie(ee) {
    var re;
    if (ee.preventDefault(), !T.value || f.value || g.value) {
      s.value = false;
      return;
    }
    const J = (re = ee.dataTransfer) === null || re === void 0 ? void 0 : re.items;
    (J == null ? void 0 : J.length) ? Y5(Array.from(J).map((Se) => Se.webkitGetAsEntry()), z.value).then((Se) => {
      M(Se);
    }).finally(() => {
      s.value = false;
    }) : s.value = false;
  }
  return () => {
    var ee;
    const { value: re } = d;
    return r.abstract ? (ee = i.default) === null || ee === void 0 ? void 0 : ee.call(i, { handleClick: V, handleDrop: ie, handleDragOver: X, handleDragEnter: W, handleDragLeave: K }) : F("div", { class: [`${re}-upload-trigger`, (f.value || g.value) && `${re}-upload-trigger--disabled`, O.value && `${re}-upload-trigger--image-card`, L.value], style: A.value, onClick: V, onDrop: ie, onDragover: X, onDragenter: W, onDragleave: K }, O.value ? F(Zb, null, { default: () => Un(i.default, () => [F(Nr, { clsPrefix: re }, { default: () => F(dp, null) })]) }) : i);
  };
} }), Q5 = st({ name: "UploadFileList", setup(r, { slots: i }) {
  const l = fr(sc, null);
  l || Zo("upload-file-list", "`n-upload-file-list` must be placed inside `n-upload`.");
  const { abstractRef: d, mergedClsPrefixRef: f, listTypeRef: g, mergedFileListRef: m, fileListClassRef: s, fileListStyleRef: C, cssVarsRef: T, themeClassRef: M, maxReachedRef: z, showTriggerRef: L, imageGroupPropsRef: A } = l, O = ze(() => g.value === "image-card"), V = () => m.value.map((W, K) => F(J5, { clsPrefix: f.value, key: W.id, file: W, index: K, listType: g.value })), X = () => O.value ? F(i5, Object.assign({}, A.value), { default: V }) : F(op, { group: true }, { default: V });
  return () => {
    const { value: W } = f, { value: K } = d;
    return F("div", { class: [`${W}-upload-file-list`, O.value && `${W}-upload-file-list--grid`, K ? M == null ? void 0 : M.value : void 0, s.value], style: [K && T ? T.value : "", C.value] }, X(), L.value && !z.value && O.value && F(Yb, null, i));
  };
} });
var B_ = function(r, i, l, d) {
  function f(g) {
    return g instanceof l ? g : new l(function(m) {
      m(g);
    });
  }
  return new (l || (l = Promise))(function(g, m) {
    function s(M) {
      try {
        T(d.next(M));
      } catch (z) {
        m(z);
      }
    }
    function C(M) {
      try {
        T(d.throw(M));
      } catch (z) {
        m(z);
      }
    }
    function T(M) {
      M.done ? g(M.value) : f(M.value).then(s, C);
    }
    T((d = d.apply(r, i || [])).next());
  });
};
function e6(r, i, l) {
  const { doChange: d, xhrMap: f } = r;
  let g = 0;
  function m(C) {
    var T;
    let M = Object.assign({}, i, { status: "error", percentage: g });
    f.delete(i.id), M = Hd(((T = r.onError) === null || T === void 0 ? void 0 : T.call(r, { file: M, event: C })) || M), d(M, C);
  }
  function s(C) {
    var T;
    if (r.isErrorState) {
      if (r.isErrorState(l)) {
        m(C);
        return;
      }
    } else if (l.status < 200 || l.status >= 300) {
      m(C);
      return;
    }
    let M = Object.assign({}, i, { status: "finished", percentage: g });
    f.delete(i.id), M = Hd(((T = r.onFinish) === null || T === void 0 ? void 0 : T.call(r, { file: M, event: C })) || M), d(M, C);
  }
  return { handleXHRLoad: s, handleXHRError: m, handleXHRAbort(C) {
    const T = Object.assign({}, i, { status: "removed", file: null, percentage: g });
    f.delete(i.id), d(T, C);
  }, handleXHRProgress(C) {
    const T = Object.assign({}, i, { status: "uploading" });
    if (C.lengthComputable) {
      const M = Math.ceil(C.loaded / C.total * 100);
      T.percentage = M, g = M;
    }
    d(T, C);
  } };
}
function t6(r) {
  const { inst: i, file: l, data: d, headers: f, withCredentials: g, action: m, customRequest: s } = r, { doChange: C } = r.inst;
  let T = 0;
  s({ file: l, data: d, headers: f, withCredentials: g, action: m, onProgress(M) {
    const z = Object.assign({}, l, { status: "uploading" }), L = M.percent;
    z.percentage = L, T = L, C(z);
  }, onFinish() {
    var M;
    let z = Object.assign({}, l, { status: "finished", percentage: T });
    z = Hd(((M = i.onFinish) === null || M === void 0 ? void 0 : M.call(i, { file: z })) || z), C(z);
  }, onError() {
    var M;
    let z = Object.assign({}, l, { status: "error", percentage: T });
    z = Hd(((M = i.onError) === null || M === void 0 ? void 0 : M.call(i, { file: z })) || z), C(z);
  } });
}
function r6(r, i, l) {
  const d = e6(r, i, l);
  l.onabort = d.handleXHRAbort, l.onerror = d.handleXHRError, l.onload = d.handleXHRLoad, l.upload && (l.upload.onprogress = d.handleXHRProgress);
}
function Kb(r, i) {
  return typeof r == "function" ? r({ file: i }) : r || {};
}
function i6(r, i, l) {
  const d = Kb(i, l);
  d && Object.keys(d).forEach((f) => {
    r.setRequestHeader(f, d[f]);
  });
}
function n6(r, i, l) {
  const d = Kb(i, l);
  d && Object.keys(d).forEach((f) => {
    r.append(f, d[f]);
  });
}
function o6(r, i, l, { method: d, action: f, withCredentials: g, responseType: m, headers: s, data: C }) {
  const T = new XMLHttpRequest();
  T.responseType = m, r.xhrMap.set(l.id, T), T.withCredentials = g;
  const M = new FormData();
  if (n6(M, C, l), l.file !== null && M.append(i, l.file), r6(r, l, T), f !== void 0) {
    T.open(d.toUpperCase(), f), i6(T, s, l), T.send(M);
    const z = Object.assign({}, l, { status: "uploading" });
    r.doChange(z);
  }
}
const a6 = Object.assign(Object.assign({}, Kt.props), { name: { type: String, default: "file" }, accept: String, action: String, customRequest: Function, directory: Boolean, directoryDnd: { type: Boolean, default: void 0 }, method: { type: String, default: "POST" }, multiple: Boolean, showFileList: { type: Boolean, default: true }, data: [Object, Function], headers: [Object, Function], withCredentials: Boolean, responseType: { type: String, default: "" }, disabled: { type: Boolean, default: void 0 }, onChange: Function, onRemove: Function, onFinish: Function, onError: Function, onRetry: Function, onBeforeUpload: Function, isErrorState: Function, onDownload: Function, customDownload: Function, defaultUpload: { type: Boolean, default: true }, fileList: Array, "onUpdate:fileList": [Function, Array], onUpdateFileList: [Function, Array], fileListClass: String, fileListStyle: [String, Object], defaultFileList: { type: Array, default: () => [] }, showCancelButton: { type: Boolean, default: true }, showRemoveButton: { type: Boolean, default: true }, showDownloadButton: Boolean, showRetryButton: { type: Boolean, default: true }, showPreviewButton: { type: Boolean, default: true }, listType: { type: String, default: "text" }, onPreview: Function, shouldUseThumbnailUrl: { type: Function, default: (r) => Z5 ? Xb(r) : false }, createThumbnailUrl: Function, abstract: Boolean, max: Number, showTrigger: { type: Boolean, default: true }, imageGroupProps: Object, inputProps: Object, triggerClass: String, triggerStyle: [String, Object], renderIcon: Function }), s6 = st({ name: "Upload", props: a6, setup(r) {
  r.abstract && r.listType === "image-card" && Zo("upload", "when the list-type is image-card, abstract is not supported.");
  const { mergedClsPrefixRef: i, inlineThemeDisabled: l, mergedRtlRef: d } = Tr(r), f = Kt("Upload", "-upload", V5, eC, r, i), g = Rn("Upload", d, i), m = va(r), s = Ae(r.defaultFileList), C = Dt(r, "fileList"), T = Ae(null), M = { value: false }, z = Ae(false), L = /* @__PURE__ */ new Map(), A = Zi(C, s), O = ze(() => A.value.map(Hd)), V = ze(() => {
    const { max: be } = r;
    return be !== void 0 ? O.value.length >= be : false;
  });
  function X() {
    var be;
    (be = T.value) === null || be === void 0 || be.click();
  }
  function W(be) {
    const je = be.target;
    re(je.files ? Array.from(je.files).map((Ve) => ({ file: Ve, entry: null, source: "input" })) : null, be), je.value = "";
  }
  function K(be) {
    const { "onUpdate:fileList": je, onUpdateFileList: Ve } = r;
    je && Ot(je, be), Ve && Ot(Ve, be), s.value = be;
  }
  const ie = ze(() => r.multiple || r.directory), ee = (be, je, Ve = { append: false, remove: false }) => {
    const { append: Ke, remove: lt } = Ve, vt = Array.from(O.value), wt = vt.findIndex((at) => at.id === be.id);
    if (Ke || lt || ~wt) {
      Ke ? vt.push(be) : lt ? vt.splice(wt, 1) : vt.splice(wt, 1, be);
      const { onChange: at } = r;
      at && at({ file: be, fileList: vt, event: je }), K(vt);
    }
  };
  function re(be, je) {
    if (!be || be.length === 0) return;
    const { onBeforeUpload: Ve } = r;
    be = ie.value ? be : [be[0]];
    const { max: Ke, accept: lt } = r;
    be = be.filter(({ file: wt, source: at }) => at === "dnd" && (lt == null ? void 0 : lt.trim()) ? K5(wt.name, wt.type, lt) : true), Ke && (be = be.slice(0, Ke - O.value.length));
    const vt = Ml();
    Promise.all(be.map((wt) => B_(this, [wt], void 0, function* ({ file: at, entry: et }) {
      var ht;
      const yt = { id: Ml(), batchId: vt, name: at.name, status: "pending", percentage: 0, file: at, url: null, type: at.type, thumbnailUrl: null, fullPath: (ht = et == null ? void 0 : et.fullPath) !== null && ht !== void 0 ? ht : `/${at.webkitRelativePath || at.name}` };
      return !Ve || (yield Ve({ file: yt, fileList: O.value })) !== false ? yt : null;
    }))).then((wt) => B_(this, void 0, void 0, function* () {
      let at = Promise.resolve();
      wt.forEach((et) => {
        at = at.then(Vn).then(() => {
          et && ee(et, je, { append: true });
        });
      }), yield at;
    })).then(() => {
      r.defaultUpload && J();
    });
  }
  function J(be) {
    const { method: je, action: Ve, withCredentials: Ke, headers: lt, data: vt, name: wt } = r, at = be !== void 0 ? O.value.filter((ht) => ht.id === be) : O.value, et = be !== void 0;
    at.forEach((ht) => {
      const { status: yt } = ht;
      (yt === "pending" || yt === "error" && et) && (r.customRequest ? t6({ inst: { doChange: ee, xhrMap: L, onFinish: r.onFinish, onError: r.onError }, file: ht, action: Ve, withCredentials: Ke, headers: lt, data: vt, customRequest: r.customRequest }) : o6({ doChange: ee, xhrMap: L, onFinish: r.onFinish, onError: r.onError, isErrorState: r.isErrorState }, wt, ht, { method: je, action: Ve, withCredentials: Ke, responseType: r.responseType, headers: lt, data: vt }));
    });
  }
  function Se(be) {
    var je;
    if (be.thumbnailUrl) return be.thumbnailUrl;
    const { createThumbnailUrl: Ve } = r;
    return Ve ? (je = Ve(be.file, be)) !== null && je !== void 0 ? je : be.url || "" : be.url ? be.url : be.file ? W5(be.file) : "";
  }
  const fe = ze(() => {
    const { common: { cubicBezierEaseInOut: be }, self: { draggerColor: je, draggerBorder: Ve, draggerBorderHover: Ke, itemColorHover: lt, itemColorHoverError: vt, itemTextColorError: wt, itemTextColorSuccess: at, itemTextColor: et, itemIconColor: ht, itemDisabledOpacity: yt, lineHeight: nt, borderRadius: ut, fontSize: Ft, itemBorderImageCardError: Ht, itemBorderImageCard: zt } } = f.value;
    return { "--n-bezier": be, "--n-border-radius": ut, "--n-dragger-border": Ve, "--n-dragger-border-hover": Ke, "--n-dragger-color": je, "--n-font-size": Ft, "--n-item-color-hover": lt, "--n-item-color-hover-error": vt, "--n-item-disabled-opacity": yt, "--n-item-icon-color": ht, "--n-item-text-color": et, "--n-item-text-color-error": wt, "--n-item-text-color-success": at, "--n-line-height": nt, "--n-item-border-image-card-error": Ht, "--n-item-border-image-card": zt };
  }), oe = l ? mi("upload", void 0, fe, r) : void 0;
  Yr(sc, { mergedClsPrefixRef: i, mergedThemeRef: f, showCancelButtonRef: Dt(r, "showCancelButton"), showDownloadButtonRef: Dt(r, "showDownloadButton"), showRemoveButtonRef: Dt(r, "showRemoveButton"), showRetryButtonRef: Dt(r, "showRetryButton"), onRemoveRef: Dt(r, "onRemove"), onDownloadRef: Dt(r, "onDownload"), customDownloadRef: Dt(r, "customDownload"), mergedFileListRef: O, triggerClassRef: Dt(r, "triggerClass"), triggerStyleRef: Dt(r, "triggerStyle"), shouldUseThumbnailUrlRef: Dt(r, "shouldUseThumbnailUrl"), renderIconRef: Dt(r, "renderIcon"), xhrMap: L, submit: J, doChange: ee, showPreviewButtonRef: Dt(r, "showPreviewButton"), onPreviewRef: Dt(r, "onPreview"), getFileThumbnailUrlResolver: Se, listTypeRef: Dt(r, "listType"), dragOverRef: z, openOpenFileDialog: X, draggerInsideRef: M, handleFileAddition: re, mergedDisabledRef: m.mergedDisabledRef, maxReachedRef: V, fileListClassRef: Dt(r, "fileListClass"), fileListStyleRef: Dt(r, "fileListStyle"), abstractRef: Dt(r, "abstract"), acceptRef: Dt(r, "accept"), cssVarsRef: l ? void 0 : fe, themeClassRef: oe == null ? void 0 : oe.themeClass, onRender: oe == null ? void 0 : oe.onRender, showTriggerRef: Dt(r, "showTrigger"), imageGroupPropsRef: Dt(r, "imageGroupProps"), mergedDirectoryDndRef: ze(() => {
    var be;
    return (be = r.directoryDnd) !== null && be !== void 0 ? be : r.directory;
  }), onRetryRef: Dt(r, "onRetry") });
  const he = { clear: () => {
    s.value = [];
  }, submit: J, openOpenFileDialog: X };
  return Object.assign({ mergedClsPrefix: i, draggerInsideRef: M, rtlEnabled: g, inputElRef: T, mergedTheme: f, dragOver: z, mergedMultiple: ie, cssVars: l ? void 0 : fe, themeClass: oe == null ? void 0 : oe.themeClass, onRender: oe == null ? void 0 : oe.onRender, handleFileInputChange: W }, he);
}, render() {
  var r, i;
  const { draggerInsideRef: l, mergedClsPrefix: d, $slots: f, directory: g, onRender: m } = this;
  if (f.default && !this.abstract) {
    const C = f.default()[0];
    !((r = C == null ? void 0 : C.type) === null || r === void 0) && r[Wb] && (l.value = true);
  }
  const s = F("input", Object.assign({}, this.inputProps, { ref: "inputElRef", type: "file", class: `${d}-upload-file-input`, accept: this.accept, multiple: this.mergedMultiple, onChange: this.handleFileInputChange, webkitdirectory: g || void 0, directory: g || void 0 }));
  return this.abstract ? F(Gr, null, (i = f.default) === null || i === void 0 ? void 0 : i.call(f), F(wy, { to: "body" }, s)) : (m == null ? void 0 : m(), F("div", { class: [`${d}-upload`, this.rtlEnabled && `${d}-upload--rtl`, l.value && `${d}-upload--dragger-inside`, this.dragOver && `${d}-upload--drag-over`, this.themeClass], style: this.cssVars }, s, this.showTrigger && this.listType !== "image-card" && F(Yb, null, f), this.showFileList && F(Q5, null, f)));
} });
function El() {
  const r = fr(Iy, null);
  return ze(() => {
    if (r === null) return Yv;
    const { mergedThemeRef: { value: i }, mergedThemeOverridesRef: { value: l } } = r, d = (i == null ? void 0 : i.common) || Yv;
    return (l == null ? void 0 : l.common) ? Object.assign({}, d, l.common) : d;
  });
}
var $f = { exports: {} };
/**
* MapLibre GL JS
* @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.7.3/LICENSE.txt
*/
var l6 = $f.exports, O_;
function u6() {
  return O_ || (O_ = 1, (function(r, i) {
    (function(l, d) {
      r.exports = d();
    })(l6, (function() {
      var l = {}, d = {};
      function f(m, s, C) {
        if (d[m] = C, m === "index") {
          var T = "var sharedModule = {}; (" + d.shared + ")(sharedModule); (" + d.worker + ")(sharedModule);", M = {};
          return d.shared(M), d.index(l, M), typeof window < "u" && l.setWorkerUrl(window.URL.createObjectURL(new Blob([T], { type: "text/javascript" }))), l;
        }
      }
      f("shared", ["exports"], (function(m) {
        function s(o, t, n, u) {
          return new (n || (n = Promise))((function(h, _) {
            function b(I) {
              try {
                S(u.next(I));
              } catch (R) {
                _(R);
              }
            }
            function w(I) {
              try {
                S(u.throw(I));
              } catch (R) {
                _(R);
              }
            }
            function S(I) {
              var R;
              I.done ? h(I.value) : (R = I.value, R instanceof n ? R : new n((function(B) {
                B(R);
              }))).then(b, w);
            }
            S((u = u.apply(o, t || [])).next());
          }));
        }
        function C(o, t) {
          this.x = o, this.y = t;
        }
        function T(o) {
          return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
        }
        var M, z;
        typeof SuppressedError == "function" && SuppressedError, C.prototype = { clone() {
          return new C(this.x, this.y);
        }, add(o) {
          return this.clone()._add(o);
        }, sub(o) {
          return this.clone()._sub(o);
        }, multByPoint(o) {
          return this.clone()._multByPoint(o);
        }, divByPoint(o) {
          return this.clone()._divByPoint(o);
        }, mult(o) {
          return this.clone()._mult(o);
        }, div(o) {
          return this.clone()._div(o);
        }, rotate(o) {
          return this.clone()._rotate(o);
        }, rotateAround(o, t) {
          return this.clone()._rotateAround(o, t);
        }, matMult(o) {
          return this.clone()._matMult(o);
        }, unit() {
          return this.clone()._unit();
        }, perp() {
          return this.clone()._perp();
        }, round() {
          return this.clone()._round();
        }, mag() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals(o) {
          return this.x === o.x && this.y === o.y;
        }, dist(o) {
          return Math.sqrt(this.distSqr(o));
        }, distSqr(o) {
          const t = o.x - this.x, n = o.y - this.y;
          return t * t + n * n;
        }, angle() {
          return Math.atan2(this.y, this.x);
        }, angleTo(o) {
          return Math.atan2(this.y - o.y, this.x - o.x);
        }, angleWith(o) {
          return this.angleWithSep(o.x, o.y);
        }, angleWithSep(o, t) {
          return Math.atan2(this.x * t - this.y * o, this.x * o + this.y * t);
        }, _matMult(o) {
          const t = o[2] * this.x + o[3] * this.y;
          return this.x = o[0] * this.x + o[1] * this.y, this.y = t, this;
        }, _add(o) {
          return this.x += o.x, this.y += o.y, this;
        }, _sub(o) {
          return this.x -= o.x, this.y -= o.y, this;
        }, _mult(o) {
          return this.x *= o, this.y *= o, this;
        }, _div(o) {
          return this.x /= o, this.y /= o, this;
        }, _multByPoint(o) {
          return this.x *= o.x, this.y *= o.y, this;
        }, _divByPoint(o) {
          return this.x /= o.x, this.y /= o.y, this;
        }, _unit() {
          return this._div(this.mag()), this;
        }, _perp() {
          const o = this.y;
          return this.y = this.x, this.x = -o, this;
        }, _rotate(o) {
          const t = Math.cos(o), n = Math.sin(o), u = n * this.x + t * this.y;
          return this.x = t * this.x - n * this.y, this.y = u, this;
        }, _rotateAround(o, t) {
          const n = Math.cos(o), u = Math.sin(o), h = t.y + u * (this.x - t.x) + n * (this.y - t.y);
          return this.x = t.x + n * (this.x - t.x) - u * (this.y - t.y), this.y = h, this;
        }, _round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }, constructor: C }, C.convert = function(o) {
          if (o instanceof C) return o;
          if (Array.isArray(o)) return new C(+o[0], +o[1]);
          if (o.x !== void 0 && o.y !== void 0) return new C(+o.x, +o.y);
          throw new Error("Expected [x, y] or {x, y} point format");
        };
        var L = (function() {
          if (z) return M;
          function o(t, n, u, h) {
            this.cx = 3 * t, this.bx = 3 * (u - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (h - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = u, this.p2y = h;
          }
          return z = 1, M = o, o.prototype = { sampleCurveX: function(t) {
            return ((this.ax * t + this.bx) * t + this.cx) * t;
          }, sampleCurveY: function(t) {
            return ((this.ay * t + this.by) * t + this.cy) * t;
          }, sampleCurveDerivativeX: function(t) {
            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
          }, solveCurveX: function(t, n) {
            if (n === void 0 && (n = 1e-6), t < 0) return 0;
            if (t > 1) return 1;
            for (var u = t, h = 0; h < 8; h++) {
              var _ = this.sampleCurveX(u) - t;
              if (Math.abs(_) < n) return u;
              var b = this.sampleCurveDerivativeX(u);
              if (Math.abs(b) < 1e-6) break;
              u -= _ / b;
            }
            var w = 0, S = 1;
            for (u = t, h = 0; h < 20 && (_ = this.sampleCurveX(u), !(Math.abs(_ - t) < n)); h++) t > _ ? w = u : S = u, u = 0.5 * (S - w) + w;
            return u;
          }, solve: function(t, n) {
            return this.sampleCurveY(this.solveCurveX(t, n));
          } }, M;
        })(), A = T(L);
        let O, V;
        function X() {
          return O == null && (O = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), O;
        }
        function W() {
          if (V == null && (V = false, X())) {
            const t = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: true });
            if (t) {
              for (let u = 0; u < 25; u++) {
                const h = 4 * u;
                t.fillStyle = `rgb(${h},${h + 1},${h + 2})`, t.fillRect(u % 5, Math.floor(u / 5), 1, 1);
              }
              const n = t.getImageData(0, 0, 5, 5).data;
              for (let u = 0; u < 100; u++) if (u % 4 != 3 && n[u] !== u) {
                V = true;
                break;
              }
            }
          }
          return V || false;
        }
        var K = 1e-6, ie = typeof Float32Array < "u" ? Float32Array : Array;
        function ee() {
          var o = new ie(9);
          return ie != Float32Array && (o[1] = 0, o[2] = 0, o[3] = 0, o[5] = 0, o[6] = 0, o[7] = 0), o[0] = 1, o[4] = 1, o[8] = 1, o;
        }
        function re(o) {
          return o[0] = 1, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = 1, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 1, o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, o;
        }
        function J() {
          var o = new ie(3);
          return ie != Float32Array && (o[0] = 0, o[1] = 0, o[2] = 0), o;
        }
        function Se(o) {
          var t = o[0], n = o[1], u = o[2];
          return Math.sqrt(t * t + n * n + u * u);
        }
        function fe(o, t, n) {
          var u = new ie(3);
          return u[0] = o, u[1] = t, u[2] = n, u;
        }
        function oe(o, t, n) {
          return o[0] = t[0] + n[0], o[1] = t[1] + n[1], o[2] = t[2] + n[2], o;
        }
        function he(o, t, n) {
          return o[0] = t[0] * n, o[1] = t[1] * n, o[2] = t[2] * n, o;
        }
        function be(o, t, n) {
          var u = t[0], h = t[1], _ = t[2], b = n[0], w = n[1], S = n[2];
          return o[0] = h * S - _ * w, o[1] = _ * b - u * S, o[2] = u * w - h * b, o;
        }
        var je, Ve = Se;
        function Ke(o, t, n) {
          var u = t[0], h = t[1], _ = t[2], b = t[3];
          return o[0] = n[0] * u + n[4] * h + n[8] * _ + n[12] * b, o[1] = n[1] * u + n[5] * h + n[9] * _ + n[13] * b, o[2] = n[2] * u + n[6] * h + n[10] * _ + n[14] * b, o[3] = n[3] * u + n[7] * h + n[11] * _ + n[15] * b, o;
        }
        function lt() {
          var o = new ie(4);
          return ie != Float32Array && (o[0] = 0, o[1] = 0, o[2] = 0), o[3] = 1, o;
        }
        function vt(o, t, n, u) {
          var h = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "zyx", _ = Math.PI / 360;
          t *= _, u *= _, n *= _;
          var b = Math.sin(t), w = Math.cos(t), S = Math.sin(n), I = Math.cos(n), R = Math.sin(u), B = Math.cos(u);
          switch (h) {
            case "xyz":
              o[0] = b * I * B + w * S * R, o[1] = w * S * B - b * I * R, o[2] = w * I * R + b * S * B, o[3] = w * I * B - b * S * R;
              break;
            case "xzy":
              o[0] = b * I * B - w * S * R, o[1] = w * S * B - b * I * R, o[2] = w * I * R + b * S * B, o[3] = w * I * B + b * S * R;
              break;
            case "yxz":
              o[0] = b * I * B + w * S * R, o[1] = w * S * B - b * I * R, o[2] = w * I * R - b * S * B, o[3] = w * I * B + b * S * R;
              break;
            case "yzx":
              o[0] = b * I * B + w * S * R, o[1] = w * S * B + b * I * R, o[2] = w * I * R - b * S * B, o[3] = w * I * B - b * S * R;
              break;
            case "zxy":
              o[0] = b * I * B - w * S * R, o[1] = w * S * B + b * I * R, o[2] = w * I * R + b * S * B, o[3] = w * I * B - b * S * R;
              break;
            case "zyx":
              o[0] = b * I * B - w * S * R, o[1] = w * S * B + b * I * R, o[2] = w * I * R - b * S * B, o[3] = w * I * B + b * S * R;
              break;
            default:
              throw new Error("Unknown angle order " + h);
          }
          return o;
        }
        function wt() {
          var o = new ie(2);
          return ie != Float32Array && (o[0] = 0, o[1] = 0), o;
        }
        function at(o, t) {
          var n = new ie(2);
          return n[0] = o, n[1] = t, n;
        }
        J(), je = new ie(4), ie != Float32Array && (je[0] = 0, je[1] = 0, je[2] = 0, je[3] = 0), J(), fe(1, 0, 0), fe(0, 1, 0), lt(), lt(), ee(), wt();
        const et = 8192;
        function ht(o, t, n) {
          return t * (et / (o.tileSize * Math.pow(2, n - o.tileID.overscaledZ)));
        }
        function yt(o, t) {
          return (o % t + t) % t;
        }
        function nt(o, t, n) {
          return o * (1 - n) + t * n;
        }
        function ut(o) {
          if (o <= 0) return 0;
          if (o >= 1) return 1;
          const t = o * o, n = t * o;
          return 4 * (o < 0.5 ? n : 3 * (o - t) + n - 0.75);
        }
        function Ft(o, t, n, u) {
          const h = new A(o, t, n, u);
          return (_) => h.solve(_);
        }
        const Ht = Ft(0.25, 0.1, 0.25, 1);
        function zt(o, t, n) {
          return Math.min(n, Math.max(t, o));
        }
        function pr(o, t, n) {
          const u = n - t, h = ((o - t) % u + u) % u + t;
          return h === t ? n : h;
        }
        function Qt(o, ...t) {
          for (const n of t) for (const u in n) o[u] = n[u];
          return o;
        }
        let tr = 1;
        function xr(o, t, n) {
          const u = {};
          for (const h in o) u[h] = t.call(this, o[h], h, o);
          return u;
        }
        function Mr(o, t, n) {
          const u = {};
          for (const h in o) t.call(this, o[h], h, o) && (u[h] = o[h]);
          return u;
        }
        function rr(o) {
          return Array.isArray(o) ? o.map(rr) : typeof o == "object" && o ? xr(o, rr) : o;
        }
        const sr = {};
        function Gt(o) {
          sr[o] || (typeof console < "u" && console.warn(o), sr[o] = true);
        }
        function Dr(o, t, n) {
          return (n.y - o.y) * (t.x - o.x) > (t.y - o.y) * (n.x - o.x);
        }
        function wr(o) {
          return typeof WorkerGlobalScope < "u" && o !== void 0 && o instanceof WorkerGlobalScope;
        }
        let Ct = null;
        function Ee(o) {
          return typeof ImageBitmap < "u" && o instanceof ImageBitmap;
        }
        const ot = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function Le(o, t, n, u, h) {
          return s(this, void 0, void 0, (function* () {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const _ = new VideoFrame(o, { timestamp: 0 });
            try {
              const b = _ == null ? void 0 : _.format;
              if (!b || !b.startsWith("BGR") && !b.startsWith("RGB")) throw new Error(`Unrecognized format ${b}`);
              const w = b.startsWith("BGR"), S = new Uint8ClampedArray(u * h * 4);
              if (yield _.copyTo(S, (function(I, R, B, N, q) {
                const G = 4 * Math.max(-R, 0), Q = (Math.max(0, B) - B) * N * 4 + G, ae = 4 * N, pe = Math.max(0, R), Oe = Math.max(0, B);
                return { rect: { x: pe, y: Oe, width: Math.min(I.width, R + N) - pe, height: Math.min(I.height, B + q) - Oe }, layout: [{ offset: Q, stride: ae }] };
              })(o, t, n, u, h)), w) for (let I = 0; I < S.length; I += 4) {
                const R = S[I];
                S[I] = S[I + 2], S[I + 2] = R;
              }
              return S;
            } finally {
              _.close();
            }
          }));
        }
        let Ye, ft;
        function bt(o, t, n, u) {
          return o.addEventListener(t, n, u), { unsubscribe: () => {
            o.removeEventListener(t, n, u);
          } };
        }
        function tt(o) {
          return o * Math.PI / 180;
        }
        function mt(o) {
          return o / Math.PI * 180;
        }
        const Zt = { touchstart: true, touchmove: true, touchmoveWindow: true, touchend: true, touchcancel: true }, ri = { dblclick: true, click: true, mouseover: true, mouseout: true, mousedown: true, mousemove: true, mousemoveWindow: true, mouseup: true, mouseupWindow: true, contextmenu: true, wheel: true }, Si = "AbortError";
        function Fe() {
          return new Error(Si);
        }
        const Z = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function H(o) {
          return Z.REGISTERED_PROTOCOLS[o.substring(0, o.indexOf("://"))];
        }
        const ne = "global-dispatcher";
        class xe extends Error {
          constructor(t, n, u, h) {
            super(`AJAXError: ${n} (${t}): ${u}`), this.status = t, this.statusText = n, this.url = u, this.body = h;
          }
        }
        const ke = () => wr(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, De = function(o, t) {
          if (/:\/\//.test(o.url) && !/^https?:|^file:/.test(o.url)) {
            const u = H(o.url);
            if (u) return u(o, t);
            if (wr(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: o, targetMapId: ne }, t);
          }
          if (!(/^file:/.test(n = o.url) || /^file:/.test(ke()) && !/^\w+:/.test(n))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return (function(u, h) {
              return s(this, void 0, void 0, (function* () {
                const _ = new Request(u.url, { method: u.method || "GET", body: u.body, credentials: u.credentials, headers: u.headers, cache: u.cache, referrer: ke(), signal: h.signal });
                let b, w;
                u.type !== "json" || _.headers.has("Accept") || _.headers.set("Accept", "application/json");
                try {
                  b = yield fetch(_);
                } catch (I) {
                  throw new xe(0, I.message, u.url, new Blob());
                }
                if (!b.ok) {
                  const I = yield b.blob();
                  throw new xe(b.status, b.statusText, u.url, I);
                }
                w = u.type === "arrayBuffer" || u.type === "image" ? b.arrayBuffer() : u.type === "json" ? b.json() : b.text();
                const S = yield w;
                if (h.signal.aborted) throw Fe();
                return { data: S, cacheControl: b.headers.get("Cache-Control"), expires: b.headers.get("Expires") };
              }));
            })(o, t);
            if (wr(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: o, mustQueue: true, targetMapId: ne }, t);
          }
          var n;
          return (function(u, h) {
            return new Promise(((_, b) => {
              var w;
              const S = new XMLHttpRequest();
              S.open(u.method || "GET", u.url, true), u.type !== "arrayBuffer" && u.type !== "image" || (S.responseType = "arraybuffer");
              for (const I in u.headers) S.setRequestHeader(I, u.headers[I]);
              u.type === "json" && (S.responseType = "text", !((w = u.headers) === null || w === void 0) && w.Accept || S.setRequestHeader("Accept", "application/json")), S.withCredentials = u.credentials === "include", S.onerror = () => {
                b(new Error(S.statusText));
              }, S.onload = () => {
                if (!h.signal.aborted) if ((S.status >= 200 && S.status < 300 || S.status === 0) && S.response !== null) {
                  let I = S.response;
                  if (u.type === "json") try {
                    I = JSON.parse(S.response);
                  } catch (R) {
                    return void b(R);
                  }
                  _({ data: I, cacheControl: S.getResponseHeader("Cache-Control"), expires: S.getResponseHeader("Expires") });
                } else {
                  const I = new Blob([S.response], { type: S.getResponseHeader("Content-Type") });
                  b(new xe(S.status, S.statusText, u.url, I));
                }
              }, h.signal.addEventListener("abort", (() => {
                S.abort(), b(Fe());
              })), S.send(u.body);
            }));
          })(o, t);
        };
        function de(o) {
          if (!o || o.indexOf("://") <= 0 || o.indexOf("data:image/") === 0 || o.indexOf("blob:") === 0) return true;
          const t = new URL(o), n = window.location;
          return t.protocol === n.protocol && t.host === n.host;
        }
        function ve(o, t, n) {
          n[o] && n[o].indexOf(t) !== -1 || (n[o] = n[o] || [], n[o].push(t));
        }
        function $e(o, t, n) {
          if (n && n[o]) {
            const u = n[o].indexOf(t);
            u !== -1 && n[o].splice(u, 1);
          }
        }
        class it {
          constructor(t, n = {}) {
            Qt(this, n), this.type = t;
          }
        }
        class Xe extends it {
          constructor(t, n = {}) {
            super("error", Qt({ error: t }, n));
          }
        }
        class xt {
          on(t, n) {
            return this._listeners = this._listeners || {}, ve(t, n, this._listeners), { unsubscribe: () => {
              this.off(t, n);
            } };
          }
          off(t, n) {
            return $e(t, n, this._listeners), $e(t, n, this._oneTimeListeners), this;
          }
          once(t, n) {
            return n ? (this._oneTimeListeners = this._oneTimeListeners || {}, ve(t, n, this._oneTimeListeners), this) : new Promise(((u) => this.once(t, u)));
          }
          fire(t, n) {
            typeof t == "string" && (t = new it(t, n || {}));
            const u = t.type;
            if (this.listens(u)) {
              t.target = this;
              const h = this._listeners && this._listeners[u] ? this._listeners[u].slice() : [];
              for (const w of h) w.call(this, t);
              const _ = this._oneTimeListeners && this._oneTimeListeners[u] ? this._oneTimeListeners[u].slice() : [];
              for (const w of _) $e(u, w, this._oneTimeListeners), w.call(this, t);
              const b = this._eventedParent;
              b && (Qt(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), b.fire(t));
            } else t instanceof Xe && console.error(t.error);
            return this;
          }
          listens(t) {
            return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t);
          }
          setEventedParent(t, n) {
            return this._eventedParent = t, this._eventedParentData = n, this;
          }
        }
        var Te = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, "font-faces": { type: "array", value: "fontFaces" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, "color-relief": {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_color-relief", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_color-relief": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: false, expression: { interpolated: true, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_color-relief", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, "paint_color-relief": { "color-relief-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "color-relief-color": { type: "color", transition: false, expression: { interpolated: true, parameters: ["elevation"] }, "property-type": "color-ramp" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        const $t = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function er(o, t) {
          const n = {};
          for (const u in o) u !== "ref" && (n[u] = o[u]);
          return $t.forEach(((u) => {
            u in t && (n[u] = t[u]);
          })), n;
        }
        function Nt(o, t) {
          if (Array.isArray(o)) {
            if (!Array.isArray(t) || o.length !== t.length) return false;
            for (let n = 0; n < o.length; n++) if (!Nt(o[n], t[n])) return false;
            return true;
          }
          if (typeof o == "object" && o !== null && t !== null) {
            if (typeof t != "object" || Object.keys(o).length !== Object.keys(t).length) return false;
            for (const n in o) if (!Nt(o[n], t[n])) return false;
            return true;
          }
          return o === t;
        }
        function ur(o, t) {
          o.push(t);
        }
        function Br(o, t, n) {
          ur(n, { command: "addSource", args: [o, t[o]] });
        }
        function Kr(o, t, n) {
          ur(t, { command: "removeSource", args: [o] }), n[o] = true;
        }
        function Jr(o, t, n, u) {
          Kr(o, n, u), Br(o, t, n);
        }
        function ii(o, t, n) {
          let u;
          for (u in o[n]) if (Object.prototype.hasOwnProperty.call(o[n], u) && u !== "data" && !Nt(o[n][u], t[n][u])) return false;
          for (u in t[n]) if (Object.prototype.hasOwnProperty.call(t[n], u) && u !== "data" && !Nt(o[n][u], t[n][u])) return false;
          return true;
        }
        function gr(o, t, n, u, h, _) {
          o = o || {}, t = t || {};
          for (const b in o) Object.prototype.hasOwnProperty.call(o, b) && (Nt(o[b], t[b]) || n.push({ command: _, args: [u, b, t[b], h] }));
          for (const b in t) Object.prototype.hasOwnProperty.call(t, b) && !Object.prototype.hasOwnProperty.call(o, b) && (Nt(o[b], t[b]) || n.push({ command: _, args: [u, b, t[b], h] }));
        }
        function vr(o) {
          return o.id;
        }
        function Wr(o, t) {
          return o[t.id] = t, o;
        }
        class ge {
          constructor(t, n, u, h) {
            this.message = (t ? `${t}: ` : "") + u, h && (this.identifier = h), n != null && n.__line__ && (this.line = n.__line__);
          }
        }
        function dt(o, ...t) {
          for (const n of t) for (const u in n) o[u] = n[u];
          return o;
        }
        class Bt extends Error {
          constructor(t, n) {
            super(n), this.message = n, this.key = t;
          }
        }
        class Er {
          constructor(t, n = []) {
            this.parent = t, this.bindings = {};
            for (const [u, h] of n) this.bindings[u] = h;
          }
          concat(t) {
            return new Er(this, t);
          }
          get(t) {
            if (this.bindings[t]) return this.bindings[t];
            if (this.parent) return this.parent.get(t);
            throw new Error(`${t} not found in scope.`);
          }
          has(t) {
            return !!this.bindings[t] || !!this.parent && this.parent.has(t);
          }
        }
        const $r = { kind: "null" }, gt = { kind: "number" }, cr = { kind: "string" }, lr = { kind: "boolean" }, ni = { kind: "color" }, fn = { kind: "projectionDefinition" }, tn = { kind: "object" }, dr = { kind: "value" }, Yo = { kind: "collator" }, qn = { kind: "formatted" }, Ko = { kind: "padding" }, kn = { kind: "colorArray" }, vo = { kind: "numberArray" }, Zr = { kind: "resolvedImage" }, Jn = { kind: "variableAnchorOffsetCollection" };
        function rn(o, t) {
          return { kind: "array", itemType: o, N: t };
        }
        function Ur(o) {
          if (o.kind === "array") {
            const t = Ur(o.itemType);
            return typeof o.N == "number" ? `array<${t}, ${o.N}>` : o.itemType.kind === "value" ? "array" : `array<${t}>`;
          }
          return o.kind;
        }
        const Rl = [$r, gt, cr, lr, ni, fn, qn, tn, rn(dr), Ko, vo, kn, Zr, Jn];
        function ba(o, t) {
          if (t.kind === "error") return null;
          if (o.kind === "array") {
            if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !ba(o.itemType, t.itemType)) && (typeof o.N != "number" || o.N === t.N)) return null;
          } else {
            if (o.kind === t.kind) return null;
            if (o.kind === "value") {
              for (const n of Rl) if (!ba(n, t)) return null;
            }
          }
          return `Expected ${Ur(o)} but found ${Ur(t)} instead.`;
        }
        function Ps(o, t) {
          return t.some(((n) => n.kind === o.kind));
        }
        function _o(o, t) {
          return t.some(((n) => n === "null" ? o === null : n === "array" ? Array.isArray(o) : n === "object" ? o && !Array.isArray(o) && typeof o == "object" : n === typeof o));
        }
        function yo(o, t) {
          return o.kind === "array" && t.kind === "array" ? o.itemType.kind === t.itemType.kind && typeof o.N == "number" : o.kind === t.kind;
        }
        const Ts = 0.96422, Al = 0.82521, Dl = 4 / 29, Jo = 6 / 29, zl = 3 * Jo * Jo, dc = Jo * Jo * Jo, hc = Math.PI / 180, fc = 180 / Math.PI;
        function Is(o) {
          return (o %= 360) < 0 && (o += 360), o;
        }
        function Qo([o, t, n, u]) {
          let h, _;
          const b = Es((0.2225045 * (o = Ms(o)) + 0.7168786 * (t = Ms(t)) + 0.0606169 * (n = Ms(n))) / 1);
          o === t && t === n ? h = _ = b : (h = Es((0.4360747 * o + 0.3850649 * t + 0.1430804 * n) / Ts), _ = Es((0.0139322 * o + 0.0971045 * t + 0.7141733 * n) / Al));
          const w = 116 * b - 16;
          return [w < 0 ? 0 : w, 500 * (h - b), 200 * (b - _), u];
        }
        function Ms(o) {
          return o <= 0.04045 ? o / 12.92 : Math.pow((o + 0.055) / 1.055, 2.4);
        }
        function Es(o) {
          return o > dc ? Math.pow(o, 1 / 3) : o / zl + Dl;
        }
        function ea([o, t, n, u]) {
          let h = (o + 16) / 116, _ = isNaN(t) ? h : h + t / 500, b = isNaN(n) ? h : h - n / 200;
          return h = 1 * As(h), _ = Ts * As(_), b = Al * As(b), [Rs(3.1338561 * _ - 1.6168667 * h - 0.4906146 * b), Rs(-0.9787684 * _ + 1.9161415 * h + 0.033454 * b), Rs(0.0719453 * _ - 0.2289914 * h + 1.4052427 * b), u];
        }
        function Rs(o) {
          return (o = o <= 304e-5 ? 12.92 * o : 1.055 * Math.pow(o, 1 / 2.4) - 0.055) < 0 ? 0 : o > 1 ? 1 : o;
        }
        function As(o) {
          return o > Jo ? o * o * o : zl * (o - Dl);
        }
        const pc = Object.hasOwn || function(o, t) {
          return Object.prototype.hasOwnProperty.call(o, t);
        };
        function ta(o, t) {
          return pc(o, t) ? o[t] : void 0;
        }
        function xa(o) {
          return parseInt(o.padEnd(2, o), 16) / 255;
        }
        function Dn(o, t) {
          return yr(t ? o / 100 : o, 0, 1);
        }
        function yr(o, t, n) {
          return Math.min(Math.max(t, o), n);
        }
        function Ao(o) {
          return !o.some(Number.isNaN);
        }
        const bo = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        function Qn(o, t, n) {
          return o + n * (t - o);
        }
        function Do(o, t, n) {
          return o.map(((u, h) => Qn(u, t[h], n)));
        }
        class br {
          constructor(t, n, u, h = 1, _ = true) {
            this.r = t, this.g = n, this.b = u, this.a = h, _ || (this.r *= h, this.g *= h, this.b *= h, h || this.overwriteGetter("rgb", [t, n, u, h]));
          }
          static parse(t) {
            if (t instanceof br) return t;
            if (typeof t != "string") return;
            const n = (function(u) {
              if ((u = u.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const h = ta(bo, u);
              if (h) {
                const [b, w, S] = h;
                return [b / 255, w / 255, S / 255, 1];
              }
              if (u.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(u)) {
                const b = u.length < 6 ? 1 : 2;
                let w = 1;
                return [xa(u.slice(w, w += b)), xa(u.slice(w, w += b)), xa(u.slice(w, w += b)), xa(u.slice(w, w + b) || "ff")];
              }
              if (u.startsWith("rgb")) {
                const b = u.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (b) {
                  const [w, S, I, R, B, N, q, G, Q, ae, pe, Oe] = b, Ce = [R || " ", q || " ", ae].join("");
                  if (Ce === "  " || Ce === "  /" || Ce === ",," || Ce === ",,,") {
                    const Ie = [I, N, Q].join(""), He = Ie === "%%%" ? 100 : Ie === "" ? 255 : 0;
                    if (He) {
                      const rt = [yr(+S / He, 0, 1), yr(+B / He, 0, 1), yr(+G / He, 0, 1), pe ? Dn(+pe, Oe) : 1];
                      if (Ao(rt)) return rt;
                    }
                  }
                  return;
                }
              }
              const _ = u.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (_) {
                const [b, w, S, I, R, B, N, q, G] = _, Q = [S || " ", R || " ", N].join("");
                if (Q === "  " || Q === "  /" || Q === ",," || Q === ",,,") {
                  const ae = [+w, yr(+I, 0, 100), yr(+B, 0, 100), q ? Dn(+q, G) : 1];
                  if (Ao(ae)) return (function([pe, Oe, Ce, Ie]) {
                    function He(rt) {
                      const _t = (rt + pe / 30) % 12, At = Oe * Math.min(Ce, 1 - Ce);
                      return Ce - At * Math.max(-1, Math.min(_t - 3, 9 - _t, 1));
                    }
                    return pe = Is(pe), Oe /= 100, Ce /= 100, [He(0), He(8), He(4), Ie];
                  })(ae);
                }
              }
            })(t);
            return n ? new br(...n, false) : void 0;
          }
          get rgb() {
            const { r: t, g: n, b: u, a: h } = this, _ = h || 1 / 0;
            return this.overwriteGetter("rgb", [t / _, n / _, u / _, h]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", (function(t) {
              const [n, u, h, _] = Qo(t), b = Math.sqrt(u * u + h * h);
              return [Math.round(1e4 * b) ? Is(Math.atan2(h, u) * fc) : NaN, b, n, _];
            })(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", Qo(this.rgb));
          }
          overwriteGetter(t, n) {
            return Object.defineProperty(this, t, { value: n }), n;
          }
          toString() {
            const [t, n, u, h] = this.rgb;
            return `rgba(${[t, n, u].map(((_) => Math.round(255 * _))).join(",")},${h})`;
          }
          static interpolate(t, n, u, h = "rgb") {
            switch (h) {
              case "rgb": {
                const [_, b, w, S] = Do(t.rgb, n.rgb, u);
                return new br(_, b, w, S, false);
              }
              case "hcl": {
                const [_, b, w, S] = t.hcl, [I, R, B, N] = n.hcl;
                let q, G;
                if (isNaN(_) || isNaN(I)) isNaN(_) ? isNaN(I) ? q = NaN : (q = I, w !== 1 && w !== 0 || (G = R)) : (q = _, B !== 1 && B !== 0 || (G = b));
                else {
                  let Ce = I - _;
                  I > _ && Ce > 180 ? Ce -= 360 : I < _ && _ - I > 180 && (Ce += 360), q = _ + u * Ce;
                }
                const [Q, ae, pe, Oe] = (function([Ce, Ie, He, rt]) {
                  return Ce = isNaN(Ce) ? 0 : Ce * hc, ea([He, Math.cos(Ce) * Ie, Math.sin(Ce) * Ie, rt]);
                })([q, G ?? Qn(b, R, u), Qn(w, B, u), Qn(S, N, u)]);
                return new br(Q, ae, pe, Oe, false);
              }
              case "lab": {
                const [_, b, w, S] = ea(Do(t.lab, n.lab, u));
                return new br(_, b, w, S, false);
              }
            }
          }
        }
        br.black = new br(0, 0, 0, 1), br.white = new br(1, 1, 1, 1), br.transparent = new br(0, 0, 0, 0), br.red = new br(1, 0, 0, 1);
        class wa {
          constructor(t, n, u) {
            this.sensitivity = t ? n ? "variant" : "case" : n ? "accent" : "base", this.locale = u, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t, n) {
            return this.collator.compare(t, n);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        const Fl = ["bottom", "center", "top"];
        class Ll {
          constructor(t, n, u, h, _, b) {
            this.text = t, this.image = n, this.scale = u, this.fontStack = h, this.textColor = _, this.verticalAlign = b;
          }
        }
        class pn {
          constructor(t) {
            this.sections = t;
          }
          static fromString(t) {
            return new pn([new Ll(t, null, null, null, null, null)]);
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some(((t) => t.text.length !== 0 || t.image && t.image.name.length !== 0));
          }
          static factory(t) {
            return t instanceof pn ? t : pn.fromString(t);
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map(((t) => t.text)).join("");
          }
        }
        class ji {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof ji) return t;
            if (typeof t == "number") return new ji([t, t, t, t]);
            if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
              for (const n of t) if (typeof n != "number") return;
              switch (t.length) {
                case 1:
                  t = [t[0], t[0], t[0], t[0]];
                  break;
                case 2:
                  t = [t[0], t[1], t[0], t[1]];
                  break;
                case 3:
                  t = [t[0], t[1], t[2], t[1]];
              }
              return new ji(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, u) {
            return new ji(Do(t.values, n.values, u));
          }
        }
        class mn {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof mn) return t;
            if (typeof t == "number") return new mn([t]);
            if (Array.isArray(t)) {
              for (const n of t) if (typeof n != "number") return;
              return new mn(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, u) {
            return new mn(Do(t.values, n.values, u));
          }
        }
        class Mi {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof Mi) return t;
            if (typeof t == "string") {
              const u = br.parse(t);
              return u ? new Mi([u]) : void 0;
            }
            if (!Array.isArray(t)) return;
            const n = [];
            for (const u of t) {
              if (typeof u != "string") return;
              const h = br.parse(u);
              if (!h) return;
              n.push(h);
            }
            return new Mi(n);
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, u, h = "rgb") {
            const _ = [];
            if (t.values.length != n.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t.values.length} vs. ${n.values.length}), cannot interpolate.`);
            for (let b = 0; b < t.values.length; b++) _.push(br.interpolate(t.values[b], n.values[b], u, h));
            return new Mi(_);
          }
        }
        class Qr extends Error {
          constructor(t) {
            super(t), this.name = "RuntimeError";
          }
          toJSON() {
            return this.message;
          }
        }
        const ch = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class gn {
          constructor(t) {
            this.values = t.slice();
          }
          static parse(t) {
            if (t instanceof gn) return t;
            if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
              for (let n = 0; n < t.length; n += 2) {
                const u = t[n], h = t[n + 1];
                if (typeof u != "string" || !ch.has(u) || !Array.isArray(h) || h.length !== 2 || typeof h[0] != "number" || typeof h[1] != "number") return;
              }
              return new gn(t);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t, n, u) {
            const h = t.values, _ = n.values;
            if (h.length !== _.length) throw new Qr(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${n.toString()}`);
            const b = [];
            for (let w = 0; w < h.length; w += 2) {
              if (h[w] !== _[w]) throw new Qr(`Cannot interpolate values containing mismatched anchors. from[${w}]: ${h[w]}, to[${w}]: ${_[w]}`);
              b.push(h[w]);
              const [S, I] = h[w + 1], [R, B] = _[w + 1];
              b.push([Qn(S, R, u), Qn(I, B, u)]);
            }
            return new gn(b);
          }
        }
        class zn {
          constructor(t) {
            this.name = t.name, this.available = t.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t) {
            return t ? new zn({ name: t, available: false }) : null;
          }
        }
        class nn {
          constructor(t, n, u) {
            this.from = t, this.to = n, this.transition = u;
          }
          static interpolate(t, n, u) {
            return new nn(t, n, u);
          }
          static parse(t) {
            return t instanceof nn ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new nn(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new nn(t.from, t.to, t.transition) : typeof t == "string" ? new nn(t, t, 1) : void 0;
          }
        }
        function li(o, t, n, u) {
          return typeof o == "number" && o >= 0 && o <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof n == "number" && n >= 0 && n <= 255 ? u === void 0 || typeof u == "number" && u >= 0 && u <= 1 ? null : `Invalid rgba value [${[o, t, n, u].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof u == "number" ? [o, t, n, u] : [o, t, n]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Ca(o) {
          if (o === null || typeof o == "string" || typeof o == "boolean" || typeof o == "number" || o instanceof nn || o instanceof br || o instanceof wa || o instanceof pn || o instanceof ji || o instanceof mn || o instanceof Mi || o instanceof gn || o instanceof zn) return true;
          if (Array.isArray(o)) {
            for (const t of o) if (!Ca(t)) return false;
            return true;
          }
          if (typeof o == "object") {
            for (const t in o) if (!Ca(o[t])) return false;
            return true;
          }
          return false;
        }
        function nr(o) {
          if (o === null) return $r;
          if (typeof o == "string") return cr;
          if (typeof o == "boolean") return lr;
          if (typeof o == "number") return gt;
          if (o instanceof br) return ni;
          if (o instanceof nn) return fn;
          if (o instanceof wa) return Yo;
          if (o instanceof pn) return qn;
          if (o instanceof ji) return Ko;
          if (o instanceof mn) return vo;
          if (o instanceof Mi) return kn;
          if (o instanceof gn) return Jn;
          if (o instanceof zn) return Zr;
          if (Array.isArray(o)) {
            const t = o.length;
            let n;
            for (const u of o) {
              const h = nr(u);
              if (n) {
                if (n === h) continue;
                n = dr;
                break;
              }
              n = h;
            }
            return rn(n || dr, t);
          }
          return tn;
        }
        function mr(o) {
          const t = typeof o;
          return o === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(o) : o instanceof br || o instanceof nn || o instanceof pn || o instanceof ji || o instanceof mn || o instanceof Mi || o instanceof gn || o instanceof zn ? o.toString() : JSON.stringify(o);
        }
        class zo {
          constructor(t, n) {
            this.type = t, this.value = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (!Ca(t[1])) return n.error("invalid value");
            const u = t[1];
            let h = nr(u);
            const _ = n.expectedType;
            return h.kind !== "array" || h.N !== 0 || !_ || _.kind !== "array" || typeof _.N == "number" && _.N !== 0 || (h = _), new zo(h, u);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        const Rr = { string: cr, number: gt, boolean: lr, object: tn };
        class Fn {
          constructor(t, n) {
            this.type = t, this.args = n;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            let u, h = 1;
            const _ = t[0];
            if (_ === "array") {
              let w, S;
              if (t.length > 2) {
                const I = t[1];
                if (typeof I != "string" || !(I in Rr) || I === "object") return n.error('The item type argument of "array" must be one of string, number, boolean', 1);
                w = Rr[I], h++;
              } else w = dr;
              if (t.length > 3) {
                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return n.error('The length argument to "array" must be a positive integer literal', 2);
                S = t[2], h++;
              }
              u = rn(w, S);
            } else {
              if (!Rr[_]) throw new Error(`Types doesn't contain name = ${_}`);
              u = Rr[_];
            }
            const b = [];
            for (; h < t.length; h++) {
              const w = n.parse(t[h], h, dr);
              if (!w) return null;
              b.push(w);
            }
            return new Fn(u, b);
          }
          evaluate(t) {
            for (let n = 0; n < this.args.length; n++) {
              const u = this.args[n].evaluate(t);
              if (!ba(this.type, nr(u))) return u;
              if (n === this.args.length - 1) throw new Qr(`Expected value to be of type ${Ur(this.type)}, but found ${Ur(nr(u))} instead.`);
            }
            throw new Error();
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        const xo = { "to-boolean": lr, "to-color": ni, "to-number": gt, "to-string": cr };
        class wo {
          constructor(t, n) {
            this.type = t, this.args = n;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            const u = t[0];
            if (!xo[u]) throw new Error(`Can't parse ${u} as it is not part of the known types`);
            if ((u === "to-boolean" || u === "to-string") && t.length !== 2) return n.error("Expected one argument.");
            const h = xo[u], _ = [];
            for (let b = 1; b < t.length; b++) {
              const w = n.parse(t[b], b, dr);
              if (!w) return null;
              _.push(w);
            }
            return new wo(h, _);
          }
          evaluate(t) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(t);
              case "color": {
                let n, u;
                for (const h of this.args) {
                  if (n = h.evaluate(t), u = null, n instanceof br) return n;
                  if (typeof n == "string") {
                    const _ = t.parseColor(n);
                    if (_) return _;
                  } else if (Array.isArray(n) && (u = n.length < 3 || n.length > 4 ? `Invalid rgba value ${JSON.stringify(n)}: expected an array containing either three or four numeric values.` : li(n[0], n[1], n[2], n[3]), !u)) return new br(n[0] / 255, n[1] / 255, n[2] / 255, n[3]);
                }
                throw new Qr(u || `Could not parse color from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "padding": {
                let n;
                for (const u of this.args) {
                  n = u.evaluate(t);
                  const h = ji.parse(n);
                  if (h) return h;
                }
                throw new Qr(`Could not parse padding from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "numberArray": {
                let n;
                for (const u of this.args) {
                  n = u.evaluate(t);
                  const h = mn.parse(n);
                  if (h) return h;
                }
                throw new Qr(`Could not parse numberArray from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "colorArray": {
                let n;
                for (const u of this.args) {
                  n = u.evaluate(t);
                  const h = Mi.parse(n);
                  if (h) return h;
                }
                throw new Qr(`Could not parse colorArray from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let n;
                for (const u of this.args) {
                  n = u.evaluate(t);
                  const h = gn.parse(n);
                  if (h) return h;
                }
                throw new Qr(`Could not parse variableAnchorOffsetCollection from value '${typeof n == "string" ? n : JSON.stringify(n)}'`);
              }
              case "number": {
                let n = null;
                for (const u of this.args) {
                  if (n = u.evaluate(t), n === null) return 0;
                  const h = Number(n);
                  if (!isNaN(h)) return h;
                }
                throw new Qr(`Could not convert ${JSON.stringify(n)} to number.`);
              }
              case "formatted":
                return pn.fromString(mr(this.args[0].evaluate(t)));
              case "resolvedImage":
                return zn.fromString(mr(this.args[0].evaluate(t)));
              case "projectionDefinition":
                return this.args[0].evaluate(t);
              default:
                return mr(this.args[0].evaluate(t));
            }
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        const Bl = ["Unknown", "Point", "LineString", "Polygon"];
        class mc {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? Bl[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(t) {
            let n = this._parseColorCache.get(t);
            return n || (n = br.parse(t), this._parseColorCache.set(t, n)), n;
          }
        }
        class es {
          constructor(t, n, u = [], h, _ = new Er(), b = []) {
            this.registry = t, this.path = u, this.key = u.map(((w) => `[${w}]`)).join(""), this.scope = _, this.errors = b, this.expectedType = h, this._isConstant = n;
          }
          parse(t, n, u, h, _ = {}) {
            return n ? this.concat(n, u, h)._parse(t, _) : this._parse(t, _);
          }
          _parse(t, n) {
            function u(h, _, b) {
              return b === "assert" ? new Fn(_, [h]) : b === "coerce" ? new wo(_, [h]) : h;
            }
            if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) {
              if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const h = t[0];
              if (typeof h != "string") return this.error(`Expression name must be a string, but found ${typeof h} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const _ = this.registry[h];
              if (_) {
                let b = _.parse(t, this);
                if (!b) return null;
                if (this.expectedType) {
                  const w = this.expectedType, S = b.type;
                  if (w.kind !== "string" && w.kind !== "number" && w.kind !== "boolean" && w.kind !== "object" && w.kind !== "array" || S.kind !== "value") {
                    if (w.kind === "projectionDefinition" && ["string", "array"].includes(S.kind) || ["color", "formatted", "resolvedImage"].includes(w.kind) && ["value", "string"].includes(S.kind) || ["padding", "numberArray"].includes(w.kind) && ["value", "number", "array"].includes(S.kind) || w.kind === "colorArray" && ["value", "string", "array"].includes(S.kind) || w.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(S.kind)) b = u(b, w, n.typeAnnotation || "coerce");
                    else if (this.checkSubtype(w, S)) return null;
                  } else b = u(b, w, n.typeAnnotation || "assert");
                }
                if (!(b instanceof zo) && b.type.kind !== "resolvedImage" && this._isConstant(b)) {
                  const w = new mc();
                  try {
                    b = new zo(b.type, b.evaluate(w));
                  } catch (S) {
                    return this.error(S.message), null;
                  }
                }
                return b;
              }
              return this.error(`Unknown expression "${h}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);
          }
          concat(t, n, u) {
            const h = typeof t == "number" ? this.path.concat(t) : this.path, _ = u ? this.scope.concat(u) : this.scope;
            return new es(this.registry, this._isConstant, h, n || null, _, this.errors);
          }
          error(t, ...n) {
            const u = `${this.key}${n.map(((h) => `[${h}]`)).join("")}`;
            this.errors.push(new Bt(u, t));
          }
          checkSubtype(t, n) {
            const u = ba(t, n);
            return u && this.error(u), u;
          }
        }
        class Ds {
          constructor(t, n) {
            this.type = n.type, this.bindings = [].concat(t), this.result = n;
          }
          evaluate(t) {
            return this.result.evaluate(t);
          }
          eachChild(t) {
            for (const n of this.bindings) t(n[1]);
            t(this.result);
          }
          static parse(t, n) {
            if (t.length < 4) return n.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
            const u = [];
            for (let _ = 1; _ < t.length - 1; _ += 2) {
              const b = t[_];
              if (typeof b != "string") return n.error(`Expected string, but found ${typeof b} instead.`, _);
              if (/[^a-zA-Z0-9_]/.test(b)) return n.error("Variable names must contain only alphanumeric characters or '_'.", _);
              const w = n.parse(t[_ + 1], _ + 1);
              if (!w) return null;
              u.push([b, w]);
            }
            const h = n.parse(t[t.length - 1], t.length - 1, n.expectedType, u);
            return h ? new Ds(u, h) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class Ol {
          constructor(t, n) {
            this.type = n.type, this.name = t, this.boundExpression = n;
          }
          static parse(t, n) {
            if (t.length !== 2 || typeof t[1] != "string") return n.error("'var' expression requires exactly one string literal argument.");
            const u = t[1];
            return n.scope.has(u) ? new Ol(u, n.scope.get(u)) : n.error(`Unknown variable "${u}". Make sure "${u}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t) {
            return this.boundExpression.evaluate(t);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
        }
        class $l {
          constructor(t, n, u) {
            this.type = t, this.index = n, this.input = u;
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
            const u = n.parse(t[1], 1, gt), h = n.parse(t[2], 2, rn(n.expectedType || dr));
            return u && h ? new $l(h.type.itemType, u, h) : null;
          }
          evaluate(t) {
            const n = this.index.evaluate(t), u = this.input.evaluate(t);
            if (n < 0) throw new Qr(`Array index out of bounds: ${n} < 0.`);
            if (n >= u.length) throw new Qr(`Array index out of bounds: ${n} > ${u.length - 1}.`);
            if (n !== Math.floor(n)) throw new Qr(`Array index must be an integer, but found ${n} instead.`);
            return u[n];
          }
          eachChild(t) {
            t(this.index), t(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class jl {
          constructor(t, n) {
            this.type = lr, this.needle = t, this.haystack = n;
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
            const u = n.parse(t[1], 1, dr), h = n.parse(t[2], 2, dr);
            return u && h ? Ps(u.type, [lr, cr, gt, $r, dr]) ? new jl(u, h) : n.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ur(u.type)} instead`) : null;
          }
          evaluate(t) {
            const n = this.needle.evaluate(t), u = this.haystack.evaluate(t);
            if (!u) return false;
            if (!_o(n, ["boolean", "string", "number", "null"])) throw new Qr(`Expected first argument to be of type boolean, string, number or null, but found ${Ur(nr(n))} instead.`);
            if (!_o(u, ["string", "array"])) throw new Qr(`Expected second argument to be of type array or string, but found ${Ur(nr(u))} instead.`);
            return u.indexOf(n) >= 0;
          }
          eachChild(t) {
            t(this.needle), t(this.haystack);
          }
          outputDefined() {
            return true;
          }
        }
        class eo {
          constructor(t, n, u) {
            this.type = gt, this.needle = t, this.haystack = n, this.fromIndex = u;
          }
          static parse(t, n) {
            if (t.length <= 2 || t.length >= 5) return n.error(`Expected 2 or 3 arguments, but found ${t.length - 1} instead.`);
            const u = n.parse(t[1], 1, dr), h = n.parse(t[2], 2, dr);
            if (!u || !h) return null;
            if (!Ps(u.type, [lr, cr, gt, $r, dr])) return n.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ur(u.type)} instead`);
            if (t.length === 4) {
              const _ = n.parse(t[3], 3, gt);
              return _ ? new eo(u, h, _) : null;
            }
            return new eo(u, h);
          }
          evaluate(t) {
            const n = this.needle.evaluate(t), u = this.haystack.evaluate(t);
            if (!_o(n, ["boolean", "string", "number", "null"])) throw new Qr(`Expected first argument to be of type boolean, string, number or null, but found ${Ur(nr(n))} instead.`);
            let h;
            if (this.fromIndex && (h = this.fromIndex.evaluate(t)), _o(u, ["string"])) {
              const _ = u.indexOf(n, h);
              return _ === -1 ? -1 : [...u.slice(0, _)].length;
            }
            if (_o(u, ["array"])) return u.indexOf(n, h);
            throw new Qr(`Expected second argument to be of type array or string, but found ${Ur(nr(u))} instead.`);
          }
          eachChild(t) {
            t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
        }
        class Ni {
          constructor(t, n, u, h, _, b) {
            this.inputType = t, this.type = n, this.input = u, this.cases = h, this.outputs = _, this.otherwise = b;
          }
          static parse(t, n) {
            if (t.length < 5) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if (t.length % 2 != 1) return n.error("Expected an even number of arguments.");
            let u, h;
            n.expectedType && n.expectedType.kind !== "value" && (h = n.expectedType);
            const _ = {}, b = [];
            for (let I = 2; I < t.length - 1; I += 2) {
              let R = t[I];
              const B = t[I + 1];
              Array.isArray(R) || (R = [R]);
              const N = n.concat(I);
              if (R.length === 0) return N.error("Expected at least one branch label.");
              for (const G of R) {
                if (typeof G != "number" && typeof G != "string") return N.error("Branch labels must be numbers or strings.");
                if (typeof G == "number" && Math.abs(G) > Number.MAX_SAFE_INTEGER) return N.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof G == "number" && Math.floor(G) !== G) return N.error("Numeric branch labels must be integer values.");
                if (u) {
                  if (N.checkSubtype(u, nr(G))) return null;
                } else u = nr(G);
                if (_[String(G)] !== void 0) return N.error("Branch labels must be unique.");
                _[String(G)] = b.length;
              }
              const q = n.parse(B, I, h);
              if (!q) return null;
              h = h || q.type, b.push(q);
            }
            const w = n.parse(t[1], 1, dr);
            if (!w) return null;
            const S = n.parse(t[t.length - 1], t.length - 1, h);
            return S ? w.type.kind !== "value" && n.concat(1).checkSubtype(u, w.type) ? null : new Ni(u, h, w, _, b, S) : null;
          }
          evaluate(t) {
            const n = this.input.evaluate(t);
            return (nr(n) === this.inputType && this.outputs[this.cases[n]] || this.otherwise).evaluate(t);
          }
          eachChild(t) {
            t(this.input), this.outputs.forEach(t), t(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class ts {
          constructor(t, n, u) {
            this.type = t, this.branches = n, this.otherwise = u;
          }
          static parse(t, n) {
            if (t.length < 4) return n.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
            if (t.length % 2 != 0) return n.error("Expected an odd number of arguments.");
            let u;
            n.expectedType && n.expectedType.kind !== "value" && (u = n.expectedType);
            const h = [];
            for (let b = 1; b < t.length - 1; b += 2) {
              const w = n.parse(t[b], b, lr);
              if (!w) return null;
              const S = n.parse(t[b + 1], b + 1, u);
              if (!S) return null;
              h.push([w, S]), u = u || S.type;
            }
            const _ = n.parse(t[t.length - 1], t.length - 1, u);
            if (!_) return null;
            if (!u) throw new Error("Can't infer output type");
            return new ts(u, h, _);
          }
          evaluate(t) {
            for (const [n, u] of this.branches) if (n.evaluate(t)) return u.evaluate(t);
            return this.otherwise.evaluate(t);
          }
          eachChild(t) {
            for (const [n, u] of this.branches) t(n), t(u);
            t(this.otherwise);
          }
          outputDefined() {
            return this.branches.every((([t, n]) => n.outputDefined())) && this.otherwise.outputDefined();
          }
        }
        class zs {
          constructor(t, n, u, h) {
            this.type = t, this.input = n, this.beginIndex = u, this.endIndex = h;
          }
          static parse(t, n) {
            if (t.length <= 2 || t.length >= 5) return n.error(`Expected 2 or 3 arguments, but found ${t.length - 1} instead.`);
            const u = n.parse(t[1], 1, dr), h = n.parse(t[2], 2, gt);
            if (!u || !h) return null;
            if (!Ps(u.type, [rn(dr), cr, dr])) return n.error(`Expected first argument to be of type array or string, but found ${Ur(u.type)} instead`);
            if (t.length === 4) {
              const _ = n.parse(t[3], 3, gt);
              return _ ? new zs(u.type, u, h, _) : null;
            }
            return new zs(u.type, u, h);
          }
          evaluate(t) {
            const n = this.input.evaluate(t), u = this.beginIndex.evaluate(t);
            let h;
            if (this.endIndex && (h = this.endIndex.evaluate(t)), _o(n, ["string"])) return [...n].slice(u, h).join("");
            if (_o(n, ["array"])) return n.slice(u, h);
            throw new Qr(`Expected first argument to be of type array or string, but found ${Ur(nr(n))} instead.`);
          }
          eachChild(t) {
            t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
          }
          outputDefined() {
            return false;
          }
        }
        function Sa(o, t) {
          const n = o.length - 1;
          let u, h, _ = 0, b = n, w = 0;
          for (; _ <= b; ) if (w = Math.floor((_ + b) / 2), u = o[w], h = o[w + 1], u <= t) {
            if (w === n || t < h) return w;
            _ = w + 1;
          } else {
            if (!(u > t)) throw new Qr("Input is not a number.");
            b = w - 1;
          }
          return 0;
        }
        class xi {
          constructor(t, n, u) {
            this.type = t, this.input = n, this.labels = [], this.outputs = [];
            for (const [h, _] of u) this.labels.push(h), this.outputs.push(_);
          }
          static parse(t, n) {
            if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
            const u = n.parse(t[1], 1, gt);
            if (!u) return null;
            const h = [];
            let _ = null;
            n.expectedType && n.expectedType.kind !== "value" && (_ = n.expectedType);
            for (let b = 1; b < t.length; b += 2) {
              const w = b === 1 ? -1 / 0 : t[b], S = t[b + 1], I = b, R = b + 1;
              if (typeof w != "number") return n.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', I);
              if (h.length && h[h.length - 1][0] >= w) return n.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', I);
              const B = n.parse(S, R, _);
              if (!B) return null;
              _ = _ || B.type, h.push([w, B]);
            }
            return new xi(_, u, h);
          }
          evaluate(t) {
            const n = this.labels, u = this.outputs;
            if (n.length === 1) return u[0].evaluate(t);
            const h = this.input.evaluate(t);
            if (h <= n[0]) return u[0].evaluate(t);
            const _ = n.length;
            return h >= n[_ - 1] ? u[_ - 1].evaluate(t) : u[Sa(n, h)].evaluate(t);
          }
          eachChild(t) {
            t(this.input);
            for (const n of this.outputs) t(n);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined()));
          }
        }
        function dh(o) {
          return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
        }
        var Fs, gc, bp = (function() {
          if (gc) return Fs;
          function o(t, n, u, h) {
            this.cx = 3 * t, this.bx = 3 * (u - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (h - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = u, this.p2y = h;
          }
          return gc = 1, Fs = o, o.prototype = { sampleCurveX: function(t) {
            return ((this.ax * t + this.bx) * t + this.cx) * t;
          }, sampleCurveY: function(t) {
            return ((this.ay * t + this.by) * t + this.cy) * t;
          }, sampleCurveDerivativeX: function(t) {
            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
          }, solveCurveX: function(t, n) {
            if (n === void 0 && (n = 1e-6), t < 0) return 0;
            if (t > 1) return 1;
            for (var u = t, h = 0; h < 8; h++) {
              var _ = this.sampleCurveX(u) - t;
              if (Math.abs(_) < n) return u;
              var b = this.sampleCurveDerivativeX(u);
              if (Math.abs(b) < 1e-6) break;
              u -= _ / b;
            }
            var w = 0, S = 1;
            for (u = t, h = 0; h < 20 && (_ = this.sampleCurveX(u), !(Math.abs(_ - t) < n)); h++) t > _ ? w = u : S = u, u = 0.5 * (S - w) + w;
            return u;
          }, solve: function(t, n) {
            return this.sampleCurveY(this.solveCurveX(t, n));
          } }, Fs;
        })(), rs = dh(bp);
        class Hi {
          constructor(t, n, u, h, _) {
            this.type = t, this.operator = n, this.interpolation = u, this.input = h, this.labels = [], this.outputs = [];
            for (const [b, w] of _) this.labels.push(b), this.outputs.push(w);
          }
          static interpolationFactor(t, n, u, h) {
            let _ = 0;
            if (t.name === "exponential") _ = Ls(n, t.base, u, h);
            else if (t.name === "linear") _ = Ls(n, 1, u, h);
            else if (t.name === "cubic-bezier") {
              const b = t.controlPoints;
              _ = new rs(b[0], b[1], b[2], b[3]).solve(Ls(n, 1, u, h));
            }
            return _;
          }
          static parse(t, n) {
            let [u, h, _, ...b] = t;
            if (!Array.isArray(h) || h.length === 0) return n.error("Expected an interpolation type expression.", 1);
            if (h[0] === "linear") h = { name: "linear" };
            else if (h[0] === "exponential") {
              const I = h[1];
              if (typeof I != "number") return n.error("Exponential interpolation requires a numeric base.", 1, 1);
              h = { name: "exponential", base: I };
            } else {
              if (h[0] !== "cubic-bezier") return n.error(`Unknown interpolation type ${String(h[0])}`, 1, 0);
              {
                const I = h.slice(1);
                if (I.length !== 4 || I.some(((R) => typeof R != "number" || R < 0 || R > 1))) return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                h = { name: "cubic-bezier", controlPoints: I };
              }
            }
            if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
            if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments.");
            if (_ = n.parse(_, 2, gt), !_) return null;
            const w = [];
            let S = null;
            u !== "interpolate-hcl" && u !== "interpolate-lab" || n.expectedType == kn ? n.expectedType && n.expectedType.kind !== "value" && (S = n.expectedType) : S = ni;
            for (let I = 0; I < b.length; I += 2) {
              const R = b[I], B = b[I + 1], N = I + 3, q = I + 4;
              if (typeof R != "number") return n.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', N);
              if (w.length && w[w.length - 1][0] >= R) return n.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', N);
              const G = n.parse(B, q, S);
              if (!G) return null;
              S = S || G.type, w.push([R, G]);
            }
            return yo(S, gt) || yo(S, fn) || yo(S, ni) || yo(S, Ko) || yo(S, vo) || yo(S, kn) || yo(S, Jn) || yo(S, rn(gt)) ? new Hi(S, u, h, _, w) : n.error(`Type ${Ur(S)} is not interpolatable.`);
          }
          evaluate(t) {
            const n = this.labels, u = this.outputs;
            if (n.length === 1) return u[0].evaluate(t);
            const h = this.input.evaluate(t);
            if (h <= n[0]) return u[0].evaluate(t);
            const _ = n.length;
            if (h >= n[_ - 1]) return u[_ - 1].evaluate(t);
            const b = Sa(n, h), w = Hi.interpolationFactor(this.interpolation, h, n[b], n[b + 1]), S = u[b].evaluate(t), I = u[b + 1].evaluate(t);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return Qn(S, I, w);
                  case "color":
                    return br.interpolate(S, I, w);
                  case "padding":
                    return ji.interpolate(S, I, w);
                  case "colorArray":
                    return Mi.interpolate(S, I, w);
                  case "numberArray":
                    return mn.interpolate(S, I, w);
                  case "variableAnchorOffsetCollection":
                    return gn.interpolate(S, I, w);
                  case "array":
                    return Do(S, I, w);
                  case "projectionDefinition":
                    return nn.interpolate(S, I, w);
                }
              case "interpolate-hcl":
                switch (this.type.kind) {
                  case "color":
                    return br.interpolate(S, I, w, "hcl");
                  case "colorArray":
                    return Mi.interpolate(S, I, w, "hcl");
                }
              case "interpolate-lab":
                switch (this.type.kind) {
                  case "color":
                    return br.interpolate(S, I, w, "lab");
                  case "colorArray":
                    return Mi.interpolate(S, I, w, "lab");
                }
            }
          }
          eachChild(t) {
            t(this.input);
            for (const n of this.outputs) t(n);
          }
          outputDefined() {
            return this.outputs.every(((t) => t.outputDefined()));
          }
        }
        function Ls(o, t, n, u) {
          const h = u - n, _ = o - n;
          return h === 0 ? 0 : t === 1 ? _ / h : (Math.pow(t, _) - 1) / (Math.pow(t, h) - 1);
        }
        const Co = { color: br.interpolate, number: Qn, padding: ji.interpolate, numberArray: mn.interpolate, colorArray: Mi.interpolate, variableAnchorOffsetCollection: gn.interpolate, array: Do };
        class Bs {
          constructor(t, n) {
            this.type = t, this.args = n;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            let u = null;
            const h = n.expectedType;
            h && h.kind !== "value" && (u = h);
            const _ = [];
            for (const w of t.slice(1)) {
              const S = n.parse(w, 1 + _.length, u, void 0, { typeAnnotation: "omit" });
              if (!S) return null;
              u = u || S.type, _.push(S);
            }
            if (!u) throw new Error("No output type");
            const b = h && _.some(((w) => ba(h, w.type)));
            return new Bs(b ? dr : u, _);
          }
          evaluate(t) {
            let n, u = null, h = 0;
            for (const _ of this.args) if (h++, u = _.evaluate(t), u && u instanceof zn && !u.available && (n || (n = u.name), u = null, h === this.args.length && (u = n)), u !== null) break;
            return u;
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return this.args.every(((t) => t.outputDefined()));
          }
        }
        function Os(o, t) {
          return o === "==" || o === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value";
        }
        function $s(o, t, n, u) {
          return u.compare(t, n) === 0;
        }
        function on(o, t, n) {
          const u = o !== "==" && o !== "!=";
          return class Jb {
            constructor(_, b, w) {
              this.type = lr, this.lhs = _, this.rhs = b, this.collator = w, this.hasUntypedArgument = _.type.kind === "value" || b.type.kind === "value";
            }
            static parse(_, b) {
              if (_.length !== 3 && _.length !== 4) return b.error("Expected two or three arguments.");
              const w = _[0];
              let S = b.parse(_[1], 1, dr);
              if (!S) return null;
              if (!Os(w, S.type)) return b.concat(1).error(`"${w}" comparisons are not supported for type '${Ur(S.type)}'.`);
              let I = b.parse(_[2], 2, dr);
              if (!I) return null;
              if (!Os(w, I.type)) return b.concat(2).error(`"${w}" comparisons are not supported for type '${Ur(I.type)}'.`);
              if (S.type.kind !== I.type.kind && S.type.kind !== "value" && I.type.kind !== "value") return b.error(`Cannot compare types '${Ur(S.type)}' and '${Ur(I.type)}'.`);
              u && (S.type.kind === "value" && I.type.kind !== "value" ? S = new Fn(I.type, [S]) : S.type.kind !== "value" && I.type.kind === "value" && (I = new Fn(S.type, [I])));
              let R = null;
              if (_.length === 4) {
                if (S.type.kind !== "string" && I.type.kind !== "string" && S.type.kind !== "value" && I.type.kind !== "value") return b.error("Cannot use collator to compare non-string types.");
                if (R = b.parse(_[3], 3, Yo), !R) return null;
              }
              return new Jb(S, I, R);
            }
            evaluate(_) {
              const b = this.lhs.evaluate(_), w = this.rhs.evaluate(_);
              if (u && this.hasUntypedArgument) {
                const S = nr(b), I = nr(w);
                if (S.kind !== I.kind || S.kind !== "string" && S.kind !== "number") throw new Qr(`Expected arguments for "${o}" to be (string, string) or (number, number), but found (${S.kind}, ${I.kind}) instead.`);
              }
              if (this.collator && !u && this.hasUntypedArgument) {
                const S = nr(b), I = nr(w);
                if (S.kind !== "string" || I.kind !== "string") return t(_, b, w);
              }
              return this.collator ? n(_, b, w, this.collator.evaluate(_)) : t(_, b, w);
            }
            eachChild(_) {
              _(this.lhs), _(this.rhs), this.collator && _(this.collator);
            }
            outputDefined() {
              return true;
            }
          };
        }
        const hh = on("==", (function(o, t, n) {
          return t === n;
        }), $s), Nl = on("!=", (function(o, t, n) {
          return t !== n;
        }), (function(o, t, n, u) {
          return !$s(0, t, n, u);
        })), xp = on("<", (function(o, t, n) {
          return t < n;
        }), (function(o, t, n, u) {
          return u.compare(t, n) < 0;
        })), vc = on(">", (function(o, t, n) {
          return t > n;
        }), (function(o, t, n, u) {
          return u.compare(t, n) > 0;
        })), wp = on("<=", (function(o, t, n) {
          return t <= n;
        }), (function(o, t, n, u) {
          return u.compare(t, n) <= 0;
        })), Cp = on(">=", (function(o, t, n) {
          return t >= n;
        }), (function(o, t, n, u) {
          return u.compare(t, n) >= 0;
        }));
        class Vl {
          constructor(t, n, u) {
            this.type = Yo, this.locale = u, this.caseSensitive = t, this.diacriticSensitive = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error("Expected one argument.");
            const u = t[1];
            if (typeof u != "object" || Array.isArray(u)) return n.error("Collator options argument must be an object.");
            const h = n.parse(u["case-sensitive"] !== void 0 && u["case-sensitive"], 1, lr);
            if (!h) return null;
            const _ = n.parse(u["diacritic-sensitive"] !== void 0 && u["diacritic-sensitive"], 1, lr);
            if (!_) return null;
            let b = null;
            return u.locale && (b = n.parse(u.locale, 1, cr), !b) ? null : new Vl(h, _, b);
          }
          evaluate(t) {
            return new wa(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
          }
          eachChild(t) {
            t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
          }
          outputDefined() {
            return false;
          }
        }
        class _c {
          constructor(t, n, u, h, _) {
            this.type = cr, this.number = t, this.locale = n, this.currency = u, this.minFractionDigits = h, this.maxFractionDigits = _;
          }
          static parse(t, n) {
            if (t.length !== 3) return n.error("Expected two arguments.");
            const u = n.parse(t[1], 1, gt);
            if (!u) return null;
            const h = t[2];
            if (typeof h != "object" || Array.isArray(h)) return n.error("NumberFormat options argument must be an object.");
            let _ = null;
            if (h.locale && (_ = n.parse(h.locale, 1, cr), !_)) return null;
            let b = null;
            if (h.currency && (b = n.parse(h.currency, 1, cr), !b)) return null;
            let w = null;
            if (h["min-fraction-digits"] && (w = n.parse(h["min-fraction-digits"], 1, gt), !w)) return null;
            let S = null;
            return h["max-fraction-digits"] && (S = n.parse(h["max-fraction-digits"], 1, gt), !S) ? null : new _c(u, _, b, w, S);
          }
          evaluate(t) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0 }).format(this.number.evaluate(t));
          }
          eachChild(t) {
            t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
        }
        class ka {
          constructor(t) {
            this.type = qn, this.sections = t;
          }
          static parse(t, n) {
            if (t.length < 2) return n.error("Expected at least one argument.");
            const u = t[1];
            if (!Array.isArray(u) && typeof u == "object") return n.error("First argument must be an image or text section.");
            const h = [];
            let _ = false;
            for (let b = 1; b <= t.length - 1; ++b) {
              const w = t[b];
              if (_ && typeof w == "object" && !Array.isArray(w)) {
                _ = false;
                let S = null;
                if (w["font-scale"] && (S = n.parse(w["font-scale"], 1, gt), !S)) return null;
                let I = null;
                if (w["text-font"] && (I = n.parse(w["text-font"], 1, rn(cr)), !I)) return null;
                let R = null;
                if (w["text-color"] && (R = n.parse(w["text-color"], 1, ni), !R)) return null;
                let B = null;
                if (w["vertical-align"]) {
                  if (typeof w["vertical-align"] == "string" && !Fl.includes(w["vertical-align"])) return n.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${w["vertical-align"]}' instead.`);
                  if (B = n.parse(w["vertical-align"], 1, cr), !B) return null;
                }
                const N = h[h.length - 1];
                N.scale = S, N.font = I, N.textColor = R, N.verticalAlign = B;
              } else {
                const S = n.parse(t[b], 1, dr);
                if (!S) return null;
                const I = S.type.kind;
                if (I !== "string" && I !== "value" && I !== "null" && I !== "resolvedImage") return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                _ = true, h.push({ content: S, scale: null, font: null, textColor: null, verticalAlign: null });
              }
            }
            return new ka(h);
          }
          evaluate(t) {
            return new pn(this.sections.map(((n) => {
              const u = n.content.evaluate(t);
              return nr(u) === Zr ? new Ll("", u, null, null, null, n.verticalAlign ? n.verticalAlign.evaluate(t) : null) : new Ll(mr(u), null, n.scale ? n.scale.evaluate(t) : null, n.font ? n.font.evaluate(t).join(",") : null, n.textColor ? n.textColor.evaluate(t) : null, n.verticalAlign ? n.verticalAlign.evaluate(t) : null);
            })));
          }
          eachChild(t) {
            for (const n of this.sections) t(n.content), n.scale && t(n.scale), n.font && t(n.font), n.textColor && t(n.textColor), n.verticalAlign && t(n.verticalAlign);
          }
          outputDefined() {
            return false;
          }
        }
        class yc {
          constructor(t) {
            this.type = Zr, this.input = t;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error("Expected two arguments.");
            const u = n.parse(t[1], 1, cr);
            return u ? new yc(u) : n.error("No image name provided.");
          }
          evaluate(t) {
            const n = this.input.evaluate(t), u = zn.fromString(n);
            return u && t.availableImages && (u.available = t.availableImages.indexOf(n) > -1), u;
          }
          eachChild(t) {
            t(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class Ul {
          constructor(t) {
            this.type = gt, this.input = t;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
            const u = n.parse(t[1], 1);
            return u ? u.type.kind !== "array" && u.type.kind !== "string" && u.type.kind !== "value" ? n.error(`Expected argument of type string or array, but found ${Ur(u.type)} instead.`) : new Ul(u) : null;
          }
          evaluate(t) {
            const n = this.input.evaluate(t);
            if (typeof n == "string") return [...n].length;
            if (Array.isArray(n)) return n.length;
            throw new Qr(`Expected value to be of type string or array, but found ${Ur(nr(n))} instead.`);
          }
          eachChild(t) {
            t(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        const to = 8192;
        function Sp(o, t) {
          const n = (180 + o[0]) / 360, u = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + o[1] * Math.PI / 360))) / 360, h = Math.pow(2, t.z);
          return [Math.round(n * h * to), Math.round(u * h * to)];
        }
        function ql(o, t) {
          const n = Math.pow(2, t.z);
          return [(h = (o[0] / to + t.x) / n, 360 * h - 180), (u = (o[1] / to + t.y) / n, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * u) * Math.PI / 180)) - 90)];
          var u, h;
        }
        function js(o, t) {
          o[0] = Math.min(o[0], t[0]), o[1] = Math.min(o[1], t[1]), o[2] = Math.max(o[2], t[0]), o[3] = Math.max(o[3], t[1]);
        }
        function Ns(o, t) {
          return !(o[0] <= t[0] || o[2] >= t[2] || o[1] <= t[1] || o[3] >= t[3]);
        }
        function kp(o, t, n) {
          const u = o[0] - t[0], h = o[1] - t[1], _ = o[0] - n[0], b = o[1] - n[1];
          return u * b - _ * h == 0 && u * _ <= 0 && h * b <= 0;
        }
        function Gl(o, t, n, u) {
          return (h = [u[0] - n[0], u[1] - n[1]])[0] * (_ = [t[0] - o[0], t[1] - o[1]])[1] - h[1] * _[0] != 0 && !(!ph(o, t, n, u) || !ph(n, u, o, t));
          var h, _;
        }
        function Pp(o, t, n) {
          for (const u of n) for (let h = 0; h < u.length - 1; ++h) if (Gl(o, t, u[h], u[h + 1])) return true;
          return false;
        }
        function Pa(o, t, n = false) {
          let u = false;
          for (const w of t) for (let S = 0; S < w.length - 1; S++) {
            if (kp(o, w[S], w[S + 1])) return n;
            (_ = w[S])[1] > (h = o)[1] != (b = w[S + 1])[1] > h[1] && h[0] < (b[0] - _[0]) * (h[1] - _[1]) / (b[1] - _[1]) + _[0] && (u = !u);
          }
          var h, _, b;
          return u;
        }
        function fh(o, t) {
          for (const n of t) if (Pa(o, n)) return true;
          return false;
        }
        function bc(o, t) {
          for (const n of o) if (!Pa(n, t)) return false;
          for (let n = 0; n < o.length - 1; ++n) if (Pp(o[n], o[n + 1], t)) return false;
          return true;
        }
        function Tp(o, t) {
          for (const n of t) if (bc(o, n)) return true;
          return false;
        }
        function ph(o, t, n, u) {
          const h = u[0] - n[0], _ = u[1] - n[1], b = (o[0] - n[0]) * _ - h * (o[1] - n[1]), w = (t[0] - n[0]) * _ - h * (t[1] - n[1]);
          return b > 0 && w < 0 || b < 0 && w > 0;
        }
        function xc(o, t, n) {
          const u = [];
          for (let h = 0; h < o.length; h++) {
            const _ = [];
            for (let b = 0; b < o[h].length; b++) {
              const w = Sp(o[h][b], n);
              js(t, w), _.push(w);
            }
            u.push(_);
          }
          return u;
        }
        function mh(o, t, n) {
          const u = [];
          for (let h = 0; h < o.length; h++) {
            const _ = xc(o[h], t, n);
            u.push(_);
          }
          return u;
        }
        function Wl(o, t, n, u) {
          if (o[0] < n[0] || o[0] > n[2]) {
            const h = 0.5 * u;
            let _ = o[0] - n[0] > h ? -u : n[0] - o[0] > h ? u : 0;
            _ === 0 && (_ = o[0] - n[2] > h ? -u : n[2] - o[0] > h ? u : 0), o[0] += _;
          }
          js(t, o);
        }
        function gh(o, t, n, u) {
          const h = Math.pow(2, u.z) * to, _ = [u.x * to, u.y * to], b = [];
          for (const w of o) for (const S of w) {
            const I = [S.x + _[0], S.y + _[1]];
            Wl(I, t, n, h), b.push(I);
          }
          return b;
        }
        function vh(o, t, n, u) {
          const h = Math.pow(2, u.z) * to, _ = [u.x * to, u.y * to], b = [];
          for (const S of o) {
            const I = [];
            for (const R of S) {
              const B = [R.x + _[0], R.y + _[1]];
              js(t, B), I.push(B);
            }
            b.push(I);
          }
          if (t[2] - t[0] <= h / 2) {
            (w = t)[0] = w[1] = 1 / 0, w[2] = w[3] = -1 / 0;
            for (const S of b) for (const I of S) Wl(I, t, n, h);
          }
          var w;
          return b;
        }
        class Ta {
          constructor(t, n) {
            this.type = lr, this.geojson = t, this.geometries = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (Ca(t[1])) {
              const u = t[1];
              if (u.type === "FeatureCollection") {
                const h = [];
                for (const _ of u.features) {
                  const { type: b, coordinates: w } = _.geometry;
                  b === "Polygon" && h.push(w), b === "MultiPolygon" && h.push(...w);
                }
                if (h.length) return new Ta(u, { type: "MultiPolygon", coordinates: h });
              } else if (u.type === "Feature") {
                const h = u.geometry.type;
                if (h === "Polygon" || h === "MultiPolygon") return new Ta(u, u.geometry);
              } else if (u.type === "Polygon" || u.type === "MultiPolygon") return new Ta(u, u);
            }
            return n.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(n, u) {
                const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0], _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], b = n.canonicalID();
                if (u.type === "Polygon") {
                  const w = xc(u.coordinates, _, b), S = gh(n.geometry(), h, _, b);
                  if (!Ns(h, _)) return false;
                  for (const I of S) if (!Pa(I, w)) return false;
                }
                if (u.type === "MultiPolygon") {
                  const w = mh(u.coordinates, _, b), S = gh(n.geometry(), h, _, b);
                  if (!Ns(h, _)) return false;
                  for (const I of S) if (!fh(I, w)) return false;
                }
                return true;
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(n, u) {
                const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0], _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], b = n.canonicalID();
                if (u.type === "Polygon") {
                  const w = xc(u.coordinates, _, b), S = vh(n.geometry(), h, _, b);
                  if (!Ns(h, _)) return false;
                  for (const I of S) if (!bc(I, w)) return false;
                }
                if (u.type === "MultiPolygon") {
                  const w = mh(u.coordinates, _, b), S = vh(n.geometry(), h, _, b);
                  if (!Ns(h, _)) return false;
                  for (const I of S) if (!Tp(I, w)) return false;
                }
                return true;
              })(t, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        let wc = class {
          constructor(o = [], t = (n, u) => n < u ? -1 : n > u ? 1 : 0) {
            if (this.data = o, this.length = this.data.length, this.compare = t, this.length > 0) for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
          }
          push(o) {
            this.data.push(o), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const o = this.data[0], t = this.data.pop();
            return --this.length > 0 && (this.data[0] = t, this._down(0)), o;
          }
          peek() {
            return this.data[0];
          }
          _up(o) {
            const { data: t, compare: n } = this, u = t[o];
            for (; o > 0; ) {
              const h = o - 1 >> 1, _ = t[h];
              if (n(u, _) >= 0) break;
              t[o] = _, o = h;
            }
            t[o] = u;
          }
          _down(o) {
            const { data: t, compare: n } = this, u = this.length >> 1, h = t[o];
            for (; o < u; ) {
              let _ = 1 + (o << 1);
              const b = _ + 1;
              if (b < this.length && n(t[b], t[_]) < 0 && (_ = b), n(t[_], h) >= 0) break;
              t[o] = t[_], o = _;
            }
            t[o] = h;
          }
        };
        function Cc(o, t, n = 0, u = o.length - 1, h = Ip) {
          for (; u > n; ) {
            if (u - n > 600) {
              const S = u - n + 1, I = t - n + 1, R = Math.log(S), B = 0.5 * Math.exp(2 * R / 3), N = 0.5 * Math.sqrt(R * B * (S - B) / S) * (I - S / 2 < 0 ? -1 : 1);
              Cc(o, t, Math.max(n, Math.floor(t - I * B / S + N)), Math.min(u, Math.floor(t + (S - I) * B / S + N)), h);
            }
            const _ = o[t];
            let b = n, w = u;
            for (Vs(o, n, t), h(o[u], _) > 0 && Vs(o, n, u); b < w; ) {
              for (Vs(o, b, w), b++, w--; h(o[b], _) < 0; ) b++;
              for (; h(o[w], _) > 0; ) w--;
            }
            h(o[n], _) === 0 ? Vs(o, n, w) : (w++, Vs(o, w, u)), w <= t && (n = w + 1), t <= w && (u = w - 1);
          }
        }
        function Vs(o, t, n) {
          const u = o[t];
          o[t] = o[n], o[n] = u;
        }
        function Ip(o, t) {
          return o < t ? -1 : o > t ? 1 : 0;
        }
        function Us(o, t) {
          if (o.length <= 1) return [o];
          const n = [];
          let u, h;
          for (const _ of o) {
            const b = Mp(_);
            b !== 0 && (_.area = Math.abs(b), h === void 0 && (h = b < 0), h === b < 0 ? (u && n.push(u), u = [_]) : u.push(_));
          }
          if (u && n.push(u), t > 1) for (let _ = 0; _ < n.length; _++) n[_].length <= t || (Cc(n[_], t, 1, n[_].length - 1, _h), n[_] = n[_].slice(0, t));
          return n;
        }
        function _h(o, t) {
          return t.area - o.area;
        }
        function Mp(o) {
          let t = 0;
          for (let n, u, h = 0, _ = o.length, b = _ - 1; h < _; b = h++) n = o[h], u = o[b], t += (u.x - n.x) * (n.y + u.y);
          return t;
        }
        const yh = 1 / 298.257223563, bh = yh * (2 - yh), Sc = Math.PI / 180;
        class kc {
          constructor(t) {
            const n = 6378.137 * Sc * 1e3, u = Math.cos(t * Sc), h = 1 / (1 - bh * (1 - u * u)), _ = Math.sqrt(h);
            this.kx = n * _ * u, this.ky = n * _ * h * (1 - bh);
          }
          distance(t, n) {
            const u = this.wrap(t[0] - n[0]) * this.kx, h = (t[1] - n[1]) * this.ky;
            return Math.sqrt(u * u + h * h);
          }
          pointOnLine(t, n) {
            let u, h, _, b, w = 1 / 0;
            for (let S = 0; S < t.length - 1; S++) {
              let I = t[S][0], R = t[S][1], B = this.wrap(t[S + 1][0] - I) * this.kx, N = (t[S + 1][1] - R) * this.ky, q = 0;
              B === 0 && N === 0 || (q = (this.wrap(n[0] - I) * this.kx * B + (n[1] - R) * this.ky * N) / (B * B + N * N), q > 1 ? (I = t[S + 1][0], R = t[S + 1][1]) : q > 0 && (I += B / this.kx * q, R += N / this.ky * q)), B = this.wrap(n[0] - I) * this.kx, N = (n[1] - R) * this.ky;
              const G = B * B + N * N;
              G < w && (w = G, u = I, h = R, _ = S, b = q);
            }
            return { point: [u, h], index: _, t: Math.max(0, Math.min(1, b)) };
          }
          wrap(t) {
            for (; t < -180; ) t += 360;
            for (; t > 180; ) t -= 360;
            return t;
          }
        }
        function xh(o, t) {
          return t[0] - o[0];
        }
        function Zl(o) {
          return o[1] - o[0] + 1;
        }
        function Fo(o, t) {
          return o[1] >= o[0] && o[1] < t;
        }
        function Fr(o, t) {
          if (o[0] > o[1]) return [null, null];
          const n = Zl(o);
          if (t) {
            if (n === 2) return [o, null];
            const h = Math.floor(n / 2);
            return [[o[0], o[0] + h], [o[0] + h, o[1]]];
          }
          if (n === 1) return [o, null];
          const u = Math.floor(n / 2) - 1;
          return [[o[0], o[0] + u], [o[0] + u + 1, o[1]]];
        }
        function Pc(o, t) {
          if (!Fo(t, o.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let u = t[0]; u <= t[1]; ++u) js(n, o[u]);
          return n;
        }
        function Tc(o) {
          const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const n of o) for (const u of n) js(t, u);
          return t;
        }
        function wh(o) {
          return o[0] !== -1 / 0 && o[1] !== -1 / 0 && o[2] !== 1 / 0 && o[3] !== 1 / 0;
        }
        function Ic(o, t, n) {
          if (!wh(o) || !wh(t)) return NaN;
          let u = 0, h = 0;
          return o[2] < t[0] && (u = t[0] - o[2]), o[0] > t[2] && (u = o[0] - t[2]), o[1] > t[3] && (h = o[1] - t[3]), o[3] < t[1] && (h = t[1] - o[3]), n.distance([0, 0], [u, h]);
        }
        function Ia(o, t, n) {
          const u = n.pointOnLine(t, o);
          return n.distance(o, u.point);
        }
        function Mc(o, t, n, u, h) {
          const _ = Math.min(Ia(o, [n, u], h), Ia(t, [n, u], h)), b = Math.min(Ia(n, [o, t], h), Ia(u, [o, t], h));
          return Math.min(_, b);
        }
        function Ep(o, t, n, u, h) {
          if (!Fo(t, o.length) || !Fo(u, n.length)) return 1 / 0;
          let _ = 1 / 0;
          for (let b = t[0]; b < t[1]; ++b) {
            const w = o[b], S = o[b + 1];
            for (let I = u[0]; I < u[1]; ++I) {
              const R = n[I], B = n[I + 1];
              if (Gl(w, S, R, B)) return 0;
              _ = Math.min(_, Mc(w, S, R, B, h));
            }
          }
          return _;
        }
        function Rp(o, t, n, u, h) {
          if (!Fo(t, o.length) || !Fo(u, n.length)) return NaN;
          let _ = 1 / 0;
          for (let b = t[0]; b <= t[1]; ++b) for (let w = u[0]; w <= u[1]; ++w) if (_ = Math.min(_, h.distance(o[b], n[w])), _ === 0) return _;
          return _;
        }
        function Ap(o, t, n) {
          if (Pa(o, t, true)) return 0;
          let u = 1 / 0;
          for (const h of t) {
            const _ = h[0], b = h[h.length - 1];
            if (_ !== b && (u = Math.min(u, Ia(o, [b, _], n)), u === 0)) return u;
            const w = n.pointOnLine(h, o);
            if (u = Math.min(u, n.distance(o, w.point)), u === 0) return u;
          }
          return u;
        }
        function Dp(o, t, n, u) {
          if (!Fo(t, o.length)) return NaN;
          for (let _ = t[0]; _ <= t[1]; ++_) if (Pa(o[_], n, true)) return 0;
          let h = 1 / 0;
          for (let _ = t[0]; _ < t[1]; ++_) {
            const b = o[_], w = o[_ + 1];
            for (const S of n) for (let I = 0, R = S.length, B = R - 1; I < R; B = I++) {
              const N = S[B], q = S[I];
              if (Gl(b, w, N, q)) return 0;
              h = Math.min(h, Mc(b, w, N, q, u));
            }
          }
          return h;
        }
        function Ch(o, t) {
          for (const n of o) for (const u of n) if (Pa(u, t, true)) return true;
          return false;
        }
        function zp(o, t, n, u = 1 / 0) {
          const h = Tc(o), _ = Tc(t);
          if (u !== 1 / 0 && Ic(h, _, n) >= u) return u;
          if (Ns(h, _)) {
            if (Ch(o, t)) return 0;
          } else if (Ch(t, o)) return 0;
          let b = 1 / 0;
          for (const w of o) for (let S = 0, I = w.length, R = I - 1; S < I; R = S++) {
            const B = w[R], N = w[S];
            for (const q of t) for (let G = 0, Q = q.length, ae = Q - 1; G < Q; ae = G++) {
              const pe = q[ae], Oe = q[G];
              if (Gl(B, N, pe, Oe)) return 0;
              b = Math.min(b, Mc(B, N, pe, Oe, n));
            }
          }
          return b;
        }
        function Sh(o, t, n, u, h, _) {
          if (!_) return;
          const b = Ic(Pc(u, _), h, n);
          b < t && o.push([b, _, [0, 0]]);
        }
        function Hl(o, t, n, u, h, _, b) {
          if (!_ || !b) return;
          const w = Ic(Pc(u, _), Pc(h, b), n);
          w < t && o.push([w, _, b]);
        }
        function Xl(o, t, n, u, h = 1 / 0) {
          let _ = Math.min(u.distance(o[0], n[0][0]), h);
          if (_ === 0) return _;
          const b = new wc([[0, [0, o.length - 1], [0, 0]]], xh), w = Tc(n);
          for (; b.length > 0; ) {
            const S = b.pop();
            if (S[0] >= _) continue;
            const I = S[1], R = t ? 50 : 100;
            if (Zl(I) <= R) {
              if (!Fo(I, o.length)) return NaN;
              if (t) {
                const B = Dp(o, I, n, u);
                if (isNaN(B) || B === 0) return B;
                _ = Math.min(_, B);
              } else for (let B = I[0]; B <= I[1]; ++B) {
                const N = Ap(o[B], n, u);
                if (_ = Math.min(_, N), _ === 0) return 0;
              }
            } else {
              const B = Fr(I, t);
              Sh(b, _, u, o, w, B[0]), Sh(b, _, u, o, w, B[1]);
            }
          }
          return _;
        }
        function Yl(o, t, n, u, h, _ = 1 / 0) {
          let b = Math.min(_, h.distance(o[0], n[0]));
          if (b === 0) return b;
          const w = new wc([[0, [0, o.length - 1], [0, n.length - 1]]], xh);
          for (; w.length > 0; ) {
            const S = w.pop();
            if (S[0] >= b) continue;
            const I = S[1], R = S[2], B = t ? 50 : 100, N = u ? 50 : 100;
            if (Zl(I) <= B && Zl(R) <= N) {
              if (!Fo(I, o.length) && Fo(R, n.length)) return NaN;
              let q;
              if (t && u) q = Ep(o, I, n, R, h), b = Math.min(b, q);
              else if (t && !u) {
                const G = o.slice(I[0], I[1] + 1);
                for (let Q = R[0]; Q <= R[1]; ++Q) if (q = Ia(n[Q], G, h), b = Math.min(b, q), b === 0) return b;
              } else if (!t && u) {
                const G = n.slice(R[0], R[1] + 1);
                for (let Q = I[0]; Q <= I[1]; ++Q) if (q = Ia(o[Q], G, h), b = Math.min(b, q), b === 0) return b;
              } else q = Rp(o, I, n, R, h), b = Math.min(b, q);
            } else {
              const q = Fr(I, t), G = Fr(R, u);
              Hl(w, b, h, o, n, q[0], G[0]), Hl(w, b, h, o, n, q[0], G[1]), Hl(w, b, h, o, n, q[1], G[0]), Hl(w, b, h, o, n, q[1], G[1]);
            }
          }
          return b;
        }
        function Ec(o) {
          return o.type === "MultiPolygon" ? o.coordinates.map(((t) => ({ type: "Polygon", coordinates: t }))) : o.type === "MultiLineString" ? o.coordinates.map(((t) => ({ type: "LineString", coordinates: t }))) : o.type === "MultiPoint" ? o.coordinates.map(((t) => ({ type: "Point", coordinates: t }))) : [o];
        }
        class Ma {
          constructor(t, n) {
            this.type = gt, this.geojson = t, this.geometries = n;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`'distance' expression requires exactly one argument, but found ${t.length - 1} instead.`);
            if (Ca(t[1])) {
              const u = t[1];
              if (u.type === "FeatureCollection") return new Ma(u, u.features.map(((h) => Ec(h.geometry))).flat());
              if (u.type === "Feature") return new Ma(u, Ec(u.geometry));
              if ("type" in u && "coordinates" in u) return new Ma(u, Ec(u));
            }
            return n.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t) {
            if (t.geometry() != null && t.canonicalID() != null) {
              if (t.geometryType() === "Point") return (function(n, u) {
                const h = n.geometry(), _ = h.flat().map(((S) => ql([S.x, S.y], n.canonical)));
                if (h.length === 0) return NaN;
                const b = new kc(_[0][1]);
                let w = 1 / 0;
                for (const S of u) {
                  switch (S.type) {
                    case "Point":
                      w = Math.min(w, Yl(_, false, [S.coordinates], false, b, w));
                      break;
                    case "LineString":
                      w = Math.min(w, Yl(_, false, S.coordinates, true, b, w));
                      break;
                    case "Polygon":
                      w = Math.min(w, Xl(_, false, S.coordinates, b, w));
                  }
                  if (w === 0) return w;
                }
                return w;
              })(t, this.geometries);
              if (t.geometryType() === "LineString") return (function(n, u) {
                const h = n.geometry(), _ = h.flat().map(((S) => ql([S.x, S.y], n.canonical)));
                if (h.length === 0) return NaN;
                const b = new kc(_[0][1]);
                let w = 1 / 0;
                for (const S of u) {
                  switch (S.type) {
                    case "Point":
                      w = Math.min(w, Yl(_, true, [S.coordinates], false, b, w));
                      break;
                    case "LineString":
                      w = Math.min(w, Yl(_, true, S.coordinates, true, b, w));
                      break;
                    case "Polygon":
                      w = Math.min(w, Xl(_, true, S.coordinates, b, w));
                  }
                  if (w === 0) return w;
                }
                return w;
              })(t, this.geometries);
              if (t.geometryType() === "Polygon") return (function(n, u) {
                const h = n.geometry();
                if (h.length === 0 || h[0].length === 0) return NaN;
                const _ = Us(h, 0).map(((S) => S.map(((I) => I.map(((R) => ql([R.x, R.y], n.canonical))))))), b = new kc(_[0][0][0][1]);
                let w = 1 / 0;
                for (const S of u) for (const I of _) {
                  switch (S.type) {
                    case "Point":
                      w = Math.min(w, Xl([S.coordinates], false, I, b, w));
                      break;
                    case "LineString":
                      w = Math.min(w, Xl(S.coordinates, true, I, b, w));
                      break;
                    case "Polygon":
                      w = Math.min(w, zp(I, S.coordinates, b, w));
                  }
                  if (w === 0) return w;
                }
                return w;
              })(t, this.geometries);
            }
            return NaN;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        class qs {
          constructor(t) {
            this.type = dr, this.key = t;
          }
          static parse(t, n) {
            if (t.length !== 2) return n.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
            const u = t[1];
            return u == null ? n.error("Global state property must be defined.") : typeof u != "string" ? n.error(`Global state property must be string, but found ${typeof t[1]} instead.`) : new qs(u);
          }
          evaluate(t) {
            var n;
            const u = (n = t.globals) === null || n === void 0 ? void 0 : n.globalState;
            return u && Object.keys(u).length !== 0 ? ta(u, this.key) : null;
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
        }
        const is = { "==": hh, "!=": Nl, ">": vc, "<": xp, ">=": Cp, "<=": wp, array: Fn, at: $l, boolean: Fn, case: ts, coalesce: Bs, collator: Vl, format: ka, image: yc, in: jl, "index-of": eo, interpolate: Hi, "interpolate-hcl": Hi, "interpolate-lab": Hi, length: Ul, let: Ds, literal: zo, match: Ni, number: Fn, "number-format": _c, object: Fn, slice: zs, step: xi, string: Fn, "to-boolean": wo, "to-color": wo, "to-number": wo, "to-string": wo, var: Ol, within: Ta, distance: Ma, "global-state": qs };
        class Gn {
          constructor(t, n, u, h) {
            this.name = t, this.type = n, this._evaluate = u, this.args = h;
          }
          evaluate(t) {
            return this._evaluate(t, this.args);
          }
          eachChild(t) {
            this.args.forEach(t);
          }
          outputDefined() {
            return false;
          }
          static parse(t, n) {
            const u = t[0], h = Gn.definitions[u];
            if (!h) return n.error(`Unknown expression "${u}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const _ = Array.isArray(h) ? h[0] : h.type, b = Array.isArray(h) ? [[h[1], h[2]]] : h.overloads, w = b.filter((([I]) => !Array.isArray(I) || I.length === t.length - 1));
            let S = null;
            for (const [I, R] of w) {
              S = new es(n.registry, Kl, n.path, null, n.scope);
              const B = [];
              let N = false;
              for (let q = 1; q < t.length; q++) {
                const G = t[q], Q = Array.isArray(I) ? I[q - 1] : I.type, ae = S.parse(G, 1 + B.length, Q);
                if (!ae) {
                  N = true;
                  break;
                }
                B.push(ae);
              }
              if (!N) if (Array.isArray(I) && I.length !== B.length) S.error(`Expected ${I.length} arguments, but found ${B.length} instead.`);
              else {
                for (let q = 0; q < B.length; q++) {
                  const G = Array.isArray(I) ? I[q] : I.type, Q = B[q];
                  S.concat(q + 1).checkSubtype(G, Q.type);
                }
                if (S.errors.length === 0) return new Gn(u, _, R, B);
              }
            }
            if (w.length === 1) n.errors.push(...S.errors);
            else {
              const I = (w.length ? w : b).map((([B]) => {
                return N = B, Array.isArray(N) ? `(${N.map(Ur).join(", ")})` : `(${Ur(N.type)}...)`;
                var N;
              })).join(" | "), R = [];
              for (let B = 1; B < t.length; B++) {
                const N = n.parse(t[B], 1 + R.length);
                if (!N) return null;
                R.push(Ur(N.type));
              }
              n.error(`Expected arguments of type ${I}, but found (${R.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t, n) {
            Gn.definitions = n;
            for (const u in n) t[u] = Gn;
          }
        }
        function kh(o, [t, n, u, h]) {
          t = t.evaluate(o), n = n.evaluate(o), u = u.evaluate(o);
          const _ = h ? h.evaluate(o) : 1, b = li(t, n, u, _);
          if (b) throw new Qr(b);
          return new br(t / 255, n / 255, u / 255, _, false);
        }
        function Ph(o, t) {
          return o in t;
        }
        function Rc(o, t) {
          const n = t[o];
          return n === void 0 ? null : n;
        }
        function Ea(o) {
          return { type: o };
        }
        function Kl(o) {
          if (o instanceof Ol) return Kl(o.boundExpression);
          if (o instanceof Gn && o.name === "error" || o instanceof Vl || o instanceof Ta || o instanceof Ma || o instanceof qs) return false;
          const t = o instanceof wo || o instanceof Fn;
          let n = true;
          return o.eachChild(((u) => {
            n = t ? n && Kl(u) : n && u instanceof zo;
          })), !!n && Jl(o) && Ql(o, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]);
        }
        function Jl(o) {
          if (o instanceof Gn && (o.name === "get" && o.args.length === 1 || o.name === "feature-state" || o.name === "has" && o.args.length === 1 || o.name === "properties" || o.name === "geometry-type" || o.name === "id" || /^filter-/.test(o.name)) || o instanceof Ta || o instanceof Ma) return false;
          let t = true;
          return o.eachChild(((n) => {
            t && !Jl(n) && (t = false);
          })), t;
        }
        function Gs(o) {
          if (o instanceof Gn && o.name === "feature-state") return false;
          let t = true;
          return o.eachChild(((n) => {
            t && !Gs(n) && (t = false);
          })), t;
        }
        function Ql(o, t) {
          if (o instanceof Gn && t.indexOf(o.name) >= 0) return false;
          let n = true;
          return o.eachChild(((u) => {
            n && !Ql(u, t) && (n = false);
          })), n;
        }
        function Th(o) {
          return { result: "success", value: o };
        }
        function ns(o) {
          return { result: "error", value: o };
        }
        function ra(o) {
          return o["property-type"] === "data-driven" || o["property-type"] === "cross-faded-data-driven";
        }
        function Ih(o) {
          return !!o.expression && o.expression.parameters.indexOf("zoom") > -1;
        }
        function Ac(o) {
          return !!o.expression && o.expression.interpolated;
        }
        function Sr(o) {
          return o instanceof Number ? "number" : o instanceof String ? "string" : o instanceof Boolean ? "boolean" : Array.isArray(o) ? "array" : o === null ? "null" : typeof o;
        }
        function Ws(o) {
          return typeof o == "object" && o !== null && !Array.isArray(o) && nr(o) === tn;
        }
        function Fp(o) {
          return o;
        }
        function Mh(o, t) {
          const n = o.stops && typeof o.stops[0][0] == "object", u = n || !(n || o.property !== void 0), h = o.type || (Ac(t) ? "exponential" : "interval"), _ = (function(R) {
            switch (R.type) {
              case "color":
                return br.parse;
              case "padding":
                return ji.parse;
              case "numberArray":
                return mn.parse;
              case "colorArray":
                return Mi.parse;
              default:
                return null;
            }
          })(t);
          if (_ && ((o = dt({}, o)).stops && (o.stops = o.stops.map(((R) => [R[0], _(R[1])]))), o.default = _(o.default ? o.default : t.default)), o.colorSpace && (b = o.colorSpace) !== "rgb" && b !== "hcl" && b !== "lab") throw new Error(`Unknown color space: "${o.colorSpace}"`);
          var b;
          const w = (function(R) {
            switch (R) {
              case "exponential":
                return Rh;
              case "interval":
                return Lp;
              case "categorical":
                return Eh;
              case "identity":
                return Bp;
              default:
                throw new Error(`Unknown function type "${R}"`);
            }
          })(h);
          let S, I;
          if (h === "categorical") {
            S = /* @__PURE__ */ Object.create(null);
            for (const R of o.stops) S[R[0]] = R[1];
            I = typeof o.stops[0][0];
          }
          if (n) {
            const R = {}, B = [];
            for (let G = 0; G < o.stops.length; G++) {
              const Q = o.stops[G], ae = Q[0].zoom;
              R[ae] === void 0 && (R[ae] = { zoom: ae, type: o.type, property: o.property, default: o.default, stops: [] }, B.push(ae)), R[ae].stops.push([Q[0].value, Q[1]]);
            }
            const N = [];
            for (const G of B) N.push([R[G].zoom, Mh(R[G], t)]);
            const q = { name: "linear" };
            return { kind: "composite", interpolationType: q, interpolationFactor: Hi.interpolationFactor.bind(void 0, q), zoomStops: N.map(((G) => G[0])), evaluate: ({ zoom: G }, Q) => Rh({ stops: N, base: o.base }, t, G).evaluate(G, Q) };
          }
          if (u) {
            const R = h === "exponential" ? { name: "exponential", base: o.base !== void 0 ? o.base : 1 } : null;
            return { kind: "camera", interpolationType: R, interpolationFactor: Hi.interpolationFactor.bind(void 0, R), zoomStops: o.stops.map(((B) => B[0])), evaluate: ({ zoom: B }) => w(o, t, B, S, I) };
          }
          return { kind: "source", evaluate(R, B) {
            const N = B && B.properties ? B.properties[o.property] : void 0;
            return N === void 0 ? ia(o.default, t.default) : w(o, t, N, S, I);
          } };
        }
        function ia(o, t, n) {
          return o !== void 0 ? o : t !== void 0 ? t : n !== void 0 ? n : void 0;
        }
        function Eh(o, t, n, u, h) {
          return ia(typeof n === h ? u[n] : void 0, o.default, t.default);
        }
        function Lp(o, t, n) {
          if (Sr(n) !== "number") return ia(o.default, t.default);
          const u = o.stops.length;
          if (u === 1 || n <= o.stops[0][0]) return o.stops[0][1];
          if (n >= o.stops[u - 1][0]) return o.stops[u - 1][1];
          const h = Sa(o.stops.map(((_) => _[0])), n);
          return o.stops[h][1];
        }
        function Rh(o, t, n) {
          const u = o.base !== void 0 ? o.base : 1;
          if (Sr(n) !== "number") return ia(o.default, t.default);
          const h = o.stops.length;
          if (h === 1 || n <= o.stops[0][0]) return o.stops[0][1];
          if (n >= o.stops[h - 1][0]) return o.stops[h - 1][1];
          const _ = Sa(o.stops.map(((R) => R[0])), n), b = (function(R, B, N, q) {
            const G = q - N, Q = R - N;
            return G === 0 ? 0 : B === 1 ? Q / G : (Math.pow(B, Q) - 1) / (Math.pow(B, G) - 1);
          })(n, u, o.stops[_][0], o.stops[_ + 1][0]), w = o.stops[_][1], S = o.stops[_ + 1][1], I = Co[t.type] || Fp;
          return typeof w.evaluate == "function" ? { evaluate(...R) {
            const B = w.evaluate.apply(void 0, R), N = S.evaluate.apply(void 0, R);
            if (B !== void 0 && N !== void 0) return I(B, N, b, o.colorSpace);
          } } : I(w, S, b, o.colorSpace);
        }
        function Bp(o, t, n) {
          switch (t.type) {
            case "color":
              n = br.parse(n);
              break;
            case "formatted":
              n = pn.fromString(n.toString());
              break;
            case "resolvedImage":
              n = zn.fromString(n.toString());
              break;
            case "padding":
              n = ji.parse(n);
              break;
            case "colorArray":
              n = Mi.parse(n);
              break;
            case "numberArray":
              n = mn.parse(n);
              break;
            default:
              Sr(n) === t.type || t.type === "enum" && t.values[n] || (n = void 0);
          }
          return ia(n, o.default, t.default);
        }
        Gn.register(is, { error: [{ kind: "error" }, [cr], (o, [t]) => {
          throw new Qr(t.evaluate(o));
        }], typeof: [cr, [dr], (o, [t]) => Ur(nr(t.evaluate(o)))], "to-rgba": [rn(gt, 4), [ni], (o, [t]) => {
          const [n, u, h, _] = t.evaluate(o).rgb;
          return [255 * n, 255 * u, 255 * h, _];
        }], rgb: [ni, [gt, gt, gt], kh], rgba: [ni, [gt, gt, gt, gt], kh], has: { type: lr, overloads: [[[cr], (o, [t]) => Ph(t.evaluate(o), o.properties())], [[cr, tn], (o, [t, n]) => Ph(t.evaluate(o), n.evaluate(o))]] }, get: { type: dr, overloads: [[[cr], (o, [t]) => Rc(t.evaluate(o), o.properties())], [[cr, tn], (o, [t, n]) => Rc(t.evaluate(o), n.evaluate(o))]] }, "feature-state": [dr, [cr], (o, [t]) => Rc(t.evaluate(o), o.featureState || {})], properties: [tn, [], (o) => o.properties()], "geometry-type": [cr, [], (o) => o.geometryType()], id: [dr, [], (o) => o.id()], zoom: [gt, [], (o) => o.globals.zoom], "heatmap-density": [gt, [], (o) => o.globals.heatmapDensity || 0], elevation: [gt, [], (o) => o.globals.elevation || 0], "line-progress": [gt, [], (o) => o.globals.lineProgress || 0], accumulated: [dr, [], (o) => o.globals.accumulated === void 0 ? null : o.globals.accumulated], "+": [gt, Ea(gt), (o, t) => {
          let n = 0;
          for (const u of t) n += u.evaluate(o);
          return n;
        }], "*": [gt, Ea(gt), (o, t) => {
          let n = 1;
          for (const u of t) n *= u.evaluate(o);
          return n;
        }], "-": { type: gt, overloads: [[[gt, gt], (o, [t, n]) => t.evaluate(o) - n.evaluate(o)], [[gt], (o, [t]) => -t.evaluate(o)]] }, "/": [gt, [gt, gt], (o, [t, n]) => t.evaluate(o) / n.evaluate(o)], "%": [gt, [gt, gt], (o, [t, n]) => t.evaluate(o) % n.evaluate(o)], ln2: [gt, [], () => Math.LN2], pi: [gt, [], () => Math.PI], e: [gt, [], () => Math.E], "^": [gt, [gt, gt], (o, [t, n]) => Math.pow(t.evaluate(o), n.evaluate(o))], sqrt: [gt, [gt], (o, [t]) => Math.sqrt(t.evaluate(o))], log10: [gt, [gt], (o, [t]) => Math.log(t.evaluate(o)) / Math.LN10], ln: [gt, [gt], (o, [t]) => Math.log(t.evaluate(o))], log2: [gt, [gt], (o, [t]) => Math.log(t.evaluate(o)) / Math.LN2], sin: [gt, [gt], (o, [t]) => Math.sin(t.evaluate(o))], cos: [gt, [gt], (o, [t]) => Math.cos(t.evaluate(o))], tan: [gt, [gt], (o, [t]) => Math.tan(t.evaluate(o))], asin: [gt, [gt], (o, [t]) => Math.asin(t.evaluate(o))], acos: [gt, [gt], (o, [t]) => Math.acos(t.evaluate(o))], atan: [gt, [gt], (o, [t]) => Math.atan(t.evaluate(o))], min: [gt, Ea(gt), (o, t) => Math.min(...t.map(((n) => n.evaluate(o))))], max: [gt, Ea(gt), (o, t) => Math.max(...t.map(((n) => n.evaluate(o))))], abs: [gt, [gt], (o, [t]) => Math.abs(t.evaluate(o))], round: [gt, [gt], (o, [t]) => {
          const n = t.evaluate(o);
          return n < 0 ? -Math.round(-n) : Math.round(n);
        }], floor: [gt, [gt], (o, [t]) => Math.floor(t.evaluate(o))], ceil: [gt, [gt], (o, [t]) => Math.ceil(t.evaluate(o))], "filter-==": [lr, [cr, dr], (o, [t, n]) => o.properties()[t.value] === n.value], "filter-id-==": [lr, [dr], (o, [t]) => o.id() === t.value], "filter-type-==": [lr, [cr], (o, [t]) => o.geometryType() === t.value], "filter-<": [lr, [cr, dr], (o, [t, n]) => {
          const u = o.properties()[t.value], h = n.value;
          return typeof u == typeof h && u < h;
        }], "filter-id-<": [lr, [dr], (o, [t]) => {
          const n = o.id(), u = t.value;
          return typeof n == typeof u && n < u;
        }], "filter->": [lr, [cr, dr], (o, [t, n]) => {
          const u = o.properties()[t.value], h = n.value;
          return typeof u == typeof h && u > h;
        }], "filter-id->": [lr, [dr], (o, [t]) => {
          const n = o.id(), u = t.value;
          return typeof n == typeof u && n > u;
        }], "filter-<=": [lr, [cr, dr], (o, [t, n]) => {
          const u = o.properties()[t.value], h = n.value;
          return typeof u == typeof h && u <= h;
        }], "filter-id-<=": [lr, [dr], (o, [t]) => {
          const n = o.id(), u = t.value;
          return typeof n == typeof u && n <= u;
        }], "filter->=": [lr, [cr, dr], (o, [t, n]) => {
          const u = o.properties()[t.value], h = n.value;
          return typeof u == typeof h && u >= h;
        }], "filter-id->=": [lr, [dr], (o, [t]) => {
          const n = o.id(), u = t.value;
          return typeof n == typeof u && n >= u;
        }], "filter-has": [lr, [dr], (o, [t]) => t.value in o.properties()], "filter-has-id": [lr, [], (o) => o.id() !== null && o.id() !== void 0], "filter-type-in": [lr, [rn(cr)], (o, [t]) => t.value.indexOf(o.geometryType()) >= 0], "filter-id-in": [lr, [rn(dr)], (o, [t]) => t.value.indexOf(o.id()) >= 0], "filter-in-small": [lr, [cr, rn(dr)], (o, [t, n]) => n.value.indexOf(o.properties()[t.value]) >= 0], "filter-in-large": [lr, [cr, rn(dr)], (o, [t, n]) => (function(u, h, _, b) {
          for (; _ <= b; ) {
            const w = _ + b >> 1;
            if (h[w] === u) return true;
            h[w] > u ? b = w - 1 : _ = w + 1;
          }
          return false;
        })(o.properties()[t.value], n.value, 0, n.value.length - 1)], all: { type: lr, overloads: [[[lr, lr], (o, [t, n]) => t.evaluate(o) && n.evaluate(o)], [Ea(lr), (o, t) => {
          for (const n of t) if (!n.evaluate(o)) return false;
          return true;
        }]] }, any: { type: lr, overloads: [[[lr, lr], (o, [t, n]) => t.evaluate(o) || n.evaluate(o)], [Ea(lr), (o, t) => {
          for (const n of t) if (n.evaluate(o)) return true;
          return false;
        }]] }, "!": [lr, [lr], (o, [t]) => !t.evaluate(o)], "is-supported-script": [lr, [cr], (o, [t]) => {
          const n = o.globals && o.globals.isSupportedScript;
          return !n || n(t.evaluate(o));
        }], upcase: [cr, [cr], (o, [t]) => t.evaluate(o).toUpperCase()], downcase: [cr, [cr], (o, [t]) => t.evaluate(o).toLowerCase()], concat: [cr, Ea(dr), (o, t) => t.map(((n) => mr(n.evaluate(o)))).join("")], "resolved-locale": [cr, [Yo], (o, [t]) => t.evaluate(o).resolvedLocale()] });
        class Dc {
          constructor(t, n, u) {
            this.expression = t, this._warningHistory = {}, this._evaluator = new mc(), this._defaultValue = n ? (function(h) {
              if (h.type === "color" && Ws(h.default)) return new br(0, 0, 0, 0);
              switch (h.type) {
                case "color":
                  return br.parse(h.default) || null;
                case "padding":
                  return ji.parse(h.default) || null;
                case "numberArray":
                  return mn.parse(h.default) || null;
                case "colorArray":
                  return Mi.parse(h.default) || null;
                case "variableAnchorOffsetCollection":
                  return gn.parse(h.default) || null;
                case "projectionDefinition":
                  return nn.parse(h.default) || null;
                default:
                  return h.default === void 0 ? null : h.default;
              }
            })(n) : null, this._enumValues = n && n.type === "enum" ? n.values : null, this._globalState = u;
          }
          evaluateWithoutErrorHandling(t, n, u, h, _, b) {
            return this._globalState && (t = Ra(t, this._globalState)), this._evaluator.globals = t, this._evaluator.feature = n, this._evaluator.featureState = u, this._evaluator.canonical = h, this._evaluator.availableImages = _ || null, this._evaluator.formattedSection = b, this.expression.evaluate(this._evaluator);
          }
          evaluate(t, n, u, h, _, b) {
            this._globalState && (t = Ra(t, this._globalState)), this._evaluator.globals = t, this._evaluator.feature = n || null, this._evaluator.featureState = u || null, this._evaluator.canonical = h, this._evaluator.availableImages = _ || null, this._evaluator.formattedSection = b || null;
            try {
              const w = this.expression.evaluate(this._evaluator);
              if (w == null || typeof w == "number" && w != w) return this._defaultValue;
              if (this._enumValues && !(w in this._enumValues)) throw new Qr(`Expected value to be one of ${Object.keys(this._enumValues).map(((S) => JSON.stringify(S))).join(", ")}, but found ${JSON.stringify(w)} instead.`);
              return w;
            } catch (w) {
              return this._warningHistory[w.message] || (this._warningHistory[w.message] = true, typeof console < "u" && console.warn(w.message)), this._defaultValue;
            }
          }
        }
        function eu(o) {
          return Array.isArray(o) && o.length > 0 && typeof o[0] == "string" && o[0] in is;
        }
        function Zs(o, t, n) {
          const u = new es(is, Kl, [], t ? (function(_) {
            const b = { color: ni, string: cr, number: gt, enum: cr, boolean: lr, formatted: qn, padding: Ko, numberArray: vo, colorArray: kn, projectionDefinition: fn, resolvedImage: Zr, variableAnchorOffsetCollection: Jn };
            return _.type === "array" ? rn(b[_.value] || dr, _.length) : b[_.type];
          })(t) : void 0), h = u.parse(o, void 0, void 0, void 0, t && t.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return h ? Th(new Dc(h, t, n)) : ns(u.errors);
        }
        class Hs {
          constructor(t, n, u) {
            this.kind = t, this._styleExpression = n, this.isStateDependent = t !== "constant" && !Gs(n.expression), this.globalStateRefs = Ks(n.expression), this._globalState = u;
          }
          evaluateWithoutErrorHandling(t, n, u, h, _, b) {
            return this._globalState && (t = Ra(t, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t, n, u, h, _, b);
          }
          evaluate(t, n, u, h, _, b) {
            return this._globalState && (t = Ra(t, this._globalState)), this._styleExpression.evaluate(t, n, u, h, _, b);
          }
        }
        class zc {
          constructor(t, n, u, h, _) {
            this.kind = t, this.zoomStops = u, this._styleExpression = n, this.isStateDependent = t !== "camera" && !Gs(n.expression), this.globalStateRefs = Ks(n.expression), this.interpolationType = h, this._globalState = _;
          }
          evaluateWithoutErrorHandling(t, n, u, h, _, b) {
            return this._globalState && (t = Ra(t, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(t, n, u, h, _, b);
          }
          evaluate(t, n, u, h, _, b) {
            return this._globalState && (t = Ra(t, this._globalState)), this._styleExpression.evaluate(t, n, u, h, _, b);
          }
          interpolationFactor(t, n, u) {
            return this.interpolationType ? Hi.interpolationFactor(this.interpolationType, t, n, u) : 0;
          }
        }
        function Ah(o, t, n) {
          const u = Zs(o, t, n);
          if (u.result === "error") return u;
          const h = u.value.expression, _ = Jl(h);
          if (!_ && !ra(t)) return ns([new Bt("", "data expressions not supported")]);
          const b = Ql(h, ["zoom"]);
          if (!b && !Ih(t)) return ns([new Bt("", "zoom expressions not supported")]);
          const w = Ys(h);
          return w || b ? w instanceof Bt ? ns([w]) : w instanceof Hi && !Ac(t) ? ns([new Bt("", '"interpolate" expressions cannot be used with this property')]) : Th(w ? new zc(_ ? "camera" : "composite", u.value, w.labels, w instanceof Hi ? w.interpolation : void 0, n) : new Hs(_ ? "constant" : "source", u.value, n)) : ns([new Bt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class Xs {
          constructor(t, n) {
            this._parameters = t, this._specification = n, dt(this, Mh(this._parameters, this._specification));
          }
          static deserialize(t) {
            return new Xs(t._parameters, t._specification);
          }
          static serialize(t) {
            return { _parameters: t._parameters, _specification: t._specification };
          }
        }
        function Ys(o) {
          let t = null;
          if (o instanceof Ds) t = Ys(o.result);
          else if (o instanceof Bs) {
            for (const n of o.args) if (t = Ys(n), t) break;
          } else (o instanceof xi || o instanceof Hi) && o.input instanceof Gn && o.input.name === "zoom" && (t = o);
          return t instanceof Bt || o.eachChild(((n) => {
            const u = Ys(n);
            u instanceof Bt ? t = u : !t && u ? t = new Bt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && u && t !== u && (t = new Bt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          })), t;
        }
        function Ks(o, t = /* @__PURE__ */ new Set()) {
          return o instanceof qs && t.add(o.key), o.eachChild(((n) => {
            Ks(n, t);
          })), t;
        }
        function Ra(o, t) {
          const { zoom: n, heatmapDensity: u, elevation: h, lineProgress: _, isSupportedScript: b, accumulated: w } = o ?? {};
          return { zoom: n, heatmapDensity: u, elevation: h, lineProgress: _, isSupportedScript: b, accumulated: w, globalState: t };
        }
        function Js(o) {
          if (o === true || o === false) return true;
          if (!Array.isArray(o) || o.length === 0) return false;
          switch (o[0]) {
            case "has":
              return o.length >= 2 && o[1] !== "$id" && o[1] !== "$type";
            case "in":
              return o.length >= 3 && (typeof o[1] != "string" || Array.isArray(o[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return o.length !== 3 || Array.isArray(o[1]) || Array.isArray(o[2]);
            case "any":
            case "all":
              for (const t of o.slice(1)) if (!Js(t) && typeof t != "boolean") return false;
              return true;
            default:
              return true;
          }
        }
        const Fc = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
        function Aa(o, t) {
          if (o == null) return { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() };
          Js(o) || (o = tu(o));
          const n = Zs(o, Fc, t);
          if (n.result === "error") throw new Error(n.value.map(((u) => `${u.key}: ${u.message}`)).join(", "));
          return { filter: (u, h, _) => n.value.evaluate(u, h, {}, _), needGeometry: Qs(o), getGlobalStateRefs: () => Ks(n.value.expression) };
        }
        function Lc(o, t) {
          return o < t ? -1 : o > t ? 1 : 0;
        }
        function Qs(o) {
          if (!Array.isArray(o)) return false;
          if (o[0] === "within" || o[0] === "distance") return true;
          for (let t = 1; t < o.length; t++) if (Qs(o[t])) return true;
          return false;
        }
        function tu(o) {
          if (!o) return true;
          const t = o[0];
          return o.length <= 1 ? t !== "any" : t === "==" ? Bc(o[1], o[2], "==") : t === "!=" ? ru(Bc(o[1], o[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? Bc(o[1], o[2], t) : t === "any" ? (n = o.slice(1), ["any"].concat(n.map(tu))) : t === "all" ? ["all"].concat(o.slice(1).map(tu)) : t === "none" ? ["all"].concat(o.slice(1).map(tu).map(ru)) : t === "in" ? Dh(o[1], o.slice(2)) : t === "!in" ? ru(Dh(o[1], o.slice(2))) : t === "has" ? zh(o[1]) : t !== "!has" || ru(zh(o[1]));
          var n;
        }
        function Bc(o, t, n) {
          switch (o) {
            case "$type":
              return [`filter-type-${n}`, t];
            case "$id":
              return [`filter-id-${n}`, t];
            default:
              return [`filter-${n}`, o, t];
          }
        }
        function Dh(o, t) {
          if (t.length === 0) return false;
          switch (o) {
            case "$type":
              return ["filter-type-in", ["literal", t]];
            case "$id":
              return ["filter-id-in", ["literal", t]];
            default:
              return t.length > 200 && !t.some(((n) => typeof n != typeof t[0])) ? ["filter-in-large", o, ["literal", t.sort(Lc)]] : ["filter-in-small", o, ["literal", t]];
          }
        }
        function zh(o) {
          switch (o) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", o];
          }
        }
        function ru(o) {
          return ["!", o];
        }
        function Oc(o) {
          const t = typeof o;
          if (t === "number" || t === "boolean" || t === "string" || o == null) return JSON.stringify(o);
          if (Array.isArray(o)) {
            let h = "[";
            for (const _ of o) h += `${Oc(_)},`;
            return `${h}]`;
          }
          const n = Object.keys(o).sort();
          let u = "{";
          for (let h = 0; h < n.length; h++) u += `${JSON.stringify(n[h])}:${Oc(o[n[h]])},`;
          return `${u}}`;
        }
        function Fh(o) {
          let t = "";
          for (const n of $t) t += `/${Oc(o[n])}`;
          return t;
        }
        function $c(o) {
          const t = o.value;
          return t ? [new ge(o.key, t, "constants have been deprecated as of v8")] : [];
        }
        function ci(o) {
          return o instanceof Number || o instanceof String || o instanceof Boolean ? o.valueOf() : o;
        }
        function Da(o) {
          if (Array.isArray(o)) return o.map(Da);
          if (o instanceof Object && !(o instanceof Number || o instanceof String || o instanceof Boolean)) {
            const t = {};
            for (const n in o) t[n] = Da(o[n]);
            return t;
          }
          return ci(o);
        }
        function Ln(o) {
          const t = o.key, n = o.value, u = o.valueSpec || {}, h = o.objectElementValidators || {}, _ = o.style, b = o.styleSpec, w = o.validateSpec;
          let S = [];
          const I = Sr(n);
          if (I !== "object") return [new ge(t, n, `object expected, ${I} found`)];
          for (const R in n) {
            const B = R.split(".")[0], N = ta(u, B) || u["*"];
            let q;
            if (ta(h, B)) q = h[B];
            else if (ta(u, B)) q = w;
            else if (h["*"]) q = h["*"];
            else {
              if (!u["*"]) {
                S.push(new ge(t, n[R], `unknown property "${R}"`));
                continue;
              }
              q = w;
            }
            S = S.concat(q({ key: (t && `${t}.`) + R, value: n[R], valueSpec: N, style: _, styleSpec: b, object: n, objectKey: R, validateSpec: w }, n));
          }
          for (const R in u) h[R] || u[R].required && u[R].default === void 0 && n[R] === void 0 && S.push(new ge(t, n, `missing required property "${R}"`));
          return S;
        }
        function iu(o) {
          const t = o.value, n = o.valueSpec, u = o.style, h = o.styleSpec, _ = o.key, b = o.arrayElementValidator || o.validateSpec;
          if (Sr(t) !== "array") return [new ge(_, t, `array expected, ${Sr(t)} found`)];
          if (n.length && t.length !== n.length) return [new ge(_, t, `array length ${n.length} expected, length ${t.length} found`)];
          if (n["min-length"] && t.length < n["min-length"]) return [new ge(_, t, `array length at least ${n["min-length"]} expected, length ${t.length} found`)];
          let w = { type: n.value, values: n.values };
          h.$version < 7 && (w.function = n.function), Sr(n.value) === "object" && (w = n.value);
          let S = [];
          for (let I = 0; I < t.length; I++) S = S.concat(b({ array: t, arrayIndex: I, value: t[I], valueSpec: w, validateSpec: o.validateSpec, style: u, styleSpec: h, key: `${_}[${I}]` }));
          return S;
        }
        function nu(o) {
          const t = o.key, n = o.value, u = o.valueSpec;
          let h = Sr(n);
          return h === "number" && n != n && (h = "NaN"), h !== "number" ? [new ge(t, n, `number expected, ${h} found`)] : "minimum" in u && n < u.minimum ? [new ge(t, n, `${n} is less than the minimum value ${u.minimum}`)] : "maximum" in u && n > u.maximum ? [new ge(t, n, `${n} is greater than the maximum value ${u.maximum}`)] : [];
        }
        function jc(o) {
          const t = o.valueSpec, n = ci(o.value.type);
          let u, h, _, b = {};
          const w = n !== "categorical" && o.value.property === void 0, S = !w, I = Sr(o.value.stops) === "array" && Sr(o.value.stops[0]) === "array" && Sr(o.value.stops[0][0]) === "object", R = Ln({ key: o.key, value: o.value, valueSpec: o.styleSpec.function, validateSpec: o.validateSpec, style: o.style, styleSpec: o.styleSpec, objectElementValidators: { stops: function(q) {
            if (n === "identity") return [new ge(q.key, q.value, 'identity function may not have a "stops" property')];
            let G = [];
            const Q = q.value;
            return G = G.concat(iu({ key: q.key, value: Q, valueSpec: q.valueSpec, validateSpec: q.validateSpec, style: q.style, styleSpec: q.styleSpec, arrayElementValidator: B })), Sr(Q) === "array" && Q.length === 0 && G.push(new ge(q.key, Q, "array must have at least one stop")), G;
          }, default: function(q) {
            return q.validateSpec({ key: q.key, value: q.value, valueSpec: t, validateSpec: q.validateSpec, style: q.style, styleSpec: q.styleSpec });
          } } });
          return n === "identity" && w && R.push(new ge(o.key, o.value, 'missing required property "property"')), n === "identity" || o.value.stops || R.push(new ge(o.key, o.value, 'missing required property "stops"')), n === "exponential" && o.valueSpec.expression && !Ac(o.valueSpec) && R.push(new ge(o.key, o.value, "exponential functions not supported")), o.styleSpec.$version >= 8 && (S && !ra(o.valueSpec) ? R.push(new ge(o.key, o.value, "property functions not supported")) : w && !Ih(o.valueSpec) && R.push(new ge(o.key, o.value, "zoom functions not supported"))), n !== "categorical" && !I || o.value.property !== void 0 || R.push(new ge(o.key, o.value, '"property" property is required')), R;
          function B(q) {
            let G = [];
            const Q = q.value, ae = q.key;
            if (Sr(Q) !== "array") return [new ge(ae, Q, `array expected, ${Sr(Q)} found`)];
            if (Q.length !== 2) return [new ge(ae, Q, `array length 2 expected, length ${Q.length} found`)];
            if (I) {
              if (Sr(Q[0]) !== "object") return [new ge(ae, Q, `object expected, ${Sr(Q[0])} found`)];
              if (Q[0].zoom === void 0) return [new ge(ae, Q, "object stop key must have zoom")];
              if (Q[0].value === void 0) return [new ge(ae, Q, "object stop key must have value")];
              if (_ && _ > ci(Q[0].zoom)) return [new ge(ae, Q[0].zoom, "stop zoom values must appear in ascending order")];
              ci(Q[0].zoom) !== _ && (_ = ci(Q[0].zoom), h = void 0, b = {}), G = G.concat(Ln({ key: `${ae}[0]`, value: Q[0], valueSpec: { zoom: {} }, validateSpec: q.validateSpec, style: q.style, styleSpec: q.styleSpec, objectElementValidators: { zoom: nu, value: N } }));
            } else G = G.concat(N({ key: `${ae}[0]`, value: Q[0], validateSpec: q.validateSpec, style: q.style, styleSpec: q.styleSpec }, Q));
            return eu(Da(Q[1])) ? G.concat([new ge(`${ae}[1]`, Q[1], "expressions are not allowed in function stops.")]) : G.concat(q.validateSpec({ key: `${ae}[1]`, value: Q[1], valueSpec: t, validateSpec: q.validateSpec, style: q.style, styleSpec: q.styleSpec }));
          }
          function N(q, G) {
            const Q = Sr(q.value), ae = ci(q.value), pe = q.value !== null ? q.value : G;
            if (u) {
              if (Q !== u) return [new ge(q.key, pe, `${Q} stop domain type must match previous stop domain type ${u}`)];
            } else u = Q;
            if (Q !== "number" && Q !== "string" && Q !== "boolean") return [new ge(q.key, pe, "stop domain value must be a number, string, or boolean")];
            if (Q !== "number" && n !== "categorical") {
              let Oe = `number expected, ${Q} found`;
              return ra(t) && n === void 0 && (Oe += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ge(q.key, pe, Oe)];
            }
            return n !== "categorical" || Q !== "number" || isFinite(ae) && Math.floor(ae) === ae ? n !== "categorical" && Q === "number" && h !== void 0 && ae < h ? [new ge(q.key, pe, "stop domain values must appear in ascending order")] : (h = ae, n === "categorical" && ae in b ? [new ge(q.key, pe, "stop domain values must be unique")] : (b[ae] = true, [])) : [new ge(q.key, pe, `integer expected, found ${ae}`)];
          }
        }
        function za(o) {
          const t = (o.expressionContext === "property" ? Ah : Zs)(Da(o.value), o.valueSpec);
          if (t.result === "error") return t.value.map(((u) => new ge(`${o.key}${u.key}`, o.value, u.message)));
          const n = t.value.expression || t.value._styleExpression.expression;
          if (o.expressionContext === "property" && o.propertyKey === "text-font" && !n.outputDefined()) return [new ge(o.key, o.value, `Invalid data expression for "${o.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (o.expressionContext === "property" && o.propertyType === "layout" && !Gs(n)) return [new ge(o.key, o.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (o.expressionContext === "filter" && !Gs(n)) return [new ge(o.key, o.value, '"feature-state" data expressions are not supported with filters.')];
          if (o.expressionContext && o.expressionContext.indexOf("cluster") === 0) {
            if (!Ql(n, ["zoom", "feature-state"])) return [new ge(o.key, o.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (o.expressionContext === "cluster-initial" && !Jl(n)) return [new ge(o.key, o.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function Fa(o) {
          const t = o.key, n = o.value, u = Sr(n);
          return u !== "string" ? [new ge(t, n, `color expected, ${u} found`)] : br.parse(String(n)) ? [] : [new ge(t, n, `color expected, "${n}" found`)];
        }
        function el(o) {
          const t = o.key, n = o.value, u = o.valueSpec, h = [];
          return Array.isArray(u.values) ? u.values.indexOf(ci(n)) === -1 && h.push(new ge(t, n, `expected one of [${u.values.join(", ")}], ${JSON.stringify(n)} found`)) : Object.keys(u.values).indexOf(ci(n)) === -1 && h.push(new ge(t, n, `expected one of [${Object.keys(u.values).join(", ")}], ${JSON.stringify(n)} found`)), h;
        }
        function Nc(o) {
          return Js(Da(o.value)) ? za(dt({}, o, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Lh(o);
        }
        function Lh(o) {
          const t = o.value, n = o.key;
          if (Sr(t) !== "array") return [new ge(n, t, `array expected, ${Sr(t)} found`)];
          const u = o.styleSpec;
          let h, _ = [];
          if (t.length < 1) return [new ge(n, t, "filter array must have at least 1 element")];
          switch (_ = _.concat(el({ key: `${n}[0]`, value: t[0], valueSpec: u.filter_operator, style: o.style, styleSpec: o.styleSpec })), ci(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && ci(t[1]) === "$type" && _.push(new ge(n, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && _.push(new ge(n, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (h = Sr(t[1]), h !== "string" && _.push(new ge(`${n}[1]`, t[1], `string expected, ${h} found`)));
              for (let b = 2; b < t.length; b++) h = Sr(t[b]), ci(t[1]) === "$type" ? _ = _.concat(el({ key: `${n}[${b}]`, value: t[b], valueSpec: u.geometry_type, style: o.style, styleSpec: o.styleSpec })) : h !== "string" && h !== "number" && h !== "boolean" && _.push(new ge(`${n}[${b}]`, t[b], `string, number, or boolean expected, ${h} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let b = 1; b < t.length; b++) _ = _.concat(Lh({ key: `${n}[${b}]`, value: t[b], style: o.style, styleSpec: o.styleSpec }));
              break;
            case "has":
            case "!has":
              h = Sr(t[1]), t.length !== 2 ? _.push(new ge(n, t, `filter array for "${t[0]}" operator must have 2 elements`)) : h !== "string" && _.push(new ge(`${n}[1]`, t[1], `string expected, ${h} found`));
          }
          return _;
        }
        function Bh(o, t) {
          const n = o.key, u = o.validateSpec, h = o.style, _ = o.styleSpec, b = o.value, w = o.objectKey, S = _[`${t}_${o.layerType}`];
          if (!S) return [];
          const I = w.match(/^(.*)-transition$/);
          if (t === "paint" && I && S[I[1]] && S[I[1]].transition) return u({ key: n, value: b, valueSpec: _.transition, style: h, styleSpec: _ });
          const R = o.valueSpec || S[w];
          if (!R) return [new ge(n, b, `unknown property "${w}"`)];
          let B;
          if (Sr(b) === "string" && ra(R) && !R.tokens && (B = /^{([^}]+)}$/.exec(b))) return [new ge(n, b, `"${w}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(B[1])} }\`.`)];
          const N = [];
          return o.layerType === "symbol" && (w === "text-field" && h && !h.glyphs && N.push(new ge(n, b, 'use of "text-field" requires a style "glyphs" property')), w === "text-font" && Ws(Da(b)) && ci(b.type) === "identity" && N.push(new ge(n, b, '"text-font" does not support identity functions'))), N.concat(u({ key: o.key, value: b, valueSpec: R, style: h, styleSpec: _, expressionContext: "property", propertyType: t, propertyKey: w }));
        }
        function Oh(o) {
          return Bh(o, "paint");
        }
        function $h(o) {
          return Bh(o, "layout");
        }
        function os(o) {
          let t = [];
          const n = o.value, u = o.key, h = o.style, _ = o.styleSpec;
          if (Sr(n) !== "object") return [new ge(u, n, `object expected, ${Sr(n)} found`)];
          n.type || n.ref || t.push(new ge(u, n, 'either "type" or "ref" is required'));
          let b = ci(n.type);
          const w = ci(n.ref);
          if (n.id) {
            const S = ci(n.id);
            for (let I = 0; I < o.arrayIndex; I++) {
              const R = h.layers[I];
              ci(R.id) === S && t.push(new ge(u, n.id, `duplicate layer id "${n.id}", previously used at line ${R.id.__line__}`));
            }
          }
          if ("ref" in n) {
            let S;
            ["type", "source", "source-layer", "filter", "layout"].forEach(((I) => {
              I in n && t.push(new ge(u, n[I], `"${I}" is prohibited for ref layers`));
            })), h.layers.forEach(((I) => {
              ci(I.id) === w && (S = I);
            })), S ? S.ref ? t.push(new ge(u, n.ref, "ref cannot reference another ref layer")) : b = ci(S.type) : t.push(new ge(u, n.ref, `ref layer "${w}" not found`));
          } else if (b !== "background") if (n.source) {
            const S = h.sources && h.sources[n.source], I = S && ci(S.type);
            S ? I === "vector" && b === "raster" ? t.push(new ge(u, n.source, `layer "${n.id}" requires a raster source`)) : I !== "raster-dem" && b === "hillshade" || I !== "raster-dem" && b === "color-relief" ? t.push(new ge(u, n.source, `layer "${n.id}" requires a raster-dem source`)) : I === "raster" && b !== "raster" ? t.push(new ge(u, n.source, `layer "${n.id}" requires a vector source`)) : I !== "vector" || n["source-layer"] ? I === "raster-dem" && b !== "hillshade" && b !== "color-relief" ? t.push(new ge(u, n.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : b !== "line" || !n.paint || !n.paint["line-gradient"] || I === "geojson" && S.lineMetrics || t.push(new ge(u, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new ge(u, n, `layer "${n.id}" must specify a "source-layer"`)) : t.push(new ge(u, n.source, `source "${n.source}" not found`));
          } else t.push(new ge(u, n, 'missing required property "source"'));
          return t = t.concat(Ln({ key: u, value: n, valueSpec: _.layer, style: o.style, styleSpec: o.styleSpec, validateSpec: o.validateSpec, objectElementValidators: { "*": () => [], type: () => o.validateSpec({ key: `${u}.type`, value: n.type, valueSpec: _.layer.type, style: o.style, styleSpec: o.styleSpec, validateSpec: o.validateSpec, object: n, objectKey: "type" }), filter: Nc, layout: (S) => Ln({ layer: n, key: S.key, value: S.value, style: S.style, styleSpec: S.styleSpec, validateSpec: S.validateSpec, objectElementValidators: { "*": (I) => $h(dt({ layerType: b }, I)) } }), paint: (S) => Ln({ layer: n, key: S.key, value: S.value, style: S.style, styleSpec: S.styleSpec, validateSpec: S.validateSpec, objectElementValidators: { "*": (I) => Oh(dt({ layerType: b }, I)) } }) } })), t;
        }
        function ro(o) {
          const t = o.value, n = o.key, u = Sr(t);
          return u !== "string" ? [new ge(n, t, `string expected, ${u} found`)] : [];
        }
        const Pn = { promoteId: function({ key: o, value: t }) {
          if (Sr(t) === "string") return ro({ key: o, value: t });
          {
            const n = [];
            for (const u in t) n.push(...ro({ key: `${o}.${u}`, value: t[u] }));
            return n;
          }
        } };
        function as(o) {
          const t = o.value, n = o.key, u = o.styleSpec, h = o.style, _ = o.validateSpec;
          if (!t.type) return [new ge(n, t, '"type" is required')];
          const b = ci(t.type);
          let w;
          switch (b) {
            case "vector":
            case "raster":
              return w = Ln({ key: n, value: t, valueSpec: u[`source_${b.replace("-", "_")}`], style: o.style, styleSpec: u, objectElementValidators: Pn, validateSpec: _ }), w;
            case "raster-dem":
              return w = (function(S) {
                var I;
                const R = (I = S.sourceName) !== null && I !== void 0 ? I : "", B = S.value, N = S.styleSpec, q = N.source_raster_dem, G = S.style;
                let Q = [];
                const ae = Sr(B);
                if (B === void 0) return Q;
                if (ae !== "object") return Q.push(new ge("source_raster_dem", B, `object expected, ${ae} found`)), Q;
                const pe = ci(B.encoding) === "custom", Oe = ["redFactor", "greenFactor", "blueFactor", "baseShift"], Ce = S.value.encoding ? `"${S.value.encoding}"` : "Default";
                for (const Ie in B) !pe && Oe.includes(Ie) ? Q.push(new ge(Ie, B[Ie], `In "${R}": "${Ie}" is only valid when "encoding" is set to "custom". ${Ce} encoding found`)) : q[Ie] ? Q = Q.concat(S.validateSpec({ key: Ie, value: B[Ie], valueSpec: q[Ie], validateSpec: S.validateSpec, style: G, styleSpec: N })) : Q.push(new ge(Ie, B[Ie], `unknown property "${Ie}"`));
                return Q;
              })({ sourceName: n, value: t, style: o.style, styleSpec: u, validateSpec: _ }), w;
            case "geojson":
              if (w = Ln({ key: n, value: t, valueSpec: u.source_geojson, style: h, styleSpec: u, validateSpec: _, objectElementValidators: Pn }), t.cluster) for (const S in t.clusterProperties) {
                const [I, R] = t.clusterProperties[S], B = typeof I == "string" ? [I, ["accumulated"], ["get", S]] : I;
                w.push(...za({ key: `${n}.${S}.map`, value: R, expressionContext: "cluster-map" })), w.push(...za({ key: `${n}.${S}.reduce`, value: B, expressionContext: "cluster-reduce" }));
              }
              return w;
            case "video":
              return Ln({ key: n, value: t, valueSpec: u.source_video, style: h, validateSpec: _, styleSpec: u });
            case "image":
              return Ln({ key: n, value: t, valueSpec: u.source_image, style: h, validateSpec: _, styleSpec: u });
            case "canvas":
              return [new ge(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return el({ key: `${n}.type`, value: t.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
          }
        }
        function Vc(o) {
          const t = o.value, n = o.styleSpec, u = n.light, h = o.style;
          let _ = [];
          const b = Sr(t);
          if (t === void 0) return _;
          if (b !== "object") return _ = _.concat([new ge("light", t, `object expected, ${b} found`)]), _;
          for (const w in t) {
            const S = w.match(/^(.*)-transition$/);
            _ = _.concat(S && u[S[1]] && u[S[1]].transition ? o.validateSpec({ key: w, value: t[w], valueSpec: n.transition, validateSpec: o.validateSpec, style: h, styleSpec: n }) : u[w] ? o.validateSpec({ key: w, value: t[w], valueSpec: u[w], validateSpec: o.validateSpec, style: h, styleSpec: n }) : [new ge(w, t[w], `unknown property "${w}"`)]);
          }
          return _;
        }
        function jh(o) {
          const t = o.value, n = o.styleSpec, u = n.sky, h = o.style, _ = Sr(t);
          if (t === void 0) return [];
          if (_ !== "object") return [new ge("sky", t, `object expected, ${_} found`)];
          let b = [];
          for (const w in t) b = b.concat(u[w] ? o.validateSpec({ key: w, value: t[w], valueSpec: u[w], style: h, styleSpec: n }) : [new ge(w, t[w], `unknown property "${w}"`)]);
          return b;
        }
        function Nh(o) {
          const t = o.value, n = o.styleSpec, u = n.terrain, h = o.style;
          let _ = [];
          const b = Sr(t);
          if (t === void 0) return _;
          if (b !== "object") return _ = _.concat([new ge("terrain", t, `object expected, ${b} found`)]), _;
          for (const w in t) _ = _.concat(u[w] ? o.validateSpec({ key: w, value: t[w], valueSpec: u[w], validateSpec: o.validateSpec, style: h, styleSpec: n }) : [new ge(w, t[w], `unknown property "${w}"`)]);
          return _;
        }
        function ss(o) {
          let t = [];
          const n = o.value, u = o.key;
          if (Array.isArray(n)) {
            const h = [], _ = [];
            for (const b in n) n[b].id && h.includes(n[b].id) && t.push(new ge(u, n, `all the sprites' ids must be unique, but ${n[b].id} is duplicated`)), h.push(n[b].id), n[b].url && _.includes(n[b].url) && t.push(new ge(u, n, `all the sprites' URLs must be unique, but ${n[b].url} is duplicated`)), _.push(n[b].url), t = t.concat(Ln({ key: `${u}[${b}]`, value: n[b], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: o.validateSpec }));
            return t;
          }
          return ro({ key: u, value: n });
        }
        function Uc(o) {
          return t = o.value, t && t.constructor === Object ? [] : [new ge(o.key, o.value, `object expected, ${Sr(o.value)} found`)];
          var t;
        }
        const ou = { "*": () => [], array: iu, boolean: function(o) {
          const t = o.value, n = o.key, u = Sr(t);
          return u !== "boolean" ? [new ge(n, t, `boolean expected, ${u} found`)] : [];
        }, number: nu, color: Fa, constants: $c, enum: el, filter: Nc, function: jc, layer: os, object: Ln, source: as, light: Vc, sky: jh, terrain: Nh, projection: function(o) {
          const t = o.value, n = o.styleSpec, u = n.projection, h = o.style, _ = Sr(t);
          if (t === void 0) return [];
          if (_ !== "object") return [new ge("projection", t, `object expected, ${_} found`)];
          let b = [];
          for (const w in t) b = b.concat(u[w] ? o.validateSpec({ key: w, value: t[w], valueSpec: u[w], style: h, styleSpec: n }) : [new ge(w, t[w], `unknown property "${w}"`)]);
          return b;
        }, projectionDefinition: function(o) {
          const t = o.key;
          let n = o.value;
          n = n instanceof String ? n.valueOf() : n;
          const u = Sr(n);
          return u !== "array" || (function(h) {
            return Array.isArray(h) && h.length === 3 && typeof h[0] == "string" && typeof h[1] == "string" && typeof h[2] == "number";
          })(n) || (function(h) {
            return !!["interpolate", "step", "literal"].includes(h[0]);
          })(n) ? ["array", "string"].includes(u) ? [] : [new ge(t, n, `projection expected, invalid type "${u}" found`)] : [new ge(t, n, `projection expected, invalid array ${JSON.stringify(n)} found`)];
        }, string: ro, formatted: function(o) {
          return ro(o).length === 0 ? [] : za(o);
        }, resolvedImage: function(o) {
          return ro(o).length === 0 ? [] : za(o);
        }, padding: function(o) {
          const t = o.key, n = o.value;
          if (Sr(n) === "array") {
            if (n.length < 1 || n.length > 4) return [new ge(t, n, `padding requires 1 to 4 values; ${n.length} values found`)];
            const u = { type: "number" };
            let h = [];
            for (let _ = 0; _ < n.length; _++) h = h.concat(o.validateSpec({ key: `${t}[${_}]`, value: n[_], validateSpec: o.validateSpec, valueSpec: u }));
            return h;
          }
          return nu({ key: t, value: n, valueSpec: {} });
        }, numberArray: function(o) {
          const t = o.key, n = o.value;
          if (Sr(n) === "array") {
            const u = { type: "number" };
            if (n.length < 1) return [new ge(t, n, "array length at least 1 expected, length 0 found")];
            let h = [];
            for (let _ = 0; _ < n.length; _++) h = h.concat(o.validateSpec({ key: `${t}[${_}]`, value: n[_], validateSpec: o.validateSpec, valueSpec: u }));
            return h;
          }
          return nu({ key: t, value: n, valueSpec: {} });
        }, colorArray: function(o) {
          const t = o.key, n = o.value;
          if (Sr(n) === "array") {
            if (n.length < 1) return [new ge(t, n, "array length at least 1 expected, length 0 found")];
            let u = [];
            for (let h = 0; h < n.length; h++) u = u.concat(Fa({ key: `${t}[${h}]`, value: n[h] }));
            return u;
          }
          return Fa({ key: t, value: n });
        }, variableAnchorOffsetCollection: function(o) {
          const t = o.key, n = o.value, u = Sr(n), h = o.styleSpec;
          if (u !== "array" || n.length < 1 || n.length % 2 != 0) return [new ge(t, n, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let _ = [];
          for (let b = 0; b < n.length; b += 2) _ = _.concat(el({ key: `${t}[${b}]`, value: n[b], valueSpec: h.layout_symbol["text-anchor"] })), _ = _.concat(iu({ key: `${t}[${b + 1}]`, value: n[b + 1], valueSpec: { length: 2, value: "number" }, validateSpec: o.validateSpec, style: o.style, styleSpec: h }));
          return _;
        }, sprite: ss, state: Uc };
        function au(o) {
          const t = o.value, n = o.valueSpec, u = o.styleSpec;
          return o.validateSpec = au, n.expression && Ws(ci(t)) ? jc(o) : n.expression && eu(Da(t)) ? za(o) : n.type && ou[n.type] ? ou[n.type](o) : Ln(dt({}, o, { valueSpec: n.type ? u[n.type] : n }));
        }
        function su(o) {
          const t = o.value, n = o.key, u = ro(o);
          return u.length || (t.indexOf("{fontstack}") === -1 && u.push(new ge(n, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && u.push(new ge(n, t, '"glyphs" url must include a "{range}" token'))), u;
        }
        function Wn(o, t = Te) {
          let n = [];
          return n = n.concat(au({ key: "", value: o, valueSpec: t.$root, styleSpec: t, style: o, validateSpec: au, objectElementValidators: { glyphs: su, "*": () => [] } })), o.constants && (n = n.concat($c({ key: "constants", value: o.constants }))), Vh(n);
        }
        function vn(o) {
          return function(t) {
            return o({ ...t, validateSpec: au });
          };
        }
        function Vh(o) {
          return [].concat(o).sort(((t, n) => t.line - n.line));
        }
        function io(o) {
          return function(...t) {
            return Vh(o.apply(this, t));
          };
        }
        Wn.source = io(vn(as)), Wn.sprite = io(vn(ss)), Wn.glyphs = io(vn(su)), Wn.light = io(vn(Vc)), Wn.sky = io(vn(jh)), Wn.terrain = io(vn(Nh)), Wn.state = io(vn(Uc)), Wn.layer = io(vn(os)), Wn.filter = io(vn(Nc)), Wn.paintProperty = io(vn(Oh)), Wn.layoutProperty = io(vn($h));
        const ls = Wn, tl = ls.light, Op = ls.sky, $p = ls.paintProperty, lu = ls.layoutProperty;
        function Uh(o, t) {
          let n = false;
          if (t && t.length) for (const u of t) o.fire(new Xe(new Error(u.message))), n = true;
          return n;
        }
        class La {
          constructor(t, n, u) {
            const h = this.cells = [];
            if (t instanceof ArrayBuffer) {
              this.arrayBuffer = t;
              const b = new Int32Array(this.arrayBuffer);
              t = b[0], this.d = (n = b[1]) + 2 * (u = b[2]);
              for (let S = 0; S < this.d * this.d; S++) {
                const I = b[3 + S], R = b[3 + S + 1];
                h.push(I === R ? null : b.subarray(I, R));
              }
              const w = b[3 + h.length + 1];
              this.keys = b.subarray(b[3 + h.length], w), this.bboxes = b.subarray(w), this.insert = this._insertReadonly;
            } else {
              this.d = n + 2 * u;
              for (let b = 0; b < this.d * this.d; b++) h.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = n, this.extent = t, this.padding = u, this.scale = n / t, this.uid = 0;
            const _ = u / n * t;
            this.min = -_, this.max = t + _;
          }
          insert(t, n, u, h, _) {
            this._forEachCell(n, u, h, _, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(n), this.bboxes.push(u), this.bboxes.push(h), this.bboxes.push(_);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(t, n, u, h, _, b) {
            this.cells[_].push(b);
          }
          query(t, n, u, h, _) {
            const b = this.min, w = this.max;
            if (t <= b && n <= b && w <= u && w <= h && !_) return Array.prototype.slice.call(this.keys);
            {
              const S = [];
              return this._forEachCell(t, n, u, h, this._queryCell, S, {}, _), S;
            }
          }
          _queryCell(t, n, u, h, _, b, w, S) {
            const I = this.cells[_];
            if (I !== null) {
              const R = this.keys, B = this.bboxes;
              for (let N = 0; N < I.length; N++) {
                const q = I[N];
                if (w[q] === void 0) {
                  const G = 4 * q;
                  (S ? S(B[G + 0], B[G + 1], B[G + 2], B[G + 3]) : t <= B[G + 2] && n <= B[G + 3] && u >= B[G + 0] && h >= B[G + 1]) ? (w[q] = true, b.push(R[q])) : w[q] = false;
                }
              }
            }
          }
          _forEachCell(t, n, u, h, _, b, w, S) {
            const I = this._convertToCellCoord(t), R = this._convertToCellCoord(n), B = this._convertToCellCoord(u), N = this._convertToCellCoord(h);
            for (let q = I; q <= B; q++) for (let G = R; G <= N; G++) {
              const Q = this.d * G + q;
              if ((!S || S(this._convertFromCellCoord(q), this._convertFromCellCoord(G), this._convertFromCellCoord(q + 1), this._convertFromCellCoord(G + 1))) && _.call(this, t, n, u, h, Q, b, w, S)) return;
            }
          }
          _convertFromCellCoord(t) {
            return (t - this.padding) / this.scale;
          }
          _convertToCellCoord(t) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t = this.cells, n = 3 + this.cells.length + 1 + 1;
            let u = 0;
            for (let b = 0; b < this.cells.length; b++) u += this.cells[b].length;
            const h = new Int32Array(n + u + this.keys.length + this.bboxes.length);
            h[0] = this.extent, h[1] = this.n, h[2] = this.padding;
            let _ = n;
            for (let b = 0; b < t.length; b++) {
              const w = t[b];
              h[3 + b] = _, h.set(w, _), _ += w.length;
            }
            return h[3 + t.length] = _, h.set(this.keys, _), _ += this.keys.length, h[3 + t.length + 1] = _, h.set(this.bboxes, _), _ += this.bboxes.length, h.buffer;
          }
          static serialize(t, n) {
            const u = t.toArrayBuffer();
            return n && n.push(u), { buffer: u };
          }
          static deserialize(t) {
            return new La(t.buffer);
          }
        }
        const Zn = {};
        function Lt(o, t, n = {}) {
          if (Zn[o]) throw new Error(`${o} is already registered.`);
          Object.defineProperty(t, "_classRegistryKey", { value: o, writeable: false }), Zn[o] = { klass: t, omit: n.omit || [], shallow: n.shallow || [] };
        }
        Lt("Object", Object), Lt("Set", Set), Lt("TransferableGridIndex", La), Lt("Color", br), Lt("Error", Error), Lt("AJAXError", xe), Lt("ResolvedImage", zn), Lt("StylePropertyFunction", Xs), Lt("StyleExpression", Dc, { omit: ["_evaluator"] }), Lt("ZoomDependentExpression", zc), Lt("ZoomConstantExpression", Hs), Lt("CompoundExpression", Gn, { omit: ["_evaluate"] });
        for (const o in is) is[o]._classRegistryKey || Lt(`Expression_${o}`, is[o]);
        function qc(o) {
          return o && typeof ArrayBuffer < "u" && (o instanceof ArrayBuffer || o.constructor && o.constructor.name === "ArrayBuffer");
        }
        function uu(o) {
          return o.$name || o.constructor._classRegistryKey;
        }
        function Gc(o) {
          return !(function(t) {
            if (t === null || typeof t != "object") return false;
            const n = uu(t);
            return !(!n || n === "Object");
          })(o) && (o == null || typeof o == "boolean" || typeof o == "number" || typeof o == "string" || o instanceof Boolean || o instanceof Number || o instanceof String || o instanceof Date || o instanceof RegExp || o instanceof Blob || o instanceof Error || qc(o) || Ee(o) || ArrayBuffer.isView(o) || o instanceof ImageData);
        }
        function Ba(o, t) {
          if (Gc(o)) return (qc(o) || Ee(o)) && t && t.push(o), ArrayBuffer.isView(o) && t && t.push(o.buffer), o instanceof ImageData && t && t.push(o.data.buffer), o;
          if (Array.isArray(o)) {
            const _ = [];
            for (const b of o) _.push(Ba(b, t));
            return _;
          }
          if (typeof o != "object") throw new Error("can't serialize object of type " + typeof o);
          const n = uu(o);
          if (!n) throw new Error(`can't serialize object of unregistered class ${o.constructor.name}`);
          if (!Zn[n]) throw new Error(`${n} is not registered.`);
          const { klass: u } = Zn[n], h = u.serialize ? u.serialize(o, t) : {};
          if (u.serialize) {
            if (t && h === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const _ in o) {
              if (!o.hasOwnProperty(_) || Zn[n].omit.indexOf(_) >= 0) continue;
              const b = o[_];
              h[_] = Zn[n].shallow.indexOf(_) >= 0 ? b : Ba(b, t);
            }
            o instanceof Error && (h.message = o.message);
          }
          if (h.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return n !== "Object" && (h.$name = n), h;
        }
        function us(o) {
          if (Gc(o)) return o;
          if (Array.isArray(o)) return o.map(us);
          if (typeof o != "object") throw new Error("can't deserialize object of type " + typeof o);
          const t = uu(o) || "Object";
          if (!Zn[t]) throw new Error(`can't deserialize unregistered class ${t}`);
          const { klass: n } = Zn[t];
          if (!n) throw new Error(`can't deserialize unregistered class ${t}`);
          if (n.deserialize) return n.deserialize(o);
          const u = Object.create(n.prototype);
          for (const h of Object.keys(o)) {
            if (h === "$name") continue;
            const _ = o[h];
            u[h] = Zn[t].shallow.indexOf(h) >= 0 ? _ : us(_);
          }
          return u;
        }
        class Wc {
          constructor() {
            this.first = true;
          }
          update(t, n) {
            const u = Math.floor(t);
            return this.first ? (this.first = false, this.lastIntegerZoom = u, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = u, true) : (this.lastFloorZoom > u ? (this.lastIntegerZoom = u + 1, this.lastIntegerZoomTime = n) : this.lastFloorZoom < u && (this.lastIntegerZoom = u, this.lastIntegerZoomTime = n), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = u, true));
          }
        }
        const kr = { "Latin-1 Supplement": (o) => o >= 128 && o <= 255, "Hangul Jamo": (o) => o >= 4352 && o <= 4607, Khmer: (o) => o >= 6016 && o <= 6143, "General Punctuation": (o) => o >= 8192 && o <= 8303, "Letterlike Symbols": (o) => o >= 8448 && o <= 8527, "Number Forms": (o) => o >= 8528 && o <= 8591, "Miscellaneous Technical": (o) => o >= 8960 && o <= 9215, "Control Pictures": (o) => o >= 9216 && o <= 9279, "Optical Character Recognition": (o) => o >= 9280 && o <= 9311, "Enclosed Alphanumerics": (o) => o >= 9312 && o <= 9471, "Geometric Shapes": (o) => o >= 9632 && o <= 9727, "Miscellaneous Symbols": (o) => o >= 9728 && o <= 9983, "Miscellaneous Symbols and Arrows": (o) => o >= 11008 && o <= 11263, "Ideographic Description Characters": (o) => o >= 12272 && o <= 12287, "CJK Symbols and Punctuation": (o) => o >= 12288 && o <= 12351, Hiragana: (o) => o >= 12352 && o <= 12447, Katakana: (o) => o >= 12448 && o <= 12543, Kanbun: (o) => o >= 12688 && o <= 12703, "CJK Strokes": (o) => o >= 12736 && o <= 12783, "Enclosed CJK Letters and Months": (o) => o >= 12800 && o <= 13055, "CJK Compatibility": (o) => o >= 13056 && o <= 13311, "Yijing Hexagram Symbols": (o) => o >= 19904 && o <= 19967, "CJK Unified Ideographs": (o) => o >= 19968 && o <= 40959, "Hangul Syllables": (o) => o >= 44032 && o <= 55215, "Private Use Area": (o) => o >= 57344 && o <= 63743, "Vertical Forms": (o) => o >= 65040 && o <= 65055, "CJK Compatibility Forms": (o) => o >= 65072 && o <= 65103, "Small Form Variants": (o) => o >= 65104 && o <= 65135, "Halfwidth and Fullwidth Forms": (o) => o >= 65280 && o <= 65519 };
        function Zc(o) {
          for (const t of o) if (Xc(t.charCodeAt(0))) return true;
          return false;
        }
        function qh(o) {
          for (const t of o) if (!Wh(t.charCodeAt(0))) return false;
          return true;
        }
        function Hc(o) {
          const t = o.map(((n) => {
            try {
              return new RegExp(`\\p{sc=${n}}`, "u").source;
            } catch {
              return null;
            }
          })).filter(((n) => n));
          return new RegExp(t.join("|"), "u");
        }
        const Gh = Hc(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
        function Wh(o) {
          return !Gh.test(String.fromCodePoint(o));
        }
        const Zh = Hc(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
        function Xc(o) {
          return !(o !== 746 && o !== 747 && (o < 4352 || !(kr["CJK Compatibility Forms"](o) && !(o >= 65097 && o <= 65103) || kr["CJK Compatibility"](o) || kr["CJK Strokes"](o) || !(!kr["CJK Symbols and Punctuation"](o) || o >= 12296 && o <= 12305 || o >= 12308 && o <= 12319 || o === 12336) || kr["Enclosed CJK Letters and Months"](o) || kr["Ideographic Description Characters"](o) || kr.Kanbun(o) || kr.Katakana(o) && o !== 12540 || !(!kr["Halfwidth and Fullwidth Forms"](o) || o === 65288 || o === 65289 || o === 65293 || o >= 65306 && o <= 65310 || o === 65339 || o === 65341 || o === 65343 || o >= 65371 && o <= 65503 || o === 65507 || o >= 65512 && o <= 65519) || !(!kr["Small Form Variants"](o) || o >= 65112 && o <= 65118 || o >= 65123 && o <= 65126) || kr["Vertical Forms"](o) || kr["Yijing Hexagram Symbols"](o) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(o)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(o)) || Zh.test(String.fromCodePoint(o)))));
        }
        function Yc(o) {
          return !(Xc(o) || (function(t) {
            return !!(kr["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || kr["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || kr["Letterlike Symbols"](t) || kr["Number Forms"](t) || kr["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || kr["Control Pictures"](t) && t !== 9251 || kr["Optical Character Recognition"](t) || kr["Enclosed Alphanumerics"](t) || kr["Geometric Shapes"](t) || kr["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || kr["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || kr["CJK Symbols and Punctuation"](t) || kr.Katakana(t) || kr["Private Use Area"](t) || kr["CJK Compatibility Forms"](t) || kr["Small Form Variants"](t) || kr["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533);
          })(o));
        }
        const Hh = Hc(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
        function Kc(o) {
          return Hh.test(String.fromCodePoint(o));
        }
        function Xh(o, t) {
          return !(!t && Kc(o) || o >= 2304 && o <= 3583 || o >= 3840 && o <= 4255 || kr.Khmer(o));
        }
        function cu(o) {
          for (const t of o) if (Kc(t.charCodeAt(0))) return true;
          return false;
        }
        const na = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
            };
          }
          setState(o) {
            this.pluginStatus = o.pluginStatus, this.pluginURL = o.pluginURL;
          }
          getState() {
            return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
          }
          setMethods(o) {
            if (na.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = o.applyArabicShaping, this.processBidirectionalText = o.processBidirectionalText, this.processStyledBidirectionalText = o.processStyledBidirectionalText, this.loadScriptResolve();
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
          syncState(o, t) {
            return s(this, void 0, void 0, (function* () {
              if (this.isParsed()) return this.getState();
              if (o.pluginStatus !== "loading") return this.setState(o), o;
              const n = o.pluginURL, u = new Promise(((_) => {
                this.loadScriptResolve = _;
              }));
              t(n);
              const h = new Promise(((_) => setTimeout((() => _()), this.TIMEOUT)));
              if (yield Promise.race([u, h]), this.isParsed()) {
                const _ = { pluginStatus: "loaded", pluginURL: n };
                return this.setState(_), _;
              }
              throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${n}`);
            }));
          }
        }();
        class qr {
          constructor(t, n) {
            this.isSupportedScript = jp, this.zoom = t, n ? (this.now = n.now || 0, this.fadeDuration = n.fadeDuration || 0, this.zoomHistory = n.zoomHistory || new Wc(), this.transition = n.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Wc(), this.transition = {});
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const t = this.zoom, n = t - Math.floor(t), u = this.crossFadingFactor();
            return t > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: n + (1 - n) * u } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - u) * n };
          }
        }
        function jp(o) {
          return (function(t, n) {
            for (const u of t) if (!Xh(u.charCodeAt(0), n)) return false;
            return true;
          })(o, na.getRTLTextPluginStatus() === "loaded");
        }
        class du {
          constructor(t, n, u) {
            this.property = t, this.value = n, this.expression = (function(h, _, b) {
              if (Ws(h)) return new Xs(h, _);
              if (eu(h)) {
                const w = Ah(h, _, b);
                if (w.result === "error") throw new Error(w.value.map(((S) => `${S.key}: ${S.message}`)).join(", "));
                return w.value;
              }
              {
                let w = h;
                return _.type === "color" && typeof h == "string" ? w = br.parse(h) : _.type !== "padding" || typeof h != "number" && !Array.isArray(h) ? _.type !== "numberArray" || typeof h != "number" && !Array.isArray(h) ? _.type !== "colorArray" || typeof h != "string" && !Array.isArray(h) ? _.type === "variableAnchorOffsetCollection" && Array.isArray(h) ? w = gn.parse(h) : _.type === "projectionDefinition" && typeof h == "string" && (w = nn.parse(h)) : w = Mi.parse(h) : w = mn.parse(h) : w = ji.parse(h), { globalStateRefs: /* @__PURE__ */ new Set(), _globalState: null, kind: "constant", evaluate: () => w };
              }
            })(n === void 0 ? t.specification.default : n, t.specification, u);
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite";
          }
          getGlobalStateRefs() {
            return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
          }
          possiblyEvaluate(t, n, u) {
            return this.property.possiblyEvaluate(this, t, n, u);
          }
        }
        class hu {
          constructor(t, n) {
            this.property = t, this.value = new du(t, void 0, n);
          }
          transitioned(t, n) {
            return new Qc(this.property, this.value, n, Qt({}, t.transition, this.transition), t.now);
          }
          untransitioned() {
            return new Qc(this.property, this.value, null, {}, 0);
          }
        }
        class Jc {
          constructor(t, n) {
            this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues), this._globalState = n;
          }
          getValue(t) {
            return rr(this._values[t].value.value);
          }
          setValue(t, n) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new hu(this._values[t].property, this._globalState)), this._values[t].value = new du(this._values[t].property, n === null ? void 0 : rr(n), this._globalState);
          }
          getTransition(t) {
            return rr(this._values[t].transition);
          }
          setTransition(t, n) {
            Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new hu(this._values[t].property, this._globalState)), this._values[t].transition = rr(n) || void 0;
          }
          serialize() {
            const t = {};
            for (const n of Object.keys(this._values)) {
              const u = this.getValue(n);
              u !== void 0 && (t[n] = u);
              const h = this.getTransition(n);
              h !== void 0 && (t[`${n}-transition`] = h);
            }
            return t;
          }
          transitioned(t, n) {
            const u = new Yh(this._properties);
            for (const h of Object.keys(this._values)) u._values[h] = this._values[h].transitioned(t, n._values[h]);
            return u;
          }
          untransitioned() {
            const t = new Yh(this._properties);
            for (const n of Object.keys(this._values)) t._values[n] = this._values[n].untransitioned();
            return t;
          }
        }
        class Qc {
          constructor(t, n, u, h, _) {
            this.property = t, this.value = n, this.begin = _ + h.delay || 0, this.end = this.begin + h.duration || 0, t.specification.transition && (h.delay || h.duration) && (this.prior = u);
          }
          possiblyEvaluate(t, n, u) {
            const h = t.now || 0, _ = this.value.possiblyEvaluate(t, n, u), b = this.prior;
            if (b) {
              if (h > this.end) return this.prior = null, _;
              if (this.value.isDataDriven()) return this.prior = null, _;
              if (h < this.begin) return b.possiblyEvaluate(t, n, u);
              {
                const w = (h - this.begin) / (this.end - this.begin);
                return this.property.interpolate(b.possiblyEvaluate(t, n, u), _, ut(w));
              }
            }
            return _;
          }
        }
        class Yh {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t, n, u) {
            const h = new fu(this._properties);
            for (const _ of Object.keys(this._values)) h._values[_] = this._values[_].possiblyEvaluate(t, n, u);
            return h;
          }
          hasTransition() {
            for (const t of Object.keys(this._values)) if (this._values[t].prior) return true;
            return false;
          }
        }
        class Np {
          constructor(t, n) {
            this._properties = t, this._values = Object.create(t.defaultPropertyValues), this._globalState = n;
          }
          hasValue(t) {
            return this._values[t].value !== void 0;
          }
          getValue(t) {
            return rr(this._values[t].value);
          }
          setValue(t, n) {
            this._values[t] = new du(this._values[t].property, n === null ? void 0 : rr(n), this._globalState);
          }
          serialize() {
            const t = {};
            for (const n of Object.keys(this._values)) {
              const u = this.getValue(n);
              u !== void 0 && (t[n] = u);
            }
            return t;
          }
          possiblyEvaluate(t, n, u) {
            const h = new fu(this._properties);
            for (const _ of Object.keys(this._values)) h._values[_] = this._values[_].possiblyEvaluate(t, n, u);
            return h;
          }
        }
        class So {
          constructor(t, n, u) {
            this.property = t, this.value = n, this.parameters = u;
          }
          isConstant() {
            return this.value.kind === "constant";
          }
          constantOr(t) {
            return this.value.kind === "constant" ? this.value.value : t;
          }
          evaluate(t, n, u, h) {
            return this.property.evaluate(this.value, this.parameters, t, n, u, h);
          }
        }
        class fu {
          constructor(t) {
            this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);
          }
          get(t) {
            return this._values[t];
          }
        }
        class qt {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, n) {
            if (t.isDataDriven()) throw new Error("Value should not be data driven");
            return t.expression.evaluate(n);
          }
          interpolate(t, n, u) {
            const h = Co[this.specification.type];
            return h ? h(t, n, u) : t;
          }
        }
        class Xt {
          constructor(t, n) {
            this.specification = t, this.overrides = n;
          }
          possiblyEvaluate(t, n, u, h) {
            return new So(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? { kind: "constant", value: t.expression.evaluate(n, null, {}, u, h) } : t.expression, n);
          }
          interpolate(t, n, u) {
            if (t.value.kind !== "constant" || n.value.kind !== "constant") return t;
            if (t.value.value === void 0 || n.value.value === void 0) return new So(this, { kind: "constant", value: void 0 }, t.parameters);
            const h = Co[this.specification.type];
            if (h) {
              const _ = h(t.value.value, n.value.value, u);
              return new So(this, { kind: "constant", value: _ }, t.parameters);
            }
            return t;
          }
          evaluate(t, n, u, h, _, b) {
            return t.kind === "constant" ? t.value : t.evaluate(n, u, h, _, b);
          }
        }
        class pu extends Xt {
          possiblyEvaluate(t, n, u, h) {
            if (t.value === void 0) return new So(this, { kind: "constant", value: void 0 }, n);
            if (t.expression.kind === "constant") {
              const _ = t.expression.evaluate(n, null, {}, u, h), b = t.property.specification.type === "resolvedImage" && typeof _ != "string" ? _.name : _, w = this._calculate(b, b, b, n);
              return new So(this, { kind: "constant", value: w }, n);
            }
            if (t.expression.kind === "camera") {
              const _ = this._calculate(t.expression.evaluate({ zoom: n.zoom - 1 }), t.expression.evaluate({ zoom: n.zoom }), t.expression.evaluate({ zoom: n.zoom + 1 }), n);
              return new So(this, { kind: "constant", value: _ }, n);
            }
            return new So(this, t.expression, n);
          }
          evaluate(t, n, u, h, _, b) {
            if (t.kind === "source") {
              const w = t.evaluate(n, u, h, _, b);
              return this._calculate(w, w, w, n);
            }
            return t.kind === "composite" ? this._calculate(t.evaluate({ zoom: Math.floor(n.zoom) - 1 }, u, h), t.evaluate({ zoom: Math.floor(n.zoom) }, u, h), t.evaluate({ zoom: Math.floor(n.zoom) + 1 }, u, h), n) : t.value;
          }
          _calculate(t, n, u, h) {
            return h.zoom > h.zoomHistory.lastIntegerZoom ? { from: t, to: n } : { from: u, to: n };
          }
          interpolate(t) {
            return t;
          }
        }
        class ed {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, n, u, h) {
            if (t.value !== void 0) {
              if (t.expression.kind === "constant") {
                const _ = t.expression.evaluate(n, null, {}, u, h);
                return this._calculate(_, _, _, n);
              }
              return this._calculate(t.expression.evaluate(new qr(Math.floor(n.zoom - 1), n)), t.expression.evaluate(new qr(Math.floor(n.zoom), n)), t.expression.evaluate(new qr(Math.floor(n.zoom + 1), n)), n);
            }
          }
          _calculate(t, n, u, h) {
            return h.zoom > h.zoomHistory.lastIntegerZoom ? { from: t, to: n } : { from: u, to: n };
          }
          interpolate(t) {
            return t;
          }
        }
        class mu {
          constructor(t) {
            this.specification = t;
          }
          possiblyEvaluate(t, n, u, h) {
            return !!t.expression.evaluate(n, null, {}, u, h);
          }
          interpolate() {
            return false;
          }
        }
        class an {
          constructor(t) {
            this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const n in t) {
              const u = t[n];
              u.specification.overridable && this.overridableProperties.push(n);
              const h = this.defaultPropertyValues[n] = new du(u, void 0, void 0), _ = this.defaultTransitionablePropertyValues[n] = new hu(u, void 0);
              this.defaultTransitioningPropertyValues[n] = _.untransitioned(), this.defaultPossiblyEvaluatedValues[n] = h.possiblyEvaluate({});
            }
          }
        }
        Lt("DataDrivenProperty", Xt), Lt("DataConstantProperty", qt), Lt("CrossFadedDataDrivenProperty", pu), Lt("CrossFadedProperty", ed), Lt("ColorRampProperty", mu);
        const Kh = "-transition";
        class no extends xt {
          constructor(t, n, u) {
            if (super(), this.id = t.id, this.type = t.type, this._globalState = u, this._featureFilter = { filter: () => true, needGeometry: false, getGlobalStateRefs: () => /* @__PURE__ */ new Set() }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter, this._featureFilter = Aa(t.filter, u)), n.layout && (this._unevaluatedLayout = new Np(n.layout, u)), n.paint)) {
              this._transitionablePaint = new Jc(n.paint, u);
              for (const h in t.paint) this.setPaintProperty(h, t.paint[h], { validate: false });
              for (const h in t.layout) this.setLayoutProperty(h, t.layout[h], { validate: false });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new fu(n.paint);
            }
          }
          setFilter(t) {
            this.filter = t, this._featureFilter = Aa(t, this._globalState);
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(t) {
            return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t);
          }
          getLayoutAffectingGlobalStateRefs() {
            const t = /* @__PURE__ */ new Set();
            if (this._unevaluatedLayout) for (const n in this._unevaluatedLayout._values) {
              const u = this._unevaluatedLayout._values[n];
              for (const h of u.getGlobalStateRefs()) t.add(h);
            }
            for (const n of this._featureFilter.getGlobalStateRefs()) t.add(n);
            return t;
          }
          getPaintAffectingGlobalStateRefs() {
            var t;
            const n = new globalThis.Map();
            if (this._transitionablePaint) for (const u in this._transitionablePaint._values) {
              const h = this._transitionablePaint._values[u].value;
              for (const _ of h.getGlobalStateRefs()) {
                const b = (t = n.get(_)) !== null && t !== void 0 ? t : [];
                b.push({ name: u, value: h.value }), n.set(_, b);
              }
            }
            return n;
          }
          setLayoutProperty(t, n, u = {}) {
            n != null && this._validate(lu, `layers.${this.id}.layout.${t}`, t, n, u) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, n) : this.visibility = n);
          }
          getPaintProperty(t) {
            return t.endsWith(Kh) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t);
          }
          setPaintProperty(t, n, u = {}) {
            if (n != null && this._validate($p, `layers.${this.id}.paint.${t}`, t, n, u)) return false;
            if (t.endsWith(Kh)) return this._transitionablePaint.setTransition(t.slice(0, -11), n || void 0), false;
            {
              const h = this._transitionablePaint._values[t], _ = h.property.specification["property-type"] === "cross-faded-data-driven", b = h.value.isDataDriven(), w = h.value;
              this._transitionablePaint.setValue(t, n), this._handleSpecialPaintPropertyUpdate(t);
              const S = this._transitionablePaint._values[t].value;
              return S.isDataDriven() || b || _ || this._handleOverridablePaintPropertyUpdate(t, w, S);
            }
          }
          _handleSpecialPaintPropertyUpdate(t) {
          }
          _handleOverridablePaintPropertyUpdate(t, n, u) {
            return false;
          }
          isHidden(t) {
            return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none";
          }
          updateTransitions(t) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t, n) {
            t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, n)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, n);
          }
          serialize() {
            const t = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), Mr(t, ((n, u) => !(n === void 0 || u === "layout" && !Object.keys(n).length || u === "paint" && !Object.keys(n).length)));
          }
          _validate(t, n, u, h, _ = {}) {
            return (!_ || _.validate !== false) && Uh(this, t.call(ls, { key: n, layerType: this.type, objectKey: u, value: h, styleSpec: Te, style: { glyphs: true, sprite: true } }));
          }
          is3D() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          resize() {
          }
          isStateDependent() {
            for (const t in this.paint._values) {
              const n = this.paint.get(t);
              if (n instanceof So && ra(n.property.specification) && (n.value.kind === "source" || n.value.kind === "composite") && n.value.isStateDependent) return true;
            }
            return false;
          }
        }
        const Oa = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class cs {
          constructor(t, n) {
            this._structArray = t, this._pos1 = n * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class di {
          constructor() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          }
          static serialize(t, n) {
            return t._trim(), n && (t.isTransferred = true, n.push(t.arrayBuffer)), { length: t.length, arrayBuffer: t.arrayBuffer };
          }
          static deserialize(t) {
            const n = Object.create(this.prototype);
            return n.arrayBuffer = t.arrayBuffer, n.length = t.length, n.capacity = t.arrayBuffer.byteLength / n.bytesPerElement, n._refreshViews(), n;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t) {
            this.reserve(t), this.length = t;
          }
          reserve(t) {
            if (t > this.capacity) {
              this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const n = this.uint8;
              this._refreshViews(), n && this.uint8.set(n);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function wi(o, t = 1) {
          let n = 0, u = 0;
          return { members: o.map(((h) => {
            const _ = Oa[h.type].BYTES_PER_ELEMENT, b = n = gu(n, Math.max(t, _)), w = h.components || 1;
            return u = Math.max(u, _), n += _ * w, { name: h.name, type: h.type, components: w, offset: b };
          })), size: gu(n, Math.max(u, t)), alignment: t };
        }
        function gu(o, t) {
          return Math.ceil(o / t) * t;
        }
        class rl extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n);
          }
          emplace(t, n, u) {
            const h = 2 * t;
            return this.int16[h + 0] = n, this.int16[h + 1] = u, t;
          }
        }
        rl.prototype.bytesPerElement = 4, Lt("StructArrayLayout2i4", rl);
        class $a extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, t, n, u);
          }
          emplace(t, n, u, h) {
            const _ = 3 * t;
            return this.int16[_ + 0] = n, this.int16[_ + 1] = u, this.int16[_ + 2] = h, t;
          }
        }
        $a.prototype.bytesPerElement = 6, Lt("StructArrayLayout3i6", $a);
        class ja extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, n, u, h);
          }
          emplace(t, n, u, h, _) {
            const b = 4 * t;
            return this.int16[b + 0] = n, this.int16[b + 1] = u, this.int16[b + 2] = h, this.int16[b + 3] = _, t;
          }
        }
        ja.prototype.bytesPerElement = 8, Lt("StructArrayLayout4i8", ja);
        class td extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, _, b) {
            const w = this.length;
            return this.resize(w + 1), this.emplace(w, t, n, u, h, _, b);
          }
          emplace(t, n, u, h, _, b, w) {
            const S = 6 * t;
            return this.int16[S + 0] = n, this.int16[S + 1] = u, this.int16[S + 2] = h, this.int16[S + 3] = _, this.int16[S + 4] = b, this.int16[S + 5] = w, t;
          }
        }
        td.prototype.bytesPerElement = 12, Lt("StructArrayLayout2i4i12", td);
        class vu extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, _, b) {
            const w = this.length;
            return this.resize(w + 1), this.emplace(w, t, n, u, h, _, b);
          }
          emplace(t, n, u, h, _, b, w) {
            const S = 4 * t, I = 8 * t;
            return this.int16[S + 0] = n, this.int16[S + 1] = u, this.uint8[I + 4] = h, this.uint8[I + 5] = _, this.uint8[I + 6] = b, this.uint8[I + 7] = w, t;
          }
        }
        vu.prototype.bytesPerElement = 8, Lt("StructArrayLayout2i4ub8", vu);
        class Lo extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n);
          }
          emplace(t, n, u) {
            const h = 2 * t;
            return this.float32[h + 0] = n, this.float32[h + 1] = u, t;
          }
        }
        Lo.prototype.bytesPerElement = 8, Lt("StructArrayLayout2f8", Lo);
        class rd extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, _, b, w, S, I, R) {
            const B = this.length;
            return this.resize(B + 1), this.emplace(B, t, n, u, h, _, b, w, S, I, R);
          }
          emplace(t, n, u, h, _, b, w, S, I, R, B) {
            const N = 10 * t;
            return this.uint16[N + 0] = n, this.uint16[N + 1] = u, this.uint16[N + 2] = h, this.uint16[N + 3] = _, this.uint16[N + 4] = b, this.uint16[N + 5] = w, this.uint16[N + 6] = S, this.uint16[N + 7] = I, this.uint16[N + 8] = R, this.uint16[N + 9] = B, t;
          }
        }
        rd.prototype.bytesPerElement = 20, Lt("StructArrayLayout10ui20", rd);
        class id extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, _, b, w, S, I, R, B, N) {
            const q = this.length;
            return this.resize(q + 1), this.emplace(q, t, n, u, h, _, b, w, S, I, R, B, N);
          }
          emplace(t, n, u, h, _, b, w, S, I, R, B, N, q) {
            const G = 12 * t;
            return this.int16[G + 0] = n, this.int16[G + 1] = u, this.int16[G + 2] = h, this.int16[G + 3] = _, this.uint16[G + 4] = b, this.uint16[G + 5] = w, this.uint16[G + 6] = S, this.uint16[G + 7] = I, this.int16[G + 8] = R, this.int16[G + 9] = B, this.int16[G + 10] = N, this.int16[G + 11] = q, t;
          }
        }
        id.prototype.bytesPerElement = 24, Lt("StructArrayLayout4i4ui4i24", id);
        class _u extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, t, n, u);
          }
          emplace(t, n, u, h) {
            const _ = 3 * t;
            return this.float32[_ + 0] = n, this.float32[_ + 1] = u, this.float32[_ + 2] = h, t;
          }
        }
        _u.prototype.bytesPerElement = 12, Lt("StructArrayLayout3f12", _u);
        class nd extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t);
          }
          emplace(t, n) {
            return this.uint32[1 * t + 0] = n, t;
          }
        }
        nd.prototype.bytesPerElement = 4, Lt("StructArrayLayout1ul4", nd);
        class v extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, _, b, w, S, I) {
            const R = this.length;
            return this.resize(R + 1), this.emplace(R, t, n, u, h, _, b, w, S, I);
          }
          emplace(t, n, u, h, _, b, w, S, I, R) {
            const B = 10 * t, N = 5 * t;
            return this.int16[B + 0] = n, this.int16[B + 1] = u, this.int16[B + 2] = h, this.int16[B + 3] = _, this.int16[B + 4] = b, this.int16[B + 5] = w, this.uint32[N + 3] = S, this.uint16[B + 8] = I, this.uint16[B + 9] = R, t;
          }
        }
        v.prototype.bytesPerElement = 20, Lt("StructArrayLayout6i1ul2ui20", v);
        class e extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, _, b) {
            const w = this.length;
            return this.resize(w + 1), this.emplace(w, t, n, u, h, _, b);
          }
          emplace(t, n, u, h, _, b, w) {
            const S = 6 * t;
            return this.int16[S + 0] = n, this.int16[S + 1] = u, this.int16[S + 2] = h, this.int16[S + 3] = _, this.int16[S + 4] = b, this.int16[S + 5] = w, t;
          }
        }
        e.prototype.bytesPerElement = 12, Lt("StructArrayLayout2i2i2i12", e);
        class a extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, _) {
            const b = this.length;
            return this.resize(b + 1), this.emplace(b, t, n, u, h, _);
          }
          emplace(t, n, u, h, _, b) {
            const w = 4 * t, S = 8 * t;
            return this.float32[w + 0] = n, this.float32[w + 1] = u, this.float32[w + 2] = h, this.int16[S + 6] = _, this.int16[S + 7] = b, t;
          }
        }
        a.prototype.bytesPerElement = 16, Lt("StructArrayLayout2f1f2i16", a);
        class c extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, _, b) {
            const w = this.length;
            return this.resize(w + 1), this.emplace(w, t, n, u, h, _, b);
          }
          emplace(t, n, u, h, _, b, w) {
            const S = 16 * t, I = 4 * t, R = 8 * t;
            return this.uint8[S + 0] = n, this.uint8[S + 1] = u, this.float32[I + 1] = h, this.float32[I + 2] = _, this.int16[R + 6] = b, this.int16[R + 7] = w, t;
          }
        }
        c.prototype.bytesPerElement = 16, Lt("StructArrayLayout2ub2f2i16", c);
        class p extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, t, n, u);
          }
          emplace(t, n, u, h) {
            const _ = 3 * t;
            return this.uint16[_ + 0] = n, this.uint16[_ + 1] = u, this.uint16[_ + 2] = h, t;
          }
        }
        p.prototype.bytesPerElement = 6, Lt("StructArrayLayout3ui6", p);
        class y extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, _, b, w, S, I, R, B, N, q, G, Q, ae, pe) {
            const Oe = this.length;
            return this.resize(Oe + 1), this.emplace(Oe, t, n, u, h, _, b, w, S, I, R, B, N, q, G, Q, ae, pe);
          }
          emplace(t, n, u, h, _, b, w, S, I, R, B, N, q, G, Q, ae, pe, Oe) {
            const Ce = 24 * t, Ie = 12 * t, He = 48 * t;
            return this.int16[Ce + 0] = n, this.int16[Ce + 1] = u, this.uint16[Ce + 2] = h, this.uint16[Ce + 3] = _, this.uint32[Ie + 2] = b, this.uint32[Ie + 3] = w, this.uint32[Ie + 4] = S, this.uint16[Ce + 10] = I, this.uint16[Ce + 11] = R, this.uint16[Ce + 12] = B, this.float32[Ie + 7] = N, this.float32[Ie + 8] = q, this.uint8[He + 36] = G, this.uint8[He + 37] = Q, this.uint8[He + 38] = ae, this.uint32[Ie + 10] = pe, this.int16[Ce + 22] = Oe, t;
          }
        }
        y.prototype.bytesPerElement = 48, Lt("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", y);
        class x extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h, _, b, w, S, I, R, B, N, q, G, Q, ae, pe, Oe, Ce, Ie, He, rt, _t, At, kt, Et, Wt, Mt) {
            const Rt = this.length;
            return this.resize(Rt + 1), this.emplace(Rt, t, n, u, h, _, b, w, S, I, R, B, N, q, G, Q, ae, pe, Oe, Ce, Ie, He, rt, _t, At, kt, Et, Wt, Mt);
          }
          emplace(t, n, u, h, _, b, w, S, I, R, B, N, q, G, Q, ae, pe, Oe, Ce, Ie, He, rt, _t, At, kt, Et, Wt, Mt, Rt) {
            const ct = 32 * t, or = 16 * t;
            return this.int16[ct + 0] = n, this.int16[ct + 1] = u, this.int16[ct + 2] = h, this.int16[ct + 3] = _, this.int16[ct + 4] = b, this.int16[ct + 5] = w, this.int16[ct + 6] = S, this.int16[ct + 7] = I, this.uint16[ct + 8] = R, this.uint16[ct + 9] = B, this.uint16[ct + 10] = N, this.uint16[ct + 11] = q, this.uint16[ct + 12] = G, this.uint16[ct + 13] = Q, this.uint16[ct + 14] = ae, this.uint16[ct + 15] = pe, this.uint16[ct + 16] = Oe, this.uint16[ct + 17] = Ce, this.uint16[ct + 18] = Ie, this.uint16[ct + 19] = He, this.uint16[ct + 20] = rt, this.uint16[ct + 21] = _t, this.uint16[ct + 22] = At, this.uint32[or + 12] = kt, this.float32[or + 13] = Et, this.float32[or + 14] = Wt, this.uint16[ct + 30] = Mt, this.uint16[ct + 31] = Rt, t;
          }
        }
        x.prototype.bytesPerElement = 64, Lt("StructArrayLayout8i15ui1ul2f2ui64", x);
        class k extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t);
          }
          emplace(t, n) {
            return this.float32[1 * t + 0] = n, t;
          }
        }
        k.prototype.bytesPerElement = 4, Lt("StructArrayLayout1f4", k);
        class P extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, t, n, u);
          }
          emplace(t, n, u, h) {
            const _ = 3 * t;
            return this.uint16[6 * t + 0] = n, this.float32[_ + 1] = u, this.float32[_ + 2] = h, t;
          }
        }
        P.prototype.bytesPerElement = 12, Lt("StructArrayLayout1ui2f12", P);
        class E extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, t, n, u);
          }
          emplace(t, n, u, h) {
            const _ = 4 * t;
            return this.uint32[2 * t + 0] = n, this.uint16[_ + 2] = u, this.uint16[_ + 3] = h, t;
          }
        }
        E.prototype.bytesPerElement = 8, Lt("StructArrayLayout1ul2ui8", E);
        class D extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t, n) {
            const u = this.length;
            return this.resize(u + 1), this.emplace(u, t, n);
          }
          emplace(t, n, u) {
            const h = 2 * t;
            return this.uint16[h + 0] = n, this.uint16[h + 1] = u, t;
          }
        }
        D.prototype.bytesPerElement = 4, Lt("StructArrayLayout2ui4", D);
        class j extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t) {
            const n = this.length;
            return this.resize(n + 1), this.emplace(n, t);
          }
          emplace(t, n) {
            return this.uint16[1 * t + 0] = n, t;
          }
        }
        j.prototype.bytesPerElement = 2, Lt("StructArrayLayout1ui2", j);
        class $ extends di {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t, n, u, h) {
            const _ = this.length;
            return this.resize(_ + 1), this.emplace(_, t, n, u, h);
          }
          emplace(t, n, u, h, _) {
            const b = 4 * t;
            return this.float32[b + 0] = n, this.float32[b + 1] = u, this.float32[b + 2] = h, this.float32[b + 3] = _, t;
          }
        }
        $.prototype.bytesPerElement = 16, Lt("StructArrayLayout4f16", $);
        class U extends cs {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new C(this.anchorPointX, this.anchorPointY);
          }
        }
        U.prototype.size = 20;
        class Y extends v {
          get(t) {
            return new U(this, t);
          }
        }
        Lt("CollisionBoxArray", Y);
        class se extends cs {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(t) {
            this._structArray.uint8[this._pos1 + 37] = t;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(t) {
            this._structArray.uint8[this._pos1 + 38] = t;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 10] = t;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        se.prototype.size = 48;
        class le extends y {
          get(t) {
            return new se(this, t);
          }
        }
        Lt("PlacedSymbolArray", le);
        class ce extends cs {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(t) {
            this._structArray.uint32[this._pos4 + 12] = t;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        ce.prototype.size = 64;
        class me extends x {
          get(t) {
            return new ce(this, t);
          }
        }
        Lt("SymbolInstanceArray", me);
        class we extends k {
          getoffsetX(t) {
            return this.float32[1 * t + 0];
          }
        }
        Lt("GlyphOffsetArray", we);
        class _e extends $a {
          getx(t) {
            return this.int16[3 * t + 0];
          }
          gety(t) {
            return this.int16[3 * t + 1];
          }
          gettileUnitDistanceFromAnchor(t) {
            return this.int16[3 * t + 2];
          }
        }
        Lt("SymbolLineVertexArray", _e);
        class Pe extends cs {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        Pe.prototype.size = 12;
        class Me extends P {
          get(t) {
            return new Pe(this, t);
          }
        }
        Lt("TextAnchorOffsetArray", Me);
        class ye extends cs {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        ye.prototype.size = 8;
        class Be extends E {
          get(t) {
            return new ye(this, t);
          }
        }
        Lt("FeatureIndexArray", Be);
        class Je extends rl {
        }
        class We extends rl {
        }
        class Ze extends rl {
        }
        class Qe extends td {
        }
        class It extends vu {
        }
        class Pt extends Lo {
        }
        class pt extends rd {
        }
        class Vt extends id {
        }
        class _r extends _u {
        }
        class Or extends nd {
        }
        class hi extends e {
        }
        class ei extends c {
        }
        class Hr extends p {
        }
        class fi extends D {
        }
        const oi = wi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: ti } = oi;
        class Ar {
          constructor(t = []) {
            this._forceNewSegmentOnNextPrepare = false, this.segments = t;
          }
          prepareSegment(t, n, u, h) {
            const _ = this.segments[this.segments.length - 1];
            return t > Ar.MAX_VERTEX_ARRAY_LENGTH && Gt(`Max vertices per segment is ${Ar.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Ar.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !_ || _.vertexLength + t > Ar.MAX_VERTEX_ARRAY_LENGTH || _.sortKey !== h ? this.createNewSegment(n, u, h) : _;
          }
          createNewSegment(t, n, u) {
            const h = { vertexOffset: t.length, primitiveOffset: n.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
            return u !== void 0 && (h.sortKey = u), this._forceNewSegmentOnNextPrepare = false, this.segments.push(h), h;
          }
          getOrCreateLatestSegment(t, n, u) {
            return this.prepareSegment(0, t, n, u);
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = true;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t of this.segments) for (const n in t.vaos) t.vaos[n].destroy();
          }
          static simpleSegment(t, n, u, h) {
            return new Ar([{ vertexOffset: t, primitiveOffset: n, vertexLength: u, primitiveLength: h, vaos: {}, sortKey: 0 }]);
          }
        }
        function Fi(o, t) {
          return 256 * (o = zt(Math.floor(o), 0, 255)) + zt(Math.floor(t), 0, 255);
        }
        Ar.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Lt("SegmentVector", Ar);
        const Ei = wi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
        var _n, oa, aa, oo = { exports: {} }, Na = { exports: {} }, il = { exports: {} }, yu = (function() {
          if (aa) return oo.exports;
          aa = 1;
          var o = (_n || (_n = 1, Na.exports = function(n, u) {
            var h, _, b, w, S, I, R, B;
            for (_ = n.length - (h = 3 & n.length), b = u, S = 3432918353, I = 461845907, B = 0; B < _; ) R = 255 & n.charCodeAt(B) | (255 & n.charCodeAt(++B)) << 8 | (255 & n.charCodeAt(++B)) << 16 | (255 & n.charCodeAt(++B)) << 24, ++B, b = 27492 + (65535 & (w = 5 * (65535 & (b = (b ^= R = (65535 & (R = (R = (65535 & R) * S + (((R >>> 16) * S & 65535) << 16) & 4294967295) << 15 | R >>> 17)) * I + (((R >>> 16) * I & 65535) << 16) & 4294967295) << 13 | b >>> 19)) + ((5 * (b >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (w >>> 16) & 65535) << 16);
            switch (R = 0, h) {
              case 3:
                R ^= (255 & n.charCodeAt(B + 2)) << 16;
              case 2:
                R ^= (255 & n.charCodeAt(B + 1)) << 8;
              case 1:
                b ^= R = (65535 & (R = (R = (65535 & (R ^= 255 & n.charCodeAt(B))) * S + (((R >>> 16) * S & 65535) << 16) & 4294967295) << 15 | R >>> 17)) * I + (((R >>> 16) * I & 65535) << 16) & 4294967295;
            }
            return b ^= n.length, b = 2246822507 * (65535 & (b ^= b >>> 16)) + ((2246822507 * (b >>> 16) & 65535) << 16) & 4294967295, b = 3266489909 * (65535 & (b ^= b >>> 13)) + ((3266489909 * (b >>> 16) & 65535) << 16) & 4294967295, (b ^= b >>> 16) >>> 0;
          }), Na.exports), t = (oa || (oa = 1, il.exports = function(n, u) {
            for (var h, _ = n.length, b = u ^ _, w = 0; _ >= 4; ) h = 1540483477 * (65535 & (h = 255 & n.charCodeAt(w) | (255 & n.charCodeAt(++w)) << 8 | (255 & n.charCodeAt(++w)) << 16 | (255 & n.charCodeAt(++w)) << 24)) + ((1540483477 * (h >>> 16) & 65535) << 16), b = 1540483477 * (65535 & b) + ((1540483477 * (b >>> 16) & 65535) << 16) ^ (h = 1540483477 * (65535 & (h ^= h >>> 24)) + ((1540483477 * (h >>> 16) & 65535) << 16)), _ -= 4, ++w;
            switch (_) {
              case 3:
                b ^= (255 & n.charCodeAt(w + 2)) << 16;
              case 2:
                b ^= (255 & n.charCodeAt(w + 1)) << 8;
              case 1:
                b = 1540483477 * (65535 & (b ^= 255 & n.charCodeAt(w))) + ((1540483477 * (b >>> 16) & 65535) << 16);
            }
            return b = 1540483477 * (65535 & (b ^= b >>> 13)) + ((1540483477 * (b >>> 16) & 65535) << 16), (b ^= b >>> 15) >>> 0;
          }), il.exports);
          return oo.exports = o, oo.exports.murmur3 = o, oo.exports.murmur2 = t, oo.exports;
        })(), sa = T(yu);
        class yn {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = false;
          }
          add(t, n, u, h) {
            this.ids.push(Bo(t)), this.positions.push(n, u, h);
          }
          getPositions(t) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const n = Bo(t);
            let u = 0, h = this.ids.length - 1;
            for (; u < h; ) {
              const b = u + h >> 1;
              this.ids[b] >= n ? h = b : u = b + 1;
            }
            const _ = [];
            for (; this.ids[u] === n; ) _.push({ index: this.positions[3 * u], start: this.positions[3 * u + 1], end: this.positions[3 * u + 2] }), u++;
            return _;
          }
          static serialize(t, n) {
            const u = new Float64Array(t.ids), h = new Uint32Array(t.positions);
            return Oo(u, h, 0, u.length - 1), n && n.push(u.buffer, h.buffer), { ids: u, positions: h };
          }
          static deserialize(t) {
            const n = new yn();
            return n.ids = t.ids, n.positions = t.positions, n.indexed = true, n;
          }
        }
        function Bo(o) {
          const t = +o;
          return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : sa(String(o));
        }
        function Oo(o, t, n, u) {
          for (; n < u; ) {
            const h = o[n + u >> 1];
            let _ = n - 1, b = u + 1;
            for (; ; ) {
              do
                _++;
              while (o[_] < h);
              do
                b--;
              while (o[b] > h);
              if (_ >= b) break;
              la(o, _, b), la(t, 3 * _, 3 * b), la(t, 3 * _ + 1, 3 * b + 1), la(t, 3 * _ + 2, 3 * b + 2);
            }
            b - n < u - b ? (Oo(o, t, n, b), n = b + 1) : (Oo(o, t, b + 1, u), u = b);
          }
        }
        function la(o, t, n) {
          const u = o[t];
          o[t] = o[n], o[n] = u;
        }
        Lt("FeaturePositionMap", yn);
        class ai {
          constructor(t, n) {
            this.gl = t.gl, this.location = n;
          }
        }
        class ki extends ai {
          constructor(t, n) {
            super(t, n), this.current = 0;
          }
          set(t) {
            this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t));
          }
        }
        class Bn extends ai {
          constructor(t, n) {
            super(t, n), this.current = [0, 0, 0, 0];
          }
          set(t) {
            t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));
          }
        }
        class Li extends ai {
          constructor(t, n) {
            super(t, n), this.current = br.transparent;
          }
          set(t) {
            t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));
          }
        }
        const Vp = new Float32Array(16);
        function od(o) {
          return [Fi(255 * o.r, 255 * o.g), Fi(255 * o.b, 255 * o.a)];
        }
        class nl {
          constructor(t, n, u) {
            this.value = t, this.uniformNames = n.map(((h) => `u_${h}`)), this.type = u;
          }
          setUniform(t, n, u) {
            t.set(u.constantOr(this.value));
          }
          getBinding(t, n, u) {
            return this.type === "color" ? new Li(t, n) : new ki(t, n);
          }
        }
        class ds {
          constructor(t, n) {
            this.uniformNames = n.map(((u) => `u_${u}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(t, n) {
            this.pixelRatioFrom = n.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = n.tlbr, this.patternTo = t.tlbr;
          }
          setUniform(t, n, u, h) {
            const _ = h === "u_pattern_to" ? this.patternTo : h === "u_pattern_from" ? this.patternFrom : h === "u_pixel_ratio_to" ? this.pixelRatioTo : h === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
            _ && t.set(_);
          }
          getBinding(t, n, u) {
            return u.substr(0, 9) === "u_pattern" ? new Bn(t, n) : new ki(t, n);
          }
        }
        class $o {
          constructor(t, n, u, h) {
            this.expression = t, this.type = u, this.maxValue = 0, this.paintVertexAttributes = n.map(((_) => ({ name: `a_${_}`, type: "Float32", components: u === "color" ? 2 : 1, offset: 0 }))), this.paintVertexArray = new h();
          }
          populatePaintArray(t, n, u) {
            const h = this.paintVertexArray.length, _ = this.expression.evaluate(new qr(0, u), n, {}, u.canonical, [], u.formattedSection);
            this.paintVertexArray.resize(t), this._setPaintValue(h, t, _);
          }
          updatePaintArray(t, n, u, h, _) {
            const b = this.expression.evaluate(new qr(0, _), u, h);
            this._setPaintValue(t, n, b);
          }
          _setPaintValue(t, n, u) {
            if (this.type === "color") {
              const h = od(u);
              for (let _ = t; _ < n; _++) this.paintVertexArray.emplace(_, h[0], h[1]);
            } else {
              for (let h = t; h < n; h++) this.paintVertexArray.emplace(h, u);
              this.maxValue = Math.max(this.maxValue, Math.abs(u));
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class ao {
          constructor(t, n, u, h, _, b) {
            this.expression = t, this.uniformNames = n.map(((w) => `u_${w}_t`)), this.type = u, this.useIntegerZoom = h, this.zoom = _, this.maxValue = 0, this.paintVertexAttributes = n.map(((w) => ({ name: `a_${w}`, type: "Float32", components: u === "color" ? 4 : 2, offset: 0 }))), this.paintVertexArray = new b();
          }
          populatePaintArray(t, n, u) {
            const h = this.expression.evaluate(new qr(this.zoom, u), n, {}, u.canonical, [], u.formattedSection), _ = this.expression.evaluate(new qr(this.zoom + 1, u), n, {}, u.canonical, [], u.formattedSection), b = this.paintVertexArray.length;
            this.paintVertexArray.resize(t), this._setPaintValue(b, t, h, _);
          }
          updatePaintArray(t, n, u, h, _) {
            const b = this.expression.evaluate(new qr(this.zoom, _), u, h), w = this.expression.evaluate(new qr(this.zoom + 1, _), u, h);
            this._setPaintValue(t, n, b, w);
          }
          _setPaintValue(t, n, u, h) {
            if (this.type === "color") {
              const _ = od(u), b = od(h);
              for (let w = t; w < n; w++) this.paintVertexArray.emplace(w, _[0], _[1], b[0], b[1]);
            } else {
              for (let _ = t; _ < n; _++) this.paintVertexArray.emplace(_, u, h);
              this.maxValue = Math.max(this.maxValue, Math.abs(u), Math.abs(h));
            }
          }
          upload(t) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t, n) {
            const u = this.useIntegerZoom ? Math.floor(n.zoom) : n.zoom, h = zt(this.expression.interpolationFactor(u, this.zoom, this.zoom + 1), 0, 1);
            t.set(h);
          }
          getBinding(t, n, u) {
            return new ki(t, n);
          }
        }
        class Tn {
          constructor(t, n, u, h, _, b) {
            this.expression = t, this.type = n, this.useIntegerZoom = u, this.zoom = h, this.layerId = b, this.zoomInPaintVertexArray = new _(), this.zoomOutPaintVertexArray = new _();
          }
          populatePaintArray(t, n, u) {
            const h = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(h, t, n.patterns && n.patterns[this.layerId], u.imagePositions);
          }
          updatePaintArray(t, n, u, h, _) {
            this._setPaintValues(t, n, u.patterns && u.patterns[this.layerId], _.imagePositions);
          }
          _setPaintValues(t, n, u, h) {
            if (!h || !u) return;
            const { min: _, mid: b, max: w } = u, S = h[_], I = h[b], R = h[w];
            if (S && I && R) for (let B = t; B < n; B++) this.zoomInPaintVertexArray.emplace(B, I.tl[0], I.tl[1], I.br[0], I.br[1], S.tl[0], S.tl[1], S.br[0], S.br[1], I.pixelRatio, S.pixelRatio), this.zoomOutPaintVertexArray.emplace(B, I.tl[0], I.tl[1], I.br[0], I.br[1], R.tl[0], R.tl[1], R.br[0], R.br[1], I.pixelRatio, R.pixelRatio);
          }
          upload(t) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, Ei.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, Ei.members, this.expression.isStateDependent));
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class ad {
          constructor(t, n, u) {
            this.binders = {}, this._buffers = [];
            const h = [];
            for (const _ in t.paint._values) {
              if (!u(_)) continue;
              const b = t.paint.get(_);
              if (!(b instanceof So && ra(b.property.specification))) continue;
              const w = Jh(_, t.type), S = b.value, I = b.property.specification.type, R = b.property.useIntegerZoom, B = b.property.specification["property-type"], N = B === "cross-faded" || B === "cross-faded-data-driven";
              if (S.kind === "constant") this.binders[_] = N ? new ds(S.value, w) : new nl(S.value, w, I), h.push(`/u_${_}`);
              else if (S.kind === "source" || N) {
                const q = bu(_, I, "source");
                this.binders[_] = N ? new Tn(S, I, R, n, q, t.id) : new $o(S, w, I, q), h.push(`/a_${_}`);
              } else {
                const q = bu(_, I, "composite");
                this.binders[_] = new ao(S, w, I, R, n, q), h.push(`/z_${_}`);
              }
            }
            this.cacheKey = h.sort().join("");
          }
          getMaxValue(t) {
            const n = this.binders[t];
            return n instanceof $o || n instanceof ao ? n.maxValue : 0;
          }
          populatePaintArrays(t, n, u) {
            for (const h in this.binders) {
              const _ = this.binders[h];
              (_ instanceof $o || _ instanceof ao || _ instanceof Tn) && _.populatePaintArray(t, n, u);
            }
          }
          setConstantPatternPositions(t, n) {
            for (const u in this.binders) {
              const h = this.binders[u];
              h instanceof ds && h.setConstantPatternPositions(t, n);
            }
          }
          updatePaintArrays(t, n, u, h, _) {
            let b = false;
            for (const w in t) {
              const S = n.getPositions(w);
              for (const I of S) {
                const R = u.feature(I.index);
                for (const B in this.binders) {
                  const N = this.binders[B];
                  if ((N instanceof $o || N instanceof ao || N instanceof Tn) && N.expression.isStateDependent === true) {
                    const q = h.paint.get(B);
                    N.expression = q.value, N.updatePaintArray(I.start, I.end, R, t[w], _), b = true;
                  }
                }
              }
            }
            return b;
          }
          defines() {
            const t = [];
            for (const n in this.binders) {
              const u = this.binders[n];
              (u instanceof nl || u instanceof ds) && t.push(...u.uniformNames.map(((h) => `#define HAS_UNIFORM_${h}`)));
            }
            return t;
          }
          getBinderAttributes() {
            const t = [];
            for (const n in this.binders) {
              const u = this.binders[n];
              if (u instanceof $o || u instanceof ao) for (let h = 0; h < u.paintVertexAttributes.length; h++) t.push(u.paintVertexAttributes[h].name);
              else if (u instanceof Tn) for (let h = 0; h < Ei.members.length; h++) t.push(Ei.members[h].name);
            }
            return t;
          }
          getBinderUniforms() {
            const t = [];
            for (const n in this.binders) {
              const u = this.binders[n];
              if (u instanceof nl || u instanceof ds || u instanceof ao) for (const h of u.uniformNames) t.push(h);
            }
            return t;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t, n) {
            const u = [];
            for (const h in this.binders) {
              const _ = this.binders[h];
              if (_ instanceof nl || _ instanceof ds || _ instanceof ao) {
                for (const b of _.uniformNames) if (n[b]) {
                  const w = _.getBinding(t, n[b], b);
                  u.push({ name: b, property: h, binding: w });
                }
              }
            }
            return u;
          }
          setUniforms(t, n, u, h) {
            for (const { name: _, property: b, binding: w } of n) this.binders[b].setUniform(w, h, u.get(b), _);
          }
          updatePaintBuffers(t) {
            this._buffers = [];
            for (const n in this.binders) {
              const u = this.binders[n];
              if (t && u instanceof Tn) {
                const h = t.fromScale === 2 ? u.zoomInPaintVertexBuffer : u.zoomOutPaintVertexBuffer;
                h && this._buffers.push(h);
              } else (u instanceof $o || u instanceof ao) && u.paintVertexBuffer && this._buffers.push(u.paintVertexBuffer);
            }
          }
          upload(t) {
            for (const n in this.binders) {
              const u = this.binders[n];
              (u instanceof $o || u instanceof ao || u instanceof Tn) && u.upload(t);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t in this.binders) {
              const n = this.binders[t];
              (n instanceof $o || n instanceof ao || n instanceof Tn) && n.destroy();
            }
          }
        }
        class ua {
          constructor(t, n, u = () => true) {
            this.programConfigurations = {};
            for (const h of t) this.programConfigurations[h.id] = new ad(h, n, u);
            this.needsUpload = false, this._featureMap = new yn(), this._bufferOffset = 0;
          }
          populatePaintArrays(t, n, u, h) {
            for (const _ in this.programConfigurations) this.programConfigurations[_].populatePaintArrays(t, n, h);
            n.id !== void 0 && this._featureMap.add(n.id, u, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = true;
          }
          updatePaintArrays(t, n, u, h) {
            for (const _ of u) this.needsUpload = this.programConfigurations[_.id].updatePaintArrays(t, this._featureMap, n, _, h) || this.needsUpload;
          }
          get(t) {
            return this.programConfigurations[t];
          }
          upload(t) {
            if (this.needsUpload) {
              for (const n in this.programConfigurations) this.programConfigurations[n].upload(t);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const t in this.programConfigurations) this.programConfigurations[t].destroy();
          }
        }
        function Jh(o, t) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[o] || [o.replace(`${t}-`, "").replace(/-/g, "_")];
        }
        function bu(o, t, n) {
          const u = { color: { source: Lo, composite: $ }, number: { source: k, composite: Lo } }, h = (function(_) {
            return { "line-pattern": { source: pt, composite: pt }, "fill-pattern": { source: pt, composite: pt }, "fill-extrusion-pattern": { source: pt, composite: pt } }[_];
          })(o);
          return h && h[n] || u[t][n];
        }
        Lt("ConstantBinder", nl), Lt("CrossFadedConstantBinder", ds), Lt("SourceExpressionBinder", $o), Lt("CrossFadedCompositeBinder", Tn), Lt("CompositeExpressionBinder", ao), Lt("ProgramConfiguration", ad, { omit: ["_buffers"] }), Lt("ProgramConfigurationSet", ua);
        const xu = Math.pow(2, 14) - 1, wu = -xu - 1;
        function ol(o) {
          const t = et / o.extent, n = o.loadGeometry();
          for (let u = 0; u < n.length; u++) {
            const h = n[u];
            for (let _ = 0; _ < h.length; _++) {
              const b = h[_], w = Math.round(b.x * t), S = Math.round(b.y * t);
              b.x = zt(w, wu, xu), b.y = zt(S, wu, xu), (w < b.x || w > b.x + 1 || S < b.y || S > b.y + 1) && Gt("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return n;
        }
        function al(o, t) {
          return { type: o.type, id: o.id, properties: o.properties, geometry: t ? ol(o) : [] };
        }
        const d0 = -32768;
        function W1(o, t, n, u, h) {
          o.emplaceBack(d0 + 8 * t + u, d0 + 8 * n + h);
        }
        class Up {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((n) => n.id)), this.index = t.index, this.hasPattern = false, this.layoutVertexArray = new We(), this.indexArray = new Hr(), this.segments = new Ar(), this.programConfigurations = new ua(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter(((n) => n.isStateDependent())).map(((n) => n.id));
          }
          populate(t, n, u) {
            const h = this.layers[0], _ = [];
            let b = null, w = false, S = h.type === "heatmap";
            if (h.type === "circle") {
              const R = h;
              b = R.layout.get("circle-sort-key"), w = !b.isConstant(), S = S || R.paint.get("circle-pitch-alignment") === "map";
            }
            const I = S ? n.subdivisionGranularity.circle : 1;
            for (const { feature: R, id: B, index: N, sourceLayerIndex: q } of t) {
              const G = this.layers[0]._featureFilter.needGeometry, Q = al(R, G);
              if (!this.layers[0]._featureFilter.filter(new qr(this.zoom), Q, u)) continue;
              const ae = w ? b.evaluate(Q, {}, u) : void 0, pe = { id: B, properties: R.properties, type: R.type, sourceLayerIndex: q, index: N, geometry: G ? Q.geometry : ol(R), patterns: {}, sortKey: ae };
              _.push(pe);
            }
            w && _.sort(((R, B) => R.sortKey - B.sortKey));
            for (const R of _) {
              const { geometry: B, index: N, sourceLayerIndex: q } = R, G = t[N].feature;
              this.addFeature(R, B, N, u, I), n.featureIndex.insert(G, B, N, q, this.index);
            }
          }
          update(t, n, u) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, { imagePositions: u });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, ti), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t, n, u, h, _ = 1) {
            let b;
            switch (_) {
              case 1:
                b = [0, 7];
                break;
              case 3:
                b = [0, 2, 5, 7];
                break;
              case 5:
                b = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                b = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${_}; valid values are 1, 3, 5, 7.`);
            }
            const w = b.length;
            for (const S of n) for (const I of S) {
              const R = I.x, B = I.y;
              if (R < 0 || R >= et || B < 0 || B >= et) continue;
              const N = this.segments.prepareSegment(w * w, this.layoutVertexArray, this.indexArray, t.sortKey), q = N.vertexLength;
              for (let G = 0; G < w; G++) for (let Q = 0; Q < w; Q++) W1(this.layoutVertexArray, R, B, b[Q], b[G]);
              for (let G = 0; G < w - 1; G++) for (let Q = 0; Q < w - 1; Q++) {
                const ae = q + G * w + Q, pe = q + (G + 1) * w + Q;
                this.indexArray.emplaceBack(ae, pe + 1, ae + 1), this.indexArray.emplaceBack(ae, pe, pe + 1);
              }
              N.vertexLength += w * w, N.primitiveLength += (w - 1) * (w - 1) * 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, u, { imagePositions: {}, canonical: h });
          }
        }
        function h0(o, t) {
          for (let n = 0; n < o.length; n++) if (Cu(t, o[n])) return true;
          for (let n = 0; n < t.length; n++) if (Cu(o, t[n])) return true;
          return !!qp(o, t);
        }
        function Qh(o, t, n) {
          return !!Cu(o, t) || !!Gp(t, o, n);
        }
        function f0(o, t) {
          if (o.length === 1) return m0(t, o[0]);
          for (let n = 0; n < t.length; n++) {
            const u = t[n];
            for (let h = 0; h < u.length; h++) if (Cu(o, u[h])) return true;
          }
          for (let n = 0; n < o.length; n++) if (m0(t, o[n])) return true;
          for (let n = 0; n < t.length; n++) if (qp(o, t[n])) return true;
          return false;
        }
        function Z1(o, t, n) {
          if (o.length > 1) {
            if (qp(o, t)) return true;
            for (let u = 0; u < t.length; u++) if (Gp(t[u], o, n)) return true;
          }
          for (let u = 0; u < o.length; u++) if (Gp(o[u], t, n)) return true;
          return false;
        }
        function qp(o, t) {
          if (o.length === 0 || t.length === 0) return false;
          for (let n = 0; n < o.length - 1; n++) {
            const u = o[n], h = o[n + 1];
            for (let _ = 0; _ < t.length - 1; _++) if (H1(u, h, t[_], t[_ + 1])) return true;
          }
          return false;
        }
        function H1(o, t, n, u) {
          return Dr(o, n, u) !== Dr(t, n, u) && Dr(o, t, n) !== Dr(o, t, u);
        }
        function Gp(o, t, n) {
          const u = n * n;
          if (t.length === 1) return o.distSqr(t[0]) < u;
          for (let h = 1; h < t.length; h++) if (p0(o, t[h - 1], t[h]) < u) return true;
          return false;
        }
        function p0(o, t, n) {
          const u = t.distSqr(n);
          if (u === 0) return o.distSqr(t);
          const h = ((o.x - t.x) * (n.x - t.x) + (o.y - t.y) * (n.y - t.y)) / u;
          return o.distSqr(h < 0 ? t : h > 1 ? n : n.sub(t)._mult(h)._add(t));
        }
        function m0(o, t) {
          let n, u, h, _ = false;
          for (let b = 0; b < o.length; b++) {
            n = o[b];
            for (let w = 0, S = n.length - 1; w < n.length; S = w++) u = n[w], h = n[S], u.y > t.y != h.y > t.y && t.x < (h.x - u.x) * (t.y - u.y) / (h.y - u.y) + u.x && (_ = !_);
          }
          return _;
        }
        function Cu(o, t) {
          let n = false;
          for (let u = 0, h = o.length - 1; u < o.length; h = u++) {
            const _ = o[u], b = o[h];
            _.y > t.y != b.y > t.y && t.x < (b.x - _.x) * (t.y - _.y) / (b.y - _.y) + _.x && (n = !n);
          }
          return n;
        }
        function X1(o, t, n) {
          const u = n[0], h = n[2];
          if (o.x < u.x && t.x < u.x || o.x > h.x && t.x > h.x || o.y < u.y && t.y < u.y || o.y > h.y && t.y > h.y) return false;
          const _ = Dr(o, t, n[0]);
          return _ !== Dr(o, t, n[1]) || _ !== Dr(o, t, n[2]) || _ !== Dr(o, t, n[3]);
        }
        function Su(o, t, n) {
          const u = t.paint.get(o).value;
          return u.kind === "constant" ? u.value : n.programConfigurations.get(t.id).getMaxValue(o);
        }
        function ef(o) {
          return Math.sqrt(o[0] * o[0] + o[1] * o[1]);
        }
        function tf(o, t, n, u, h) {
          if (!t[0] && !t[1]) return o;
          const _ = C.convert(t)._mult(h);
          n === "viewport" && _._rotate(-u);
          const b = [];
          for (let w = 0; w < o.length; w++) b.push(o[w].sub(_));
          return b;
        }
        function Y1({ queryGeometry: o, size: t }, n) {
          return Qh(o, n, t);
        }
        function K1({ queryGeometry: o, size: t, transform: n, unwrappedTileID: u, getElevation: h }, _) {
          return Qh(o, _, t * (n.projectTileCoordinates(_.x, _.y, u, h).signedDistanceFromCamera / n.cameraToCenterDistance));
        }
        function J1({ queryGeometry: o, size: t, transform: n, unwrappedTileID: u, getElevation: h }, _) {
          const b = n.projectTileCoordinates(_.x, _.y, u, h).signedDistanceFromCamera, w = t * (n.cameraToCenterDistance / b);
          return Qh(o, Wp(_, n, u, h), w);
        }
        function Q1({ queryGeometry: o, size: t, transform: n, unwrappedTileID: u, getElevation: h }, _) {
          return Qh(o, Wp(_, n, u, h), t);
        }
        function g0({ queryGeometry: o, size: t, transform: n, unwrappedTileID: u, getElevation: h, pitchAlignment: _ = "map", pitchScale: b = "map" }, w) {
          const S = _ === "map" ? b === "map" ? Y1 : K1 : b === "map" ? J1 : Q1, I = { queryGeometry: o, size: t, transform: n, unwrappedTileID: u, getElevation: h };
          for (const R of w) for (const B of R) if (S(I, B)) return true;
          return false;
        }
        function Wp(o, t, n, u) {
          const h = t.projectTileCoordinates(o.x, o.y, n, u).point;
          return new C((0.5 * h.x + 0.5) * t.width, (0.5 * -h.y + 0.5) * t.height);
        }
        let v0, _0;
        Lt("CircleBucket", Up, { omit: ["layers"] });
        var ex = { get paint() {
          return _0 = _0 || new an({ "circle-radius": new Xt(Te.paint_circle["circle-radius"]), "circle-color": new Xt(Te.paint_circle["circle-color"]), "circle-blur": new Xt(Te.paint_circle["circle-blur"]), "circle-opacity": new Xt(Te.paint_circle["circle-opacity"]), "circle-translate": new qt(Te.paint_circle["circle-translate"]), "circle-translate-anchor": new qt(Te.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new qt(Te.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new qt(Te.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Xt(Te.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Xt(Te.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Xt(Te.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return v0 = v0 || new an({ "circle-sort-key": new Xt(Te.layout_circle["circle-sort-key"]) });
        } };
        class tx extends no {
          constructor(t, n) {
            super(t, ex, n);
          }
          createBucket(t) {
            return new Up(t);
          }
          queryRadius(t) {
            const n = t;
            return Su("circle-radius", this, n) + Su("circle-stroke-width", this, n) + ef(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: u, geometry: h, transform: _, pixelsToTileUnits: b, unwrappedTileID: w, getElevation: S }) {
            const I = tf(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -_.bearingInRadians, b), R = this.paint.get("circle-radius").evaluate(n, u) + this.paint.get("circle-stroke-width").evaluate(n, u), B = this.paint.get("circle-pitch-scale"), N = this.paint.get("circle-pitch-alignment");
            let q, G;
            return N === "map" ? (q = I, G = R * b) : (q = (function(Q, ae, pe, Oe) {
              return Q.map(((Ce) => Wp(Ce, ae, pe, Oe)));
            })(I, _, w, S), G = R), g0({ queryGeometry: q, size: G, transform: _, unwrappedTileID: w, getElevation: S, pitchAlignment: N, pitchScale: B }, h);
          }
        }
        class y0 extends Up {
        }
        let b0;
        Lt("HeatmapBucket", y0, { omit: ["layers"] });
        var rx = { get paint() {
          return b0 = b0 || new an({ "heatmap-radius": new Xt(Te.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Xt(Te.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new qt(Te.paint_heatmap["heatmap-intensity"]), "heatmap-color": new mu(Te.paint_heatmap["heatmap-color"]), "heatmap-opacity": new qt(Te.paint_heatmap["heatmap-opacity"]) });
        } };
        function Zp(o, { width: t, height: n }, u, h) {
          if (h) {
            if (h instanceof Uint8ClampedArray) h = new Uint8Array(h.buffer);
            else if (h.length !== t * n * u) throw new RangeError(`mismatched image size. expected: ${h.length} but got: ${t * n * u}`);
          } else h = new Uint8Array(t * n * u);
          return o.width = t, o.height = n, o.data = h, o;
        }
        function x0(o, { width: t, height: n }, u) {
          if (t === o.width && n === o.height) return;
          const h = Zp({}, { width: t, height: n }, u);
          Hp(o, h, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(o.width, t), height: Math.min(o.height, n) }, u), o.width = t, o.height = n, o.data = h.data;
        }
        function Hp(o, t, n, u, h, _) {
          if (h.width === 0 || h.height === 0) return t;
          if (h.width > o.width || h.height > o.height || n.x > o.width - h.width || n.y > o.height - h.height) throw new RangeError("out of range source coordinates for image copy");
          if (h.width > t.width || h.height > t.height || u.x > t.width - h.width || u.y > t.height - h.height) throw new RangeError("out of range destination coordinates for image copy");
          const b = o.data, w = t.data;
          if (b === w) throw new Error("srcData equals dstData, so image is already copied");
          for (let S = 0; S < h.height; S++) {
            const I = ((n.y + S) * o.width + n.x) * _, R = ((u.y + S) * t.width + u.x) * _;
            for (let B = 0; B < h.width * _; B++) w[R + B] = b[I + B];
          }
          return t;
        }
        class sd {
          constructor(t, n) {
            Zp(this, t, 1, n);
          }
          resize(t) {
            x0(this, t, 1);
          }
          clone() {
            return new sd({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t, n, u, h, _) {
            Hp(t, n, u, h, _, 1);
          }
        }
        class On {
          constructor(t, n) {
            Zp(this, t, 4, n);
          }
          resize(t) {
            x0(this, t, 4);
          }
          replace(t, n) {
            n ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;
          }
          clone() {
            return new On({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t, n, u, h, _) {
            Hp(t, n, u, h, _, 4);
          }
          setPixel(t, n, u) {
            const h = 4 * (t * this.width + n);
            this.data[h + 0] = Math.round(255 * u.r / u.a), this.data[h + 1] = Math.round(255 * u.g / u.a), this.data[h + 2] = Math.round(255 * u.b / u.a), this.data[h + 3] = Math.round(255 * u.a);
          }
        }
        function w0(o) {
          const t = {}, n = o.resolution || 256, u = o.clips ? o.clips.length : 1, h = o.image || new On({ width: n, height: u });
          if (Math.log(n) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${n}`);
          const _ = (b, w, S) => {
            t[o.evaluationKey] = S;
            const I = o.expression.evaluate(t);
            h.setPixel(b / 4 / n, w / 4, I);
          };
          if (o.clips) for (let b = 0, w = 0; b < u; ++b, w += 4 * n) for (let S = 0, I = 0; S < n; S++, I += 4) {
            const R = S / (n - 1), { start: B, end: N } = o.clips[b];
            _(w, I, B * (1 - R) + N * R);
          }
          else for (let b = 0, w = 0; b < n; b++, w += 4) _(0, w, b / (n - 1));
          return h;
        }
        Lt("AlphaImage", sd), Lt("RGBAImage", On);
        const Xp = "big-fb";
        class ix extends no {
          createBucket(t) {
            return new y0(t);
          }
          constructor(t, n) {
            super(t, rx, n), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t) {
            t === "heatmap-color" && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = w0({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbos.has(Xp) && this.heatmapFbos.delete(Xp);
          }
          queryRadius(t) {
            return Su("heatmap-radius", this, t);
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: u, geometry: h, transform: _, pixelsToTileUnits: b, unwrappedTileID: w, getElevation: S }) {
            return g0({ queryGeometry: t, size: this.paint.get("heatmap-radius").evaluate(n, u) * b, transform: _, unwrappedTileID: w, getElevation: S }, h);
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
          }
        }
        let C0;
        var nx = { get paint() {
          return C0 = C0 || new an({ "hillshade-illumination-direction": new qt(Te.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new qt(Te.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new qt(Te.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new qt(Te.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new qt(Te.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new qt(Te.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new qt(Te.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new qt(Te.paint_hillshade["hillshade-method"]) });
        } };
        class ox extends no {
          constructor(t, n) {
            super(t, nx, n), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
          }
          getIlluminationProperties() {
            let t = this.paint.get("hillshade-illumination-direction").values, n = this.paint.get("hillshade-illumination-altitude").values, u = this.paint.get("hillshade-highlight-color").values, h = this.paint.get("hillshade-shadow-color").values;
            const _ = Math.max(t.length, n.length, u.length, h.length);
            t = t.concat(Array(_ - t.length).fill(t.at(-1))), n = n.concat(Array(_ - n.length).fill(n.at(-1))), u = u.concat(Array(_ - u.length).fill(u.at(-1))), h = h.concat(Array(_ - h.length).fill(h.at(-1)));
            const b = n.map(tt);
            return { directionRadians: t.map(tt), altitudeRadians: b, shadowColor: h, highlightColor: u };
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
          }
        }
        let S0;
        var ax = { get paint() {
          return S0 = S0 || new an({ "color-relief-opacity": new qt(Te["paint_color-relief"]["color-relief-opacity"]), "color-relief-color": new mu(Te["paint_color-relief"]["color-relief-color"]) });
        } };
        class Yp {
          constructor(t, n, u, h) {
            this.context = t, this.format = u, this.texture = t.gl.createTexture(), this.update(n, h);
          }
          update(t, n, u) {
            const { width: h, height: _ } = t, b = !(this.size && this.size[0] === h && this.size[1] === _ || u), { context: w } = this, { gl: S } = w;
            if (this.useMipmap = !!(n && n.useMipmap), S.bindTexture(S.TEXTURE_2D, this.texture), w.pixelStoreUnpackFlipY.set(false), w.pixelStoreUnpack.set(1), w.pixelStoreUnpackPremultiplyAlpha.set(this.format === S.RGBA && (!n || n.premultiply !== false)), b) this.size = [h, _], t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || Ee(t) ? S.texImage2D(S.TEXTURE_2D, 0, this.format, this.format, S.UNSIGNED_BYTE, t) : S.texImage2D(S.TEXTURE_2D, 0, this.format, h, _, 0, this.format, S.UNSIGNED_BYTE, t.data);
            else {
              const { x: I, y: R } = u || { x: 0, y: 0 };
              t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || Ee(t) ? S.texSubImage2D(S.TEXTURE_2D, 0, I, R, S.RGBA, S.UNSIGNED_BYTE, t) : S.texSubImage2D(S.TEXTURE_2D, 0, I, R, h, _, S.RGBA, S.UNSIGNED_BYTE, t.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && S.generateMipmap(S.TEXTURE_2D), w.pixelStoreUnpackFlipY.setDefault(), w.pixelStoreUnpack.setDefault(), w.pixelStoreUnpackPremultiplyAlpha.setDefault();
          }
          bind(t, n, u) {
            const { context: h } = this, { gl: _ } = h;
            _.bindTexture(_.TEXTURE_2D, this.texture), u !== _.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (u = _.LINEAR), t !== this.filter && (_.texParameteri(_.TEXTURE_2D, _.TEXTURE_MAG_FILTER, t), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_MIN_FILTER, u || t), this.filter = t), n !== this.wrap && (_.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_S, n), _.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_T, n), this.wrap = n);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: t } = this.context;
            t.deleteTexture(this.texture), this.texture = null;
          }
        }
        class k0 {
          constructor(t, n, u, h = 1, _ = 1, b = 1, w = 0) {
            if (this.uid = t, n.height !== n.width) throw new RangeError("DEM tiles must be square");
            if (u && !["mapbox", "terrarium", "custom"].includes(u)) return void Gt(`"${u}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = n.height;
            const S = this.dim = n.height - 2;
            switch (this.data = new Uint32Array(n.data.buffer), u) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = h, this.greenFactor = _, this.blueFactor = b, this.baseShift = w;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let I = 0; I < S; I++) this.data[this._idx(-1, I)] = this.data[this._idx(0, I)], this.data[this._idx(S, I)] = this.data[this._idx(S - 1, I)], this.data[this._idx(I, -1)] = this.data[this._idx(I, 0)], this.data[this._idx(I, S)] = this.data[this._idx(I, S - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(S, -1)] = this.data[this._idx(S - 1, 0)], this.data[this._idx(-1, S)] = this.data[this._idx(0, S - 1)], this.data[this._idx(S, S)] = this.data[this._idx(S - 1, S - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let I = 0; I < S; I++) for (let R = 0; R < S; R++) {
              const B = this.get(I, R);
              B > this.max && (this.max = B), B < this.min && (this.min = B);
            }
          }
          get(t, n) {
            const u = new Uint8Array(this.data.buffer), h = 4 * this._idx(t, n);
            return this.unpack(u[h], u[h + 1], u[h + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(t, n) {
            if (t < -1 || t >= this.dim + 1 || n < -1 || n >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (n + 1) * this.stride + (t + 1);
          }
          unpack(t, n, u) {
            return t * this.redFactor + n * this.greenFactor + u * this.blueFactor - this.baseShift;
          }
          pack(t) {
            return P0(t, this.getUnpackVector());
          }
          getPixels() {
            return new On({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(t, n, u) {
            if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
            let h = n * this.dim, _ = n * this.dim + this.dim, b = u * this.dim, w = u * this.dim + this.dim;
            switch (n) {
              case -1:
                h = _ - 1;
                break;
              case 1:
                _ = h + 1;
            }
            switch (u) {
              case -1:
                b = w - 1;
                break;
              case 1:
                w = b + 1;
            }
            const S = -n * this.dim, I = -u * this.dim;
            for (let R = b; R < w; R++) for (let B = h; B < _; B++) this.data[this._idx(B, R)] = t.data[this._idx(B + S, R + I)];
          }
        }
        function P0(o, t) {
          const n = t[0], u = t[1], h = t[2], _ = t[3], b = Math.min(n, u, h), w = Math.round((o + _) / b);
          return { r: Math.floor(w * b / n) % 256, g: Math.floor(w * b / u) % 256, b: Math.floor(w * b / h) % 256 };
        }
        Lt("DEMData", k0);
        class sx extends no {
          constructor(t, n) {
            super(t, ax, n);
          }
          _createColorRamp(t) {
            const n = { elevationStops: [], colorStops: [] }, u = this._transitionablePaint._values["color-relief-color"].value.expression;
            if (u instanceof Hs && u._styleExpression.expression instanceof Hi) {
              this.colorRampExpression = u;
              const b = u._styleExpression.expression;
              n.elevationStops = b.labels, n.colorStops = [];
              for (const w of n.elevationStops) n.colorStops.push(b.evaluate({ globals: { elevation: w } }));
            }
            if (n.elevationStops.length < 1 && (n.elevationStops = [0], n.colorStops = [br.transparent]), n.elevationStops.length < 2 && (n.elevationStops.push(n.elevationStops[0] + 1), n.colorStops.push(n.colorStops[0])), n.elevationStops.length <= t) return n;
            const h = { elevationStops: [], colorStops: [] }, _ = (n.elevationStops.length - 1) / (t - 1);
            for (let b = 0; b < n.elevationStops.length - 0.5; b += _) h.elevationStops.push(n.elevationStops[Math.round(b)]), h.colorStops.push(n.colorStops[Math.round(b)]);
            return Gt(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`), h;
          }
          _colorRampChanged() {
            return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
          }
          getColorRampTextures(t, n, u) {
            if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
            const h = this._createColorRamp(n), _ = new On({ width: h.colorStops.length, height: 1 }), b = new On({ width: h.colorStops.length, height: 1 });
            for (let w = 0; w < h.elevationStops.length; w++) {
              const S = P0(h.elevationStops[w], u);
              b.setPixel(0, w, new br(S.r / 255, S.g / 255, S.b / 255, 1)), _.setPixel(0, w, h.colorStops[w]);
            }
            return this.colorRampTextures = { elevationTexture: new Yp(t, b, t.gl.RGBA), colorTexture: new Yp(t, _, t.gl.RGBA) }, this.colorRampTextures;
          }
          hasOffscreenPass() {
            return this.visibility !== "none" && !!this.colorRampTextures;
          }
        }
        const lx = wi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: ux } = lx;
        function Kp(o, t, n) {
          const u = n.patternDependencies;
          let h = false;
          for (const _ of t) {
            const b = _.paint.get(`${o}-pattern`);
            b.isConstant() || (h = true);
            const w = b.constantOr(null);
            w && (h = true, u[w.to] = true, u[w.from] = true);
          }
          return h;
        }
        function Jp(o, t, n, u, h) {
          const { zoom: _ } = u, b = h.patternDependencies;
          for (const w of t) {
            const S = w.paint.get(`${o}-pattern`).value;
            if (S.kind !== "constant") {
              let I = S.evaluate({ zoom: _ - 1 }, n, {}, h.availableImages), R = S.evaluate({ zoom: _ }, n, {}, h.availableImages), B = S.evaluate({ zoom: _ + 1 }, n, {}, h.availableImages);
              I = I && I.name ? I.name : I, R = R && R.name ? R.name : R, B = B && B.name ? B.name : B, b[I] = true, b[R] = true, b[B] = true, n.patterns[w.id] = { min: I, mid: R, max: B };
            }
          }
          return n;
        }
        function T0(o, t, n, u, h) {
          let _;
          if (h === (function(b, w, S, I) {
            let R = 0;
            for (let B = w, N = S - I; B < S; B += I) R += (b[N] - b[B]) * (b[B + 1] + b[N + 1]), N = B;
            return R;
          })(o, t, n, u) > 0) for (let b = t; b < n; b += u) _ = R0(b / u | 0, o[b], o[b + 1], _);
          else for (let b = n - u; b >= t; b -= u) _ = R0(b / u | 0, o[b], o[b + 1], _);
          return _ && ku(_, _.next) && (dd(_), _ = _.next), _;
        }
        function sl(o, t) {
          if (!o) return o;
          t || (t = o);
          let n, u = o;
          do
            if (n = false, u.steiner || !ku(u, u.next) && Pi(u.prev, u, u.next) !== 0) u = u.next;
            else {
              if (dd(u), u = t = u.prev, u === u.next) break;
              n = true;
            }
          while (n || u !== t);
          return t;
        }
        function ld(o, t, n, u, h, _, b) {
          if (!o) return;
          !b && _ && (function(S, I, R, B) {
            let N = S;
            do
              N.z === 0 && (N.z = Qp(N.x, N.y, I, R, B)), N.prevZ = N.prev, N.nextZ = N.next, N = N.next;
            while (N !== S);
            N.prevZ.nextZ = null, N.prevZ = null, (function(q) {
              let G, Q = 1;
              do {
                let ae, pe = q;
                q = null;
                let Oe = null;
                for (G = 0; pe; ) {
                  G++;
                  let Ce = pe, Ie = 0;
                  for (let rt = 0; rt < Q && (Ie++, Ce = Ce.nextZ, Ce); rt++) ;
                  let He = Q;
                  for (; Ie > 0 || He > 0 && Ce; ) Ie !== 0 && (He === 0 || !Ce || pe.z <= Ce.z) ? (ae = pe, pe = pe.nextZ, Ie--) : (ae = Ce, Ce = Ce.nextZ, He--), Oe ? Oe.nextZ = ae : q = ae, ae.prevZ = Oe, Oe = ae;
                  pe = Ce;
                }
                Oe.nextZ = null, Q *= 2;
              } while (G > 1);
            })(N);
          })(o, u, h, _);
          let w = o;
          for (; o.prev !== o.next; ) {
            const S = o.prev, I = o.next;
            if (_ ? dx(o, u, h, _) : cx(o)) t.push(S.i, o.i, I.i), dd(o), o = I.next, w = I.next;
            else if ((o = I) === w) {
              b ? b === 1 ? ld(o = hx(sl(o), t), t, n, u, h, _, 2) : b === 2 && fx(o, t, n, u, h, _) : ld(sl(o), t, n, u, h, _, 1);
              break;
            }
          }
        }
        function cx(o) {
          const t = o.prev, n = o, u = o.next;
          if (Pi(t, n, u) >= 0) return false;
          const h = t.x, _ = n.x, b = u.x, w = t.y, S = n.y, I = u.y, R = Math.min(h, _, b), B = Math.min(w, S, I), N = Math.max(h, _, b), q = Math.max(w, S, I);
          let G = u.next;
          for (; G !== t; ) {
            if (G.x >= R && G.x <= N && G.y >= B && G.y <= q && ud(h, w, _, S, b, I, G.x, G.y) && Pi(G.prev, G, G.next) >= 0) return false;
            G = G.next;
          }
          return true;
        }
        function dx(o, t, n, u) {
          const h = o.prev, _ = o, b = o.next;
          if (Pi(h, _, b) >= 0) return false;
          const w = h.x, S = _.x, I = b.x, R = h.y, B = _.y, N = b.y, q = Math.min(w, S, I), G = Math.min(R, B, N), Q = Math.max(w, S, I), ae = Math.max(R, B, N), pe = Qp(q, G, t, n, u), Oe = Qp(Q, ae, t, n, u);
          let Ce = o.prevZ, Ie = o.nextZ;
          for (; Ce && Ce.z >= pe && Ie && Ie.z <= Oe; ) {
            if (Ce.x >= q && Ce.x <= Q && Ce.y >= G && Ce.y <= ae && Ce !== h && Ce !== b && ud(w, R, S, B, I, N, Ce.x, Ce.y) && Pi(Ce.prev, Ce, Ce.next) >= 0 || (Ce = Ce.prevZ, Ie.x >= q && Ie.x <= Q && Ie.y >= G && Ie.y <= ae && Ie !== h && Ie !== b && ud(w, R, S, B, I, N, Ie.x, Ie.y) && Pi(Ie.prev, Ie, Ie.next) >= 0)) return false;
            Ie = Ie.nextZ;
          }
          for (; Ce && Ce.z >= pe; ) {
            if (Ce.x >= q && Ce.x <= Q && Ce.y >= G && Ce.y <= ae && Ce !== h && Ce !== b && ud(w, R, S, B, I, N, Ce.x, Ce.y) && Pi(Ce.prev, Ce, Ce.next) >= 0) return false;
            Ce = Ce.prevZ;
          }
          for (; Ie && Ie.z <= Oe; ) {
            if (Ie.x >= q && Ie.x <= Q && Ie.y >= G && Ie.y <= ae && Ie !== h && Ie !== b && ud(w, R, S, B, I, N, Ie.x, Ie.y) && Pi(Ie.prev, Ie, Ie.next) >= 0) return false;
            Ie = Ie.nextZ;
          }
          return true;
        }
        function hx(o, t) {
          let n = o;
          do {
            const u = n.prev, h = n.next.next;
            !ku(u, h) && M0(u, n, n.next, h) && cd(u, h) && cd(h, u) && (t.push(u.i, n.i, h.i), dd(n), dd(n.next), n = o = h), n = n.next;
          } while (n !== o);
          return sl(n);
        }
        function fx(o, t, n, u, h, _) {
          let b = o;
          do {
            let w = b.next.next;
            for (; w !== b.prev; ) {
              if (b.i !== w.i && _x(b, w)) {
                let S = E0(b, w);
                return b = sl(b, b.next), S = sl(S, S.next), ld(b, t, n, u, h, _, 0), void ld(S, t, n, u, h, _, 0);
              }
              w = w.next;
            }
            b = b.next;
          } while (b !== o);
        }
        function px(o, t) {
          let n = o.x - t.x;
          return n === 0 && (n = o.y - t.y, n === 0) && (n = (o.next.y - o.y) / (o.next.x - o.x) - (t.next.y - t.y) / (t.next.x - t.x)), n;
        }
        function mx(o, t) {
          const n = (function(h, _) {
            let b = _;
            const w = h.x, S = h.y;
            let I, R = -1 / 0;
            if (ku(h, b)) return b;
            do {
              if (ku(h, b.next)) return b.next;
              if (S <= b.y && S >= b.next.y && b.next.y !== b.y) {
                const Q = b.x + (S - b.y) * (b.next.x - b.x) / (b.next.y - b.y);
                if (Q <= w && Q > R && (R = Q, I = b.x < b.next.x ? b : b.next, Q === w)) return I;
              }
              b = b.next;
            } while (b !== _);
            if (!I) return null;
            const B = I, N = I.x, q = I.y;
            let G = 1 / 0;
            b = I;
            do {
              if (w >= b.x && b.x >= N && w !== b.x && I0(S < q ? w : R, S, N, q, S < q ? R : w, S, b.x, b.y)) {
                const Q = Math.abs(S - b.y) / (w - b.x);
                cd(b, h) && (Q < G || Q === G && (b.x > I.x || b.x === I.x && gx(I, b))) && (I = b, G = Q);
              }
              b = b.next;
            } while (b !== B);
            return I;
          })(o, t);
          if (!n) return t;
          const u = E0(n, o);
          return sl(u, u.next), sl(n, n.next);
        }
        function gx(o, t) {
          return Pi(o.prev, o, t.prev) < 0 && Pi(t.next, o, o.next) < 0;
        }
        function Qp(o, t, n, u, h) {
          return (o = 1431655765 & ((o = 858993459 & ((o = 252645135 & ((o = 16711935 & ((o = (o - n) * h | 0) | o << 8)) | o << 4)) | o << 2)) | o << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - u) * h | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
        }
        function vx(o) {
          let t = o, n = o;
          do
            (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next;
          while (t !== o);
          return n;
        }
        function I0(o, t, n, u, h, _, b, w) {
          return (h - b) * (t - w) >= (o - b) * (_ - w) && (o - b) * (u - w) >= (n - b) * (t - w) && (n - b) * (_ - w) >= (h - b) * (u - w);
        }
        function ud(o, t, n, u, h, _, b, w) {
          return !(o === b && t === w) && I0(o, t, n, u, h, _, b, w);
        }
        function _x(o, t) {
          return o.next.i !== t.i && o.prev.i !== t.i && !(function(n, u) {
            let h = n;
            do {
              if (h.i !== n.i && h.next.i !== n.i && h.i !== u.i && h.next.i !== u.i && M0(h, h.next, n, u)) return true;
              h = h.next;
            } while (h !== n);
            return false;
          })(o, t) && (cd(o, t) && cd(t, o) && (function(n, u) {
            let h = n, _ = false;
            const b = (n.x + u.x) / 2, w = (n.y + u.y) / 2;
            do
              h.y > w != h.next.y > w && h.next.y !== h.y && b < (h.next.x - h.x) * (w - h.y) / (h.next.y - h.y) + h.x && (_ = !_), h = h.next;
            while (h !== n);
            return _;
          })(o, t) && (Pi(o.prev, o, t.prev) || Pi(o, t.prev, t)) || ku(o, t) && Pi(o.prev, o, o.next) > 0 && Pi(t.prev, t, t.next) > 0);
        }
        function Pi(o, t, n) {
          return (t.y - o.y) * (n.x - t.x) - (t.x - o.x) * (n.y - t.y);
        }
        function ku(o, t) {
          return o.x === t.x && o.y === t.y;
        }
        function M0(o, t, n, u) {
          const h = nf(Pi(o, t, n)), _ = nf(Pi(o, t, u)), b = nf(Pi(n, u, o)), w = nf(Pi(n, u, t));
          return h !== _ && b !== w || !(h !== 0 || !rf(o, n, t)) || !(_ !== 0 || !rf(o, u, t)) || !(b !== 0 || !rf(n, o, u)) || !(w !== 0 || !rf(n, t, u));
        }
        function rf(o, t, n) {
          return t.x <= Math.max(o.x, n.x) && t.x >= Math.min(o.x, n.x) && t.y <= Math.max(o.y, n.y) && t.y >= Math.min(o.y, n.y);
        }
        function nf(o) {
          return o > 0 ? 1 : o < 0 ? -1 : 0;
        }
        function cd(o, t) {
          return Pi(o.prev, o, o.next) < 0 ? Pi(o, t, o.next) >= 0 && Pi(o, o.prev, t) >= 0 : Pi(o, t, o.prev) < 0 || Pi(o, o.next, t) < 0;
        }
        function E0(o, t) {
          const n = em(o.i, o.x, o.y), u = em(t.i, t.x, t.y), h = o.next, _ = t.prev;
          return o.next = t, t.prev = o, n.next = h, h.prev = n, u.next = n, n.prev = u, _.next = u, u.prev = _, u;
        }
        function R0(o, t, n, u) {
          const h = em(o, t, n);
          return u ? (h.next = u.next, h.prev = u, u.next.prev = h, u.next = h) : (h.prev = h, h.next = h), h;
        }
        function dd(o) {
          o.next.prev = o.prev, o.prev.next = o.next, o.prevZ && (o.prevZ.nextZ = o.nextZ), o.nextZ && (o.nextZ.prevZ = o.prevZ);
        }
        function em(o, t, n) {
          return { i: o, x: t, y: n, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
        }
        class Pu {
          constructor(t, n) {
            if (n > t) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t, this._minGranularity = n;
          }
          getGranularityForZoomLevel(t) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1);
          }
        }
        class of {
          constructor(t) {
            this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle;
          }
        }
        of.noSubdivision = new of({ fill: new Pu(0, 0), line: new Pu(0, 0), tile: new Pu(0, 0), stencil: new Pu(0, 0), circle: 1 }), Lt("SubdivisionGranularityExpression", Pu), Lt("SubdivisionGranularitySetting", of);
        const Tu = -32768, hd = 32767;
        class yx {
          constructor(t, n) {
            this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = false, this._granularity = t, this._granularityCellSize = et / t, this._canonical = n;
          }
          _getKey(t, n) {
            return (t += 32768) << 16 | n + 32768;
          }
          _vertexToIndex(t, n) {
            if (t < -32768 || n < -32768 || t > 32767 || n > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const u = 0 | Math.round(t), h = 0 | Math.round(n), _ = this._getKey(u, h);
            if (this._vertexDictionary.has(_)) return this._vertexDictionary.get(_);
            const b = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(_, b), this._vertexBuffer.push(u, h), b;
          }
          _subdivideTrianglesScanline(t) {
            if (this._granularity < 2) return (function(h, _) {
              const b = [];
              for (let w = 0; w < _.length; w += 3) {
                const S = _[w], I = _[w + 1], R = _[w + 2], B = h[2 * S], N = h[2 * S + 1];
                (h[2 * I] - B) * (h[2 * R + 1] - N) - (h[2 * I + 1] - N) * (h[2 * R] - B) > 0 ? (b.push(S), b.push(R), b.push(I)) : (b.push(S), b.push(I), b.push(R));
              }
              return b;
            })(this._vertexBuffer, t);
            const n = [], u = t.length;
            for (let h = 0; h < u; h += 3) {
              const _ = [t[h + 0], t[h + 1], t[h + 2]], b = [this._vertexBuffer[2 * t[h + 0] + 0], this._vertexBuffer[2 * t[h + 0] + 1], this._vertexBuffer[2 * t[h + 1] + 0], this._vertexBuffer[2 * t[h + 1] + 1], this._vertexBuffer[2 * t[h + 2] + 0], this._vertexBuffer[2 * t[h + 2] + 1]];
              let w = 1 / 0, S = 1 / 0, I = -1 / 0, R = -1 / 0;
              for (let Q = 0; Q < 3; Q++) {
                const ae = b[2 * Q], pe = b[2 * Q + 1];
                w = Math.min(w, ae), I = Math.max(I, ae), S = Math.min(S, pe), R = Math.max(R, pe);
              }
              if (w === I || S === R) continue;
              const B = Math.floor(w / this._granularityCellSize), N = Math.ceil(I / this._granularityCellSize), q = Math.floor(S / this._granularityCellSize), G = Math.ceil(R / this._granularityCellSize);
              if (B !== N || q !== G) for (let Q = q; Q < G; Q++) {
                const ae = this._scanlineGenerateVertexRingForCellRow(Q, b, _);
                bx(this._vertexBuffer, ae, n);
              }
              else n.push(..._);
            }
            return n;
          }
          _scanlineGenerateVertexRingForCellRow(t, n, u) {
            const h = t * this._granularityCellSize, _ = h + this._granularityCellSize, b = [];
            for (let w = 0; w < 3; w++) {
              const S = n[2 * w], I = n[2 * w + 1], R = n[2 * (w + 1) % 6], B = n[(2 * (w + 1) + 1) % 6], N = n[2 * (w + 2) % 6], q = n[(2 * (w + 2) + 1) % 6], G = R - S, Q = B - I, ae = G === 0, pe = Q === 0, Oe = (h - I) / Q, Ce = (_ - I) / Q, Ie = Math.min(Oe, Ce), He = Math.max(Oe, Ce);
              if (!pe && (Ie >= 1 || He <= 0) || pe && (I < h || I > _)) {
                B >= h && B <= _ && b.push(u[(w + 1) % 3]);
                continue;
              }
              !pe && Ie > 0 && b.push(this._vertexToIndex(S + G * Ie, I + Q * Ie));
              const rt = S + G * Math.max(Ie, 0), _t = S + G * Math.min(He, 1);
              ae || this._generateIntraEdgeVertices(b, S, I, R, B, rt, _t), !pe && He < 1 && b.push(this._vertexToIndex(S + G * He, I + Q * He)), (pe || B >= h && B <= _) && b.push(u[(w + 1) % 3]), !pe && (B <= h || B >= _) && this._generateInterEdgeVertices(b, S, I, R, B, N, q, _t, h, _);
            }
            return b;
          }
          _generateIntraEdgeVertices(t, n, u, h, _, b, w) {
            const S = h - n, I = _ - u, R = I === 0, B = R ? Math.min(n, h) : Math.min(b, w), N = R ? Math.max(n, h) : Math.max(b, w), q = Math.floor(B / this._granularityCellSize) + 1, G = Math.ceil(N / this._granularityCellSize) - 1;
            if (R ? n < h : b < w) for (let Q = q; Q <= G; Q++) {
              const ae = Q * this._granularityCellSize;
              t.push(this._vertexToIndex(ae, u + I * (ae - n) / S));
            }
            else for (let Q = G; Q >= q; Q--) {
              const ae = Q * this._granularityCellSize;
              t.push(this._vertexToIndex(ae, u + I * (ae - n) / S));
            }
          }
          _generateInterEdgeVertices(t, n, u, h, _, b, w, S, I, R) {
            const B = _ - u, N = b - h, q = w - _, G = (I - _) / q, Q = (R - _) / q, ae = Math.min(G, Q), pe = Math.max(G, Q), Oe = h + N * ae;
            let Ce = Math.floor(Math.min(Oe, S) / this._granularityCellSize) + 1, Ie = Math.ceil(Math.max(Oe, S) / this._granularityCellSize) - 1, He = S < Oe;
            const rt = q === 0;
            if (rt && (w === I || w === R)) return;
            if (rt || ae >= 1 || pe <= 0) {
              const At = u - w, kt = b + (n - b) * Math.min((I - w) / At, (R - w) / At);
              Ce = Math.floor(Math.min(kt, S) / this._granularityCellSize) + 1, Ie = Math.ceil(Math.max(kt, S) / this._granularityCellSize) - 1, He = S < kt;
            }
            const _t = B > 0 ? R : I;
            if (He) for (let At = Ce; At <= Ie; At++) t.push(this._vertexToIndex(At * this._granularityCellSize, _t));
            else for (let At = Ie; At >= Ce; At--) t.push(this._vertexToIndex(At * this._granularityCellSize, _t));
          }
          _generateOutline(t) {
            const n = [];
            for (const u of t) {
              const h = ll(u, this._granularity, true), _ = this._pointArrayToIndices(h), b = [];
              for (let w = 1; w < _.length; w++) b.push(_[w - 1]), b.push(_[w]);
              n.push(b);
            }
            return n;
          }
          _handlePoles(t) {
            let n = false, u = false;
            this._canonical && (this._canonical.y === 0 && (n = true), this._canonical.y === (1 << this._canonical.z) - 1 && (u = true)), (n || u) && this._fillPoles(t, n, u);
          }
          _ensureNoPoleVertices() {
            const t = this._vertexBuffer;
            for (let n = 0; n < t.length; n += 2) {
              const u = t[n + 1];
              u === Tu && (t[n + 1] = -32767), u === hd && (t[n + 1] = 32766);
            }
          }
          _generatePoleQuad(t, n, u, h, _, b) {
            h > _ != (b === Tu) ? (t.push(n), t.push(u), t.push(this._vertexToIndex(h, b)), t.push(u), t.push(this._vertexToIndex(_, b)), t.push(this._vertexToIndex(h, b))) : (t.push(u), t.push(n), t.push(this._vertexToIndex(h, b)), t.push(this._vertexToIndex(_, b)), t.push(u), t.push(this._vertexToIndex(h, b)));
          }
          _fillPoles(t, n, u) {
            const h = this._vertexBuffer, _ = et, b = t.length;
            for (let w = 2; w < b; w += 3) {
              const S = t[w - 2], I = t[w - 1], R = t[w], B = h[2 * S], N = h[2 * S + 1], q = h[2 * I], G = h[2 * I + 1], Q = h[2 * R], ae = h[2 * R + 1];
              n && (N === 0 && G === 0 && this._generatePoleQuad(t, S, I, B, q, Tu), G === 0 && ae === 0 && this._generatePoleQuad(t, I, R, q, Q, Tu), ae === 0 && N === 0 && this._generatePoleQuad(t, R, S, Q, B, Tu)), u && (N === _ && G === _ && this._generatePoleQuad(t, S, I, B, q, hd), G === _ && ae === _ && this._generatePoleQuad(t, I, R, q, Q, hd), ae === _ && N === _ && this._generatePoleQuad(t, R, S, Q, B, hd));
            }
          }
          _initializeVertices(t) {
            for (let n = 0; n < t.length; n += 2) this._vertexToIndex(t[n], t[n + 1]);
          }
          subdividePolygonInternal(t, n) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = true;
            const { flattened: u, holeIndices: h } = (function(w) {
              const S = [], I = [];
              for (const R of w) if (R.length !== 0) {
                R !== w[0] && S.push(I.length / 2);
                for (let B = 0; B < R.length; B++) I.push(R[B].x), I.push(R[B].y);
              }
              return { flattened: I, holeIndices: S };
            })(t);
            let _;
            this._initializeVertices(u);
            try {
              const w = (function(I, R, B = 2) {
                const N = R && R.length, q = N ? R[0] * B : I.length;
                let G = T0(I, 0, q, B, true);
                const Q = [];
                if (!G || G.next === G.prev) return Q;
                let ae, pe, Oe;
                if (N && (G = (function(Ce, Ie, He, rt) {
                  const _t = [];
                  for (let At = 0, kt = Ie.length; At < kt; At++) {
                    const Et = T0(Ce, Ie[At] * rt, At < kt - 1 ? Ie[At + 1] * rt : Ce.length, rt, false);
                    Et === Et.next && (Et.steiner = true), _t.push(vx(Et));
                  }
                  _t.sort(px);
                  for (let At = 0; At < _t.length; At++) He = mx(_t[At], He);
                  return He;
                })(I, R, G, B)), I.length > 80 * B) {
                  ae = I[0], pe = I[1];
                  let Ce = ae, Ie = pe;
                  for (let He = B; He < q; He += B) {
                    const rt = I[He], _t = I[He + 1];
                    rt < ae && (ae = rt), _t < pe && (pe = _t), rt > Ce && (Ce = rt), _t > Ie && (Ie = _t);
                  }
                  Oe = Math.max(Ce - ae, Ie - pe), Oe = Oe !== 0 ? 32767 / Oe : 0;
                }
                return ld(G, Q, B, ae, pe, Oe, 0), Q;
              })(u, h), S = this._convertIndices(u, w);
              _ = this._subdivideTrianglesScanline(S);
            } catch (w) {
              console.error(w);
            }
            let b = [];
            return n && (b = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(_), { verticesFlattened: this._vertexBuffer, indicesTriangles: _, indicesLineList: b };
          }
          _convertIndices(t, n) {
            const u = [];
            for (let h = 0; h < n.length; h++) u.push(this._vertexToIndex(t[2 * n[h]], t[2 * n[h] + 1]));
            return u;
          }
          _pointArrayToIndices(t) {
            const n = [];
            for (let u = 0; u < t.length; u++) {
              const h = t[u];
              n.push(this._vertexToIndex(h.x, h.y));
            }
            return n;
          }
        }
        function A0(o, t, n, u = true) {
          return new yx(n, t).subdividePolygonInternal(o, u);
        }
        function ll(o, t, n = false) {
          if (!o || o.length < 1) return [];
          if (o.length < 2) return [];
          const u = o[0], h = o[o.length - 1], _ = n && (u.x !== h.x || u.y !== h.y);
          if (t < 2) return _ ? [...o, o[0]] : [...o];
          const b = Math.floor(et / t), w = [];
          w.push(new C(o[0].x, o[0].y));
          const S = o.length, I = _ ? S : S - 1;
          for (let R = 0; R < I; R++) {
            const B = o[R], N = R < S - 1 ? o[R + 1] : o[0], q = B.x, G = B.y, Q = N.x, ae = N.y, pe = q !== Q, Oe = G !== ae;
            if (!pe && !Oe) continue;
            const Ce = Q - q, Ie = ae - G, He = Math.abs(Ce), rt = Math.abs(Ie);
            let _t = q, At = G;
            for (; ; ) {
              const Et = Ce > 0 ? (Math.floor(_t / b) + 1) * b : (Math.ceil(_t / b) - 1) * b, Wt = Ie > 0 ? (Math.floor(At / b) + 1) * b : (Math.ceil(At / b) - 1) * b, Mt = Math.abs(_t - Et), Rt = Math.abs(At - Wt), ct = Math.abs(_t - Q), or = Math.abs(At - ae), hr = pe ? Mt / He : Number.POSITIVE_INFINITY, Jt = Oe ? Rt / rt : Number.POSITIVE_INFINITY;
              if ((ct <= Mt || !pe) && (or <= Rt || !Oe)) break;
              if (hr < Jt && pe || !Oe) {
                _t = Et, At += Ie * hr;
                const Ut = new C(_t, Math.round(At));
                w[w.length - 1].x === Ut.x && w[w.length - 1].y === Ut.y || w.push(Ut);
              } else {
                _t += Ce * Jt, At = Wt;
                const Ut = new C(Math.round(_t), At);
                w[w.length - 1].x === Ut.x && w[w.length - 1].y === Ut.y || w.push(Ut);
              }
            }
            const kt = new C(Q, ae);
            w[w.length - 1].x === kt.x && w[w.length - 1].y === kt.y || w.push(kt);
          }
          return w;
        }
        function bx(o, t, n) {
          if (t.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let u = 0, h = o[2 * t[0]];
          for (let S = 1; S < t.length; S++) {
            const I = o[2 * t[S]];
            I < h && (h = I, u = S);
          }
          const _ = t.length;
          let b = u, w = (b + 1) % _;
          for (; ; ) {
            const S = b - 1 >= 0 ? b - 1 : _ - 1, I = (w + 1) % _, R = o[2 * t[S]], B = o[2 * t[I]], N = o[2 * t[b]], q = o[2 * t[b] + 1], G = o[2 * t[w] + 1];
            let Q = false;
            if (R < B) Q = true;
            else if (R > B) Q = false;
            else {
              const ae = G - q, pe = -(o[2 * t[w]] - N), Oe = q < G ? 1 : -1;
              ((R - N) * ae + (o[2 * t[S] + 1] - q) * pe) * Oe > ((B - N) * ae + (o[2 * t[I] + 1] - q) * pe) * Oe && (Q = true);
            }
            if (Q) {
              const ae = t[S], pe = t[b], Oe = t[w];
              ae !== pe && ae !== Oe && pe !== Oe && n.push(Oe, pe, ae), b--, b < 0 && (b = _ - 1);
            } else {
              const ae = t[I], pe = t[b], Oe = t[w];
              ae !== pe && ae !== Oe && pe !== Oe && n.push(Oe, pe, ae), w++, w >= _ && (w = 0);
            }
            if (S === I) break;
          }
        }
        function D0(o, t, n, u, h, _, b, w, S) {
          const I = h.length / 2, R = b && w && S;
          if (I < Ar.MAX_VERTEX_ARRAY_LENGTH) {
            const B = t.prepareSegment(I, n, u), N = B.vertexLength;
            for (let Q = 0; Q < _.length; Q += 3) u.emplaceBack(N + _[Q], N + _[Q + 1], N + _[Q + 2]);
            let q, G;
            B.vertexLength += I, B.primitiveLength += _.length / 3, R && (G = b.prepareSegment(I, n, w), q = G.vertexLength, G.vertexLength += I);
            for (let Q = 0; Q < h.length; Q += 2) o(h[Q], h[Q + 1]);
            if (R) for (let Q = 0; Q < S.length; Q++) {
              const ae = S[Q];
              for (let pe = 1; pe < ae.length; pe += 2) w.emplaceBack(q + ae[pe - 1], q + ae[pe]);
              G.primitiveLength += ae.length / 2;
            }
          } else (function(B, N, q, G, Q, ae) {
            const pe = [];
            for (let rt = 0; rt < G.length / 2; rt++) pe.push(-1);
            const Oe = { count: 0 };
            let Ce = 0, Ie = B.getOrCreateLatestSegment(N, q), He = Ie.vertexLength;
            for (let rt = 2; rt < Q.length; rt += 3) {
              const _t = Q[rt - 2], At = Q[rt - 1], kt = Q[rt];
              let Et = pe[_t] < Ce, Wt = pe[At] < Ce, Mt = pe[kt] < Ce;
              Ie.vertexLength + ((Et ? 1 : 0) + (Wt ? 1 : 0) + (Mt ? 1 : 0)) > Ar.MAX_VERTEX_ARRAY_LENGTH && (Ie = B.createNewSegment(N, q), Ce = Oe.count, Et = true, Wt = true, Mt = true, He = 0);
              const Rt = fd(pe, G, ae, Oe, _t, Et, Ie), ct = fd(pe, G, ae, Oe, At, Wt, Ie), or = fd(pe, G, ae, Oe, kt, Mt, Ie);
              q.emplaceBack(He + Rt - Ce, He + ct - Ce, He + or - Ce), Ie.primitiveLength++;
            }
          })(t, n, u, h, _, o), R && (function(B, N, q, G, Q, ae) {
            const pe = [];
            for (let rt = 0; rt < G.length / 2; rt++) pe.push(-1);
            const Oe = { count: 0 };
            let Ce = 0, Ie = B.getOrCreateLatestSegment(N, q), He = Ie.vertexLength;
            for (let rt = 0; rt < Q.length; rt++) {
              const _t = Q[rt];
              for (let At = 1; At < Q[rt].length; At += 2) {
                const kt = _t[At - 1], Et = _t[At];
                let Wt = pe[kt] < Ce, Mt = pe[Et] < Ce;
                Ie.vertexLength + ((Wt ? 1 : 0) + (Mt ? 1 : 0)) > Ar.MAX_VERTEX_ARRAY_LENGTH && (Ie = B.createNewSegment(N, q), Ce = Oe.count, Wt = true, Mt = true, He = 0);
                const Rt = fd(pe, G, ae, Oe, kt, Wt, Ie), ct = fd(pe, G, ae, Oe, Et, Mt, Ie);
                q.emplaceBack(He + Rt - Ce, He + ct - Ce), Ie.primitiveLength++;
              }
            }
          })(b, n, w, h, S, o), t.forceNewSegmentOnNextPrepare(), b == null ? void 0 : b.forceNewSegmentOnNextPrepare();
        }
        function fd(o, t, n, u, h, _, b) {
          if (_) {
            const w = u.count;
            return n(t[2 * h], t[2 * h + 1]), o[h] = u.count, u.count++, b.vertexLength++, w;
          }
          return o[h];
        }
        class tm {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((n) => n.id)), this.index = t.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new Ze(), this.indexArray = new Hr(), this.indexArray2 = new fi(), this.programConfigurations = new ua(t.layers, t.zoom), this.segments = new Ar(), this.segments2 = new Ar(), this.stateDependentLayerIds = this.layers.filter(((n) => n.isStateDependent())).map(((n) => n.id));
          }
          populate(t, n, u) {
            this.hasPattern = Kp("fill", this.layers, n);
            const h = this.layers[0].layout.get("fill-sort-key"), _ = !h.isConstant(), b = [];
            for (const { feature: w, id: S, index: I, sourceLayerIndex: R } of t) {
              const B = this.layers[0]._featureFilter.needGeometry, N = al(w, B);
              if (!this.layers[0]._featureFilter.filter(new qr(this.zoom), N, u)) continue;
              const q = _ ? h.evaluate(N, {}, u, n.availableImages) : void 0, G = { id: S, properties: w.properties, type: w.type, sourceLayerIndex: R, index: I, geometry: B ? N.geometry : ol(w), patterns: {}, sortKey: q };
              b.push(G);
            }
            _ && b.sort(((w, S) => w.sortKey - S.sortKey));
            for (const w of b) {
              const { geometry: S, index: I, sourceLayerIndex: R } = w;
              if (this.hasPattern) {
                const B = Jp("fill", this.layers, w, { zoom: this.zoom }, n);
                this.patternFeatures.push(B);
              } else this.addFeature(w, S, I, u, {}, n.subdivisionGranularity);
              n.featureIndex.insert(t[I].feature, S, I, R, this.index);
            }
          }
          update(t, n, u) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, { imagePositions: u });
          }
          addFeatures(t, n, u) {
            for (const h of this.patternFeatures) this.addFeature(h, h.geometry, h.index, n, u, t.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, ux), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t, n, u, h, _, b) {
            for (const w of Us(n, 500)) {
              const S = A0(w, h, b.fill.getGranularityForZoomLevel(h.z)), I = this.layoutVertexArray;
              D0(((R, B) => {
                I.emplaceBack(R, B);
              }), this.segments, this.layoutVertexArray, this.indexArray, S.verticesFlattened, S.indicesTriangles, this.segments2, this.indexArray2, S.indicesLineList);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, u, { imagePositions: _, canonical: h });
          }
        }
        let z0, F0;
        Lt("FillBucket", tm, { omit: ["layers", "patternFeatures"] });
        var xx = { get paint() {
          return F0 = F0 || new an({ "fill-antialias": new qt(Te.paint_fill["fill-antialias"]), "fill-opacity": new Xt(Te.paint_fill["fill-opacity"]), "fill-color": new Xt(Te.paint_fill["fill-color"]), "fill-outline-color": new Xt(Te.paint_fill["fill-outline-color"]), "fill-translate": new qt(Te.paint_fill["fill-translate"]), "fill-translate-anchor": new qt(Te.paint_fill["fill-translate-anchor"]), "fill-pattern": new pu(Te.paint_fill["fill-pattern"]) });
        }, get layout() {
          return z0 = z0 || new an({ "fill-sort-key": new Xt(Te.layout_fill["fill-sort-key"]) });
        } };
        class wx extends no {
          constructor(t, n) {
            super(t, xx, n);
          }
          recalculate(t, n) {
            super.recalculate(t, n);
            const u = this.paint._values["fill-outline-color"];
            u.value.kind === "constant" && u.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t) {
            return new tm(t);
          }
          queryRadius() {
            return ef(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, geometry: n, transform: u, pixelsToTileUnits: h }) {
            return f0(tf(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -u.bearingInRadians, h), n);
          }
          isTileClipped() {
            return true;
          }
        }
        const Cx = wi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Sx = wi([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: kx } = Cx;
        class Iu {
          constructor(t, n, u, h, _) {
            this.properties = {}, this.extent = u, this.type = 0, this.id = void 0, this._pbf = t, this._geometry = -1, this._keys = h, this._values = _, t.readFields(Px, this, n);
          }
          loadGeometry() {
            const t = this._pbf;
            t.pos = this._geometry;
            const n = t.readVarint() + t.pos, u = [];
            let h, _ = 1, b = 0, w = 0, S = 0;
            for (; t.pos < n; ) {
              if (b <= 0) {
                const I = t.readVarint();
                _ = 7 & I, b = I >> 3;
              }
              if (b--, _ === 1 || _ === 2) w += t.readSVarint(), S += t.readSVarint(), _ === 1 && (h && u.push(h), h = []), h && h.push(new C(w, S));
              else {
                if (_ !== 7) throw new Error(`unknown command ${_}`);
                h && h.push(h[0].clone());
              }
            }
            return h && u.push(h), u;
          }
          bbox() {
            const t = this._pbf;
            t.pos = this._geometry;
            const n = t.readVarint() + t.pos;
            let u = 1, h = 0, _ = 0, b = 0, w = 1 / 0, S = -1 / 0, I = 1 / 0, R = -1 / 0;
            for (; t.pos < n; ) {
              if (h <= 0) {
                const B = t.readVarint();
                u = 7 & B, h = B >> 3;
              }
              if (h--, u === 1 || u === 2) _ += t.readSVarint(), b += t.readSVarint(), _ < w && (w = _), _ > S && (S = _), b < I && (I = b), b > R && (R = b);
              else if (u !== 7) throw new Error(`unknown command ${u}`);
            }
            return [w, I, S, R];
          }
          toGeoJSON(t, n, u) {
            const h = this.extent * Math.pow(2, u), _ = this.extent * t, b = this.extent * n, w = this.loadGeometry();
            function S(N) {
              return [360 * (N.x + _) / h - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (N.y + b) / h) * Math.PI)) - 90];
            }
            function I(N) {
              return N.map(S);
            }
            let R;
            if (this.type === 1) {
              const N = [];
              for (const G of w) N.push(G[0]);
              const q = I(N);
              R = N.length === 1 ? { type: "Point", coordinates: q[0] } : { type: "MultiPoint", coordinates: q };
            } else if (this.type === 2) {
              const N = w.map(I);
              R = N.length === 1 ? { type: "LineString", coordinates: N[0] } : { type: "MultiLineString", coordinates: N };
            } else {
              if (this.type !== 3) throw new Error("unknown feature type");
              {
                const N = (function(G) {
                  const Q = G.length;
                  if (Q <= 1) return [G];
                  const ae = [];
                  let pe, Oe;
                  for (let Ce = 0; Ce < Q; Ce++) {
                    const Ie = Tx(G[Ce]);
                    Ie !== 0 && (Oe === void 0 && (Oe = Ie < 0), Oe === Ie < 0 ? (pe && ae.push(pe), pe = [G[Ce]]) : pe && pe.push(G[Ce]));
                  }
                  return pe && ae.push(pe), ae;
                })(w), q = [];
                for (const G of N) q.push(G.map(I));
                R = q.length === 1 ? { type: "Polygon", coordinates: q[0] } : { type: "MultiPolygon", coordinates: q };
              }
            }
            const B = { type: "Feature", geometry: R, properties: this.properties };
            return this.id != null && (B.id = this.id), B;
          }
        }
        function Px(o, t, n) {
          o === 1 ? t.id = n.readVarint() : o === 2 ? (function(u, h) {
            const _ = u.readVarint() + u.pos;
            for (; u.pos < _; ) {
              const b = h._keys[u.readVarint()], w = h._values[u.readVarint()];
              h.properties[b] = w;
            }
          })(n, t) : o === 3 ? t.type = n.readVarint() : o === 4 && (t._geometry = n.pos);
        }
        function Tx(o) {
          let t = 0;
          for (let n, u, h = 0, _ = o.length, b = _ - 1; h < _; b = h++) n = o[h], u = o[b], t += (u.x - n.x) * (n.y + u.y);
          return t;
        }
        Iu.types = ["Unknown", "Point", "LineString", "Polygon"];
        class L0 {
          constructor(t, n) {
            this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(Ix, this, n), this.length = this._features.length;
          }
          feature(t) {
            if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t];
            const n = this._pbf.readVarint() + this._pbf.pos;
            return new Iu(this._pbf, n, this.extent, this._keys, this._values);
          }
        }
        function Ix(o, t, n) {
          o === 15 ? t.version = n.readVarint() : o === 1 ? t.name = n.readString() : o === 5 ? t.extent = n.readVarint() : o === 2 ? t._features.push(n.pos) : o === 3 ? t._keys.push(n.readString()) : o === 4 && t._values.push((function(u) {
            let h = null;
            const _ = u.readVarint() + u.pos;
            for (; u.pos < _; ) {
              const b = u.readVarint() >> 3;
              h = b === 1 ? u.readString() : b === 2 ? u.readFloat() : b === 3 ? u.readDouble() : b === 4 ? u.readVarint64() : b === 5 ? u.readVarint() : b === 6 ? u.readSVarint() : b === 7 ? u.readBoolean() : null;
            }
            if (h == null) throw new Error("unknown feature value");
            return h;
          })(n));
        }
        class B0 {
          constructor(t, n) {
            this.layers = t.readFields(Mx, {}, n);
          }
        }
        function Mx(o, t, n) {
          if (o === 3) {
            const u = new L0(n, n.readVarint() + n.pos);
            u.length && (t[u.name] = u);
          }
        }
        const rm = Math.pow(2, 13);
        function pd(o, t, n, u, h, _, b, w) {
          o.emplaceBack(t, n, 2 * Math.floor(u * rm) + b, h * rm * 2, _ * rm * 2, Math.round(w));
        }
        class im {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((n) => n.id)), this.index = t.index, this.hasPattern = false, this.layoutVertexArray = new Qe(), this.centroidVertexArray = new Je(), this.indexArray = new Hr(), this.programConfigurations = new ua(t.layers, t.zoom), this.segments = new Ar(), this.stateDependentLayerIds = this.layers.filter(((n) => n.isStateDependent())).map(((n) => n.id));
          }
          populate(t, n, u) {
            this.features = [], this.hasPattern = Kp("fill-extrusion", this.layers, n);
            for (const { feature: h, id: _, index: b, sourceLayerIndex: w } of t) {
              const S = this.layers[0]._featureFilter.needGeometry, I = al(h, S);
              if (!this.layers[0]._featureFilter.filter(new qr(this.zoom), I, u)) continue;
              const R = { id: _, sourceLayerIndex: w, index: b, geometry: S ? I.geometry : ol(h), properties: h.properties, type: h.type, patterns: {} };
              this.hasPattern ? this.features.push(Jp("fill-extrusion", this.layers, R, { zoom: this.zoom }, n)) : this.addFeature(R, R.geometry, b, u, {}, n.subdivisionGranularity), n.featureIndex.insert(h, R.geometry, b, w, this.index, true);
            }
          }
          addFeatures(t, n, u) {
            for (const h of this.features) {
              const { geometry: _ } = h;
              this.addFeature(h, _, h.index, n, u, t.subdivisionGranularity);
            }
          }
          update(t, n, u) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, { imagePositions: u });
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, kx), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, Sx.members, true), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(t, n, u, h, _, b) {
            for (const w of Us(n, 500)) {
              const S = { x: 0, y: 0, sampleCount: 0 }, I = this.layoutVertexArray.length;
              this.processPolygon(S, h, t, w, b);
              const R = this.layoutVertexArray.length - I, B = Math.floor(S.x / S.sampleCount), N = Math.floor(S.y / S.sampleCount);
              for (let q = 0; q < R; q++) this.centroidVertexArray.emplaceBack(B, N);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, u, { imagePositions: _, canonical: h });
          }
          processPolygon(t, n, u, h, _) {
            if (h.length < 1 || O0(h[0])) return;
            for (const B of h) B.length !== 0 && Ex(t, B);
            const b = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, w = _.fill.getGranularityForZoomLevel(n.z), S = Iu.types[u.type] === "Polygon";
            for (const B of h) {
              if (B.length === 0 || O0(B)) continue;
              const N = ll(B, w, S);
              this._generateSideFaces(N, b);
            }
            if (!S) return;
            const I = A0(h, n, w, false), R = this.layoutVertexArray;
            D0(((B, N) => {
              pd(R, B, N, 0, 0, 1, 1, 0);
            }), this.segments, this.layoutVertexArray, this.indexArray, I.verticesFlattened, I.indicesTriangles);
          }
          _generateSideFaces(t, n) {
            let u = 0;
            for (let h = 1; h < t.length; h++) {
              const _ = t[h], b = t[h - 1];
              if (Rx(_, b)) continue;
              n.segment.vertexLength + 4 > Ar.MAX_VERTEX_ARRAY_LENGTH && (n.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const w = _.sub(b)._perp()._unit(), S = b.dist(_);
              u + S > 32768 && (u = 0), pd(this.layoutVertexArray, _.x, _.y, w.x, w.y, 0, 0, u), pd(this.layoutVertexArray, _.x, _.y, w.x, w.y, 0, 1, u), u += S, pd(this.layoutVertexArray, b.x, b.y, w.x, w.y, 0, 0, u), pd(this.layoutVertexArray, b.x, b.y, w.x, w.y, 0, 1, u);
              const I = n.segment.vertexLength;
              this.indexArray.emplaceBack(I, I + 2, I + 1), this.indexArray.emplaceBack(I + 1, I + 2, I + 3), n.segment.vertexLength += 4, n.segment.primitiveLength += 2;
            }
          }
        }
        function Ex(o, t) {
          for (let n = 0; n < t.length; n++) {
            const u = t[n];
            n === t.length - 1 && t[0].x === u.x && t[0].y === u.y || (o.x += u.x, o.y += u.y, o.sampleCount++);
          }
        }
        function Rx(o, t) {
          return o.x === t.x && (o.x < 0 || o.x > et) || o.y === t.y && (o.y < 0 || o.y > et);
        }
        function O0(o) {
          return o.every(((t) => t.x < 0)) || o.every(((t) => t.x > et)) || o.every(((t) => t.y < 0)) || o.every(((t) => t.y > et));
        }
        let $0;
        Lt("FillExtrusionBucket", im, { omit: ["layers", "features"] });
        var Ax = { get paint() {
          return $0 = $0 || new an({ "fill-extrusion-opacity": new qt(Te["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Xt(Te["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new qt(Te["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new qt(Te["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new pu(Te["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Xt(Te["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Xt(Te["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new qt(Te["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class Dx extends no {
          constructor(t, n) {
            super(t, Ax, n);
          }
          createBucket(t) {
            return new im(t);
          }
          queryRadius() {
            return ef(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return true;
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: u, geometry: h, transform: _, pixelsToTileUnits: b, pixelPosMatrix: w }) {
            const S = tf(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -_.bearingInRadians, b), I = this.paint.get("fill-extrusion-height").evaluate(n, u), R = this.paint.get("fill-extrusion-base").evaluate(n, u), B = (function(q, G) {
              const Q = [];
              for (const ae of q) {
                const pe = [ae.x, ae.y, 0, 1];
                Ke(pe, pe, G), Q.push(new C(pe[0] / pe[3], pe[1] / pe[3]));
              }
              return Q;
            })(S, w), N = (function(q, G, Q, ae) {
              const pe = [], Oe = [], Ce = ae[8] * G, Ie = ae[9] * G, He = ae[10] * G, rt = ae[11] * G, _t = ae[8] * Q, At = ae[9] * Q, kt = ae[10] * Q, Et = ae[11] * Q;
              for (const Wt of q) {
                const Mt = [], Rt = [];
                for (const ct of Wt) {
                  const or = ct.x, hr = ct.y, Jt = ae[0] * or + ae[4] * hr + ae[12], Ut = ae[1] * or + ae[5] * hr + ae[13], Ir = ae[2] * or + ae[6] * hr + ae[14], bi = ae[3] * or + ae[7] * hr + ae[15], Bi = Ir + He, ln = bi + rt, lo = Jt + _t, $n = Ut + At, Xi = Ir + kt, gi = bi + Et, Ui = new C((Jt + Ce) / ln, (Ut + Ie) / ln);
                  Ui.z = Bi / ln, Mt.push(Ui);
                  const Yi = new C(lo / gi, $n / gi);
                  Yi.z = Xi / gi, Rt.push(Yi);
                }
                pe.push(Mt), Oe.push(Rt);
              }
              return [pe, Oe];
            })(h, R, I, w);
            return (function(q, G, Q) {
              let ae = 1 / 0;
              f0(Q, G) && (ae = j0(Q, G[0]));
              for (let pe = 0; pe < G.length; pe++) {
                const Oe = G[pe], Ce = q[pe];
                for (let Ie = 0; Ie < Oe.length - 1; Ie++) {
                  const He = Oe[Ie], rt = [He, Oe[Ie + 1], Ce[Ie + 1], Ce[Ie], He];
                  h0(Q, rt) && (ae = Math.min(ae, j0(Q, rt)));
                }
              }
              return ae !== 1 / 0 && ae;
            })(N[0], N[1], B);
          }
        }
        function md(o, t) {
          return o.x * t.x + o.y * t.y;
        }
        function j0(o, t) {
          if (o.length === 1) {
            let n = 0;
            const u = t[n++];
            let h;
            for (; !h || u.equals(h); ) if (h = t[n++], !h) return 1 / 0;
            for (; n < t.length; n++) {
              const _ = t[n], b = o[0], w = h.sub(u), S = _.sub(u), I = b.sub(u), R = md(w, w), B = md(w, S), N = md(S, S), q = md(I, w), G = md(I, S), Q = R * N - B * B, ae = (N * q - B * G) / Q, pe = (R * G - B * q) / Q, Oe = u.z * (1 - ae - pe) + h.z * ae + _.z * pe;
              if (isFinite(Oe)) return Oe;
            }
            return 1 / 0;
          }
          {
            let n = 1 / 0;
            for (const u of t) n = Math.min(n, u.z);
            return n;
          }
        }
        const zx = wi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: Fx } = zx, Lx = wi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: Bx } = Lx, Ox = Math.cos(Math.PI / 180 * 37.5), N0 = Math.pow(2, 14) / 0.5;
        class nm {
          constructor(t) {
            this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((n) => n.id)), this.index = t.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(((n) => {
              this.gradients[n.id] = {};
            })), this.layoutVertexArray = new It(), this.layoutVertexArray2 = new Pt(), this.indexArray = new Hr(), this.programConfigurations = new ua(t.layers, t.zoom), this.segments = new Ar(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(((n) => n.isStateDependent())).map(((n) => n.id));
          }
          populate(t, n, u) {
            this.hasPattern = Kp("line", this.layers, n);
            const h = this.layers[0].layout.get("line-sort-key"), _ = !h.isConstant(), b = [];
            for (const { feature: w, id: S, index: I, sourceLayerIndex: R } of t) {
              const B = this.layers[0]._featureFilter.needGeometry, N = al(w, B);
              if (!this.layers[0]._featureFilter.filter(new qr(this.zoom), N, u)) continue;
              const q = _ ? h.evaluate(N, {}, u) : void 0, G = { id: S, properties: w.properties, type: w.type, sourceLayerIndex: R, index: I, geometry: B ? N.geometry : ol(w), patterns: {}, sortKey: q };
              b.push(G);
            }
            _ && b.sort(((w, S) => w.sortKey - S.sortKey));
            for (const w of b) {
              const { geometry: S, index: I, sourceLayerIndex: R } = w;
              if (this.hasPattern) {
                const B = Jp("line", this.layers, w, { zoom: this.zoom }, n);
                this.patternFeatures.push(B);
              } else this.addFeature(w, S, I, u, {}, n.subdivisionGranularity);
              n.featureIndex.insert(t[I].feature, S, I, R, this.index);
            }
          }
          update(t, n, u) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, { imagePositions: u });
          }
          addFeatures(t, n, u) {
            for (const h of this.patternFeatures) this.addFeature(h, h.geometry, h.index, n, u, t.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Bx)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Fx), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t) {
            if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return { start: +t.properties.mapbox_clip_start, end: +t.properties.mapbox_clip_end };
          }
          addFeature(t, n, u, h, _, b) {
            const w = this.layers[0].layout, S = w.get("line-join").evaluate(t, {}), I = w.get("line-cap"), R = w.get("line-miter-limit"), B = w.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t);
            for (const N of n) this.addLine(N, t, S, I, R, B, h, b);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, u, { imagePositions: _, canonical: h });
          }
          addLine(t, n, u, h, _, b, w, S) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = ll(t, w ? S.line.getGranularityForZoomLevel(w.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let Ce = 0; Ce < t.length - 1; Ce++) this.totalDistance += t[Ce].dist(t[Ce + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const I = Iu.types[n.type] === "Polygon";
            let R = t.length;
            for (; R >= 2 && t[R - 1].equals(t[R - 2]); ) R--;
            let B = 0;
            for (; B < R - 1 && t[B].equals(t[B + 1]); ) B++;
            if (R < (I ? 3 : 2)) return;
            u === "bevel" && (_ = 1.05);
            const N = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, q = this.segments.prepareSegment(10 * R, this.layoutVertexArray, this.indexArray);
            let G, Q, ae, pe, Oe;
            this.e1 = this.e2 = -1, I && (G = t[R - 2], Oe = t[B].sub(G)._unit()._perp());
            for (let Ce = B; Ce < R; Ce++) {
              if (ae = Ce === R - 1 ? I ? t[B + 1] : void 0 : t[Ce + 1], ae && t[Ce].equals(ae)) continue;
              Oe && (pe = Oe), G && (Q = G), G = t[Ce], Oe = ae ? ae.sub(G)._unit()._perp() : pe, pe = pe || Oe;
              let Ie = pe.add(Oe);
              Ie.x === 0 && Ie.y === 0 || Ie._unit();
              const He = pe.x * Oe.x + pe.y * Oe.y, rt = Ie.x * Oe.x + Ie.y * Oe.y, _t = rt !== 0 ? 1 / rt : 1 / 0, At = 2 * Math.sqrt(2 - 2 * rt), kt = rt < Ox && Q && ae, Et = pe.x * Oe.y - pe.y * Oe.x > 0;
              if (kt && Ce > B) {
                const Rt = G.dist(Q);
                if (Rt > 2 * N) {
                  const ct = G.sub(G.sub(Q)._mult(N / Rt)._round());
                  this.updateDistance(Q, ct), this.addCurrentVertex(ct, pe, 0, 0, q), Q = ct;
                }
              }
              const Wt = Q && ae;
              let Mt = Wt ? u : I ? "butt" : h;
              if (Wt && Mt === "round" && (_t < b ? Mt = "miter" : _t <= 2 && (Mt = "fakeround")), Mt === "miter" && _t > _ && (Mt = "bevel"), Mt === "bevel" && (_t > 2 && (Mt = "flipbevel"), _t < _ && (Mt = "miter")), Q && this.updateDistance(Q, G), Mt === "miter") Ie._mult(_t), this.addCurrentVertex(G, Ie, 0, 0, q);
              else if (Mt === "flipbevel") {
                if (_t > 100) Ie = Oe.mult(-1);
                else {
                  const Rt = _t * pe.add(Oe).mag() / pe.sub(Oe).mag();
                  Ie._perp()._mult(Rt * (Et ? -1 : 1));
                }
                this.addCurrentVertex(G, Ie, 0, 0, q), this.addCurrentVertex(G, Ie.mult(-1), 0, 0, q);
              } else if (Mt === "bevel" || Mt === "fakeround") {
                const Rt = -Math.sqrt(_t * _t - 1), ct = Et ? Rt : 0, or = Et ? 0 : Rt;
                if (Q && this.addCurrentVertex(G, pe, ct, or, q), Mt === "fakeround") {
                  const hr = Math.round(180 * At / Math.PI / 20);
                  for (let Jt = 1; Jt < hr; Jt++) {
                    let Ut = Jt / hr;
                    if (Ut !== 0.5) {
                      const bi = Ut - 0.5;
                      Ut += Ut * bi * (Ut - 1) * ((1.0904 + He * (He * (3.55645 - 1.43519 * He) - 3.2452)) * bi * bi + (0.848013 + He * (0.215638 * He - 1.06021)));
                    }
                    const Ir = Oe.sub(pe)._mult(Ut)._add(pe)._unit()._mult(Et ? -1 : 1);
                    this.addHalfVertex(G, Ir.x, Ir.y, false, Et, 0, q);
                  }
                }
                ae && this.addCurrentVertex(G, Oe, -ct, -or, q);
              } else if (Mt === "butt") this.addCurrentVertex(G, Ie, 0, 0, q);
              else if (Mt === "square") {
                const Rt = Q ? 1 : -1;
                this.addCurrentVertex(G, Ie, Rt, Rt, q);
              } else Mt === "round" && (Q && (this.addCurrentVertex(G, pe, 0, 0, q), this.addCurrentVertex(G, pe, 1, 1, q, true)), ae && (this.addCurrentVertex(G, Oe, -1, -1, q, true), this.addCurrentVertex(G, Oe, 0, 0, q)));
              if (kt && Ce < R - 1) {
                const Rt = G.dist(ae);
                if (Rt > 2 * N) {
                  const ct = G.add(ae.sub(G)._mult(N / Rt)._round());
                  this.updateDistance(G, ct), this.addCurrentVertex(ct, Oe, 0, 0, q), G = ct;
                }
              }
            }
          }
          addCurrentVertex(t, n, u, h, _, b = false) {
            const w = n.y * h - n.x, S = -n.y - n.x * h;
            this.addHalfVertex(t, n.x + n.y * u, n.y - n.x * u, b, false, u, _), this.addHalfVertex(t, w, S, b, true, -h, _), this.distance > N0 / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, n, u, h, _, b));
          }
          addHalfVertex({ x: t, y: n }, u, h, _, b, w, S) {
            const I = 0.5 * (this.lineClips ? this.scaledDistance * (N0 - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t << 1) + (_ ? 1 : 0), (n << 1) + (b ? 1 : 0), Math.round(63 * u) + 128, Math.round(63 * h) + 128, 1 + (w === 0 ? 0 : w < 0 ? -1 : 1) | (63 & I) << 2, I >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const R = S.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, R, this.e2), S.primitiveLength++), b ? this.e2 = R : this.e1 = R;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(t, n) {
            this.distance += t.dist(n), this.updateScaledDistance();
          }
        }
        let V0, U0;
        Lt("LineBucket", nm, { omit: ["layers", "patternFeatures"] });
        var q0 = { get paint() {
          return U0 = U0 || new an({ "line-opacity": new Xt(Te.paint_line["line-opacity"]), "line-color": new Xt(Te.paint_line["line-color"]), "line-translate": new qt(Te.paint_line["line-translate"]), "line-translate-anchor": new qt(Te.paint_line["line-translate-anchor"]), "line-width": new Xt(Te.paint_line["line-width"]), "line-gap-width": new Xt(Te.paint_line["line-gap-width"]), "line-offset": new Xt(Te.paint_line["line-offset"]), "line-blur": new Xt(Te.paint_line["line-blur"]), "line-dasharray": new ed(Te.paint_line["line-dasharray"]), "line-pattern": new pu(Te.paint_line["line-pattern"]), "line-gradient": new mu(Te.paint_line["line-gradient"]) });
        }, get layout() {
          return V0 = V0 || new an({ "line-cap": new qt(Te.layout_line["line-cap"]), "line-join": new Xt(Te.layout_line["line-join"]), "line-miter-limit": new qt(Te.layout_line["line-miter-limit"]), "line-round-limit": new qt(Te.layout_line["line-round-limit"]), "line-sort-key": new Xt(Te.layout_line["line-sort-key"]) });
        } };
        class $x extends Xt {
          possiblyEvaluate(t, n) {
            return n = new qr(Math.floor(n.zoom), { now: n.now, fadeDuration: n.fadeDuration, zoomHistory: n.zoomHistory, transition: n.transition }), super.possiblyEvaluate(t, n);
          }
          evaluate(t, n, u, h) {
            return n = Qt({}, n, { zoom: Math.floor(n.zoom) }), super.evaluate(t, n, u, h);
          }
        }
        let af;
        class jx extends no {
          constructor(t, n) {
            super(t, q0, n), this.gradientVersion = 0, af || (af = new $x(q0.paint.properties["line-width"].specification), af.useIntegerZoom = true);
          }
          _handleSpecialPaintPropertyUpdate(t) {
            if (t === "line-gradient") {
              const n = this.gradientExpression();
              this.stepInterpolant = !!(function(u) {
                return u._styleExpression !== void 0;
              })(n) && n._styleExpression.expression instanceof xi, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(t, n) {
            super.recalculate(t, n), this.paint._values["line-floorwidth"] = af.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t);
          }
          createBucket(t) {
            return new nm(t);
          }
          queryRadius(t) {
            const n = t, u = G0(Su("line-width", this, n), Su("line-gap-width", this, n)), h = Su("line-offset", this, n);
            return u / 2 + Math.abs(h) + ef(this.paint.get("line-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: u, geometry: h, transform: _, pixelsToTileUnits: b }) {
            const w = tf(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -_.bearingInRadians, b), S = b / 2 * G0(this.paint.get("line-width").evaluate(n, u), this.paint.get("line-gap-width").evaluate(n, u)), I = this.paint.get("line-offset").evaluate(n, u);
            return I && (h = (function(R, B) {
              const N = [];
              for (let q = 0; q < R.length; q++) {
                const G = R[q], Q = [];
                for (let ae = 0; ae < G.length; ae++) {
                  const pe = G[ae - 1], Oe = G[ae], Ce = G[ae + 1], Ie = ae === 0 ? new C(0, 0) : Oe.sub(pe)._unit()._perp(), He = ae === G.length - 1 ? new C(0, 0) : Ce.sub(Oe)._unit()._perp(), rt = Ie._add(He)._unit(), _t = rt.x * He.x + rt.y * He.y;
                  _t !== 0 && rt._mult(1 / _t), Q.push(rt._mult(B)._add(Oe));
                }
                N.push(Q);
              }
              return N;
            })(h, I * b)), (function(R, B, N) {
              for (let q = 0; q < B.length; q++) {
                const G = B[q];
                if (R.length >= 3) {
                  for (let Q = 0; Q < G.length; Q++) if (Cu(R, G[Q])) return true;
                }
                if (Z1(R, G, N)) return true;
              }
              return false;
            })(w, h, S);
          }
          isTileClipped() {
            return true;
          }
        }
        function G0(o, t) {
          return t > 0 ? t + 2 * o : o;
        }
        const Nx = wi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Vx = wi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        wi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const Ux = wi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
        wi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const W0 = wi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), qx = wi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function Gx(o, t, n) {
          return o.sections.forEach(((u) => {
            u.text = (function(h, _, b) {
              const w = _.layout.get("text-transform").evaluate(b, {});
              return w === "uppercase" ? h = h.toLocaleUpperCase() : w === "lowercase" && (h = h.toLocaleLowerCase()), na.applyArabicShaping && (h = na.applyArabicShaping(h)), h;
            })(u.text, t, n);
          })), o;
        }
        wi([{ name: "triangle", components: 3, type: "Uint16" }]), wi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), wi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), wi([{ type: "Float32", name: "offsetX" }]), wi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), wi([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        const gd = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
        var Vi = 24;
        const om = 4294967296, Z0 = 1 / om, H0 = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        class am {
          constructor(t = new Uint8Array(16)) {
            this.buf = ArrayBuffer.isView(t) ? t : new Uint8Array(t), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          readFields(t, n, u = this.length) {
            for (; this.pos < u; ) {
              const h = this.readVarint(), _ = h >> 3, b = this.pos;
              this.type = 7 & h, t(_, n, this), this.pos === b && this.skip(h);
            }
            return n;
          }
          readMessage(t, n) {
            return this.readFields(t, n, this.readVarint() + this.pos);
          }
          readFixed32() {
            const t = this.dataView.getUint32(this.pos, true);
            return this.pos += 4, t;
          }
          readSFixed32() {
            const t = this.dataView.getInt32(this.pos, true);
            return this.pos += 4, t;
          }
          readFixed64() {
            const t = this.dataView.getUint32(this.pos, true) + this.dataView.getUint32(this.pos + 4, true) * om;
            return this.pos += 8, t;
          }
          readSFixed64() {
            const t = this.dataView.getUint32(this.pos, true) + this.dataView.getInt32(this.pos + 4, true) * om;
            return this.pos += 8, t;
          }
          readFloat() {
            const t = this.dataView.getFloat32(this.pos, true);
            return this.pos += 4, t;
          }
          readDouble() {
            const t = this.dataView.getFloat64(this.pos, true);
            return this.pos += 8, t;
          }
          readVarint(t) {
            const n = this.buf;
            let u, h;
            return h = n[this.pos++], u = 127 & h, h < 128 ? u : (h = n[this.pos++], u |= (127 & h) << 7, h < 128 ? u : (h = n[this.pos++], u |= (127 & h) << 14, h < 128 ? u : (h = n[this.pos++], u |= (127 & h) << 21, h < 128 ? u : (h = n[this.pos], u |= (15 & h) << 28, (function(_, b, w) {
              const S = w.buf;
              let I, R;
              if (R = S[w.pos++], I = (112 & R) >> 4, R < 128 || (R = S[w.pos++], I |= (127 & R) << 3, R < 128) || (R = S[w.pos++], I |= (127 & R) << 10, R < 128) || (R = S[w.pos++], I |= (127 & R) << 17, R < 128) || (R = S[w.pos++], I |= (127 & R) << 24, R < 128) || (R = S[w.pos++], I |= (1 & R) << 31, R < 128)) return Mu(_, I, b);
              throw new Error("Expected varint not more than 10 bytes");
            })(u, t, this)))));
          }
          readVarint64() {
            return this.readVarint(true);
          }
          readSVarint() {
            const t = this.readVarint();
            return t % 2 == 1 ? (t + 1) / -2 : t / 2;
          }
          readBoolean() {
            return !!this.readVarint();
          }
          readString() {
            const t = this.readVarint() + this.pos, n = this.pos;
            return this.pos = t, t - n >= 12 && H0 ? H0.decode(this.buf.subarray(n, t)) : (function(u, h, _) {
              let b = "", w = h;
              for (; w < _; ) {
                const S = u[w];
                let I, R, B, N = null, q = S > 239 ? 4 : S > 223 ? 3 : S > 191 ? 2 : 1;
                if (w + q > _) break;
                q === 1 ? S < 128 && (N = S) : q === 2 ? (I = u[w + 1], (192 & I) == 128 && (N = (31 & S) << 6 | 63 & I, N <= 127 && (N = null))) : q === 3 ? (I = u[w + 1], R = u[w + 2], (192 & I) == 128 && (192 & R) == 128 && (N = (15 & S) << 12 | (63 & I) << 6 | 63 & R, (N <= 2047 || N >= 55296 && N <= 57343) && (N = null))) : q === 4 && (I = u[w + 1], R = u[w + 2], B = u[w + 3], (192 & I) == 128 && (192 & R) == 128 && (192 & B) == 128 && (N = (15 & S) << 18 | (63 & I) << 12 | (63 & R) << 6 | 63 & B, (N <= 65535 || N >= 1114112) && (N = null))), N === null ? (N = 65533, q = 1) : N > 65535 && (N -= 65536, b += String.fromCharCode(N >>> 10 & 1023 | 55296), N = 56320 | 1023 & N), b += String.fromCharCode(N), w += q;
              }
              return b;
            })(this.buf, n, t);
          }
          readBytes() {
            const t = this.readVarint() + this.pos, n = this.buf.subarray(this.pos, t);
            return this.pos = t, n;
          }
          readPackedVarint(t = [], n) {
            const u = this.readPackedEnd();
            for (; this.pos < u; ) t.push(this.readVarint(n));
            return t;
          }
          readPackedSVarint(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readSVarint());
            return t;
          }
          readPackedBoolean(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readBoolean());
            return t;
          }
          readPackedFloat(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readFloat());
            return t;
          }
          readPackedDouble(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readDouble());
            return t;
          }
          readPackedFixed32(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readFixed32());
            return t;
          }
          readPackedSFixed32(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readSFixed32());
            return t;
          }
          readPackedFixed64(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readFixed64());
            return t;
          }
          readPackedSFixed64(t = []) {
            const n = this.readPackedEnd();
            for (; this.pos < n; ) t.push(this.readSFixed64());
            return t;
          }
          readPackedEnd() {
            return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1;
          }
          skip(t) {
            const n = 7 & t;
            if (n === 0) for (; this.buf[this.pos++] > 127; ) ;
            else if (n === 2) this.pos = this.readVarint() + this.pos;
            else if (n === 5) this.pos += 4;
            else {
              if (n !== 1) throw new Error(`Unimplemented type: ${n}`);
              this.pos += 8;
            }
          }
          writeTag(t, n) {
            this.writeVarint(t << 3 | n);
          }
          realloc(t) {
            let n = this.length || 16;
            for (; n < this.pos + t; ) n *= 2;
            if (n !== this.length) {
              const u = new Uint8Array(n);
              u.set(this.buf), this.buf = u, this.dataView = new DataView(u.buffer), this.length = n;
            }
          }
          finish() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }
          writeFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, true), this.pos += 4;
          }
          writeSFixed32(t) {
            this.realloc(4), this.dataView.setInt32(this.pos, t, true), this.pos += 4;
          }
          writeFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, true), this.dataView.setInt32(this.pos + 4, Math.floor(t * Z0), true), this.pos += 8;
          }
          writeSFixed64(t) {
            this.realloc(8), this.dataView.setInt32(this.pos, -1 & t, true), this.dataView.setInt32(this.pos + 4, Math.floor(t * Z0), true), this.pos += 8;
          }
          writeVarint(t) {
            (t = +t || 0) > 268435455 || t < 0 ? (function(n, u) {
              let h, _;
              if (n >= 0 ? (h = n % 4294967296 | 0, _ = n / 4294967296 | 0) : (h = ~(-n % 4294967296), _ = ~(-n / 4294967296), 4294967295 ^ h ? h = h + 1 | 0 : (h = 0, _ = _ + 1 | 0)), n >= 18446744073709552e3 || n < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              u.realloc(10), (function(b, w, S) {
                S.buf[S.pos++] = 127 & b | 128, b >>>= 7, S.buf[S.pos++] = 127 & b | 128, b >>>= 7, S.buf[S.pos++] = 127 & b | 128, b >>>= 7, S.buf[S.pos++] = 127 & b | 128, S.buf[S.pos] = 127 & (b >>>= 7);
              })(h, 0, u), (function(b, w) {
                const S = (7 & b) << 4;
                w.buf[w.pos++] |= S | ((b >>>= 3) ? 128 : 0), b && (w.buf[w.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (w.buf[w.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (w.buf[w.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (w.buf[w.pos++] = 127 & b | ((b >>>= 7) ? 128 : 0), b && (w.buf[w.pos++] = 127 & b)))));
              })(_, u);
            })(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));
          }
          writeSVarint(t) {
            this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
          }
          writeBoolean(t) {
            this.writeVarint(+t);
          }
          writeString(t) {
            t = String(t), this.realloc(4 * t.length), this.pos++;
            const n = this.pos;
            this.pos = (function(h, _, b) {
              for (let w, S, I = 0; I < _.length; I++) {
                if (w = _.charCodeAt(I), w > 55295 && w < 57344) {
                  if (!S) {
                    w > 56319 || I + 1 === _.length ? (h[b++] = 239, h[b++] = 191, h[b++] = 189) : S = w;
                    continue;
                  }
                  if (w < 56320) {
                    h[b++] = 239, h[b++] = 191, h[b++] = 189, S = w;
                    continue;
                  }
                  w = S - 55296 << 10 | w - 56320 | 65536, S = null;
                } else S && (h[b++] = 239, h[b++] = 191, h[b++] = 189, S = null);
                w < 128 ? h[b++] = w : (w < 2048 ? h[b++] = w >> 6 | 192 : (w < 65536 ? h[b++] = w >> 12 | 224 : (h[b++] = w >> 18 | 240, h[b++] = w >> 12 & 63 | 128), h[b++] = w >> 6 & 63 | 128), h[b++] = 63 & w | 128);
              }
              return b;
            })(this.buf, t, this.pos);
            const u = this.pos - n;
            u >= 128 && X0(n, u, this), this.pos = n - 1, this.writeVarint(u), this.pos += u;
          }
          writeFloat(t) {
            this.realloc(4), this.dataView.setFloat32(this.pos, t, true), this.pos += 4;
          }
          writeDouble(t) {
            this.realloc(8), this.dataView.setFloat64(this.pos, t, true), this.pos += 8;
          }
          writeBytes(t) {
            const n = t.length;
            this.writeVarint(n), this.realloc(n);
            for (let u = 0; u < n; u++) this.buf[this.pos++] = t[u];
          }
          writeRawMessage(t, n) {
            this.pos++;
            const u = this.pos;
            t(n, this);
            const h = this.pos - u;
            h >= 128 && X0(u, h, this), this.pos = u - 1, this.writeVarint(h), this.pos += h;
          }
          writeMessage(t, n, u) {
            this.writeTag(t, 2), this.writeRawMessage(n, u);
          }
          writePackedVarint(t, n) {
            n.length && this.writeMessage(t, Wx, n);
          }
          writePackedSVarint(t, n) {
            n.length && this.writeMessage(t, Zx, n);
          }
          writePackedBoolean(t, n) {
            n.length && this.writeMessage(t, Yx, n);
          }
          writePackedFloat(t, n) {
            n.length && this.writeMessage(t, Hx, n);
          }
          writePackedDouble(t, n) {
            n.length && this.writeMessage(t, Xx, n);
          }
          writePackedFixed32(t, n) {
            n.length && this.writeMessage(t, Kx, n);
          }
          writePackedSFixed32(t, n) {
            n.length && this.writeMessage(t, Jx, n);
          }
          writePackedFixed64(t, n) {
            n.length && this.writeMessage(t, Qx, n);
          }
          writePackedSFixed64(t, n) {
            n.length && this.writeMessage(t, ew, n);
          }
          writeBytesField(t, n) {
            this.writeTag(t, 2), this.writeBytes(n);
          }
          writeFixed32Field(t, n) {
            this.writeTag(t, 5), this.writeFixed32(n);
          }
          writeSFixed32Field(t, n) {
            this.writeTag(t, 5), this.writeSFixed32(n);
          }
          writeFixed64Field(t, n) {
            this.writeTag(t, 1), this.writeFixed64(n);
          }
          writeSFixed64Field(t, n) {
            this.writeTag(t, 1), this.writeSFixed64(n);
          }
          writeVarintField(t, n) {
            this.writeTag(t, 0), this.writeVarint(n);
          }
          writeSVarintField(t, n) {
            this.writeTag(t, 0), this.writeSVarint(n);
          }
          writeStringField(t, n) {
            this.writeTag(t, 2), this.writeString(n);
          }
          writeFloatField(t, n) {
            this.writeTag(t, 5), this.writeFloat(n);
          }
          writeDoubleField(t, n) {
            this.writeTag(t, 1), this.writeDouble(n);
          }
          writeBooleanField(t, n) {
            this.writeVarintField(t, +n);
          }
        }
        function Mu(o, t, n) {
          return n ? 4294967296 * t + (o >>> 0) : 4294967296 * (t >>> 0) + (o >>> 0);
        }
        function X0(o, t, n) {
          const u = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
          n.realloc(u);
          for (let h = n.pos - 1; h >= o; h--) n.buf[h + u] = n.buf[h];
        }
        function Wx(o, t) {
          for (let n = 0; n < o.length; n++) t.writeVarint(o[n]);
        }
        function Zx(o, t) {
          for (let n = 0; n < o.length; n++) t.writeSVarint(o[n]);
        }
        function Hx(o, t) {
          for (let n = 0; n < o.length; n++) t.writeFloat(o[n]);
        }
        function Xx(o, t) {
          for (let n = 0; n < o.length; n++) t.writeDouble(o[n]);
        }
        function Yx(o, t) {
          for (let n = 0; n < o.length; n++) t.writeBoolean(o[n]);
        }
        function Kx(o, t) {
          for (let n = 0; n < o.length; n++) t.writeFixed32(o[n]);
        }
        function Jx(o, t) {
          for (let n = 0; n < o.length; n++) t.writeSFixed32(o[n]);
        }
        function Qx(o, t) {
          for (let n = 0; n < o.length; n++) t.writeFixed64(o[n]);
        }
        function ew(o, t) {
          for (let n = 0; n < o.length; n++) t.writeSFixed64(o[n]);
        }
        function tw(o, t, n) {
          o === 1 && n.readMessage(rw, t);
        }
        function rw(o, t, n) {
          if (o === 3) {
            const { id: u, bitmap: h, width: _, height: b, left: w, top: S, advance: I } = n.readMessage(iw, {});
            t.push({ id: u, bitmap: new sd({ width: _ + 6, height: b + 6 }, h), metrics: { width: _, height: b, left: w, top: S, advance: I } });
          }
        }
        function iw(o, t, n) {
          o === 1 ? t.id = n.readVarint() : o === 2 ? t.bitmap = n.readBytes() : o === 3 ? t.width = n.readVarint() : o === 4 ? t.height = n.readVarint() : o === 5 ? t.left = n.readSVarint() : o === 6 ? t.top = n.readSVarint() : o === 7 && (t.advance = n.readVarint());
        }
        function Y0(o) {
          let t = 0, n = 0;
          for (const b of o) t += b.w * b.h, n = Math.max(n, b.w);
          o.sort(((b, w) => w.h - b.h));
          const u = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), n), h: 1 / 0 }];
          let h = 0, _ = 0;
          for (const b of o) for (let w = u.length - 1; w >= 0; w--) {
            const S = u[w];
            if (!(b.w > S.w || b.h > S.h)) {
              if (b.x = S.x, b.y = S.y, _ = Math.max(_, b.y + b.h), h = Math.max(h, b.x + b.w), b.w === S.w && b.h === S.h) {
                const I = u.pop();
                I && w < u.length && (u[w] = I);
              } else b.h === S.h ? (S.x += b.w, S.w -= b.w) : b.w === S.w ? (S.y += b.h, S.h -= b.h) : (u.push({ x: S.x + b.w, y: S.y, w: S.w - b.w, h: b.h }), S.y += b.h, S.h -= b.h);
              break;
            }
          }
          return { w: h, h: _, fill: t / (h * _) || 0 };
        }
        class sm {
          constructor(t, { pixelRatio: n, version: u, stretchX: h, stretchY: _, content: b, textFitWidth: w, textFitHeight: S }) {
            this.paddedRect = t, this.pixelRatio = n, this.stretchX = h, this.stretchY = _, this.content = b, this.version = u, this.textFitWidth = w, this.textFitHeight = S;
          }
          get tl() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
          }
        }
        class K0 {
          constructor(t, n) {
            const u = {}, h = {};
            this.haveRenderCallbacks = [];
            const _ = [];
            this.addImages(t, u, _), this.addImages(n, h, _);
            const { w: b, h: w } = Y0(_), S = new On({ width: b || 1, height: w || 1 });
            for (const I in t) {
              const R = t[I], B = u[I].paddedRect;
              On.copy(R.data, S, { x: 0, y: 0 }, { x: B.x + 1, y: B.y + 1 }, R.data);
            }
            for (const I in n) {
              const R = n[I], B = h[I].paddedRect, N = B.x + 1, q = B.y + 1, G = R.data.width, Q = R.data.height;
              On.copy(R.data, S, { x: 0, y: 0 }, { x: N, y: q }, R.data), On.copy(R.data, S, { x: 0, y: Q - 1 }, { x: N, y: q - 1 }, { width: G, height: 1 }), On.copy(R.data, S, { x: 0, y: 0 }, { x: N, y: q + Q }, { width: G, height: 1 }), On.copy(R.data, S, { x: G - 1, y: 0 }, { x: N - 1, y: q }, { width: 1, height: Q }), On.copy(R.data, S, { x: 0, y: 0 }, { x: N + G, y: q }, { width: 1, height: Q });
            }
            this.image = S, this.iconPositions = u, this.patternPositions = h;
          }
          addImages(t, n, u) {
            for (const h in t) {
              const _ = t[h], b = { x: 0, y: 0, w: _.data.width + 2, h: _.data.height + 2 };
              u.push(b), n[h] = new sm(b, _), _.hasRenderCallback && this.haveRenderCallbacks.push(h);
            }
          }
          patchUpdatedImages(t, n) {
            t.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const u in t.updatedImages) this.patchUpdatedImage(this.iconPositions[u], t.getImage(u), n), this.patchUpdatedImage(this.patternPositions[u], t.getImage(u), n);
          }
          patchUpdatedImage(t, n, u) {
            if (!t || !n || t.version === n.version) return;
            t.version = n.version;
            const [h, _] = t.tl;
            u.update(n.data, void 0, { x: h, y: _ });
          }
        }
        var hs;
        Lt("ImagePosition", sm), Lt("ImageAtlas", K0), m.ao = void 0, (hs = m.ao || (m.ao = {}))[hs.none = 0] = "none", hs[hs.horizontal = 1] = "horizontal", hs[hs.vertical = 2] = "vertical", hs[hs.horizontalOnly = 3] = "horizontalOnly";
        class vd {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
          }
          static forText(t, n, u) {
            const h = new vd();
            return h.scale = t || 1, h.fontStack = n, h.verticalAlign = u || "bottom", h;
          }
          static forImage(t, n) {
            const u = new vd();
            return u.imageName = t, u.verticalAlign = n || "bottom", u;
          }
        }
        class Eu {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t, n) {
            const u = new Eu();
            for (let h = 0; h < t.sections.length; h++) {
              const _ = t.sections[h];
              _.image ? u.addImageSection(_) : u.addTextSection(_, n);
            }
            return u;
          }
          length() {
            return this.text.length;
          }
          getSection(t) {
            return this.sections[this.sectionIndex[t]];
          }
          getSectionIndex(t) {
            return this.sectionIndex[t];
          }
          getCharCode(t) {
            return this.text.charCodeAt(t);
          }
          verticalizePunctuation() {
            this.text = (function(t) {
              let n = "";
              for (let u = 0; u < t.length; u++) {
                const h = t.charCodeAt(u + 1) || null, _ = t.charCodeAt(u - 1) || null;
                n += h && Yc(h) && !gd[t[u + 1]] || _ && Yc(_) && !gd[t[u - 1]] || !gd[t[u]] ? t[u] : gd[t[u]];
              }
              return n;
            })(this.text);
          }
          trim() {
            let t = 0;
            for (let u = 0; u < this.text.length && lf[this.text.charCodeAt(u)]; u++) t++;
            let n = this.text.length;
            for (let u = this.text.length - 1; u >= 0 && u >= t && lf[this.text.charCodeAt(u)]; u--) n--;
            this.text = this.text.substring(t, n), this.sectionIndex = this.sectionIndex.slice(t, n);
          }
          substring(t, n) {
            const u = new Eu();
            return u.text = this.text.substring(t, n), u.sectionIndex = this.sectionIndex.slice(t, n), u.sections = this.sections, u;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce(((t, n) => Math.max(t, this.sections[n].scale)), 0);
          }
          getMaxImageSize(t) {
            let n = 0, u = 0;
            for (let h = 0; h < this.length(); h++) {
              const _ = this.getSection(h);
              if (_.imageName) {
                const b = t[_.imageName];
                if (!b) continue;
                const w = b.displaySize;
                n = Math.max(n, w[0]), u = Math.max(u, w[1]);
              }
            }
            return { maxImageWidth: n, maxImageHeight: u };
          }
          addTextSection(t, n) {
            this.text += t.text, this.sections.push(vd.forText(t.scale, t.fontStack || n, t.verticalAlign));
            const u = this.sections.length - 1;
            for (let h = 0; h < t.text.length; ++h) this.sectionIndex.push(u);
          }
          addImageSection(t) {
            const n = t.image ? t.image.name : "";
            if (n.length === 0) return void Gt("Can't add FormattedSection with an empty image.");
            const u = this.getNextImageSectionCharCode();
            u ? (this.text += String.fromCharCode(u), this.sections.push(vd.forImage(n, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : Gt("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function sf(o, t, n, u, h, _, b, w, S, I, R, B, N, q, G) {
          const Q = Eu.fromFeature(o, h);
          let ae;
          B === m.ao.vertical && Q.verticalizePunctuation();
          const { processBidirectionalText: pe, processStyledBidirectionalText: Oe } = na;
          if (pe && Q.sections.length === 1) {
            ae = [];
            const He = pe(Q.toString(), lm(Q, I, _, t, u, q));
            for (const rt of He) {
              const _t = new Eu();
              _t.text = rt, _t.sections = Q.sections;
              for (let At = 0; At < rt.length; At++) _t.sectionIndex.push(0);
              ae.push(_t);
            }
          } else if (Oe) {
            ae = [];
            const He = Oe(Q.text, Q.sectionIndex, lm(Q, I, _, t, u, q));
            for (const rt of He) {
              const _t = new Eu();
              _t.text = rt[0], _t.sectionIndex = rt[1], _t.sections = Q.sections, ae.push(_t);
            }
          } else ae = (function(He, rt) {
            const _t = [], At = He.text;
            let kt = 0;
            for (const Et of rt) _t.push(He.substring(kt, Et)), kt = Et;
            return kt < At.length && _t.push(He.substring(kt, At.length)), _t;
          })(Q, lm(Q, I, _, t, u, q));
          const Ce = [], Ie = { positionedLines: Ce, text: Q.toString(), top: R[1], bottom: R[1], left: R[0], right: R[0], writingMode: B, iconsInText: false, verticalizable: false };
          return (function(He, rt, _t, At, kt, Et, Wt, Mt, Rt, ct, or, hr) {
            let Jt = 0, Ut = 0, Ir = 0, bi = 0;
            const Bi = Mt === "right" ? 1 : Mt === "left" ? 0 : 0.5, ln = Vi / hr;
            let lo = 0;
            for (const gi of kt) {
              gi.trim();
              const Ui = gi.getMaxScale(), Yi = { positionedGlyphs: [], lineOffset: 0 };
              He.positionedLines[lo] = Yi;
              const Ki = Yi.positionedGlyphs;
              let In = 0;
              if (!gi.length()) {
                Ut += Et, ++lo;
                continue;
              }
              const uo = sw(At, gi, ln);
              for (let jn = 0; jn < gi.length(); jn++) {
                const Oi = gi.getSection(jn), Gi = gi.getSectionIndex(jn), Wi = gi.getCharCode(jn), Ri = lw(Rt, or, Wi);
                let ui;
                if (Oi.imageName) {
                  if (He.iconsInText = true, Oi.scale = Oi.scale * ln, ui = cw(Oi, Ri, Ui, uo, At), !ui) continue;
                  In = Math.max(In, ui.imageOffset);
                } else if (ui = uw(Oi, Wi, Ri, uo, rt, _t), !ui) continue;
                const { rect: jo, metrics: zu, baselineOffset: No } = ui;
                Ki.push({ glyph: Wi, imageName: Oi.imageName, x: Jt, y: Ut + No + -17, vertical: Ri, scale: Oi.scale, fontStack: Oi.fontStack, sectionIndex: Gi, metrics: zu, rect: jo }), Ri ? (He.verticalizable = true, Jt += (Oi.imageName ? zu.advance : Vi) * Oi.scale + ct) : Jt += zu.advance * Oi.scale + ct;
              }
              Ki.length !== 0 && (Ir = Math.max(Jt - ct, Ir), dw(Ki, 0, Ki.length - 1, Bi)), Jt = 0, Yi.lineOffset = Math.max(In, (Ui - 1) * Vi);
              const qi = Et * Ui + In;
              Ut += qi, bi = Math.max(qi, bi), ++lo;
            }
            const { horizontalAlign: $n, verticalAlign: Xi } = um(Wt);
            (function(gi, Ui, Yi, Ki, In, uo, qi, jn, Oi) {
              const Gi = (Ui - Yi) * In;
              let Wi = 0;
              Wi = uo !== qi ? -jn * Ki - -17 : -Ki * Oi * qi + 0.5 * qi;
              for (const Ri of gi) for (const ui of Ri.positionedGlyphs) ui.x += Gi, ui.y += Wi;
            })(He.positionedLines, Bi, $n, Xi, Ir, bi, Et, Ut, kt.length), He.top += -Xi * Ut, He.bottom = He.top + Ut, He.left += -$n * Ir, He.right = He.left + Ir;
          })(Ie, t, n, u, ae, b, w, S, B, I, N, G), !(function(He) {
            for (const rt of He) if (rt.positionedGlyphs.length !== 0) return false;
            return true;
          })(Ce) && Ie;
        }
        const lf = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, nw = { 10: true, 32: true, 38: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true }, ow = { 40: true };
        function J0(o, t, n, u, h, _) {
          if (t.imageName) {
            const b = u[t.imageName];
            return b ? b.displaySize[0] * t.scale * Vi / _ + h : 0;
          }
          {
            const b = n[t.fontStack], w = b && b[o];
            return w ? w.metrics.advance * t.scale + h : 0;
          }
        }
        function Q0(o, t, n, u) {
          const h = Math.pow(o - t, 2);
          return u ? o < t ? h / 2 : 2 * h : h + Math.abs(n) * n;
        }
        function aw(o, t, n) {
          let u = 0;
          return o === 10 && (u -= 1e4), n && (u += 150), o !== 40 && o !== 65288 || (u += 50), t !== 41 && t !== 65289 || (u += 50), u;
        }
        function ev(o, t, n, u, h, _) {
          let b = null, w = Q0(t, n, h, _);
          for (const S of u) {
            const I = Q0(t - S.x, n, h, _) + S.badness;
            I <= w && (b = S, w = I);
          }
          return { index: o, x: t, priorBreak: b, badness: w };
        }
        function tv(o) {
          return o ? tv(o.priorBreak).concat(o.index) : [];
        }
        function lm(o, t, n, u, h, _) {
          if (!o) return [];
          const b = [], w = (function(B, N, q, G, Q, ae) {
            let pe = 0;
            for (let Oe = 0; Oe < B.length(); Oe++) {
              const Ce = B.getSection(Oe);
              pe += J0(B.getCharCode(Oe), Ce, G, Q, N, ae);
            }
            return pe / Math.max(1, Math.ceil(pe / q));
          })(o, t, n, u, h, _), S = o.text.indexOf("\u200B") >= 0;
          let I = 0;
          for (let B = 0; B < o.length(); B++) {
            const N = o.getSection(B), q = o.getCharCode(B);
            if (lf[q] || (I += J0(q, N, u, h, t, _)), B < o.length() - 1) {
              const G = !((R = q) < 11904) && (!!kr["CJK Compatibility Forms"](R) || !!kr["CJK Compatibility"](R) || !!kr["CJK Strokes"](R) || !!kr["CJK Symbols and Punctuation"](R) || !!kr["Enclosed CJK Letters and Months"](R) || !!kr["Halfwidth and Fullwidth Forms"](R) || !!kr["Ideographic Description Characters"](R) || !!kr["Vertical Forms"](R) || Zh.test(String.fromCodePoint(R)));
              (nw[q] || G || N.imageName || B !== o.length() - 2 && ow[o.getCharCode(B + 1)]) && b.push(ev(B + 1, I, w, b, aw(q, o.getCharCode(B + 1), G && S), false));
            }
          }
          var R;
          return tv(ev(o.length(), I, w, b, 0, true));
        }
        function um(o) {
          let t = 0.5, n = 0.5;
          switch (o) {
            case "right":
            case "top-right":
            case "bottom-right":
              t = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              t = 0;
          }
          switch (o) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              n = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              n = 0;
          }
          return { horizontalAlign: t, verticalAlign: n };
        }
        function sw(o, t, n) {
          const u = t.getMaxScale() * Vi, { maxImageWidth: h, maxImageHeight: _ } = t.getMaxImageSize(o), b = Math.max(u, _ * n);
          return { verticalLineContentWidth: Math.max(u, h * n), horizontalLineContentHeight: b };
        }
        function rv(o) {
          switch (o) {
            case "top":
              return 0;
            case "center":
              return 0.5;
            default:
              return 1;
          }
        }
        function lw(o, t, n) {
          return !(o === m.ao.horizontal || !t && !Xc(n) || t && (lf[n] || (u = n, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(u)))));
          var u;
        }
        function uw(o, t, n, u, h, _) {
          const b = _[o.fontStack], w = (function(I, R, B, N) {
            if (I && I.rect) return I;
            const q = R[B.fontStack], G = q && q[N];
            return G ? { rect: null, metrics: G.metrics } : null;
          })(b && b[t], h, o, t);
          if (w === null) return null;
          let S;
          if (n) S = u.verticalLineContentWidth - o.scale * Vi;
          else {
            const I = rv(o.verticalAlign);
            S = (u.horizontalLineContentHeight - o.scale * Vi) * I;
          }
          return { rect: w.rect, metrics: w.metrics, baselineOffset: S };
        }
        function cw(o, t, n, u, h) {
          const _ = h[o.imageName];
          if (!_) return null;
          const b = _.paddedRect, w = _.displaySize, S = { width: w[0], height: w[1], left: 1, top: -3, advance: t ? w[1] : w[0] };
          let I;
          if (t) I = u.verticalLineContentWidth - w[1] * o.scale;
          else {
            const R = rv(o.verticalAlign);
            I = (u.horizontalLineContentHeight - w[1] * o.scale) * R;
          }
          return { rect: b, metrics: S, baselineOffset: I, imageOffset: (t ? w[0] : w[1]) * o.scale - Vi * n };
        }
        function dw(o, t, n, u) {
          if (u === 0) return;
          const h = o[n], _ = (o[n].x + h.metrics.advance * h.scale) * u;
          for (let b = t; b <= n; b++) o[b].x -= _;
        }
        function hw(o, t, n) {
          const { horizontalAlign: u, verticalAlign: h } = um(n), _ = t[0] - o.displaySize[0] * u, b = t[1] - o.displaySize[1] * h;
          return { image: o, top: b, bottom: b + o.displaySize[1], left: _, right: _ + o.displaySize[0] };
        }
        function iv(o) {
          var t, n;
          let u = o.left, h = o.top, _ = o.right - u, b = o.bottom - h;
          const w = (t = o.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink", S = (n = o.image.textFitHeight) !== null && n !== void 0 ? n : "stretchOrShrink", I = (o.image.content[2] - o.image.content[0]) / (o.image.content[3] - o.image.content[1]);
          if (S === "proportional") {
            if (w === "stretchOnly" && _ / b < I || w === "proportional") {
              const R = Math.ceil(b * I);
              u *= R / _, _ = R;
            }
          } else if (w === "proportional" && S === "stretchOnly" && I !== 0 && _ / b > I) {
            const R = Math.ceil(_ / I);
            h *= R / b, b = R;
          }
          return { x1: u, y1: h, x2: u + _, y2: h + b };
        }
        function nv(o, t, n, u, h, _) {
          const b = o.image;
          let w;
          if (b.content) {
            const ae = b.content, pe = b.pixelRatio || 1;
            w = [ae[0] / pe, ae[1] / pe, b.displaySize[0] - ae[2] / pe, b.displaySize[1] - ae[3] / pe];
          }
          const S = t.left * _, I = t.right * _;
          let R, B, N, q;
          n === "width" || n === "both" ? (q = h[0] + S - u[3], B = h[0] + I + u[1]) : (q = h[0] + (S + I - b.displaySize[0]) / 2, B = q + b.displaySize[0]);
          const G = t.top * _, Q = t.bottom * _;
          return n === "height" || n === "both" ? (R = h[1] + G - u[0], N = h[1] + Q + u[2]) : (R = h[1] + (G + Q - b.displaySize[1]) / 2, N = R + b.displaySize[1]), { image: b, top: R, right: B, bottom: N, left: q, collisionPadding: w };
        }
        const Va = 128, fs = 32640;
        function ov(o, t) {
          const { expression: n } = t;
          if (n.kind === "constant") return { kind: "constant", layoutSize: n.evaluate(new qr(o + 1)) };
          if (n.kind === "source") return { kind: "source" };
          {
            const { zoomStops: u, interpolationType: h } = n;
            let _ = 0;
            for (; _ < u.length && u[_] <= o; ) _++;
            _ = Math.max(0, _ - 1);
            let b = _;
            for (; b < u.length && u[b] < o + 1; ) b++;
            b = Math.min(u.length - 1, b);
            const w = u[_], S = u[b];
            return n.kind === "composite" ? { kind: "composite", minZoom: w, maxZoom: S, interpolationType: h } : { kind: "camera", minZoom: w, maxZoom: S, minSize: n.evaluate(new qr(w)), maxSize: n.evaluate(new qr(S)), interpolationType: h };
          }
        }
        function cm(o, t, n) {
          let u = "never";
          const h = o.get(t);
          return h ? u = h : o.get(n) && (u = "always"), u;
        }
        const fw = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function uf(o, t, n, u, h, _, b, w, S, I, R, B, N) {
          const q = w ? Math.min(fs, Math.round(w[0])) : 0, G = w ? Math.min(fs, Math.round(w[1])) : 0;
          o.emplaceBack(t, n, Math.round(32 * u), Math.round(32 * h), _, b, (q << 1) + (S ? 1 : 0), G, 16 * I, 16 * R, 256 * B, 256 * N);
        }
        function dm(o, t, n) {
          o.emplaceBack(t.x, t.y, n), o.emplaceBack(t.x, t.y, n), o.emplaceBack(t.x, t.y, n), o.emplaceBack(t.x, t.y, n);
        }
        function pw(o) {
          for (const t of o.sections) if (cu(t.text)) return true;
          return false;
        }
        class hm {
          constructor(t) {
            this.layoutVertexArray = new Vt(), this.indexArray = new Hr(), this.programConfigurations = t, this.segments = new Ar(), this.dynamicLayoutVertexArray = new _r(), this.opacityVertexArray = new Or(), this.hasVisibleVertices = false, this.placedSymbolArray = new le();
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
          }
          upload(t, n, u, h) {
            this.isEmpty() || (u && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Nx.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, n), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Vx.members, true), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, fw, true), this.opacityVertexBuffer.itemSize = 1), (u || h) && this.programConfigurations.upload(t));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        Lt("SymbolBuffers", hm);
        class fm {
          constructor(t, n, u) {
            this.layoutVertexArray = new t(), this.layoutAttributes = n, this.indexArray = new u(), this.segments = new Ar(), this.collisionVertexArray = new ei();
          }
          upload(t) {
            this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Ux.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        Lt("CollisionBuffers", fm);
        class Ru {
          constructor(t) {
            this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((b) => b.id)), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const n = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = ov(this.zoom, n["text-size"]), this.iconSizeData = ov(this.zoom, n["icon-size"]);
            const u = this.layers[0].layout, h = u.get("symbol-sort-key"), _ = u.get("symbol-z-order");
            this.canOverlap = cm(u, "text-overlap", "text-allow-overlap") !== "never" || cm(u, "icon-overlap", "icon-allow-overlap") !== "never" || u.get("text-ignore-placement") || u.get("icon-ignore-placement"), this.sortFeaturesByKey = _ !== "viewport-y" && !h.isConstant(), this.sortFeaturesByY = (_ === "viewport-y" || _ === "auto" && !this.sortFeaturesByKey) && this.canOverlap, u.get("symbol-placement") === "point" && (this.writingModes = u.get("text-writing-mode").map(((b) => m.ao[b]))), this.stateDependentLayerIds = this.layers.filter(((b) => b.isStateDependent())).map(((b) => b.id)), this.sourceID = t.sourceID;
          }
          createArrays() {
            this.text = new hm(new ua(this.layers, this.zoom, ((t) => /^text/.test(t)))), this.icon = new hm(new ua(this.layers, this.zoom, ((t) => /^icon/.test(t)))), this.glyphOffsetArray = new we(), this.lineVertexArray = new _e(), this.symbolInstances = new me(), this.textAnchorOffsets = new Me();
          }
          calculateGlyphDependencies(t, n, u, h, _) {
            for (let b = 0; b < t.length; b++) if (n[t.charCodeAt(b)] = true, (u || h) && _) {
              const w = gd[t.charAt(b)];
              w && (n[w.charCodeAt(0)] = true);
            }
          }
          populate(t, n, u) {
            const h = this.layers[0], _ = h.layout, b = _.get("text-font"), w = _.get("text-field"), S = _.get("icon-image"), I = (w.value.kind !== "constant" || w.value.value instanceof pn && !w.value.value.isEmpty() || w.value.value.toString().length > 0) && (b.value.kind !== "constant" || b.value.value.length > 0), R = S.value.kind !== "constant" || !!S.value.value || Object.keys(S.parameters).length > 0, B = _.get("symbol-sort-key");
            if (this.features = [], !I && !R) return;
            const N = n.iconDependencies, q = n.glyphDependencies, G = n.availableImages, Q = new qr(this.zoom);
            for (const { feature: ae, id: pe, index: Oe, sourceLayerIndex: Ce } of t) {
              const Ie = h._featureFilter.needGeometry, He = al(ae, Ie);
              if (!h._featureFilter.filter(Q, He, u)) continue;
              let rt, _t;
              if (Ie || (He.geometry = ol(ae)), I) {
                const kt = h.getValueAndResolveTokens("text-field", He, u, G), Et = pn.factory(kt), Wt = this.hasRTLText = this.hasRTLText || pw(Et);
                (!Wt || na.getRTLTextPluginStatus() === "unavailable" || Wt && na.isParsed()) && (rt = Gx(Et, h, He));
              }
              if (R) {
                const kt = h.getValueAndResolveTokens("icon-image", He, u, G);
                _t = kt instanceof zn ? kt : zn.fromString(kt);
              }
              if (!rt && !_t) continue;
              const At = this.sortFeaturesByKey ? B.evaluate(He, {}, u) : void 0;
              if (this.features.push({ id: pe, text: rt, icon: _t, index: Oe, sourceLayerIndex: Ce, geometry: He.geometry, properties: ae.properties, type: Iu.types[ae.type], sortKey: At }), _t && (N[_t.name] = true), rt) {
                const kt = b.evaluate(He, {}, u).join(","), Et = _.get("text-rotation-alignment") !== "viewport" && _.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(m.ao.vertical) >= 0;
                for (const Wt of rt.sections) if (Wt.image) N[Wt.image.name] = true;
                else {
                  const Mt = Zc(rt.toString()), Rt = Wt.fontStack || kt, ct = q[Rt] = q[Rt] || {};
                  this.calculateGlyphDependencies(Wt.text, ct, Et, this.allowVerticalPlacement, Mt);
                }
              }
            }
            _.get("symbol-placement") === "line" && (this.features = (function(ae) {
              const pe = {}, Oe = {}, Ce = [];
              let Ie = 0;
              function He(kt) {
                Ce.push(ae[kt]), Ie++;
              }
              function rt(kt, Et, Wt) {
                const Mt = Oe[kt];
                return delete Oe[kt], Oe[Et] = Mt, Ce[Mt].geometry[0].pop(), Ce[Mt].geometry[0] = Ce[Mt].geometry[0].concat(Wt[0]), Mt;
              }
              function _t(kt, Et, Wt) {
                const Mt = pe[Et];
                return delete pe[Et], pe[kt] = Mt, Ce[Mt].geometry[0].shift(), Ce[Mt].geometry[0] = Wt[0].concat(Ce[Mt].geometry[0]), Mt;
              }
              function At(kt, Et, Wt) {
                const Mt = Wt ? Et[0][Et[0].length - 1] : Et[0][0];
                return `${kt}:${Mt.x}:${Mt.y}`;
              }
              for (let kt = 0; kt < ae.length; kt++) {
                const Et = ae[kt], Wt = Et.geometry, Mt = Et.text ? Et.text.toString() : null;
                if (!Mt) {
                  He(kt);
                  continue;
                }
                const Rt = At(Mt, Wt), ct = At(Mt, Wt, true);
                if (Rt in Oe && ct in pe && Oe[Rt] !== pe[ct]) {
                  const or = _t(Rt, ct, Wt), hr = rt(Rt, ct, Ce[or].geometry);
                  delete pe[Rt], delete Oe[ct], Oe[At(Mt, Ce[hr].geometry, true)] = hr, Ce[or].geometry = null;
                } else Rt in Oe ? rt(Rt, ct, Wt) : ct in pe ? _t(Rt, ct, Wt) : (He(kt), pe[Rt] = Ie - 1, Oe[ct] = Ie - 1);
              }
              return Ce.filter(((kt) => kt.geometry));
            })(this.features)), this.sortFeaturesByKey && this.features.sort(((ae, pe) => ae.sortKey - pe.sortKey));
          }
          update(t, n, u) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, n, this.layers, { imagePositions: u }), this.icon.programConfigurations.updatePaintArrays(t, n, this.layers, { imagePositions: u }));
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t, n) {
            const u = this.lineVertexArray.length;
            if (t.segment !== void 0) {
              let h = t.dist(n[t.segment + 1]), _ = t.dist(n[t.segment]);
              const b = {};
              for (let w = t.segment + 1; w < n.length; w++) b[w] = { x: n[w].x, y: n[w].y, tileUnitDistanceFromAnchor: h }, w < n.length - 1 && (h += n[w + 1].dist(n[w]));
              for (let w = t.segment || 0; w >= 0; w--) b[w] = { x: n[w].x, y: n[w].y, tileUnitDistanceFromAnchor: _ }, w > 0 && (_ += n[w - 1].dist(n[w]));
              for (let w = 0; w < n.length; w++) {
                const S = b[w];
                this.lineVertexArray.emplaceBack(S.x, S.y, S.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: u, lineLength: this.lineVertexArray.length - u };
          }
          addSymbols(t, n, u, h, _, b, w, S, I, R, B, N) {
            const q = t.indexArray, G = t.layoutVertexArray, Q = t.segments.prepareSegment(4 * n.length, G, q, this.canOverlap ? b.sortKey : void 0), ae = this.glyphOffsetArray.length, pe = Q.vertexLength, Oe = this.allowVerticalPlacement && w === m.ao.vertical ? Math.PI / 2 : 0, Ce = b.text && b.text.sections;
            for (let Ie = 0; Ie < n.length; Ie++) {
              const { tl: He, tr: rt, bl: _t, br: At, tex: kt, pixelOffsetTL: Et, pixelOffsetBR: Wt, minFontScaleX: Mt, minFontScaleY: Rt, glyphOffset: ct, isSDF: or, sectionIndex: hr } = n[Ie], Jt = Q.vertexLength, Ut = ct[1];
              uf(G, S.x, S.y, He.x, Ut + He.y, kt.x, kt.y, u, or, Et.x, Et.y, Mt, Rt), uf(G, S.x, S.y, rt.x, Ut + rt.y, kt.x + kt.w, kt.y, u, or, Wt.x, Et.y, Mt, Rt), uf(G, S.x, S.y, _t.x, Ut + _t.y, kt.x, kt.y + kt.h, u, or, Et.x, Wt.y, Mt, Rt), uf(G, S.x, S.y, At.x, Ut + At.y, kt.x + kt.w, kt.y + kt.h, u, or, Wt.x, Wt.y, Mt, Rt), dm(t.dynamicLayoutVertexArray, S, Oe), q.emplaceBack(Jt, Jt + 2, Jt + 1), q.emplaceBack(Jt + 1, Jt + 2, Jt + 3), Q.vertexLength += 4, Q.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(ct[0]), Ie !== n.length - 1 && hr === n[Ie + 1].sectionIndex || t.programConfigurations.populatePaintArrays(G.length, b, b.index, { imagePositions: {}, canonical: N, formattedSection: Ce && Ce[hr] });
            }
            t.placedSymbolArray.emplaceBack(S.x, S.y, ae, this.glyphOffsetArray.length - ae, pe, I, R, S.segment, u ? u[0] : 0, u ? u[1] : 0, h[0], h[1], w, 0, false, 0, B);
          }
          _addCollisionDebugVertex(t, n, u, h, _, b) {
            return n.emplaceBack(0, 0), t.emplaceBack(u.x, u.y, h, _, Math.round(b.x), Math.round(b.y));
          }
          addCollisionDebugVertices(t, n, u, h, _, b, w) {
            const S = _.segments.prepareSegment(4, _.layoutVertexArray, _.indexArray), I = S.vertexLength, R = _.layoutVertexArray, B = _.collisionVertexArray, N = w.anchorX, q = w.anchorY;
            this._addCollisionDebugVertex(R, B, b, N, q, new C(t, n)), this._addCollisionDebugVertex(R, B, b, N, q, new C(u, n)), this._addCollisionDebugVertex(R, B, b, N, q, new C(u, h)), this._addCollisionDebugVertex(R, B, b, N, q, new C(t, h)), S.vertexLength += 4;
            const G = _.indexArray;
            G.emplaceBack(I, I + 1), G.emplaceBack(I + 1, I + 2), G.emplaceBack(I + 2, I + 3), G.emplaceBack(I + 3, I), S.primitiveLength += 4;
          }
          addDebugCollisionBoxes(t, n, u, h) {
            for (let _ = t; _ < n; _++) {
              const b = this.collisionBoxArray.get(_);
              this.addCollisionDebugVertices(b.x1, b.y1, b.x2, b.y2, h ? this.textCollisionBox : this.iconCollisionBox, b.anchorPoint, u);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new fm(hi, W0.members, fi), this.iconCollisionBox = new fm(hi, W0.members, fi);
            for (let t = 0; t < this.symbolInstances.length; t++) {
              const n = this.symbolInstances.get(t);
              this.addDebugCollisionBoxes(n.textBoxStartIndex, n.textBoxEndIndex, n, true), this.addDebugCollisionBoxes(n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n, true), this.addDebugCollisionBoxes(n.iconBoxStartIndex, n.iconBoxEndIndex, n, false), this.addDebugCollisionBoxes(n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex, n, false);
            }
          }
          _deserializeCollisionBoxesForSymbol(t, n, u, h, _, b, w, S, I) {
            const R = {};
            for (let B = n; B < u; B++) {
              const N = t.get(B);
              R.textBox = { x1: N.x1, y1: N.y1, x2: N.x2, y2: N.y2, anchorPointX: N.anchorPointX, anchorPointY: N.anchorPointY }, R.textFeatureIndex = N.featureIndex;
              break;
            }
            for (let B = h; B < _; B++) {
              const N = t.get(B);
              R.verticalTextBox = { x1: N.x1, y1: N.y1, x2: N.x2, y2: N.y2, anchorPointX: N.anchorPointX, anchorPointY: N.anchorPointY }, R.verticalTextFeatureIndex = N.featureIndex;
              break;
            }
            for (let B = b; B < w; B++) {
              const N = t.get(B);
              R.iconBox = { x1: N.x1, y1: N.y1, x2: N.x2, y2: N.y2, anchorPointX: N.anchorPointX, anchorPointY: N.anchorPointY }, R.iconFeatureIndex = N.featureIndex;
              break;
            }
            for (let B = S; B < I; B++) {
              const N = t.get(B);
              R.verticalIconBox = { x1: N.x1, y1: N.y1, x2: N.x2, y2: N.y2, anchorPointX: N.anchorPointX, anchorPointY: N.anchorPointY }, R.verticalIconFeatureIndex = N.featureIndex;
              break;
            }
            return R;
          }
          deserializeCollisionBoxes(t) {
            this.collisionArrays = [];
            for (let n = 0; n < this.symbolInstances.length; n++) {
              const u = this.symbolInstances.get(n);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, u.textBoxStartIndex, u.textBoxEndIndex, u.verticalTextBoxStartIndex, u.verticalTextBoxEndIndex, u.iconBoxStartIndex, u.iconBoxEndIndex, u.verticalIconBoxStartIndex, u.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t, n) {
            const u = t.placedSymbolArray.get(n), h = u.vertexStartIndex + 4 * u.numGlyphs;
            for (let _ = u.vertexStartIndex; _ < h; _ += 4) t.indexArray.emplaceBack(_, _ + 2, _ + 1), t.indexArray.emplaceBack(_ + 1, _ + 2, _ + 3);
          }
          getSortedSymbolIndexes(t) {
            if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const n = Math.sin(t), u = Math.cos(t), h = [], _ = [], b = [];
            for (let w = 0; w < this.symbolInstances.length; ++w) {
              b.push(w);
              const S = this.symbolInstances.get(w);
              h.push(0 | Math.round(n * S.anchorX + u * S.anchorY)), _.push(S.featureIndex);
            }
            return b.sort(((w, S) => h[w] - h[S] || _[S] - _[w])), b;
          }
          addToSortKeyRanges(t, n) {
            const u = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            u && u.sortKey === n ? u.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({ sortKey: n, symbolInstanceStart: t, symbolInstanceEnd: t + 1 });
          }
          sortFeatures(t) {
            if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const n of this.symbolInstanceIndexes) {
                const u = this.symbolInstances.get(n);
                this.featureSortOrder.push(u.featureIndex), [u.rightJustifiedTextSymbolIndex, u.centerJustifiedTextSymbolIndex, u.leftJustifiedTextSymbolIndex].forEach(((h, _, b) => {
                  h >= 0 && b.indexOf(h) === _ && this.addIndicesForPlacedSymbol(this.text, h);
                })), u.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, u.verticalPlacedTextSymbolIndex), u.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, u.placedIconSymbolIndex), u.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, u.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let av, sv;
        Lt("SymbolBucket", Ru, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Ru.MAX_GLYPHS = 65535, Ru.addDynamicAttributes = dm;
        var pm = { get paint() {
          return sv = sv || new an({ "icon-opacity": new Xt(Te.paint_symbol["icon-opacity"]), "icon-color": new Xt(Te.paint_symbol["icon-color"]), "icon-halo-color": new Xt(Te.paint_symbol["icon-halo-color"]), "icon-halo-width": new Xt(Te.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Xt(Te.paint_symbol["icon-halo-blur"]), "icon-translate": new qt(Te.paint_symbol["icon-translate"]), "icon-translate-anchor": new qt(Te.paint_symbol["icon-translate-anchor"]), "text-opacity": new Xt(Te.paint_symbol["text-opacity"]), "text-color": new Xt(Te.paint_symbol["text-color"], { runtimeType: ni, getOverride: (o) => o.textColor, hasOverride: (o) => !!o.textColor }), "text-halo-color": new Xt(Te.paint_symbol["text-halo-color"]), "text-halo-width": new Xt(Te.paint_symbol["text-halo-width"]), "text-halo-blur": new Xt(Te.paint_symbol["text-halo-blur"]), "text-translate": new qt(Te.paint_symbol["text-translate"]), "text-translate-anchor": new qt(Te.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return av = av || new an({ "symbol-placement": new qt(Te.layout_symbol["symbol-placement"]), "symbol-spacing": new qt(Te.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new qt(Te.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Xt(Te.layout_symbol["symbol-sort-key"]), "symbol-z-order": new qt(Te.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new qt(Te.layout_symbol["icon-allow-overlap"]), "icon-overlap": new qt(Te.layout_symbol["icon-overlap"]), "icon-ignore-placement": new qt(Te.layout_symbol["icon-ignore-placement"]), "icon-optional": new qt(Te.layout_symbol["icon-optional"]), "icon-rotation-alignment": new qt(Te.layout_symbol["icon-rotation-alignment"]), "icon-size": new Xt(Te.layout_symbol["icon-size"]), "icon-text-fit": new qt(Te.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new qt(Te.layout_symbol["icon-text-fit-padding"]), "icon-image": new Xt(Te.layout_symbol["icon-image"]), "icon-rotate": new Xt(Te.layout_symbol["icon-rotate"]), "icon-padding": new Xt(Te.layout_symbol["icon-padding"]), "icon-keep-upright": new qt(Te.layout_symbol["icon-keep-upright"]), "icon-offset": new Xt(Te.layout_symbol["icon-offset"]), "icon-anchor": new Xt(Te.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new qt(Te.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new qt(Te.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new qt(Te.layout_symbol["text-rotation-alignment"]), "text-field": new Xt(Te.layout_symbol["text-field"]), "text-font": new Xt(Te.layout_symbol["text-font"]), "text-size": new Xt(Te.layout_symbol["text-size"]), "text-max-width": new Xt(Te.layout_symbol["text-max-width"]), "text-line-height": new qt(Te.layout_symbol["text-line-height"]), "text-letter-spacing": new Xt(Te.layout_symbol["text-letter-spacing"]), "text-justify": new Xt(Te.layout_symbol["text-justify"]), "text-radial-offset": new Xt(Te.layout_symbol["text-radial-offset"]), "text-variable-anchor": new qt(Te.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new Xt(Te.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new Xt(Te.layout_symbol["text-anchor"]), "text-max-angle": new qt(Te.layout_symbol["text-max-angle"]), "text-writing-mode": new qt(Te.layout_symbol["text-writing-mode"]), "text-rotate": new Xt(Te.layout_symbol["text-rotate"]), "text-padding": new qt(Te.layout_symbol["text-padding"]), "text-keep-upright": new qt(Te.layout_symbol["text-keep-upright"]), "text-transform": new Xt(Te.layout_symbol["text-transform"]), "text-offset": new Xt(Te.layout_symbol["text-offset"]), "text-allow-overlap": new qt(Te.layout_symbol["text-allow-overlap"]), "text-overlap": new qt(Te.layout_symbol["text-overlap"]), "text-ignore-placement": new qt(Te.layout_symbol["text-ignore-placement"]), "text-optional": new qt(Te.layout_symbol["text-optional"]) });
        } };
        class lv {
          constructor(t) {
            if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t.property.overrides ? t.property.overrides.runtimeType : $r, this.defaultValue = t;
          }
          evaluate(t) {
            if (t.formattedSection) {
              const n = this.defaultValue.property.overrides;
              if (n && n.hasOverride(t.formattedSection)) return n.getOverride(t.formattedSection);
            }
            return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t) {
            this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        Lt("FormatSectionOverride", lv, { omit: ["defaultValue"] });
        class cf extends no {
          constructor(t, n) {
            super(t, pm, n);
          }
          recalculate(t, n) {
            if (super.recalculate(t, n), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const u = this.layout.get("text-writing-mode");
              if (u) {
                const h = [];
                for (const _ of u) h.indexOf(_) < 0 && h.push(_);
                this.layout._values["text-writing-mode"] = h;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t, n, u, h) {
            const _ = this.layout.get(t).evaluate(n, {}, u, h), b = this._unevaluatedLayout._values[t];
            return b.isDataDriven() || eu(b.value) || !_ ? _ : (function(w, S) {
              return S.replace(/{([^{}]+)}/g, ((I, R) => w && R in w ? String(w[R]) : ""));
            })(n.properties, _);
          }
          createBucket(t) {
            return new Ru(t);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const t of pm.paint.overridableProperties) {
              if (!cf.hasPaintOverride(this.layout, t)) continue;
              const n = this.paint.get(t), u = new lv(n), h = new Dc(u, n.property.specification);
              let _ = null;
              _ = n.value.kind === "constant" || n.value.kind === "source" ? new Hs("source", h) : new zc("composite", h, n.value.zoomStops), this.paint._values[t] = new So(n.property, _, n.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t, n, u) {
            return !(!this.layout || n.isDataDriven() || u.isDataDriven()) && cf.hasPaintOverride(this.layout, t);
          }
          static hasPaintOverride(t, n) {
            const u = t.get("text-field"), h = pm.paint.properties[n];
            let _ = false;
            const b = (w) => {
              for (const S of w) if (h.overrides && h.overrides.hasOverride(S)) return void (_ = true);
            };
            if (u.value.kind === "constant" && u.value.value instanceof pn) b(u.value.value.sections);
            else if (u.value.kind === "source" || u.value.kind === "composite") {
              const w = (I) => {
                _ || (I instanceof zo && nr(I.value) === qn ? b(I.value.sections) : I instanceof ka ? b(I.sections) : I.eachChild(w));
              }, S = u.value;
              S._styleExpression && w(S._styleExpression.expression);
            }
            return _;
          }
        }
        let uv;
        var mw = { get paint() {
          return uv = uv || new an({ "background-color": new qt(Te.paint_background["background-color"]), "background-pattern": new ed(Te.paint_background["background-pattern"]), "background-opacity": new qt(Te.paint_background["background-opacity"]) });
        } };
        class gw extends no {
          constructor(t, n) {
            super(t, mw, n);
          }
        }
        let cv;
        var vw = { get paint() {
          return cv = cv || new an({ "raster-opacity": new qt(Te.paint_raster["raster-opacity"]), "raster-hue-rotate": new qt(Te.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new qt(Te.paint_raster["raster-brightness-min"]), "raster-brightness-max": new qt(Te.paint_raster["raster-brightness-max"]), "raster-saturation": new qt(Te.paint_raster["raster-saturation"]), "raster-contrast": new qt(Te.paint_raster["raster-contrast"]), "raster-resampling": new qt(Te.paint_raster["raster-resampling"]), "raster-fade-duration": new qt(Te.paint_raster["raster-fade-duration"]) });
        } };
        class _w extends no {
          constructor(t, n) {
            super(t, vw, n);
          }
        }
        class yw extends no {
          constructor(t, n) {
            super(t, {}, n), this.onAdd = (u) => {
              this.implementation.onAdd && this.implementation.onAdd(u, u.painter.context.gl);
            }, this.onRemove = (u) => {
              this.implementation.onRemove && this.implementation.onRemove(u, u.painter.context.gl);
            }, this.implementation = t;
          }
          is3D() {
            return this.implementation.renderingMode === "3d";
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return false;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class bw {
          constructor(t) {
            this._methodToThrottle = t, this._triggered = false, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout((() => {
              this._triggered = false, this._methodToThrottle();
            }), 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const xw = { once: true }, mm = 63710088e-1;
        class ps {
          constructor(t, n) {
            if (isNaN(t) || isNaN(n)) throw new Error(`Invalid LngLat object: (${t}, ${n})`);
            if (this.lng = +t, this.lat = +n, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new ps(pr(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t) {
            const n = Math.PI / 180, u = this.lat * n, h = t.lat * n, _ = Math.sin(u) * Math.sin(h) + Math.cos(u) * Math.cos(h) * Math.cos((t.lng - this.lng) * n);
            return mm * Math.acos(Math.min(_, 1));
          }
          static convert(t) {
            if (t instanceof ps) return t;
            if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new ps(Number(t[0]), Number(t[1]));
            if (!Array.isArray(t) && typeof t == "object" && t !== null) return new ps(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const dv = 2 * Math.PI * mm;
        function hv(o) {
          return dv * Math.cos(o * Math.PI / 180);
        }
        function fv(o) {
          return (180 + o) / 360;
        }
        function pv(o) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + o * Math.PI / 360))) / 360;
        }
        function mv(o, t) {
          return o / hv(t);
        }
        function gm(o) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * o) * Math.PI / 180)) - 90;
        }
        function gv(o, t) {
          return o * hv(gm(t));
        }
        class _d {
          constructor(t, n, u = 0) {
            this.x = +t, this.y = +n, this.z = +u;
          }
          static fromLngLat(t, n = 0) {
            const u = ps.convert(t);
            return new _d(fv(u.lng), pv(u.lat), mv(n, u.lat));
          }
          toLngLat() {
            return new ps(360 * this.x - 180, gm(this.y));
          }
          toAltitude() {
            return gv(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / dv * (t = gm(this.y), 1 / Math.cos(t * Math.PI / 180));
            var t;
          }
        }
        function vv(o, t, n) {
          var u = 2 * Math.PI * 6378137 / 256 / Math.pow(2, n);
          return [o * u - 2 * Math.PI * 6378137 / 2, t * u - 2 * Math.PI * 6378137 / 2];
        }
        class vm {
          constructor(t, n, u) {
            if (!(function(h, _, b) {
              return !(h < 0 || h > 25 || b < 0 || b >= Math.pow(2, h) || _ < 0 || _ >= Math.pow(2, h));
            })(t, n, u)) throw new Error(`x=${n}, y=${u}, z=${t} outside of bounds. 0<=x<${Math.pow(2, t)}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `);
            this.z = t, this.x = n, this.y = u, this.key = Au(0, t, t, n, u);
          }
          equals(t) {
            return this.z === t.z && this.x === t.x && this.y === t.y;
          }
          url(t, n, u) {
            const h = (b = this.y, w = this.z, S = vv(256 * (_ = this.x), 256 * (b = Math.pow(2, w) - b - 1), w), I = vv(256 * (_ + 1), 256 * (b + 1), w), S[0] + "," + S[1] + "," + I[0] + "," + I[1]);
            var _, b, w, S, I;
            const R = (function(B, N, q) {
              let G, Q = "";
              for (let ae = B; ae > 0; ae--) G = 1 << ae - 1, Q += (N & G ? 1 : 0) + (q & G ? 2 : 0);
              return Q;
            })(this.z, this.x, this.y);
            return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(u === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, n > 1 ? "@2x" : "").replace(/{quadkey}/g, R).replace(/{bbox-epsg-3857}/g, h);
          }
          isChildOf(t) {
            const n = this.z - t.z;
            return n > 0 && t.x === this.x >> n && t.y === this.y >> n;
          }
          getTilePoint(t) {
            const n = Math.pow(2, this.z);
            return new C((t.x * n - this.x) * et, (t.y * n - this.y) * et);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class _v {
          constructor(t, n) {
            this.wrap = t, this.canonical = n, this.key = Au(t, n.z, n.z, n.x, n.y);
          }
        }
        class so {
          constructor(t, n, u, h, _) {
            if (this.terrainRttPosMatrix32f = null, t < u) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${u}`);
            this.overscaledZ = t, this.wrap = n, this.canonical = new vm(u, +h, +_), this.key = Au(n, t, u, h, _);
          }
          clone() {
            return new so(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(t) {
            return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);
          }
          scaledTo(t) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const n = this.canonical.z - t;
            return t > this.canonical.z ? new so(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new so(t, this.wrap, t, this.canonical.x >> n, this.canonical.y >> n);
          }
          calculateScaledKey(t, n) {
            if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
            const u = this.canonical.z - t;
            return t > this.canonical.z ? Au(this.wrap * +n, t, this.canonical.z, this.canonical.x, this.canonical.y) : Au(this.wrap * +n, t, t, this.canonical.x >> u, this.canonical.y >> u);
          }
          isChildOf(t) {
            if (t.wrap !== this.wrap || this.overscaledZ - t.overscaledZ <= 0) return false;
            if (t.overscaledZ === 0) return this.overscaledZ > 0;
            const n = this.canonical.z - t.canonical.z;
            return !(n < 0) && t.canonical.x === this.canonical.x >> n && t.canonical.y === this.canonical.y >> n;
          }
          children(t) {
            if (this.overscaledZ >= t) return [new so(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const n = this.canonical.z + 1, u = 2 * this.canonical.x, h = 2 * this.canonical.y;
            return [new so(n, this.wrap, n, u, h), new so(n, this.wrap, n, u + 1, h), new so(n, this.wrap, n, u, h + 1), new so(n, this.wrap, n, u + 1, h + 1)];
          }
          isLessThan(t) {
            return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));
          }
          wrapped() {
            return new so(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t) {
            return new so(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new _v(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(t) {
            return this.canonical.getTilePoint(new _d(t.x - this.wrap, t.y));
          }
        }
        function Au(o, t, n, u, h) {
          (o *= 2) < 0 && (o = -1 * o - 1);
          const _ = 1 << n;
          return (_ * _ * o + _ * h + u).toString(36) + n.toString(36) + t.toString(36);
        }
        function yd(o, t) {
          return t ? o.properties[t] : o.id;
        }
        Lt("CanonicalTileID", vm), Lt("OverscaledTileID", so, { omit: ["terrainRttPosMatrix32f"] });
        class ul {
          constructor() {
            this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0;
          }
          extend(t) {
            return this.minX = Math.min(this.minX, t.x), this.minY = Math.min(this.minY, t.y), this.maxX = Math.max(this.maxX, t.x), this.maxY = Math.max(this.maxY, t.y), this;
          }
          expandBy(t) {
            return this.minX -= t, this.minY -= t, this.maxX += t, this.maxY += t, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = 1 / 0, this.maxX = -1 / 0, this.minY = 1 / 0, this.maxY = -1 / 0), this;
          }
          shrinkBy(t) {
            return this.expandBy(-t);
          }
          map(t) {
            const n = new ul();
            return n.extend(t(new C(this.minX, this.minY))), n.extend(t(new C(this.maxX, this.minY))), n.extend(t(new C(this.minX, this.maxY))), n.extend(t(new C(this.maxX, this.maxY))), n;
          }
          static fromPoints(t) {
            const n = new ul();
            for (const u of t) n.extend(u);
            return n;
          }
          contains(t) {
            return t.x >= this.minX && t.x <= this.maxX && t.y >= this.minY && t.y <= this.maxY;
          }
          empty() {
            return this.minX > this.maxX;
          }
          width() {
            return this.maxX - this.minX;
          }
          height() {
            return this.maxY - this.minY;
          }
          covers(t) {
            return !this.empty() && !t.empty() && t.minX >= this.minX && t.maxX <= this.maxX && t.minY >= this.minY && t.maxY <= this.maxY;
          }
          intersects(t) {
            return !this.empty() && !t.empty() && t.minX <= this.maxX && t.maxX >= this.minX && t.minY <= this.maxY && t.maxY >= this.minY;
          }
        }
        class yv {
          constructor(t) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let n = 0; n < t.length; n++) {
              const u = t[n];
              this._stringToNumber[u] = n, this._numberToString[n] = u;
            }
          }
          encode(t) {
            return this._stringToNumber[t];
          }
          decode(t) {
            if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t];
          }
        }
        class bv {
          constructor(t, n, u, h, _) {
            this.type = "Feature", this._vectorTileFeature = t, t._z = n, t._x = u, t._y = h, this.properties = t.properties, this.id = _;
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(t) {
            this._geometry = t;
          }
          toJSON() {
            const t = { geometry: this.geometry };
            for (const n in this) n !== "_geometry" && n !== "_vectorTileFeature" && (t[n] = this[n]);
            return t;
          }
        }
        class xv {
          constructor(t, n) {
            this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new La(et, 16, 0), this.grid3D = new La(et, 16, 0), this.featureIndexArray = new Be(), this.promoteId = n;
          }
          insert(t, n, u, h, _, b) {
            const w = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(u, h, _);
            const S = b ? this.grid3D : this.grid;
            for (let I = 0; I < n.length; I++) {
              const R = n[I], B = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let N = 0; N < R.length; N++) {
                const q = R[N];
                B[0] = Math.min(B[0], q.x), B[1] = Math.min(B[1], q.y), B[2] = Math.max(B[2], q.x), B[3] = Math.max(B[3], q.y);
              }
              B[0] < et && B[1] < et && B[2] >= 0 && B[3] >= 0 && S.insert(w, B[0], B[1], B[2], B[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new B0(new am(this.rawTileData)).layers, this.sourceLayerCoder = new yv(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(t, n, u, h) {
            this.loadVTLayers();
            const _ = t.params, b = et / t.tileSize / t.scale, w = Aa(_.filter, _.globalState), S = t.queryGeometry, I = t.queryPadding * b, R = ul.fromPoints(S), B = this.grid.query(R.minX - I, R.minY - I, R.maxX + I, R.maxY + I), N = ul.fromPoints(t.cameraQueryGeometry).expandBy(I), q = this.grid3D.query(N.minX, N.minY, N.maxX, N.maxY, ((ae, pe, Oe, Ce) => (function(Ie, He, rt, _t, At) {
              for (const Et of Ie) if (He <= Et.x && rt <= Et.y && _t >= Et.x && At >= Et.y) return true;
              const kt = [new C(He, rt), new C(He, At), new C(_t, At), new C(_t, rt)];
              if (Ie.length > 2) {
                for (const Et of kt) if (Cu(Ie, Et)) return true;
              }
              for (let Et = 0; Et < Ie.length - 1; Et++) if (X1(Ie[Et], Ie[Et + 1], kt)) return true;
              return false;
            })(t.cameraQueryGeometry, ae - I, pe - I, Oe + I, Ce + I)));
            for (const ae of q) B.push(ae);
            B.sort(ww);
            const G = {};
            let Q;
            for (let ae = 0; ae < B.length; ae++) {
              const pe = B[ae];
              if (pe === Q) continue;
              Q = pe;
              const Oe = this.featureIndexArray.get(pe);
              let Ce = null;
              this.loadMatchingFeature(G, Oe.bucketIndex, Oe.sourceLayerIndex, Oe.featureIndex, w, _.layers, _.availableImages, n, u, h, ((Ie, He, rt) => (Ce || (Ce = ol(Ie)), He.queryIntersectsFeature({ queryGeometry: S, feature: Ie, featureState: rt, geometry: Ce, zoom: this.z, transform: t.transform, pixelsToTileUnits: b, pixelPosMatrix: t.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: t.getElevation }))));
            }
            return G;
          }
          loadMatchingFeature(t, n, u, h, _, b, w, S, I, R, B) {
            const N = this.bucketLayerIDs[n];
            if (b && !N.some(((ae) => b.has(ae)))) return;
            const q = this.sourceLayerCoder.decode(u), G = this.vtLayers[q].feature(h);
            if (_.needGeometry) {
              const ae = al(G, true);
              if (!_.filter(new qr(this.tileID.overscaledZ), ae, this.tileID.canonical)) return;
            } else if (!_.filter(new qr(this.tileID.overscaledZ), G)) return;
            const Q = this.getId(G, q);
            for (let ae = 0; ae < N.length; ae++) {
              const pe = N[ae];
              if (b && !b.has(pe)) continue;
              const Oe = S[pe];
              if (!Oe) continue;
              let Ce = {};
              Q && R && (Ce = R.getState(Oe.sourceLayer || "_geojsonTileLayer", Q));
              const Ie = Qt({}, I[pe]);
              Ie.paint = wv(Ie.paint, Oe.paint, G, Ce, w), Ie.layout = wv(Ie.layout, Oe.layout, G, Ce, w);
              const He = !B || B(G, Oe, Ce);
              if (!He) continue;
              const rt = new bv(G, this.z, this.x, this.y, Q);
              rt.layer = Ie;
              let _t = t[pe];
              _t === void 0 && (_t = t[pe] = []), _t.push({ featureIndex: h, feature: rt, intersectionZ: He });
            }
          }
          lookupSymbolFeatures(t, n, u, h, _, b, w, S) {
            const I = {};
            this.loadVTLayers();
            const R = Aa(_.filterSpec, _.globalState);
            for (const B of t) this.loadMatchingFeature(I, u, h, B, R, b, w, S, n);
            return I;
          }
          hasLayer(t) {
            for (const n of this.bucketLayerIDs) for (const u of n) if (t === u) return true;
            return false;
          }
          getId(t, n) {
            var u;
            let h = t.id;
            return this.promoteId && (h = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[n]], typeof h == "boolean" && (h = Number(h)), h === void 0 && (!((u = t.properties) === null || u === void 0) && u.cluster) && this.promoteId && (h = Number(t.properties.cluster_id))), h;
          }
        }
        function wv(o, t, n, u, h) {
          return xr(o, ((_, b) => {
            const w = t instanceof fu ? t.get(b) : null;
            return w && w.evaluate ? w.evaluate(n, u, h) : w;
          }));
        }
        function ww(o, t) {
          return t - o;
        }
        function Cv(o, t, n, u, h) {
          const _ = [];
          for (let b = 0; b < o.length; b++) {
            const w = o[b];
            let S;
            for (let I = 0; I < w.length - 1; I++) {
              let R = w[I], B = w[I + 1];
              R.x < t && B.x < t || (R.x < t ? R = new C(t, R.y + (t - R.x) / (B.x - R.x) * (B.y - R.y))._round() : B.x < t && (B = new C(t, R.y + (t - R.x) / (B.x - R.x) * (B.y - R.y))._round()), R.y < n && B.y < n || (R.y < n ? R = new C(R.x + (n - R.y) / (B.y - R.y) * (B.x - R.x), n)._round() : B.y < n && (B = new C(R.x + (n - R.y) / (B.y - R.y) * (B.x - R.x), n)._round()), R.x >= u && B.x >= u || (R.x >= u ? R = new C(u, R.y + (u - R.x) / (B.x - R.x) * (B.y - R.y))._round() : B.x >= u && (B = new C(u, R.y + (u - R.x) / (B.x - R.x) * (B.y - R.y))._round()), R.y >= h && B.y >= h || (R.y >= h ? R = new C(R.x + (h - R.y) / (B.y - R.y) * (B.x - R.x), h)._round() : B.y >= h && (B = new C(R.x + (h - R.y) / (B.y - R.y) * (B.x - R.x), h)._round()), S && R.equals(S[S.length - 1]) || (S = [R], _.push(S)), S.push(B)))));
            }
          }
          return _;
        }
        Lt("FeatureIndex", xv, { omit: ["rawTileData", "sourceLayerCoder"] });
        class ms extends C {
          constructor(t, n, u, h) {
            super(t, n), this.angle = u, h !== void 0 && (this.segment = h);
          }
          clone() {
            return new ms(this.x, this.y, this.angle, this.segment);
          }
        }
        function Sv(o, t, n, u, h) {
          if (t.segment === void 0 || n === 0) return true;
          let _ = t, b = t.segment + 1, w = 0;
          for (; w > -n / 2; ) {
            if (b--, b < 0) return false;
            w -= o[b].dist(_), _ = o[b];
          }
          w += o[b].dist(o[b + 1]), b++;
          const S = [];
          let I = 0;
          for (; w < n / 2; ) {
            const R = o[b], B = o[b + 1];
            if (!B) return false;
            let N = o[b - 1].angleTo(R) - R.angleTo(B);
            for (N = Math.abs((N + 3 * Math.PI) % (2 * Math.PI) - Math.PI), S.push({ distance: w, angleDelta: N }), I += N; w - S[0].distance > u; ) I -= S.shift().angleDelta;
            if (I > h) return false;
            b++, w += R.dist(B);
          }
          return true;
        }
        function kv(o) {
          let t = 0;
          for (let n = 0; n < o.length - 1; n++) t += o[n].dist(o[n + 1]);
          return t;
        }
        function Pv(o, t, n) {
          return o ? 0.6 * t * n : 0;
        }
        function Tv(o, t) {
          return Math.max(o ? o.right - o.left : 0, t ? t.right - t.left : 0);
        }
        function Cw(o, t, n, u, h, _) {
          const b = Pv(n, h, _), w = Tv(n, u) * _;
          let S = 0;
          const I = kv(o) / 2;
          for (let R = 0; R < o.length - 1; R++) {
            const B = o[R], N = o[R + 1], q = B.dist(N);
            if (S + q > I) {
              const G = (I - S) / q, Q = Co.number(B.x, N.x, G), ae = Co.number(B.y, N.y, G), pe = new ms(Q, ae, N.angleTo(B), R);
              return pe._round(), !b || Sv(o, pe, w, b, t) ? pe : void 0;
            }
            S += q;
          }
        }
        function Sw(o, t, n, u, h, _, b, w, S) {
          const I = Pv(u, _, b), R = Tv(u, h), B = R * b, N = o[0].x === 0 || o[0].x === S || o[0].y === 0 || o[0].y === S;
          return t - B < t / 4 && (t = B + t / 4), Iv(o, N ? t / 2 * w % t : (R / 2 + 2 * _) * b * w % t, t, I, n, B, N, false, S);
        }
        function Iv(o, t, n, u, h, _, b, w, S) {
          const I = _ / 2, R = kv(o);
          let B = 0, N = t - n, q = [];
          for (let G = 0; G < o.length - 1; G++) {
            const Q = o[G], ae = o[G + 1], pe = Q.dist(ae), Oe = ae.angleTo(Q);
            for (; N + n < B + pe; ) {
              N += n;
              const Ce = (N - B) / pe, Ie = Co.number(Q.x, ae.x, Ce), He = Co.number(Q.y, ae.y, Ce);
              if (Ie >= 0 && Ie < S && He >= 0 && He < S && N - I >= 0 && N + I <= R) {
                const rt = new ms(Ie, He, Oe, G);
                rt._round(), u && !Sv(o, rt, _, u, h) || q.push(rt);
              }
            }
            B += pe;
          }
          return w || q.length || b || (q = Iv(o, B / 2, n, u, h, _, b, true, S)), q;
        }
        function Mv(o, t, n, u) {
          const h = [], _ = o.image, b = _.pixelRatio, w = _.paddedRect.w - 2, S = _.paddedRect.h - 2;
          let I = { x1: o.left, y1: o.top, x2: o.right, y2: o.bottom };
          const R = _.stretchX || [[0, w]], B = _.stretchY || [[0, S]], N = (ct, or) => ct + or[1] - or[0], q = R.reduce(N, 0), G = B.reduce(N, 0), Q = w - q, ae = S - G;
          let pe = 0, Oe = q, Ce = 0, Ie = G, He = 0, rt = Q, _t = 0, At = ae;
          if (_.content && u) {
            const ct = _.content, or = ct[2] - ct[0], hr = ct[3] - ct[1];
            (_.textFitWidth || _.textFitHeight) && (I = iv(o)), pe = df(R, 0, ct[0]), Ce = df(B, 0, ct[1]), Oe = df(R, ct[0], ct[2]), Ie = df(B, ct[1], ct[3]), He = ct[0] - pe, _t = ct[1] - Ce, rt = or - Oe, At = hr - Ie;
          }
          const kt = I.x1, Et = I.y1, Wt = I.x2 - kt, Mt = I.y2 - Et, Rt = (ct, or, hr, Jt) => {
            const Ut = hf(ct.stretch - pe, Oe, Wt, kt), Ir = ff(ct.fixed - He, rt, ct.stretch, q), bi = hf(or.stretch - Ce, Ie, Mt, Et), Bi = ff(or.fixed - _t, At, or.stretch, G), ln = hf(hr.stretch - pe, Oe, Wt, kt), lo = ff(hr.fixed - He, rt, hr.stretch, q), $n = hf(Jt.stretch - Ce, Ie, Mt, Et), Xi = ff(Jt.fixed - _t, At, Jt.stretch, G), gi = new C(Ut, bi), Ui = new C(ln, bi), Yi = new C(ln, $n), Ki = new C(Ut, $n), In = new C(Ir / b, Bi / b), uo = new C(lo / b, Xi / b), qi = t * Math.PI / 180;
            if (qi) {
              const Gi = Math.sin(qi), Wi = Math.cos(qi), Ri = [Wi, -Gi, Gi, Wi];
              gi._matMult(Ri), Ui._matMult(Ri), Ki._matMult(Ri), Yi._matMult(Ri);
            }
            const jn = ct.stretch + ct.fixed, Oi = or.stretch + or.fixed;
            return { tl: gi, tr: Ui, bl: Ki, br: Yi, tex: { x: _.paddedRect.x + 1 + jn, y: _.paddedRect.y + 1 + Oi, w: hr.stretch + hr.fixed - jn, h: Jt.stretch + Jt.fixed - Oi }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: In, pixelOffsetBR: uo, minFontScaleX: rt / b / Wt, minFontScaleY: At / b / Mt, isSDF: n };
          };
          if (u && (_.stretchX || _.stretchY)) {
            const ct = Ev(R, Q, q), or = Ev(B, ae, G);
            for (let hr = 0; hr < ct.length - 1; hr++) {
              const Jt = ct[hr], Ut = ct[hr + 1];
              for (let Ir = 0; Ir < or.length - 1; Ir++) h.push(Rt(Jt, or[Ir], Ut, or[Ir + 1]));
            }
          } else h.push(Rt({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: w + 1 }, { fixed: 0, stretch: S + 1 }));
          return h;
        }
        function df(o, t, n) {
          let u = 0;
          for (const h of o) u += Math.max(t, Math.min(n, h[1])) - Math.max(t, Math.min(n, h[0]));
          return u;
        }
        function Ev(o, t, n) {
          const u = [{ fixed: -1, stretch: 0 }];
          for (const [h, _] of o) {
            const b = u[u.length - 1];
            u.push({ fixed: h - b.stretch, stretch: b.stretch }), u.push({ fixed: h - b.stretch, stretch: b.stretch + (_ - h) });
          }
          return u.push({ fixed: t + 1, stretch: n }), u;
        }
        function hf(o, t, n, u) {
          return o / t * n + u;
        }
        function ff(o, t, n, u) {
          return o - t * n / u;
        }
        Lt("Anchor", ms);
        class pf {
          constructor(t, n, u, h, _, b, w, S, I, R) {
            var B;
            if (this.boxStartIndex = t.length, I) {
              let N = b.top, q = b.bottom;
              const G = b.collisionPadding;
              G && (N -= G[1], q += G[3]);
              let Q = q - N;
              Q > 0 && (Q = Math.max(10, Q), this.circleDiameter = Q);
            } else {
              const N = !((B = b.image) === null || B === void 0) && B.content && (b.image.textFitWidth || b.image.textFitHeight) ? iv(b) : { x1: b.left, y1: b.top, x2: b.right, y2: b.bottom };
              N.y1 = N.y1 * w - S[0], N.y2 = N.y2 * w + S[2], N.x1 = N.x1 * w - S[3], N.x2 = N.x2 * w + S[1];
              const q = b.collisionPadding;
              if (q && (N.x1 -= q[0] * w, N.y1 -= q[1] * w, N.x2 += q[2] * w, N.y2 += q[3] * w), R) {
                const G = new C(N.x1, N.y1), Q = new C(N.x2, N.y1), ae = new C(N.x1, N.y2), pe = new C(N.x2, N.y2), Oe = R * Math.PI / 180;
                G._rotate(Oe), Q._rotate(Oe), ae._rotate(Oe), pe._rotate(Oe), N.x1 = Math.min(G.x, Q.x, ae.x, pe.x), N.x2 = Math.max(G.x, Q.x, ae.x, pe.x), N.y1 = Math.min(G.y, Q.y, ae.y, pe.y), N.y2 = Math.max(G.y, Q.y, ae.y, pe.y);
              }
              t.emplaceBack(n.x, n.y, N.x1, N.y1, N.x2, N.y2, u, h, _);
            }
            this.boxEndIndex = t.length;
          }
        }
        class kw {
          constructor(t = [], n = (u, h) => u < h ? -1 : u > h ? 1 : 0) {
            if (this.data = t, this.length = this.data.length, this.compare = n, this.length > 0) for (let u = (this.length >> 1) - 1; u >= 0; u--) this._down(u);
          }
          push(t) {
            this.data.push(t), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const t = this.data[0], n = this.data.pop();
            return --this.length > 0 && (this.data[0] = n, this._down(0)), t;
          }
          peek() {
            return this.data[0];
          }
          _up(t) {
            const { data: n, compare: u } = this, h = n[t];
            for (; t > 0; ) {
              const _ = t - 1 >> 1, b = n[_];
              if (u(h, b) >= 0) break;
              n[t] = b, t = _;
            }
            n[t] = h;
          }
          _down(t) {
            const { data: n, compare: u } = this, h = this.length >> 1, _ = n[t];
            for (; t < h; ) {
              let b = 1 + (t << 1);
              const w = b + 1;
              if (w < this.length && u(n[w], n[b]) < 0 && (b = w), u(n[b], _) >= 0) break;
              n[t] = n[b], t = b;
            }
            n[t] = _;
          }
        }
        function Pw(o, t = 1, n = false) {
          const u = ul.fromPoints(o[0]), h = Math.min(u.width(), u.height());
          let _ = h / 2;
          const b = new kw([], Tw), { minX: w, minY: S, maxX: I, maxY: R } = u;
          if (h === 0) return new C(w, S);
          for (let q = w; q < I; q += h) for (let G = S; G < R; G += h) b.push(new Du(q + _, G + _, _, o));
          let B = (function(q) {
            let G = 0, Q = 0, ae = 0;
            const pe = q[0];
            for (let Oe = 0, Ce = pe.length, Ie = Ce - 1; Oe < Ce; Ie = Oe++) {
              const He = pe[Oe], rt = pe[Ie], _t = He.x * rt.y - rt.x * He.y;
              Q += (He.x + rt.x) * _t, ae += (He.y + rt.y) * _t, G += 3 * _t;
            }
            return new Du(Q / G, ae / G, 0, q);
          })(o), N = b.length;
          for (; b.length; ) {
            const q = b.pop();
            (q.d > B.d || !B.d) && (B = q, n && console.log("found best %d after %d probes", Math.round(1e4 * q.d) / 1e4, N)), q.max - B.d <= t || (_ = q.h / 2, b.push(new Du(q.p.x - _, q.p.y - _, _, o)), b.push(new Du(q.p.x + _, q.p.y - _, _, o)), b.push(new Du(q.p.x - _, q.p.y + _, _, o)), b.push(new Du(q.p.x + _, q.p.y + _, _, o)), N += 4);
          }
          return n && (console.log(`num probes: ${N}`), console.log(`best distance: ${B.d}`)), B.p;
        }
        function Tw(o, t) {
          return t.max - o.max;
        }
        function Du(o, t, n, u) {
          this.p = new C(o, t), this.h = n, this.d = (function(h, _) {
            let b = false, w = 1 / 0;
            for (let S = 0; S < _.length; S++) {
              const I = _[S];
              for (let R = 0, B = I.length, N = B - 1; R < B; N = R++) {
                const q = I[R], G = I[N];
                q.y > h.y != G.y > h.y && h.x < (G.x - q.x) * (h.y - q.y) / (G.y - q.y) + q.x && (b = !b), w = Math.min(w, p0(h, q, G));
              }
            }
            return (b ? 1 : -1) * Math.sqrt(w);
          })(this.p, u), this.max = this.d + this.h * Math.SQRT2;
        }
        var sn;
        m.aE = void 0, (sn = m.aE || (m.aE = {}))[sn.center = 1] = "center", sn[sn.left = 2] = "left", sn[sn.right = 3] = "right", sn[sn.top = 4] = "top", sn[sn.bottom = 5] = "bottom", sn[sn["top-left"] = 6] = "top-left", sn[sn["top-right"] = 7] = "top-right", sn[sn["bottom-left"] = 8] = "bottom-left", sn[sn["bottom-right"] = 9] = "bottom-right";
        const _m = Number.POSITIVE_INFINITY;
        function Rv(o, t) {
          return t[1] !== _m ? (function(n, u, h) {
            let _ = 0, b = 0;
            switch (u = Math.abs(u), h = Math.abs(h), n) {
              case "top-right":
              case "top-left":
              case "top":
                b = h - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                b = 7 - h;
            }
            switch (n) {
              case "top-right":
              case "bottom-right":
              case "right":
                _ = -u;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                _ = u;
            }
            return [_, b];
          })(o, t[0], t[1]) : (function(n, u) {
            let h = 0, _ = 0;
            u < 0 && (u = 0);
            const b = u / Math.SQRT2;
            switch (n) {
              case "top-right":
              case "top-left":
                _ = b - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                _ = 7 - b;
                break;
              case "bottom":
                _ = 7 - u;
                break;
              case "top":
                _ = u - 7;
            }
            switch (n) {
              case "top-right":
              case "bottom-right":
                h = -b;
                break;
              case "top-left":
              case "bottom-left":
                h = b;
                break;
              case "left":
                h = u;
                break;
              case "right":
                h = -u;
            }
            return [h, _];
          })(o, t[0]);
        }
        function Av(o, t, n) {
          var u;
          const h = o.layout, _ = (u = h.get("text-variable-anchor-offset")) === null || u === void 0 ? void 0 : u.evaluate(t, {}, n);
          if (_) {
            const w = _.values, S = [];
            for (let I = 0; I < w.length; I += 2) {
              const R = S[I] = w[I], B = w[I + 1].map(((N) => N * Vi));
              R.startsWith("top") ? B[1] -= 7 : R.startsWith("bottom") && (B[1] += 7), S[I + 1] = B;
            }
            return new gn(S);
          }
          const b = h.get("text-variable-anchor");
          if (b) {
            let w;
            w = o._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [h.get("text-radial-offset").evaluate(t, {}, n) * Vi, _m] : h.get("text-offset").evaluate(t, {}, n).map(((I) => I * Vi));
            const S = [];
            for (const I of b) S.push(I, Rv(I, w));
            return new gn(S);
          }
          return null;
        }
        function ym(o) {
          switch (o) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function Iw(o, t, n, u, h, _, b, w, S, I, R, B) {
          let N = _.textMaxSize.evaluate(t, {});
          N === void 0 && (N = b);
          const q = o.layers[0].layout, G = q.get("icon-offset").evaluate(t, {}, R), Q = zv(n.horizontal), ae = b / 24, pe = o.tilePixelRatio * ae, Oe = o.tilePixelRatio * N / 24, Ce = o.tilePixelRatio * w, Ie = o.tilePixelRatio * q.get("symbol-spacing"), He = q.get("text-padding") * o.tilePixelRatio, rt = (function(hr, Jt, Ut, Ir = 1) {
            const bi = hr.get("icon-padding").evaluate(Jt, {}, Ut), Bi = bi && bi.values;
            return [Bi[0] * Ir, Bi[1] * Ir, Bi[2] * Ir, Bi[3] * Ir];
          })(q, t, R, o.tilePixelRatio), _t = q.get("text-max-angle") / 180 * Math.PI, At = q.get("text-rotation-alignment") !== "viewport" && q.get("symbol-placement") !== "point", kt = q.get("icon-rotation-alignment") === "map" && q.get("symbol-placement") !== "point", Et = q.get("symbol-placement"), Wt = Ie / 2, Mt = q.get("icon-text-fit");
          let Rt;
          u && Mt !== "none" && (o.allowVerticalPlacement && n.vertical && (Rt = nv(u, n.vertical, Mt, q.get("icon-text-fit-padding"), G, ae)), Q && (u = nv(u, Q, Mt, q.get("icon-text-fit-padding"), G, ae)));
          const ct = R ? B.line.getGranularityForZoomLevel(R.z) : 1, or = (hr, Jt) => {
            Jt.x < 0 || Jt.x >= et || Jt.y < 0 || Jt.y >= et || (function(Ut, Ir, bi, Bi, ln, lo, $n, Xi, gi, Ui, Yi, Ki, In, uo, qi, jn, Oi, Gi, Wi, Ri, ui, jo, zu, No, Rw) {
              const Fu = Ut.addToLineVertexArray(Ir, bi);
              let cl, Lu, Bu, Ou, Ov = 0, $v = 0, jv = 0, Nv = 0, Tm = -1, Im = -1;
              const Ua = {};
              let Vv = sa("");
              if (Ut.allowVerticalPlacement && Bi.vertical) {
                const bn = Xi.layout.get("text-rotate").evaluate(ui, {}, No) + 90;
                Bu = new pf(gi, Ir, Ui, Yi, Ki, Bi.vertical, In, uo, qi, bn), $n && (Ou = new pf(gi, Ir, Ui, Yi, Ki, $n, Oi, Gi, qi, bn));
              }
              if (ln) {
                const bn = Xi.layout.get("icon-rotate").evaluate(ui, {}), co = Xi.layout.get("icon-text-fit") !== "none", dl = Mv(ln, bn, zu, co), Uo = $n ? Mv($n, bn, zu, co) : void 0;
                Lu = new pf(gi, Ir, Ui, Yi, Ki, ln, Oi, Gi, false, bn), Ov = 4 * dl.length;
                const hl = Ut.iconSizeData;
                let ca = null;
                hl.kind === "source" ? (ca = [Va * Xi.layout.get("icon-size").evaluate(ui, {})], ca[0] > fs && Gt(`${Ut.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : hl.kind === "composite" && (ca = [Va * jo.compositeIconSizes[0].evaluate(ui, {}, No), Va * jo.compositeIconSizes[1].evaluate(ui, {}, No)], (ca[0] > fs || ca[1] > fs) && Gt(`${Ut.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), Ut.addSymbols(Ut.icon, dl, ca, Ri, Wi, ui, m.ao.none, Ir, Fu.lineStartIndex, Fu.lineLength, -1, No), Tm = Ut.icon.placedSymbolArray.length - 1, Uo && ($v = 4 * Uo.length, Ut.addSymbols(Ut.icon, Uo, ca, Ri, Wi, ui, m.ao.vertical, Ir, Fu.lineStartIndex, Fu.lineLength, -1, No), Im = Ut.icon.placedSymbolArray.length - 1);
              }
              const Uv = Object.keys(Bi.horizontal);
              for (const bn of Uv) {
                const co = Bi.horizontal[bn];
                if (!cl) {
                  Vv = sa(co.text);
                  const Uo = Xi.layout.get("text-rotate").evaluate(ui, {}, No);
                  cl = new pf(gi, Ir, Ui, Yi, Ki, co, In, uo, qi, Uo);
                }
                const dl = co.positionedLines.length === 1;
                if (jv += Dv(Ut, Ir, co, lo, Xi, qi, ui, jn, Fu, Bi.vertical ? m.ao.horizontal : m.ao.horizontalOnly, dl ? Uv : [bn], Ua, Tm, jo, No), dl) break;
              }
              Bi.vertical && (Nv += Dv(Ut, Ir, Bi.vertical, lo, Xi, qi, ui, jn, Fu, m.ao.vertical, ["vertical"], Ua, Im, jo, No));
              const Aw = cl ? cl.boxStartIndex : Ut.collisionBoxArray.length, Dw = cl ? cl.boxEndIndex : Ut.collisionBoxArray.length, zw = Bu ? Bu.boxStartIndex : Ut.collisionBoxArray.length, Fw = Bu ? Bu.boxEndIndex : Ut.collisionBoxArray.length, Lw = Lu ? Lu.boxStartIndex : Ut.collisionBoxArray.length, Bw = Lu ? Lu.boxEndIndex : Ut.collisionBoxArray.length, Ow = Ou ? Ou.boxStartIndex : Ut.collisionBoxArray.length, $w = Ou ? Ou.boxEndIndex : Ut.collisionBoxArray.length;
              let Vo = -1;
              const gf = (bn, co) => bn && bn.circleDiameter ? Math.max(bn.circleDiameter, co) : co;
              Vo = gf(cl, Vo), Vo = gf(Bu, Vo), Vo = gf(Lu, Vo), Vo = gf(Ou, Vo);
              const qv = Vo > -1 ? 1 : 0;
              qv && (Vo *= Rw / Vi), Ut.glyphOffsetArray.length >= Ru.MAX_GLYPHS && Gt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), ui.sortKey !== void 0 && Ut.addToSortKeyRanges(Ut.symbolInstances.length, ui.sortKey);
              const jw = Av(Xi, ui, No), [Nw, Vw] = (function(bn, co) {
                const dl = bn.length, Uo = co == null ? void 0 : co.values;
                if ((Uo == null ? void 0 : Uo.length) > 0) for (let hl = 0; hl < Uo.length; hl += 2) {
                  const ca = Uo[hl + 1];
                  bn.emplaceBack(m.aE[Uo[hl]], ca[0], ca[1]);
                }
                return [dl, bn.length];
              })(Ut.textAnchorOffsets, jw);
              Ut.symbolInstances.emplaceBack(Ir.x, Ir.y, Ua.right >= 0 ? Ua.right : -1, Ua.center >= 0 ? Ua.center : -1, Ua.left >= 0 ? Ua.left : -1, Ua.vertical || -1, Tm, Im, Vv, Aw, Dw, zw, Fw, Lw, Bw, Ow, $w, Ui, jv, Nv, Ov, $v, qv, 0, In, Vo, Nw, Vw);
            })(o, Jt, hr, n, u, h, Rt, o.layers[0], o.collisionBoxArray, t.index, t.sourceLayerIndex, o.index, pe, [He, He, He, He], At, S, Ce, rt, kt, G, t, _, I, R, b);
          };
          if (Et === "line") for (const hr of Cv(t.geometry, 0, 0, et, et)) {
            const Jt = ll(hr, ct), Ut = Sw(Jt, Ie, _t, n.vertical || Q, u, 24, Oe, o.overscaling, et);
            for (const Ir of Ut) Q && Mw(o, Q.text, Wt, Ir) || or(Jt, Ir);
          }
          else if (Et === "line-center") {
            for (const hr of t.geometry) if (hr.length > 1) {
              const Jt = ll(hr, ct), Ut = Cw(Jt, _t, n.vertical || Q, u, 24, Oe);
              Ut && or(Jt, Ut);
            }
          } else if (t.type === "Polygon") for (const hr of Us(t.geometry, 0)) {
            const Jt = Pw(hr, 16);
            or(ll(hr[0], ct, true), new ms(Jt.x, Jt.y, 0));
          }
          else if (t.type === "LineString") for (const hr of t.geometry) {
            const Jt = ll(hr, ct);
            or(Jt, new ms(Jt[0].x, Jt[0].y, 0));
          }
          else if (t.type === "Point") for (const hr of t.geometry) for (const Jt of hr) or([Jt], new ms(Jt.x, Jt.y, 0));
        }
        function Dv(o, t, n, u, h, _, b, w, S, I, R, B, N, q, G) {
          const Q = (function(Oe, Ce, Ie, He, rt, _t, At, kt) {
            const Et = He.layout.get("text-rotate").evaluate(_t, {}) * Math.PI / 180, Wt = [];
            for (const Mt of Ce.positionedLines) for (const Rt of Mt.positionedGlyphs) {
              if (!Rt.rect) continue;
              const ct = Rt.rect || {};
              let or = 4, hr = true, Jt = 1, Ut = 0;
              const Ir = (rt || kt) && Rt.vertical, bi = Rt.metrics.advance * Rt.scale / 2;
              if (kt && Ce.verticalizable && (Ut = Mt.lineOffset / 2 - (Rt.imageName ? -(Vi - Rt.metrics.width * Rt.scale) / 2 : (Rt.scale - 1) * Vi)), Rt.imageName) {
                const Gi = At[Rt.imageName];
                hr = Gi.sdf, Jt = Gi.pixelRatio, or = 1 / Jt;
              }
              const Bi = rt ? [Rt.x + bi, Rt.y] : [0, 0];
              let ln = rt ? [0, 0] : [Rt.x + bi + Ie[0], Rt.y + Ie[1] - Ut], lo = [0, 0];
              Ir && (lo = ln, ln = [0, 0]);
              const $n = Rt.metrics.isDoubleResolution ? 2 : 1, Xi = (Rt.metrics.left - or) * Rt.scale - bi + ln[0], gi = (-Rt.metrics.top - or) * Rt.scale + ln[1], Ui = Xi + ct.w / $n * Rt.scale / Jt, Yi = gi + ct.h / $n * Rt.scale / Jt, Ki = new C(Xi, gi), In = new C(Ui, gi), uo = new C(Xi, Yi), qi = new C(Ui, Yi);
              if (Ir) {
                const Gi = new C(-bi, bi - -17), Wi = -Math.PI / 2, Ri = 12 - bi, ui = new C(22 - Ri, -(Rt.imageName ? Ri : 0)), jo = new C(...lo);
                Ki._rotateAround(Wi, Gi)._add(ui)._add(jo), In._rotateAround(Wi, Gi)._add(ui)._add(jo), uo._rotateAround(Wi, Gi)._add(ui)._add(jo), qi._rotateAround(Wi, Gi)._add(ui)._add(jo);
              }
              if (Et) {
                const Gi = Math.sin(Et), Wi = Math.cos(Et), Ri = [Wi, -Gi, Gi, Wi];
                Ki._matMult(Ri), In._matMult(Ri), uo._matMult(Ri), qi._matMult(Ri);
              }
              const jn = new C(0, 0), Oi = new C(0, 0);
              Wt.push({ tl: Ki, tr: In, bl: uo, br: qi, tex: ct, writingMode: Ce.writingMode, glyphOffset: Bi, sectionIndex: Rt.sectionIndex, isSDF: hr, pixelOffsetTL: jn, pixelOffsetBR: Oi, minFontScaleX: 0, minFontScaleY: 0 });
            }
            return Wt;
          })(0, n, w, h, _, b, u, o.allowVerticalPlacement), ae = o.textSizeData;
          let pe = null;
          ae.kind === "source" ? (pe = [Va * h.layout.get("text-size").evaluate(b, {})], pe[0] > fs && Gt(`${o.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : ae.kind === "composite" && (pe = [Va * q.compositeTextSizes[0].evaluate(b, {}, G), Va * q.compositeTextSizes[1].evaluate(b, {}, G)], (pe[0] > fs || pe[1] > fs) && Gt(`${o.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), o.addSymbols(o.text, Q, pe, w, _, b, I, t, S.lineStartIndex, S.lineLength, N, G);
          for (const Oe of R) B[Oe] = o.text.placedSymbolArray.length - 1;
          return 4 * Q.length;
        }
        function zv(o) {
          for (const t in o) return o[t];
          return null;
        }
        function Mw(o, t, n, u) {
          const h = o.compareText;
          if (t in h) {
            const _ = h[t];
            for (let b = _.length - 1; b >= 0; b--) if (u.dist(_[b]) < n) return true;
          } else h[t] = [];
          return h[t].push(u), false;
        }
        const Fv = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class bm {
          static from(t) {
            if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [n, u] = new Uint8Array(t, 0, 2);
            if (n !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const h = u >> 4;
            if (h !== 1) throw new Error(`Got v${h} data when expected v1.`);
            const _ = Fv[15 & u];
            if (!_) throw new Error("Unrecognized array type.");
            const [b] = new Uint16Array(t, 2, 1), [w] = new Uint32Array(t, 4, 1);
            return new bm(w, b, _, t);
          }
          constructor(t, n = 64, u = Float64Array, h) {
            if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
            this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = u, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
            const _ = Fv.indexOf(this.ArrayType), b = 2 * t * this.ArrayType.BYTES_PER_ELEMENT, w = t * this.IndexArrayType.BYTES_PER_ELEMENT, S = (8 - w % 8) % 8;
            if (_ < 0) throw new Error(`Unexpected typed array class: ${u}.`);
            h && h instanceof ArrayBuffer ? (this.data = h, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + w + S, 2 * t), this._pos = 2 * t, this._finished = true) : (this.data = new ArrayBuffer(8 + b + w + S), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + w + S, 2 * t), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + _]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
          }
          add(t, n) {
            const u = this._pos >> 1;
            return this.ids[u] = u, this.coords[this._pos++] = t, this.coords[this._pos++] = n, u;
          }
          finish() {
            const t = this._pos >> 1;
            if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
            return xm(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
          }
          range(t, n, u, h) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: _, coords: b, nodeSize: w } = this, S = [0, _.length - 1, 0], I = [];
            for (; S.length; ) {
              const R = S.pop() || 0, B = S.pop() || 0, N = S.pop() || 0;
              if (B - N <= w) {
                for (let ae = N; ae <= B; ae++) {
                  const pe = b[2 * ae], Oe = b[2 * ae + 1];
                  pe >= t && pe <= u && Oe >= n && Oe <= h && I.push(_[ae]);
                }
                continue;
              }
              const q = N + B >> 1, G = b[2 * q], Q = b[2 * q + 1];
              G >= t && G <= u && Q >= n && Q <= h && I.push(_[q]), (R === 0 ? t <= G : n <= Q) && (S.push(N), S.push(q - 1), S.push(1 - R)), (R === 0 ? u >= G : h >= Q) && (S.push(q + 1), S.push(B), S.push(1 - R));
            }
            return I;
          }
          within(t, n, u) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: h, coords: _, nodeSize: b } = this, w = [0, h.length - 1, 0], S = [], I = u * u;
            for (; w.length; ) {
              const R = w.pop() || 0, B = w.pop() || 0, N = w.pop() || 0;
              if (B - N <= b) {
                for (let ae = N; ae <= B; ae++) Bv(_[2 * ae], _[2 * ae + 1], t, n) <= I && S.push(h[ae]);
                continue;
              }
              const q = N + B >> 1, G = _[2 * q], Q = _[2 * q + 1];
              Bv(G, Q, t, n) <= I && S.push(h[q]), (R === 0 ? t - u <= G : n - u <= Q) && (w.push(N), w.push(q - 1), w.push(1 - R)), (R === 0 ? t + u >= G : n + u >= Q) && (w.push(q + 1), w.push(B), w.push(1 - R));
            }
            return S;
          }
        }
        function xm(o, t, n, u, h, _) {
          if (h - u <= n) return;
          const b = u + h >> 1;
          Lv(o, t, b, u, h, _), xm(o, t, n, u, b - 1, 1 - _), xm(o, t, n, b + 1, h, 1 - _);
        }
        function Lv(o, t, n, u, h, _) {
          for (; h > u; ) {
            if (h - u > 600) {
              const I = h - u + 1, R = n - u + 1, B = Math.log(I), N = 0.5 * Math.exp(2 * B / 3), q = 0.5 * Math.sqrt(B * N * (I - N) / I) * (R - I / 2 < 0 ? -1 : 1);
              Lv(o, t, n, Math.max(u, Math.floor(n - R * N / I + q)), Math.min(h, Math.floor(n + (I - R) * N / I + q)), _);
            }
            const b = t[2 * n + _];
            let w = u, S = h;
            for (bd(o, t, u, n), t[2 * h + _] > b && bd(o, t, u, h); w < S; ) {
              for (bd(o, t, w, S), w++, S--; t[2 * w + _] < b; ) w++;
              for (; t[2 * S + _] > b; ) S--;
            }
            t[2 * u + _] === b ? bd(o, t, u, S) : (S++, bd(o, t, S, h)), S <= n && (u = S + 1), n <= S && (h = S - 1);
          }
        }
        function bd(o, t, n, u) {
          wm(o, n, u), wm(t, 2 * n, 2 * u), wm(t, 2 * n + 1, 2 * u + 1);
        }
        function wm(o, t, n) {
          const u = o[t];
          o[t] = o[n], o[n] = u;
        }
        function Bv(o, t, n, u) {
          const h = o - n, _ = t - u;
          return h * h + _ * _;
        }
        var Cm;
        m.cx = void 0, (Cm = m.cx || (m.cx = {})).create = "create", Cm.load = "load", Cm.fullLoad = "fullLoad";
        let mf = null, xd = [];
        const Sm = 1e3 / 60, km = "loadTime", Pm = "fullLoadTime", Ew = { mark(o) {
          performance.mark(o);
        }, frame(o) {
          const t = o;
          mf != null && xd.push(t - mf), mf = t;
        }, clearMetrics() {
          mf = null, xd = [], performance.clearMeasures(km), performance.clearMeasures(Pm);
          for (const o in m.cx) performance.clearMarks(m.cx[o]);
        }, getPerformanceMetrics() {
          performance.measure(km, m.cx.create, m.cx.load), performance.measure(Pm, m.cx.create, m.cx.fullLoad);
          const o = performance.getEntriesByName(km)[0].duration, t = performance.getEntriesByName(Pm)[0].duration, n = xd.length, u = 1 / (xd.reduce(((_, b) => _ + b), 0) / n / 1e3), h = xd.filter(((_) => _ > Sm)).reduce(((_, b) => _ + (b - Sm) / Sm), 0);
          return { loadTime: o, fullLoadTime: t, fps: u, percentDroppedFrames: h / (n + h) * 100, totalFrames: n };
        } };
        m.$ = et, m.A = ie, m.B = function([o, t, n]) {
          return t += 90, t *= Math.PI / 180, n *= Math.PI / 180, { x: o * Math.cos(t) * Math.sin(n), y: o * Math.sin(t) * Math.sin(n), z: o * Math.cos(n) };
        }, m.C = Co, m.D = qt, m.E = xt, m.F = qr, m.G = Op, m.H = function(o) {
          if (Ct == null) {
            const t = o.navigator ? o.navigator.userAgent : null;
            Ct = !!o.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")));
          }
          return Ct;
        }, m.I = sm, m.J = class {
          constructor(o, t) {
            this.target = o, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new bw((() => this.process())), this.subscription = bt(this.target, "message", ((n) => this.receive(n)), false), this.globalScope = wr(self) ? o : window;
          }
          registerMessageHandler(o, t) {
            this.messageHandlers[o] = t;
          }
          sendAsync(o, t) {
            return new Promise(((n, u) => {
              const h = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), _ = t ? bt(t.signal, "abort", (() => {
                _ == null ? void 0 : _.unsubscribe(), delete this.resolveRejects[h];
                const S = { id: h, type: "<cancel>", origin: location.origin, targetMapId: o.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(S);
              }), xw) : null;
              this.resolveRejects[h] = { resolve: (S) => {
                _ == null ? void 0 : _.unsubscribe(), n(S);
              }, reject: (S) => {
                _ == null ? void 0 : _.unsubscribe(), u(S);
              } };
              const b = [], w = Object.assign(Object.assign({}, o), { id: h, sourceMapId: this.mapId, origin: location.origin, data: Ba(o.data, b) });
              this.target.postMessage(w, { transfer: b });
            }));
          }
          receive(o) {
            const t = o.data, n = t.id;
            if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
              if (t.type === "<cancel>") {
                delete this.tasks[n];
                const u = this.abortControllers[n];
                return delete this.abortControllers[n], void (u && u.abort());
              }
              if (wr(self) || t.mustQueue) return this.tasks[n] = t, this.taskQueue.push(n), void this.invoker.trigger();
              this.processTask(n, t);
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const o = this.taskQueue.shift(), t = this.tasks[o];
            delete this.tasks[o], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(o, t);
          }
          processTask(o, t) {
            return s(this, void 0, void 0, (function* () {
              if (t.type === "<response>") {
                const h = this.resolveRejects[o];
                return delete this.resolveRejects[o], h ? void (t.error ? h.reject(us(t.error)) : h.resolve(us(t.data))) : void 0;
              }
              if (!this.messageHandlers[t.type]) return void this.completeTask(o, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const n = us(t.data), u = new AbortController();
              this.abortControllers[o] = u;
              try {
                const h = yield this.messageHandlers[t.type](t.sourceMapId, n, u);
                this.completeTask(o, null, h);
              } catch (h) {
                this.completeTask(o, h);
              }
            }));
          }
          completeTask(o, t, n) {
            const u = [];
            delete this.abortControllers[o];
            const h = { id: o, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: t ? Ba(t) : null, data: Ba(n, u) };
            this.target.postMessage(h, { transfer: u });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, m.K = ne, m.L = function() {
          var o = new ie(16);
          return ie != Float32Array && (o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0), o[0] = 1, o[5] = 1, o[10] = 1, o[15] = 1, o;
        }, m.M = function(o, t, n) {
          var u, h, _, b, w, S, I, R, B, N, q, G, Q = n[0], ae = n[1], pe = n[2];
          return t === o ? (o[12] = t[0] * Q + t[4] * ae + t[8] * pe + t[12], o[13] = t[1] * Q + t[5] * ae + t[9] * pe + t[13], o[14] = t[2] * Q + t[6] * ae + t[10] * pe + t[14], o[15] = t[3] * Q + t[7] * ae + t[11] * pe + t[15]) : (h = t[1], _ = t[2], b = t[3], w = t[4], S = t[5], I = t[6], R = t[7], B = t[8], N = t[9], q = t[10], G = t[11], o[0] = u = t[0], o[1] = h, o[2] = _, o[3] = b, o[4] = w, o[5] = S, o[6] = I, o[7] = R, o[8] = B, o[9] = N, o[10] = q, o[11] = G, o[12] = u * Q + w * ae + B * pe + t[12], o[13] = h * Q + S * ae + N * pe + t[13], o[14] = _ * Q + I * ae + q * pe + t[14], o[15] = b * Q + R * ae + G * pe + t[15]), o;
        }, m.N = function(o, t, n) {
          var u = n[0], h = n[1], _ = n[2];
          return o[0] = t[0] * u, o[1] = t[1] * u, o[2] = t[2] * u, o[3] = t[3] * u, o[4] = t[4] * h, o[5] = t[5] * h, o[6] = t[6] * h, o[7] = t[7] * h, o[8] = t[8] * _, o[9] = t[9] * _, o[10] = t[10] * _, o[11] = t[11] * _, o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15], o;
        }, m.O = function(o, t, n) {
          var u = t[0], h = t[1], _ = t[2], b = t[3], w = t[4], S = t[5], I = t[6], R = t[7], B = t[8], N = t[9], q = t[10], G = t[11], Q = t[12], ae = t[13], pe = t[14], Oe = t[15], Ce = n[0], Ie = n[1], He = n[2], rt = n[3];
          return o[0] = Ce * u + Ie * w + He * B + rt * Q, o[1] = Ce * h + Ie * S + He * N + rt * ae, o[2] = Ce * _ + Ie * I + He * q + rt * pe, o[3] = Ce * b + Ie * R + He * G + rt * Oe, o[4] = (Ce = n[4]) * u + (Ie = n[5]) * w + (He = n[6]) * B + (rt = n[7]) * Q, o[5] = Ce * h + Ie * S + He * N + rt * ae, o[6] = Ce * _ + Ie * I + He * q + rt * pe, o[7] = Ce * b + Ie * R + He * G + rt * Oe, o[8] = (Ce = n[8]) * u + (Ie = n[9]) * w + (He = n[10]) * B + (rt = n[11]) * Q, o[9] = Ce * h + Ie * S + He * N + rt * ae, o[10] = Ce * _ + Ie * I + He * q + rt * pe, o[11] = Ce * b + Ie * R + He * G + rt * Oe, o[12] = (Ce = n[12]) * u + (Ie = n[13]) * w + (He = n[14]) * B + (rt = n[15]) * Q, o[13] = Ce * h + Ie * S + He * N + rt * ae, o[14] = Ce * _ + Ie * I + He * q + rt * pe, o[15] = Ce * b + Ie * R + He * G + rt * Oe, o;
        }, m.P = C, m.Q = function(o, t) {
          const n = {};
          for (let u = 0; u < t.length; u++) {
            const h = t[u];
            h in o && (n[h] = o[h]);
          }
          return n;
        }, m.R = On, m.S = ps, m.T = Yp, m.U = pv, m.V = fv, m.W = X, m.X = W, m.Y = Le, m.Z = so, m._ = s, m.a = Z, m.a$ = Ve, m.a0 = function(o, t) {
          var n, u, h, _, b;
          if (!o) return t ?? {};
          if (!t) return o;
          let w = Object.assign({}, o);
          if (t.removeAll && (w = { removeAll: true }), t.remove) {
            const S = new Set(t.remove);
            w.add && (w.add = w.add.filter(((R) => !S.has(R.id)))), w.update && (w.update = w.update.filter(((R) => !S.has(R.id))));
            const I = new Set(((n = o.add) !== null && n !== void 0 ? n : []).map(((R) => R.id)));
            t.remove = t.remove.filter(((R) => !I.has(R)));
          }
          if (t.remove) {
            const S = new Set(w.remove ? w.remove.concat(t.remove) : t.remove);
            w.remove = Array.from(S.values());
          }
          if (t.add) {
            const S = w.add ? w.add.concat(t.add) : t.add, I = new Map(S.map(((R) => [R.id, R])));
            w.add = Array.from(I.values());
          }
          if (t.update) {
            const S = new Map((u = w.update) === null || u === void 0 ? void 0 : u.map(((I) => [I.id, I])));
            for (const I of t.update) {
              const R = (h = S.get(I.id)) !== null && h !== void 0 ? h : { id: I.id };
              I.newGeometry && (R.newGeometry = I.newGeometry), I.addOrUpdateProperties && (R.addOrUpdateProperties = ((_ = R.addOrUpdateProperties) !== null && _ !== void 0 ? _ : []).concat(I.addOrUpdateProperties)), I.removeProperties && (R.removeProperties = ((b = R.removeProperties) !== null && b !== void 0 ? b : []).concat(I.removeProperties)), I.removeAllProperties && (R.removeAllProperties = true), S.set(I.id, R);
            }
            w.update = Array.from(S.values());
          }
          return w.remove && w.add && (w.remove = w.remove.filter(((S) => w.add.findIndex(((I) => I.id === S)) === -1))), w;
        }, m.a1 = _d, m.a2 = ul, m.a3 = 25, m.a4 = vm, m.a5 = (o) => {
          const t = window.document.createElement("video");
          return t.muted = true, new Promise(((n) => {
            t.onloadstart = () => {
              n(t);
            };
            for (const u of o) {
              const h = window.document.createElement("source");
              de(u) || (t.crossOrigin = "Anonymous"), h.src = u, t.appendChild(h);
            }
          }));
        }, m.a6 = ge, m.a7 = function() {
          return tr++;
        }, m.a8 = Y, m.a9 = Ru, m.aA = function(o) {
          let t = 1 / 0, n = 1 / 0, u = -1 / 0, h = -1 / 0;
          for (const _ of o) t = Math.min(t, _.x), n = Math.min(n, _.y), u = Math.max(u, _.x), h = Math.max(h, _.y);
          return [t, n, u, h];
        }, m.aB = Vi, m.aC = ht, m.aD = function(o, t, n, u, h = false) {
          if (!n[0] && !n[1]) return [0, 0];
          const _ = h ? u === "map" ? -o.bearingInRadians : 0 : u === "viewport" ? o.bearingInRadians : 0;
          if (_) {
            const b = Math.sin(_), w = Math.cos(_);
            n = [n[0] * w - n[1] * b, n[0] * b + n[1] * w];
          }
          return [h ? n[0] : ht(t, n[0], o.zoom), h ? n[1] : ht(t, n[1], o.zoom)];
        }, m.aF = cm, m.aG = ym, m.aH = um, m.aI = bm, m.aJ = wi, m.aK = of, m.aL = Je, m.aM = Ar, m.aN = Hr, m.aO = pr, m.aP = mt, m.aQ = gv, m.aR = he, m.aS = oe, m.aT = function(o) {
          var t = new ie(3);
          return t[0] = o[0], t[1] = o[1], t[2] = o[2], t;
        }, m.aU = function(o, t, n) {
          return o[0] = t[0] - n[0], o[1] = t[1] - n[1], o[2] = t[2] - n[2], o;
        }, m.aV = function(o, t) {
          var n = t[0], u = t[1], h = t[2], _ = n * n + u * u + h * h;
          return _ > 0 && (_ = 1 / Math.sqrt(_)), o[0] = t[0] * _, o[1] = t[1] * _, o[2] = t[2] * _, o;
        }, m.aW = be, m.aX = function(o, t) {
          return o[0] * t[0] + o[1] * t[1] + o[2] * t[2];
        }, m.aY = function(o, t, n) {
          return o[0] = t[0] * n[0], o[1] = t[1] * n[1], o[2] = t[2] * n[2], o[3] = t[3] * n[3], o;
        }, m.aZ = Se, m.a_ = function(o, t, n) {
          const u = t[0] * n[0] + t[1] * n[1] + t[2] * n[2];
          return u === 0 ? null : (-(o[0] * n[0] + o[1] * n[1] + o[2] * n[2]) - n[3]) / u;
        }, m.aa = Aa, m.ab = al, m.ac = bv, m.ad = function(o) {
          const t = {};
          if (o.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((n, u, h, _) => {
            const b = h || _;
            return t[u] = !b || b.toLowerCase(), "";
          })), t["max-age"]) {
            const n = parseInt(t["max-age"], 10);
            isNaN(n) ? delete t["max-age"] : t["max-age"] = n;
          }
          return t;
        }, m.ae = tt, m.af = function(o) {
          return Math.pow(2, o);
        }, m.ag = re, m.ah = zt, m.ai = 85.051129, m.aj = mv, m.ak = function(o) {
          return Math.log(o) / Math.LN2;
        }, m.al = function(o) {
          var t = o[0], n = o[1];
          return t * t + n * n;
        }, m.am = function(o, t) {
          const n = [];
          for (const u in o) u in t || n.push(u);
          return n;
        }, m.an = function(o, t) {
          let n = 0, u = 0;
          if (o.kind === "constant") u = o.layoutSize;
          else if (o.kind !== "source") {
            const { interpolationType: h, minZoom: _, maxZoom: b } = o, w = h ? zt(Hi.interpolationFactor(h, t, _, b), 0, 1) : 0;
            o.kind === "camera" ? u = Co.number(o.minSize, o.maxSize, w) : n = w;
          }
          return { uSizeT: n, uSize: u };
        }, m.ap = function(o, { uSize: t, uSizeT: n }, { lowerSize: u, upperSize: h }) {
          return o.kind === "source" ? u / Va : o.kind === "composite" ? Co.number(u / Va, h / Va, n) : t;
        }, m.aq = function(o, t) {
          var n = t[0], u = t[1], h = t[2], _ = t[3], b = t[4], w = t[5], S = t[6], I = t[7], R = t[8], B = t[9], N = t[10], q = t[11], G = t[12], Q = t[13], ae = t[14], pe = t[15], Oe = n * w - u * b, Ce = n * S - h * b, Ie = n * I - _ * b, He = u * S - h * w, rt = u * I - _ * w, _t = h * I - _ * S, At = R * Q - B * G, kt = R * ae - N * G, Et = R * pe - q * G, Wt = B * ae - N * Q, Mt = B * pe - q * Q, Rt = N * pe - q * ae, ct = Oe * Rt - Ce * Mt + Ie * Wt + He * Et - rt * kt + _t * At;
          return ct ? (o[0] = (w * Rt - S * Mt + I * Wt) * (ct = 1 / ct), o[1] = (h * Mt - u * Rt - _ * Wt) * ct, o[2] = (Q * _t - ae * rt + pe * He) * ct, o[3] = (N * rt - B * _t - q * He) * ct, o[4] = (S * Et - b * Rt - I * kt) * ct, o[5] = (n * Rt - h * Et + _ * kt) * ct, o[6] = (ae * Ie - G * _t - pe * Ce) * ct, o[7] = (R * _t - N * Ie + q * Ce) * ct, o[8] = (b * Mt - w * Et + I * At) * ct, o[9] = (u * Et - n * Mt - _ * At) * ct, o[10] = (G * rt - Q * Ie + pe * Oe) * ct, o[11] = (B * Ie - R * rt - q * Oe) * ct, o[12] = (w * kt - b * Wt - S * At) * ct, o[13] = (n * Wt - u * kt + h * At) * ct, o[14] = (Q * Ce - G * He - ae * Oe) * ct, o[15] = (R * He - B * Ce + N * Oe) * ct, o) : null;
        }, m.ar = wt, m.as = function(o) {
          var t = o[0], n = o[1];
          return Math.sqrt(t * t + n * n);
        }, m.at = function(o) {
          return o[0] = 0, o[1] = 0, o;
        }, m.au = function(o, t, n) {
          return o[0] = t[0] * n, o[1] = t[1] * n, o;
        }, m.av = dm, m.aw = Ke, m.ax = function(o, t, n, u) {
          const h = t.y - o.y, _ = t.x - o.x, b = u.y - n.y, w = u.x - n.x, S = b * _ - w * h;
          if (S === 0) return null;
          const I = (w * (o.y - n.y) - b * (o.x - n.x)) / S;
          return new C(o.x + I * _, o.y + I * h);
        }, m.ay = Cv, m.az = h0, m.b = Ee, m.b$ = class extends a {
        }, m.b0 = function(o, t, n) {
          return o[0] = t[0] * n, o[1] = t[1] * n, o[2] = t[2] * n, o[3] = t[3] * n, o;
        }, m.b1 = function(o, t) {
          return o[0] * t[0] + o[1] * t[1] + o[2] * t[2] + o[3];
        }, m.b2 = _v, m.b3 = Au, m.b4 = function(o, t, n, u, h) {
          var _ = 1 / Math.tan(t / 2);
          if (o[0] = _ / n, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = _, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[11] = -1, o[12] = 0, o[13] = 0, o[15] = 0, h != null && h !== 1 / 0) {
            var b = 1 / (u - h);
            o[10] = (h + u) * b, o[14] = 2 * h * u * b;
          } else o[10] = -1, o[14] = -2 * u;
          return o;
        }, m.b5 = function(o) {
          var t = new ie(16);
          return t[0] = o[0], t[1] = o[1], t[2] = o[2], t[3] = o[3], t[4] = o[4], t[5] = o[5], t[6] = o[6], t[7] = o[7], t[8] = o[8], t[9] = o[9], t[10] = o[10], t[11] = o[11], t[12] = o[12], t[13] = o[13], t[14] = o[14], t[15] = o[15], t;
        }, m.b6 = function(o, t, n) {
          var u = Math.sin(n), h = Math.cos(n), _ = t[0], b = t[1], w = t[2], S = t[3], I = t[4], R = t[5], B = t[6], N = t[7];
          return t !== o && (o[8] = t[8], o[9] = t[9], o[10] = t[10], o[11] = t[11], o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15]), o[0] = _ * h + I * u, o[1] = b * h + R * u, o[2] = w * h + B * u, o[3] = S * h + N * u, o[4] = I * h - _ * u, o[5] = R * h - b * u, o[6] = B * h - w * u, o[7] = N * h - S * u, o;
        }, m.b7 = function(o, t, n) {
          var u = Math.sin(n), h = Math.cos(n), _ = t[4], b = t[5], w = t[6], S = t[7], I = t[8], R = t[9], B = t[10], N = t[11];
          return t !== o && (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15]), o[4] = _ * h + I * u, o[5] = b * h + R * u, o[6] = w * h + B * u, o[7] = S * h + N * u, o[8] = I * h - _ * u, o[9] = R * h - b * u, o[10] = B * h - w * u, o[11] = N * h - S * u, o;
        }, m.b8 = function() {
          const o = new Float32Array(16);
          return re(o), o;
        }, m.b9 = function() {
          const o = new Float64Array(16);
          return re(o), o;
        }, m.bA = function(o, t) {
          const n = yt(o, 360), u = yt(t, 360), h = u - n, _ = u > n ? h - 360 : h + 360;
          return Math.abs(h) < Math.abs(_) ? h : _;
        }, m.bB = function(o) {
          return o[0] = 0, o[1] = 0, o[2] = 0, o;
        }, m.bC = function(o, t, n, u) {
          const h = Math.sqrt(o * o + t * t), _ = Math.sqrt(n * n + u * u);
          o /= h, t /= h, n /= _, u /= _;
          const b = Math.acos(o * n + t * u);
          return -t * n + o * u > 0 ? b : -b;
        }, m.bD = function(o, t) {
          const n = yt(o, 2 * Math.PI), u = yt(t, 2 * Math.PI);
          return Math.min(Math.abs(n - u), Math.abs(n - u + 2 * Math.PI), Math.abs(n - u - 2 * Math.PI));
        }, m.bE = function() {
          const o = {}, t = Te.$version;
          for (const n in Te.$root) {
            const u = Te.$root[n];
            if (u.required) {
              let h = null;
              h = n === "version" ? t : u.type === "array" ? [] : {}, h != null && (o[n] = h);
            }
          }
          return o;
        }, m.bF = Wc, m.bG = ke, m.bH = function o(t, n) {
          if (Array.isArray(t)) {
            if (!Array.isArray(n) || t.length !== n.length) return false;
            for (let u = 0; u < t.length; u++) if (!o(t[u], n[u])) return false;
            return true;
          }
          if (typeof t == "object" && t !== null && n !== null) {
            if (typeof n != "object" || Object.keys(t).length !== Object.keys(n).length) return false;
            for (const u in t) if (!o(t[u], n[u])) return false;
            return true;
          }
          return t === n;
        }, m.bI = function(o) {
          o = o.slice();
          const t = /* @__PURE__ */ Object.create(null);
          for (let n = 0; n < o.length; n++) t[o[n].id] = o[n];
          for (let n = 0; n < o.length; n++) "ref" in o[n] && (o[n] = er(o[n], t[o[n].ref]));
          return o;
        }, m.bJ = function(o, t) {
          if (o.type === "custom") return new yw(o, t);
          switch (o.type) {
            case "background":
              return new gw(o, t);
            case "circle":
              return new tx(o, t);
            case "color-relief":
              return new sx(o, t);
            case "fill":
              return new wx(o, t);
            case "fill-extrusion":
              return new Dx(o, t);
            case "heatmap":
              return new ix(o, t);
            case "hillshade":
              return new ox(o, t);
            case "line":
              return new jx(o, t);
            case "raster":
              return new _w(o, t);
            case "symbol":
              return new cf(o, t);
          }
        }, m.bK = rr, m.bL = function(o, t) {
          if (!o) return [{ command: "setStyle", args: [t] }];
          let n = [];
          try {
            if (!Nt(o.version, t.version)) return [{ command: "setStyle", args: [t] }];
            Nt(o.center, t.center) || n.push({ command: "setCenter", args: [t.center] }), Nt(o.state, t.state) || n.push({ command: "setGlobalState", args: [t.state] }), Nt(o.centerAltitude, t.centerAltitude) || n.push({ command: "setCenterAltitude", args: [t.centerAltitude] }), Nt(o.zoom, t.zoom) || n.push({ command: "setZoom", args: [t.zoom] }), Nt(o.bearing, t.bearing) || n.push({ command: "setBearing", args: [t.bearing] }), Nt(o.pitch, t.pitch) || n.push({ command: "setPitch", args: [t.pitch] }), Nt(o.roll, t.roll) || n.push({ command: "setRoll", args: [t.roll] }), Nt(o.sprite, t.sprite) || n.push({ command: "setSprite", args: [t.sprite] }), Nt(o.glyphs, t.glyphs) || n.push({ command: "setGlyphs", args: [t.glyphs] }), Nt(o.transition, t.transition) || n.push({ command: "setTransition", args: [t.transition] }), Nt(o.light, t.light) || n.push({ command: "setLight", args: [t.light] }), Nt(o.terrain, t.terrain) || n.push({ command: "setTerrain", args: [t.terrain] }), Nt(o.sky, t.sky) || n.push({ command: "setSky", args: [t.sky] }), Nt(o.projection, t.projection) || n.push({ command: "setProjection", args: [t.projection] });
            const u = {}, h = [];
            (function(b, w, S, I) {
              let R;
              for (R in w = w || {}, b = b || {}) Object.prototype.hasOwnProperty.call(b, R) && (Object.prototype.hasOwnProperty.call(w, R) || Kr(R, S, I));
              for (R in w) Object.prototype.hasOwnProperty.call(w, R) && (Object.prototype.hasOwnProperty.call(b, R) ? Nt(b[R], w[R]) || (b[R].type === "geojson" && w[R].type === "geojson" && ii(b, w, R) ? ur(S, { command: "setGeoJSONSourceData", args: [R, w[R].data] }) : Jr(R, w, S, I)) : Br(R, w, S));
            })(o.sources, t.sources, h, u);
            const _ = [];
            o.layers && o.layers.forEach(((b) => {
              "source" in b && u[b.source] ? n.push({ command: "removeLayer", args: [b.id] }) : _.push(b);
            })), n = n.concat(h), (function(b, w, S) {
              w = w || [];
              const I = (b = b || []).map(vr), R = w.map(vr), B = b.reduce(Wr, {}), N = w.reduce(Wr, {}), q = I.slice(), G = /* @__PURE__ */ Object.create(null);
              let Q, ae, pe, Oe, Ce;
              for (let Ie = 0, He = 0; Ie < I.length; Ie++) Q = I[Ie], Object.prototype.hasOwnProperty.call(N, Q) ? He++ : (ur(S, { command: "removeLayer", args: [Q] }), q.splice(q.indexOf(Q, He), 1));
              for (let Ie = 0, He = 0; Ie < R.length; Ie++) Q = R[R.length - 1 - Ie], q[q.length - 1 - Ie] !== Q && (Object.prototype.hasOwnProperty.call(B, Q) ? (ur(S, { command: "removeLayer", args: [Q] }), q.splice(q.lastIndexOf(Q, q.length - He), 1)) : He++, Oe = q[q.length - Ie], ur(S, { command: "addLayer", args: [N[Q], Oe] }), q.splice(q.length - Ie, 0, Q), G[Q] = true);
              for (let Ie = 0; Ie < R.length; Ie++) if (Q = R[Ie], ae = B[Q], pe = N[Q], !G[Q] && !Nt(ae, pe)) if (Nt(ae.source, pe.source) && Nt(ae["source-layer"], pe["source-layer"]) && Nt(ae.type, pe.type)) {
                for (Ce in gr(ae.layout, pe.layout, S, Q, null, "setLayoutProperty"), gr(ae.paint, pe.paint, S, Q, null, "setPaintProperty"), Nt(ae.filter, pe.filter) || ur(S, { command: "setFilter", args: [Q, pe.filter] }), Nt(ae.minzoom, pe.minzoom) && Nt(ae.maxzoom, pe.maxzoom) || ur(S, { command: "setLayerZoomRange", args: [Q, pe.minzoom, pe.maxzoom] }), ae) Object.prototype.hasOwnProperty.call(ae, Ce) && Ce !== "layout" && Ce !== "paint" && Ce !== "filter" && Ce !== "metadata" && Ce !== "minzoom" && Ce !== "maxzoom" && (Ce.indexOf("paint.") === 0 ? gr(ae[Ce], pe[Ce], S, Q, Ce.slice(6), "setPaintProperty") : Nt(ae[Ce], pe[Ce]) || ur(S, { command: "setLayerProperty", args: [Q, Ce, pe[Ce]] }));
                for (Ce in pe) Object.prototype.hasOwnProperty.call(pe, Ce) && !Object.prototype.hasOwnProperty.call(ae, Ce) && Ce !== "layout" && Ce !== "paint" && Ce !== "filter" && Ce !== "metadata" && Ce !== "minzoom" && Ce !== "maxzoom" && (Ce.indexOf("paint.") === 0 ? gr(ae[Ce], pe[Ce], S, Q, Ce.slice(6), "setPaintProperty") : Nt(ae[Ce], pe[Ce]) || ur(S, { command: "setLayerProperty", args: [Q, Ce, pe[Ce]] }));
              } else ur(S, { command: "removeLayer", args: [Q] }), Oe = q[q.lastIndexOf(Q) + 1], ur(S, { command: "addLayer", args: [pe, Oe] });
            })(_, t.layers, n);
          } catch (u) {
            console.warn("Unable to compute style diff:", u), n = [{ command: "setStyle", args: [t] }];
          }
          return n;
        }, m.bM = function(o) {
          const t = [], n = o.id;
          return n === void 0 && t.push({ message: `layers.${n}: missing required property "id"` }), o.render === void 0 && t.push({ message: `layers.${n}: missing required method "render"` }), o.renderingMode && o.renderingMode !== "2d" && o.renderingMode !== "3d" && t.push({ message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"` }), t;
        }, m.bN = xr, m.bO = Mr, m.bP = class extends ai {
          constructor(o, t) {
            super(o, t), this.current = 0;
          }
          set(o) {
            this.current !== o && (this.current = o, this.gl.uniform1i(this.location, o));
          }
        }, m.bQ = Li, m.bR = class extends ai {
          constructor(o, t) {
            super(o, t), this.current = Vp;
          }
          set(o) {
            if (o[12] !== this.current[12] || o[0] !== this.current[0]) return this.current = o, void this.gl.uniformMatrix4fv(this.location, false, o);
            for (let t = 1; t < 16; t++) if (o[t] !== this.current[t]) {
              this.current = o, this.gl.uniformMatrix4fv(this.location, false, o);
              break;
            }
          }
        }, m.bS = Bn, m.bT = class extends ai {
          constructor(o, t) {
            super(o, t), this.current = [0, 0, 0];
          }
          set(o) {
            o[0] === this.current[0] && o[1] === this.current[1] && o[2] === this.current[2] || (this.current = o, this.gl.uniform3f(this.location, o[0], o[1], o[2]));
          }
        }, m.bU = class extends ai {
          constructor(o, t) {
            super(o, t), this.current = [0, 0];
          }
          set(o) {
            o[0] === this.current[0] && o[1] === this.current[1] || (this.current = o, this.gl.uniform2f(this.location, o[0], o[1]));
          }
        }, m.bV = ee, m.bW = function(o, t) {
          var n = Math.sin(t), u = Math.cos(t);
          return o[0] = u, o[1] = n, o[2] = 0, o[3] = -n, o[4] = u, o[5] = 0, o[6] = 0, o[7] = 0, o[8] = 1, o;
        }, m.bX = function(o, t, n) {
          var u = t[0], h = t[1], _ = t[2];
          return o[0] = u * n[0] + h * n[3] + _ * n[6], o[1] = u * n[1] + h * n[4] + _ * n[7], o[2] = u * n[2] + h * n[5] + _ * n[8], o;
        }, m.bY = function(o, t, n, u, h, _, b) {
          var w = 1 / (t - n), S = 1 / (u - h), I = 1 / (_ - b);
          return o[0] = -2 * w, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = -2 * S, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 2 * I, o[11] = 0, o[12] = (t + n) * w, o[13] = (h + u) * S, o[14] = (b + _) * I, o[15] = 1, o;
        }, m.bZ = class extends ai {
          constructor(o, t) {
            super(o, t), this.current = new Array();
          }
          set(o) {
            if (o != this.current) {
              this.current = o;
              const t = new Float32Array(4 * o.length);
              for (let n = 0; n < o.length; n++) t[4 * n] = o[n].r, t[4 * n + 1] = o[n].g, t[4 * n + 2] = o[n].b, t[4 * n + 3] = o[n].a;
              this.gl.uniform4fv(this.location, t);
            }
          }
        }, m.b_ = class extends ai {
          constructor(o, t) {
            super(o, t), this.current = new Array();
          }
          set(o) {
            if (o != this.current) {
              this.current = o;
              const t = new Float32Array(o);
              this.gl.uniform1fv(this.location, t);
            }
          }
        }, m.ba = function() {
          return new Float64Array(16);
        }, m.bb = function(o, t, n) {
          const u = new Float64Array(4);
          return vt(u, o, t - 90, n), u;
        }, m.bc = function(o, t, n, u) {
          var h, _, b, w, S, I = t[0], R = t[1], B = t[2], N = t[3], q = n[0], G = n[1], Q = n[2], ae = n[3];
          return (_ = I * q + R * G + B * Q + N * ae) < 0 && (_ = -_, q = -q, G = -G, Q = -Q, ae = -ae), 1 - _ > K ? (h = Math.acos(_), b = Math.sin(h), w = Math.sin((1 - u) * h) / b, S = Math.sin(u * h) / b) : (w = 1 - u, S = u), o[0] = w * I + S * q, o[1] = w * R + S * G, o[2] = w * B + S * Q, o[3] = w * N + S * ae, o;
        }, m.bd = function(o) {
          const t = new Float64Array(9);
          var n, u, h, _, b, w, S, I, R, B, N, q, G, Q, ae, pe, Oe, Ce;
          B = (h = (u = o)[0]) * (S = h + h), N = (_ = u[1]) * S, G = (b = u[2]) * S, Q = b * (I = _ + _), pe = (w = u[3]) * S, Oe = w * I, Ce = w * (R = b + b), (n = t)[0] = 1 - (q = _ * I) - (ae = b * R), n[3] = N - Ce, n[6] = G + Oe, n[1] = N + Ce, n[4] = 1 - B - ae, n[7] = Q - pe, n[2] = G - Oe, n[5] = Q + pe, n[8] = 1 - B - q;
          const Ie = mt(-Math.asin(zt(t[2], -1, 1)));
          let He, rt;
          return Math.hypot(t[5], t[8]) < 1e-3 ? (He = 0, rt = -mt(Math.atan2(t[3], t[4]))) : (He = mt(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), rt = mt(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), { roll: He, pitch: Ie + 90, bearing: rt };
        }, m.be = function(o, t) {
          return o.roll == t.roll && o.pitch == t.pitch && o.bearing == t.bearing;
        }, m.bf = br, m.bg = ki, m.bh = Tu, m.bi = hd, m.bj = Pu, m.bk = nt, m.bl = ut, m.bm = nn, m.bn = function(o, t, n, u, h) {
          return nt(u, h, zt((o - t) / (n - t), 0, 1));
        }, m.bo = yt, m.bp = function() {
          return new Float64Array(3);
        }, m.bq = function(o, t, n, u) {
          return o[0] = t[0] + n[0] * u, o[1] = t[1] + n[1] * u, o[2] = t[2] + n[2] * u, o;
        }, m.br = vt, m.bs = function(o, t, n) {
          var u = n[0], h = n[1], _ = n[2], b = n[3], w = t[0], S = t[1], I = t[2], R = h * I - _ * S, B = _ * w - u * I, N = u * S - h * w;
          return o[0] = w + b * (R += R) + h * (N += N) - _ * (B += B), o[1] = S + b * B + _ * R - u * N, o[2] = I + b * N + u * B - h * R, o;
        }, m.bt = function(o, t, n) {
          const u = (h = [o[0], o[1], o[2], t[0], t[1], t[2], n[0], n[1], n[2]])[0] * ((R = h[8]) * (b = h[4]) - (w = h[5]) * (I = h[7])) + h[1] * (-R * (_ = h[3]) + w * (S = h[6])) + h[2] * (I * _ - b * S);
          var h, _, b, w, S, I, R;
          if (u === 0) return null;
          const B = be([], [t[0], t[1], t[2]], [n[0], n[1], n[2]]), N = be([], [n[0], n[1], n[2]], [o[0], o[1], o[2]]), q = be([], [o[0], o[1], o[2]], [t[0], t[1], t[2]]), G = he([], B, -o[3]);
          return oe(G, G, he([], N, -t[3])), oe(G, G, he([], q, -n[3])), he(G, G, 1 / u), G;
        }, m.bu = mm, m.bv = function() {
          return new Float64Array(4);
        }, m.bw = function(o, t, n, u) {
          var h = [], _ = [];
          return h[0] = t[0] - n[0], h[1] = t[1] - n[1], h[2] = t[2] - n[2], _[0] = h[0] * Math.cos(u) - h[1] * Math.sin(u), _[1] = h[0] * Math.sin(u) + h[1] * Math.cos(u), _[2] = h[2], o[0] = _[0] + n[0], o[1] = _[1] + n[1], o[2] = _[2] + n[2], o;
        }, m.bx = function(o, t, n, u) {
          var h = [], _ = [];
          return h[0] = t[0] - n[0], h[1] = t[1] - n[1], h[2] = t[2] - n[2], _[0] = h[0], _[1] = h[1] * Math.cos(u) - h[2] * Math.sin(u), _[2] = h[1] * Math.sin(u) + h[2] * Math.cos(u), o[0] = _[0] + n[0], o[1] = _[1] + n[1], o[2] = _[2] + n[2], o;
        }, m.by = function(o, t, n, u) {
          var h = [], _ = [];
          return h[0] = t[0] - n[0], h[1] = t[1] - n[1], h[2] = t[2] - n[2], _[0] = h[2] * Math.sin(u) + h[0] * Math.cos(u), _[1] = h[1], _[2] = h[2] * Math.cos(u) - h[0] * Math.sin(u), o[0] = _[0] + n[0], o[1] = _[1] + n[1], o[2] = _[2] + n[2], o;
        }, m.bz = function(o, t, n) {
          var u = Math.sin(n), h = Math.cos(n), _ = t[0], b = t[1], w = t[2], S = t[3], I = t[8], R = t[9], B = t[10], N = t[11];
          return t !== o && (o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7], o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15]), o[0] = _ * h - I * u, o[1] = b * h - R * u, o[2] = w * h - B * u, o[3] = S * h - N * u, o[8] = _ * u + I * h, o[9] = b * u + R * h, o[10] = w * u + B * h, o[11] = S * u + N * h, o;
        }, m.c = Fe, m.c0 = qx, m.c1 = class extends p {
        }, m.c2 = Xp, m.c3 = function(o) {
          return o <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(o) / Math.LN2));
        }, m.c4 = w0, m.c5 = function(o, t, n) {
          var u = t[0], h = t[1], _ = t[2], b = n[3] * u + n[7] * h + n[11] * _ + n[15];
          return o[0] = (n[0] * u + n[4] * h + n[8] * _ + n[12]) / (b = b || 1), o[1] = (n[1] * u + n[5] * h + n[9] * _ + n[13]) / b, o[2] = (n[2] * u + n[6] * h + n[10] * _ + n[14]) / b, o;
        }, m.c6 = class extends ja {
        }, m.c7 = class extends j {
        }, m.c8 = function(o, t) {
          return o[0] === t[0] && o[1] === t[1] && o[2] === t[2] && o[3] === t[3] && o[4] === t[4] && o[5] === t[5] && o[6] === t[6] && o[7] === t[7] && o[8] === t[8] && o[9] === t[9] && o[10] === t[10] && o[11] === t[11] && o[12] === t[12] && o[13] === t[13] && o[14] === t[14] && o[15] === t[15];
        }, m.c9 = function(o, t) {
          var n = o[0], u = o[1], h = o[2], _ = o[3], b = o[4], w = o[5], S = o[6], I = o[7], R = o[8], B = o[9], N = o[10], q = o[11], G = o[12], Q = o[13], ae = o[14], pe = o[15], Oe = t[0], Ce = t[1], Ie = t[2], He = t[3], rt = t[4], _t = t[5], At = t[6], kt = t[7], Et = t[8], Wt = t[9], Mt = t[10], Rt = t[11], ct = t[12], or = t[13], hr = t[14], Jt = t[15];
          return Math.abs(n - Oe) <= K * Math.max(1, Math.abs(n), Math.abs(Oe)) && Math.abs(u - Ce) <= K * Math.max(1, Math.abs(u), Math.abs(Ce)) && Math.abs(h - Ie) <= K * Math.max(1, Math.abs(h), Math.abs(Ie)) && Math.abs(_ - He) <= K * Math.max(1, Math.abs(_), Math.abs(He)) && Math.abs(b - rt) <= K * Math.max(1, Math.abs(b), Math.abs(rt)) && Math.abs(w - _t) <= K * Math.max(1, Math.abs(w), Math.abs(_t)) && Math.abs(S - At) <= K * Math.max(1, Math.abs(S), Math.abs(At)) && Math.abs(I - kt) <= K * Math.max(1, Math.abs(I), Math.abs(kt)) && Math.abs(R - Et) <= K * Math.max(1, Math.abs(R), Math.abs(Et)) && Math.abs(B - Wt) <= K * Math.max(1, Math.abs(B), Math.abs(Wt)) && Math.abs(N - Mt) <= K * Math.max(1, Math.abs(N), Math.abs(Mt)) && Math.abs(q - Rt) <= K * Math.max(1, Math.abs(q), Math.abs(Rt)) && Math.abs(G - ct) <= K * Math.max(1, Math.abs(G), Math.abs(ct)) && Math.abs(Q - or) <= K * Math.max(1, Math.abs(Q), Math.abs(or)) && Math.abs(ae - hr) <= K * Math.max(1, Math.abs(ae), Math.abs(hr)) && Math.abs(pe - Jt) <= K * Math.max(1, Math.abs(pe), Math.abs(Jt));
        }, m.cA = function(o, t) {
          Z.REGISTERED_PROTOCOLS[o] = t;
        }, m.cB = function(o) {
          delete Z.REGISTERED_PROTOCOLS[o];
        }, m.cC = function(o, t) {
          const n = {};
          for (let h = 0; h < o.length; h++) {
            const _ = t && t[o[h].id] || Fh(o[h]);
            t && (t[o[h].id] = _);
            let b = n[_];
            b || (b = n[_] = []), b.push(o[h]);
          }
          const u = [];
          for (const h in n) u.push(n[h]);
          return u;
        }, m.cD = Lt, m.cE = yv, m.cF = xv, m.cG = K0, m.cH = function(o) {
          o.bucket.createArrays(), o.bucket.tilePixelRatio = et / (512 * o.bucket.overscaling), o.bucket.compareText = {}, o.bucket.iconsNeedLinear = false;
          const t = o.bucket.layers[0], n = t.layout, u = t._unevaluatedLayout._values, h = { layoutIconSize: u["icon-size"].possiblyEvaluate(new qr(o.bucket.zoom + 1), o.canonical), layoutTextSize: u["text-size"].possiblyEvaluate(new qr(o.bucket.zoom + 1), o.canonical), textMaxSize: u["text-size"].possiblyEvaluate(new qr(18)) };
          if (o.bucket.textSizeData.kind === "composite") {
            const { minZoom: I, maxZoom: R } = o.bucket.textSizeData;
            h.compositeTextSizes = [u["text-size"].possiblyEvaluate(new qr(I), o.canonical), u["text-size"].possiblyEvaluate(new qr(R), o.canonical)];
          }
          if (o.bucket.iconSizeData.kind === "composite") {
            const { minZoom: I, maxZoom: R } = o.bucket.iconSizeData;
            h.compositeIconSizes = [u["icon-size"].possiblyEvaluate(new qr(I), o.canonical), u["icon-size"].possiblyEvaluate(new qr(R), o.canonical)];
          }
          const _ = n.get("text-line-height") * Vi, b = n.get("text-rotation-alignment") !== "viewport" && n.get("symbol-placement") !== "point", w = n.get("text-keep-upright"), S = n.get("text-size");
          for (const I of o.bucket.features) {
            const R = n.get("text-font").evaluate(I, {}, o.canonical).join(","), B = S.evaluate(I, {}, o.canonical), N = h.layoutTextSize.evaluate(I, {}, o.canonical), q = h.layoutIconSize.evaluate(I, {}, o.canonical), G = { horizontal: {}, vertical: void 0 }, Q = I.text;
            let ae, pe = [0, 0];
            if (Q) {
              const Ie = Q.toString(), He = n.get("text-letter-spacing").evaluate(I, {}, o.canonical) * Vi, rt = qh(Ie) ? He : 0, _t = n.get("text-anchor").evaluate(I, {}, o.canonical), At = Av(t, I, o.canonical);
              if (!At) {
                const Mt = n.get("text-radial-offset").evaluate(I, {}, o.canonical);
                pe = Mt ? Rv(_t, [Mt * Vi, _m]) : n.get("text-offset").evaluate(I, {}, o.canonical).map(((Rt) => Rt * Vi));
              }
              let kt = b ? "center" : n.get("text-justify").evaluate(I, {}, o.canonical);
              const Et = n.get("symbol-placement") === "point" ? n.get("text-max-width").evaluate(I, {}, o.canonical) * Vi : 1 / 0, Wt = () => {
                o.bucket.allowVerticalPlacement && Zc(Ie) && (G.vertical = sf(Q, o.glyphMap, o.glyphPositions, o.imagePositions, R, Et, _, _t, "left", rt, pe, m.ao.vertical, true, N, B));
              };
              if (!b && At) {
                const Mt = /* @__PURE__ */ new Set();
                if (kt === "auto") for (let ct = 0; ct < At.values.length; ct += 2) Mt.add(ym(At.values[ct]));
                else Mt.add(kt);
                let Rt = false;
                for (const ct of Mt) if (!G.horizontal[ct]) if (Rt) G.horizontal[ct] = G.horizontal[0];
                else {
                  const or = sf(Q, o.glyphMap, o.glyphPositions, o.imagePositions, R, Et, _, "center", ct, rt, pe, m.ao.horizontal, false, N, B);
                  or && (G.horizontal[ct] = or, Rt = or.positionedLines.length === 1);
                }
                Wt();
              } else {
                kt === "auto" && (kt = ym(_t));
                const Mt = sf(Q, o.glyphMap, o.glyphPositions, o.imagePositions, R, Et, _, _t, kt, rt, pe, m.ao.horizontal, false, N, B);
                Mt && (G.horizontal[kt] = Mt), Wt(), Zc(Ie) && b && w && (G.vertical = sf(Q, o.glyphMap, o.glyphPositions, o.imagePositions, R, Et, _, _t, kt, rt, pe, m.ao.vertical, false, N, B));
              }
            }
            let Oe = false;
            if (I.icon && I.icon.name) {
              const Ie = o.imageMap[I.icon.name];
              Ie && (ae = hw(o.imagePositions[I.icon.name], n.get("icon-offset").evaluate(I, {}, o.canonical), n.get("icon-anchor").evaluate(I, {}, o.canonical)), Oe = !!Ie.sdf, o.bucket.sdfIcons === void 0 ? o.bucket.sdfIcons = Oe : o.bucket.sdfIcons !== Oe && Gt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Ie.pixelRatio !== o.bucket.pixelRatio || n.get("icon-rotate").constantOr(1) !== 0) && (o.bucket.iconsNeedLinear = true));
            }
            const Ce = zv(G.horizontal) || G.vertical;
            o.bucket.iconsInText = !!Ce && Ce.iconsInText, (Ce || ae) && Iw(o.bucket, I, G, ae, o.imageMap, h, N, q, pe, Oe, o.canonical, o.subdivisionGranularity);
          }
          o.showCollisionBoxes && o.bucket.generateCollisionDebugBuffers();
        }, m.cI = nm, m.cJ = tm, m.cK = im, m.cL = B0, m.cM = am, m.cN = class {
          constructor(o) {
            this._marks = { start: [o.url, "start"].join("#"), end: [o.url, "end"].join("#"), measure: o.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let o = performance.getEntriesByName(this._marks.measure);
            return o.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), o = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), o;
          }
        }, m.cO = function(o, t, n, u, h) {
          return s(this, void 0, void 0, (function* () {
            if (W()) try {
              return yield Le(o, t, n, u, h);
            } catch {
            }
            return (function(_, b, w, S, I) {
              const R = _.width, B = _.height;
              Ye && ft || (Ye = new OffscreenCanvas(R, B), ft = Ye.getContext("2d", { willReadFrequently: true })), Ye.width = R, Ye.height = B, ft.drawImage(_, 0, 0, R, B);
              const N = ft.getImageData(b, w, S, I);
              return ft.clearRect(0, 0, R, B), N.data;
            })(o, t, n, u, h);
          }));
        }, m.cP = k0, m.cQ = T, m.cR = L0, m.cS = Iu, m.cT = Zs, m.cU = function(o, t) {
          const n = /* @__PURE__ */ new Map();
          if (o != null) if (o.type === "Feature") n.set(yd(o, t), o);
          else for (const u of o.features) n.set(yd(u, t), u);
          return n;
        }, m.cV = function(o, t) {
          if (o == null) return true;
          if (o.type === "Feature") return yd(o, t) != null;
          if (o.type === "FeatureCollection") {
            const n = /* @__PURE__ */ new Set();
            for (const u of o.features) {
              const h = yd(u, t);
              if (h == null || n.has(h)) return false;
              n.add(h);
            }
            return true;
          }
          return false;
        }, m.cW = function(o, t, n) {
          var u, h, _, b;
          if (t.removeAll && o.clear(), t.remove) for (const w of t.remove) o.delete(w);
          if (t.add) for (const w of t.add) {
            const S = yd(w, n);
            S != null && o.set(S, w);
          }
          if (t.update) for (const w of t.update) {
            let S = o.get(w.id);
            if (S == null) continue;
            const I = !w.removeAllProperties && (((u = w.removeProperties) === null || u === void 0 ? void 0 : u.length) > 0 || ((h = w.addOrUpdateProperties) === null || h === void 0 ? void 0 : h.length) > 0);
            if ((w.newGeometry || w.removeAllProperties || I) && (S = Object.assign({}, S), o.set(w.id, S), I && (S.properties = Object.assign({}, S.properties))), w.newGeometry && (S.geometry = w.newGeometry), w.removeAllProperties) S.properties = {};
            else if (((_ = w.removeProperties) === null || _ === void 0 ? void 0 : _.length) > 0) for (const R of w.removeProperties) Object.prototype.hasOwnProperty.call(S.properties, R) && delete S.properties[R];
            if (((b = w.addOrUpdateProperties) === null || b === void 0 ? void 0 : b.length) > 0) for (const { key: R, value: B } of w.addOrUpdateProperties) S.properties[R] = B;
          }
        }, m.cX = na, m.ca = function(o, t) {
          return o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7], o[8] = t[8], o[9] = t[9], o[10] = t[10], o[11] = t[11], o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15], o;
        }, m.cb = (o) => o.type === "symbol", m.cc = (o) => o.type === "circle", m.cd = (o) => o.type === "heatmap", m.ce = (o) => o.type === "line", m.cf = (o) => o.type === "fill", m.cg = (o) => o.type === "fill-extrusion", m.ch = (o) => o.type === "hillshade", m.ci = (o) => o.type === "color-relief", m.cj = (o) => o.type === "raster", m.ck = (o) => o.type === "background", m.cl = (o) => o.type === "custom", m.cm = Ft, m.cn = function(o, t, n) {
          const u = at(t.x - n.x, t.y - n.y), h = at(o.x - n.x, o.y - n.y);
          var _, b;
          return mt(Math.atan2(u[0] * h[1] - u[1] * h[0], (_ = u)[0] * (b = h)[0] + _[1] * b[1]));
        }, m.co = Ht, m.cp = function(o, t) {
          return ri[t] && (o instanceof MouseEvent || o instanceof WheelEvent);
        }, m.cq = function(o, t) {
          return Zt[t] && "touches" in o;
        }, m.cr = function(o) {
          return Zt[o] || ri[o];
        }, m.cs = function(o, t, n) {
          var u = t[0], h = t[1];
          return o[0] = n[0] * u + n[4] * h + n[12], o[1] = n[1] * u + n[5] * h + n[13], o;
        }, m.ct = function(o, t) {
          const { x: n, y: u } = _d.fromLngLat(t);
          return !(o < 0 || o > 25 || u < 0 || u >= 1 || n < 0 || n >= 1);
        }, m.cu = function(o, t) {
          return o[0] = t[0], o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = t[1], o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = t[2], o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, o;
        }, m.cv = class extends $a {
        }, m.cw = Ew, m.cy = function(o) {
          return o.message === Si;
        }, m.cz = xe, m.d = de, m.e = Qt, m.f = (o) => s(void 0, void 0, void 0, (function* () {
          if (o.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const t = new Blob([new Uint8Array(o)], { type: "image/png" });
          try {
            return createImageBitmap(t);
          } catch (n) {
            throw new Error(`Could not load image because of ${n.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
          }
        })), m.g = H, m.h = (o) => new Promise(((t, n) => {
          const u = new Image();
          u.onload = () => {
            t(u), URL.revokeObjectURL(u.src), u.onload = null, window.requestAnimationFrame((() => {
              u.src = ot;
            }));
          }, u.onerror = () => n(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const h = new Blob([new Uint8Array(o)], { type: "image/png" });
          u.src = o.byteLength ? URL.createObjectURL(h) : ot;
        })), m.i = wr, m.j = (o, t) => De(Qt(o, { type: "json" }), t), m.k = Xe, m.l = it, m.m = De, m.n = (o, t) => De(Qt(o, { type: "arrayBuffer" }), t), m.o = function(o) {
          return new am(o).readFields(tw, []);
        }, m.p = Y0, m.q = sd, m.r = an, m.s = bt, m.t = Jc, m.u = kr, m.v = Te, m.w = Gt, m.x = tl, m.y = Uh, m.z = ls;
      })), f("worker", ["./shared"], (function(m) {
        class s {
          constructor(Z, H) {
            this.keyCache = {}, Z && this.replace(Z, H);
          }
          replace(Z, H) {
            this._layerConfigs = {}, this._layers = {}, this.update(Z, [], H);
          }
          update(Z, H, ne) {
            for (const ke of Z) {
              this._layerConfigs[ke.id] = ke;
              const De = this._layers[ke.id] = m.bJ(ke, ne);
              De._featureFilter = m.aa(De.filter, ne), this.keyCache[ke.id] && delete this.keyCache[ke.id];
            }
            for (const ke of H) delete this.keyCache[ke], delete this._layerConfigs[ke], delete this._layers[ke];
            this.familiesBySource = {};
            const xe = m.cC(Object.values(this._layerConfigs), this.keyCache);
            for (const ke of xe) {
              const De = ke.map(((xt) => this._layers[xt.id])), de = De[0];
              if (de.visibility === "none") continue;
              const ve = de.source || "";
              let $e = this.familiesBySource[ve];
              $e || ($e = this.familiesBySource[ve] = {});
              const it = de.sourceLayer || "_geojsonTileLayer";
              let Xe = $e[it];
              Xe || (Xe = $e[it] = []), Xe.push(De);
            }
          }
        }
        class C {
          constructor(Z) {
            const H = {}, ne = [];
            for (const de in Z) {
              const ve = Z[de], $e = H[de] = {};
              for (const it in ve) {
                const Xe = ve[+it];
                if (!Xe || Xe.bitmap.width === 0 || Xe.bitmap.height === 0) continue;
                const xt = { x: 0, y: 0, w: Xe.bitmap.width + 2, h: Xe.bitmap.height + 2 };
                ne.push(xt), $e[it] = { rect: xt, metrics: Xe.metrics };
              }
            }
            const { w: xe, h: ke } = m.p(ne), De = new m.q({ width: xe || 1, height: ke || 1 });
            for (const de in Z) {
              const ve = Z[de];
              for (const $e in ve) {
                const it = ve[+$e];
                if (!it || it.bitmap.width === 0 || it.bitmap.height === 0) continue;
                const Xe = H[de][$e].rect;
                m.q.copy(it.bitmap, De, { x: 0, y: 0 }, { x: Xe.x + 1, y: Xe.y + 1 }, it.bitmap);
              }
            }
            this.image = De, this.positions = H;
          }
        }
        m.cD("GlyphAtlas", C);
        class T {
          constructor(Z) {
            this.tileID = new m.Z(Z.tileID.overscaledZ, Z.tileID.wrap, Z.tileID.canonical.z, Z.tileID.canonical.x, Z.tileID.canonical.y), this.uid = Z.uid, this.zoom = Z.zoom, this.pixelRatio = Z.pixelRatio, this.tileSize = Z.tileSize, this.source = Z.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = Z.showCollisionBoxes, this.collectResourceTiming = !!Z.collectResourceTiming, this.returnDependencies = !!Z.returnDependencies, this.promoteId = Z.promoteId, this.inFlightDependencies = [];
          }
          parse(Z, H, ne, xe, ke) {
            return m._(this, void 0, void 0, (function* () {
              this.status = "parsing", this.data = Z, this.collisionBoxArray = new m.a8();
              const De = new m.cE(Object.keys(Z.layers).sort()), de = new m.cF(this.tileID, this.promoteId);
              de.bucketLayerIDs = [];
              const ve = {}, $e = { featureIndex: de, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: ne, subdivisionGranularity: ke }, it = H.familiesBySource[this.source];
              for (const gr in it) {
                const vr = Z.layers[gr];
                if (!vr) continue;
                vr.version === 1 && m.w(`Vector tile source "${this.source}" layer "${gr}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const Wr = De.encode(gr), ge = [];
                for (let dt = 0; dt < vr.length; dt++) {
                  const Bt = vr.feature(dt), Er = de.getId(Bt, gr);
                  ge.push({ feature: Bt, id: Er, index: dt, sourceLayerIndex: Wr });
                }
                for (const dt of it[gr]) {
                  const Bt = dt[0];
                  Bt.source !== this.source && m.w(`layer.source = ${Bt.source} does not equal this.source = ${this.source}`), Bt.minzoom && this.zoom < Math.floor(Bt.minzoom) || Bt.maxzoom && this.zoom >= Bt.maxzoom || Bt.visibility !== "none" && (M(dt, this.zoom, ne), (ve[Bt.id] = Bt.createBucket({ index: de.bucketLayerIDs.length, layers: dt, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Wr, sourceID: this.source })).populate(ge, $e, this.tileID.canonical), de.bucketLayerIDs.push(dt.map(((Er) => Er.id))));
                }
              }
              const Xe = m.bN($e.glyphDependencies, ((gr) => Object.keys(gr).map(Number)));
              this.inFlightDependencies.forEach(((gr) => gr == null ? void 0 : gr.abort())), this.inFlightDependencies = [];
              let xt = Promise.resolve({});
              if (Object.keys(Xe).length) {
                const gr = new AbortController();
                this.inFlightDependencies.push(gr), xt = xe.sendAsync({ type: "GG", data: { stacks: Xe, source: this.source, tileID: this.tileID, type: "glyphs" } }, gr);
              }
              const Te = Object.keys($e.iconDependencies);
              let $t = Promise.resolve({});
              if (Te.length) {
                const gr = new AbortController();
                this.inFlightDependencies.push(gr), $t = xe.sendAsync({ type: "GI", data: { icons: Te, source: this.source, tileID: this.tileID, type: "icons" } }, gr);
              }
              const er = Object.keys($e.patternDependencies);
              let Nt = Promise.resolve({});
              if (er.length) {
                const gr = new AbortController();
                this.inFlightDependencies.push(gr), Nt = xe.sendAsync({ type: "GI", data: { icons: er, source: this.source, tileID: this.tileID, type: "patterns" } }, gr);
              }
              const [ur, Br, Kr] = yield Promise.all([xt, $t, Nt]), Jr = new C(ur), ii = new m.cG(Br, Kr);
              for (const gr in ve) {
                const vr = ve[gr];
                vr instanceof m.a9 ? (M(vr.layers, this.zoom, ne), m.cH({ bucket: vr, glyphMap: ur, glyphPositions: Jr.positions, imageMap: Br, imagePositions: ii.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: $e.subdivisionGranularity })) : vr.hasPattern && (vr instanceof m.cI || vr instanceof m.cJ || vr instanceof m.cK) && (M(vr.layers, this.zoom, ne), vr.addFeatures($e, this.tileID.canonical, ii.patternPositions));
              }
              return this.status = "done", { buckets: Object.values(ve).filter(((gr) => !gr.isEmpty())), featureIndex: de, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Jr.image, imageAtlas: ii, glyphMap: this.returnDependencies ? ur : null, iconMap: this.returnDependencies ? Br : null, glyphPositions: this.returnDependencies ? Jr.positions : null };
            }));
          }
        }
        function M(Fe, Z, H) {
          const ne = new m.F(Z);
          for (const xe of Fe) xe.recalculate(ne, H);
        }
        class z {
          constructor(Z, H, ne) {
            this.actor = Z, this.layerIndex = H, this.availableImages = ne, this.fetching = {}, this.loading = {}, this.loaded = {};
          }
          loadVectorTile(Z, H) {
            return m._(this, void 0, void 0, (function* () {
              const ne = yield m.n(Z.request, H);
              try {
                return { vectorTile: new m.cL(new m.cM(ne.data)), rawData: ne.data, cacheControl: ne.cacheControl, expires: ne.expires };
              } catch (xe) {
                const ke = new Uint8Array(ne.data);
                let De = `Unable to parse the tile at ${Z.request.url}, `;
                throw De += ke[0] === 31 && ke[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${xe.message}`, new Error(De);
              }
            }));
          }
          loadTile(Z) {
            return m._(this, void 0, void 0, (function* () {
              const H = Z.uid, ne = !!(Z && Z.request && Z.request.collectResourceTiming) && new m.cN(Z.request), xe = new T(Z);
              this.loading[H] = xe;
              const ke = new AbortController();
              xe.abort = ke;
              try {
                const De = yield this.loadVectorTile(Z, ke);
                if (delete this.loading[H], !De) return null;
                const de = De.rawData, ve = {};
                De.expires && (ve.expires = De.expires), De.cacheControl && (ve.cacheControl = De.cacheControl);
                const $e = {};
                if (ne) {
                  const Xe = ne.finish();
                  Xe && ($e.resourceTiming = JSON.parse(JSON.stringify(Xe)));
                }
                xe.vectorTile = De.vectorTile;
                const it = xe.parse(De.vectorTile, this.layerIndex, this.availableImages, this.actor, Z.subdivisionGranularity);
                this.loaded[H] = xe, this.fetching[H] = { rawTileData: de, cacheControl: ve, resourceTiming: $e };
                try {
                  const Xe = yield it;
                  return m.e({ rawTileData: de.slice(0) }, Xe, ve, $e);
                } finally {
                  delete this.fetching[H];
                }
              } catch (De) {
                throw delete this.loading[H], xe.status = "done", this.loaded[H] = xe, De;
              }
            }));
          }
          reloadTile(Z) {
            return m._(this, void 0, void 0, (function* () {
              const H = Z.uid;
              if (!this.loaded || !this.loaded[H]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const ne = this.loaded[H];
              if (ne.showCollisionBoxes = Z.showCollisionBoxes, ne.status === "parsing") {
                const xe = yield ne.parse(ne.vectorTile, this.layerIndex, this.availableImages, this.actor, Z.subdivisionGranularity);
                let ke;
                if (this.fetching[H]) {
                  const { rawTileData: De, cacheControl: de, resourceTiming: ve } = this.fetching[H];
                  delete this.fetching[H], ke = m.e({ rawTileData: De.slice(0) }, xe, de, ve);
                } else ke = xe;
                return ke;
              }
              if (ne.status === "done" && ne.vectorTile) return ne.parse(ne.vectorTile, this.layerIndex, this.availableImages, this.actor, Z.subdivisionGranularity);
            }));
          }
          abortTile(Z) {
            return m._(this, void 0, void 0, (function* () {
              const H = this.loading, ne = Z.uid;
              H && H[ne] && H[ne].abort && (H[ne].abort.abort(), delete H[ne]);
            }));
          }
          removeTile(Z) {
            return m._(this, void 0, void 0, (function* () {
              this.loaded && this.loaded[Z.uid] && delete this.loaded[Z.uid];
            }));
          }
        }
        class L {
          constructor() {
            this.loaded = {};
          }
          loadTile(Z) {
            return m._(this, void 0, void 0, (function* () {
              const { uid: H, encoding: ne, rawImageData: xe, redFactor: ke, greenFactor: De, blueFactor: de, baseShift: ve } = Z, $e = xe.width + 2, it = xe.height + 2, Xe = m.b(xe) ? new m.R({ width: $e, height: it }, yield m.cO(xe, -1, -1, $e, it)) : xe, xt = new m.cP(H, Xe, ne, ke, De, de, ve);
              return this.loaded = this.loaded || {}, this.loaded[H] = xt, xt;
            }));
          }
          removeTile(Z) {
            const H = this.loaded, ne = Z.uid;
            H && H[ne] && delete H[ne];
          }
        }
        var A, O, V = (function() {
          if (O) return A;
          function Fe(H, ne) {
            if (H.length !== 0) {
              Z(H[0], ne);
              for (var xe = 1; xe < H.length; xe++) Z(H[xe], !ne);
            }
          }
          function Z(H, ne) {
            for (var xe = 0, ke = 0, De = 0, de = H.length, ve = de - 1; De < de; ve = De++) {
              var $e = (H[De][0] - H[ve][0]) * (H[ve][1] + H[De][1]), it = xe + $e;
              ke += Math.abs(xe) >= Math.abs($e) ? xe - it + $e : $e - it + xe, xe = it;
            }
            xe + ke >= 0 != !!ne && H.reverse();
          }
          return O = 1, A = function H(ne, xe) {
            var ke, De = ne && ne.type;
            if (De === "FeatureCollection") for (ke = 0; ke < ne.features.length; ke++) H(ne.features[ke], xe);
            else if (De === "GeometryCollection") for (ke = 0; ke < ne.geometries.length; ke++) H(ne.geometries[ke], xe);
            else if (De === "Feature") H(ne.geometry, xe);
            else if (De === "Polygon") Fe(ne.coordinates, xe);
            else if (De === "MultiPolygon") for (ke = 0; ke < ne.coordinates.length; ke++) Fe(ne.coordinates[ke], xe);
            return ne;
          };
        })(), X = m.cQ(V);
        class W extends m.cS {
          constructor(Z, H) {
            super(new m.cM(), 0, H, [], []), this.feature = Z, this.type = Z.type, this.properties = Z.tags ? Z.tags : {}, "id" in Z && (typeof Z.id == "string" ? this.id = parseInt(Z.id, 10) : typeof Z.id != "number" || isNaN(Z.id) || (this.id = Z.id));
          }
          loadGeometry() {
            const Z = [], H = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
            for (const ne of H) {
              const xe = [];
              for (const ke of ne) xe.push(new m.P(ke[0], ke[1]));
              Z.push(xe);
            }
            return Z;
          }
        }
        class K extends m.cR {
          constructor(Z, H) {
            super(new m.cM()), this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.version = H ? H.version : 1, this.extent = H ? H.extent : 4096, this.length = Z.length, this.features = Z;
          }
          feature(Z) {
            return new W(this.features[Z], this.extent);
          }
        }
        function ie(Fe, Z) {
          Z.writeVarintField(15, Fe.version || 1), Z.writeStringField(1, Fe.name || ""), Z.writeVarintField(5, Fe.extent || 4096);
          const H = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (let ke = 0; ke < Fe.length; ke++) H.feature = Fe.feature(ke), Z.writeMessage(2, ee, H);
          const ne = H.keys;
          for (const ke of ne) Z.writeStringField(3, ke);
          const xe = H.values;
          for (const ke of xe) Z.writeMessage(4, oe, ke);
        }
        function ee(Fe, Z) {
          if (!Fe.feature) return;
          const H = Fe.feature;
          H.id !== void 0 && Z.writeVarintField(1, H.id), Z.writeMessage(2, re, Fe), Z.writeVarintField(3, H.type), Z.writeMessage(4, fe, H);
        }
        function re(Fe, Z) {
          var _a3;
          for (const H in (_a3 = Fe.feature) == null ? void 0 : _a3.properties) {
            let ne = Fe.feature.properties[H], xe = Fe.keycache[H];
            if (ne === null) continue;
            xe === void 0 && (Fe.keys.push(H), xe = Fe.keys.length - 1, Fe.keycache[H] = xe), Z.writeVarint(xe), typeof ne != "string" && typeof ne != "boolean" && typeof ne != "number" && (ne = JSON.stringify(ne));
            const ke = typeof ne + ":" + ne;
            let De = Fe.valuecache[ke];
            De === void 0 && (Fe.values.push(ne), De = Fe.values.length - 1, Fe.valuecache[ke] = De), Z.writeVarint(De);
          }
        }
        function J(Fe, Z) {
          return (Z << 3) + (7 & Fe);
        }
        function Se(Fe) {
          return Fe << 1 ^ Fe >> 31;
        }
        function fe(Fe, Z) {
          const H = Fe.loadGeometry(), ne = Fe.type;
          let xe = 0, ke = 0;
          for (const De of H) {
            let de = 1;
            ne === 1 && (de = De.length), Z.writeVarint(J(1, de));
            const ve = ne === 3 ? De.length - 1 : De.length;
            for (let $e = 0; $e < ve; $e++) {
              $e === 1 && ne !== 1 && Z.writeVarint(J(2, ve - 1));
              const it = De[$e].x - xe, Xe = De[$e].y - ke;
              Z.writeVarint(Se(it)), Z.writeVarint(Se(Xe)), xe += it, ke += Xe;
            }
            Fe.type === 3 && Z.writeVarint(J(7, 1));
          }
        }
        function oe(Fe, Z) {
          const H = typeof Fe;
          H === "string" ? Z.writeStringField(1, Fe) : H === "boolean" ? Z.writeBooleanField(7, Fe) : H === "number" && (Fe % 1 != 0 ? Z.writeDoubleField(3, Fe) : Fe < 0 ? Z.writeSVarintField(6, Fe) : Z.writeVarintField(5, Fe));
        }
        const he = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (Fe) => Fe }, be = Math.fround || (je = new Float32Array(1), (Fe) => (je[0] = +Fe, je[0]));
        var je;
        class Ve {
          constructor(Z) {
            this.options = Object.assign(Object.create(he), Z), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(Z) {
            const { log: H, minZoom: ne, maxZoom: xe } = this.options;
            H && console.time("total time");
            const ke = `prepare ${Z.length} points`;
            H && console.time(ke), this.points = Z;
            const De = [];
            for (let ve = 0; ve < Z.length; ve++) {
              const $e = Z[ve];
              if (!$e.geometry) continue;
              const [it, Xe] = $e.geometry.coordinates, xt = be(vt(it)), Te = be(wt(Xe));
              De.push(xt, Te, 1 / 0, ve, -1, 1), this.options.reduce && De.push(0);
            }
            let de = this.trees[xe + 1] = this._createTree(De);
            H && console.timeEnd(ke);
            for (let ve = xe; ve >= ne; ve--) {
              const $e = +Date.now();
              de = this.trees[ve] = this._createTree(this._cluster(de, ve)), H && console.log("z%d: %d clusters in %dms", ve, de.numItems, +Date.now() - $e);
            }
            return H && console.timeEnd("total time"), this;
          }
          getClusters(Z, H) {
            let ne = ((Z[0] + 180) % 360 + 360) % 360 - 180;
            const xe = Math.max(-90, Math.min(90, Z[1]));
            let ke = Z[2] === 180 ? 180 : ((Z[2] + 180) % 360 + 360) % 360 - 180;
            const De = Math.max(-90, Math.min(90, Z[3]));
            if (Z[2] - Z[0] >= 360) ne = -180, ke = 180;
            else if (ne > ke) {
              const Xe = this.getClusters([ne, xe, 180, De], H), xt = this.getClusters([-180, xe, ke, De], H);
              return Xe.concat(xt);
            }
            const de = this.trees[this._limitZoom(H)], ve = de.range(vt(ne), wt(De), vt(ke), wt(xe)), $e = de.data, it = [];
            for (const Xe of ve) {
              const xt = this.stride * Xe;
              it.push($e[xt + 5] > 1 ? Ke($e, xt, this.clusterProps) : this.points[$e[xt + 3]]);
            }
            return it;
          }
          getChildren(Z) {
            const H = this._getOriginId(Z), ne = this._getOriginZoom(Z), xe = "No cluster with the specified id.", ke = this.trees[ne];
            if (!ke) throw new Error(xe);
            const De = ke.data;
            if (H * this.stride >= De.length) throw new Error(xe);
            const de = this.options.radius / (this.options.extent * Math.pow(2, ne - 1)), ve = ke.within(De[H * this.stride], De[H * this.stride + 1], de), $e = [];
            for (const it of ve) {
              const Xe = it * this.stride;
              De[Xe + 4] === Z && $e.push(De[Xe + 5] > 1 ? Ke(De, Xe, this.clusterProps) : this.points[De[Xe + 3]]);
            }
            if ($e.length === 0) throw new Error(xe);
            return $e;
          }
          getLeaves(Z, H, ne) {
            const xe = [];
            return this._appendLeaves(xe, Z, H = H || 10, ne = ne || 0, 0), xe;
          }
          getTile(Z, H, ne) {
            const xe = this.trees[this._limitZoom(Z)], ke = Math.pow(2, Z), { extent: De, radius: de } = this.options, ve = de / De, $e = (ne - ve) / ke, it = (ne + 1 + ve) / ke, Xe = { features: [] };
            return this._addTileFeatures(xe.range((H - ve) / ke, $e, (H + 1 + ve) / ke, it), xe.data, H, ne, ke, Xe), H === 0 && this._addTileFeatures(xe.range(1 - ve / ke, $e, 1, it), xe.data, ke, ne, ke, Xe), H === ke - 1 && this._addTileFeatures(xe.range(0, $e, ve / ke, it), xe.data, -1, ne, ke, Xe), Xe.features.length ? Xe : null;
          }
          getClusterExpansionZoom(Z) {
            let H = this._getOriginZoom(Z) - 1;
            for (; H <= this.options.maxZoom; ) {
              const ne = this.getChildren(Z);
              if (H++, ne.length !== 1) break;
              Z = ne[0].properties.cluster_id;
            }
            return H;
          }
          _appendLeaves(Z, H, ne, xe, ke) {
            const De = this.getChildren(H);
            for (const de of De) {
              const ve = de.properties;
              if (ve && ve.cluster ? ke + ve.point_count <= xe ? ke += ve.point_count : ke = this._appendLeaves(Z, ve.cluster_id, ne, xe, ke) : ke < xe ? ke++ : Z.push(de), Z.length === ne) break;
            }
            return ke;
          }
          _createTree(Z) {
            const H = new m.aI(Z.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let ne = 0; ne < Z.length; ne += this.stride) H.add(Z[ne], Z[ne + 1]);
            return H.finish(), H.data = Z, H;
          }
          _addTileFeatures(Z, H, ne, xe, ke, De) {
            for (const de of Z) {
              const ve = de * this.stride, $e = H[ve + 5] > 1;
              let it, Xe, xt;
              if ($e) it = lt(H, ve, this.clusterProps), Xe = H[ve], xt = H[ve + 1];
              else {
                const er = this.points[H[ve + 3]];
                it = er.properties;
                const [Nt, ur] = er.geometry.coordinates;
                Xe = vt(Nt), xt = wt(ur);
              }
              const Te = { type: 1, geometry: [[Math.round(this.options.extent * (Xe * ke - ne)), Math.round(this.options.extent * (xt * ke - xe))]], tags: it };
              let $t;
              $t = $e || this.options.generateId ? H[ve + 3] : this.points[H[ve + 3]].id, $t !== void 0 && (Te.id = $t), De.features.push(Te);
            }
          }
          _limitZoom(Z) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+Z), this.options.maxZoom + 1));
          }
          _cluster(Z, H) {
            const { radius: ne, extent: xe, reduce: ke, minPoints: De } = this.options, de = ne / (xe * Math.pow(2, H)), ve = Z.data, $e = [], it = this.stride;
            for (let Xe = 0; Xe < ve.length; Xe += it) {
              if (ve[Xe + 2] <= H) continue;
              ve[Xe + 2] = H;
              const xt = ve[Xe], Te = ve[Xe + 1], $t = Z.within(ve[Xe], ve[Xe + 1], de), er = ve[Xe + 5];
              let Nt = er;
              for (const ur of $t) {
                const Br = ur * it;
                ve[Br + 2] > H && (Nt += ve[Br + 5]);
              }
              if (Nt > er && Nt >= De) {
                let ur, Br = xt * er, Kr = Te * er, Jr = -1;
                const ii = (Xe / it << 5) + (H + 1) + this.points.length;
                for (const gr of $t) {
                  const vr = gr * it;
                  if (ve[vr + 2] <= H) continue;
                  ve[vr + 2] = H;
                  const Wr = ve[vr + 5];
                  Br += ve[vr] * Wr, Kr += ve[vr + 1] * Wr, ve[vr + 4] = ii, ke && (ur || (ur = this._map(ve, Xe, true), Jr = this.clusterProps.length, this.clusterProps.push(ur)), ke(ur, this._map(ve, vr)));
                }
                ve[Xe + 4] = ii, $e.push(Br / Nt, Kr / Nt, 1 / 0, ii, -1, Nt), ke && $e.push(Jr);
              } else {
                for (let ur = 0; ur < it; ur++) $e.push(ve[Xe + ur]);
                if (Nt > 1) for (const ur of $t) {
                  const Br = ur * it;
                  if (!(ve[Br + 2] <= H)) {
                    ve[Br + 2] = H;
                    for (let Kr = 0; Kr < it; Kr++) $e.push(ve[Br + Kr]);
                  }
                }
              }
            }
            return $e;
          }
          _getOriginId(Z) {
            return Z - this.points.length >> 5;
          }
          _getOriginZoom(Z) {
            return (Z - this.points.length) % 32;
          }
          _map(Z, H, ne) {
            if (Z[H + 5] > 1) {
              const De = this.clusterProps[Z[H + 6]];
              return ne ? Object.assign({}, De) : De;
            }
            const xe = this.points[Z[H + 3]].properties, ke = this.options.map(xe);
            return ne && ke === xe ? Object.assign({}, ke) : ke;
          }
        }
        function Ke(Fe, Z, H) {
          return { type: "Feature", id: Fe[Z + 3], properties: lt(Fe, Z, H), geometry: { type: "Point", coordinates: [(ne = Fe[Z], 360 * (ne - 0.5)), at(Fe[Z + 1])] } };
          var ne;
        }
        function lt(Fe, Z, H) {
          const ne = Fe[Z + 5], xe = ne >= 1e4 ? `${Math.round(ne / 1e3)}k` : ne >= 1e3 ? Math.round(ne / 100) / 10 + "k" : ne, ke = Fe[Z + 6], De = ke === -1 ? {} : Object.assign({}, H[ke]);
          return Object.assign(De, { cluster: true, cluster_id: Fe[Z + 3], point_count: ne, point_count_abbreviated: xe });
        }
        function vt(Fe) {
          return Fe / 360 + 0.5;
        }
        function wt(Fe) {
          const Z = Math.sin(Fe * Math.PI / 180), H = 0.5 - 0.25 * Math.log((1 + Z) / (1 - Z)) / Math.PI;
          return H < 0 ? 0 : H > 1 ? 1 : H;
        }
        function at(Fe) {
          const Z = (180 - 360 * Fe) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(Z)) / Math.PI - 90;
        }
        function et(Fe, Z, H, ne) {
          let xe = ne;
          const ke = Z + (H - Z >> 1);
          let De, de = H - Z;
          const ve = Fe[Z], $e = Fe[Z + 1], it = Fe[H], Xe = Fe[H + 1];
          for (let xt = Z + 3; xt < H; xt += 3) {
            const Te = ht(Fe[xt], Fe[xt + 1], ve, $e, it, Xe);
            if (Te > xe) De = xt, xe = Te;
            else if (Te === xe) {
              const $t = Math.abs(xt - ke);
              $t < de && (De = xt, de = $t);
            }
          }
          xe > ne && (De - Z > 3 && et(Fe, Z, De, ne), Fe[De + 2] = xe, H - De > 3 && et(Fe, De, H, ne));
        }
        function ht(Fe, Z, H, ne, xe, ke) {
          let De = xe - H, de = ke - ne;
          if (De !== 0 || de !== 0) {
            const ve = ((Fe - H) * De + (Z - ne) * de) / (De * De + de * de);
            ve > 1 ? (H = xe, ne = ke) : ve > 0 && (H += De * ve, ne += de * ve);
          }
          return De = Fe - H, de = Z - ne, De * De + de * de;
        }
        function yt(Fe, Z, H, ne) {
          const xe = { id: Fe ?? null, type: Z, geometry: H, tags: ne, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if (Z === "Point" || Z === "MultiPoint" || Z === "LineString") nt(xe, H);
          else if (Z === "Polygon") nt(xe, H[0]);
          else if (Z === "MultiLineString") for (const ke of H) nt(xe, ke);
          else if (Z === "MultiPolygon") for (const ke of H) nt(xe, ke[0]);
          return xe;
        }
        function nt(Fe, Z) {
          for (let H = 0; H < Z.length; H += 3) Fe.minX = Math.min(Fe.minX, Z[H]), Fe.minY = Math.min(Fe.minY, Z[H + 1]), Fe.maxX = Math.max(Fe.maxX, Z[H]), Fe.maxY = Math.max(Fe.maxY, Z[H + 1]);
        }
        function ut(Fe, Z, H, ne) {
          if (!Z.geometry) return;
          const xe = Z.geometry.coordinates;
          if (xe && xe.length === 0) return;
          const ke = Z.geometry.type, De = Math.pow(H.tolerance / ((1 << H.maxZoom) * H.extent), 2);
          let de = [], ve = Z.id;
          if (H.promoteId ? ve = Z.properties[H.promoteId] : H.generateId && (ve = ne || 0), ke === "Point") Ft(xe, de);
          else if (ke === "MultiPoint") for (const $e of xe) Ft($e, de);
          else if (ke === "LineString") Ht(xe, de, De, false);
          else if (ke === "MultiLineString") {
            if (H.lineMetrics) {
              for (const $e of xe) de = [], Ht($e, de, De, false), Fe.push(yt(ve, "LineString", de, Z.properties));
              return;
            }
            zt(xe, de, De, false);
          } else if (ke === "Polygon") zt(xe, de, De, true);
          else {
            if (ke !== "MultiPolygon") {
              if (ke === "GeometryCollection") {
                for (const $e of Z.geometry.geometries) ut(Fe, { id: ve, geometry: $e, properties: Z.properties }, H, ne);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const $e of xe) {
              const it = [];
              zt($e, it, De, true), de.push(it);
            }
          }
          Fe.push(yt(ve, ke, de, Z.properties));
        }
        function Ft(Fe, Z) {
          Z.push(pr(Fe[0]), Qt(Fe[1]), 0);
        }
        function Ht(Fe, Z, H, ne) {
          let xe, ke, De = 0;
          for (let ve = 0; ve < Fe.length; ve++) {
            const $e = pr(Fe[ve][0]), it = Qt(Fe[ve][1]);
            Z.push($e, it, 0), ve > 0 && (De += ne ? (xe * it - $e * ke) / 2 : Math.sqrt(Math.pow($e - xe, 2) + Math.pow(it - ke, 2))), xe = $e, ke = it;
          }
          const de = Z.length - 3;
          Z[2] = 1, et(Z, 0, de, H), Z[de + 2] = 1, Z.size = Math.abs(De), Z.start = 0, Z.end = Z.size;
        }
        function zt(Fe, Z, H, ne) {
          for (let xe = 0; xe < Fe.length; xe++) {
            const ke = [];
            Ht(Fe[xe], ke, H, ne), Z.push(ke);
          }
        }
        function pr(Fe) {
          return Fe / 360 + 0.5;
        }
        function Qt(Fe) {
          const Z = Math.sin(Fe * Math.PI / 180), H = 0.5 - 0.25 * Math.log((1 + Z) / (1 - Z)) / Math.PI;
          return H < 0 ? 0 : H > 1 ? 1 : H;
        }
        function tr(Fe, Z, H, ne, xe, ke, De, de) {
          if (ne /= Z, ke >= (H /= Z) && De < ne) return Fe;
          if (De < H || ke >= ne) return null;
          const ve = [];
          for (const $e of Fe) {
            const it = $e.geometry;
            let Xe = $e.type;
            const xt = xe === 0 ? $e.minX : $e.minY, Te = xe === 0 ? $e.maxX : $e.maxY;
            if (xt >= H && Te < ne) {
              ve.push($e);
              continue;
            }
            if (Te < H || xt >= ne) continue;
            let $t = [];
            if (Xe === "Point" || Xe === "MultiPoint") xr(it, $t, H, ne, xe);
            else if (Xe === "LineString") Mr(it, $t, H, ne, xe, false, de.lineMetrics);
            else if (Xe === "MultiLineString") sr(it, $t, H, ne, xe, false);
            else if (Xe === "Polygon") sr(it, $t, H, ne, xe, true);
            else if (Xe === "MultiPolygon") for (const er of it) {
              const Nt = [];
              sr(er, Nt, H, ne, xe, true), Nt.length && $t.push(Nt);
            }
            if ($t.length) {
              if (de.lineMetrics && Xe === "LineString") {
                for (const er of $t) ve.push(yt($e.id, Xe, er, $e.tags));
                continue;
              }
              Xe !== "LineString" && Xe !== "MultiLineString" || ($t.length === 1 ? (Xe = "LineString", $t = $t[0]) : Xe = "MultiLineString"), Xe !== "Point" && Xe !== "MultiPoint" || (Xe = $t.length === 3 ? "Point" : "MultiPoint"), ve.push(yt($e.id, Xe, $t, $e.tags));
            }
          }
          return ve.length ? ve : null;
        }
        function xr(Fe, Z, H, ne, xe) {
          for (let ke = 0; ke < Fe.length; ke += 3) {
            const De = Fe[ke + xe];
            De >= H && De <= ne && Gt(Z, Fe[ke], Fe[ke + 1], Fe[ke + 2]);
          }
        }
        function Mr(Fe, Z, H, ne, xe, ke, De) {
          let de = rr(Fe);
          const ve = xe === 0 ? Dr : wr;
          let $e, it, Xe = Fe.start;
          for (let Nt = 0; Nt < Fe.length - 3; Nt += 3) {
            const ur = Fe[Nt], Br = Fe[Nt + 1], Kr = Fe[Nt + 2], Jr = Fe[Nt + 3], ii = Fe[Nt + 4], gr = xe === 0 ? ur : Br, vr = xe === 0 ? Jr : ii;
            let Wr = false;
            De && ($e = Math.sqrt(Math.pow(ur - Jr, 2) + Math.pow(Br - ii, 2))), gr < H ? vr > H && (it = ve(de, ur, Br, Jr, ii, H), De && (de.start = Xe + $e * it)) : gr > ne ? vr < ne && (it = ve(de, ur, Br, Jr, ii, ne), De && (de.start = Xe + $e * it)) : Gt(de, ur, Br, Kr), vr < H && gr >= H && (it = ve(de, ur, Br, Jr, ii, H), Wr = true), vr > ne && gr <= ne && (it = ve(de, ur, Br, Jr, ii, ne), Wr = true), !ke && Wr && (De && (de.end = Xe + $e * it), Z.push(de), de = rr(Fe)), De && (Xe += $e);
          }
          let xt = Fe.length - 3;
          const Te = Fe[xt], $t = Fe[xt + 1], er = xe === 0 ? Te : $t;
          er >= H && er <= ne && Gt(de, Te, $t, Fe[xt + 2]), xt = de.length - 3, ke && xt >= 3 && (de[xt] !== de[0] || de[xt + 1] !== de[1]) && Gt(de, de[0], de[1], de[2]), de.length && Z.push(de);
        }
        function rr(Fe) {
          const Z = [];
          return Z.size = Fe.size, Z.start = Fe.start, Z.end = Fe.end, Z;
        }
        function sr(Fe, Z, H, ne, xe, ke) {
          for (const De of Fe) Mr(De, Z, H, ne, xe, ke, false);
        }
        function Gt(Fe, Z, H, ne) {
          Fe.push(Z, H, ne);
        }
        function Dr(Fe, Z, H, ne, xe, ke) {
          const De = (ke - Z) / (ne - Z);
          return Gt(Fe, ke, H + (xe - H) * De, 1), De;
        }
        function wr(Fe, Z, H, ne, xe, ke) {
          const De = (ke - H) / (xe - H);
          return Gt(Fe, Z + (ne - Z) * De, ke, 1), De;
        }
        function Ct(Fe, Z) {
          const H = [];
          for (let ne = 0; ne < Fe.length; ne++) {
            const xe = Fe[ne], ke = xe.type;
            let De;
            if (ke === "Point" || ke === "MultiPoint" || ke === "LineString") De = Ee(xe.geometry, Z);
            else if (ke === "MultiLineString" || ke === "Polygon") {
              De = [];
              for (const de of xe.geometry) De.push(Ee(de, Z));
            } else if (ke === "MultiPolygon") {
              De = [];
              for (const de of xe.geometry) {
                const ve = [];
                for (const $e of de) ve.push(Ee($e, Z));
                De.push(ve);
              }
            }
            H.push(yt(xe.id, ke, De, xe.tags));
          }
          return H;
        }
        function Ee(Fe, Z) {
          const H = [];
          H.size = Fe.size, Fe.start !== void 0 && (H.start = Fe.start, H.end = Fe.end);
          for (let ne = 0; ne < Fe.length; ne += 3) H.push(Fe[ne] + Z, Fe[ne + 1], Fe[ne + 2]);
          return H;
        }
        function ot(Fe, Z) {
          if (Fe.transformed) return Fe;
          const H = 1 << Fe.z, ne = Fe.x, xe = Fe.y;
          for (const ke of Fe.features) {
            const De = ke.geometry, de = ke.type;
            if (ke.geometry = [], de === 1) for (let ve = 0; ve < De.length; ve += 2) ke.geometry.push(Le(De[ve], De[ve + 1], Z, H, ne, xe));
            else for (let ve = 0; ve < De.length; ve++) {
              const $e = [];
              for (let it = 0; it < De[ve].length; it += 2) $e.push(Le(De[ve][it], De[ve][it + 1], Z, H, ne, xe));
              ke.geometry.push($e);
            }
          }
          return Fe.transformed = true, Fe;
        }
        function Le(Fe, Z, H, ne, xe, ke) {
          return [Math.round(H * (Fe * ne - xe)), Math.round(H * (Z * ne - ke))];
        }
        function Ye(Fe, Z, H, ne, xe) {
          const ke = Z === xe.maxZoom ? 0 : xe.tolerance / ((1 << Z) * xe.extent), De = { features: [], numPoints: 0, numSimplified: 0, numFeatures: Fe.length, source: null, x: H, y: ne, z: Z, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const de of Fe) ft(De, de, ke, xe);
          return De;
        }
        function ft(Fe, Z, H, ne) {
          const xe = Z.geometry, ke = Z.type, De = [];
          if (Fe.minX = Math.min(Fe.minX, Z.minX), Fe.minY = Math.min(Fe.minY, Z.minY), Fe.maxX = Math.max(Fe.maxX, Z.maxX), Fe.maxY = Math.max(Fe.maxY, Z.maxY), ke === "Point" || ke === "MultiPoint") for (let de = 0; de < xe.length; de += 3) De.push(xe[de], xe[de + 1]), Fe.numPoints++, Fe.numSimplified++;
          else if (ke === "LineString") bt(De, xe, Fe, H, false, false);
          else if (ke === "MultiLineString" || ke === "Polygon") for (let de = 0; de < xe.length; de++) bt(De, xe[de], Fe, H, ke === "Polygon", de === 0);
          else if (ke === "MultiPolygon") for (let de = 0; de < xe.length; de++) {
            const ve = xe[de];
            for (let $e = 0; $e < ve.length; $e++) bt(De, ve[$e], Fe, H, true, $e === 0);
          }
          if (De.length) {
            let de = Z.tags || null;
            if (ke === "LineString" && ne.lineMetrics) {
              de = {};
              for (const $e in Z.tags) de[$e] = Z.tags[$e];
              de.mapbox_clip_start = xe.start / xe.size, de.mapbox_clip_end = xe.end / xe.size;
            }
            const ve = { geometry: De, type: ke === "Polygon" || ke === "MultiPolygon" ? 3 : ke === "LineString" || ke === "MultiLineString" ? 2 : 1, tags: de };
            Z.id !== null && (ve.id = Z.id), Fe.features.push(ve);
          }
        }
        function bt(Fe, Z, H, ne, xe, ke) {
          const De = ne * ne;
          if (ne > 0 && Z.size < (xe ? De : ne)) return void (H.numPoints += Z.length / 3);
          const de = [];
          for (let ve = 0; ve < Z.length; ve += 3) (ne === 0 || Z[ve + 2] > De) && (H.numSimplified++, de.push(Z[ve], Z[ve + 1])), H.numPoints++;
          xe && (function(ve, $e) {
            let it = 0;
            for (let Xe = 0, xt = ve.length, Te = xt - 2; Xe < xt; Te = Xe, Xe += 2) it += (ve[Xe] - ve[Te]) * (ve[Xe + 1] + ve[Te + 1]);
            if (it > 0 === $e) for (let Xe = 0, xt = ve.length; Xe < xt / 2; Xe += 2) {
              const Te = ve[Xe], $t = ve[Xe + 1];
              ve[Xe] = ve[xt - 2 - Xe], ve[Xe + 1] = ve[xt - 1 - Xe], ve[xt - 2 - Xe] = Te, ve[xt - 1 - Xe] = $t;
            }
          })(de, ke), Fe.push(de);
        }
        const tt = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 };
        class mt {
          constructor(Z, H) {
            const ne = (H = this.options = (function(ke, De) {
              for (const de in De) ke[de] = De[de];
              return ke;
            })(Object.create(tt), H)).debug;
            if (ne && console.time("preprocess data"), H.maxZoom < 0 || H.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (H.promoteId && H.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let xe = (function(ke, De) {
              const de = [];
              if (ke.type === "FeatureCollection") for (let ve = 0; ve < ke.features.length; ve++) ut(de, ke.features[ve], De, ve);
              else ut(de, ke.type === "Feature" ? ke : { geometry: ke }, De);
              return de;
            })(Z, H);
            this.tiles = {}, this.tileCoords = [], ne && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", H.indexMaxZoom, H.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), xe = (function(ke, De) {
              const de = De.buffer / De.extent;
              let ve = ke;
              const $e = tr(ke, 1, -1 - de, de, 0, -1, 2, De), it = tr(ke, 1, 1 - de, 2 + de, 0, -1, 2, De);
              return ($e || it) && (ve = tr(ke, 1, -de, 1 + de, 0, -1, 2, De) || [], $e && (ve = Ct($e, 1).concat(ve)), it && (ve = ve.concat(Ct(it, -1)))), ve;
            })(xe, H), xe.length && this.splitTile(xe, 0, 0, 0), ne && (xe.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile(Z, H, ne, xe, ke, De, de) {
            const ve = [Z, H, ne, xe], $e = this.options, it = $e.debug;
            for (; ve.length; ) {
              xe = ve.pop(), ne = ve.pop(), H = ve.pop(), Z = ve.pop();
              const Xe = 1 << H, xt = Zt(H, ne, xe);
              let Te = this.tiles[xt];
              if (!Te && (it > 1 && console.time("creation"), Te = this.tiles[xt] = Ye(Z, H, ne, xe, $e), this.tileCoords.push({ z: H, x: ne, y: xe }), it)) {
                it > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", H, ne, xe, Te.numFeatures, Te.numPoints, Te.numSimplified), console.timeEnd("creation"));
                const Wr = `z${H}`;
                this.stats[Wr] = (this.stats[Wr] || 0) + 1, this.total++;
              }
              if (Te.source = Z, ke == null) {
                if (H === $e.indexMaxZoom || Te.numPoints <= $e.indexMaxPoints) continue;
              } else {
                if (H === $e.maxZoom || H === ke) continue;
                if (ke != null) {
                  const Wr = ke - H;
                  if (ne !== De >> Wr || xe !== de >> Wr) continue;
                }
              }
              if (Te.source = null, Z.length === 0) continue;
              it > 1 && console.time("clipping");
              const $t = 0.5 * $e.buffer / $e.extent, er = 0.5 - $t, Nt = 0.5 + $t, ur = 1 + $t;
              let Br = null, Kr = null, Jr = null, ii = null, gr = tr(Z, Xe, ne - $t, ne + Nt, 0, Te.minX, Te.maxX, $e), vr = tr(Z, Xe, ne + er, ne + ur, 0, Te.minX, Te.maxX, $e);
              Z = null, gr && (Br = tr(gr, Xe, xe - $t, xe + Nt, 1, Te.minY, Te.maxY, $e), Kr = tr(gr, Xe, xe + er, xe + ur, 1, Te.minY, Te.maxY, $e), gr = null), vr && (Jr = tr(vr, Xe, xe - $t, xe + Nt, 1, Te.minY, Te.maxY, $e), ii = tr(vr, Xe, xe + er, xe + ur, 1, Te.minY, Te.maxY, $e), vr = null), it > 1 && console.timeEnd("clipping"), ve.push(Br || [], H + 1, 2 * ne, 2 * xe), ve.push(Kr || [], H + 1, 2 * ne, 2 * xe + 1), ve.push(Jr || [], H + 1, 2 * ne + 1, 2 * xe), ve.push(ii || [], H + 1, 2 * ne + 1, 2 * xe + 1);
            }
          }
          getTile(Z, H, ne) {
            Z = +Z, H = +H, ne = +ne;
            const xe = this.options, { extent: ke, debug: De } = xe;
            if (Z < 0 || Z > 24) return null;
            const de = 1 << Z, ve = Zt(Z, H = H + de & de - 1, ne);
            if (this.tiles[ve]) return ot(this.tiles[ve], ke);
            De > 1 && console.log("drilling down to z%d-%d-%d", Z, H, ne);
            let $e, it = Z, Xe = H, xt = ne;
            for (; !$e && it > 0; ) it--, Xe >>= 1, xt >>= 1, $e = this.tiles[Zt(it, Xe, xt)];
            return $e && $e.source ? (De > 1 && (console.log("found parent tile z%d-%d-%d", it, Xe, xt), console.time("drilling down")), this.splitTile($e.source, it, Xe, xt, Z, H, ne), De > 1 && console.timeEnd("drilling down"), this.tiles[ve] ? ot(this.tiles[ve], ke) : null) : null;
          }
        }
        function Zt(Fe, Z, H) {
          return 32 * ((1 << Fe) * H + Z) + Fe;
        }
        class ri extends z {
          constructor() {
            super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
          }
          loadVectorTile(Z, H) {
            return m._(this, void 0, void 0, (function* () {
              const ne = Z.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const xe = this._geoJSONIndex.getTile(ne.z, ne.x, ne.y);
              if (!xe) return null;
              const ke = new K(xe.features, { version: 2, extent: m.$ });
              let De = (function(de) {
                const ve = new m.cM();
                return (function($e, it) {
                  for (const Xe in $e.layers) it.writeMessage(3, ie, $e.layers[Xe]);
                })(de, ve), ve.finish();
              })(ke);
              return De.byteOffset === 0 && De.byteLength === De.buffer.byteLength || (De = new Uint8Array(De)), { vectorTile: ke, rawData: De.buffer };
            }));
          }
          loadData(Z) {
            return m._(this, void 0, void 0, (function* () {
              var H;
              (H = this._pendingRequest) === null || H === void 0 || H.abort();
              const ne = !!(Z && Z.request && Z.request.collectResourceTiming) && new m.cN(Z.request);
              this._pendingRequest = new AbortController();
              try {
                this._pendingData = this.loadAndProcessGeoJSON(Z, this._pendingRequest);
                const xe = yield this._pendingData;
                this._geoJSONIndex = Z.cluster ? new Ve((function({ superclusterOptions: De, clusterProperties: de }) {
                  if (!de || !De) return De;
                  const ve = {}, $e = {}, it = { accumulated: null, zoom: 0 }, Xe = { properties: null }, xt = Object.keys(de);
                  for (const Te of xt) {
                    const [$t, er] = de[Te], Nt = m.cT(er), ur = m.cT(typeof $t == "string" ? [$t, ["accumulated"], ["get", Te]] : $t);
                    ve[Te] = Nt.value, $e[Te] = ur.value;
                  }
                  return De.map = (Te) => {
                    Xe.properties = Te;
                    const $t = {};
                    for (const er of xt) $t[er] = ve[er].evaluate(it, Xe);
                    return $t;
                  }, De.reduce = (Te, $t) => {
                    Xe.properties = $t;
                    for (const er of xt) it.accumulated = Te[er], Te[er] = $e[er].evaluate(it, Xe);
                  }, De;
                })(Z)).load(xe.features) : (function(De, de) {
                  return new mt(De, de);
                })(xe, Z.geojsonVtOptions), this.loaded = {};
                const ke = { data: xe };
                if (ne) {
                  const De = ne.finish();
                  De && (ke.resourceTiming = {}, ke.resourceTiming[Z.source] = JSON.parse(JSON.stringify(De)));
                }
                return ke;
              } catch (xe) {
                if (delete this._pendingRequest, m.cy(xe)) return { abandoned: true };
                throw xe;
              }
            }));
          }
          getData() {
            return m._(this, void 0, void 0, (function* () {
              return this._pendingData;
            }));
          }
          reloadTile(Z) {
            const H = this.loaded;
            return H && H[Z.uid] ? super.reloadTile(Z) : this.loadTile(Z);
          }
          loadAndProcessGeoJSON(Z, H) {
            return m._(this, void 0, void 0, (function* () {
              let ne = yield this.loadGeoJSON(Z, H);
              if (delete this._pendingRequest, typeof ne != "object") throw new Error(`Input data given to '${Z.source}' is not a valid GeoJSON object.`);
              if (X(ne, true), Z.filter) {
                const xe = m.cT(Z.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                if (xe.result === "error") throw new Error(xe.value.map(((De) => `${De.key}: ${De.message}`)).join(", "));
                ne = { type: "FeatureCollection", features: ne.features.filter(((De) => xe.value.evaluate({ zoom: 0 }, De))) };
              }
              return ne;
            }));
          }
          loadGeoJSON(Z, H) {
            return m._(this, void 0, void 0, (function* () {
              const { promoteId: ne } = Z;
              if (Z.request) {
                const xe = yield m.j(Z.request, H);
                return this._dataUpdateable = m.cV(xe.data, ne) ? m.cU(xe.data, ne) : void 0, xe.data;
              }
              if (typeof Z.data == "string") try {
                const xe = JSON.parse(Z.data);
                return this._dataUpdateable = m.cV(xe, ne) ? m.cU(xe, ne) : void 0, xe;
              } catch {
                throw new Error(`Input data given to '${Z.source}' is not a valid GeoJSON object.`);
              }
              if (!Z.dataDiff) throw new Error(`Input data given to '${Z.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${Z.source}`);
              return m.cW(this._dataUpdateable, Z.dataDiff, ne), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
            }));
          }
          removeSource(Z) {
            return m._(this, void 0, void 0, (function* () {
              this._pendingRequest && this._pendingRequest.abort();
            }));
          }
          getClusterExpansionZoom(Z) {
            return this._geoJSONIndex.getClusterExpansionZoom(Z.clusterId);
          }
          getClusterChildren(Z) {
            return this._geoJSONIndex.getChildren(Z.clusterId);
          }
          getClusterLeaves(Z) {
            return this._geoJSONIndex.getLeaves(Z.clusterId, Z.limit, Z.offset);
          }
        }
        class Si {
          constructor(Z) {
            this.self = Z, this.actor = new m.J(Z), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = /* @__PURE__ */ new Map(), this.self.registerWorkerSource = (H, ne) => {
              if (this.externalWorkerSourceTypes[H]) throw new Error(`Worker source with name "${H}" already registered.`);
              this.externalWorkerSourceTypes[H] = ne;
            }, this.self.addProtocol = m.cA, this.self.removeProtocol = m.cB, this.self.registerRTLTextPlugin = (H) => {
              m.cX.setMethods(H);
            }, this.actor.registerMessageHandler("LDT", ((H, ne) => this._getDEMWorkerSource(H, ne.source).loadTile(ne))), this.actor.registerMessageHandler("RDT", ((H, ne) => m._(this, void 0, void 0, (function* () {
              this._getDEMWorkerSource(H, ne.source).removeTile(ne);
            })))), this.actor.registerMessageHandler("GCEZ", ((H, ne) => m._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(H, ne.type, ne.source).getClusterExpansionZoom(ne);
            })))), this.actor.registerMessageHandler("GCC", ((H, ne) => m._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(H, ne.type, ne.source).getClusterChildren(ne);
            })))), this.actor.registerMessageHandler("GCL", ((H, ne) => m._(this, void 0, void 0, (function* () {
              return this._getWorkerSource(H, ne.type, ne.source).getClusterLeaves(ne);
            })))), this.actor.registerMessageHandler("LD", ((H, ne) => this._getWorkerSource(H, ne.type, ne.source).loadData(ne))), this.actor.registerMessageHandler("GD", ((H, ne) => this._getWorkerSource(H, ne.type, ne.source).getData())), this.actor.registerMessageHandler("LT", ((H, ne) => this._getWorkerSource(H, ne.type, ne.source).loadTile(ne))), this.actor.registerMessageHandler("RT", ((H, ne) => this._getWorkerSource(H, ne.type, ne.source).reloadTile(ne))), this.actor.registerMessageHandler("AT", ((H, ne) => this._getWorkerSource(H, ne.type, ne.source).abortTile(ne))), this.actor.registerMessageHandler("RMT", ((H, ne) => this._getWorkerSource(H, ne.type, ne.source).removeTile(ne))), this.actor.registerMessageHandler("RS", ((H, ne) => m._(this, void 0, void 0, (function* () {
              if (!this.workerSources[H] || !this.workerSources[H][ne.type] || !this.workerSources[H][ne.type][ne.source]) return;
              const xe = this.workerSources[H][ne.type][ne.source];
              delete this.workerSources[H][ne.type][ne.source], xe.removeSource !== void 0 && xe.removeSource(ne);
            })))), this.actor.registerMessageHandler("RM", ((H) => m._(this, void 0, void 0, (function* () {
              delete this.layerIndexes[H], delete this.availableImages[H], delete this.workerSources[H], delete this.demWorkerSources[H], this.globalStates.delete(H);
            })))), this.actor.registerMessageHandler("SR", ((H, ne) => m._(this, void 0, void 0, (function* () {
              this.referrer = ne;
            })))), this.actor.registerMessageHandler("SRPS", ((H, ne) => this._syncRTLPluginState(H, ne))), this.actor.registerMessageHandler("IS", ((H, ne) => m._(this, void 0, void 0, (function* () {
              this.self.importScripts(ne);
            })))), this.actor.registerMessageHandler("SI", ((H, ne) => this._setImages(H, ne))), this.actor.registerMessageHandler("UL", ((H, ne) => m._(this, void 0, void 0, (function* () {
              this._getLayerIndex(H).update(ne.layers, ne.removedIds, this._getGlobalState(H));
            })))), this.actor.registerMessageHandler("UGS", ((H, ne) => m._(this, void 0, void 0, (function* () {
              const xe = this._getGlobalState(H);
              for (const ke in ne) xe[ke] = ne[ke];
            })))), this.actor.registerMessageHandler("SL", ((H, ne) => m._(this, void 0, void 0, (function* () {
              this._getLayerIndex(H).replace(ne, this._getGlobalState(H));
            }))));
          }
          _getGlobalState(Z) {
            let H = this.globalStates.get(Z);
            return H || (H = {}, this.globalStates.set(Z, H)), H;
          }
          _setImages(Z, H) {
            return m._(this, void 0, void 0, (function* () {
              this.availableImages[Z] = H;
              for (const ne in this.workerSources[Z]) {
                const xe = this.workerSources[Z][ne];
                for (const ke in xe) xe[ke].availableImages = H;
              }
            }));
          }
          _syncRTLPluginState(Z, H) {
            return m._(this, void 0, void 0, (function* () {
              return yield m.cX.syncState(H, this.self.importScripts);
            }));
          }
          _getAvailableImages(Z) {
            let H = this.availableImages[Z];
            return H || (H = []), H;
          }
          _getLayerIndex(Z) {
            let H = this.layerIndexes[Z];
            return H || (H = this.layerIndexes[Z] = new s()), H;
          }
          _getWorkerSource(Z, H, ne) {
            if (this.workerSources[Z] || (this.workerSources[Z] = {}), this.workerSources[Z][H] || (this.workerSources[Z][H] = {}), !this.workerSources[Z][H][ne]) {
              const xe = { sendAsync: (ke, De) => (ke.targetMapId = Z, this.actor.sendAsync(ke, De)) };
              switch (H) {
                case "vector":
                  this.workerSources[Z][H][ne] = new z(xe, this._getLayerIndex(Z), this._getAvailableImages(Z));
                  break;
                case "geojson":
                  this.workerSources[Z][H][ne] = new ri(xe, this._getLayerIndex(Z), this._getAvailableImages(Z));
                  break;
                default:
                  this.workerSources[Z][H][ne] = new this.externalWorkerSourceTypes[H](xe, this._getLayerIndex(Z), this._getAvailableImages(Z));
              }
            }
            return this.workerSources[Z][H][ne];
          }
          _getDEMWorkerSource(Z, H) {
            return this.demWorkerSources[Z] || (this.demWorkerSources[Z] = {}), this.demWorkerSources[Z][H] || (this.demWorkerSources[Z][H] = new L()), this.demWorkerSources[Z][H];
          }
        }
        return m.i(self) && (self.worker = new Si(self)), Si;
      })), f("index", ["exports", "./shared"], (function(m, s) {
        var C = "5.7.3";
        function T() {
          var v = new s.A(4);
          return s.A != Float32Array && (v[1] = 0, v[2] = 0), v[0] = 1, v[3] = 1, v;
        }
        let M, z;
        const L = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(v, e, a) {
          const c = requestAnimationFrame(((y) => {
            p(), e(y);
          })), { unsubscribe: p } = s.s(v.signal, "abort", (() => {
            p(), cancelAnimationFrame(c), a(s.c());
          }), false);
        }, frameAsync(v) {
          return new Promise(((e, a) => {
            this.frame(v, e, a);
          }));
        }, getImageData(v, e = 0) {
          return this.getImageCanvasContext(v).getImageData(-e, -e, v.width + 2 * e, v.height + 2 * e);
        }, getImageCanvasContext(v) {
          const e = window.document.createElement("canvas"), a = e.getContext("2d", { willReadFrequently: true });
          if (!a) throw new Error("failed to create canvas 2d context");
          return e.width = v.width, e.height = v.height, a.drawImage(v, 0, 0, v.width, v.height), a;
        }, resolveURL: (v) => (M || (M = document.createElement("a")), M.href = v, M.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return !!matchMedia && (z == null && (z = matchMedia("(prefers-reduced-motion: reduce)")), z.matches);
        } };
        class A {
          static testProp(e) {
            if (!A.docStyle) return e[0];
            for (let a = 0; a < e.length; a++) if (e[a] in A.docStyle) return e[a];
            return e[0];
          }
          static create(e, a, c) {
            const p = window.document.createElement(e);
            return a !== void 0 && (p.className = a), c && c.appendChild(p), p;
          }
          static createNS(e, a) {
            return window.document.createElementNS(e, a);
          }
          static disableDrag() {
            A.docStyle && A.selectProp && (A.userSelect = A.docStyle[A.selectProp], A.docStyle[A.selectProp] = "none");
          }
          static enableDrag() {
            A.docStyle && A.selectProp && (A.docStyle[A.selectProp] = A.userSelect);
          }
          static setTransform(e, a) {
            e.style[A.transformProp] = a;
          }
          static addEventListener(e, a, c, p = {}) {
            e.addEventListener(a, c, "passive" in p ? p : p.capture);
          }
          static removeEventListener(e, a, c, p = {}) {
            e.removeEventListener(a, c, "passive" in p ? p : p.capture);
          }
          static suppressClickInternal(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", A.suppressClickInternal, true);
          }
          static suppressClick() {
            window.addEventListener("click", A.suppressClickInternal, true), window.setTimeout((() => {
              window.removeEventListener("click", A.suppressClickInternal, true);
            }), 0);
          }
          static getScale(e) {
            const a = e.getBoundingClientRect();
            return { x: a.width / e.offsetWidth || 1, y: a.height / e.offsetHeight || 1, boundingClientRect: a };
          }
          static getPoint(e, a, c) {
            const p = a.boundingClientRect;
            return new s.P((c.clientX - p.left) / a.x - e.clientLeft, (c.clientY - p.top) / a.y - e.clientTop);
          }
          static mousePos(e, a) {
            const c = A.getScale(e);
            return A.getPoint(e, c, a);
          }
          static touchPos(e, a) {
            const c = [], p = A.getScale(e);
            for (let y = 0; y < a.length; y++) c.push(A.getPoint(e, p, a[y]));
            return c;
          }
          static mouseButton(e) {
            return e.button;
          }
          static remove(e) {
            e.parentNode && e.parentNode.removeChild(e);
          }
          static sanitize(e) {
            const a = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"), c = a.querySelectorAll("script");
            for (const p of c) p.remove();
            return A.clean(a), a.innerHTML;
          }
          static isPossiblyDangerous(e, a) {
            const c = a.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e) || !c.includes("javascript:") && !c.includes("data:")) || !!e.startsWith("on") || void 0;
          }
          static clean(e) {
            const a = e.children;
            for (const c of a) A.removeAttributes(c), A.clean(c);
          }
          static removeAttributes(e) {
            for (const { name: a, value: c } of e.attributes) A.isPossiblyDangerous(a, c) && e.removeAttribute(a);
          }
        }
        A.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, A.selectProp = A.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), A.transformProp = A.testProp(["transform", "WebkitTransform"]);
        const O = { supported: false, testSupport: function(v) {
          !W && X && (K ? ie(v) : V = v);
        } };
        let V, X, W = false, K = false;
        function ie(v) {
          const e = v.createTexture();
          v.bindTexture(v.TEXTURE_2D, e);
          try {
            if (v.texImage2D(v.TEXTURE_2D, 0, v.RGBA, v.RGBA, v.UNSIGNED_BYTE, X), v.isContextLost()) return;
            O.supported = true;
          } catch {
          }
          v.deleteTexture(e), W = true;
        }
        var ee;
        typeof document < "u" && (X = document.createElement("img"), X.onload = () => {
          V && ie(V), V = null, K = true;
        }, X.onerror = () => {
          W = true, V = null;
        }, X.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), (function(v) {
          let e, a, c, p;
          v.resetRequestQueue = () => {
            e = [], a = 0, c = 0, p = {};
          }, v.addThrottleControl = (P) => {
            const E = c++;
            return p[E] = P, E;
          }, v.removeThrottleControl = (P) => {
            delete p[P], x();
          }, v.getImage = (P, E, D = true) => new Promise(((j, $) => {
            O.supported && (P.headers || (P.headers = {}), P.headers.accept = "image/webp,*/*"), s.e(P, { type: "image" }), e.push({ abortController: E, requestParameters: P, supportImageRefresh: D, state: "queued", onError: (U) => {
              $(U);
            }, onSuccess: (U) => {
              j(U);
            } }), x();
          }));
          const y = (P) => s._(this, void 0, void 0, (function* () {
            P.state = "running";
            const { requestParameters: E, supportImageRefresh: D, onError: j, onSuccess: $, abortController: U } = P, Y = D === false && !s.i(self) && !s.g(E.url) && (!E.headers || Object.keys(E.headers).reduce(((ce, me) => ce && me === "accept"), true));
            a++;
            const se = Y ? k(E, U) : s.m(E, U);
            try {
              const ce = yield se;
              delete P.abortController, P.state = "completed", ce.data instanceof HTMLImageElement || s.b(ce.data) ? $(ce) : ce.data && $({ data: yield (le = ce.data, typeof createImageBitmap == "function" ? s.f(le) : s.h(le)), cacheControl: ce.cacheControl, expires: ce.expires });
            } catch (ce) {
              delete P.abortController, j(ce);
            } finally {
              a--, x();
            }
            var le;
          })), x = () => {
            const P = (() => {
              for (const E of Object.keys(p)) if (p[E]()) return true;
              return false;
            })() ? s.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : s.a.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let E = a; E < P && e.length > 0; E++) {
              const D = e.shift();
              D.abortController.signal.aborted ? E-- : y(D);
            }
          }, k = (P, E) => new Promise(((D, j) => {
            const $ = new Image(), U = P.url, Y = P.credentials;
            Y && Y === "include" ? $.crossOrigin = "use-credentials" : (Y && Y === "same-origin" || !s.d(U)) && ($.crossOrigin = "anonymous"), E.signal.addEventListener("abort", (() => {
              $.src = "", j(s.c());
            })), $.fetchPriority = "high", $.onload = () => {
              $.onerror = $.onload = null, D({ data: $ });
            }, $.onerror = () => {
              $.onerror = $.onload = null, E.signal.aborted || j(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, $.src = U;
          }));
        })(ee || (ee = {})), ee.resetRequestQueue();
        class re {
          constructor(e) {
            this._transformRequestFn = e ?? null;
          }
          transformRequest(e, a) {
            return this._transformRequestFn && this._transformRequestFn(e, a) || { url: e };
          }
          setTransformRequest(e) {
            this._transformRequestFn = e;
          }
        }
        function J(v) {
          const e = [];
          if (typeof v == "string") e.push({ id: "default", url: v });
          else if (v && v.length > 0) {
            const a = [];
            for (const { id: c, url: p } of v) {
              const y = `${c}${p}`;
              a.indexOf(y) === -1 && (a.push(y), e.push({ id: c, url: p }));
            }
          }
          return e;
        }
        function Se(v, e, a) {
          try {
            const c = new URL(v);
            return c.pathname += `${e}${a}`, c.toString();
          } catch {
            throw new Error(`Invalid sprite URL "${v}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
          }
        }
        function fe(v) {
          const { userImage: e } = v;
          return !!(e && e.render && e.render()) && (v.data.replace(new Uint8Array(e.data.buffer)), true);
        }
        class oe extends s.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new s.R({ width: 1, height: 1 }), this.dirty = true;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(e) {
            if (this.loaded !== e && (this.loaded = e, e)) {
              for (const { ids: a, promiseResolve: c } of this.requestors) c(this._getImagesForIds(a));
              this.requestors = [];
            }
          }
          getImage(e) {
            const a = this.images[e];
            if (a && !a.data && a.spriteData) {
              const c = a.spriteData;
              a.data = new s.R({ width: c.width, height: c.height }, c.context.getImageData(c.x, c.y, c.width, c.height).data), a.spriteData = null;
            }
            return a;
          }
          addImage(e, a) {
            if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`);
            this._validate(e, a) && (this.images[e] = a);
          }
          _validate(e, a) {
            let c = true;
            const p = a.data || a.spriteData;
            return this._validateStretch(a.stretchX, p && p.width) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "stretchX" value`))), c = false), this._validateStretch(a.stretchY, p && p.height) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "stretchY" value`))), c = false), this._validateContent(a.content, a) || (this.fire(new s.k(new Error(`Image "${e}" has invalid "content" value`))), c = false), c;
          }
          _validateStretch(e, a) {
            if (!e) return true;
            let c = 0;
            for (const p of e) {
              if (p[0] < c || p[1] < p[0] || a < p[1]) return false;
              c = p[1];
            }
            return true;
          }
          _validateContent(e, a) {
            if (!e) return true;
            if (e.length !== 4) return false;
            const c = a.spriteData, p = c && c.width || a.data.width, y = c && c.height || a.data.height;
            return !(e[0] < 0 || p < e[0] || e[1] < 0 || y < e[1] || e[2] < 0 || p < e[2] || e[3] < 0 || y < e[3] || e[2] < e[0] || e[3] < e[1]);
          }
          updateImage(e, a, c = true) {
            const p = this.getImage(e);
            if (c && (p.data.width !== a.data.width || p.data.height !== a.data.height)) throw new Error(`size mismatch between old image (${p.data.width}x${p.data.height}) and new image (${a.data.width}x${a.data.height}).`);
            a.version = p.version + 1, this.images[e] = a, this.updatedImages[e] = true;
          }
          removeImage(e) {
            const a = this.images[e];
            delete this.images[e], delete this.patterns[e], a.userImage && a.userImage.onRemove && a.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(e) {
            return new Promise(((a, c) => {
              let p = true;
              if (!this.isLoaded()) for (const y of e) this.images[y] || (p = false);
              this.isLoaded() || p ? a(this._getImagesForIds(e)) : this.requestors.push({ ids: e, promiseResolve: a });
            }));
          }
          _getImagesForIds(e) {
            const a = {};
            for (const c of e) {
              let p = this.getImage(c);
              p || (this.fire(new s.l("styleimagemissing", { id: c })), p = this.getImage(c)), p ? a[c] = { data: p.data.clone(), pixelRatio: p.pixelRatio, sdf: p.sdf, version: p.version, stretchX: p.stretchX, stretchY: p.stretchY, content: p.content, textFitWidth: p.textFitWidth, textFitHeight: p.textFitHeight, hasRenderCallback: !!(p.userImage && p.userImage.render) } : s.w(`Image "${c}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            return a;
          }
          getPixelSize() {
            const { width: e, height: a } = this.atlasImage;
            return { width: e, height: a };
          }
          getPattern(e) {
            const a = this.patterns[e], c = this.getImage(e);
            if (!c) return null;
            if (a && a.position.version === c.version) return a.position;
            if (a) a.position.version = c.version;
            else {
              const p = { w: c.data.width + 2, h: c.data.height + 2, x: 0, y: 0 }, y = new s.I(p, c);
              this.patterns[e] = { bin: p, position: y };
            }
            return this._updatePatternAtlas(), this.patterns[e].position;
          }
          bind(e) {
            const a = e.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new s.T(e, this.atlasImage, a.RGBA), this.atlasTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const e = [];
            for (const y in this.patterns) e.push(this.patterns[y].bin);
            const { w: a, h: c } = s.p(e), p = this.atlasImage;
            p.resize({ width: a || 1, height: c || 1 });
            for (const y in this.patterns) {
              const { bin: x } = this.patterns[y], k = x.x + 1, P = x.y + 1, E = this.getImage(y).data, D = E.width, j = E.height;
              s.R.copy(E, p, { x: 0, y: 0 }, { x: k, y: P }, { width: D, height: j }), s.R.copy(E, p, { x: 0, y: j - 1 }, { x: k, y: P - 1 }, { width: D, height: 1 }), s.R.copy(E, p, { x: 0, y: 0 }, { x: k, y: P + j }, { width: D, height: 1 }), s.R.copy(E, p, { x: D - 1, y: 0 }, { x: k - 1, y: P }, { width: 1, height: j }), s.R.copy(E, p, { x: 0, y: 0 }, { x: k + D, y: P }, { width: 1, height: j });
            }
            this.dirty = true;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(e) {
            for (const a of e) {
              if (this.callbackDispatchedThisFrame[a]) continue;
              this.callbackDispatchedThisFrame[a] = true;
              const c = this.getImage(a);
              c || s.w(`Image with ID: "${a}" was not found`), fe(c) && this.updateImage(a, c);
            }
          }
        }
        const he = 1e20;
        function be(v, e, a, c, p, y, x, k, P) {
          for (let E = e; E < e + c; E++) je(v, a * y + E, y, p, x, k, P);
          for (let E = a; E < a + p; E++) je(v, E * y + e, 1, c, x, k, P);
        }
        function je(v, e, a, c, p, y, x) {
          y[0] = 0, x[0] = -he, x[1] = he, p[0] = v[e];
          for (let k = 1, P = 0, E = 0; k < c; k++) {
            p[k] = v[e + k * a];
            const D = k * k;
            do {
              const j = y[P];
              E = (p[k] - p[j] + D - j * j) / (k - j) / 2;
            } while (E <= x[P] && --P > -1);
            P++, y[P] = k, x[P] = E, x[P + 1] = he;
          }
          for (let k = 0, P = 0; k < c; k++) {
            for (; x[P + 1] < k; ) P++;
            const E = y[P], D = k - E;
            v[e + k * a] = p[E] + D * D;
          }
        }
        class Ve {
          constructor(e, a, c) {
            this.requestManager = e, this.localIdeographFontFamily = a, this.entries = {}, this.lang = c;
          }
          setURL(e) {
            this.url = e;
          }
          getGlyphs(e) {
            return s._(this, void 0, void 0, (function* () {
              const a = [];
              for (const y in e) for (const x of e[y]) a.push(this._getAndCacheGlyphsPromise(y, x));
              const c = yield Promise.all(a), p = {};
              for (const { stack: y, id: x, glyph: k } of c) p[y] || (p[y] = {}), p[y][x] = k && { id: k.id, bitmap: k.bitmap.clone(), metrics: k.metrics };
              return p;
            }));
          }
          _getAndCacheGlyphsPromise(e, a) {
            return s._(this, void 0, void 0, (function* () {
              let c = this.entries[e];
              c || (c = this.entries[e] = { glyphs: {}, requests: {}, ranges: {} });
              let p = c.glyphs[a];
              if (p !== void 0) return { stack: e, id: a, glyph: p };
              if (p = this._tinySDF(c, e, a), p) return c.glyphs[a] = p, { stack: e, id: a, glyph: p };
              const y = Math.floor(a / 256);
              if (256 * y > 65535) throw new Error("glyphs > 65535 not supported");
              if (c.ranges[y]) return { stack: e, id: a, glyph: p };
              if (!this.url) throw new Error("glyphsUrl is not set");
              if (!c.requests[y]) {
                const k = Ve.loadGlyphRange(e, y, this.url, this.requestManager);
                c.requests[y] = k;
              }
              const x = yield c.requests[y];
              for (const k in x) this._doesCharSupportLocalGlyph(+k) || (c.glyphs[+k] = x[+k]);
              return c.ranges[y] = true, { stack: e, id: a, glyph: x[a] || null };
            }));
          }
          _doesCharSupportLocalGlyph(e) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || s.u["CJK Unified Ideographs"](e) || s.u["Hangul Syllables"](e) || s.u.Hiragana(e) || s.u.Katakana(e) || s.u["CJK Symbols and Punctuation"](e) || s.u["Halfwidth and Fullwidth Forms"](e));
          }
          _tinySDF(e, a, c) {
            const p = this.localIdeographFontFamily;
            if (!p || !this._doesCharSupportLocalGlyph(c)) return;
            let y = e.tinySDF;
            if (!y) {
              let k = "400";
              /bold/i.test(a) ? k = "900" : /medium/i.test(a) ? k = "500" : /light/i.test(a) && (k = "200"), y = e.tinySDF = new Ve.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, lang: this.lang, fontFamily: p, fontWeight: k });
            }
            const x = y.draw(String.fromCharCode(c));
            return { id: c, bitmap: new s.q({ width: x.width || 60, height: x.height || 60 }, x.data), metrics: { width: x.glyphWidth / 2 || 24, height: x.glyphHeight / 2 || 24, left: x.glyphLeft / 2 + 0.5 || 0, top: x.glyphTop / 2 - 27.5 || -8, advance: x.glyphAdvance / 2 || 24, isDoubleResolution: true } };
          }
        }
        Ve.loadGlyphRange = function(v, e, a, c) {
          return s._(this, void 0, void 0, (function* () {
            const p = 256 * e, y = p + 255, x = c.transformRequest(a.replace("{fontstack}", v).replace("{range}", `${p}-${y}`), "Glyphs"), k = yield s.n(x, new AbortController());
            if (!k || !k.data) throw new Error(`Could not load glyph range. range: ${e}, ${p}-${y}`);
            const P = {};
            for (const E of s.o(k.data)) P[E.id] = E;
            return P;
          }));
        }, Ve.TinySDF = class {
          constructor({ fontSize: v = 24, buffer: e = 3, radius: a = 8, cutoff: c = 0.25, fontFamily: p = "sans-serif", fontWeight: y = "normal", fontStyle: x = "normal", lang: k = null } = {}) {
            this.buffer = e, this.cutoff = c, this.radius = a, this.lang = k;
            const P = this.size = v + 4 * e, E = this._createCanvas(P), D = this.ctx = E.getContext("2d", { willReadFrequently: true });
            D.font = `${x} ${y} ${v}px ${p}`, D.textBaseline = "alphabetic", D.textAlign = "left", D.fillStyle = "black", this.gridOuter = new Float64Array(P * P), this.gridInner = new Float64Array(P * P), this.f = new Float64Array(P), this.z = new Float64Array(P + 1), this.v = new Uint16Array(P);
          }
          _createCanvas(v) {
            const e = document.createElement("canvas");
            return e.width = e.height = v, e;
          }
          draw(v) {
            const { width: e, actualBoundingBoxAscent: a, actualBoundingBoxDescent: c, actualBoundingBoxLeft: p, actualBoundingBoxRight: y } = this.ctx.measureText(v), x = Math.ceil(a), k = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(y - p))), P = Math.min(this.size - this.buffer, x + Math.ceil(c)), E = k + 2 * this.buffer, D = P + 2 * this.buffer, j = Math.max(E * D, 0), $ = new Uint8ClampedArray(j), U = { data: $, width: E, height: D, glyphWidth: k, glyphHeight: P, glyphTop: x, glyphLeft: 0, glyphAdvance: e };
            if (k === 0 || P === 0) return U;
            const { ctx: Y, buffer: se, gridInner: le, gridOuter: ce } = this;
            this.lang && (Y.lang = this.lang), Y.clearRect(se, se, k, P), Y.fillText(v, se, se + x);
            const me = Y.getImageData(se, se, k, P);
            ce.fill(he, 0, j), le.fill(0, 0, j);
            for (let we = 0; we < P; we++) for (let _e = 0; _e < k; _e++) {
              const Pe = me.data[4 * (we * k + _e) + 3] / 255;
              if (Pe === 0) continue;
              const Me = (we + se) * E + _e + se;
              if (Pe === 1) ce[Me] = 0, le[Me] = he;
              else {
                const ye = 0.5 - Pe;
                ce[Me] = ye > 0 ? ye * ye : 0, le[Me] = ye < 0 ? ye * ye : 0;
              }
            }
            be(ce, 0, 0, E, D, E, this.f, this.v, this.z), be(le, se, se, k, P, E, this.f, this.v, this.z);
            for (let we = 0; we < j; we++) {
              const _e = Math.sqrt(ce[we]) - Math.sqrt(le[we]);
              $[we] = Math.round(255 - 255 * (_e / this.radius + this.cutoff));
            }
            return U;
          }
        };
        class Ke {
          constructor() {
            this.specification = s.v.light.position;
          }
          possiblyEvaluate(e, a) {
            return s.B(e.expression.evaluate(a));
          }
          interpolate(e, a, c) {
            return { x: s.C.number(e.x, a.x, c), y: s.C.number(e.y, a.y, c), z: s.C.number(e.z, a.z, c) };
          }
        }
        let lt;
        class vt extends s.E {
          constructor(e) {
            super(), lt = lt || new s.r({ anchor: new s.D(s.v.light.anchor), position: new Ke(), color: new s.D(s.v.light.color), intensity: new s.D(s.v.light.intensity) }), this._transitionable = new s.t(lt, void 0), this.setLight(e), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(e, a = {}) {
            if (!this._validate(s.x, e, a)) for (const c in e) {
              const p = e[c];
              c.endsWith("-transition") ? this._transitionable.setTransition(c.slice(0, -11), p) : this._transitionable.setValue(c, p);
            }
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, a, c) {
            return (!c || c.validate !== false) && s.y(this, e.call(s.z, { value: a, style: { glyphs: true, sprite: true }, styleSpec: s.v }));
          }
        }
        const wt = new s.r({ "sky-color": new s.D(s.v.sky["sky-color"]), "horizon-color": new s.D(s.v.sky["horizon-color"]), "fog-color": new s.D(s.v.sky["fog-color"]), "fog-ground-blend": new s.D(s.v.sky["fog-ground-blend"]), "horizon-fog-blend": new s.D(s.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new s.D(s.v.sky["sky-horizon-blend"]), "atmosphere-blend": new s.D(s.v.sky["atmosphere-blend"]) });
        class at extends s.E {
          constructor(e) {
            super(), this._transitionable = new s.t(wt, void 0), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.F(0));
          }
          setSky(e, a = {}) {
            if (!this._validate(s.G, e, a)) {
              e || (e = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
              for (const c in e) {
                const p = e[c];
                c.endsWith("-transition") ? this._transitionable.setTransition(c.slice(0, -11), p) : this._transitionable.setValue(c, p);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          _validate(e, a, c = {}) {
            return (c == null ? void 0 : c.validate) !== false && s.y(this, e.call(s.z, s.e({ value: a, style: { glyphs: true, sprite: true }, styleSpec: s.v })));
          }
          calculateFogBlendOpacity(e) {
            return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1;
          }
        }
        class et {
          constructor(e, a) {
            this.width = e, this.height = a, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(e, a) {
            const c = e.join(",") + String(a);
            return this.dashEntry[c] || (this.dashEntry[c] = this.addDash(e, a)), this.dashEntry[c];
          }
          getDashRanges(e, a, c) {
            const p = [];
            let y = e.length % 2 == 1 ? -e[e.length - 1] * c : 0, x = e[0] * c, k = true;
            p.push({ left: y, right: x, isDash: k, zeroLength: e[0] === 0 });
            let P = e[0];
            for (let E = 1; E < e.length; E++) {
              k = !k;
              const D = e[E];
              y = P * c, P += D, x = P * c, p.push({ left: y, right: x, isDash: k, zeroLength: D === 0 });
            }
            return p;
          }
          addRoundDash(e, a, c) {
            const p = a / 2;
            for (let y = -c; y <= c; y++) {
              const x = this.width * (this.nextRow + c + y);
              let k = 0, P = e[k];
              for (let E = 0; E < this.width; E++) {
                E / P.right > 1 && (P = e[++k]);
                const D = Math.abs(E - P.left), j = Math.abs(E - P.right), $ = Math.min(D, j);
                let U;
                const Y = y / c * (p + 1);
                if (P.isDash) {
                  const se = p - Math.abs(Y);
                  U = Math.sqrt($ * $ + se * se);
                } else U = p - Math.sqrt($ * $ + Y * Y);
                this.data[x + E] = Math.max(0, Math.min(255, U + 128));
              }
            }
          }
          addRegularDash(e) {
            for (let k = e.length - 1; k >= 0; --k) {
              const P = e[k], E = e[k + 1];
              P.zeroLength ? e.splice(k, 1) : E && E.isDash === P.isDash && (E.left = P.left, e.splice(k, 1));
            }
            const a = e[0], c = e[e.length - 1];
            a.isDash === c.isDash && (a.left = c.left - this.width, c.right = a.right + this.width);
            const p = this.width * this.nextRow;
            let y = 0, x = e[y];
            for (let k = 0; k < this.width; k++) {
              k / x.right > 1 && (x = e[++y]);
              const P = Math.abs(k - x.left), E = Math.abs(k - x.right), D = Math.min(P, E);
              this.data[p + k] = Math.max(0, Math.min(255, (x.isDash ? D : -D) + 128));
            }
          }
          addDash(e, a) {
            const c = a ? 7 : 0, p = 2 * c + 1;
            if (this.nextRow + p > this.height) return s.w("LineAtlas out of space"), null;
            let y = 0;
            for (let k = 0; k < e.length; k++) y += e[k];
            if (y !== 0) {
              const k = this.width / y, P = this.getDashRanges(e, this.width, k);
              a ? this.addRoundDash(P, k, c) : this.addRegularDash(P);
            }
            const x = { y: (this.nextRow + c + 0.5) / this.height, height: 2 * c / this.height, width: y };
            return this.nextRow += p, this.dirty = true, x;
          }
          bind(e) {
            const a = e.gl;
            this.texture ? (a.bindTexture(a.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, this.width, this.height, a.ALPHA, a.UNSIGNED_BYTE, this.data))) : (this.texture = a.createTexture(), a.bindTexture(a.TEXTURE_2D, this.texture), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.REPEAT), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.REPEAT), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR), a.texImage2D(a.TEXTURE_2D, 0, a.ALPHA, this.width, this.height, 0, a.ALPHA, a.UNSIGNED_BYTE, this.data));
          }
        }
        const ht = "maplibre_preloaded_worker_pool";
        class yt {
          constructor() {
            this.active = {};
          }
          acquire(e) {
            if (!this.workers) for (this.workers = []; this.workers.length < yt.workerCount; ) this.workers.push(new Worker(s.a.WORKER_URL));
            return this.active[e] = true, this.workers.slice();
          }
          release(e) {
            delete this.active[e], this.numActive() === 0 && (this.workers.forEach(((a) => {
              a.terminate();
            })), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[ht];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const nt = Math.floor(L.hardwareConcurrency / 2);
        let ut, Ft;
        function Ht() {
          return ut || (ut = new yt()), ut;
        }
        yt.workerCount = s.H(globalThis) ? Math.max(Math.min(nt, 3), 1) : 1;
        class zt {
          constructor(e, a) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = a;
            const c = this.workerPool.acquire(a);
            for (let p = 0; p < c.length; p++) {
              const y = new s.J(c[p], a);
              y.name = `Worker ${p}`, this.actors.push(y);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(e, a) {
            const c = [];
            for (const p of this.actors) c.push(p.sendAsync({ type: e, data: a }));
            return Promise.all(c);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(e = true) {
            this.actors.forEach(((a) => {
              a.remove();
            })), this.actors = [], e && this.workerPool.release(this.id);
          }
          registerMessageHandler(e, a) {
            for (const c of this.actors) c.registerMessageHandler(e, a);
          }
        }
        function pr() {
          return Ft || (Ft = new zt(Ht(), s.K), Ft.registerMessageHandler("GR", ((v, e, a) => s.m(e, a)))), Ft;
        }
        function Qt(v, e) {
          const a = s.L();
          return s.M(a, a, [1, 1, 0]), s.N(a, a, [0.5 * v.width, 0.5 * v.height, 1]), v.calculatePosMatrix ? s.O(a, a, v.calculatePosMatrix(e.toUnwrapped())) : a;
        }
        function tr(v, e, a, c, p, y, x) {
          var k;
          const P = (function($, U, Y) {
            if ($) for (const se of $) {
              const le = U[se];
              if (le && le.source === Y && le.type === "fill-extrusion") return true;
            }
            else for (const se in U) {
              const le = U[se];
              if (le.source === Y && le.type === "fill-extrusion") return true;
            }
            return false;
          })((k = p == null ? void 0 : p.layers) !== null && k !== void 0 ? k : null, e, v.id), E = y.maxPitchScaleFactor(), D = v.tilesIn(c, E, P);
          D.sort(xr);
          const j = [];
          for (const $ of D) j.push({ wrappedTileID: $.tileID.wrapped().key, queryResults: $.tile.queryRenderedFeatures(e, a, v._state, $.queryGeometry, $.cameraQueryGeometry, $.scale, p, y, E, Qt(v.transform, $.tileID), x ? (U, Y) => x($.tileID, U, Y) : void 0) });
          return (function($, U) {
            for (const Y in $) for (const se of $[Y]) Mr(se, U);
            return $;
          })((function($) {
            const U = {}, Y = {};
            for (const se of $) {
              const le = se.queryResults, ce = se.wrappedTileID, me = Y[ce] = Y[ce] || {};
              for (const we in le) {
                const _e = le[we], Pe = me[we] = me[we] || {}, Me = U[we] = U[we] || [];
                for (const ye of _e) Pe[ye.featureIndex] || (Pe[ye.featureIndex] = true, Me.push(ye));
              }
            }
            return U;
          })(j), v);
        }
        function xr(v, e) {
          const a = v.tileID, c = e.tileID;
          return a.overscaledZ - c.overscaledZ || a.canonical.y - c.canonical.y || a.wrap - c.wrap || a.canonical.x - c.canonical.x;
        }
        function Mr(v, e) {
          const a = v.feature, c = e.getFeatureState(a.layer["source-layer"], a.id);
          a.source = a.layer.source, a.layer["source-layer"] && (a.sourceLayer = a.layer["source-layer"]), a.state = c;
        }
        function rr(v, e, a) {
          return s._(this, void 0, void 0, (function* () {
            let c = v;
            if (v.url ? c = (yield s.j(e.transformRequest(v.url, "Source"), a)).data : yield L.frameAsync(a), !c) return null;
            const p = s.Q(s.e(c, v), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in c && c.vector_layers && (p.vectorLayerIds = c.vector_layers.map(((y) => y.id))), p;
          }));
        }
        class sr {
          constructor(e, a) {
            e && (a ? this.setSouthWest(e).setNorthEast(a) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])));
          }
          setNorthEast(e) {
            return this._ne = e instanceof s.S ? new s.S(e.lng, e.lat) : s.S.convert(e), this;
          }
          setSouthWest(e) {
            return this._sw = e instanceof s.S ? new s.S(e.lng, e.lat) : s.S.convert(e), this;
          }
          extend(e) {
            const a = this._sw, c = this._ne;
            let p, y;
            if (e instanceof s.S) p = e, y = e;
            else {
              if (!(e instanceof sr)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(sr.convert(e)) : this.extend(s.S.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(s.S.convert(e)) : this;
              if (p = e._sw, y = e._ne, !p || !y) return this;
            }
            return a || c ? (a.lng = Math.min(p.lng, a.lng), a.lat = Math.min(p.lat, a.lat), c.lng = Math.max(y.lng, c.lng), c.lat = Math.max(y.lat, c.lat)) : (this._sw = new s.S(p.lng, p.lat), this._ne = new s.S(y.lng, y.lat)), this;
          }
          getCenter() {
            return new s.S((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new s.S(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new s.S(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(e) {
            const { lng: a, lat: c } = s.S.convert(e);
            let p = this._sw.lng <= a && a <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (p = this._sw.lng >= a && a >= this._ne.lng), this._sw.lat <= c && c <= this._ne.lat && p;
          }
          static convert(e) {
            return e instanceof sr ? e : e && new sr(e);
          }
          static fromLngLat(e, a = 0) {
            const c = 360 * a / 40075017, p = c / Math.cos(Math.PI / 180 * e.lat);
            return new sr(new s.S(e.lng - p, e.lat - c), new s.S(e.lng + p, e.lat + c));
          }
          adjustAntiMeridian() {
            const e = new s.S(this._sw.lng, this._sw.lat), a = new s.S(this._ne.lng, this._ne.lat);
            return new sr(e, e.lng > a.lng ? new s.S(a.lng + 360, a.lat) : a);
          }
        }
        class Gt {
          constructor(e, a, c) {
            this.bounds = sr.convert(this.validateBounds(e)), this.minzoom = a || 0, this.maxzoom = c || 24;
          }
          validateBounds(e) {
            return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];
          }
          contains(e) {
            const a = Math.pow(2, e.z), c = Math.floor(s.V(this.bounds.getWest()) * a), p = Math.floor(s.U(this.bounds.getNorth()) * a), y = Math.ceil(s.V(this.bounds.getEast()) * a), x = Math.ceil(s.U(this.bounds.getSouth()) * a);
            return e.x >= c && e.x < y && e.y >= p && e.y < x;
          }
        }
        class Dr extends s.E {
          constructor(e, a, c, p) {
            if (super(), this.id = e, this.dispatcher = c, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, s.e(this, s.Q(a, ["url", "scheme", "tileSize", "promoteId"])), this._options = s.e({ type: "vector" }, a), this._collectResourceTiming = a.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(p);
          }
          load() {
            return s._(this, void 0, void 0, (function* () {
              this._loaded = false, this.fire(new s.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const e = yield rr(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e && (s.e(this, e), e.bounds && (this.tileBounds = new Gt(e.bounds, this.minzoom, this.maxzoom)), this.fire(new s.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.l("data", { dataType: "source", sourceDataType: "content" })));
              } catch (e) {
                this._tileJSONRequest = null, this._loaded = true, this.fire(new s.k(e));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          setSourceProperty(e) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load();
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e;
            })), this;
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e;
            })), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return s.e({}, this._options);
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), c = { request: this.map._requestManager.transformRequest(a, "Tile"), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
              c.request.collectResourceTiming = this._collectResourceTiming;
              let p = "RT";
              if (e.actor && e.state !== "expired") {
                if (e.state === "loading") return new Promise(((y, x) => {
                  e.reloadPromise = { resolve: y, reject: x };
                }));
              } else e.actor = this.dispatcher.getActor(), p = "LT";
              e.abortController = new AbortController();
              try {
                const y = yield e.actor.sendAsync({ type: p, data: c }, e.abortController);
                if (delete e.abortController, e.aborted) return;
                this._afterTileLoadWorkerResponse(e, y);
              } catch (y) {
                if (delete e.abortController, e.aborted) return;
                if (y && y.status !== 404) throw y;
                this._afterTileLoadWorkerResponse(e, null);
              }
            }));
          }
          _afterTileLoadWorkerResponse(e, a) {
            if (a && a.resourceTiming && (e.resourceTiming = a.resourceTiming), a && this.map._refreshExpiredTiles && e.setExpiryData(a), e.loadVectorData(a, this.map.painter), e.reloadPromise) {
              const c = e.reloadPromise;
              e.reloadPromise = null, this.loadTile(e).then(c.resolve).catch(c.reject);
            }
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({ type: "AT", data: { uid: e.uid, type: this.type, source: this.id } }));
            }));
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } }));
            }));
          }
          hasTransition() {
            return false;
          }
        }
        class wr extends s.E {
          constructor(e, a, c, p) {
            super(), this.id = e, this.dispatcher = c, this.setEventedParent(p), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = s.e({ type: "raster" }, a), s.e(this, s.Q(a, ["url", "scheme", "tileSize"]));
          }
          load() {
            return s._(this, arguments, void 0, (function* (e = false) {
              this._loaded = false, this.fire(new s.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const a = yield rr(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, a && (s.e(this, a), a.bounds && (this.tileBounds = new Gt(a.bounds, this.minzoom, this.maxzoom)), this.fire(new s.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new s.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: e })));
              } catch (a) {
                this._tileJSONRequest = null, this._loaded = true, this.fire(new s.k(a));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(e) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(true);
          }
          setTiles(e) {
            return this.setSourceProperty((() => {
              this._options.tiles = e;
            })), this;
          }
          setUrl(e) {
            return this.setSourceProperty((() => {
              this.url = e, this._options.url = e;
            })), this;
          }
          serialize() {
            return s.e({}, this._options);
          }
          hasTile(e) {
            return !this.tileBounds || this.tileBounds.contains(e.canonical);
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e.abortController = new AbortController();
              try {
                const c = yield ee.getImage(this.map._requestManager.transformRequest(a, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
                if (c && c.data) {
                  this.map._refreshExpiredTiles && (c.cacheControl || c.expires) && e.setExpiryData({ cacheControl: c.cacheControl, expires: c.expires });
                  const p = this.map.painter.context, y = p.gl, x = c.data;
                  e.texture = this.map.painter.getTileTexture(x.width), e.texture ? e.texture.update(x, { useMipmap: true }) : (e.texture = new s.T(p, x, y.RGBA, { useMipmap: true }), e.texture.bind(y.LINEAR, y.CLAMP_TO_EDGE, y.LINEAR_MIPMAP_NEAREST)), e.state = "loaded";
                }
              } catch (c) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (c) throw e.state = "errored", c;
              }
            }));
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController);
            }));
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.texture && this.map.painter.saveTileTexture(e.texture);
            }));
          }
          hasTransition() {
            return false;
          }
        }
        class Ct extends wr {
          constructor(e, a, c, p) {
            super(e, a, c, p), this.type = "raster-dem", this.maxzoom = 22, this._options = s.e({ type: "raster-dem" }, a), this.encoding = a.encoding || "mapbox", this.redFactor = a.redFactor, this.greenFactor = a.greenFactor, this.blueFactor = a.blueFactor, this.baseShift = a.baseShift;
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              const a = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), c = this.map._requestManager.transformRequest(a, "Tile");
              e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController();
              try {
                const p = yield ee.getImage(c, e.abortController, this.map._refreshExpiredTiles);
                if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
                if (p && p.data) {
                  const y = p.data;
                  this.map._refreshExpiredTiles && (p.cacheControl || p.expires) && e.setExpiryData({ cacheControl: p.cacheControl, expires: p.expires });
                  const x = s.b(y) && s.W() ? y : yield this.readImageNow(y), k = { type: this.type, uid: e.uid, source: this.id, rawImageData: x, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!e.actor || e.state === "expired") {
                    e.actor = this.dispatcher.getActor();
                    const P = yield e.actor.sendAsync({ type: "LDT", data: k });
                    e.dem = P, e.needsHillshadePrepare = true, e.needsTerrainPrepare = true, e.state = "loaded";
                  }
                }
              } catch (p) {
                if (delete e.abortController, e.aborted) e.state = "unloaded";
                else if (p) throw e.state = "errored", p;
              }
            }));
          }
          readImageNow(e) {
            return s._(this, void 0, void 0, (function* () {
              if (typeof VideoFrame < "u" && s.X()) {
                const a = e.width + 2, c = e.height + 2;
                try {
                  return new s.R({ width: a, height: c }, yield s.Y(e, -1, -1, a, c));
                } catch {
                }
              }
              return L.getImageData(e, 1);
            }));
          }
          _getNeighboringTiles(e) {
            const a = e.canonical, c = Math.pow(2, a.z), p = (a.x - 1 + c) % c, y = a.x === 0 ? e.wrap - 1 : e.wrap, x = (a.x + 1 + c) % c, k = a.x + 1 === c ? e.wrap + 1 : e.wrap, P = {};
            return P[new s.Z(e.overscaledZ, y, a.z, p, a.y).key] = { backfilled: false }, P[new s.Z(e.overscaledZ, k, a.z, x, a.y).key] = { backfilled: false }, a.y > 0 && (P[new s.Z(e.overscaledZ, y, a.z, p, a.y - 1).key] = { backfilled: false }, P[new s.Z(e.overscaledZ, e.wrap, a.z, a.x, a.y - 1).key] = { backfilled: false }, P[new s.Z(e.overscaledZ, k, a.z, x, a.y - 1).key] = { backfilled: false }), a.y + 1 < c && (P[new s.Z(e.overscaledZ, y, a.z, p, a.y + 1).key] = { backfilled: false }, P[new s.Z(e.overscaledZ, e.wrap, a.z, a.x, a.y + 1).key] = { backfilled: false }, P[new s.Z(e.overscaledZ, k, a.z, x, a.y + 1).key] = { backfilled: false }), P;
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e.uid, source: this.id } }));
            }));
          }
        }
        class Ee extends s.E {
          constructor(e, a, c, p) {
            super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._isUpdatingWorker = false, this._pendingWorkerUpdate = { data: a.data }, this.actor = c.getActor(), this.setEventedParent(p), this._data = a.data, this._options = s.e({}, a), this._collectResourceTiming = a.collectResourceTiming, a.maxzoom !== void 0 && (this.maxzoom = a.maxzoom), a.type && (this.type = a.type), a.attribution && (this.attribution = a.attribution), this.promoteId = a.promoteId, a.clusterMaxZoom !== void 0 && this.maxzoom <= a.clusterMaxZoom && s.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${a.clusterMaxZoom}".`), this.workerOptions = s.e({ source: this.id, cluster: a.cluster || false, geojsonVtOptions: { buffer: this._pixelsToTileUnits(a.buffer !== void 0 ? a.buffer : 128), tolerance: this._pixelsToTileUnits(a.tolerance !== void 0 ? a.tolerance : 0.375), extent: s.$, maxZoom: this.maxzoom, lineMetrics: a.lineMetrics || false, generateId: a.generateId || false }, superclusterOptions: { maxZoom: this._getClusterMaxZoom(a.clusterMaxZoom), minPoints: Math.max(2, a.clusterMinPoints || 2), extent: s.$, radius: this._pixelsToTileUnits(a.clusterRadius || 50), log: false, generateId: a.generateId || false }, clusterProperties: a.clusterProperties, filter: a.filter }, a.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
          }
          _pixelsToTileUnits(e) {
            return e * (s.$ / this.tileSize);
          }
          _getClusterMaxZoom(e) {
            const a = e ? Math.round(e) : this.maxzoom - 1;
            return Number.isInteger(e) || e === void 0 || s.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${a}"`), a;
          }
          load() {
            return s._(this, void 0, void 0, (function* () {
              yield this._updateWorkerData();
            }));
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          setData(e) {
            return this._data = e, this._pendingWorkerUpdate = { data: e }, this._updateWorkerData(), this;
          }
          updateData(e) {
            return this._pendingWorkerUpdate.diff = s.a0(this._pendingWorkerUpdate.diff, e), this._updateWorkerData(), this;
          }
          getData() {
            return s._(this, void 0, void 0, (function* () {
              const e = s.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: "GD", data: e });
            }));
          }
          getCoordinatesFromGeometry(e) {
            return e.type === "GeometryCollection" ? e.geometries.map(((a) => a.coordinates)).flat(1 / 0) : e.coordinates.flat(1 / 0);
          }
          getBounds() {
            return s._(this, void 0, void 0, (function* () {
              const e = new sr(), a = yield this.getData();
              let c;
              switch (a.type) {
                case "FeatureCollection":
                  c = a.features.map(((p) => this.getCoordinatesFromGeometry(p.geometry))).flat(1 / 0);
                  break;
                case "Feature":
                  c = this.getCoordinatesFromGeometry(a.geometry);
                  break;
                default:
                  c = this.getCoordinatesFromGeometry(a);
              }
              if (c.length == 0) return e;
              for (let p = 0; p < c.length - 1; p += 2) e.extend([c[p], c[p + 1]]);
              return e;
            }));
          }
          setClusterOptions(e) {
            return this.workerOptions.cluster = e.cluster, e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom))), this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(e) {
            return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e, source: this.id } });
          }
          getClusterChildren(e) {
            return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e, source: this.id } });
          }
          getClusterLeaves(e, a, c) {
            return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e, limit: a, offset: c } });
          }
          _updateWorkerData() {
            return s._(this, void 0, void 0, (function* () {
              if (this._isUpdatingWorker) return;
              const { data: e, diff: a } = this._pendingWorkerUpdate;
              if (!e && !a) return void s.w(`No data or diff provided to GeoJSONSource ${this.id}.`);
              const c = s.e({ type: this.type }, this.workerOptions);
              e ? (typeof e == "string" ? (c.request = this.map._requestManager.transformRequest(L.resolveURL(e), "Source"), c.request.collectResourceTiming = this._collectResourceTiming) : c.data = JSON.stringify(e), this._pendingWorkerUpdate.data = void 0) : a && (c.dataDiff = a, this._pendingWorkerUpdate.diff = void 0), this._isUpdatingWorker = true, this.fire(new s.l("dataloading", { dataType: "source" }));
              try {
                const p = yield this.actor.sendAsync({ type: "LD", data: c });
                if (this._isUpdatingWorker = false, this._removed || p.abandoned) return void this.fire(new s.l("dataabort", { dataType: "source" }));
                this._data = p.data;
                let y = null;
                p.resourceTiming && p.resourceTiming[this.id] && (y = p.resourceTiming[this.id].slice(0));
                const x = { dataType: "source" };
                this._collectResourceTiming && y && y.length > 0 && s.e(x, { resourceTiming: y }), this.fire(new s.l("data", Object.assign(Object.assign({}, x), { sourceDataType: "metadata" }))), this.fire(new s.l("data", Object.assign(Object.assign({}, x), { sourceDataType: "content" })));
              } catch (p) {
                if (this._isUpdatingWorker = false, this._removed) return void this.fire(new s.l("dataabort", { dataType: "source" }));
                this.fire(new s.k(p));
              } finally {
                (this._pendingWorkerUpdate.data || this._pendingWorkerUpdate.diff) && this._updateWorkerData();
              }
            }));
          }
          loaded() {
            return !this._isUpdatingWorker && this._pendingWorkerUpdate.data === void 0 && this._pendingWorkerUpdate.diff === void 0;
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              const a = e.actor ? "RT" : "LT";
              e.actor = this.actor;
              const c = { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
              e.abortController = new AbortController();
              const p = yield this.actor.sendAsync({ type: a, data: c }, e.abortController);
              delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(p, this.map.painter, a === "RT");
            }));
          }
          abortTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = true;
            }));
          }
          unloadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              e.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } });
            }));
          }
          onRemove() {
            this._removed = true, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return s.e({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return false;
          }
        }
        class ot extends s.E {
          constructor(e, a, c, p) {
            super(), this.flippedWindingOrder = false, this.id = e, this.dispatcher = c, this.coordinates = a.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(p), this.options = a;
          }
          load(e) {
            return s._(this, void 0, void 0, (function* () {
              this._loaded = false, this.fire(new s.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const a = yield ee.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = true, a && a.data && (this.image = a.data, e && (this.coordinates = e), this._finishLoading());
              } catch (a) {
                this._request = null, this._loaded = true, this.fire(new s.k(a));
              }
            }));
          }
          loaded() {
            return this._loaded;
          }
          updateImage(e) {
            return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally((() => {
              this.texture = null;
            })), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new s.l("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(e) {
            this.coordinates = e;
            const a = e.map(s.a1.fromLngLat);
            var c;
            return this.tileID = (function(p) {
              const y = s.a2.fromPoints(p), x = y.width(), k = y.height(), P = Math.max(x, k), E = Math.max(0, Math.floor(-Math.log(P) / Math.LN2)), D = Math.pow(2, E);
              return new s.a4(E, Math.floor((y.minX + y.maxX) / 2 * D), Math.floor((y.minY + y.maxY) / 2 * D));
            })(a), this.terrainTileRanges = this._getOverlappingTileRanges(a), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = a.map(((p) => this.tileID.getTilePoint(p)._round())), this.flippedWindingOrder = ((c = this.tileCoords)[1].x - c[0].x) * (c[2].y - c[0].y) - (c[1].y - c[0].y) * (c[2].x - c[0].x) < 0, this.fire(new s.l("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const e = this.map.painter.context, a = e.gl;
            this.texture || (this.texture = new s.T(e, this.image, a.RGBA), this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
            let c = false;
            for (const p in this.tiles) {
              const y = this.tiles[p];
              y.state !== "loaded" && (y.state = "loaded", y.texture = this.texture, c = true);
            }
            c && this.fire(new s.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(e) {
            return s._(this, void 0, void 0, (function* () {
              this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored";
            }));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return false;
          }
          _getOverlappingTileRanges(e) {
            const { minX: a, minY: c, maxX: p, maxY: y } = s.a2.fromPoints(e), x = {};
            for (let k = 0; k <= s.a3; k++) {
              const P = Math.pow(2, k), E = Math.floor(a * P), D = Math.floor(c * P), j = Math.floor(p * P), $ = Math.floor(y * P);
              x[k] = { minTileX: E, minTileY: D, maxTileX: j, maxTileY: $ };
            }
            return x;
          }
        }
        class Le extends ot {
          constructor(e, a, c, p) {
            super(e, a, c, p), this.roundZoom = true, this.type = "video", this.options = a;
          }
          load() {
            return s._(this, void 0, void 0, (function* () {
              this._loaded = false;
              const e = this.options;
              this.urls = [];
              for (const a of e.urls) this.urls.push(this.map._requestManager.transformRequest(a, "Source").url);
              try {
                const a = yield s.a5(this.urls);
                if (this._loaded = true, !a) return;
                this.video = a, this.video.loop = true, this.video.addEventListener("playing", (() => {
                  this.map.triggerRepaint();
                })), this.map && this.video.play(), this._finishLoading();
              } catch (a) {
                this.fire(new s.k(a));
              }
            }));
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(e) {
            if (this.video) {
              const a = this.video.seekable;
              e < a.start(0) || e > a.end(0) ? this.fire(new s.k(new s.a6(`sources.${this.id}`, null, `Playback for this video can be set only between the ${a.start(0)} and ${a.end(0)}-second mark.`))) : this.video.currentTime = e;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(e) {
            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const e = this.map.painter.context, a = e.gl;
            this.texture ? this.video.paused || (this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE), a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, a.RGBA, a.UNSIGNED_BYTE, this.video)) : (this.texture = new s.T(e, this.video, a.RGBA), this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE));
            let c = false;
            for (const p in this.tiles) {
              const y = this.tiles[p];
              y.state !== "loaded" && (y.state = "loaded", y.texture = this.texture, c = true);
            }
            c && this.fire(new s.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class Ye extends ot {
          constructor(e, a, c, p) {
            super(e, a, c, p), a.coordinates ? Array.isArray(a.coordinates) && a.coordinates.length === 4 && !a.coordinates.some(((y) => !Array.isArray(y) || y.length !== 2 || y.some(((x) => typeof x != "number")))) || this.fire(new s.k(new s.a6(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new s.k(new s.a6(`sources.${e}`, null, 'missing required property "coordinates"'))), a.animate && typeof a.animate != "boolean" && this.fire(new s.k(new s.a6(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), a.canvas ? typeof a.canvas == "string" || a.canvas instanceof HTMLCanvasElement || this.fire(new s.k(new s.a6(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new s.k(new s.a6(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = a, this.animate = a.animate === void 0 || a.animate;
          }
          load() {
            return s._(this, void 0, void 0, (function* () {
              this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new s.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = true, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = false);
              }, this._finishLoading());
            }));
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e) {
            this.map = e, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let e = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e = true), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const a = this.map.painter.context, c = a.gl;
            this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new s.T(a, this.canvas, c.RGBA, { premultiply: true });
            let p = false;
            for (const y in this.tiles) {
              const x = this.tiles[y];
              x.state !== "loaded" && (x.state = "loaded", x.texture = this.texture, p = true);
            }
            p && this.fire(new s.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return true;
            return false;
          }
        }
        const ft = {}, bt = (v) => {
          switch (v) {
            case "geojson":
              return Ee;
            case "image":
              return ot;
            case "raster":
              return wr;
            case "raster-dem":
              return Ct;
            case "vector":
              return Dr;
            case "video":
              return Le;
            case "canvas":
              return Ye;
          }
          return ft[v];
        }, tt = "RTLPluginLoaded";
        class mt extends s.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = pr();
          }
          _syncState(e) {
            return this.status = e, this.dispatcher.broadcast("SRPS", { pluginStatus: e, pluginURL: this.url }).catch(((a) => {
              throw this.status = "error", a;
            }));
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null;
          }
          setRTLTextPlugin(e) {
            return s._(this, arguments, void 0, (function* (a, c = false) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = L.resolveURL(a), !this.url) throw new Error(`requested url ${a} is invalid`);
              if (this.status === "unavailable") {
                if (!c) return this._requestImport();
                this.status = "deferred", this._syncState(this.status);
              } else if (this.status === "requested") return this._requestImport();
            }));
          }
          _requestImport() {
            return s._(this, void 0, void 0, (function* () {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new s.l(tt));
            }));
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
          }
        }
        let Zt = null;
        function ri() {
          return Zt || (Zt = new mt()), Zt;
        }
        class Si {
          constructor(e, a) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e, this.uid = s.a7(), this.uses = 0, this.tileSize = a, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          registerFadeDuration(e) {
            const a = e + this.timeAdded;
            a < this.fadeEndTime || (this.fadeEndTime = a);
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
          }
          clearTextures(e) {
            this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(e, a, c) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
              e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = (function(p, y) {
                const x = {};
                if (!y) return x;
                for (const k of p) {
                  const P = k.layerIds.map(((E) => y.getLayer(E))).filter(Boolean);
                  if (P.length !== 0) {
                    k.layers = P, k.stateDependentLayerIds && (k.stateDependentLayers = k.stateDependentLayerIds.map(((E) => P.filter(((D) => D.id === E))[0])));
                    for (const E of P) x[E.id] = k;
                  }
                }
                return x;
              })(e.buckets, a == null ? void 0 : a.style), this.hasSymbolBuckets = false;
              for (const p in this.buckets) {
                const y = this.buckets[p];
                if (y instanceof s.a9) {
                  if (this.hasSymbolBuckets = true, !c) break;
                  y.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets) for (const p in this.buckets) {
                const y = this.buckets[p];
                if (y instanceof s.a9 && y.hasRTLText) {
                  this.hasRTLText = true, ri().lazyLoad();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const p in this.buckets) {
                const y = this.buckets[p];
                this.queryPadding = Math.max(this.queryPadding, a.style.getLayer(p).queryRadius(y));
              }
              e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage);
            } else this.collisionBoxArray = new s.a8();
          }
          unloadVectorData() {
            for (const e in this.buckets) this.buckets[e].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(e) {
            return this.buckets[e.id];
          }
          upload(e) {
            for (const c in this.buckets) {
              const p = this.buckets[c];
              p.uploadPending() && p.upload(e);
            }
            const a = e.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new s.T(e, this.imageAtlas.image, a.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new s.T(e, this.glyphAtlasImage, a.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(e) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
          }
          queryRenderedFeatures(e, a, c, p, y, x, k, P, E, D, j) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: p, cameraQueryGeometry: y, scale: x, tileSize: this.tileSize, pixelPosMatrix: D, transform: P, params: k, queryPadding: this.queryPadding * E, getElevation: j }, e, a, c) : {};
          }
          querySourceFeatures(e, a) {
            const c = this.latestFeatureIndex;
            if (!c || !c.rawTileData) return;
            const p = c.loadVTLayers(), y = a && a.sourceLayer ? a.sourceLayer : "", x = p._geojsonTileLayer || p[y];
            if (!x) return;
            const k = s.aa(a == null ? void 0 : a.filter, a == null ? void 0 : a.globalState), { z: P, x: E, y: D } = this.tileID.canonical, j = { z: P, x: E, y: D };
            for (let $ = 0; $ < x.length; $++) {
              const U = x.feature($);
              if (k.needGeometry) {
                const le = s.ab(U, true);
                if (!k.filter(new s.F(this.tileID.overscaledZ), le, this.tileID.canonical)) continue;
              } else if (!k.filter(new s.F(this.tileID.overscaledZ), U)) continue;
              const Y = c.getId(U, y), se = new s.ac(U, P, E, D, Y);
              se.tile = j, e.push(se);
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(e) {
            const a = this.expirationTime;
            if (e.cacheControl) {
              const c = s.ad(e.cacheControl);
              c["max-age"] && (this.expirationTime = Date.now() + 1e3 * c["max-age"]);
            } else e.expires && (this.expirationTime = new Date(e.expires).getTime());
            if (this.expirationTime) {
              const c = Date.now();
              let p = false;
              if (this.expirationTime > c) p = false;
              else if (a) if (this.expirationTime < a) p = true;
              else {
                const y = this.expirationTime - a;
                y ? this.expirationTime = c + Math.max(y, 3e4) : p = true;
              }
              else p = true;
              p ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(e, a) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
            const c = this.latestFeatureIndex.loadVTLayers();
            for (const p in this.buckets) {
              if (!a.style.hasLayer(p)) continue;
              const y = this.buckets[p], x = y.layers[0].sourceLayer || "_geojsonTileLayer", k = c[x], P = e[x];
              if (!k || !P || Object.keys(P).length === 0) continue;
              y.update(P, k, this.imageAtlas && this.imageAtlas.patternPositions || {});
              const E = a && a.style && a.style.getLayer(p);
              E && (this.queryPadding = Math.max(this.queryPadding, E.queryRadius(y)));
            }
          }
          holdingForFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < L.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(e) {
            this.symbolFadeHoldUntil = L.now() + e;
          }
          setDependencies(e, a) {
            const c = {};
            for (const p of a) c[p] = true;
            this.dependencies[e] = c;
          }
          hasDependency(e, a) {
            for (const c of e) {
              const p = this.dependencies[c];
              if (p) {
                for (const y of a) if (p[y]) return true;
              }
            }
            return false;
          }
        }
        class Fe {
          constructor(e, a) {
            this.max = e, this.onRemove = a, this.reset();
          }
          reset() {
            for (const e in this.data) for (const a of this.data[e]) a.timeout && clearTimeout(a.timeout), this.onRemove(a.value);
            return this.data = {}, this.order = [], this;
          }
          add(e, a, c) {
            const p = e.wrapped().key;
            this.data[p] === void 0 && (this.data[p] = []);
            const y = { value: a, timeout: void 0 };
            if (c !== void 0 && (y.timeout = setTimeout((() => {
              this.remove(e, y);
            }), c)), this.data[p].push(y), this.order.push(p), this.order.length > this.max) {
              const x = this._getAndRemoveByKey(this.order[0]);
              x && this.onRemove(x);
            }
            return this;
          }
          has(e) {
            return e.wrapped().key in this.data;
          }
          getAndRemove(e) {
            return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
          }
          _getAndRemoveByKey(e) {
            const a = this.data[e].shift();
            return a.timeout && clearTimeout(a.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), a.value;
          }
          getByKey(e) {
            const a = this.data[e];
            return a ? a[0].value : null;
          }
          get(e) {
            return this.has(e) ? this.data[e.wrapped().key][0].value : null;
          }
          remove(e, a) {
            if (!this.has(e)) return this;
            const c = e.wrapped().key, p = a === void 0 ? 0 : this.data[c].indexOf(a), y = this.data[c][p];
            return this.data[c].splice(p, 1), y.timeout && clearTimeout(y.timeout), this.data[c].length === 0 && delete this.data[c], this.onRemove(y.value), this.order.splice(this.order.indexOf(c), 1), this;
          }
          setMaxSize(e) {
            for (this.max = e; this.order.length > this.max; ) {
              const a = this._getAndRemoveByKey(this.order[0]);
              a && this.onRemove(a);
            }
            return this;
          }
          filter(e) {
            const a = [];
            for (const c in this.data) for (const p of this.data[c]) e(p.value) || a.push(p);
            for (const c of a) this.remove(c.value.tileID, c);
          }
        }
        class Z {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(e, a, c) {
            const p = String(a);
            if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][p] = this.stateChanges[e][p] || {}, s.e(this.stateChanges[e][p], c), this.deletedStates[e] === null) {
              this.deletedStates[e] = {};
              for (const y in this.state[e]) y !== p && (this.deletedStates[e][y] = null);
            } else if (this.deletedStates[e] && this.deletedStates[e][p] === null) {
              this.deletedStates[e][p] = {};
              for (const y in this.state[e][p]) c[y] || (this.deletedStates[e][p][y] = null);
            } else for (const y in c) this.deletedStates[e] && this.deletedStates[e][p] && this.deletedStates[e][p][y] === null && delete this.deletedStates[e][p][y];
          }
          removeFeatureState(e, a, c) {
            if (this.deletedStates[e] === null) return;
            const p = String(a);
            if (this.deletedStates[e] = this.deletedStates[e] || {}, c && a !== void 0) this.deletedStates[e][p] !== null && (this.deletedStates[e][p] = this.deletedStates[e][p] || {}, this.deletedStates[e][p][c] = null);
            else if (a !== void 0) if (this.stateChanges[e] && this.stateChanges[e][p]) for (c in this.deletedStates[e][p] = {}, this.stateChanges[e][p]) this.deletedStates[e][p][c] = null;
            else this.deletedStates[e][p] = null;
            else this.deletedStates[e] = null;
          }
          getState(e, a) {
            const c = String(a), p = s.e({}, (this.state[e] || {})[c], (this.stateChanges[e] || {})[c]);
            if (this.deletedStates[e] === null) return {};
            if (this.deletedStates[e]) {
              const y = this.deletedStates[e][a];
              if (y === null) return {};
              for (const x in y) delete p[x];
            }
            return p;
          }
          initializeTileState(e, a) {
            e.setFeatureState(this.state, a);
          }
          coalesceChanges(e, a) {
            const c = {};
            for (const p in this.stateChanges) {
              this.state[p] = this.state[p] || {};
              const y = {};
              for (const x in this.stateChanges[p]) this.state[p][x] || (this.state[p][x] = {}), s.e(this.state[p][x], this.stateChanges[p][x]), y[x] = this.state[p][x];
              c[p] = y;
            }
            for (const p in this.deletedStates) {
              this.state[p] = this.state[p] || {};
              const y = {};
              if (this.deletedStates[p] === null) for (const x in this.state[p]) y[x] = {}, this.state[p][x] = {};
              else for (const x in this.deletedStates[p]) {
                if (this.deletedStates[p][x] === null) this.state[p][x] = {};
                else for (const k of Object.keys(this.deletedStates[p][x])) delete this.state[p][x][k];
                y[x] = this.state[p][x];
              }
              c[p] = c[p] || {}, s.e(c[p], y);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(c).length !== 0) for (const p in e) e[p].setFeatureState(c, a);
          }
        }
        const H = 89.25;
        function ne(v, e) {
          const a = s.ah(e.lat, -s.ai, s.ai);
          return new s.P(s.V(e.lng) * v, s.U(a) * v);
        }
        function xe(v, e) {
          return new s.a1(e.x / v, e.y / v).toLngLat();
        }
        function ke(v) {
          return v.cameraToCenterDistance * Math.min(0.85 * Math.tan(s.ae(90 - v.pitch)), Math.tan(s.ae(H - v.pitch)));
        }
        function De(v, e) {
          const a = v.canonical, c = e / s.af(a.z), p = a.x + Math.pow(2, a.z) * v.wrap, y = s.ag(new Float64Array(16));
          return s.M(y, y, [p * c, a.y * c, 0]), s.N(y, y, [c / s.$, c / s.$, 1]), y;
        }
        function de(v, e, a, c, p) {
          const y = s.a1.fromLngLat(v, e), x = p * s.aj(1, v.lat), k = x * Math.cos(s.ae(a)), P = Math.sqrt(x * x - k * k), E = P * Math.sin(s.ae(-c)), D = P * Math.cos(s.ae(-c));
          return new s.a1(y.x + E, y.y + D, y.z + k);
        }
        function ve(v, e, a) {
          const c = e.intersectsFrustum(v);
          if (!a || c === 0) return c;
          const p = e.intersectsPlane(a);
          return p === 0 ? 0 : c === 2 && p === 2 ? 2 : 1;
        }
        function $e(v, e, a) {
          let c = 0;
          const p = (a - e) / 10;
          for (let y = 0; y < 10; y++) c += p * Math.pow(Math.cos(e + (y + 0.5) / 10 * (a - e)), v);
          return c;
        }
        function it(v, e) {
          return function(a, c, p, y, x) {
            const k = 2 * ((v - 1) / s.ak(Math.cos(s.ae(H - x)) / Math.cos(s.ae(H))) - 1), P = Math.acos(p / y), E = 2 * $e(k - 1, 0, s.ae(x / 2)), D = Math.min(s.ae(H), P + s.ae(x / 2)), j = $e(k - 1, Math.min(D, P - s.ae(x / 2)), D), $ = Math.atan(c / p), U = Math.hypot(c, p);
            let Y = a;
            return Y += s.ak(y / U / Math.max(0.5, Math.cos(s.ae(x / 2)))), Y += k * s.ak(Math.cos($)) / 2, Y -= s.ak(Math.max(1, j / E / e)) / 2, Y;
          };
        }
        const Xe = it(9.314, 3);
        function xt(v, e) {
          const a = (e.roundZoom ? Math.round : Math.floor)(v.zoom + s.ak(v.tileSize / e.tileSize));
          return Math.max(0, a);
        }
        function Te(v, e) {
          const a = v.getCameraFrustum(), c = v.getClippingPlane(), p = v.screenPointToMercatorCoordinate(v.getCameraPoint()), y = s.a1.fromLngLat(v.center, v.elevation);
          p.z = y.z + Math.cos(v.pitchInRadians) * v.cameraToCenterDistance / v.worldSize;
          const x = v.getCoveringTilesDetailsProvider(), k = x.allowVariableZoom(v, e), P = xt(v, e), E = e.minzoom || 0, D = e.maxzoom !== void 0 ? e.maxzoom : v.maxZoom, j = Math.min(Math.max(0, P), D), $ = Math.pow(2, j), U = [$ * p.x, $ * p.y, 0], Y = [$ * y.x, $ * y.y, 0], se = Math.hypot(y.x - p.x, y.y - p.y), le = Math.abs(y.z - p.z), ce = Math.hypot(se, le), me = (Pe) => ({ zoom: 0, x: 0, y: 0, wrap: Pe, fullyVisible: false }), we = [], _e = [];
          if (v.renderWorldCopies && x.allowWorldCopies()) for (let Pe = 1; Pe <= 3; Pe++) we.push(me(-Pe)), we.push(me(Pe));
          for (we.push(me(0)); we.length > 0; ) {
            const Pe = we.pop(), Me = Pe.x, ye = Pe.y;
            let Be = Pe.fullyVisible;
            const Je = { x: Me, y: ye, z: Pe.zoom }, We = x.getTileBoundingVolume(Je, Pe.wrap, v.elevation, e);
            if (!Be) {
              const Pt = ve(a, We, c);
              if (Pt === 0) continue;
              Be = Pt === 2;
            }
            const Ze = x.distanceToTile2d(p.x, p.y, Je, We);
            let Qe = P;
            k && (Qe = (e.calculateTileZoom || Xe)(v.zoom + s.ak(v.tileSize / e.tileSize), Ze, le, ce, v.fov)), Qe = (e.roundZoom ? Math.round : Math.floor)(Qe), Qe = Math.max(0, Qe);
            const It = Math.min(Qe, D);
            if (Pe.wrap = x.getWrap(y, Je, Pe.wrap), Pe.zoom >= It) {
              if (Pe.zoom < E) continue;
              const Pt = j - Pe.zoom, pt = U[0] - 0.5 - (Me << Pt), Vt = U[1] - 0.5 - (ye << Pt), _r = e.reparseOverscaled ? Math.max(Pe.zoom, Qe) : Pe.zoom;
              _e.push({ tileID: new s.Z(Pe.zoom === D ? _r : Pe.zoom, Pe.wrap, Pe.zoom, Me, ye), distanceSq: s.al([Y[0] - 0.5 - Me, Y[1] - 0.5 - ye]), tileDistanceToCamera: Math.sqrt(pt * pt + Vt * Vt) });
            } else for (let Pt = 0; Pt < 4; Pt++) we.push({ zoom: Pe.zoom + 1, x: (Me << 1) + Pt % 2, y: (ye << 1) + (Pt >> 1), wrap: Pe.wrap, fullyVisible: Be });
          }
          return _e.sort(((Pe, Me) => Pe.distanceSq - Me.distanceSq)).map(((Pe) => Pe.tileID));
        }
        const $t = s.a2.fromPoints([new s.P(0, 0), new s.P(s.$, s.$)]);
        class er extends s.E {
          constructor(e, a, c) {
            super(), this.id = e, this.dispatcher = c, this.on("data", ((p) => this._dataHandler(p))), this.on("dataloading", (() => {
              this._sourceErrored = false;
            })), this.on("error", (() => {
              this._sourceErrored = this._source.loaded();
            })), this._source = ((p, y, x, k) => {
              const P = new (bt(y.type))(p, y, x, k);
              if (P.id !== p) throw new Error(`Expected Source id to be ${p} instead of ${P.id}`);
              return P;
            })(e, a, c, this), this._tiles = {}, this._cache = new Fe(0, ((p) => this._unloadTile(p))), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Z(), this._didEmitContent = false, this._updated = false;
          }
          onAdd(e) {
            this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e);
          }
          onRemove(e) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e);
          }
          loaded() {
            if (this._sourceErrored) return true;
            if (!this._sourceLoaded || !this._source.loaded()) return false;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return true;
            if (!this._updated) return false;
            for (const e in this._tiles) {
              const a = this._tiles[e];
              if (a.state !== "loaded" && a.state !== "errored") return false;
            }
            return true;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused) return;
            const e = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, e && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(e, a, c) {
            return s._(this, void 0, void 0, (function* () {
              try {
                yield this._source.loadTile(e), this._tileLoaded(e, a, c);
              } catch (p) {
                e.state = "errored", p.status !== 404 ? this._source.fire(new s.k(p, { tile: e })) : this.update(this.transform, this.terrain);
              }
            }));
          }
          _unloadTile(e) {
            this._source.unloadTile && this._source.unloadTile(e);
          }
          _abortTile(e) {
            this._source.abortTile && this._source.abortTile(e), this._source.fire(new s.l("dataabort", { tile: e, coord: e.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(e) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const a in this._tiles) {
              const c = this._tiles[a];
              c.upload(e), c.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map(((e) => e.tileID)).sort(Nt).map(((e) => e.key));
          }
          getRenderableIds(e) {
            const a = [];
            for (const c in this._tiles) this._isIdRenderable(c, e) && a.push(this._tiles[c]);
            return e ? a.sort(((c, p) => {
              const y = c.tileID, x = p.tileID, k = new s.P(y.canonical.x, y.canonical.y)._rotate(-this.transform.bearingInRadians), P = new s.P(x.canonical.x, x.canonical.y)._rotate(-this.transform.bearingInRadians);
              return y.overscaledZ - x.overscaledZ || P.y - k.y || P.x - k.x;
            })).map(((c) => c.tileID.key)) : a.map(((c) => c.tileID)).sort(Nt).map(((c) => c.key));
          }
          hasRenderableParent(e) {
            const a = this.findLoadedParent(e, 0);
            return !!a && this._isIdRenderable(a.tileID.key);
          }
          _isIdRenderable(e, a) {
            return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (a || !this._tiles[e].holdingForFade());
          }
          reload(e) {
            if (this._paused) this._shouldReloadOnResume = true;
            else {
              this._cache.reset();
              for (const a in this._tiles) e ? this._reloadTile(a, "expired") : this._tiles[a].state !== "errored" && this._reloadTile(a, "reloading");
            }
          }
          _reloadTile(e, a) {
            return s._(this, void 0, void 0, (function* () {
              const c = this._tiles[e];
              c && (c.state !== "loading" && (c.state = a), yield this._loadTile(c, e, a));
            }));
          }
          _tileLoaded(e, a, c) {
            e.timeAdded = L.now(), c === "expired" && (e.refreshedUponExpiration = true), this._setTileReloadTimer(a, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new s.l("data", { dataType: "source", tile: e, coord: e.tileID }));
          }
          _backfillDEM(e) {
            const a = this.getRenderableIds();
            for (let p = 0; p < a.length; p++) {
              const y = a[p];
              if (e.neighboringTiles && e.neighboringTiles[y]) {
                const x = this.getTileByID(y);
                c(e, x), c(x, e);
              }
            }
            function c(p, y) {
              p.needsHillshadePrepare = true, p.needsTerrainPrepare = true;
              let x = y.tileID.canonical.x - p.tileID.canonical.x;
              const k = y.tileID.canonical.y - p.tileID.canonical.y, P = Math.pow(2, p.tileID.canonical.z), E = y.tileID.key;
              x === 0 && k === 0 || Math.abs(k) > 1 || (Math.abs(x) > 1 && (Math.abs(x + P) === 1 ? x += P : Math.abs(x - P) === 1 && (x -= P)), y.dem && p.dem && (p.dem.backfillBorder(y.dem, x, k), p.neighboringTiles && p.neighboringTiles[E] && (p.neighboringTiles[E].backfilled = true)));
            }
          }
          getTile(e) {
            return this.getTileByID(e.key);
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          _retainLoadedChildren(e, a) {
            const c = Object.values(e), p = this._getLoadedDescendents(c);
            for (const y of c) {
              const x = p[y.key];
              if (!x) continue;
              const k = y.overscaledZ + er.maxUnderzooming;
              let P = 1 / 0;
              for (const E of x) {
                const D = E.tileID.overscaledZ;
                D <= k && D < P && (P = D);
              }
              if (P !== 1 / 0) for (const E of x) E.tileID.overscaledZ === P && (a[E.tileID.key] = E.tileID);
            }
          }
          _getLoadedDescendents(e) {
            var a;
            const c = {};
            for (const p in this._tiles) {
              const y = this._tiles[p];
              if (y.hasData()) for (const x of e) y.tileID.isChildOf(x) && (c[a = x.key] || (c[a] = [])).push(y);
            }
            return c;
          }
          findLoadedParent(e, a) {
            if (e.key in this._loadedParentTiles) {
              const c = this._loadedParentTiles[e.key];
              return c && c.tileID.overscaledZ >= a ? c : null;
            }
            for (let c = e.overscaledZ - 1; c >= a; c--) {
              const p = e.scaledTo(c), y = this._getLoadedTile(p);
              if (y) return y;
            }
          }
          findLoadedSibling(e) {
            return this._getLoadedTile(e);
          }
          _getLoadedTile(e) {
            const a = this._tiles[e.key];
            return a && a.hasData() ? a : this._cache.getByKey(e.wrapped().key);
          }
          updateCacheSize(e) {
            const a = Math.ceil(e.width / this._source.tileSize) + 1, c = Math.ceil(e.height / this._source.tileSize) + 1, p = Math.floor(a * c * (this._maxTileCacheZoomLevels === null ? s.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), y = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, p) : p;
            this._cache.setMaxSize(y);
          }
          handleWrapJump(e) {
            const a = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
            if (this._prevLng = e, a) {
              const c = {};
              for (const p in this._tiles) {
                const y = this._tiles[p];
                y.tileID = y.tileID.unwrapTo(y.tileID.wrap + a), c[y.tileID.key] = y;
              }
              this._tiles = c;
              for (const p in this._timers) clearTimeout(this._timers[p]), delete this._timers[p];
              for (const p in this._tiles) this._setTileReloadTimer(p, this._tiles[p]);
            }
          }
          _updateCoveredAndRetainedTiles(e, a, c, p) {
            const y = {}, x = {}, k = Object.keys(e), P = L.now();
            for (const E of k) {
              const D = e[E], j = this._tiles[E];
              if (!j || j.fadeEndTime !== 0 && j.fadeEndTime <= P) continue;
              const $ = this.findLoadedParent(D, a), U = this.findLoadedSibling(D), Y = $ || U || null;
              Y && (this._addTile(Y.tileID), y[Y.tileID.key] = Y.tileID), x[E] = D;
            }
            this._retainLoadedChildren(x, e);
            for (const E in y) e[E] || (this._coveredTiles[E] = true, e[E] = y[E]);
            if (p) {
              const E = {}, D = {};
              for (const j of c) this._tiles[j.key].hasData() ? E[j.key] = j : D[j.key] = j;
              for (const j in D) {
                const $ = D[j].children(this._source.maxzoom);
                this._tiles[$[0].key] && this._tiles[$[1].key] && this._tiles[$[2].key] && this._tiles[$[3].key] && (E[$[0].key] = e[$[0].key] = $[0], E[$[1].key] = e[$[1].key] = $[1], E[$[2].key] = e[$[2].key] = $[2], E[$[3].key] = e[$[3].key] = $[3], delete D[j]);
              }
              for (const j in D) {
                const $ = D[j], U = this.findLoadedParent($, this._source.minzoom), Y = this.findLoadedSibling($), se = U || Y || null;
                if (se) {
                  E[se.tileID.key] = e[se.tileID.key] = se.tileID;
                  for (const le in E) E[le].isChildOf(se.tileID) && delete E[le];
                }
              }
              for (const j in this._tiles) E[j] || (this._coveredTiles[j] = true);
            }
          }
          update(e, a) {
            if (!this._sourceLoaded || this._paused) return;
            let c;
            this.transform = e, this.terrain = a, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? c = e.getVisibleUnwrappedCoordinates(this._source.tileID).map(((E) => new s.Z(E.canonical.z, E.wrap, E.canonical.z, E.canonical.x, E.canonical.y))) : (c = Te(e, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: a, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (c = c.filter(((E) => this._source.hasTile(E))))) : c = [];
            const p = xt(e, this._source), y = Math.max(p - er.maxOverzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              const E = {};
              for (const D of c) if (D.canonical.z > this._source.minzoom) {
                const j = D.scaledTo(D.canonical.z - 1);
                E[j.key] = j;
                const $ = D.scaledTo(Math.max(this._source.minzoom, Math.min(D.canonical.z, 5)));
                E[$.key] = $;
              }
              c = c.concat(Object.values(E));
            }
            const x = c.length === 0 && !this._updated && this._didEmitContent;
            this._updated = true, x && this.fire(new s.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const k = this._updateRetainedTiles(c, p);
            ur(this._source.type) && this._updateCoveredAndRetainedTiles(k, y, c, a);
            for (const E in k) this._tiles[E].clearFadeHold();
            const P = s.am(this._tiles, k);
            for (const E of P) {
              const D = this._tiles[E];
              D.hasSymbolBuckets && !D.holdingForFade() ? D.setHoldDuration(this.map._fadeDuration) : D.hasSymbolBuckets && !D.symbolFadeFinished() || this._removeTile(E);
            }
            this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
          }
          releaseSymbolFadeTiles() {
            for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e);
          }
          _updateRetainedTiles(e, a) {
            var c;
            const p = {}, y = {}, x = Math.max(a - er.maxOverzooming, this._source.minzoom), k = {};
            for (const P of e) {
              const E = this._addTile(P);
              p[P.key] = P, E.hasData() || a < this._source.maxzoom && (k[P.key] = P);
            }
            this._retainLoadedChildren(k, p);
            for (const P of e) {
              let E = this._tiles[P.key];
              if (E.hasData()) continue;
              if (a + 1 > this._source.maxzoom) {
                const j = P.children(this._source.maxzoom)[0], $ = this.getTile(j);
                if ($ && $.hasData()) {
                  p[j.key] = j;
                  continue;
                }
              } else {
                const j = P.children(this._source.maxzoom);
                if (j.length === 4 && p[j[0].key] && p[j[1].key] && p[j[2].key] && p[j[3].key] || j.length === 1 && p[j[0].key]) continue;
              }
              let D = E.wasRequested();
              for (let j = P.overscaledZ - 1; j >= x; --j) {
                const $ = P.scaledTo(j);
                if (y[$.key]) break;
                if (y[$.key] = true, E = this.getTile($), !E && D && (E = this._addTile($)), E) {
                  const U = E.hasData();
                  if ((U || !(!((c = this.map) === null || c === void 0) && c.cancelPendingTileRequestsWhileZooming) || D) && (p[$.key] = $), D = E.wasRequested(), U) break;
                }
              }
            }
            return p;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const e in this._tiles) {
              const a = [];
              let c, p = this._tiles[e].tileID;
              for (; p.overscaledZ > 0; ) {
                if (p.key in this._loadedParentTiles) {
                  c = this._loadedParentTiles[p.key];
                  break;
                }
                a.push(p.key);
                const y = p.scaledTo(p.overscaledZ - 1);
                if (c = this._getLoadedTile(y), c) break;
                p = y;
              }
              for (const y of a) this._loadedParentTiles[y] = c;
            }
          }
          _updateLoadedSiblingTileCache() {
            this._loadedSiblingTiles = {};
            for (const e in this._tiles) {
              const a = this._tiles[e].tileID, c = this._getLoadedTile(a);
              this._loadedSiblingTiles[a.key] = c;
            }
          }
          _addTile(e) {
            let a = this._tiles[e.key];
            if (a) return a;
            a = this._cache.getAndRemove(e), a && (this._setTileReloadTimer(e.key, a), a.tileID = e, this._state.initializeTileState(a, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, a)));
            const c = a;
            return a || (a = new Si(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(a, e.key, a.state)), a.uses++, this._tiles[e.key] = a, c || this._source.fire(new s.l("dataloading", { tile: a, coord: a.tileID, dataType: "source" })), a;
          }
          _setTileReloadTimer(e, a) {
            e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
            const c = a.getExpiryTimeout();
            c && (this._timers[e] = setTimeout((() => {
              this._reloadTile(e, "expired"), delete this._timers[e];
            }), c));
          }
          refreshTiles(e) {
            for (const a in this._tiles) (this._isIdRenderable(a) || this._tiles[a].state == "errored") && e.some(((c) => c.equals(this._tiles[a].tileID.canonical))) && this._reloadTile(a, "expired");
          }
          _removeTile(e) {
            const a = this._tiles[e];
            a && (a.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), a.uses > 0 || (a.hasData() && a.state !== "reloading" ? this._cache.add(a.tileID, a, a.getExpiryTimeout()) : (a.aborted = true, this._abortTile(a), this._unloadTile(a))));
          }
          _dataHandler(e) {
            const a = e.sourceDataType;
            e.dataType === "source" && a === "metadata" && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && e.dataType === "source" && a === "content" && (this.reload(e.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const e in this._tiles) this._removeTile(e);
            this._cache.reset();
          }
          tilesIn(e, a, c) {
            const p = [], y = this.transform;
            if (!y) return p;
            const x = y.getCoveringTilesDetailsProvider().allowWorldCopies(), k = c ? y.getCameraQueryGeometry(e) : e, P = (U) => y.screenPointToMercatorCoordinate(U, this.terrain), E = this.transformBbox(e, P, !x), D = this.transformBbox(k, P, !x), j = this.getIds(), $ = s.a2.fromPoints(D);
            for (let U = 0; U < j.length; U++) {
              const Y = this._tiles[j[U]];
              if (Y.holdingForFade()) continue;
              const se = x ? [Y.tileID] : [Y.tileID.unwrapTo(-1), Y.tileID.unwrapTo(0)], le = Math.pow(2, y.zoom - Y.tileID.overscaledZ), ce = a * Y.queryPadding * s.$ / Y.tileSize / le;
              for (const me of se) {
                const we = $.map(((_e) => me.getTilePoint(new s.a1(_e.x, _e.y))));
                if (we.expandBy(ce), we.intersects($t)) {
                  const _e = E.map(((Me) => me.getTilePoint(Me))), Pe = D.map(((Me) => me.getTilePoint(Me)));
                  p.push({ tile: Y, tileID: x ? me : me.unwrapTo(0), queryGeometry: _e, cameraQueryGeometry: Pe, scale: le });
                }
              }
            }
            return p;
          }
          transformBbox(e, a, c) {
            let p = e.map(a);
            if (c) {
              const y = s.a2.fromPoints(e);
              y.shrinkBy(1e-3 * Math.min(y.width(), y.height()));
              const x = y.map(a);
              s.a2.fromPoints(p).covers(x) || (p = p.map(((k) => k.x > 0.5 ? new s.a1(k.x - 1, k.y, k.z) : k)));
            }
            return p;
          }
          getVisibleCoordinates(e) {
            const a = this.getRenderableIds(e).map(((c) => this._tiles[c].tileID));
            return this.transform && this.transform.populateCache(a), a;
          }
          hasTransition() {
            if (this._source.hasTransition()) return true;
            if (ur(this._source.type)) {
              const e = L.now();
              for (const a in this._tiles) if (this._tiles[a].fadeEndTime >= e) return true;
            }
            return false;
          }
          setFeatureState(e, a, c) {
            this._state.updateState(e = e || "_geojsonTileLayer", a, c);
          }
          removeFeatureState(e, a, c) {
            this._state.removeFeatureState(e = e || "_geojsonTileLayer", a, c);
          }
          getFeatureState(e, a) {
            return this._state.getState(e = e || "_geojsonTileLayer", a);
          }
          setDependencies(e, a, c) {
            const p = this._tiles[e];
            p && p.setDependencies(a, c);
          }
          reloadTilesForDependencies(e, a) {
            for (const c in this._tiles) this._tiles[c].hasDependency(e, a) && this._reloadTile(c, "reloading");
            this._cache.filter(((c) => !c.hasDependency(e, a)));
          }
        }
        function Nt(v, e) {
          const a = Math.abs(2 * v.wrap) - +(v.wrap < 0), c = Math.abs(2 * e.wrap) - +(e.wrap < 0);
          return v.overscaledZ - e.overscaledZ || c - a || e.canonical.y - v.canonical.y || e.canonical.x - v.canonical.x;
        }
        function ur(v) {
          return v === "raster" || v === "image" || v === "video";
        }
        er.maxOverzooming = 10, er.maxUnderzooming = 3;
        class Br {
          constructor(e, a) {
            this.reset(e, a);
          }
          reset(e, a) {
            this.points = e || [], this._distances = [0];
            for (let c = 1; c < this.points.length; c++) this._distances[c] = this._distances[c - 1] + this.points[c].dist(this.points[c - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(a || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(e) {
            if (this.points.length === 1) return this.points[0];
            e = s.ah(e, 0, 1);
            let a = 1, c = this._distances[a];
            const p = e * this.paddedLength + this.padding;
            for (; c < p && a < this._distances.length; ) c = this._distances[++a];
            const y = a - 1, x = this._distances[y], k = c - x, P = k > 0 ? (p - x) / k : 0;
            return this.points[y].mult(1 - P).add(this.points[a].mult(P));
          }
        }
        function Kr(v, e) {
          let a = true;
          return v === "always" || v !== "never" && e !== "never" || (a = false), a;
        }
        class Jr {
          constructor(e, a, c) {
            const p = this.boxCells = [], y = this.circleCells = [];
            this.xCellCount = Math.ceil(e / c), this.yCellCount = Math.ceil(a / c);
            for (let x = 0; x < this.xCellCount * this.yCellCount; x++) p.push([]), y.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = a, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / a, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(e, a, c, p, y) {
            this._forEachCell(a, c, p, y, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(a), this.bboxes.push(c), this.bboxes.push(p), this.bboxes.push(y);
          }
          insertCircle(e, a, c, p) {
            this._forEachCell(a - p, c - p, a + p, c + p, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(a), this.circles.push(c), this.circles.push(p);
          }
          _insertBoxCell(e, a, c, p, y, x) {
            this.boxCells[y].push(x);
          }
          _insertCircleCell(e, a, c, p, y, x) {
            this.circleCells[y].push(x);
          }
          _query(e, a, c, p, y, x, k) {
            if (c < 0 || e > this.width || p < 0 || a > this.height) return [];
            const P = [];
            if (e <= 0 && a <= 0 && this.width <= c && this.height <= p) {
              if (y) return [{ key: null, x1: e, y1: a, x2: c, y2: p }];
              for (let E = 0; E < this.boxKeys.length; E++) P.push({ key: this.boxKeys[E], x1: this.bboxes[4 * E], y1: this.bboxes[4 * E + 1], x2: this.bboxes[4 * E + 2], y2: this.bboxes[4 * E + 3] });
              for (let E = 0; E < this.circleKeys.length; E++) {
                const D = this.circles[3 * E], j = this.circles[3 * E + 1], $ = this.circles[3 * E + 2];
                P.push({ key: this.circleKeys[E], x1: D - $, y1: j - $, x2: D + $, y2: j + $ });
              }
            } else this._forEachCell(e, a, c, p, this._queryCell, P, { hitTest: y, overlapMode: x, seenUids: { box: {}, circle: {} } }, k);
            return P;
          }
          query(e, a, c, p) {
            return this._query(e, a, c, p, false, null);
          }
          hitTest(e, a, c, p, y, x) {
            return this._query(e, a, c, p, true, y, x).length > 0;
          }
          hitTestCircle(e, a, c, p, y) {
            const x = e - c, k = e + c, P = a - c, E = a + c;
            if (k < 0 || x > this.width || E < 0 || P > this.height) return false;
            const D = [];
            return this._forEachCell(x, P, k, E, this._queryCellCircle, D, { hitTest: true, overlapMode: p, circle: { x: e, y: a, radius: c }, seenUids: { box: {}, circle: {} } }, y), D.length > 0;
          }
          _queryCell(e, a, c, p, y, x, k, P) {
            const { seenUids: E, hitTest: D, overlapMode: j } = k, $ = this.boxCells[y];
            if ($ !== null) {
              const Y = this.bboxes;
              for (const se of $) if (!E.box[se]) {
                E.box[se] = true;
                const le = 4 * se, ce = this.boxKeys[se];
                if (e <= Y[le + 2] && a <= Y[le + 3] && c >= Y[le + 0] && p >= Y[le + 1] && (!P || P(ce)) && (!D || !Kr(j, ce.overlapMode)) && (x.push({ key: ce, x1: Y[le], y1: Y[le + 1], x2: Y[le + 2], y2: Y[le + 3] }), D)) return true;
              }
            }
            const U = this.circleCells[y];
            if (U !== null) {
              const Y = this.circles;
              for (const se of U) if (!E.circle[se]) {
                E.circle[se] = true;
                const le = 3 * se, ce = this.circleKeys[se];
                if (this._circleAndRectCollide(Y[le], Y[le + 1], Y[le + 2], e, a, c, p) && (!P || P(ce)) && (!D || !Kr(j, ce.overlapMode))) {
                  const me = Y[le], we = Y[le + 1], _e = Y[le + 2];
                  if (x.push({ key: ce, x1: me - _e, y1: we - _e, x2: me + _e, y2: we + _e }), D) return true;
                }
              }
            }
            return false;
          }
          _queryCellCircle(e, a, c, p, y, x, k, P) {
            const { circle: E, seenUids: D, overlapMode: j } = k, $ = this.boxCells[y];
            if ($ !== null) {
              const Y = this.bboxes;
              for (const se of $) if (!D.box[se]) {
                D.box[se] = true;
                const le = 4 * se, ce = this.boxKeys[se];
                if (this._circleAndRectCollide(E.x, E.y, E.radius, Y[le + 0], Y[le + 1], Y[le + 2], Y[le + 3]) && (!P || P(ce)) && !Kr(j, ce.overlapMode)) return x.push(true), true;
              }
            }
            const U = this.circleCells[y];
            if (U !== null) {
              const Y = this.circles;
              for (const se of U) if (!D.circle[se]) {
                D.circle[se] = true;
                const le = 3 * se, ce = this.circleKeys[se];
                if (this._circlesCollide(Y[le], Y[le + 1], Y[le + 2], E.x, E.y, E.radius) && (!P || P(ce)) && !Kr(j, ce.overlapMode)) return x.push(true), true;
              }
            }
          }
          _forEachCell(e, a, c, p, y, x, k, P) {
            const E = this._convertToXCellCoord(e), D = this._convertToYCellCoord(a), j = this._convertToXCellCoord(c), $ = this._convertToYCellCoord(p);
            for (let U = E; U <= j; U++) for (let Y = D; Y <= $; Y++) if (y.call(this, e, a, c, p, this.xCellCount * Y + U, x, k, P)) return;
          }
          _convertToXCellCoord(e) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
          }
          _convertToYCellCoord(e) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
          }
          _circlesCollide(e, a, c, p, y, x) {
            const k = p - e, P = y - a, E = c + x;
            return E * E > k * k + P * P;
          }
          _circleAndRectCollide(e, a, c, p, y, x, k) {
            const P = (x - p) / 2, E = Math.abs(e - (p + P));
            if (E > P + c) return false;
            const D = (k - y) / 2, j = Math.abs(a - (y + D));
            if (j > D + c) return false;
            if (E <= P || j <= D) return true;
            const $ = E - P, U = j - D;
            return $ * $ + U * U <= c * c;
          }
        }
        function ii(v, e, a) {
          const c = s.L();
          if (!v) {
            const { vecSouth: j, vecEast: $ } = vr(e), U = T();
            U[0] = $[0], U[1] = $[1], U[2] = j[0], U[3] = j[1], p = U, (D = (x = (y = U)[0]) * (E = y[3]) - (P = y[2]) * (k = y[1])) && (p[0] = E * (D = 1 / D), p[1] = -k * D, p[2] = -P * D, p[3] = x * D), c[0] = U[0], c[1] = U[1], c[4] = U[2], c[5] = U[3];
          }
          var p, y, x, k, P, E, D;
          return s.N(c, c, [1 / a, 1 / a, 1]), c;
        }
        function gr(v, e, a, c) {
          if (v) {
            const p = s.L();
            if (!e) {
              const { vecSouth: y, vecEast: x } = vr(a);
              p[0] = x[0], p[1] = x[1], p[4] = y[0], p[5] = y[1];
            }
            return s.N(p, p, [c, c, 1]), p;
          }
          return a.pixelsToClipSpaceMatrix;
        }
        function vr(v) {
          const e = Math.cos(v.rollInRadians), a = Math.sin(v.rollInRadians), c = Math.cos(v.pitchInRadians), p = Math.cos(v.bearingInRadians), y = Math.sin(v.bearingInRadians), x = s.ar();
          x[0] = -p * c * a - y * e, x[1] = -y * c * a + p * e;
          const k = s.as(x);
          k < 1e-9 ? s.at(x) : s.au(x, x, 1 / k);
          const P = s.ar();
          P[0] = p * c * e - y * a, P[1] = y * c * e + p * a;
          const E = s.as(P);
          return E < 1e-9 ? s.at(P) : s.au(P, P, 1 / E), { vecEast: P, vecSouth: x };
        }
        function Wr(v, e, a, c) {
          let p;
          c ? (p = [v, e, c(v, e), 1], s.aw(p, p, a)) : (p = [v, e, 0, 1], vo(p, p, a));
          const y = p[3];
          return { point: new s.P(p[0] / y, p[1] / y), signedDistanceFromCamera: y, isOccluded: false };
        }
        function ge(v, e) {
          return 0.5 + v / e * 0.5;
        }
        function dt(v, e) {
          return v.x >= -e[0] && v.x <= e[0] && v.y >= -e[1] && v.y <= e[1];
        }
        function Bt(v, e, a, c, p, y, x, k, P, E, D, j, $) {
          const U = a ? v.textSizeData : v.iconSizeData, Y = s.an(U, e.transform.zoom), se = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1], le = a ? v.text.dynamicLayoutVertexArray : v.icon.dynamicLayoutVertexArray;
          le.clear();
          const ce = v.lineVertexArray, me = a ? v.text.placedSymbolArray : v.icon.placedSymbolArray, we = e.transform.width / e.transform.height;
          let _e = false;
          for (let Pe = 0; Pe < me.length; Pe++) {
            const Me = me.get(Pe);
            if (Me.hidden || Me.writingMode === s.ao.vertical && !_e) {
              kn(Me.numGlyphs, le);
              continue;
            }
            _e = false;
            const ye = new s.P(Me.anchorX, Me.anchorY), Be = { getElevation: $, pitchedLabelPlaneMatrix: c, lineVertexArray: ce, pitchWithMap: y, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: e.transform, tileAnchorPoint: ye, unwrappedTileID: P, width: E, height: D, translation: j }, Je = tn(Me.anchorX, Me.anchorY, Be);
            if (!dt(Je.point, se)) {
              kn(Me.numGlyphs, le);
              continue;
            }
            const We = ge(e.transform.cameraToCenterDistance, Je.signedDistanceFromCamera), Ze = s.ap(U, Y, Me), Qe = y ? Ze * e.transform.getPitchedTextCorrection(Me.anchorX, Me.anchorY, P) / We : Ze * We, It = gt({ projectionContext: Be, pitchedLabelPlaneMatrixInverse: p, symbol: Me, fontSize: Qe, flip: false, keepUpright: x, glyphOffsetArray: v.glyphOffsetArray, dynamicLayoutVertexArray: le, aspectRatio: we, rotateToLine: k });
            _e = It.useVertical, (It.notEnoughRoom || _e || It.needsFlipping && gt({ projectionContext: Be, pitchedLabelPlaneMatrixInverse: p, symbol: Me, fontSize: Qe, flip: true, keepUpright: x, glyphOffsetArray: v.glyphOffsetArray, dynamicLayoutVertexArray: le, aspectRatio: we, rotateToLine: k }).notEnoughRoom) && kn(Me.numGlyphs, le);
          }
          a ? v.text.dynamicLayoutVertexBuffer.updateData(le) : v.icon.dynamicLayoutVertexBuffer.updateData(le);
        }
        function Er(v, e, a, c, p, y, x, k) {
          const P = y.glyphStartIndex + y.numGlyphs, E = y.lineStartIndex, D = y.lineStartIndex + y.lineLength, j = e.getoffsetX(y.glyphStartIndex), $ = e.getoffsetX(P - 1), U = qn(v * j, a, c, p, y.segment, E, D, k, x);
          if (!U) return null;
          const Y = qn(v * $, a, c, p, y.segment, E, D, k, x);
          return Y ? k.projectionCache.anyProjectionOccluded ? null : { first: U, last: Y } : null;
        }
        function $r(v, e, a, c) {
          return v === s.ao.horizontal && Math.abs(a.y - e.y) > Math.abs(a.x - e.x) * c ? { useVertical: true } : (v === s.ao.vertical ? e.y < a.y : e.x > a.x) ? { needsFlipping: true } : null;
        }
        function gt(v) {
          const { projectionContext: e, pitchedLabelPlaneMatrixInverse: a, symbol: c, fontSize: p, flip: y, keepUpright: x, glyphOffsetArray: k, dynamicLayoutVertexArray: P, aspectRatio: E, rotateToLine: D } = v, j = p / 24, $ = c.lineOffsetX * j, U = c.lineOffsetY * j;
          let Y;
          if (c.numGlyphs > 1) {
            const se = c.glyphStartIndex + c.numGlyphs, le = c.lineStartIndex, ce = c.lineStartIndex + c.lineLength, me = Er(j, k, $, U, y, c, D, e);
            if (!me) return { notEnoughRoom: true };
            const we = fn(me.first.point.x, me.first.point.y, e, a), _e = fn(me.last.point.x, me.last.point.y, e, a);
            if (x && !y) {
              const Pe = $r(c.writingMode, we, _e, E);
              if (Pe) return Pe;
            }
            Y = [me.first];
            for (let Pe = c.glyphStartIndex + 1; Pe < se - 1; Pe++) {
              const Me = qn(j * k.getoffsetX(Pe), $, U, y, c.segment, le, ce, e, D);
              if (!Me) return { notEnoughRoom: true };
              Y.push(Me);
            }
            Y.push(me.last);
          } else {
            if (x && !y) {
              const le = ni(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point, ce = c.lineStartIndex + c.segment + 1, me = new s.P(e.lineVertexArray.getx(ce), e.lineVertexArray.gety(ce)), we = ni(me.x, me.y, e), _e = we.signedDistanceFromCamera > 0 ? we.point : cr(e.tileAnchorPoint, me, le, 1, e), Pe = fn(le.x, le.y, e, a), Me = fn(_e.x, _e.y, e, a), ye = $r(c.writingMode, Pe, Me, E);
              if (ye) return ye;
            }
            const se = qn(j * k.getoffsetX(c.glyphStartIndex), $, U, y, c.segment, c.lineStartIndex, c.lineStartIndex + c.lineLength, e, D);
            if (!se || e.projectionCache.anyProjectionOccluded) return { notEnoughRoom: true };
            Y = [se];
          }
          for (const se of Y) s.av(P, se.point, se.angle);
          return {};
        }
        function cr(v, e, a, c, p) {
          const y = v.add(v.sub(e)._unit()), x = ni(y.x, y.y, p).point, k = a.sub(x);
          return a.add(k._mult(c / k.mag()));
        }
        function lr(v, e, a) {
          const c = e.projectionCache;
          if (c.projections[v]) return c.projections[v];
          const p = new s.P(e.lineVertexArray.getx(v), e.lineVertexArray.gety(v)), y = ni(p.x, p.y, e);
          if (y.signedDistanceFromCamera > 0) return c.projections[v] = y.point, c.anyProjectionOccluded = c.anyProjectionOccluded || y.isOccluded, y.point;
          const x = v - a.direction;
          return cr(a.distanceFromAnchor === 0 ? e.tileAnchorPoint : new s.P(e.lineVertexArray.getx(x), e.lineVertexArray.gety(x)), p, a.previousVertex, a.absOffsetX - a.distanceFromAnchor + 1, e);
        }
        function ni(v, e, a) {
          const c = v + a.translation[0], p = e + a.translation[1];
          let y;
          return a.pitchWithMap ? (y = Wr(c, p, a.pitchedLabelPlaneMatrix, a.getElevation), y.isOccluded = false) : (y = a.transform.projectTileCoordinates(c, p, a.unwrappedTileID, a.getElevation), y.point.x = (0.5 * y.point.x + 0.5) * a.width, y.point.y = (0.5 * -y.point.y + 0.5) * a.height), y;
        }
        function fn(v, e, a, c) {
          if (a.pitchWithMap) {
            const p = [v, e, 0, 1];
            return s.aw(p, p, c), a.transform.projectTileCoordinates(p[0] / p[3], p[1] / p[3], a.unwrappedTileID, a.getElevation).point;
          }
          return { x: v / a.width * 2 - 1, y: 1 - e / a.height * 2 };
        }
        function tn(v, e, a) {
          return a.transform.projectTileCoordinates(v, e, a.unwrappedTileID, a.getElevation);
        }
        function dr(v, e, a) {
          return v._unit()._perp()._mult(e * a);
        }
        function Yo(v, e, a, c, p, y, x, k, P) {
          if (k.projectionCache.offsets[v]) return k.projectionCache.offsets[v];
          const E = a.add(e);
          if (v + P.direction < c || v + P.direction >= p) return k.projectionCache.offsets[v] = E, E;
          const D = lr(v + P.direction, k, P), j = dr(D.sub(a), x, P.direction), $ = a.add(j), U = D.add(j);
          return k.projectionCache.offsets[v] = s.ax(y, E, $, U) || E, k.projectionCache.offsets[v];
        }
        function qn(v, e, a, c, p, y, x, k, P) {
          const E = c ? v - e : v + e;
          let D = E > 0 ? 1 : -1, j = 0;
          c && (D *= -1, j = Math.PI), D < 0 && (j += Math.PI);
          let $, U = D > 0 ? y + p : y + p + 1;
          k.projectionCache.cachedAnchorPoint ? $ = k.projectionCache.cachedAnchorPoint : ($ = ni(k.tileAnchorPoint.x, k.tileAnchorPoint.y, k).point, k.projectionCache.cachedAnchorPoint = $);
          let Y, se, le = $, ce = $, me = 0, we = 0;
          const _e = Math.abs(E), Pe = [];
          let Me;
          for (; me + we <= _e; ) {
            if (U += D, U < y || U >= x) return null;
            me += we, ce = le, se = Y;
            const Je = { absOffsetX: _e, direction: D, distanceFromAnchor: me, previousVertex: ce };
            if (le = lr(U, k, Je), a === 0) Pe.push(ce), Me = le.sub(ce);
            else {
              let We;
              const Ze = le.sub(ce);
              We = Ze.mag() === 0 ? dr(lr(U + D, k, Je).sub(le), a, D) : dr(Ze, a, D), se || (se = ce.add(We)), Y = Yo(U, We, le, y, x, se, a, k, Je), Pe.push(se), Me = Y.sub(se);
            }
            we = Me.mag();
          }
          const ye = Me._mult((_e - me) / we)._add(se || ce), Be = j + Math.atan2(le.y - ce.y, le.x - ce.x);
          return Pe.push(ye), { point: ye, angle: P ? Be : 0, path: Pe };
        }
        const Ko = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function kn(v, e) {
          for (let a = 0; a < v; a++) {
            const c = e.length;
            e.resize(c + 4), e.float32.set(Ko, 3 * c);
          }
        }
        function vo(v, e, a) {
          const c = e[0], p = e[1];
          return v[0] = a[0] * c + a[4] * p + a[12], v[1] = a[1] * c + a[5] * p + a[13], v[3] = a[3] * c + a[7] * p + a[15], v;
        }
        const Zr = 100;
        class Jn {
          constructor(e, a = new Jr(e.width + 200, e.height + 200, 25), c = new Jr(e.width + 200, e.height + 200, 25)) {
            this.transform = e, this.grid = a, this.ignoredGrid = c, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + Zr, this.screenBottomBoundary = e.height + Zr, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(e, a, c, p, y, x, k, P, E, D, j, $) {
            const U = this.projectAndGetPerspectiveRatio(e.anchorPointX + P[0], e.anchorPointY + P[1], y, D, $), Y = c * U.perspectiveRatio;
            let se;
            if (x || k) se = this._projectCollisionBox(e, Y, p, y, x, k, P, U, D, j, $);
            else {
              const Me = U.x + (j ? j.x * Y : 0), ye = U.y + (j ? j.y * Y : 0);
              se = { allPointsOccluded: false, box: [Me + e.x1 * Y, ye + e.y1 * Y, Me + e.x2 * Y, ye + e.y2 * Y] };
            }
            const [le, ce, me, we] = se.box, _e = x ? se.allPointsOccluded : U.isOccluded;
            let Pe = _e;
            return Pe || (Pe = U.perspectiveRatio < this.perspectiveRatioCutoff), Pe || (Pe = !this.isInsideGrid(le, ce, me, we)), Pe || a !== "always" && this.grid.hitTest(le, ce, me, we, a, E) ? { box: [le, ce, me, we], placeable: false, offscreen: false, occluded: _e } : { box: [le, ce, me, we], placeable: true, offscreen: this.isOffscreen(le, ce, me, we), occluded: _e };
          }
          placeCollisionCircles(e, a, c, p, y, x, k, P, E, D, j, $, U, Y) {
            const se = [], le = new s.P(a.anchorX, a.anchorY), ce = this.getPerspectiveRatio(le.x, le.y, x, Y), me = (E ? y * this.transform.getPitchedTextCorrection(a.anchorX, a.anchorY, x) / ce : y * ce) / s.aB, we = { getElevation: Y, pitchedLabelPlaneMatrix: k, lineVertexArray: c, pitchWithMap: E, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: this.transform, tileAnchorPoint: le, unwrappedTileID: x, width: this.transform.width, height: this.transform.height, translation: U }, _e = Er(me, p, a.lineOffsetX * me, a.lineOffsetY * me, false, a, false, we);
            let Pe = false, Me = false, ye = true;
            if (_e) {
              const Be = 0.5 * j * ce + $, Je = new s.P(-100, -100), We = new s.P(this.screenRightBoundary, this.screenBottomBoundary), Ze = new Br(), Qe = _e.first, It = _e.last;
              let Pt = [];
              for (let _r = Qe.path.length - 1; _r >= 1; _r--) Pt.push(Qe.path[_r]);
              for (let _r = 1; _r < It.path.length; _r++) Pt.push(It.path[_r]);
              const pt = 2.5 * Be;
              if (E) {
                const _r = this.projectPathToScreenSpace(Pt, we);
                Pt = _r.some(((Or) => Or.signedDistanceFromCamera <= 0)) ? [] : _r.map(((Or) => Or.point));
              }
              let Vt = [];
              if (Pt.length > 0) {
                const _r = Pt[0].clone(), Or = Pt[0].clone();
                for (let hi = 1; hi < Pt.length; hi++) _r.x = Math.min(_r.x, Pt[hi].x), _r.y = Math.min(_r.y, Pt[hi].y), Or.x = Math.max(Or.x, Pt[hi].x), Or.y = Math.max(Or.y, Pt[hi].y);
                Vt = _r.x >= Je.x && Or.x <= We.x && _r.y >= Je.y && Or.y <= We.y ? [Pt] : Or.x < Je.x || _r.x > We.x || Or.y < Je.y || _r.y > We.y ? [] : s.ay([Pt], Je.x, Je.y, We.x, We.y);
              }
              for (const _r of Vt) {
                Ze.reset(_r, 0.25 * Be);
                let Or = 0;
                Or = Ze.length <= 0.5 * Be ? 1 : Math.ceil(Ze.paddedLength / pt) + 1;
                for (let hi = 0; hi < Or; hi++) {
                  const ei = hi / Math.max(Or - 1, 1), Hr = Ze.lerp(ei), fi = Hr.x + Zr, oi = Hr.y + Zr;
                  se.push(fi, oi, Be, 0);
                  const ti = fi - Be, Ar = oi - Be, Fi = fi + Be, Ei = oi + Be;
                  if (ye = ye && this.isOffscreen(ti, Ar, Fi, Ei), Me = Me || this.isInsideGrid(ti, Ar, Fi, Ei), e !== "always" && this.grid.hitTestCircle(fi, oi, Be, e, D) && (Pe = true, !P)) return { circles: [], offscreen: false, collisionDetected: Pe };
                }
              }
            }
            return { circles: !P && Pe || !Me || ce < this.perspectiveRatioCutoff ? [] : se, offscreen: ye, collisionDetected: Pe };
          }
          projectPathToScreenSpace(e, a) {
            const c = (function(p, y) {
              const x = s.L();
              return s.aq(x, y.pitchedLabelPlaneMatrix), p.map(((k) => {
                const P = Wr(k.x, k.y, x, y.getElevation), E = y.transform.projectTileCoordinates(P.point.x, P.point.y, y.unwrappedTileID, y.getElevation);
                return E.point.x = (0.5 * E.point.x + 0.5) * y.width, E.point.y = (0.5 * -E.point.y + 0.5) * y.height, E;
              }));
            })(e, a);
            return (function(p) {
              let y = 0, x = 0, k = 0, P = 0;
              for (let E = 0; E < p.length; E++) p[E].isOccluded ? (k = E + 1, P = 0) : (P++, P > x && (x = P, y = k));
              return p.slice(y, y + x);
            })(c);
          }
          queryRenderedSymbols(e) {
            if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const a = [], c = new s.a2();
            for (const j of e) {
              const $ = new s.P(j.x + Zr, j.y + Zr);
              c.extend($), a.push($);
            }
            const { minX: p, minY: y, maxX: x, maxY: k } = c, P = this.grid.query(p, y, x, k).concat(this.ignoredGrid.query(p, y, x, k)), E = {}, D = {};
            for (const j of P) {
              const $ = j.key;
              if (E[$.bucketInstanceId] === void 0 && (E[$.bucketInstanceId] = {}), E[$.bucketInstanceId][$.featureIndex]) continue;
              const U = [new s.P(j.x1, j.y1), new s.P(j.x2, j.y1), new s.P(j.x2, j.y2), new s.P(j.x1, j.y2)];
              s.az(a, U) && (E[$.bucketInstanceId][$.featureIndex] = true, D[$.bucketInstanceId] === void 0 && (D[$.bucketInstanceId] = []), D[$.bucketInstanceId].push($.featureIndex));
            }
            return D;
          }
          insertCollisionBox(e, a, c, p, y, x) {
            (c ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: p, featureIndex: y, collisionGroupID: x, overlapMode: a }, e[0], e[1], e[2], e[3]);
          }
          insertCollisionCircles(e, a, c, p, y, x) {
            const k = c ? this.ignoredGrid : this.grid, P = { bucketInstanceId: p, featureIndex: y, collisionGroupID: x, overlapMode: a };
            for (let E = 0; E < e.length; E += 4) k.insertCircle(P, e[E], e[E + 1], e[E + 2]);
          }
          projectAndGetPerspectiveRatio(e, a, c, p, y) {
            if (y) {
              let x;
              p ? (x = [e, a, p(e, a), 1], s.aw(x, x, y)) : (x = [e, a, 0, 1], vo(x, x, y));
              const k = x[3];
              return { x: (x[0] / k + 1) / 2 * this.transform.width + Zr, y: (-x[1] / k + 1) / 2 * this.transform.height + Zr, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / k * 0.5, isOccluded: false, signedDistanceFromCamera: k };
            }
            {
              const x = this.transform.projectTileCoordinates(e, a, c, p);
              return { x: (x.point.x + 1) / 2 * this.transform.width + Zr, y: (1 - x.point.y) / 2 * this.transform.height + Zr, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / x.signedDistanceFromCamera * 0.5, isOccluded: x.isOccluded, signedDistanceFromCamera: x.signedDistanceFromCamera };
            }
          }
          getPerspectiveRatio(e, a, c, p) {
            const y = this.transform.projectTileCoordinates(e, a, c, p);
            return 0.5 + this.transform.cameraToCenterDistance / y.signedDistanceFromCamera * 0.5;
          }
          isOffscreen(e, a, c, p) {
            return c < Zr || e >= this.screenRightBoundary || p < Zr || a > this.screenBottomBoundary;
          }
          isInsideGrid(e, a, c, p) {
            return c >= 0 && e < this.gridRightBoundary && p >= 0 && a < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const e = s.ag([]);
            return s.M(e, e, [-100, -100, 0]), e;
          }
          _projectCollisionBox(e, a, c, p, y, x, k, P, E, D, j) {
            let $ = 1, U = 0, Y = 0, se = 1;
            const le = e.anchorPointX + k[0], ce = e.anchorPointY + k[1];
            if (x && !y) {
              const Pt = this.projectAndGetPerspectiveRatio(le + 1, ce, p, E, j), pt = Pt.x - P.x, Vt = Math.atan((Pt.y - P.y) / pt) + (pt < 0 ? Math.PI : 0), _r = Math.sin(Vt), Or = Math.cos(Vt);
              $ = Or, U = _r, Y = -_r, se = Or;
            } else if (!x && y) {
              const Pt = vr(this.transform);
              $ = Pt.vecEast[0], U = Pt.vecEast[1], Y = Pt.vecSouth[0], se = Pt.vecSouth[1];
            }
            let me = P.x, we = P.y, _e = a;
            y && (me = le, we = ce, _e = Math.pow(2, -(this.transform.zoom - c.overscaledZ)), _e *= this.transform.getPitchedTextCorrection(le, ce, p), D || (_e *= s.ah(0.5 + P.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), D && (me += $ * D.x * _e + Y * D.y * _e, we += U * D.x * _e + se * D.y * _e);
            const Pe = e.x1 * _e, Me = e.x2 * _e, ye = (Pe + Me) / 2, Be = e.y1 * _e, Je = e.y2 * _e, We = (Be + Je) / 2, Ze = [{ offsetX: Pe, offsetY: Be }, { offsetX: ye, offsetY: Be }, { offsetX: Me, offsetY: Be }, { offsetX: Me, offsetY: We }, { offsetX: Me, offsetY: Je }, { offsetX: ye, offsetY: Je }, { offsetX: Pe, offsetY: Je }, { offsetX: Pe, offsetY: We }];
            let Qe = [];
            for (const { offsetX: Pt, offsetY: pt } of Ze) Qe.push(new s.P(me + $ * Pt + Y * pt, we + U * Pt + se * pt));
            let It = false;
            if (y) {
              const Pt = Qe.map(((pt) => this.projectAndGetPerspectiveRatio(pt.x, pt.y, p, E, j)));
              It = Pt.some(((pt) => !pt.isOccluded)), Qe = Pt.map(((pt) => new s.P(pt.x, pt.y)));
            } else It = true;
            return { box: s.aA(Qe), allPointsOccluded: !It };
          }
        }
        class rn {
          constructor(e, a, c, p) {
            this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? a : -a))) : p && c ? 1 : 0, this.placed = c;
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class Ur {
          constructor(e, a, c, p, y) {
            this.text = new rn(e ? e.text : null, a, c, y), this.icon = new rn(e ? e.icon : null, a, p, y);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Rl {
          constructor(e, a, c) {
            this.text = e, this.icon = a, this.skipFade = c;
          }
        }
        class ba {
          constructor(e, a, c, p, y) {
            this.bucketInstanceId = e, this.featureIndex = a, this.sourceLayerIndex = c, this.bucketIndex = p, this.tileID = y;
          }
        }
        class Ps {
          constructor(e) {
            this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(e) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[e]) {
              const a = ++this.maxGroupID;
              this.collisionGroups[e] = { ID: a, predicate: (c) => c.collisionGroupID === a };
            }
            return this.collisionGroups[e];
          }
        }
        function _o(v, e, a, c, p) {
          const { horizontalAlign: y, verticalAlign: x } = s.aH(v);
          return new s.P(-(y - 0.5) * e + c[0] * p, -(x - 0.5) * a + c[1] * p);
        }
        class yo {
          constructor(e, a, c, p, y) {
            this.transform = e.clone(), this.terrain = a, this.collisionIndex = new Jn(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = c, this.retainedQueryData = {}, this.collisionGroups = new Ps(p), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = y, y && (y.prevPlacement = void 0), this.placedOrientations = {};
          }
          _getTerrainElevationFunc(e) {
            const a = this.terrain;
            return a ? (c, p) => a.getElevation(e, c, p) : null;
          }
          getBucketParts(e, a, c, p) {
            const y = c.getBucket(a), x = c.latestFeatureIndex;
            if (!y || !x || a.id !== y.layerIds[0]) return;
            const k = c.collisionBoxArray, P = y.layers[0].layout, E = y.layers[0].paint, D = Math.pow(2, this.transform.zoom - c.tileID.overscaledZ), j = c.tileSize / s.$, $ = c.tileID.toUnwrapped(), U = P.get("text-rotation-alignment") === "map", Y = s.aC(c, 1, this.transform.zoom), se = s.aD(this.collisionIndex.transform, c, E.get("text-translate"), E.get("text-translate-anchor")), le = s.aD(this.collisionIndex.transform, c, E.get("icon-translate"), E.get("icon-translate-anchor")), ce = ii(U, this.transform, Y);
            this.retainedQueryData[y.bucketInstanceId] = new ba(y.bucketInstanceId, x, y.sourceLayerIndex, y.index, c.tileID);
            const me = { bucket: y, layout: P, translationText: se, translationIcon: le, unwrappedTileID: $, pitchedLabelPlaneMatrix: ce, scale: D, textPixelRatio: j, holdingForFade: c.holdingForFade(), collisionBoxArray: k, partiallyEvaluatedTextSize: s.an(y.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(y.sourceID) };
            if (p) for (const we of y.sortKeyRanges) {
              const { sortKey: _e, symbolInstanceStart: Pe, symbolInstanceEnd: Me } = we;
              e.push({ sortKey: _e, symbolInstanceStart: Pe, symbolInstanceEnd: Me, parameters: me });
            }
            else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: y.symbolInstances.length, parameters: me });
          }
          attemptAnchorPlacement(e, a, c, p, y, x, k, P, E, D, j, $, U, Y, se, le, ce, me, we, _e) {
            const Pe = s.aE[e.textAnchor], Me = [e.textOffset0, e.textOffset1], ye = _o(Pe, c, p, Me, y), Be = this.collisionIndex.placeCollisionBox(a, $, P, E, D, k, x, le, j.predicate, we, ye, _e);
            if ((!me || this.collisionIndex.placeCollisionBox(me, $, P, E, D, k, x, ce, j.predicate, we, ye, _e).placeable) && Be.placeable) {
              let Je;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[U.crossTileID] && this.prevPlacement.placements[U.crossTileID] && this.prevPlacement.placements[U.crossTileID].text && (Je = this.prevPlacement.variableOffsets[U.crossTileID].anchor), U.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[U.crossTileID] = { textOffset: Me, width: c, height: p, anchor: Pe, textBoxScale: y, prevAnchor: Je }, this.markUsedJustification(Y, Pe, U, se), Y.allowVerticalPlacement && (this.markUsedOrientation(Y, se, U), this.placedOrientations[U.crossTileID] = se), { shift: ye, placedGlyphBoxes: Be };
            }
          }
          placeLayerBucketPart(e, a, c) {
            const { bucket: p, layout: y, translationText: x, translationIcon: k, unwrappedTileID: P, pitchedLabelPlaneMatrix: E, textPixelRatio: D, holdingForFade: j, collisionBoxArray: $, partiallyEvaluatedTextSize: U, collisionGroup: Y } = e.parameters, se = y.get("text-optional"), le = y.get("icon-optional"), ce = s.aF(y, "text-overlap", "text-allow-overlap"), me = ce === "always", we = s.aF(y, "icon-overlap", "icon-allow-overlap"), _e = we === "always", Pe = y.get("text-rotation-alignment") === "map", Me = y.get("text-pitch-alignment") === "map", ye = y.get("icon-text-fit") !== "none", Be = y.get("symbol-z-order") === "viewport-y", Je = me && (_e || !p.hasIconData() || le), We = _e && (me || !p.hasTextData() || se);
            !p.collisionArrays && $ && p.deserializeCollisionBoxes($);
            const Ze = this.retainedQueryData[p.bucketInstanceId].tileID, Qe = this._getTerrainElevationFunc(Ze), It = this.transform.getFastPathSimpleProjectionMatrix(Ze), Pt = (pt, Vt, _r) => {
              var Or, hi;
              if (a[pt.crossTileID]) return;
              if (j) return void (this.placements[pt.crossTileID] = new Rl(false, false, false));
              let ei = false, Hr = false, fi = true, oi = null, ti = { box: null, placeable: false, offscreen: null, occluded: false }, Ar = { placeable: false }, Fi = null, Ei = null, _n = null, oa = 0, aa = 0, oo = 0;
              Vt.textFeatureIndex ? oa = Vt.textFeatureIndex : pt.useRuntimeCollisionCircles && (oa = pt.featureIndex), Vt.verticalTextFeatureIndex && (aa = Vt.verticalTextFeatureIndex);
              const Na = Vt.textBox;
              if (Na) {
                const yn = (ai) => {
                  let ki = s.ao.horizontal;
                  if (p.allowVerticalPlacement && !ai && this.prevPlacement) {
                    const Bn = this.prevPlacement.placedOrientations[pt.crossTileID];
                    Bn && (this.placedOrientations[pt.crossTileID] = Bn, ki = Bn, this.markUsedOrientation(p, ki, pt));
                  }
                  return ki;
                }, Bo = (ai, ki) => {
                  if (p.allowVerticalPlacement && pt.numVerticalGlyphVertices > 0 && Vt.verticalTextBox) {
                    for (const Bn of p.writingModes) if (Bn === s.ao.vertical ? (ti = ki(), Ar = ti) : ti = ai(), ti && ti.placeable) break;
                  } else ti = ai();
                }, Oo = pt.textAnchorOffsetStartIndex, la = pt.textAnchorOffsetEndIndex;
                if (la === Oo) {
                  const ai = (ki, Bn) => {
                    const Li = this.collisionIndex.placeCollisionBox(ki, ce, D, Ze, P, Me, Pe, x, Y.predicate, Qe, void 0, It);
                    return Li && Li.placeable && (this.markUsedOrientation(p, Bn, pt), this.placedOrientations[pt.crossTileID] = Bn), Li;
                  };
                  Bo((() => ai(Na, s.ao.horizontal)), (() => {
                    const ki = Vt.verticalTextBox;
                    return p.allowVerticalPlacement && pt.numVerticalGlyphVertices > 0 && ki ? ai(ki, s.ao.vertical) : { box: null, offscreen: null };
                  })), yn(ti && ti.placeable);
                } else {
                  let ai = s.aE[(hi = (Or = this.prevPlacement) === null || Or === void 0 ? void 0 : Or.variableOffsets[pt.crossTileID]) === null || hi === void 0 ? void 0 : hi.anchor];
                  const ki = (Li, Vp, od) => {
                    const nl = Li.x2 - Li.x1, ds = Li.y2 - Li.y1, $o = pt.textBoxScale, ao = ye && we === "never" ? Vp : null;
                    let Tn = null, ad = ce === "never" ? 1 : 2, ua = "never";
                    ai && ad++;
                    for (let Jh = 0; Jh < ad; Jh++) {
                      for (let bu = Oo; bu < la; bu++) {
                        const xu = p.textAnchorOffsets.get(bu);
                        if (ai && xu.textAnchor !== ai) continue;
                        const wu = this.attemptAnchorPlacement(xu, Li, nl, ds, $o, Pe, Me, D, Ze, P, Y, ua, pt, p, od, x, k, ao, Qe);
                        if (wu && (Tn = wu.placedGlyphBoxes, Tn && Tn.placeable)) return ei = true, oi = wu.shift, Tn;
                      }
                      ai ? ai = null : ua = ce;
                    }
                    return c && !Tn && (Tn = { box: this.collisionIndex.placeCollisionBox(Na, "always", D, Ze, P, Me, Pe, x, Y.predicate, Qe, void 0, It).box, offscreen: false, placeable: false, occluded: false }), Tn;
                  };
                  Bo((() => ki(Na, Vt.iconBox, s.ao.horizontal)), (() => {
                    const Li = Vt.verticalTextBox;
                    return p.allowVerticalPlacement && (!ti || !ti.placeable) && pt.numVerticalGlyphVertices > 0 && Li ? ki(Li, Vt.verticalIconBox, s.ao.vertical) : { box: null, occluded: true, offscreen: null };
                  })), ti && (ei = ti.placeable, fi = ti.offscreen);
                  const Bn = yn(ti && ti.placeable);
                  if (!ei && this.prevPlacement) {
                    const Li = this.prevPlacement.variableOffsets[pt.crossTileID];
                    Li && (this.variableOffsets[pt.crossTileID] = Li, this.markUsedJustification(p, Li.anchor, pt, Bn));
                  }
                }
              }
              if (Fi = ti, ei = Fi && Fi.placeable, fi = Fi && Fi.offscreen, pt.useRuntimeCollisionCircles) {
                const yn = p.text.placedSymbolArray.get(pt.centerJustifiedTextSymbolIndex), Bo = s.ap(p.textSizeData, U, yn), Oo = y.get("text-padding");
                Ei = this.collisionIndex.placeCollisionCircles(ce, yn, p.lineVertexArray, p.glyphOffsetArray, Bo, P, E, c, Me, Y.predicate, pt.collisionCircleDiameter, Oo, x, Qe), Ei.circles.length && Ei.collisionDetected && !c && s.w("Collisions detected, but collision boxes are not shown"), ei = me || Ei.circles.length > 0 && !Ei.collisionDetected, fi = fi && Ei.offscreen;
              }
              if (Vt.iconFeatureIndex && (oo = Vt.iconFeatureIndex), Vt.iconBox) {
                const yn = (Bo) => this.collisionIndex.placeCollisionBox(Bo, we, D, Ze, P, Me, Pe, k, Y.predicate, Qe, ye && oi ? oi : void 0, It);
                Ar && Ar.placeable && Vt.verticalIconBox ? (_n = yn(Vt.verticalIconBox), Hr = _n.placeable) : (_n = yn(Vt.iconBox), Hr = _n.placeable), fi = fi && _n.offscreen;
              }
              const il = se || pt.numHorizontalGlyphVertices === 0 && pt.numVerticalGlyphVertices === 0, yu = le || pt.numIconVertices === 0;
              il || yu ? yu ? il || (Hr = Hr && ei) : ei = Hr && ei : Hr = ei = Hr && ei;
              const sa = Hr && _n.placeable;
              if (ei && Fi.placeable && this.collisionIndex.insertCollisionBox(Fi.box, ce, y.get("text-ignore-placement"), p.bucketInstanceId, Ar && Ar.placeable && aa ? aa : oa, Y.ID), sa && this.collisionIndex.insertCollisionBox(_n.box, we, y.get("icon-ignore-placement"), p.bucketInstanceId, oo, Y.ID), Ei && ei && this.collisionIndex.insertCollisionCircles(Ei.circles, ce, y.get("text-ignore-placement"), p.bucketInstanceId, oa, Y.ID), c && this.storeCollisionData(p.bucketInstanceId, _r, Vt, Fi, _n, Ei), pt.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              if (p.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[pt.crossTileID] = new Rl((ei || Je) && !(Fi == null ? void 0 : Fi.occluded), (Hr || We) && !(_n == null ? void 0 : _n.occluded), fi || p.justReloaded), a[pt.crossTileID] = true;
            };
            if (Be) {
              if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const pt = p.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let Vt = pt.length - 1; Vt >= 0; --Vt) {
                const _r = pt[Vt];
                Pt(p.symbolInstances.get(_r), p.collisionArrays[_r], _r);
              }
            } else for (let pt = e.symbolInstanceStart; pt < e.symbolInstanceEnd; pt++) Pt(p.symbolInstances.get(pt), p.collisionArrays[pt], pt);
            p.justReloaded = false;
          }
          storeCollisionData(e, a, c, p, y, x) {
            if (c.textBox || c.iconBox) {
              let k, P;
              this.collisionBoxArrays.has(e) ? k = this.collisionBoxArrays.get(e) : (k = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e, k)), k.has(a) ? P = k.get(a) : (P = { text: null, icon: null }, k.set(a, P)), c.textBox && (P.text = p.box), c.iconBox && (P.icon = y.box);
            }
            if (x) {
              let k = this.collisionCircleArrays[e];
              k === void 0 && (k = this.collisionCircleArrays[e] = []);
              for (let P = 0; P < x.circles.length; P += 4) k.push(x.circles[P + 0] - Zr), k.push(x.circles[P + 1] - Zr), k.push(x.circles[P + 2]), k.push(x.collisionDetected ? 1 : 0);
            }
          }
          markUsedJustification(e, a, c, p) {
            let y;
            y = p === s.ao.vertical ? c.verticalPlacedTextSymbolIndex : { left: c.leftJustifiedTextSymbolIndex, center: c.centerJustifiedTextSymbolIndex, right: c.rightJustifiedTextSymbolIndex }[s.aG(a)];
            const x = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex, c.verticalPlacedTextSymbolIndex];
            for (const k of x) k >= 0 && (e.text.placedSymbolArray.get(k).crossTileID = y >= 0 && k !== y ? 0 : c.crossTileID);
          }
          markUsedOrientation(e, a, c) {
            const p = a === s.ao.horizontal || a === s.ao.horizontalOnly ? a : 0, y = a === s.ao.vertical ? a : 0, x = [c.leftJustifiedTextSymbolIndex, c.centerJustifiedTextSymbolIndex, c.rightJustifiedTextSymbolIndex];
            for (const k of x) e.text.placedSymbolArray.get(k).placedOrientation = p;
            c.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(c.verticalPlacedTextSymbolIndex).placedOrientation = y);
          }
          commit(e) {
            this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const a = this.prevPlacement;
            let c = false;
            this.prevZoomAdjustment = a ? a.zoomAdjustment(this.transform.zoom) : 0;
            const p = a ? a.symbolFadeChange(e) : 1, y = a ? a.opacities : {}, x = a ? a.variableOffsets : {}, k = a ? a.placedOrientations : {};
            for (const P in this.placements) {
              const E = this.placements[P], D = y[P];
              D ? (this.opacities[P] = new Ur(D, p, E.text, E.icon), c = c || E.text !== D.text.placed || E.icon !== D.icon.placed) : (this.opacities[P] = new Ur(null, p, E.text, E.icon, E.skipFade), c = c || E.text || E.icon);
            }
            for (const P in y) {
              const E = y[P];
              if (!this.opacities[P]) {
                const D = new Ur(E, p, false, false);
                D.isHidden() || (this.opacities[P] = D, c = c || E.text.placed || E.icon.placed);
              }
            }
            for (const P in x) this.variableOffsets[P] || !this.opacities[P] || this.opacities[P].isHidden() || (this.variableOffsets[P] = x[P]);
            for (const P in k) this.placedOrientations[P] || !this.opacities[P] || this.opacities[P].isHidden() || (this.placedOrientations[P] = k[P]);
            if (a && a.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            c ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = a ? a.lastPlacementChangeTime : e);
          }
          updateLayerOpacities(e, a) {
            const c = {};
            for (const p of a) {
              const y = p.getBucket(e);
              y && p.latestFeatureIndex && e.id === y.layerIds[0] && this.updateBucketOpacities(y, p.tileID, c, p.collisionBoxArray);
            }
          }
          updateBucketOpacities(e, a, c, p) {
            e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = false), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = false), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
            const y = e.layers[0], x = y.layout, k = new Ur(null, 0, false, false, true), P = x.get("text-allow-overlap"), E = x.get("icon-allow-overlap"), D = y._unevaluatedLayout.hasValue("text-variable-anchor") || y._unevaluatedLayout.hasValue("text-variable-anchor-offset"), j = x.get("text-rotation-alignment") === "map", $ = x.get("text-pitch-alignment") === "map", U = x.get("icon-text-fit") !== "none", Y = new Ur(null, 0, P && (E || !e.hasIconData() || x.get("icon-optional")), E && (P || !e.hasTextData() || x.get("text-optional")), true);
            !e.collisionArrays && p && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(p);
            const se = (ce, me, we) => {
              for (let _e = 0; _e < me / 4; _e++) ce.opacityVertexArray.emplaceBack(we);
              ce.hasVisibleVertices = ce.hasVisibleVertices || we !== Qo;
            }, le = this.collisionBoxArrays.get(e.bucketInstanceId);
            for (let ce = 0; ce < e.symbolInstances.length; ce++) {
              const me = e.symbolInstances.get(ce), { numHorizontalGlyphVertices: we, numVerticalGlyphVertices: _e, crossTileID: Pe } = me;
              let Me = this.opacities[Pe];
              c[Pe] ? Me = k : Me || (Me = Y, this.opacities[Pe] = Me), c[Pe] = true;
              const ye = me.numIconVertices > 0, Be = this.placedOrientations[me.crossTileID], Je = Be === s.ao.vertical, We = Be === s.ao.horizontal || Be === s.ao.horizontalOnly;
              if (we > 0 || _e > 0) {
                const Qe = Is(Me.text);
                se(e.text, we, Je ? Qo : Qe), se(e.text, _e, We ? Qo : Qe);
                const It = Me.text.isHidden();
                [me.rightJustifiedTextSymbolIndex, me.centerJustifiedTextSymbolIndex, me.leftJustifiedTextSymbolIndex].forEach(((Vt) => {
                  Vt >= 0 && (e.text.placedSymbolArray.get(Vt).hidden = It || Je ? 1 : 0);
                })), me.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(me.verticalPlacedTextSymbolIndex).hidden = It || We ? 1 : 0);
                const Pt = this.variableOffsets[me.crossTileID];
                Pt && this.markUsedJustification(e, Pt.anchor, me, Be);
                const pt = this.placedOrientations[me.crossTileID];
                pt && (this.markUsedJustification(e, "left", me, pt), this.markUsedOrientation(e, pt, me));
              }
              if (ye) {
                const Qe = Is(Me.icon), It = !(U && me.verticalPlacedIconSymbolIndex && Je);
                me.placedIconSymbolIndex >= 0 && (se(e.icon, me.numIconVertices, It ? Qe : Qo), e.icon.placedSymbolArray.get(me.placedIconSymbolIndex).hidden = Me.icon.isHidden()), me.verticalPlacedIconSymbolIndex >= 0 && (se(e.icon, me.numVerticalIconVertices, It ? Qo : Qe), e.icon.placedSymbolArray.get(me.verticalPlacedIconSymbolIndex).hidden = Me.icon.isHidden());
              }
              const Ze = le && le.has(ce) ? le.get(ce) : { text: null, icon: null };
              if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                const Qe = e.collisionArrays[ce];
                if (Qe) {
                  let It = new s.P(0, 0);
                  if (Qe.textBox || Qe.verticalTextBox) {
                    let Pt = true;
                    if (D) {
                      const pt = this.variableOffsets[Pe];
                      pt ? (It = _o(pt.anchor, pt.width, pt.height, pt.textOffset, pt.textBoxScale), j && It._rotate($ ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : Pt = false;
                    }
                    if (Qe.textBox || Qe.verticalTextBox) {
                      let pt;
                      Qe.textBox && (pt = Je), Qe.verticalTextBox && (pt = We), Ts(e.textCollisionBox.collisionVertexArray, Me.text.placed, !Pt || pt, Ze.text, It.x, It.y);
                    }
                  }
                  if (Qe.iconBox || Qe.verticalIconBox) {
                    const Pt = !!(!We && Qe.verticalIconBox);
                    let pt;
                    Qe.iconBox && (pt = Pt), Qe.verticalIconBox && (pt = !Pt), Ts(e.iconCollisionBox.collisionVertexArray, Me.icon.placed, pt, Ze.icon, U ? It.x : 0, U ? It.y : 0);
                  }
                }
              }
            }
            if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
            if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
            e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId]);
          }
          symbolFadeChange(e) {
            return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(e) {
            return Math.max(0, (this.transform.zoom - e) / 1.5);
          }
          hasTransitions(e) {
            return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(e, a) {
            const c = this.zoomAtLastRecencyCheck === a ? 1 - this.zoomAdjustment(a) : 1;
            return this.zoomAtLastRecencyCheck = a, this.commitTime + this.fadeDuration * c > e;
          }
          setStale() {
            this.stale = true;
          }
        }
        function Ts(v, e, a, c, p, y) {
          c && c.length !== 0 || (c = [0, 0, 0, 0]);
          const x = c[0] - Zr, k = c[1] - Zr, P = c[2] - Zr, E = c[3] - Zr;
          v.emplaceBack(e ? 1 : 0, a ? 1 : 0, p || 0, y || 0, x, k), v.emplaceBack(e ? 1 : 0, a ? 1 : 0, p || 0, y || 0, P, k), v.emplaceBack(e ? 1 : 0, a ? 1 : 0, p || 0, y || 0, P, E), v.emplaceBack(e ? 1 : 0, a ? 1 : 0, p || 0, y || 0, x, E);
        }
        const Al = Math.pow(2, 25), Dl = Math.pow(2, 24), Jo = Math.pow(2, 17), zl = Math.pow(2, 16), dc = Math.pow(2, 9), hc = Math.pow(2, 8), fc = Math.pow(2, 1);
        function Is(v) {
          if (v.opacity === 0 && !v.placed) return 0;
          if (v.opacity === 1 && v.placed) return 4294967295;
          const e = v.placed ? 1 : 0, a = Math.floor(127 * v.opacity);
          return a * Al + e * Dl + a * Jo + e * zl + a * dc + e * hc + a * fc + e;
        }
        const Qo = 0;
        class Ms {
          constructor(e) {
            this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(e, a, c, p, y) {
            const x = this._bucketParts;
            for (; this._currentTileIndex < e.length; ) if (a.getBucketParts(x, p, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, y()) return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, x.sort(((k, P) => k.sortKey - P.sortKey))); this._currentPartIndex < x.length; ) if (a.placeLayerBucketPart(x[this._currentPartIndex], this._seenCrossTileIDs, c), this._currentPartIndex++, y()) return true;
            return false;
          }
        }
        class Es {
          constructor(e, a, c, p, y, x, k, P) {
            this.placement = new yo(e, a, x, k, P), this._currentPlacementIndex = c.length - 1, this._forceFullPlacement = p, this._showCollisionBoxes = y, this._done = false;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(e, a, c) {
            const p = L.now(), y = () => !this._forceFullPlacement && L.now() - p > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const x = a[e[this._currentPlacementIndex]], k = this.placement.collisionIndex.transform.zoom;
              if (x.type === "symbol" && (!x.minzoom || x.minzoom <= k) && (!x.maxzoom || x.maxzoom > k)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Ms(x)), this._inProgressLayer.continuePlacement(c[x.source], this.placement, this._showCollisionBoxes, x, y)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }
          commit(e) {
            return this.placement.commit(e), this.placement;
          }
        }
        const ea = 512 / s.$ / 2;
        class Rs {
          constructor(e, a, c) {
            this.tileID = e, this.bucketInstanceId = c, this._symbolsByKey = {};
            const p = /* @__PURE__ */ new Map();
            for (let y = 0; y < a.length; y++) {
              const x = a.get(y), k = x.key, P = p.get(k);
              P ? P.push(x) : p.set(k, [x]);
            }
            for (const [y, x] of p) {
              const k = { positions: x.map(((P) => ({ x: Math.floor(P.anchorX * ea), y: Math.floor(P.anchorY * ea) }))), crossTileIDs: x.map(((P) => P.crossTileID)) };
              if (k.positions.length > 128) {
                const P = new s.aI(k.positions.length, 16, Uint16Array);
                for (const { x: E, y: D } of k.positions) P.add(E, D);
                P.finish(), delete k.positions, k.index = P;
              }
              this._symbolsByKey[y] = k;
            }
          }
          getScaledCoordinates(e, a) {
            const { x: c, y: p, z: y } = this.tileID.canonical, { x, y: k, z: P } = a.canonical, E = ea / Math.pow(2, P - y), D = (k * s.$ + e.anchorY) * E, j = p * s.$ * ea;
            return { x: Math.floor((x * s.$ + e.anchorX) * E - c * s.$ * ea), y: Math.floor(D - j) };
          }
          findMatches(e, a, c) {
            const p = this.tileID.canonical.z < a.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - a.canonical.z);
            for (let y = 0; y < e.length; y++) {
              const x = e.get(y);
              if (x.crossTileID) continue;
              const k = this._symbolsByKey[x.key];
              if (!k) continue;
              const P = this.getScaledCoordinates(x, a);
              if (k.index) {
                const E = k.index.range(P.x - p, P.y - p, P.x + p, P.y + p).sort();
                for (const D of E) {
                  const j = k.crossTileIDs[D];
                  if (!c[j]) {
                    c[j] = true, x.crossTileID = j;
                    break;
                  }
                }
              } else if (k.positions) for (let E = 0; E < k.positions.length; E++) {
                const D = k.positions[E], j = k.crossTileIDs[E];
                if (Math.abs(D.x - P.x) <= p && Math.abs(D.y - P.y) <= p && !c[j]) {
                  c[j] = true, x.crossTileID = j;
                  break;
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((({ crossTileIDs: e }) => e));
          }
        }
        class As {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class pc {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(e) {
            const a = Math.round((e - this.lng) / 360);
            if (a !== 0) for (const c in this.indexes) {
              const p = this.indexes[c], y = {};
              for (const x in p) {
                const k = p[x];
                k.tileID = k.tileID.unwrapTo(k.tileID.wrap + a), y[k.tileID.key] = k;
              }
              this.indexes[c] = y;
            }
            this.lng = e;
          }
          addBucket(e, a, c) {
            if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
              if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === a.bucketInstanceId) return false;
              this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
            }
            for (let y = 0; y < a.symbolInstances.length; y++) a.symbolInstances.get(y).crossTileID = 0;
            this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
            const p = this.usedCrossTileIDs[e.overscaledZ];
            for (const y in this.indexes) {
              const x = this.indexes[y];
              if (Number(y) > e.overscaledZ) for (const k in x) {
                const P = x[k];
                P.tileID.isChildOf(e) && P.findMatches(a.symbolInstances, e, p);
              }
              else {
                const k = x[e.scaledTo(Number(y)).key];
                k && k.findMatches(a.symbolInstances, e, p);
              }
            }
            for (let y = 0; y < a.symbolInstances.length; y++) {
              const x = a.symbolInstances.get(y);
              x.crossTileID || (x.crossTileID = c.generate(), p[x.crossTileID] = true);
            }
            return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Rs(e, a.symbolInstances, a.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(e, a) {
            for (const c of a.getCrossTileIDsLists()) for (const p of c) delete this.usedCrossTileIDs[e][p];
          }
          removeStaleBuckets(e) {
            let a = false;
            for (const c in this.indexes) {
              const p = this.indexes[c];
              for (const y in p) e[p[y].bucketInstanceId] || (this.removeBucketCrossTileIDs(c, p[y]), delete p[y], a = true);
            }
            return a;
          }
        }
        class ta {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new As(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(e, a, c) {
            let p = this.layerIndexes[e.id];
            p === void 0 && (p = this.layerIndexes[e.id] = new pc());
            let y = false;
            const x = {};
            p.handleWrapJump(c);
            for (const k of a) {
              const P = k.getBucket(e);
              P && e.id === P.layerIds[0] && (P.bucketInstanceId || (P.bucketInstanceId = ++this.maxBucketInstanceId), p.addBucket(k.tileID, P, this.crossTileIDs) && (y = true), x[P.bucketInstanceId] = true);
            }
            return p.removeStaleBuckets(x) && (y = true), y;
          }
          pruneUnusedLayers(e) {
            const a = {};
            e.forEach(((c) => {
              a[c] = true;
            }));
            for (const c in this.layerIndexes) a[c] || delete this.layerIndexes[c];
          }
        }
        var xa = "void main() {fragColor=vec4(1.0);}";
        const Dn = { prelude: yr(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: yr("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: yr("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: yr(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: yr(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: yr(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: yr(xa, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: yr(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: yr(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: yr("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: yr("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), colorRelief: yr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else
{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), debug: yr("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: yr(xa, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: yr(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: yr(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: yr(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: yr(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: yr(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: yr(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: yr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: yr(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];
#define PI 3.141592653589793
#define STANDARD 0
#define COMBINED 1
#define IGOR 2
#define MULTIDIRECTIONAL 3
#define BASIC 4
float get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else
{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else
{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: yr(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: yr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: yr(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: yr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: yr(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: yr(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: yr(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: yr(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: yr("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: yr("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: yr("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: yr("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: yr(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: yr("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
        function yr(v, e) {
          const a = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, c = e.match(/in ([\w]+) ([\w]+)/g), p = v.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), y = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), x = y ? y.concat(p) : p, k = {};
          return { fragmentSource: v = v.replace(a, ((P, E, D, j, $) => (k[$] = true, E === "define" ? `
#ifndef HAS_UNIFORM_u_${$}
in ${D} ${j} ${$};
#else
uniform ${D} ${j} u_${$};
#endif
` : `
#ifdef HAS_UNIFORM_u_${$}
    ${D} ${j} ${$} = u_${$};
#endif
`))), vertexSource: e = e.replace(a, ((P, E, D, j, $) => {
            const U = j === "float" ? "vec2" : "vec4", Y = $.match(/color/) ? "color" : U;
            return k[$] ? E === "define" ? `
#ifndef HAS_UNIFORM_u_${$}
uniform lowp float u_${$}_t;
in ${D} ${U} a_${$};
out ${D} ${j} ${$};
#else
uniform ${D} ${j} u_${$};
#endif
` : Y === "vec4" ? `
#ifndef HAS_UNIFORM_u_${$}
    ${$} = a_${$};
#else
    ${D} ${j} ${$} = u_${$};
#endif
` : `
#ifndef HAS_UNIFORM_u_${$}
    ${$} = unpack_mix_${Y}(a_${$}, u_${$}_t);
#else
    ${D} ${j} ${$} = u_${$};
#endif
` : E === "define" ? `
#ifndef HAS_UNIFORM_u_${$}
uniform lowp float u_${$}_t;
in ${D} ${U} a_${$};
#else
uniform ${D} ${j} u_${$};
#endif
` : Y === "vec4" ? `
#ifndef HAS_UNIFORM_u_${$}
    ${D} ${j} ${$} = a_${$};
#else
    ${D} ${j} ${$} = u_${$};
#endif
` : `
#ifndef HAS_UNIFORM_u_${$}
    ${D} ${j} ${$} = unpack_mix_${Y}(a_${$}, u_${$}_t);
#else
    ${D} ${j} ${$} = u_${$};
#endif
`;
          })), staticAttributes: c, staticUniforms: x };
        }
        class Ao {
          constructor(e, a, c) {
            this.vertexBuffer = e, this.indexBuffer = a, this.segments = c;
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
          }
        }
        var bo = s.aJ([{ name: "a_pos", type: "Int16", components: 2 }]);
        const Qn = "#define PROJECTION_MERCATOR", Do = "mercator";
        class br {
          constructor() {
            this._cachedMesh = null;
          }
          get name() {
            return "mercator";
          }
          get useSubdivision() {
            return false;
          }
          get shaderVariantName() {
            return Do;
          }
          get shaderDefine() {
            return Qn;
          }
          get shaderPreludeCode() {
            return Dn.projectionMercator;
          }
          get vertexShaderPreludeCode() {
            return Dn.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return s.aK.noSubdivision;
          }
          get useGlobeControls() {
            return false;
          }
          get transitionState() {
            return 0;
          }
          get latitudeErrorCorrectionRadians() {
            return 0;
          }
          destroy() {
          }
          updateGPUdependent(e) {
          }
          getMeshFromTileID(e, a, c, p, y) {
            if (this._cachedMesh) return this._cachedMesh;
            const x = new s.aL();
            x.emplaceBack(0, 0), x.emplaceBack(s.$, 0), x.emplaceBack(0, s.$), x.emplaceBack(s.$, s.$);
            const k = e.createVertexBuffer(x, bo.members), P = s.aM.simpleSegment(0, 0, 4, 2), E = new s.aN();
            E.emplaceBack(1, 0, 2), E.emplaceBack(1, 2, 3);
            const D = e.createIndexBuffer(E);
            return this._cachedMesh = new Ao(k, D, P), this._cachedMesh;
          }
          recalculate() {
          }
          hasTransition() {
            return false;
          }
          setErrorQueryLatitudeDegrees(e) {
          }
        }
        class wa {
          constructor(e = 0, a = 0, c = 0, p = 0) {
            if (isNaN(e) || e < 0 || isNaN(a) || a < 0 || isNaN(c) || c < 0 || isNaN(p) || p < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e, this.bottom = a, this.left = c, this.right = p;
          }
          interpolate(e, a, c) {
            return a.top != null && e.top != null && (this.top = s.C.number(e.top, a.top, c)), a.bottom != null && e.bottom != null && (this.bottom = s.C.number(e.bottom, a.bottom, c)), a.left != null && e.left != null && (this.left = s.C.number(e.left, a.left, c)), a.right != null && e.right != null && (this.right = s.C.number(e.right, a.right, c)), this;
          }
          getCenter(e, a) {
            const c = s.ah((this.left + e - this.right) / 2, 0, e), p = s.ah((this.top + a - this.bottom) / 2, 0, a);
            return new s.P(c, p);
          }
          equals(e) {
            return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
          }
          clone() {
            return new wa(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function Fl(v, e) {
          if (!v.renderWorldCopies || v.lngRange) return;
          const a = e.lng - v.center.lng;
          e.lng += a > 180 ? -360 : a < -180 ? 360 : 0;
        }
        function Ll(v) {
          return Math.max(0, Math.floor(v));
        }
        class pn {
          constructor(e, a, c, p, y, x) {
            this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = x === void 0 || !!x, this._minZoom = a || 0, this._maxZoom = c || 22, this._minPitch = p ?? 0, this._maxPitch = y ?? 60, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new s.S(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Ll(this._zoom), this._scale = s.af(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = true, this._edgeInsets = new wa(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = true;
          }
          apply(e, a, c) {
            this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = Ll(this._zoom), this._scale = s.af(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new wa(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !c && e.autoCalculateNearFarZ, a && this._constrain(), this._calcMatrices();
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix;
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile;
          }
          setMinElevationForCurrentTile(e) {
            this._minElevationForCurrentTile = e;
          }
          get tileSize() {
            return this._tileSize;
          }
          get tileZoom() {
            return this._tileZoom;
          }
          get scale() {
            return this._scale;
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get bearingInRadians() {
            return this._bearingInRadians;
          }
          get lngRange() {
            return this._lngRange;
          }
          get latRange() {
            return this._latRange;
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits;
          }
          get minZoom() {
            return this._minZoom;
          }
          setMinZoom(e) {
            this._minZoom !== e && (this._minZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          setMaxZoom(e) {
            this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get minPitch() {
            return this._minPitch;
          }
          setMinPitch(e) {
            this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          setMaxPitch(e) {
            this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          setRenderWorldCopies(e) {
            e === void 0 ? e = true : e === null && (e = false), this._renderWorldCopies = e;
          }
          get worldSize() {
            return this._tileSize * this._scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new s.P(this._width, this._height);
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180;
          }
          setBearing(e) {
            const a = s.aO(e, -180, 180) * Math.PI / 180;
            var c, p, y, x, k, P, E, D, j;
            this._bearingInRadians !== a && (this._unmodified = false, this._bearingInRadians = a, this._calcMatrices(), this._rotationMatrix = T(), c = this._rotationMatrix, y = -this._bearingInRadians, x = (p = this._rotationMatrix)[0], k = p[1], P = p[2], E = p[3], D = Math.sin(y), j = Math.cos(y), c[0] = x * j + P * D, c[1] = k * j + E * D, c[2] = x * -D + P * j, c[3] = k * -D + E * j);
          }
          get rotationMatrix() {
            return this._rotationMatrix;
          }
          get pitchInRadians() {
            return this._pitchInRadians;
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180;
          }
          setPitch(e) {
            const a = s.ah(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== a && (this._unmodified = false, this._pitchInRadians = a, this._calcMatrices());
          }
          get rollInRadians() {
            return this._rollInRadians;
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180;
          }
          setRoll(e) {
            const a = e / 180 * Math.PI;
            this._rollInRadians !== a && (this._unmodified = false, this._rollInRadians = a, this._calcMatrices());
          }
          get fovInRadians() {
            return this._fovInRadians;
          }
          get fov() {
            return s.aP(this._fovInRadians);
          }
          setFov(e) {
            e = s.ah(e, 0.1, 150), this.fov !== e && (this._unmodified = false, this._fovInRadians = s.ae(e), this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          setZoom(e) {
            const a = this.getConstrained(this._center, e).zoom;
            this._zoom !== a && (this._unmodified = false, this._zoom = a, this._tileZoom = Math.max(0, Math.floor(a)), this._scale = s.af(a), this._constrain(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          setCenter(e) {
            e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = false, this._center = e, this._constrain(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          setElevation(e) {
            e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          setPadding(e) {
            this._edgeInsets.equals(e) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height);
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter;
          }
          get unmodified() {
            return this._unmodified;
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance;
          }
          get nearZ() {
            return this._nearZ;
          }
          get farZ() {
            return this._farZ;
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ;
          }
          overrideNearFarZ(e, a) {
            this._autoCalculateNearFarZ = false, this._nearZ = e, this._farZ = a, this._calcMatrices();
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = true, this._calcMatrices();
          }
          isPaddingEqual(e) {
            return this._edgeInsets.equals(e);
          }
          interpolatePadding(e, a, c) {
            this._unmodified = false, this._edgeInsets.interpolate(e, a, c), this._constrain(), this._calcMatrices();
          }
          resize(e, a, c = true) {
            this._width = e, this._height = a, c && this._constrain(), this._calcMatrices();
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new sr([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
          }
          setMaxBounds(e) {
            e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-s.ai, s.ai]);
          }
          getConstrained(e, a) {
            return this._callbacks.getConstrained(e, a);
          }
          getCameraQueryGeometry(e, a) {
            if (a.length === 1) return [a[0], e];
            {
              const { minX: c, minY: p, maxX: y, maxY: x } = s.a2.fromPoints(a).extend(e);
              return [new s.P(c, p), new s.P(y, p), new s.P(y, x), new s.P(c, x), new s.P(c, p)];
            }
          }
          _constrain() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = true;
            const e = this._unmodified, { center: a, zoom: c } = this.getConstrained(this.center, this.zoom);
            this.setCenter(a), this.setZoom(c), this._unmodified = e, this._constraining = false;
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e = s.ag(new Float64Array(16));
              s.N(e, e, [this._width / 2, -this._height / 2, 1]), s.M(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = s.ag(new Float64Array(16)), s.N(e, e, [1, -1, 1]), s.M(e, e, [-1, -1, 0]), s.N(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
            }
            this._callbacks.calcMatrices();
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, p) {
            const y = c !== void 0 ? c : this.bearing, x = p = p !== void 0 ? p : this.pitch, k = s.a1.fromLngLat(e, a), P = -Math.cos(s.ae(x)), E = Math.sin(s.ae(x)), D = E * Math.sin(s.ae(y)), j = -E * Math.cos(s.ae(y));
            let $ = this.elevation;
            const U = a - $;
            let Y;
            P * U >= 0 || Math.abs(P) < 0.1 ? (Y = 1e4, $ = a + Y * P) : Y = -U / P;
            let se, le, ce = s.aQ(1, k.y), me = 0;
            do {
              if (me += 1, me > 10) break;
              le = Y / ce, se = new s.a1(k.x + D * le, k.y + j * le), ce = 1 / se.meterInMercatorCoordinateUnits();
            } while (Math.abs(Y - le * ce) > 1e-12);
            return { center: se.toLngLat(), elevation: $, zoom: s.ak(this.height / 2 / Math.tan(this.fovInRadians / 2) / le / this.tileSize) };
          }
          recalculateZoomAndCenter(e) {
            if (this.elevation - e == 0) return;
            const a = s.aj(1, this.center.lat) * this.worldSize, c = this.cameraToCenterDistance / a, p = s.a1.fromLngLat(this.center, this.elevation), y = de(this.center, this.elevation, this.pitch, this.bearing, c);
            this._elevation = e;
            const x = this.calculateCenterFromCameraLngLatAlt(y.toLngLat(), s.aQ(y.z, p.y), this.bearing, this.pitch);
            this._elevation = x.elevation, this._center = x.center, this.setZoom(x.zoom);
          }
          getCameraPoint() {
            const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new s.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)));
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
          }
          getCameraLngLat() {
            const e = s.aj(1, this.center.lat) * this.worldSize;
            return de(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat();
          }
          getMercatorTileCoordinates(e) {
            if (!e) return [0, 0, 1, 1];
            const a = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
            return [e.canonical.x / a, e.canonical.y / a, 1 / a / s.$, 1 / a / s.$];
          }
        }
        class ji {
          constructor(e, a) {
            this.min = e, this.max = a, this.center = s.aR([], s.aS([], this.min, this.max), 0.5);
          }
          quadrant(e) {
            const a = [e % 2 == 0, e < 2], c = s.aT(this.min), p = s.aT(this.max);
            for (let y = 0; y < a.length; y++) c[y] = a[y] ? this.min[y] : this.center[y], p[y] = a[y] ? this.center[y] : this.max[y];
            return p[2] = this.max[2], new ji(c, p);
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
          }
          intersectsFrustum(e) {
            let a = true;
            for (let c = 0; c < e.planes.length; c++) {
              const p = this.intersectsPlane(e.planes[c]);
              if (p === 0) return 0;
              p === 1 && (a = false);
            }
            return a ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1;
          }
          intersectsPlane(e) {
            let a = e[3], c = e[3];
            for (let p = 0; p < 3; p++) e[p] > 0 ? (a += e[p] * this.min[p], c += e[p] * this.max[p]) : (c += e[p] * this.min[p], a += e[p] * this.max[p]);
            return a >= 0 ? 2 : c < 0 ? 0 : 1;
          }
        }
        class mn {
          distanceToTile2d(e, a, c, p) {
            const y = p.distanceX([e, a]), x = p.distanceY([e, a]);
            return Math.hypot(y, x);
          }
          getWrap(e, a, c) {
            return c;
          }
          getTileBoundingVolume(e, a, c, p) {
            var y, x;
            let k = 0, P = 0;
            if (p == null ? void 0 : p.terrain) {
              const D = new s.Z(e.z, a, e.z, e.x, e.y), j = p.terrain.getMinMaxElevation(D);
              k = (y = j.minElevation) !== null && y !== void 0 ? y : Math.min(0, c), P = (x = j.maxElevation) !== null && x !== void 0 ? x : Math.max(0, c);
            }
            const E = 1 << e.z;
            return new ji([a + e.x / E, e.y / E, k], [a + (e.x + 1) / E, (e.y + 1) / E, P]);
          }
          allowVariableZoom(e, a) {
            const c = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height, p = s.ah(78.5 - c / 2, 0, 60);
            return !!a.terrain || e.pitch > p;
          }
          allowWorldCopies() {
            return true;
          }
          prepareNextFrame() {
          }
        }
        class Mi {
          constructor(e, a, c) {
            this.points = e, this.planes = a, this.aabb = c;
          }
          static fromInvProjectionMatrix(e, a = 1, c = 0, p, y) {
            const x = y ? [[6, 5, 4], [0, 1, 2], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]] : [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]], k = Math.pow(2, c), P = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((($) => (function(U, Y, se, le) {
              const ce = s.aw([], U, Y), me = 1 / ce[3] / se * le;
              return s.aY(ce, ce, [me, me, 1 / ce[3], me]);
            })($, e, a, k)));
            p && (function($, U, Y, se) {
              const le = se ? 4 : 0, ce = se ? 0 : 4;
              let me = 0;
              const we = [], _e = [];
              for (let ye = 0; ye < 4; ye++) {
                const Be = s.aU([], $[ye + ce], $[ye + le]), Je = s.aZ(Be);
                s.aR(Be, Be, 1 / Je), we.push(Je), _e.push(Be);
              }
              for (let ye = 0; ye < 4; ye++) {
                const Be = s.a_($[ye + le], _e[ye], Y);
                me = Be !== null && Be >= 0 ? Math.max(me, Be) : Math.max(me, we[ye]);
              }
              const Pe = (function(ye, Be) {
                const Je = s.aU([], ye[Be[0]], ye[Be[1]]), We = s.aU([], ye[Be[2]], ye[Be[1]]), Ze = [0, 0, 0, 0];
                return s.aV(Ze, s.aW([], Je, We)), Ze[3] = -s.aX(Ze, ye[Be[0]]), Ze;
              })($, U), Me = (function(ye, Be) {
                const Je = s.a$(ye), We = s.b0([], ye, 1 / Je), Ze = s.aU([], Be, s.aR([], We, s.aX(Be, We))), Qe = s.a$(Ze);
                if (Qe > 0) {
                  const It = Math.sqrt(1 - We[3] * We[3]), Pt = s.aR([], We, -We[3]), pt = s.aS([], Pt, s.aR([], Ze, It / Qe));
                  return s.b1(Be, pt);
                }
                return null;
              })(Y, Pe);
              if (Me !== null) {
                const ye = Me / s.aX(_e[0], Pe);
                me = Math.min(me, ye);
              }
              for (let ye = 0; ye < 4; ye++) {
                const Be = Math.min(me, we[ye]);
                $[ye + ce] = [$[ye + le][0] + _e[ye][0] * Be, $[ye + le][1] + _e[ye][1] * Be, $[ye + le][2] + _e[ye][2] * Be, 1];
              }
            })(P, x[0], p, y);
            const E = x.map((($) => {
              const U = s.aU([], P[$[0]], P[$[1]]), Y = s.aU([], P[$[2]], P[$[1]]), se = s.aV([], s.aW([], U, Y)), le = -s.aX(se, P[$[1]]);
              return se.concat(le);
            })), D = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], j = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const $ of P) for (let U = 0; U < 3; U++) D[U] = Math.min(D[U], $[U]), j[U] = Math.max(j[U], $[U]);
            return new Mi(P, E, new ji(D, j));
          }
        }
        class Qr {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, a, c) {
            return this._helper.interpolatePadding(e, a, c);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, a, c = true) {
            this._helper.resize(e, a, c);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e, a) {
          }
          constructor(e, a, c, p, y) {
            this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this._helper = new pn({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (x, k) => this.getConstrained(x, k) }, e, a, c, p, y), this._coveringTilesDetailsProvider = new mn();
          }
          clone() {
            const e = new Qr();
            return e.apply(this), e;
          }
          apply(e, a, c) {
            this._helper.apply(e, a, c);
          }
          get cameraPosition() {
            return this._cameraPosition;
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix;
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix;
          }
          get mercatorMatrix() {
            return this._mercatorMatrix;
          }
          getVisibleUnwrappedCoordinates(e) {
            const a = [new s.b2(0, e)];
            if (this._helper._renderWorldCopies) {
              const c = this.screenPointToMercatorCoordinate(new s.P(0, 0)), p = this.screenPointToMercatorCoordinate(new s.P(this._helper._width, 0)), y = this.screenPointToMercatorCoordinate(new s.P(this._helper._width, this._helper._height)), x = this.screenPointToMercatorCoordinate(new s.P(0, this._helper._height)), k = Math.floor(Math.min(c.x, p.x, y.x, x.x)), P = Math.floor(Math.max(c.x, p.x, y.x, x.x)), E = 1;
              for (let D = k - E; D <= P + E; D++) D !== 0 && a.push(new s.b2(D, e));
            }
            return a;
          }
          getCameraFrustum() {
            return Mi.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
          }
          getClippingPlane() {
            return null;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e) {
            const a = this.screenPointToLocation(this.centerPoint, e), c = e ? e.getElevationForLngLatZoom(a, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(c);
          }
          setLocationAtPoint(e, a) {
            const c = s.aj(this.elevation, this.center.lat), p = this.screenPointToMercatorCoordinateAtZ(a, c), y = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, c), x = s.a1.fromLngLat(e), k = new s.a1(x.x - (p.x - y.x), x.y - (p.y - y.y));
            this.setCenter(k == null ? void 0 : k.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
          }
          locationToScreenPoint(e, a) {
            return a ? this.coordinatePoint(s.a1.fromLngLat(e), a.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(s.a1.fromLngLat(e));
          }
          screenPointToLocation(e, a) {
            var c;
            return (c = this.screenPointToMercatorCoordinate(e, a)) === null || c === void 0 ? void 0 : c.toLngLat();
          }
          screenPointToMercatorCoordinate(e, a) {
            if (a) {
              const c = a.pointCoordinate(e);
              if (c != null) return c;
            }
            return this.screenPointToMercatorCoordinateAtZ(e);
          }
          screenPointToMercatorCoordinateAtZ(e, a) {
            const c = a || 0, p = [e.x, e.y, 0, 1], y = [e.x, e.y, 1, 1];
            s.aw(p, p, this._pixelMatrixInverse), s.aw(y, y, this._pixelMatrixInverse);
            const x = p[3], k = y[3], P = p[1] / x, E = y[1] / k, D = p[2] / x, j = y[2] / k, $ = D === j ? 0 : (c - D) / (j - D);
            return new s.a1(s.C.number(p[0] / x, y[0] / k, $) / this.worldSize, s.C.number(P, E, $) / this.worldSize, c);
          }
          coordinatePoint(e, a = 0, c = this._pixelMatrix) {
            const p = [e.x * this.worldSize, e.y * this.worldSize, a, 1];
            return s.aw(p, p, c), new s.P(p[0] / p[3], p[1] / p[3]);
          }
          getBounds() {
            const e = Math.max(0, this._helper._height / 2 - ke(this));
            return new sr().extend(this.screenPointToLocation(new s.P(0, e))).extend(this.screenPointToLocation(new s.P(this._helper._width, e))).extend(this.screenPointToLocation(new s.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new s.P(0, this._helper._height)));
          }
          isPointOnMapSurface(e, a) {
            return a ? a.pointCoordinate(e) != null : e.y > this.height / 2 - ke(this);
          }
          calculatePosMatrix(e, a = false, c) {
            var p;
            const y = (p = e.key) !== null && p !== void 0 ? p : s.b3(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y), x = a ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (x.has(y)) {
              const E = x.get(y);
              return c ? E.f32 : E.f64;
            }
            const k = De(e, this.worldSize);
            s.O(k, a ? this._alignedProjMatrix : this._viewProjMatrix, k);
            const P = { f64: k, f32: new Float32Array(k) };
            return x.set(y, P), c ? P.f32 : P.f64;
          }
          calculateFogMatrix(e) {
            const a = e.key, c = this._fogMatrixCacheF32;
            if (c.has(a)) return c.get(a);
            const p = De(e, this.worldSize);
            return s.O(p, this._fogMatrix, p), c.set(a, new Float32Array(p)), c.get(a);
          }
          getConstrained(e, a) {
            a = s.ah(+a, this.minZoom, this.maxZoom);
            const c = { center: new s.S(e.lng, e.lat), zoom: a };
            let p = this._helper._lngRange;
            if (!this._helper._renderWorldCopies && p === null) {
              const we = 179.9999999999;
              p = [-we, we];
            }
            const y = this.tileSize * s.af(c.zoom);
            let x = 0, k = y, P = 0, E = y, D = 0, j = 0;
            const { x: $, y: U } = this.size;
            if (this._helper._latRange) {
              const we = this._helper._latRange;
              x = s.U(we[1]) * y, k = s.U(we[0]) * y, k - x < U && (D = U / (k - x));
            }
            p && (P = s.aO(s.V(p[0]) * y, 0, y), E = s.aO(s.V(p[1]) * y, 0, y), E < P && (E += y), E - P < $ && (j = $ / (E - P)));
            const { x: Y, y: se } = ne(y, e);
            let le, ce;
            const me = Math.max(j || 0, D || 0);
            if (me) {
              const we = new s.P(j ? (E + P) / 2 : Y, D ? (k + x) / 2 : se);
              return c.center = xe(y, we).wrap(), c.zoom += s.ak(me), c;
            }
            if (this._helper._latRange) {
              const we = U / 2;
              se - we < x && (ce = x + we), se + we > k && (ce = k - we);
            }
            if (p) {
              const we = (P + E) / 2;
              let _e = Y;
              this._helper._renderWorldCopies && (_e = s.aO(Y, we - y / 2, we + y / 2));
              const Pe = $ / 2;
              _e - Pe < P && (le = P + Pe), _e + Pe > E && (le = E - Pe);
            }
            if (le !== void 0 || ce !== void 0) {
              const we = new s.P(le ?? Y, ce ?? se);
              c.center = xe(y, we).wrap();
            }
            return c;
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, p) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, c, p);
          }
          _calculateNearFarZIfNeeded(e, a, c) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const p = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), y = e - p * this._helper._pixelPerMeter / Math.cos(a), x = p < 0 ? y : e, k = Math.PI / 2 + this.pitchInRadians, P = s.ae(this.fov) * (Math.abs(Math.cos(s.ae(this.roll))) * this.height + Math.abs(Math.sin(s.ae(this.roll))) * this.width) / this.height * (0.5 + c.y / this.height), E = Math.sin(P) * x / Math.sin(s.ah(Math.PI - k - P, 0.01, Math.PI - 0.01)), D = ke(this), j = Math.atan(D / this._helper.cameraToCenterDistance), $ = s.ae(0.75), U = j > $ ? 2 * j * (0.5 + c.y / (2 * D)) : $, Y = Math.sin(U) * x / Math.sin(s.ah(Math.PI - k - U, 0.01, Math.PI - 0.01)), se = Math.min(E, Y);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - a) * se + x), this._helper._nearZ = this._helper._height / 50;
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e = this.centerOffset, a = ne(this.worldSize, this.center), c = a.x, p = a.y;
            this._helper._pixelPerMeter = s.aj(1, this.center.lat) * this.worldSize;
            const y = s.ae(Math.min(this.pitch, H)), x = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(y));
            let k;
            this._calculateNearFarZIfNeeded(x, y, e), k = new Float64Array(16), s.b4(k, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), s.aq(this._invProjMatrix, k), k[8] = 2 * -e.x / this._helper._width, k[9] = 2 * e.y / this._helper._height, this._projectionMatrix = s.b5(k), s.N(k, k, [1, -1, 1]), s.M(k, k, [0, 0, -this._helper.cameraToCenterDistance]), s.b6(k, k, -this.rollInRadians), s.b7(k, k, this.pitchInRadians), s.b6(k, k, -this.bearingInRadians), s.M(k, k, [-c, -p, 0]), this._mercatorMatrix = s.N([], k, [this.worldSize, this.worldSize, this.worldSize]), s.N(k, k, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = s.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, k), s.M(k, k, [0, 0, -this.elevation]), this._viewProjMatrix = k, this._invViewProjMatrix = s.aq([], k);
            const P = [0, 0, -1, 1];
            s.aw(P, P, this._invViewProjMatrix), this._cameraPosition = [P[0] / P[3], P[1] / P[3], P[2] / P[3]], this._fogMatrix = new Float64Array(16), s.b4(this._fogMatrix, this.fovInRadians, this.width / this.height, x, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, s.N(this._fogMatrix, this._fogMatrix, [1, -1, 1]), s.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), s.b6(this._fogMatrix, this._fogMatrix, -this.rollInRadians), s.b7(this._fogMatrix, this._fogMatrix, this.pitchInRadians), s.b6(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), s.M(this._fogMatrix, this._fogMatrix, [-c, -p, 0]), s.N(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), s.M(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = s.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, k);
            const E = this._helper._width % 2 / 2, D = this._helper._height % 2 / 2, j = Math.cos(this.bearingInRadians), $ = Math.sin(-this.bearingInRadians), U = c - Math.round(c) + j * E + $ * D, Y = p - Math.round(p) + j * D + $ * E, se = new Float64Array(k);
            if (s.M(se, se, [U > 0.5 ? U - 1 : U, Y > 0.5 ? Y - 1 : Y, 0]), this._alignedProjMatrix = se, k = s.aq(new Float64Array(16), this._pixelMatrix), !k) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = k, this._clearMatrixCaches();
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e = this.screenPointToMercatorCoordinate(new s.P(0, 0)), a = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
            return s.aw(a, a, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            const e = s.aj(1, this.center.lat) * this.worldSize;
            return de(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat();
          }
          lngLatToCameraDepth(e, a) {
            const c = s.a1.fromLngLat(e), p = [c.x * this.worldSize, c.y * this.worldSize, a, 1];
            return s.aw(p, p, this._viewProjMatrix), p[2] / p[3];
          }
          getProjectionData(e) {
            const { overscaledTileID: a, aligned: c, applyTerrainMatrix: p } = e, y = this._helper.getMercatorTileCoordinates(a), x = a ? this.calculatePosMatrix(a, c, true) : null;
            let k;
            return k = a && a.terrainRttPosMatrix32f && p ? a.terrainRttPosMatrix32f : x || s.b8(), { mainMatrix: k, tileMercatorCoords: y, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: k };
          }
          isLocationOccluded(e) {
            return false;
          }
          getPixelScale() {
            return 1;
          }
          getCircleRadiusCorrection() {
            return 1;
          }
          getPitchedTextCorrection(e, a, c) {
            return 1;
          }
          transformLightDirection(e) {
            return s.aT(e);
          }
          getRayDirectionFromPixel(e) {
            throw new Error("Not implemented.");
          }
          projectTileCoordinates(e, a, c, p) {
            const y = this.calculatePosMatrix(c);
            let x;
            p ? (x = [e, a, p(e, a), 1], s.aw(x, x, y)) : (x = [e, a, 0, 1], vo(x, x, y));
            const k = x[3];
            return { point: new s.P(x[0] / k, x[1] / k), signedDistanceFromCamera: k, isOccluded: false };
          }
          populateCache(e) {
            for (const a of e) this.calculatePosMatrix(a);
          }
          getMatrixForModel(e, a) {
            const c = s.a1.fromLngLat(e, a), p = c.meterInMercatorCoordinateUnits(), y = s.b9();
            return s.M(y, y, [c.x, c.y, c.z]), s.b6(y, y, Math.PI), s.b7(y, y, Math.PI / 2), s.N(y, y, [-p, p, p]), y;
          }
          getProjectionDataForCustomLayer(e = true) {
            const a = new s.Z(0, 0, 0, 0, 0), c = this.getProjectionData({ overscaledTileID: a, applyGlobeMatrix: e }), p = De(a, this.worldSize);
            s.O(p, this._viewProjMatrix, p), c.tileMercatorCoords = [0, 0, 1, 1];
            const y = [s.$, s.$, this.worldSize / this._helper.pixelsPerMeter], x = s.ba();
            return s.N(x, p, y), c.fallbackMatrix = x, c.mainMatrix = x, c;
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.calculatePosMatrix(e);
          }
        }
        function ch() {
          s.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }
        function gn(v) {
          if (v.useSlerp) if (v.k < 1) {
            const e = s.bb(v.startEulerAngles.roll, v.startEulerAngles.pitch, v.startEulerAngles.bearing), a = s.bb(v.endEulerAngles.roll, v.endEulerAngles.pitch, v.endEulerAngles.bearing), c = new Float64Array(4);
            s.bc(c, e, a, v.k);
            const p = s.bd(c);
            v.tr.setRoll(p.roll), v.tr.setPitch(p.pitch), v.tr.setBearing(p.bearing);
          } else v.tr.setRoll(v.endEulerAngles.roll), v.tr.setPitch(v.endEulerAngles.pitch), v.tr.setBearing(v.endEulerAngles.bearing);
          else v.tr.setRoll(s.C.number(v.startEulerAngles.roll, v.endEulerAngles.roll, v.k)), v.tr.setPitch(s.C.number(v.startEulerAngles.pitch, v.endEulerAngles.pitch, v.k)), v.tr.setBearing(s.C.number(v.startEulerAngles.bearing, v.endEulerAngles.bearing, v.k));
        }
        function zn(v, e, a, c, p) {
          const y = p.padding, x = ne(p.worldSize, a.getNorthWest()), k = ne(p.worldSize, a.getNorthEast()), P = ne(p.worldSize, a.getSouthEast()), E = ne(p.worldSize, a.getSouthWest()), D = s.ae(-c), j = x.rotate(D), $ = k.rotate(D), U = P.rotate(D), Y = E.rotate(D), se = new s.P(Math.max(j.x, $.x, Y.x, U.x), Math.max(j.y, $.y, Y.y, U.y)), le = new s.P(Math.min(j.x, $.x, Y.x, U.x), Math.min(j.y, $.y, Y.y, U.y)), ce = se.sub(le), me = (p.width - (y.left + y.right + e.left + e.right)) / ce.x, we = (p.height - (y.top + y.bottom + e.top + e.bottom)) / ce.y;
          if (we < 0 || me < 0) return void ch();
          const _e = Math.min(s.ak(p.scale * Math.min(me, we)), v.maxZoom), Pe = s.P.convert(v.offset), Me = new s.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(s.ae(c)), ye = Pe.add(Me).mult(p.scale / s.af(_e));
          return { center: xe(p.worldSize, x.add(P).div(2).sub(ye)), zoom: _e, bearing: c };
        }
        class nn {
          get useGlobeControls() {
            return false;
          }
          handlePanInertia(e, a) {
            const c = e.mag(), p = Math.abs(ke(a));
            return { easingOffset: e.mult(Math.min(0.75 * p / c, 1)), easingCenter: a.center };
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            e.bearingDelta && a.setBearing(a.bearing + e.bearingDelta), e.pitchDelta && a.setPitch(a.pitch + e.pitchDelta), e.rollDelta && a.setRoll(a.roll + e.rollDelta), e.zoomDelta && a.setZoom(a.zoom + e.zoomDelta);
          }
          handleMapControlsPan(e, a, c) {
            e.around.distSqr(a.centerPoint) < 0.01 || a.setLocationAtPoint(c, e.around);
          }
          cameraForBoxAndBearing(e, a, c, p, y) {
            return zn(e, a, c, p, y);
          }
          handleJumpToCenterZoom(e, a) {
            e.zoom !== (a.zoom !== void 0 ? +a.zoom : e.zoom) && e.setZoom(+a.zoom), a.center !== void 0 && e.setCenter(s.S.convert(a.center));
          }
          handleEaseTo(e, a) {
            const c = e.zoom, p = e.padding, y = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, x = { roll: a.roll === void 0 ? e.roll : a.roll, pitch: a.pitch === void 0 ? e.pitch : a.pitch, bearing: a.bearing === void 0 ? e.bearing : a.bearing }, k = a.zoom !== void 0, P = !e.isPaddingEqual(a.padding);
            let E = false;
            const D = k ? +a.zoom : e.zoom;
            let j = e.centerPoint.add(a.offsetAsPoint);
            const $ = e.screenPointToLocation(j), { center: U, zoom: Y } = e.getConstrained(s.S.convert(a.center || $), D ?? c);
            Fl(e, U);
            const se = ne(e.worldSize, $), le = ne(e.worldSize, U).sub(se), ce = s.af(Y - c);
            return E = Y !== c, { easeFunc: (me) => {
              if (E && e.setZoom(s.C.number(c, Y, me)), s.be(y, x) || gn({ startEulerAngles: y, endEulerAngles: x, tr: e, k: me, useSlerp: y.roll != x.roll }), P && (e.interpolatePadding(p, a.padding, me), j = e.centerPoint.add(a.offsetAsPoint)), a.around) e.setLocationAtPoint(a.around, a.aroundPoint);
              else {
                const we = s.af(e.zoom - c), _e = Y > c ? Math.min(2, ce) : Math.max(0.5, ce), Pe = Math.pow(_e, 1 - me), Me = xe(e.worldSize, se.add(le.mult(me * Pe)).mult(we));
                e.setLocationAtPoint(e.renderWorldCopies ? Me.wrap() : Me, j);
              }
            }, isZooming: E, elevationCenter: U };
          }
          handleFlyTo(e, a) {
            const c = a.zoom !== void 0, p = e.zoom, y = e.getConstrained(s.S.convert(a.center || a.locationAtOffset), c ? +a.zoom : p), x = y.center, k = y.zoom;
            Fl(e, x);
            const P = ne(e.worldSize, a.locationAtOffset), E = ne(e.worldSize, x).sub(P), D = E.mag(), j = s.af(k - p);
            let $;
            if (a.minZoom !== void 0) {
              const U = Math.min(+a.minZoom, p, k), Y = e.getConstrained(x, U).zoom;
              $ = s.af(Y - p);
            }
            return { easeFunc: (U, Y, se, le) => {
              e.setZoom(U === 1 ? k : p + s.ak(Y));
              const ce = U === 1 ? x : xe(e.worldSize, P.add(E.mult(se)).mult(Y));
              e.setLocationAtPoint(e.renderWorldCopies ? ce.wrap() : ce, le);
            }, scaleOfZoom: j, targetCenter: x, scaleOfMinZoom: $, pixelPathLength: D };
          }
        }
        class li {
          constructor(e, a, c) {
            this.blendFunction = e, this.blendColor = a, this.mask = c;
          }
        }
        li.Replace = [1, 0], li.disabled = new li(li.Replace, s.bf.transparent, [false, false, false, false]), li.unblended = new li(li.Replace, s.bf.transparent, [true, true, true, true]), li.alphaBlended = new li([1, 771], s.bf.transparent, [true, true, true, true]);
        const Ca = 2305;
        class nr {
          constructor(e, a, c) {
            this.enable = e, this.mode = a, this.frontFace = c;
          }
        }
        nr.disabled = new nr(false, 1029, Ca), nr.backCCW = new nr(true, 1029, Ca), nr.frontCCW = new nr(true, 1028, Ca);
        class mr {
          constructor(e, a, c) {
            this.func = e, this.mask = a, this.range = c;
          }
        }
        mr.ReadOnly = false, mr.ReadWrite = true, mr.disabled = new mr(519, mr.ReadOnly, [0, 1]);
        const zo = 7680;
        class Rr {
          constructor(e, a, c, p, y, x) {
            this.test = e, this.ref = a, this.mask = c, this.fail = p, this.depthFail = y, this.pass = x;
          }
        }
        Rr.disabled = new Rr({ func: 519, mask: 0 }, 0, 0, zo, zo, zo);
        const Fn = /* @__PURE__ */ new WeakMap();
        function xo(v) {
          var e;
          if (Fn.has(v)) return Fn.get(v);
          {
            const a = (e = v.getParameter(v.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
            return Fn.set(v, a), a;
          }
        }
        class wo {
          get awaitingQuery() {
            return !!this._readbackQueue;
          }
          constructor(e) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
            const a = e.context, c = a.gl;
            this._texFormat = c.RGBA, this._texType = c.UNSIGNED_BYTE;
            const p = new s.aL();
            p.emplaceBack(-1, -1), p.emplaceBack(2, -1), p.emplaceBack(-1, 2);
            const y = new s.aN();
            y.emplaceBack(0, 1, 2), this._fullscreenTriangle = new Ao(a.createVertexBuffer(p, bo.members), a.createIndexBuffer(y), s.aM.simpleSegment(0, 0, p.length, y.length)), this._resultBuffer = new Uint8Array(4), a.activeTexture.set(c.TEXTURE1);
            const x = c.createTexture();
            c.bindTexture(c.TEXTURE_2D, x), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.NEAREST), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.NEAREST), c.texImage2D(c.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = a.createFramebuffer(this._texWidth, this._texHeight, false, false), this._fbo.colorAttachment.set(x), xo(c) && (this._pbo = c.createBuffer(), c.bindBuffer(c.PIXEL_PACK_BUFFER, this._pbo), c.bufferData(c.PIXEL_PACK_BUFFER, 4, c.STREAM_READ), c.bindBuffer(c.PIXEL_PACK_BUFFER, null));
          }
          destroy() {
            const e = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
          }
          updateErrorLoop(e, a) {
            const c = this._updateCount;
            return this._readbackQueue ? c >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : c >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, a), this._updateCount++, this._measuredError;
          }
          _bindFramebuffer() {
            const e = this._cachedRenderContext.context, a = e.gl;
            e.activeTexture.set(a.TEXTURE1), a.bindTexture(a.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer);
          }
          _renderErrorTexture(e, a) {
            const c = this._cachedRenderContext.context, p = c.gl;
            if (this._bindFramebuffer(), c.viewport.set([0, 0, this._texWidth, this._texHeight]), c.clear({ color: s.bf.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(c, p.TRIANGLES, mr.disabled, Rr.disabled, li.unblended, nr.disabled, /* @__PURE__ */ ((y, x) => ({ u_input: y, u_output_expected: x }))(e, a), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && xo(p)) {
              p.bindBuffer(p.PIXEL_PACK_BUFFER, this._pbo), p.readBuffer(p.COLOR_ATTACHMENT0), p.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), p.bindBuffer(p.PIXEL_PACK_BUFFER, null);
              const y = p.fenceSync(p.SYNC_GPU_COMMANDS_COMPLETE, 0);
              p.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: y };
            } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
          }
          _tryReadback() {
            const e = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && xo(e)) {
              const a = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (a === e.WAIT_FAILED) return s.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
              if (a === e.TIMEOUT_EXPIRED) return;
              e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null);
            } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = wo._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
          }
          static _parseRGBA8float(e) {
            let a = 0;
            return a += e[0] / 256, a += e[1] / 65536, a += e[2] / 16777216, e[3] < 127 && (a = -a), a / 128;
          }
        }
        const Bl = s.$ / 128;
        function mc(v, e) {
          const a = v.granularity !== void 0 ? Math.max(v.granularity, 1) : 1, c = a + (v.generateBorders ? 2 : 0), p = a + (v.extendToNorthPole || v.generateBorders ? 1 : 0) + (v.extendToSouthPole || v.generateBorders ? 1 : 0), y = c + 1, x = p + 1, k = v.generateBorders ? -1 : 0, P = v.generateBorders || v.extendToNorthPole ? -1 : 0, E = a + (v.generateBorders ? 1 : 0), D = a + (v.generateBorders || v.extendToSouthPole ? 1 : 0), j = y * x, $ = c * p * 6, U = y * x > 65536;
          if (U && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const Y = U || e === "32bit", se = new Int16Array(2 * j);
          let le = 0;
          for (let we = P; we <= D; we++) for (let _e = k; _e <= E; _e++) {
            let Pe = _e / a * s.$;
            _e === -1 && (Pe = -Bl), _e === a + 1 && (Pe = s.$ + Bl);
            let Me = we / a * s.$;
            we === -1 && (Me = v.extendToNorthPole ? s.bh : -Bl), we === a + 1 && (Me = v.extendToSouthPole ? s.bi : s.$ + Bl), se[le++] = Pe, se[le++] = Me;
          }
          const ce = Y ? new Uint32Array($) : new Uint16Array($);
          let me = 0;
          for (let we = 0; we < p; we++) for (let _e = 0; _e < c; _e++) {
            const Pe = _e + 1 + we * y, Me = _e + (we + 1) * y, ye = _e + 1 + (we + 1) * y;
            ce[me++] = _e + we * y, ce[me++] = Me, ce[me++] = Pe, ce[me++] = Pe, ce[me++] = Me, ce[me++] = ye;
          }
          return { vertices: se.buffer.slice(0), indices: ce.buffer.slice(0), uses32bitIndices: Y };
        }
        const es = new s.aK({ fill: new s.bj(128, 2), line: new s.bj(512, 0), tile: new s.bj(128, 32), stencil: new s.bj(128, 1), circle: 3 });
        class Ds {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
          }
          get name() {
            return "vertical-perspective";
          }
          get transitionState() {
            return 1;
          }
          get useSubdivision() {
            return true;
          }
          get shaderVariantName() {
            return "globe";
          }
          get shaderDefine() {
            return "#define GLOBE";
          }
          get shaderPreludeCode() {
            return Dn.projectionGlobe;
          }
          get vertexShaderPreludeCode() {
            return Dn.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return es;
          }
          get useGlobeControls() {
            return true;
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable;
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy();
          }
          updateGPUdependent(e) {
            this._errorMeasurement || (this._errorMeasurement = new wo(e));
            const a = s.U(this._errorQueryLatitudeDegrees), c = 2 * Math.atan(Math.exp(Math.PI - a * Math.PI * 2)) - 0.5 * Math.PI, p = this._errorMeasurement.updateErrorLoop(a, c), y = L.now();
            p !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = p, this._errorMeasurementLastChangeTime = y);
            const x = Math.min(Math.max((y - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
            this._errorCorrectionUsable = s.bk(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, s.bl(x));
          }
          _getMeshKey(e) {
            return `${e.granularity.toString(36)}_${e.generateBorders ? "b" : ""}${e.extendToNorthPole ? "n" : ""}${e.extendToSouthPole ? "s" : ""}`;
          }
          getMeshFromTileID(e, a, c, p, y) {
            const x = (y === "stencil" ? es.stencil : es.tile).getGranularityForZoomLevel(a.z);
            return this._getMesh(e, { granularity: x, generateBorders: c, extendToNorthPole: a.y === 0 && p, extendToSouthPole: a.y === (1 << a.z) - 1 && p });
          }
          _getMesh(e, a) {
            const c = this._getMeshKey(a);
            if (c in this._tileMeshCache) return this._tileMeshCache[c];
            const p = (function(y, x) {
              const k = mc(x, "16bit"), P = s.aL.deserialize({ arrayBuffer: k.vertices, length: k.vertices.byteLength / 2 / 2 }), E = s.aN.deserialize({ arrayBuffer: k.indices, length: k.indices.byteLength / 2 / 3 });
              return new Ao(y.createVertexBuffer(P, bo.members), y.createIndexBuffer(E), s.aM.simpleSegment(0, 0, P.length, E.length));
            })(e, a);
            return this._tileMeshCache[c] = p, p;
          }
          recalculate(e) {
          }
          hasTransition() {
            const e = L.now();
            let a = false;
            return a = a || (e - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, a = a || this._errorMeasurement && this._errorMeasurement.awaitingQuery, a;
          }
          setErrorQueryLatitudeDegrees(e) {
            this._errorQueryLatitudeDegrees = e;
          }
        }
        const Ol = new s.r({ type: new s.D(s.v.projection.type) });
        class $l extends s.E {
          constructor(e) {
            super(), this._transitionable = new s.t(Ol, void 0), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new s.F(0)), this._mercatorProjection = new br(), this._verticalPerspectiveProjection = new Ds();
          }
          get transitionState() {
            const e = this.properties.get("type");
            if (typeof e == "string" && e === "mercator") return 0;
            if (typeof e == "string" && e === "vertical-perspective") return 1;
            if (e instanceof s.bm) {
              if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
              if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition;
            }
            return 1;
          }
          get useGlobeRendering() {
            return this.transitionState > 0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
          }
          get name() {
            return "globe";
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision;
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName;
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine;
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode;
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode;
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity;
          }
          get useGlobeControls() {
            return this.transitionState > 0;
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
          }
          updateGPUdependent(e) {
            this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e);
          }
          getMeshFromTileID(e, a, c, p, y) {
            return this.currentProjection.getMeshFromTileID(e, a, c, p, y);
          }
          setProjection(e) {
            this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator");
          }
          updateTransitions(e) {
            this._transitioning = this._transitionable.transitioned(e, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
          }
          recalculate(e) {
            this.properties = this._transitioning.possiblyEvaluate(e);
          }
          setErrorQueryLatitudeDegrees(e) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e);
          }
        }
        function jl(v) {
          const e = ts(v.worldSize, v.center.lat);
          return 2 * Math.PI * e;
        }
        function eo(v, e, a, c, p) {
          const y = 1 / (1 << p), x = e / s.$ * y + c * y, k = s.bo((v / s.$ * y + a * y) * Math.PI * 2 + Math.PI, 2 * Math.PI), P = 2 * Math.atan(Math.exp(Math.PI - x * Math.PI * 2)) - 0.5 * Math.PI, E = Math.cos(P), D = new Float64Array(3);
          return D[0] = Math.sin(k) * E, D[1] = Math.sin(P), D[2] = Math.cos(k) * E, D;
        }
        function Ni(v) {
          return (function(e, a) {
            const c = Math.cos(a), p = new Float64Array(3);
            return p[0] = Math.sin(e) * c, p[1] = Math.sin(a), p[2] = Math.cos(e) * c, p;
          })(v.lng * Math.PI / 180, v.lat * Math.PI / 180);
        }
        function ts(v, e) {
          return v / (2 * Math.PI) / Math.cos(e * Math.PI / 180);
        }
        function zs(v) {
          const e = Math.asin(v[1]) / Math.PI * 180, a = Math.sqrt(v[0] * v[0] + v[2] * v[2]);
          if (a > 1e-6) {
            const c = v[0] / a, p = Math.acos(v[2] / a), y = (c > 0 ? p : -p) / Math.PI * 180;
            return new s.S(s.aO(y, -180, 180), e);
          }
          return new s.S(0, e);
        }
        function Sa(v) {
          return Math.cos(v * Math.PI / 180);
        }
        function xi(v, e) {
          const a = Sa(v), c = Sa(e);
          return s.ak(c / a);
        }
        function dh(v, e) {
          const a = v.rotate(e.bearingInRadians), c = e.zoom + xi(e.center.lat, 0), p = s.bk(1 / Sa(e.center.lat), 1 / Sa(Math.min(Math.abs(e.center.lat), 60)), s.bn(c, 7, 3, 0, 1)), y = 360 / jl({ worldSize: e.worldSize, center: { lat: e.center.lat } });
          return new s.S(e.center.lng - a.x * y * p, s.ah(e.center.lat + a.y * y, -s.ai, s.ai));
        }
        function Fs(v) {
          const e = 0.5 * v, a = Math.sin(e), c = Math.cos(e);
          return Math.log(a + c) - Math.log(c - a);
        }
        function gc(v, e, a, c) {
          const p = v.lat + a * c;
          if (Math.abs(a) > 1) {
            const y = (Math.sign(v.lat + a) !== Math.sign(v.lat) ? -Math.abs(v.lat) : Math.abs(v.lat)) * Math.PI / 180, x = Math.abs(v.lat + a) * Math.PI / 180, k = Fs(y + c * (x - y)), P = Fs(y), E = Fs(x);
            return new s.S(v.lng + e * ((k - P) / (E - P)), p);
          }
          return new s.S(v.lng + e * c, p);
        }
        class bp {
          constructor(e) {
            this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = false, this._boundingVolumeFactory = e;
          }
          swapBuffers() {
            if (!this._hadAnyChanges) return;
            const e = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = false;
          }
          getTileBoundingVolume(e, a, c, p) {
            const y = `${e.z}_${e.x}_${e.y}_${(p == null ? void 0 : p.terrain) ? "t" : ""}`, x = this._cache.get(y);
            if (x) return x;
            const k = this._cachePrevious.get(y);
            if (k) return this._cache.set(y, k), k;
            const P = this._boundingVolumeFactory(e, a, c, p);
            return this._cache.set(y, P), this._hadAnyChanges = true, P;
          }
        }
        class rs {
          constructor(e, a, c, p) {
            this.min = c, this.max = p, this.points = e, this.planes = a;
          }
          static fromAabb(e, a) {
            const c = [];
            for (let p = 0; p < 8; p++) c.push([1 & ~p ? e[0] : a[0], (p >> 1 & 1) == 1 ? a[1] : e[1], (p >> 2 & 1) == 1 ? a[2] : e[2]]);
            return new rs(c, [[-1, 0, 0, a[0]], [1, 0, 0, -e[0]], [0, -1, 0, a[1]], [0, 1, 0, -e[1]], [0, 0, -1, a[2]], [0, 0, 1, -e[2]]], e, a);
          }
          static fromCenterSizeAngles(e, a, c) {
            const p = s.br([], c[0], c[1], c[2]), y = s.bs([], [a[0], 0, 0], p), x = s.bs([], [0, a[1], 0], p), k = s.bs([], [0, 0, a[2]], p), P = [...e], E = [...e];
            for (let j = 0; j < 8; j++) for (let $ = 0; $ < 3; $++) {
              const U = e[$] + y[$] * (1 & ~j ? -1 : 1) + x[$] * ((j >> 1 & 1) == 1 ? 1 : -1) + k[$] * ((j >> 2 & 1) == 1 ? 1 : -1);
              P[$] = Math.min(P[$], U), E[$] = Math.max(E[$], U);
            }
            const D = [];
            for (let j = 0; j < 8; j++) {
              const $ = [...e];
              s.aS($, $, s.aR([], y, 1 & ~j ? -1 : 1)), s.aS($, $, s.aR([], x, (j >> 1 & 1) == 1 ? 1 : -1)), s.aS($, $, s.aR([], k, (j >> 2 & 1) == 1 ? 1 : -1)), D.push($);
            }
            return new rs(D, [[...y, -s.aX(y, D[0])], [...x, -s.aX(x, D[0])], [...k, -s.aX(k, D[0])], [-y[0], -y[1], -y[2], -s.aX(y, D[7])], [-x[0], -x[1], -x[2], -s.aX(x, D[7])], [-k[0], -k[1], -k[2], -s.aX(k, D[7])]], P, E);
          }
          intersectsFrustum(e) {
            let a = true;
            const c = this.points.length, p = this.planes.length, y = e.planes.length, x = e.points.length;
            for (let k = 0; k < y; k++) {
              const P = e.planes[k];
              let E = 0;
              for (let D = 0; D < c; D++) {
                const j = this.points[D];
                P[0] * j[0] + P[1] * j[1] + P[2] * j[2] + P[3] >= 0 && E++;
              }
              if (E === 0) return 0;
              E < c && (a = false);
            }
            if (a) return 2;
            for (let k = 0; k < p; k++) {
              const P = this.planes[k];
              let E = 0;
              for (let D = 0; D < x; D++) {
                const j = e.points[D];
                P[0] * j[0] + P[1] * j[1] + P[2] * j[2] + P[3] >= 0 && E++;
              }
              if (E === 0) return 0;
            }
            return 1;
          }
          intersectsPlane(e) {
            const a = this.points.length;
            let c = 0;
            for (let p = 0; p < a; p++) {
              const y = this.points[p];
              e[0] * y[0] + e[1] * y[1] + e[2] * y[2] + e[3] >= 0 && c++;
            }
            return c === a ? 2 : c === 0 ? 0 : 1;
          }
        }
        function Hi(v, e, a) {
          const c = v - e;
          return c < 0 ? -c : Math.max(0, c - a);
        }
        function Ls(v, e, a, c, p) {
          const y = v - a;
          let x;
          return x = y < 0 ? Math.min(-y, 1 + y - p) : y > 1 ? Math.min(Math.max(y - p, 0), 1 - y) : 0, Math.max(x, Hi(e, c, p));
        }
        class Co {
          constructor() {
            this._boundingVolumeCache = new bp(this._computeTileBoundingVolume);
          }
          prepareNextFrame() {
            this._boundingVolumeCache.swapBuffers();
          }
          distanceToTile2d(e, a, c, p) {
            const y = 1 << c.z, x = 1 / y, k = c.x / y, P = c.y / y;
            let E = 2;
            return E = Math.min(E, Ls(e, a, k, P, x)), E = Math.min(E, Ls(e, a, k + 0.5, -P - x, x)), E = Math.min(E, Ls(e, a, k + 0.5, 2 - P - x, x)), E;
          }
          getWrap(e, a, c) {
            const p = 1 << a.z, y = 1 / p, x = a.x / p, k = Hi(e.x, x, y), P = Hi(e.x, x - 1, y), E = Hi(e.x, x + 1, y), D = Math.min(k, P, E);
            return D === E ? 1 : D === P ? -1 : 0;
          }
          allowVariableZoom(e, a) {
            return xt(e, a) > 4;
          }
          allowWorldCopies() {
            return false;
          }
          getTileBoundingVolume(e, a, c, p) {
            return this._boundingVolumeCache.getTileBoundingVolume(e, a, c, p);
          }
          _computeTileBoundingVolume(e, a, c, p) {
            var y, x;
            let k = 0, P = 0;
            if (p == null ? void 0 : p.terrain) {
              const E = new s.Z(e.z, a, e.z, e.x, e.y), D = p.terrain.getMinMaxElevation(E);
              k = (y = D.minElevation) !== null && y !== void 0 ? y : Math.min(0, c), P = (x = D.maxElevation) !== null && x !== void 0 ? x : Math.max(0, c);
            }
            if (k /= s.bu, P /= s.bu, k += 1, P += 1, e.z <= 0) return rs.fromAabb([-P, -P, -P], [P, P, P]);
            if (e.z === 1) return rs.fromAabb([e.x === 0 ? -P : 0, e.y === 0 ? 0 : -P, -P], [e.x === 0 ? 0 : P, e.y === 0 ? P : 0, P]);
            {
              const E = [eo(0, 0, e.x, e.y, e.z), eo(s.$, 0, e.x, e.y, e.z), eo(s.$, s.$, e.x, e.y, e.z), eo(0, s.$, e.x, e.y, e.z)], D = [];
              for (const Ze of E) D.push(s.aR([], Ze, P));
              if (P !== k) for (const Ze of E) D.push(s.aR([], Ze, k));
              e.y === 0 && D.push([0, 1, 0]), e.y === (1 << e.z) - 1 && D.push([0, -1, 0]);
              const j = [1, 1, 1], $ = [-1, -1, -1];
              for (const Ze of D) for (let Qe = 0; Qe < 3; Qe++) j[Qe] = Math.min(j[Qe], Ze[Qe]), $[Qe] = Math.max($[Qe], Ze[Qe]);
              const U = eo(s.$ / 2, s.$ / 2, e.x, e.y, e.z), Y = s.aW([], [0, 1, 0], U);
              s.aV(Y, Y);
              const se = s.aW([], U, Y);
              s.aV(se, se);
              const le = s.aW([], E[2], E[1]);
              s.aV(le, le);
              const ce = s.aW([], E[0], E[3]);
              s.aV(ce, ce), D.push(s.aR([], U, P)), e.y >= (1 << e.z) / 2 && D.push(s.aR([], eo(s.$ / 2, 0, e.x, e.y, e.z), P)), e.y < (1 << e.z) / 2 && D.push(s.aR([], eo(s.$ / 2, s.$, e.x, e.y, e.z), P));
              const me = Bs(U, D), we = Bs(se, D), _e = [-U[0], -U[1], -U[2], me.max], Pe = [U[0], U[1], U[2], -me.min], Me = [-se[0], -se[1], -se[2], we.max], ye = [se[0], se[1], se[2], -we.min], Be = [...le, 0], Je = [...ce, 0], We = [];
              return e.y === 0 ? We.push(s.bt(Je, Be, _e), s.bt(Je, Be, Pe)) : We.push(s.bt(Me, Be, _e), s.bt(Me, Be, Pe), s.bt(Me, Je, _e), s.bt(Me, Je, Pe)), e.y === (1 << e.z) - 1 ? We.push(s.bt(Je, Be, _e), s.bt(Je, Be, Pe)) : We.push(s.bt(ye, Be, _e), s.bt(ye, Be, Pe), s.bt(ye, Je, _e), s.bt(ye, Je, Pe)), new rs(We, [_e, Pe, Me, ye, Be, Je], j, $);
            }
          }
        }
        function Bs(v, e) {
          let a = 1 / 0, c = -1 / 0;
          for (const p of e) {
            const y = s.aX(v, p);
            a = Math.min(a, y), c = Math.max(c, y);
          }
          return { min: a, max: c };
        }
        class Os {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, a, c) {
            return this._helper.interpolatePadding(e, a, c);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, a) {
            this._helper.resize(e, a);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e) {
          }
          constructor() {
            this._cachedClippingPlane = s.bv(), this._projectionMatrix = s.b9(), this._globeViewProjMatrix32f = s.b8(), this._globeViewProjMatrixNoCorrection = s.b9(), this._globeViewProjMatrixNoCorrectionInverted = s.b9(), this._globeProjMatrixInverted = s.b9(), this._cameraPosition = s.bp(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new pn({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (e, a) => this.getConstrained(e, a) }), this._coveringTilesDetailsProvider = new Co();
          }
          clone() {
            const e = new Os();
            return e.apply(this), e;
          }
          apply(e, a) {
            this._globeLatitudeErrorCorrectionRadians = a || 0, this._helper.apply(e);
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection;
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted;
          }
          get cameraPosition() {
            const e = s.bp();
            return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          getProjectionData(e) {
            const { overscaledTileID: a, applyGlobeMatrix: c } = e, p = this._helper.getMercatorTileCoordinates(a);
            return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: p, clippingPlane: this._cachedClippingPlane, projectionTransition: c ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
          }
          _computeClippingPlane(e) {
            const a = this.pitchInRadians, c = this.cameraToCenterDistance / e, p = Math.sin(a) * c, y = Math.cos(a) * c + 1, x = 1 / Math.sqrt(p * p + y * y) * 1;
            let k = -p, P = y;
            const E = Math.sqrt(k * k + P * P);
            k /= E, P /= E;
            const D = [0, k, P];
            s.bw(D, D, [0, 0, 0], -this.bearingInRadians), s.bx(D, D, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), s.by(D, D, [0, 0, 0], this.center.lng * Math.PI / 180);
            const j = 1 / s.aZ(D);
            return s.aR(D, D, j), [...D, -x * j];
          }
          isLocationOccluded(e) {
            return !this.isSurfacePointVisible(Ni(e));
          }
          transformLightDirection(e) {
            const a = this._helper._center.lng * Math.PI / 180, c = this._helper._center.lat * Math.PI / 180, p = Math.cos(c), y = [Math.sin(a) * p, Math.sin(c), Math.cos(a) * p], x = [y[2], 0, -y[0]], k = [0, 0, 0];
            s.aW(k, x, y), s.aV(x, x), s.aV(k, k);
            const P = [0, 0, 0];
            return s.aV(P, [x[0] * e[0] + k[0] * e[1] + y[0] * e[2], x[1] * e[0] + k[1] * e[1] + y[1] * e[2], x[2] * e[0] + k[2] * e[1] + y[2] * e[2]]), P;
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getPitchedTextCorrection(e, a, c) {
            const p = (function(k, P, E) {
              const D = 1 / (1 << E.z);
              return new s.a1(k / s.$ * D + E.x * D, P / s.$ * D + E.y * D);
            })(e, a, c.canonical), y = (x = p.y, [s.bo(p.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - x * Math.PI * 2)) - 0.5 * Math.PI]);
            var x;
            return this.getCircleRadiusCorrection() / Math.cos(y[1]);
          }
          projectTileCoordinates(e, a, c, p) {
            const y = c.canonical, x = eo(e, a, y.x, y.y, y.z), k = 1 + (p ? p(e, a) : 0) / s.bu, P = [x[0] * k, x[1] * k, x[2] * k, 1];
            s.aw(P, P, this._globeViewProjMatrixNoCorrection);
            const E = this._cachedClippingPlane, D = E[0] * x[0] + E[1] * x[1] + E[2] * x[2] + E[3] < 0;
            return { point: new s.P(P[0] / P[3], P[1] / P[3]), signedDistanceFromCamera: P[3], isOccluded: D };
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e = ts(this.worldSize, this.center.lat), a = s.ba(), c = s.ba();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), s.b4(a, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const p = this.centerOffset;
            a[8] = 2 * -p.x / this._helper._width, a[9] = 2 * p.y / this._helper._height, this._projectionMatrix = s.b5(a), this._globeProjMatrixInverted = s.ba(), s.aq(this._globeProjMatrixInverted, a), s.M(a, a, [0, 0, -this.cameraToCenterDistance]), s.b6(a, a, this.rollInRadians), s.b7(a, a, -this.pitchInRadians), s.b6(a, a, this.bearingInRadians), s.M(a, a, [0, 0, -e]);
            const y = s.bp();
            y[0] = e, y[1] = e, y[2] = e, s.b7(c, a, this.center.lat * Math.PI / 180), s.bz(c, c, -this.center.lng * Math.PI / 180), s.N(c, c, y), this._globeViewProjMatrixNoCorrection = c, s.b7(a, a, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), s.bz(a, a, -this.center.lng * Math.PI / 180), s.N(a, a, y), this._globeViewProjMatrix32f = new Float32Array(a), this._globeViewProjMatrixNoCorrectionInverted = s.ba(), s.aq(this._globeViewProjMatrixNoCorrectionInverted, c);
            const x = s.bp();
            this._cameraPosition = s.bp(), this._cameraPosition[2] = this.cameraToCenterDistance / e, s.bw(this._cameraPosition, this._cameraPosition, x, -this.rollInRadians), s.bx(this._cameraPosition, this._cameraPosition, x, this.pitchInRadians), s.bw(this._cameraPosition, this._cameraPosition, x, -this.bearingInRadians), s.aS(this._cameraPosition, this._cameraPosition, [0, 0, 1]), s.bx(this._cameraPosition, this._cameraPosition, x, -this.center.lat * Math.PI / 180), s.by(this._cameraPosition, this._cameraPosition, x, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
            const k = s.b5(this._globeViewProjMatrixNoCorrectionInverted);
            s.N(k, k, [1, 1, -1]), this._cachedFrustum = Mi.fromInvProjectionMatrix(k, 1, 0, this._cachedClippingPlane, true);
          }
          calculateFogMatrix(e) {
            s.w("calculateFogMatrix is not supported on globe projection.");
            const a = s.ba();
            return s.ag(a), a;
          }
          getVisibleUnwrappedCoordinates(e) {
            return [new s.b2(0, e)];
          }
          getCameraFrustum() {
            return this._cachedFrustum;
          }
          getClippingPlane() {
            return this._cachedClippingPlane;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e) {
            e && s.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
          }
          maxPitchScaleFactor() {
            return 1;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e, a) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const c = Ni(e);
            s.aR(c, c, 1 + a / s.bu);
            const p = s.bv();
            return s.aw(p, [c[0], c[1], c[2], 1], this._globeViewProjMatrixNoCorrection), p[2] / p[3];
          }
          populateCache(e) {
          }
          getBounds() {
            const e = 0.5 * this.width, a = 0.5 * this.height, c = [new s.P(0, 0), new s.P(e, 0), new s.P(this.width, 0), new s.P(this.width, a), new s.P(this.width, this.height), new s.P(e, this.height), new s.P(0, this.height), new s.P(0, a)], p = [];
            for (const j of c) p.push(this.unprojectScreenPoint(j));
            let y = 0, x = 0, k = 0, P = 0;
            const E = this.center;
            for (const j of p) {
              const $ = s.bA(E.lng, j.lng), U = s.bA(E.lat, j.lat);
              $ < x && (x = $), $ > y && (y = $), U < P && (P = U), U > k && (k = U);
            }
            const D = [E.lng + x, E.lat + P, E.lng + y, E.lat + k];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (D[3] = 90, D[0] = -180, D[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (D[1] = -90, D[0] = -180, D[2] = 180), new sr(D);
          }
          getConstrained(e, a) {
            const c = s.ah(e.lat, -s.ai, s.ai), p = s.ah(+a, this.minZoom + xi(0, c), this.maxZoom);
            return { center: new s.S(e.lng, c), zoom: p };
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, p) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, c, p);
          }
          setLocationAtPoint(e, a) {
            const c = Ni(this.unprojectScreenPoint(a)), p = Ni(e), y = s.bp();
            s.bB(y);
            const x = s.bp();
            s.by(x, c, y, -this.center.lng * Math.PI / 180), s.bx(x, x, y, this.center.lat * Math.PI / 180);
            const k = p[0] * p[0] + p[2] * p[2], P = x[0] * x[0];
            if (k < P) return;
            const E = Math.sqrt(k - P), D = -E, j = s.bC(p[0], p[2], x[0], E), $ = s.bC(p[0], p[2], x[0], D), U = s.bp();
            s.by(U, p, y, -j);
            const Y = s.bC(U[1], U[2], x[1], x[2]), se = s.bp();
            s.by(se, p, y, -$);
            const le = s.bC(se[1], se[2], x[1], x[2]), ce = 0.5 * Math.PI, me = Y >= -ce && Y <= ce, we = le >= -ce && le <= ce;
            let _e, Pe;
            if (me && we) {
              const Je = this.center.lng * Math.PI / 180, We = this.center.lat * Math.PI / 180;
              s.bD(j, Je) + s.bD(Y, We) < s.bD($, Je) + s.bD(le, We) ? (_e = j, Pe = Y) : (_e = $, Pe = le);
            } else if (me) _e = j, Pe = Y;
            else {
              if (!we) return;
              _e = $, Pe = le;
            }
            const Me = _e / Math.PI * 180, ye = Pe / Math.PI * 180, Be = this.center.lat;
            this.setCenter(new s.S(Me, s.ah(ye, -90, 90))), this.setZoom(this.zoom + xi(Be, this.center.lat));
          }
          locationToScreenPoint(e, a) {
            const c = Ni(e);
            if (a) {
              const p = a.getElevationForLngLatZoom(e, this._helper._tileZoom);
              s.aR(c, c, 1 + p / s.bu);
            }
            return this._projectSurfacePointToScreen(c);
          }
          _projectSurfacePointToScreen(e) {
            const a = s.bv();
            return s.aw(a, [...e, 1], this._globeViewProjMatrixNoCorrection), a[0] /= a[3], a[1] /= a[3], new s.P((0.5 * a[0] + 0.5) * this.width, (0.5 * -a[1] + 0.5) * this.height);
          }
          screenPointToMercatorCoordinate(e, a) {
            if (a) {
              const c = a.pointCoordinate(e);
              if (c) return c;
            }
            return s.a1.fromLngLat(this.unprojectScreenPoint(e));
          }
          screenPointToLocation(e, a) {
            var c;
            return (c = this.screenPointToMercatorCoordinate(e, a)) === null || c === void 0 ? void 0 : c.toLngLat();
          }
          isPointOnMapSurface(e, a) {
            const c = this._cameraPosition, p = this.getRayDirectionFromPixel(e);
            return !!this.rayPlanetIntersection(c, p);
          }
          getRayDirectionFromPixel(e) {
            const a = s.bv();
            a[0] = e.x / this.width * 2 - 1, a[1] = -1 * (e.y / this.height * 2 - 1), a[2] = 1, a[3] = 1, s.aw(a, a, this._globeViewProjMatrixNoCorrectionInverted), a[0] /= a[3], a[1] /= a[3], a[2] /= a[3];
            const c = s.bp();
            c[0] = a[0] - this._cameraPosition[0], c[1] = a[1] - this._cameraPosition[1], c[2] = a[2] - this._cameraPosition[2];
            const p = s.bp();
            return s.aV(p, c), p;
          }
          isSurfacePointVisible(e) {
            const a = this._cachedClippingPlane;
            return a[0] * e[0] + a[1] * e[1] + a[2] * e[2] + a[3] >= 0;
          }
          isSurfacePointOnScreen(e) {
            if (!this.isSurfacePointVisible(e)) return false;
            const a = s.bv();
            return s.aw(a, [...e, 1], this._globeViewProjMatrixNoCorrection), a[0] /= a[3], a[1] /= a[3], a[2] /= a[3], a[0] > -1 && a[0] < 1 && a[1] > -1 && a[1] < 1 && a[2] > -1 && a[2] < 1;
          }
          rayPlanetIntersection(e, a) {
            const c = s.aX(e, a), p = s.bp(), y = s.bp();
            s.aR(y, a, c), s.aU(p, e, y);
            const x = 1 - s.aX(p, p);
            if (x < 0) return null;
            const k = s.aX(e, e) - 1, P = -c + (c < 0 ? 1 : -1) * Math.sqrt(x), E = k / P, D = P;
            return { tMin: Math.min(E, D), tMax: Math.max(E, D) };
          }
          unprojectScreenPoint(e) {
            const a = this._cameraPosition, c = this.getRayDirectionFromPixel(e), p = this.rayPlanetIntersection(a, c);
            if (p) {
              const D = s.bp();
              s.aS(D, a, [c[0] * p.tMin, c[1] * p.tMin, c[2] * p.tMin]);
              const j = s.bp();
              return s.aV(j, D), zs(j);
            }
            const y = this._cachedClippingPlane, x = y[0] * c[0] + y[1] * c[1] + y[2] * c[2], k = -s.b1(y, a) / x, P = s.bp();
            if (k > 0) s.aS(P, a, [c[0] * k, c[1] * k, c[2] * k]);
            else {
              const D = s.bp();
              s.aS(D, a, [2 * c[0], 2 * c[1], 2 * c[2]]);
              const j = s.b1(this._cachedClippingPlane, D);
              s.aU(P, D, [this._cachedClippingPlane[0] * j, this._cachedClippingPlane[1] * j, this._cachedClippingPlane[2] * j]);
            }
            const E = (function(D) {
              const j = s.bp();
              return j[0] = D[0] * -D[3], j[1] = D[1] * -D[3], j[2] = D[2] * -D[3], { center: j, radius: Math.sqrt(1 - D[3] * D[3]) };
            })(y);
            return zs((function(D, j, $) {
              const U = s.bp();
              s.aU(U, $, D);
              const Y = s.bp();
              return s.bq(Y, D, U, j / s.a$(U)), Y;
            })(E.center, E.radius, P));
          }
          getMatrixForModel(e, a) {
            const c = s.S.convert(e), p = 1 / s.bu, y = s.b9();
            return s.bz(y, y, c.lng / 180 * Math.PI), s.b7(y, y, -c.lat / 180 * Math.PI), s.M(y, y, [0, 0, 1 + a / s.bu]), s.b7(y, y, 0.5 * Math.PI), s.N(y, y, [p, p, p]), y;
          }
          getProjectionDataForCustomLayer(e = true) {
            const a = this.getProjectionData({ overscaledTileID: new s.Z(0, 0, 0, 0, 0), applyGlobeMatrix: e });
            return a.tileMercatorCoords = [0, 0, 1, 1], a;
          }
          getFastPathSimpleProjectionMatrix(e) {
          }
        }
        class $s {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e) {
            this._helper.setMinZoom(e);
          }
          setMaxZoom(e) {
            this._helper.setMaxZoom(e);
          }
          setMinPitch(e) {
            this._helper.setMinPitch(e);
          }
          setMaxPitch(e) {
            this._helper.setMaxPitch(e);
          }
          setRenderWorldCopies(e) {
            this._helper.setRenderWorldCopies(e);
          }
          setBearing(e) {
            this._helper.setBearing(e);
          }
          setPitch(e) {
            this._helper.setPitch(e);
          }
          setRoll(e) {
            this._helper.setRoll(e);
          }
          setFov(e) {
            this._helper.setFov(e);
          }
          setZoom(e) {
            this._helper.setZoom(e);
          }
          setCenter(e) {
            this._helper.setCenter(e);
          }
          setElevation(e) {
            this._helper.setElevation(e);
          }
          setMinElevationForCurrentTile(e) {
            this._helper.setMinElevationForCurrentTile(e);
          }
          setPadding(e) {
            this._helper.setPadding(e);
          }
          interpolatePadding(e, a, c) {
            return this._helper.interpolatePadding(e, a, c);
          }
          isPaddingEqual(e) {
            return this._helper.isPaddingEqual(e);
          }
          resize(e, a, c = true) {
            this._helper.resize(e, a, c);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e) {
            this._helper.setMaxBounds(e);
          }
          overrideNearFarZ(e, a) {
            this._helper.overrideNearFarZ(e, a);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          get isGlobeRendering() {
            return this._globeness > 0;
          }
          setTransitionState(e, a) {
            this._globeness = e, this._globeLatitudeErrorCorrectionRadians = a, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
          }
          constructor() {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new pn({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (e, a) => this.getConstrained(e, a) }), this._globeness = 1, this._mercatorTransform = new Qr(), this._verticalPerspectiveTransform = new Os();
          }
          clone() {
            const e = new $s();
            return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e;
          }
          apply(e) {
            this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix;
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix;
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition;
          }
          getProjectionData(e) {
            const a = this._mercatorTransform.getProjectionData(e), c = this._verticalPerspectiveTransform.getProjectionData(e);
            return { mainMatrix: this.isGlobeRendering ? c.mainMatrix : a.mainMatrix, clippingPlane: c.clippingPlane, tileMercatorCoords: c.tileMercatorCoords, projectionTransition: e.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: a.fallbackMatrix };
          }
          isLocationOccluded(e) {
            return this.currentTransform.isLocationOccluded(e);
          }
          transformLightDirection(e) {
            return this.currentTransform.transformLightDirection(e);
          }
          getPixelScale() {
            return s.bk(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
          }
          getCircleRadiusCorrection() {
            return s.bk(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
          }
          getPitchedTextCorrection(e, a, c) {
            const p = this._mercatorTransform.getPitchedTextCorrection(e, a, c), y = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, a, c);
            return s.bk(p, y, this._globeness);
          }
          projectTileCoordinates(e, a, c, p) {
            return this.currentTransform.projectTileCoordinates(e, a, c, p);
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, true, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
          }
          calculateFogMatrix(e) {
            return this.currentTransform.calculateFogMatrix(e);
          }
          getVisibleUnwrappedCoordinates(e) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e);
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum();
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane();
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider();
          }
          recalculateZoomAndCenter(e) {
            this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e);
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor();
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e, a) {
            return this.currentTransform.lngLatToCameraDepth(e, a);
          }
          populateCache(e) {
            this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e);
          }
          getBounds() {
            return this.currentTransform.getBounds();
          }
          getConstrained(e, a) {
            return this.currentTransform.getConstrained(e, a);
          }
          calculateCenterFromCameraLngLatAlt(e, a, c, p) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e, a, c, p);
          }
          setLocationAtPoint(e, a) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, a), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e, a), this.apply(this._verticalPerspectiveTransform);
          }
          locationToScreenPoint(e, a) {
            return this.currentTransform.locationToScreenPoint(e, a);
          }
          screenPointToMercatorCoordinate(e, a) {
            return this.currentTransform.screenPointToMercatorCoordinate(e, a);
          }
          screenPointToLocation(e, a) {
            return this.currentTransform.screenPointToLocation(e, a);
          }
          isPointOnMapSurface(e, a) {
            return this.currentTransform.isPointOnMapSurface(e, a);
          }
          getRayDirectionFromPixel(e) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e);
          }
          getMatrixForModel(e, a) {
            return this.currentTransform.getMatrixForModel(e, a);
          }
          getProjectionDataForCustomLayer(e = true) {
            const a = this._mercatorTransform.getProjectionDataForCustomLayer(e);
            if (!this.isGlobeRendering) return a;
            const c = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
            return c.fallbackMatrix = a.mainMatrix, c;
          }
          getFastPathSimpleProjectionMatrix(e) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e);
          }
        }
        class on {
          get useGlobeControls() {
            return true;
          }
          handlePanInertia(e, a) {
            const c = dh(e, a);
            return Math.abs(c.lng - a.center.lng) > 180 && (c.lng = a.center.lng + 179.5 * Math.sign(c.lng - a.center.lng)), { easingCenter: c, easingOffset: new s.P(0, 0) };
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            const c = e.around, p = a.screenPointToLocation(c);
            e.bearingDelta && a.setBearing(a.bearing + e.bearingDelta), e.pitchDelta && a.setPitch(a.pitch + e.pitchDelta), e.rollDelta && a.setRoll(a.roll + e.rollDelta);
            const y = a.zoom;
            e.zoomDelta && a.setZoom(a.zoom + e.zoomDelta);
            const x = a.zoom - y;
            if (x === 0) return;
            const k = s.bA(a.center.lng, p.lng), P = k / (Math.abs(k / 180) + 1), E = s.bA(a.center.lat, p.lat), D = a.getRayDirectionFromPixel(c), j = a.cameraPosition, $ = -1 * s.aX(j, D), U = s.bp();
            s.aS(U, j, [D[0] * $, D[1] * $, D[2] * $]);
            const Y = s.aZ(U) - 1, se = Math.exp(0.5 * -Math.max(Y - 0.3, 0)), le = ts(a.worldSize, a.center.lat) / Math.min(a.width, a.height), ce = s.bn(le, 0.9, 0.5, 1, 0.25), me = (1 - s.af(-x)) * Math.min(se, ce), we = a.center.lat, _e = a.zoom, Pe = new s.S(a.center.lng + P * me, s.ah(a.center.lat + E * me, -s.ai, s.ai));
            a.setLocationAtPoint(p, c);
            const Me = a.center, ye = s.bn(Math.abs(k), 45, 85, 0, 1), Be = s.bn(le, 0.75, 0.35, 0, 1), Je = Math.pow(Math.max(ye, Be), 0.25), We = s.bA(Me.lng, Pe.lng), Ze = s.bA(Me.lat, Pe.lat);
            a.setCenter(new s.S(Me.lng + We * Je, Me.lat + Ze * Je).wrap()), a.setZoom(_e + xi(we, a.center.lat));
          }
          handleMapControlsPan(e, a, c) {
            if (!e.panDelta) return;
            const p = a.center.lat, y = a.zoom;
            a.setCenter(dh(e.panDelta, a).wrap()), a.setZoom(y + xi(p, a.center.lat));
          }
          cameraForBoxAndBearing(e, a, c, p, y) {
            const x = zn(e, a, c, p, y), k = a.left / y.width * 2 - 1, P = (y.width - a.right) / y.width * 2 - 1, E = a.top / y.height * -2 + 1, D = (y.height - a.bottom) / y.height * -2 + 1, j = s.bA(c.getWest(), c.getEast()) < 0, $ = j ? c.getEast() : c.getWest(), U = j ? c.getWest() : c.getEast(), Y = Math.max(c.getNorth(), c.getSouth()), se = Math.min(c.getNorth(), c.getSouth()), le = $ + 0.5 * s.bA($, U), ce = Y + 0.5 * s.bA(Y, se), me = y.clone();
            me.setCenter(x.center), me.setBearing(x.bearing), me.setPitch(0), me.setRoll(0), me.setZoom(x.zoom);
            const we = me.modelViewProjectionMatrix, _e = [Ni(c.getNorthWest()), Ni(c.getNorthEast()), Ni(c.getSouthWest()), Ni(c.getSouthEast()), Ni(new s.S(U, ce)), Ni(new s.S($, ce)), Ni(new s.S(le, Y)), Ni(new s.S(le, se))], Pe = Ni(x.center);
            let Me = Number.POSITIVE_INFINITY;
            for (const ye of _e) k < 0 && (Me = on.getLesserNonNegativeNonNull(Me, on.solveVectorScale(ye, Pe, we, "x", k))), P > 0 && (Me = on.getLesserNonNegativeNonNull(Me, on.solveVectorScale(ye, Pe, we, "x", P))), E > 0 && (Me = on.getLesserNonNegativeNonNull(Me, on.solveVectorScale(ye, Pe, we, "y", E))), D < 0 && (Me = on.getLesserNonNegativeNonNull(Me, on.solveVectorScale(ye, Pe, we, "y", D)));
            if (Number.isFinite(Me) && Me !== 0) return x.zoom = me.zoom + s.ak(Me), x;
            ch();
          }
          handleJumpToCenterZoom(e, a) {
            const c = e.center.lat, p = e.getConstrained(a.center ? s.S.convert(a.center) : e.center, e.zoom).center;
            e.setCenter(p.wrap());
            const y = a.zoom !== void 0 ? +a.zoom : e.zoom + xi(c, p.lat);
            e.zoom !== y && e.setZoom(y);
          }
          handleEaseTo(e, a) {
            const c = e.zoom, p = e.center, y = e.padding, x = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, k = { roll: a.roll === void 0 ? e.roll : a.roll, pitch: a.pitch === void 0 ? e.pitch : a.pitch, bearing: a.bearing === void 0 ? e.bearing : a.bearing }, P = a.zoom !== void 0, E = !e.isPaddingEqual(a.padding);
            let D = false;
            const j = a.center ? s.S.convert(a.center) : p, $ = e.getConstrained(j, c).center;
            Fl(e, $);
            const U = e.clone();
            U.setCenter($), U.setZoom(P ? +a.zoom : c + xi(p.lat, j.lat)), U.setBearing(a.bearing);
            const Y = new s.P(s.ah(e.centerPoint.x + a.offsetAsPoint.x, 0, e.width), s.ah(e.centerPoint.y + a.offsetAsPoint.y, 0, e.height));
            U.setLocationAtPoint($, Y);
            const se = (a.offset && a.offsetAsPoint.mag()) > 0 ? U.center : $, le = P ? +a.zoom : c + xi(p.lat, se.lat), ce = c + xi(p.lat, 0), me = le + xi(se.lat, 0), we = s.bA(p.lng, se.lng), _e = s.bA(p.lat, se.lat), Pe = s.af(me - ce);
            return D = le !== c, { easeFunc: (Me) => {
              if (s.be(x, k) || gn({ startEulerAngles: x, endEulerAngles: k, tr: e, k: Me, useSlerp: x.roll != k.roll }), E && e.interpolatePadding(y, a.padding, Me), a.around) s.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(a.around, a.aroundPoint);
              else {
                const ye = me > ce ? Math.min(2, Pe) : Math.max(0.5, Pe), Be = Math.pow(ye, 1 - Me), Je = gc(p, we, _e, Me * Be);
                e.setCenter(Je.wrap());
              }
              if (D) {
                const ye = s.C.number(ce, me, Me) + xi(0, e.center.lat);
                e.setZoom(ye);
              }
            }, isZooming: D, elevationCenter: se };
          }
          handleFlyTo(e, a) {
            const c = a.zoom !== void 0, p = e.center, y = e.zoom, x = e.padding, k = !e.isPaddingEqual(a.padding), P = e.getConstrained(s.S.convert(a.center || a.locationAtOffset), y).center, E = c ? +a.zoom : e.zoom + xi(e.center.lat, P.lat), D = e.clone();
            D.setCenter(P), D.setZoom(E), D.setBearing(a.bearing);
            const j = new s.P(s.ah(e.centerPoint.x + a.offsetAsPoint.x, 0, e.width), s.ah(e.centerPoint.y + a.offsetAsPoint.y, 0, e.height));
            D.setLocationAtPoint(P, j);
            const $ = D.center;
            Fl(e, $);
            const U = (function(_e, Pe, Me) {
              const ye = Ni(Pe), Be = Ni(Me), Je = s.aX(ye, Be), We = Math.acos(Je), Ze = jl(_e);
              return We / (2 * Math.PI) * Ze;
            })(e, p, $), Y = y + xi(p.lat, 0), se = E + xi($.lat, 0), le = s.af(se - Y);
            let ce;
            if (typeof a.minZoom == "number") {
              const _e = +a.minZoom + xi($.lat, 0), Pe = Math.min(_e, Y, se) + xi(0, $.lat), Me = e.getConstrained($, Pe).zoom + xi($.lat, 0);
              ce = s.af(Me - Y);
            }
            const me = s.bA(p.lng, $.lng), we = s.bA(p.lat, $.lat);
            return { easeFunc: (_e, Pe, Me, ye) => {
              const Be = gc(p, me, we, Me);
              k && e.interpolatePadding(x, a.padding, _e);
              const Je = _e === 1 ? $ : Be;
              e.setCenter(Je.wrap());
              const We = Y + s.ak(Pe);
              e.setZoom(_e === 1 ? E : We + xi(0, Je.lat));
            }, scaleOfZoom: le, targetCenter: $, scaleOfMinZoom: ce, pixelPathLength: U };
          }
          static solveVectorScale(e, a, c, p, y) {
            const x = p === "x" ? [c[0], c[4], c[8], c[12]] : [c[1], c[5], c[9], c[13]], k = [c[3], c[7], c[11], c[15]], P = e[0] * x[0] + e[1] * x[1] + e[2] * x[2], E = e[0] * k[0] + e[1] * k[1] + e[2] * k[2], D = a[0] * x[0] + a[1] * x[1] + a[2] * x[2], j = a[0] * k[0] + a[1] * k[1] + a[2] * k[2];
            return D + y * E === P + y * j || k[3] * (P - D) + x[3] * (j - E) + P * j == D * E ? null : (D + x[3] - y * j - y * k[3]) / (D - P - y * j + y * E);
          }
          static getLesserNonNegativeNonNull(e, a) {
            return a !== null && a >= 0 && a < e ? a : e;
          }
        }
        class hh {
          constructor(e) {
            this._globe = e, this._mercatorCameraHelper = new nn(), this._verticalPerspectiveCameraHelper = new on();
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering;
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
          }
          handlePanInertia(e, a) {
            return this.currentHelper.handlePanInertia(e, a);
          }
          handleMapControlsRollPitchBearingZoom(e, a) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, a);
          }
          handleMapControlsPan(e, a, c) {
            this.currentHelper.handleMapControlsPan(e, a, c);
          }
          cameraForBoxAndBearing(e, a, c, p, y) {
            return this.currentHelper.cameraForBoxAndBearing(e, a, c, p, y);
          }
          handleJumpToCenterZoom(e, a) {
            this.currentHelper.handleJumpToCenterZoom(e, a);
          }
          handleEaseTo(e, a) {
            return this.currentHelper.handleEaseTo(e, a);
          }
          handleFlyTo(e, a) {
            return this.currentHelper.handleFlyTo(e, a);
          }
        }
        const Nl = (v, e) => s.y(v, e && e.filter(((a) => a.identifier !== "source.canvas"))), xp = s.bE();
        class vc extends s.E {
          constructor(e, a = {}) {
            var c, p;
            super(), this._rtlPluginLoaded = () => {
              for (const x in this.sourceCaches) {
                const k = this.sourceCaches[x].getSource().type;
                k !== "vector" && k !== "geojson" || this.sourceCaches[x].reload();
              }
            }, this.map = e, this.dispatcher = new zt(Ht(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", ((x, k) => this.getGlyphs(x, k))), this.dispatcher.registerMessageHandler("GI", ((x, k) => this.getImages(x, k))), this.imageManager = new oe(), this.imageManager.setEventedParent(this);
            const y = ((c = e._container) === null || c === void 0 ? void 0 : c.lang) || typeof document < "u" && ((p = document.documentElement) === null || p === void 0 ? void 0 : p.lang) || void 0;
            this.glyphManager = new Ve(e._requestManager, a.localIdeographFontFamily, y), this.lineAtlas = new et(256, 512), this.crossTileSymbolIndex = new ta(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new s.bF(), this._loaded = false, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", s.bG()), ri().on(tt, this._rtlPluginLoaded), this.on("data", ((x) => {
              if (x.dataType !== "source" || x.sourceDataType !== "metadata") return;
              const k = this.sourceCaches[x.sourceId];
              if (!k) return;
              const P = k.getSource();
              if (P && P.vectorLayerIds) for (const E in this._layers) {
                const D = this._layers[E];
                D.source === P.id && this._validateLayer(D);
              }
            }));
          }
          setGlobalStateProperty(e, a) {
            var c, p, y;
            this._checkLoaded();
            const x = a === null ? (y = (p = (c = this.stylesheet.state) === null || c === void 0 ? void 0 : c[e]) === null || p === void 0 ? void 0 : p.default) !== null && y !== void 0 ? y : null : a;
            if (s.bH(x, this._globalState[e])) return this;
            this._globalState[e] = x, this._applyGlobalStateChanges([e]);
          }
          getGlobalState() {
            return this._globalState;
          }
          setGlobalState(e) {
            this._checkLoaded();
            const a = [];
            for (const c in e) !s.bH(this._globalState[c], e[c].default) && (a.push(c), this._globalState[c] = e[c].default);
            this._applyGlobalStateChanges(a);
          }
          _applyGlobalStateChanges(e) {
            if (e.length === 0) return;
            const a = /* @__PURE__ */ new Set(), c = {};
            for (const p of e) {
              c[p] = this._globalState[p];
              for (const y in this._layers) {
                const x = this._layers[y], k = x.getLayoutAffectingGlobalStateRefs(), P = x.getPaintAffectingGlobalStateRefs();
                if (k.has(p) && a.add(x.source), P.has(p)) for (const { name: E, value: D } of P.get(p)) this._updatePaintProperty(x, E, D);
              }
            }
            this.dispatcher.broadcast("UGS", c);
            for (const p in this.sourceCaches) a.has(p) && (this._reloadSource(p), this._changed = true);
          }
          loadURL(e, a = {}, c) {
            this.fire(new s.l("dataloading", { dataType: "style" })), a.validate = typeof a.validate != "boolean" || a.validate;
            const p = this.map._requestManager.transformRequest(e, "Style");
            this._loadStyleRequest = new AbortController();
            const y = this._loadStyleRequest;
            s.j(p, this._loadStyleRequest).then(((x) => {
              this._loadStyleRequest = null, this._load(x.data, a, c);
            })).catch(((x) => {
              this._loadStyleRequest = null, x && !y.signal.aborted && this.fire(new s.k(x));
            }));
          }
          loadJSON(e, a = {}, c) {
            this.fire(new s.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), L.frameAsync(this._frameRequest).then((() => {
              this._frameRequest = null, a.validate = a.validate !== false, this._load(e, a, c);
            })).catch((() => {
            }));
          }
          loadEmpty() {
            this.fire(new s.l("dataloading", { dataType: "style" })), this._load(xp, { validate: false });
          }
          _load(e, a, c) {
            var p, y;
            let x = a.transformStyle ? a.transformStyle(c, e) : e;
            if (!a.validate || !Nl(this, s.z(x))) {
              x = Object.assign({}, x), this._loaded = true, this.stylesheet = x;
              for (const k in x.sources) this.addSource(k, x.sources[k], { validate: false });
              x.sprite ? this._loadSprite(x.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(x.glyphs), this._createLayers(), this.light = new vt(this.stylesheet.light), this._setProjectionInternal(((p = this.stylesheet.projection) === null || p === void 0 ? void 0 : p.type) || "mercator"), this.sky = new at(this.stylesheet.sky), this.map.setTerrain((y = this.stylesheet.terrain) !== null && y !== void 0 ? y : null), this.fire(new s.l("data", { dataType: "style" })), this.fire(new s.l("style.load"));
            }
          }
          _createLayers() {
            var e;
            const a = s.bI(this.stylesheet.layers);
            this.setGlobalState((e = this.stylesheet.state) !== null && e !== void 0 ? e : null), this.dispatcher.broadcast("SL", a), this._order = a.map(((c) => c.id)), this._layers = {}, this._serializedLayers = null;
            for (const c of a) {
              const p = s.bJ(c, this._globalState);
              p.setEventedParent(this, { layer: { id: c.id } }), this._layers[c.id] = p;
            }
          }
          _loadSprite(e, a = false, c = void 0) {
            let p;
            this.imageManager.setLoaded(false), this._spriteRequest = new AbortController(), (function(y, x, k, P) {
              return s._(this, void 0, void 0, (function* () {
                const E = J(y), D = k > 1 ? "@2x" : "", j = {}, $ = {};
                for (const { id: U, url: Y } of E) {
                  const se = x.transformRequest(Se(Y, D, ".json"), "SpriteJSON");
                  j[U] = s.j(se, P);
                  const le = x.transformRequest(Se(Y, D, ".png"), "SpriteImage");
                  $[U] = ee.getImage(le, P);
                }
                return yield Promise.all([...Object.values(j), ...Object.values($)]), (function(U, Y) {
                  return s._(this, void 0, void 0, (function* () {
                    const se = {};
                    for (const le in U) {
                      se[le] = {};
                      const ce = L.getImageCanvasContext((yield Y[le]).data), me = (yield U[le]).data;
                      for (const we in me) {
                        const { width: _e, height: Pe, x: Me, y: ye, sdf: Be, pixelRatio: Je, stretchX: We, stretchY: Ze, content: Qe, textFitWidth: It, textFitHeight: Pt } = me[we];
                        se[le][we] = { data: null, pixelRatio: Je, sdf: Be, stretchX: We, stretchY: Ze, content: Qe, textFitWidth: It, textFitHeight: Pt, spriteData: { width: _e, height: Pe, x: Me, y: ye, context: ce } };
                      }
                    }
                    return se;
                  }));
                })(j, $);
              }));
            })(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(((y) => {
              if (this._spriteRequest = null, y) for (const x in y) {
                this._spritesImagesIds[x] = [];
                const k = this._spritesImagesIds[x] ? this._spritesImagesIds[x].filter(((P) => !(P in y))) : [];
                for (const P of k) this.imageManager.removeImage(P), this._changedImages[P] = true;
                for (const P in y[x]) {
                  const E = x === "default" ? P : `${x}:${P}`;
                  this._spritesImagesIds[x].push(E), E in this.imageManager.images ? this.imageManager.updateImage(E, y[x][P], false) : this.imageManager.addImage(E, y[x][P]), a && (this._changedImages[E] = true);
                }
              }
            })).catch(((y) => {
              this._spriteRequest = null, p = y, this.fire(new s.k(p));
            })).finally((() => {
              this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), a && (this._changed = true), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", { dataType: "style" })), c && c(p);
            }));
          }
          _unloadSprite() {
            for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = true;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", { dataType: "style" }));
          }
          _validateLayer(e) {
            const a = this.sourceCaches[e.source];
            if (!a) return;
            const c = e.sourceLayer;
            if (!c) return;
            const p = a.getSource();
            (p.type === "geojson" || p.vectorLayerIds && p.vectorLayerIds.indexOf(c) === -1) && this.fire(new s.k(new Error(`Source layer "${c}" does not exist on source "${p.id}" as specified by style layer "${e.id}".`)));
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return false;
            for (const e in this.sourceCaches) if (!this.sourceCaches[e].loaded()) return false;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(e, a = false) {
            const c = this._serializedAllLayers();
            if (!e || e.length === 0) return Object.values(a ? s.bK(c) : c);
            const p = [];
            for (const y of e) if (c[y]) {
              const x = a ? s.bK(c[y]) : c[y];
              p.push(x);
            }
            return p;
          }
          _serializedAllLayers() {
            let e = this._serializedLayers;
            if (e) return e;
            e = this._serializedLayers = {};
            const a = Object.keys(this._layers);
            for (const c of a) {
              const p = this._layers[c];
              p.type !== "custom" && (e[c] = p.serialize());
            }
            return e;
          }
          hasTransitions() {
            var e, a, c;
            if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((a = this.sky) === null || a === void 0) && a.hasTransition() || !((c = this.projection) === null || c === void 0) && c.hasTransition()) return true;
            for (const p in this.sourceCaches) if (this.sourceCaches[p].hasTransition()) return true;
            for (const p in this._layers) if (this._layers[p].hasTransition()) return true;
            return false;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(e) {
            if (!this._loaded) return;
            const a = this._changed;
            if (a) {
              const p = Object.keys(this._updatedLayers), y = Object.keys(this._removedLayers);
              (p.length || y.length) && this._updateWorkerLayers(p, y);
              for (const x in this._updatedSources) {
                const k = this._updatedSources[x];
                if (k === "reload") this._reloadSource(x);
                else {
                  if (k !== "clear") throw new Error(`Invalid action ${k}`);
                  this._clearSource(x);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const x in this._updatedPaintProps) this._layers[x].updateTransitions(e);
              this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates();
            }
            const c = {};
            for (const p in this.sourceCaches) {
              const y = this.sourceCaches[p];
              c[p] = y.used, y.used = false;
            }
            for (const p of this._order) {
              const y = this._layers[p];
              y.recalculate(e, this._availableImages), !y.isHidden(e.zoom) && y.source && (this.sourceCaches[y.source].used = true);
            }
            for (const p in c) {
              const y = this.sourceCaches[p];
              !!c[p] != !!y.used && y.fire(new s.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: p }));
            }
            this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, a && this.fire(new s.l("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const e = Object.keys(this._changedImages);
            if (e.length) {
              for (const a in this.sourceCaches) this.sourceCaches[a].reloadTilesForDependencies(["icons", "patterns"], e);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = false;
            }
          }
          _updateWorkerLayers(e, a) {
            this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e, false), removedIds: a });
          }
          _resetUpdates() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
          }
          setState(e, a = {}) {
            var c;
            this._checkLoaded();
            const p = this.serialize();
            if (e = a.transformStyle ? a.transformStyle(p, e) : e, ((c = a.validate) === null || c === void 0 || c) && Nl(this, s.z(e))) return false;
            (e = s.bK(e)).layers = s.bI(e.layers);
            const y = s.bL(p, e), x = this._getOperationsToPerform(y);
            if (x.unimplemented.length > 0) throw new Error(`Unimplemented: ${x.unimplemented.join(", ")}.`);
            if (x.operations.length === 0) return false;
            for (const k of x.operations) k();
            return this.stylesheet = e, this._serializedLayers = null, true;
          }
          _getOperationsToPerform(e) {
            const a = [], c = [];
            for (const p of e) switch (p.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                a.push((() => this.addLayer.apply(this, p.args)));
                break;
              case "removeLayer":
                a.push((() => this.removeLayer.apply(this, p.args)));
                break;
              case "setPaintProperty":
                a.push((() => this.setPaintProperty.apply(this, p.args)));
                break;
              case "setLayoutProperty":
                a.push((() => this.setLayoutProperty.apply(this, p.args)));
                break;
              case "setFilter":
                a.push((() => this.setFilter.apply(this, p.args)));
                break;
              case "addSource":
                a.push((() => this.addSource.apply(this, p.args)));
                break;
              case "removeSource":
                a.push((() => this.removeSource.apply(this, p.args)));
                break;
              case "setLayerZoomRange":
                a.push((() => this.setLayerZoomRange.apply(this, p.args)));
                break;
              case "setLight":
                a.push((() => this.setLight.apply(this, p.args)));
                break;
              case "setGeoJSONSourceData":
                a.push((() => this.setGeoJSONSourceData.apply(this, p.args)));
                break;
              case "setGlyphs":
                a.push((() => this.setGlyphs.apply(this, p.args)));
                break;
              case "setSprite":
                a.push((() => this.setSprite.apply(this, p.args)));
                break;
              case "setTerrain":
                a.push((() => this.map.setTerrain.apply(this, p.args)));
                break;
              case "setSky":
                a.push((() => this.setSky.apply(this, p.args)));
                break;
              case "setProjection":
                this.setProjection.apply(this, p.args);
                break;
              case "setGlobalState":
                a.push((() => this.setGlobalState.apply(this, p.args)));
                break;
              case "setTransition":
                a.push((() => {
                }));
                break;
              default:
                c.push(p.command);
            }
            return { operations: a, unimplemented: c };
          }
          addImage(e, a) {
            if (this.getImage(e)) return this.fire(new s.k(new Error(`An image named "${e}" already exists.`)));
            this.imageManager.addImage(e, a), this._afterImageUpdated(e);
          }
          updateImage(e, a) {
            this.imageManager.updateImage(e, a);
          }
          getImage(e) {
            return this.imageManager.getImage(e);
          }
          removeImage(e) {
            if (!this.getImage(e)) return this.fire(new s.k(new Error(`An image named "${e}" does not exist.`)));
            this.imageManager.removeImage(e), this._afterImageUpdated(e);
          }
          _afterImageUpdated(e) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e] = true, this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(e, a, c = {}) {
            if (this._checkLoaded(), this.sourceCaches[e] !== void 0) throw new Error(`Source "${e}" already exists.`);
            if (!a.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(a).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(a.type) >= 0 && this._validate(s.z.source, `sources.${e}`, a, null, c)) return;
            this.map && this.map._collectResourceTiming && (a.collectResourceTiming = true);
            const p = this.sourceCaches[e] = new er(e, a, this.dispatcher);
            p.style = this, p.setEventedParent(this, (() => ({ isSourceLoaded: p.loaded(), source: p.serialize(), sourceId: e }))), p.onAdd(this.map), this._changed = true;
          }
          removeSource(e) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error("There is no source with this ID");
            for (const c in this._layers) if (this._layers[c].source === e) return this.fire(new s.k(new Error(`Source "${e}" cannot be removed while layer "${c}" is using it.`)));
            const a = this.sourceCaches[e];
            delete this.sourceCaches[e], delete this._updatedSources[e], a.fire(new s.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: e })), a.setEventedParent(null), a.onRemove(this.map), this._changed = true;
          }
          setGeoJSONSourceData(e, a) {
            if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error(`There is no source with this ID=${e}`);
            const c = this.sourceCaches[e].getSource();
            if (c.type !== "geojson") throw new Error(`geojsonSource.type is ${c.type}, which is !== 'geojson`);
            c.setData(a), this._changed = true;
          }
          getSource(e) {
            return this.sourceCaches[e] && this.sourceCaches[e].getSource();
          }
          addLayer(e, a, c = {}) {
            this._checkLoaded();
            const p = e.id;
            if (this.getLayer(p)) return void this.fire(new s.k(new Error(`Layer "${p}" already exists on this map.`)));
            let y;
            if (e.type === "custom") {
              if (Nl(this, s.bM(e))) return;
              y = s.bJ(e, this._globalState);
            } else {
              if ("source" in e && typeof e.source == "object" && (this.addSource(p, e.source), e = s.bK(e), e = s.e(e, { source: p })), this._validate(s.z.layer, `layers.${p}`, e, { arrayIndex: -1 }, c)) return;
              y = s.bJ(e, this._globalState), this._validateLayer(y), y.setEventedParent(this, { layer: { id: p } });
            }
            const x = a ? this._order.indexOf(a) : this._order.length;
            if (a && x === -1) this.fire(new s.k(new Error(`Cannot add layer "${p}" before non-existing layer "${a}".`)));
            else {
              if (this._order.splice(x, 0, p), this._layerOrderChanged = true, this._layers[p] = y, this._removedLayers[p] && y.source && y.type !== "custom") {
                const k = this._removedLayers[p];
                delete this._removedLayers[p], k.type !== y.type ? this._updatedSources[y.source] = "clear" : (this._updatedSources[y.source] = "reload", this.sourceCaches[y.source].pause());
              }
              this._updateLayer(y), y.onAdd && y.onAdd(this.map);
            }
          }
          moveLayer(e, a) {
            if (this._checkLoaded(), this._changed = true, !this._layers[e]) return void this.fire(new s.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
            if (e === a) return;
            const c = this._order.indexOf(e);
            this._order.splice(c, 1);
            const p = a ? this._order.indexOf(a) : this._order.length;
            a && p === -1 ? this.fire(new s.k(new Error(`Cannot move layer "${e}" before non-existing layer "${a}".`))) : (this._order.splice(p, 0, e), this._layerOrderChanged = true);
          }
          removeLayer(e) {
            this._checkLoaded();
            const a = this._layers[e];
            if (!a) return void this.fire(new s.k(new Error(`Cannot remove non-existing layer "${e}".`)));
            a.setEventedParent(null);
            const c = this._order.indexOf(e);
            this._order.splice(c, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e] = a, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], a.onRemove && a.onRemove(this.map);
          }
          getLayer(e) {
            return this._layers[e];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(e) {
            return e in this._layers;
          }
          setLayerZoomRange(e, a, c) {
            this._checkLoaded();
            const p = this.getLayer(e);
            p ? p.minzoom === a && p.maxzoom === c || (a != null && (p.minzoom = a), c != null && (p.maxzoom = c), this._updateLayer(p)) : this.fire(new s.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)));
          }
          setFilter(e, a, c = {}) {
            this._checkLoaded();
            const p = this.getLayer(e);
            if (p) {
              if (!s.bH(p.filter, a)) return a == null ? (p.setFilter(void 0), void this._updateLayer(p)) : void (this._validate(s.z.filter, `layers.${p.id}.filter`, a, null, c) || (p.setFilter(s.bK(a)), this._updateLayer(p)));
            } else this.fire(new s.k(new Error(`Cannot filter non-existing layer "${e}".`)));
          }
          getFilter(e) {
            return s.bK(this.getLayer(e).filter);
          }
          setLayoutProperty(e, a, c, p = {}) {
            this._checkLoaded();
            const y = this.getLayer(e);
            y ? s.bH(y.getLayoutProperty(a), c) || (y.setLayoutProperty(a, c, p), this._updateLayer(y)) : this.fire(new s.k(new Error(`Cannot style non-existing layer "${e}".`)));
          }
          getLayoutProperty(e, a) {
            const c = this.getLayer(e);
            if (c) return c.getLayoutProperty(a);
            this.fire(new s.k(new Error(`Cannot get style of non-existing layer "${e}".`)));
          }
          setPaintProperty(e, a, c, p = {}) {
            this._checkLoaded();
            const y = this.getLayer(e);
            y ? s.bH(y.getPaintProperty(a), c) || this._updatePaintProperty(y, a, c, p) : this.fire(new s.k(new Error(`Cannot style non-existing layer "${e}".`)));
          }
          _updatePaintProperty(e, a, c, p = {}) {
            e.setPaintProperty(a, c, p) && this._updateLayer(e), this._changed = true, this._updatedPaintProps[e.id] = true, this._serializedLayers = null;
          }
          getPaintProperty(e, a) {
            return this.getLayer(e).getPaintProperty(a);
          }
          setFeatureState(e, a) {
            this._checkLoaded();
            const c = e.source, p = e.sourceLayer, y = this.sourceCaches[c];
            if (y === void 0) return void this.fire(new s.k(new Error(`The source '${c}' does not exist in the map's style.`)));
            const x = y.getSource().type;
            x === "geojson" && p ? this.fire(new s.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : x !== "vector" || p ? (e.id === void 0 && this.fire(new s.k(new Error("The feature id parameter must be provided."))), y.setFeatureState(p, e.id, a)) : this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(e, a) {
            this._checkLoaded();
            const c = e.source, p = this.sourceCaches[c];
            if (p === void 0) return void this.fire(new s.k(new Error(`The source '${c}' does not exist in the map's style.`)));
            const y = p.getSource().type, x = y === "vector" ? e.sourceLayer : void 0;
            y !== "vector" || x ? a && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new s.k(new Error("A feature id is required to remove its specific state property."))) : p.removeFeatureState(x, e.id, a) : this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(e) {
            this._checkLoaded();
            const a = e.source, c = e.sourceLayer, p = this.sourceCaches[a];
            if (p !== void 0) return p.getSource().type !== "vector" || c ? (e.id === void 0 && this.fire(new s.k(new Error("The feature id parameter must be provided."))), p.getFeatureState(c, e.id)) : void this.fire(new s.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new s.k(new Error(`The source '${a}' does not exist in the map's style.`)));
          }
          getTransition() {
            return s.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded) return;
            const e = s.bN(this.sourceCaches, ((y) => y.serialize())), a = this._serializeByIds(this._order, true), c = this.map.getTerrain() || void 0, p = this.stylesheet;
            return s.bO({ version: p.version, name: p.name, metadata: p.metadata, light: p.light, sky: p.sky, center: p.center, zoom: p.zoom, bearing: p.bearing, pitch: p.pitch, sprite: p.sprite, glyphs: p.glyphs, transition: p.transition, projection: p.projection, sources: e, layers: a, terrain: c }, ((y) => y !== void 0));
          }
          _updateLayer(e) {
            this._updatedLayers[e.id] = true, e.source && !this._updatedSources[e.source] && this.sourceCaches[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.sourceCaches[e.source].pause()), this._serializedLayers = null, this._changed = true;
          }
          _flattenAndSortRenderedFeatures(e) {
            const a = (x) => this._layers[x].type === "fill-extrusion", c = {}, p = [];
            for (let x = this._order.length - 1; x >= 0; x--) {
              const k = this._order[x];
              if (a(k)) {
                c[k] = x;
                for (const P of e) {
                  const E = P[k];
                  if (E) for (const D of E) p.push(D);
                }
              }
            }
            p.sort(((x, k) => k.intersectionZ - x.intersectionZ));
            const y = [];
            for (let x = this._order.length - 1; x >= 0; x--) {
              const k = this._order[x];
              if (a(k)) for (let P = p.length - 1; P >= 0; P--) {
                const E = p[P].feature;
                if (c[E.layer.id] < x) break;
                y.push(E), p.pop();
              }
              else for (const P of e) {
                const E = P[k];
                if (E) for (const D of E) y.push(D.feature);
              }
            }
            return y;
          }
          queryRenderedFeatures(e, a, c) {
            a && a.filter && this._validate(s.z.filter, "queryRenderedFeatures.filter", a.filter, null, a);
            const p = {};
            if (a && a.layers) {
              if (!(Array.isArray(a.layers) || a.layers instanceof Set)) return this.fire(new s.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const E of a.layers) {
                const D = this._layers[E];
                if (!D) return this.fire(new s.k(new Error(`The layer '${E}' does not exist in the map's style and cannot be queried for features.`))), [];
                p[D.source] = true;
              }
            }
            const y = [];
            a.availableImages = this._availableImages;
            const x = this._serializedAllLayers(), k = a.layers instanceof Set ? a.layers : Array.isArray(a.layers) ? new Set(a.layers) : null, P = Object.assign(Object.assign({}, a), { layers: k, globalState: this._globalState });
            for (const E in this.sourceCaches) a.layers && !p[E] || y.push(tr(this.sourceCaches[E], this._layers, x, e, P, c, this.map.terrain ? (D, j, $) => this.map.terrain.getElevation(D, j, $) : void 0));
            return this.placement && y.push((function(E, D, j, $, U, Y, se) {
              const le = {}, ce = Y.queryRenderedSymbols($), me = [];
              for (const we of Object.keys(ce).map(Number)) me.push(se[we]);
              me.sort(xr);
              for (const we of me) {
                const _e = we.featureIndex.lookupSymbolFeatures(ce[we.bucketInstanceId], D, we.bucketIndex, we.sourceLayerIndex, { filterSpec: U.filter, globalState: U.globalState }, U.layers, U.availableImages, E);
                for (const Pe in _e) {
                  const Me = le[Pe] = le[Pe] || [], ye = _e[Pe];
                  ye.sort(((Be, Je) => {
                    const We = we.featureSortOrder;
                    if (We) {
                      const Ze = We.indexOf(Be.featureIndex);
                      return We.indexOf(Je.featureIndex) - Ze;
                    }
                    return Je.featureIndex - Be.featureIndex;
                  }));
                  for (const Be of ye) Me.push(Be);
                }
              }
              return (function(we, _e, Pe) {
                for (const Me in we) for (const ye of we[Me]) Mr(ye, Pe[_e[Me].source]);
                return we;
              })(le, E, j);
            })(this._layers, x, this.sourceCaches, e, P, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(y);
          }
          querySourceFeatures(e, a) {
            (a == null ? void 0 : a.filter) && this._validate(s.z.filter, "querySourceFeatures.filter", a.filter, null, a);
            const c = this.sourceCaches[e];
            return c ? (function(p, y) {
              const x = p.getRenderableIds().map(((E) => p.getTileByID(E))), k = [], P = {};
              for (let E = 0; E < x.length; E++) {
                const D = x[E], j = D.tileID.canonical.key;
                P[j] || (P[j] = true, D.querySourceFeatures(k, y));
              }
              return k;
            })(c, a ? Object.assign(Object.assign({}, a), { globalState: this._globalState }) : { globalState: this._globalState }) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(e, a = {}) {
            this._checkLoaded();
            const c = this.light.getLight();
            let p = false;
            for (const x in e) if (!s.bH(e[x], c[x])) {
              p = true;
              break;
            }
            if (!p) return;
            const y = { now: L.now(), transition: s.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(e, a), this.light.updateTransitions(y);
          }
          getProjection() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection;
          }
          setProjection(e) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e.type) return;
              this.projection.destroy(), delete this.projection;
            }
            this.stylesheet.projection = e, this._setProjectionInternal(e.type);
          }
          getSky() {
            var e;
            return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky;
          }
          setSky(e, a = {}) {
            this._checkLoaded();
            const c = this.getSky();
            let p = false;
            if (!e && !c) return;
            if (e && !c) p = true;
            else if (!e && c) p = true;
            else for (const x in e) if (!s.bH(e[x], c[x])) {
              p = true;
              break;
            }
            if (!p) return;
            const y = { now: L.now(), transition: s.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.stylesheet.sky = e, this.sky.setSky(e, a), this.sky.updateTransitions(y);
          }
          _setProjectionInternal(e) {
            const a = (function(c) {
              if (Array.isArray(c)) {
                const p = new $l({ type: c });
                return { projection: p, transform: new $s(), cameraHelper: new hh(p) };
              }
              switch (c) {
                case "mercator":
                  return { projection: new br(), transform: new Qr(), cameraHelper: new nn() };
                case "globe": {
                  const p = new $l({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                  return { projection: p, transform: new $s(), cameraHelper: new hh(p) };
                }
                case "vertical-perspective":
                  return { projection: new Ds(), transform: new Os(), cameraHelper: new on() };
                default:
                  return s.w(`Unknown projection name: ${c}. Falling back to mercator projection.`), { projection: new br(), transform: new Qr(), cameraHelper: new nn() };
              }
            })(e);
            this.projection = a.projection, this.map.migrateProjection(a.transform, a.cameraHelper);
            for (const c in this.sourceCaches) this.sourceCaches[c].reload();
          }
          _validate(e, a, c, p, y = {}) {
            return (!y || y.validate !== false) && Nl(this, e.call(s.z, s.e({ key: a, style: this.serialize(), value: c, styleSpec: s.v }, p)));
          }
          _remove(e = true) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), ri().off(tt, this._rtlPluginLoaded);
            for (const a in this._layers) this._layers[a].setEventedParent(null);
            for (const a in this.sourceCaches) {
              const c = this.sourceCaches[a];
              c.setEventedParent(null), c.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e);
          }
          _clearSource(e) {
            this.sourceCaches[e].clearTiles();
          }
          _reloadSource(e) {
            this.sourceCaches[e].resume(), this.sourceCaches[e].reload();
          }
          _updateSources(e) {
            for (const a in this.sourceCaches) this.sourceCaches[a].update(e, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const e in this.sourceCaches) this._reloadSource(e);
          }
          _updatePlacement(e, a, c, p, y = false) {
            let x = false, k = false;
            const P = {};
            for (const E of this._order) {
              const D = this._layers[E];
              if (D.type !== "symbol") continue;
              if (!P[D.source]) {
                const $ = this.sourceCaches[D.source];
                P[D.source] = $.getRenderableIds(true).map(((U) => $.getTileByID(U))).sort(((U, Y) => Y.tileID.overscaledZ - U.tileID.overscaledZ || (U.tileID.isLessThan(Y.tileID) ? -1 : 1)));
              }
              const j = this.crossTileSymbolIndex.addLayer(D, P[D.source], e.center.lng);
              x = x || j;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((y = y || this._layerOrderChanged || c === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(L.now(), e.zoom)) && (this.pauseablePlacement = new Es(e, this.map.terrain, this._order, y, a, c, p, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, P), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(L.now()), k = true), x && this.pauseablePlacement.placement.setStale()), k || x) for (const E of this._order) {
              const D = this._layers[E];
              D.type === "symbol" && this.placement.updateLayerOpacities(D, P[D.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(L.now());
          }
          _releaseSymbolFadeTiles() {
            for (const e in this.sourceCaches) this.sourceCaches[e].releaseSymbolFadeTiles();
          }
          getImages(e, a) {
            return s._(this, void 0, void 0, (function* () {
              const c = yield this.imageManager.getImages(a.icons);
              this._updateTilesForChangedImages();
              const p = this.sourceCaches[a.source];
              return p && p.setDependencies(a.tileID.key, a.type, a.icons), c;
            }));
          }
          getGlyphs(e, a) {
            return s._(this, void 0, void 0, (function* () {
              const c = yield this.glyphManager.getGlyphs(a.stacks), p = this.sourceCaches[a.source];
              return p && p.setDependencies(a.tileID.key, a.type, [""]), c;
            }));
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(e, a = {}) {
            this._checkLoaded(), e && this._validate(s.z.glyphs, "glyphs", e, null, a) || (this._glyphsDidChange = true, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e));
          }
          addSprite(e, a, c = {}, p) {
            this._checkLoaded();
            const y = [{ id: e, url: a }], x = [...J(this.stylesheet.sprite), ...y];
            this._validate(s.z.sprite, "sprite", x, null, c) || (this.stylesheet.sprite = x, this._loadSprite(y, true, p));
          }
          removeSprite(e) {
            this._checkLoaded();
            const a = J(this.stylesheet.sprite);
            if (a.find(((c) => c.id === e))) {
              if (this._spritesImagesIds[e]) for (const c of this._spritesImagesIds[e]) this.imageManager.removeImage(c), this._changedImages[c] = true;
              a.splice(a.findIndex(((c) => c.id === e)), 1), this.stylesheet.sprite = a.length > 0 ? a : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new s.l("data", { dataType: "style" }));
            } else this.fire(new s.k(new Error(`Sprite "${e}" doesn't exists on this map.`)));
          }
          getSprite() {
            return J(this.stylesheet.sprite);
          }
          setSprite(e, a = {}, c) {
            this._checkLoaded(), e && this._validate(s.z.sprite, "sprite", e, null, a) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, true, c) : (this._unloadSprite(), c && c(null)));
          }
        }
        var wp = s.aJ([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class Cp {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(e, a, c, p, y, x, k, P, E) {
            this.context = e;
            let D = this.boundPaintVertexBuffers.length !== p.length;
            for (let j = 0; !D && j < p.length; j++) this.boundPaintVertexBuffers[j] !== p[j] && (D = true);
            !this.vao || this.boundProgram !== a || this.boundLayoutVertexBuffer !== c || D || this.boundIndexBuffer !== y || this.boundVertexOffset !== x || this.boundDynamicVertexBuffer !== k || this.boundDynamicVertexBuffer2 !== P || this.boundDynamicVertexBuffer3 !== E ? this.freshBind(a, c, p, y, x, k, P, E) : (e.bindVertexArray.set(this.vao), k && k.bind(), y && y.dynamicDraw && y.bind(), P && P.bind(), E && E.bind());
          }
          freshBind(e, a, c, p, y, x, k, P) {
            const E = e.numAttributes, D = this.context, j = D.gl;
            this.vao && this.destroy(), this.vao = D.createVertexArray(), D.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = a, this.boundPaintVertexBuffers = c, this.boundIndexBuffer = p, this.boundVertexOffset = y, this.boundDynamicVertexBuffer = x, this.boundDynamicVertexBuffer2 = k, this.boundDynamicVertexBuffer3 = P, a.enableAttributes(j, e);
            for (const $ of c) $.enableAttributes(j, e);
            x && x.enableAttributes(j, e), k && k.enableAttributes(j, e), P && P.enableAttributes(j, e), a.bind(), a.setVertexAttribPointers(j, e, y);
            for (const $ of c) $.bind(), $.setVertexAttribPointers(j, e, y);
            x && (x.bind(), x.setVertexAttribPointers(j, e, y)), p && p.bind(), k && (k.bind(), k.setVertexAttribPointers(j, e, y)), P && (P.bind(), P.setVertexAttribPointers(j, e, y)), D.currentNumAttributes = E;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        const Vl = (v, e, a, c, p) => ({ u_texture: 0, u_ele_delta: v, u_fog_matrix: e, u_fog_color: a ? a.properties.get("fog-color") : s.bf.white, u_fog_ground_blend: a ? a.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: p ? 0 : a ? a.calculateFogBlendOpacity(c) : 0, u_horizon_color: a ? a.properties.get("horizon-color") : s.bf.white, u_horizon_fog_blend: a ? a.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: p ? 1 : 0 }), _c = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
        function ka(v) {
          const e = [];
          for (let a = 0; a < v.length; a++) {
            if (v[a] === null) continue;
            const c = v[a].split(" ");
            e.push(c.pop());
          }
          return e;
        }
        class yc {
          constructor(e, a, c, p, y, x, k, P, E = []) {
            const D = e.gl;
            this.program = D.createProgram();
            const j = ka(a.staticAttributes), $ = c ? c.getBinderAttributes() : [], U = j.concat($), Y = Dn.prelude.staticUniforms ? ka(Dn.prelude.staticUniforms) : [], se = k.staticUniforms ? ka(k.staticUniforms) : [], le = a.staticUniforms ? ka(a.staticUniforms) : [], ce = c ? c.getBinderUniforms() : [], me = Y.concat(se).concat(le).concat(ce), we = [];
            for (const We of me) we.indexOf(We) < 0 && we.push(We);
            const _e = c ? c.defines() : [];
            xo(D) && _e.unshift("#version 300 es"), y && _e.push("#define OVERDRAW_INSPECTOR;"), x && _e.push("#define TERRAIN3D;"), P && _e.push(P), E && _e.push(...E);
            let Pe = _e.concat(Dn.prelude.fragmentSource, k.fragmentSource, a.fragmentSource).join(`
`), Me = _e.concat(Dn.prelude.vertexSource, k.vertexSource, a.vertexSource).join(`
`);
            xo(D) || (Pe = (function(We) {
              return We.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
            })(Pe), Me = (function(We) {
              return We.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
            })(Me));
            const ye = D.createShader(D.FRAGMENT_SHADER);
            if (D.isContextLost()) return void (this.failedToCreate = true);
            if (D.shaderSource(ye, Pe), D.compileShader(ye), !D.getShaderParameter(ye, D.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${D.getShaderInfoLog(ye)}`);
            D.attachShader(this.program, ye);
            const Be = D.createShader(D.VERTEX_SHADER);
            if (D.isContextLost()) return void (this.failedToCreate = true);
            if (D.shaderSource(Be, Me), D.compileShader(Be), !D.getShaderParameter(Be, D.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${D.getShaderInfoLog(Be)}`);
            D.attachShader(this.program, Be), this.attributes = {};
            const Je = {};
            this.numAttributes = U.length;
            for (let We = 0; We < this.numAttributes; We++) U[We] && (D.bindAttribLocation(this.program, We, U[We]), this.attributes[U[We]] = We);
            if (D.linkProgram(this.program), !D.getProgramParameter(this.program, D.LINK_STATUS)) throw new Error(`Program failed to link: ${D.getProgramInfoLog(this.program)}`);
            D.deleteShader(Be), D.deleteShader(ye);
            for (let We = 0; We < we.length; We++) {
              const Ze = we[We];
              if (Ze && !Je[Ze]) {
                const Qe = D.getUniformLocation(this.program, Ze);
                Qe && (Je[Ze] = Qe);
              }
            }
            this.fixedUniforms = p(e, Je), this.terrainUniforms = ((We, Ze) => ({ u_depth: new s.bP(We, Ze.u_depth), u_terrain: new s.bP(We, Ze.u_terrain), u_terrain_dim: new s.bg(We, Ze.u_terrain_dim), u_terrain_matrix: new s.bR(We, Ze.u_terrain_matrix), u_terrain_unpack: new s.bS(We, Ze.u_terrain_unpack), u_terrain_exaggeration: new s.bg(We, Ze.u_terrain_exaggeration) }))(e, Je), this.projectionUniforms = ((We, Ze) => ({ u_projection_matrix: new s.bR(We, Ze.u_projection_matrix), u_projection_tile_mercator_coords: new s.bS(We, Ze.u_projection_tile_mercator_coords), u_projection_clipping_plane: new s.bS(We, Ze.u_projection_clipping_plane), u_projection_transition: new s.bg(We, Ze.u_projection_transition), u_projection_fallback_matrix: new s.bR(We, Ze.u_projection_fallback_matrix) }))(e, Je), this.binderUniforms = c ? c.getUniforms(e, Je) : [];
          }
          draw(e, a, c, p, y, x, k, P, E, D, j, $, U, Y, se, le, ce, me, we) {
            const _e = e.gl;
            if (this.failedToCreate) return;
            if (e.program.set(this.program), e.setDepthMode(c), e.setStencilMode(p), e.setColorMode(y), e.setCullFace(x), P) {
              e.activeTexture.set(_e.TEXTURE2), _e.bindTexture(_e.TEXTURE_2D, P.depthTexture), e.activeTexture.set(_e.TEXTURE3), _e.bindTexture(_e.TEXTURE_2D, P.texture);
              for (const Me in this.terrainUniforms) this.terrainUniforms[Me].set(P[Me]);
            }
            if (E) for (const Me in E) this.projectionUniforms[_c[Me]].set(E[Me]);
            if (k) for (const Me in this.fixedUniforms) this.fixedUniforms[Me].set(k[Me]);
            le && le.setUniforms(e, this.binderUniforms, Y, { zoom: se });
            let Pe = 0;
            switch (a) {
              case _e.LINES:
                Pe = 2;
                break;
              case _e.TRIANGLES:
                Pe = 3;
                break;
              case _e.LINE_STRIP:
                Pe = 1;
            }
            for (const Me of U.get()) {
              const ye = Me.vaos || (Me.vaos = {});
              (ye[D] || (ye[D] = new Cp())).bind(e, this, j, le ? le.getPaintVertexBuffers() : [], $, Me.vertexOffset, ce, me, we), _e.drawElements(a, Me.primitiveLength * Pe, _e.UNSIGNED_SHORT, Me.primitiveOffset * Pe * 2);
            }
          }
        }
        function Ul(v, e, a) {
          const c = 1 / s.aC(a, 1, e.transform.tileZoom), p = Math.pow(2, a.tileID.overscaledZ), y = a.tileSize * Math.pow(2, e.transform.tileZoom) / p, x = y * (a.tileID.canonical.x + a.tileID.wrap * p), k = y * a.tileID.canonical.y;
          return { u_image: 0, u_texsize: a.imageAtlasTexture.size, u_scale: [c, v.fromScale, v.toScale], u_fade: v.t, u_pixel_coord_upper: [x >> 16, k >> 16], u_pixel_coord_lower: [65535 & x, 65535 & k] };
        }
        const to = (v, e, a, c) => {
          const p = v.style.light, y = p.properties.get("position"), x = [y.x, y.y, y.z], k = s.bV();
          p.properties.get("anchor") === "viewport" && s.bW(k, v.transform.bearingInRadians), s.bX(x, x, k);
          const P = v.transform.transformLightDirection(x), E = p.properties.get("color");
          return { u_lightpos: x, u_lightpos_globe: P, u_lightintensity: p.properties.get("intensity"), u_lightcolor: [E.r, E.g, E.b], u_vertical_gradient: +e, u_opacity: a, u_fill_translate: c };
        }, Sp = (v, e, a, c, p, y, x) => s.e(to(v, e, a, c), Ul(y, v, x), { u_height_factor: -Math.pow(2, p.overscaledZ) / x.tileSize / 8 }), ql = (v, e, a, c) => s.e(Ul(e, v, a), { u_fill_translate: c }), js = (v, e) => ({ u_world: v, u_fill_translate: e }), Ns = (v, e, a, c, p) => s.e(ql(v, e, a, p), { u_world: c }), kp = (v, e, a, c, p) => {
          const y = v.transform;
          let x, k, P = 0;
          if (a.paint.get("circle-pitch-alignment") === "map") {
            const E = s.aC(e, 1, y.zoom);
            x = true, k = [E, E], P = E / (s.$ * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * p;
          } else x = false, k = y.pixelsToGLUnits;
          return { u_camera_to_center_distance: y.cameraToCenterDistance, u_scale_with_map: +(a.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +x, u_device_pixel_ratio: v.pixelRatio, u_extrude_scale: k, u_globe_extrude_scale: P, u_translate: c };
        }, Gl = (v) => ({ u_pixel_extrude_scale: [1 / v.width, 1 / v.height] }), Pp = (v) => ({ u_viewport_size: [v.width, v.height] }), Pa = (v, e = 1) => ({ u_color: v, u_overlay: 0, u_overlay_scale: e }), fh = (v, e, a, c) => {
          const p = s.aC(v, 1, e) / (s.$ * Math.pow(2, v.tileID.overscaledZ)) * 2 * Math.PI * c;
          return { u_extrude_scale: s.aC(v, 1, e), u_intensity: a, u_globe_extrude_scale: p };
        }, bc = (v, e, a, c) => {
          const p = s.L();
          s.bY(p, 0, v.width, v.height, 0, 0, 1);
          const y = v.context.gl;
          return { u_matrix: p, u_world: [y.drawingBufferWidth, y.drawingBufferHeight], u_image: a, u_color_ramp: c, u_opacity: e.paint.get("heatmap-opacity") };
        }, Tp = (v, e, a) => {
          const c = a.paint.get("hillshade-accent-color");
          let p;
          switch (a.paint.get("hillshade-method")) {
            case "basic":
              p = 4;
              break;
            case "combined":
              p = 1;
              break;
            case "igor":
              p = 2;
              break;
            case "multidirectional":
              p = 3;
              break;
            default:
              p = 0;
          }
          const y = a.getIlluminationProperties();
          for (let x = 0; x < y.directionRadians.length; x++) a.paint.get("hillshade-illumination-anchor") === "viewport" && (y.directionRadians[x] += v.transform.bearingInRadians);
          return { u_image: 0, u_latrange: xc(0, e.tileID), u_exaggeration: a.paint.get("hillshade-exaggeration"), u_altitudes: y.altitudeRadians, u_azimuths: y.directionRadians, u_accent: c, u_method: p, u_highlights: y.highlightColor, u_shadows: y.shadowColor };
        }, ph = (v, e) => {
          const a = e.stride, c = s.L();
          return s.bY(c, 0, s.$, -s.$, 0, 0, 1), s.M(c, c, [0, -s.$, 0]), { u_matrix: c, u_image: 1, u_dimension: [a, a], u_zoom: v.overscaledZ, u_unpack: e.getUnpackVector() };
        };
        function xc(v, e) {
          const a = Math.pow(2, e.canonical.z), c = e.canonical.y;
          return [new s.a1(0, c / a).toLngLat().lat, new s.a1(0, (c + 1) / a).toLngLat().lat];
        }
        const mh = (v, e, a = 0) => ({ u_image: 0, u_unpack: e.getUnpackVector(), u_dimension: [e.stride, e.stride], u_elevation_stops: 1, u_color_stops: 4, u_color_ramp_size: a, u_opacity: v.paint.get("color-relief-opacity") }), Wl = (v, e, a, c) => {
          const p = v.transform;
          return { u_translation: Cc(v, e, a), u_ratio: c / s.aC(e, 1, p.zoom), u_device_pixel_ratio: v.pixelRatio, u_units_to_pixels: [1 / p.pixelsToGLUnits[0], 1 / p.pixelsToGLUnits[1]] };
        }, gh = (v, e, a, c, p) => s.e(Wl(v, e, a, c), { u_image: 0, u_image_height: p }), vh = (v, e, a, c, p) => {
          const y = v.transform, x = wc(e, y);
          return { u_translation: Cc(v, e, a), u_texsize: e.imageAtlasTexture.size, u_ratio: c / s.aC(e, 1, y.zoom), u_device_pixel_ratio: v.pixelRatio, u_image: 0, u_scale: [x, p.fromScale, p.toScale], u_fade: p.t, u_units_to_pixels: [1 / y.pixelsToGLUnits[0], 1 / y.pixelsToGLUnits[1]] };
        }, Ta = (v, e, a, c, p, y) => {
          const x = v.lineAtlas, k = wc(e, v.transform), P = a.layout.get("line-cap") === "round", E = x.getDash(p.from, P), D = x.getDash(p.to, P), j = E.width * y.fromScale, $ = D.width * y.toScale;
          return s.e(Wl(v, e, a, c), { u_patternscale_a: [k / j, -E.height / 2], u_patternscale_b: [k / $, -D.height / 2], u_sdfgamma: x.width / (256 * Math.min(j, $) * v.pixelRatio) / 2, u_image: 0, u_tex_y_a: E.y, u_tex_y_b: D.y, u_mix: y.t });
        };
        function wc(v, e) {
          return 1 / s.aC(v, 1, e.tileZoom);
        }
        function Cc(v, e, a) {
          return s.aD(v.transform, e, a.paint.get("line-translate"), a.paint.get("line-translate-anchor"));
        }
        const Vs = (v, e, a, c, p) => {
          return { u_tl_parent: v, u_scale_parent: e, u_buffer_scale: 1, u_fade_t: a.mix, u_opacity: a.opacity * c.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: c.paint.get("raster-brightness-min"), u_brightness_high: c.paint.get("raster-brightness-max"), u_saturation_factor: (x = c.paint.get("raster-saturation"), x > 0 ? 1 - 1 / (1.001 - x) : -x), u_contrast_factor: (y = c.paint.get("raster-contrast"), y > 0 ? 1 / (1 - y) : 1 + y), u_spin_weights: Ip(c.paint.get("raster-hue-rotate")), u_coords_top: [p[0].x, p[0].y, p[1].x, p[1].y], u_coords_bottom: [p[3].x, p[3].y, p[2].x, p[2].y] };
          var y, x;
        };
        function Ip(v) {
          v *= Math.PI / 180;
          const e = Math.sin(v), a = Math.cos(v);
          return [(2 * a + 1) / 3, (-Math.sqrt(3) * e - a + 1) / 3, (Math.sqrt(3) * e - a + 1) / 3];
        }
        const Us = (v, e, a, c, p, y, x, k, P, E, D, j, $) => {
          const U = x.transform;
          return { u_is_size_zoom_constant: +(v === "constant" || v === "source"), u_is_size_feature_constant: +(v === "constant" || v === "camera"), u_size_t: e ? e.uSizeT : 0, u_size: e ? e.uSize : 0, u_camera_to_center_distance: U.cameraToCenterDistance, u_pitch: U.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +a, u_aspect_ratio: U.width / U.height, u_fade_change: x.options.fadeDuration ? x.symbolFadeChange : 1, u_label_plane_matrix: k, u_coord_matrix: P, u_is_text: +D, u_pitch_with_map: +c, u_is_along_line: p, u_is_variable_anchor: y, u_texsize: j, u_texture: 0, u_translation: E, u_pitched_scale: $ };
        }, _h = (v, e, a, c, p, y, x, k, P, E, D, j, $, U) => {
          const Y = x.transform;
          return s.e(Us(v, e, a, c, p, y, x, k, P, E, D, j, U), { u_gamma_scale: c ? Math.cos(Y.pitch * Math.PI / 180) * Y.cameraToCenterDistance : 1, u_device_pixel_ratio: x.pixelRatio, u_is_halo: 1 });
        }, Mp = (v, e, a, c, p, y, x, k, P, E, D, j, $) => s.e(_h(v, e, a, c, p, y, x, k, P, E, true, D, 0, $), { u_texsize_icon: j, u_texture_icon: 1 }), yh = (v, e) => ({ u_opacity: v, u_color: e }), bh = (v, e, a, c, p) => s.e((function(y, x, k, P) {
          const E = k.imageManager.getPattern(y.from.toString()), D = k.imageManager.getPattern(y.to.toString()), { width: j, height: $ } = k.imageManager.getPixelSize(), U = Math.pow(2, P.tileID.overscaledZ), Y = P.tileSize * Math.pow(2, k.transform.tileZoom) / U, se = Y * (P.tileID.canonical.x + P.tileID.wrap * U), le = Y * P.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: E.tl, u_pattern_br_a: E.br, u_pattern_tl_b: D.tl, u_pattern_br_b: D.br, u_texsize: [j, $], u_mix: x.t, u_pattern_size_a: E.displaySize, u_pattern_size_b: D.displaySize, u_scale_a: x.fromScale, u_scale_b: x.toScale, u_tile_units_to_pixels: 1 / s.aC(P, 1, k.transform.tileZoom), u_pixel_coord_upper: [se >> 16, le >> 16], u_pixel_coord_lower: [65535 & se, 65535 & le] };
        })(a, p, e, c), { u_opacity: v }), Sc = (v, e) => {
        }, kc = { fillExtrusion: (v, e) => ({ u_lightpos: new s.bT(v, e.u_lightpos), u_lightpos_globe: new s.bT(v, e.u_lightpos_globe), u_lightintensity: new s.bg(v, e.u_lightintensity), u_lightcolor: new s.bT(v, e.u_lightcolor), u_vertical_gradient: new s.bg(v, e.u_vertical_gradient), u_opacity: new s.bg(v, e.u_opacity), u_fill_translate: new s.bU(v, e.u_fill_translate) }), fillExtrusionPattern: (v, e) => ({ u_lightpos: new s.bT(v, e.u_lightpos), u_lightpos_globe: new s.bT(v, e.u_lightpos_globe), u_lightintensity: new s.bg(v, e.u_lightintensity), u_lightcolor: new s.bT(v, e.u_lightcolor), u_vertical_gradient: new s.bg(v, e.u_vertical_gradient), u_height_factor: new s.bg(v, e.u_height_factor), u_opacity: new s.bg(v, e.u_opacity), u_fill_translate: new s.bU(v, e.u_fill_translate), u_image: new s.bP(v, e.u_image), u_texsize: new s.bU(v, e.u_texsize), u_pixel_coord_upper: new s.bU(v, e.u_pixel_coord_upper), u_pixel_coord_lower: new s.bU(v, e.u_pixel_coord_lower), u_scale: new s.bT(v, e.u_scale), u_fade: new s.bg(v, e.u_fade) }), fill: (v, e) => ({ u_fill_translate: new s.bU(v, e.u_fill_translate) }), fillPattern: (v, e) => ({ u_image: new s.bP(v, e.u_image), u_texsize: new s.bU(v, e.u_texsize), u_pixel_coord_upper: new s.bU(v, e.u_pixel_coord_upper), u_pixel_coord_lower: new s.bU(v, e.u_pixel_coord_lower), u_scale: new s.bT(v, e.u_scale), u_fade: new s.bg(v, e.u_fade), u_fill_translate: new s.bU(v, e.u_fill_translate) }), fillOutline: (v, e) => ({ u_world: new s.bU(v, e.u_world), u_fill_translate: new s.bU(v, e.u_fill_translate) }), fillOutlinePattern: (v, e) => ({ u_world: new s.bU(v, e.u_world), u_image: new s.bP(v, e.u_image), u_texsize: new s.bU(v, e.u_texsize), u_pixel_coord_upper: new s.bU(v, e.u_pixel_coord_upper), u_pixel_coord_lower: new s.bU(v, e.u_pixel_coord_lower), u_scale: new s.bT(v, e.u_scale), u_fade: new s.bg(v, e.u_fade), u_fill_translate: new s.bU(v, e.u_fill_translate) }), circle: (v, e) => ({ u_camera_to_center_distance: new s.bg(v, e.u_camera_to_center_distance), u_scale_with_map: new s.bP(v, e.u_scale_with_map), u_pitch_with_map: new s.bP(v, e.u_pitch_with_map), u_extrude_scale: new s.bU(v, e.u_extrude_scale), u_device_pixel_ratio: new s.bg(v, e.u_device_pixel_ratio), u_globe_extrude_scale: new s.bg(v, e.u_globe_extrude_scale), u_translate: new s.bU(v, e.u_translate) }), collisionBox: (v, e) => ({ u_pixel_extrude_scale: new s.bU(v, e.u_pixel_extrude_scale) }), collisionCircle: (v, e) => ({ u_viewport_size: new s.bU(v, e.u_viewport_size) }), debug: (v, e) => ({ u_color: new s.bQ(v, e.u_color), u_overlay: new s.bP(v, e.u_overlay), u_overlay_scale: new s.bg(v, e.u_overlay_scale) }), depth: Sc, clippingMask: Sc, heatmap: (v, e) => ({ u_extrude_scale: new s.bg(v, e.u_extrude_scale), u_intensity: new s.bg(v, e.u_intensity), u_globe_extrude_scale: new s.bg(v, e.u_globe_extrude_scale) }), heatmapTexture: (v, e) => ({ u_matrix: new s.bR(v, e.u_matrix), u_world: new s.bU(v, e.u_world), u_image: new s.bP(v, e.u_image), u_color_ramp: new s.bP(v, e.u_color_ramp), u_opacity: new s.bg(v, e.u_opacity) }), hillshade: (v, e) => ({ u_image: new s.bP(v, e.u_image), u_latrange: new s.bU(v, e.u_latrange), u_exaggeration: new s.bg(v, e.u_exaggeration), u_altitudes: new s.b_(v, e.u_altitudes), u_azimuths: new s.b_(v, e.u_azimuths), u_accent: new s.bQ(v, e.u_accent), u_method: new s.bP(v, e.u_method), u_shadows: new s.bZ(v, e.u_shadows), u_highlights: new s.bZ(v, e.u_highlights) }), hillshadePrepare: (v, e) => ({ u_matrix: new s.bR(v, e.u_matrix), u_image: new s.bP(v, e.u_image), u_dimension: new s.bU(v, e.u_dimension), u_zoom: new s.bg(v, e.u_zoom), u_unpack: new s.bS(v, e.u_unpack) }), colorRelief: (v, e) => ({ u_image: new s.bP(v, e.u_image), u_unpack: new s.bS(v, e.u_unpack), u_dimension: new s.bU(v, e.u_dimension), u_elevation_stops: new s.bP(v, e.u_elevation_stops), u_color_stops: new s.bP(v, e.u_color_stops), u_color_ramp_size: new s.bP(v, e.u_color_ramp_size), u_opacity: new s.bg(v, e.u_opacity) }), line: (v, e) => ({ u_translation: new s.bU(v, e.u_translation), u_ratio: new s.bg(v, e.u_ratio), u_device_pixel_ratio: new s.bg(v, e.u_device_pixel_ratio), u_units_to_pixels: new s.bU(v, e.u_units_to_pixels) }), lineGradient: (v, e) => ({ u_translation: new s.bU(v, e.u_translation), u_ratio: new s.bg(v, e.u_ratio), u_device_pixel_ratio: new s.bg(v, e.u_device_pixel_ratio), u_units_to_pixels: new s.bU(v, e.u_units_to_pixels), u_image: new s.bP(v, e.u_image), u_image_height: new s.bg(v, e.u_image_height) }), linePattern: (v, e) => ({ u_translation: new s.bU(v, e.u_translation), u_texsize: new s.bU(v, e.u_texsize), u_ratio: new s.bg(v, e.u_ratio), u_device_pixel_ratio: new s.bg(v, e.u_device_pixel_ratio), u_image: new s.bP(v, e.u_image), u_units_to_pixels: new s.bU(v, e.u_units_to_pixels), u_scale: new s.bT(v, e.u_scale), u_fade: new s.bg(v, e.u_fade) }), lineSDF: (v, e) => ({ u_translation: new s.bU(v, e.u_translation), u_ratio: new s.bg(v, e.u_ratio), u_device_pixel_ratio: new s.bg(v, e.u_device_pixel_ratio), u_units_to_pixels: new s.bU(v, e.u_units_to_pixels), u_patternscale_a: new s.bU(v, e.u_patternscale_a), u_patternscale_b: new s.bU(v, e.u_patternscale_b), u_sdfgamma: new s.bg(v, e.u_sdfgamma), u_image: new s.bP(v, e.u_image), u_tex_y_a: new s.bg(v, e.u_tex_y_a), u_tex_y_b: new s.bg(v, e.u_tex_y_b), u_mix: new s.bg(v, e.u_mix) }), raster: (v, e) => ({ u_tl_parent: new s.bU(v, e.u_tl_parent), u_scale_parent: new s.bg(v, e.u_scale_parent), u_buffer_scale: new s.bg(v, e.u_buffer_scale), u_fade_t: new s.bg(v, e.u_fade_t), u_opacity: new s.bg(v, e.u_opacity), u_image0: new s.bP(v, e.u_image0), u_image1: new s.bP(v, e.u_image1), u_brightness_low: new s.bg(v, e.u_brightness_low), u_brightness_high: new s.bg(v, e.u_brightness_high), u_saturation_factor: new s.bg(v, e.u_saturation_factor), u_contrast_factor: new s.bg(v, e.u_contrast_factor), u_spin_weights: new s.bT(v, e.u_spin_weights), u_coords_top: new s.bS(v, e.u_coords_top), u_coords_bottom: new s.bS(v, e.u_coords_bottom) }), symbolIcon: (v, e) => ({ u_is_size_zoom_constant: new s.bP(v, e.u_is_size_zoom_constant), u_is_size_feature_constant: new s.bP(v, e.u_is_size_feature_constant), u_size_t: new s.bg(v, e.u_size_t), u_size: new s.bg(v, e.u_size), u_camera_to_center_distance: new s.bg(v, e.u_camera_to_center_distance), u_pitch: new s.bg(v, e.u_pitch), u_rotate_symbol: new s.bP(v, e.u_rotate_symbol), u_aspect_ratio: new s.bg(v, e.u_aspect_ratio), u_fade_change: new s.bg(v, e.u_fade_change), u_label_plane_matrix: new s.bR(v, e.u_label_plane_matrix), u_coord_matrix: new s.bR(v, e.u_coord_matrix), u_is_text: new s.bP(v, e.u_is_text), u_pitch_with_map: new s.bP(v, e.u_pitch_with_map), u_is_along_line: new s.bP(v, e.u_is_along_line), u_is_variable_anchor: new s.bP(v, e.u_is_variable_anchor), u_texsize: new s.bU(v, e.u_texsize), u_texture: new s.bP(v, e.u_texture), u_translation: new s.bU(v, e.u_translation), u_pitched_scale: new s.bg(v, e.u_pitched_scale) }), symbolSDF: (v, e) => ({ u_is_size_zoom_constant: new s.bP(v, e.u_is_size_zoom_constant), u_is_size_feature_constant: new s.bP(v, e.u_is_size_feature_constant), u_size_t: new s.bg(v, e.u_size_t), u_size: new s.bg(v, e.u_size), u_camera_to_center_distance: new s.bg(v, e.u_camera_to_center_distance), u_pitch: new s.bg(v, e.u_pitch), u_rotate_symbol: new s.bP(v, e.u_rotate_symbol), u_aspect_ratio: new s.bg(v, e.u_aspect_ratio), u_fade_change: new s.bg(v, e.u_fade_change), u_label_plane_matrix: new s.bR(v, e.u_label_plane_matrix), u_coord_matrix: new s.bR(v, e.u_coord_matrix), u_is_text: new s.bP(v, e.u_is_text), u_pitch_with_map: new s.bP(v, e.u_pitch_with_map), u_is_along_line: new s.bP(v, e.u_is_along_line), u_is_variable_anchor: new s.bP(v, e.u_is_variable_anchor), u_texsize: new s.bU(v, e.u_texsize), u_texture: new s.bP(v, e.u_texture), u_gamma_scale: new s.bg(v, e.u_gamma_scale), u_device_pixel_ratio: new s.bg(v, e.u_device_pixel_ratio), u_is_halo: new s.bP(v, e.u_is_halo), u_translation: new s.bU(v, e.u_translation), u_pitched_scale: new s.bg(v, e.u_pitched_scale) }), symbolTextAndIcon: (v, e) => ({ u_is_size_zoom_constant: new s.bP(v, e.u_is_size_zoom_constant), u_is_size_feature_constant: new s.bP(v, e.u_is_size_feature_constant), u_size_t: new s.bg(v, e.u_size_t), u_size: new s.bg(v, e.u_size), u_camera_to_center_distance: new s.bg(v, e.u_camera_to_center_distance), u_pitch: new s.bg(v, e.u_pitch), u_rotate_symbol: new s.bP(v, e.u_rotate_symbol), u_aspect_ratio: new s.bg(v, e.u_aspect_ratio), u_fade_change: new s.bg(v, e.u_fade_change), u_label_plane_matrix: new s.bR(v, e.u_label_plane_matrix), u_coord_matrix: new s.bR(v, e.u_coord_matrix), u_is_text: new s.bP(v, e.u_is_text), u_pitch_with_map: new s.bP(v, e.u_pitch_with_map), u_is_along_line: new s.bP(v, e.u_is_along_line), u_is_variable_anchor: new s.bP(v, e.u_is_variable_anchor), u_texsize: new s.bU(v, e.u_texsize), u_texsize_icon: new s.bU(v, e.u_texsize_icon), u_texture: new s.bP(v, e.u_texture), u_texture_icon: new s.bP(v, e.u_texture_icon), u_gamma_scale: new s.bg(v, e.u_gamma_scale), u_device_pixel_ratio: new s.bg(v, e.u_device_pixel_ratio), u_is_halo: new s.bP(v, e.u_is_halo), u_translation: new s.bU(v, e.u_translation), u_pitched_scale: new s.bg(v, e.u_pitched_scale) }), background: (v, e) => ({ u_opacity: new s.bg(v, e.u_opacity), u_color: new s.bQ(v, e.u_color) }), backgroundPattern: (v, e) => ({ u_opacity: new s.bg(v, e.u_opacity), u_image: new s.bP(v, e.u_image), u_pattern_tl_a: new s.bU(v, e.u_pattern_tl_a), u_pattern_br_a: new s.bU(v, e.u_pattern_br_a), u_pattern_tl_b: new s.bU(v, e.u_pattern_tl_b), u_pattern_br_b: new s.bU(v, e.u_pattern_br_b), u_texsize: new s.bU(v, e.u_texsize), u_mix: new s.bg(v, e.u_mix), u_pattern_size_a: new s.bU(v, e.u_pattern_size_a), u_pattern_size_b: new s.bU(v, e.u_pattern_size_b), u_scale_a: new s.bg(v, e.u_scale_a), u_scale_b: new s.bg(v, e.u_scale_b), u_pixel_coord_upper: new s.bU(v, e.u_pixel_coord_upper), u_pixel_coord_lower: new s.bU(v, e.u_pixel_coord_lower), u_tile_units_to_pixels: new s.bg(v, e.u_tile_units_to_pixels) }), terrain: (v, e) => ({ u_texture: new s.bP(v, e.u_texture), u_ele_delta: new s.bg(v, e.u_ele_delta), u_fog_matrix: new s.bR(v, e.u_fog_matrix), u_fog_color: new s.bQ(v, e.u_fog_color), u_fog_ground_blend: new s.bg(v, e.u_fog_ground_blend), u_fog_ground_blend_opacity: new s.bg(v, e.u_fog_ground_blend_opacity), u_horizon_color: new s.bQ(v, e.u_horizon_color), u_horizon_fog_blend: new s.bg(v, e.u_horizon_fog_blend), u_is_globe_mode: new s.bg(v, e.u_is_globe_mode) }), terrainDepth: (v, e) => ({ u_ele_delta: new s.bg(v, e.u_ele_delta) }), terrainCoords: (v, e) => ({ u_texture: new s.bP(v, e.u_texture), u_terrain_coords_id: new s.bg(v, e.u_terrain_coords_id), u_ele_delta: new s.bg(v, e.u_ele_delta) }), projectionErrorMeasurement: (v, e) => ({ u_input: new s.bg(v, e.u_input), u_output_expected: new s.bg(v, e.u_output_expected) }), atmosphere: (v, e) => ({ u_sun_pos: new s.bT(v, e.u_sun_pos), u_atmosphere_blend: new s.bg(v, e.u_atmosphere_blend), u_globe_position: new s.bT(v, e.u_globe_position), u_globe_radius: new s.bg(v, e.u_globe_radius), u_inv_proj_matrix: new s.bR(v, e.u_inv_proj_matrix) }), sky: (v, e) => ({ u_sky_color: new s.bQ(v, e.u_sky_color), u_horizon_color: new s.bQ(v, e.u_horizon_color), u_horizon: new s.bU(v, e.u_horizon), u_horizon_normal: new s.bU(v, e.u_horizon_normal), u_sky_horizon_blend: new s.bg(v, e.u_sky_horizon_blend), u_sky_blend: new s.bg(v, e.u_sky_blend) }) };
        class xh {
          constructor(e, a, c) {
            this.context = e;
            const p = e.gl;
            this.buffer = p.createBuffer(), this.dynamicDraw = !!c, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), p.bufferData(p.ELEMENT_ARRAY_BUFFER, a.arrayBuffer, this.dynamicDraw ? p.DYNAMIC_DRAW : p.STATIC_DRAW), this.dynamicDraw || delete a.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(e) {
            const a = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), a.bufferSubData(a.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const Zl = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class Fo {
          constructor(e, a, c, p) {
            this.length = a.length, this.attributes = c, this.itemSize = a.bytesPerElement, this.dynamicDraw = p, this.context = e;
            const y = e.gl;
            this.buffer = y.createBuffer(), e.bindVertexBuffer.set(this.buffer), y.bufferData(y.ARRAY_BUFFER, a.arrayBuffer, this.dynamicDraw ? y.DYNAMIC_DRAW : y.STATIC_DRAW), this.dynamicDraw || delete a.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(e) {
            if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
            const a = this.context.gl;
            this.bind(), a.bufferSubData(a.ARRAY_BUFFER, 0, e.arrayBuffer);
          }
          enableAttributes(e, a) {
            for (let c = 0; c < this.attributes.length; c++) {
              const p = a.attributes[this.attributes[c].name];
              p !== void 0 && e.enableVertexAttribArray(p);
            }
          }
          setVertexAttribPointers(e, a, c) {
            for (let p = 0; p < this.attributes.length; p++) {
              const y = this.attributes[p], x = a.attributes[y.name];
              x !== void 0 && e.vertexAttribPointer(x, y.components, e[Zl[y.type]], false, this.itemSize, y.offset + this.itemSize * (c || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class Fr {
          constructor(e) {
            this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(e) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Pc extends Fr {
          getDefault() {
            return s.bf.transparent;
          }
          set(e) {
            const a = this.current;
            (e.r !== a.r || e.g !== a.g || e.b !== a.b || e.a !== a.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = false);
          }
        }
        class Tc extends Fr {
          getDefault() {
            return 1;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = false);
          }
        }
        class wh extends Fr {
          getDefault() {
            return 0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = false);
          }
        }
        class Ic extends Fr {
          getDefault() {
            return [true, true, true, true];
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || e[3] !== a[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = false);
          }
        }
        class Ia extends Fr {
          getDefault() {
            return true;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = false);
          }
        }
        class Mc extends Fr {
          getDefault() {
            return 255;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = false);
          }
        }
        class Ep extends Fr {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(e) {
            const a = this.current;
            (e.func !== a.func || e.ref !== a.ref || e.mask !== a.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = false);
          }
        }
        class Rp extends Fr {
          getDefault() {
            const e = this.gl;
            return [e.KEEP, e.KEEP, e.KEEP];
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = false);
          }
        }
        class Ap extends Fr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.STENCIL_TEST) : a.disable(a.STENCIL_TEST), this.current = e, this.dirty = false;
          }
        }
        class Dp extends Fr {
          getDefault() {
            return [0, 1];
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = false);
          }
        }
        class Ch extends Fr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.DEPTH_TEST) : a.disable(a.DEPTH_TEST), this.current = e, this.dirty = false;
          }
        }
        class zp extends Fr {
          getDefault() {
            return this.gl.LESS;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = false);
          }
        }
        class Sh extends Fr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.BLEND) : a.disable(a.BLEND), this.current = e, this.dirty = false;
          }
        }
        class Hl extends Fr {
          getDefault() {
            const e = this.gl;
            return [e.ONE, e.ZERO];
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = false);
          }
        }
        class Xl extends Fr {
          getDefault() {
            return s.bf.transparent;
          }
          set(e) {
            const a = this.current;
            (e.r !== a.r || e.g !== a.g || e.b !== a.b || e.a !== a.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = false);
          }
        }
        class Yl extends Fr {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = false);
          }
        }
        class Ec extends Fr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            e ? a.enable(a.CULL_FACE) : a.disable(a.CULL_FACE), this.current = e, this.dirty = false;
          }
        }
        class Ma extends Fr {
          getDefault() {
            return this.gl.BACK;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = false);
          }
        }
        class qs extends Fr {
          getDefault() {
            return this.gl.CCW;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = false);
          }
        }
        class is extends Fr {
          getDefault() {
            return null;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = false);
          }
        }
        class Gn extends Fr {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(e) {
            (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = false);
          }
        }
        class kh extends Fr {
          getDefault() {
            const e = this.gl;
            return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
          }
          set(e) {
            const a = this.current;
            (e[0] !== a[0] || e[1] !== a[1] || e[2] !== a[2] || e[3] !== a[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = false);
          }
        }
        class Ph extends Fr {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindFramebuffer(a.FRAMEBUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class Rc extends Fr {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindRenderbuffer(a.RENDERBUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class Ea extends Fr {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindTexture(a.TEXTURE_2D, e), this.current = e, this.dirty = false;
          }
        }
        class Kl extends Fr {
          getDefault() {
            return null;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.bindBuffer(a.ARRAY_BUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class Jl extends Fr {
          getDefault() {
            return null;
          }
          set(e) {
            const a = this.gl;
            a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class Gs extends Fr {
          getDefault() {
            return null;
          }
          set(e) {
            var a;
            if (e === this.current && !this.dirty) return;
            const c = this.gl;
            xo(c) ? c.bindVertexArray(e) : (a = c.getExtension("OES_vertex_array_object")) === null || a === void 0 || a.bindVertexArrayOES(e), this.current = e, this.dirty = false;
          }
        }
        class Ql extends Fr {
          getDefault() {
            return 4;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = false;
          }
        }
        class Th extends Fr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = false;
          }
        }
        class ns extends Fr {
          getDefault() {
            return false;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            const a = this.gl;
            a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = false;
          }
        }
        class ra extends Fr {
          constructor(e, a) {
            super(e), this.context = e, this.parent = a;
          }
          getDefault() {
            return null;
          }
        }
        class Ih extends ra {
          setDirty() {
            this.dirty = true;
          }
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, e, 0), this.current = e, this.dirty = false;
          }
        }
        class Ac extends ra {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, e), this.current = e, this.dirty = false;
          }
        }
        class Sr extends ra {
          set(e) {
            if (e === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const a = this.gl;
            a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, e), this.current = e, this.dirty = false;
          }
        }
        const Ws = "Framebuffer is not complete";
        class Fp {
          constructor(e, a, c, p, y) {
            this.context = e, this.width = a, this.height = c;
            const x = e.gl, k = this.framebuffer = x.createFramebuffer();
            if (this.colorAttachment = new Ih(e, k), p) this.depthAttachment = y ? new Sr(e, k) : new Ac(e, k);
            else if (y) throw new Error("Stencil cannot be set without depth");
            if (x.checkFramebufferStatus(x.FRAMEBUFFER) !== x.FRAMEBUFFER_COMPLETE) throw new Error(Ws);
          }
          destroy() {
            const e = this.context.gl, a = this.colorAttachment.get();
            if (a && e.deleteTexture(a), this.depthAttachment) {
              const c = this.depthAttachment.get();
              c && e.deleteRenderbuffer(c);
            }
            e.deleteFramebuffer(this.framebuffer);
          }
        }
        class Mh {
          constructor(e) {
            var a, c;
            if (this.gl = e, this.clearColor = new Pc(this), this.clearDepth = new Tc(this), this.clearStencil = new wh(this), this.colorMask = new Ic(this), this.depthMask = new Ia(this), this.stencilMask = new Mc(this), this.stencilFunc = new Ep(this), this.stencilOp = new Rp(this), this.stencilTest = new Ap(this), this.depthRange = new Dp(this), this.depthTest = new Ch(this), this.depthFunc = new zp(this), this.blend = new Sh(this), this.blendFunc = new Hl(this), this.blendColor = new Xl(this), this.blendEquation = new Yl(this), this.cullFace = new Ec(this), this.cullFaceSide = new Ma(this), this.frontFace = new qs(this), this.program = new is(this), this.activeTexture = new Gn(this), this.viewport = new kh(this), this.bindFramebuffer = new Ph(this), this.bindRenderbuffer = new Rc(this), this.bindTexture = new Ea(this), this.bindVertexBuffer = new Kl(this), this.bindElementBuffer = new Jl(this), this.bindVertexArray = new Gs(this), this.pixelStoreUnpack = new Ql(this), this.pixelStoreUnpackPremultiplyAlpha = new Th(this), this.pixelStoreUnpackFlipY = new ns(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), xo(e)) {
              this.HALF_FLOAT = e.HALF_FLOAT;
              const p = e.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (a = e.RGBA16F) !== null && a !== void 0 ? a : p == null ? void 0 : p.RGBA16F_EXT, this.RGB16F = (c = e.RGB16F) !== null && c !== void 0 ? c : p == null ? void 0 : p.RGB16F_EXT, e.getExtension("EXT_color_buffer_float");
            } else {
              e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear");
              const p = e.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = p == null ? void 0 : p.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(e, a) {
            return new xh(this, e, a);
          }
          createVertexBuffer(e, a, c) {
            return new Fo(this, e, a, c);
          }
          createRenderbuffer(e, a, c) {
            const p = this.gl, y = p.createRenderbuffer();
            return this.bindRenderbuffer.set(y), p.renderbufferStorage(p.RENDERBUFFER, e, a, c), this.bindRenderbuffer.set(null), y;
          }
          createFramebuffer(e, a, c, p) {
            return new Fp(this, e, a, c, p);
          }
          clear({ color: e, depth: a, stencil: c }) {
            const p = this.gl;
            let y = 0;
            e && (y |= p.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([true, true, true, true])), a !== void 0 && (y |= p.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(a), this.depthMask.set(true)), c !== void 0 && (y |= p.STENCIL_BUFFER_BIT, this.clearStencil.set(c), this.stencilMask.set(255)), p.clear(y);
          }
          setCullFace(e) {
            e.enable === false ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
          }
          setDepthMode(e) {
            e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(true), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(false);
          }
          setStencilMode(e) {
            e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(true), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(e) {
            s.bH(e.blendFunction, li.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);
          }
          createVertexArray() {
            var e;
            return xo(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES();
          }
          deleteVertexArray(e) {
            var a;
            return xo(this.gl) ? this.gl.deleteVertexArray(e) : (a = this.gl.getExtension("OES_vertex_array_object")) === null || a === void 0 ? void 0 : a.deleteVertexArrayOES(e);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        let ia;
        function Eh(v, e, a, c, p) {
          const y = v.context, x = v.transform, k = y.gl, P = v.useProgram("collisionBox"), E = [];
          let D = 0, j = 0;
          for (let ce = 0; ce < c.length; ce++) {
            const me = c[ce], we = e.getTile(me).getBucket(a);
            if (!we) continue;
            const _e = p ? we.textCollisionBox : we.iconCollisionBox, Pe = we.collisionCircleArray;
            Pe.length > 0 && (E.push({ circleArray: Pe, circleOffset: j, coord: me }), D += Pe.length / 4, j = D), _e && P.draw(y, k.LINES, mr.disabled, Rr.disabled, v.colorModeForRenderPass(), nr.disabled, Gl(v.transform), v.style.map.terrain && v.style.map.terrain.getTerrainData(me), x.getProjectionData({ overscaledTileID: me, applyGlobeMatrix: true, applyTerrainMatrix: true }), a.id, _e.layoutVertexBuffer, _e.indexBuffer, _e.segments, null, v.transform.zoom, null, null, _e.collisionVertexBuffer);
          }
          if (!p || !E.length) return;
          const $ = v.useProgram("collisionCircle"), U = new s.b$();
          U.resize(4 * D), U._trim();
          let Y = 0;
          for (const ce of E) for (let me = 0; me < ce.circleArray.length / 4; me++) {
            const we = 4 * me, _e = ce.circleArray[we + 0], Pe = ce.circleArray[we + 1], Me = ce.circleArray[we + 2], ye = ce.circleArray[we + 3];
            U.emplace(Y++, _e, Pe, Me, ye, 0), U.emplace(Y++, _e, Pe, Me, ye, 1), U.emplace(Y++, _e, Pe, Me, ye, 2), U.emplace(Y++, _e, Pe, Me, ye, 3);
          }
          (!ia || ia.length < 2 * D) && (ia = (function(ce) {
            const me = 2 * ce, we = new s.c1();
            we.resize(me), we._trim();
            for (let _e = 0; _e < me; _e++) {
              const Pe = 6 * _e;
              we.uint16[Pe + 0] = 4 * _e + 0, we.uint16[Pe + 1] = 4 * _e + 1, we.uint16[Pe + 2] = 4 * _e + 2, we.uint16[Pe + 3] = 4 * _e + 2, we.uint16[Pe + 4] = 4 * _e + 3, we.uint16[Pe + 5] = 4 * _e + 0;
            }
            return we;
          })(D));
          const se = y.createIndexBuffer(ia, true), le = y.createVertexBuffer(U, s.c0.members, true);
          for (const ce of E) {
            const me = Pp(v.transform);
            $.draw(y, k.TRIANGLES, mr.disabled, Rr.disabled, v.colorModeForRenderPass(), nr.disabled, me, v.style.map.terrain && v.style.map.terrain.getTerrainData(ce.coord), null, a.id, le, se, s.aM.simpleSegment(0, 2 * ce.circleOffset, ce.circleArray.length, ce.circleArray.length / 2), null, v.transform.zoom, null, null, null);
          }
          le.destroy(), se.destroy();
        }
        const Lp = s.ag(new Float32Array(16));
        function Rh(v, e, a, c, p, y) {
          const { horizontalAlign: x, verticalAlign: k } = s.aH(v);
          return new s.P((-(x - 0.5) * e / p + c[0]) * y, (-(k - 0.5) * a / p + c[1]) * y);
        }
        function Bp(v, e, a, c, p, y) {
          const x = e.tileAnchorPoint.add(new s.P(e.translation[0], e.translation[1]));
          if (e.pitchWithMap) {
            let k = c.mult(y);
            a || (k = k.rotate(-p));
            const P = x.add(k);
            return Wr(P.x, P.y, e.pitchedLabelPlaneMatrix, e.getElevation).point;
          }
          if (a) {
            const k = ni(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(v), P = Math.atan(k.y / k.x) + (k.x < 0 ? Math.PI : 0);
            return v.add(c.rotate(P));
          }
          return v.add(c);
        }
        function Dc(v, e, a, c, p, y, x, k, P, E, D, j) {
          const $ = v.text.placedSymbolArray, U = v.text.dynamicLayoutVertexArray, Y = v.icon.dynamicLayoutVertexArray, se = {};
          U.clear();
          for (let le = 0; le < $.length; le++) {
            const ce = $.get(le), me = ce.hidden || !ce.crossTileID || v.allowVerticalPlacement && !ce.placedOrientation ? null : c[ce.crossTileID];
            if (me) {
              const we = new s.P(ce.anchorX, ce.anchorY), _e = { getElevation: j, width: p.width, height: p.height, pitchedLabelPlaneMatrix: y, pitchWithMap: a, transform: p, tileAnchorPoint: we, translation: E, unwrappedTileID: D }, Pe = a ? tn(we.x, we.y, _e) : ni(we.x, we.y, _e), Me = ge(p.cameraToCenterDistance, Pe.signedDistanceFromCamera);
              let ye = s.ap(v.textSizeData, k, ce) * Me / s.aB;
              a && (ye *= v.tilePixelRatio / x);
              const { width: Be, height: Je, anchor: We, textOffset: Ze, textBoxScale: Qe } = me, It = Rh(We, Be, Je, Ze, Qe, ye), Pt = p.getPitchedTextCorrection(we.x + E[0], we.y + E[1], D), pt = Bp(Pe.point, _e, e, It, -p.bearingInRadians, Pt), Vt = v.allowVerticalPlacement && ce.placedOrientation === s.ao.vertical ? Math.PI / 2 : 0;
              for (let _r = 0; _r < ce.numGlyphs; _r++) s.av(U, pt, Vt);
              P && ce.associatedIconIndex >= 0 && (se[ce.associatedIconIndex] = { shiftedAnchor: pt, angle: Vt });
            } else kn(ce.numGlyphs, U);
          }
          if (P) {
            Y.clear();
            const le = v.icon.placedSymbolArray;
            for (let ce = 0; ce < le.length; ce++) {
              const me = le.get(ce);
              if (me.hidden) kn(me.numGlyphs, Y);
              else {
                const we = se[ce];
                if (we) for (let _e = 0; _e < me.numGlyphs; _e++) s.av(Y, we.shiftedAnchor, we.angle);
                else kn(me.numGlyphs, Y);
              }
            }
            v.icon.dynamicLayoutVertexBuffer.updateData(Y);
          }
          v.text.dynamicLayoutVertexBuffer.updateData(U);
        }
        function eu(v, e, a) {
          return a.iconsInText && e ? "symbolTextAndIcon" : v ? "symbolSDF" : "symbolIcon";
        }
        function Zs(v, e, a, c, p, y, x, k, P, E, D, j, $) {
          const U = v.context, Y = U.gl, se = v.transform, le = k === "map", ce = P === "map", me = k !== "viewport" && a.layout.get("symbol-placement") !== "point", we = le && !ce && !me, _e = !a.layout.get("symbol-sort-key").isConstant();
          let Pe = false;
          const Me = v.getDepthModeForSublayer(0, mr.ReadOnly), ye = a._unevaluatedLayout.hasValue("text-variable-anchor") || a._unevaluatedLayout.hasValue("text-variable-anchor-offset"), Be = [], Je = se.getCircleRadiusCorrection();
          for (const We of c) {
            const Ze = e.getTile(We), Qe = Ze.getBucket(a);
            if (!Qe) continue;
            const It = p ? Qe.text : Qe.icon;
            if (!It || !It.segments.get().length || !It.hasVisibleVertices) continue;
            const Pt = It.programConfigurations.get(a.id), pt = p || Qe.sdfIcons, Vt = p ? Qe.textSizeData : Qe.iconSizeData, _r = ce || se.pitch !== 0, Or = v.useProgram(eu(pt, p, Qe), Pt), hi = s.an(Vt, se.zoom), ei = v.style.map.terrain && v.style.map.terrain.getTerrainData(We);
            let Hr, fi, oi, ti, Ar = [0, 0], Fi = null;
            if (p) fi = Ze.glyphAtlasTexture, oi = Y.LINEAR, Hr = Ze.glyphAtlasTexture.size, Qe.iconsInText && (Ar = Ze.imageAtlasTexture.size, Fi = Ze.imageAtlasTexture, ti = _r || v.options.rotating || v.options.zooming || Vt.kind === "composite" || Vt.kind === "camera" ? Y.LINEAR : Y.NEAREST);
            else {
              const ai = a.layout.get("icon-size").constantOr(0) !== 1 || Qe.iconsNeedLinear;
              fi = Ze.imageAtlasTexture, oi = pt || v.options.rotating || v.options.zooming || ai || _r ? Y.LINEAR : Y.NEAREST, Hr = Ze.imageAtlasTexture.size;
            }
            const Ei = s.aC(Ze, 1, v.transform.zoom), _n = ii(le, v.transform, Ei), oa = s.L();
            s.aq(oa, _n);
            const aa = gr(ce, le, v.transform, Ei), oo = s.aD(se, Ze, y, x), Na = se.getProjectionData({ overscaledTileID: We, applyGlobeMatrix: !$, applyTerrainMatrix: true }), il = ye && Qe.hasTextData(), yu = a.layout.get("icon-text-fit") !== "none" && il && Qe.hasIconData();
            if (me) {
              const ai = v.style.map.terrain ? (Bn, Li) => v.style.map.terrain.getElevation(We, Bn, Li) : null, ki = a.layout.get("text-rotation-alignment") === "map";
              Bt(Qe, v, p, _n, oa, ce, E, ki, We.toUnwrapped(), se.width, se.height, oo, ai);
            }
            const sa = p && ye || yu, yn = me || sa ? Lp : ce ? _n : v.transform.clipSpaceToPixelsMatrix, Bo = pt && a.paint.get(p ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let Oo;
            Oo = pt ? Qe.iconsInText ? Mp(Vt.kind, hi, we, ce, me, sa, v, yn, aa, oo, Hr, Ar, Je) : _h(Vt.kind, hi, we, ce, me, sa, v, yn, aa, oo, p, Hr, 0, Je) : Us(Vt.kind, hi, we, ce, me, sa, v, yn, aa, oo, p, Hr, Je);
            const la = { program: Or, buffers: It, uniformValues: Oo, projectionData: Na, atlasTexture: fi, atlasTextureIcon: Fi, atlasInterpolation: oi, atlasInterpolationIcon: ti, isSDF: pt, hasHalo: Bo };
            if (_e && Qe.canOverlap) {
              Pe = true;
              const ai = It.segments.get();
              for (const ki of ai) Be.push({ segments: new s.aM([ki]), sortKey: ki.sortKey, state: la, terrainData: ei });
            } else Be.push({ segments: It.segments, sortKey: 0, state: la, terrainData: ei });
          }
          Pe && Be.sort(((We, Ze) => We.sortKey - Ze.sortKey));
          for (const We of Be) {
            const Ze = We.state;
            if (U.activeTexture.set(Y.TEXTURE0), Ze.atlasTexture.bind(Ze.atlasInterpolation, Y.CLAMP_TO_EDGE), Ze.atlasTextureIcon && (U.activeTexture.set(Y.TEXTURE1), Ze.atlasTextureIcon && Ze.atlasTextureIcon.bind(Ze.atlasInterpolationIcon, Y.CLAMP_TO_EDGE)), Ze.isSDF) {
              const Qe = Ze.uniformValues;
              Ze.hasHalo && (Qe.u_is_halo = 1, Hs(Ze.buffers, We.segments, a, v, Ze.program, Me, D, j, Qe, Ze.projectionData, We.terrainData)), Qe.u_is_halo = 0;
            }
            Hs(Ze.buffers, We.segments, a, v, Ze.program, Me, D, j, Ze.uniformValues, Ze.projectionData, We.terrainData);
          }
        }
        function Hs(v, e, a, c, p, y, x, k, P, E, D) {
          const j = c.context;
          p.draw(j, j.gl.TRIANGLES, y, x, k, nr.backCCW, P, D, E, a.id, v.layoutVertexBuffer, v.indexBuffer, e, a.paint, c.transform.zoom, v.programConfigurations.get(a.id), v.dynamicLayoutVertexBuffer, v.opacityVertexBuffer);
        }
        function zc(v, e, a, c, p) {
          const y = v.context, x = y.gl, k = Rr.disabled, P = new li([x.ONE, x.ONE], s.bf.transparent, [true, true, true, true]), E = e.getBucket(a);
          if (!E) return;
          const D = c.key;
          let j = a.heatmapFbos.get(D);
          j || (j = Xs(y, e.tileSize, e.tileSize), a.heatmapFbos.set(D, j)), y.bindFramebuffer.set(j.framebuffer), y.viewport.set([0, 0, e.tileSize, e.tileSize]), y.clear({ color: s.bf.transparent });
          const $ = E.programConfigurations.get(a.id), U = v.useProgram("heatmap", $, !p), Y = v.transform.getProjectionData({ overscaledTileID: e.tileID, applyGlobeMatrix: true, applyTerrainMatrix: true }), se = v.style.map.terrain.getTerrainData(c);
          U.draw(y, x.TRIANGLES, mr.disabled, k, P, nr.disabled, fh(e, v.transform.zoom, a.paint.get("heatmap-intensity"), 1), se, Y, a.id, E.layoutVertexBuffer, E.indexBuffer, E.segments, a.paint, v.transform.zoom, $);
        }
        function Ah(v, e, a, c, p) {
          const y = v.context, x = y.gl, k = v.transform;
          y.setColorMode(v.colorModeForRenderPass());
          const P = Ys(y, e), E = a.key, D = e.heatmapFbos.get(E);
          if (!D) return;
          y.activeTexture.set(x.TEXTURE0), x.bindTexture(x.TEXTURE_2D, D.colorAttachment.get()), y.activeTexture.set(x.TEXTURE1), P.bind(x.LINEAR, x.CLAMP_TO_EDGE);
          const j = k.getProjectionData({ overscaledTileID: a, applyTerrainMatrix: p, applyGlobeMatrix: !c });
          v.useProgram("heatmapTexture").draw(y, x.TRIANGLES, mr.disabled, Rr.disabled, v.colorModeForRenderPass(), nr.disabled, bc(v, e, 0, 1), null, j, e.id, v.rasterBoundsBuffer, v.quadTriangleIndexBuffer, v.rasterBoundsSegments, e.paint, k.zoom), D.destroy(), e.heatmapFbos.delete(E);
        }
        function Xs(v, e, a) {
          var c, p;
          const y = v.gl, x = y.createTexture();
          y.bindTexture(y.TEXTURE_2D, x), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_S, y.CLAMP_TO_EDGE), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_T, y.CLAMP_TO_EDGE), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MIN_FILTER, y.LINEAR), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MAG_FILTER, y.LINEAR);
          const k = (c = v.HALF_FLOAT) !== null && c !== void 0 ? c : y.UNSIGNED_BYTE, P = (p = v.RGBA16F) !== null && p !== void 0 ? p : y.RGBA;
          y.texImage2D(y.TEXTURE_2D, 0, P, e, a, 0, y.RGBA, k, null);
          const E = v.createFramebuffer(e, a, false, false);
          return E.colorAttachment.set(x), E;
        }
        function Ys(v, e) {
          return e.colorRampTexture || (e.colorRampTexture = new s.T(v, e.colorRamp, v.gl.RGBA)), e.colorRampTexture;
        }
        function Ks(v, e, a, c, p) {
          if (!a || !c || !c.imageAtlas) return;
          const y = c.imageAtlas.patternPositions;
          let x = y[a.to.toString()], k = y[a.from.toString()];
          if (!x && k && (x = k), !k && x && (k = x), !x || !k) {
            const P = p.getPaintProperty(e);
            x = y[P], k = y[P];
          }
          x && k && v.setConstantPatternPositions(x, k);
        }
        function Ra(v, e, a, c, p, y, x, k) {
          const P = v.context.gl, E = "fill-pattern", D = a.paint.get(E), j = D && D.constantOr(1), $ = a.getCrossfadeParameters();
          let U, Y, se, le, ce;
          const me = v.transform, we = a.paint.get("fill-translate"), _e = a.paint.get("fill-translate-anchor");
          x ? (Y = j && !a.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", U = P.LINES) : (Y = j ? "fillPattern" : "fill", U = P.TRIANGLES);
          const Pe = D.constantOr(null);
          for (const Me of c) {
            const ye = e.getTile(Me);
            if (j && !ye.patternsLoaded()) continue;
            const Be = ye.getBucket(a);
            if (!Be) continue;
            const Je = Be.programConfigurations.get(a.id), We = v.useProgram(Y, Je), Ze = v.style.map.terrain && v.style.map.terrain.getTerrainData(Me);
            j && (v.context.activeTexture.set(P.TEXTURE0), ye.imageAtlasTexture.bind(P.LINEAR, P.CLAMP_TO_EDGE), Je.updatePaintBuffers($)), Ks(Je, E, Pe, ye, a);
            const Qe = me.getProjectionData({ overscaledTileID: Me, applyGlobeMatrix: !k, applyTerrainMatrix: true }), It = s.aD(me, ye, we, _e);
            if (x) {
              le = Be.indexBuffer2, ce = Be.segments2;
              const pt = [P.drawingBufferWidth, P.drawingBufferHeight];
              se = Y === "fillOutlinePattern" && j ? Ns(v, $, ye, pt, It) : js(pt, It);
            } else le = Be.indexBuffer, ce = Be.segments, se = j ? ql(v, $, ye, It) : { u_fill_translate: It };
            const Pt = v.stencilModeForClipping(Me);
            We.draw(v.context, U, p, Pt, y, nr.backCCW, se, Ze, Qe, a.id, Be.layoutVertexBuffer, le, ce, a.paint, v.transform.zoom, Je);
          }
        }
        function Js(v, e, a, c, p, y, x, k) {
          const P = v.context, E = P.gl, D = "fill-extrusion-pattern", j = a.paint.get(D), $ = j.constantOr(1), U = a.getCrossfadeParameters(), Y = a.paint.get("fill-extrusion-opacity"), se = j.constantOr(null), le = v.transform;
          for (const ce of c) {
            const me = e.getTile(ce), we = me.getBucket(a);
            if (!we) continue;
            const _e = v.style.map.terrain && v.style.map.terrain.getTerrainData(ce), Pe = we.programConfigurations.get(a.id), Me = v.useProgram($ ? "fillExtrusionPattern" : "fillExtrusion", Pe);
            $ && (v.context.activeTexture.set(E.TEXTURE0), me.imageAtlasTexture.bind(E.LINEAR, E.CLAMP_TO_EDGE), Pe.updatePaintBuffers(U));
            const ye = le.getProjectionData({ overscaledTileID: ce, applyGlobeMatrix: !k, applyTerrainMatrix: true });
            Ks(Pe, D, se, me, a);
            const Be = s.aD(le, me, a.paint.get("fill-extrusion-translate"), a.paint.get("fill-extrusion-translate-anchor")), Je = a.paint.get("fill-extrusion-vertical-gradient"), We = $ ? Sp(v, Je, Y, Be, ce, U, me) : to(v, Je, Y, Be);
            Me.draw(P, P.gl.TRIANGLES, p, y, x, nr.backCCW, We, _e, ye, a.id, we.layoutVertexBuffer, we.indexBuffer, we.segments, a.paint, v.transform.zoom, Pe, v.style.map.terrain && we.centroidVertexBuffer);
          }
        }
        function Fc(v, e, a, c, p, y, x, k, P) {
          var E;
          const D = v.style.projection, j = v.context, $ = v.transform, U = j.gl, Y = [`#define NUM_ILLUMINATION_SOURCES ${a.paint.get("hillshade-highlight-color").values.length}`], se = v.useProgram("hillshade", null, false, Y), le = !v.options.moving;
          for (const ce of c) {
            const me = e.getTile(ce), we = me.fbo;
            if (!we) continue;
            const _e = D.getMeshFromTileID(j, ce.canonical, k, true, "raster"), Pe = (E = v.style.map.terrain) === null || E === void 0 ? void 0 : E.getTerrainData(ce);
            j.activeTexture.set(U.TEXTURE0), U.bindTexture(U.TEXTURE_2D, we.colorAttachment.get());
            const Me = $.getProjectionData({ overscaledTileID: ce, aligned: le, applyGlobeMatrix: !P, applyTerrainMatrix: true });
            se.draw(j, U.TRIANGLES, y, p[ce.overscaledZ], x, nr.backCCW, Tp(v, me, a), Pe, Me, a.id, _e.vertexBuffer, _e.indexBuffer, _e.segments);
          }
        }
        function Aa(v, e, a, c, p, y, x, k, P) {
          var E;
          const D = v.style.projection, j = v.context, $ = v.transform, U = j.gl, Y = v.useProgram("colorRelief"), se = !v.options.moving;
          let le = true, ce = 0;
          for (const me of c) {
            const we = e.getTile(me), _e = we.dem;
            if (le) {
              const We = U.getParameter(U.MAX_TEXTURE_SIZE), { elevationTexture: Ze, colorTexture: Qe } = a.getColorRampTextures(j, We, _e.getUnpackVector());
              j.activeTexture.set(U.TEXTURE1), Ze.bind(U.NEAREST, U.CLAMP_TO_EDGE), j.activeTexture.set(U.TEXTURE4), Qe.bind(U.LINEAR, U.CLAMP_TO_EDGE), le = false, ce = Ze.size[0];
            }
            if (!_e || !_e.data) continue;
            const Pe = _e.stride, Me = _e.getPixels();
            if (j.activeTexture.set(U.TEXTURE0), j.pixelStoreUnpackPremultiplyAlpha.set(false), we.demTexture = we.demTexture || v.getTileTexture(Pe), we.demTexture) {
              const We = we.demTexture;
              We.update(Me, { premultiply: false }), We.bind(U.LINEAR, U.CLAMP_TO_EDGE);
            } else we.demTexture = new s.T(j, Me, U.RGBA, { premultiply: false }), we.demTexture.bind(U.LINEAR, U.CLAMP_TO_EDGE);
            const ye = D.getMeshFromTileID(j, me.canonical, k, true, "raster"), Be = (E = v.style.map.terrain) === null || E === void 0 ? void 0 : E.getTerrainData(me), Je = $.getProjectionData({ overscaledTileID: me, aligned: se, applyGlobeMatrix: !P, applyTerrainMatrix: true });
            Y.draw(j, U.TRIANGLES, y, p[me.overscaledZ], x, nr.backCCW, mh(a, we.dem, ce), Be, Je, a.id, ye.vertexBuffer, ye.indexBuffer, ye.segments);
          }
        }
        const Lc = [new s.P(0, 0), new s.P(s.$, 0), new s.P(s.$, s.$), new s.P(0, s.$)];
        function Qs(v, e, a, c, p, y, x, k, P = false, E = false) {
          const D = c[c.length - 1].overscaledZ, j = v.context, $ = j.gl, U = v.useProgram("raster"), Y = v.transform, se = v.style.projection, le = v.colorModeForRenderPass(), ce = !v.options.moving;
          for (const me of c) {
            const we = v.getDepthModeForSublayer(me.overscaledZ - D, a.paint.get("raster-opacity") === 1 ? mr.ReadWrite : mr.ReadOnly, $.LESS), _e = e.getTile(me);
            _e.registerFadeDuration(a.paint.get("raster-fade-duration"));
            const Pe = e.findLoadedParent(me, 0), Me = e.findLoadedSibling(me), ye = tu(_e, Pe || Me || null, e, a, v.transform, v.style.map.terrain);
            let Be, Je;
            const We = a.paint.get("raster-resampling") === "nearest" ? $.NEAREST : $.LINEAR;
            j.activeTexture.set($.TEXTURE0), _e.texture.bind(We, $.CLAMP_TO_EDGE, $.LINEAR_MIPMAP_NEAREST), j.activeTexture.set($.TEXTURE1), Pe ? (Pe.texture.bind(We, $.CLAMP_TO_EDGE, $.LINEAR_MIPMAP_NEAREST), Be = Math.pow(2, Pe.tileID.overscaledZ - _e.tileID.overscaledZ), Je = [_e.tileID.canonical.x * Be % 1, _e.tileID.canonical.y * Be % 1]) : _e.texture.bind(We, $.CLAMP_TO_EDGE, $.LINEAR_MIPMAP_NEAREST), _e.texture.useMipmap && j.extTextureFilterAnisotropic && v.transform.pitch > 20 && $.texParameterf($.TEXTURE_2D, j.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, j.extTextureFilterAnisotropicMax);
            const Ze = v.style.map.terrain && v.style.map.terrain.getTerrainData(me), Qe = Y.getProjectionData({ overscaledTileID: me, aligned: ce, applyGlobeMatrix: !E, applyTerrainMatrix: true }), It = Vs(Je || [0, 0], Be || 1, ye, a, k), Pt = se.getMeshFromTileID(j, me.canonical, y, x, "raster");
            U.draw(j, $.TRIANGLES, we, p ? p[me.overscaledZ] : Rr.disabled, le, P ? nr.frontCCW : nr.backCCW, It, Ze, Qe, a.id, Pt.vertexBuffer, Pt.indexBuffer, Pt.segments);
          }
        }
        function tu(v, e, a, c, p, y) {
          const x = c.paint.get("raster-fade-duration");
          if (!y && x > 0) {
            const k = L.now(), P = (k - v.timeAdded) / x, E = e ? (k - e.timeAdded) / x : -1, D = a.getSource(), j = xt(p, { tileSize: D.tileSize, roundZoom: D.roundZoom }), $ = !e || Math.abs(e.tileID.overscaledZ - j) > Math.abs(v.tileID.overscaledZ - j), U = $ && v.refreshedUponExpiration ? 1 : s.ah($ ? P : 1 - E, 0, 1);
            return v.refreshedUponExpiration && P >= 1 && (v.refreshedUponExpiration = false), e ? { opacity: 1, mix: 1 - U } : { opacity: U, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        const Bc = new s.bf(1, 0, 0, 1), Dh = new s.bf(0, 1, 0, 1), zh = new s.bf(0, 0, 1, 1), ru = new s.bf(1, 0, 1, 1), Oc = new s.bf(0, 1, 1, 1);
        function Fh(v, e, a, c) {
          ci(v, 0, e + a / 2, v.transform.width, a, c);
        }
        function $c(v, e, a, c) {
          ci(v, e - a / 2, 0, a, v.transform.height, c);
        }
        function ci(v, e, a, c, p, y) {
          const x = v.context, k = x.gl;
          k.enable(k.SCISSOR_TEST), k.scissor(e * v.pixelRatio, a * v.pixelRatio, c * v.pixelRatio, p * v.pixelRatio), x.clear({ color: y }), k.disable(k.SCISSOR_TEST);
        }
        function Da(v, e, a) {
          const c = v.context, p = c.gl, y = v.useProgram("debug"), x = mr.disabled, k = Rr.disabled, P = v.colorModeForRenderPass(), E = "$debug", D = v.style.map.terrain && v.style.map.terrain.getTerrainData(a);
          c.activeTexture.set(p.TEXTURE0);
          const j = e.getTileByID(a.key).latestRawTileData, $ = Math.floor((j && j.byteLength || 0) / 1024), U = e.getTile(a).tileSize, Y = 512 / Math.min(U, 512) * (a.overscaledZ / v.transform.zoom) * 0.5;
          let se = a.canonical.toString();
          a.overscaledZ !== a.canonical.z && (se += ` => ${a.overscaledZ}`), (function(ce, me) {
            ce.initDebugOverlayCanvas();
            const we = ce.debugOverlayCanvas, _e = ce.context.gl, Pe = ce.debugOverlayCanvas.getContext("2d");
            Pe.clearRect(0, 0, we.width, we.height), Pe.shadowColor = "white", Pe.shadowBlur = 2, Pe.lineWidth = 1.5, Pe.strokeStyle = "white", Pe.textBaseline = "top", Pe.font = "bold 36px Open Sans, sans-serif", Pe.fillText(me, 5, 5), Pe.strokeText(me, 5, 5), ce.debugOverlayTexture.update(we), ce.debugOverlayTexture.bind(_e.LINEAR, _e.CLAMP_TO_EDGE);
          })(v, `${se} ${$}kB`);
          const le = v.transform.getProjectionData({ overscaledTileID: a, applyGlobeMatrix: true, applyTerrainMatrix: true });
          y.draw(c, p.TRIANGLES, x, k, li.alphaBlended, nr.disabled, Pa(s.bf.transparent, Y), null, le, E, v.debugBuffer, v.quadTriangleIndexBuffer, v.debugSegments), y.draw(c, p.LINE_STRIP, x, k, P, nr.disabled, Pa(s.bf.red), D, le, E, v.debugBuffer, v.tileBorderIndexBuffer, v.debugSegments);
        }
        function Ln(v, e, a, c) {
          const { isRenderingGlobe: p } = c, y = v.context, x = y.gl, k = v.transform, P = v.colorModeForRenderPass(), E = v.getDepthModeFor3D(), D = v.useProgram("terrain");
          y.bindFramebuffer.set(null), y.viewport.set([0, 0, v.width, v.height]);
          for (const j of a) {
            const $ = e.getTerrainMesh(j.tileID), U = v.renderToTexture.getTexture(j), Y = e.getTerrainData(j.tileID);
            y.activeTexture.set(x.TEXTURE0), x.bindTexture(x.TEXTURE_2D, U.texture);
            const se = e.getMeshFrameDelta(k.zoom), le = k.calculateFogMatrix(j.tileID.toUnwrapped()), ce = Vl(se, le, v.style.sky, k.pitch, p), me = k.getProjectionData({ overscaledTileID: j.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
            D.draw(y, x.TRIANGLES, E, Rr.disabled, P, nr.backCCW, ce, Y, me, "terrain", $.vertexBuffer, $.indexBuffer, $.segments);
          }
        }
        function iu(v, e) {
          if (!e.mesh) {
            const a = new s.aL();
            a.emplaceBack(-1, -1), a.emplaceBack(1, -1), a.emplaceBack(1, 1), a.emplaceBack(-1, 1);
            const c = new s.aN();
            c.emplaceBack(0, 1, 2), c.emplaceBack(0, 2, 3), e.mesh = new Ao(v.createVertexBuffer(a, bo.members), v.createIndexBuffer(c), s.aM.simpleSegment(0, 0, a.length, c.length));
          }
          return e.mesh;
        }
        class nu {
          constructor(e, a) {
            this.context = new Mh(e), this.transform = a, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: s.ag(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = er.maxUnderzooming + er.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new ta();
          }
          resize(e, a, c) {
            if (this.width = Math.floor(e * c), this.height = Math.floor(a * c), this.pixelRatio = c, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const p of this.style._order) this.style._layers[p].resize();
          }
          setup() {
            const e = this.context, a = new s.aL();
            a.emplaceBack(0, 0), a.emplaceBack(s.$, 0), a.emplaceBack(0, s.$), a.emplaceBack(s.$, s.$), this.tileExtentBuffer = e.createVertexBuffer(a, bo.members), this.tileExtentSegments = s.aM.simpleSegment(0, 0, 4, 2);
            const c = new s.aL();
            c.emplaceBack(0, 0), c.emplaceBack(s.$, 0), c.emplaceBack(0, s.$), c.emplaceBack(s.$, s.$), this.debugBuffer = e.createVertexBuffer(c, bo.members), this.debugSegments = s.aM.simpleSegment(0, 0, 4, 5);
            const p = new s.c6();
            p.emplaceBack(0, 0, 0, 0), p.emplaceBack(s.$, 0, s.$, 0), p.emplaceBack(0, s.$, 0, s.$), p.emplaceBack(s.$, s.$, s.$, s.$), this.rasterBoundsBuffer = e.createVertexBuffer(p, wp.members), this.rasterBoundsSegments = s.aM.simpleSegment(0, 0, 4, 2);
            const y = new s.aL();
            y.emplaceBack(0, 0), y.emplaceBack(s.$, 0), y.emplaceBack(0, s.$), y.emplaceBack(s.$, s.$), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(y, bo.members), this.rasterBoundsSegmentsPosOnly = s.aM.simpleSegment(0, 0, 4, 5);
            const x = new s.aL();
            x.emplaceBack(0, 0), x.emplaceBack(1, 0), x.emplaceBack(0, 1), x.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(x, bo.members), this.viewportSegments = s.aM.simpleSegment(0, 0, 4, 2);
            const k = new s.c7();
            k.emplaceBack(0), k.emplaceBack(1), k.emplaceBack(3), k.emplaceBack(2), k.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(k);
            const P = new s.aN();
            P.emplaceBack(1, 0, 2), P.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(P);
            const E = this.context.gl;
            this.stencilClearMode = new Rr({ func: E.ALWAYS, mask: 0 }, 0, 255, E.ZERO, E.ZERO, E.ZERO), this.tileExtentMesh = new Ao(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
          clearStencil() {
            const e = this.context, a = e.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const c = s.L();
            s.bY(c, 0, this.width, this.height, 0, 0, 1), s.N(c, c, [a.drawingBufferWidth, a.drawingBufferHeight, 0]);
            const p = { mainMatrix: c, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: c };
            this.useProgram("clippingMask", null, true).draw(e, a.TRIANGLES, mr.disabled, this.stencilClearMode, li.disabled, nr.disabled, null, null, p, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(e, a, c) {
            if (this.currentStencilSource === e.source || !e.isTileClipped() || !a || !a.length) return;
            this.currentStencilSource = e.source, this.nextStencilID + a.length > 256 && this.clearStencil();
            const p = this.context;
            p.setColorMode(li.disabled), p.setDepthMode(mr.disabled);
            const y = {};
            for (const x of a) y[x.key] = this.nextStencilID++;
            this._renderTileMasks(y, a, c, true), this._renderTileMasks(y, a, c, false), this._tileClippingMaskIDs = y;
          }
          _renderTileMasks(e, a, c, p) {
            const y = this.context, x = y.gl, k = this.style.projection, P = this.transform, E = this.useProgram("clippingMask");
            for (const D of a) {
              const j = e[D.key], $ = this.style.map.terrain && this.style.map.terrain.getTerrainData(D), U = k.getMeshFromTileID(this.context, D.canonical, p, true, "stencil"), Y = P.getProjectionData({ overscaledTileID: D, applyGlobeMatrix: !c, applyTerrainMatrix: true });
              E.draw(y, x.TRIANGLES, mr.disabled, new Rr({ func: x.ALWAYS, mask: 0 }, j, 255, x.KEEP, x.KEEP, x.REPLACE), li.disabled, c ? nr.disabled : nr.backCCW, null, $, Y, "$clipping", U.vertexBuffer, U.indexBuffer, U.segments);
            }
          }
          _renderTilesDepthBuffer() {
            const e = this.context, a = e.gl, c = this.style.projection, p = this.transform, y = this.useProgram("depth"), x = this.getDepthModeFor3D(), k = Te(p, { tileSize: p.tileSize });
            for (const P of k) {
              const E = this.style.map.terrain && this.style.map.terrain.getTerrainData(P), D = c.getMeshFromTileID(this.context, P.canonical, true, true, "raster"), j = p.getProjectionData({ overscaledTileID: P, applyGlobeMatrix: true, applyTerrainMatrix: true });
              y.draw(e, a.TRIANGLES, x, Rr.disabled, li.disabled, nr.backCCW, null, E, j, "$clipping", D.vertexBuffer, D.indexBuffer, D.segments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e = this.nextStencilID++, a = this.context.gl;
            return new Rr({ func: a.NOTEQUAL, mask: 255 }, e, 255, a.KEEP, a.KEEP, a.REPLACE);
          }
          stencilModeForClipping(e) {
            const a = this.context.gl;
            return new Rr({ func: a.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e.key], 0, a.KEEP, a.KEEP, a.REPLACE);
          }
          getStencilConfigForOverlapAndUpdateStencilID(e) {
            const a = this.context.gl, c = e.sort(((x, k) => k.overscaledZ - x.overscaledZ)), p = c[c.length - 1].overscaledZ, y = c[0].overscaledZ - p + 1;
            if (y > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + y > 256 && this.clearStencil();
              const x = {};
              for (let k = 0; k < y; k++) x[k + p] = new Rr({ func: a.GEQUAL, mask: 255 }, k + this.nextStencilID, 255, a.KEEP, a.KEEP, a.REPLACE);
              return this.nextStencilID += y, [x, c];
            }
            return [{ [p]: Rr.disabled }, c];
          }
          stencilConfigForOverlapTwoPass(e) {
            const a = this.context.gl, c = e.sort(((x, k) => k.overscaledZ - x.overscaledZ)), p = c[c.length - 1].overscaledZ, y = c[0].overscaledZ - p + 1;
            if (this.clearStencil(), y > 1) {
              const x = {}, k = {};
              for (let P = 0; P < y; P++) x[P + p] = new Rr({ func: a.GREATER, mask: 255 }, y + 1 + P, 255, a.KEEP, a.KEEP, a.REPLACE), k[P + p] = new Rr({ func: a.GREATER, mask: 255 }, 1 + P, 255, a.KEEP, a.KEEP, a.REPLACE);
              return this.nextStencilID = 2 * y + 1, [x, k, c];
            }
            return this.nextStencilID = 3, [{ [p]: new Rr({ func: a.GREATER, mask: 255 }, 2, 255, a.KEEP, a.KEEP, a.REPLACE) }, { [p]: new Rr({ func: a.GREATER, mask: 255 }, 1, 255, a.KEEP, a.KEEP, a.REPLACE) }, c];
          }
          colorModeForRenderPass() {
            const e = this.context.gl;
            return this._showOverdrawInspector ? new li([e.CONSTANT_COLOR, e.ONE], new s.bf(0.125, 0.125, 0.125, 0), [true, true, true, true]) : this.renderPass === "opaque" ? li.unblended : li.alphaBlended;
          }
          getDepthModeForSublayer(e, a, c) {
            if (!this.opaquePassEnabledForLayer()) return mr.disabled;
            const p = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
            return new mr(c || this.context.gl.LEQUAL, a, [p, p]);
          }
          getDepthModeFor3D() {
            return new mr(this.context.gl.LEQUAL, mr.ReadWrite, this.depthRangeFor3D);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(e, a) {
            var c, p;
            this.style = e, this.options = a, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(L.now()), this.imageManager.beginFrame();
            const y = this.style._order, x = this.style.sourceCaches, k = {}, P = {}, E = {}, D = { isRenderingToTexture: false, isRenderingGlobe: ((c = e.projection) === null || c === void 0 ? void 0 : c.transitionState) > 0 };
            for (const $ in x) {
              const U = x[$];
              U.used && U.prepare(this.context), k[$] = U.getVisibleCoordinates(false), P[$] = k[$].slice().reverse(), E[$] = U.getVisibleCoordinates(true).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let $ = 0; $ < y.length; $++) if (this.style._layers[y[$]].is3D()) {
              this.opaquePassCutoff = $;
              break;
            }
            this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const $ of y) {
              const U = this.style._layers[$];
              if (!U.hasOffscreenPass() || U.isHidden(this.transform.zoom)) continue;
              const Y = P[U.source];
              (U.type === "custom" || Y.length) && this.renderLayer(this, x[U.source], U, Y, D);
            }
            if ((p = this.style.projection) === null || p === void 0 || p.updateGPUdependent({ context: this.context, useProgram: ($) => this.useProgram($) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: a.showOverdrawInspector ? s.bf.black : s.bf.transparent, depth: 1 }), this.clearStencil(), this.style.sky && (function($, U) {
              const Y = $.context, se = Y.gl, le = ((Me, ye, Be) => {
                const Je = Math.cos(ye.rollInRadians), We = Math.sin(ye.rollInRadians), Ze = ke(ye), Qe = ye.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }).projectionTransition;
                return { u_sky_color: Me.properties.get("sky-color"), u_horizon_color: Me.properties.get("horizon-color"), u_horizon: [(ye.width / 2 - Ze * We) * Be, (ye.height / 2 + Ze * Je) * Be], u_horizon_normal: [-We, Je], u_sky_horizon_blend: Me.properties.get("sky-horizon-blend") * ye.height / 2 * Be, u_sky_blend: Qe };
              })(U, $.style.map.transform, $.pixelRatio), ce = new mr(se.LEQUAL, mr.ReadWrite, [0, 1]), me = Rr.disabled, we = $.colorModeForRenderPass(), _e = $.useProgram("sky"), Pe = iu(Y, U);
              _e.draw(Y, se.TRIANGLES, ce, me, we, nr.disabled, le, null, void 0, "sky", Pe.vertexBuffer, Pe.indexBuffer, Pe.segments);
            })(this, this.style.sky), this._showOverdrawInspector = a.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = y.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const $ = this.style._layers[y[this.currentLayer]], U = x[$.source], Y = k[$.source];
              this._renderTileClippingMasks($, Y, false), this.renderLayer(this, U, $, Y, D);
            }
            this.renderPass = "translucent";
            let j = false;
            for (this.currentLayer = 0; this.currentLayer < y.length; this.currentLayer++) {
              const $ = this.style._layers[y[this.currentLayer]], U = x[$.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer($, D)) continue;
              this.opaquePassEnabledForLayer() || j || (j = true, D.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const Y = ($.type === "symbol" ? E : P)[$.source];
              this._renderTileClippingMasks($, k[$.source], !!this.renderToTexture), this.renderLayer(this, U, $, Y, D);
            }
            if (D.isRenderingGlobe && (function($, U, Y) {
              const se = $.context, le = se.gl, ce = $.useProgram("atmosphere"), me = new mr(le.LEQUAL, mr.ReadOnly, [0, 1]), we = $.transform, _e = (function(Qe, It) {
                const Pt = Qe.properties.get("position"), pt = [-Pt.x, -Pt.y, -Pt.z], Vt = s.ag(new Float64Array(16));
                return Qe.properties.get("anchor") === "map" && (s.b6(Vt, Vt, It.rollInRadians), s.b7(Vt, Vt, -It.pitchInRadians), s.b6(Vt, Vt, It.bearingInRadians), s.b7(Vt, Vt, It.center.lat * Math.PI / 180), s.bz(Vt, Vt, -It.center.lng * Math.PI / 180)), s.c5(pt, pt, Vt), pt;
              })(Y, $.transform), Pe = we.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }), Me = U.properties.get("atmosphere-blend") * Pe.projectionTransition;
              if (Me === 0) return;
              const ye = ts(we.worldSize, we.center.lat), Be = we.inverseProjectionMatrix, Je = new Float64Array(4);
              Je[3] = 1, s.aw(Je, Je, we.modelViewProjectionMatrix), Je[0] /= Je[3], Je[1] /= Je[3], Je[2] /= Je[3], Je[3] = 1, s.aw(Je, Je, Be), Je[0] /= Je[3], Je[1] /= Je[3], Je[2] /= Je[3], Je[3] = 1;
              const We = /* @__PURE__ */ ((Qe, It, Pt, pt, Vt) => ({ u_sun_pos: Qe, u_atmosphere_blend: It, u_globe_position: Pt, u_globe_radius: pt, u_inv_proj_matrix: Vt }))(_e, Me, [Je[0], Je[1], Je[2]], ye, Be), Ze = iu(se, U);
              ce.draw(se, le.TRIANGLES, me, Rr.disabled, li.alphaBlended, nr.disabled, We, null, null, "atmosphere", Ze.vertexBuffer, Ze.indexBuffer, Ze.segments);
            })(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const $ = (function(U, Y) {
                let se = null;
                const le = Object.values(U._layers).flatMap(((_e) => _e.source && !_e.isHidden(Y) ? [U.sourceCaches[_e.source]] : [])), ce = le.filter(((_e) => _e.getSource().type === "vector")), me = le.filter(((_e) => _e.getSource().type !== "vector")), we = (_e) => {
                  (!se || se.getSource().maxzoom < _e.getSource().maxzoom) && (se = _e);
                };
                return ce.forEach(((_e) => we(_e))), se || me.forEach(((_e) => we(_e))), se;
              })(this.style, this.transform.zoom);
              $ && (function(U, Y, se) {
                for (let le = 0; le < se.length; le++) Da(U, Y, se[le]);
              })(this, $, $.getVisibleCoordinates());
            }
            this.options.showPadding && (function($) {
              const U = $.transform.padding;
              Fh($, $.transform.height - (U.top || 0), 3, Bc), Fh($, U.bottom || 0, 3, Dh), $c($, U.left || 0, 3, zh), $c($, $.transform.width - (U.right || 0), 3, ru);
              const Y = $.transform.centerPoint;
              (function(se, le, ce, me) {
                ci(se, le - 1, ce - 10, 2, 20, me), ci(se, le - 10, ce - 1, 20, 2, me);
              })($, Y.x, $.transform.height - Y.y, Oc);
            })(this), this.context.setDefault();
          }
          maybeDrawDepthAndCoords(e) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const a = this.terrainFacilitator.matrix, c = this.transform.modelViewProjectionMatrix;
            let p = this.terrainFacilitator.dirty;
            p || (p = e ? !s.c8(a, c) : !s.c9(a, c)), p || (p = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), p && (s.ca(a, c), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, (function(y, x) {
              const k = y.context, P = k.gl, E = y.transform, D = li.unblended, j = new mr(P.LEQUAL, mr.ReadWrite, [0, 1]), $ = x.sourceCache.getRenderableTiles(), U = y.useProgram("terrainDepth");
              k.bindFramebuffer.set(x.getFramebuffer("depth").framebuffer), k.viewport.set([0, 0, y.width / devicePixelRatio, y.height / devicePixelRatio]), k.clear({ color: s.bf.transparent, depth: 1 });
              for (const Y of $) {
                const se = x.getTerrainMesh(Y.tileID), le = x.getTerrainData(Y.tileID), ce = E.getProjectionData({ overscaledTileID: Y.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true }), me = { u_ele_delta: x.getMeshFrameDelta(E.zoom) };
                U.draw(k, P.TRIANGLES, j, Rr.disabled, D, nr.backCCW, me, le, ce, "terrain", se.vertexBuffer, se.indexBuffer, se.segments);
              }
              k.bindFramebuffer.set(null), k.viewport.set([0, 0, y.width, y.height]);
            })(this, this.style.map.terrain), (function(y, x) {
              const k = y.context, P = k.gl, E = y.transform, D = li.unblended, j = new mr(P.LEQUAL, mr.ReadWrite, [0, 1]), $ = x.getCoordsTexture(), U = x.sourceCache.getRenderableTiles(), Y = y.useProgram("terrainCoords");
              k.bindFramebuffer.set(x.getFramebuffer("coords").framebuffer), k.viewport.set([0, 0, y.width / devicePixelRatio, y.height / devicePixelRatio]), k.clear({ color: s.bf.transparent, depth: 1 }), x.coordsIndex = [];
              for (const se of U) {
                const le = x.getTerrainMesh(se.tileID), ce = x.getTerrainData(se.tileID);
                k.activeTexture.set(P.TEXTURE0), P.bindTexture(P.TEXTURE_2D, $.texture);
                const me = { u_terrain_coords_id: (255 - x.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: x.getMeshFrameDelta(E.zoom) }, we = E.getProjectionData({ overscaledTileID: se.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
                Y.draw(k, P.TRIANGLES, j, Rr.disabled, D, nr.backCCW, me, ce, we, "terrain", le.vertexBuffer, le.indexBuffer, le.segments), x.coordsIndex.push(se.tileID.key);
              }
              k.bindFramebuffer.set(null), k.viewport.set([0, 0, y.width, y.height]);
            })(this, this.style.map.terrain));
          }
          renderLayer(e, a, c, p, y) {
            c.isHidden(this.transform.zoom) || (c.type === "background" || c.type === "custom" || (p || []).length) && (this.id = c.id, s.cb(c) ? (function(x, k, P, E, D, j) {
              if (x.renderPass !== "translucent") return;
              const { isRenderingToTexture: $ } = j, U = Rr.disabled, Y = x.colorModeForRenderPass();
              (P._unevaluatedLayout.hasValue("text-variable-anchor") || P._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && (function(se, le, ce, me, we, _e, Pe, Me, ye) {
                const Be = le.transform, Je = le.style.map.terrain, We = we === "map", Ze = _e === "map";
                for (const Qe of se) {
                  const It = me.getTile(Qe), Pt = It.getBucket(ce);
                  if (!Pt || !Pt.text || !Pt.text.segments.get().length) continue;
                  const pt = s.an(Pt.textSizeData, Be.zoom), Vt = s.aC(It, 1, le.transform.zoom), _r = ii(We, le.transform, Vt), Or = ce.layout.get("icon-text-fit") !== "none" && Pt.hasIconData();
                  if (pt) {
                    const hi = Math.pow(2, Be.zoom - It.tileID.overscaledZ), ei = Je ? (Hr, fi) => Je.getElevation(Qe, Hr, fi) : null;
                    Dc(Pt, We, Ze, ye, Be, _r, hi, pt, Or, s.aD(Be, It, Pe, Me), Qe.toUnwrapped(), ei);
                  }
                }
              })(E, x, P, k, P.layout.get("text-rotation-alignment"), P.layout.get("text-pitch-alignment"), P.paint.get("text-translate"), P.paint.get("text-translate-anchor"), D), P.paint.get("icon-opacity").constantOr(1) !== 0 && Zs(x, k, P, E, false, P.paint.get("icon-translate"), P.paint.get("icon-translate-anchor"), P.layout.get("icon-rotation-alignment"), P.layout.get("icon-pitch-alignment"), P.layout.get("icon-keep-upright"), U, Y, $), P.paint.get("text-opacity").constantOr(1) !== 0 && Zs(x, k, P, E, true, P.paint.get("text-translate"), P.paint.get("text-translate-anchor"), P.layout.get("text-rotation-alignment"), P.layout.get("text-pitch-alignment"), P.layout.get("text-keep-upright"), U, Y, $), k.map.showCollisionBoxes && (Eh(x, k, P, E, true), Eh(x, k, P, E, false));
            })(e, a, c, p, this.style.placement.variableOffsets, y) : s.cc(c) ? (function(x, k, P, E, D) {
              if (x.renderPass !== "translucent") return;
              const { isRenderingToTexture: j } = D, $ = P.paint.get("circle-opacity"), U = P.paint.get("circle-stroke-width"), Y = P.paint.get("circle-stroke-opacity"), se = !P.layout.get("circle-sort-key").isConstant();
              if ($.constantOr(1) === 0 && (U.constantOr(1) === 0 || Y.constantOr(1) === 0)) return;
              const le = x.context, ce = le.gl, me = x.transform, we = x.getDepthModeForSublayer(0, mr.ReadOnly), _e = Rr.disabled, Pe = x.colorModeForRenderPass(), Me = [], ye = me.getCircleRadiusCorrection();
              for (let Be = 0; Be < E.length; Be++) {
                const Je = E[Be], We = k.getTile(Je), Ze = We.getBucket(P);
                if (!Ze) continue;
                const Qe = P.paint.get("circle-translate"), It = P.paint.get("circle-translate-anchor"), Pt = s.aD(me, We, Qe, It), pt = Ze.programConfigurations.get(P.id), Vt = x.useProgram("circle", pt), _r = Ze.layoutVertexBuffer, Or = Ze.indexBuffer, hi = x.style.map.terrain && x.style.map.terrain.getTerrainData(Je), ei = { programConfiguration: pt, program: Vt, layoutVertexBuffer: _r, indexBuffer: Or, uniformValues: kp(x, We, P, Pt, ye), terrainData: hi, projectionData: me.getProjectionData({ overscaledTileID: Je, applyGlobeMatrix: !j, applyTerrainMatrix: true }) };
                if (se) {
                  const Hr = Ze.segments.get();
                  for (const fi of Hr) Me.push({ segments: new s.aM([fi]), sortKey: fi.sortKey, state: ei });
                } else Me.push({ segments: Ze.segments, sortKey: 0, state: ei });
              }
              se && Me.sort(((Be, Je) => Be.sortKey - Je.sortKey));
              for (const Be of Me) {
                const { programConfiguration: Je, program: We, layoutVertexBuffer: Ze, indexBuffer: Qe, uniformValues: It, terrainData: Pt, projectionData: pt } = Be.state;
                We.draw(le, ce.TRIANGLES, we, _e, Pe, nr.backCCW, It, Pt, pt, P.id, Ze, Qe, Be.segments, P.paint, x.transform.zoom, Je);
              }
            })(e, a, c, p, y) : s.cd(c) ? (function(x, k, P, E, D) {
              if (P.paint.get("heatmap-opacity") === 0) return;
              const j = x.context, { isRenderingToTexture: $, isRenderingGlobe: U } = D;
              if (x.style.map.terrain) {
                for (const Y of E) {
                  const se = k.getTile(Y);
                  k.hasRenderableParent(Y) || (x.renderPass === "offscreen" ? zc(x, se, P, Y, U) : x.renderPass === "translucent" && Ah(x, P, Y, $, U));
                }
                j.viewport.set([0, 0, x.width, x.height]);
              } else x.renderPass === "offscreen" ? (function(Y, se, le, ce) {
                const me = Y.context, we = me.gl, _e = Y.transform, Pe = Rr.disabled, Me = new li([we.ONE, we.ONE], s.bf.transparent, [true, true, true, true]);
                (function(ye, Be, Je) {
                  const We = ye.gl;
                  ye.activeTexture.set(We.TEXTURE1), ye.viewport.set([0, 0, Be.width / 4, Be.height / 4]);
                  let Ze = Je.heatmapFbos.get(s.c2);
                  Ze ? (We.bindTexture(We.TEXTURE_2D, Ze.colorAttachment.get()), ye.bindFramebuffer.set(Ze.framebuffer)) : (Ze = Xs(ye, Be.width / 4, Be.height / 4), Je.heatmapFbos.set(s.c2, Ze));
                })(me, Y, le), me.clear({ color: s.bf.transparent });
                for (let ye = 0; ye < ce.length; ye++) {
                  const Be = ce[ye];
                  if (se.hasRenderableParent(Be)) continue;
                  const Je = se.getTile(Be), We = Je.getBucket(le);
                  if (!We) continue;
                  const Ze = We.programConfigurations.get(le.id), Qe = Y.useProgram("heatmap", Ze), It = _e.getProjectionData({ overscaledTileID: Be, applyGlobeMatrix: true, applyTerrainMatrix: false }), Pt = _e.getCircleRadiusCorrection();
                  Qe.draw(me, we.TRIANGLES, mr.disabled, Pe, Me, nr.backCCW, fh(Je, _e.zoom, le.paint.get("heatmap-intensity"), Pt), null, It, le.id, We.layoutVertexBuffer, We.indexBuffer, We.segments, le.paint, _e.zoom, Ze);
                }
                me.viewport.set([0, 0, Y.width, Y.height]);
              })(x, k, P, E) : x.renderPass === "translucent" && (function(Y, se) {
                const le = Y.context, ce = le.gl;
                le.setColorMode(Y.colorModeForRenderPass());
                const me = se.heatmapFbos.get(s.c2);
                me && (le.activeTexture.set(ce.TEXTURE0), ce.bindTexture(ce.TEXTURE_2D, me.colorAttachment.get()), le.activeTexture.set(ce.TEXTURE1), Ys(le, se).bind(ce.LINEAR, ce.CLAMP_TO_EDGE), Y.useProgram("heatmapTexture").draw(le, ce.TRIANGLES, mr.disabled, Rr.disabled, Y.colorModeForRenderPass(), nr.disabled, bc(Y, se, 0, 1), null, null, se.id, Y.viewportBuffer, Y.quadTriangleIndexBuffer, Y.viewportSegments, se.paint, Y.transform.zoom));
              })(x, P);
            })(e, a, c, p, y) : s.ce(c) ? (function(x, k, P, E, D) {
              if (x.renderPass !== "translucent") return;
              const { isRenderingToTexture: j } = D, $ = P.paint.get("line-opacity"), U = P.paint.get("line-width");
              if ($.constantOr(1) === 0 || U.constantOr(1) === 0) return;
              const Y = x.getDepthModeForSublayer(0, mr.ReadOnly), se = x.colorModeForRenderPass(), le = P.paint.get("line-dasharray"), ce = P.paint.get("line-pattern"), me = ce.constantOr(1), we = P.paint.get("line-gradient"), _e = P.getCrossfadeParameters(), Pe = me ? "linePattern" : le ? "lineSDF" : we ? "lineGradient" : "line", Me = x.context, ye = Me.gl, Be = x.transform;
              let Je = true;
              for (const We of E) {
                const Ze = k.getTile(We);
                if (me && !Ze.patternsLoaded()) continue;
                const Qe = Ze.getBucket(P);
                if (!Qe) continue;
                const It = Qe.programConfigurations.get(P.id), Pt = x.context.program.get(), pt = x.useProgram(Pe, It), Vt = Je || pt.program !== Pt, _r = x.style.map.terrain && x.style.map.terrain.getTerrainData(We), Or = ce.constantOr(null);
                if (Or && Ze.imageAtlas) {
                  const oi = Ze.imageAtlas, ti = oi.patternPositions[Or.to.toString()], Ar = oi.patternPositions[Or.from.toString()];
                  ti && Ar && It.setConstantPatternPositions(ti, Ar);
                }
                const hi = Be.getProjectionData({ overscaledTileID: We, applyGlobeMatrix: !j, applyTerrainMatrix: true }), ei = Be.getPixelScale(), Hr = me ? vh(x, Ze, P, ei, _e) : le ? Ta(x, Ze, P, ei, le, _e) : we ? gh(x, Ze, P, ei, Qe.lineClipsArray.length) : Wl(x, Ze, P, ei);
                if (me) Me.activeTexture.set(ye.TEXTURE0), Ze.imageAtlasTexture.bind(ye.LINEAR, ye.CLAMP_TO_EDGE), It.updatePaintBuffers(_e);
                else if (le && (Vt || x.lineAtlas.dirty)) Me.activeTexture.set(ye.TEXTURE0), x.lineAtlas.bind(Me);
                else if (we) {
                  const oi = Qe.gradients[P.id];
                  let ti = oi.texture;
                  if (P.gradientVersion !== oi.version) {
                    let Ar = 256;
                    if (P.stepInterpolant) {
                      const Fi = k.getSource().maxzoom, Ei = We.canonical.z === Fi ? Math.ceil(1 << x.transform.maxZoom - We.canonical.z) : 1;
                      Ar = s.ah(s.c3(Qe.maxLineLength / s.$ * 1024 * Ei), 256, Me.maxTextureSize);
                    }
                    oi.gradient = s.c4({ expression: P.gradientExpression(), evaluationKey: "lineProgress", resolution: Ar, image: oi.gradient || void 0, clips: Qe.lineClipsArray }), oi.texture ? oi.texture.update(oi.gradient) : oi.texture = new s.T(Me, oi.gradient, ye.RGBA), oi.version = P.gradientVersion, ti = oi.texture;
                  }
                  Me.activeTexture.set(ye.TEXTURE0), ti.bind(P.stepInterpolant ? ye.NEAREST : ye.LINEAR, ye.CLAMP_TO_EDGE);
                }
                const fi = x.stencilModeForClipping(We);
                pt.draw(Me, ye.TRIANGLES, Y, fi, se, nr.disabled, Hr, _r, hi, P.id, Qe.layoutVertexBuffer, Qe.indexBuffer, Qe.segments, P.paint, x.transform.zoom, It, Qe.layoutVertexBuffer2), Je = false;
              }
            })(e, a, c, p, y) : s.cf(c) ? (function(x, k, P, E, D) {
              const j = P.paint.get("fill-color"), $ = P.paint.get("fill-opacity");
              if ($.constantOr(1) === 0) return;
              const { isRenderingToTexture: U } = D, Y = x.colorModeForRenderPass(), se = P.paint.get("fill-pattern"), le = x.opaquePassEnabledForLayer() && !se.constantOr(1) && j.constantOr(s.bf.transparent).a === 1 && $.constantOr(0) === 1 ? "opaque" : "translucent";
              if (x.renderPass === le) {
                const ce = x.getDepthModeForSublayer(1, x.renderPass === "opaque" ? mr.ReadWrite : mr.ReadOnly);
                Ra(x, k, P, E, ce, Y, false, U);
              }
              if (x.renderPass === "translucent" && P.paint.get("fill-antialias")) {
                const ce = x.getDepthModeForSublayer(P.getPaintProperty("fill-outline-color") ? 2 : 0, mr.ReadOnly);
                Ra(x, k, P, E, ce, Y, true, U);
              }
            })(e, a, c, p, y) : s.cg(c) ? (function(x, k, P, E, D) {
              const j = P.paint.get("fill-extrusion-opacity");
              if (j === 0) return;
              const { isRenderingToTexture: $ } = D;
              if (x.renderPass === "translucent") {
                const U = new mr(x.context.gl.LEQUAL, mr.ReadWrite, x.depthRangeFor3D);
                if (j !== 1 || P.paint.get("fill-extrusion-pattern").constantOr(1)) Js(x, k, P, E, U, Rr.disabled, li.disabled, $), Js(x, k, P, E, U, x.stencilModeFor3D(), x.colorModeForRenderPass(), $);
                else {
                  const Y = x.colorModeForRenderPass();
                  Js(x, k, P, E, U, Rr.disabled, Y, $);
                }
              }
            })(e, a, c, p, y) : s.ch(c) ? (function(x, k, P, E, D) {
              if (x.renderPass !== "offscreen" && x.renderPass !== "translucent") return;
              const { isRenderingToTexture: j } = D, $ = x.context, U = x.style.projection.useSubdivision, Y = x.getDepthModeForSublayer(0, mr.ReadOnly), se = x.colorModeForRenderPass();
              if (x.renderPass === "offscreen") (function(le, ce, me, we, _e, Pe, Me) {
                const ye = le.context, Be = ye.gl;
                for (const Je of me) {
                  const We = ce.getTile(Je), Ze = We.dem;
                  if (!Ze || !Ze.data || !We.needsHillshadePrepare) continue;
                  const Qe = Ze.dim, It = Ze.stride, Pt = Ze.getPixels();
                  if (ye.activeTexture.set(Be.TEXTURE1), ye.pixelStoreUnpackPremultiplyAlpha.set(false), We.demTexture = We.demTexture || le.getTileTexture(It), We.demTexture) {
                    const Vt = We.demTexture;
                    Vt.update(Pt, { premultiply: false }), Vt.bind(Be.NEAREST, Be.CLAMP_TO_EDGE);
                  } else We.demTexture = new s.T(ye, Pt, Be.RGBA, { premultiply: false }), We.demTexture.bind(Be.NEAREST, Be.CLAMP_TO_EDGE);
                  ye.activeTexture.set(Be.TEXTURE0);
                  let pt = We.fbo;
                  if (!pt) {
                    const Vt = new s.T(ye, { width: Qe, height: Qe, data: null }, Be.RGBA);
                    Vt.bind(Be.LINEAR, Be.CLAMP_TO_EDGE), pt = We.fbo = ye.createFramebuffer(Qe, Qe, true, false), pt.colorAttachment.set(Vt.texture);
                  }
                  ye.bindFramebuffer.set(pt.framebuffer), ye.viewport.set([0, 0, Qe, Qe]), le.useProgram("hillshadePrepare").draw(ye, Be.TRIANGLES, _e, Pe, Me, nr.disabled, ph(We.tileID, Ze), null, null, we.id, le.rasterBoundsBuffer, le.quadTriangleIndexBuffer, le.rasterBoundsSegments), We.needsHillshadePrepare = false;
                }
              })(x, k, E, P, Y, Rr.disabled, se), $.viewport.set([0, 0, x.width, x.height]);
              else if (x.renderPass === "translucent") if (U) {
                const [le, ce, me] = x.stencilConfigForOverlapTwoPass(E);
                Fc(x, k, P, me, le, Y, se, false, j), Fc(x, k, P, me, ce, Y, se, true, j);
              } else {
                const [le, ce] = x.getStencilConfigForOverlapAndUpdateStencilID(E);
                Fc(x, k, P, ce, le, Y, se, false, j);
              }
            })(e, a, c, p, y) : s.ci(c) ? (function(x, k, P, E, D) {
              if (x.renderPass !== "translucent" || !E.length) return;
              const { isRenderingToTexture: j } = D, $ = x.style.projection.useSubdivision, U = x.getDepthModeForSublayer(0, mr.ReadOnly), Y = x.colorModeForRenderPass();
              if ($) {
                const [se, le, ce] = x.stencilConfigForOverlapTwoPass(E);
                Aa(x, k, P, ce, se, U, Y, false, j), Aa(x, k, P, ce, le, U, Y, true, j);
              } else {
                const [se, le] = x.getStencilConfigForOverlapAndUpdateStencilID(E);
                Aa(x, k, P, le, se, U, Y, false, j);
              }
            })(e, a, c, p, y) : s.cj(c) ? (function(x, k, P, E, D) {
              if (x.renderPass !== "translucent" || P.paint.get("raster-opacity") === 0 || !E.length) return;
              const { isRenderingToTexture: j } = D, $ = k.getSource(), U = x.style.projection.useSubdivision;
              if ($ instanceof ot) Qs(x, k, P, E, null, false, false, $.tileCoords, $.flippedWindingOrder, j);
              else if (U) {
                const [Y, se, le] = x.stencilConfigForOverlapTwoPass(E);
                Qs(x, k, P, le, Y, false, true, Lc, false, j), Qs(x, k, P, le, se, true, true, Lc, false, j);
              } else {
                const [Y, se] = x.getStencilConfigForOverlapAndUpdateStencilID(E);
                Qs(x, k, P, se, Y, false, true, Lc, false, j);
              }
            })(e, a, c, p, y) : s.ck(c) ? (function(x, k, P, E, D) {
              const j = P.paint.get("background-color"), $ = P.paint.get("background-opacity");
              if ($ === 0) return;
              const { isRenderingToTexture: U } = D, Y = x.context, se = Y.gl, le = x.style.projection, ce = x.transform, me = ce.tileSize, we = P.paint.get("background-pattern");
              if (x.isPatternMissing(we)) return;
              const _e = !we && j.a === 1 && $ === 1 && x.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (x.renderPass !== _e) return;
              const Pe = Rr.disabled, Me = x.getDepthModeForSublayer(0, _e === "opaque" ? mr.ReadWrite : mr.ReadOnly), ye = x.colorModeForRenderPass(), Be = x.useProgram(we ? "backgroundPattern" : "background"), Je = E || Te(ce, { tileSize: me, terrain: x.style.map.terrain });
              we && (Y.activeTexture.set(se.TEXTURE0), x.imageManager.bind(x.context));
              const We = P.getCrossfadeParameters();
              for (const Ze of Je) {
                const Qe = ce.getProjectionData({ overscaledTileID: Ze, applyGlobeMatrix: !U, applyTerrainMatrix: true }), It = we ? bh($, x, we, { tileID: Ze, tileSize: me }, We) : yh($, j), Pt = x.style.map.terrain && x.style.map.terrain.getTerrainData(Ze), pt = le.getMeshFromTileID(Y, Ze.canonical, false, true, "raster");
                Be.draw(Y, se.TRIANGLES, Me, Pe, ye, nr.backCCW, It, Pt, Qe, P.id, pt.vertexBuffer, pt.indexBuffer, pt.segments);
              }
            })(e, 0, c, p, y) : s.cl(c) && (function(x, k, P, E) {
              const { isRenderingGlobe: D } = E, j = x.context, $ = P.implementation, U = x.style.projection, Y = x.transform, se = Y.getProjectionDataForCustomLayer(D), le = { farZ: Y.farZ, nearZ: Y.nearZ, fov: Y.fov * Math.PI / 180, modelViewProjectionMatrix: Y.modelViewProjectionMatrix, projectionMatrix: Y.projectionMatrix, shaderData: { variantName: U.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${U.shaderPreludeCode.vertexSource}`, define: U.shaderDefine }, defaultProjectionData: se }, ce = $.renderingMode ? $.renderingMode : "2d";
              if (x.renderPass === "offscreen") {
                const me = $.prerender;
                me && (x.setCustomLayerDefaults(), j.setColorMode(x.colorModeForRenderPass()), me.call($, j.gl, le), j.setDirty(), x.setBaseState());
              } else if (x.renderPass === "translucent") {
                x.setCustomLayerDefaults(), j.setColorMode(x.colorModeForRenderPass()), j.setStencilMode(Rr.disabled);
                const me = ce === "3d" ? x.getDepthModeFor3D() : x.getDepthModeForSublayer(0, mr.ReadOnly);
                j.setDepthMode(me), $.render(j.gl, le), j.setDirty(), x.setBaseState(), j.bindFramebuffer.set(null);
              }
            })(e, 0, c, y));
          }
          saveTileTexture(e) {
            const a = this._tileTextures[e.size[0]];
            a ? a.push(e) : this._tileTextures[e.size[0]] = [e];
          }
          getTileTexture(e) {
            const a = this._tileTextures[e];
            return a && a.length > 0 ? a.pop() : null;
          }
          isPatternMissing(e) {
            if (!e) return false;
            if (!e.from || !e.to) return true;
            const a = this.imageManager.getPattern(e.from.toString()), c = this.imageManager.getPattern(e.to.toString());
            return !a || !c;
          }
          useProgram(e, a, c = false, p = []) {
            this.cache = this.cache || {};
            const y = !!this.style.map.terrain, x = this.style.projection, k = c ? Dn.projectionMercator : x.shaderPreludeCode, P = c ? Qn : x.shaderDefine, E = e + (a ? a.cacheKey : "") + `/${c ? Do : x.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (y ? "/terrain" : "") + (p ? `/${p.join("/")}` : "");
            return this.cache[E] || (this.cache[E] = new yc(this.context, Dn[e], a, kc[e], this._showOverdrawInspector, y, k, P, p)), this.cache[E];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const e = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new s.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            const { drawingBufferWidth: e, drawingBufferHeight: a } = this.context.gl;
            return this.width !== e || this.height !== a;
          }
        }
        function jc(v, e) {
          let a, c = false, p = null, y = null;
          const x = () => {
            p = null, c && (v.apply(y, a), p = setTimeout(x, e), c = false);
          };
          return (...k) => (c = true, y = this, a = k, p || x(), p);
        }
        class za {
          constructor(e) {
            this._getCurrentHash = () => {
              const a = window.location.hash.replace("#", "");
              if (this._hashName) {
                let c;
                return a.split("&").map(((p) => p.split("="))).forEach(((p) => {
                  p[0] === this._hashName && (c = p);
                })), (c && c[1] || "").split("/");
              }
              return a.split("/");
            }, this._onHashChange = () => {
              const a = this._getCurrentHash();
              if (!this._isValidHash(a)) return false;
              const c = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(a[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+a[2], +a[1]], zoom: +a[0], bearing: c, pitch: +(a[4] || 0) }), true;
            }, this._updateHashUnthrottled = () => {
              const a = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, a);
            }, this._removeHash = () => {
              const a = this._getCurrentHash();
              if (a.length === 0) return;
              const c = a.join("/");
              let p = c;
              p.split("&").length > 0 && (p = p.split("&")[0]), this._hashName && (p = `${this._hashName}=${c}`);
              let y = window.location.hash.replace(p, "");
              y.startsWith("#&") ? y = y.slice(0, 1) + y.slice(2) : y === "#" && (y = "");
              let x = window.location.href.replace(/(#.+)?$/, y);
              x = x.replace("&&", "&"), window.history.replaceState(window.history.state, null, x);
            }, this._updateHash = jc(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e);
          }
          addTo(e) {
            return this._map = e, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
          }
          getHashString(e) {
            const a = this._map.getCenter(), c = Math.round(100 * this._map.getZoom()) / 100, p = Math.ceil((c * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), y = Math.pow(10, p), x = Math.round(a.lng * y) / y, k = Math.round(a.lat * y) / y, P = this._map.getBearing(), E = this._map.getPitch();
            let D = "";
            if (D += e ? `/${x}/${k}/${c}` : `${c}/${k}/${x}`, (P || E) && (D += "/" + Math.round(10 * P) / 10), E && (D += `/${Math.round(E)}`), this._hashName) {
              const j = this._hashName;
              let $ = false;
              const U = window.location.hash.slice(1).split("&").map(((Y) => {
                const se = Y.split("=")[0];
                return se === j ? ($ = true, `${se}=${D}`) : Y;
              })).filter(((Y) => Y));
              return $ || U.push(`${j}=${D}`), `#${U.join("&")}`;
            }
            return `#${D}`;
          }
          _isValidHash(e) {
            if (e.length < 3 || e.some(isNaN)) return false;
            try {
              new s.S(+e[2], +e[1]);
            } catch {
              return false;
            }
            const a = +e[0], c = +(e[3] || 0), p = +(e[4] || 0);
            return a >= this._map.getMinZoom() && a <= this._map.getMaxZoom() && c >= -180 && c <= 180 && p >= this._map.getMinPitch() && p <= this._map.getMaxPitch();
          }
        }
        const Fa = { linearity: 0.3, easing: s.cm(0, 0, 0.3, 1) }, el = s.e({ deceleration: 2500, maxSpeed: 1400 }, Fa), Nc = s.e({ deceleration: 20, maxSpeed: 1400 }, Fa), Lh = s.e({ deceleration: 1e3, maxSpeed: 360 }, Fa), Bh = s.e({ deceleration: 1e3, maxSpeed: 90 }, Fa), Oh = s.e({ deceleration: 1e3, maxSpeed: 360 }, Fa);
        class $h {
          constructor(e) {
            this._map = e, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(e) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: L.now(), settings: e });
          }
          _drainInertiaBuffer() {
            const e = this._inertiaBuffer, a = L.now();
            for (; e.length > 0 && a - e[0].time > 160; ) e.shift();
          }
          _onMoveEnd(e) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const a = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new s.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: y } of this._inertiaBuffer) a.zoom += y.zoomDelta || 0, a.bearing += y.bearingDelta || 0, a.pitch += y.pitchDelta || 0, a.roll += y.rollDelta || 0, y.panDelta && a.pan._add(y.panDelta), y.around && (a.around = y.around), y.pinchAround && (a.pinchAround = y.pinchAround);
            const c = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, p = {};
            if (a.pan.mag()) {
              const y = ro(a.pan.mag(), c, s.e({}, el, e || {})), x = a.pan.mult(y.amount / a.pan.mag()), k = this._map.cameraHelper.handlePanInertia(x, this._map.transform);
              p.center = k.easingCenter, p.offset = k.easingOffset, os(p, y);
            }
            if (a.zoom) {
              const y = ro(a.zoom, c, Nc);
              p.zoom = this._map.transform.zoom + y.amount, os(p, y);
            }
            if (a.bearing) {
              const y = ro(a.bearing, c, Lh);
              p.bearing = this._map.transform.bearing + s.ah(y.amount, -179, 179), os(p, y);
            }
            if (a.pitch) {
              const y = ro(a.pitch, c, Bh);
              p.pitch = this._map.transform.pitch + y.amount, os(p, y);
            }
            if (a.roll) {
              const y = ro(a.roll, c, Oh);
              p.roll = this._map.transform.roll + s.ah(y.amount, -179, 179), os(p, y);
            }
            if (p.zoom || p.bearing) {
              const y = a.pinchAround === void 0 ? a.around : a.pinchAround;
              p.around = y ? this._map.unproject(y) : this._map.getCenter();
            }
            return this.clear(), s.e(p, { noMoveStart: true });
          }
        }
        function os(v, e) {
          (!v.duration || v.duration < e.duration) && (v.duration = e.duration, v.easing = e.easing);
        }
        function ro(v, e, a) {
          const { maxSpeed: c, linearity: p, deceleration: y } = a, x = s.ah(v * p / (e / 1e3), -c, c), k = Math.abs(x) / (y * p);
          return { easing: a.easing, duration: 1e3 * k, amount: x * (k / 2) };
        }
        class Pn extends s.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, a, c, p = {}) {
            c = c instanceof MouseEvent ? c : new MouseEvent(e, c);
            const y = A.mousePos(a.getCanvas(), c), x = a.unproject(y);
            super(e, s.e({ point: y, lngLat: x, originalEvent: c }, p)), this._defaultPrevented = false, this.target = a;
          }
        }
        class as extends s.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, a, c) {
            const p = e === "touchend" ? c.changedTouches : c.touches, y = A.touchPos(a.getCanvasContainer(), p), x = y.map(((P) => a.unproject(P))), k = y.reduce(((P, E, D, j) => P.add(E.div(j.length))), new s.P(0, 0));
            super(e, { points: y, point: k, lngLats: x, lngLat: a.unproject(k), originalEvent: c }), this._defaultPrevented = false;
          }
        }
        class Vc extends s.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e, a, c) {
            super(e, { originalEvent: c }), this._defaultPrevented = false;
          }
        }
        class jh {
          constructor(e, a) {
            this._map = e, this._clickTolerance = a.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(e) {
            return this._firePreventable(new Vc(e.type, this._map, e));
          }
          mousedown(e, a) {
            return this._mousedownPos = a, this._firePreventable(new Pn(e.type, this._map, e));
          }
          mouseup(e) {
            this._map.fire(new Pn(e.type, this._map, e));
          }
          click(e, a) {
            this._mousedownPos && this._mousedownPos.dist(a) >= this._clickTolerance || this._map.fire(new Pn(e.type, this._map, e));
          }
          dblclick(e) {
            return this._firePreventable(new Pn(e.type, this._map, e));
          }
          mouseover(e) {
            this._map.fire(new Pn(e.type, this._map, e));
          }
          mouseout(e) {
            this._map.fire(new Pn(e.type, this._map, e));
          }
          touchstart(e) {
            return this._firePreventable(new as(e.type, this._map, e));
          }
          touchmove(e) {
            this._map.fire(new as(e.type, this._map, e));
          }
          touchend(e) {
            this._map.fire(new as(e.type, this._map, e));
          }
          touchcancel(e) {
            this._map.fire(new as(e.type, this._map, e));
          }
          _firePreventable(e) {
            if (this._map.fire(e), e.defaultPrevented) return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class Nh {
          constructor(e) {
            this._map = e;
          }
          reset() {
            this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
          }
          mousemove(e) {
            this._map.fire(new Pn(e.type, this._map, e));
          }
          mousedown() {
            this._delayContextMenu = true, this._ignoreContextMenu = false;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new Pn("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(e) {
            this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new Pn(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class ss {
          constructor(e) {
            this._map = e;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(e) {
            return this.transform.screenPointToLocation(s.P.convert(e), this._map.terrain);
          }
        }
        class Uc {
          constructor(e, a) {
            this._map = e, this._tr = new ss(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = a.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(e, a) {
            this.isEnabled() && e.shiftKey && e.button === 0 && (A.disableDrag(), this._startPos = this._lastPos = a, this._active = true);
          }
          mousemoveWindow(e, a) {
            if (!this._active) return;
            const c = a;
            if (this._lastPos.equals(c) || !this._box && c.dist(this._startPos) < this._clickTolerance) return;
            const p = this._startPos;
            this._lastPos = c, this._box || (this._box = A.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
            const y = Math.min(p.x, c.x), x = Math.max(p.x, c.x), k = Math.min(p.y, c.y), P = Math.max(p.y, c.y);
            A.setTransform(this._box, `translate(${y}px,${k}px)`), this._box.style.width = x - y + "px", this._box.style.height = P - k + "px";
          }
          mouseupWindow(e, a) {
            if (!this._active || e.button !== 0) return;
            const c = this._startPos, p = a;
            if (this.reset(), A.suppressClick(), c.x !== p.x || c.y !== p.y) return this._map.fire(new s.l("boxzoomend", { originalEvent: e })), { cameraAnimation: (y) => y.fitScreenCoordinates(c, p, this._tr.bearing, { linear: true }) };
            this._fireEvent("boxzoomcancel", e);
          }
          keydown(e) {
            this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e));
          }
          reset() {
            this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (A.remove(this._box), this._box = null), A.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(e, a) {
            return this._map.fire(new s.l(e, { originalEvent: a }));
          }
        }
        function ou(v, e) {
          if (v.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${v.length}, points ${e.length}`);
          const a = {};
          for (let c = 0; c < v.length; c++) a[v[c].identifier] = e[c];
          return a;
        }
        class au {
          constructor(e) {
            this.reset(), this.numTouches = e.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
          }
          touchstart(e, a, c) {
            (this.centroid || c.length > this.numTouches) && (this.aborted = true), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), c.length === this.numTouches && (this.centroid = (function(p) {
              const y = new s.P(0, 0);
              for (const x of p) y._add(x);
              return y.div(p.length);
            })(a), this.touches = ou(c, a)));
          }
          touchmove(e, a, c) {
            if (this.aborted || !this.centroid) return;
            const p = ou(c, a);
            for (const y in this.touches) {
              const x = p[y];
              (!x || x.dist(this.touches[y]) > 30) && (this.aborted = true);
            }
          }
          touchend(e, a, c) {
            if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = true), c.length === 0) {
              const p = !this.aborted && this.centroid;
              if (this.reset(), p) return p;
            }
          }
        }
        class su {
          constructor(e) {
            this.singleTap = new au(e), this.numTaps = e.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(e, a, c) {
            this.singleTap.touchstart(e, a, c);
          }
          touchmove(e, a, c) {
            this.singleTap.touchmove(e, a, c);
          }
          touchend(e, a, c) {
            const p = this.singleTap.touchend(e, a, c);
            if (p) {
              const y = e.timeStamp - this.lastTime < 500, x = !this.lastTap || this.lastTap.dist(p) < 30;
              if (y && x || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = p, this.count === this.numTaps) return this.reset(), p;
            }
          }
        }
        class Wn {
          constructor(e) {
            this._tr = new ss(e), this._zoomIn = new su({ numTouches: 1, numTaps: 2 }), this._zoomOut = new su({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(e, a, c) {
            this._zoomIn.touchstart(e, a, c), this._zoomOut.touchstart(e, a, c);
          }
          touchmove(e, a, c) {
            this._zoomIn.touchmove(e, a, c), this._zoomOut.touchmove(e, a, c);
          }
          touchend(e, a, c) {
            const p = this._zoomIn.touchend(e, a, c), y = this._zoomOut.touchend(e, a, c), x = this._tr;
            return p ? (this._active = true, e.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (k) => k.easeTo({ duration: 300, zoom: x.zoom + 1, around: x.unproject(p) }, { originalEvent: e }) }) : y ? (this._active = true, e.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (k) => k.easeTo({ duration: 300, zoom: x.zoom - 1, around: x.unproject(y) }, { originalEvent: e }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class vn {
          constructor(e) {
            this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset();
          }
          reset(e) {
            this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(e);
          }
          _move(...e) {
            const a = this._moveFunction(...e);
            if (a.bearingDelta || a.pitchDelta || a.rollDelta || a.around || a.panDelta) return this._active = true, a;
          }
          dragStart(e, a) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(a) ? a[0] : a, this._activateOnStart && this._lastPoint && (this._active = true));
          }
          dragMove(e, a) {
            if (!this.isEnabled()) return;
            const c = this._lastPoint;
            if (!c) return;
            if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
            const p = Array.isArray(a) ? a[0] : a;
            return !this._moved && p.dist(c) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = p, this._move(c, p));
          }
          dragEnd(e) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && A.suppressClick(), this.reset(e));
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const Vh = 0, io = 2, ls = { [Vh]: 1, [io]: 2 };
        class tl {
          constructor(e) {
            this._correctEvent = e.checkCorrectEvent;
          }
          startMove(e) {
            const a = A.mouseButton(e);
            this._eventButton = a;
          }
          endMove(e) {
            delete this._eventButton;
          }
          isValidStartEvent(e) {
            return this._correctEvent(e);
          }
          isValidMoveEvent(e) {
            return !(function(a, c) {
              const p = ls[c];
              return a.buttons === void 0 || (a.buttons & p) !== p;
            })(e, this._eventButton);
          }
          isValidEndEvent(e) {
            return A.mouseButton(e) === this._eventButton;
          }
        }
        class Op {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(e) {
            return e.targetTouches.length === 1;
          }
          _isSameTouchEvent(e) {
            return e.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(e) {
            this._firstTouch = e.targetTouches[0].identifier;
          }
          endMove(e) {
            delete this._firstTouch;
          }
          isValidStartEvent(e) {
            return this._isOneFingerTouch(e);
          }
          isValidMoveEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
          isValidEndEvent(e) {
            return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
          }
        }
        class $p {
          constructor(e = new tl({ checkCorrectEvent: () => true }), a = new Op()) {
            this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = a;
          }
          _executeRelevantHandler(e, a, c) {
            return e instanceof MouseEvent ? a(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? c(e) : void 0;
          }
          startMove(e) {
            this._executeRelevantHandler(e, ((a) => this.mouseMoveStateManager.startMove(a)), ((a) => this.oneFingerTouchMoveStateManager.startMove(a)));
          }
          endMove(e) {
            this._executeRelevantHandler(e, ((a) => this.mouseMoveStateManager.endMove(a)), ((a) => this.oneFingerTouchMoveStateManager.endMove(a)));
          }
          isValidStartEvent(e) {
            return this._executeRelevantHandler(e, ((a) => this.mouseMoveStateManager.isValidStartEvent(a)), ((a) => this.oneFingerTouchMoveStateManager.isValidStartEvent(a)));
          }
          isValidMoveEvent(e) {
            return this._executeRelevantHandler(e, ((a) => this.mouseMoveStateManager.isValidMoveEvent(a)), ((a) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(a)));
          }
          isValidEndEvent(e) {
            return this._executeRelevantHandler(e, ((a) => this.mouseMoveStateManager.isValidEndEvent(a)), ((a) => this.oneFingerTouchMoveStateManager.isValidEndEvent(a)));
          }
        }
        const lu = (v) => {
          v.mousedown = v.dragStart, v.mousemoveWindow = v.dragMove, v.mouseup = v.dragEnd, v.contextmenu = (e) => {
            e.preventDefault();
          };
        };
        class Uh {
          constructor(e, a) {
            this._clickTolerance = e.clickTolerance || 1, this._map = a, this.reset();
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new s.P(0, 0);
          }
          _shouldBePrevented(e) {
            return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(e, a, c) {
            return this._calculateTransform(e, a, c);
          }
          touchmove(e, a, c) {
            if (this._active) {
              if (!this._shouldBePrevented(c.length)) return e.preventDefault(), this._calculateTransform(e, a, c);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e);
            }
          }
          touchend(e, a, c) {
            this._calculateTransform(e, a, c), this._active && this._shouldBePrevented(c.length) && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(e, a, c) {
            c.length > 0 && (this._active = true);
            const p = ou(c, a), y = new s.P(0, 0), x = new s.P(0, 0);
            let k = 0;
            for (const E in p) {
              const D = p[E], j = this._touches[E];
              j && (y._add(D), x._add(D.sub(j)), k++, p[E] = D);
            }
            if (this._touches = p, this._shouldBePrevented(k) || !x.mag()) return;
            const P = x.div(k);
            return this._sum._add(P), this._sum.mag() < this._clickTolerance ? void 0 : { around: y.div(k), panDelta: P };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class La {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, delete this._firstTwoTouches;
          }
          touchstart(e, a, c) {
            this._firstTwoTouches || c.length < 2 || (this._firstTwoTouches = [c[0].identifier, c[1].identifier], this._start([a[0], a[1]]));
          }
          touchmove(e, a, c) {
            if (!this._firstTwoTouches) return;
            e.preventDefault();
            const [p, y] = this._firstTwoTouches, x = Zn(c, a, p), k = Zn(c, a, y);
            if (!x || !k) return;
            const P = this._aroundCenter ? null : x.add(k).div(2);
            return this._move([x, k], P, e);
          }
          touchend(e, a, c) {
            if (!this._firstTwoTouches) return;
            const [p, y] = this._firstTwoTouches, x = Zn(c, a, p), k = Zn(c, a, y);
            x && k || (this._active && A.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(e) {
            this._enabled = true, this._aroundCenter = !!e && e.around === "center";
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function Zn(v, e, a) {
          for (let c = 0; c < v.length; c++) if (v[c].identifier === a) return e[c];
        }
        function Lt(v, e) {
          return Math.log(v / e) / Math.LN2;
        }
        class qc extends La {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(e) {
            this._startDistance = this._distance = e[0].dist(e[1]);
          }
          _move(e, a) {
            const c = this._distance;
            if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(Lt(this._distance, this._startDistance)) < 0.1)) return this._active = true, { zoomDelta: Lt(this._distance, c), pinchAround: a };
          }
        }
        function uu(v, e) {
          return 180 * v.angleWith(e) / Math.PI;
        }
        class Gc extends La {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(e) {
            this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
          }
          _move(e, a, c) {
            const p = this._vector;
            if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = true, { bearingDelta: uu(this._vector, p), pinchAround: a };
          }
          _isBelowThreshold(e) {
            this._minDiameter = Math.min(this._minDiameter, e.mag());
            const a = 25 / (Math.PI * this._minDiameter) * 360, c = uu(e, this._startVector);
            return Math.abs(c) < a;
          }
        }
        function Ba(v) {
          return Math.abs(v.y) > Math.abs(v.x);
        }
        class us extends La {
          constructor(e) {
            super(), this._currentTouchCount = 0, this._map = e;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(e, a, c) {
            super.touchstart(e, a, c), this._currentTouchCount = c.length;
          }
          _start(e) {
            this._lastPoints = e, Ba(e[0].sub(e[1])) && (this._valid = false);
          }
          _move(e, a, c) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const p = e[0].sub(this._lastPoints[0]), y = e[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(p, y, c.timeStamp), this._valid ? (this._lastPoints = e, this._active = true, { pitchDelta: (p.y + y.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(e, a, c) {
            if (this._valid !== void 0) return this._valid;
            const p = e.mag() >= 2, y = a.mag() >= 2;
            if (!p && !y) return;
            if (!p || !y) return this._firstMove === void 0 && (this._firstMove = c), c - this._firstMove < 100 && void 0;
            const x = e.y > 0 == a.y > 0;
            return Ba(e) && Ba(a) && x;
          }
        }
        const Wc = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class kr {
          constructor(e) {
            this._tr = new ss(e);
            const a = Wc;
            this._panStep = a.panStep, this._bearingStep = a.bearingStep, this._pitchStep = a.pitchStep, this._rotationDisabled = false;
          }
          reset() {
            this._active = false;
          }
          keydown(e) {
            if (e.altKey || e.ctrlKey || e.metaKey) return;
            let a = 0, c = 0, p = 0, y = 0, x = 0;
            switch (e.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                a = 1;
                break;
              case 189:
              case 109:
              case 173:
                a = -1;
                break;
              case 37:
                e.shiftKey ? c = -1 : (e.preventDefault(), y = -1);
                break;
              case 39:
                e.shiftKey ? c = 1 : (e.preventDefault(), y = 1);
                break;
              case 38:
                e.shiftKey ? p = 1 : (e.preventDefault(), x = -1);
                break;
              case 40:
                e.shiftKey ? p = -1 : (e.preventDefault(), x = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (c = 0, p = 0), { cameraAnimation: (k) => {
              const P = this._tr;
              k.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Zc, zoom: a ? Math.round(P.zoom) + a * (e.shiftKey ? 2 : 1) : P.zoom, bearing: P.bearing + c * this._bearingStep, pitch: P.pitch + p * this._pitchStep, offset: [-y * this._panStep, -x * this._panStep], center: P.center }, { originalEvent: e });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function Zc(v) {
          return v * (2 - v);
        }
        const qh = 4.000244140625, Hc = 1 / 450;
        class Gh {
          constructor(e, a) {
            this._onTimeout = (c) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(c);
            }, this._map = e, this._tr = new ss(e), this._triggerRenderFrame = a, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = Hc;
          }
          setZoomRate(e) {
            this._defaultZoomRate = e;
          }
          setWheelZoomRate(e) {
            this._wheelZoomRate = e;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(e) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e && e.around === "center");
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          _shouldBePrevented(e) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e));
          }
          wheel(e) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
            let a = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
            const c = L.now(), p = c - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = c, a !== 0 && a % qh == 0 ? this._type = "wheel" : a !== 0 && Math.abs(a) < 4 ? this._type = "trackpad" : p > 400 ? (this._type = null, this._lastValue = a, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(p * a) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, a += this._lastValue)), e.shiftKey && a && (a /= 4), this._type && (this._lastWheelEvent = e, this._delta -= a, this._active || this._start(e)), e.preventDefault();
          }
          _start(e) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const a = A.mousePos(this._map.getCanvas(), e), c = this._tr;
            this._aroundPoint = this._aroundCenter ? c.transform.locationToScreenPoint(s.S.convert(c.center)) : a, this._frameId || (this._frameId = true, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const e = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const k = e.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += k), typeof this._targetZoom == "number" && (this._targetZoom += k);
            }
            if (this._delta !== 0) {
              const k = this._type === "wheel" && Math.abs(this._delta) > qh ? this._wheelZoomRate : this._defaultZoomRate;
              let P = 2 / (1 + Math.exp(-Math.abs(this._delta * k)));
              this._delta < 0 && P !== 0 && (P = 1 / P);
              const E = typeof this._targetZoom != "number" ? e.scale : s.af(this._targetZoom);
              this._targetZoom = e.getConstrained(e.getCameraLngLat(), s.ak(E * P)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const a = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom, c = this._startZoom, p = this._easing;
            let y, x = false;
            if (this._type === "wheel" && c && p) {
              const k = L.now() - this._lastWheelEventTime, P = Math.min((k + 5) / 200, 1), E = p(P);
              y = s.C.number(c, a, E), P < 1 ? this._frameId || (this._frameId = true) : x = true;
            } else y = a, x = true;
            return this._active = true, x && (this._active = false, this._finishTimeout = setTimeout((() => {
              this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
            }), 200)), this._lastExpectedZoom = y, { noInertia: true, needsRenderFrame: !x, zoomDelta: y - e.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(e) {
            let a = s.co;
            if (this._prevEase) {
              const c = this._prevEase, p = (L.now() - c.start) / c.duration, y = c.easing(p + 0.01) - c.easing(p), x = 0.27 / Math.sqrt(y * y + 1e-4) * 0.01, k = Math.sqrt(0.0729 - x * x);
              a = s.cm(x, k, 0.25, 1);
            }
            return this._prevEase = { start: L.now(), duration: e, easing: a }, a;
          }
          reset() {
            this._active = false, this._zooming = false, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class Wh {
          constructor(e, a) {
            this._clickZoom = e, this._tapZoom = a;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class Zh {
          constructor(e) {
            this._tr = new ss(e), this.reset();
          }
          reset() {
            this._active = false;
          }
          dblclick(e, a) {
            return e.preventDefault(), { cameraAnimation: (c) => {
              c.easeTo({ duration: 300, zoom: this._tr.zoom + (e.shiftKey ? -1 : 1), around: this._tr.unproject(a) }, { originalEvent: e });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Xc {
          constructor() {
            this._tap = new su({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(e, a, c) {
            if (!this._swipePoint) if (this._tapTime) {
              const p = a[0], y = e.timeStamp - this._tapTime < 500, x = this._tapPoint.dist(p) < 30;
              y && x ? c.length > 0 && (this._swipePoint = p, this._swipeTouch = c[0].identifier) : this.reset();
            } else this._tap.touchstart(e, a, c);
          }
          touchmove(e, a, c) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (c[0].identifier !== this._swipeTouch) return;
                const p = a[0], y = p.y - this._swipePoint.y;
                return this._swipePoint = p, e.preventDefault(), this._active = true, { zoomDelta: y / 128 };
              }
            } else this._tap.touchmove(e, a, c);
          }
          touchend(e, a, c) {
            if (this._tapTime) this._swipePoint && c.length === 0 && this.reset();
            else {
              const p = this._tap.touchend(e, a, c);
              p && (this._tapTime = e.timeStamp, this._tapPoint = p);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Yc {
          constructor(e, a, c) {
            this._el = e, this._mousePan = a, this._touchPan = c;
          }
          enable(e) {
            this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Hh {
          constructor(e, a, c, p) {
            this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = a, this._mousePitch = c, this._mouseRoll = p;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
          }
        }
        class Kc {
          constructor(e, a, c, p) {
            this._el = e, this._touchZoom = a, this._touchRotate = c, this._tapDragZoom = p, this._rotationDisabled = false, this._enabled = true;
          }
          enable(e) {
            this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class Xh {
          constructor(e, a) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = a, this._enabled = false;
          }
          isActive() {
            return false;
          }
          reset() {
          }
          _setupUI() {
            if (this._container) return;
            const e = this._map.getCanvasContainer();
            e.classList.add("maplibregl-cooperative-gestures"), this._container = A.create("div", "maplibregl-cooperative-gesture-screen", e);
            let a = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (a = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const c = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), p = document.createElement("div");
            p.className = "maplibregl-desktop-message", p.textContent = a, this._container.appendChild(p);
            const y = document.createElement("div");
            y.className = "maplibregl-mobile-message", y.textContent = c, this._container.appendChild(y), this._container.setAttribute("aria-hidden", "true");
          }
          _destroyUI() {
            this._container && (A.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = true;
          }
          disable() {
            this._enabled = false, this._destroyUI();
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(e) {
            return e[this._bypassKey];
          }
          notifyGestureBlocked(e, a) {
            this._enabled && (this._map.fire(new s.l("cooperativegestureprevented", { gestureType: e, originalEvent: a })), this._container.classList.add("maplibregl-show"), setTimeout((() => {
              this._container.classList.remove("maplibregl-show");
            }), 100));
          }
        }
        const cu = (v) => v.zoom || v.drag || v.roll || v.pitch || v.rotate;
        class na extends s.l {
        }
        function qr(v) {
          return v.panDelta && v.panDelta.mag() || v.zoomDelta || v.bearingDelta || v.pitchDelta || v.rollDelta;
        }
        class jp {
          constructor(e, a) {
            this.handleWindowEvent = (p) => {
              this.handleEvent(p, `${p.type}Window`);
            }, this.handleEvent = (p, y) => {
              if (p.type === "blur") return void this.stop(true);
              this._updatingCamera = true;
              const x = p.type === "renderFrame" ? void 0 : p, k = { needsRenderFrame: false }, P = {}, E = {};
              for (const { handlerName: $, handler: U, allowed: Y } of this._handlers) {
                if (!U.isEnabled()) continue;
                let se;
                if (this._blockedByActive(E, Y, $)) U.reset();
                else if (U[y || p.type]) {
                  if (s.cp(p, y || p.type)) {
                    const le = A.mousePos(this._map.getCanvas(), p);
                    se = U[y || p.type](p, le);
                  } else if (s.cq(p, y || p.type)) {
                    const le = this._getMapTouches(p.touches), ce = A.touchPos(this._map.getCanvas(), le);
                    se = U[y || p.type](p, ce, le);
                  } else s.cr(y || p.type) || (se = U[y || p.type](p));
                  this.mergeHandlerResult(k, P, se, $, x), se && se.needsRenderFrame && this._triggerRenderFrame();
                }
                (se || U.isActive()) && (E[$] = U);
              }
              const D = {};
              for (const $ in this._previousActiveHandlers) E[$] || (D[$] = x);
              this._previousActiveHandlers = E, (Object.keys(D).length || qr(k)) && (this._changes.push([k, P, D]), this._triggerRenderFrame()), (Object.keys(E).length || qr(k)) && this._map._stop(true), this._updatingCamera = false;
              const { cameraAnimation: j } = k;
              j && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], j(this._map));
            }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new $h(e), this._bearingSnap = a.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(a);
            const c = this._el;
            this._listeners = [[c, "touchstart", { passive: true }], [c, "touchmove", { passive: false }], [c, "touchend", void 0], [c, "touchcancel", void 0], [c, "mousedown", void 0], [c, "mousemove", void 0], [c, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [c, "mouseover", void 0], [c, "mouseout", void 0], [c, "dblclick", void 0], [c, "click", void 0], [c, "keydown", { capture: false }], [c, "keyup", void 0], [c, "wheel", { passive: false }], [c, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [p, y, x] of this._listeners) A.addEventListener(p, y, p === document ? this.handleWindowEvent : this.handleEvent, x);
          }
          destroy() {
            for (const [e, a, c] of this._listeners) A.removeEventListener(e, a, e === document ? this.handleWindowEvent : this.handleEvent, c);
          }
          _addDefaultHandlers(e) {
            const a = this._map, c = a.getCanvasContainer();
            this._add("mapEvent", new jh(a, e));
            const p = a.boxZoom = new Uc(a, e);
            this._add("boxZoom", p), e.interactive && e.boxZoom && p.enable();
            const y = a.cooperativeGestures = new Xh(a, e.cooperativeGestures);
            this._add("cooperativeGestures", y), e.cooperativeGestures && y.enable();
            const x = new Wn(a), k = new Zh(a);
            a.doubleClickZoom = new Wh(k, x), this._add("tapZoom", x), this._add("clickZoom", k), e.interactive && e.doubleClickZoom && a.doubleClickZoom.enable();
            const P = new Xc();
            this._add("tapDragZoom", P);
            const E = a.touchPitch = new us(a);
            this._add("touchPitch", E), e.interactive && e.touchPitch && a.touchPitch.enable(e.touchPitch);
            const D = () => a.project(a.getCenter()), j = (function({ enable: _e, clickTolerance: Pe, aroundCenter: Me = true, minPixelCenterThreshold: ye = 100, rotateDegreesPerPixelMoved: Be = 0.8 }, Je) {
              const We = new tl({ checkCorrectEvent: (Ze) => A.mouseButton(Ze) === 0 && Ze.ctrlKey || A.mouseButton(Ze) === 2 && !Ze.ctrlKey });
              return new vn({ clickTolerance: Pe, move: (Ze, Qe) => {
                const It = Je();
                if (Me && Math.abs(It.y - Ze.y) > ye) return { bearingDelta: s.cn(new s.P(Ze.x, Qe.y), Qe, It) };
                let Pt = (Qe.x - Ze.x) * Be;
                return Me && Qe.y < It.y && (Pt = -Pt), { bearingDelta: Pt };
              }, moveStateManager: We, enable: _e, assignEvents: lu });
            })(e, D), $ = (function({ enable: _e, clickTolerance: Pe, pitchDegreesPerPixelMoved: Me = -0.5 }) {
              const ye = new tl({ checkCorrectEvent: (Be) => A.mouseButton(Be) === 0 && Be.ctrlKey || A.mouseButton(Be) === 2 });
              return new vn({ clickTolerance: Pe, move: (Be, Je) => ({ pitchDelta: (Je.y - Be.y) * Me }), moveStateManager: ye, enable: _e, assignEvents: lu });
            })(e), U = (function({ enable: _e, clickTolerance: Pe, rollDegreesPerPixelMoved: Me = 0.3 }, ye) {
              const Be = new tl({ checkCorrectEvent: (Je) => A.mouseButton(Je) === 2 && Je.ctrlKey });
              return new vn({ clickTolerance: Pe, move: (Je, We) => {
                const Ze = ye();
                let Qe = (We.x - Je.x) * Me;
                return We.y < Ze.y && (Qe = -Qe), { rollDelta: Qe };
              }, moveStateManager: Be, enable: _e, assignEvents: lu });
            })(e, D);
            a.dragRotate = new Hh(e, j, $, U), this._add("mouseRotate", j, ["mousePitch"]), this._add("mousePitch", $, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", U, ["mousePitch"]), e.interactive && e.dragRotate && a.dragRotate.enable();
            const Y = (function({ enable: _e, clickTolerance: Pe }) {
              const Me = new tl({ checkCorrectEvent: (ye) => A.mouseButton(ye) === 0 && !ye.ctrlKey });
              return new vn({ clickTolerance: Pe, move: (ye, Be) => ({ around: Be, panDelta: Be.sub(ye) }), activateOnStart: true, moveStateManager: Me, enable: _e, assignEvents: lu });
            })(e), se = new Uh(e, a);
            a.dragPan = new Yc(c, Y, se), this._add("mousePan", Y), this._add("touchPan", se, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && a.dragPan.enable(e.dragPan);
            const le = new Gc(), ce = new qc();
            a.touchZoomRotate = new Kc(c, ce, le, P), this._add("touchRotate", le, ["touchPan", "touchZoom"]), this._add("touchZoom", ce, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && a.touchZoomRotate.enable(e.touchZoomRotate);
            const me = a.scrollZoom = new Gh(a, (() => this._triggerRenderFrame()));
            this._add("scrollZoom", me, ["mousePan"]), e.interactive && e.scrollZoom && a.scrollZoom.enable(e.scrollZoom);
            const we = a.keyboard = new kr(a);
            this._add("keyboard", we), e.interactive && e.keyboard && a.keyboard.enable(), this._add("blockableMapEvent", new Nh(a));
          }
          _add(e, a, c) {
            this._handlers.push({ handlerName: e, handler: a, allowed: c }), this._handlersById[e] = a;
          }
          stop(e) {
            if (!this._updatingCamera) {
              for (const { handler: a } of this._handlers) a.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: e } of this._handlers) if (e.isActive()) return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!cu(this._eventsInProgress) || this.isZooming();
          }
          _blockedByActive(e, a, c) {
            for (const p in e) if (p !== c && (!a || a.indexOf(p) < 0)) return true;
            return false;
          }
          _getMapTouches(e) {
            const a = [];
            for (const c of e) this._el.contains(c.target) && a.push(c);
            return a;
          }
          mergeHandlerResult(e, a, c, p, y) {
            if (!c) return;
            s.e(e, c);
            const x = { handlerName: p, originalEvent: c.originalEvent || y };
            c.zoomDelta !== void 0 && (a.zoom = x), c.panDelta !== void 0 && (a.drag = x), c.rollDelta !== void 0 && (a.roll = x), c.pitchDelta !== void 0 && (a.pitch = x), c.bearingDelta !== void 0 && (a.rotate = x);
          }
          _applyChanges() {
            const e = {}, a = {}, c = {};
            for (const [p, y, x] of this._changes) p.panDelta && (e.panDelta = (e.panDelta || new s.P(0, 0))._add(p.panDelta)), p.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + p.zoomDelta), p.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + p.bearingDelta), p.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + p.pitchDelta), p.rollDelta && (e.rollDelta = (e.rollDelta || 0) + p.rollDelta), p.around !== void 0 && (e.around = p.around), p.pinchAround !== void 0 && (e.pinchAround = p.pinchAround), p.noInertia && (e.noInertia = p.noInertia), s.e(a, y), s.e(c, x);
            this._updateMapTransform(e, a, c), this._changes = [];
          }
          _updateMapTransform(e, a, c) {
            const p = this._map, y = p._getTransformForUpdate(), x = p.terrain;
            if (!(qr(e) || x && this._terrainMovement)) return this._fireEvents(a, c, true);
            p._stop(true);
            let { panDelta: k, zoomDelta: P, bearingDelta: E, pitchDelta: D, rollDelta: j, around: $, pinchAround: U } = e;
            U !== void 0 && ($ = U), $ = $ || p.transform.centerPoint, x && !y.isPointOnMapSurface($) && ($ = y.centerPoint);
            const Y = { panDelta: k, zoomDelta: P, rollDelta: j, pitchDelta: D, bearingDelta: E, around: $ };
            this._map.cameraHelper.useGlobeControls && !y.isPointOnMapSurface($) && ($ = y.centerPoint);
            const se = $.distSqr(y.centerPoint) < 0.01 ? y.center : y.screenPointToLocation(k ? $.sub(k) : $);
            x ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(Y, y), this._terrainMovement || !a.drag && !a.zoom ? a.drag && this._terrainMovement ? y.setCenter(y.screenPointToLocation(y.centerPoint.sub(k))) : this._map.cameraHelper.handleMapControlsPan(Y, y, se) : (this._terrainMovement = true, this._map._elevationFreeze = true, this._map.cameraHelper.handleMapControlsPan(Y, y, se))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(Y, y), this._map.cameraHelper.handleMapControlsPan(Y, y, se)), p._applyUpdatedTransform(y), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(a, c, true);
          }
          _fireEvents(e, a, c) {
            const p = cu(this._eventsInProgress), y = cu(e), x = {};
            for (const j in e) {
              const { originalEvent: $ } = e[j];
              this._eventsInProgress[j] || (x[`${j}start`] = $), this._eventsInProgress[j] = e[j];
            }
            !p && y && this._fireEvent("movestart", y.originalEvent);
            for (const j in x) this._fireEvent(j, x[j]);
            y && this._fireEvent("move", y.originalEvent);
            for (const j in e) {
              const { originalEvent: $ } = e[j];
              this._fireEvent(j, $);
            }
            const k = {};
            let P;
            for (const j in this._eventsInProgress) {
              const { handlerName: $, originalEvent: U } = this._eventsInProgress[j];
              this._handlersById[$].isActive() || (delete this._eventsInProgress[j], P = a[$] || U, k[`${j}end`] = P);
            }
            for (const j in k) this._fireEvent(j, k[j]);
            const E = cu(this._eventsInProgress), D = (p || y) && !E;
            if (D && this._terrainMovement) {
              this._map._elevationFreeze = false, this._terrainMovement = false;
              const j = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && j.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(j);
            }
            if (c && D) {
              this._updatingCamera = true;
              const j = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), $ = (U) => U !== 0 && -this._bearingSnap < U && U < this._bearingSnap;
              !j || !j.essential && L.prefersReducedMotion ? (this._map.fire(new s.l("moveend", { originalEvent: P })), $(this._map.getBearing()) && this._map.resetNorth()) : ($(j.bearing || this._map.getBearing()) && (j.bearing = 0), j.freezeElevation = true, this._map.easeTo(j, { originalEvent: P })), this._updatingCamera = false;
            }
          }
          _fireEvent(e, a) {
            this._map.fire(new s.l(e, a ? { originalEvent: a } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add(((e) => {
              delete this._frameId, this.handleEvent(new na("renderFrame", { timeStamp: e })), this._applyChanges();
            }));
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        class du extends s.E {
          constructor(e, a, c) {
            super(), this._renderFrameCallback = () => {
              const p = Math.min((L.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(p)), p < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = false, this._zooming = false, this.transform = e, this._bearingSnap = c.bearingSnap, this.cameraHelper = a, this.on("moveend", (() => {
              delete this._requestedCameraState;
            }));
          }
          migrateProjection(e, a) {
            e.apply(this.transform), this.transform = e, this.cameraHelper = a;
          }
          getCenter() {
            return new s.S(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(e, a) {
            return this.jumpTo({ center: e }, a);
          }
          getCenterElevation() {
            return this.transform.elevation;
          }
          setCenterElevation(e, a) {
            return this.jumpTo({ elevation: e }, a), this;
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround;
          }
          setCenterClampedToGround(e) {
            this._centerClampedToGround = e;
          }
          panBy(e, a, c) {
            return e = s.P.convert(e).mult(-1), this.panTo(this.transform.center, s.e({ offset: e }, a), c);
          }
          panTo(e, a, c) {
            return this.easeTo(s.e({ center: e }, a), c);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(e, a) {
            return this.jumpTo({ zoom: e }, a), this;
          }
          zoomTo(e, a, c) {
            return this.easeTo(s.e({ zoom: e }, a), c);
          }
          zoomIn(e, a) {
            return this.zoomTo(this.getZoom() + 1, e, a), this;
          }
          zoomOut(e, a) {
            return this.zoomTo(this.getZoom() - 1, e, a), this;
          }
          getVerticalFieldOfView() {
            return this.transform.fov;
          }
          setVerticalFieldOfView(e, a) {
            return e != this.transform.fov && (this.transform.setFov(e), this.fire(new s.l("movestart", a)).fire(new s.l("move", a)).fire(new s.l("moveend", a))), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(e, a) {
            return this.jumpTo({ bearing: e }, a), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(e, a) {
            return this.jumpTo({ padding: e }, a), this;
          }
          rotateTo(e, a, c) {
            return this.easeTo(s.e({ bearing: e }, a), c);
          }
          resetNorth(e, a) {
            return this.rotateTo(0, s.e({ duration: 1e3 }, e), a), this;
          }
          resetNorthPitch(e, a) {
            return this.easeTo(s.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e), a), this;
          }
          snapToNorth(e, a) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, a) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(e, a) {
            return this.jumpTo({ pitch: e }, a), this;
          }
          getRoll() {
            return this.transform.roll;
          }
          setRoll(e, a) {
            return this.jumpTo({ roll: e }, a), this;
          }
          cameraForBounds(e, a) {
            e = sr.convert(e).adjustAntiMeridian();
            const c = a && a.bearing || 0;
            return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), c, a);
          }
          _cameraForBoxAndBearing(e, a, c, p) {
            const y = { top: 0, bottom: 0, right: 0, left: 0 };
            if (typeof (p = s.e({ padding: y, offset: [0, 0], maxZoom: this.transform.maxZoom }, p)).padding == "number") {
              const E = p.padding;
              p.padding = { top: E, bottom: E, right: E, left: E };
            }
            const x = s.e(y, p.padding);
            p.padding = x;
            const k = this.transform, P = new sr(e, a);
            return this.cameraHelper.cameraForBoxAndBearing(p, x, P, c, k);
          }
          fitBounds(e, a, c) {
            return this._fitInternal(this.cameraForBounds(e, a), a, c);
          }
          fitScreenCoordinates(e, a, c, p, y) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(s.P.convert(e)), this.transform.screenPointToLocation(s.P.convert(a)), c, p), p, y);
          }
          _fitInternal(e, a, c) {
            return e ? (delete (a = s.e(e, a)).padding, a.linear ? this.easeTo(a, c) : this.flyTo(a, c)) : this;
          }
          jumpTo(e, a) {
            this.stop();
            const c = this._getTransformForUpdate();
            let p = false, y = false, x = false;
            const k = c.zoom;
            this.cameraHelper.handleJumpToCenterZoom(c, e);
            const P = c.zoom !== k;
            return "elevation" in e && c.elevation !== +e.elevation && c.setElevation(+e.elevation), "bearing" in e && c.bearing !== +e.bearing && (p = true, c.setBearing(+e.bearing)), "pitch" in e && c.pitch !== +e.pitch && (y = true, c.setPitch(+e.pitch)), "roll" in e && c.roll !== +e.roll && (x = true, c.setRoll(+e.roll)), e.padding == null || c.isPaddingEqual(e.padding) || c.setPadding(e.padding), this._applyUpdatedTransform(c), this.fire(new s.l("movestart", a)).fire(new s.l("move", a)), P && this.fire(new s.l("zoomstart", a)).fire(new s.l("zoom", a)).fire(new s.l("zoomend", a)), p && this.fire(new s.l("rotatestart", a)).fire(new s.l("rotate", a)).fire(new s.l("rotateend", a)), y && this.fire(new s.l("pitchstart", a)).fire(new s.l("pitch", a)).fire(new s.l("pitchend", a)), x && this.fire(new s.l("rollstart", a)).fire(new s.l("roll", a)).fire(new s.l("rollend", a)), this.fire(new s.l("moveend", a));
          }
          calculateCameraOptionsFromTo(e, a, c, p = 0) {
            const y = s.a1.fromLngLat(e, a), x = s.a1.fromLngLat(c, p), k = x.x - y.x, P = x.y - y.y, E = x.z - y.z, D = Math.hypot(k, P, E);
            if (D === 0) throw new Error("Can't calculate camera options with same From and To");
            const j = Math.hypot(k, P), $ = s.ak(this.transform.cameraToCenterDistance / D / this.transform.tileSize), U = 180 * Math.atan2(k, -P) / Math.PI;
            let Y = 180 * Math.acos(j / D) / Math.PI;
            return Y = E < 0 ? 90 - Y : 90 + Y, { center: x.toLngLat(), elevation: p, zoom: $, pitch: Y, bearing: U };
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e, a, c, p, y) {
            const x = this.transform.calculateCenterFromCameraLngLatAlt(e, a, c, p);
            return { center: x.center, elevation: x.elevation, zoom: x.zoom, bearing: c, pitch: p, roll: y };
          }
          easeTo(e, a) {
            this._stop(false, e.easeId), ((e = s.e({ offset: [0, 0], duration: 500, easing: s.co }, e)).animate === false || !e.essential && L.prefersReducedMotion) && (e.duration = 0);
            const c = this._getTransformForUpdate(), p = this.getBearing(), y = c.pitch, x = c.roll, k = "bearing" in e ? this._normalizeBearing(e.bearing, p) : p, P = "pitch" in e ? +e.pitch : y, E = "roll" in e ? this._normalizeBearing(e.roll, x) : x, D = "padding" in e ? e.padding : c.padding, j = s.P.convert(e.offset);
            let $, U;
            e.around && ($ = s.S.convert(e.around), U = c.locationToScreenPoint($));
            const Y = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, se = this.cameraHelper.handleEaseTo(c, { bearing: k, pitch: P, roll: E, padding: D, around: $, aroundPoint: U, offsetAsPoint: j, offset: e.offset, zoom: e.zoom, center: e.center });
            return this._rotating = this._rotating || p !== k, this._pitching = this._pitching || P !== y, this._rolling = this._rolling || E !== x, this._padding = !c.isPaddingEqual(D), this._zooming = this._zooming || se.isZooming, this._easeId = e.easeId, this._prepareEase(a, e.noMoveStart, Y), this.terrain && this._prepareElevation(se.elevationCenter), this._ease(((le) => {
              se.easeFunc(le), this.terrain && !e.freezeElevation && this._updateElevation(le), this._applyUpdatedTransform(c), this._fireMoveEvents(a);
            }), ((le) => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(a, le);
            }), e), this;
          }
          _prepareEase(e, a, c = {}) {
            this._moving = true, a || c.moving || this.fire(new s.l("movestart", e)), this._zooming && !c.zooming && this.fire(new s.l("zoomstart", e)), this._rotating && !c.rotating && this.fire(new s.l("rotatestart", e)), this._pitching && !c.pitching && this.fire(new s.l("pitchstart", e)), this._rolling && !c.rolling && this.fire(new s.l("rollstart", e));
          }
          _prepareElevation(e) {
            this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = true;
          }
          _updateElevation(e) {
            this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const a = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e < 1 && a !== this._elevationTarget) {
              const c = this._elevationTarget - this._elevationStart;
              this._elevationStart += e * (c - (a - (c * e + this._elevationStart)) / (1 - e)), this._elevationTarget = a;
            }
            this.transform.setElevation(s.C.number(this._elevationStart, this._elevationTarget, e));
          }
          _finalizeElevation() {
            this._elevationFreeze = false, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _elevateCameraIfInsideTerrain(e) {
            if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
            const a = e.getCameraLngLat(), c = e.getCameraAltitude(), p = this.terrain ? this.terrain.getElevationForLngLatZoom(a, e.zoom) : 0;
            if (c < p) {
              const y = this.calculateCameraOptionsFromTo(a, p, e.center, e.elevation);
              return { pitch: y.pitch, zoom: y.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(e) {
            const a = [];
            if (a.push(((p) => this._elevateCameraIfInsideTerrain(p))), this.transformCameraUpdate && a.push(((p) => this.transformCameraUpdate(p))), !a.length) return;
            const c = e.clone();
            for (const p of a) {
              const y = c.clone(), { center: x, zoom: k, roll: P, pitch: E, bearing: D, elevation: j } = p(y);
              x && y.setCenter(x), j !== void 0 && y.setElevation(j), k !== void 0 && y.setZoom(k), P !== void 0 && y.setRoll(P), E !== void 0 && y.setPitch(E), D !== void 0 && y.setBearing(D), c.apply(y);
            }
            this.transform.apply(c);
          }
          _fireMoveEvents(e) {
            this.fire(new s.l("move", e)), this._zooming && this.fire(new s.l("zoom", e)), this._rotating && this.fire(new s.l("rotate", e)), this._pitching && this.fire(new s.l("pitch", e)), this._rolling && this.fire(new s.l("roll", e));
          }
          _afterEase(e, a) {
            if (this._easeId && a && this._easeId === a) return;
            delete this._easeId;
            const c = this._zooming, p = this._rotating, y = this._pitching, x = this._rolling;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._rolling = false, this._padding = false, c && this.fire(new s.l("zoomend", e)), p && this.fire(new s.l("rotateend", e)), y && this.fire(new s.l("pitchend", e)), x && this.fire(new s.l("rollend", e)), this.fire(new s.l("moveend", e));
          }
          flyTo(e, a) {
            if (!e.essential && L.prefersReducedMotion) {
              const Qe = s.Q(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
              return this.jumpTo(Qe, a);
            }
            this.stop(), e = s.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: s.co }, e);
            const c = this._getTransformForUpdate(), p = c.bearing, y = c.pitch, x = c.roll, k = c.padding, P = "bearing" in e ? this._normalizeBearing(e.bearing, p) : p, E = "pitch" in e ? +e.pitch : y, D = "roll" in e ? this._normalizeBearing(e.roll, x) : x, j = "padding" in e ? e.padding : c.padding, $ = s.P.convert(e.offset);
            let U = c.centerPoint.add($);
            const Y = c.screenPointToLocation(U), se = this.cameraHelper.handleFlyTo(c, { bearing: P, pitch: E, roll: D, padding: j, locationAtOffset: Y, offsetAsPoint: $, center: e.center, minZoom: e.minZoom, zoom: e.zoom });
            let le = e.curve;
            const ce = Math.max(c.width, c.height), me = ce / se.scaleOfZoom, we = se.pixelPathLength;
            typeof se.scaleOfMinZoom == "number" && (le = Math.sqrt(ce / se.scaleOfMinZoom / we * 2));
            const _e = le * le;
            function Pe(Qe) {
              const It = (me * me - ce * ce + (Qe ? -1 : 1) * _e * _e * we * we) / (2 * (Qe ? me : ce) * _e * we);
              return Math.log(Math.sqrt(It * It + 1) - It);
            }
            function Me(Qe) {
              return (Math.exp(Qe) - Math.exp(-Qe)) / 2;
            }
            function ye(Qe) {
              return (Math.exp(Qe) + Math.exp(-Qe)) / 2;
            }
            const Be = Pe(false);
            let Je = function(Qe) {
              return ye(Be) / ye(Be + le * Qe);
            }, We = function(Qe) {
              return ce * ((ye(Be) * (Me(It = Be + le * Qe) / ye(It)) - Me(Be)) / _e) / we;
              var It;
            }, Ze = (Pe(true) - Be) / le;
            if (Math.abs(we) < 2e-6 || !isFinite(Ze)) {
              if (Math.abs(ce - me) < 1e-6) return this.easeTo(e, a);
              const Qe = me < ce ? -1 : 1;
              Ze = Math.abs(Math.log(me / ce)) / le, We = () => 0, Je = (It) => Math.exp(Qe * le * It);
            }
            return e.duration = "duration" in e ? +e.duration : 1e3 * Ze / ("screenSpeed" in e ? +e.screenSpeed / le : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = true, this._rotating = p !== P, this._pitching = E !== y, this._rolling = D !== x, this._padding = !c.isPaddingEqual(j), this._prepareEase(a, false), this.terrain && this._prepareElevation(se.targetCenter), this._ease(((Qe) => {
              const It = Qe * Ze, Pt = 1 / Je(It), pt = We(It);
              this._rotating && c.setBearing(s.C.number(p, P, Qe)), this._pitching && c.setPitch(s.C.number(y, E, Qe)), this._rolling && c.setRoll(s.C.number(x, D, Qe)), this._padding && (c.interpolatePadding(k, j, Qe), U = c.centerPoint.add($)), se.easeFunc(Qe, Pt, pt, U), this.terrain && !e.freezeElevation && this._updateElevation(Qe), this._applyUpdatedTransform(c), this._fireMoveEvents(a);
            }), (() => {
              this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(a);
            }), e), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(e, a) {
            var c;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const p = this._onEaseEnd;
              delete this._onEaseEnd, p.call(this, a);
            }
            return e || (c = this.handlers) === null || c === void 0 || c.stop(false), this;
          }
          _ease(e, a, c) {
            c.animate === false || c.duration === 0 ? (e(1), a()) : (this._easeStart = L.now(), this._easeOptions = c, this._onEaseFrame = e, this._onEaseEnd = a, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(e, a) {
            e = s.aO(e, -180, 180);
            const c = Math.abs(e - a);
            return Math.abs(e - 360 - a) < c && (e -= 360), Math.abs(e + 360 - a) < c && (e += 360), e;
          }
          queryTerrainElevation(e) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(s.S.convert(e), this.transform.tileZoom) : null;
          }
        }
        const hu = { compact: true, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class Jc {
          constructor(e = hu) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (a) => {
              !a || a.sourceDataType !== "metadata" && a.sourceDataType !== "visibility" && a.dataType !== "style" && a.type !== "terrain" || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === false ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = e;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(e) {
            return this._map = e, this._compact = this.options.compact, this._container = A.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = A.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = A.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            A.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(e, a) {
            const c = this._map._getUIString(`AttributionControl.${a}`);
            e.title = c, e.setAttribute("aria-label", c);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map(((p) => typeof p != "string" ? "" : p))) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const p = this._map.style.stylesheet;
              this.styleOwner = p.owner, this.styleId = p.id;
            }
            const a = this._map.style.sourceCaches;
            for (const p in a) {
              const y = a[p];
              if (y.used || y.usedForTerrain) {
                const x = y.getSource();
                x.attribution && e.indexOf(x.attribution) < 0 && e.push(x.attribution);
              }
            }
            e = e.filter(((p) => String(p).trim())), e.sort(((p, y) => p.length - y.length)), e = e.filter(((p, y) => {
              for (let x = y + 1; x < e.length; x++) if (e[x].indexOf(p) >= 0) return false;
              return true;
            }));
            const c = e.join(" | ");
            c !== this._attribHTML && (this._attribHTML = c, e.length ? (this._innerContainer.innerHTML = A.sanitize(c), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class Qc {
          constructor(e = {}) {
            this._updateCompact = () => {
              const a = this._container.children;
              if (a.length) {
                const c = a[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== false && c.classList.add("maplibregl-compact") : c.classList.remove("maplibregl-compact");
              }
            }, this.options = e;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(e) {
            this._map = e, this._compact = this.options && this.options.compact, this._container = A.create("div", "maplibregl-ctrl");
            const a = A.create("a", "maplibregl-ctrl-logo");
            return a.target = "_blank", a.rel = "noopener nofollow", a.href = "https://maplibre.org/", a.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), a.setAttribute("rel", "noopener nofollow"), this._container.appendChild(a), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            A.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class Yh {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(e) {
            const a = ++this._id;
            return this._queue.push({ callback: e, id: a, cancelled: false }), a;
          }
          remove(e) {
            const a = this._currentlyRunning, c = a ? this._queue.concat(a) : this._queue;
            for (const p of c) if (p.id === e) return void (p.cancelled = true);
          }
          run(e = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const a = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const c of a) if (!c.cancelled && (c.callback(e), this._cleared)) break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        var Np = s.aJ([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class So extends s.E {
          constructor(e) {
            super(), this._lastTilesetChange = L.now(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = true, e.tileSize = this.tileSize;
          }
          destruct() {
            this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
          }
          update(e, a) {
            this.sourceCache.update(e, a), this._renderableTilesKeys = [];
            const c = {};
            for (const p of Te(e, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: a, calculateTileZoom: this.sourceCache._source.calculateTileZoom })) c[p.key] = true, this._renderableTilesKeys.push(p.key), this._tiles[p.key] || (p.terrainRttPosMatrix32f = new Float64Array(16), s.bY(p.terrainRttPosMatrix32f, 0, s.$, s.$, 0, 0, 1), this._tiles[p.key] = new Si(p, this.tileSize), this._lastTilesetChange = L.now());
            for (const p in this._tiles) c[p] || delete this._tiles[p];
          }
          freeRtt(e) {
            for (const a in this._tiles) {
              const c = this._tiles[a];
              (!e || c.tileID.equals(e) || c.tileID.isChildOf(e) || e.isChildOf(c.tileID)) && (c.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map(((e) => this.getTileByID(e)));
          }
          getTileByID(e) {
            return this._tiles[e];
          }
          getTerrainCoords(e, a) {
            return a ? this._getTerrainCoordsForTileRanges(e, a) : this._getTerrainCoordsForRegularTile(e);
          }
          _getTerrainCoordsForRegularTile(e) {
            const a = {};
            for (const c of this._renderableTilesKeys) {
              const p = this._tiles[c].tileID, y = e.clone(), x = s.ba();
              if (p.canonical.equals(e.canonical)) s.bY(x, 0, s.$, s.$, 0, 0, 1);
              else if (p.canonical.isChildOf(e.canonical)) {
                const k = p.canonical.z - e.canonical.z, P = p.canonical.x - (p.canonical.x >> k << k), E = p.canonical.y - (p.canonical.y >> k << k), D = s.$ >> k;
                s.bY(x, 0, D, D, 0, 0, 1), s.M(x, x, [-P * D, -E * D, 0]);
              } else {
                if (!e.canonical.isChildOf(p.canonical)) continue;
                {
                  const k = e.canonical.z - p.canonical.z, P = e.canonical.x - (e.canonical.x >> k << k), E = e.canonical.y - (e.canonical.y >> k << k), D = s.$ >> k;
                  s.bY(x, 0, s.$, s.$, 0, 0, 1), s.M(x, x, [P * D, E * D, 0]), s.N(x, x, [1 / 2 ** k, 1 / 2 ** k, 0]);
                }
              }
              y.terrainRttPosMatrix32f = new Float32Array(x), a[c] = y;
            }
            return a;
          }
          _getTerrainCoordsForTileRanges(e, a) {
            const c = {};
            for (const p of this._renderableTilesKeys) {
              const y = this._tiles[p].tileID;
              if (!this._isWithinTileRanges(y, a)) continue;
              const x = e.clone(), k = s.ba();
              if (y.canonical.z === e.canonical.z) {
                const P = e.canonical.x - y.canonical.x, E = e.canonical.y - y.canonical.y;
                s.bY(k, 0, s.$, s.$, 0, 0, 1), s.M(k, k, [P * s.$, E * s.$, 0]);
              } else if (y.canonical.z > e.canonical.z) {
                const P = y.canonical.z - e.canonical.z, E = y.canonical.x - (y.canonical.x >> P << P), D = y.canonical.y - (y.canonical.y >> P << P), j = e.canonical.x - (y.canonical.x >> P), $ = e.canonical.y - (y.canonical.y >> P), U = s.$ >> P;
                s.bY(k, 0, U, U, 0, 0, 1), s.M(k, k, [-E * U + j * s.$, -D * U + $ * s.$, 0]);
              } else {
                const P = e.canonical.z - y.canonical.z, E = e.canonical.x - (e.canonical.x >> P << P), D = e.canonical.y - (e.canonical.y >> P << P), j = (e.canonical.x >> P) - y.canonical.x, $ = (e.canonical.y >> P) - y.canonical.y, U = s.$ << P;
                s.bY(k, 0, U, U, 0, 0, 1), s.M(k, k, [E * s.$ + j * U, D * s.$ + $ * U, 0]);
              }
              x.terrainRttPosMatrix32f = new Float32Array(k), c[p] = x;
            }
            return c;
          }
          getSourceTile(e, a) {
            const c = this.sourceCache._source;
            let p = e.overscaledZ - this.deltaZoom;
            if (p > c.maxzoom && (p = c.maxzoom), p < c.minzoom) return null;
            this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(p).key);
            let y = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
            if ((!y || !y.dem) && a) for (; p >= c.minzoom && (!y || !y.dem); ) y = this.sourceCache.getTileByID(e.scaledTo(p--).key);
            return y;
          }
          anyTilesAfterTime(e = Date.now()) {
            return this._lastTilesetChange >= e;
          }
          _isWithinTileRanges(e, a) {
            return a[e.canonical.z] && e.canonical.x >= a[e.canonical.z].minTileX && e.canonical.x <= a[e.canonical.z].maxTileX && e.canonical.y >= a[e.canonical.z].minTileY && e.canonical.y <= a[e.canonical.z].maxTileY;
          }
        }
        class fu {
          constructor(e, a, c) {
            this._meshCache = {}, this.painter = e, this.sourceCache = new So(a), this.options = c, this.exaggeration = typeof c.exaggeration == "number" ? c.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(e, a, c, p = s.$) {
            var y;
            if (!(a >= 0 && a < p && c >= 0 && c < p)) return 0;
            const x = this.getTerrainData(e), k = (y = x.tile) === null || y === void 0 ? void 0 : y.dem;
            if (!k) return 0;
            const P = s.cs([], [a / p * s.$, c / p * s.$], x.u_terrain_matrix), E = [P[0] * k.dim, P[1] * k.dim], D = Math.floor(E[0]), j = Math.floor(E[1]), $ = E[0] - D, U = E[1] - j;
            return k.get(D, j) * (1 - $) * (1 - U) + k.get(D + 1, j) * $ * (1 - U) + k.get(D, j + 1) * (1 - $) * U + k.get(D + 1, j + 1) * $ * U;
          }
          getElevationForLngLatZoom(e, a) {
            if (!s.ct(a, e.wrap())) return 0;
            const { tileID: c, mercatorX: p, mercatorY: y } = this._getOverscaledTileIDFromLngLatZoom(e, a);
            return this.getElevation(c, p % s.$, y % s.$, s.$);
          }
          getElevation(e, a, c, p = s.$) {
            return this.getDEMElevation(e, a, c, p) * this.exaggeration;
          }
          getTerrainData(e) {
            if (!this._emptyDemTexture) {
              const p = this.painter.context, y = new s.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new s.T(p, y, p.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new s.T(p, new s.R({ width: 1, height: 1 }), p.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(p.gl.NEAREST, p.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = s.ag([]);
            }
            const a = this.sourceCache.getSourceTile(e, true);
            if (a && a.dem && (!a.demTexture || a.needsTerrainPrepare)) {
              const p = this.painter.context;
              a.demTexture = this.painter.getTileTexture(a.dem.stride), a.demTexture ? a.demTexture.update(a.dem.getPixels(), { premultiply: false }) : a.demTexture = new s.T(p, a.dem.getPixels(), p.gl.RGBA, { premultiply: false }), a.demTexture.bind(p.gl.NEAREST, p.gl.CLAMP_TO_EDGE), a.needsTerrainPrepare = false;
            }
            const c = a && a + a.tileID.key + e.key;
            if (c && !this._demMatrixCache[c]) {
              const p = this.sourceCache.sourceCache._source.maxzoom;
              let y = e.canonical.z - a.tileID.canonical.z;
              e.overscaledZ > e.canonical.z && (e.canonical.z >= p ? y = e.canonical.z - p : s.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const x = e.canonical.x - (e.canonical.x >> y << y), k = e.canonical.y - (e.canonical.y >> y << y), P = s.cu(new Float64Array(16), [1 / (s.$ << y), 1 / (s.$ << y), 0]);
              s.M(P, P, [x * s.$, k * s.$, 0]), this._demMatrixCache[e.key] = { matrix: P, coord: e };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: a && a.dem && a.dem.dim || 1, u_terrain_matrix: c ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix, u_terrain_unpack: a && a.dem && a.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (a && a.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: a };
          }
          getFramebuffer(e) {
            const a = this.painter, c = a.width / devicePixelRatio, p = a.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === c && this._fbo.height === p || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new s.T(a.context, { width: c, height: p, data: null }, a.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(a.context.gl.NEAREST, a.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new s.T(a.context, { width: c, height: p, data: null }, a.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(a.context.gl.NEAREST, a.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = a.context.createFramebuffer(c, p, true, false), this._fbo.depthAttachment.set(a.context.createRenderbuffer(a.context.gl.DEPTH_COMPONENT16, c, p))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const e = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const a = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let y = 0, x = 0; y < this._coordsTextureSize; y++) for (let k = 0; k < this._coordsTextureSize; k++, x += 4) a[x + 0] = 255 & k, a[x + 1] = 255 & y, a[x + 2] = k >> 8 << 4 | y >> 8, a[x + 3] = 0;
            const c = new s.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(a.buffer)), p = new s.T(e, c, e.gl.RGBA, { premultiply: false });
            return p.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = p, p;
          }
          pointCoordinate(e) {
            this.painter.maybeDrawDepthAndCoords(true);
            const a = new Uint8Array(4), c = this.painter.context, p = c.gl, y = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio), x = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio), k = Math.round(this.painter.height / devicePixelRatio);
            c.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), p.readPixels(y, k - x - 1, 1, 1, p.RGBA, p.UNSIGNED_BYTE, a), c.bindFramebuffer.set(null);
            const P = a[0] + (a[2] >> 4 << 8), E = a[1] + ((15 & a[2]) << 8), D = this.coordsIndex[255 - a[3]], j = D && this.sourceCache.getTileByID(D);
            if (!j) return null;
            const $ = this._coordsTextureSize, U = (1 << j.tileID.canonical.z) * $;
            return new s.a1((j.tileID.canonical.x * $ + P) / U + j.tileID.wrap, (j.tileID.canonical.y * $ + E) / U, this.getElevation(j.tileID, P, E, $));
          }
          depthAtPoint(e) {
            const a = new Uint8Array(4), c = this.painter.context, p = c.gl;
            return c.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), p.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, p.RGBA, p.UNSIGNED_BYTE, a), c.bindFramebuffer.set(null), (a[0] / 16777216 + a[1] / 65536 + a[2] / 256 + a[3]) / 256;
          }
          getTerrainMesh(e) {
            var a;
            const c = ((a = this.painter.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0, p = c && e.canonical.y === 0, y = c && e.canonical.y === (1 << e.canonical.z) - 1, x = `m_${p ? "n" : ""}_${y ? "s" : ""}`;
            if (this._meshCache[x]) return this._meshCache[x];
            const k = this.painter.context, P = new s.cv(), E = new s.aN(), D = this.meshSize, j = s.$ / D, $ = D * D;
            for (let ye = 0; ye <= D; ye++) for (let Be = 0; Be <= D; Be++) P.emplaceBack(Be * j, ye * j, 0);
            for (let ye = 0; ye < $; ye += D + 1) for (let Be = 0; Be < D; Be++) E.emplaceBack(Be + ye, D + Be + ye + 1, D + Be + ye + 2), E.emplaceBack(Be + ye, D + Be + ye + 2, Be + ye + 1);
            const U = P.length, Y = U + (D + 1), se = (D + 1) * D, le = p ? s.bh : 0, ce = p ? 0 : 1, me = y ? s.bi : s.$, we = y ? 0 : 1;
            for (let ye = 0; ye <= D; ye++) P.emplaceBack(ye * j, le, ce);
            for (let ye = 0; ye <= D; ye++) P.emplaceBack(ye * j, me, we);
            for (let ye = 0; ye < D; ye++) E.emplaceBack(se + ye, Y + ye, Y + ye + 1), E.emplaceBack(se + ye, Y + ye + 1, se + ye + 1), E.emplaceBack(0 + ye, U + ye + 1, U + ye), E.emplaceBack(0 + ye, 0 + ye + 1, U + ye + 1);
            const _e = P.length, Pe = _e + 2 * (D + 1);
            for (const ye of [0, 1]) for (let Be = 0; Be <= D; Be++) for (const Je of [0, 1]) P.emplaceBack(ye * s.$, Be * j, Je);
            for (let ye = 0; ye < 2 * D; ye += 2) E.emplaceBack(_e + ye, _e + ye + 1, _e + ye + 3), E.emplaceBack(_e + ye, _e + ye + 3, _e + ye + 2), E.emplaceBack(Pe + ye, Pe + ye + 3, Pe + ye + 1), E.emplaceBack(Pe + ye, Pe + ye + 2, Pe + ye + 3);
            const Me = new Ao(k.createVertexBuffer(P, Np.members), k.createIndexBuffer(E), s.aM.simpleSegment(0, 0, P.length, E.length));
            return this._meshCache[x] = Me, Me;
          }
          getMeshFrameDelta(e) {
            return 2 * Math.PI * s.bu / Math.pow(2, Math.max(e, 0)) / 5;
          }
          getMinTileElevationForLngLatZoom(e, a) {
            var c;
            const { tileID: p } = this._getOverscaledTileIDFromLngLatZoom(e, a);
            return (c = this.getMinMaxElevation(p).minElevation) !== null && c !== void 0 ? c : 0;
          }
          getMinMaxElevation(e) {
            const a = this.getTerrainData(e).tile, c = { minElevation: null, maxElevation: null };
            return a && a.dem && (c.minElevation = a.dem.min * this.exaggeration, c.maxElevation = a.dem.max * this.exaggeration), c;
          }
          _getOverscaledTileIDFromLngLatZoom(e, a) {
            const c = s.a1.fromLngLat(e.wrap()), p = (1 << a) * s.$, y = c.x * p, x = c.y * p, k = Math.floor(y / s.$), P = Math.floor(x / s.$);
            return { tileID: new s.Z(a, 0, a, k, P), mercatorX: y, mercatorY: x };
          }
        }
        class qt {
          constructor(e, a, c) {
            this._context = e, this._size = a, this._tileSize = c, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const e of this._objects) e.texture.destroy(), e.fbo.destroy();
          }
          _createObject(e) {
            const a = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), c = new s.T(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return c.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), a.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), a.colorAttachment.set(c.texture), { id: e, fbo: a, texture: c, stamp: -1, inUse: false };
          }
          getObjectForId(e) {
            return this._objects[e];
          }
          useObject(e) {
            e.inUse = true, this._recentlyUsed = this._recentlyUsed.filter(((a) => e.id !== a)), this._recentlyUsed.push(e.id);
          }
          stampObject(e) {
            e.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const a of this._recentlyUsed) if (!this._objects[a].inUse) return this._objects[a];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e = this._createObject(this._objects.length);
            return this._objects.push(e), e;
          }
          freeObject(e) {
            e.inUse = false;
          }
          freeAllObjects() {
            for (const e of this._objects) this.freeObject(e);
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some(((e) => !e.inUse)) === false;
          }
        }
        const Xt = { background: true, fill: true, line: true, raster: true, hillshade: true, "color-relief": true };
        class pu {
          constructor(e, a) {
            this.painter = e, this.terrain = a, this.pool = new qt(e.context, 30, a.sourceCache.tileSize * a.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(e) {
            return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(e, a) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter(((c) => !e._layers[c].isHidden(a))), this._coordsAscending = {};
            for (const c in e.sourceCaches) {
              this._coordsAscending[c] = {};
              const p = e.sourceCaches[c].getVisibleCoordinates(), y = e.sourceCaches[c].getSource(), x = y instanceof ot ? y.terrainTileRanges : null;
              for (const k of p) {
                const P = this.terrain.sourceCache.getTerrainCoords(k, x);
                for (const E in P) this._coordsAscending[c][E] || (this._coordsAscending[c][E] = []), this._coordsAscending[c][E].push(P[E]);
              }
            }
            this._coordsAscendingStr = {};
            for (const c of e._order) {
              const p = e._layers[c], y = p.source;
              if (Xt[p.type] && !this._coordsAscendingStr[y]) {
                this._coordsAscendingStr[y] = {};
                for (const x in this._coordsAscending[y]) this._coordsAscendingStr[y][x] = this._coordsAscending[y][x].map(((k) => k.key)).sort().join();
              }
            }
            for (const c of this._renderableTiles) for (const p in this._coordsAscendingStr) {
              const y = this._coordsAscendingStr[p][c.tileID.key];
              y && y !== c.rttCoords[p] && (c.rtt = []);
            }
          }
          renderLayer(e, a) {
            if (e.isHidden(this.painter.transform.zoom)) return false;
            const c = Object.assign(Object.assign({}, a), { isRenderingToTexture: true }), p = e.type, y = this.painter, x = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
            if (Xt[p] && (this._prevType && Xt[this._prevType] || this._stacks.push([]), this._prevType = p, this._stacks[this._stacks.length - 1].push(e.id), !x)) return true;
            if (Xt[this._prevType] || Xt[p] && x) {
              this._prevType = p;
              const k = this._stacks.length - 1, P = this._stacks[k] || [];
              for (const E of this._renderableTiles) {
                if (this.pool.isFull() && (Ln(this.painter, this.terrain, this._rttTiles, c), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(E), E.rtt[k]) {
                  const j = this.pool.getObjectForId(E.rtt[k].id);
                  if (j.stamp === E.rtt[k].stamp) {
                    this.pool.useObject(j);
                    continue;
                  }
                }
                const D = this.pool.getOrCreateFreeObject();
                this.pool.useObject(D), this.pool.stampObject(D), E.rtt[k] = { id: D.id, stamp: D.stamp }, y.context.bindFramebuffer.set(D.fbo.framebuffer), y.context.clear({ color: s.bf.transparent, stencil: 0 }), y.currentStencilSource = void 0;
                for (let j = 0; j < P.length; j++) {
                  const $ = y.style._layers[P[j]], U = $.source ? this._coordsAscending[$.source][E.tileID.key] : [E.tileID];
                  y.context.viewport.set([0, 0, D.fbo.width, D.fbo.height]), y._renderTileClippingMasks($, U, true), y.renderLayer(y, y.style.sourceCaches[$.source], $, U, c), $.source && (E.rttCoords[$.source] = this._coordsAscendingStr[$.source][E.tileID.key]);
                }
              }
              return Ln(this.painter, this.terrain, this._rttTiles, c), this._rttTiles = [], this.pool.freeAllObjects(), Xt[p];
            }
            return false;
          }
        }
        const ed = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use \u2318 + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, mu = C, an = { hash: false, interactive: true, bearingSnap: 7, attributionControl: hu, maplibreLogo: false, refreshExpiredTiles: true, canvasContextAttributes: { antialias: false, preserveDrawingBuffer: false, powerPreference: "high-performance", failIfMajorPerformanceCaveat: false, desynchronized: false, contextType: void 0 }, scrollZoom: true, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, trackResize: true, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: true, maxTileCacheSize: null, maxTileCacheZoomLevels: s.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: true, rollEnabled: false, validateStyle: true, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: true, centerClampedToGround: true }, Kh = { showCompass: true, showZoom: true, visualizePitch: false, visualizeRoll: true };
        class no {
          constructor(e, a, c = false) {
            this.mousedown = (y) => {
              this.startMove(y, A.mousePos(this.element, y)), A.addEventListener(window, "mousemove", this.mousemove), A.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (y) => {
              this.move(y, A.mousePos(this.element, y));
            }, this.mouseup = (y) => {
              this._rotatePitchHandler.dragEnd(y), this.offTemp();
            }, this.touchstart = (y) => {
              y.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = A.touchPos(this.element, y.targetTouches)[0], this.startMove(y, this._startPos), A.addEventListener(window, "touchmove", this.touchmove, { passive: false }), A.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (y) => {
              y.targetTouches.length !== 1 ? this.reset() : (this._lastPos = A.touchPos(this.element, y.targetTouches)[0], this.move(y, this._lastPos));
            }, this.touchend = (y) => {
              y.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10, this.element = a;
            const p = new $p();
            this._rotatePitchHandler = new vn({ clickTolerance: 3, move: (y, x) => {
              const k = a.getBoundingClientRect(), P = new s.P((k.bottom - k.top) / 2, (k.right - k.left) / 2);
              return { bearingDelta: s.cn(new s.P(y.x, x.y), x, P), pitchDelta: c ? -0.5 * (x.y - y.y) : void 0 };
            }, moveStateManager: p, enable: true, assignEvents: () => {
            } }), this.map = e, A.addEventListener(a, "mousedown", this.mousedown), A.addEventListener(a, "touchstart", this.touchstart, { passive: false }), A.addEventListener(a, "touchcancel", this.reset);
          }
          startMove(e, a) {
            this._rotatePitchHandler.dragStart(e, a), A.disableDrag();
          }
          move(e, a) {
            const c = this.map, { bearingDelta: p, pitchDelta: y } = this._rotatePitchHandler.dragMove(e, a) || {};
            p && c.setBearing(c.getBearing() + p), y && c.setPitch(c.getPitch() + y);
          }
          off() {
            const e = this.element;
            A.removeEventListener(e, "mousedown", this.mousedown), A.removeEventListener(e, "touchstart", this.touchstart, { passive: false }), A.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), A.removeEventListener(window, "touchend", this.touchend), A.removeEventListener(e, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            A.enableDrag(), A.removeEventListener(window, "mousemove", this.mousemove), A.removeEventListener(window, "mouseup", this.mouseup), A.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), A.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let Oa;
        function cs(v, e, a, c = false) {
          if (c || !a.getCoveringTilesDetailsProvider().allowWorldCopies()) return v == null ? void 0 : v.wrap();
          const p = new s.S(v.lng, v.lat);
          if (v = new s.S(v.lng, v.lat), e) {
            const y = new s.S(v.lng - 360, v.lat), x = new s.S(v.lng + 360, v.lat), k = a.locationToScreenPoint(v).distSqr(e);
            a.locationToScreenPoint(y).distSqr(e) < k ? v = y : a.locationToScreenPoint(x).distSqr(e) < k && (v = x);
          }
          for (; Math.abs(v.lng - a.center.lng) > 180; ) {
            const y = a.locationToScreenPoint(v);
            if (y.x >= 0 && y.y >= 0 && y.x <= a.width && y.y <= a.height) break;
            v.lng > a.center.lng ? v.lng -= 360 : v.lng += 360;
          }
          return v.lng !== p.lng && a.isPointOnMapSurface(a.locationToScreenPoint(v)) ? v : p;
        }
        const di = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function wi(v, e, a) {
          const c = v.classList;
          for (const p in di) c.remove(`maplibregl-${a}-anchor-${p}`);
          c.add(`maplibregl-${a}-anchor-${e}`);
        }
        class gu extends s.E {
          constructor(e) {
            if (super(), this._onKeyPress = (a) => {
              const c = a.code, p = a.charCode || a.keyCode;
              c !== "Space" && c !== "Enter" && p !== 32 && p !== 13 || this.togglePopup();
            }, this._onMapClick = (a) => {
              const c = a.originalEvent.target, p = this._element;
              this._popup && (c === p || p.contains(c)) && this.togglePopup();
            }, this._update = (a) => {
              if (!this._map) return;
              const c = this._map.loaded() && !this._map.isMoving();
              ((a == null ? void 0 : a.type) === "terrain" || (a == null ? void 0 : a.type) === "render" && !c) && this._map.once("render", this._update), this._lngLat = cs(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
              let p = "";
              this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? p = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (p = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let y = "";
              this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? y = "rotateX(0deg)" : this._pitchAlignment === "map" && (y = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || a && a.type !== "moveend" || (this._pos = this._pos.round()), A.setTransform(this._element, `${di[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${y} ${p}`), L.frameAsync(new AbortController()).then((() => {
                this._updateOpacity(a && a.type === "moveend");
              })).catch((() => {
              }));
            }, this._onMove = (a) => {
              if (!this._isDragging) {
                const c = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = a.point.dist(this._pointerdownPos) >= c;
              }
              this._isDragging && (this._pos = a.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new s.l("dragstart"))), this.fire(new s.l("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new s.l("dragend")), this._state = "inactive";
            }, this._addDragHandler = (a) => {
              this._element.contains(a.originalEvent.target) && (a.preventDefault(), this._positionDelta = a.point.sub(this._pos).add(this._offset), this._pointerdownPos = a.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || false, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || false, this._isDragging = false, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = s.P.convert(e && e.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = A.create("div");
              const a = A.createNS("http://www.w3.org/2000/svg", "svg"), c = 41, p = 27;
              a.setAttributeNS(null, "display", "block"), a.setAttributeNS(null, "height", `${c}px`), a.setAttributeNS(null, "width", `${p}px`), a.setAttributeNS(null, "viewBox", `0 0 ${p} ${c}`);
              const y = A.createNS("http://www.w3.org/2000/svg", "g");
              y.setAttributeNS(null, "stroke", "none"), y.setAttributeNS(null, "stroke-width", "1"), y.setAttributeNS(null, "fill", "none"), y.setAttributeNS(null, "fill-rule", "evenodd");
              const x = A.createNS("http://www.w3.org/2000/svg", "g");
              x.setAttributeNS(null, "fill-rule", "nonzero");
              const k = A.createNS("http://www.w3.org/2000/svg", "g");
              k.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), k.setAttributeNS(null, "fill", "#000000");
              const P = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const ce of P) {
                const me = A.createNS("http://www.w3.org/2000/svg", "ellipse");
                me.setAttributeNS(null, "opacity", "0.04"), me.setAttributeNS(null, "cx", "10.5"), me.setAttributeNS(null, "cy", "5.80029008"), me.setAttributeNS(null, "rx", ce.rx), me.setAttributeNS(null, "ry", ce.ry), k.appendChild(me);
              }
              const E = A.createNS("http://www.w3.org/2000/svg", "g");
              E.setAttributeNS(null, "fill", this._color);
              const D = A.createNS("http://www.w3.org/2000/svg", "path");
              D.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), E.appendChild(D);
              const j = A.createNS("http://www.w3.org/2000/svg", "g");
              j.setAttributeNS(null, "opacity", "0.25"), j.setAttributeNS(null, "fill", "#000000");
              const $ = A.createNS("http://www.w3.org/2000/svg", "path");
              $.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), j.appendChild($);
              const U = A.createNS("http://www.w3.org/2000/svg", "g");
              U.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), U.setAttributeNS(null, "fill", "#FFFFFF");
              const Y = A.createNS("http://www.w3.org/2000/svg", "g");
              Y.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const se = A.createNS("http://www.w3.org/2000/svg", "circle");
              se.setAttributeNS(null, "fill", "#000000"), se.setAttributeNS(null, "opacity", "0.25"), se.setAttributeNS(null, "cx", "5.5"), se.setAttributeNS(null, "cy", "5.5"), se.setAttributeNS(null, "r", "5.4999962");
              const le = A.createNS("http://www.w3.org/2000/svg", "circle");
              le.setAttributeNS(null, "fill", "#FFFFFF"), le.setAttributeNS(null, "cx", "5.5"), le.setAttributeNS(null, "cy", "5.5"), le.setAttributeNS(null, "r", "5.4999962"), Y.appendChild(se), Y.appendChild(le), x.appendChild(k), x.appendChild(E), x.appendChild(j), x.appendChild(U), x.appendChild(Y), a.appendChild(x), a.setAttributeNS(null, "height", c * this._scale + "px"), a.setAttributeNS(null, "width", p * this._scale + "px"), this._element.appendChild(a), this._offset = s.P.convert(e && e.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", ((a) => {
              a.preventDefault();
            })), this._element.addEventListener("mousedown", ((a) => {
              a.preventDefault();
            })), wi(this._element, this._anchor, "marker"), e && e.className) for (const a of e.className.split(" ")) this._element.classList.add(a);
            this._popup = null;
          }
          addTo(e) {
            return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), A.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e) {
            return this._lngLat = s.S.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(e) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
              if (!("offset" in e.options)) {
                const p = Math.abs(13.5) / Math.SQRT2;
                e.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [p, -1 * (38.1 - 13.5 + p)], "bottom-right": [-p, -1 * (38.1 - 13.5 + p)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
              }
              this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          setSubpixelPositioning(e) {
            return this._subpixelPositioning = e, this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const e = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this;
          }
          _updateOpacity(e = false) {
            var a, c;
            const p = (a = this._map) === null || a === void 0 ? void 0 : a.terrain, y = this._map.transform.isLocationOccluded(this._lngLat);
            if (!p || y) {
              const U = y ? this._opacityWhenCovered : this._opacity;
              return void (this._element.style.opacity !== U && (this._element.style.opacity = U));
            }
            if (e) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout((() => {
                this._opacityTimeout = null;
              }), 100);
            }
            const x = this._map, k = x.terrain.depthAtPoint(this._pos), P = x.terrain.getElevationForLngLatZoom(this._lngLat, x.transform.tileZoom);
            if (x.transform.lngLatToCameraDepth(this._lngLat, P) - k < 6e-3) return void (this._element.style.opacity = this._opacity);
            const E = -this._offset.y / x.transform.pixelsPerMeter, D = Math.sin(x.getPitch() * Math.PI / 180) * E, j = x.terrain.depthAtPoint(new s.P(this._pos.x, this._pos.y - this._offset.y)), $ = x.transform.lngLatToCameraDepth(this._lngLat, P + D) - j > 6e-3;
            !((c = this._popup) === null || c === void 0) && c.isOpen() && $ && this._popup.remove(), this._element.style.opacity = $ ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(e) {
            return this._offset = s.P.convert(e), this._update(), this;
          }
          addClassName(e) {
            this._element.classList.add(e);
          }
          removeClassName(e) {
            this._element.classList.remove(e);
          }
          toggleClassName(e) {
            return this._element.classList.toggle(e);
          }
          setDraggable(e) {
            return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(e) {
            return this._rotation = e || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(e) {
            return this._rotationAlignment = e || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(e) {
            return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(e, a) {
            return (this._opacity === void 0 || e === void 0 && a === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), a !== void 0 && (this._opacityWhenCovered = a), this._map && this._updateOpacity(true), this;
          }
        }
        const rl = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
        let $a = 0, ja = false;
        const td = { maxWidth: 100, unit: "metric" };
        function vu(v, e, a) {
          const c = a && a.maxWidth || 100, p = v._container.clientHeight / 2, y = v._container.clientWidth / 2, x = v.unproject([y - c / 2, p]), k = v.unproject([y + c / 2, p]), P = Math.round(v.project(k).x - v.project(x).x), E = Math.min(c, P, v._container.clientWidth), D = x.distanceTo(k);
          if (a && a.unit === "imperial") {
            const j = 3.2808 * D;
            j > 5280 ? Lo(e, E, j / 5280, v._getUIString("ScaleControl.Miles")) : Lo(e, E, j, v._getUIString("ScaleControl.Feet"));
          } else a && a.unit === "nautical" ? Lo(e, E, D / 1852, v._getUIString("ScaleControl.NauticalMiles")) : D >= 1e3 ? Lo(e, E, D / 1e3, v._getUIString("ScaleControl.Kilometers")) : Lo(e, E, D, v._getUIString("ScaleControl.Meters"));
        }
        function Lo(v, e, a, c) {
          const p = (function(y) {
            const x = Math.pow(10, `${Math.floor(y)}`.length - 1);
            let k = y / x;
            return k = k >= 10 ? 10 : k >= 5 ? 5 : k >= 3 ? 3 : k >= 2 ? 2 : k >= 1 ? 1 : (function(P) {
              const E = Math.pow(10, Math.ceil(-Math.log(P) / Math.LN10));
              return Math.round(P * E) / E;
            })(k), x * k;
          })(a);
          v.style.width = e * (p / a) + "px", v.innerHTML = `${p}&nbsp;${c}`;
        }
        const rd = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", subpixelPositioning: false, locationOccludedOpacity: void 0 }, id = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function _u(v) {
          if (v) {
            if (typeof v == "number") {
              const e = Math.round(Math.abs(v) / Math.SQRT2);
              return { center: new s.P(0, 0), top: new s.P(0, v), "top-left": new s.P(e, e), "top-right": new s.P(-e, e), bottom: new s.P(0, -v), "bottom-left": new s.P(e, -e), "bottom-right": new s.P(-e, -e), left: new s.P(v, 0), right: new s.P(-v, 0) };
            }
            if (v instanceof s.P || Array.isArray(v)) {
              const e = s.P.convert(v);
              return { center: e, top: e, "top-left": e, "top-right": e, bottom: e, "bottom-left": e, "bottom-right": e, left: e, right: e };
            }
            return { center: s.P.convert(v.center || [0, 0]), top: s.P.convert(v.top || [0, 0]), "top-left": s.P.convert(v["top-left"] || [0, 0]), "top-right": s.P.convert(v["top-right"] || [0, 0]), bottom: s.P.convert(v.bottom || [0, 0]), "bottom-left": s.P.convert(v["bottom-left"] || [0, 0]), "bottom-right": s.P.convert(v["bottom-right"] || [0, 0]), left: s.P.convert(v.left || [0, 0]), right: s.P.convert(v.right || [0, 0]) };
          }
          return _u(new s.P(0, 0));
        }
        const nd = C;
        m.AJAXError = s.cz, m.Event = s.l, m.Evented = s.E, m.LngLat = s.S, m.MercatorCoordinate = s.a1, m.Point = s.P, m.addProtocol = s.cA, m.config = s.a, m.removeProtocol = s.cB, m.AttributionControl = Jc, m.BoxZoomHandler = Uc, m.CanvasSource = Ye, m.CooperativeGesturesHandler = Xh, m.DoubleClickZoomHandler = Wh, m.DragPanHandler = Yc, m.DragRotateHandler = Hh, m.EdgeInsets = wa, m.FullscreenControl = class extends s.E {
          constructor(v = {}) {
            super(), this._onFullscreenChange = () => {
              var e;
              let a = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((e = a == null ? void 0 : a.shadowRoot) === null || e === void 0) && e.fullscreenElement; ) a = a.shadowRoot.fullscreenElement;
              a === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = false, v && v.container && (v.container instanceof HTMLElement ? this._container = v.container : s.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(v) {
            return this._map = v, this._container || (this._container = this._map.getContainer()), this._controlContainer = A.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            A.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const v = this._fullscreenButton = A.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            A.create("span", "maplibregl-ctrl-icon", v).setAttribute("aria-hidden", "true"), v.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const v = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", v), this._fullscreenButton.title = v;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new s.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new s.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, m.GeoJSONSource = Ee, m.GeolocateControl = class extends s.E {
          constructor(v) {
            super(), this._onSuccess = (e) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new s.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new s.l("geolocate", e)), this._finish();
              }
            }, this._updateCamera = (e) => {
              const a = new s.S(e.coords.longitude, e.coords.latitude), c = e.coords.accuracy, p = this._map.getBearing(), y = s.e({ bearing: p }, this.options.fitBoundsOptions), x = sr.fromLngLat(a, c);
              this._map.fitBounds(x, y, { geolocateSource: true });
            }, this._updateMarker = (e) => {
              if (e) {
                const a = new s.S(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(a).addTo(this._map), this._userLocationDotMarker.setLngLat(a).addTo(this._map), this._accuracy = e.coords.accuracy, this._updateCircleRadiusIfNeeded();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onUpdate = () => {
              this._updateCircleRadiusIfNeeded();
            }, this._onError = (e) => {
              if (this._map) {
                if (e.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                  const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a), this._geolocationWatchID !== void 0 && this._clearWatch();
                } else {
                  if (e.code === 3 && ja) return;
                  this.options.trackUserLocation && this._setErrorState();
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new s.l("error", e)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", ((e) => e.preventDefault())), this._geolocateButton = A.create("button", "maplibregl-ctrl-geolocate", this._container), A.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = true);
            }, this._finishSetupUI = (e) => {
              if (this._map) {
                if (e === false) {
                  s.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const a = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = true, this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a);
                } else {
                  const a = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = false, this._geolocateButton.title = a, this._geolocateButton.setAttribute("aria-label", a);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = A.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new gu({ element: this._dotElement }), this._circleElement = A.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new gu({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", ((a) => {
                  const c = (a == null ? void 0 : a[0]) instanceof ResizeObserverEntry;
                  a.geolocateSource || this._watchState !== "ACTIVE_LOCK" || c || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new s.l("trackuserlocationend")), this.fire(new s.l("userlocationlostfocus")));
                }));
              }
            }, this.options = s.e({}, rl, v);
          }
          onAdd(v) {
            return this._map = v, this._container = A.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), (function() {
              return s._(this, arguments, void 0, (function* (e = false) {
                if (Oa !== void 0 && !e) return Oa;
                if (window.navigator.permissions === void 0) return Oa = !!window.navigator.geolocation, Oa;
                try {
                  Oa = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
                } catch {
                  Oa = !!window.navigator.geolocation;
                }
                return Oa;
              }));
            })().then(((e) => this._finishSetupUI(e))), this._container;
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), A.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, $a = 0, ja = false;
          }
          _isOutOfMapMaxBounds(v) {
            const e = this._map.getMaxBounds(), a = v.coords;
            return e && (a.longitude < e.getWest() || a.longitude > e.getEast() || a.latitude < e.getSouth() || a.latitude > e.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadiusIfNeeded() {
            const v = this._userLocationDotMarker.getLngLat();
            if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && v)) return;
            const e = this._map.project(v), a = this._map.unproject([e.x + 100, e.y]), c = v.distanceTo(a) / 100, p = 2 * this._accuracy / c;
            this._circleElement.style.width = `${p.toFixed(2)}px`, this._circleElement.style.height = `${p.toFixed(2)}px`;
          }
          trigger() {
            if (!this._setup) return s.w("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new s.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  $a--, ja = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new s.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new s.l("trackuserlocationstart")), this.fire(new s.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let v;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), $a++, $a > 1 ? (v = { maximumAge: 6e5, timeout: 0 }, ja = true) : (v = this.options.positionOptions, ja = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, v);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, m.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var v;
              const e = (v = this._map.getProjection()) === null || v === void 0 ? void 0 : v.type;
              this._map.setProjection(e !== "mercator" && e ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
            }, this._updateGlobeIcon = () => {
              var v;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((v = this._map.getProjection()) === null || v === void 0 ? void 0 : v.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
            };
          }
          onAdd(v) {
            return this._map = v, this._container = A.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = A.create("button", "maplibregl-ctrl-globe", this._container), A.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
          }
          onRemove() {
            A.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
          }
        }, m.Hash = za, m.ImageSource = ot, m.KeyboardHandler = kr, m.LngLatBounds = sr, m.LogoControl = Qc, m.Map = class extends du {
          constructor(v) {
            var e, a;
            s.cw.mark(s.cx.create);
            const c = Object.assign(Object.assign(Object.assign({}, an), v), { canvasContextAttributes: Object.assign(Object.assign({}, an.canvasContextAttributes), v.canvasContextAttributes) });
            if (c.minZoom != null && c.maxZoom != null && c.minZoom > c.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (c.minPitch != null && c.maxPitch != null && c.minPitch > c.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (c.minPitch != null && c.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (c.maxPitch != null && c.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const p = new Qr(), y = new nn();
            if (c.minZoom !== void 0 && p.setMinZoom(c.minZoom), c.maxZoom !== void 0 && p.setMaxZoom(c.maxZoom), c.minPitch !== void 0 && p.setMinPitch(c.minPitch), c.maxPitch !== void 0 && p.setMaxPitch(c.maxPitch), c.renderWorldCopies !== void 0 && p.setRenderWorldCopies(c.renderWorldCopies), super(p, y, { bearingSnap: c.bearingSnap }), this._idleTriggered = false, this._crossFadingFactor = 1, this._renderTaskQueue = new Yh(), this._controls = [], this._mapId = s.a7(), this._contextLost = (k) => {
              k.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new s.l("webglcontextlost", { originalEvent: k }));
            }, this._contextRestored = (k) => {
              this._setupPainter(), this.resize(), this._update(), this.fire(new s.l("webglcontextrestored", { originalEvent: k }));
            }, this._onMapScroll = (k) => {
              if (k.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = c.interactive, this._maxTileCacheSize = c.maxTileCacheSize, this._maxTileCacheZoomLevels = c.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, c.canvasContextAttributes), this._trackResize = c.trackResize === true, this._bearingSnap = c.bearingSnap, this._centerClampedToGround = c.centerClampedToGround, this._refreshExpiredTiles = c.refreshExpiredTiles === true, this._fadeDuration = c.fadeDuration, this._crossSourceCollisions = c.crossSourceCollisions === true, this._collectResourceTiming = c.collectResourceTiming === true, this._locale = Object.assign(Object.assign({}, ed), c.locale), this._clickTolerance = c.clickTolerance, this._overridePixelRatio = c.pixelRatio, this._maxCanvasSize = c.maxCanvasSize, this.transformCameraUpdate = c.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = c.cancelPendingTileRequestsWhileZooming === true, this._imageQueueHandle = ee.addThrottleControl((() => this.isMoving())), this._requestManager = new re(c.transformRequest), typeof c.container == "string") {
              if (this._container = document.getElementById(c.container), !this._container) throw new Error(`Container '${c.container}' not found.`);
            } else {
              if (!(c.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = c.container;
            }
            if (c.maxBounds && this.setMaxBounds(c.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(false))), this.on("moveend", (() => this._update(false))), this.on("zoom", (() => this._update(true))), this.on("terrain", (() => {
              this.painter.terrainFacilitator.dirty = true, this._update(true);
            })), this.once("idle", (() => {
              this._idleTriggered = true;
            })), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, false);
              let k = false;
              const P = jc(((E) => {
                this._trackResize && !this._removed && (this.resize(E), this.redraw());
              }), 50);
              this._resizeObserver = new ResizeObserver(((E) => {
                k ? P(E) : k = true;
              })), this._resizeObserver.observe(this._container);
            }
            this.handlers = new jp(this, c), this._hash = c.hash && new za(typeof c.hash == "string" && c.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: c.center, elevation: c.elevation, zoom: c.zoom, bearing: c.bearing, pitch: c.pitch, roll: c.roll }), c.bounds && (this.resize(), this.fitBounds(c.bounds, s.e({}, c.fitBoundsOptions, { duration: 0 }))));
            const x = typeof c.style == "string" || ((a = (e = c.style) === null || e === void 0 ? void 0 : e.projection) === null || a === void 0 ? void 0 : a.type) !== "globe";
            this.resize(null, x), this._localIdeographFontFamily = c.localIdeographFontFamily, this._validateStyle = c.validateStyle, c.style && this.setStyle(c.style, { localIdeographFontFamily: c.localIdeographFontFamily }), c.attributionControl && this.addControl(new Jc(typeof c.attributionControl == "boolean" ? void 0 : c.attributionControl)), c.maplibreLogo && this.addControl(new Qc(), c.logoPosition), this.on("style.load", (() => {
              if (x || this._resizeTransform(), this.transform.unmodified) {
                const k = s.Q(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(k);
              }
            })), this.on("data", ((k) => {
              this._update(k.dataType === "style"), this.fire(new s.l(`${k.dataType}data`, k));
            })), this.on("dataloading", ((k) => {
              this.fire(new s.l(`${k.dataType}dataloading`, k));
            })), this.on("dataabort", ((k) => {
              this.fire(new s.l("sourcedataabort", k));
            }));
          }
          _getMapId() {
            return this._mapId;
          }
          setGlobalStateProperty(v, e) {
            return this.style.setGlobalStateProperty(v, e), this._update(true);
          }
          getGlobalState() {
            return this.style.getGlobalState();
          }
          addControl(v, e) {
            if (e === void 0 && (e = v.getDefaultPosition ? v.getDefaultPosition() : "top-right"), !v || !v.onAdd) return this.fire(new s.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const a = v.onAdd(this);
            this._controls.push(v);
            const c = this._controlPositions[e];
            return e.indexOf("bottom") !== -1 ? c.insertBefore(a, c.firstChild) : c.appendChild(a), this;
          }
          removeControl(v) {
            if (!v || !v.onRemove) return this.fire(new s.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const e = this._controls.indexOf(v);
            return e > -1 && this._controls.splice(e, 1), v.onRemove(this), this;
          }
          hasControl(v) {
            return this._controls.indexOf(v) > -1;
          }
          coveringTiles(v) {
            return Te(this.transform, v);
          }
          calculateCameraOptionsFromTo(v, e, a, c) {
            return c == null && this.terrain && (c = this.terrain.getElevationForLngLatZoom(a, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(v, e, a, c);
          }
          resize(v, e = true) {
            const [a, c] = this._containerDimensions(), p = this._getClampedPixelRatio(a, c);
            if (this._resizeCanvas(a, c, p), this.painter.resize(a, c, p), this.painter.overLimit()) {
              const x = this.painter.context.gl;
              this._maxCanvasSize = [x.drawingBufferWidth, x.drawingBufferHeight];
              const k = this._getClampedPixelRatio(a, c);
              this._resizeCanvas(a, c, k), this.painter.resize(a, c, k);
            }
            this._resizeTransform(e);
            const y = !this._moving;
            return y && (this.stop(), this.fire(new s.l("movestart", v)).fire(new s.l("move", v))), this.fire(new s.l("resize", v)), y && this.fire(new s.l("moveend", v)), this;
          }
          _resizeTransform(v = true) {
            var e;
            const [a, c] = this._containerDimensions();
            this.transform.resize(a, c, v), (e = this._requestedCameraState) === null || e === void 0 || e.resize(a, c, v);
          }
          _getClampedPixelRatio(v, e) {
            const { 0: a, 1: c } = this._maxCanvasSize, p = this.getPixelRatio(), y = v * p, x = e * p;
            return Math.min(y > a ? a / y : 1, x > c ? c / x : 1) * p;
          }
          getPixelRatio() {
            var v;
            return (v = this._overridePixelRatio) !== null && v !== void 0 ? v : devicePixelRatio;
          }
          setPixelRatio(v) {
            this._overridePixelRatio = v, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(v) {
            return this.transform.setMaxBounds(sr.convert(v)), this._update();
          }
          setMinZoom(v) {
            if ((v = v ?? -2) >= -2 && v <= this.transform.maxZoom) return this.transform.setMinZoom(v), this._update(), this.getZoom() < v && this.setZoom(v), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(v) {
            if ((v = v ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(v), this._update(), this.getZoom() > v && this.setZoom(v), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(v) {
            if ((v = v ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (v >= 0 && v <= this.transform.maxPitch) return this.transform.setMinPitch(v), this._update(), this.getPitch() < v && this.setPitch(v), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(v) {
            if ((v = v ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (v >= this.transform.minPitch) return this.transform.setMaxPitch(v), this._update(), this.getPitch() > v && this.setPitch(v), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(v) {
            return this.transform.setRenderWorldCopies(v), this._update();
          }
          project(v) {
            return this.transform.locationToScreenPoint(s.S.convert(v), this.style && this.terrain);
          }
          unproject(v) {
            return this.transform.screenPointToLocation(s.P.convert(v), this.terrain);
          }
          isMoving() {
            var v;
            return this._moving || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isMoving());
          }
          isZooming() {
            var v;
            return this._zooming || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isZooming());
          }
          isRotating() {
            var v;
            return this._rotating || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isRotating());
          }
          _createDelegatedListener(v, e, a) {
            if (v === "mouseenter" || v === "mouseover") {
              let c = false;
              return { layers: e, listener: a, delegates: { mousemove: (y) => {
                const x = e.filter(((P) => this.getLayer(P))), k = x.length !== 0 ? this.queryRenderedFeatures(y.point, { layers: x }) : [];
                k.length ? c || (c = true, a.call(this, new Pn(v, this, y.originalEvent, { features: k }))) : c = false;
              }, mouseout: () => {
                c = false;
              } } };
            }
            if (v === "mouseleave" || v === "mouseout") {
              let c = false;
              return { layers: e, listener: a, delegates: { mousemove: (x) => {
                const k = e.filter(((P) => this.getLayer(P)));
                (k.length !== 0 ? this.queryRenderedFeatures(x.point, { layers: k }) : []).length ? c = true : c && (c = false, a.call(this, new Pn(v, this, x.originalEvent)));
              }, mouseout: (x) => {
                c && (c = false, a.call(this, new Pn(v, this, x.originalEvent)));
              } } };
            }
            {
              const c = (p) => {
                const y = e.filter(((k) => this.getLayer(k))), x = y.length !== 0 ? this.queryRenderedFeatures(p.point, { layers: y }) : [];
                x.length && (p.features = x, a.call(this, p), delete p.features);
              };
              return { layers: e, listener: a, delegates: { [v]: c } };
            }
          }
          _saveDelegatedListener(v, e) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[v] = this._delegatedListeners[v] || [], this._delegatedListeners[v].push(e);
          }
          _removeDelegatedListener(v, e, a) {
            if (!this._delegatedListeners || !this._delegatedListeners[v]) return;
            const c = this._delegatedListeners[v];
            for (let p = 0; p < c.length; p++) {
              const y = c[p];
              if (y.listener === a && y.layers.length === e.length && y.layers.every(((x) => e.includes(x)))) {
                for (const x in y.delegates) this.off(x, y.delegates[x]);
                return void c.splice(p, 1);
              }
            }
          }
          on(v, e, a) {
            if (a === void 0) return super.on(v, e);
            const c = typeof e == "string" ? [e] : e, p = this._createDelegatedListener(v, c, a);
            this._saveDelegatedListener(v, p);
            for (const y in p.delegates) this.on(y, p.delegates[y]);
            return { unsubscribe: () => {
              this._removeDelegatedListener(v, c, a);
            } };
          }
          once(v, e, a) {
            if (a === void 0) return super.once(v, e);
            const c = typeof e == "string" ? [e] : e, p = this._createDelegatedListener(v, c, a);
            for (const y in p.delegates) {
              const x = p.delegates[y];
              p.delegates[y] = (...k) => {
                this._removeDelegatedListener(v, c, a), x(...k);
              };
            }
            this._saveDelegatedListener(v, p);
            for (const y in p.delegates) this.once(y, p.delegates[y]);
            return this;
          }
          off(v, e, a) {
            return a === void 0 ? super.off(v, e) : (this._removeDelegatedListener(v, typeof e == "string" ? [e] : e, a), this);
          }
          queryRenderedFeatures(v, e) {
            if (!this.style) return [];
            let a;
            const c = v instanceof s.P || Array.isArray(v), p = c ? v : [[0, 0], [this.transform.width, this.transform.height]];
            if (e = e || (c ? {} : v) || {}, p instanceof s.P || typeof p[0] == "number") a = [s.P.convert(p)];
            else {
              const y = s.P.convert(p[0]), x = s.P.convert(p[1]);
              a = [y, new s.P(x.x, y.y), x, new s.P(y.x, x.y), y];
            }
            return this.style.queryRenderedFeatures(a, e, this.transform);
          }
          querySourceFeatures(v, e) {
            return this.style.querySourceFeatures(v, e);
          }
          setStyle(v, e) {
            return (e = s.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, e)).diff !== false && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && v ? (this._diffStyle(v, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(v, e));
          }
          setTransformRequest(v) {
            return this._requestManager.setTransformRequest(v), this;
          }
          _getUIString(v) {
            const e = this._locale[v];
            if (e == null) throw new Error(`Missing UI string '${v}'`);
            return e;
          }
          _updateStyle(v, e) {
            var a, c;
            if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(v, e)));
            const p = this.style && e.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!v)), v ? (this.style = new vc(this, e || {}), this.style.setEventedParent(this, { style: this.style }), typeof v == "string" ? this.style.loadURL(v, e, p) : this.style.loadJSON(v, e, p), this) : ((c = (a = this.style) === null || a === void 0 ? void 0 : a.projection) === null || c === void 0 || c.destroy(), delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new vc(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(v, e) {
            if (typeof v == "string") {
              const a = this._requestManager.transformRequest(v, "Style");
              s.j(a, new AbortController()).then(((c) => {
                this._updateDiff(c.data, e);
              })).catch(((c) => {
                c && this.fire(new s.k(c));
              }));
            } else typeof v == "object" && this._updateDiff(v, e);
          }
          _updateDiff(v, e) {
            try {
              this.style.setState(v, e) && this._update(true);
            } catch (a) {
              s.w(`Unable to perform style diff: ${a.message || a.error || a}.  Rebuilding the style from scratch.`), this._updateStyle(v, e);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : s.w("There is no style added to the map.");
          }
          addSource(v, e) {
            return this._lazyInitEmptyStyle(), this.style.addSource(v, e), this._update(true);
          }
          isSourceLoaded(v) {
            const e = this.style && this.style.sourceCaches[v];
            if (e !== void 0) return e.loaded();
            this.fire(new s.k(new Error(`There is no source with ID '${v}'`)));
          }
          setTerrain(v) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), v) {
              const e = this.style.sourceCaches[v.source];
              if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${v.source}`);
              this.terrain === null && e.reload();
              for (const a in this.style._layers) {
                const c = this.style._layers[a];
                c.type === "hillshade" && c.source === v.source && s.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), c.type === "color-relief" && c.source === v.source && s.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new fu(this.painter, e, v), this.painter.renderToTexture = new pu(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (a) => {
                var c;
                a.dataType === "style" ? this.terrain.sourceCache.freeRtt() : a.dataType === "source" && a.tile && (a.sourceId !== v.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), ((c = a.source) === null || c === void 0 ? void 0 : c.type) === "image" ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(a.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new s.l("terrain", { terrain: v })), this;
          }
          getTerrain() {
            var v, e;
            return (e = (v = this.terrain) === null || v === void 0 ? void 0 : v.options) !== null && e !== void 0 ? e : null;
          }
          areTilesLoaded() {
            const v = this.style && this.style.sourceCaches;
            for (const e in v) {
              const a = v[e]._tiles;
              for (const c in a) {
                const p = a[c];
                if (p.state !== "loaded" && p.state !== "errored") return false;
              }
            }
            return true;
          }
          removeSource(v) {
            return this.style.removeSource(v), this._update(true);
          }
          getSource(v) {
            return this.style.getSource(v);
          }
          setSourceTileLodParams(v, e, a) {
            if (a) {
              const c = this.getSource(a);
              if (!c) throw new Error(`There is no source with ID "${a}", cannot set LOD parameters`);
              c.calculateTileZoom = it(Math.max(1, v), Math.max(1, e));
            } else for (const c in this.style.sourceCaches) this.style.sourceCaches[c].getSource().calculateTileZoom = it(Math.max(1, v), Math.max(1, e));
            return this._update(true), this;
          }
          refreshTiles(v, e) {
            const a = this.style.sourceCaches[v];
            if (!a) throw new Error(`There is no source cache with ID "${v}", cannot refresh tile`);
            e === void 0 ? a.reload(true) : a.refreshTiles(e.map(((c) => new s.a4(c.z, c.x, c.y))));
          }
          addImage(v, e, a = {}) {
            const { pixelRatio: c = 1, sdf: p = false, stretchX: y, stretchY: x, content: k, textFitWidth: P, textFitHeight: E } = a;
            if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || s.b(e))) {
              if (e.width === void 0 || e.height === void 0) return this.fire(new s.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: D, height: j, data: $ } = e, U = e;
                return this.style.addImage(v, { data: new s.R({ width: D, height: j }, new Uint8Array($)), pixelRatio: c, stretchX: y, stretchY: x, content: k, textFitWidth: P, textFitHeight: E, sdf: p, version: 0, userImage: U }), U.onAdd && U.onAdd(this, v), this;
              }
            }
            {
              const { width: D, height: j, data: $ } = L.getImageData(e);
              this.style.addImage(v, { data: new s.R({ width: D, height: j }, $), pixelRatio: c, stretchX: y, stretchY: x, content: k, textFitWidth: P, textFitHeight: E, sdf: p, version: 0 });
            }
          }
          updateImage(v, e) {
            const a = this.style.getImage(v);
            if (!a) return this.fire(new s.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const c = e instanceof HTMLImageElement || s.b(e) ? L.getImageData(e) : e, { width: p, height: y, data: x } = c;
            if (p === void 0 || y === void 0) return this.fire(new s.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (p !== a.data.width || y !== a.data.height) return this.fire(new s.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const k = !(e instanceof HTMLImageElement || s.b(e));
            return a.data.replace(x, k), this.style.updateImage(v, a), this;
          }
          getImage(v) {
            return this.style.getImage(v);
          }
          hasImage(v) {
            return v ? !!this.style.getImage(v) : (this.fire(new s.k(new Error("Missing required image id"))), false);
          }
          removeImage(v) {
            this.style.removeImage(v);
          }
          loadImage(v) {
            return ee.getImage(this._requestManager.transformRequest(v, "Image"), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(v, e) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(v, e), this._update(true);
          }
          moveLayer(v, e) {
            return this.style.moveLayer(v, e), this._update(true);
          }
          removeLayer(v) {
            return this.style.removeLayer(v), this._update(true);
          }
          getLayer(v) {
            return this.style.getLayer(v);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(v, e, a) {
            return this.style.setLayerZoomRange(v, e, a), this._update(true);
          }
          setFilter(v, e, a = {}) {
            return this.style.setFilter(v, e, a), this._update(true);
          }
          getFilter(v) {
            return this.style.getFilter(v);
          }
          setPaintProperty(v, e, a, c = {}) {
            return this.style.setPaintProperty(v, e, a, c), this._update(true);
          }
          getPaintProperty(v, e) {
            return this.style.getPaintProperty(v, e);
          }
          setLayoutProperty(v, e, a, c = {}) {
            return this.style.setLayoutProperty(v, e, a, c), this._update(true);
          }
          getLayoutProperty(v, e) {
            return this.style.getLayoutProperty(v, e);
          }
          setGlyphs(v, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(v, e), this._update(true);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(v, e, a = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(v, e, a, ((c) => {
              c || this._update(true);
            })), this;
          }
          removeSprite(v) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(v), this._update(true);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(v, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(v, e, ((a) => {
              a || this._update(true);
            })), this;
          }
          setLight(v, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(v, e), this._update(true);
          }
          getLight() {
            return this.style.getLight();
          }
          setSky(v, e = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(v, e), this._update(true);
          }
          getSky() {
            return this.style.getSky();
          }
          setFeatureState(v, e) {
            return this.style.setFeatureState(v, e), this._update();
          }
          removeFeatureState(v, e) {
            return this.style.removeFeatureState(v, e), this._update();
          }
          getFeatureState(v) {
            return this.style.getFeatureState(v);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let v = 0, e = 0;
            return this._container && (v = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [v, e];
          }
          _setupContainer() {
            const v = this._container;
            v.classList.add("maplibregl-map");
            const e = this._canvasContainer = A.create("div", "maplibregl-canvas-container", v);
            this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = A.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const a = this._containerDimensions(), c = this._getClampedPixelRatio(a[0], a[1]);
            this._resizeCanvas(a[0], a[1], c);
            const p = this._controlContainer = A.create("div", "maplibregl-control-container", v), y = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(((x) => {
              y[x] = A.create("div", `maplibregl-ctrl-${x} `, p);
            })), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _resizeCanvas(v, e, a) {
            this._canvas.width = Math.floor(a * v), this._canvas.height = Math.floor(a * e), this._canvas.style.width = `${v}px`, this._canvas.style.height = `${e}px`;
          }
          _setupPainter() {
            const v = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: true, depth: true, stencil: true, premultipliedAlpha: true });
            let e = null;
            this._canvas.addEventListener("webglcontextcreationerror", ((c) => {
              e = { requestedAttributes: v }, c && (e.statusMessage = c.statusMessage, e.type = c.type);
            }), { once: true });
            let a = null;
            if (a = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, v) : this._canvas.getContext("webgl2", v) || this._canvas.getContext("webgl", v), !a) {
              const c = "Failed to initialize WebGL";
              throw e ? (e.message = c, new Error(JSON.stringify(e))) : new Error(c);
            }
            this.painter = new nu(a, this.transform), O.testSupport(a);
          }
          migrateProjection(v, e) {
            super.migrateProjection(v, e), this.painter.transform = v, this.fire(new s.l("projectiontransition", { newProjection: this.style.projection.name }));
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(v) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || v, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(v) {
            return this._update(), this._renderTaskQueue.add(v);
          }
          _cancelRenderFrame(v) {
            this._renderTaskQueue.remove(v);
          }
          _render(v) {
            var e, a, c, p, y;
            const x = this._idleTriggered ? this._fadeDuration : 0, k = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(v), this._removed) return;
            let P = false;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const j = this.transform.zoom, $ = L.now();
              this.style.zoomHistory.update(j, $);
              const U = new s.F(j, { now: $, fadeDuration: x, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), Y = U.crossFadingFactor();
              Y === 1 && Y === this._crossFadingFactor || (P = true, this._crossFadingFactor = Y), this.style.update(U);
            }
            const E = ((a = this.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0 !== k;
            (c = this.style.projection) === null || c === void 0 || c.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((p = this.style.projection) === null || p === void 0 ? void 0 : p.transitionState, (y = this.style.projection) === null || y === void 0 ? void 0 : y.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || E) && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, x, this._crossSourceCollisions, E), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: x, showPadding: this.showPadding }), this.fire(new s.l("render")), this.loaded() && !this._loaded && (this._loaded = true, s.cw.mark(s.cx.load), this.fire(new s.l("load"))), this.style && (this.style.hasTransitions() || P) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const D = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return D || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new s.l("idle")), !this._loaded || this._fullyLoaded || D || (this._fullyLoaded = true, s.cw.mark(s.cx.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var v;
            this._hash && this._hash.remove();
            for (const a of this._controls) a.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, false), ee.removeThrottleControl(this._imageQueueHandle), (v = this._resizeObserver) === null || v === void 0 || v.disconnect();
            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
            (e == null ? void 0 : e.loseContext) && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), A.remove(this._canvasContainer), A.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, false), this._container.classList.remove("maplibregl-map"), s.cw.clearMetrics(), this._removed = true, this.fire(new s.l("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), L.frame(this._frameRequest, ((v) => {
              s.cw.frame(v), this._frameRequest = null;
              try {
                this._render(v);
              } catch (e) {
                if (!s.cy(e) && !(function(a) {
                  return a.message === Ws;
                })(e)) throw e;
              }
            }), (() => {
            })));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(v) {
            this._showTileBoundaries !== v && (this._showTileBoundaries = v, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(v) {
            this._showPadding !== v && (this._showPadding = v, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(v) {
            this._showCollisionBoxes !== v && (this._showCollisionBoxes = v, v ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(v) {
            this._showOverdrawInspector !== v && (this._showOverdrawInspector = v, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(v) {
            this._repaint !== v && (this._repaint = v, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(v) {
            this._vertices = v, this._update();
          }
          get version() {
            return mu;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
          getProjection() {
            return this.style.getProjection();
          }
          setProjection(v) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(v), this._update(true);
          }
        }, m.MapMouseEvent = Pn, m.MapTouchEvent = as, m.MapWheelEvent = Vc, m.Marker = gu, m.NavigationControl = class {
          constructor(v) {
            this._updateZoomButtons = () => {
              const e = this._map.getZoom(), a = e === this._map.getMaxZoom(), c = e === this._map.getMinZoom();
              this._zoomInButton.disabled = a, this._zoomOutButton.disabled = c, this._zoomInButton.setAttribute("aria-disabled", a.toString()), this._zoomOutButton.setAttribute("aria-disabled", c.toString());
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
            }, this._setButtonTitle = (e, a) => {
              const c = this._map._getUIString(`NavigationControl.${a}`);
              e.title = c, e.setAttribute("aria-label", c);
            }, this.options = s.e({}, Kh, v), this._container = A.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", ((e) => e.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", ((e) => this._map.zoomIn({}, { originalEvent: e }))), A.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", ((e) => this._map.zoomOut({}, { originalEvent: e }))), A.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", ((e) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e }) : this._map.resetNorth({}, { originalEvent: e });
            })), this._compassIcon = A.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(v) {
            return this._map = v, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new no(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            A.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(v, e) {
            const a = A.create("button", v, this._container);
            return a.type = "button", a.addEventListener("click", e), a;
          }
        }, m.Popup = class extends s.E {
          constructor(v) {
            super(), this._updateOpacity = () => {
              this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "");
            }, this.remove = () => (this._content && A.remove(this._content), this._container && (A.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new s.l("close"))), this), this._onMouseUp = (e) => {
              this._update(e.point);
            }, this._onMouseMove = (e) => {
              this._update(e.point);
            }, this._onDrag = (e) => {
              this._update(e.point);
            }, this._update = (e) => {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = A.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = A.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const x of this.options.className.split(" ")) this._container.classList.add(x);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = cs(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
              const a = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
              let c = this.options.anchor;
              const p = _u(this.options.offset);
              if (!c) {
                const x = this._container.offsetWidth, k = this._container.offsetHeight;
                let P;
                P = a.y + p.bottom.y < k ? ["top"] : a.y > this._map.transform.height - k ? ["bottom"] : [], a.x < x / 2 ? P.push("left") : a.x > this._map.transform.width - x / 2 && P.push("right"), c = P.length === 0 ? "bottom" : P.join("-");
              }
              let y = a.add(p[c]);
              this.options.subpixelPositioning || (y = y.round()), A.setTransform(this._container, `${di[c]} translate(${y.x}px,${y.y}px)`), wi(this._container, c, "popup"), this._updateOpacity();
            }, this._onClose = () => {
              this.remove();
            }, this.options = s.e(Object.create(rd), v);
          }
          addTo(v) {
            return this._map && this.remove(), this._map = v, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new s.l("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(v) {
            return this._lngLat = s.S.convert(v), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(v) {
            return this.setDOMContent(document.createTextNode(v));
          }
          setHTML(v) {
            const e = document.createDocumentFragment(), a = document.createElement("body");
            let c;
            for (a.innerHTML = v; c = a.firstChild, c; ) e.appendChild(c);
            return this.setDOMContent(e);
          }
          getMaxWidth() {
            var v;
            return (v = this._container) === null || v === void 0 ? void 0 : v.style.maxWidth;
          }
          setMaxWidth(v) {
            return this.options.maxWidth = v, this._update(), this;
          }
          setDOMContent(v) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = A.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(v), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(v) {
            return this._container && this._container.classList.add(v), this;
          }
          removeClassName(v) {
            return this._container && this._container.classList.remove(v), this;
          }
          setOffset(v) {
            return this.options.offset = v, this._update(), this;
          }
          toggleClassName(v) {
            if (this._container) return this._container.classList.toggle(v);
          }
          setSubpixelPositioning(v) {
            this.options.subpixelPositioning = v;
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = A.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const v = this._container.querySelector(id);
            v && v.focus();
          }
        }, m.RasterDEMTileSource = Ct, m.RasterTileSource = wr, m.ScaleControl = class {
          constructor(v) {
            this._onMove = () => {
              vu(this._map, this._container, this.options);
            }, this.setUnit = (e) => {
              this.options.unit = e, vu(this._map, this._container, this.options);
            }, this.options = Object.assign(Object.assign({}, td), v);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(v) {
            return this._map = v, this._container = A.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", v.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            A.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, m.ScrollZoomHandler = Gh, m.Style = vc, m.TerrainControl = class {
          constructor(v) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = v;
          }
          onAdd(v) {
            return this._map = v, this._container = A.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = A.create("button", "maplibregl-ctrl-terrain", this._container), A.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            A.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, m.TwoFingersTouchPitchHandler = us, m.TwoFingersTouchRotateHandler = Gc, m.TwoFingersTouchZoomHandler = qc, m.TwoFingersTouchZoomRotateHandler = Kc, m.VectorTileSource = Dr, m.VideoSource = Le, m.addSourceType = (v, e) => s._(void 0, void 0, void 0, (function* () {
          if (bt(v)) throw new Error(`A source type called "${v}" already exists.`);
          ((a, c) => {
            ft[a] = c;
          })(v, e);
        })), m.clearPrewarmedResources = function() {
          const v = ut;
          v && (v.isPreloaded() && v.numActive() === 1 ? (v.release(ht), ut = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, m.createTileMesh = mc, m.getMaxParallelImageRequests = function() {
          return s.a.MAX_PARALLEL_IMAGE_REQUESTS;
        }, m.getRTLTextPluginStatus = function() {
          return ri().getRTLTextPluginStatus();
        }, m.getVersion = function() {
          return nd;
        }, m.getWorkerCount = function() {
          return yt.workerCount;
        }, m.getWorkerUrl = function() {
          return s.a.WORKER_URL;
        }, m.importScriptInWorkers = function(v) {
          return pr().broadcast("IS", v);
        }, m.prewarm = function() {
          Ht().acquire(ht);
        }, m.setMaxParallelImageRequests = function(v) {
          s.a.MAX_PARALLEL_IMAGE_REQUESTS = v;
        }, m.setRTLTextPlugin = function(v, e) {
          return ri().setRTLTextPlugin(v, e);
        }, m.setWorkerCount = function(v) {
          yt.workerCount = v;
        }, m.setWorkerUrl = function(v) {
          s.a.WORKER_URL = v;
        };
      }));
      var g = l;
      return g;
    }));
  })($f)), $f.exports;
}
var ws = u6();
/*!
* @indoorequal/vue-maplibre-gl v8.4.2
* (c) 2025 Franois de Metz <francois@2metz.fr>
* @license MIT
*/
const c6 = Symbol("map"), lc = c6, nh = Symbol("isLoaded"), d6 = Symbol("isInitialized"), Qb = d6, Jg = Symbol("componentId"), Qg = Symbol("sourceId"), e1 = Symbol("sourceLayerRegistry"), h6 = ["error", "load", "idle", "remove", "render", "resize", "webglcontextlost", "webglcontextrestored", "dataloading", "data", "tiledataloading", "sourcedataloading", "styledataloading", "sourcedata", "styledata", "styleimagemissing", "dataabort", "sourcedataabort", "boxzoomcancel", "boxzoomstart", "boxzoomend", "touchcancel", "touchmove", "touchend", "touchstart", "click", "contextmenu", "dblclick", "mousemove", "mouseup", "mousedown", "mouseout", "mouseover", "movestart", "move", "moveend", "zoomstart", "zoom", "zoomend", "rotatestart", "rotate", "rotateend", "dragstart", "drag", "dragend", "pitchstart", "pitch", "pitchend", "wheel", "terrain", "cooperativegestureprevented"];
function f6(r, i, l, d) {
  return (f) => l.emit(d, { type: f.type, map: i, component: r, event: f });
}
function p6(r, i) {
  const l = ws.LngLat.convert(r), d = ws.LngLat.convert(i);
  return l.lng === d.lng && l.lat === d.lat;
}
var oh = ((r) => (r.TOP_LEFT = "top-left", r.TOP_RIGHT = "top-right", r.BOTTOM_LEFT = "bottom-left", r.BOTTOM_RIGHT = "bottom-right", r))(oh || {});
const uc = Object.values(oh), $_ = /* @__PURE__ */ new Map(), m6 = Symbol("default");
function g6(r, i, l = m6) {
  var _a3;
  let d = $_.get(l);
  return d || (d = Xw({ isLoaded: false, isMounted: false, language: null }), $_.set(l, d)), d.isLoaded = ((_a3 = i.value) == null ? void 0 : _a3.loaded()) || false, d.isMounted = false, d.component = r, d.map = i.value, d;
}
const t1 = st({ name: "MglMap", props: { width: { type: [Number, String], default: "100%" }, height: { type: [Number, String], default: "100%" }, attributionControl: { type: [Boolean, Object], default: void 0 }, bearing: { type: Number }, bearingSnap: { type: Number }, bounds: { type: [Array, Object] }, boxZoom: { type: Boolean, default: void 0 }, center: { type: [Array, Object] }, clickTolerance: { type: Number }, collectResourceTiming: { type: Boolean, default: void 0 }, crossSourceCollisions: { type: Boolean, default: void 0 }, dragPan: { type: Boolean, default: void 0 }, dragRotate: { type: Boolean, default: void 0 }, doubleClickZoom: { type: Boolean, default: void 0 }, hash: { type: [Boolean, String], default: void 0 }, fadeDuration: { type: Number }, fitBoundsOptions: { type: Object }, interactive: { type: Boolean, default: void 0 }, keyboard: { type: Boolean, default: void 0 }, locale: { type: Object }, localIdeographFontFamily: { type: String }, logoPosition: { type: [String], validator: (r) => r in oh }, maxBounds: { type: [Array, Object] }, maxPitch: { type: Number }, maxZoom: { type: Number }, minPitch: { type: Number }, minZoom: { type: Number }, pitch: { type: Number }, pitchWithRotate: { type: Boolean, default: void 0 }, canvasContextAttributes: { type: Object }, refreshExpiredTiles: { type: Boolean, default: void 0 }, renderWorldCopies: { type: Boolean, default: void 0 }, scrollZoom: { type: Boolean, default: void 0 }, mapStyle: { type: [String, Object] }, trackResize: { type: Boolean, default: void 0 }, transformRequest: { type: Function }, transformCameraUpdate: { type: Function }, touchZoomRotate: { type: Boolean, default: void 0 }, touchPitch: { type: Boolean, default: void 0 }, zoom: { type: Number }, maxTileCacheSize: { type: Number }, mapKey: { type: [String, Symbol] }, pixelRatio: { type: Number }, validateStyle: { type: Boolean, default: void 0 }, cooperativeGestures: { type: Boolean } }, emits: ["map:error", "map:load", "map:idle", "map:remove", "map:render", "map:resize", "map:webglcontextlost", "map:webglcontextrestored", "map:dataloading", "map:data", "map:tiledataloading", "map:sourcedataloading", "map:styledataloading", "map:sourcedata", "map:styledata", "map:styleimagemissing", "map:dataabort", "map:sourcedataabort", "map:boxzoomcancel", "map:boxzoomstart", "map:boxzoomend", "map:touchcancel", "map:touchmove", "map:touchend", "map:touchstart", "map:click", "map:contextmenu", "map:dblclick", "map:mousemove", "map:mouseup", "map:mousedown", "map:mouseout", "map:mouseover", "map:movestart", "map:move", "map:moveend", "map:zoomstart", "map:zoom", "map:zoomend", "map:rotatestart", "map:rotate", "map:rotateend", "map:dragstart", "map:drag", "map:dragend", "map:pitchstart", "map:pitch", "map:pitchend", "map:wheel", "map:terrain", "map:cooperativegestureprevented", "map:projectiontransition", "update:center", "update:zoom", "update:pitch", "update:bearing"], slots: Object, setup(r, i) {
  const l = Gv(eh()), d = Tl(), f = Tl(), g = Ae(false), m = Ae(false), s = /* @__PURE__ */ new Map(), C = g6(l, f, r.mapKey);
  Yr(lc, f), Yr(nh, m), Yr(Qb, g), Yr(Jg, l.uid), Yr(Qg, ""), ar(() => r.bearing, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setBearing(L));
  }), ar(() => r.bounds, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.fitBounds(L, r.fitBoundsOptions));
  }), ar(() => r.center, (L) => {
    var _a3, _b2;
    const A = (_a3 = f.value) == null ? void 0 : _a3.getCenter();
    L && A && !p6(L, A) && ((_b2 = f.value) == null ? void 0 : _b2.setCenter(L));
  }), ar(() => r.maxBounds, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setMaxBounds(L));
  }), ar(() => r.maxPitch, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setMaxPitch(L));
  }), ar(() => r.maxZoom, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setMaxZoom(L));
  }), ar(() => r.minPitch, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setMinPitch(L));
  }), ar(() => r.minZoom, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setMinZoom(L));
  }), ar(() => r.pitch, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setPitch(L));
  }), ar(() => r.renderWorldCopies, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setRenderWorldCopies(L));
  }), ar(() => r.mapStyle, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setStyle(L));
  }), ar(() => r.transformRequest, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setTransformRequest(L));
  }), ar(() => r.zoom, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setZoom(L));
  }), ar(() => r.zoom, (L) => {
    var _a3;
    L && ((_a3 = f.value) == null ? void 0 : _a3.setZoom(L));
  });
  function T() {
    C.isMounted = true;
    const L = { ...r, style: r.mapStyle, container: d.value };
    for (const A of Object.keys(L)) L[A] === void 0 && delete L[A];
    if (f.value = Gv(new ws.Map(L)), C.map = f.value, g.value = true, s.set("__load", () => (m.value = true, C.isLoaded = true)), f.value.on("load", s.get("__load")), s.set("__moveend", () => i.emit("update:center", f.value.getCenter())), f.value.on("moveend", s.get("__moveend")), s.set("__zoomend", () => i.emit("update:zoom", f.value.getZoom())), f.value.on("zoomend", s.get("__zoomend")), s.set("__pitchend", () => i.emit("update:pitch", f.value.getPitch())), f.value.on("pitchend", s.get("__pitchend")), s.set("__rotateend", () => i.emit("update:bearing", f.value.getBearing())), f.value.on("rotateend", s.get("__rotateend")), l.vnode.props) {
      for (const A of h6) if (l.vnode.props["onMap:" + A]) {
        const O = `map:${A}`, V = f6(l, f.value, i, O);
        s.set(A, V), f.value.on(A, V);
      }
    }
    f.value.getCanvas().addEventListener("webglcontextlost", z);
  }
  async function M() {
    C.isMounted = false, C.isLoaded = false, m.value = false, f.value && (f.value.getCanvas().removeEventListener("webglcontextlost", z), g.value = false, s.forEach((L, A) => {
      f.value.off(A.startsWith("__") ? A.substring(2) : A, L);
    }), f.value.remove());
  }
  function z() {
    M(), Vn(T);
  }
  return Qi(T), Sn(M), i.expose({ map: f }), () => [F("div", { ref: d, style: { height: r.height, width: r.width } }), g.value && i.slots.default ? i.slots.default({}) : void 0];
}, render() {
  return null;
} });
function v6(r, i, l) {
  ar(r, (d) => {
    var _a3, _b2;
    d && uc.indexOf(d) === -1 || (((_a3 = i.value) == null ? void 0 : _a3.hasControl(l)) && i.value.removeControl(l), (_b2 = i.value) == null ? void 0 : _b2.addControl(l, d));
  }, { immediate: true });
}
function ah(r, i) {
  const l = fr(lc), d = fr(Qb), f = Tl();
  return f.value = r(), v6(() => i.position, l, f.value), Sn(() => {
    var _a3;
    return d.value && ((_a3 = l.value) == null ? void 0 : _a3.removeControl(f.value));
  }), { control: f, map: l };
}
class _6 {
  constructor(i, l) {
    __publicField(this, "container");
    this.isAdded = i, this.container = document.createElement("div"), this.setClasses(l);
  }
  getDefaultPosition() {
    return oh.TOP_LEFT;
  }
  onAdd() {
    return Vn(() => this.isAdded.value = true), this.container;
  }
  onRemove() {
    this.isAdded.value = false, this.container.remove();
  }
  setClasses(i) {
    this.container.className = i;
  }
}
const j_ = st({ name: "MglCustomControl", props: { position: { type: String, validator: (r) => uc.indexOf(r) !== -1 }, class: { type: String, default: "maplibregl-ctrl maplibregl-ctrl-group" } }, slots: Object, setup(r, { slots: i }) {
  const l = Ae(false), { control: d } = ah(() => new _6(l, r.class), r);
  return ar(() => r.class, () => d.value.setClasses(r.class)), () => {
    var _a3;
    return l.value ? F(wy, { to: d.value.container }, (_a3 = i.default) == null ? void 0 : _a3.call(i, {})) : Xr("custom-component");
  };
}, render() {
  return null;
} }), r1 = st({ name: "MglFullscreenControl", props: { position: { type: String, validator: (r) => uc.indexOf(r) !== -1 }, container: { type: Object, default: null } }, setup(r) {
  const { control: i, map: l } = ah(() => new ws.FullscreenControl({ container: r.container || void 0 }), r);
  function d() {
    Vn(() => {
      var _a3;
      return (_a3 = l.value) == null ? void 0 : _a3.resize();
    });
  }
  i.value.on("fullscreenstart", d), i.value.on("fullscreenend", d), Sn(() => {
    i.value.off("fullscreenstart", d), i.value.off("fullscreenend", d);
  });
}, render() {
  return null;
} }), y6 = st({ name: "MglGeolocateControl", props: { position: { type: String, default: oh.TOP_RIGHT, validator: (r) => uc.indexOf(r) !== -1 }, positionOptions: { type: Object, default: () => ({ enableHighAccuracy: false, timeout: 6e3 }) }, fitBoundsOptions: { type: Object, default: () => ({ maxZoom: 15 }) }, trackUserLocation: { type: Boolean, default: false }, showAccuracyCircle: { type: Boolean, default: true }, showUserLocation: { type: Boolean, default: true } }, emits: ["trackuserlocationstart", "trackuserlocationend", "userlocationlostfocus", "userlocationfocus", "geolocate", "error", "outofmaxbounds"], setup(r, i) {
  const { control: l } = ah(() => new ws.GeolocateControl({ positionOptions: r.positionOptions, fitBoundsOptions: r.fitBoundsOptions, trackUserLocation: r.trackUserLocation, showAccuracyCircle: r.showAccuracyCircle, showUserLocation: r.showUserLocation }), r);
  function d(f) {
    const g = (m) => {
      i.emit(f, m);
    };
    l.value.on(f, g), Sn(() => {
      l.value.off(f, g);
    });
  }
  d("trackuserlocationstart"), d("trackuserlocationend"), d("userlocationlostfocus"), d("userlocationfocus"), d("geolocate"), d("error"), d("outofmaxbounds");
}, render() {
  return null;
} }), i1 = st({ name: "MglNavigationControl", props: { position: { type: String, validator: (r) => uc.indexOf(r) !== -1 }, showCompass: { type: Boolean, default: true }, showZoom: { type: Boolean, default: true }, visualizePitch: Boolean }, setup(r) {
  ah(() => new ws.NavigationControl({ showCompass: r.showCompass, showZoom: r.showZoom, visualizePitch: r.visualizePitch }), r);
}, render() {
  return null;
} });
var n1 = ((r) => (r.IMPERIAL = "imperial", r.METRIC = "metric", r.NAUTICAL = "nautical", r))(n1 || {});
const b6 = Object.values(n1), o1 = st({ name: "MglScaleControl", props: { position: { type: String, validator: (r) => uc.indexOf(r) !== -1 }, maxWidth: { type: Number, default: 100 }, unit: { type: String, default: "metric", validator: (r) => b6.indexOf(r) !== -1 } }, setup(r) {
  ah(() => new ws.ScaleControl({ maxWidth: r.maxWidth, unit: r.unit }), r);
}, render() {
  return null;
} });
let x6 = class {
  constructor() {
    __publicField(this, "unmountHandlers", /* @__PURE__ */ new Map());
  }
  registerUnmountHandler(i, l) {
    this.unmountHandlers.set(i, l);
  }
  unregisterUnmountHandler(i) {
    this.unmountHandlers.delete(i);
  }
  unmount() {
    this.unmountHandlers.forEach((i) => i());
  }
}, e0 = (_a = class {
  static genSourceOpts(i) {
    const l = { ...i };
    for (const d of Object.keys(l)) (l[d] === void 0 || d === "sourceId") && delete l[d];
    return l;
  }
  static getSourceRef(i, l) {
    const d = typeof l == "string", f = String(i) + (d ? l : "");
    let g = _a.REFS.get(f);
    return g || (g = Ae(d ? null : void 0), _a.REFS.set(f, g)), g;
  }
}, __publicField(_a, "REFS", /* @__PURE__ */ new Map()), _a);
function w6(r, i, l) {
  const d = fr(lc), f = fr(nh);
  function g() {
    f.value && (d.value.addSource(i.sourceId, e0.genSourceOpts(i)), r.value = d.value.getSource(i.sourceId));
  }
  return ar(f, g, { immediate: true }), d.value.on("style.load", g), Sn(() => {
    f.value && (l.unmount(), d.value.removeSource(i.sourceId)), d.value.off("style.load", g);
  });
}
const C6 = st({ name: "MglGeoJsonSource", props: { sourceId: { type: String, required: true }, data: { type: [Object, String], required: true }, maxzoom: Number, attribution: String, buffer: Number, tolerance: Number, cluster: Boolean, clusterRadius: Number, clusterMaxZoom: Number, clusterMinPoints: Number, clusterProperties: Object, lineMetrics: Boolean, generateId: Boolean, promoteId: [Object, String], filter: [Array, String, Object] }, slots: Object, setup(r, { slots: i }) {
  const l = fr(Jg), d = e0.getSourceRef(l, r.sourceId), f = new x6(), g = { ...r, type: "geojson" };
  return Yr(Qg, r.sourceId), Yr(e1, f), w6(d, g, f), ar([Hw(r.data) ? r.data : () => r.data, d], ([m, s]) => {
    s == null ? void 0 : s.setData(m || { type: "FeatureCollection", features: [] });
  }, { immediate: true }), () => [Xr("GeoJSON Source"), d.value && i.default ? i.default({}) : void 0];
} }), Ho = ["click", "dblclick", "mousedown", "mouseup", "mousemove", "mouseenter", "mouseleave", "mouseover", "mouseout", "contextmenu", "touchstart", "touchend", "touchcancel"];
function Ss() {
  return { layerId: { type: String, required: true }, source: { type: String }, metadata: { type: [Object, Array, String, Number] }, sourceLayer: { type: String }, minzoom: { type: Number }, maxzoom: { type: Number }, filter: { type: Object }, before: { type: String }, layout: { type: Object }, paint: { type: Object } };
}
function S6(r, i, l, d) {
  const f = { id: r, type: i, source: l.source || d, metadata: l.metadata, minzoom: l.minzoom, maxzoom: l.maxzoom, "source-layer": l.sourceLayer, filter: l.filter, paint: l.paint, layout: l.layout };
  for (const g of Object.keys(f)) f[g] === void 0 && delete f[g];
  return f;
}
function k6(r, i, l) {
  if (l.props) for (const d of Ho) {
    const f = "on" + d.charAt(0).toUpperCase() + d.substr(1);
    l.props[f] && r.on(d, i, l.props[f]);
  }
}
function P6(r, i, l) {
  if (l.props) for (const d of Ho) {
    const f = "on" + d.charAt(0).toUpperCase() + d.substr(1);
    l.props[f] && r.off(d, i, l.props[f]);
  }
}
function a1(r, i) {
  const l = fr(lc), d = fr(nh), f = fr(e1);
  function g() {
    d.value && (i && P6(l.value, r, i.vnode), l.value.getLayer(r) && l.value.removeLayer(r));
  }
  f.registerUnmountHandler(r, g), Sn(() => {
    f.unregisterUnmountHandler(r), g();
  });
}
st({ name: "MglBackgroundLayer", props: { layerId: { type: String, required: true }, metadata: [Object, Array, String, Number], minzoom: Number, maxzoom: Number, before: String, layout: Object, paint: Object }, emits: [...Ho], setup(r) {
  const i = fr(lc), l = fr(nh);
  return a1(r.layerId), ar(() => r.layout, (d) => {
    if (d) for (const [f, g] of Object.entries(d)) i.value.setLayoutProperty(r.layerId, f, g);
  }), ar(() => r.paint, (d) => {
    if (d) for (const [f, g] of Object.entries(d)) i.value.setPaintProperty(r.layerId, f, g);
  }), ar(l, (d) => {
    d && i.value.addLayer({ id: r.layerId, type: "background", metadata: r.metadata, minzoom: r.minzoom, maxzoom: r.maxzoom, layout: r.layout, paint: r.paint }, r.before || void 0);
  }, { immediate: true }), () => Xr("Background Layer");
} });
function ks(r, i) {
  const l = fr(Qg);
  if (!l && !i.source) return;
  const d = eh(), f = fr(lc), g = fr(nh), m = fr(Jg), s = e0.getSourceRef(m, i.source || l);
  return a1(i.layerId, d), ar(() => i.minzoom, () => f.value.setLayerZoomRange(i.layerId, i.minzoom || 0, i.maxzoom || 24)), ar(() => i.maxzoom, () => f.value.setLayerZoomRange(i.layerId, i.minzoom || 0, i.maxzoom || 24)), ar(() => i.layout, (C) => {
    if (C) for (const [T, M] of Object.entries(C)) f.value.setLayoutProperty(i.layerId, T, M);
  }, { deep: true }), ar(() => i.paint, (C) => {
    if (C) for (const [T, M] of Object.entries(C)) f.value.setPaintProperty(i.layerId, T, M);
  }, { deep: true }), ar(() => i.filter, (C) => f.value.setFilter(i.layerId, C), { deep: true }), ar([g, s], ([C, T]) => {
    C && (T || T === void 0) && (f.value.addLayer(S6(i.layerId, r, i, l), i.before || void 0), k6(f.value, i.layerId, d.vnode));
  }, { immediate: true }), () => Xr(`${r} Layer`);
}
st({ name: "MglCircleLayer", props: Ss(), emits: [...Ho], setup(r) {
  return ks("circle", r);
} });
st({ name: "MglFillLayer", props: Ss(), emits: [...Ho], setup(r) {
  return ks("fill", r);
} });
st({ name: "MglFillExtrusionLayer", props: Ss(), emits: [...Ho], setup(r) {
  return ks("fill-extrusion", r);
} });
st({ name: "MglHeatmapLayer", props: Ss(), emits: [...Ho], setup(r) {
  return ks("heatmap", r);
} });
st({ name: "MglHillshadeLayer", props: Ss(), emits: [...Ho], setup(r) {
  return ks("hillshade", r);
} });
const T6 = st({ name: "MglLineLayer", props: Ss(), emits: [...Ho], setup(r) {
  return ks("line", r);
} });
st({ name: "MglRasterLayer", props: Ss(), emits: [...Ho], setup(r) {
  return ks("raster", r);
} });
st({ name: "MglSymbolLayer", props: Ss(), emits: [...Ho], setup(r) {
  return ks("symbol", r);
} });
function Cn() {
  return Cn = Object.assign ? Object.assign.bind() : function(r) {
    for (var i = 1; i < arguments.length; i++) {
      var l = arguments[i];
      for (var d in l) ({}).hasOwnProperty.call(l, d) && (r[d] = l[d]);
    }
    return r;
  }, Cn.apply(null, arguments);
}
var Mn;
(function(r) {
  r.Commit = "commit", r.Provisional = "provisional", r.Finish = "finish";
})(Mn || (Mn = {}));
const cn = { SELECTED: "selected", MID_POINT: "midPoint", SELECTION_POINT_FEATURE_ID: "selectionPointFeatureId", SELECTION_POINT: "selectionPoint" }, Di = { MODE: "mode", CURRENTLY_DRAWING: "currentlyDrawing", EDITED: "edited", CLOSING_POINT: "closingPoint", SNAPPING_POINT: "snappingPoint", COORDINATE_POINT: "coordinatePoint", COORDINATE_POINT_FEATURE_ID: "coordinatePointFeatureId", COORDINATE_POINT_IDS: "coordinatePointIds", PROVISIONAL_COORDINATE_COUNT: "provisionalCoordinateCount", COMMITTED_COORDINATE_COUNT: "committedCoordinateCount" }, jf = 10;
function Hm(r) {
  return !!(r && typeof r == "object" && r !== null && !Array.isArray(r));
}
function N_(r) {
  return !!(r && typeof r == "object" && "properties" in r && typeof r.properties == "object" && r.properties !== null && "mode" in r.properties);
}
function V_(r) {
  return !!(function(i) {
    return typeof i == "number" && !isNaN(new Date(i).valueOf());
  })(r);
}
const I6 = "Feature mode property does not match the mode being added to";
var ec;
(function(r) {
  r.Drawing = "drawing", r.Select = "select", r.Static = "static", r.Render = "render";
})(ec || (ec = {}));
const M6 = { rightClick: true, contextMenu: false, leftClick: true, onDragStart: true, onDrag: true, onDragEnd: true };
class mp {
  get state() {
    return this._state;
  }
  set state(i) {
    throw new Error("Please use the modes lifecycle methods");
  }
  get styles() {
    return this._styles;
  }
  set styles(i) {
    if (typeof i != "object") throw new Error("Styling must be an object");
    this.onStyleChange && this.onStyleChange([], "styling"), this._styles = i;
  }
  registerBehaviors(i) {
  }
  constructor(i, l = false) {
    this._state = "unregistered", this._styles = {}, this.pointerEvents = M6, this.behaviors = [], this.validate = void 0, this.pointerDistance = 40, this.coordinatePrecision = void 0, this.onStyleChange = void 0, this.store = void 0, this.projection = "web-mercator", this.setDoubleClickToZoom = void 0, this.unproject = void 0, this.project = void 0, this.setCursor = void 0, this.type = ec.Drawing, this.mode = "base", l || this.updateOptions(i);
  }
  updateOptions(i) {
    i != null && i.styles && (this.styles = Cn({}, this._styles, i.styles)), i != null && i.pointerDistance && (this.pointerDistance = i.pointerDistance), i != null && i.validation && (this.validate = i && i.validation), i != null && i.projection && (this.projection = i.projection), (i == null ? void 0 : i.pointerEvents) !== void 0 && (this.pointerEvents = i.pointerEvents);
  }
  allowPointerEvent(i, l) {
    return typeof i == "boolean" ? i : typeof i != "function" || i(l);
  }
  setDrawing() {
    if (this._state !== "started") throw new Error("Mode must be unregistered or stopped to start");
    this._state = "drawing";
  }
  setStarted() {
    if (this._state !== "stopped" && this._state !== "registered" && this._state !== "drawing" && this._state !== "selecting") throw new Error("Mode must be unregistered or stopped to start");
    this._state = "started", this.setDoubleClickToZoom(false);
  }
  setStopped() {
    if (this._state !== "started") throw new Error("Mode must be started to be stopped");
    this._state = "stopped", this.setDoubleClickToZoom(true);
  }
  register(i) {
    if (this._state !== "unregistered") throw new Error("Can not register unless mode is unregistered");
    this._state = "registered", this.store = i.store, this.store.registerOnChange(i.onChange), this.setDoubleClickToZoom = i.setDoubleClickToZoom, this.project = i.project, this.unproject = i.unproject, this.onSelect = i.onSelect, this.onDeselect = i.onDeselect, this.setCursor = i.setCursor, this.onStyleChange = i.onChange, this.onFinish = i.onFinish, this.coordinatePrecision = i.coordinatePrecision, this.registerBehaviors({ mode: i.mode, store: this.store, project: this.project, unproject: this.unproject, pointerDistance: this.pointerDistance, coordinatePrecision: i.coordinatePrecision, projection: this.projection });
  }
  validateFeature(i) {
    return this.performFeatureValidation(i);
  }
  afterFeatureAdded(i) {
  }
  afterFeatureUpdated(i) {
  }
  performFeatureValidation(i) {
    if (this._state === "unregistered") throw new Error("Mode must be registered");
    const l = (function(d, f) {
      let g;
      if (Hm(d)) if (d.id == null) g = "Feature has no id";
      else if (typeof d.id != "string" && typeof d.id != "number") g = "Feature must be string or number as per GeoJSON spec";
      else if (f(d.id)) if (Hm(d.geometry)) if (Hm(d.properties)) if (typeof d.geometry.type == "string" && ["Polygon", "LineString", "Point"].includes(d.geometry.type)) if (Array.isArray(d.geometry.coordinates)) {
        if (!d.properties.mode || typeof d.properties.mode != "string") return { valid: false, reason: "Feature does not have a valid mode property" };
      } else g = "Feature coordinates is not an array";
      else g = "Feature is not Point, LineString or Polygon";
      else g = "Feature has no properties";
      else g = "Feature has no geometry";
      else g = "Feature must match the id strategy (default is UUID4)";
      else g = "Feature is not object";
      return g ? { valid: false, reason: g } : { valid: true };
    })(i, this.store.idStrategy.isValidId);
    if (this.validate) {
      const d = this.validate(i, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Mn.Provisional });
      return { valid: l.valid && d.valid, reason: d.reason };
    }
    return { valid: l.valid, reason: l.reason };
  }
  validateModeFeature(i, l) {
    const d = this.performFeatureValidation(i);
    return d.valid ? i.properties.mode !== this.mode ? { valid: false, reason: I6 } : l(i) : { valid: false, reason: d.reason };
  }
  onFinish(i, l) {
  }
  onDeselect(i) {
  }
  onSelect(i) {
  }
  onKeyDown(i) {
  }
  onKeyUp(i) {
  }
  onMouseMove(i) {
  }
  onClick(i) {
  }
  onDragStart(i, l) {
  }
  onDrag(i, l) {
  }
  onDragEnd(i, l) {
  }
  getHexColorStylingValue(i, l, d) {
    return this.getStylingValue(i, l, d);
  }
  getNumericStylingValue(i, l, d) {
    return this.getStylingValue(i, l, d);
  }
  getStylingValue(i, l, d) {
    return i === void 0 ? l : typeof i == "function" ? i(d) : i;
  }
}
class E6 extends mp {
  constructor(...i) {
    super(...i), this.type = ec.Select;
  }
}
function Qa(r, i) {
  const l = (T) => T * Math.PI / 180, d = l(r[1]), f = l(r[0]), g = l(i[1]), m = g - d, s = l(i[0]) - f, C = Math.sin(m / 2) * Math.sin(m / 2) + Math.cos(d) * Math.cos(g) * Math.sin(s / 2) * Math.sin(s / 2);
  return 2 * Math.atan2(Math.sqrt(C), Math.sqrt(1 - C)) * 6371e3 / 1e3;
}
const s1 = 63710088e-1;
function Xn(r) {
  return r % 360 * Math.PI / 180;
}
function R6(r) {
  return r / 6371.0088;
}
function tc(r) {
  return r % (2 * Math.PI) * 180 / Math.PI;
}
function zi(r, i = 9) {
  const l = Math.pow(10, i);
  return Math.round(r * l) / l;
}
const U_ = 57.29577951308232, q_ = 0.017453292519943295, Hf = 6378137, Ai = (r, i) => ({ x: r === 0 ? 0 : r * q_ * Hf, y: i === 0 ? 0 : Math.log(Math.tan(Math.PI / 4 + i * q_ / 2)) * Hf }), rc = (r, i) => ({ lng: r === 0 ? 0 : U_ * (r / Hf), lat: i === 0 ? 0 : (2 * Math.atan(Math.exp(i / Hf)) - Math.PI / 2) * U_ });
function A6(r) {
  let i;
  if (r.geometry.type === "Polygon") i = r.geometry.coordinates;
  else {
    if (r.geometry.type !== "LineString") throw new Error("Self intersects only accepts Polygons and LineStrings");
    i = [r.geometry.coordinates];
  }
  const l = [];
  for (let g = 0; g < i.length; g++) for (let m = 0; m < i[g].length - 1; m++) for (let s = 0; s < i.length; s++) for (let C = 0; C < i[s].length - 1; C++) f(g, m, s, C);
  return l.length > 0;
  function d(g) {
    return g < 0 || g > 1;
  }
  function f(g, m, s, C) {
    const T = i[g][m], M = i[g][m + 1], z = i[s][C], L = i[s][C + 1], A = (function(X, W, K, ie) {
      if (If(X, K) || If(X, ie) || If(W, K) || If(ie, K)) return null;
      const ee = X[0], re = X[1], J = W[0], Se = W[1], fe = K[0], oe = K[1], he = ie[0], be = ie[1], je = (ee - J) * (oe - be) - (re - Se) * (fe - he);
      return je === 0 ? null : [((ee * Se - re * J) * (fe - he) - (ee - J) * (fe * be - oe * he)) / je, ((ee * Se - re * J) * (oe - be) - (re - Se) * (fe * be - oe * he)) / je];
    })(T, M, z, L);
    if (A === null) return;
    let O, V;
    O = M[0] !== T[0] ? (A[0] - T[0]) / (M[0] - T[0]) : (A[1] - T[1]) / (M[1] - T[1]), V = L[0] !== z[0] ? (A[0] - z[0]) / (L[0] - z[0]) : (A[1] - z[1]) / (L[1] - z[1]), d(O) || d(V) || (A.toString(), l.push(A));
  }
}
function If(r, i) {
  return r[0] === i[0] && r[1] === i[1];
}
function t0(r, i) {
  return G_(r[0]) <= i && G_(r[1]) <= i;
}
function l1(r) {
  return r.length === 2 && typeof r[0] == "number" && typeof r[1] == "number" && r[0] !== 1 / 0 && r[1] !== 1 / 0 && (l = r[0]) >= -180 && l <= 180 && (i = r[1]) >= -90 && i <= 90;
  var i, l;
}
function G_(r) {
  let i = 1, l = 0;
  for (; Math.round(r * i) / i !== r; ) i *= 10, l++;
  return l;
}
const pa = (r, i) => {
  const { x: l, y: d } = r, { x: f, y: g } = i, m = f - l, s = g - d;
  return Math.sqrt(s * s + m * m);
};
class Kn {
  constructor({ store: i, mode: l, project: d, unproject: f, pointerDistance: g, coordinatePrecision: m, projection: s }) {
    this.store = void 0, this.mode = void 0, this.project = void 0, this.unproject = void 0, this.pointerDistance = void 0, this.coordinatePrecision = void 0, this.projection = void 0, this.store = i, this.mode = l, this.project = d, this.unproject = f, this.pointerDistance = g, this.coordinatePrecision = m, this.projection = s;
  }
}
function u1({ unproject: r, point: i, pointerDistance: l }) {
  const d = l / 2, { x: f, y: g } = i;
  return { type: "Feature", properties: {}, geometry: { type: "Polygon", coordinates: [[r(f - d, g - d), r(f + d, g - d), r(f + d, g + d), r(f - d, g + d), r(f - d, g - d)].map((m) => [m.lng, m.lat])] } };
}
class Xf extends Kn {
  constructor(i) {
    super(i);
  }
  create(i) {
    const { containerX: l, containerY: d } = i;
    return u1({ unproject: this.unproject, point: { x: l, y: d }, pointerDistance: this.pointerDistance });
  }
}
class Yf extends Kn {
  constructor(i) {
    super(i);
  }
  measure(i, l) {
    const { x: d, y: f } = this.project(l[0], l[1]);
    return pa({ x: d, y: f }, { x: i.containerX, y: i.containerY });
  }
}
class Eg extends Kn {
  constructor(i, l, d) {
    super(i), this.config = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.getSnappableCoordinateFirstClick = (f) => this.getSnappable(f, (g) => !!(g.properties && g.properties.mode === this.mode)).coordinate, this.getSnappableCoordinate = (f, g) => this.getSnappable(f, (m) => !!(m.properties && m.properties.mode === this.mode && m.id !== g)).coordinate, this.config = i, this.pixelDistance = l, this.clickBoundingBox = d;
  }
  getSnappable(i, l) {
    const d = this.clickBoundingBox.create(i), f = this.store.search(d, l), g = { featureId: void 0, featureCoordinateIndex: void 0, coordinate: void 0, minDist: 1 / 0 };
    return f.forEach((m) => {
      let s;
      if (m.geometry.type === "Polygon") s = m.geometry.coordinates[0];
      else {
        if (m.geometry.type !== "LineString") return;
        s = m.geometry.coordinates;
      }
      s.forEach((C, T) => {
        const M = this.pixelDistance.measure(i, C);
        M < g.minDist && M < this.pointerDistance && (g.coordinate = C, g.minDist = M, g.featureId = m.id, g.featureCoordinateIndex = T);
      });
    }), g;
  }
}
function W_(r, i, l) {
  const d = Xn(r[0]), f = Xn(r[1]), g = Xn(l), m = R6(i), s = Math.asin(Math.sin(f) * Math.cos(m) + Math.cos(f) * Math.sin(m) * Math.cos(g));
  return [tc(d + Math.atan2(Math.sin(g) * Math.sin(m) * Math.cos(f), Math.cos(m) - Math.sin(f) * Math.sin(s))), tc(s)];
}
function Z_(r, i) {
  const l = Xn(r[0]), d = Xn(i[0]), f = Xn(r[1]), g = Xn(i[1]), m = Math.sin(d - l) * Math.cos(g), s = Math.cos(f) * Math.sin(g) - Math.sin(f) * Math.cos(g) * Math.cos(d - l);
  return tc(Math.atan2(m, s));
}
function D6({ x: r, y: i }, { x: l, y: d }) {
  const f = l - r, g = d - i;
  if (f === 0 && g === 0) return 0;
  let m = Math.atan2(g, f);
  return m *= 180 / Math.PI, m > 180 ? m -= 360 : m < -180 && (m += 360), m;
}
function z6(r, i, l) {
  const d = [], f = r.length;
  let g, m, s, C = 0;
  for (let M = 0; M < r.length && !(i >= C && M === r.length - 1); M++) {
    if (C > i && d.length === 0) {
      if (g = i - C, !g) return d.push(r[M]), d;
      m = Z_(r[M], r[M - 1]) - 180, s = W_(r[M], g, m), d.push(s);
    }
    if (C >= l) return g = l - C, g ? (m = Z_(r[M], r[M - 1]) - 180, s = W_(r[M], g, m), d.push(s), d) : (d.push(r[M]), d);
    if (C >= i && d.push(r[M]), M === r.length - 1) return d;
    C += Qa(r[M], r[M + 1]);
  }
  if (C < i && r.length === f) throw new Error("Start position is beyond line");
  const T = r[r.length - 1];
  return [T, T];
}
function Mf(r) {
  return r * (Math.PI / 180);
}
function H_(r) {
  return r * (180 / Math.PI);
}
class F6 extends Kn {
  constructor(i) {
    super(i), this.config = void 0, this.config = i;
  }
  generateInsertionCoordinates(i, l, d) {
    const f = [i, l];
    let g = 0;
    for (let T = 0; T < f.length - 1; T++) g += Qa(f[0], f[1]);
    if (g <= d) return f;
    let m = g / d - 1;
    Number.isInteger(m) || (m = Math.floor(m) + 1);
    const s = [];
    for (let T = 0; T < m; T++) {
      const M = z6(f, d * T, d * (T + 1));
      s.push(M);
    }
    const C = [];
    for (let T = 0; T < s.length; T++) C.push(s[T][1]);
    return this.limitCoordinates(C);
  }
  generateInsertionGeodesicCoordinates(i, l, d) {
    const f = Qa(i, l), g = (function(m, s, C) {
      const T = [], M = Mf(m[1]), z = Mf(m[0]), L = Mf(s[1]), A = Mf(s[0]);
      C += 1;
      const O = 2 * Math.asin(Math.sqrt(Math.sin((L - M) / 2) ** 2 + Math.cos(M) * Math.cos(L) * Math.sin((A - z) / 2) ** 2));
      if (O === 0 || isNaN(O)) return T;
      for (let V = 0; V <= C; V++) {
        const X = V / C, W = Math.sin((1 - X) * O) / Math.sin(O), K = Math.sin(X * O) / Math.sin(O), ie = W * Math.cos(M) * Math.cos(z) + K * Math.cos(L) * Math.cos(A), ee = W * Math.cos(M) * Math.sin(z) + K * Math.cos(L) * Math.sin(A), re = W * Math.sin(M) + K * Math.sin(L);
        if (isNaN(ie) || isNaN(ee) || isNaN(re)) continue;
        const J = Math.atan2(re, Math.sqrt(ie ** 2 + ee ** 2)), Se = Math.atan2(ee, ie);
        isNaN(J) || isNaN(Se) || T.push([H_(Se), H_(J)]);
      }
      return T.slice(1, -1);
    })(i, l, Math.floor(f / d));
    return this.limitCoordinates(g);
  }
  limitCoordinates(i) {
    return i.map((l) => [zi(l[0], this.config.coordinatePrecision), zi(l[1], this.config.coordinatePrecision)]);
  }
}
function L6(r, i) {
  return r[0] === i[0] && r[1] === i[1];
}
function B6(r, i) {
  if (r.geometry.type !== "LineString") return { valid: false, reason: "Feature is not a LineString" };
  if (r.geometry.coordinates.length < 2) return { valid: false, reason: "Feature has less than 2 coordinates" };
  for (let l = 0; l < r.geometry.coordinates.length; l++) {
    if (!l1(r.geometry.coordinates[l])) return { valid: false, reason: "Feature has invalid coordinates" };
    if (!t0(r.geometry.coordinates[l], i)) return { valid: false, reason: "Feature has coordinates with excessive precision" };
  }
  return { valid: true };
}
function X_(r) {
  return Math.sqrt(Math.pow(r[0], 2) + Math.pow(r[1], 2) + Math.pow(r[2], 2));
}
function ml(r, i) {
  const l = (function(d, f) {
    const [g, m, s] = d, [C, T, M] = f;
    return g * C + m * T + s * M;
  })(r, i) / (X_(r) * X_(i));
  return Math.acos(Math.min(Math.max(l, -1), 1));
}
function Xm(r) {
  const i = Xn(r[1]), l = Xn(r[0]);
  return [Math.cos(i) * Math.cos(l), Math.cos(i) * Math.sin(l), Math.sin(i)];
}
function gl(r) {
  const [i, l, d] = r, f = tc(Math.asin(d));
  return [tc(Math.atan2(l, i)), f];
}
function O6(r, i, l) {
  const d = Xm(r), f = Xm(i), g = Xm(l), [m, s, C] = g, [T, M, z] = (function(be, je) {
    const [Ve, Ke, lt] = be, [vt, wt, at] = je;
    return [Ke * at - lt * wt, lt * vt - Ve * at, Ve * wt - Ke * vt];
  })(d, f), L = M * C - z * s, A = z * m - T * C, O = T * s - M * m, V = O * M - A * z, X = L * z - O * T, W = A * T - L * M, K = 1 / Math.sqrt(Math.pow(V, 2) + Math.pow(X, 2) + Math.pow(W, 2)), ie = [V * K, X * K, W * K], ee = [-1 * V * K, -1 * X * K, -1 * W * K], re = ml(d, f), J = ml(d, ie), Se = ml(f, ie), fe = ml(d, ee), oe = ml(f, ee);
  let he;
  return he = J < fe && J < oe || Se < fe && Se < oe ? ie : ee, ml(d, he) > re || ml(f, he) > re ? Qa(gl(he), gl(d)) <= Qa(gl(he), gl(f)) ? [gl(d), true, false] : [gl(f), false, true] : [gl(he), false, false];
}
function $6(r, i, l) {
  const d = i.x - r.x, f = i.y - r.y, g = Math.max(0, Math.min(1, ((l.x - r.x) * d + (l.y - r.y) * f) / (d * d + f * f)));
  return { x: r.x + g * d, y: r.y + g * f };
}
class c1 extends Kn {
  constructor(i, l, d) {
    super(i), this.config = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.getSnappableCoordinateFirstClick = (f) => {
      const g = this.getSnappable(f, (m) => !!(m.properties && m.properties.mode === this.mode));
      return g.coordinate ? [zi(g.coordinate[0], this.config.coordinatePrecision), zi(g.coordinate[1], this.config.coordinatePrecision)] : void 0;
    }, this.getSnappableCoordinate = (f, g) => {
      const m = this.getSnappable(f, (s) => !!(s.properties && s.properties.mode === this.mode && s.id !== g));
      return m.coordinate ? [zi(m.coordinate[0], this.config.coordinatePrecision), zi(m.coordinate[1], this.config.coordinatePrecision)] : void 0;
    }, this.config = i, this.pixelDistance = l, this.clickBoundingBox = d;
  }
  getSnappable(i, l) {
    const d = this.clickBoundingBox.create(i), f = this.store.search(d, l), g = { featureId: void 0, featureCoordinateIndex: void 0, coordinate: void 0, minDistance: 1 / 0 };
    return f.forEach((m) => {
      let s;
      if (m.geometry.type === "Polygon") s = m.geometry.coordinates[0];
      else {
        if (m.geometry.type !== "LineString") return;
        s = m.geometry.coordinates;
      }
      const C = [];
      for (let L = 0; L < s.length - 1; L++) C.push([s[L], s[L + 1]]);
      let T;
      const M = [i.lng, i.lat];
      if (this.config.projection === "web-mercator" ? T = (function(L, A) {
        let O = [1 / 0, 1 / 0], V = 1 / 0, X = 0;
        for (let W of A) {
          const K = W[0], ie = W[1];
          let ee, re = 1 / 0;
          const J = Ai(K[0], K[1]), Se = Ai(ie[0], ie[1]), fe = Ai(L[0], L[1]);
          if (K[0] === L[0] && K[1] === L[1]) ee = K;
          else if (ie[0] === L[0] && ie[1] === L[1]) ee = ie;
          else {
            const { x: oe, y: he } = $6(J, Se, fe), { lng: be, lat: je } = rc(oe, he);
            ee = [be, je];
          }
          ee && (re = pa(fe, Ai(ee[0], ee[1])), re < V && (O = ee, V = re, X = A.indexOf(W)));
        }
        return V === 1 / 0 ? void 0 : { coordinate: O, lineIndex: X, distance: V };
      })(M, C) : this.config.projection === "globe" && (T = (function(L, A) {
        let O = [1 / 0, 1 / 0], V = 1 / 0, X = 0;
        for (let W of A) {
          const K = W[0], ie = W[1];
          let ee, re = 1 / 0;
          K[0] === L[0] && K[1] === L[1] ? ee = K : ie[0] === L[0] && ie[1] === L[1] ? ee = ie : [ee] = O6(K, ie, L), ee && (re = Qa(L, ee), re < V && (O = ee, V = re, X = A.indexOf(W)));
        }
        return V === 1 / 0 ? void 0 : { coordinate: O, distance: V, lineIndex: X };
      })(M, C)), !T) return;
      const z = this.pixelDistance.measure(i, T.coordinate);
      z < g.minDistance && z < this.pointerDistance && (g.featureId = m.id, g.coordinate = [zi(T.coordinate[0], this.config.coordinatePrecision), zi(T.coordinate[1], this.config.coordinatePrecision)], g.featureCoordinateIndex = T.lineIndex, g.minDistance = z);
    }), g;
  }
}
const j6 = { cancel: "Escape", finish: "Enter" }, N6 = { start: "crosshair", close: "pointer", dragStart: "grabbing", dragEnd: "crosshair" };
class V6 extends mp {
  constructor(i) {
    super(i, true), this.mode = "linestring", this.currentCoordinate = 0, this.currentId = void 0, this.closingPointId = void 0, this.keyEvents = j6, this.snapping = void 0, this.cursors = N6, this.mouseMove = false, this.insertCoordinates = void 0, this.lastCommittedCoordinates = void 0, this.snappedPointId = void 0, this.lastMouseMoveEvent = void 0, this.editable = false, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedSnapType = void 0, this.editedInsertIndex = void 0, this.editedPointId = void 0, this.coordinateSnapping = void 0, this.insertPoint = void 0, this.lineSnapping = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.updateOptions(i);
  }
  updateOptions(i) {
    super.updateOptions(i), i != null && i.cursors && (this.cursors = Cn({}, this.cursors, i.cursors)), i != null && i.snapping && (this.snapping = i.snapping), (i == null ? void 0 : i.keyEvents) === null ? this.keyEvents = { cancel: null, finish: null } : i != null && i.keyEvents && (this.keyEvents = Cn({}, this.keyEvents, i.keyEvents)), i != null && i.insertCoordinates && (this.insertCoordinates = i.insertCoordinates), i && i.editable && (this.editable = i.editable);
  }
  updateSnappedCoordinate(i) {
    const l = this.snapCoordinate(i);
    if (l) {
      if (this.snappedPointId) this.store.updateGeometry([{ id: this.snappedPointId, geometry: { type: "Point", coordinates: l } }]);
      else {
        const [d] = this.store.create([{ geometry: { type: "Point", coordinates: l }, properties: { mode: this.mode, [Di.SNAPPING_POINT]: true } }]);
        this.snappedPointId = d;
      }
      i.lng = l[0], i.lat = l[1];
    } else this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0);
    return l;
  }
  close() {
    if (this.currentId === void 0) return;
    const i = this.store.getGeometryCopy(this.currentId);
    i.coordinates.pop(), this.updateGeometries([...i.coordinates], void 0, Mn.Commit), this.store.updateProperty([{ id: this.currentId, property: Di.CURRENTLY_DRAWING, value: void 0 }]);
    const l = this.currentId;
    this.closingPointId && this.store.delete([this.closingPointId]), this.snappedPointId && this.store.delete([this.snappedPointId]), this.currentCoordinate = 0, this.currentId = void 0, this.closingPointId = void 0, this.snappedPointId = void 0, this.lastCommittedCoordinates = void 0, this.state === "drawing" && this.setStarted(), this.onFinish(l, { mode: this.mode, action: "draw" });
  }
  updateGeometries(i, l, d) {
    if (!this.currentId) return;
    const f = { type: "LineString", coordinates: i };
    if (this.validate && !this.validate({ type: "Feature", geometry: f }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: d }).valid) return;
    const g = [{ id: this.currentId, geometry: f }];
    this.closingPointId && l && g.push({ id: this.closingPointId, geometry: { type: "Point", coordinates: l } }), d === "commit" && (this.lastCommittedCoordinates = f.coordinates), this.store.updateGeometry(g);
  }
  generateInsertCoordinates(i, l) {
    if (!this.insertCoordinates || !this.lastCommittedCoordinates) throw new Error("Not able to insert coordinates");
    if (this.insertCoordinates.strategy !== "amount") throw new Error("Strategy does not exist");
    const d = Qa(i, l) / (this.insertCoordinates.value + 1);
    let f = [];
    return this.projection === "globe" ? f = this.insertPoint.generateInsertionGeodesicCoordinates(i, l, d) : this.projection === "web-mercator" && (f = this.insertPoint.generateInsertionCoordinates(i, l, d)), f;
  }
  createLine(i) {
    const [l] = this.store.create([{ geometry: { type: "LineString", coordinates: [i, i] }, properties: { mode: this.mode, [Di.CURRENTLY_DRAWING]: true } }]);
    this.lastCommittedCoordinates = [i, i], this.currentId = l, this.currentCoordinate++, this.setDrawing();
  }
  firstUpdateToLine(i) {
    if (!this.currentId) return;
    const l = this.store.getGeometryCopy(this.currentId).coordinates, [d] = this.store.create([{ geometry: { type: "Point", coordinates: [...i] }, properties: { mode: this.mode, [Di.CLOSING_POINT]: true } }]);
    this.closingPointId = d, this.setCursor(this.cursors.close);
    const f = [...l, i];
    this.updateGeometries(f, void 0, Mn.Commit), this.currentCoordinate++;
  }
  updateToLine(i, l) {
    if (!this.currentId) return;
    const d = this.store.getGeometryCopy(this.currentId).coordinates, [f, g] = this.lastCommittedCoordinates ? this.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1] : d[d.length - 2], { x: m, y: s } = this.project(f, g);
    if (pa({ x: m, y: s }, { x: l.x, y: l.y }) < this.pointerDistance) return void this.close();
    this.setCursor(this.cursors.close);
    const C = [...d, i];
    this.updateGeometries(C, d[d.length - 1], Mn.Commit), this.currentCoordinate++;
  }
  registerBehaviors(i) {
    this.coordinateSnapping = new Eg(i, new Yf(i), new Xf(i)), this.insertPoint = new F6(i), this.clickBoundingBox = new Xf(i), this.pixelDistance = new Yf(i), this.lineSnapping = new c1(i, this.pixelDistance, this.clickBoundingBox), this.coordinateSnapping = new Eg(i, this.pixelDistance, this.clickBoundingBox);
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.start);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onMouseMove(i) {
    this.mouseMove = true, this.setCursor(this.cursors.start), this.lastMouseMoveEvent = i;
    const l = this.updateSnappedCoordinate(i) || [i.lng, i.lat];
    if (this.currentId === void 0 || this.currentCoordinate === 0) return;
    const d = this.store.getGeometryCopy(this.currentId).coordinates;
    if (d.pop(), this.closingPointId) {
      const [g, m] = d[d.length - 1], { x: s, y: C } = this.project(g, m);
      pa({ x: s, y: C }, { x: i.containerX, y: i.containerY }) < this.pointerDistance && this.setCursor(this.cursors.close);
    }
    let f = [...d, l];
    if (this.insertCoordinates && this.currentId && this.lastCommittedCoordinates) {
      const g = this.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1], m = l;
      if (!L6(g, m)) {
        const s = this.generateInsertCoordinates(g, m);
        f = [...this.lastCommittedCoordinates.slice(0, -1), ...s, l];
      }
    }
    this.updateGeometries(f, void 0, Mn.Provisional);
  }
  onRightClick(i) {
    if (!this.editable || this.state !== "started") return;
    const { featureId: l, featureCoordinateIndex: d } = this.coordinateSnapping.getSnappable(i, (m) => this.lineStringFilter(m));
    if (!l || d === void 0) return;
    const f = this.store.getGeometryCopy(l);
    let g;
    if (f.type === "LineString" && (g = f.coordinates, !(g.length <= 2))) {
      if (g.splice(d, 1), this.validate && !this.validate({ id: l, type: "Feature", geometry: f, properties: {} }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Mn.Commit }).valid) return;
      this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.store.updateGeometry([{ id: l, geometry: f }]), this.onFinish(l, { mode: this.mode, action: "edit" });
    }
  }
  onLeftClick(i) {
    this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0);
    const l = this.snapCoordinate(i) || [i.lng, i.lat];
    this.currentCoordinate === 0 ? this.createLine(l) : this.currentCoordinate === 1 && this.currentId ? this.firstUpdateToLine(l) : this.currentId && this.updateToLine(l, { x: i.containerX, y: i.containerY });
  }
  onClick(i) {
    (i.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, i) || i.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, i) || i.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, i)) && (this.currentCoordinate > 0 && !this.mouseMove && this.onMouseMove(i), this.mouseMove = false, i.button === "right" ? this.onRightClick(i) : i.button === "left" && this.onLeftClick(i));
  }
  onKeyDown() {
  }
  onKeyUp(i) {
    i.key === this.keyEvents.cancel && this.cleanUp(), i.key === this.keyEvents.finish && this.close();
  }
  onDragStart(i, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDragStart, i) || !this.editable) return;
    let d;
    if (this.state === "started") {
      const f = this.lineSnapping.getSnappable(i, (m) => this.lineStringFilter(m));
      f.coordinate && (this.editedSnapType = "line", this.editedFeatureCoordinateIndex = f.featureCoordinateIndex, this.editedFeatureId = f.featureId, d = f.coordinate);
      const g = this.coordinateSnapping.getSnappable(i, (m) => this.lineStringFilter(m));
      g.coordinate && (this.editedSnapType = "coordinate", this.editedFeatureCoordinateIndex = g.featureCoordinateIndex, this.editedFeatureId = g.featureId, d = g.coordinate);
    }
    if (this.editedFeatureId && d) {
      if (!this.editedPointId) {
        const [f] = this.store.create([{ geometry: { type: "Point", coordinates: d }, properties: { mode: this.mode, [Di.EDITED]: true } }]);
        this.editedPointId = f;
      }
      this.setCursor(this.cursors.dragStart), l(false);
    }
  }
  onDrag(i, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDrag, i) || this.editedFeatureId === void 0 || this.editedFeatureCoordinateIndex === void 0) return;
    const d = this.store.getGeometryCopy(this.editedFeatureId);
    this.editedSnapType === "coordinate" || this.editedSnapType === "line" && this.editedInsertIndex !== void 0 ? d.coordinates[this.editedFeatureCoordinateIndex] = [i.lng, i.lat] : this.editedSnapType === "line" && this.editedInsertIndex === void 0 && (this.editedInsertIndex = this.editedFeatureCoordinateIndex + 1, d.coordinates.splice(this.editedInsertIndex, 0, [i.lng, i.lat]), this.editedFeatureCoordinateIndex++);
    const f = { type: "LineString", coordinates: d.coordinates };
    this.validate && !this.validate({ type: "Feature", geometry: f, properties: this.store.getPropertiesCopy(this.editedFeatureId) }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Mn.Provisional }).valid || (this.snapping && this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.store.updateGeometry([{ id: this.editedFeatureId, geometry: f }]), this.editedPointId && this.store.updateGeometry([{ id: this.editedPointId, geometry: { type: "Point", coordinates: [i.lng, i.lat] } }]), this.store.updateProperty([{ id: this.editedFeatureId, property: Di.EDITED, value: true }]));
  }
  onDragEnd(i, l) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, i) && this.editedFeatureId !== void 0 && (this.setCursor(this.cursors.dragEnd), this.editedPointId && (this.store.delete([this.editedPointId]), this.editedPointId = void 0), this.store.updateProperty([{ id: this.editedFeatureId, property: Di.EDITED, value: false }]), this.onFinish(this.editedFeatureId, { mode: this.mode, action: "edit" }), this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedInsertIndex = void 0, this.editedSnapType = void 0, l(true));
  }
  cleanUp() {
    const i = this.currentId, l = this.closingPointId, d = this.snappedPointId;
    this.closingPointId = void 0, this.snappedPointId = void 0, this.currentId = void 0, this.currentCoordinate = 0, this.state === "drawing" && this.setStarted();
    try {
      i !== void 0 && this.store.delete([i]), d !== void 0 && this.store.delete([d]), l !== void 0 && this.store.delete([l]);
    } catch {
    }
  }
  styleFeature(i) {
    const l = Cn({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    if (i.type === "Feature" && i.geometry.type === "LineString" && i.properties.mode === this.mode) return l.lineStringColor = this.getHexColorStylingValue(this.styles.lineStringColor, l.lineStringColor, i), l.lineStringWidth = this.getNumericStylingValue(this.styles.lineStringWidth, l.lineStringWidth, i), l.zIndex = jf, l;
    if (i.type === "Feature" && i.geometry.type === "Point" && i.properties.mode === this.mode) {
      const d = i.properties[Di.CLOSING_POINT];
      return l.pointColor = this.getHexColorStylingValue(d ? this.styles.closingPointColor : this.styles.snappingPointColor, l.pointColor, i), l.pointWidth = this.getNumericStylingValue(d ? this.styles.closingPointWidth : this.styles.snappingPointWidth, l.pointWidth, i), l.pointOutlineColor = this.getHexColorStylingValue(d ? this.styles.closingPointOutlineColor : this.styles.snappingPointOutlineColor, "#ffffff", i), l.pointOutlineWidth = this.getNumericStylingValue(d ? this.styles.closingPointOutlineWidth : this.styles.snappingPointOutlineWidth, 2, i), l.zIndex = 50, l;
    }
    return l;
  }
  validateFeature(i) {
    return this.validateModeFeature(i, (l) => B6(l, this.coordinatePrecision));
  }
  lineStringFilter(i) {
    return !!(i.geometry.type === "LineString" && i.properties && i.properties.mode === this.mode);
  }
  snapCoordinate(i) {
    var l, d, f;
    let g;
    if ((l = this.snapping) != null && l.toLine) {
      let m;
      m = this.currentId ? this.lineSnapping.getSnappableCoordinate(i, this.currentId) : this.lineSnapping.getSnappableCoordinateFirstClick(i), m && (g = m);
    }
    return (d = this.snapping) != null && d.toCoordinate && (g = this.currentId ? this.coordinateSnapping.getSnappableCoordinate(i, this.currentId) : this.coordinateSnapping.getSnappableCoordinateFirstClick(i)), (f = this.snapping) != null && f.toCustom && (g = this.snapping.toCustom(i, { currentCoordinate: this.currentCoordinate, currentId: this.currentId, getCurrentGeometrySnapshot: this.currentId ? () => this.store.getGeometryCopy(this.currentId) : () => null, project: this.project, unproject: this.unproject })), g;
  }
  afterFeatureUpdated(i) {
    this.editedFeatureId === i.id && this.editedPointId && (this.store.delete([this.editedPointId]), this.editedPointId = void 0, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedSnapType = void 0), this.snappedPointId && this.lastMouseMoveEvent && this.updateSnappedCoordinate(this.lastMouseMoveEvent), this.currentId === i.id && (this.closingPointId && (this.store.delete([this.closingPointId]), this.closingPointId = void 0), this.currentCoordinate = 0, this.currentId = void 0, this.state === "drawing" && this.setStarted());
  }
}
const U6 = "Feature is not a Point", q6 = "Feature has invalid coordinates", G6 = "Feature has coordinates with excessive precision";
function W6(r, i) {
  return r.geometry.type !== "Point" ? { valid: false, reason: U6 } : l1(r.geometry.coordinates) ? t0(r.geometry.coordinates, i) ? { valid: true } : { valid: false, reason: G6 } : { valid: false, reason: q6 };
}
const Z6 = { create: "crosshair", dragStart: "grabbing", dragEnd: "crosshair" };
class H6 extends mp {
  constructor(i) {
    super(i, true), this.mode = "point", this.cursors = Z6, this.editable = false, this.editedFeatureId = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.updateOptions(i);
  }
  updateOptions(i) {
    super.updateOptions(i), i != null && i.cursors && (this.cursors = Cn({}, this.cursors, i.cursors)), i != null && i.editable && (this.editable = i.editable);
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.create);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor("unset");
  }
  onClick(i) {
    i.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, i) || i.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, i) ? this.onRightClick(i) : i.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, i) && this.onLeftClick(i);
  }
  onMouseMove() {
  }
  onKeyDown() {
  }
  onKeyUp() {
  }
  cleanUp() {
    this.editedFeatureId = void 0;
  }
  onDragStart(i, l) {
    if (this.allowPointerEvent(this.pointerEvents.onDragStart, i)) {
      if (this.editable) {
        const d = this.getNearestPointFeature(i);
        this.editedFeatureId = d == null ? void 0 : d.id;
      }
      this.editedFeatureId && (this.setCursor(this.cursors.dragStart), l(false));
    }
  }
  onDrag(i, l) {
    this.allowPointerEvent(this.pointerEvents.onDrag, i) && this.editedFeatureId !== void 0 && (this.validate && !this.validate({ type: "Feature", geometry: { type: "Point", coordinates: [i.lng, i.lat] }, properties: this.store.getPropertiesCopy(this.editedFeatureId) }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Mn.Finish }).valid || (this.store.updateGeometry([{ id: this.editedFeatureId, geometry: { type: "Point", coordinates: [i.lng, i.lat] } }]), this.store.updateProperty([{ id: this.editedFeatureId, property: Di.EDITED, value: true }])));
  }
  onDragEnd(i, l) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, i) && this.editedFeatureId !== void 0 && (this.onFinish(this.editedFeatureId, { mode: this.mode, action: "edit" }), this.setCursor(this.cursors.dragEnd), this.store.updateProperty([{ id: this.editedFeatureId, property: Di.EDITED, value: false }]), this.editedFeatureId = void 0, l(true));
  }
  registerBehaviors(i) {
    this.pixelDistance = new Yf(i), this.clickBoundingBox = new Xf(i);
  }
  styleFeature(i) {
    const l = Cn({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    if (i.type === "Feature" && i.geometry.type === "Point" && i.properties.mode === this.mode) {
      const d = !!(i.id && this.editedFeatureId === i.id);
      l.pointWidth = this.getNumericStylingValue(d ? this.styles.editedPointWidth : this.styles.pointWidth, l.pointWidth, i), l.pointColor = this.getHexColorStylingValue(d ? this.styles.editedPointColor : this.styles.pointColor, l.pointColor, i), l.pointOutlineColor = this.getHexColorStylingValue(d ? this.styles.editedPointOutlineColor : this.styles.pointOutlineColor, l.pointOutlineColor, i), l.pointOutlineWidth = this.getNumericStylingValue(d ? this.styles.editedPointOutlineWidth : this.styles.pointOutlineWidth, 2, i), l.zIndex = 30;
    }
    return l;
  }
  validateFeature(i) {
    return this.validateModeFeature(i, (l) => W6(l, this.coordinatePrecision));
  }
  onLeftClick(i) {
    const l = { type: "Point", coordinates: [i.lng, i.lat] }, d = { mode: this.mode };
    if (this.validate && !this.validate({ type: "Feature", geometry: l, properties: d }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Mn.Finish }).valid) return;
    const [f] = this.store.create([{ geometry: l, properties: d }]);
    this.onFinish(f, { mode: this.mode, action: "draw" });
  }
  onRightClick(i) {
    if (!this.editable) return;
    const l = this.getNearestPointFeature(i);
    l && this.store.delete([l.id]);
  }
  getNearestPointFeature(i) {
    const l = this.clickBoundingBox.create(i), d = this.store.search(l);
    let f, g = 1 / 0;
    for (let m = 0; m < d.length; m++) {
      const s = d[m];
      if (s.geometry.type !== "Point" || s.properties.mode !== this.mode) continue;
      const C = this.pixelDistance.measure(i, s.geometry.coordinates);
      C > g || C > this.pointerDistance || (g = C, f = s);
    }
    return f;
  }
  afterFeatureUpdated(i) {
    this.editedFeatureId === i.id && (this.editedFeatureId = void 0, this.setCursor(this.cursors.create));
  }
}
class X6 extends Kn {
  constructor(i) {
    super(i);
  }
  createOrUpdate(i) {
    const l = this.store.getGeometryCopy(i), d = this.store.getPropertiesCopy(i);
    let f;
    if (l.type === "Polygon") f = l.coordinates[0].slice(0, -1);
    else {
      if (l.type !== "LineString") return;
      f = l.coordinates;
    }
    const g = this.store.getPropertiesCopy(i), m = g.coordinatePointIds;
    if (m) if (m && m.every((s) => this.store.has(s))) {
      const s = g.coordinatePointIds, C = s.map((T) => this.store.getGeometryCopy(T).coordinates);
      if (s.length !== f.length) {
        this.deleteCoordinatePoints(s);
        const T = this.createPoints(f, d.mode, i);
        this.setFeatureCoordinatePoints(i, T);
      } else f.forEach((T, M) => {
        T[0] === C[M][0] && T[1] === C[M][1] || this.store.updateGeometry([{ id: s[M], geometry: { type: "Point", coordinates: T } }]);
      });
    } else {
      const s = m.filter((T) => this.store.has(T));
      s.length && this.deleteCoordinatePoints(s);
      const C = this.createPoints(f, d.mode, i);
      this.setFeatureCoordinatePoints(i, C);
    }
    else {
      const s = this.createPoints(f, d.mode, i);
      this.setFeatureCoordinatePoints(i, s);
    }
  }
  deletePointsByFeatureIds(i) {
    for (const l of i) this.deleteIfPresent(l);
  }
  getUpdated(i, l) {
    const d = this.store.getPropertiesCopy(i);
    if (d.coordinatePointIds) return d.coordinatePointIds.map((f, g) => ({ id: f, geometry: Cn({}, this.store.getGeometryCopy(f), { coordinates: l[g] }) }));
  }
  createPoints(i, l, d) {
    return this.store.create(i.map((f, g) => ({ geometry: { type: "Point", coordinates: f }, properties: { mode: l, [Di.COORDINATE_POINT]: true, [Di.COORDINATE_POINT_FEATURE_ID]: d, index: g } })));
  }
  setFeatureCoordinatePoints(i, l) {
    this.store.updateProperty([{ id: i, property: Di.COORDINATE_POINT_IDS, value: l }]);
  }
  deleteCoordinatePoints(i) {
    const l = i.filter((d) => this.store.has(d));
    this.store.delete(l);
  }
  deleteIfPresent(i) {
    const l = this.store.getPropertiesCopy(i).coordinatePointIds;
    l && (this.deleteCoordinatePoints(l), this.setFeatureCoordinatePoints(i, null));
  }
}
function Rg(r, i) {
  const l = r, d = i, f = Xn(l[1]), g = Xn(d[1]);
  let m = Xn(d[0] - l[0]);
  m > Math.PI && (m -= 2 * Math.PI), m < -Math.PI && (m += 2 * Math.PI);
  const s = Math.log(Math.tan(g / 2 + Math.PI / 4) / Math.tan(f / 2 + Math.PI / 4)), C = (tc(Math.atan2(m, s)) + 360) % 360;
  return C > 180 ? -(360 - C) : C;
}
function d1(r, i, l) {
  let d = i;
  i < 0 && (d = -Math.abs(d));
  const f = d / s1, g = r[0] * Math.PI / 180, m = Xn(r[1]), s = Xn(l), C = f * Math.cos(s);
  let T = m + C;
  Math.abs(T) > Math.PI / 2 && (T = T > 0 ? Math.PI - T : -Math.PI - T);
  const M = Math.log(Math.tan(T / 2 + Math.PI / 4) / Math.tan(m / 2 + Math.PI / 4)), z = Math.abs(M) > 1e-11 ? C / M : Math.cos(m), L = [(180 * (g + f * Math.sin(s) / z) / Math.PI + 540) % 360 - 180, 180 * T / Math.PI];
  return L[0] += L[0] - r[0] > 180 ? -360 : r[0] - L[0] > 180 ? 360 : 0, L;
}
function Y6(r, i, l, d, f) {
  const g = d(r[0], r[1]), m = d(i[0], i[1]), { lng: s, lat: C } = f((g.x + m.x) / 2, (g.y + m.y) / 2);
  return [zi(s, l), zi(C, l)];
}
function K6(r, i, l) {
  const d = d1(r, 1e3 * Qa(r, i) / 2, Rg(r, i));
  return [zi(d[0], l), zi(d[1], l)];
}
function Y_({ featureCoords: r, precision: i, unproject: l, project: d, projection: f }) {
  const g = [];
  for (let m = 0; m < r.length - 1; m++) {
    let s;
    if (f === "web-mercator") s = Y6(r[m], r[m + 1], i, d, l);
    else {
      if (f !== "globe") throw new Error("Invalid projection");
      s = K6(r[m], r[m + 1], i);
    }
    g.push(s);
  }
  return g;
}
class J6 extends Kn {
  constructor(i, l, d) {
    super(i), this.config = void 0, this.selectionPointBehavior = void 0, this.coordinatePointBehavior = void 0, this._midPoints = [], this.config = i, this.selectionPointBehavior = l, this.coordinatePointBehavior = d;
  }
  get ids() {
    return this._midPoints.concat();
  }
  set ids(i) {
  }
  insert(i, l, d) {
    const f = this.store.getGeometryCopy(l), { midPointFeatureId: g, midPointSegment: m } = this.store.getPropertiesCopy(l), s = this.store.getGeometryCopy(g), C = s.type === "Polygon" ? s.coordinates[0] : s.coordinates;
    C.splice(m + 1, 0, f.coordinates), s.coordinates = s.type === "Polygon" ? [C] : C, this.store.updateGeometry([{ id: g, geometry: s }]), this.store.getPropertiesCopy(i)[Di.COORDINATE_POINT_IDS] && this.coordinatePointBehavior.createOrUpdate(i), this.store.delete([...this._midPoints, ...this.selectionPointBehavior.ids]), this.create(C, g, d), this.selectionPointBehavior.create(C, s.type, g);
  }
  create(i, l, d) {
    if (!this.store.has(l)) throw new Error("Store does not have feature with this id");
    this._midPoints = this.store.create((function(f, g, m, s, C, T) {
      return Y_({ featureCoords: f, precision: m, project: s, unproject: C, projection: T }).map((M, z) => ({ geometry: { type: "Point", coordinates: M }, properties: g(z) }));
    })(i, (f) => ({ mode: this.mode, [cn.MID_POINT]: true, midPointSegment: f, midPointFeatureId: l }), d, this.config.project, this.config.unproject, this.projection));
  }
  delete() {
    this._midPoints.length && (this.store.delete(this._midPoints), this._midPoints = []);
  }
  getUpdated(i) {
    if (this._midPoints.length !== 0) return Y_({ featureCoords: i, precision: this.coordinatePrecision, project: this.config.project, unproject: this.config.unproject, projection: this.config.projection }).map((l, d) => ({ id: this._midPoints[d], geometry: { type: "Point", coordinates: l } }));
  }
}
class Q6 extends Kn {
  constructor(i) {
    super(i), this._selectionPoints = [];
  }
  get ids() {
    return this._selectionPoints.concat();
  }
  set ids(i) {
  }
  create(i, l, d) {
    this._selectionPoints = this.store.create((function(f, g, m) {
      const s = [], C = g === "Polygon" ? f.length - 1 : f.length;
      for (let T = 0; T < C; T++) s.push({ geometry: { type: "Point", coordinates: f[T] }, properties: m(T) });
      return s;
    })(i, l, (f) => ({ mode: this.mode, index: f, [cn.SELECTION_POINT]: true, [cn.SELECTION_POINT_FEATURE_ID]: d })));
  }
  delete() {
    this.ids.length && (this.store.delete(this.ids), this._selectionPoints = []);
  }
  getUpdated(i) {
    if (this._selectionPoints.length !== 0) return this._selectionPoints.map((l, d) => ({ id: l, geometry: { type: "Point", coordinates: i[d] } }));
  }
  getOneUpdated(i, l) {
    if (this._selectionPoints[i] !== void 0) return { id: this._selectionPoints[i], geometry: { type: "Point", coordinates: l } };
  }
}
function h1(r, i) {
  let l = false;
  for (let m = 0, s = i.length; m < s; m++) {
    const C = i[m];
    for (let T = 0, M = C.length, z = M - 1; T < M; z = T++) (f = C[T])[1] > (d = r)[1] != (g = C[z])[1] > d[1] && d[0] < (g[0] - f[0]) * (d[1] - f[1]) / (g[1] - f[1]) + f[0] && (l = !l);
  }
  var d, f, g;
  return l;
}
const Ag = (r, i, l) => {
  const d = (g) => g * g, f = (g, m) => d(g.x - m.x) + d(g.y - m.y);
  return Math.sqrt(((g, m, s) => {
    const C = f(m, s);
    if (C === 0) return f(g, m);
    let T = ((g.x - m.x) * (s.x - m.x) + (g.y - m.y) * (s.y - m.y)) / C;
    return T = Math.max(0, Math.min(1, T)), f(g, { x: m.x + T * (s.x - m.x), y: m.y + T * (s.y - m.y) });
  })(r, i, l));
};
class eI extends Kn {
  constructor(i, l, d) {
    super(i), this.config = void 0, this.createClickBoundingBox = void 0, this.pixelDistance = void 0, this.config = i, this.createClickBoundingBox = l, this.pixelDistance = d;
  }
  find(i, l) {
    let d, f, g, m, s = 1 / 0, C = 1 / 0, T = 1 / 0;
    const M = this.createClickBoundingBox.create(i), z = this.store.search(M);
    for (let L = 0; L < z.length; L++) {
      const A = z[L], O = A.geometry;
      if (O.type === "Point") {
        if (A.properties.selectionPoint || A.properties.coordinatePoint || !l && A.properties[cn.MID_POINT]) continue;
        const V = this.pixelDistance.measure(i, O.coordinates);
        A.properties[cn.MID_POINT] && V < this.pointerDistance && V < T ? (T = V, g = A) : !A.properties[cn.MID_POINT] && V < this.pointerDistance && V < s && (s = V, d = A);
      } else if (O.type === "LineString") {
        if (d) continue;
        for (let V = 0; V < O.coordinates.length - 1; V++) {
          const X = O.coordinates[V], W = O.coordinates[V + 1], K = Ag({ x: i.containerX, y: i.containerY }, this.project(X[0], X[1]), this.project(W[0], W[1]));
          K < this.pointerDistance && K < C && (C = K, f = A);
        }
      } else if (O.type === "Polygon") {
        if (d || f) continue;
        h1([i.lng, i.lat], O.coordinates) && (m = A);
      }
    }
    return { clickedFeature: d || f || m, clickedMidPoint: g };
  }
}
class tI extends Kn {
  constructor(i, l, d, f, g) {
    super(i), this.config = void 0, this.featuresAtCursorEvent = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.draggedFeatureId = null, this.dragPosition = void 0, this.config = i, this.featuresAtCursorEvent = l, this.selectionPoints = d, this.midPoints = f, this.coordinatePoints = g;
  }
  startDragging(i, l) {
    this.draggedFeatureId = l, this.dragPosition = [i.lng, i.lat];
  }
  stopDragging() {
    this.draggedFeatureId = null, this.dragPosition = void 0;
  }
  isDragging() {
    return this.draggedFeatureId !== null;
  }
  canDrag(i, l) {
    const { clickedFeature: d } = this.featuresAtCursorEvent.find(i, true);
    return !(!d || d.id !== l);
  }
  drag(i, l) {
    if (!this.draggedFeatureId) return;
    const d = this.store.getGeometryCopy(this.draggedFeatureId), f = [i.lng, i.lat];
    if (d.type === "Polygon" || d.type === "LineString") {
      let g, m;
      if (d.type === "Polygon" ? (g = d.coordinates[0], m = g.length - 1) : (g = d.coordinates, m = g.length), !this.dragPosition) return false;
      for (let M = 0; M < m; M++) {
        const z = g[M];
        let L, A;
        if (this.config.projection === "web-mercator") {
          const O = Ai(this.dragPosition[0], this.dragPosition[1]), V = Ai(f[0], f[1]), X = Ai(z[0], z[1]), W = { x: O.x - V.x, y: O.y - V.y }, K = X.x - W.x, ie = X.y - W.y, { lng: ee, lat: re } = rc(K, ie);
          L = ee, A = re;
        } else {
          const O = [this.dragPosition[0] - f[0], this.dragPosition[1] - f[1]];
          L = z[0] - O[0], A = z[1] - O[1];
        }
        if (L = zi(L, this.config.coordinatePrecision), A = zi(A, this.config.coordinatePrecision), L > 180 || L < -180 || A > 90 || A < -90) return false;
        g[M] = [L, A];
      }
      d.type === "Polygon" && (g[g.length - 1] = [g[0][0], g[0][1]]);
      const s = this.selectionPoints.getUpdated(g) || [], C = this.midPoints.getUpdated(g) || [], T = this.coordinatePoints.getUpdated(this.draggedFeatureId, g) || [];
      if (l && !l({ type: "Feature", id: this.draggedFeatureId, geometry: d, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Mn.Provisional }).valid) return false;
      this.store.updateGeometry([{ id: this.draggedFeatureId, geometry: d }, ...s, ...C, ...T]), this.dragPosition = [i.lng, i.lat];
    } else d.type === "Point" && (this.store.updateGeometry([{ id: this.draggedFeatureId, geometry: { type: "Point", coordinates: f } }]), this.dragPosition = [i.lng, i.lat]);
  }
}
class rI extends Kn {
  constructor(i, l, d, f, g, m, s) {
    super(i), this.config = void 0, this.pixelDistance = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.coordinateSnapping = void 0, this.lineSnapping = void 0, this.draggedCoordinate = { id: null, index: -1 }, this.config = i, this.pixelDistance = l, this.selectionPoints = d, this.midPoints = f, this.coordinatePoints = g, this.coordinateSnapping = m, this.lineSnapping = s;
  }
  getClosestCoordinate(i, l) {
    const d = { dist: 1 / 0, index: -1, isFirstOrLastPolygonCoord: false };
    let f;
    if (l.type === "LineString") f = l.coordinates;
    else {
      if (l.type !== "Polygon") return d;
      f = l.coordinates[0];
    }
    for (let g = 0; g < f.length; g++) {
      const m = this.pixelDistance.measure(i, f[g]);
      if (m < this.pointerDistance && m < d.dist) {
        const s = l.type === "Polygon" && (g === f.length - 1 || g === 0);
        d.dist = m, d.index = s ? 0 : g, d.isFirstOrLastPolygonCoord = s;
      }
    }
    return d;
  }
  getDraggableIndex(i, l) {
    const d = this.store.getGeometryCopy(l), f = this.getClosestCoordinate(i, d);
    return f.index === -1 ? -1 : f.index;
  }
  snapCoordinate(i, l, d) {
    let f = [i.lng, i.lat];
    const g = (m) => !!(m.properties && m.properties.mode === d.properties.mode && m.id !== this.draggedCoordinate.id);
    if (l != null && l.toLine) {
      let m;
      m = this.lineSnapping.getSnappable(i, g).coordinate, m && (f = m);
    }
    if (l.toCoordinate) {
      let m;
      m = this.coordinateSnapping.getSnappable(i, g).coordinate, m && (f = m);
    }
    if (l != null && l.toCustom) {
      let m;
      m = l.toCustom(i, { currentCoordinate: this.draggedCoordinate.index, currentId: d.id, getCurrentGeometrySnapshot: d.id ? () => this.store.getGeometryCopy(d.id) : () => null, project: this.project, unproject: this.unproject }), m && (f = m);
    }
    return f;
  }
  drag(i, l, d, f) {
    const g = this.draggedCoordinate.id;
    if (g === null) return false;
    const m = this.draggedCoordinate.index, s = this.store.getGeometryCopy(g), C = this.store.getPropertiesCopy(g), T = s.type === "LineString" ? s.coordinates : s.coordinates[0], M = s.type === "Polygon" && (m === T.length - 1 || m === 0), z = { type: "Feature", id: g, geometry: s, properties: C }, L = this.snapCoordinate(i, f, z);
    if (i.lng > 180 || i.lng < -180 || i.lat > 90 || i.lat < -90) return false;
    if (M) {
      const W = T.length - 1;
      T[0] = L, T[W] = L;
    } else T[m] = L;
    const A = this.selectionPoints.getOneUpdated(m, L), O = A ? [A] : [], V = this.midPoints.getUpdated(T) || [], X = this.coordinatePoints.getUpdated(g, T) || [];
    return !(s.type !== "Point" && !l && A6({ geometry: s }) || d && !d(z, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Mn.Provisional }).valid || (this.store.updateGeometry([{ id: g, geometry: s }, ...O, ...V, ...X]), 0));
  }
  isDragging() {
    return this.draggedCoordinate.id !== null;
  }
  startDragging(i, l) {
    this.draggedCoordinate = { id: i, index: l };
  }
  stopDragging() {
    this.draggedCoordinate = { id: null, index: -1 };
  }
}
function K_(r) {
  let i = 0, l = 0, d = 0;
  return (r.geometry.type === "Polygon" ? r.geometry.coordinates[0].slice(0, -1) : r.geometry.coordinates).forEach((f) => {
    i += f[0], l += f[1], d++;
  }, true), [i / d, l / d];
}
const f1 = (r, i) => {
  if (i === 0 || i === 360 || i === -360) return r;
  const l = 0.017453292519943295 * i, d = (r.geometry.type === "Polygon" ? r.geometry.coordinates[0] : r.geometry.coordinates).map(([m, s]) => Ai(m, s)), f = d.reduce((m, s) => ({ x: m.x + s.x, y: m.y + s.y }), { x: 0, y: 0 });
  f.x /= d.length, f.y /= d.length;
  const g = d.map((m) => ({ x: f.x + (m.x - f.x) * Math.cos(l) - (m.y - f.y) * Math.sin(l), y: f.y + (m.x - f.x) * Math.sin(l) + (m.y - f.y) * Math.cos(l) })).map(({ x: m, y: s }) => [rc(m, s).lng, rc(m, s).lat]);
  return r.geometry.type === "Polygon" ? r.geometry.coordinates[0] = g : r.geometry.coordinates = g, r;
};
function Dg(r) {
  const i = (r.geometry.type === "Polygon" ? r.geometry.coordinates[0] : r.geometry.coordinates).map((l) => {
    const { x: d, y: f } = Ai(l[0], l[1]);
    return [d, f];
  });
  return r.geometry.type === "Polygon" ? (function(l) {
    let d = 0, f = 0, g = 0;
    const m = l.length;
    for (let s = 0; s < m - 1; s++) {
      const [C, T] = l[s], [M, z] = l[s + 1], L = C * z - M * T;
      d += L, f += (C + M) * L, g += (T + z) * L;
    }
    return d /= 2, f /= 6 * d, g /= 6 * d, { x: f, y: g };
  })(i) : (function(l) {
    const d = l.length;
    let f = 0, g = 0;
    for (let m = 0; m < d; m++) {
      const [s, C] = l[m];
      f += s, g += C;
    }
    return { x: f / d, y: g / d };
  })(i);
}
class iI extends Kn {
  constructor(i, l, d, f) {
    super(i), this.config = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.lastBearing = void 0, this.selectedGeometry = void 0, this.selectedGeometryCentroid = void 0, this.selectedGeometryWebMercatorCentroid = void 0, this.config = i, this.selectionPoints = l, this.midPoints = d, this.coordinatePoints = f;
  }
  reset() {
    this.lastBearing = void 0, this.selectedGeometry = void 0, this.selectedGeometryWebMercatorCentroid = void 0, this.selectedGeometryCentroid = void 0;
  }
  rotate(i, l, d) {
    this.selectedGeometry || (this.selectedGeometry = this.store.getGeometryCopy(l));
    const f = this.selectedGeometry;
    if (f.type !== "Polygon" && f.type !== "LineString") return;
    const g = [i.lng, i.lat];
    let m;
    const s = { type: "Feature", geometry: f, properties: {} };
    if (this.config.projection === "web-mercator") {
      this.selectedGeometryWebMercatorCentroid || (this.selectedGeometryWebMercatorCentroid = Dg(s));
      const L = Ai(i.lng, i.lat);
      if (m = D6(this.selectedGeometryWebMercatorCentroid, L), m === 0) return;
      if (!this.lastBearing) return void (this.lastBearing = m);
      f1(s, -(this.lastBearing - m));
    } else {
      if (this.config.projection !== "globe") throw new Error("Unsupported projection");
      if (this.selectedGeometryCentroid || (this.selectedGeometryCentroid = K_({ geometry: f })), m = Rg(this.selectedGeometryCentroid, g), !this.lastBearing) return void (this.lastBearing = m + 180);
      (function(L, A) {
        if (A === 0 || A === 360 || A === -360) return L;
        const O = K_(L);
        (L.geometry.type === "Polygon" ? L.geometry.coordinates[0] : L.geometry.coordinates).forEach((V) => {
          const X = Rg(O, V) + A, W = (function(ie, ee) {
            ie[0] += ie[0] - ee[0] > 180 ? -360 : ee[0] - ie[0] > 180 ? 360 : 0;
            const re = s1, J = ee[1] * Math.PI / 180, Se = ie[1] * Math.PI / 180, fe = Se - J;
            let oe = Math.abs(ie[0] - ee[0]) * Math.PI / 180;
            oe > Math.PI && (oe -= 2 * Math.PI);
            const he = Math.log(Math.tan(Se / 2 + Math.PI / 4) / Math.tan(J / 2 + Math.PI / 4)), be = Math.abs(he) > 1e-11 ? fe / he : Math.cos(J);
            return Math.sqrt(fe * fe + be * be * oe * oe) * re;
          })(O, V), K = d1(O, W, X);
          V[0] = K[0], V[1] = K[1];
        });
      })(s, -(this.lastBearing - (m + 180)));
    }
    const C = f.type === "Polygon" ? f.coordinates[0] : f.coordinates;
    C.forEach((L) => {
      L[0] = zi(L[0], this.coordinatePrecision), L[1] = zi(L[1], this.coordinatePrecision);
    });
    const T = this.midPoints.getUpdated(C) || [], M = this.selectionPoints.getUpdated(C) || [], z = this.coordinatePoints.getUpdated(l, C) || [];
    if (d && !d({ id: l, type: "Feature", geometry: f, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Mn.Provisional })) return false;
    this.store.updateGeometry([{ id: l, geometry: f }, ...M, ...T, ...z]), this.projection === "web-mercator" ? this.lastBearing = m : this.projection === "globe" && (this.lastBearing = m + 180);
  }
}
class nI extends Kn {
  constructor(i, l) {
    super(i), this.config = void 0, this.dragCoordinateResizeBehavior = void 0, this.config = i, this.dragCoordinateResizeBehavior = l;
  }
  scale(i, l, d) {
    if (!this.dragCoordinateResizeBehavior.isDragging()) {
      const f = this.dragCoordinateResizeBehavior.getDraggableIndex(i, l);
      this.dragCoordinateResizeBehavior.startDragging(l, f);
    }
    this.dragCoordinateResizeBehavior.drag(i, "center-fixed", d);
  }
  reset() {
    this.dragCoordinateResizeBehavior.stopDragging();
  }
}
function p1({ coordinates: r, originX: i, originY: l, xScale: d, yScale: f }) {
  d === 1 && f === 1 || r.forEach((g) => {
    const { x: m, y: s } = Ai(g[0], g[1]), C = i + (m - i) * d, T = l + (s - l) * f, { lng: M, lat: z } = rc(C, T);
    g[0] = M, g[1] = z;
  });
}
class oI extends Kn {
  constructor(i, l, d, f, g) {
    super(i), this.config = void 0, this.pixelDistance = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.minimumScale = 1e-4, this.draggedCoordinate = { id: null, index: -1 }, this.boundingBoxMaps = { opposite: { 0: 4, 1: 5, 2: 6, 3: 7, 4: 0, 5: 1, 6: 2, 7: 3 } }, this.config = i, this.pixelDistance = l, this.selectionPoints = d, this.midPoints = f, this.coordinatePoints = g;
  }
  getClosestCoordinate(i, l) {
    const d = { dist: 1 / 0, index: -1, isFirstOrLastPolygonCoord: false };
    let f;
    if (l.type === "LineString") f = l.coordinates;
    else {
      if (l.type !== "Polygon") return d;
      f = l.coordinates[0];
    }
    for (let g = 0; g < f.length; g++) {
      const m = this.pixelDistance.measure(i, f[g]);
      if (m < this.pointerDistance && m < d.dist) {
        const s = l.type === "Polygon" && (g === f.length - 1 || g === 0);
        d.dist = m, d.index = s ? 0 : g, d.isFirstOrLastPolygonCoord = s;
      }
    }
    return d;
  }
  isValidDragWebMercator(i, l, d) {
    switch (i) {
      case 0:
        if (l <= 0 || d >= 0) return false;
        break;
      case 1:
        if (d >= 0) return false;
        break;
      case 2:
        if (l >= 0 || d >= 0) return false;
        break;
      case 3:
        if (l >= 0) return false;
        break;
      case 4:
        if (l >= 0 || d <= 0) return false;
        break;
      case 5:
        if (d <= 0) return false;
        break;
      case 6:
        if (l <= 0 || d <= 0) return false;
        break;
      case 7:
        if (l <= 0) return false;
    }
    return true;
  }
  getSelectedFeatureDataWebMercator() {
    if (!this.draggedCoordinate.id || this.draggedCoordinate.index === -1) return null;
    const i = this.getFeature(this.draggedCoordinate.id);
    if (!i) return null;
    const l = this.getNormalisedCoordinates(i.geometry);
    return { boundingBox: this.getBBoxWebMercator(l), feature: i, updatedCoords: l, selectedCoordinate: l[this.draggedCoordinate.index] };
  }
  centerWebMercatorDrag(i) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { feature: d, boundingBox: f, updatedCoords: g, selectedCoordinate: m } = l, s = Dg(d);
    if (!s) return null;
    const C = Ai(m[0], m[1]), { closestBBoxIndex: T } = this.getIndexesWebMercator(f, C), M = Ai(i.lng, i.lat);
    return this.scaleWebMercator({ closestBBoxIndex: T, updatedCoords: g, webMercatorCursor: M, webMercatorSelected: C, webMercatorOrigin: s }), g;
  }
  centerFixedWebMercatorDrag(i) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { feature: d, boundingBox: f, updatedCoords: g, selectedCoordinate: m } = l, s = Dg(d);
    if (!s) return null;
    const C = Ai(m[0], m[1]), { closestBBoxIndex: T } = this.getIndexesWebMercator(f, C), M = Ai(i.lng, i.lat);
    return this.scaleFixedWebMercator({ closestBBoxIndex: T, updatedCoords: g, webMercatorCursor: M, webMercatorSelected: C, webMercatorOrigin: s }), g;
  }
  scaleFixedWebMercator({ closestBBoxIndex: i, webMercatorOrigin: l, webMercatorSelected: d, webMercatorCursor: f, updatedCoords: g }) {
    if (!this.isValidDragWebMercator(i, l.x - f.x, l.y - f.y)) return null;
    let m = pa(l, f) / pa(l, d);
    return m < 0 && (m = this.minimumScale), p1({ coordinates: g, originX: l.x, originY: l.y, xScale: m, yScale: m }), g;
  }
  oppositeFixedWebMercatorDrag(i) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { boundingBox: d, updatedCoords: f, selectedCoordinate: g } = l, m = Ai(g[0], g[1]), { oppositeBboxIndex: s, closestBBoxIndex: C } = this.getIndexesWebMercator(d, m), T = { x: d[s][0], y: d[s][1] }, M = Ai(i.lng, i.lat);
    return this.scaleFixedWebMercator({ closestBBoxIndex: C, updatedCoords: f, webMercatorCursor: M, webMercatorSelected: m, webMercatorOrigin: T }), f;
  }
  oppositeWebMercatorDrag(i) {
    const l = this.getSelectedFeatureDataWebMercator();
    if (!l) return null;
    const { boundingBox: d, updatedCoords: f, selectedCoordinate: g } = l, m = Ai(g[0], g[1]), { oppositeBboxIndex: s, closestBBoxIndex: C } = this.getIndexesWebMercator(d, m), T = { x: d[s][0], y: d[s][1] }, M = Ai(i.lng, i.lat);
    return this.scaleWebMercator({ closestBBoxIndex: C, updatedCoords: f, webMercatorCursor: M, webMercatorSelected: m, webMercatorOrigin: T }), f;
  }
  scaleWebMercator({ closestBBoxIndex: i, webMercatorOrigin: l, webMercatorSelected: d, webMercatorCursor: f, updatedCoords: g }) {
    const m = l.x - f.x, s = l.y - f.y;
    if (!this.isValidDragWebMercator(i, m, s)) return null;
    let C = 1;
    m !== 0 && i !== 1 && i !== 5 && (C = 1 - (l.x - d.x - m) / m);
    let T = 1;
    return s !== 0 && i !== 3 && i !== 7 && (T = 1 - (l.y - d.y - s) / s), this.validateScale(C, T) ? (C < 0 && (C = this.minimumScale), T < 0 && (T = this.minimumScale), this.performWebMercatorScale(g, l.x, l.y, C, T), g) : null;
  }
  getFeature(i) {
    if (this.draggedCoordinate.id === null) return null;
    const l = this.store.getGeometryCopy(i);
    return l.type !== "Polygon" && l.type !== "LineString" ? null : { id: i, type: "Feature", geometry: l, properties: {} };
  }
  getNormalisedCoordinates(i) {
    return i.type === "Polygon" ? i.coordinates[0] : i.coordinates;
  }
  validateScale(i, l) {
    const d = !isNaN(i) && l < Number.MAX_SAFE_INTEGER, f = !isNaN(l) && l < Number.MAX_SAFE_INTEGER;
    return d && f;
  }
  performWebMercatorScale(i, l, d, f, g) {
    i.forEach((m) => {
      const { x: s, y: C } = Ai(m[0], m[1]), T = l + (s - l) * f, M = d + (C - d) * g, { lng: z, lat: L } = rc(T, M);
      m[0] = z, m[1] = L;
    });
  }
  getBBoxWebMercator(i) {
    const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    (i = i.map((s) => {
      const { x: C, y: T } = Ai(s[0], s[1]);
      return [C, T];
    })).forEach(([s, C]) => {
      s < l[0] && (l[0] = s), C < l[1] && (l[1] = C), s > l[2] && (l[2] = s), C > l[3] && (l[3] = C);
    });
    const [d, f, g, m] = l;
    return [[d, m], [(d + g) / 2, m], [g, m], [g, m + (f - m) / 2], [g, f], [(d + g) / 2, f], [d, f], [d, m + (f - m) / 2]];
  }
  getIndexesWebMercator(i, l) {
    let d, f = 1 / 0;
    for (let g = 0; g < i.length; g++) {
      const m = pa({ x: l.x, y: l.y }, { x: i[g][0], y: i[g][1] });
      m < f && (d = g, f = m);
    }
    if (d === void 0) throw new Error("No closest coordinate found");
    return { oppositeBboxIndex: this.boundingBoxMaps.opposite[d], closestBBoxIndex: d };
  }
  isDragging() {
    return this.draggedCoordinate.id !== null;
  }
  startDragging(i, l) {
    this.draggedCoordinate = { id: i, index: l };
  }
  stopDragging() {
    this.draggedCoordinate = { id: null, index: -1 };
  }
  getDraggableIndex(i, l) {
    const d = this.store.getGeometryCopy(l), f = this.getClosestCoordinate(i, d);
    return f.index === -1 ? -1 : f.index;
  }
  drag(i, l, d) {
    if (!this.draggedCoordinate.id) return false;
    const f = this.getFeature(this.draggedCoordinate.id);
    if (!f) return false;
    let g = null;
    if (l === "center" ? g = this.centerWebMercatorDrag(i) : l === "opposite" ? g = this.oppositeWebMercatorDrag(i) : l === "center-fixed" ? g = this.centerFixedWebMercatorDrag(i) : l === "opposite-fixed" && (g = this.oppositeFixedWebMercatorDrag(i)), !g) return false;
    for (let M = 0; M < g.length; M++) {
      const z = g[M];
      if (z[0] = zi(z[0], this.coordinatePrecision), z[1] = zi(z[1], this.coordinatePrecision), !t0(z, this.coordinatePrecision)) return false;
    }
    const m = this.midPoints.getUpdated(g) || [], s = this.selectionPoints.getUpdated(g) || [], C = this.coordinatePoints.getUpdated(f.id, g) || [], T = { type: f.geometry.type, coordinates: f.geometry.type === "Polygon" ? [g] : g };
    return !(d && !d({ id: this.draggedCoordinate.id, type: "Feature", geometry: T, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: Mn.Provisional }).valid || (this.store.updateGeometry([{ id: this.draggedCoordinate.id, geometry: T }, ...s, ...m, ...C]), 0));
  }
}
const aI = { deselect: "Escape", delete: "Delete", rotate: ["Control", "r"], scale: ["Control", "s"] }, J_ = { pointerOver: "move", dragStart: "move", dragEnd: "move", insertMidpoint: "crosshair" };
class sI extends E6 {
  constructor(i) {
    super(i, true), this.mode = "select", this.allowManualDeselection = true, this.dragEventThrottle = 5, this.dragEventCount = 0, this.selected = [], this.flags = {}, this.keyEvents = aI, this.cursors = J_, this.validations = {}, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinateSnap = void 0, this.featuresAtMouseEvent = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.dragFeature = void 0, this.dragCoordinate = void 0, this.rotateFeature = void 0, this.scaleFeature = void 0, this.dragCoordinateResizeFeature = void 0, this.coordinatePoints = void 0, this.lineSnap = void 0, this.updateOptions(i);
  }
  updateOptions(i) {
    if (super.updateOptions(i), this.cursors = i && i.cursors ? Cn({}, this.cursors, i.cursors) : J_, (i == null ? void 0 : i.keyEvents) === null ? this.keyEvents = { deselect: null, delete: null, rotate: null, scale: null } : i != null && i.keyEvents && (this.keyEvents = Cn({}, this.keyEvents, i.keyEvents)), (i == null ? void 0 : i.dragEventThrottle) !== void 0 && (this.dragEventThrottle = i.dragEventThrottle), (i == null ? void 0 : i.allowManualDeselection) !== void 0 && (this.allowManualDeselection = i.allowManualDeselection), i != null && i.flags) {
      this.flags = Cn({}, this.flags, i.flags), this.validations = {};
      for (const l in this.flags) {
        const d = this.flags[l].feature;
        d && d.validation && (this.validations[l] = d.validation);
      }
    }
  }
  selectFeature(i) {
    this.select(i, false);
  }
  setSelecting() {
    if (this._state !== "started") throw new Error("Mode must be started to move to selecting state");
    this._state = "selecting";
  }
  registerBehaviors(i) {
    this.pixelDistance = new Yf(i), this.clickBoundingBox = new Xf(i), this.featuresAtMouseEvent = new eI(i, this.clickBoundingBox, this.pixelDistance), this.selectionPoints = new Q6(i), this.coordinatePoints = new X6(i), this.midPoints = new J6(i, this.selectionPoints, this.coordinatePoints), this.coordinateSnap = new Eg(i, this.pixelDistance, this.clickBoundingBox), this.lineSnap = new c1(i, this.pixelDistance, this.clickBoundingBox), this.rotateFeature = new iI(i, this.selectionPoints, this.midPoints, this.coordinatePoints), this.dragFeature = new tI(i, this.featuresAtMouseEvent, this.selectionPoints, this.midPoints, this.coordinatePoints), this.dragCoordinate = new rI(i, this.pixelDistance, this.selectionPoints, this.midPoints, this.coordinatePoints, this.coordinateSnap, this.lineSnap), this.dragCoordinateResizeFeature = new oI(i, this.pixelDistance, this.selectionPoints, this.midPoints, this.coordinatePoints), this.scaleFeature = new nI(i, this.dragCoordinateResizeFeature);
  }
  deselectFeature() {
    this.deselect();
  }
  deselect() {
    const i = this.selected.filter((l) => this.store.has(l)).map((l) => ({ id: l, property: cn.SELECTED, value: false }));
    this.store.updateProperty(i), this.onDeselect(this.selected[0]), this.selected = [], this.selectionPoints.delete(), this.midPoints.delete();
  }
  deleteSelected() {
    this.store.delete(this.selected), this.selected = [];
  }
  onRightClick(i) {
    if (!this.selectionPoints.ids.length) return;
    let l, d = 1 / 0;
    if (this.selectionPoints.ids.forEach((L) => {
      const A = this.store.getGeometryCopy(L), O = this.pixelDistance.measure(i, A.coordinates);
      O < this.pointerDistance && O < d && (d = O, l = this.store.getPropertiesCopy(L));
    }), !l) return;
    const f = l.selectionPointFeatureId, g = l.index, m = this.store.getPropertiesCopy(f), s = this.flags[m.mode], C = this.validations[m.mode];
    if (!(s && s.feature && s.feature.coordinates && s.feature.coordinates.deletable)) return;
    const T = this.store.getGeometryCopy(f);
    let M;
    if (T.type === "Polygon") {
      if (M = T.coordinates[0], M.length <= 4) return;
    } else if (T.type === "LineString" && (M = T.coordinates, M.length <= 2)) return;
    if (!M || (T.type !== "Polygon" || g !== 0 && g !== M.length - 1 ? M.splice(g, 1) : (M.shift(), M.pop(), M.push([M[0][0], M[0][1]])), C && !C({ id: f, type: "Feature", geometry: T, properties: m }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: Mn.Commit }).valid)) return;
    const z = [...this.midPoints.ids, ...this.selectionPoints.ids];
    this.store.delete(z), this.store.updateGeometry([{ id: f, geometry: T }]), m.coordinatePointIds && this.coordinatePoints.createOrUpdate(f), this.selectionPoints.create(M, T.type, f), s && s.feature && s.feature.coordinates && s.feature.coordinates.midpoints && this.midPoints.create(M, f, this.coordinatePrecision);
  }
  select(i, l = true) {
    if (this.selected[0] === i) return;
    const { mode: d } = this.store.getPropertiesCopy(i), f = this.flags[d];
    if (!f || !f.feature) return;
    const g = this.selected[0];
    if (g) {
      if (g === i) return;
      this.deselect();
    }
    l && this.setCursor(this.cursors.pointerOver), this.selected = [i], this.store.updateProperty([{ id: i, property: cn.SELECTED, value: true }]), this.onSelect(i);
    const { type: m, coordinates: s } = this.store.getGeometryCopy(i);
    if (m !== "LineString" && m !== "Polygon") return;
    const C = m === "LineString" ? s : s[0];
    C && f && f.feature.coordinates && (this.selectionPoints.create(C, m, i), f.feature.coordinates.midpoints && this.midPoints.create(C, i, this.coordinatePrecision));
  }
  onLeftClick(i) {
    const { clickedFeature: l, clickedMidPoint: d } = this.featuresAtMouseEvent.find(i, this.selected.length > 0);
    if (this.selected.length && d) this.midPoints.insert(this.selected[0], d.id, this.coordinatePrecision);
    else if (l && l.id) this.select(l.id, true);
    else if (this.selected.length && this.allowManualDeselection) return void this.deselect();
  }
  start() {
    this.setStarted(), this.setSelecting();
  }
  stop() {
    this.cleanUp(), this.setStarted(), this.setStopped();
  }
  onClick(i) {
    i.button === "right" && this.allowPointerEvent(this.pointerEvents.rightClick, i) || i.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, i) ? this.onRightClick(i) : i.button === "left" && this.allowPointerEvent(this.pointerEvents.leftClick, i) && this.onLeftClick(i);
  }
  canScale(i) {
    return this.keyEvents.scale && this.keyEvents.scale.every((l) => i.heldKeys.includes(l));
  }
  canRotate(i) {
    return this.keyEvents.rotate && this.keyEvents.rotate.every((l) => i.heldKeys.includes(l));
  }
  preventDefaultKeyEvent(i) {
    const l = this.canRotate(i), d = this.canScale(i);
    (l || d) && i.preventDefault();
  }
  onKeyDown(i) {
    this.preventDefaultKeyEvent(i);
  }
  onKeyUp(i) {
    if (this.preventDefaultKeyEvent(i), this.keyEvents.delete && i.key === this.keyEvents.delete) {
      if (!this.selected.length) return;
      const l = this.selected[0];
      this.onDeselect(this.selected[0]), this.coordinatePoints.deletePointsByFeatureIds([l]), this.deleteSelected(), this.selectionPoints.delete(), this.midPoints.delete();
    } else this.keyEvents.deselect && i.key === this.keyEvents.deselect && this.cleanUp();
  }
  cleanUp() {
    this.selected.length && this.deselect();
  }
  onDragStart(i, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDragStart, i) || !this.selected.length) return;
    const d = this.store.getPropertiesCopy(this.selected[0]), f = this.flags[d.mode];
    if (!(f && f.feature && (f.feature.draggable || f.feature.coordinates && f.feature.coordinates.draggable || f.feature.coordinates && f.feature.coordinates.resizable || f.feature.coordinates && typeof f.feature.coordinates.midpoints == "object" && f.feature.coordinates.midpoints.draggable))) return;
    this.dragEventCount = 0;
    const g = this.selected[0], m = this.dragCoordinate.getDraggableIndex(i, g);
    if (f && f.feature && f.feature.coordinates && (f.feature.coordinates.draggable || f.feature.coordinates.resizable) && m !== -1) return this.setCursor(this.cursors.dragStart), f.feature.coordinates.resizable ? this.dragCoordinateResizeFeature.startDragging(g, m) : this.dragCoordinate.startDragging(g, m), void l(false);
    if (f && f.feature && f.feature.coordinates && typeof f.feature.coordinates.midpoints == "object" && f.feature.coordinates.midpoints.draggable) {
      const { clickedMidPoint: s } = this.featuresAtMouseEvent.find(i, this.selected.length > 0);
      if (this.selected.length && s) {
        this.midPoints.insert(g, s.id, this.coordinatePrecision);
        const C = this.dragCoordinate.getDraggableIndex(i, g);
        return this.dragCoordinate.startDragging(g, C), void l(false);
      }
    }
    return f && f.feature && f.feature.draggable && this.dragFeature.canDrag(i, g) ? (this.setCursor(this.cursors.dragStart), this.dragFeature.startDragging(i, g), void l(false)) : void 0;
  }
  onDrag(i, l) {
    if (!this.allowPointerEvent(this.pointerEvents.onDrag, i)) return;
    const d = this.selected[0];
    if (!d) return;
    const f = this.store.getPropertiesCopy(d), g = this.flags[f.mode], m = (g && g.feature && g.feature.selfIntersectable) === true;
    if (this.dragEventCount++, this.dragEventCount % this.dragEventThrottle == 0) return;
    const s = this.validations[f.mode];
    if (g && g.feature && g.feature.rotateable && this.canRotate(i)) return l(false), void this.rotateFeature.rotate(i, d, s);
    if (g && g.feature && g.feature.scaleable && this.canScale(i)) return l(false), void this.scaleFeature.scale(i, d, s);
    if (this.dragCoordinateResizeFeature.isDragging() && g.feature && g.feature.coordinates && g.feature.coordinates.resizable) {
      if (this.projection === "globe") throw new Error("Globe is currently unsupported projection for resizable");
      return l(false), void this.dragCoordinateResizeFeature.drag(i, g.feature.coordinates.resizable, s);
    }
    if (this.dragCoordinate.isDragging()) {
      var C;
      const T = (C = g.feature) == null || (C = C.coordinates) == null ? void 0 : C.snappable;
      let M = { toCoordinate: false };
      return T === true ? M = { toCoordinate: true } : typeof T == "object" && (M = T), void this.dragCoordinate.drag(i, m, s, M);
    }
    this.dragFeature.isDragging() ? this.dragFeature.drag(i, s) : l(true);
  }
  onDragEnd(i, l) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, i) && (this.setCursor(this.cursors.dragEnd), this.dragCoordinate.isDragging() ? this.onFinish(this.selected[0], { mode: this.mode, action: "dragCoordinate" }) : this.dragFeature.isDragging() ? this.onFinish(this.selected[0], { mode: this.mode, action: "dragFeature" }) : this.dragCoordinateResizeFeature.isDragging() && this.onFinish(this.selected[0], { mode: this.mode, action: "dragCoordinateResize" }), this.dragCoordinate.stopDragging(), this.dragFeature.stopDragging(), this.dragCoordinateResizeFeature.stopDragging(), this.rotateFeature.reset(), this.scaleFeature.reset(), l(true));
  }
  onMouseMove(i) {
    if (!this.selected.length) return void this.setCursor("unset");
    if (this.dragFeature.isDragging()) return;
    let l = false;
    this.midPoints.ids.forEach((g) => {
      if (l) return;
      const m = this.store.getGeometryCopy(g);
      this.pixelDistance.measure(i, m.coordinates) < this.pointerDistance && (l = true);
    });
    let d = false;
    if (this.selectionPoints.ids.forEach((g) => {
      const m = this.store.getGeometryCopy(g);
      this.pixelDistance.measure(i, m.coordinates) < this.pointerDistance && (l = false, d = true);
    }), l) return void this.setCursor(this.cursors.insertMidpoint);
    const { clickedFeature: f } = this.featuresAtMouseEvent.find(i, true);
    this.setCursor(this.selected.length > 0 && (f && f.id === this.selected[0] || d) ? this.cursors.pointerOver : "unset");
  }
  styleFeature(i) {
    const l = Cn({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
    if (i.properties.mode === this.mode && i.geometry.type === "Point") {
      if (i.properties.selectionPoint) return l.pointColor = this.getHexColorStylingValue(this.styles.selectionPointColor, l.pointColor, i), l.pointOutlineColor = this.getHexColorStylingValue(this.styles.selectionPointOutlineColor, l.pointOutlineColor, i), l.pointWidth = this.getNumericStylingValue(this.styles.selectionPointWidth, l.pointWidth, i), l.pointOutlineWidth = this.getNumericStylingValue(this.styles.selectionPointOutlineWidth, 2, i), l.zIndex = 30, l;
      if (i.properties.midPoint) return l.pointColor = this.getHexColorStylingValue(this.styles.midPointColor, l.pointColor, i), l.pointOutlineColor = this.getHexColorStylingValue(this.styles.midPointOutlineColor, l.pointOutlineColor, i), l.pointWidth = this.getNumericStylingValue(this.styles.midPointWidth, 4, i), l.pointOutlineWidth = this.getNumericStylingValue(this.styles.midPointOutlineWidth, 2, i), l.zIndex = 50, l;
    } else if (i.properties[cn.SELECTED]) {
      if (i.geometry.type === "Polygon") return l.polygonFillColor = this.getHexColorStylingValue(this.styles.selectedPolygonColor, l.polygonFillColor, i), l.polygonOutlineWidth = this.getNumericStylingValue(this.styles.selectedPolygonOutlineWidth, l.polygonOutlineWidth, i), l.polygonOutlineColor = this.getHexColorStylingValue(this.styles.selectedPolygonOutlineColor, l.polygonOutlineColor, i), l.polygonFillOpacity = this.getNumericStylingValue(this.styles.selectedPolygonFillOpacity, l.polygonFillOpacity, i), l.zIndex = jf, l;
      if (i.geometry.type === "LineString") return l.lineStringColor = this.getHexColorStylingValue(this.styles.selectedLineStringColor, l.lineStringColor, i), l.lineStringWidth = this.getNumericStylingValue(this.styles.selectedLineStringWidth, l.lineStringWidth, i), l.zIndex = jf, l;
      if (i.geometry.type === "Point") return l.pointWidth = this.getNumericStylingValue(this.styles.selectedPointWidth, l.pointWidth, i), l.pointColor = this.getHexColorStylingValue(this.styles.selectedPointColor, l.pointColor, i), l.pointOutlineColor = this.getHexColorStylingValue(this.styles.selectedPointOutlineColor, l.pointOutlineColor, i), l.pointOutlineWidth = this.getNumericStylingValue(this.styles.selectedPointOutlineWidth, l.pointOutlineWidth, i), l.zIndex = jf, l;
    }
    return l;
  }
  afterFeatureUpdated(i) {
    if (this.selected.length && i.id === this.selected[0]) {
      var l, d;
      const f = this.flags[i.properties.mode];
      if (f == null || (l = f.feature) == null || !l.coordinates) return;
      const g = i.geometry.type, m = i.id;
      let s;
      if (this.selectionPoints.delete(), this.midPoints.delete(), g === "Polygon") s = i.geometry.coordinates[0];
      else {
        if (g !== "LineString") return;
        s = i.geometry.coordinates;
      }
      this.selectionPoints.create(s, g, m), f != null && (d = f.feature) != null && (d = d.coordinates) != null && d.midpoints && this.midPoints.create(g === "Polygon" ? i.geometry.coordinates[0] : i.geometry.coordinates, m, this.coordinatePrecision);
    }
  }
}
class lI extends mp {
  constructor(...i) {
    super(...i), this.type = ec.Static, this.mode = "static";
  }
  start() {
  }
  stop() {
  }
  onKeyUp() {
  }
  onKeyDown() {
  }
  onClick() {
  }
  onDragStart() {
  }
  onDrag() {
  }
  onDragEnd() {
  }
  onMouseMove() {
  }
  cleanUp() {
  }
  styleFeature() {
    return Cn({}, { polygonFillColor: "#3f97e0", polygonOutlineColor: "#3f97e0", polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: "#3f97e0", pointOutlineColor: "#ffffff", pointOutlineWidth: 0, pointWidth: 6, lineStringColor: "#3f97e0", lineStringWidth: 4, zIndex: 0 });
  }
}
function m1(r, i, l, d, f) {
  for (; d > l; ) {
    if (d - l > 600) {
      const C = d - l + 1, T = i - l + 1, M = Math.log(C), z = 0.5 * Math.exp(2 * M / 3), L = 0.5 * Math.sqrt(M * z * (C - z) / C) * (T - C / 2 < 0 ? -1 : 1);
      m1(r, i, Math.max(l, Math.floor(i - T * z / C + L)), Math.min(d, Math.floor(i + (C - T) * z / C + L)), f);
    }
    const g = r[i];
    let m = l, s = d;
    for (Id(r, l, i), f(r[d], g) > 0 && Id(r, l, d); m < s; ) {
      for (Id(r, m, s), m++, s--; f(r[m], g) < 0; ) m++;
      for (; f(r[s], g) > 0; ) s--;
    }
    f(r[l], g) === 0 ? Id(r, l, s) : (s++, Id(r, s, d)), s <= i && (l = s + 1), i <= s && (d = s - 1);
  }
}
function Id(r, i, l) {
  const d = r[i];
  r[i] = r[l], r[l] = d;
}
function qu(r, i) {
  Rd(r, 0, r.children.length, i, r);
}
function Rd(r, i, l, d, f) {
  f || (f = Hu([])), f.minX = 1 / 0, f.minY = 1 / 0, f.maxX = -1 / 0, f.maxY = -1 / 0;
  for (let g = i; g < l; g++) {
    const m = r.children[g];
    Ad(f, r.leaf ? d(m) : m);
  }
  return f;
}
function Ad(r, i) {
  return r.minX = Math.min(r.minX, i.minX), r.minY = Math.min(r.minY, i.minY), r.maxX = Math.max(r.maxX, i.maxX), r.maxY = Math.max(r.maxY, i.maxY), r;
}
function uI(r, i) {
  return r.minX - i.minX;
}
function cI(r, i) {
  return r.minY - i.minY;
}
function Ym(r) {
  return (r.maxX - r.minX) * (r.maxY - r.minY);
}
function Ef(r) {
  return r.maxX - r.minX + (r.maxY - r.minY);
}
function dI(r, i) {
  const l = Math.max(r.minX, i.minX), d = Math.max(r.minY, i.minY), f = Math.min(r.maxX, i.maxX), g = Math.min(r.maxY, i.maxY);
  return Math.max(0, f - l) * Math.max(0, g - d);
}
function Km(r, i) {
  return r.minX <= i.minX && r.minY <= i.minY && i.maxX <= r.maxX && i.maxY <= r.maxY;
}
function Rf(r, i) {
  return i.minX <= r.maxX && i.minY <= r.maxY && i.maxX >= r.minX && i.maxY >= r.minY;
}
function Hu(r) {
  return { children: r, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
}
function Q_(r, i, l, d, f) {
  const g = [i, l];
  for (; g.length; ) {
    if ((l = g.pop()) - (i = g.pop()) <= d) continue;
    const m = i + Math.ceil((l - i) / d / 2) * d;
    m1(r, m, i, l, f), g.push(i, m, m, l);
  }
}
class hI {
  constructor(i) {
    this._maxEntries = void 0, this._minEntries = void 0, this.data = void 0, this._maxEntries = Math.max(4, i), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
  }
  search(i) {
    let l = this.data;
    const d = [];
    if (!Rf(i, l)) return d;
    const f = this.toBBox, g = [];
    for (; l; ) {
      for (let m = 0; m < l.children.length; m++) {
        const s = l.children[m], C = l.leaf ? f(s) : s;
        Rf(i, C) && (l.leaf ? d.push(s) : Km(i, C) ? this._all(s, d) : g.push(s));
      }
      l = g.pop();
    }
    return d;
  }
  collides(i) {
    let l = this.data;
    if (Rf(i, l)) {
      const d = [];
      for (; l; ) {
        for (let f = 0; f < l.children.length; f++) {
          const g = l.children[f], m = l.leaf ? this.toBBox(g) : g;
          if (Rf(i, m)) {
            if (l.leaf || Km(i, m)) return true;
            d.push(g);
          }
        }
        l = d.pop();
      }
    }
    return false;
  }
  load(i) {
    if (i.length < this._minEntries) {
      for (let d = 0; d < i.length; d++) this.insert(i[d]);
      return;
    }
    let l = this._build(i.slice(), 0, i.length - 1, 0);
    if (this.data.children.length) if (this.data.height === l.height) this._splitRoot(this.data, l);
    else {
      if (this.data.height < l.height) {
        const d = this.data;
        this.data = l, l = d;
      }
      this._insert(l, this.data.height - l.height - 1, true);
    }
    else this.data = l;
  }
  insert(i) {
    this._insert(i, this.data.height - 1);
  }
  clear() {
    this.data = Hu([]);
  }
  remove(i) {
    let l = this.data;
    const d = this.toBBox(i), f = [], g = [];
    let m, s, C = false;
    for (; l || f.length; ) {
      if (l || (l = f.pop(), s = f[f.length - 1], m = g.pop(), C = true), l.leaf) {
        const T = l.children.indexOf(i);
        T !== -1 && (l.children.splice(T, 1), f.push(l), this._condense(f));
      }
      C || l.leaf || !Km(l, d) ? s ? (m++, l = s.children[m], C = false) : l = null : (f.push(l), g.push(m), m = 0, s = l, l = l.children[0]);
    }
  }
  toBBox(i) {
    return i;
  }
  compareMinX(i, l) {
    return i.minX - l.minX;
  }
  compareMinY(i, l) {
    return i.minY - l.minY;
  }
  _all(i, l) {
    const d = [];
    for (; i; ) i.leaf ? l.push(...i.children) : d.push(...i.children), i = d.pop();
    return l;
  }
  _build(i, l, d, f) {
    const g = d - l + 1;
    let m, s = this._maxEntries;
    if (g <= s) return m = Hu(i.slice(l, d + 1)), qu(m, this.toBBox), m;
    f || (f = Math.ceil(Math.log(g) / Math.log(s)), s = Math.ceil(g / Math.pow(s, f - 1))), m = Hu([]), m.leaf = false, m.height = f;
    const C = Math.ceil(g / s), T = C * Math.ceil(Math.sqrt(s));
    Q_(i, l, d, T, this.compareMinX);
    for (let M = l; M <= d; M += T) {
      const z = Math.min(M + T - 1, d);
      Q_(i, M, z, C, this.compareMinY);
      for (let L = M; L <= z; L += C) {
        const A = Math.min(L + C - 1, z);
        m.children.push(this._build(i, L, A, f - 1));
      }
    }
    return qu(m, this.toBBox), m;
  }
  _chooseSubtree(i, l, d, f) {
    for (; f.push(l), !l.leaf && f.length - 1 !== d; ) {
      let s, C = 1 / 0, T = 1 / 0;
      for (let M = 0; M < l.children.length; M++) {
        const z = l.children[M], L = Ym(z), A = (g = i, m = z, (Math.max(m.maxX, g.maxX) - Math.min(m.minX, g.minX)) * (Math.max(m.maxY, g.maxY) - Math.min(m.minY, g.minY)) - L);
        A < T ? (T = A, C = L < C ? L : C, s = z) : A === T && L < C && (C = L, s = z);
      }
      l = s || l.children[0];
    }
    var g, m;
    return l;
  }
  _insert(i, l, d) {
    const f = d ? i : this.toBBox(i), g = [], m = this._chooseSubtree(f, this.data, l, g);
    for (m.children.push(i), Ad(m, f); l >= 0 && g[l].children.length > this._maxEntries; ) this._split(g, l), l--;
    this._adjustParentBBoxes(f, g, l);
  }
  _split(i, l) {
    const d = i[l], f = d.children.length, g = this._minEntries;
    this._chooseSplitAxis(d, g, f);
    const m = this._chooseSplitIndex(d, g, f), s = Hu(d.children.splice(m, d.children.length - m));
    s.height = d.height, s.leaf = d.leaf, qu(d, this.toBBox), qu(s, this.toBBox), l ? i[l - 1].children.push(s) : this._splitRoot(d, s);
  }
  _splitRoot(i, l) {
    this.data = Hu([i, l]), this.data.height = i.height + 1, this.data.leaf = false, qu(this.data, this.toBBox);
  }
  _chooseSplitIndex(i, l, d) {
    let f, g = 1 / 0, m = 1 / 0;
    for (let s = l; s <= d - l; s++) {
      const C = Rd(i, 0, s, this.toBBox), T = Rd(i, s, d, this.toBBox), M = dI(C, T), z = Ym(C) + Ym(T);
      M < g ? (g = M, f = s, m = z < m ? z : m) : M === g && z < m && (m = z, f = s);
    }
    return f || d - l;
  }
  _chooseSplitAxis(i, l, d) {
    const f = i.leaf ? this.compareMinX : uI, g = i.leaf ? this.compareMinY : cI;
    this._allDistMargin(i, l, d, f) < this._allDistMargin(i, l, d, g) && i.children.sort(f);
  }
  _allDistMargin(i, l, d, f) {
    i.children.sort(f);
    const g = this.toBBox, m = Rd(i, 0, l, g), s = Rd(i, d - l, d, g);
    let C = Ef(m) + Ef(s);
    for (let T = l; T < d - l; T++) {
      const M = i.children[T];
      Ad(m, i.leaf ? g(M) : M), C += Ef(m);
    }
    for (let T = d - l - 1; T >= l; T--) {
      const M = i.children[T];
      Ad(s, i.leaf ? g(M) : M), C += Ef(s);
    }
    return C;
  }
  _adjustParentBBoxes(i, l, d) {
    for (let f = d; f >= 0; f--) Ad(l[f], i);
  }
  _condense(i) {
    for (let l, d = i.length - 1; d >= 0; d--) i[d].children.length === 0 ? d > 0 ? (l = i[d - 1].children, l.splice(l.indexOf(i[d]), 1)) : this.clear() : qu(i[d], this.toBBox);
  }
}
class fI {
  constructor(i) {
    this.tree = void 0, this.idToNode = void 0, this.nodeToId = void 0, this.tree = new hI(i && i.maxEntries ? i.maxEntries : 9), this.idToNode = /* @__PURE__ */ new Map(), this.nodeToId = /* @__PURE__ */ new Map();
  }
  setMaps(i, l) {
    this.idToNode.set(i.id, l), this.nodeToId.set(l, i.id);
  }
  toBBox(i) {
    const l = [], d = [];
    let f;
    if (i.geometry.type === "Polygon") f = i.geometry.coordinates[0];
    else if (i.geometry.type === "LineString") f = i.geometry.coordinates;
    else {
      if (i.geometry.type !== "Point") throw new Error("Not a valid feature to turn into a bounding box");
      f = [i.geometry.coordinates];
    }
    for (let s = 0; s < f.length; s++) d.push(f[s][1]), l.push(f[s][0]);
    const g = Math.min(...d), m = Math.max(...d);
    return { minX: Math.min(...l), minY: g, maxX: Math.max(...l), maxY: m };
  }
  insert(i) {
    if (this.idToNode.get(String(i.id))) throw new Error("Feature already exists");
    const l = this.toBBox(i);
    this.setMaps(i, l), this.tree.insert(l);
  }
  load(i) {
    const l = [], d = /* @__PURE__ */ new Set();
    i.forEach((f) => {
      const g = this.toBBox(f);
      if (this.setMaps(f, g), d.has(String(f.id))) throw new Error(`Duplicate feature ID found ${f.id}`);
      d.add(String(f.id)), l.push(g);
    }), this.tree.load(l);
  }
  update(i) {
    this.remove(i.id);
    const l = this.toBBox(i);
    this.setMaps(i, l), this.tree.insert(l);
  }
  remove(i) {
    const l = this.idToNode.get(i);
    if (!l) throw new Error(`${i} not inserted into the spatial index`);
    this.tree.remove(l);
  }
  clear() {
    this.tree.clear();
  }
  search(i) {
    return this.tree.search(this.toBBox(i)).map((l) => this.nodeToId.get(l));
  }
  collides(i) {
    return this.tree.collides(this.toBBox(i));
  }
}
const pI = { getId: () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(r) {
  const i = 16 * Math.random() | 0;
  return (r == "x" ? i : 3 & i | 8).toString(16);
}), isValidId: (r) => typeof r == "string" && r.length === 36 };
class mI {
  constructor(i) {
    this.idStrategy = void 0, this.tracked = void 0, this.spatialIndex = void 0, this.store = void 0, this._onChange = () => {
    }, this.store = {}, this.spatialIndex = new fI(), this.tracked = !i || i.tracked !== false, this.idStrategy = i && i.idStrategy ? i.idStrategy : pI;
  }
  clone(i) {
    return JSON.parse(JSON.stringify(i));
  }
  getId() {
    return this.idStrategy.getId();
  }
  has(i) {
    return !!this.store[i];
  }
  load(i, l, d, f) {
    if (i.length === 0) return [];
    let g = this.clone(i);
    const m = [], s = [];
    g = g.filter((T) => {
      T.id == null && (T.id = this.idStrategy.getId());
      const M = T.id;
      if (l) {
        const z = l(T);
        if (!z.valid) return m.push({ id: M, valid: false, reason: z.reason }), false;
      }
      if (this.tracked) {
        if (T.properties.createdAt) {
          if (!V_(T.properties.createdAt)) return m.push({ id: T.id, valid: false, reason: "createdAt is not a valid numeric timestamp" }), false;
        } else T.properties.createdAt = +/* @__PURE__ */ new Date();
        if (T.properties.updatedAt) {
          if (!V_(T.properties.updatedAt)) return m.push({ id: T.id, valid: false, reason: "updatedAt is not a valid numeric timestamp" }), false;
        } else T.properties.updatedAt = +/* @__PURE__ */ new Date();
      }
      return this.has(M) ? (m.push({ id: M, valid: false, reason: `Feature already exists with this id: ${M}` }), false) : (this.store[M] = T, s.push(T), m.push({ id: M, valid: true }), true);
    }), this.spatialIndex.load(g);
    const C = s.map(({ id: T }) => T);
    return C.length > 0 && (this._onChange(C, "create", f), d && s.forEach((T) => {
      d(T);
    })), m;
  }
  search(i, l) {
    const d = this.spatialIndex.search(i).map((f) => this.store[f]);
    return this.clone(l ? d.filter(l) : d);
  }
  registerOnChange(i) {
    this._onChange = (l, d, f) => {
      i(l, d, f);
    };
  }
  getGeometryCopy(i) {
    const l = this.store[i];
    if (!l) throw new Error(`No feature with this id (${i}), can not get geometry copy`);
    return this.clone(l.geometry);
  }
  getPropertiesCopy(i) {
    const l = this.store[i];
    if (!l) throw new Error(`No feature with this id (${i}), can not get properties copy`);
    return this.clone(l.properties);
  }
  updateProperty(i, l) {
    const d = [];
    i.forEach(({ id: f, property: g, value: m }) => {
      const s = this.store[f];
      if (!s) throw new Error(`No feature with this (${f}), can not update geometry`);
      d.push(f), m === void 0 ? delete s.properties[g] : s.properties[g] = m, this.tracked && (s.properties.updatedAt = +/* @__PURE__ */ new Date());
    }), this._onChange && this._onChange(d, "update", l);
  }
  updateGeometry(i, l) {
    const d = [];
    i.forEach(({ id: f, geometry: g }) => {
      d.push(f);
      const m = this.store[f];
      if (!m) throw new Error(`No feature with this (${f}), can not update geometry`);
      m.geometry = this.clone(g), this.spatialIndex.update(m), this.tracked && (m.properties.updatedAt = +/* @__PURE__ */ new Date());
    }), this._onChange && this._onChange(d, "update", l);
  }
  create(i, l) {
    const d = [];
    return i.forEach(({ geometry: f, properties: g }) => {
      let m, s = Cn({}, g);
      this.tracked && (m = +/* @__PURE__ */ new Date(), g ? (s.createdAt = typeof g.createdAt == "number" ? g.createdAt : m, s.updatedAt = typeof g.updatedAt == "number" ? g.updatedAt : m) : s = { createdAt: m, updatedAt: m });
      const C = this.getId(), T = { id: C, type: "Feature", geometry: f, properties: s };
      this.store[C] = T, this.spatialIndex.insert(T), d.push(C);
    }), this._onChange && this._onChange([...d], "create", l), d;
  }
  delete(i, l) {
    i.forEach((d) => {
      if (!this.store[d]) throw new Error(`No feature with id ${d}, can not delete`);
      delete this.store[d], this.spatialIndex.remove(d);
    }), this._onChange && this._onChange([...i], "delete", l);
  }
  copy(i) {
    return this.clone(this.store[i]);
  }
  copyAll() {
    return this.clone(Object.keys(this.store).map((i) => this.store[i]));
  }
  copyAllWhere(i) {
    return this.clone(Object.keys(this.store).map((l) => this.store[l]).filter((l) => l.properties && i(l.properties)));
  }
  clear() {
    this.store = {}, this.spatialIndex.clear();
  }
  size() {
    return Object.keys(this.store).length;
  }
}
class Gu {
  constructor({ name: i, callback: l, unregister: d, register: f }) {
    this.name = void 0, this.callback = void 0, this.registered = false, this.register = void 0, this.unregister = void 0, this.name = i, this.register = () => {
      this.registered || (this.registered = true, f(l));
    }, this.unregister = () => {
      this.register && (this.registered = false, d(l));
    }, this.callback = l;
  }
}
var gI = { __proto__: null, TerraDrawBaseAdapter: class {
  constructor(r) {
    this._nextKeyUpIsContextMenu = false, this._minPixelDragDistance = void 0, this._minPixelDragDistanceDrawing = void 0, this._minPixelDragDistanceSelecting = void 0, this._lastDrawEvent = void 0, this._coordinatePrecision = void 0, this._heldKeys = /* @__PURE__ */ new Set(), this._listeners = [], this._dragState = "not-dragging", this._currentModeCallbacks = void 0, this._minPixelDragDistance = typeof r.minPixelDragDistance == "number" ? r.minPixelDragDistance : 1, this._minPixelDragDistanceSelecting = typeof r.minPixelDragDistanceSelecting == "number" ? r.minPixelDragDistanceSelecting : 1, this._minPixelDragDistanceDrawing = typeof r.minPixelDragDistanceDrawing == "number" ? r.minPixelDragDistanceDrawing : 8, this._coordinatePrecision = typeof r.coordinatePrecision == "number" ? r.coordinatePrecision : 9;
  }
  getButton(r) {
    return r.button === -1 ? "neither" : r.button === 0 ? "left" : r.button === 1 ? "middle" : r.button === 2 ? "right" : "neither";
  }
  getMapElementXYPosition(r) {
    const i = this.getMapEventElement(), { left: l, top: d } = i.getBoundingClientRect();
    return { containerX: r.clientX - l, containerY: r.clientY - d };
  }
  getDrawEventFromEvent(r, i = false) {
    const l = this.getLngLatFromEvent(r);
    if (!l) return null;
    const { lng: d, lat: f } = l, { containerX: g, containerY: m } = this.getMapElementXYPosition(r), s = this.getButton(r), C = Array.from(this._heldKeys);
    return { lng: zi(d, this._coordinatePrecision), lat: zi(f, this._coordinatePrecision), containerX: g, containerY: m, button: s, heldKeys: C, isContextMenu: i };
  }
  register(r) {
    this._currentModeCallbacks = r, this._listeners = this.getAdapterListeners(), this._listeners.forEach((i) => {
      i.register();
    });
  }
  getCoordinatePrecision() {
    return this._coordinatePrecision;
  }
  getAdapterListeners() {
    return [new Gu({ name: "pointerdown", callback: (r) => {
      if (!this._currentModeCallbacks || !r.isPrimary) return;
      const i = this.getDrawEventFromEvent(r);
      i && (this._dragState = "pre-dragging", this._lastDrawEvent = i);
    }, register: (r) => {
      this.getMapEventElement().addEventListener("pointerdown", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("pointerdown", r);
    } }), new Gu({ name: "pointermove", callback: (r) => {
      if (!this._currentModeCallbacks || !r.isPrimary) return;
      r.preventDefault();
      const i = this.getDrawEventFromEvent(r);
      if (i) if (this._dragState === "not-dragging") this._currentModeCallbacks.onMouseMove(i), this._lastDrawEvent = i;
      else if (this._dragState === "pre-dragging") {
        if (!this._lastDrawEvent) return;
        const l = { x: this._lastDrawEvent.containerX, y: this._lastDrawEvent.containerY }, d = { x: i.containerX, y: i.containerY }, f = this._currentModeCallbacks.getState(), g = pa(l, d);
        let m = false;
        if (m = f === "drawing" ? g < this._minPixelDragDistanceDrawing : f === "selecting" ? g < this._minPixelDragDistanceSelecting : g < this._minPixelDragDistance, m) return;
        this._nextKeyUpIsContextMenu = false, this._dragState = "dragging", this._currentModeCallbacks.onDragStart(i, (s) => {
          this.setDraggability.bind(this)(s);
        });
      } else this._dragState === "dragging" && this._currentModeCallbacks.onDrag(i, (l) => {
        this.setDraggability.bind(this)(l);
      });
    }, register: (r) => {
      this.getMapEventElement().addEventListener("pointermove", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("pointermove", r);
    } }), new Gu({ name: "contextmenu", callback: (r) => {
      this._currentModeCallbacks && (r.preventDefault(), this._nextKeyUpIsContextMenu = true);
    }, register: (r) => {
      this.getMapEventElement().addEventListener("contextmenu", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("contextmenu", r);
    } }), new Gu({ name: "pointerup", callback: (r) => {
      if (!this._currentModeCallbacks || r.target !== this.getMapEventElement() || !r.isPrimary) return;
      const i = this.getDrawEventFromEvent(r);
      i && (this._dragState === "dragging" ? this._currentModeCallbacks.onDragEnd(i, (l) => {
        this.setDraggability.bind(this)(l);
      }) : this._dragState !== "not-dragging" && this._dragState !== "pre-dragging" || (this._nextKeyUpIsContextMenu && (i.isContextMenu = true, this._nextKeyUpIsContextMenu = false), this._currentModeCallbacks.onClick(i)), this._dragState = "not-dragging", this.setDraggability(true));
    }, register: (r) => {
      this.getMapEventElement().addEventListener("pointerup", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("pointerup", r);
    } }), new Gu({ name: "keyup", callback: (r) => {
      this._currentModeCallbacks && (this._heldKeys.delete(r.key), this._currentModeCallbacks.onKeyUp({ key: r.key, heldKeys: Array.from(this._heldKeys), preventDefault: () => r.preventDefault() }));
    }, register: (r) => {
      this.getMapEventElement().addEventListener("keyup", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("keyup", r);
    } }), new Gu({ name: "keydown", callback: (r) => {
      this._currentModeCallbacks && (this._heldKeys.add(r.key), this._currentModeCallbacks.onKeyDown({ key: r.key, heldKeys: Array.from(this._heldKeys), preventDefault: () => r.preventDefault() }));
    }, register: (r) => {
      this.getMapEventElement().addEventListener("keydown", r);
    }, unregister: (r) => {
      this.getMapEventElement().removeEventListener("keydown", r);
    } })];
  }
  unregister() {
    this._listeners.forEach((r) => {
      r.unregister();
    }), this.clear(), this._currentModeCallbacks = void 0;
  }
} };
function zg(r) {
  if (r === null || typeof r == "boolean" || typeof r == "string") return true;
  if (r === void 0) return false;
  if (typeof r == "number") return Number.isFinite(r);
  if (typeof r == "bigint" || typeof r == "symbol" || typeof r == "function" || r instanceof RegExp || r instanceof Map || r instanceof Set || r instanceof Date) return false;
  if (typeof r == "object" && r !== null && !Array.isArray(r)) {
    const i = Object.getPrototypeOf(r);
    if (i !== Object.prototype && i !== null) return false;
  }
  if (ArrayBuffer.isView(r) && !(r instanceof DataView)) return false;
  if (Array.isArray(r)) {
    for (const i of r) if (!zg(i)) return false;
  }
  return typeof r == "object" && Object.keys(r).every((i) => typeof i == "string" && zg(r[i]));
}
class vI {
  constructor(i) {
    this._modes = void 0, this._mode = void 0, this._adapter = void 0, this._enabled = false, this._store = void 0, this._eventListeners = void 0, this._instanceSelectMode = void 0, this._adapter = i.adapter, this._mode = new lI();
    const l = /* @__PURE__ */ new Set(), d = i.modes.reduce((M, z) => {
      if (l.has(z.mode)) throw new Error(`There is already a ${z.mode} mode provided`);
      return l.add(z.mode), M[z.mode] = z, M;
    }, {}), f = Object.keys(d);
    if (f.length === 0) throw new Error("No modes provided");
    f.forEach((M) => {
      if (d[M].type === ec.Select) {
        if (this._instanceSelectMode) throw new Error("only one type of select mode can be provided");
        this._instanceSelectMode = M;
      }
    }), this._modes = Cn({}, d, { static: this._mode }), this._eventListeners = { change: [], select: [], deselect: [], finish: [], ready: [] }, this._store = new mI({ tracked: !!i.tracked, idStrategy: i.idStrategy ? i.idStrategy : void 0 });
    const g = (M) => {
      const z = [], L = this._store.copyAll().filter((A) => !M.includes(A.id) || (z.push(A), false));
      return { changed: z, unchanged: L };
    }, m = (M, z) => {
      this._enabled && this._eventListeners.finish.forEach((L) => {
        L(M, z);
      });
    }, s = (M, z, L) => {
      if (!this._enabled) return;
      this._eventListeners.change.forEach((V) => {
        V(M, z, L);
      });
      const { changed: A, unchanged: O } = g(M);
      z === "create" ? this._adapter.render({ created: A, deletedIds: [], unchanged: O, updated: [] }, this.getModeStyles()) : z === "update" ? this._adapter.render({ created: [], deletedIds: [], unchanged: O, updated: A }, this.getModeStyles()) : z === "delete" ? this._adapter.render({ created: [], deletedIds: M, unchanged: O, updated: [] }, this.getModeStyles()) : z === "styling" && this._adapter.render({ created: [], deletedIds: [], unchanged: O, updated: [] }, this.getModeStyles());
    }, C = (M) => {
      if (!this._enabled) return;
      this._eventListeners.select.forEach((A) => {
        A(M);
      });
      const { changed: z, unchanged: L } = g([M]);
      this._adapter.render({ created: [], deletedIds: [], unchanged: L, updated: z }, this.getModeStyles());
    }, T = (M) => {
      if (!this._enabled) return;
      this._eventListeners.deselect.forEach((A) => {
        A();
      });
      const { changed: z, unchanged: L } = g([M]);
      z && this._adapter.render({ created: [], deletedIds: [], unchanged: L, updated: z }, this.getModeStyles());
    };
    Object.keys(this._modes).forEach((M) => {
      this._modes[M].register({ mode: M, store: this._store, setCursor: this._adapter.setCursor.bind(this._adapter), project: this._adapter.project.bind(this._adapter), unproject: this._adapter.unproject.bind(this._adapter), setDoubleClickToZoom: this._adapter.setDoubleClickToZoom.bind(this._adapter), onChange: s, onSelect: C, onDeselect: T, onFinish: m, coordinatePrecision: this._adapter.getCoordinatePrecision() });
    });
  }
  checkEnabled() {
    if (!this._enabled) throw new Error("Terra Draw is not enabled");
  }
  getModeStyles() {
    const i = {};
    return Object.keys(this._modes).forEach((l) => {
      i[l] = (d) => this._instanceSelectMode && d.properties[cn.SELECTED] ? this._modes[this._instanceSelectMode].styleFeature.bind(this._modes[this._instanceSelectMode])(d) : this._modes[l].styleFeature.bind(this._modes[l])(d);
    }), i;
  }
  featuresAtLocation({ lng: i, lat: l }, d) {
    const f = d && d.pointerDistance !== void 0 ? d.pointerDistance : 30, g = !d || d.ignoreSelectFeatures === void 0 || d.ignoreSelectFeatures, m = !(!d || d.ignoreCoordinatePoints === void 0) && d.ignoreCoordinatePoints, s = !(!d || d.ignoreCurrentlyDrawing === void 0) && d.ignoreCurrentlyDrawing, C = !(!d || d.ignoreClosingPoints === void 0) && d.ignoreClosingPoints, T = this._adapter.unproject.bind(this._adapter), M = this._adapter.project.bind(this._adapter), z = M(i, l), L = u1({ unproject: T, point: z, pointerDistance: f });
    return this._store.search(L).filter((A) => {
      if (g && (A.properties[cn.MID_POINT] || A.properties[cn.SELECTION_POINT]) || m && A.properties[Di.COORDINATE_POINT] || C && A.properties[Di.CLOSING_POINT] || s && A.properties[Di.CURRENTLY_DRAWING]) return false;
      if (A.geometry.type === "Point") {
        const O = A.geometry.coordinates, V = M(O[0], O[1]);
        return pa(z, V) < f;
      }
      if (A.geometry.type === "LineString") {
        const O = A.geometry.coordinates;
        for (let V = 0; V < O.length - 1; V++) {
          const X = O[V], W = O[V + 1];
          if (Ag(z, M(X[0], X[1]), M(W[0], W[1])) < f) return true;
        }
        return false;
      }
      if (h1([i, l], A.geometry.coordinates)) return true;
      if (d != null && d.includePolygonsWithinPointerDistance) {
        const O = A.geometry.coordinates;
        for (const V of O) for (let X = 0; X < V.length - 1; X++) {
          const W = V[X], K = V[X + 1], ie = M(W[0], W[1]), ee = M(K[0], K[1]);
          if (Ag(z, ie, ee) < f) return true;
        }
      }
      return false;
    }).map((A) => {
      if (d == null || !d.addClosestCoordinateInfoToProperties) return A;
      let O;
      if (A.geometry.type === "Polygon") O = A.geometry.coordinates[0], O.pop();
      else {
        if (A.geometry.type !== "LineString") return A;
        O = A.geometry.coordinates;
      }
      let V, X = -1, W = 1 / 0;
      for (let K = 0; K < O.length; K++) {
        const ie = O[K], ee = pa(M(ie[0], ie[1]), z);
        ee < W && (X = K, W = ee, V = ie);
      }
      return A.properties.closestCoordinateIndexToEvent = X, A.properties.closestCoordinatePixelDistanceToEvent = W, A.properties.closestCoordinateDistanceKmToEvent = Qa(V, [i, l]), A;
    });
  }
  getSelectModeOrThrow() {
    const i = this.getSelectMode({ switchToSelectMode: true });
    if (!i) throw new Error("No select mode defined in instance");
    return i;
  }
  getSelectMode({ switchToSelectMode: i }) {
    if (this.checkEnabled(), !this._instanceSelectMode) return null;
    const l = this.getMode();
    return i && l !== this._instanceSelectMode && this.setMode(this._instanceSelectMode), this._modes[this._instanceSelectMode];
  }
  isGuidanceFeature(i) {
    return !!(i.properties[cn.MID_POINT] || i.properties[cn.SELECTION_POINT] || i.properties[Di.COORDINATE_POINT] || i.properties[Di.SNAPPING_POINT]);
  }
  setModeStyles(i, l) {
    if (this.checkEnabled(), !this._modes[i]) throw new Error("No mode with this name present");
    this._modes[i].styles = l;
  }
  updateModeOptions(i, l) {
    if (this.checkEnabled(), !this._modes[i]) throw new Error("No mode with this name present");
    this._modes[i].updateOptions(l);
  }
  getSnapshot() {
    return this._store.copyAll();
  }
  getSnapshotFeature(i) {
    if (this._store.has(i)) return this._store.copy(i);
  }
  clear() {
    this.checkEnabled(), this._adapter.clear();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(i) {
    throw new Error("Enabled is read only");
  }
  getMode() {
    return this._mode.mode;
  }
  getModeState() {
    return this._mode.state;
  }
  setMode(i) {
    if (this.checkEnabled(), !this._modes[i]) throw new Error("No mode with this name present");
    this._mode.stop(), this._mode = this._modes[i], this._mode.start();
  }
  removeFeatures(i) {
    this.checkEnabled();
    const l = [];
    i.forEach((d) => {
      if (!this._store.has(d)) throw new Error(`No feature with id ${d}, can not delete`);
      const f = this._store.copy(d);
      f.properties[cn.SELECTED] && this.deselectFeature(d), f.properties[Di.COORDINATE_POINT_IDS] && l.push(...f.properties[Di.COORDINATE_POINT_IDS]);
    }), this._store.delete([...i, ...l], { origin: "api" });
  }
  selectFeature(i) {
    this.getSelectModeOrThrow().selectFeature(i);
  }
  deselectFeature(i) {
    this.getSelectModeOrThrow().deselectFeature(i);
  }
  getFeatureId() {
    return this._store.getId();
  }
  hasFeature(i) {
    return this._store.has(i);
  }
  checkIsReservedProperty(i) {
    return ![...Object.values(cn), ...Object.values(Di)].includes(i);
  }
  updateFeatureProperties(i, l) {
    if (!this._store.has(i)) throw new Error(`No feature with id ${i} present in store`);
    const d = this._store.copy(i);
    if (this.isGuidanceFeature(d)) throw new Error("Guidance features are not allowed to be updated directly.");
    const f = d.properties.mode;
    if (!this._modes[f]) throw new Error(`No mode with name ${f} present in instance`);
    const g = Object.entries(l);
    g.forEach(([m, s]) => {
      if (!this.checkIsReservedProperty(m)) throw new Error(`You are trying to update a reserved property name: ${m}. Please choose another name.`);
      if (s !== void 0 && !zg(s)) throw new Error(`Invalid JSON value provided for property ${m}`);
    }), this._store.updateProperty(g.map(([m, s]) => ({ id: d.id, property: m, value: s })), { origin: "api" });
  }
  updateFeatureGeometry(i, l) {
    if (!this._store.has(i)) throw new Error(`No feature with id ${i} present in store`);
    const d = this._store.copy(i);
    if (this.isGuidanceFeature(d)) throw new Error("Guidance features are not allowed to be updated directly.");
    if (!(d && l && l.type && l.coordinates)) throw new Error("Invalid geometry provided");
    if (l.type !== d.geometry.type) throw new Error(`Geometry type mismatch: expected ${d.geometry.type}, got ${l.type}`);
    const f = d.properties.mode, g = this._modes[f];
    if (!g) throw new Error(`No mode with name ${f} present in instance`);
    const m = Cn({}, d, { geometry: l }), s = g.validateFeature(m);
    if (!s.valid) throw new Error(`Feature validation failed: ${s.reason || "Unknown reason"}`);
    if (this._store.updateGeometry([{ id: d.id, geometry: l }], { origin: "api" }), g.afterFeatureUpdated) {
      g.afterFeatureUpdated(m);
      const C = m.properties[cn.SELECTED], T = this.getSelectMode({ switchToSelectMode: false });
      T && C && T.afterFeatureUpdated(m);
    }
  }
  transformFeatureGeometry(i, l) {
    if (!this._store.has(i)) throw new Error(`No feature with id ${i} present in store`);
    let d = this._store.copy(i);
    if (this.isGuidanceFeature(d)) throw new Error("Guidance features are not allowed to be updated directly.");
    const f = d.properties.mode, g = this._modes[f];
    if (!g) throw new Error(`No mode with name ${f} present in instance`);
    let m;
    if (d.geometry.type === "Polygon") m = d.geometry.coordinates[0];
    else {
      if (d.geometry.type !== "LineString") throw new Error(`Feature geometry type ${d.geometry.type} is not supported for transformation`);
      m = d.geometry.coordinates;
    }
    if (l.projection != "web-mercator") throw new Error(`Projection ${l.projection} is not currently supported for transformation`);
    if (l.type === "scale") {
      const { x: s, y: C } = Ai(l.origin[0], l.origin[1]);
      p1({ coordinates: m, originX: s, originY: C, xScale: l.options.xScale || 1, yScale: l.options.yScale || 1 });
    } else l.type === "rotate" && (d = f1(d, l.options.angle || 0), m = d.geometry.type === "Polygon" ? d.geometry.coordinates[0] : d.geometry.coordinates);
    if (m = m.map((s) => [zi(s[0], this._adapter.getCoordinatePrecision()), zi(s[1], this._adapter.getCoordinatePrecision())]), d.geometry.coordinates = d.geometry.type === "Polygon" ? [m] : m, this._store.updateGeometry([{ id: d.id, geometry: d.geometry }], { origin: "api" }), g.afterFeatureUpdated) {
      g.afterFeatureUpdated(d);
      const s = d.properties[cn.SELECTED], C = this.getSelectMode({ switchToSelectMode: false });
      C && s && C.afterFeatureUpdated(d);
    }
  }
  addFeatures(i) {
    return this.checkEnabled(), i.length === 0 ? [] : this._store.load(i, (l) => {
      if (N_(l)) {
        const d = l.properties.mode, f = this._modes[d];
        if (!f) return { id: l.id, valid: false, reason: `${d} mode is not in the list of instantiated modes` };
        const g = f.validateFeature.bind(f)(l);
        return { id: l.id, valid: g.valid, reason: g.reason ? g.reason : g.valid ? void 0 : "Feature is invalid" };
      }
      return { id: l.id, valid: false, reason: "Mode property does not exist" };
    }, (l) => {
      if (N_(l)) {
        const d = this._modes[l.properties.mode];
        d && d.afterFeatureAdded && d.afterFeatureAdded(l);
      }
    }, { origin: "api" });
  }
  start() {
    this._enabled || (this._enabled = true, this._adapter.register({ onReady: () => {
      this._eventListeners.ready.forEach((i) => {
        i();
      });
    }, getState: () => this._mode.state, onClick: (i) => {
      this._mode.onClick(i);
    }, onMouseMove: (i) => {
      this._mode.onMouseMove(i);
    }, onKeyDown: (i) => {
      this._mode.onKeyDown(i);
    }, onKeyUp: (i) => {
      this._mode.onKeyUp(i);
    }, onDragStart: (i, l) => {
      this._mode.onDragStart(i, l);
    }, onDrag: (i, l) => {
      this._mode.onDrag(i, l);
    }, onDragEnd: (i, l) => {
      this._mode.onDragEnd(i, l);
    }, onClear: () => {
      this._mode.cleanUp(), this._store.clear();
    } }));
  }
  getFeaturesAtLngLat(i, l) {
    const { lng: d, lat: f } = i;
    return this.featuresAtLocation({ lng: d, lat: f }, l);
  }
  getFeaturesAtPointerEvent(i, l) {
    const d = this._adapter.getLngLatFromEvent.bind(this._adapter)(i);
    return d === null ? [] : this.featuresAtLocation(d, l);
  }
  stop() {
    this._enabled && (this._enabled = false, this._adapter.unregister());
  }
  on(i, l) {
    const d = this._eventListeners[i];
    d.includes(l) || d.push(l);
  }
  off(i, l) {
    const d = this._eventListeners[i];
    d.includes(l) && d.splice(d.indexOf(l), 1);
  }
}
class _I extends gI.TerraDrawBaseAdapter {
  constructor(i) {
    super(i), this._renderBeforeLayerId = void 0, this._prefixId = void 0, this._initialDragPan = void 0, this._initialDragRotate = void 0, this._nextRender = void 0, this._map = void 0, this._container = void 0, this.changedIds = { deletion: false, points: false, linestrings: false, polygons: false, styling: false }, this._map = i.map, this._container = this._map.getContainer(), this._initialDragRotate = this._map.dragRotate.isEnabled(), this._initialDragPan = this._map.dragPan.isEnabled(), this._renderBeforeLayerId = i.renderBelowLayerId, this._prefixId = i.prefixId || "td";
  }
  _addGeoJSONSource(i, l) {
    this._map.addSource(i, { type: "geojson", data: { type: "FeatureCollection", features: l }, tolerance: 0 });
  }
  _addFillLayer(i) {
    return this._map.addLayer({ id: i, source: i, type: "fill", layout: { "fill-sort-key": ["get", "zIndex"] }, paint: { "fill-color": ["get", "polygonFillColor"], "fill-opacity": ["get", "polygonFillOpacity"] } });
  }
  _addFillOutlineLayer(i) {
    return this._map.addLayer({ id: i + "-outline", source: i, type: "line", layout: { "line-sort-key": ["get", "zIndex"] }, paint: { "line-width": ["get", "polygonOutlineWidth"], "line-color": ["get", "polygonOutlineColor"] } });
  }
  _addLineLayer(i) {
    return this._map.addLayer({ id: i, source: i, type: "line", layout: { "line-sort-key": ["get", "zIndex"] }, paint: { "line-width": ["get", "lineStringWidth"], "line-color": ["get", "lineStringColor"] } });
  }
  _addPointLayer(i) {
    return this._map.addLayer({ id: i, source: i, type: "circle", layout: { "circle-sort-key": ["get", "zIndex"] }, paint: { "circle-stroke-color": ["get", "pointOutlineColor"], "circle-stroke-width": ["get", "pointOutlineWidth"], "circle-radius": ["get", "pointWidth"], "circle-color": ["get", "pointColor"] } });
  }
  _addLayer(i, l) {
    l === "Point" && this._addPointLayer(i), l === "LineString" && this._addLineLayer(i), l === "Polygon" && (this._addFillLayer(i), this._addFillOutlineLayer(i));
  }
  _addGeoJSONLayer(i, l) {
    const d = `${this._prefixId}-${i.toLowerCase()}`;
    return this._addGeoJSONSource(d, l), this._addLayer(d, i), d;
  }
  _setGeoJSONLayerData(i, l) {
    const d = `${this._prefixId}-${i.toLowerCase()}`;
    return this._map.getSource(d).setData({ type: "FeatureCollection", features: l }), d;
  }
  updateChangedIds(i) {
    [...i.updated, ...i.created].forEach((l) => {
      l.geometry.type === "Point" ? this.changedIds.points = true : l.geometry.type === "LineString" ? this.changedIds.linestrings = true : l.geometry.type === "Polygon" && (this.changedIds.polygons = true);
    }), i.deletedIds.length > 0 && (this.changedIds.deletion = true), i.created.length === 0 && i.updated.length === 0 && i.deletedIds.length === 0 && (this.changedIds.styling = true);
  }
  getLngLatFromEvent(i) {
    const { left: l, top: d } = this._container.getBoundingClientRect();
    return this.unproject(i.clientX - l, i.clientY - d);
  }
  getMapEventElement() {
    return this._map.getCanvas();
  }
  setDraggability(i) {
    i ? (this._initialDragRotate && this._map.dragRotate.enable(), this._initialDragPan && this._map.dragPan.enable()) : (this._initialDragRotate && this._map.dragRotate.disable(), this._initialDragPan && this._map.dragPan.disable());
  }
  project(i, l) {
    const { x: d, y: f } = this._map.project({ lng: i, lat: l });
    return { x: d, y: f };
  }
  unproject(i, l) {
    const { lng: d, lat: f } = this._map.unproject({ x: i, y: l });
    return { lng: d, lat: f };
  }
  setCursor(i) {
    const l = this._map.getCanvas();
    i === "unset" ? l.style.removeProperty("cursor") : l.style.cursor = i;
  }
  setDoubleClickToZoom(i) {
    i ? this._map.doubleClickZoom.enable() : this._map.doubleClickZoom.disable();
  }
  render(i, l) {
    this.updateChangedIds(i), this._nextRender && cancelAnimationFrame(this._nextRender), this._nextRender = requestAnimationFrame(() => {
      if (!this._currentModeCallbacks) return;
      const d = [...i.created, ...i.updated, ...i.unchanged], f = [], g = [], m = [];
      for (let M = 0; M < d.length; M++) {
        const z = d[M], { properties: L } = z, A = l[L.mode](z);
        z.geometry.type === "Point" ? (L.pointColor = A.pointColor, L.pointOutlineColor = A.pointOutlineColor, L.pointOutlineWidth = A.pointOutlineWidth, L.pointWidth = A.pointWidth, L.zIndex = A.zIndex, f.push(z)) : z.geometry.type === "LineString" ? (L.lineStringColor = A.lineStringColor, L.lineStringWidth = A.lineStringWidth, g.push(z)) : z.geometry.type === "Polygon" && (L.polygonFillColor = A.polygonFillColor, L.polygonFillOpacity = A.polygonFillOpacity, L.polygonOutlineColor = A.polygonOutlineColor, L.polygonOutlineWidth = A.polygonOutlineWidth, m.push(z));
      }
      const s = this.changedIds.deletion || this.changedIds.styling, C = s || this.changedIds.linestrings, T = s || this.changedIds.polygons;
      (s || this.changedIds.points) && this._setGeoJSONLayerData("Point", f), C && this._setGeoJSONLayerData("LineString", g), T && this._setGeoJSONLayerData("Polygon", m), this.changedIds = { points: false, linestrings: false, polygons: false, deletion: false, styling: false };
    });
  }
  clear() {
    this._currentModeCallbacks && (this._currentModeCallbacks.onClear(), this._nextRender && (cancelAnimationFrame(this._nextRender), this._nextRender = void 0), this._setGeoJSONLayerData("Point", []), this._setGeoJSONLayerData("LineString", []), this._setGeoJSONLayerData("Polygon", []));
  }
  getCoordinatePrecision() {
    return super.getCoordinatePrecision();
  }
  unregister() {
    super.unregister(), this.changedIds = { points: false, linestrings: false, polygons: false, deletion: false, styling: false }, this._map.removeLayer(`${this._prefixId}-point`), this._map.removeSource(`${this._prefixId}-point`), this._map.removeLayer(`${this._prefixId}-linestring`), this._map.removeSource(`${this._prefixId}-linestring`), this._map.removeLayer(`${this._prefixId}-polygon`), this._map.removeLayer(`${this._prefixId}-polygon-outline`), this._map.removeSource(`${this._prefixId}-polygon`);
  }
  register(i) {
    var l;
    super.register(i);
    const d = this._addGeoJSONLayer("Polygon", []), f = this._addGeoJSONLayer("LineString", []), g = this._addGeoJSONLayer("Point", []);
    this._renderBeforeLayerId && (this._map.moveLayer(g, this._renderBeforeLayerId), this._map.moveLayer(f, g), this._map.moveLayer(d + "-outline", f), this._map.moveLayer(d, f)), (l = this._currentModeCallbacks) != null && l.onReady && this._currentModeCallbacks.onReady();
  }
}
const xn = [];
for (let r = 0; r < 256; ++r) xn.push((r + 256).toString(16).slice(1));
function yI(r, i = 0) {
  return (xn[r[i + 0]] + xn[r[i + 1]] + xn[r[i + 2]] + xn[r[i + 3]] + "-" + xn[r[i + 4]] + xn[r[i + 5]] + "-" + xn[r[i + 6]] + xn[r[i + 7]] + "-" + xn[r[i + 8]] + xn[r[i + 9]] + "-" + xn[r[i + 10]] + xn[r[i + 11]] + xn[r[i + 12]] + xn[r[i + 13]] + xn[r[i + 14]] + xn[r[i + 15]]).toLowerCase();
}
let Jm;
const bI = new Uint8Array(16);
function xI() {
  if (!Jm) {
    if (typeof crypto > "u" || !crypto.getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Jm = crypto.getRandomValues.bind(crypto);
  }
  return Jm(bI);
}
const wI = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), ey = { randomUUID: wI };
function Bd(r, i, l) {
  var _a3;
  if (ey.randomUUID && !r) return ey.randomUUID();
  r = r || {};
  const d = r.random ?? ((_a3 = r.rng) == null ? void 0 : _a3.call(r)) ?? xI();
  if (d.length < 16) throw new Error("Random bytes length must be >= 16");
  return d[6] = d[6] & 15 | 64, d[8] = d[8] & 63 | 128, yI(d);
}
function Wo() {
  return { name: "Untitled", description: "A new geographic item", creation_timestamp: Date.now(), modification_timestamp: Date.now(), created_by: "anonymous", modified_by: "anonymous", tags: [] };
}
function CI() {
  return { ...Wo(), version: 1, signature: void 0 };
}
class Pl {
  constructor(i = Bd(), l, d, f) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "routes");
    __publicField(this, "drafts");
    this.id = i, this.routes = l || { id: Bd(), meta: Wo(), routes: [] }, this.drafts = d || { id: Bd(), meta: Wo(), drafts: [] }, this.meta = { ...CI(), ...f };
  }
  toStorage() {
    return { id: this.id, meta: this.meta, routes: this.routes, drafts: this.drafts };
  }
  static fromStorage(i) {
    return new Pl(i.id, i.routes, i.drafts, i.meta);
  }
  clone() {
    return Pl.fromStorage(this.toStorage());
  }
  updateName(i) {
    this.meta.name = i, this.meta.modification_timestamp = Date.now();
  }
  updateDescription(i) {
    this.meta.description = i, this.meta.modification_timestamp = Date.now();
  }
  addTag(i) {
    this.meta.tags.includes(i) || (this.meta.tags.push(i), this.meta.modification_timestamp = Date.now());
  }
  removeTag(i) {
    const l = this.meta.tags.indexOf(i);
    l > -1 && (this.meta.tags.splice(l, 1), this.meta.modification_timestamp = Date.now());
  }
}
class SI {
  constructor(i = [], l = Bd(), d = Wo()) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "routesInternal");
    this.id = l, this.meta = d || Wo(), this.routesInternal = i;
  }
  get name() {
    return this.meta || (this.meta = Wo()), this.meta.name;
  }
  set name(i) {
    this.meta || (this.meta = Wo()), this.meta.name = i;
  }
  get routes() {
    return Ga(this.routesInternal);
  }
  set routes(i) {
    this.routesInternal = Ga(i);
  }
  findRoute(i) {
    return this.routesInternal.find((l) => l.id === i);
  }
  existRoute(i) {
    return this.routesInternal.some((l) => l.id === i);
  }
  addRoute(i) {
    if (this.existRoute(i.id)) throw new Error(`[CartoSketch.Route] Route ${i.id} already exist`);
    this.routesInternal.push(Ga(i)), this.updateModificationTime();
  }
  updateRoute(i) {
    const l = this.routesInternal.findIndex((d) => d.id === i.id);
    if (l === -1) throw new Error(`[CartoSketch.Route] Route ${i.id} not found`);
    this.routesInternal[l] = Ga(i), this.updateModificationTime();
  }
  removeRoute(i) {
    const l = this.routesInternal.findIndex((d) => d.id === i);
    l !== -1 && (this.routesInternal.splice(l, 1), this.updateModificationTime());
  }
  updateModificationTime() {
    this.meta.modification_timestamp = Date.now();
  }
  exportAsGeoJSON() {
    return { type: "FeatureCollection", features: this.routesInternal.map((i) => i.exportAsGeoJSON()), properties: this.meta };
  }
  exportToStorage() {
    return Object.freeze({ id: this.id, meta: this.meta, routes: this.routesInternal.map((i) => i.exportToStorage()) });
  }
}
class Qm {
  constructor(i = Bd(), l = [], d = {}, f) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "properties");
    __publicField(this, "points");
    this.id = i, this.meta = { ...Wo(), record_timespan: 0, ...f }, this.properties = d, this.points = l;
  }
  get name() {
    return this.meta || (this.meta = Wo()), this.meta.name;
  }
  set name(i) {
    this.meta || (this.meta = Wo()), this.meta.name = i;
  }
  get distance() {
    return this.meta.distance || 0;
  }
  set distance(i) {
    this.meta.distance = i;
  }
  get recordTimespan() {
    return this.meta.record_timespan || 0;
  }
  set recordTimespan(i) {
    this.meta.record_timespan = i;
  }
  setPoints(i) {
    this.points = Ga(i), this.updateModificationTime();
  }
  appendPoint(i) {
    this.points.push(Ga(i)), this.updateModificationTime();
  }
  getPoints() {
    return Ga(this.points);
  }
  setProperties(i) {
    const l = Ga(i);
    Object.assign(this.properties, l), this.updateModificationTime();
  }
  updateModificationTime() {
    this.meta.modification_timestamp = Date.now();
  }
  exportAsGeoJSON() {
    return { type: "Feature", properties: { ...this.properties, ...this.meta, description: JSON.stringify({ name: this.meta.name, id: this.id }) }, geometry: { type: "LineString", coordinates: this.points.map((i) => [i.longitude, i.latitude]) } };
  }
  exportToStorage() {
    return Ga({ id: this.id, meta: this.meta, properties: this.properties, points: this.points });
  }
}
var si = ((r) => (r.MIGRATION_FAILED = "MIGRATION_FAILED", r.INVALID_VERSION = "INVALID_VERSION", r.UNSUPPORTED_VERSION = "UNSUPPORTED_VERSION", r.ROLLBACK_FAILED = "ROLLBACK_FAILED", r.VALIDATION_FAILED = "VALIDATION_FAILED", r.STRATEGY_NOT_FOUND = "STRATEGY_NOT_FOUND", r.DATA_CORRUPTION = "DATA_CORRUPTION", r))(si || {});
class vi extends Yw {
  constructor(i, l = "MIGRATION_FAILED", d) {
    super(i, d);
    __publicField(this, "code");
    __publicField(this, "domain", Kw.GENERIC);
    this.code = l;
  }
}
class da extends vi {
  constructor(i, l = "INVALID_VERSION", d, f, g) {
    super(i, l, g), this.currentVersion = d, this.targetVersion = f;
  }
}
class jr extends vi {
  constructor(i, l, d, f) {
    super(i, "VALIDATION_FAILED", f), this.field = l, this.value = d;
  }
}
class ty extends vi {
  constructor(i, l, d) {
    super(i, "DATA_CORRUPTION", d), this.corruptedData = l;
  }
}
class kI extends vi {
  constructor(i, l, d, f) {
    super(i, "ROLLBACK_FAILED", f), this.originalError = l, this.rollbackError = d;
  }
}
class Md {
  static getCurrentVersion() {
    return this.CURRENT_VERSION;
  }
  static getMinimumSupportedVersion() {
    return this.MIN_SUPPORTED_VERSION;
  }
  static extractVersion(i) {
    try {
      if (typeof i == "object" && i !== null && "version" in i) {
        const l = i.version;
        if (typeof l == "number" && l >= 0) return $i(l);
      }
      if (this.isRouteCollectionFormat(i)) return $i(0);
      if (this.isSketchArrayFormat(i)) return $i(1);
      throw new Error("Unable to determine data version");
    } catch (l) {
      const d = l instanceof da ? l : new da(`Failed to extract version from data: ${l}`, si.INVALID_VERSION, void 0, void 0, l instanceof Error ? l : new Error(String(l)));
      return zr(d);
    }
  }
  static isRouteCollectionFormat(i) {
    return typeof i == "object" && i !== null && "routes" in i && !("sketches" in i) && Array.isArray(i.routes);
  }
  static isSketchArrayFormat(i) {
    return Array.isArray(i) && i.length > 0 && this.isSketchObject(i[0]);
  }
  static isSketchObject(i) {
    return typeof i == "object" && i !== null && "id" in i && "meta" in i && "routes" in i && "drafts" in i;
  }
  static validateVersion(i) {
    try {
      if (i < this.MIN_SUPPORTED_VERSION) throw new da(`Version ${i} is below minimum supported version ${this.MIN_SUPPORTED_VERSION}`, si.UNSUPPORTED_VERSION, i);
      if (i > this.CURRENT_VERSION) throw new da(`Version ${i} is above current version ${this.CURRENT_VERSION}`, si.UNSUPPORTED_VERSION, i, this.CURRENT_VERSION);
      return $i(void 0);
    } catch (l) {
      const d = l instanceof da ? l : new da(`Version validation failed: ${l}`, si.INVALID_VERSION, i, void 0, l instanceof Error ? l : new Error(String(l)));
      return zr(d);
    }
  }
  static addVersionMetadata(i, l = this.CURRENT_VERSION) {
    return { ...i, [this.VERSION_KEY]: { version: l, timestamp: Date.now(), description: `Version ${l} data format` } };
  }
  static extractVersionMetadata(i) {
    try {
      if (typeof i == "object" && i !== null && this.VERSION_KEY in i) {
        const l = i[this.VERSION_KEY];
        if (this.isValidVersionInfo(l)) return $i(l);
      }
      return $i(null);
    } catch (l) {
      const d = l instanceof da ? l : new da(`Failed to extract version metadata: ${l}`, si.INVALID_VERSION, void 0, void 0, l instanceof Error ? l : new Error(String(l)));
      return zr(d);
    }
  }
  static isValidVersionInfo(i) {
    return typeof i == "object" && i !== null && "version" in i && "timestamp" in i && typeof i.version == "number" && typeof i.timestamp == "number";
  }
  static determineMigrationPath(i, l) {
    try {
      const d = this.validateVersion(i);
      if (d.isErr()) throw d.error;
      const f = this.validateVersion(l);
      if (f.isErr()) throw f.error;
      if (i === l) return $i([]);
      const g = [], m = i < l ? 1 : -1;
      for (let s = i; s !== l; s += m) g.push(s + m);
      return $i(g);
    } catch (d) {
      const f = d instanceof da ? d : new da(`Failed to determine migration path: ${d}`, si.INVALID_VERSION, i, l, d instanceof Error ? d : new Error(String(d)));
      return zr(f);
    }
  }
  static isMigrationNeeded(i) {
    return this.extractVersion(i).map((l) => l !== this.CURRENT_VERSION);
  }
}
__publicField(Md, "CURRENT_VERSION", 1);
__publicField(Md, "VERSION_KEY", "_data_version");
__publicField(Md, "MIN_SUPPORTED_VERSION", 0);
class Za {
  static validateSketchData(i) {
    try {
      if (!i || typeof i != "object") throw new jr("Sketch data must be an object", "data", i);
      const l = i, d = ["id", "meta", "routes", "drafts"];
      for (const g of d) if (!(g in l)) throw new jr(`Missing required field: ${g}`, g, l[g]);
      if (typeof l.id != "string" || !l.id) throw new jr("Sketch ID must be a non-empty string", "id", l.id);
      if (!l.meta || typeof l.meta != "object") throw new jr("Sketch meta must be an object", "meta", l.meta);
      const f = this.validateRouteCollectionData(l.routes);
      if (f.isErr()) throw f.error;
      if (!l.drafts || typeof l.drafts != "object") throw new jr("Sketch drafts must be an object", "drafts", l.drafts);
      return $i(l);
    } catch (l) {
      if (l instanceof jr) return zr(l);
      const d = new jr(`Unexpected validation error: ${l}`, void 0, i, l instanceof Error ? l : new Error(String(l)));
      return zr(d);
    }
  }
  static validateRouteCollectionData(i) {
    try {
      if (!i || typeof i != "object") throw new jr("Route collection data must be an object", "data", i);
      const l = i, d = ["id", "meta", "routes"];
      for (const f of d) if (!(f in l)) throw new jr(`Missing required field: ${f}`, f, l[f]);
      if (typeof l.id != "string" || !l.id) throw new jr("Route collection ID must be a non-empty string", "id", l.id);
      if (!l.meta || typeof l.meta != "object") throw new jr("Route collection meta must be an object", "meta", l.meta);
      if (!Array.isArray(l.routes)) throw new jr("Routes must be an array", "routes", l.routes);
      for (let f = 0; f < l.routes.length; f++) {
        const g = l.routes[f], m = this.validateRouteItem(g);
        if (m.isErr()) throw new jr(`Invalid route at index ${f}: ${m.error.message}`, `routes[${f}]`, g, m.error);
      }
      return $i(l);
    } catch (l) {
      if (l instanceof jr) return zr(l);
      const d = new jr(`Unexpected validation error: ${l}`, void 0, i, l instanceof Error ? l : new Error(String(l)));
      return zr(d);
    }
  }
  static validateRouteItem(i) {
    try {
      if (!i || typeof i != "object") throw new jr("Route item must be an object", "data", i);
      const l = i, d = ["id", "meta", "properties", "points"];
      for (const f of d) if (!(f in l)) throw new jr(`Missing required field: ${f}`, f, l[f]);
      if (typeof l.id != "string" || !l.id) throw new jr("Route item ID must be a non-empty string", "id", l.id);
      if (!Array.isArray(l.points)) throw new jr("Route points must be an array", "points", l.points);
      for (let f = 0; f < l.points.length; f++) {
        const g = l.points[f];
        if (!g || typeof g != "object") throw new jr(`Route point at index ${f} must be an object`, `points[${f}]`, g);
        const m = g;
        if (typeof m.latitude != "number" || typeof m.longitude != "number") throw new jr(`Route point at index ${f} must have numeric latitude and longitude`, `points[${f}]`, g);
      }
      return $i(l);
    } catch (l) {
      if (l instanceof jr) return zr(l);
      const d = new jr(`Unexpected validation error: ${l}`, void 0, i, l instanceof Error ? l : new Error(String(l)));
      return zr(d);
    }
  }
  static validateSketchArray(i) {
    try {
      if (!Array.isArray(i)) throw new jr("Sketch array must be an array", "data", i);
      if (i.length === 0) throw new jr("Sketch array cannot be empty", "data.length", i.length);
      for (let l = 0; l < i.length; l++) {
        const d = i[l], f = this.validateSketchData(d);
        if (f.isErr()) throw new jr(`Invalid sketch at index ${l}: ${f.error.message}`, `[${l}]`, d, f.error);
      }
      return $i(i);
    } catch (l) {
      if (l instanceof jr) return zr(l);
      const d = new jr(`Unexpected validation error: ${l}`, void 0, i, l instanceof Error ? l : new Error(String(l)));
      return zr(d);
    }
  }
  static validateData(i, l) {
    switch (l) {
      case "sketch":
        return this.validateSketchData(i);
      case "route-collection":
        return this.validateRouteCollectionData(i);
      case "sketch-array":
        return this.validateSketchArray(i);
      default:
        return zr(new jr(`Unknown expected format: ${l}`, "expectedFormat", l));
    }
  }
  static checkDataIntegrity(i, l) {
    try {
      const d = this.validateData(i, l);
      return d.isErr() ? zr(new ty(`Data validation failed: ${d.error.message}`, i, d.error)) : $i({ isValid: true, errors: [], warnings: [] });
    } catch (d) {
      return zr(new ty(`Data integrity check failed: ${d}`, i, d instanceof Error ? d : new Error(String(d))));
    }
  }
}
class PI {
  constructor() {
    __publicField(this, "fromVersion", 0);
    __publicField(this, "toVersion", 1);
    __publicField(this, "name", "route-collection-to-sketch");
  }
  migrate(i) {
    try {
      const l = Za.validateRouteCollectionData(i);
      if (l.isErr()) return zr(new vi(`Invalid route collection data: ${l.error.message}`, si.VALIDATION_FAILED, l.error));
      const d = l.value, f = new Pl();
      f.meta.name = d.meta.name || "Migrated Routes", f.meta.description = d.meta.description || "Migrated from route collection", f.meta.creation_timestamp = d.meta.creation_timestamp, f.meta.modification_timestamp = Date.now(), f.routes = d;
      const g = [f.toStorage()];
      return $i(g);
    } catch (l) {
      return zr(new vi(`Route collection to sketch migration failed: ${l}`, si.MIGRATION_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
  rollback(i) {
    try {
      const l = Za.validateSketchArray(i);
      if (l.isErr()) return zr(new vi(`Invalid sketch array data for rollback: ${l.error.message}`, si.VALIDATION_FAILED, l.error));
      const d = l.value;
      if (d.length === 0) return zr(new vi("Cannot rollback: empty sketch array", si.MIGRATION_FAILED));
      const f = d[0];
      return $i(f.routes);
    } catch (l) {
      return zr(new vi(`Route collection to sketch rollback failed: ${l}`, si.ROLLBACK_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
  validateBefore(i) {
    return Za.validateRouteCollectionData(i).map(() => {
    }).mapErr((l) => new jr(`Pre-migration validation failed: ${l.message}`, l.field, l.value, l));
  }
  validateAfter(i) {
    return Za.validateSketchArray(i).map(() => {
    }).mapErr((l) => new jr(`Post-migration validation failed: ${l.message}`, l.field, l.value, l));
  }
}
class TI {
  constructor() {
    __publicField(this, "fromVersion", 1);
    __publicField(this, "toVersion", 2);
    __publicField(this, "name", "sketch-v1-to-v2");
  }
  migrate() {
    return zr(new vi("Sketch V1 to V2 migration not yet implemented", si.STRATEGY_NOT_FOUND));
  }
  validateBefore(i) {
    return Za.validateSketchArray(i).map(() => {
    }).mapErr((l) => new jr(`Pre-migration validation failed: ${l.message}`, l.field, l.value, l));
  }
  validateAfter(i) {
    return zr(new jr("Sketch V2 validation not yet implemented", void 0, i));
  }
}
const _II = class _II {
  static register(i) {
    const l = this.getStrategyKey(i.fromVersion, i.toVersion);
    this.strategies.set(l, i);
  }
  static getStrategy(i, l) {
    const d = this.getStrategyKey(i, l), f = this.strategies.get(d);
    return f ? $i(f) : zr(new vi(`No migration strategy found for version ${i} to ${l}`, si.STRATEGY_NOT_FOUND));
  }
  static getAllStrategies() {
    return Array.from(this.strategies.values());
  }
  static hasStrategy(i, l) {
    const d = this.getStrategyKey(i, l);
    return this.strategies.has(d);
  }
  static getStrategyKey(i, l) {
    return `${i}->${l}`;
  }
};
__publicField(_II, "strategies", /* @__PURE__ */ new Map());
_II.register(new PI()), _II.register(new TI());
let II = _II;
class MI {
  static createStrategy(i, l) {
    return II.getStrategy(i, l);
  }
  static createStrategiesForPath(i) {
    try {
      const l = [];
      for (let d = 0; d < i.length; d++) {
        const f = d === 0 ? i[0] - 1 : i[d - 1], g = i[d], m = this.createStrategy(f, g);
        if (m.isErr()) return zr(m.error);
        l.push(m.value);
      }
      return $i(l);
    } catch (l) {
      return zr(new vi(`Failed to create strategies for migration path: ${l}`, si.MIGRATION_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
}
class EI {
  static isMigrationNeeded(i) {
    return Md.isMigrationNeeded(i);
  }
  static getDataVersion(i) {
    return Md.extractVersion(i);
  }
  static migrateToCurrent(i, l = {}) {
    return this.migrateToVersion(i, Md.getCurrentVersion(), l);
  }
  static migrateToVersion(i, l, d = {}) {
    try {
      const f = { ...this.DEFAULT_OPTIONS, ...d }, g = Md.extractVersion(i);
      if (g.isErr()) return zr(new vi(`Failed to extract current version: ${g.error.message}`, si.INVALID_VERSION, g.error));
      const m = g.value;
      if (m === l) return $i({ data: i, fromVersion: m, toVersion: l, migratedVersions: [] });
      const s = Md.determineMigrationPath(m, l);
      if (s.isErr()) return zr(new vi(`Failed to determine migration path: ${s.error.message}`, si.INVALID_VERSION, s.error));
      const C = s.value, T = MI.createStrategiesForPath(C);
      if (T.isErr()) return zr(T.error);
      const M = T.value;
      if (f.validateBefore) {
        const O = this.validateDataBeforeMigration(i, m);
        if (O.isErr()) return zr(new vi(`Pre-migration validation failed: ${O.error.message}`, si.VALIDATION_FAILED, O.error));
      }
      const z = f.enableRollback ? i : void 0;
      let L = i;
      const A = [];
      for (const O of M) {
        const V = this.executeMigrationWithRetry(O, L, f);
        if (V.isErr()) {
          if (f.enableRollback && z) {
            const X = this.rollbackToVersion(z);
            if (X.isErr()) return zr(new kI(`Migration failed and rollback also failed: ${X.error.message}`, V.error, X.error));
          }
          return zr(V.error);
        }
        L = V.value, A.push(O.toVersion);
      }
      if (f.validateAfter) {
        const O = this.validateDataAfterMigration(L, l);
        if (O.isErr()) return zr(new vi(`Post-migration validation failed: ${O.error.message}`, si.VALIDATION_FAILED, O.error));
      }
      return $i({ data: L, fromVersion: m, toVersion: l, migratedVersions: A, rollbackData: f.enableRollback ? z : void 0 });
    } catch (f) {
      return zr(new vi(`Migration service error: ${f}`, si.MIGRATION_FAILED, f instanceof Error ? f : new Error(String(f))));
    }
  }
  static executeMigrationWithRetry(i, l, d) {
    let f = null;
    for (let g = 0; g <= (d.maxRetries || 0); g++) {
      try {
        const m = i.migrate(l);
        if (m.isErr()) {
          f = m.error;
          continue;
        }
        if (i.validateAfter) {
          const s = i.validateAfter(m.value);
          if (s.isErr()) {
            f = new vi(`Post-migration validation failed: ${s.error.message}`, si.VALIDATION_FAILED, s.error);
            continue;
          }
        }
        return $i(m.value);
      } catch (m) {
        f = new vi(`Migration attempt ${g + 1} failed: ${m}`, si.MIGRATION_FAILED, m instanceof Error ? m : new Error(String(m)));
      }
      g < (d.maxRetries || 0) && d.retryDelay && console.warn(`Migration failed, retrying in ${d.retryDelay}ms...`);
    }
    return zr(f || new vi("Migration failed after all retry attempts", si.MIGRATION_FAILED));
  }
  static rollbackToVersion(i) {
    try {
      return $i(i);
    } catch (l) {
      return zr(new vi(`Rollback failed: ${l}`, si.ROLLBACK_FAILED, l instanceof Error ? l : new Error(String(l))));
    }
  }
  static validateDataBeforeMigration(i, l) {
    switch (l) {
      case 0:
        return Za.validateRouteCollectionData(i).map(() => {
        }).mapErr((d) => new vi(`Route collection validation failed: ${d.message}`, si.VALIDATION_FAILED, d));
      case 1:
        return Za.validateSketchArray(i).map(() => {
        }).mapErr((d) => new vi(`Sketch array validation failed: ${d.message}`, si.VALIDATION_FAILED, d));
      default:
        return zr(new vi(`Unknown version for pre-migration validation: ${l}`, si.VALIDATION_FAILED));
    }
  }
  static validateDataAfterMigration(i, l) {
    switch (l) {
      case 1:
        return Za.validateSketchArray(i).map(() => {
        }).mapErr((d) => new vi(`Sketch array validation failed: ${d.message}`, si.VALIDATION_FAILED, d));
      default:
        return zr(new vi(`Unknown version for post-migration validation: ${l}`, si.VALIDATION_FAILED));
    }
  }
  static checkDataIntegrity(i, l) {
    return Za.checkDataIntegrity(i, l);
  }
}
__publicField(EI, "DEFAULT_OPTIONS", { validateBefore: true, validateAfter: true, enableRollback: true, maxRetries: 3, retryDelay: 1e3 });
const r0 = Cy("sketches", () => {
  const r = Ae([]), i = Ae(null), l = Ae(null), d = ze(() => {
    if (!i.value) return null;
    const fe = r.value.find((oe) => oe.id === i.value);
    return fe ? new SI(fe.routes.routes.map((oe) => new Qm(oe.id, oe.points, oe.properties, oe.meta)), fe.routes.id, fe.routes.meta) : null;
  }), f = ze(() => d.value ? d.value.routes.map((fe) => ({ id: fe.id, name: fe.name, points: fe.getPoints(), meta: fe.meta })) : []), g = ze(() => i.value && r.value.find((fe) => fe.id === i.value) || null), m = ze(() => g.value ? g.value.drafts.drafts : []);
  async function s() {
    const fe = await tC("sketches");
    if (fe) {
      const oe = EI.migrateToCurrent(fe, { validateBefore: true, validateAfter: true, enableRollback: true });
      if (oe.isErr()) {
        console.error("[SketchStore] Data migration failed:", oe.error), await C();
        return;
      }
      const he = oe.value;
      he.migratedVersions.length > 0 && console.info(`[SketchStore] Successfully migrated data from version ${he.fromVersion} to ${he.toVersion}`), Array.isArray(he.data) ? (r.value = he.data.map((be) => Pl.fromStorage(be)), r.value.forEach((be) => {
        be.routes.routes.forEach(async (je) => {
          if (je.points.length > 1 && !je.meta.distance) try {
            je.meta.distance = await Mm(je.points);
          } catch (Ve) {
            console.warn("Failed to calculate route distance:", Ve), je.meta.distance = 0;
          }
        });
      }), !i.value && r.value.length > 0 && (i.value = r.value[0].id)) : await C();
    } else await C();
  }
  async function C() {
    const fe = new Pl();
    fe.meta.name = "Default Sketch", r.value = [fe], i.value = fe.id, await ko("sketches", r.value.map((oe) => oe.toStorage())), await Po();
  }
  async function T(fe = "New Sketch") {
    const oe = new Pl();
    return oe.meta.name = fe, r.value.push(oe), await ko("sketches", r.value.map((he) => he.toStorage())), await Po(), oe;
  }
  async function M(fe, oe) {
    const he = r.value.find((be) => be.id === fe);
    he && (oe.name !== void 0 && he.updateName(oe.name), oe.description !== void 0 && he.updateDescription(oe.description), oe.tags !== void 0 && (he.meta.tags.forEach((be) => he.removeTag(be)), oe.tags.forEach((be) => he.addTag(be))), await ko("sketches", r.value.map((be) => be.toStorage())), await Po());
  }
  async function z(fe) {
    const oe = r.value.findIndex((he) => he.id === fe);
    oe !== -1 && (r.value.splice(oe, 1), i.value === fe && (i.value = r.value.length > 0 ? r.value[0].id : null), await ko("sketches", r.value.map((he) => he.toStorage())), await Po());
  }
  function L(fe) {
    i.value = fe, l.value = null;
  }
  async function A(fe, oe = {}, he = {}) {
    g.value || await C();
    const be = new Qm(void 0, [], oe, he);
    return be.meta.name = fe, g.value && g.value.routes.routes.push(be.exportToStorage()), await ko("sketches", r.value.map((je) => je.toStorage())), await Po(), be;
  }
  async function O(fe) {
    if (!g.value) return;
    const oe = g.value.routes.routes.findIndex((he) => he.id === fe);
    oe !== -1 && (g.value.routes.routes.splice(oe, 1), l.value === fe && (l.value = null), await ko("sketches", r.value.map((he) => he.toStorage())), await Po());
  }
  async function V(fe, oe) {
    if (!g.value) return;
    const he = g.value.routes.routes.find((be) => be.id === fe);
    if (he) {
      if (he.points.push(oe), he.meta.modification_timestamp = Date.now(), he.points.length > 1) try {
        if (he.meta.distance) {
          const be = await Mm([he.points[he.points.length - 2], oe]);
          he.meta.distance += be;
        } else {
          const be = await Mm(he.points);
          he.meta.distance = be;
        }
      } catch (be) {
        console.warn("Failed to calculate route distance:", be), he.meta.distance || (he.meta.distance = 0);
      }
      await ko("sketches", r.value.map((be) => be.toStorage())), await Po();
    }
  }
  async function X(fe, oe) {
    if (!g.value) return;
    const he = g.value.routes.routes.find((be) => be.id === fe);
    he && (oe.meta !== void 0 && (he.meta = { ...he.meta, ...oe.meta }), oe.properties !== void 0 && (he.properties = { ...he.properties, ...oe.properties }), he.meta.modification_timestamp = Date.now(), await ko("sketches", r.value.map((be) => be.toStorage())), await Po());
  }
  async function W(fe) {
    if (!g.value) return;
    const oe = g.value.routes.routes.find((he) => he.id === fe);
    oe && (oe.points = [], oe.meta.modification_timestamp = Date.now(), await ko("sketches", r.value.map((he) => he.toStorage())), await Po());
  }
  function K(fe) {
    if (!g.value) return null;
    const oe = g.value.routes.routes.find((he) => he.id === fe);
    return oe ? new Qm(oe.id, oe.points, oe.properties, oe.meta) : null;
  }
  function ie(fe) {
    l.value = fe;
  }
  async function ee(fe, oe = {}, he = {}) {
    g.value || await C();
    const be = { id: crypto.randomUUID(), meta: { ...Wo(), ...he }, shape: fe, properties: oe };
    return g.value && g.value.drafts.drafts.push(be), await ko("sketches", r.value.map((je) => je.toStorage())), await Po(), be;
  }
  async function re(fe, oe) {
    if (!g.value) return;
    const he = g.value.drafts.drafts.find((be) => be.id === fe);
    he && (oe.shape !== void 0 && (he.shape = oe.shape), oe.properties !== void 0 && (he.properties = { ...he.properties, ...oe.properties }), oe.meta !== void 0 && (he.meta = { ...he.meta, ...oe.meta }, he.meta.modification_timestamp = Date.now()), await ko("sketches", r.value.map((be) => be.toStorage())), await Po());
  }
  async function J(fe) {
    if (!g.value) return;
    const oe = g.value.drafts.drafts.findIndex((he) => he.id === fe);
    oe !== -1 && (g.value.drafts.drafts.splice(oe, 1), await ko("sketches", r.value.map((he) => he.toStorage())), await Po());
  }
  function Se(fe) {
    return g.value && g.value.drafts.drafts.find((oe) => oe.id === fe) || null;
  }
  return { sketches: r, currentSketchId: i, currentRouteId: l, routeCollection: d, routes: f, currentSketch: g, currentDrafts: m, init: s, createSketch: T, updateSketch: M, deleteSketch: z, setCurrentSketchId: L, addRoute: A, deleteRoute: O, addPointToRoute: V, updateRoute: X, clearRoutePoints: W, getRouteById: K, setCurrentRouteId: ie, addDraft: ee, updateDraft: re, deleteDraft: J, getDraftById: Se };
}), g1 = Cy("routes", () => {
  const r = r0(), i = ze(() => r.routeCollection), l = ze({ get: () => r.currentRouteId, set: (J) => r.setCurrentRouteId(J) }), d = Ae(0);
  ar(l, (J) => {
    var _a3, _b2;
    J && (d.value = ((_b2 = (_a3 = r.getRouteById(J)) == null ? void 0 : _a3.meta) == null ? void 0 : _b2.record_timespan) ?? 0);
  });
  const f = Ae(false), g = Ae(-1), m = Ae(null);
  let s;
  const C = ze(() => r.routes);
  function T(J) {
    m.value = J;
  }
  async function M() {
    await r.init();
  }
  async function z(J, Se = {}) {
    return await r.addRoute(J, Se);
  }
  async function L(J) {
    await r.deleteRoute(J);
  }
  async function A(J, Se) {
    await r.addPointToRoute(J, Se);
  }
  async function O(J, Se) {
    await r.updateRoute(J, Se);
  }
  async function V(J) {
    await r.clearRoutePoints(J);
  }
  function X(J) {
    return r.getRouteById(J);
  }
  function W(J) {
    r.setCurrentRouteId(J);
  }
  function K(J) {
    f.value || !m.value || (f.value = true, J && A(l.value, J), g.value = m.value.addLocationListener((Se) => {
      l.value && A(l.value, Se);
    }), r.updateRoute(l.value, { meta: { modification_timestamp: Date.now() } }), s = setInterval(async () => {
      const Se = r.getRouteById(l.value);
      Se.recordTimespan !== void 0 && Se.meta.modification_timestamp && (d.value = Se.recordTimespan + (Date.now() - Se.meta.modification_timestamp), await r.updateRoute(l.value, { meta: { record_timespan: d.value } }));
    }, 100));
  }
  function ie() {
    !f.value || !m.value || (g.value !== -1 && (m.value.removeLocationListener(g.value), g.value = -1), s && (clearTimeout(s), s = void 0), f.value = false);
  }
  async function ee(J) {
    try {
      if (!m.value) throw new Error("Geolocation service not available");
      if (f.value) ie();
      else if (l.value) K();
      else {
        const Se = await z(J("trackerView.nameNewRoute"));
        W(Se.id), K(m.value.getLastKnownLocation());
      }
    } catch (Se) {
      throw console.error(Se), Se;
    }
  }
  function re() {
    g.value !== -1 && m.value && (m.value.removeLocationListener(g.value), g.value = -1), f.value = false;
  }
  return { routeCollection: i, routes: C, currentRouteId: l, isRecording: f, watchingHandler: g, currentRouteRecordTimespan: d, setLocator: T, init: M, addRoute: z, deleteRoute: L, addPointToRoute: A, updateRoute: O, clearRoutePoints: V, getRouteById: X, setCurrentRouteId: W, startRecording: K, stopRecording: ie, toggleRecording: ee, cleanup: re };
}), RI = { class: "upload-container" }, AI = { class: "action-buttons" }, DI = st({ __name: "TextFileUploaderDialog", props: Il({ multiple: { type: Boolean }, icon: {}, prompt: {}, types: {} }, { show: { default: false, type: Boolean }, showModifiers: {} }), emits: Il(["update:value", "confirm"], ["update:show"]), setup(r, { emit: i }) {
  const l = hp(), d = r, f = i, g = Od(r, "show");
  let m = [];
  const s = (M) => {
    m = [];
    for (const z of M) {
      const L = z.file;
      if (L) if (d.types.includes(L.type)) {
        const A = new FileReader();
        A.onload = (O) => {
          var _a3;
          ((_a3 = O.target) == null ? void 0 : _a3.result) && m.push(O.target.result), m.length === M.length && f("update:value", m);
        }, A.readAsText(L);
      } else l.warning(`Skipped file ${z.name} due to unsupported type ${L.type}`);
    }
  }, C = () => {
    f("confirm", m), g.value = false;
  }, T = (M) => {
    var _a3, _b2;
    return d.types.includes(((_a3 = M.file.file) == null ? void 0 : _a3.type) ?? "") ? true : (l.error(`Unsupported file type ${((_b2 = M.file.file) == null ? void 0 : _b2.type) ?? "unknown"}. Supported types: ['${d.types.join("', '")}']`), false);
  };
  return (M, z) => (St(), Cr(te(Vd), { show: g.value, "onUpdate:show": z[2] || (z[2] = (L) => g.value = L), preset: "dialog", title: "Dialog" }, { header: qe(() => [...z[3] || (z[3] = [Pr(" File Upload ", -1)])]), default: qe(() => [Tt("div", RI, [Ne(te(s6), { multiple: d.multiple ?? false, onChange: z[0] || (z[0] = ({ fileList: L }) => s(L)), onBeforeUpload: T }, { default: qe(() => [Ne(te(Zb), null, { default: qe(() => [Ne(te(Ii), { size: 36, name: "upload", class: "upload-icon" }, { default: qe(() => [(St(), Cr(Ku(d.icon ?? te(cb))))]), _: 1 }), Tt("div", null, ir(d.prompt ?? "Drag and drop a file here or click to upload"), 1)]), _: 1 })]), _: 1 }, 8, ["multiple"])])]), action: qe(() => [Tt("div", AI, [Ne(te(Vr), { onClick: z[1] || (z[1] = (L) => g.value = false) }, { default: qe(() => [...z[4] || (z[4] = [Pr(" Cancel ", -1)])]), _: 1 }), Ne(te(Vr), { type: "primary", onClick: C }, { default: qe(() => [...z[5] || (z[5] = [Pr(" Upload ", -1)])]), _: 1 })])]), _: 1 }, 8, ["show"]));
} }), zI = go(DI, [["__scopeId", "data-v-14c5a0c1"]]), FI = st({ __name: "MglDrawer", props: Il({ position: {} }, { show: { type: Boolean, default: false }, showModifiers: {} }), emits: Il(["update:width", "update:height", "click", "contextmenu"], ["update:show"]), setup(r, { emit: i }) {
  oc((L) => ({ a1b7bba2: te(f).modalColor, "305889d2": te(f).borderRadius, "60287bc6": M.value, "048a7f4c": T.value }));
  const l = r, d = i, f = El(), g = Jw("route-drawer"), m = ze(() => l.position || "left"), s = ze(() => {
    var _a3, _b2, _c, _d;
    return Math.min(gg(Math.round((((_b2 = (_a3 = g.value) == null ? void 0 : _a3.parentElement) == null ? void 0 : _b2.clientWidth) ?? 2e3) * 0.4), 320, 640), (((_d = (_c = g.value) == null ? void 0 : _c.parentElement) == null ? void 0 : _d.clientWidth) ?? 1 / 0) - 48);
  }), C = ze(() => {
    var _a3, _b2, _c, _d;
    return Math.min(gg(Math.round((((_b2 = (_a3 = g.value) == null ? void 0 : _a3.parentElement) == null ? void 0 : _b2.clientHeight) ?? 2e3) * 0.4), 320, 640), (((_d = (_c = g.value) == null ? void 0 : _c.parentElement) == null ? void 0 : _d.clientHeight) ?? 1 / 0) - 48);
  }), T = ze(() => m.value === "left" ? `${-16 - s.value}px` : m.value === "right" ? `${16 + s.value}px` : m.value === "top" ? `${-16 - C.value}px` : m.value === "bottom" ? `${16 + C.value}px` : "0px"), M = ze(() => m.value === "left" || m.value === "right" ? `${s.value}px` : `${C.value}px`), z = Od(r, "show");
  return ar(s, () => d("update:width", s.value)), ar(C, () => d("update:height", C.value)), (L, A) => (St(), Cr(Io, { name: `slide-${m.value}` }, { default: qe(() => [ma(Tt("div", { ref: "route-drawer", class: bl(["route-drawer", `route-drawer--${m.value}`]), onClick: A[0] || (A[0] = (O) => d("click", O)), onContextmenu: A[1] || (A[1] = (O) => d("contextmenu", O)) }, [Og(L.$slots, "default", {}, void 0, true)], 34), [[Ka, z.value]])]), _: 3 }, 8, ["name"]));
} }), LI = go(FI, [["__scopeId", "data-v-72b274a7"]]), BI = { class: "menu-list" }, OI = ["onClick", "onContextmenu", "onTouchstart"], $I = { class: "swipe-container" }, jI = { style: { height: "fit-content", padding: "8px 12px" } }, NI = ["onClick"], VI = { style: { padding: "16px" } }, UI = 120, qI = 40, GI = st({ __name: "SelectableSwipeableMenuList", props: Il({ items: {}, menuOptions: {}, swipeActions: {} }, { selection: { type: String, default: null }, selectionModifiers: {}, multipleSelection: { type: Array, default: () => [] }, multipleSelectionModifiers: {} }), emits: Il(["contextmenu"], ["update:selection", "update:multipleSelection"]), setup(r, { emit: i }) {
  oc((ee) => ({ af602246: te(m).hoverColor, "2c598f52": te(m).primaryColor, f032366a: te(m).bodyColor, "6ce963b2": s.value }));
  const l = r, d = Od(r, "selection"), f = Od(r, "multipleSelection"), g = i, m = El(), s = Ae("0s"), C = Ae({ startX: 0, delta: 0, currentX: 0, containerWidth: 0, activeId: null, leftMax: 0, rightMax: 0 }), T = Ae(false), M = Ae(0), z = Ae(0), L = Ae(null);
  function A(ee, re) {
    C.value.activeId !== re && W();
    const J = ee.touches[0];
    C.value = { startX: J.clientX, delta: C.value.delta ?? 0, currentX: J.clientX, containerWidth: ee.currentTarget.offsetWidth, activeId: re, leftMax: UI, rightMax: qI };
  }
  function O(ee) {
    C.value.activeId && (C.value.currentX = ee.touches[0].clientX, C.value.delta += C.value.currentX - C.value.startX, C.value.delta = gg(C.value.delta, -C.value.leftMax, C.value.rightMax), C.value.startX = ee.touches[0].clientX);
  }
  function V() {
    if (!C.value.activeId) return;
    s.value = `${Math.abs(C.value.delta) / C.value.containerWidth * 0.3}s`, setTimeout(() => {
      s.value = "0s";
    }, 300);
    const ee = C.value.delta < 0 ? C.value.leftMax : C.value.rightMax;
    C.value.delta = Math.abs(C.value.delta) > ee * 0.4 ? Math.sign(C.value.delta) * ee : 0, C.value.delta === 0 && Math.abs(C.value.delta) < 5;
  }
  function X(ee, re) {
    ee.stopPropagation(), !(C.value.delta > 5) && (W(), d.value !== re.id && (d.value = re.id));
  }
  function W() {
    C.value.delta > 0 || (C.value = { startX: 0, delta: 0, currentX: 0, containerWidth: 0, activeId: null, leftMax: 0, rightMax: 0 });
  }
  function K(ee, re) {
    if (ee.stopPropagation(), ee.preventDefault(), T.value) {
      T.value = false;
      return;
    }
    L.value = re, M.value = ee.clientX, z.value = ee.clientY, T.value = true, g("contextmenu", ee, re);
  }
  function ie(ee) {
    const re = [...f.value];
    if (re.includes(ee)) {
      const J = re.indexOf(ee);
      re.splice(J, 1);
    } else re.push(ee);
    f.value = re;
  }
  return (ee, re) => (St(), Yt(Gr, null, [Tt("div", BI, [(St(true), Yt(Gr, null, hn(l.items, (J) => (St(), Yt("div", { key: J.id, class: bl(["menu-list-item", ...J.id === d.value ? ["active"] : []]), style: gs({ "touch-action": C.value.activeId === J.id ? "pan-y" : "auto" }), onClick: (Se) => X(Se, J), onContextmenu: $d((Se) => K(Se, J), ["prevent"]), onTouchstart: (Se) => A(Se, J.id), onTouchmove: O, onTouchend: V }, [Tt("div", $I, [Tt("div", { class: "content-col", style: gs({ transform: `translateX(${C.value.activeId === J.id || C.value.delta > 0 ? C.value.delta : 0}px)`, willChange: C.value.activeId === J.id ? "transform" : "auto", flexDirection: C.value.delta >= 0 || C.value.activeId !== J.id ? "row" : "row-reverse" }) }, [Og(ee.$slots, "item", { item: J }, () => [Tt("div", jI, [Tt("div", null, ir(J.name ?? "Untitled"), 1)])], true)], 4), Tt("div", { class: "actions-col", style: gs({ width: `${C.value.activeId === J.id && C.value.delta < 0 ? -C.value.delta : 0}px`, visibility: C.value.activeId === J.id && C.value.delta < 0 ? "visible" : "hidden", willChange: C.value.activeId === J.id ? "width" : "auto" }) }, [(St(true), Yt(Gr, null, hn(l.swipeActions, (Se) => (St(), Yt("button", { key: Se.name, class: "menu-action", style: gs({ background: Se.color || te(m).primaryColorSuppl }), onClick: () => {
    Se.action(J.id), C.value.activeId = null;
  } }, ir(Se.label), 13, NI))), 128))], 4), Tt("div", { class: "select-col", style: gs({ width: `${C.value.delta > 0 ? C.value.delta : 0}px`, backgroundColor: d.value === J.id ? te(m).primaryColor : "transparent", visibility: C.value.delta > 0 ? "visible" : "hidden" }) }, [Tt("div", VI, [Ne(te(Wk), { checked: f.value.includes(J.id), style: gs({ border: d.value === J.id ? `1px solid ${te(m).bodyColor}` : "none", BorderRadius: d.value === J.id ? te(m).borderRadiusSmall : "none" }), "onUpdate:checked": () => ie(J.id) }, null, 8, ["checked", "style", "onUpdate:checked"])])], 4)])], 46, OI))), 128))]), Ne(te(Wy), { show: T.value, x: M.value, y: z.value, options: l.menuOptions.map((J) => {
    var _a3;
    return { ...J, label: ((_a3 = J.label) == null ? void 0 : _a3.value) ?? J.label };
  }), placement: "bottom-start", trigger: "manual", onClick: re[0] || (re[0] = (J) => T.value = false), onClickoutside: re[1] || (re[1] = (J) => T.value = false) }, null, 8, ["show", "x", "y", "options"])], 64));
} }), WI = go(GI, [["__scopeId", "data-v-b353d352"]]), ZI = { class: "drawer-floating" }, HI = { class: "drawer-container" }, XI = { class: "drawer-header" }, YI = { class: "drawer-title" }, KI = { class: "drawer-content" }, JI = { style: { height: "fit-content", padding: "8px 12px", "text-align": "left" } }, QI = { style: { "font-size": "0.8rem", opacity: "0.7", display: "flex", "flex-direction": "row", gap: "12px" } }, e4 = { key: 0 }, t4 = st({ __name: "TrackerViewRouteDrawer", props: { show: { type: Boolean, default: false }, showModifiers: {} }, emits: Il(["update:width"], ["update:show"]), setup(r, { emit: i }) {
  oc((fe) => ({ "38b2b83c": te(C).borderRadius, "3ddcb48b": te(C).hoverColor, "485009dd": te(C).primaryColorPressed, "4f454a85": te(C).primaryColor, "73f3b15d": te(C).bodyColor }));
  const d = new Gg().isMobile, { t: f } = Eo(), g = Mb(), m = i, s = g1(), C = El(), T = Od(r, "show"), M = Ae(false), z = Ae(0), L = Ae(0), A = Ae(null), O = Ae(false), V = Ae(""), X = Ae(null), W = [{ label: ze(() => f("components.trackerViewRouteDrawer.contextMenu.new")), key: "new", props: { onClick: () => {
    M.value = false, s.addRoute(f("components.trackerViewRouteDrawer.nameNewRoute"));
  } } }], K = [{ label: ze(() => f("components.trackerViewRouteDrawer.contextMenu.rename")), key: "rename", props: { onClick: () => {
    var _a3;
    ((_a3 = A.value) == null ? void 0 : _a3.id) && (V.value = A.value.name || "", O.value = true);
  } } }, { label: ze(() => f("components.trackerViewRouteDrawer.contextMenu.delete")), key: "delete", props: { onClick: () => {
    A.value && s.deleteRoute(A.value.id);
  } } }, { key: "divider-1", type: "divider" }, ...W], ie = [{ label: ze(() => f("components.trackerViewRouteDrawer.contextMenu.rename")), name: "rename", action: (fe) => {
    const oe = s.routes.find((he) => he.id === fe);
    X.value = fe, V.value = (oe == null ? void 0 : oe.name) || "", O.value = true;
  } }, { label: ze(() => f("components.trackerViewRouteDrawer.contextMenu.delete")), name: "delete", action: (fe) => s.deleteRoute(fe), color: C.value.errorColorSuppl }];
  function ee(fe) {
    if (fe.stopPropagation(), fe.preventDefault(), X.value = s.currentRouteId, M.value) {
      M.value = false;
      return;
    }
    z.value = fe.clientX, L.value = fe.clientY, M.value = true;
  }
  async function re(fe) {
    V.value.trim() && (await s.updateRoute(fe, { meta: { name: V.value.trim() } }), O.value = false);
  }
  const J = Ae([]);
  function Se() {
    g.warning({ title: f("components.trackerViewRouteDrawer.deleteConfirmation.title"), content: f("components.trackerViewRouteDrawer.deleteConfirmation.prompt"), positiveText: f("components.trackerViewRouteDrawer.deleteConfirmation.yes"), negativeText: f("components.trackerViewRouteDrawer.deleteConfirmation.no"), onPositiveClick: () => {
      J.value.forEach((fe) => {
        s.deleteRoute(fe), J.value = J.value.filter((oe) => oe !== fe);
      });
    } });
  }
  return (fe, oe) => (St(), Yt(Gr, null, [Ne(LI, { show: T.value, "onUpdate:show": oe[3] || (oe[3] = (he) => T.value = he), position: te(d) ? "bottom" : "left", onClick: oe[4] || (oe[4] = () => te(s).currentRouteId = null), "onUpdate:width": oe[5] || (oe[5] = (he) => m("update:width", he)), onContextmenu: oe[6] || (oe[6] = (he) => ee(he)) }, { default: qe(() => [Tt("div", ZI, [te(d) && T.value ? Og(fe.$slots, "bottom-floating", { key: 0 }, void 0, true) : Xr("", true)]), Tt("div", HI, [Tt("div", XI, [Tt("p", YI, ir(te(f)("components.trackerViewRouteDrawer.routes")), 1), J.value.length > 0 ? (St(), Cr(te(Vr), { key: 0, strong: "", secondary: "", circle: "", type: "error", onClick: Se }, { icon: qe(() => [Ne(te(Ii), { component: te(up) }, null, 8, ["component"])]), _: 1 })) : Xr("", true)]), Tt("div", KI, [Ne(WI, { selection: te(s).currentRouteId, "onUpdate:selection": oe[0] || (oe[0] = (he) => te(s).currentRouteId = he), "multiple-selection": J.value, "onUpdate:multipleSelection": oe[1] || (oe[1] = (he) => J.value = he), items: te(s).routes, "menu-options": K, "swipe-actions": ie, onContextmenu: oe[2] || (oe[2] = (he, be) => {
    X.value = (be == null ? void 0 : be.id) ?? null, A.value = be ?? null;
  }) }, { item: qe(({ item: he }) => {
    var _a3;
    return [Tt("div", JI, [Tt("div", null, ir(he.name ?? te(f)("components.trackerViewRouteDrawer.nameNewRoute")), 1), Tt("div", QI, [Tt("div", null, ir(te(f)("components.trackerViewRouteDrawer.points", { num: he.points.length })), 1), he.points.length > 1 && ((_a3 = he.meta) == null ? void 0 : _a3.distance) ? (St(), Yt("div", e4, ir(te(f)("components.trackerViewRouteDrawer.distance", { distance: te(Qw)(he.meta.distance) })), 1)) : Xr("", true)])])];
  }), _: 1 }, 8, ["selection", "multiple-selection", "items"])])])]), _: 3 }, 8, ["show", "position"]), Ne(te(Wy), { show: M.value, x: z.value, y: L.value, options: W.map((he) => ({ ...he, label: he.label.value })), placement: "bottom-start", trigger: "manual", onClickoutside: oe[7] || (oe[7] = (he) => M.value = false) }, null, 8, ["show", "x", "y", "options"]), Ne(te(Vd), { show: O.value, "onUpdate:show": oe[10] || (oe[10] = (he) => O.value = he), preset: "dialog", title: "Rename Route", "positive-text": "Save", "negative-text": "Cancel", onPositiveClick: oe[11] || (oe[11] = () => {
    X.value && re(X.value);
  }) }, { default: qe(() => [Ne(te(ho), { value: V.value, "onUpdate:value": oe[8] || (oe[8] = (he) => V.value = he), placeholder: "Enter new route name", onKeyup: oe[9] || (oe[9] = Sy(() => {
    X.value && re(X.value);
  }, ["enter"])) }, null, 8, ["value"])]), _: 1 }, 8, ["show"])], 64));
} }), r4 = go(t4, [["__scopeId", "data-v-a6ce157e"]]), i4 = { class: "map-layout-container" }, n4 = { class: "map-layout" }, o4 = { key: 0, style: { width: "100%", height: "100%" } }, a4 = ["title", "onClick"], s4 = { key: 1, style: { width: "100%", height: "100%", display: "grid", "place-content": "center" } }, l4 = { style: { "font-family": "monospace", "padding-left": "8px" } }, u4 = st({ __name: "TrackerView", setup(r) {
  oc((yt) => {
    var _a3, _b2, _c;
    return { "2c69e1d6": (_a3 = te(wd).Button.common) == null ? void 0 : _a3.successColorSuppl, "69ecb927": te(d).boxShadow3, "26d04306": te(d).borderRadius, "86fb57d0": te(d).borderColor, "06f6ab58": (_b2 = te(wd).Button.common) == null ? void 0 : _b2.primaryColorSuppl, "098d059a": (_c = te(wd).Button.common) == null ? void 0 : _c.errorColorSuppl };
  });
  const l = new Gg().isMobile, d = El(), f = rC(), g = hp(), m = fr("geolocation"), { t: s } = Eo(), C = Eo(), T = Ae(7), z = "https://api.maptiler.com/maps/basic-v2/style.json?key=dCeXFrS9lgSF8hm5C6nm", L = Ae({ latitude: 0, longitude: 0 }), A = Tl(null), O = Tl(null), V = Ae("select"), X = g1();
  X.setLocator(m);
  const W = fr("noSleep"), K = ze(() => {
    var _a3;
    return X.currentRouteId ? ((_a3 = X.routes.find((nt) => nt.id === X.currentRouteId)) == null ? void 0 : _a3.points) || [] : [];
  }), ie = Ae(false), ee = new ws.Marker(), re = ze(() => {
    if (K.value.length > 1 || K.value.length === 0) return ee.remove(), { type: "FeatureCollection", features: [{ type: "Feature", properties: { description: X.currentRouteId }, geometry: { type: "LineString", coordinates: K.value.map((yt) => [yt.longitude, yt.latitude]) } }] };
    if (K.value.length === 1) {
      ee.setLngLat([K.value[0].longitude, K.value[0].latitude]);
      const yt = A.value;
      yt && ee.addTo(yt);
    }
    return { type: "FeatureCollection", features: [] };
  }), J = [{ mode: new H6(), name: s("trackerView.terraDrawTools.point"), icon: Zy }, { mode: new V6(), name: s("trackerView.terraDrawTools.line"), icon: P3 }, { mode: new sI({ allowManualDeselection: true, flags: { point: { feature: { draggable: true } }, polygon: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, linestring: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, freehand: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, circle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, rectangle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } } } }), name: s("trackerView.terraDrawTools.select"), icon: S3 }];
  ar([() => f.settings.mapLanguage, () => C.locale.value], (yt) => {
    yt && A.value && Se(A.value, yt[0] === "interface" ? yt[1] : yt[0]);
  });
  const Se = (yt, nt) => {
    const ut = nt === "zh-CN" ? "zh" : "en", Ft = ["City labels", "Road labels", "Station labels", "Airport labels", "Continent labels", "Country labels"];
    for (const Ht of Ft) yt.setLayoutProperty(Ht, "text-field", ["get", `name:${ut}`]);
  };
  function fe(yt) {
    var _a3;
    A.value = yt.map, A.value && Se(A.value, C.locale.value), (_a3 = A.value) == null ? void 0 : _a3.on("click", () => {
      Ke.value = false;
    }), O.value = new vI({ adapter: new _I({ map: A.value }), modes: J.map((nt) => nt.mode) }), O.value.start();
  }
  let oe = true;
  async function he() {
    try {
      X.isRecording || (oe = X.currentRouteId === null), await X.toggleRecording(s), !X.isRecording && oe && (vt.value = true, setTimeout(() => {
        vt.value = false;
      }, 3e3)), X.isRecording ? W.enable() : W.disable();
    } catch (yt) {
      console.error(yt), W.disable();
    }
  }
  const be = Ae(async () => {
  });
  function je() {
    Ke.value = false, g.warning("Not implemented yet");
  }
  const Ve = Ae(0), Ke = Ae(false);
  ar(Ke, (yt) => {
    var _a3;
    return (_a3 = A.value) == null ? void 0 : _a3.easeTo({ padding: l ? { bottom: yt ? Ve.value : 0 } : { left: yt ? Ve.value : 0 }, duration: 500 });
  });
  const lt = () => Ke.value = !Ke.value, vt = Ae(false), wt = Ae(""), at = Ae(false);
  Qi(async () => {
    var _a3;
    await X.init();
    try {
      const yt = await m.getCurrentLocation();
      if (yt.isOk()) L.value = yt.value, m.isUsingGPS() || g.warning(s("trackerView.gpsWarning"), { duration: 5e3 });
      else throw yt.error;
    } catch (yt) {
      wt.value = yt.message ?? String(yt);
    }
    at.value = true, (_a3 = O.value) == null ? void 0 : _a3.start();
  });
  const et = false;
  function ht(yt) {
    const nt = yt / 1e3, ut = nt / 60, Ft = ut / 60, Ht = nt % 60, zt = ut % 60, pr = Ft;
    let Qt = "";
    return Math.floor(pr) > 0 && (Qt += `${String(Math.floor(pr))}h `), Math.floor(zt) > 0 && (Qt += `${String(Math.floor(zt))}m `), Qt += `${String(Ht.toFixed(1)).padStart(4, "0")}s`, Qt;
  }
  return (yt, nt) => (St(), Yt("div", i4, [Tt("div", n4, [Ne(Io, { name: "map-load" }, { default: qe(() => [at.value && !wt.value ? (St(), Yt("div", o4, [Ne(te(t1), { "map-style": z, center: [L.value.longitude, L.value.latitude], zoom: T.value, height: "100%", "onMap:load": fe }, { default: qe(() => [Ne(te(i1), { position: "top-left" }), te(m).isUsingGPS() || et ? (St(), Cr(te(y6), { key: 0, position: "top-left", "track-user-location": true })) : Xr("", true), Ne(te(r1), { position: "top-left" }), Ne(te(o1), { position: "bottom-left" }), !te(l) || et ? (St(), Cr(te(j_), { key: 1, position: "top-right" }, { default: qe(() => [(St(), Yt(Gr, null, hn(J, (ut) => Tt("button", { key: ut.name, class: bl(["btn-control", "btn-draw-mode", { active: ut.mode.mode === V.value }]), title: ut.name, onClick: () => {
    var _a3, _b2, _c;
    console.log("activeDrawMethod", V.value), V.value === ut.mode.mode ? ((_a3 = O.value) == null ? void 0 : _a3.setMode("select"), V.value = "select") : (V.value = ut.mode.mode, (_b2 = O.value) == null ? void 0 : _b2.start(), (_c = O.value) == null ? void 0 : _c.setMode(ut.mode.mode));
  } }, [Ne(te(Ii), { size: 20 }, { default: qe(() => [(St(), Cr(Ku(ut.icon), { class: "btn-default" }))]), _: 2 }, 1024)], 10, a4)), 64))]), _: 1 })) : Xr("", true), Ne(te(j_), { position: "bottom-left" }, { default: qe(() => [Ne(te(jg), { trigger: "manual", show: vt.value }, { trigger: qe(() => [Tt("button", { class: "btn-control btn-route-toggle", onClick: lt }, [Ne(te(Ii), { size: 24 }, { default: qe(() => [Ne(te(Wg))]), _: 1 })])]), default: qe(() => [Tt("span", null, ir(te(s)("trackerView.uiRouteCheckoutTip")), 1)]), _: 1 }, 8, ["show"])]), _: 1 }), Ne(te(C6), { "source-id": "geojson", data: re.value }, { default: qe(() => [Ne(te(T6), { "layer-id": "geojson", layout: { "line-join": "round", "line-cap": "round" }, paint: { "line-width": 5, "line-color": "#008800", "line-opacity": 0.8 } })]), _: 1 }, 8, ["data"])]), _: 1 }, 8, ["center", "zoom"])])) : (St(), Yt("div", s4, [wt.value ? (St(), Cr(te(vk), { key: 1, title: te(s)("app.error"), type: "error" }, { default: qe(() => [Tt("div", null, [nt[3] || (nt[3] = Tt("br", null, null, -1)), Tt("b", null, ir(te(s)("app.error")) + ": ", 1), nt[4] || (nt[4] = Tt("br", null, null, -1)), Tt("code", null, ir(wt.value), 1)])]), _: 1 }, 8, ["title"])) : (St(), Cr(te(T5), { key: 0, size: "large" }, { description: qe(() => [Ne(te(qa), null, { default: qe(() => [Pr(ir(te(s)("trackerView.mapLoading")), 1)]), _: 1 })]), _: 1 }))]))]), _: 1 })]), Ne(zI, { show: ie.value, "onUpdate:show": nt[0] || (nt[0] = (ut) => ie.value = ut), types: ["application/json", "text/plain"], onConfirm: be.value }, null, 8, ["show", "onConfirm"]), Ne(r4, { show: Ke.value, "onUpdate:show": nt[1] || (nt[1] = (ut) => Ke.value = ut), "onUpdate:width": nt[2] || (nt[2] = (ut) => Ve.value = ut) }, { "bottom-floating": qe(() => [Ne(te(Kv), { theme: te(wd) }, { default: qe(() => [K.value.length > 1 ? (St(), Cr(te(Vr), { key: 0, size: "large", type: "success", class: "drawer-floating-button", onClick: je }, { default: qe(() => [...nt[5] || (nt[5] = [Pr(" Follow ", -1)])]), _: 1 })) : Xr("", true)]), _: 1 }, 8, ["theme"])]), _: 1 }, 8, ["show"]), te(l) || et ? (St(), Yt("div", { key: 0, class: bl(["mobile-record-button-container", { "drawer-open": Ke.value }]) }, [Ne(te(Kv), { theme: te(wd) }, { default: qe(() => [Ne(te(Vr), { type: te(X).isRecording ? "error" : "primary", size: "large", class: bl(["mobile-record-button", te(X).isRecording ? "recording" : "not-recording"]), onClick: he }, { icon: qe(() => [Ne(te(Ii), { size: 20 }, { default: qe(() => [(St(), Cr(Ku(te(X).isRecording ? te(L3) : te(R3)), { size: te(X).isRecording ? 16 : 20 }, null, 8, ["size"]))]), _: 1 })]), default: qe(() => [Pr(" " + ir(te(X).isRecording ? te(s)("trackerView.uiRecordingStatus.on") : te(s)("trackerView.uiRecordingStatus.off")) + " ", 1), Tt("p", l4, ir(te(X).currentRouteRecordTimespan ? `(${ht(te(X).currentRouteRecordTimespan)})` : ""), 1)]), _: 1 }, 8, ["type", "class"])]), _: 1 }, 8, ["theme"])], 2)) : Xr("", true)]));
} }), v1 = go(u4, [["__scopeId", "data-v-3302da49"]]), c4 = Object.freeze(Object.defineProperty({ __proto__: null, default: v1 }, Symbol.toStringTag, { value: "Module" })), d4 = { class: "container" }, h4 = { style: { height: "100%", width: "100%", display: "flex", "justify-items": "center" } }, f4 = { style: { display: "flex", "flex-direction": "row", "flex-grow": "1" } }, p4 = { style: { "font-weight": "500" } }, m4 = { style: { display: "flex", "flex-wrap": "wrap", gap: "4px", "margin-left": "24px" } }, g4 = st({ __name: "SketchSelector", props: { list: { type: Array, default: () => [] } }, emits: ["select", "remove"], setup(r, { emit: i }) {
  const { t: l } = Eo(), d = r, f = i;
  function g(s) {
    f("select", s);
  }
  function m(s) {
    confirm(l("sketchEdit.deleteSketchConfirmation")) && f("remove", s);
  }
  return (s, C) => (St(), Yt("div", d4, [Ne(te(fp), { class: "select-listview", hoverable: "" }, { default: qe(() => [(St(true), Yt(Gr, null, hn(d.list, (T) => (St(), Cr(te(pp), { key: T.id, title: T.name, onClick: (M) => g(T.id) }, { prefix: qe(() => [Tt("div", h4, [Ne(te(Ii), { size: "20" }, { default: qe(() => [Ne(te(ub))]), _: 1 })])]), suffix: qe(() => [Ne(te(Vr), { quaternary: "", circle: "", onClick: $d((M) => m(T.id), ["stop"]) }, { icon: qe(() => [Ne(te(Ii), null, { default: qe(() => [Ne(te(up))]), _: 1 })]), _: 1 }, 8, ["onClick"])]), default: qe(() => [Tt("div", f4, [Tt("div", p4, ir(T.name), 1), Tt("div", m4, [(St(true), Yt(Gr, null, hn(T.tags, (M) => (St(), Cr(te(Mo), { key: M, size: "small", type: "info" }, { default: qe(() => [Pr(ir(M.toLocaleUpperCase()), 1)]), _: 2 }, 1024))), 128))])])]), _: 2 }, 1032, ["title", "onClick"]))), 128))]), _: 1 })]));
} }), v4 = go(g4, [["__scopeId", "data-v-dc2c6049"]]), _4 = st({ __name: "SelectorDrawer", props: { active: { type: Boolean, default: () => false }, placement: { type: String, default: () => "right" }, list: { type: Array, default: () => [] } }, emits: ["new", "update:active", "remove", "select", "import"], setup(r, { emit: i }) {
  const { t: l } = Eo(), d = r, f = [{ title: l("sketchEdit.import"), icon: cb, callback: () => {
    s("import");
  }, secondary: true, iconSize: 17, type: "default" }, { title: l("sketchEdit.new"), icon: Ud, callback: () => s("new"), secondary: true, iconSize: 20, type: "default" }, { title: l("sketchEdit.close"), icon: M3, callback: () => {
    g.value = false;
  }, secondary: true, iconSize: 20, type: "error" }], g = Ae(false), m = Ae(d.placement);
  ar(d, () => {
    g.value = d.active, m.value = d.placement;
  }, { deep: true }), ar(g, () => {
    s("update:active", g.value);
  });
  const s = i;
  return (C, T) => (St(), Cr(te(Eb), { show: g.value, "onUpdate:show": T[2] || (T[2] = (M) => g.value = M), width: 502, placement: m.value, "auto-focus": false }, { default: qe(() => [Ne(te(Rb), { title: te(l)("sketchEdit.cartoSketchLibrary") }, { footer: qe(() => [Ne(te(jk), null, { default: qe(() => [(St(), Yt(Gr, null, hn(f, (M) => Ne(te(Vr), { key: M.title, secondary: M.secondary, type: M.type, title: M.title, onClick: M.callback }, { icon: qe(() => [Ne(te(Ii), { size: M.iconSize }, { default: qe(() => [(St(), Cr(Ku(M.icon)))]), _: 2 }, 1032, ["size"])]), _: 2 }, 1032, ["secondary", "type", "title", "onClick"])), 64))]), _: 1 })]), default: qe(() => [Ne(v4, { list: r.list, onRemove: T[0] || (T[0] = (M) => s("remove", M)), onSelect: T[1] || (T[1] = (M) => s("select", M)) }, null, 8, ["list"])]), _: 1 }, 8, ["title"])]), _: 1 }, 8, ["show", "placement"]));
} }), y4 = ["title", "onClick"], Af = 20, b4 = st({ __name: "SketchToolbar", props: { sketchName: {}, draftCount: {}, routeCount: {} }, emits: ["save", "open", "create", "edit-meta"], setup(r, { emit: i }) {
  const { t: l } = Eo(), d = i, f = [{ title: l("sketchEdit.save"), icon: v3, iconSize: Af, callback: () => d("save") }, { title: l("sketchEdit.open"), icon: w3, iconSize: Af, callback: () => d("open") }, { title: l("sketchEdit.newComponent"), icon: Ud, iconSize: Af, callback: () => d("create") }, { title: l("sketchEdit.editMetadata"), icon: iC, iconSize: Af, callback: () => d("edit-meta") }];
  return (g, m) => (St(), Cr(te(f_), { justify: "space-between", align: "center" }, { default: qe(() => [Ne(te(qa), { strong: "" }, { default: qe(() => [Pr(ir(g.sketchName || te(l)("sketchEdit.noSketchSelectedToolbar")), 1)]), _: 1 }), Ne(te(f_), { align: "center" }, { default: qe(() => [g.sketchName !== void 0 ? (St(), Cr(te(Mo), { key: 0, type: "info", size: "small" }, { default: qe(() => [Pr(ir(g.draftCount || 0) + " " + ir(te(l)("sketchEdit.drafts")) + ", " + ir(g.routeCount || 0) + " " + ir(te(l)("sketchEdit.routes")), 1)]), _: 1 })) : Xr("", true), (St(), Yt(Gr, null, hn(f, (s, C) => Tt("div", { key: C, title: s.title, class: "tool-tip-item", onClick: s.callback }, [Ne(te(Ii), { size: s.iconSize }, { default: qe(() => [(St(), Cr(Ku(s.icon)))]), _: 2 }, 1032, ["size"])], 8, y4)), 64))]), _: 1 })]), _: 1 }));
} }), x4 = go(b4, [["__scopeId", "data-v-5b012717"]]), w4 = { key: 0, class: "empty-state" }, C4 = st({ __name: "ComponentList", props: { components: {}, selectedId: {} }, emits: ["select", "delete", "create"], setup(r, { emit: i }) {
  const { t: l } = Eo(), d = i;
  return (f, g) => (St(), Yt(Gr, null, [Ne(te(fp), { hoverable: "" }, { default: qe(() => [(St(true), Yt(Gr, null, hn(f.components, (m) => (St(), Cr(te(pp), { key: m.value, class: bl({ "selected-component": f.selectedId === m.value }), onClick: () => d("select", m.value, m.type) }, { prefix: qe(() => [Ne(te(Ii), { color: m.type === "draft" ? "#007bff" : "#28a745" }, { default: qe(() => [(St(), Cr(Ku(m.type === "draft" ? te(ub) : te(Wg))))]), _: 2 }, 1032, ["color"])]), suffix: qe(() => [Ne(te(m5), { onPositiveClick: (s) => d("delete", m.value, m.type) }, { trigger: qe(() => [Ne(te(Vr), { quaternary: "", circle: "", size: "small" }, { default: qe(() => [Ne(te(Ii), null, { default: qe(() => [Ne(te(up))]), _: 1 })]), _: 1 })]), default: qe(() => [Pr(" " + ir(te(l)("sketchEdit.deleteComponent")), 1)]), _: 1 }, 8, ["onPositiveClick"])]), default: qe(() => [Pr(" " + ir(m.label) + " ", 1)]), _: 2 }, 1032, ["class", "onClick"]))), 128))]), _: 1 }), f.components.length === 0 ? (St(), Yt("div", w4, [Ne(te(qd), { description: te(l)("sketchEdit.noComponentsYet") }, { extra: qe(() => [Ne(te(Vr), { size: "small", onClick: g[0] || (g[0] = (m) => d("create")) }, { default: qe(() => [Pr(ir(te(l)("sketchEdit.createComponent")), 1)]), _: 1 })]), _: 1 }, 8, ["description"])])) : Xr("", true)], 64));
} }), S4 = go(C4, [["__scopeId", "data-v-3addb8a0"]]), k4 = { key: 0, class: "properties-panel" }, P4 = { key: 1, style: { height: "100%", width: "100%", display: "flex", "justify-content": "center", "align-items": "center" } }, T4 = st({ __name: "PropertiesPanel", props: { component: {}, type: {} }, emits: ["updateProperties", "updateMeta"], setup(r, { emit: i }) {
  const { t: l } = Eo(), d = i;
  return (f, g) => f.component ? (St(), Yt("div", k4, [Ne(te(F5), { type: "line", animated: "", "default-value": "properties" }, { default: qe(() => [Ne(te(E_), { name: "properties", tab: te(l)("sketchEdit.properties") }, { default: qe(() => [Ne(te(Wd), null, { default: qe(() => [Ne(te(wn), { label: te(l)("sketchEdit.visible") }, { default: qe(() => [Ne(te(qb), { value: f.component.properties.visible !== false, "onUpdate:value": g[0] || (g[0] = (m) => d("updateProperties", { visible: m })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), f.type === "draft" ? (St(), Yt(Gr, { key: 0 }, [Ne(te(wn), { label: te(l)("sketchEdit.fillColor") }, { default: qe(() => [Ne(te(jm), { value: f.component.properties.fillColor || "#007bff", "show-alpha": false, "onUpdate:value": g[1] || (g[1] = (m) => d("updateProperties", { fillColor: m })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), Ne(te(wn), { label: te(l)("sketchEdit.strokeColor") }, { default: qe(() => [Ne(te(jm), { value: f.component.properties.strokeColor || "#0056b3", "show-alpha": false, "onUpdate:value": g[2] || (g[2] = (m) => d("updateProperties", { strokeColor: m })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), Ne(te(wn), { label: te(l)("sketchEdit.strokeThickness") }, { default: qe(() => [Ne(te(P_), { value: f.component.properties.strokeThickness || 2, min: 1, max: 10, "onUpdate:value": g[3] || (g[3] = (m) => d("updateProperties", { strokeThickness: m ?? void 0 })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"])], 64)) : Xr("", true), f.type === "route" ? (St(), Yt(Gr, { key: 1 }, [Ne(te(wn), { label: te(l)("sketchEdit.strokeColor") }, { default: qe(() => [Ne(te(jm), { value: f.component.properties.strokeColor || "#28a745", "show-alpha": false, "onUpdate:value": g[4] || (g[4] = (m) => d("updateProperties", { strokeColor: m })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), Ne(te(wn), { label: te(l)("sketchEdit.strokeThickness") }, { default: qe(() => [Ne(te(P_), { value: f.component.properties.strokeThickness || 3, min: 1, max: 10, "onUpdate:value": g[5] || (g[5] = (m) => d("updateProperties", { strokeThickness: m ?? void 0 })) }, null, 8, ["value"])]), _: 1 }, 8, ["label"])], 64)) : Xr("", true)]), _: 1 })]), _: 1 }, 8, ["tab"]), Ne(te(E_), { name: "metadata", tab: te(l)("sketchEdit.metadata") }, { default: qe(() => [Ne(te(Wd), null, { default: qe(() => [Ne(te(wn), { label: te(l)("sketchEdit.name") }, { default: qe(() => [Ne(te(ho), { value: f.component.meta.name, "onUpdate:value": g[6] || (g[6] = (m) => {
    var _a3, _b2;
    return d("updateMeta", { name: m, description: ((_a3 = f.component) == null ? void 0 : _a3.meta.description) ?? "", tags: ((_b2 = f.component) == null ? void 0 : _b2.meta.tags) ?? [] });
  }) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), Ne(te(wn), { label: te(l)("sketchEdit.description") }, { default: qe(() => [Ne(te(ho), { value: f.component.meta.description, type: "textarea", rows: 3, "onUpdate:value": g[7] || (g[7] = (m) => {
    var _a3, _b2;
    return d("updateMeta", { name: ((_a3 = f.component) == null ? void 0 : _a3.meta.name) ?? "", description: m, tags: ((_b2 = f.component) == null ? void 0 : _b2.meta.tags) ?? [] });
  }) }, null, 8, ["value"])]), _: 1 }, 8, ["label"]), Ne(te(wn), { label: te(l)("sketchEdit.tags") }, { default: qe(() => [Ne(te(iT), { value: f.component.meta.tags || [], placeholder: te(l)("sketchEdit.addTagPlaceholder"), "onUpdate:value": g[8] || (g[8] = (m) => {
    var _a3, _b2;
    return d("updateMeta", { name: ((_a3 = f.component) == null ? void 0 : _a3.meta.name) ?? "", description: ((_b2 = f.component) == null ? void 0 : _b2.meta.description) ?? "", tags: m });
  }) }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), Ne(te(wn), { label: "UUID" }, { default: qe(() => [Ne(te(ho), { value: f.component.id, style: { "font-family": "monospace" }, readonly: "" }, null, 8, ["value"])]), _: 1 })]), _: 1 })]), _: 1 }, 8, ["tab"])]), _: 1 })])) : (St(), Yt("div", P4, [Ne(te(qd), { description: te(l)("sketchEdit.selectComponentToEdit") }, null, 8, ["description"])]));
} }), I4 = go(T4, [["__scopeId", "data-v-f700b4bc"]]), M4 = "dCeXFrS9lgSF8hm5C6nm", E4 = `https://api.maptiler.com/maps/basic-v2/style.json?key=${M4}`;
function R4() {
  const r = Ae(7), i = Tl(null), l = Ae([0, 0]);
  function d(m) {
    i.value = m.map;
  }
  function f(m) {
    l.value = m, i.value && i.value.setCenter(m);
  }
  function g(m) {
    r.value = m, i.value && i.value.setZoom(m);
  }
  return { zoom: r, map: i, center: l, styleUrl: E4, initMap: d, setCenter: f, setZoom: g };
}
function A4(r, i) {
  const l = [];
  return r.forEach((d) => {
    l.push({ label: d.meta.name, value: d.id, type: "draft" });
  }), i.forEach((d) => {
    l.push({ label: d.meta.name, value: d.id, type: "route" });
  }), l;
}
function D4() {
  return { type: "Polygon", coordinates: [[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]] };
}
function z4() {
  return { fillColor: "#007bff", strokeColor: "#0056b3", strokeThickness: 2 };
}
function F4() {
  return { strokeColor: "#28a745", strokeThickness: 3 };
}
const L4 = { style: { display: "flex", "flex-direction": "row", gap: "8px" } }, B4 = { style: { display: "flex", gap: "8px", "margin-bottom": "8px" } }, O4 = { class: "sketch-edit-container" }, $4 = { class: "grid-layout" }, j4 = { class: "meta-info-section" }, N4 = { class: "metadata-item" }, V4 = { class: "metadata-item" }, U4 = st({ __name: "SketchEdit", props: { liteMode: { type: Boolean }, forceHighDpi: { type: Boolean }, mapType: {}, sketchId: {} }, setup(r) {
  const i = r, { t: l } = Eo(), d = hp(), f = r0(), { zoom: g, styleUrl: m, initMap: s } = R4(), C = Ae(false), T = Ae(null), M = Ae(null), z = Ae(false), L = Ae(""), A = Ae("draft"), O = Ae(false), V = Ae({ name: "", description: "", tags: [], created_by: "", modified_by: "" }), X = Ae(""), W = ze(() => f.currentSketch), K = ze(() => f.currentDrafts), ie = ze(() => {
    var _a3;
    return ((_a3 = W.value) == null ? void 0 : _a3.routes.routes) || [];
  }), ee = ze(() => !!W.value), re = ze(() => !T.value || !M.value ? null : M.value === "draft" ? f.getDraftById(T.value) : f.getRouteById(T.value)), J = ze(() => A4(K.value, ie.value));
  async function Se() {
    if (W.value) try {
      await f.updateSketch(W.value.id, { name: W.value.meta.name, description: W.value.meta.description, tags: W.value.meta.tags }), d.success(l("sketchEdit.saveSuccess"));
    } catch (at) {
      d.error(l("sketchEdit.saveError")), console.error(at);
    }
  }
  async function fe() {
    const at = prompt(l("sketchEdit.enterSketchName"));
    at && (await f.createSketch(at), C.value = false);
  }
  async function oe() {
    if (!(!L.value.trim() || !W.value)) try {
      if (A.value === "draft") {
        const at = await f.addDraft(D4(), z4(), { name: L.value });
        T.value = at.id, M.value = "draft";
      } else {
        const at = await f.addRoute(L.value, F4());
        T.value = at.id, M.value = "route";
      }
      z.value = false, L.value = "", d.success(l("sketchEdit.componentCreated"));
    } catch (at) {
      d.error(l("sketchEdit.componentCreateError")), console.error(at);
    }
  }
  async function he(at, et) {
    try {
      et === "draft" ? await f.deleteDraft(at) : await f.deleteRoute(at), T.value === at && (T.value = null, M.value = null), d.success(l("sketchEdit.componentDeleted"));
    } catch (ht) {
      d.error(l("sketchEdit.componentDeleteError")), console.error(ht);
    }
  }
  async function be(at) {
    if (!(!re.value || !M.value)) try {
      M.value === "draft" ? await f.updateDraft(T.value, { properties: at }) : await f.updateRoute(T.value, { properties: at }), d.success(l("sketchEdit.propertiesUpdated"));
    } catch (et) {
      d.error(l("sketchEdit.propertiesUpdateError")), console.error(et);
    }
  }
  async function je(at) {
    if (!(!re.value || !M.value)) try {
      M.value === "draft" ? await f.updateDraft(T.value, { meta: at }) : await f.updateRoute(T.value, { name: at.name }), d.success(l("sketchEdit.propertiesUpdated"));
    } catch (et) {
      d.error(l("sketchEdit.propertiesUpdateError")), console.error(et);
    }
  }
  function Ve() {
    W.value && (V.value = { name: W.value.meta.name, description: W.value.meta.description, tags: [...W.value.meta.tags], created_by: W.value.meta.created_by, modified_by: W.value.meta.modified_by }, O.value = true);
  }
  function Ke() {
    X.value.trim() && !V.value.tags.includes(X.value.trim()) && (V.value.tags.push(X.value.trim()), X.value = "");
  }
  function lt(at) {
    V.value.tags = V.value.tags.filter((et) => et !== at);
  }
  async function vt() {
    if (W.value) try {
      await f.updateSketch(W.value.id, { name: V.value.name, description: V.value.description, tags: V.value.tags }), O.value = false, d.success(l("sketchEdit.saveSuccess"));
    } catch (at) {
      d.error(l("sketchEdit.saveError")), console.error(at);
    }
  }
  Qi(() => {
    i.sketchId && f.setCurrentSketchId(i.sketchId);
  }), ar(() => f.currentSketchId, (at) => {
    at && (T.value = null, M.value = null);
  });
  const wt = (at) => new Date(at).toLocaleString();
  return (at, et) => (St(), Yt(Gr, null, [Ne(_4, { active: C.value, "onUpdate:active": et[0] || (et[0] = (ht) => C.value = ht), list: te(f).sketches.map((ht) => ({ id: ht.id, name: ht.meta.name, tags: ht.meta.tags })), placement: "right", onNew: fe, onRemove: et[1] || (et[1] = (ht) => te(f).deleteSketch(ht)), onSelect: et[2] || (et[2] = (ht) => te(f).setCurrentSketchId(ht)) }, null, 8, ["active", "list"]), Ne(te(Vd), { show: z.value, "onUpdate:show": et[6] || (et[6] = (ht) => z.value = ht), preset: "dialog", title: te(l)("sketchEdit.createNewComponent") }, { action: qe(() => [Ne(te(Vr), { onClick: et[5] || (et[5] = (ht) => z.value = false) }, { default: qe(() => [Pr(ir(te(l)("sketchEdit.cancel")), 1)]), _: 1 }), Ne(te(Vr), { type: "primary", disabled: !L.value.trim(), onClick: oe }, { default: qe(() => [Pr(ir(te(l)("sketchEdit.create")), 1)]), _: 1 }, 8, ["disabled"])]), default: qe(() => [Ne(te(Wd), null, { default: qe(() => [Tt("div", L4, [Ne(te(wn), { label: te(l)("sketchEdit.name"), style: { "flex-grow": "1" } }, { default: qe(() => [Ne(te(ho), { value: L.value, "onUpdate:value": et[3] || (et[3] = (ht) => L.value = ht), placeholder: te(l)("sketchEdit.enterComponentName") }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), Ne(te(wn), { label: te(l)("sketchEdit.type") }, { default: qe(() => [Ne(te(yg), { value: A.value, "onUpdate:value": et[4] || (et[4] = (ht) => A.value = ht), "consistent-menu-width": false, options: [{ label: te(l)("sketchEdit.draftShape"), value: "draft" }, { label: te(l)("sketchEdit.routePath"), value: "route" }] }, null, 8, ["value", "options"])]), _: 1 }, 8, ["label"])])]), _: 1 })]), _: 1 }, 8, ["show", "title"]), Ne(te(Vd), { show: O.value, "onUpdate:show": et[11] || (et[11] = (ht) => O.value = ht), preset: "dialog", title: te(l)("sketchEdit.editMetadata"), style: { "max-width": "600px" } }, { action: qe(() => [Ne(te(Vr), { onClick: et[10] || (et[10] = (ht) => O.value = false) }, { default: qe(() => [Pr(ir(te(l)("sketchEdit.cancel")), 1)]), _: 1 }), Ne(te(Vr), { type: "primary", disabled: !V.value.name.trim(), onClick: vt }, { default: qe(() => [Pr(ir(te(l)("sketchEdit.save")), 1)]), _: 1 }, 8, ["disabled"])]), default: qe(() => [Ne(te(Wd), null, { default: qe(() => [Ne(te(wn), { label: te(l)("sketchEdit.name") }, { default: qe(() => [Ne(te(ho), { value: V.value.name, "onUpdate:value": et[7] || (et[7] = (ht) => V.value.name = ht), placeholder: te(l)("sketchEdit.sketchNamePlaceholder") }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), Ne(te(wn), { label: te(l)("sketchEdit.description") }, { default: qe(() => [Ne(te(ho), { value: V.value.description, "onUpdate:value": et[8] || (et[8] = (ht) => V.value.description = ht), type: "textarea", placeholder: te(l)("sketchEdit.sketchDescriptionPlaceholder"), rows: 3 }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), Ne(te(wn), { label: te(l)("sketchEdit.tags") }, { default: qe(() => [Tt("div", B4, [Ne(te(ho), { value: X.value, "onUpdate:value": et[9] || (et[9] = (ht) => X.value = ht), placeholder: te(l)("sketchEdit.addTagPlaceholder"), onKeydown: Sy($d(Ke, ["prevent"]), ["enter"]) }, null, 8, ["value", "placeholder", "onKeydown"]), Ne(te(Vr), { onClick: Ke }, { default: qe(() => [Pr(ir(te(l)("sketchEdit.add")), 1)]), _: 1 })]), (St(true), Yt(Gr, null, hn(V.value.tags, (ht) => (St(), Cr(te(Mo), { key: ht, closable: "", style: { "margin-right": "8px", "margin-bottom": "8px" }, onClose: (yt) => lt(ht) }, { default: qe(() => [Pr(ir(ht), 1)]), _: 2 }, 1032, ["onClose"]))), 128)), V.value.tags.length === 0 ? (St(), Cr(te(qd), { key: 0, description: te(l)("sketchEdit.noTags"), size: "small" }, null, 8, ["description"])) : Xr("", true)]), _: 1 }, 8, ["label"])]), _: 1 })]), _: 1 }, 8, ["show", "title"]), Tt("div", O4, [Tt("div", $4, [Tt("div", j4, [Ne(te(Wa), null, { default: qe(() => {
    var _a3;
    return [Ne(x4, { "sketch-name": (_a3 = W.value) == null ? void 0 : _a3.meta.name, "draft-count": K.value.length, "route-count": ie.value.length, onSave: Se, onOpen: et[12] || (et[12] = (ht) => C.value = true), onCreate: et[13] || (et[13] = (ht) => z.value = true), onEditMeta: Ve }, null, 8, ["sketch-name", "draft-count", "route-count"])];
  }), _: 1 })]), Ne(te(M_), { direction: "horizontal", max: 0.8, min: 0.2, "default-size": 0.5, class: "bottom-row-split" }, { 1: qe(() => [Ne(te(M_), { style: { height: "100%" }, direction: "vertical" }, { 1: qe(() => [Ne(te(Wa), { style: { height: "100%" }, title: te(l)("sketchEdit.components"), "content-style": "min-height: 0; overflow-y: auto;" }, { "header-extra": qe(() => [Ne(te(Vr), { quaternary: "", circle: "", onClick: et[16] || (et[16] = (ht) => z.value = true) }, { icon: qe(() => [Ne(te(Ud))]), _: 1 })]), default: qe(() => [Ne(S4, { components: J.value, "selected-id": T.value, onSelect: et[14] || (et[14] = (ht, yt) => {
    T.value = ht, M.value = yt;
  }), onDelete: he, onCreate: et[15] || (et[15] = (ht) => z.value = true) }, null, 8, ["components", "selected-id"])]), _: 1 }, 8, ["title"])]), 2: qe(() => [Ne(te(Wa), { class: "map-container", "content-style": "padding: 0;" }, { default: qe(() => [Ne(te(t1), { "map-style": te(m), center: [0, 0], zoom: te(g), height: "100%", "onMap:load": te(s) }, { default: qe(() => [Ne(te(i1), { position: "top-left" }), Ne(te(o1), { position: "bottom-left" }), Ne(te(r1), { position: "top-left" })]), _: 1 }, 8, ["map-style", "zoom", "onMap:load"])]), _: 1 })]), _: 1 }), ee.value ? Xr("", true) : (St(), Cr(te(qd), { key: 0, description: te(l)("sketchEdit.noSketchSelected"), size: "huge", style: { height: "100%", "justify-content": "center" } }, { icon: qe(() => [Ne(te(Ii), null, { default: qe(() => [Ne(te(nC))]), _: 1 })]), extra: qe(() => [Ne(te(Vr), { size: "small", onClick: et[17] || (et[17] = (ht) => C.value = true) }, { default: qe(() => [Pr(ir(te(l)("sketchEdit.selectSketch")), 1)]), _: 1 })]), _: 1 }, 8, ["description"]))]), 2: qe(() => [Ne(te(Wa), { class: "component-info-container", "content-style": "min-height: 0; overflow: auto;" }, { footer: qe(() => [re.value ? (St(), Cr(te(qa), { key: 0, depth: "3", class: "metadata" }, { default: qe(() => [Tt("div", N4, ir(te(l)("sketchEdit.createdTimeBy", { user: re.value.meta.created_by, time: wt(re.value.meta.creation_timestamp) })), 1), Tt("div", V4, ir(te(l)("sketchEdit.modifiedTimeBy", { user: re.value.meta.modified_by, time: wt(re.value.meta.modification_timestamp) })), 1)]), _: 1 })) : Xr("", true)]), default: qe(() => [Ne(I4, { component: re.value, type: M.value, onUpdateProperties: be, onUpdateMeta: et[18] || (et[18] = (ht) => je(ht)) }, null, 8, ["component", "type"])]), _: 1 })]), _: 1 })])])], 64));
} }), q4 = go(U4, [["__scopeId", "data-v-b8cdd1f5"]]), G4 = { class: "sketch-centre-view" }, W4 = { class: "header" }, Z4 = { class: "title" }, H4 = { class: "card-header" }, X4 = { key: 0, class: "tags" }, Y4 = { class: "card-content" }, K4 = { class: "meta-info" }, J4 = { class: "meta-item" }, Q4 = { class: "meta-item" }, eM = { class: "meta-item" }, tM = { key: 0, class: "empty-state" }, rM = st({ __name: "SketchCentreView", setup(r) {
  oc((oe) => ({ "460cb2d9": te(fe).bodyColor }));
  const { t: i } = Eo(), l = Mb(), d = hp(), f = El(), g = r0(), m = ze(() => g.sketches), s = ze({ get: () => g.currentSketchId, set: (oe) => g.setCurrentSketchId(oe) }), C = (oe) => {
    const he = s.value === oe;
    return { borderColor: he ? f.value.primaryColor : "", borderWidth: he ? "2px" : "1px", padding: he ? "0px" : "1px", zIndex: he ? 0 : 1 };
  }, T = Ae(false), M = Ae(""), z = Ae(""), L = Ae(false), A = Ae(""), O = async () => {
    await g.init();
  }, V = (oe) => new Date(oe).toLocaleDateString(), X = (oe) => oe.routes.routes.length, W = (oe) => oe.drafts.drafts.length, K = (oe) => {
    g.setCurrentSketchId(oe);
  }, ie = (oe) => {
    A.value = oe, L.value = true;
  }, ee = async () => {
    if (!M.value.trim()) {
      d.error(i("sketchCentreView.nameRequired"));
      return;
    }
    const oe = await g.createSketch(M.value);
    await g.updateSketch(oe.id, { description: z.value }), g.setCurrentSketchId(oe.id), T.value = false, M.value = "", z.value = "", d.success(i("sketchCentreView.sketchCreated"));
  }, re = (oe) => {
    const he = m.value.find((be) => be.id === oe);
    he && l.warning({ title: i("sketchCentreView.deleteConfirmation.title"), content: i("sketchCentreView.deleteConfirmation.prompt", { name: he.meta.name }), positiveText: i("sketchCentreView.deleteConfirmation.yes"), negativeText: i("sketchCentreView.deleteConfirmation.no"), onPositiveClick: async () => {
      await g.deleteSketch(oe), d.success(i("sketchCentreView.sketchDeleted"));
    } });
  }, { width: J } = Hy(), Se = ze(() => Math.floor(J.value / 360));
  Qi(() => {
    O();
  });
  const fe = El();
  return (oe, he) => (St(), Yt("div", G4, [Tt("div", W4, [Tt("h1", Z4, ir(te(i)("sketchCentreView.title")), 1), Ne(te(Vr), { type: "primary", secondary: "", circle: "", onClick: he[0] || (he[0] = (be) => T.value = true) }, { icon: qe(() => [Ne(te(Ii), null, { default: qe(() => [Ne(te(Ud))]), _: 1 })]), _: 1 })]), Ne(te(YT), { cols: Se.value, "x-gap": 16, "y-gap": 16, responsive: "screen" }, { default: qe(() => [(St(true), Yt(Gr, null, hn(m.value, (be) => (St(), Cr(te(ZT), { key: be.id }, { default: qe(() => [Ne(te(Wa), { class: bl(["sketch-card", { selected: s.value === be.id }]), style: gs(C(be.id)), hoverable: "", bordered: "", clickable: "", onClick: (je) => K(be.id) }, { header: qe(() => [Tt("div", H4, [Ne(te(qa), { class: "sketch-name" }, { default: qe(() => [Pr(ir(be.meta.name), 1)]), _: 2 }, 1024), be.meta.tags.length > 0 ? (St(), Yt("div", X4, [(St(true), Yt(Gr, null, hn(be.meta.tags.slice(0, 3), (je) => (St(), Cr(te(Mo), { key: je, size: "small", round: "", type: "info" }, { default: qe(() => [Pr(ir(je.toLocaleUpperCase()), 1)]), _: 2 }, 1024))), 128)), be.meta.tags.length > 3 ? (St(), Cr(te(Mo), { key: 0, size: "small", round: "", type: "info" }, { default: qe(() => [Pr(" +" + ir(be.meta.tags.length - 3), 1)]), _: 2 }, 1024)) : Xr("", true)])) : Xr("", true)])]), "header-extra": qe(() => [Ne(te(_l), null, { default: qe(() => [Ne(te(Vr), { quaternary: "", circle: "", size: "small", onClick: $d((je) => ie(be.id), ["stop"]) }, { icon: qe(() => [Ne(te(Ii), null, { default: qe(() => [Ne(te(y3))]), _: 1 })]), _: 1 }, 8, ["onClick"]), Ne(te(Vr), { quaternary: "", circle: "", size: "small", onClick: $d((je) => re(be.id), ["stop"]) }, { icon: qe(() => [Ne(te(Ii), null, { default: qe(() => [Ne(te(up))]), _: 1 })]), _: 1 }, 8, ["onClick"])]), _: 2 }, 1024)]), default: qe(() => [Tt("div", Y4, [Ne(te(qa), { depth: "3", class: "description" }, { default: qe(() => [Pr(ir(be.meta.description || te(i)("sketchCentreView.noDescription")), 1)]), _: 2 }, 1024), Tt("div", K4, [Tt("div", J4, [Ne(te(Ii), { size: 16 }, { default: qe(() => [Ne(te(m3))]), _: 1 }), Ne(te(qa), { depth: "3", style: { "font-size": "12px" } }, { default: qe(() => [Pr(ir(V(be.meta.creation_timestamp)), 1)]), _: 2 }, 1024)]), Tt("div", Q4, [Ne(te(Ii), { size: 16 }, { default: qe(() => [Ne(te(Wg))]), _: 1 }), Ne(te(qa), { depth: "3", style: { "font-size": "12px" } }, { default: qe(() => [Pr(ir(X(be)) + " " + ir(te(i)("sketchCentreView.routes")), 1)]), _: 2 }, 1024)]), Tt("div", eM, [Ne(te(Ii), { size: 16 }, { default: qe(() => [Ne(te(lb))]), _: 1 }), Ne(te(qa), { depth: "3", style: { "font-size": "12px" } }, { default: qe(() => [Pr(ir(W(be)) + " " + ir(te(i)("sketchCentreView.drafts")), 1)]), _: 2 }, 1024)])])])]), _: 2 }, 1032, ["class", "style", "onClick"])]), _: 2 }, 1024))), 128))]), _: 1 }, 8, ["cols"]), m.value.length === 0 ? (St(), Yt("div", tM, [Ne(te(Ii), { size: "48", depth: "3" }, { default: qe(() => [Ne(te(Zy))]), _: 1 }), Ne(te(qa), { depth: "3" }, { default: qe(() => [Pr(ir(te(i)("sketchCentreView.emptyState")), 1)]), _: 1 }), Ne(te(Vr), { type: "primary", onClick: he[1] || (he[1] = (be) => T.value = true) }, { icon: qe(() => [Ne(te(Ii), null, { default: qe(() => [Ne(te(Ud))]), _: 1 })]), default: qe(() => [Pr(" " + ir(te(i)("sketchCentreView.createFirstSketch")), 1)]), _: 1 })])) : Xr("", true), Ne(te(Vd), { show: T.value, "onUpdate:show": he[5] || (he[5] = (be) => T.value = be), "mask-closable": true, preset: "card", style: { "max-width": "500px" }, title: te(i)("sketchCentreView.newSketch") }, { footer: qe(() => [Ne(te(_l), { justify: "end" }, { default: qe(() => [Ne(te(Vr), { onClick: he[4] || (he[4] = (be) => T.value = false) }, { default: qe(() => [Pr(ir(te(i)("sketchCentreView.cancel")), 1)]), _: 1 }), Ne(te(Vr), { type: "primary", onClick: ee }, { default: qe(() => [Pr(ir(te(i)("sketchCentreView.create")), 1)]), _: 1 })]), _: 1 })]), default: qe(() => [Ne(te(Wd), { model: { name: M.value, description: z.value }, "label-placement": "top", "require-mark-placement": "right-hanging" }, { default: qe(() => [Ne(te(wn), { label: te(i)("sketchCentreView.sketchName"), required: "" }, { default: qe(() => [Ne(te(ho), { value: M.value, "onUpdate:value": he[2] || (he[2] = (be) => M.value = be), placeholder: te(i)("sketchCentreView.sketchNamePlaceholder") }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"]), Ne(te(wn), { label: te(i)("sketchCentreView.description") }, { default: qe(() => [Ne(te(ho), { value: z.value, "onUpdate:value": he[3] || (he[3] = (be) => z.value = be), type: "textarea", placeholder: te(i)("sketchCentreView.sketchDescriptionPlaceholder"), autosize: { minRows: 3, maxRows: 5 } }, null, 8, ["value", "placeholder"])]), _: 1 }, 8, ["label"])]), _: 1 }, 8, ["model"])]), _: 1 }, 8, ["show", "title"]), Ne(te(Eb), { show: L.value, "onUpdate:show": he[6] || (he[6] = (be) => L.value = be), width: 800, placement: "right", "display-directive": "show", height: "100%" }, { default: qe(() => [Ne(te(Rb), { title: te(i)("sketchCentreView.editSketch"), closable: "", "body-content-style": { padding: 0, height: "100%" } }, { default: qe(() => [A.value ? (St(), Cr(q4, { key: 0, "sketch-id": A.value }, null, 8, ["sketch-id"])) : Xr("", true)]), _: 1 }, 8, ["title"])]), _: 1 }, 8, ["show"])]));
} }), _1 = go(rM, [["__scopeId", "data-v-00cdfd4b"]]), iM = Object.freeze(Object.defineProperty({ __proto__: null, default: _1 }, Symbol.toStringTag, { value: "Module" })), ry = {};
function nM(r) {
  let i = ry[r];
  if (i) return i;
  i = ry[r] = [];
  for (let l = 0; l < 128; l++) {
    const d = String.fromCharCode(l);
    i.push(d);
  }
  for (let l = 0; l < r.length; l++) {
    const d = r.charCodeAt(l);
    i[d] = "%" + ("0" + d.toString(16).toUpperCase()).slice(-2);
  }
  return i;
}
function ic(r, i) {
  typeof i != "string" && (i = ic.defaultChars);
  const l = nM(i);
  return r.replace(/(%[a-f0-9]{2})+/gi, function(d) {
    let f = "";
    for (let g = 0, m = d.length; g < m; g += 3) {
      const s = parseInt(d.slice(g + 1, g + 3), 16);
      if (s < 128) {
        f += l[s];
        continue;
      }
      if ((s & 224) === 192 && g + 3 < m) {
        const C = parseInt(d.slice(g + 4, g + 6), 16);
        if ((C & 192) === 128) {
          const T = s << 6 & 1984 | C & 63;
          T < 128 ? f += "\uFFFD\uFFFD" : f += String.fromCharCode(T), g += 3;
          continue;
        }
      }
      if ((s & 240) === 224 && g + 6 < m) {
        const C = parseInt(d.slice(g + 4, g + 6), 16), T = parseInt(d.slice(g + 7, g + 9), 16);
        if ((C & 192) === 128 && (T & 192) === 128) {
          const M = s << 12 & 61440 | C << 6 & 4032 | T & 63;
          M < 2048 || M >= 55296 && M <= 57343 ? f += "\uFFFD\uFFFD\uFFFD" : f += String.fromCharCode(M), g += 6;
          continue;
        }
      }
      if ((s & 248) === 240 && g + 9 < m) {
        const C = parseInt(d.slice(g + 4, g + 6), 16), T = parseInt(d.slice(g + 7, g + 9), 16), M = parseInt(d.slice(g + 10, g + 12), 16);
        if ((C & 192) === 128 && (T & 192) === 128 && (M & 192) === 128) {
          let z = s << 18 & 1835008 | C << 12 & 258048 | T << 6 & 4032 | M & 63;
          z < 65536 || z > 1114111 ? f += "\uFFFD\uFFFD\uFFFD\uFFFD" : (z -= 65536, f += String.fromCharCode(55296 + (z >> 10), 56320 + (z & 1023))), g += 9;
          continue;
        }
      }
      f += "\uFFFD";
    }
    return f;
  });
}
ic.defaultChars = ";/?:@&=+$,#";
ic.componentChars = "";
const iy = {};
function oM(r) {
  let i = iy[r];
  if (i) return i;
  i = iy[r] = [];
  for (let l = 0; l < 128; l++) {
    const d = String.fromCharCode(l);
    /^[0-9a-z]$/i.test(d) ? i.push(d) : i.push("%" + ("0" + l.toString(16).toUpperCase()).slice(-2));
  }
  for (let l = 0; l < r.length; l++) i[r.charCodeAt(l)] = r[l];
  return i;
}
function sh(r, i, l) {
  typeof i != "string" && (l = i, i = sh.defaultChars), typeof l > "u" && (l = true);
  const d = oM(i);
  let f = "";
  for (let g = 0, m = r.length; g < m; g++) {
    const s = r.charCodeAt(g);
    if (l && s === 37 && g + 2 < m && /^[0-9a-f]{2}$/i.test(r.slice(g + 1, g + 3))) {
      f += r.slice(g, g + 3), g += 2;
      continue;
    }
    if (s < 128) {
      f += d[s];
      continue;
    }
    if (s >= 55296 && s <= 57343) {
      if (s >= 55296 && s <= 56319 && g + 1 < m) {
        const C = r.charCodeAt(g + 1);
        if (C >= 56320 && C <= 57343) {
          f += encodeURIComponent(r[g] + r[g + 1]), g++;
          continue;
        }
      }
      f += "%EF%BF%BD";
      continue;
    }
    f += encodeURIComponent(r[g]);
  }
  return f;
}
sh.defaultChars = ";/?:@&=+$,-_.!~*'()#";
sh.componentChars = "-_.!~*'()";
function i0(r) {
  let i = "";
  return i += r.protocol || "", i += r.slashes ? "//" : "", i += r.auth ? r.auth + "@" : "", r.hostname && r.hostname.indexOf(":") !== -1 ? i += "[" + r.hostname + "]" : i += r.hostname || "", i += r.port ? ":" + r.port : "", i += r.pathname || "", i += r.search || "", i += r.hash || "", i;
}
function Kf() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
const aM = /^([a-z0-9.+-]+:)/i, sM = /:[0-9]*$/, lM = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, uM = ["<", ">", '"', "`", " ", "\r", `
`, "	"], cM = ["{", "}", "|", "\\", "^", "`"].concat(uM), dM = ["'"].concat(cM), ny = ["%", "/", "?", ";", "#"].concat(dM), oy = ["/", "?", "#"], hM = 255, ay = /^[+a-z0-9A-Z_-]{0,63}$/, fM = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, sy = { javascript: true, "javascript:": true }, ly = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
function n0(r, i) {
  if (r && r instanceof Kf) return r;
  const l = new Kf();
  return l.parse(r, i), l;
}
Kf.prototype.parse = function(r, i) {
  let l, d, f, g = r;
  if (g = g.trim(), !i && r.split("#").length === 1) {
    const T = lM.exec(g);
    if (T) return this.pathname = T[1], T[2] && (this.search = T[2]), this;
  }
  let m = aM.exec(g);
  if (m && (m = m[0], l = m.toLowerCase(), this.protocol = m, g = g.substr(m.length)), (i || m || g.match(/^\/\/[^@\/]+@[^@\/]+/)) && (f = g.substr(0, 2) === "//", f && !(m && sy[m]) && (g = g.substr(2), this.slashes = true)), !sy[m] && (f || m && !ly[m])) {
    let T = -1;
    for (let O = 0; O < oy.length; O++) d = g.indexOf(oy[O]), d !== -1 && (T === -1 || d < T) && (T = d);
    let M, z;
    T === -1 ? z = g.lastIndexOf("@") : z = g.lastIndexOf("@", T), z !== -1 && (M = g.slice(0, z), g = g.slice(z + 1), this.auth = M), T = -1;
    for (let O = 0; O < ny.length; O++) d = g.indexOf(ny[O]), d !== -1 && (T === -1 || d < T) && (T = d);
    T === -1 && (T = g.length), g[T - 1] === ":" && T--;
    const L = g.slice(0, T);
    g = g.slice(T), this.parseHost(L), this.hostname = this.hostname || "";
    const A = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!A) {
      const O = this.hostname.split(/\./);
      for (let V = 0, X = O.length; V < X; V++) {
        const W = O[V];
        if (W && !W.match(ay)) {
          let K = "";
          for (let ie = 0, ee = W.length; ie < ee; ie++) W.charCodeAt(ie) > 127 ? K += "x" : K += W[ie];
          if (!K.match(ay)) {
            const ie = O.slice(0, V), ee = O.slice(V + 1), re = W.match(fM);
            re && (ie.push(re[1]), ee.unshift(re[2])), ee.length && (g = ee.join(".") + g), this.hostname = ie.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > hM && (this.hostname = ""), A && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  const s = g.indexOf("#");
  s !== -1 && (this.hash = g.substr(s), g = g.slice(0, s));
  const C = g.indexOf("?");
  return C !== -1 && (this.search = g.substr(C), g = g.slice(0, C)), g && (this.pathname = g), ly[l] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
Kf.prototype.parseHost = function(r) {
  let i = sM.exec(r);
  i && (i = i[0], i !== ":" && (this.port = i.substr(1)), r = r.substr(0, r.length - i.length)), r && (this.hostname = r);
};
const pM = Object.freeze(Object.defineProperty({ __proto__: null, decode: ic, encode: sh, format: i0, parse: n0 }, Symbol.toStringTag, { value: "Module" })), y1 = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, b1 = /[\0-\x1F\x7F-\x9F]/, mM = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/, o0 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, x1 = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/, w1 = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, gM = Object.freeze(Object.defineProperty({ __proto__: null, Any: y1, Cc: b1, Cf: mM, P: o0, S: x1, Z: w1 }, Symbol.toStringTag, { value: "Module" })), vM = new Uint16Array('\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((r) => r.charCodeAt(0))), _M = new Uint16Array("\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((r) => r.charCodeAt(0)));
var eg;
const yM = /* @__PURE__ */ new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]), bM = (eg = String.fromCodePoint) !== null && eg !== void 0 ? eg : function(r) {
  let i = "";
  return r > 65535 && (r -= 65536, i += String.fromCharCode(r >>> 10 & 1023 | 55296), r = 56320 | r & 1023), i += String.fromCharCode(r), i;
};
function xM(r) {
  var i;
  return r >= 55296 && r <= 57343 || r > 1114111 ? 65533 : (i = yM.get(r)) !== null && i !== void 0 ? i : r;
}
var dn;
(function(r) {
  r[r.NUM = 35] = "NUM", r[r.SEMI = 59] = "SEMI", r[r.EQUALS = 61] = "EQUALS", r[r.ZERO = 48] = "ZERO", r[r.NINE = 57] = "NINE", r[r.LOWER_A = 97] = "LOWER_A", r[r.LOWER_F = 102] = "LOWER_F", r[r.LOWER_X = 120] = "LOWER_X", r[r.LOWER_Z = 122] = "LOWER_Z", r[r.UPPER_A = 65] = "UPPER_A", r[r.UPPER_F = 70] = "UPPER_F", r[r.UPPER_Z = 90] = "UPPER_Z";
})(dn || (dn = {}));
const wM = 32;
var bs;
(function(r) {
  r[r.VALUE_LENGTH = 49152] = "VALUE_LENGTH", r[r.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", r[r.JUMP_TABLE = 127] = "JUMP_TABLE";
})(bs || (bs = {}));
function Fg(r) {
  return r >= dn.ZERO && r <= dn.NINE;
}
function CM(r) {
  return r >= dn.UPPER_A && r <= dn.UPPER_F || r >= dn.LOWER_A && r <= dn.LOWER_F;
}
function SM(r) {
  return r >= dn.UPPER_A && r <= dn.UPPER_Z || r >= dn.LOWER_A && r <= dn.LOWER_Z || Fg(r);
}
function kM(r) {
  return r === dn.EQUALS || SM(r);
}
var un;
(function(r) {
  r[r.EntityStart = 0] = "EntityStart", r[r.NumericStart = 1] = "NumericStart", r[r.NumericDecimal = 2] = "NumericDecimal", r[r.NumericHex = 3] = "NumericHex", r[r.NamedEntity = 4] = "NamedEntity";
})(un || (un = {}));
var ys;
(function(r) {
  r[r.Legacy = 0] = "Legacy", r[r.Strict = 1] = "Strict", r[r.Attribute = 2] = "Attribute";
})(ys || (ys = {}));
class PM {
  constructor(i, l, d) {
    this.decodeTree = i, this.emitCodePoint = l, this.errors = d, this.state = un.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = ys.Strict;
  }
  startEntity(i) {
    this.decodeMode = i, this.state = un.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  write(i, l) {
    switch (this.state) {
      case un.EntityStart:
        return i.charCodeAt(l) === dn.NUM ? (this.state = un.NumericStart, this.consumed += 1, this.stateNumericStart(i, l + 1)) : (this.state = un.NamedEntity, this.stateNamedEntity(i, l));
      case un.NumericStart:
        return this.stateNumericStart(i, l);
      case un.NumericDecimal:
        return this.stateNumericDecimal(i, l);
      case un.NumericHex:
        return this.stateNumericHex(i, l);
      case un.NamedEntity:
        return this.stateNamedEntity(i, l);
    }
  }
  stateNumericStart(i, l) {
    return l >= i.length ? -1 : (i.charCodeAt(l) | wM) === dn.LOWER_X ? (this.state = un.NumericHex, this.consumed += 1, this.stateNumericHex(i, l + 1)) : (this.state = un.NumericDecimal, this.stateNumericDecimal(i, l));
  }
  addToNumericResult(i, l, d, f) {
    if (l !== d) {
      const g = d - l;
      this.result = this.result * Math.pow(f, g) + parseInt(i.substr(l, g), f), this.consumed += g;
    }
  }
  stateNumericHex(i, l) {
    const d = l;
    for (; l < i.length; ) {
      const f = i.charCodeAt(l);
      if (Fg(f) || CM(f)) l += 1;
      else return this.addToNumericResult(i, d, l, 16), this.emitNumericEntity(f, 3);
    }
    return this.addToNumericResult(i, d, l, 16), -1;
  }
  stateNumericDecimal(i, l) {
    const d = l;
    for (; l < i.length; ) {
      const f = i.charCodeAt(l);
      if (Fg(f)) l += 1;
      else return this.addToNumericResult(i, d, l, 10), this.emitNumericEntity(f, 2);
    }
    return this.addToNumericResult(i, d, l, 10), -1;
  }
  emitNumericEntity(i, l) {
    var d;
    if (this.consumed <= l) return (d = this.errors) === null || d === void 0 || d.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (i === dn.SEMI) this.consumed += 1;
    else if (this.decodeMode === ys.Strict) return 0;
    return this.emitCodePoint(xM(this.result), this.consumed), this.errors && (i !== dn.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  stateNamedEntity(i, l) {
    const { decodeTree: d } = this;
    let f = d[this.treeIndex], g = (f & bs.VALUE_LENGTH) >> 14;
    for (; l < i.length; l++, this.excess++) {
      const m = i.charCodeAt(l);
      if (this.treeIndex = TM(d, f, this.treeIndex + Math.max(1, g), m), this.treeIndex < 0) return this.result === 0 || this.decodeMode === ys.Attribute && (g === 0 || kM(m)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (f = d[this.treeIndex], g = (f & bs.VALUE_LENGTH) >> 14, g !== 0) {
        if (m === dn.SEMI) return this.emitNamedEntityData(this.treeIndex, g, this.consumed + this.excess);
        this.decodeMode !== ys.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  emitNotTerminatedNamedEntity() {
    var i;
    const { result: l, decodeTree: d } = this, f = (d[l] & bs.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(l, f, this.consumed), (i = this.errors) === null || i === void 0 || i.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  emitNamedEntityData(i, l, d) {
    const { decodeTree: f } = this;
    return this.emitCodePoint(l === 1 ? f[i] & ~bs.VALUE_LENGTH : f[i + 1], d), l === 3 && this.emitCodePoint(f[i + 2], d), d;
  }
  end() {
    var i;
    switch (this.state) {
      case un.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== ys.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case un.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case un.NumericHex:
        return this.emitNumericEntity(0, 3);
      case un.NumericStart:
        return (i = this.errors) === null || i === void 0 || i.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case un.EntityStart:
        return 0;
    }
  }
}
function C1(r) {
  let i = "";
  const l = new PM(r, (d) => i += bM(d));
  return function(f, g) {
    let m = 0, s = 0;
    for (; (s = f.indexOf("&", s)) >= 0; ) {
      i += f.slice(m, s), l.startEntity(g);
      const T = l.write(f, s + 1);
      if (T < 0) {
        m = s + l.end();
        break;
      }
      m = s + T, s = T === 0 ? m + 1 : m;
    }
    const C = i + f.slice(m);
    return i = "", C;
  };
}
function TM(r, i, l, d) {
  const f = (i & bs.BRANCH_LENGTH) >> 7, g = i & bs.JUMP_TABLE;
  if (f === 0) return g !== 0 && d === g ? l : -1;
  if (g) {
    const C = d - g;
    return C < 0 || C >= f ? -1 : r[l + C] - 1;
  }
  let m = l, s = m + f - 1;
  for (; m <= s; ) {
    const C = m + s >>> 1, T = r[C];
    if (T < d) m = C + 1;
    else if (T > d) s = C - 1;
    else return r[C + f];
  }
  return -1;
}
const IM = C1(vM);
C1(_M);
function S1(r, i = ys.Legacy) {
  return IM(r, i);
}
function MM(r) {
  return Object.prototype.toString.call(r);
}
function a0(r) {
  return MM(r) === "[object String]";
}
const EM = Object.prototype.hasOwnProperty;
function RM(r, i) {
  return EM.call(r, i);
}
function gp(r) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(l) {
    if (l) {
      if (typeof l != "object") throw new TypeError(l + "must be object");
      Object.keys(l).forEach(function(d) {
        r[d] = l[d];
      });
    }
  }), r;
}
function k1(r, i, l) {
  return [].concat(r.slice(0, i), l, r.slice(i + 1));
}
function s0(r) {
  return !(r >= 55296 && r <= 57343 || r >= 64976 && r <= 65007 || (r & 65535) === 65535 || (r & 65535) === 65534 || r >= 0 && r <= 8 || r === 11 || r >= 14 && r <= 31 || r >= 127 && r <= 159 || r > 1114111);
}
function Jf(r) {
  if (r > 65535) {
    r -= 65536;
    const i = 55296 + (r >> 10), l = 56320 + (r & 1023);
    return String.fromCharCode(i, l);
  }
  return String.fromCharCode(r);
}
const P1 = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g, AM = /&([a-z#][a-z0-9]{1,31});/gi, DM = new RegExp(P1.source + "|" + AM.source, "gi"), zM = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function FM(r, i) {
  if (i.charCodeAt(0) === 35 && zM.test(i)) {
    const d = i[1].toLowerCase() === "x" ? parseInt(i.slice(2), 16) : parseInt(i.slice(1), 10);
    return s0(d) ? Jf(d) : r;
  }
  const l = S1(r);
  return l !== r ? l : r;
}
function LM(r) {
  return r.indexOf("\\") < 0 ? r : r.replace(P1, "$1");
}
function nc(r) {
  return r.indexOf("\\") < 0 && r.indexOf("&") < 0 ? r : r.replace(DM, function(i, l, d) {
    return l || FM(i, d);
  });
}
const BM = /[&<>"]/, OM = /[&<>"]/g, $M = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" };
function jM(r) {
  return $M[r];
}
function Cs(r) {
  return BM.test(r) ? r.replace(OM, jM) : r;
}
const NM = /[.?*+^$[\]\\(){}|-]/g;
function VM(r) {
  return r.replace(NM, "\\$&");
}
function yi(r) {
  switch (r) {
    case 9:
    case 32:
      return true;
  }
  return false;
}
function Xd(r) {
  if (r >= 8192 && r <= 8202) return true;
  switch (r) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return true;
  }
  return false;
}
function Yd(r) {
  return o0.test(r) || x1.test(r);
}
function Kd(r) {
  switch (r) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function vp(r) {
  return r = r.trim().replace(/\s+/g, " "), "\u1E9E".toLowerCase() === "\u1E7E" && (r = r.replace(//g, "\xDF")), r.toLowerCase().toUpperCase();
}
const UM = { mdurl: pM, ucmicro: gM }, qM = Object.freeze(Object.defineProperty({ __proto__: null, arrayReplaceAt: k1, assign: gp, escapeHtml: Cs, escapeRE: VM, fromCodePoint: Jf, has: RM, isMdAsciiPunct: Kd, isPunctChar: Yd, isSpace: yi, isString: a0, isValidEntityCode: s0, isWhiteSpace: Xd, lib: UM, normalizeReference: vp, unescapeAll: nc, unescapeMd: LM }, Symbol.toStringTag, { value: "Module" }));
function GM(r, i, l) {
  let d, f, g, m;
  const s = r.posMax, C = r.pos;
  for (r.pos = i + 1, d = 1; r.pos < s; ) {
    if (g = r.src.charCodeAt(r.pos), g === 93 && (d--, d === 0)) {
      f = true;
      break;
    }
    if (m = r.pos, r.md.inline.skipToken(r), g === 91) {
      if (m === r.pos - 1) d++;
      else if (l) return r.pos = C, -1;
    }
  }
  let T = -1;
  return f && (T = r.pos), r.pos = C, T;
}
function WM(r, i, l) {
  let d, f = i;
  const g = { ok: false, pos: 0, str: "" };
  if (r.charCodeAt(f) === 60) {
    for (f++; f < l; ) {
      if (d = r.charCodeAt(f), d === 10 || d === 60) return g;
      if (d === 62) return g.pos = f + 1, g.str = nc(r.slice(i + 1, f)), g.ok = true, g;
      if (d === 92 && f + 1 < l) {
        f += 2;
        continue;
      }
      f++;
    }
    return g;
  }
  let m = 0;
  for (; f < l && (d = r.charCodeAt(f), !(d === 32 || d < 32 || d === 127)); ) {
    if (d === 92 && f + 1 < l) {
      if (r.charCodeAt(f + 1) === 32) break;
      f += 2;
      continue;
    }
    if (d === 40 && (m++, m > 32)) return g;
    if (d === 41) {
      if (m === 0) break;
      m--;
    }
    f++;
  }
  return i === f || m !== 0 || (g.str = nc(r.slice(i, f)), g.pos = f, g.ok = true), g;
}
function ZM(r, i, l, d) {
  let f, g = i;
  const m = { ok: false, can_continue: false, pos: 0, str: "", marker: 0 };
  if (d) m.str = d.str, m.marker = d.marker;
  else {
    if (g >= l) return m;
    let s = r.charCodeAt(g);
    if (s !== 34 && s !== 39 && s !== 40) return m;
    i++, g++, s === 40 && (s = 41), m.marker = s;
  }
  for (; g < l; ) {
    if (f = r.charCodeAt(g), f === m.marker) return m.pos = g + 1, m.str += nc(r.slice(i, g)), m.ok = true, m;
    if (f === 40 && m.marker === 41) return m;
    f === 92 && g + 1 < l && g++, g++;
  }
  return m.can_continue = true, m.str += nc(r.slice(i, g)), m;
}
const HM = Object.freeze(Object.defineProperty({ __proto__: null, parseLinkDestination: WM, parseLinkLabel: GM, parseLinkTitle: ZM }, Symbol.toStringTag, { value: "Module" })), _a2 = {};
_a2.code_inline = function(r, i, l, d, f) {
  const g = r[i];
  return "<code" + f.renderAttrs(g) + ">" + Cs(g.content) + "</code>";
};
_a2.code_block = function(r, i, l, d, f) {
  const g = r[i];
  return "<pre" + f.renderAttrs(g) + "><code>" + Cs(r[i].content) + `</code></pre>
`;
};
_a2.fence = function(r, i, l, d, f) {
  const g = r[i], m = g.info ? nc(g.info).trim() : "";
  let s = "", C = "";
  if (m) {
    const M = m.split(/(\s+)/g);
    s = M[0], C = M.slice(2).join("");
  }
  let T;
  if (l.highlight ? T = l.highlight(g.content, s, C) || Cs(g.content) : T = Cs(g.content), T.indexOf("<pre") === 0) return T + `
`;
  if (m) {
    const M = g.attrIndex("class"), z = g.attrs ? g.attrs.slice() : [];
    M < 0 ? z.push(["class", l.langPrefix + s]) : (z[M] = z[M].slice(), z[M][1] += " " + l.langPrefix + s);
    const L = { attrs: z };
    return `<pre><code${f.renderAttrs(L)}>${T}</code></pre>
`;
  }
  return `<pre><code${f.renderAttrs(g)}>${T}</code></pre>
`;
};
_a2.image = function(r, i, l, d, f) {
  const g = r[i];
  return g.attrs[g.attrIndex("alt")][1] = f.renderInlineAsText(g.children, l, d), f.renderToken(r, i, l);
};
_a2.hardbreak = function(r, i, l) {
  return l.xhtmlOut ? `<br />
` : `<br>
`;
};
_a2.softbreak = function(r, i, l) {
  return l.breaks ? l.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
_a2.text = function(r, i) {
  return Cs(r[i].content);
};
_a2.html_block = function(r, i) {
  return r[i].content;
};
_a2.html_inline = function(r, i) {
  return r[i].content;
};
function cc() {
  this.rules = gp({}, _a2);
}
cc.prototype.renderAttrs = function(i) {
  let l, d, f;
  if (!i.attrs) return "";
  for (f = "", l = 0, d = i.attrs.length; l < d; l++) f += " " + Cs(i.attrs[l][0]) + '="' + Cs(i.attrs[l][1]) + '"';
  return f;
};
cc.prototype.renderToken = function(i, l, d) {
  const f = i[l];
  let g = "";
  if (f.hidden) return "";
  f.block && f.nesting !== -1 && l && i[l - 1].hidden && (g += `
`), g += (f.nesting === -1 ? "</" : "<") + f.tag, g += this.renderAttrs(f), f.nesting === 0 && d.xhtmlOut && (g += " /");
  let m = false;
  if (f.block && (m = true, f.nesting === 1 && l + 1 < i.length)) {
    const s = i[l + 1];
    (s.type === "inline" || s.hidden || s.nesting === -1 && s.tag === f.tag) && (m = false);
  }
  return g += m ? `>
` : ">", g;
};
cc.prototype.renderInline = function(r, i, l) {
  let d = "";
  const f = this.rules;
  for (let g = 0, m = r.length; g < m; g++) {
    const s = r[g].type;
    typeof f[s] < "u" ? d += f[s](r, g, i, l, this) : d += this.renderToken(r, g, i);
  }
  return d;
};
cc.prototype.renderInlineAsText = function(r, i, l) {
  let d = "";
  for (let f = 0, g = r.length; f < g; f++) switch (r[f].type) {
    case "text":
      d += r[f].content;
      break;
    case "image":
      d += this.renderInlineAsText(r[f].children, i, l);
      break;
    case "html_inline":
    case "html_block":
      d += r[f].content;
      break;
    case "softbreak":
    case "hardbreak":
      d += `
`;
      break;
  }
  return d;
};
cc.prototype.render = function(r, i, l) {
  let d = "";
  const f = this.rules;
  for (let g = 0, m = r.length; g < m; g++) {
    const s = r[g].type;
    s === "inline" ? d += this.renderInline(r[g].children, i, l) : typeof f[s] < "u" ? d += f[s](r, g, i, l, this) : d += this.renderToken(r, g, i, l);
  }
  return d;
};
function Yn() {
  this.__rules__ = [], this.__cache__ = null;
}
Yn.prototype.__find__ = function(r) {
  for (let i = 0; i < this.__rules__.length; i++) if (this.__rules__[i].name === r) return i;
  return -1;
};
Yn.prototype.__compile__ = function() {
  const r = this, i = [""];
  r.__rules__.forEach(function(l) {
    l.enabled && l.alt.forEach(function(d) {
      i.indexOf(d) < 0 && i.push(d);
    });
  }), r.__cache__ = {}, i.forEach(function(l) {
    r.__cache__[l] = [], r.__rules__.forEach(function(d) {
      d.enabled && (l && d.alt.indexOf(l) < 0 || r.__cache__[l].push(d.fn));
    });
  });
};
Yn.prototype.at = function(r, i, l) {
  const d = this.__find__(r), f = l || {};
  if (d === -1) throw new Error("Parser rule not found: " + r);
  this.__rules__[d].fn = i, this.__rules__[d].alt = f.alt || [], this.__cache__ = null;
};
Yn.prototype.before = function(r, i, l, d) {
  const f = this.__find__(r), g = d || {};
  if (f === -1) throw new Error("Parser rule not found: " + r);
  this.__rules__.splice(f, 0, { name: i, enabled: true, fn: l, alt: g.alt || [] }), this.__cache__ = null;
};
Yn.prototype.after = function(r, i, l, d) {
  const f = this.__find__(r), g = d || {};
  if (f === -1) throw new Error("Parser rule not found: " + r);
  this.__rules__.splice(f + 1, 0, { name: i, enabled: true, fn: l, alt: g.alt || [] }), this.__cache__ = null;
};
Yn.prototype.push = function(r, i, l) {
  const d = l || {};
  this.__rules__.push({ name: r, enabled: true, fn: i, alt: d.alt || [] }), this.__cache__ = null;
};
Yn.prototype.enable = function(r, i) {
  Array.isArray(r) || (r = [r]);
  const l = [];
  return r.forEach(function(d) {
    const f = this.__find__(d);
    if (f < 0) {
      if (i) return;
      throw new Error("Rules manager: invalid rule name " + d);
    }
    this.__rules__[f].enabled = true, l.push(d);
  }, this), this.__cache__ = null, l;
};
Yn.prototype.enableOnly = function(r, i) {
  Array.isArray(r) || (r = [r]), this.__rules__.forEach(function(l) {
    l.enabled = false;
  }), this.enable(r, i);
};
Yn.prototype.disable = function(r, i) {
  Array.isArray(r) || (r = [r]);
  const l = [];
  return r.forEach(function(d) {
    const f = this.__find__(d);
    if (f < 0) {
      if (i) return;
      throw new Error("Rules manager: invalid rule name " + d);
    }
    this.__rules__[f].enabled = false, l.push(d);
  }, this), this.__cache__ = null, l;
};
Yn.prototype.getRules = function(r) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[r] || [];
};
function Xo(r, i, l) {
  this.type = r, this.tag = i, this.attrs = null, this.map = null, this.nesting = l, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = false, this.hidden = false;
}
Xo.prototype.attrIndex = function(i) {
  if (!this.attrs) return -1;
  const l = this.attrs;
  for (let d = 0, f = l.length; d < f; d++) if (l[d][0] === i) return d;
  return -1;
};
Xo.prototype.attrPush = function(i) {
  this.attrs ? this.attrs.push(i) : this.attrs = [i];
};
Xo.prototype.attrSet = function(i, l) {
  const d = this.attrIndex(i), f = [i, l];
  d < 0 ? this.attrPush(f) : this.attrs[d] = f;
};
Xo.prototype.attrGet = function(i) {
  const l = this.attrIndex(i);
  let d = null;
  return l >= 0 && (d = this.attrs[l][1]), d;
};
Xo.prototype.attrJoin = function(i, l) {
  const d = this.attrIndex(i);
  d < 0 ? this.attrPush([i, l]) : this.attrs[d][1] = this.attrs[d][1] + " " + l;
};
function T1(r, i, l) {
  this.src = r, this.env = l, this.tokens = [], this.inlineMode = false, this.md = i;
}
T1.prototype.Token = Xo;
const XM = /\r\n?|\n/g, YM = /\0/g;
function KM(r) {
  let i;
  i = r.src.replace(XM, `
`), i = i.replace(YM, "\uFFFD"), r.src = i;
}
function JM(r) {
  let i;
  r.inlineMode ? (i = new r.Token("inline", "", 0), i.content = r.src, i.map = [0, 1], i.children = [], r.tokens.push(i)) : r.md.block.parse(r.src, r.md, r.env, r.tokens);
}
function QM(r) {
  const i = r.tokens;
  for (let l = 0, d = i.length; l < d; l++) {
    const f = i[l];
    f.type === "inline" && r.md.inline.parse(f.content, r.md, r.env, f.children);
  }
}
function eE(r) {
  return /^<a[>\s]/i.test(r);
}
function tE(r) {
  return /^<\/a\s*>/i.test(r);
}
function rE(r) {
  const i = r.tokens;
  if (r.md.options.linkify) for (let l = 0, d = i.length; l < d; l++) {
    if (i[l].type !== "inline" || !r.md.linkify.pretest(i[l].content)) continue;
    let f = i[l].children, g = 0;
    for (let m = f.length - 1; m >= 0; m--) {
      const s = f[m];
      if (s.type === "link_close") {
        for (m--; f[m].level !== s.level && f[m].type !== "link_open"; ) m--;
        continue;
      }
      if (s.type === "html_inline" && (eE(s.content) && g > 0 && g--, tE(s.content) && g++), !(g > 0) && s.type === "text" && r.md.linkify.test(s.content)) {
        const C = s.content;
        let T = r.md.linkify.match(C);
        const M = [];
        let z = s.level, L = 0;
        T.length > 0 && T[0].index === 0 && m > 0 && f[m - 1].type === "text_special" && (T = T.slice(1));
        for (let A = 0; A < T.length; A++) {
          const O = T[A].url, V = r.md.normalizeLink(O);
          if (!r.md.validateLink(V)) continue;
          let X = T[A].text;
          T[A].schema ? T[A].schema === "mailto:" && !/^mailto:/i.test(X) ? X = r.md.normalizeLinkText("mailto:" + X).replace(/^mailto:/, "") : X = r.md.normalizeLinkText(X) : X = r.md.normalizeLinkText("http://" + X).replace(/^http:\/\//, "");
          const W = T[A].index;
          if (W > L) {
            const re = new r.Token("text", "", 0);
            re.content = C.slice(L, W), re.level = z, M.push(re);
          }
          const K = new r.Token("link_open", "a", 1);
          K.attrs = [["href", V]], K.level = z++, K.markup = "linkify", K.info = "auto", M.push(K);
          const ie = new r.Token("text", "", 0);
          ie.content = X, ie.level = z, M.push(ie);
          const ee = new r.Token("link_close", "a", -1);
          ee.level = --z, ee.markup = "linkify", ee.info = "auto", M.push(ee), L = T[A].lastIndex;
        }
        if (L < C.length) {
          const A = new r.Token("text", "", 0);
          A.content = C.slice(L), A.level = z, M.push(A);
        }
        i[l].children = f = k1(f, m, M);
      }
    }
  }
}
const I1 = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, iE = /\((c|tm|r)\)/i, nE = /\((c|tm|r)\)/ig, oE = { c: "\xA9", r: "\xAE", tm: "\u2122" };
function aE(r, i) {
  return oE[i.toLowerCase()];
}
function sE(r) {
  let i = 0;
  for (let l = r.length - 1; l >= 0; l--) {
    const d = r[l];
    d.type === "text" && !i && (d.content = d.content.replace(nE, aE)), d.type === "link_open" && d.info === "auto" && i--, d.type === "link_close" && d.info === "auto" && i++;
  }
}
function lE(r) {
  let i = 0;
  for (let l = r.length - 1; l >= 0; l--) {
    const d = r[l];
    d.type === "text" && !i && I1.test(d.content) && (d.content = d.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013")), d.type === "link_open" && d.info === "auto" && i--, d.type === "link_close" && d.info === "auto" && i++;
  }
}
function uE(r) {
  let i;
  if (r.md.options.typographer) for (i = r.tokens.length - 1; i >= 0; i--) r.tokens[i].type === "inline" && (iE.test(r.tokens[i].content) && sE(r.tokens[i].children), I1.test(r.tokens[i].content) && lE(r.tokens[i].children));
}
const cE = /['"]/, uy = /['"]/g, cy = "\u2019";
function Df(r, i, l) {
  return r.slice(0, i) + l + r.slice(i + 1);
}
function dE(r, i) {
  let l;
  const d = [];
  for (let f = 0; f < r.length; f++) {
    const g = r[f], m = r[f].level;
    for (l = d.length - 1; l >= 0 && !(d[l].level <= m); l--) ;
    if (d.length = l + 1, g.type !== "text") continue;
    let s = g.content, C = 0, T = s.length;
    e: for (; C < T; ) {
      uy.lastIndex = C;
      const M = uy.exec(s);
      if (!M) break;
      let z = true, L = true;
      C = M.index + 1;
      const A = M[0] === "'";
      let O = 32;
      if (M.index - 1 >= 0) O = s.charCodeAt(M.index - 1);
      else for (l = f - 1; l >= 0 && !(r[l].type === "softbreak" || r[l].type === "hardbreak"); l--) if (r[l].content) {
        O = r[l].content.charCodeAt(r[l].content.length - 1);
        break;
      }
      let V = 32;
      if (C < T) V = s.charCodeAt(C);
      else for (l = f + 1; l < r.length && !(r[l].type === "softbreak" || r[l].type === "hardbreak"); l++) if (r[l].content) {
        V = r[l].content.charCodeAt(0);
        break;
      }
      const X = Kd(O) || Yd(String.fromCharCode(O)), W = Kd(V) || Yd(String.fromCharCode(V)), K = Xd(O), ie = Xd(V);
      if (ie ? z = false : W && (K || X || (z = false)), K ? L = false : X && (ie || W || (L = false)), V === 34 && M[0] === '"' && O >= 48 && O <= 57 && (L = z = false), z && L && (z = X, L = W), !z && !L) {
        A && (g.content = Df(g.content, M.index, cy));
        continue;
      }
      if (L) for (l = d.length - 1; l >= 0; l--) {
        let ee = d[l];
        if (d[l].level < m) break;
        if (ee.single === A && d[l].level === m) {
          ee = d[l];
          let re, J;
          A ? (re = i.md.options.quotes[2], J = i.md.options.quotes[3]) : (re = i.md.options.quotes[0], J = i.md.options.quotes[1]), g.content = Df(g.content, M.index, J), r[ee.token].content = Df(r[ee.token].content, ee.pos, re), C += J.length - 1, ee.token === f && (C += re.length - 1), s = g.content, T = s.length, d.length = l;
          continue e;
        }
      }
      z ? d.push({ token: f, pos: M.index, single: A, level: m }) : L && A && (g.content = Df(g.content, M.index, cy));
    }
  }
}
function hE(r) {
  if (r.md.options.typographer) for (let i = r.tokens.length - 1; i >= 0; i--) r.tokens[i].type !== "inline" || !cE.test(r.tokens[i].content) || dE(r.tokens[i].children, r);
}
function fE(r) {
  let i, l;
  const d = r.tokens, f = d.length;
  for (let g = 0; g < f; g++) {
    if (d[g].type !== "inline") continue;
    const m = d[g].children, s = m.length;
    for (i = 0; i < s; i++) m[i].type === "text_special" && (m[i].type = "text");
    for (i = l = 0; i < s; i++) m[i].type === "text" && i + 1 < s && m[i + 1].type === "text" ? m[i + 1].content = m[i].content + m[i + 1].content : (i !== l && (m[l] = m[i]), l++);
    i !== l && (m.length = l);
  }
}
const tg = [["normalize", KM], ["block", JM], ["inline", QM], ["linkify", rE], ["replacements", uE], ["smartquotes", hE], ["text_join", fE]];
function l0() {
  this.ruler = new Yn();
  for (let r = 0; r < tg.length; r++) this.ruler.push(tg[r][0], tg[r][1]);
}
l0.prototype.process = function(r) {
  const i = this.ruler.getRules("");
  for (let l = 0, d = i.length; l < d; l++) i[l](r);
};
l0.prototype.State = T1;
function ya(r, i, l, d) {
  this.src = r, this.md = i, this.env = l, this.tokens = d, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = false, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0;
  const f = this.src;
  for (let g = 0, m = 0, s = 0, C = 0, T = f.length, M = false; m < T; m++) {
    const z = f.charCodeAt(m);
    if (!M) if (yi(z)) {
      s++, z === 9 ? C += 4 - C % 4 : C++;
      continue;
    } else M = true;
    (z === 10 || m === T - 1) && (z !== 10 && m++, this.bMarks.push(g), this.eMarks.push(m), this.tShift.push(s), this.sCount.push(C), this.bsCount.push(0), M = false, s = 0, C = 0, g = m + 1);
  }
  this.bMarks.push(f.length), this.eMarks.push(f.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
ya.prototype.push = function(r, i, l) {
  const d = new Xo(r, i, l);
  return d.block = true, l < 0 && this.level--, d.level = this.level, l > 0 && this.level++, this.tokens.push(d), d;
};
ya.prototype.isEmpty = function(i) {
  return this.bMarks[i] + this.tShift[i] >= this.eMarks[i];
};
ya.prototype.skipEmptyLines = function(i) {
  for (let l = this.lineMax; i < l && !(this.bMarks[i] + this.tShift[i] < this.eMarks[i]); i++) ;
  return i;
};
ya.prototype.skipSpaces = function(i) {
  for (let l = this.src.length; i < l; i++) {
    const d = this.src.charCodeAt(i);
    if (!yi(d)) break;
  }
  return i;
};
ya.prototype.skipSpacesBack = function(i, l) {
  if (i <= l) return i;
  for (; i > l; ) if (!yi(this.src.charCodeAt(--i))) return i + 1;
  return i;
};
ya.prototype.skipChars = function(i, l) {
  for (let d = this.src.length; i < d && this.src.charCodeAt(i) === l; i++) ;
  return i;
};
ya.prototype.skipCharsBack = function(i, l, d) {
  if (i <= d) return i;
  for (; i > d; ) if (l !== this.src.charCodeAt(--i)) return i + 1;
  return i;
};
ya.prototype.getLines = function(i, l, d, f) {
  if (i >= l) return "";
  const g = new Array(l - i);
  for (let m = 0, s = i; s < l; s++, m++) {
    let C = 0;
    const T = this.bMarks[s];
    let M = T, z;
    for (s + 1 < l || f ? z = this.eMarks[s] + 1 : z = this.eMarks[s]; M < z && C < d; ) {
      const L = this.src.charCodeAt(M);
      if (yi(L)) L === 9 ? C += 4 - (C + this.bsCount[s]) % 4 : C++;
      else if (M - T < this.tShift[s]) C++;
      else break;
      M++;
    }
    C > d ? g[m] = new Array(C - d + 1).join(" ") + this.src.slice(M, z) : g[m] = this.src.slice(M, z);
  }
  return g.join("");
};
ya.prototype.Token = Xo;
const pE = 65536;
function rg(r, i) {
  const l = r.bMarks[i] + r.tShift[i], d = r.eMarks[i];
  return r.src.slice(l, d);
}
function dy(r) {
  const i = [], l = r.length;
  let d = 0, f = r.charCodeAt(d), g = false, m = 0, s = "";
  for (; d < l; ) f === 124 && (g ? (s += r.substring(m, d - 1), m = d) : (i.push(s + r.substring(m, d)), s = "", m = d + 1)), g = f === 92, d++, f = r.charCodeAt(d);
  return i.push(s + r.substring(m)), i;
}
function mE(r, i, l, d) {
  if (i + 2 > l) return false;
  let f = i + 1;
  if (r.sCount[f] < r.blkIndent || r.sCount[f] - r.blkIndent >= 4) return false;
  let g = r.bMarks[f] + r.tShift[f];
  if (g >= r.eMarks[f]) return false;
  const m = r.src.charCodeAt(g++);
  if (m !== 124 && m !== 45 && m !== 58 || g >= r.eMarks[f]) return false;
  const s = r.src.charCodeAt(g++);
  if (s !== 124 && s !== 45 && s !== 58 && !yi(s) || m === 45 && yi(s)) return false;
  for (; g < r.eMarks[f]; ) {
    const ee = r.src.charCodeAt(g);
    if (ee !== 124 && ee !== 45 && ee !== 58 && !yi(ee)) return false;
    g++;
  }
  let C = rg(r, i + 1), T = C.split("|");
  const M = [];
  for (let ee = 0; ee < T.length; ee++) {
    const re = T[ee].trim();
    if (!re) {
      if (ee === 0 || ee === T.length - 1) continue;
      return false;
    }
    if (!/^:?-+:?$/.test(re)) return false;
    re.charCodeAt(re.length - 1) === 58 ? M.push(re.charCodeAt(0) === 58 ? "center" : "right") : re.charCodeAt(0) === 58 ? M.push("left") : M.push("");
  }
  if (C = rg(r, i).trim(), C.indexOf("|") === -1 || r.sCount[i] - r.blkIndent >= 4) return false;
  T = dy(C), T.length && T[0] === "" && T.shift(), T.length && T[T.length - 1] === "" && T.pop();
  const z = T.length;
  if (z === 0 || z !== M.length) return false;
  if (d) return true;
  const L = r.parentType;
  r.parentType = "table";
  const A = r.md.block.ruler.getRules("blockquote"), O = r.push("table_open", "table", 1), V = [i, 0];
  O.map = V;
  const X = r.push("thead_open", "thead", 1);
  X.map = [i, i + 1];
  const W = r.push("tr_open", "tr", 1);
  W.map = [i, i + 1];
  for (let ee = 0; ee < T.length; ee++) {
    const re = r.push("th_open", "th", 1);
    M[ee] && (re.attrs = [["style", "text-align:" + M[ee]]]);
    const J = r.push("inline", "", 0);
    J.content = T[ee].trim(), J.children = [], r.push("th_close", "th", -1);
  }
  r.push("tr_close", "tr", -1), r.push("thead_close", "thead", -1);
  let K, ie = 0;
  for (f = i + 2; f < l && !(r.sCount[f] < r.blkIndent); f++) {
    let ee = false;
    for (let J = 0, Se = A.length; J < Se; J++) if (A[J](r, f, l, true)) {
      ee = true;
      break;
    }
    if (ee || (C = rg(r, f).trim(), !C) || r.sCount[f] - r.blkIndent >= 4 || (T = dy(C), T.length && T[0] === "" && T.shift(), T.length && T[T.length - 1] === "" && T.pop(), ie += z - T.length, ie > pE)) break;
    if (f === i + 2) {
      const J = r.push("tbody_open", "tbody", 1);
      J.map = K = [i + 2, 0];
    }
    const re = r.push("tr_open", "tr", 1);
    re.map = [f, f + 1];
    for (let J = 0; J < z; J++) {
      const Se = r.push("td_open", "td", 1);
      M[J] && (Se.attrs = [["style", "text-align:" + M[J]]]);
      const fe = r.push("inline", "", 0);
      fe.content = T[J] ? T[J].trim() : "", fe.children = [], r.push("td_close", "td", -1);
    }
    r.push("tr_close", "tr", -1);
  }
  return K && (r.push("tbody_close", "tbody", -1), K[1] = f), r.push("table_close", "table", -1), V[1] = f, r.parentType = L, r.line = f, true;
}
function gE(r, i, l) {
  if (r.sCount[i] - r.blkIndent < 4) return false;
  let d = i + 1, f = d;
  for (; d < l; ) {
    if (r.isEmpty(d)) {
      d++;
      continue;
    }
    if (r.sCount[d] - r.blkIndent >= 4) {
      d++, f = d;
      continue;
    }
    break;
  }
  r.line = f;
  const g = r.push("code_block", "code", 0);
  return g.content = r.getLines(i, f, 4 + r.blkIndent, false) + `
`, g.map = [i, r.line], true;
}
function vE(r, i, l, d) {
  let f = r.bMarks[i] + r.tShift[i], g = r.eMarks[i];
  if (r.sCount[i] - r.blkIndent >= 4 || f + 3 > g) return false;
  const m = r.src.charCodeAt(f);
  if (m !== 126 && m !== 96) return false;
  let s = f;
  f = r.skipChars(f, m);
  let C = f - s;
  if (C < 3) return false;
  const T = r.src.slice(s, f), M = r.src.slice(f, g);
  if (m === 96 && M.indexOf(String.fromCharCode(m)) >= 0) return false;
  if (d) return true;
  let z = i, L = false;
  for (; z++, !(z >= l || (f = s = r.bMarks[z] + r.tShift[z], g = r.eMarks[z], f < g && r.sCount[z] < r.blkIndent)); ) if (r.src.charCodeAt(f) === m && !(r.sCount[z] - r.blkIndent >= 4) && (f = r.skipChars(f, m), !(f - s < C) && (f = r.skipSpaces(f), !(f < g)))) {
    L = true;
    break;
  }
  C = r.sCount[i], r.line = z + (L ? 1 : 0);
  const A = r.push("fence", "code", 0);
  return A.info = M, A.content = r.getLines(i + 1, z, C, true), A.markup = T, A.map = [i, r.line], true;
}
function _E(r, i, l, d) {
  let f = r.bMarks[i] + r.tShift[i], g = r.eMarks[i];
  const m = r.lineMax;
  if (r.sCount[i] - r.blkIndent >= 4 || r.src.charCodeAt(f) !== 62) return false;
  if (d) return true;
  const s = [], C = [], T = [], M = [], z = r.md.block.ruler.getRules("blockquote"), L = r.parentType;
  r.parentType = "blockquote";
  let A = false, O;
  for (O = i; O < l; O++) {
    const ie = r.sCount[O] < r.blkIndent;
    if (f = r.bMarks[O] + r.tShift[O], g = r.eMarks[O], f >= g) break;
    if (r.src.charCodeAt(f++) === 62 && !ie) {
      let re = r.sCount[O] + 1, J, Se;
      r.src.charCodeAt(f) === 32 ? (f++, re++, Se = false, J = true) : r.src.charCodeAt(f) === 9 ? (J = true, (r.bsCount[O] + re) % 4 === 3 ? (f++, re++, Se = false) : Se = true) : J = false;
      let fe = re;
      for (s.push(r.bMarks[O]), r.bMarks[O] = f; f < g; ) {
        const oe = r.src.charCodeAt(f);
        if (yi(oe)) oe === 9 ? fe += 4 - (fe + r.bsCount[O] + (Se ? 1 : 0)) % 4 : fe++;
        else break;
        f++;
      }
      A = f >= g, C.push(r.bsCount[O]), r.bsCount[O] = r.sCount[O] + 1 + (J ? 1 : 0), T.push(r.sCount[O]), r.sCount[O] = fe - re, M.push(r.tShift[O]), r.tShift[O] = f - r.bMarks[O];
      continue;
    }
    if (A) break;
    let ee = false;
    for (let re = 0, J = z.length; re < J; re++) if (z[re](r, O, l, true)) {
      ee = true;
      break;
    }
    if (ee) {
      r.lineMax = O, r.blkIndent !== 0 && (s.push(r.bMarks[O]), C.push(r.bsCount[O]), M.push(r.tShift[O]), T.push(r.sCount[O]), r.sCount[O] -= r.blkIndent);
      break;
    }
    s.push(r.bMarks[O]), C.push(r.bsCount[O]), M.push(r.tShift[O]), T.push(r.sCount[O]), r.sCount[O] = -1;
  }
  const V = r.blkIndent;
  r.blkIndent = 0;
  const X = r.push("blockquote_open", "blockquote", 1);
  X.markup = ">";
  const W = [i, 0];
  X.map = W, r.md.block.tokenize(r, i, O);
  const K = r.push("blockquote_close", "blockquote", -1);
  K.markup = ">", r.lineMax = m, r.parentType = L, W[1] = r.line;
  for (let ie = 0; ie < M.length; ie++) r.bMarks[ie + i] = s[ie], r.tShift[ie + i] = M[ie], r.sCount[ie + i] = T[ie], r.bsCount[ie + i] = C[ie];
  return r.blkIndent = V, true;
}
function yE(r, i, l, d) {
  const f = r.eMarks[i];
  if (r.sCount[i] - r.blkIndent >= 4) return false;
  let g = r.bMarks[i] + r.tShift[i];
  const m = r.src.charCodeAt(g++);
  if (m !== 42 && m !== 45 && m !== 95) return false;
  let s = 1;
  for (; g < f; ) {
    const T = r.src.charCodeAt(g++);
    if (T !== m && !yi(T)) return false;
    T === m && s++;
  }
  if (s < 3) return false;
  if (d) return true;
  r.line = i + 1;
  const C = r.push("hr", "hr", 0);
  return C.map = [i, r.line], C.markup = Array(s + 1).join(String.fromCharCode(m)), true;
}
function hy(r, i) {
  const l = r.eMarks[i];
  let d = r.bMarks[i] + r.tShift[i];
  const f = r.src.charCodeAt(d++);
  if (f !== 42 && f !== 45 && f !== 43) return -1;
  if (d < l) {
    const g = r.src.charCodeAt(d);
    if (!yi(g)) return -1;
  }
  return d;
}
function fy(r, i) {
  const l = r.bMarks[i] + r.tShift[i], d = r.eMarks[i];
  let f = l;
  if (f + 1 >= d) return -1;
  let g = r.src.charCodeAt(f++);
  if (g < 48 || g > 57) return -1;
  for (; ; ) {
    if (f >= d) return -1;
    if (g = r.src.charCodeAt(f++), g >= 48 && g <= 57) {
      if (f - l >= 10) return -1;
      continue;
    }
    if (g === 41 || g === 46) break;
    return -1;
  }
  return f < d && (g = r.src.charCodeAt(f), !yi(g)) ? -1 : f;
}
function bE(r, i) {
  const l = r.level + 2;
  for (let d = i + 2, f = r.tokens.length - 2; d < f; d++) r.tokens[d].level === l && r.tokens[d].type === "paragraph_open" && (r.tokens[d + 2].hidden = true, r.tokens[d].hidden = true, d += 2);
}
function xE(r, i, l, d) {
  let f, g, m, s, C = i, T = true;
  if (r.sCount[C] - r.blkIndent >= 4 || r.listIndent >= 0 && r.sCount[C] - r.listIndent >= 4 && r.sCount[C] < r.blkIndent) return false;
  let M = false;
  d && r.parentType === "paragraph" && r.sCount[C] >= r.blkIndent && (M = true);
  let z, L, A;
  if ((A = fy(r, C)) >= 0) {
    if (z = true, m = r.bMarks[C] + r.tShift[C], L = Number(r.src.slice(m, A - 1)), M && L !== 1) return false;
  } else if ((A = hy(r, C)) >= 0) z = false;
  else return false;
  if (M && r.skipSpaces(A) >= r.eMarks[C]) return false;
  if (d) return true;
  const O = r.src.charCodeAt(A - 1), V = r.tokens.length;
  z ? (s = r.push("ordered_list_open", "ol", 1), L !== 1 && (s.attrs = [["start", L]])) : s = r.push("bullet_list_open", "ul", 1);
  const X = [C, 0];
  s.map = X, s.markup = String.fromCharCode(O);
  let W = false;
  const K = r.md.block.ruler.getRules("list"), ie = r.parentType;
  for (r.parentType = "list"; C < l; ) {
    g = A, f = r.eMarks[C];
    const ee = r.sCount[C] + A - (r.bMarks[C] + r.tShift[C]);
    let re = ee;
    for (; g < f; ) {
      const lt = r.src.charCodeAt(g);
      if (lt === 9) re += 4 - (re + r.bsCount[C]) % 4;
      else if (lt === 32) re++;
      else break;
      g++;
    }
    const J = g;
    let Se;
    J >= f ? Se = 1 : Se = re - ee, Se > 4 && (Se = 1);
    const fe = ee + Se;
    s = r.push("list_item_open", "li", 1), s.markup = String.fromCharCode(O);
    const oe = [C, 0];
    s.map = oe, z && (s.info = r.src.slice(m, A - 1));
    const he = r.tight, be = r.tShift[C], je = r.sCount[C], Ve = r.listIndent;
    if (r.listIndent = r.blkIndent, r.blkIndent = fe, r.tight = true, r.tShift[C] = J - r.bMarks[C], r.sCount[C] = re, J >= f && r.isEmpty(C + 1) ? r.line = Math.min(r.line + 2, l) : r.md.block.tokenize(r, C, l, true), (!r.tight || W) && (T = false), W = r.line - C > 1 && r.isEmpty(r.line - 1), r.blkIndent = r.listIndent, r.listIndent = Ve, r.tShift[C] = be, r.sCount[C] = je, r.tight = he, s = r.push("list_item_close", "li", -1), s.markup = String.fromCharCode(O), C = r.line, oe[1] = C, C >= l || r.sCount[C] < r.blkIndent || r.sCount[C] - r.blkIndent >= 4) break;
    let Ke = false;
    for (let lt = 0, vt = K.length; lt < vt; lt++) if (K[lt](r, C, l, true)) {
      Ke = true;
      break;
    }
    if (Ke) break;
    if (z) {
      if (A = fy(r, C), A < 0) break;
      m = r.bMarks[C] + r.tShift[C];
    } else if (A = hy(r, C), A < 0) break;
    if (O !== r.src.charCodeAt(A - 1)) break;
  }
  return z ? s = r.push("ordered_list_close", "ol", -1) : s = r.push("bullet_list_close", "ul", -1), s.markup = String.fromCharCode(O), X[1] = C, r.line = C, r.parentType = ie, T && bE(r, V), true;
}
function wE(r, i, l, d) {
  let f = r.bMarks[i] + r.tShift[i], g = r.eMarks[i], m = i + 1;
  if (r.sCount[i] - r.blkIndent >= 4 || r.src.charCodeAt(f) !== 91) return false;
  function s(K) {
    const ie = r.lineMax;
    if (K >= ie || r.isEmpty(K)) return null;
    let ee = false;
    if (r.sCount[K] - r.blkIndent > 3 && (ee = true), r.sCount[K] < 0 && (ee = true), !ee) {
      const Se = r.md.block.ruler.getRules("reference"), fe = r.parentType;
      r.parentType = "reference";
      let oe = false;
      for (let he = 0, be = Se.length; he < be; he++) if (Se[he](r, K, ie, true)) {
        oe = true;
        break;
      }
      if (r.parentType = fe, oe) return null;
    }
    const re = r.bMarks[K] + r.tShift[K], J = r.eMarks[K];
    return r.src.slice(re, J + 1);
  }
  let C = r.src.slice(f, g + 1);
  g = C.length;
  let T = -1;
  for (f = 1; f < g; f++) {
    const K = C.charCodeAt(f);
    if (K === 91) return false;
    if (K === 93) {
      T = f;
      break;
    } else if (K === 10) {
      const ie = s(m);
      ie !== null && (C += ie, g = C.length, m++);
    } else if (K === 92 && (f++, f < g && C.charCodeAt(f) === 10)) {
      const ie = s(m);
      ie !== null && (C += ie, g = C.length, m++);
    }
  }
  if (T < 0 || C.charCodeAt(T + 1) !== 58) return false;
  for (f = T + 2; f < g; f++) {
    const K = C.charCodeAt(f);
    if (K === 10) {
      const ie = s(m);
      ie !== null && (C += ie, g = C.length, m++);
    } else if (!yi(K)) break;
  }
  const M = r.md.helpers.parseLinkDestination(C, f, g);
  if (!M.ok) return false;
  const z = r.md.normalizeLink(M.str);
  if (!r.md.validateLink(z)) return false;
  f = M.pos;
  const L = f, A = m, O = f;
  for (; f < g; f++) {
    const K = C.charCodeAt(f);
    if (K === 10) {
      const ie = s(m);
      ie !== null && (C += ie, g = C.length, m++);
    } else if (!yi(K)) break;
  }
  let V = r.md.helpers.parseLinkTitle(C, f, g);
  for (; V.can_continue; ) {
    const K = s(m);
    if (K === null) break;
    C += K, f = g, g = C.length, m++, V = r.md.helpers.parseLinkTitle(C, f, g, V);
  }
  let X;
  for (f < g && O !== f && V.ok ? (X = V.str, f = V.pos) : (X = "", f = L, m = A); f < g; ) {
    const K = C.charCodeAt(f);
    if (!yi(K)) break;
    f++;
  }
  if (f < g && C.charCodeAt(f) !== 10 && X) for (X = "", f = L, m = A; f < g; ) {
    const K = C.charCodeAt(f);
    if (!yi(K)) break;
    f++;
  }
  if (f < g && C.charCodeAt(f) !== 10) return false;
  const W = vp(C.slice(1, T));
  return W ? (d || (typeof r.env.references > "u" && (r.env.references = {}), typeof r.env.references[W] > "u" && (r.env.references[W] = { title: X, href: z }), r.line = m), true) : false;
}
const CE = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"], SE = "[a-zA-Z_:][a-zA-Z0-9:._-]*", kE = "[^\"'=<>`\\x00-\\x20]+", PE = "'[^']*'", TE = '"[^"]*"', IE = "(?:" + kE + "|" + PE + "|" + TE + ")", ME = "(?:\\s+" + SE + "(?:\\s*=\\s*" + IE + ")?)", M1 = "<[A-Za-z][A-Za-z0-9\\-]*" + ME + "*\\s*\\/?>", E1 = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", EE = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->", RE = "<[?][\\s\\S]*?[?]>", AE = "<![A-Za-z][^>]*>", DE = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", zE = new RegExp("^(?:" + M1 + "|" + E1 + "|" + EE + "|" + RE + "|" + AE + "|" + DE + ")"), FE = new RegExp("^(?:" + M1 + "|" + E1 + ")"), Wu = [[/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp("^</?(" + CE.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true], [new RegExp(FE.source + "\\s*$"), /^$/, false]];
function LE(r, i, l, d) {
  let f = r.bMarks[i] + r.tShift[i], g = r.eMarks[i];
  if (r.sCount[i] - r.blkIndent >= 4 || !r.md.options.html || r.src.charCodeAt(f) !== 60) return false;
  let m = r.src.slice(f, g), s = 0;
  for (; s < Wu.length && !Wu[s][0].test(m); s++) ;
  if (s === Wu.length) return false;
  if (d) return Wu[s][2];
  let C = i + 1;
  if (!Wu[s][1].test(m)) {
    for (; C < l && !(r.sCount[C] < r.blkIndent); C++) if (f = r.bMarks[C] + r.tShift[C], g = r.eMarks[C], m = r.src.slice(f, g), Wu[s][1].test(m)) {
      m.length !== 0 && C++;
      break;
    }
  }
  r.line = C;
  const T = r.push("html_block", "", 0);
  return T.map = [i, C], T.content = r.getLines(i, C, r.blkIndent, true), true;
}
function BE(r, i, l, d) {
  let f = r.bMarks[i] + r.tShift[i], g = r.eMarks[i];
  if (r.sCount[i] - r.blkIndent >= 4) return false;
  let m = r.src.charCodeAt(f);
  if (m !== 35 || f >= g) return false;
  let s = 1;
  for (m = r.src.charCodeAt(++f); m === 35 && f < g && s <= 6; ) s++, m = r.src.charCodeAt(++f);
  if (s > 6 || f < g && !yi(m)) return false;
  if (d) return true;
  g = r.skipSpacesBack(g, f);
  const C = r.skipCharsBack(g, 35, f);
  C > f && yi(r.src.charCodeAt(C - 1)) && (g = C), r.line = i + 1;
  const T = r.push("heading_open", "h" + String(s), 1);
  T.markup = "########".slice(0, s), T.map = [i, r.line];
  const M = r.push("inline", "", 0);
  M.content = r.src.slice(f, g).trim(), M.map = [i, r.line], M.children = [];
  const z = r.push("heading_close", "h" + String(s), -1);
  return z.markup = "########".slice(0, s), true;
}
function OE(r, i, l) {
  const d = r.md.block.ruler.getRules("paragraph");
  if (r.sCount[i] - r.blkIndent >= 4) return false;
  const f = r.parentType;
  r.parentType = "paragraph";
  let g = 0, m, s = i + 1;
  for (; s < l && !r.isEmpty(s); s++) {
    if (r.sCount[s] - r.blkIndent > 3) continue;
    if (r.sCount[s] >= r.blkIndent) {
      let A = r.bMarks[s] + r.tShift[s];
      const O = r.eMarks[s];
      if (A < O && (m = r.src.charCodeAt(A), (m === 45 || m === 61) && (A = r.skipChars(A, m), A = r.skipSpaces(A), A >= O))) {
        g = m === 61 ? 1 : 2;
        break;
      }
    }
    if (r.sCount[s] < 0) continue;
    let L = false;
    for (let A = 0, O = d.length; A < O; A++) if (d[A](r, s, l, true)) {
      L = true;
      break;
    }
    if (L) break;
  }
  if (!g) return false;
  const C = r.getLines(i, s, r.blkIndent, false).trim();
  r.line = s + 1;
  const T = r.push("heading_open", "h" + String(g), 1);
  T.markup = String.fromCharCode(m), T.map = [i, r.line];
  const M = r.push("inline", "", 0);
  M.content = C, M.map = [i, r.line - 1], M.children = [];
  const z = r.push("heading_close", "h" + String(g), -1);
  return z.markup = String.fromCharCode(m), r.parentType = f, true;
}
function $E(r, i, l) {
  const d = r.md.block.ruler.getRules("paragraph"), f = r.parentType;
  let g = i + 1;
  for (r.parentType = "paragraph"; g < l && !r.isEmpty(g); g++) {
    if (r.sCount[g] - r.blkIndent > 3 || r.sCount[g] < 0) continue;
    let T = false;
    for (let M = 0, z = d.length; M < z; M++) if (d[M](r, g, l, true)) {
      T = true;
      break;
    }
    if (T) break;
  }
  const m = r.getLines(i, g, r.blkIndent, false).trim();
  r.line = g;
  const s = r.push("paragraph_open", "p", 1);
  s.map = [i, r.line];
  const C = r.push("inline", "", 0);
  return C.content = m, C.map = [i, r.line], C.children = [], r.push("paragraph_close", "p", -1), r.parentType = f, true;
}
const zf = [["table", mE, ["paragraph", "reference"]], ["code", gE], ["fence", vE, ["paragraph", "reference", "blockquote", "list"]], ["blockquote", _E, ["paragraph", "reference", "blockquote", "list"]], ["hr", yE, ["paragraph", "reference", "blockquote", "list"]], ["list", xE, ["paragraph", "reference", "blockquote"]], ["reference", wE], ["html_block", LE, ["paragraph", "reference", "blockquote"]], ["heading", BE, ["paragraph", "reference", "blockquote"]], ["lheading", OE], ["paragraph", $E]];
function _p() {
  this.ruler = new Yn();
  for (let r = 0; r < zf.length; r++) this.ruler.push(zf[r][0], zf[r][1], { alt: (zf[r][2] || []).slice() });
}
_p.prototype.tokenize = function(r, i, l) {
  const d = this.ruler.getRules(""), f = d.length, g = r.md.options.maxNesting;
  let m = i, s = false;
  for (; m < l && (r.line = m = r.skipEmptyLines(m), !(m >= l || r.sCount[m] < r.blkIndent)); ) {
    if (r.level >= g) {
      r.line = l;
      break;
    }
    const C = r.line;
    let T = false;
    for (let M = 0; M < f; M++) if (T = d[M](r, m, l, false), T) {
      if (C >= r.line) throw new Error("block rule didn't increment state.line");
      break;
    }
    if (!T) throw new Error("none of the block rules matched");
    r.tight = !s, r.isEmpty(r.line - 1) && (s = true), m = r.line, m < l && r.isEmpty(m) && (s = true, m++, r.line = m);
  }
};
_p.prototype.parse = function(r, i, l, d) {
  if (!r) return;
  const f = new this.State(r, i, l, d);
  this.tokenize(f, f.line, f.lineMax);
};
_p.prototype.State = ya;
function lh(r, i, l, d) {
  this.src = r, this.env = l, this.md = i, this.tokens = d, this.tokens_meta = Array(d.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = false, this.linkLevel = 0;
}
lh.prototype.pushPending = function() {
  const r = new Xo("text", "", 0);
  return r.content = this.pending, r.level = this.pendingLevel, this.tokens.push(r), this.pending = "", r;
};
lh.prototype.push = function(r, i, l) {
  this.pending && this.pushPending();
  const d = new Xo(r, i, l);
  let f = null;
  return l < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), d.level = this.level, l > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], f = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(d), this.tokens_meta.push(f), d;
};
lh.prototype.scanDelims = function(r, i) {
  const l = this.posMax, d = this.src.charCodeAt(r), f = r > 0 ? this.src.charCodeAt(r - 1) : 32;
  let g = r;
  for (; g < l && this.src.charCodeAt(g) === d; ) g++;
  const m = g - r, s = g < l ? this.src.charCodeAt(g) : 32, C = Kd(f) || Yd(String.fromCharCode(f)), T = Kd(s) || Yd(String.fromCharCode(s)), M = Xd(f), z = Xd(s), L = !z && (!T || M || C), A = !M && (!C || z || T);
  return { can_open: L && (i || !A || C), can_close: A && (i || !L || T), length: m };
};
lh.prototype.Token = Xo;
function jE(r) {
  switch (r) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function NE(r, i) {
  let l = r.pos;
  for (; l < r.posMax && !jE(r.src.charCodeAt(l)); ) l++;
  return l === r.pos ? false : (i || (r.pending += r.src.slice(r.pos, l)), r.pos = l, true);
}
const VE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function UE(r, i) {
  if (!r.md.options.linkify || r.linkLevel > 0) return false;
  const l = r.pos, d = r.posMax;
  if (l + 3 > d || r.src.charCodeAt(l) !== 58 || r.src.charCodeAt(l + 1) !== 47 || r.src.charCodeAt(l + 2) !== 47) return false;
  const f = r.pending.match(VE);
  if (!f) return false;
  const g = f[1], m = r.md.linkify.matchAtStart(r.src.slice(l - g.length));
  if (!m) return false;
  let s = m.url;
  if (s.length <= g.length) return false;
  s = s.replace(/\*+$/, "");
  const C = r.md.normalizeLink(s);
  if (!r.md.validateLink(C)) return false;
  if (!i) {
    r.pending = r.pending.slice(0, -g.length);
    const T = r.push("link_open", "a", 1);
    T.attrs = [["href", C]], T.markup = "linkify", T.info = "auto";
    const M = r.push("text", "", 0);
    M.content = r.md.normalizeLinkText(s);
    const z = r.push("link_close", "a", -1);
    z.markup = "linkify", z.info = "auto";
  }
  return r.pos += s.length - g.length, true;
}
function qE(r, i) {
  let l = r.pos;
  if (r.src.charCodeAt(l) !== 10) return false;
  const d = r.pending.length - 1, f = r.posMax;
  if (!i) if (d >= 0 && r.pending.charCodeAt(d) === 32) if (d >= 1 && r.pending.charCodeAt(d - 1) === 32) {
    let g = d - 1;
    for (; g >= 1 && r.pending.charCodeAt(g - 1) === 32; ) g--;
    r.pending = r.pending.slice(0, g), r.push("hardbreak", "br", 0);
  } else r.pending = r.pending.slice(0, -1), r.push("softbreak", "br", 0);
  else r.push("softbreak", "br", 0);
  for (l++; l < f && yi(r.src.charCodeAt(l)); ) l++;
  return r.pos = l, true;
}
const u0 = [];
for (let r = 0; r < 256; r++) u0.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(r) {
  u0[r.charCodeAt(0)] = 1;
});
function GE(r, i) {
  let l = r.pos;
  const d = r.posMax;
  if (r.src.charCodeAt(l) !== 92 || (l++, l >= d)) return false;
  let f = r.src.charCodeAt(l);
  if (f === 10) {
    for (i || r.push("hardbreak", "br", 0), l++; l < d && (f = r.src.charCodeAt(l), !!yi(f)); ) l++;
    return r.pos = l, true;
  }
  let g = r.src[l];
  if (f >= 55296 && f <= 56319 && l + 1 < d) {
    const s = r.src.charCodeAt(l + 1);
    s >= 56320 && s <= 57343 && (g += r.src[l + 1], l++);
  }
  const m = "\\" + g;
  if (!i) {
    const s = r.push("text_special", "", 0);
    f < 256 && u0[f] !== 0 ? s.content = g : s.content = m, s.markup = m, s.info = "escape";
  }
  return r.pos = l + 1, true;
}
function WE(r, i) {
  let l = r.pos;
  if (r.src.charCodeAt(l) !== 96) return false;
  const f = l;
  l++;
  const g = r.posMax;
  for (; l < g && r.src.charCodeAt(l) === 96; ) l++;
  const m = r.src.slice(f, l), s = m.length;
  if (r.backticksScanned && (r.backticks[s] || 0) <= f) return i || (r.pending += m), r.pos += s, true;
  let C = l, T;
  for (; (T = r.src.indexOf("`", C)) !== -1; ) {
    for (C = T + 1; C < g && r.src.charCodeAt(C) === 96; ) C++;
    const M = C - T;
    if (M === s) {
      if (!i) {
        const z = r.push("code_inline", "code", 0);
        z.markup = m, z.content = r.src.slice(l, T).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      return r.pos = C, true;
    }
    r.backticks[M] = T;
  }
  return r.backticksScanned = true, i || (r.pending += m), r.pos += s, true;
}
function ZE(r, i) {
  const l = r.pos, d = r.src.charCodeAt(l);
  if (i || d !== 126) return false;
  const f = r.scanDelims(r.pos, true);
  let g = f.length;
  const m = String.fromCharCode(d);
  if (g < 2) return false;
  let s;
  g % 2 && (s = r.push("text", "", 0), s.content = m, g--);
  for (let C = 0; C < g; C += 2) s = r.push("text", "", 0), s.content = m + m, r.delimiters.push({ marker: d, length: 0, token: r.tokens.length - 1, end: -1, open: f.can_open, close: f.can_close });
  return r.pos += f.length, true;
}
function py(r, i) {
  let l;
  const d = [], f = i.length;
  for (let g = 0; g < f; g++) {
    const m = i[g];
    if (m.marker !== 126 || m.end === -1) continue;
    const s = i[m.end];
    l = r.tokens[m.token], l.type = "s_open", l.tag = "s", l.nesting = 1, l.markup = "~~", l.content = "", l = r.tokens[s.token], l.type = "s_close", l.tag = "s", l.nesting = -1, l.markup = "~~", l.content = "", r.tokens[s.token - 1].type === "text" && r.tokens[s.token - 1].content === "~" && d.push(s.token - 1);
  }
  for (; d.length; ) {
    const g = d.pop();
    let m = g + 1;
    for (; m < r.tokens.length && r.tokens[m].type === "s_close"; ) m++;
    m--, g !== m && (l = r.tokens[m], r.tokens[m] = r.tokens[g], r.tokens[g] = l);
  }
}
function HE(r) {
  const i = r.tokens_meta, l = r.tokens_meta.length;
  py(r, r.delimiters);
  for (let d = 0; d < l; d++) i[d] && i[d].delimiters && py(r, i[d].delimiters);
}
const R1 = { tokenize: ZE, postProcess: HE };
function XE(r, i) {
  const l = r.pos, d = r.src.charCodeAt(l);
  if (i || d !== 95 && d !== 42) return false;
  const f = r.scanDelims(r.pos, d === 42);
  for (let g = 0; g < f.length; g++) {
    const m = r.push("text", "", 0);
    m.content = String.fromCharCode(d), r.delimiters.push({ marker: d, length: f.length, token: r.tokens.length - 1, end: -1, open: f.can_open, close: f.can_close });
  }
  return r.pos += f.length, true;
}
function my(r, i) {
  const l = i.length;
  for (let d = l - 1; d >= 0; d--) {
    const f = i[d];
    if (f.marker !== 95 && f.marker !== 42 || f.end === -1) continue;
    const g = i[f.end], m = d > 0 && i[d - 1].end === f.end + 1 && i[d - 1].marker === f.marker && i[d - 1].token === f.token - 1 && i[f.end + 1].token === g.token + 1, s = String.fromCharCode(f.marker), C = r.tokens[f.token];
    C.type = m ? "strong_open" : "em_open", C.tag = m ? "strong" : "em", C.nesting = 1, C.markup = m ? s + s : s, C.content = "";
    const T = r.tokens[g.token];
    T.type = m ? "strong_close" : "em_close", T.tag = m ? "strong" : "em", T.nesting = -1, T.markup = m ? s + s : s, T.content = "", m && (r.tokens[i[d - 1].token].content = "", r.tokens[i[f.end + 1].token].content = "", d--);
  }
}
function YE(r) {
  const i = r.tokens_meta, l = r.tokens_meta.length;
  my(r, r.delimiters);
  for (let d = 0; d < l; d++) i[d] && i[d].delimiters && my(r, i[d].delimiters);
}
const A1 = { tokenize: XE, postProcess: YE };
function KE(r, i) {
  let l, d, f, g, m = "", s = "", C = r.pos, T = true;
  if (r.src.charCodeAt(r.pos) !== 91) return false;
  const M = r.pos, z = r.posMax, L = r.pos + 1, A = r.md.helpers.parseLinkLabel(r, r.pos, true);
  if (A < 0) return false;
  let O = A + 1;
  if (O < z && r.src.charCodeAt(O) === 40) {
    for (T = false, O++; O < z && (l = r.src.charCodeAt(O), !(!yi(l) && l !== 10)); O++) ;
    if (O >= z) return false;
    if (C = O, f = r.md.helpers.parseLinkDestination(r.src, O, r.posMax), f.ok) {
      for (m = r.md.normalizeLink(f.str), r.md.validateLink(m) ? O = f.pos : m = "", C = O; O < z && (l = r.src.charCodeAt(O), !(!yi(l) && l !== 10)); O++) ;
      if (f = r.md.helpers.parseLinkTitle(r.src, O, r.posMax), O < z && C !== O && f.ok) for (s = f.str, O = f.pos; O < z && (l = r.src.charCodeAt(O), !(!yi(l) && l !== 10)); O++) ;
    }
    (O >= z || r.src.charCodeAt(O) !== 41) && (T = true), O++;
  }
  if (T) {
    if (typeof r.env.references > "u") return false;
    if (O < z && r.src.charCodeAt(O) === 91 ? (C = O + 1, O = r.md.helpers.parseLinkLabel(r, O), O >= 0 ? d = r.src.slice(C, O++) : O = A + 1) : O = A + 1, d || (d = r.src.slice(L, A)), g = r.env.references[vp(d)], !g) return r.pos = M, false;
    m = g.href, s = g.title;
  }
  if (!i) {
    r.pos = L, r.posMax = A;
    const V = r.push("link_open", "a", 1), X = [["href", m]];
    V.attrs = X, s && X.push(["title", s]), r.linkLevel++, r.md.inline.tokenize(r), r.linkLevel--, r.push("link_close", "a", -1);
  }
  return r.pos = O, r.posMax = z, true;
}
function JE(r, i) {
  let l, d, f, g, m, s, C, T, M = "";
  const z = r.pos, L = r.posMax;
  if (r.src.charCodeAt(r.pos) !== 33 || r.src.charCodeAt(r.pos + 1) !== 91) return false;
  const A = r.pos + 2, O = r.md.helpers.parseLinkLabel(r, r.pos + 1, false);
  if (O < 0) return false;
  if (g = O + 1, g < L && r.src.charCodeAt(g) === 40) {
    for (g++; g < L && (l = r.src.charCodeAt(g), !(!yi(l) && l !== 10)); g++) ;
    if (g >= L) return false;
    for (T = g, s = r.md.helpers.parseLinkDestination(r.src, g, r.posMax), s.ok && (M = r.md.normalizeLink(s.str), r.md.validateLink(M) ? g = s.pos : M = ""), T = g; g < L && (l = r.src.charCodeAt(g), !(!yi(l) && l !== 10)); g++) ;
    if (s = r.md.helpers.parseLinkTitle(r.src, g, r.posMax), g < L && T !== g && s.ok) for (C = s.str, g = s.pos; g < L && (l = r.src.charCodeAt(g), !(!yi(l) && l !== 10)); g++) ;
    else C = "";
    if (g >= L || r.src.charCodeAt(g) !== 41) return r.pos = z, false;
    g++;
  } else {
    if (typeof r.env.references > "u") return false;
    if (g < L && r.src.charCodeAt(g) === 91 ? (T = g + 1, g = r.md.helpers.parseLinkLabel(r, g), g >= 0 ? f = r.src.slice(T, g++) : g = O + 1) : g = O + 1, f || (f = r.src.slice(A, O)), m = r.env.references[vp(f)], !m) return r.pos = z, false;
    M = m.href, C = m.title;
  }
  if (!i) {
    d = r.src.slice(A, O);
    const V = [];
    r.md.inline.parse(d, r.md, r.env, V);
    const X = r.push("image", "img", 0), W = [["src", M], ["alt", ""]];
    X.attrs = W, X.children = V, X.content = d, C && W.push(["title", C]);
  }
  return r.pos = g, r.posMax = L, true;
}
const QE = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, eR = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function tR(r, i) {
  let l = r.pos;
  if (r.src.charCodeAt(l) !== 60) return false;
  const d = r.pos, f = r.posMax;
  for (; ; ) {
    if (++l >= f) return false;
    const m = r.src.charCodeAt(l);
    if (m === 60) return false;
    if (m === 62) break;
  }
  const g = r.src.slice(d + 1, l);
  if (eR.test(g)) {
    const m = r.md.normalizeLink(g);
    if (!r.md.validateLink(m)) return false;
    if (!i) {
      const s = r.push("link_open", "a", 1);
      s.attrs = [["href", m]], s.markup = "autolink", s.info = "auto";
      const C = r.push("text", "", 0);
      C.content = r.md.normalizeLinkText(g);
      const T = r.push("link_close", "a", -1);
      T.markup = "autolink", T.info = "auto";
    }
    return r.pos += g.length + 2, true;
  }
  if (QE.test(g)) {
    const m = r.md.normalizeLink("mailto:" + g);
    if (!r.md.validateLink(m)) return false;
    if (!i) {
      const s = r.push("link_open", "a", 1);
      s.attrs = [["href", m]], s.markup = "autolink", s.info = "auto";
      const C = r.push("text", "", 0);
      C.content = r.md.normalizeLinkText(g);
      const T = r.push("link_close", "a", -1);
      T.markup = "autolink", T.info = "auto";
    }
    return r.pos += g.length + 2, true;
  }
  return false;
}
function rR(r) {
  return /^<a[>\s]/i.test(r);
}
function iR(r) {
  return /^<\/a\s*>/i.test(r);
}
function nR(r) {
  const i = r | 32;
  return i >= 97 && i <= 122;
}
function oR(r, i) {
  if (!r.md.options.html) return false;
  const l = r.posMax, d = r.pos;
  if (r.src.charCodeAt(d) !== 60 || d + 2 >= l) return false;
  const f = r.src.charCodeAt(d + 1);
  if (f !== 33 && f !== 63 && f !== 47 && !nR(f)) return false;
  const g = r.src.slice(d).match(zE);
  if (!g) return false;
  if (!i) {
    const m = r.push("html_inline", "", 0);
    m.content = g[0], rR(m.content) && r.linkLevel++, iR(m.content) && r.linkLevel--;
  }
  return r.pos += g[0].length, true;
}
const aR = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, sR = /^&([a-z][a-z0-9]{1,31});/i;
function lR(r, i) {
  const l = r.pos, d = r.posMax;
  if (r.src.charCodeAt(l) !== 38 || l + 1 >= d) return false;
  if (r.src.charCodeAt(l + 1) === 35) {
    const g = r.src.slice(l).match(aR);
    if (g) {
      if (!i) {
        const m = g[1][0].toLowerCase() === "x" ? parseInt(g[1].slice(1), 16) : parseInt(g[1], 10), s = r.push("text_special", "", 0);
        s.content = s0(m) ? Jf(m) : Jf(65533), s.markup = g[0], s.info = "entity";
      }
      return r.pos += g[0].length, true;
    }
  } else {
    const g = r.src.slice(l).match(sR);
    if (g) {
      const m = S1(g[0]);
      if (m !== g[0]) {
        if (!i) {
          const s = r.push("text_special", "", 0);
          s.content = m, s.markup = g[0], s.info = "entity";
        }
        return r.pos += g[0].length, true;
      }
    }
  }
  return false;
}
function gy(r) {
  const i = {}, l = r.length;
  if (!l) return;
  let d = 0, f = -2;
  const g = [];
  for (let m = 0; m < l; m++) {
    const s = r[m];
    if (g.push(0), (r[d].marker !== s.marker || f !== s.token - 1) && (d = m), f = s.token, s.length = s.length || 0, !s.close) continue;
    i.hasOwnProperty(s.marker) || (i[s.marker] = [-1, -1, -1, -1, -1, -1]);
    const C = i[s.marker][(s.open ? 3 : 0) + s.length % 3];
    let T = d - g[d] - 1, M = T;
    for (; T > C; T -= g[T] + 1) {
      const z = r[T];
      if (z.marker === s.marker && z.open && z.end < 0) {
        let L = false;
        if ((z.close || s.open) && (z.length + s.length) % 3 === 0 && (z.length % 3 !== 0 || s.length % 3 !== 0) && (L = true), !L) {
          const A = T > 0 && !r[T - 1].open ? g[T - 1] + 1 : 0;
          g[m] = m - T + A, g[T] = A, s.open = false, z.end = m, z.close = false, M = -1, f = -2;
          break;
        }
      }
    }
    M !== -1 && (i[s.marker][(s.open ? 3 : 0) + (s.length || 0) % 3] = M);
  }
}
function uR(r) {
  const i = r.tokens_meta, l = r.tokens_meta.length;
  gy(r.delimiters);
  for (let d = 0; d < l; d++) i[d] && i[d].delimiters && gy(i[d].delimiters);
}
function cR(r) {
  let i, l, d = 0;
  const f = r.tokens, g = r.tokens.length;
  for (i = l = 0; i < g; i++) f[i].nesting < 0 && d--, f[i].level = d, f[i].nesting > 0 && d++, f[i].type === "text" && i + 1 < g && f[i + 1].type === "text" ? f[i + 1].content = f[i].content + f[i + 1].content : (i !== l && (f[l] = f[i]), l++);
  i !== l && (f.length = l);
}
const ig = [["text", NE], ["linkify", UE], ["newline", qE], ["escape", GE], ["backticks", WE], ["strikethrough", R1.tokenize], ["emphasis", A1.tokenize], ["link", KE], ["image", JE], ["autolink", tR], ["html_inline", oR], ["entity", lR]], ng = [["balance_pairs", uR], ["strikethrough", R1.postProcess], ["emphasis", A1.postProcess], ["fragments_join", cR]];
function uh() {
  this.ruler = new Yn();
  for (let r = 0; r < ig.length; r++) this.ruler.push(ig[r][0], ig[r][1]);
  this.ruler2 = new Yn();
  for (let r = 0; r < ng.length; r++) this.ruler2.push(ng[r][0], ng[r][1]);
}
uh.prototype.skipToken = function(r) {
  const i = r.pos, l = this.ruler.getRules(""), d = l.length, f = r.md.options.maxNesting, g = r.cache;
  if (typeof g[i] < "u") {
    r.pos = g[i];
    return;
  }
  let m = false;
  if (r.level < f) {
    for (let s = 0; s < d; s++) if (r.level++, m = l[s](r, true), r.level--, m) {
      if (i >= r.pos) throw new Error("inline rule didn't increment state.pos");
      break;
    }
  } else r.pos = r.posMax;
  m || r.pos++, g[i] = r.pos;
};
uh.prototype.tokenize = function(r) {
  const i = this.ruler.getRules(""), l = i.length, d = r.posMax, f = r.md.options.maxNesting;
  for (; r.pos < d; ) {
    const g = r.pos;
    let m = false;
    if (r.level < f) {
      for (let s = 0; s < l; s++) if (m = i[s](r, false), m) {
        if (g >= r.pos) throw new Error("inline rule didn't increment state.pos");
        break;
      }
    }
    if (m) {
      if (r.pos >= d) break;
      continue;
    }
    r.pending += r.src[r.pos++];
  }
  r.pending && r.pushPending();
};
uh.prototype.parse = function(r, i, l, d) {
  const f = new this.State(r, i, l, d);
  this.tokenize(f);
  const g = this.ruler2.getRules(""), m = g.length;
  for (let s = 0; s < m; s++) g[s](f);
};
uh.prototype.State = lh;
function dR(r) {
  const i = {};
  r = r || {}, i.src_Any = y1.source, i.src_Cc = b1.source, i.src_Z = w1.source, i.src_P = o0.source, i.src_ZPCc = [i.src_Z, i.src_P, i.src_Cc].join("|"), i.src_ZCc = [i.src_Z, i.src_Cc].join("|");
  const l = "[><\uFF5C]";
  return i.src_pseudo_letter = "(?:(?!" + l + "|" + i.src_ZPCc + ")" + i.src_Any + ")", i.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", i.src_auth = "(?:(?:(?!" + i.src_ZCc + "|[@/\\[\\]()]).)+@)?", i.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", i.src_host_terminator = "(?=$|" + l + "|" + i.src_ZPCc + ")(?!" + (r["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + i.src_ZPCc + "))", i.src_path = "(?:[/?#](?:(?!" + i.src_ZCc + "|" + l + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + i.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + i.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + i.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + i.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + i.src_ZCc + "|[']).)+\\'|\\'(?=" + i.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + i.src_ZCc + "|[.]|$)|" + (r["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + i.src_ZCc + "|$)|;(?!" + i.src_ZCc + "|$)|\\!+(?!" + i.src_ZCc + "|[!]|$)|\\?(?!" + i.src_ZCc + "|[?]|$))+|\\/)?", i.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', i.src_xn = "xn--[a-z0-9\\-]{1,59}", i.src_domain_root = "(?:" + i.src_xn + "|" + i.src_pseudo_letter + "{1,63})", i.src_domain = "(?:" + i.src_xn + "|(?:" + i.src_pseudo_letter + ")|(?:" + i.src_pseudo_letter + "(?:-|" + i.src_pseudo_letter + "){0,61}" + i.src_pseudo_letter + "))", i.src_host = "(?:(?:(?:(?:" + i.src_domain + ")\\.)*" + i.src_domain + "))", i.tpl_host_fuzzy = "(?:" + i.src_ip4 + "|(?:(?:(?:" + i.src_domain + ")\\.)+(?:%TLDS%)))", i.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + i.src_domain + ")\\.)+(?:%TLDS%))", i.src_host_strict = i.src_host + i.src_host_terminator, i.tpl_host_fuzzy_strict = i.tpl_host_fuzzy + i.src_host_terminator, i.src_host_port_strict = i.src_host + i.src_port + i.src_host_terminator, i.tpl_host_port_fuzzy_strict = i.tpl_host_fuzzy + i.src_port + i.src_host_terminator, i.tpl_host_port_no_ip_fuzzy_strict = i.tpl_host_no_ip_fuzzy + i.src_port + i.src_host_terminator, i.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + i.src_ZPCc + "|>|$))", i.tpl_email_fuzzy = "(^|" + l + '|"|\\(|' + i.src_ZCc + ")(" + i.src_email_name + "@" + i.tpl_host_fuzzy_strict + ")", i.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + i.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + i.tpl_host_port_fuzzy_strict + i.src_path + ")", i.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + i.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + i.tpl_host_port_no_ip_fuzzy_strict + i.src_path + ")", i;
}
function Lg(r) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(l) {
    l && Object.keys(l).forEach(function(d) {
      r[d] = l[d];
    });
  }), r;
}
function yp(r) {
  return Object.prototype.toString.call(r);
}
function hR(r) {
  return yp(r) === "[object String]";
}
function fR(r) {
  return yp(r) === "[object Object]";
}
function pR(r) {
  return yp(r) === "[object RegExp]";
}
function vy(r) {
  return yp(r) === "[object Function]";
}
function mR(r) {
  return r.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
const D1 = { fuzzyLink: true, fuzzyEmail: true, fuzzyIP: false };
function gR(r) {
  return Object.keys(r || {}).reduce(function(i, l) {
    return i || D1.hasOwnProperty(l);
  }, false);
}
const vR = { "http:": { validate: function(r, i, l) {
  const d = r.slice(i);
  return l.re.http || (l.re.http = new RegExp("^\\/\\/" + l.re.src_auth + l.re.src_host_port_strict + l.re.src_path, "i")), l.re.http.test(d) ? d.match(l.re.http)[0].length : 0;
} }, "https:": "http:", "ftp:": "http:", "//": { validate: function(r, i, l) {
  const d = r.slice(i);
  return l.re.no_http || (l.re.no_http = new RegExp("^" + l.re.src_auth + "(?:localhost|(?:(?:" + l.re.src_domain + ")\\.)+" + l.re.src_domain_root + ")" + l.re.src_port + l.re.src_host_terminator + l.re.src_path, "i")), l.re.no_http.test(d) ? i >= 3 && r[i - 3] === ":" || i >= 3 && r[i - 3] === "/" ? 0 : d.match(l.re.no_http)[0].length : 0;
} }, "mailto:": { validate: function(r, i, l) {
  const d = r.slice(i);
  return l.re.mailto || (l.re.mailto = new RegExp("^" + l.re.src_email_name + "@" + l.re.src_host_strict, "i")), l.re.mailto.test(d) ? d.match(l.re.mailto)[0].length : 0;
} } }, _R = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", yR = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
function bR(r) {
  r.__index__ = -1, r.__text_cache__ = "";
}
function xR(r) {
  return function(i, l) {
    const d = i.slice(l);
    return r.test(d) ? d.match(r)[0].length : 0;
  };
}
function _y() {
  return function(r, i) {
    i.normalize(r);
  };
}
function Qf(r) {
  const i = r.re = dR(r.__opts__), l = r.__tlds__.slice();
  r.onCompile(), r.__tlds_replaced__ || l.push(_R), l.push(i.src_xn), i.src_tlds = l.join("|");
  function d(s) {
    return s.replace("%TLDS%", i.src_tlds);
  }
  i.email_fuzzy = RegExp(d(i.tpl_email_fuzzy), "i"), i.link_fuzzy = RegExp(d(i.tpl_link_fuzzy), "i"), i.link_no_ip_fuzzy = RegExp(d(i.tpl_link_no_ip_fuzzy), "i"), i.host_fuzzy_test = RegExp(d(i.tpl_host_fuzzy_test), "i");
  const f = [];
  r.__compiled__ = {};
  function g(s, C) {
    throw new Error('(LinkifyIt) Invalid schema "' + s + '": ' + C);
  }
  Object.keys(r.__schemas__).forEach(function(s) {
    const C = r.__schemas__[s];
    if (C === null) return;
    const T = { validate: null, link: null };
    if (r.__compiled__[s] = T, fR(C)) {
      pR(C.validate) ? T.validate = xR(C.validate) : vy(C.validate) ? T.validate = C.validate : g(s, C), vy(C.normalize) ? T.normalize = C.normalize : C.normalize ? g(s, C) : T.normalize = _y();
      return;
    }
    if (hR(C)) {
      f.push(s);
      return;
    }
    g(s, C);
  }), f.forEach(function(s) {
    r.__compiled__[r.__schemas__[s]] && (r.__compiled__[s].validate = r.__compiled__[r.__schemas__[s]].validate, r.__compiled__[s].normalize = r.__compiled__[r.__schemas__[s]].normalize);
  }), r.__compiled__[""] = { validate: null, normalize: _y() };
  const m = Object.keys(r.__compiled__).filter(function(s) {
    return s.length > 0 && r.__compiled__[s];
  }).map(mR).join("|");
  r.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + i.src_ZPCc + "))(" + m + ")", "i"), r.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + i.src_ZPCc + "))(" + m + ")", "ig"), r.re.schema_at_start = RegExp("^" + r.re.schema_search.source, "i"), r.re.pretest = RegExp("(" + r.re.schema_test.source + ")|(" + r.re.host_fuzzy_test.source + ")|@", "i"), bR(r);
}
function wR(r, i) {
  const l = r.__index__, d = r.__last_index__, f = r.__text_cache__.slice(l, d);
  this.schema = r.__schema__.toLowerCase(), this.index = l + i, this.lastIndex = d + i, this.raw = f, this.text = f, this.url = f;
}
function Bg(r, i) {
  const l = new wR(r, i);
  return r.__compiled__[l.schema].normalize(l, r), l;
}
function mo(r, i) {
  if (!(this instanceof mo)) return new mo(r, i);
  i || gR(r) && (i = r, r = {}), this.__opts__ = Lg({}, D1, i), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = Lg({}, vR, r), this.__compiled__ = {}, this.__tlds__ = yR, this.__tlds_replaced__ = false, this.re = {}, Qf(this);
}
mo.prototype.add = function(i, l) {
  return this.__schemas__[i] = l, Qf(this), this;
};
mo.prototype.set = function(i) {
  return this.__opts__ = Lg(this.__opts__, i), this;
};
mo.prototype.test = function(i) {
  if (this.__text_cache__ = i, this.__index__ = -1, !i.length) return false;
  let l, d, f, g, m, s, C, T, M;
  if (this.re.schema_test.test(i)) {
    for (C = this.re.schema_search, C.lastIndex = 0; (l = C.exec(i)) !== null; ) if (g = this.testSchemaAt(i, l[2], C.lastIndex), g) {
      this.__schema__ = l[2], this.__index__ = l.index + l[1].length, this.__last_index__ = l.index + l[0].length + g;
      break;
    }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (T = i.search(this.re.host_fuzzy_test), T >= 0 && (this.__index__ < 0 || T < this.__index__) && (d = i.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (m = d.index + d[1].length, (this.__index__ < 0 || m < this.__index__) && (this.__schema__ = "", this.__index__ = m, this.__last_index__ = d.index + d[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (M = i.indexOf("@"), M >= 0 && (f = i.match(this.re.email_fuzzy)) !== null && (m = f.index + f[1].length, s = f.index + f[0].length, (this.__index__ < 0 || m < this.__index__ || m === this.__index__ && s > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = m, this.__last_index__ = s))), this.__index__ >= 0;
};
mo.prototype.pretest = function(i) {
  return this.re.pretest.test(i);
};
mo.prototype.testSchemaAt = function(i, l, d) {
  return this.__compiled__[l.toLowerCase()] ? this.__compiled__[l.toLowerCase()].validate(i, d, this) : 0;
};
mo.prototype.match = function(i) {
  const l = [];
  let d = 0;
  this.__index__ >= 0 && this.__text_cache__ === i && (l.push(Bg(this, d)), d = this.__last_index__);
  let f = d ? i.slice(d) : i;
  for (; this.test(f); ) l.push(Bg(this, d)), f = f.slice(this.__last_index__), d += this.__last_index__;
  return l.length ? l : null;
};
mo.prototype.matchAtStart = function(i) {
  if (this.__text_cache__ = i, this.__index__ = -1, !i.length) return null;
  const l = this.re.schema_at_start.exec(i);
  if (!l) return null;
  const d = this.testSchemaAt(i, l[2], l[0].length);
  return d ? (this.__schema__ = l[2], this.__index__ = l.index + l[1].length, this.__last_index__ = l.index + l[0].length + d, Bg(this, 0)) : null;
};
mo.prototype.tlds = function(i, l) {
  return i = Array.isArray(i) ? i : [i], l ? (this.__tlds__ = this.__tlds__.concat(i).sort().filter(function(d, f, g) {
    return d !== g[f - 1];
  }).reverse(), Qf(this), this) : (this.__tlds__ = i.slice(), this.__tlds_replaced__ = true, Qf(this), this);
};
mo.prototype.normalize = function(i) {
  i.schema || (i.url = "http://" + i.url), i.schema === "mailto:" && !/^mailto:/i.test(i.url) && (i.url = "mailto:" + i.url);
};
mo.prototype.onCompile = function() {
};
const Yu = 2147483647, ha = 36, c0 = 1, Jd = 26, CR = 38, SR = 700, z1 = 72, F1 = 128, L1 = "-", kR = /^xn--/, PR = /[^\0-\x7F]/, TR = /[\x2E\u3002\uFF0E\uFF61]/g, IR = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, og = ha - c0, fa = Math.floor, ag = String.fromCharCode;
function vs(r) {
  throw new RangeError(IR[r]);
}
function MR(r, i) {
  const l = [];
  let d = r.length;
  for (; d--; ) l[d] = i(r[d]);
  return l;
}
function B1(r, i) {
  const l = r.split("@");
  let d = "";
  l.length > 1 && (d = l[0] + "@", r = l[1]), r = r.replace(TR, ".");
  const f = r.split("."), g = MR(f, i).join(".");
  return d + g;
}
function O1(r) {
  const i = [];
  let l = 0;
  const d = r.length;
  for (; l < d; ) {
    const f = r.charCodeAt(l++);
    if (f >= 55296 && f <= 56319 && l < d) {
      const g = r.charCodeAt(l++);
      (g & 64512) == 56320 ? i.push(((f & 1023) << 10) + (g & 1023) + 65536) : (i.push(f), l--);
    } else i.push(f);
  }
  return i;
}
const ER = (r) => String.fromCodePoint(...r), RR = function(r) {
  return r >= 48 && r < 58 ? 26 + (r - 48) : r >= 65 && r < 91 ? r - 65 : r >= 97 && r < 123 ? r - 97 : ha;
}, yy = function(r, i) {
  return r + 22 + 75 * (r < 26) - ((i != 0) << 5);
}, $1 = function(r, i, l) {
  let d = 0;
  for (r = l ? fa(r / SR) : r >> 1, r += fa(r / i); r > og * Jd >> 1; d += ha) r = fa(r / og);
  return fa(d + (og + 1) * r / (r + CR));
}, j1 = function(r) {
  const i = [], l = r.length;
  let d = 0, f = F1, g = z1, m = r.lastIndexOf(L1);
  m < 0 && (m = 0);
  for (let s = 0; s < m; ++s) r.charCodeAt(s) >= 128 && vs("not-basic"), i.push(r.charCodeAt(s));
  for (let s = m > 0 ? m + 1 : 0; s < l; ) {
    const C = d;
    for (let M = 1, z = ha; ; z += ha) {
      s >= l && vs("invalid-input");
      const L = RR(r.charCodeAt(s++));
      L >= ha && vs("invalid-input"), L > fa((Yu - d) / M) && vs("overflow"), d += L * M;
      const A = z <= g ? c0 : z >= g + Jd ? Jd : z - g;
      if (L < A) break;
      const O = ha - A;
      M > fa(Yu / O) && vs("overflow"), M *= O;
    }
    const T = i.length + 1;
    g = $1(d - C, T, C == 0), fa(d / T) > Yu - f && vs("overflow"), f += fa(d / T), d %= T, i.splice(d++, 0, f);
  }
  return String.fromCodePoint(...i);
}, N1 = function(r) {
  const i = [];
  r = O1(r);
  const l = r.length;
  let d = F1, f = 0, g = z1;
  for (const C of r) C < 128 && i.push(ag(C));
  const m = i.length;
  let s = m;
  for (m && i.push(L1); s < l; ) {
    let C = Yu;
    for (const M of r) M >= d && M < C && (C = M);
    const T = s + 1;
    C - d > fa((Yu - f) / T) && vs("overflow"), f += (C - d) * T, d = C;
    for (const M of r) if (M < d && ++f > Yu && vs("overflow"), M === d) {
      let z = f;
      for (let L = ha; ; L += ha) {
        const A = L <= g ? c0 : L >= g + Jd ? Jd : L - g;
        if (z < A) break;
        const O = z - A, V = ha - A;
        i.push(ag(yy(A + O % V, 0))), z = fa(O / V);
      }
      i.push(ag(yy(z, 0))), g = $1(f, T, s === m), f = 0, ++s;
    }
    ++f, ++d;
  }
  return i.join("");
}, AR = function(r) {
  return B1(r, function(i) {
    return kR.test(i) ? j1(i.slice(4).toLowerCase()) : i;
  });
}, DR = function(r) {
  return B1(r, function(i) {
    return PR.test(i) ? "xn--" + N1(i) : i;
  });
}, V1 = { version: "2.3.1", ucs2: { decode: O1, encode: ER }, decode: j1, encode: N1, toASCII: DR, toUnicode: AR }, zR = { options: { html: false, xhtmlOut: false, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 100 }, components: { core: {}, block: {}, inline: {} } }, FR = { options: { html: false, xhtmlOut: false, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 20 }, components: { core: { rules: ["normalize", "block", "inline", "text_join"] }, block: { rules: ["paragraph"] }, inline: { rules: ["text"], rules2: ["balance_pairs", "fragments_join"] } } }, LR = { options: { html: true, xhtmlOut: true, breaks: false, langPrefix: "language-", linkify: false, typographer: false, quotes: "\u201C\u201D\u2018\u2019", highlight: null, maxNesting: 20 }, components: { core: { rules: ["normalize", "block", "inline", "text_join"] }, block: { rules: ["blockquote", "code", "fence", "heading", "hr", "html_block", "lheading", "list", "reference", "paragraph"] }, inline: { rules: ["autolink", "backticks", "emphasis", "entity", "escape", "html_inline", "image", "link", "newline", "text"], rules2: ["balance_pairs", "emphasis", "fragments_join"] } } }, BR = { default: zR, zero: FR, commonmark: LR }, OR = /^(vbscript|javascript|file|data):/, $R = /^data:image\/(gif|png|jpeg|webp);/;
function jR(r) {
  const i = r.trim().toLowerCase();
  return OR.test(i) ? $R.test(i) : true;
}
const U1 = ["http:", "https:", "mailto:"];
function NR(r) {
  const i = n0(r, true);
  if (i.hostname && (!i.protocol || U1.indexOf(i.protocol) >= 0)) try {
    i.hostname = V1.toASCII(i.hostname);
  } catch {
  }
  return sh(i0(i));
}
function VR(r) {
  const i = n0(r, true);
  if (i.hostname && (!i.protocol || U1.indexOf(i.protocol) >= 0)) try {
    i.hostname = V1.toUnicode(i.hostname);
  } catch {
  }
  return ic(i0(i), ic.defaultChars + "%");
}
function Ro(r, i) {
  if (!(this instanceof Ro)) return new Ro(r, i);
  i || a0(r) || (i = r || {}, r = "default"), this.inline = new uh(), this.block = new _p(), this.core = new l0(), this.renderer = new cc(), this.linkify = new mo(), this.validateLink = jR, this.normalizeLink = NR, this.normalizeLinkText = VR, this.utils = qM, this.helpers = gp({}, HM), this.options = {}, this.configure(r), i && this.set(i);
}
Ro.prototype.set = function(r) {
  return gp(this.options, r), this;
};
Ro.prototype.configure = function(r) {
  const i = this;
  if (a0(r)) {
    const l = r;
    if (r = BR[l], !r) throw new Error('Wrong `markdown-it` preset "' + l + '", check name');
  }
  if (!r) throw new Error("Wrong `markdown-it` preset, can't be empty");
  return r.options && i.set(r.options), r.components && Object.keys(r.components).forEach(function(l) {
    r.components[l].rules && i[l].ruler.enableOnly(r.components[l].rules), r.components[l].rules2 && i[l].ruler2.enableOnly(r.components[l].rules2);
  }), this;
};
Ro.prototype.enable = function(r, i) {
  let l = [];
  Array.isArray(r) || (r = [r]), ["core", "block", "inline"].forEach(function(f) {
    l = l.concat(this[f].ruler.enable(r, true));
  }, this), l = l.concat(this.inline.ruler2.enable(r, true));
  const d = r.filter(function(f) {
    return l.indexOf(f) < 0;
  });
  if (d.length && !i) throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + d);
  return this;
};
Ro.prototype.disable = function(r, i) {
  let l = [];
  Array.isArray(r) || (r = [r]), ["core", "block", "inline"].forEach(function(f) {
    l = l.concat(this[f].ruler.disable(r, true));
  }, this), l = l.concat(this.inline.ruler2.disable(r, true));
  const d = r.filter(function(f) {
    return l.indexOf(f) < 0;
  });
  if (d.length && !i) throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + d);
  return this;
};
Ro.prototype.use = function(r) {
  const i = [this].concat(Array.prototype.slice.call(arguments, 1));
  return r.apply(r, i), this;
};
Ro.prototype.parse = function(r, i) {
  if (typeof r != "string") throw new Error("Input data should be a String");
  const l = new this.core.State(r, this, i);
  return this.core.process(l), l.tokens;
};
Ro.prototype.render = function(r, i) {
  return i = i || {}, this.renderer.render(this.parse(r, i), this.options, i);
};
Ro.prototype.parseInline = function(r, i) {
  const l = new this.core.State(r, this, i);
  return l.inlineMode = true, this.core.process(l), l.tokens;
};
Ro.prototype.renderInline = function(r, i) {
  return i = i || {}, this.renderer.render(this.parseInline(r, i), this.options, i);
};
const by = st((r) => {
  const i = Tl(new Ro(r.options ?? {}));
  for (const d of r.plugins ?? []) i.value.use(d);
  const l = ze(() => i.value.render(r.source));
  return () => F("div", { innerHTML: l.value });
}, { props: ["source", "options", "plugins"] }), UR = `Copyright (C) 2024-Present Heyan Zhu, LZ (lziii180511) , and the Trackmaker contributers. 

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see [https://www.gnu.org/licenses/](https://www.gnu.org/licenses/).
`, qR = { class: "about-view" }, GR = { id: "project", class: "section project-section" }, WR = { class: "project-header" }, ZR = { class: "project-description" }, HR = { id: "data-sources", class: "section data-sources" }, XR = ["href"], YR = { id: "credits", class: "section credits-section" }, KR = { class: "credit-content" }, JR = { key: 1 }, QR = { class: "license-text" }, eA = { class: "credit-links" }, tA = ["href"], rA = ["href"], iA = { __name: "AboutView", setup(r) {
  oc((C) => ({ "1e81317d": `${s.value}px` }));
  const i = El(), { t: l } = Eo(), d = Ae(false), f = () => {
    d.value = window.innerWidth >= 700;
  };
  Qi(() => {
    f(), window.addEventListener("resize", f);
  }), e2(() => {
    window.removeEventListener("resize", f);
  });
  const g = Ae(new URL("" + new URL("../favicon.svg", import.meta.url).href, import.meta.url).href), m = (C) => C.trim().replace(/\n([\s]*)\n/, `

`).split(`

`).map((T) => T.split(`
`).map((M) => M.trim()).join(" ")).join(`

`).trim(), s = Ae(20);
  return (C, T) => (St(), Yt("div", qR, [d.value ? (St(), Cr(te(bb), { key: 0, class: "page-anchor", "show-rail": true, "show-background": true }, { default: qe(() => [Ne(te(Bf), { title: te(l)("aboutView.sections.project"), href: "#project" }, null, 8, ["title"]), Ne(te(Bf), { title: te(l)("aboutView.sections.dataSource"), href: "#data-sources" }, null, 8, ["title"]), Ne(te(Bf), { title: te(l)("aboutView.sections.credits"), href: "#credits" }, null, 8, ["title"])]), _: 1 })) : Xr("", true), Tt("section", GR, [Ne(te(Wa), null, { default: qe(() => [Tt("div", WR, [Ne(te(jb), { width: "100", src: g.value, "preview-disabled": "" }, null, 8, ["src"]), Ne(te($5), null, { default: qe(() => [...T[0] || (T[0] = [Pr("Trackmaker", -1)])]), _: 1 })]), Tt("p", ZR, ir(te(l)("aboutView.description")), 1), Ne(te(c_), { class: "license-collapse" }, { default: qe(() => [Ne(te(d_), { title: "License", name: "license" }, { header: qe(() => [Ne(te(_l), null, { default: qe(() => [Ne(te(Pf), null, { default: qe(() => [...T[1] || (T[1] = [Pr("License", -1)])]), _: 1 }), Ne(te(Mo), { type: "info", round: "", size: "small" }, { default: qe(() => [...T[2] || (T[2] = [Pr(" GPL ", -1)])]), _: 1 })]), _: 1 })]), default: qe(() => [Ne(te(by), { source: te(UR), class: "license-text" }, null, 8, ["source"])]), _: 1 })]), _: 1 })]), _: 1 })]), Tt("section", HR, [Ne(te(Wa), null, { header: qe(() => [Pr(ir(te(l)("aboutView.sections.dataSource")), 1)]), footer: qe(() => [Ne(te(by), { source: te(l)("aboutView.mapInaccuracyDeclaration"), class: "markdown-resource" }, null, 8, ["source"])]), default: qe(() => [Ne(te(fp), null, { default: qe(() => [(St(true), Yt(Gr, null, hn(te(t2), (M) => (St(), Cr(te(pp), { key: M.id }, { default: qe(() => [Ne(te(_l), null, { default: qe(() => [Ne(te(Pf), null, { default: qe(() => [Pr(ir(M.name), 1)]), _: 2 }, 1024), M.license ? (St(), Cr(te(Mo), { key: 0, type: "info", round: "", size: "small" }, { default: qe(() => [Pr(ir(M.license), 1)]), _: 2 }, 1024)) : Xr("", true)]), _: 2 }, 1024)]), suffix: qe(() => [Tt("a", { href: M.url, class: "external-link" }, [Ne(te(Ii), { size: s.value, color: te(i).textColor1 }, { default: qe(() => [Ne(te(i_))]), _: 1 }, 8, ["size", "color"])], 8, XR)]), _: 2 }, 1024))), 128))]), _: 1 })]), _: 1 })]), Tt("section", YR, [Ne(te(Wa), { hoverable: "" }, { header: qe(() => [Pr(ir(te(l)("aboutView.sections.credits")), 1)]), default: qe(() => [Ne(te(Pf), null, { default: qe(() => [Pr(ir(te(l)("aboutView.creditIntro")), 1)]), _: 1 }), Ne(te(c_), { accordion: "", class: "credits-list", "trigger-areas": ["arrow", "main"] }, { default: qe(() => [(St(true), Yt(Gr, null, hn(te(r2).sort((M, z) => M.name.localeCompare(z.name)), (M) => (St(), Cr(te(d_), { key: M.id, title: M.name, name: M.id }, { header: qe(() => [Ne(te(_l), null, { default: qe(() => [Pr(ir(M.name) + " ", 1), M.licenseType.trim() ? (St(), Cr(te(_l), { key: 0 }, { default: qe(() => [(St(true), Yt(Gr, null, hn(M.licenseType.trim().split(",").map((z) => z.trim()), (z) => (St(), Cr(te(Mo), { key: z, round: "", type: "info", size: "small" }, { default: qe(() => [Pr(ir(z), 1)]), _: 2 }, 1024))), 128))]), _: 2 }, 1024)) : Xr("", true)]), _: 2 }, 1024)]), "header-extra": qe(() => [Tt("div", eA, [M.homepage ? (St(), Yt("a", { key: 0, href: M.homepage }, [Ne(te(Ii), { size: s.value, color: te(i).textColor1 }, { default: qe(() => [Ne(te(i_))]), _: 1 }, 8, ["size", "color"])], 8, tA)) : Xr("", true), M.url ? (St(), Yt("a", { key: 1, href: M.url }, [Ne(te(Ii), { size: s.value, color: te(i).textColor1 }, { default: qe(() => [M.url.includes("github") ? (St(), Cr(te(f3), { key: 0 })) : (St(), Cr(te(lb), { key: 1 }))]), _: 2 }, 1032, ["size", "color"])], 8, rA)) : Xr("", true)])]), default: qe(() => [Tt("div", KR, [Tt("p", null, ir(M.description), 1), M.license.trim() ? (St(), Cr(te(LP), { key: 0 })) : Xr("", true), M.license ? (St(), Yt("div", JR, [Ne(te(Pf), null, { default: qe(() => [...T[3] || (T[3] = [Tt("strong", null, "License:", -1)])]), _: 1 }), Tt("div", QR, [Tt("pre", null, ir(m(M.license)), 1)])])) : Xr("", true)])]), _: 2 }, 1032, ["title", "name"]))), 128))]), _: 1 })]), _: 1 })])]));
} }, q1 = go(iA, [["__scopeId", "data-v-e19031a0"]]), nA = Object.freeze(Object.defineProperty({ __proto__: null, default: q1 }, Symbol.toStringTag, { value: "Module" })), oA = { class: "settings-view" }, aA = { class: "settings-layout" }, sA = { class: "settings-content" }, lA = { style: { display: "flex", "flex-direction": "row", "justify-content": "space-between", "align-items": "center", "min-width": "0" } }, uA = { key: 0 }, cA = { key: 1 }, dA = { key: 2 }, hA = { key: 0, class: "settings-nav" }, fA = st({ __name: "SettingsView", setup(r) {
  const i = new Gg(), l = ze(() => i.isMobile), { width: d } = Hy(), f = ze(() => d.value < 800), g = ze(() => d.value < 680), { t: m, availableLocales: s } = Eo(), C = fr("settings"), T = ze(() => [{ title: "appearance", items: [{ title: "theme", type: "radio", items: [{ value: "light", label: m("settings.appearance.theme.options.light") }, { value: "dark", label: m("settings.appearance.theme.options.dark") }, { value: "system", label: m("settings.appearance.theme.options.system") }] }] }, { title: "geolocation", items: [{ title: "watchCompatibilityMode", type: "checkbox" }, { title: "geolocationCorrection", type: "checkbox" }] }, { title: "language", items: [{ title: "interfaceLanguage", type: "select", items: s.map((M) => ({ value: M, label: m(`settings.language.interfaceLanguage.options.${M}`) })) }, { title: "mapLanguage", type: "select", items: s.map((M) => ({ value: M, label: m(`settings.language.mapLanguage.options.${M}`) })).concat([{ value: "interface", label: m("settings.language.mapLanguage.options.interface") }]) }] }]);
  return Qi(() => {
    C.init();
  }), (M, z) => (St(), Yt("div", oA, [Tt("div", aA, [Tt("div", sA, [(St(true), Yt(Gr, null, hn(T.value, (L) => (St(), Cr(te(Wa), { id: "appearance", key: L.title, title: M.$t(`settings.${L.title}.title`) }, { default: qe(() => [Ne(te(fp), null, { default: qe(() => [(St(true), Yt(Gr, null, hn(L.items, (A) => (St(), Cr(te(pp), { key: A.title }, { default: qe(() => [Tt("div", lA, [Ne(te(DP), { style: { "white-space": "nowrap" }, tooltip: { trigger: l.value ? "click" : "hover" } }, { tooltip: qe(() => [Pr(ir(A.items ? M.$t(`settings.${L.title}.${A.title}.title`) : M.$t(`settings.${L.title}.${A.title}`)), 1)]), default: qe(() => [Pr(ir(A.items ? M.$t(`settings.${L.title}.${A.title}.title`) : M.$t(`settings.${L.title}.${A.title}`)) + " ", 1)]), _: 2 }, 1032, ["tooltip"]), A.type === "radio" ? (St(), Yt("div", uA, [f.value ? (St(), Cr(te(yg), { key: 1, value: te(C).settings[A.title], "onUpdate:value": (O) => te(C).settings[A.title] = O, options: A.items, "consistent-menu-width": false }, null, 8, ["value", "onUpdate:value", "options"])) : (St(), Cr(te(RP), { key: 0, value: te(C).settings[A.title], "onUpdate:value": (O) => te(C).settings[A.title] = O }, { default: qe(() => [(St(true), Yt(Gr, null, hn(A.items, (O) => (St(), Cr(te(TP), { key: O.value, value: O.value, label: O.label, checked: te(C).settings[A.title] === O.value }, null, 8, ["value", "label", "checked"]))), 128))]), _: 2 }, 1032, ["value", "onUpdate:value"]))])) : A.type === "select" ? (St(), Yt("div", cA, [Ne(te(yg), { value: te(C).settings[A.title], "onUpdate:value": (O) => te(C).settings[A.title] = O, options: A.items, "consistent-menu-width": false }, null, 8, ["value", "onUpdate:value", "options"])])) : A.type === "checkbox" ? (St(), Yt("div", dA, [Ne(te(qb), { value: te(C).settings[A.title], "onUpdate:value": (O) => te(C).settings[A.title] = O }, null, 8, ["value", "onUpdate:value"])])) : Xr("", true)])]), _: 2 }, 1024))), 128))]), _: 2 }, 1024)]), _: 2 }, 1032, ["title"]))), 128))]), g.value ? Xr("", true) : (St(), Yt("div", hA, [Ne(te(bb), { "show-rail": true, style: { width: "128px" } }, { default: qe(() => [(St(true), Yt(Gr, null, hn(T.value, (L) => (St(), Cr(te(Bf), { key: L.title, title: M.$t(`settings.${L.title}.title`), href: `#${L.title.toLowerCase()}` }, null, 8, ["title", "href"]))), 128))]), _: 1 })]))])]));
} }), G1 = go(fA, [["__scopeId", "data-v-eb834239"]]), pA = Object.freeze(Object.defineProperty({ __proto__: null, default: G1 }, Symbol.toStringTag, { value: "Module" })), yA = oC({ history: aC("./"), routes: [{ path: "/", redirect: "/tracker" }, { path: "/tracker", name: "Tracker", component: _f() ? v1 : () => vf(() => Promise.resolve().then(() => c4), void 0, import.meta.url), meta: { timeout: 5e3 } }, { path: "/sketch-centre", name: "sketchCentre", component: _f() ? _1 : () => vf(() => Promise.resolve().then(() => iM), void 0, import.meta.url) }, { path: "/about", name: "about", component: _f() ? q1 : () => vf(() => Promise.resolve().then(() => nA), void 0, import.meta.url) }, { path: "/settings", name: "settings", component: _f() ? G1 : () => vf(() => Promise.resolve().then(() => pA), void 0, import.meta.url) }] });
export {
  yA as default
};
