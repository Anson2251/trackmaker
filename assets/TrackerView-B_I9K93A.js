import { A as e, D as t, M as n, O as r, S as i, at as a, ct as o, dt as s, f as c, ft as l, g as u, h as d, ht as f, k as p, l as m, lt as h, nt as g, ot as _, pt as v, s as y, u as b, v as x, w as S } from "./Card-Cnwdt0Jy.js";
import { _ as ee, a as C, c as w, d as T, f as te, g as ne, h as re, i as ie, l as ae, m as oe, n as se, o as ce, p as le, r as ue, s as de, t as fe, u as pe, v as me, y as he } from "./sketch-store-D6GaNOqT.js";
import { H as ge, J as _e, M as ve, Q as ye, W as be, Z as xe, a as Se, m as Ce, y as we } from "./light-B0oNY7_E.js";
import { i as Te, n as Ee, r as De, t as Oe } from "./Image-BxdPvubb.js";
import { $ as ke, At as Ae, Bt as je, Dt as Me, Ft as Ne, J as Pe, Jt as E, Lt as D, Mt as Fe, Nt as Ie, Ot as Le, Pt as Re, Q as ze, Rt as Be, St as Ve, X as He, Xt as Ue, Z as We, Zt as O, _ as Ge, a as Ke, bt as qe, ct as k, dt as Je, en as A, ft as j, g as Ye, gt as M, jt as Xe, kt as N, l as Ze, lt as P, mt as F, nn as I, o as Qe, ot as L, pt as R, rn as z, rt as $e, st as B, t as V, tn as H, tt as et, ut as U, vt as tt, zt as W } from "./index-DqD7808G.js";
import { B as nt, _ as rt, t as it } from "./text-CUPhsc1_.js";
import { n as at } from "./vue-i18n-DTGvXBeS.js";
import { I as ot, M as st, h as ct, s as lt, t as ut, y as dt, z as ft } from "./light-DN2RmaL5.js";
import { C as pt, E as mt, S as ht, c as gt, n as _t, r as vt, t as yt, w as bt } from "./storage-Clz-7Xzp.js";
import { i as xt, n as St, r as Ct, t as wt } from "./Warning-BfG5UPuO.js";
import { t as Tt } from "./fade-in-height-expand.cssr-CC2wg-eD.js";
import { n as Et, t as Dt } from "./platform-Bjzfspbz.js";
import { r as Ot } from "./light-eanwvtY1.js";
import { t as kt } from "./Space-CF4aJUuv.js";
import { t as At } from "./use-theme-vars-C4H_imDf.js";
import "./imu-C9uRV4Bw.js";
function jt(e2, t2, n2) {
  return e2 === e2 && (n2 !== void 0 && (e2 = e2 <= n2 ? e2 : n2), t2 !== void 0 && (e2 = e2 >= t2 ? e2 : t2)), e2;
}
var Mt = jt;
function Nt(e2, t2, n2) {
  return n2 === void 0 && (n2 = t2, t2 = void 0), n2 !== void 0 && (n2 = he(n2), n2 = n2 === n2 ? n2 : 0), t2 !== void 0 && (t2 = he(t2), t2 = t2 === t2 ? t2 : 0), Mt(he(e2), t2, n2);
}
var Pt = Nt, Ft = { xmlns: `http://www.w3.org/2000/svg`, "xmlns:xlink": `http://www.w3.org/1999/xlink`, viewBox: `0 0 24 24` }, It = F({ name: `BuildingCommunity`, render: function(e2, t2) {
  return N(), U(`svg`, Ft, t2[0] || (t2[0] = [Je(`<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 9l5 5v7H8v-4m0 4H3v-7l5-5m1 1V4a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v17h-8"></path><path d="M13 7v.01"></path><path d="M17 7v.01"></path><path d="M17 11v.01"></path><path d="M17 15v.01"></path></g>`, 1)]));
} }), Lt = { xmlns: `http://www.w3.org/2000/svg`, "xmlns:xlink": `http://www.w3.org/1999/xlink`, viewBox: `0 0 24 24` }, Rt = F({ name: `CurrentLocation`, render: function(e2, t2) {
  return N(), U(`svg`, Lt, t2[0] || (t2[0] = [Je(`<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><circle cx="12" cy="12" r="8"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="M20 12h2"></path><path d="M2 12h2"></path></g>`, 1)]));
} }), zt = { xmlns: `http://www.w3.org/2000/svg`, "xmlns:xlink": `http://www.w3.org/1999/xlink`, viewBox: `0 0 24 24` }, Bt = F({ name: `HandFinger`, render: function(e2, t2) {
  return N(), U(`svg`, zt, t2[0] || (t2[0] = [Je(`<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 13V4.5a1.5 1.5 0 0 1 3 0V12"></path><path d="M11 11.5v-2a1.5 1.5 0 1 1 3 0V12"></path><path d="M14 10.5a1.5 1.5 0 0 1 3 0V12"></path><path d="M17 11.5a1.5 1.5 0 0 1 3 0V16a6 6 0 0 1-6 6h-2h.208a6 6 0 0 1-5.012-2.7A69.74 69.74 0 0 1 7 19c-.312-.479-1.407-2.388-3.286-5.728a1.5 1.5 0 0 1 .536-2.022a1.867 1.867 0 0 1 2.28.28L8 13"></path></g>`, 1)]));
} }), Vt = { xmlns: `http://www.w3.org/2000/svg`, "xmlns:xlink": `http://www.w3.org/1999/xlink`, viewBox: `0 0 24 24` }, Ht = F({ name: `Line`, render: function(e2, t2) {
  return N(), U(`svg`, Vt, t2[0] || (t2[0] = [B(`g`, { fill: `none`, stroke: `currentColor`, "stroke-width": `2`, "stroke-linecap": `round`, "stroke-linejoin": `round` }, [B(`circle`, { cx: `6`, cy: `18`, r: `2` }), B(`circle`, { cx: `18`, cy: `6`, r: `2` }), B(`path`, { d: `M7.5 16.5l9-9` })], -1)]));
} }), Ut = { xmlns: `http://www.w3.org/2000/svg`, "xmlns:xlink": `http://www.w3.org/1999/xlink`, viewBox: `0 0 24 24` }, Wt = F({ name: `PlayerRecord`, render: function(e2, t2) {
  return N(), U(`svg`, Ut, t2[0] || (t2[0] = [B(`circle`, { cx: `12`, cy: `12`, r: `7`, fill: `none`, stroke: `currentColor`, "stroke-width": `2`, "stroke-linecap": `round`, "stroke-linejoin": `round` }, null, -1)]));
} }), Gt = { xmlns: `http://www.w3.org/2000/svg`, "xmlns:xlink": `http://www.w3.org/1999/xlink`, viewBox: `0 0 24 24` }, Kt = F({ name: `Square`, render: function(e2, t2) {
  return N(), U(`svg`, Gt, t2[0] || (t2[0] = [B(`rect`, { x: `4`, y: `4`, width: `16`, height: `16`, rx: `2`, fill: `none`, stroke: `currentColor`, "stroke-width": `2`, "stroke-linecap": `round`, "stroke-linejoin": `round` }, null, -1)]));
} }), qt = m(`attach`, () => M(`svg`, { viewBox: `0 0 16 16`, version: `1.1`, xmlns: `http://www.w3.org/2000/svg` }, M(`g`, { stroke: `none`, "stroke-width": `1`, fill: `none`, "fill-rule": `evenodd` }, M(`g`, { fill: `currentColor`, "fill-rule": `nonzero` }, M(`path`, { d: `M3.25735931,8.70710678 L7.85355339,4.1109127 C8.82986412,3.13460197 10.4127766,3.13460197 11.3890873,4.1109127 C12.365398,5.08722343 12.365398,6.67013588 11.3890873,7.64644661 L6.08578644,12.9497475 C5.69526215,13.3402718 5.06209717,13.3402718 4.67157288,12.9497475 C4.28104858,12.5592232 4.28104858,11.9260582 4.67157288,11.5355339 L9.97487373,6.23223305 C10.1701359,6.0369709 10.1701359,5.72038841 9.97487373,5.52512627 C9.77961159,5.32986412 9.4630291,5.32986412 9.26776695,5.52512627 L3.96446609,10.8284271 C3.18341751,11.6094757 3.18341751,12.8758057 3.96446609,13.6568542 C4.74551468,14.4379028 6.01184464,14.4379028 6.79289322,13.6568542 L12.0961941,8.35355339 C13.4630291,6.98671837 13.4630291,4.77064094 12.0961941,3.40380592 C10.7293591,2.0369709 8.51328163,2.0369709 7.14644661,3.40380592 L2.55025253,8 C2.35499039,8.19526215 2.35499039,8.51184464 2.55025253,8.70710678 C2.74551468,8.90236893 3.06209717,8.90236893 3.25735931,8.70710678 Z` }))))), Jt = m(`cancel`, () => M(`svg`, { viewBox: `0 0 16 16`, version: `1.1`, xmlns: `http://www.w3.org/2000/svg` }, M(`g`, { stroke: `none`, "stroke-width": `1`, fill: `none`, "fill-rule": `evenodd` }, M(`g`, { fill: `currentColor`, "fill-rule": `nonzero` }, M(`path`, { d: `M2.58859116,2.7156945 L2.64644661,2.64644661 C2.82001296,2.47288026 3.08943736,2.45359511 3.2843055,2.58859116 L3.35355339,2.64644661 L8,7.293 L12.6464466,2.64644661 C12.8417088,2.45118446 13.1582912,2.45118446 13.3535534,2.64644661 C13.5488155,2.84170876 13.5488155,3.15829124 13.3535534,3.35355339 L8.707,8 L13.3535534,12.6464466 C13.5271197,12.820013 13.5464049,13.0894374 13.4114088,13.2843055 L13.3535534,13.3535534 C13.179987,13.5271197 12.9105626,13.5464049 12.7156945,13.4114088 L12.6464466,13.3535534 L8,8.707 L3.35355339,13.3535534 C3.15829124,13.5488155 2.84170876,13.5488155 2.64644661,13.3535534 C2.45118446,13.1582912 2.45118446,12.8417088 2.64644661,12.6464466 L7.293,8 L2.64644661,3.35355339 C2.47288026,3.17998704 2.45359511,2.91056264 2.58859116,2.7156945 L2.64644661,2.64644661 L2.58859116,2.7156945 Z` }))))), Yt = m(`retry`, () => M(`svg`, { xmlns: `http://www.w3.org/2000/svg`, viewBox: `0 0 512 512` }, M(`path`, { d: `M320,146s24.36-12-64-12A160,160,0,1,0,416,294`, style: `fill: none; stroke: currentcolor; stroke-linecap: round; stroke-miterlimit: 10; stroke-width: 32px;` }), M(`polyline`, { points: `256 58 336 138 256 218`, style: `fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;` }))), Xt = m(`trash`, () => M(`svg`, { xmlns: `http://www.w3.org/2000/svg`, viewBox: `0 0 512 512` }, M(`path`, { d: `M432,144,403.33,419.74A32,32,0,0,1,371.55,448H140.46a32,32,0,0,1-31.78-28.26L80,144`, style: `fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;` }), M(`rect`, { x: `32`, y: `64`, width: `448`, height: `80`, rx: `16`, ry: `16`, style: `fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;` }), M(`line`, { x1: `312`, y1: `240`, x2: `200`, y2: `352`, style: `fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;` }), M(`line`, { x1: `312`, y1: `352`, x2: `200`, y2: `240`, style: `fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;` })));
const Zt = n(`n-checkbox-group`);
F({ name: `CheckboxGroup`, props: { min: Number, max: Number, size: String, value: Array, defaultValue: { type: Array, default: null }, disabled: { type: Boolean, default: void 0 }, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], onChange: [Function, Array] }, setup(e2) {
  let { mergedClsPrefixRef: n2 } = x(e2), r2 = mt(e2), { mergedSizeRef: i2, mergedDisabledRef: a2 } = r2, o2 = E(e2.defaultValue), s2 = be(L(() => e2.value), o2), c2 = L(() => {
    var _a2;
    return ((_a2 = s2.value) == null ? void 0 : _a2.length) || 0;
  }), l2 = L(() => Array.isArray(s2.value) ? new Set(s2.value) : /* @__PURE__ */ new Set());
  function u2(n3, i3) {
    let { nTriggerFormInput: a3, nTriggerFormChange: c3 } = r2, { onChange: l3, "onUpdate:value": u3, onUpdateValue: d2 } = e2;
    if (Array.isArray(s2.value)) {
      let e3 = Array.from(s2.value), r3 = e3.findIndex((e4) => e4 === i3);
      n3 ? ~r3 || (e3.push(i3), d2 && t(d2, e3, { actionType: `check`, value: i3 }), u3 && t(u3, e3, { actionType: `check`, value: i3 }), a3(), c3(), o2.value = e3, l3 && t(l3, e3)) : ~r3 && (e3.splice(r3, 1), d2 && t(d2, e3, { actionType: `uncheck`, value: i3 }), u3 && t(u3, e3, { actionType: `uncheck`, value: i3 }), l3 && t(l3, e3), o2.value = e3, a3(), c3());
    } else n3 ? (d2 && t(d2, [i3], { actionType: `check`, value: i3 }), u3 && t(u3, [i3], { actionType: `check`, value: i3 }), l3 && t(l3, [i3]), o2.value = [i3], a3(), c3()) : (d2 && t(d2, [], { actionType: `uncheck`, value: i3 }), u3 && t(u3, [], { actionType: `uncheck`, value: i3 }), l3 && t(l3, []), o2.value = [], a3(), c3());
  }
  return Ae(Zt, { checkedCountRef: c2, maxRef: O(e2, `max`), minRef: O(e2, `min`), valueSetRef: l2, disabledRef: a2, mergedSizeRef: i2, toggleCheckbox: u2 }), { mergedClsPrefix: n2 };
}, render() {
  return M(`div`, { class: `${this.mergedClsPrefix}-checkbox-group`, role: `group` }, this.$slots);
} });
var Qt = () => M(`svg`, { viewBox: `0 0 64 64`, class: `check-icon` }, M(`path`, { d: `M50.42,16.76L22.34,39.45l-8.1-11.46c-1.12-1.58-3.3-1.96-4.88-0.84c-1.58,1.12-1.95,3.3-0.84,4.88l10.26,14.51  c0.56,0.79,1.42,1.31,2.38,1.45c0.16,0.02,0.32,0.03,0.48,0.03c0.8,0,1.57-0.27,2.2-0.78l30.99-25.03c1.5-1.21,1.74-3.42,0.52-4.92  C54.13,15.78,51.93,15.55,50.42,16.76z` })), $t = () => M(`svg`, { viewBox: `0 0 100 100`, class: `line-icon` }, M(`path`, { d: `M80.2,55.5H21.4c-2.8,0-5.1-2.5-5.1-5.5l0,0c0-3,2.3-5.5,5.1-5.5h58.7c2.8,0,5.1,2.5,5.1,5.5l0,0C85.2,53.1,82.9,55.5,80.2,55.5z` })), en = a([_(`checkbox`, `
 font-size: var(--n-font-size);
 outline: none;
 cursor: pointer;
 display: inline-flex;
 flex-wrap: nowrap;
 align-items: flex-start;
 word-break: break-word;
 line-height: var(--n-size);
 --n-merged-color-table: var(--n-color-table);
 `, [h(`show-label`, `line-height: var(--n-label-line-height);`), a(`&:hover`, [_(`checkbox-box`, [o(`border`, `border: var(--n-border-checked);`)])]), a(`&:focus:not(:active)`, [_(`checkbox-box`, [o(`border`, `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), h(`inside-table`, [_(`checkbox-box`, `
 background-color: var(--n-merged-color-table);
 `)]), h(`checked`, [_(`checkbox-box`, `
 background-color: var(--n-color-checked);
 `, [_(`checkbox-icon`, [a(`.check-icon`, `
 opacity: 1;
 transform: scale(1);
 `)])])]), h(`indeterminate`, [_(`checkbox-box`, [_(`checkbox-icon`, [a(`.check-icon`, `
 opacity: 0;
 transform: scale(.5);
 `), a(`.line-icon`, `
 opacity: 1;
 transform: scale(1);
 `)])])]), h(`checked, indeterminate`, [a(`&:focus:not(:active)`, [_(`checkbox-box`, [o(`border`, `
 border: var(--n-border-checked);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), _(`checkbox-box`, `
 background-color: var(--n-color-checked);
 border-left: 0;
 border-top: 0;
 `, [o(`border`, { border: `var(--n-border-checked)` })])]), h(`disabled`, { cursor: `not-allowed` }, [h(`checked`, [_(`checkbox-box`, `
 background-color: var(--n-color-disabled-checked);
 `, [o(`border`, { border: `var(--n-border-disabled-checked)` }), _(`checkbox-icon`, [a(`.check-icon, .line-icon`, { fill: `var(--n-check-mark-color-disabled-checked)` })])])]), _(`checkbox-box`, `
 background-color: var(--n-color-disabled);
 `, [o(`border`, `
 border: var(--n-border-disabled);
 `), _(`checkbox-icon`, [a(`.check-icon, .line-icon`, `
 fill: var(--n-check-mark-color-disabled);
 `)])]), o(`label`, `
 color: var(--n-text-color-disabled);
 `)]), _(`checkbox-box-wrapper`, `
 position: relative;
 width: var(--n-size);
 flex-shrink: 0;
 flex-grow: 0;
 user-select: none;
 -webkit-user-select: none;
 `), _(`checkbox-box`, `
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 height: var(--n-size);
 width: var(--n-size);
 display: inline-block;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color 0.3s var(--n-bezier);
 `, [o(`border`, `
 transition:
 border-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border: var(--n-border);
 `), _(`checkbox-icon`, `
 display: flex;
 align-items: center;
 justify-content: center;
 position: absolute;
 left: 1px;
 right: 1px;
 top: 1px;
 bottom: 1px;
 `, [a(`.check-icon, .line-icon`, `
 width: 100%;
 fill: var(--n-check-mark-color);
 opacity: 0;
 transform: scale(0.5);
 transform-origin: center;
 transition:
 fill 0.3s var(--n-bezier),
 transform 0.3s var(--n-bezier),
 opacity 0.3s var(--n-bezier),
 border-color 0.3s var(--n-bezier);
 `), pt({ left: `1px`, top: `1px` })])]), o(`label`, `
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 user-select: none;
 -webkit-user-select: none;
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 `, [a(`&:empty`, { display: `none` })])]), l(_(`checkbox`, `
 --n-merged-color-table: var(--n-color-table-modal);
 `)), v(_(`checkbox`, `
 --n-merged-color-table: var(--n-color-table-popover);
 `))]), tn = F({ name: `Checkbox`, props: Object.assign(Object.assign({}, c.props), { size: String, checked: { type: [Boolean, String, Number], default: void 0 }, defaultChecked: { type: [Boolean, String, Number], default: false }, value: [String, Number], disabled: { type: Boolean, default: void 0 }, indeterminate: Boolean, label: String, focusable: { type: Boolean, default: true }, checkedValue: { type: [Boolean, String, Number], default: true }, uncheckedValue: { type: [Boolean, String, Number], default: false }, "onUpdate:checked": [Function, Array], onUpdateChecked: [Function, Array], privateInsideTable: Boolean, onChange: [Function, Array] }), setup(e2) {
  let n2 = tt(Zt, null), r2 = E(null), { mergedClsPrefixRef: i2, inlineThemeDisabled: a2, mergedRtlRef: o2 } = x(e2), l2 = E(e2.defaultChecked), f2 = be(O(e2, `checked`), l2), p2 = _e(() => {
    if (n2) {
      let t2 = n2.valueSetRef.value;
      return t2 && e2.value !== void 0 ? t2.has(e2.value) : false;
    } else return f2.value === e2.checkedValue;
  }), m2 = mt(e2, { mergedSize(t2) {
    let { size: r3 } = e2;
    if (r3 !== void 0) return r3;
    if (n2) {
      let { value: e3 } = n2.mergedSizeRef;
      if (e3 !== void 0) return e3;
    }
    if (t2) {
      let { mergedSize: e3 } = t2;
      if (e3 !== void 0) return e3.value;
    }
    return `medium`;
  }, mergedDisabled(t2) {
    let { disabled: r3 } = e2;
    if (r3 !== void 0) return r3;
    if (n2) {
      if (n2.disabledRef.value) return true;
      let { maxRef: { value: e3 }, checkedCountRef: t3 } = n2;
      if (e3 !== void 0 && t3.value >= e3 && !p2.value) return true;
      let { minRef: { value: r4 } } = n2;
      if (r4 !== void 0 && t3.value <= r4 && p2.value) return true;
    }
    return t2 ? t2.disabled.value : false;
  } }), { mergedDisabledRef: h2, mergedSizeRef: g2 } = m2, _2 = c(`Checkbox`, `-checkbox`, en, ft, e2, i2);
  function v2(r3) {
    if (n2 && e2.value !== void 0) n2.toggleCheckbox(!p2.value, e2.value);
    else {
      let { onChange: n3, "onUpdate:checked": i3, onUpdateChecked: a3 } = e2, { nTriggerFormInput: o3, nTriggerFormChange: s2 } = m2, c2 = p2.value ? e2.uncheckedValue : e2.checkedValue;
      i3 && t(i3, c2, r3), a3 && t(a3, c2, r3), n3 && t(n3, c2, r3), o3(), s2(), l2.value = c2;
    }
  }
  function y2(e3) {
    h2.value || v2(e3);
  }
  function b2(e3) {
    if (!h2.value) switch (e3.key) {
      case ` `:
      case `Enter`:
        v2(e3);
    }
  }
  function S2(e3) {
    switch (e3.key) {
      case ` `:
        e3.preventDefault();
    }
  }
  let ee2 = { focus: () => {
    var e3;
    (e3 = r2.value) == null || e3.focus();
  }, blur: () => {
    var e3;
    (e3 = r2.value) == null || e3.blur();
  } }, C2 = d(`Checkbox`, o2, i2), w2 = L(() => {
    let { value: e3 } = g2, { common: { cubicBezierEaseInOut: t2 }, self: { borderRadius: n3, color: r3, colorChecked: i3, colorDisabled: a3, colorTableHeader: o3, colorTableHeaderModal: c2, colorTableHeaderPopover: l3, checkMarkColor: u2, checkMarkColorDisabled: d2, border: f3, borderFocus: p3, borderDisabled: m3, borderChecked: h3, boxShadowFocus: v3, textColor: y3, textColorDisabled: b3, checkMarkColorDisabledChecked: x2, colorDisabledChecked: S3, borderDisabledChecked: ee3, labelPadding: C3, labelLineHeight: w3, labelFontWeight: T3, [s(`fontSize`, e3)]: te2, [s(`size`, e3)]: ne2 } } = _2.value;
    return { "--n-label-line-height": w3, "--n-label-font-weight": T3, "--n-size": ne2, "--n-bezier": t2, "--n-border-radius": n3, "--n-border": f3, "--n-border-checked": h3, "--n-border-focus": p3, "--n-border-disabled": m3, "--n-border-disabled-checked": ee3, "--n-box-shadow-focus": v3, "--n-color": r3, "--n-color-checked": i3, "--n-color-table": o3, "--n-color-table-modal": c2, "--n-color-table-popover": l3, "--n-color-disabled": a3, "--n-color-disabled-checked": S3, "--n-text-color": y3, "--n-text-color-disabled": b3, "--n-check-mark-color": u2, "--n-check-mark-color-disabled": d2, "--n-check-mark-color-disabled-checked": x2, "--n-font-size": te2, "--n-label-padding": C3 };
  }), T2 = a2 ? u(`checkbox`, L(() => g2.value[0]), w2, e2) : void 0;
  return Object.assign(m2, ee2, { rtlEnabled: C2, selfRef: r2, mergedClsPrefix: i2, mergedDisabled: h2, renderedChecked: p2, mergedTheme: _2, labelId: ye(), handleClick: y2, handleKeyUp: b2, handleKeyDown: S2, cssVars: a2 ? void 0 : w2, themeClass: T2 == null ? void 0 : T2.themeClass, onRender: T2 == null ? void 0 : T2.onRender });
}, render() {
  var e2;
  let { $slots: t2, renderedChecked: n2, mergedDisabled: r2, indeterminate: i2, privateInsideTable: a2, cssVars: o2, labelId: s2, label: c2, mergedClsPrefix: l2, focusable: u2, handleKeyUp: d2, handleKeyDown: f2, handleClick: p2 } = this;
  (e2 = this.onRender) == null || e2.call(this);
  let m2 = S(t2.default, (e3) => c2 || e3 ? M(`span`, { class: `${l2}-checkbox__label`, id: s2 }, c2 || e3) : null);
  return M(`div`, { ref: `selfRef`, class: [`${l2}-checkbox`, this.themeClass, this.rtlEnabled && `${l2}-checkbox--rtl`, n2 && `${l2}-checkbox--checked`, r2 && `${l2}-checkbox--disabled`, i2 && `${l2}-checkbox--indeterminate`, a2 && `${l2}-checkbox--inside-table`, m2 && `${l2}-checkbox--show-label`], tabindex: r2 || !u2 ? void 0 : 0, role: `checkbox`, "aria-checked": i2 ? `mixed` : n2, "aria-labelledby": s2, style: o2, onKeyup: d2, onKeydown: f2, onClick: p2, onMousedown: () => {
    xe(`selectstart`, window, (e3) => {
      e3.preventDefault();
    }, { once: true });
  } }, M(`div`, { class: `${l2}-checkbox-box-wrapper` }, `\xA0`, M(`div`, { class: `${l2}-checkbox-box` }, M(bt, null, { default: () => this.indeterminate ? M(`div`, { key: `indeterminate`, class: `${l2}-checkbox-icon` }, $t()) : M(`div`, { key: `check`, class: `${l2}-checkbox-icon` }, Qt()) }), M(`div`, { class: `${l2}-checkbox-box__border` }))), m2);
} }), nn = { success: M(St, null), error: M(xt, null), warning: M(wt, null), info: M(Ct, null) }, rn = F({ name: `ProgressCircle`, props: { clsPrefix: { type: String, required: true }, status: { type: String, required: true }, strokeWidth: { type: Number, required: true }, fillColor: [String, Object], railColor: String, railStyle: [String, Object], percentage: { type: Number, default: 0 }, offsetDegree: { type: Number, default: 0 }, showIndicator: { type: Boolean, required: true }, indicatorTextColor: String, unit: String, viewBoxWidth: { type: Number, required: true }, gapDegree: { type: Number, required: true }, gapOffsetDegree: { type: Number, default: 0 } }, setup(e2, { slots: t2 }) {
  let n2 = L(() => {
    let t3 = `gradient`, { fillColor: n3 } = e2;
    return typeof n3 == `object` ? `${t3}-${f(JSON.stringify(n3))}` : t3;
  });
  function r2(t3, r3, i3, a2) {
    let { gapDegree: o2, viewBoxWidth: s2, strokeWidth: c2 } = e2, l2 = 50 + c2 / 2, u2 = `M ${l2},${l2} m 0,50
      a 50,50 0 1 1 0,-100
      a 50,50 0 1 1 0,100`, d2 = Math.PI * 2 * 50;
    return { pathString: u2, pathStyle: { stroke: a2 === `rail` ? i3 : typeof e2.fillColor == `object` ? `url(#${n2.value})` : i3, strokeDasharray: `${Math.min(t3, 100) / 100 * (d2 - o2)}px ${s2 * 8}px`, strokeDashoffset: `-${o2 / 2}px`, transformOrigin: r3 ? `center` : void 0, transform: r3 ? `rotate(${r3}deg)` : void 0 } };
  }
  let i2 = () => {
    let t3 = typeof e2.fillColor == `object`, r3 = t3 ? e2.fillColor.stops[0] : ``, i3 = t3 ? e2.fillColor.stops[1] : ``;
    return t3 && M(`defs`, null, M(`linearGradient`, { id: n2.value, x1: `0%`, y1: `100%`, x2: `100%`, y2: `0%` }, M(`stop`, { offset: `0%`, "stop-color": r3 }), M(`stop`, { offset: `100%`, "stop-color": i3 })));
  };
  return () => {
    let { fillColor: n3, railColor: a2, strokeWidth: o2, offsetDegree: s2, status: c2, percentage: l2, showIndicator: u2, indicatorTextColor: d2, unit: f2, gapOffsetDegree: p2, clsPrefix: m2 } = e2, { pathString: h2, pathStyle: g2 } = r2(100, 0, a2, `rail`), { pathString: _2, pathStyle: v2 } = r2(l2, s2, n3, `fill`), y2 = 100 + o2;
    return M(`div`, { class: `${m2}-progress-content`, role: `none` }, M(`div`, { class: `${m2}-progress-graph`, "aria-hidden": true }, M(`div`, { class: `${m2}-progress-graph-circle`, style: { transform: p2 ? `rotate(${p2}deg)` : void 0 } }, M(`svg`, { viewBox: `0 0 ${y2} ${y2}` }, i2(), M(`g`, null, M(`path`, { class: `${m2}-progress-graph-circle-rail`, d: h2, "stroke-width": o2, "stroke-linecap": `round`, fill: `none`, style: g2 })), M(`g`, null, M(`path`, { class: [`${m2}-progress-graph-circle-fill`, l2 === 0 && `${m2}-progress-graph-circle-fill--empty`], d: _2, "stroke-width": o2, "stroke-linecap": `round`, fill: `none`, style: v2 }))))), u2 ? M(`div`, null, t2.default ? M(`div`, { class: `${m2}-progress-custom-content`, role: `none` }, t2.default()) : c2 === `default` ? M(`div`, { class: `${m2}-progress-text`, style: { color: d2 }, role: `none` }, M(`span`, { class: `${m2}-progress-text__percentage` }, l2), M(`span`, { class: `${m2}-progress-text__unit` }, f2)) : M(`div`, { class: `${m2}-progress-icon`, "aria-hidden": true }, M(b, { clsPrefix: m2 }, { default: () => nn[c2] }))) : null);
  };
} }), an = { success: M(St, null), error: M(xt, null), warning: M(wt, null), info: M(Ct, null) }, on = F({ name: `ProgressLine`, props: { clsPrefix: { type: String, required: true }, percentage: { type: Number, default: 0 }, railColor: String, railStyle: [String, Object], fillColor: [String, Object], status: { type: String, required: true }, indicatorPlacement: { type: String, required: true }, indicatorTextColor: String, unit: { type: String, default: `%` }, processing: { type: Boolean, required: true }, showIndicator: { type: Boolean, required: true }, height: [String, Number], railBorderRadius: [String, Number], fillBorderRadius: [String, Number] }, setup(e2, { slots: t2 }) {
  let n2 = L(() => we(e2.height)), r2 = L(() => {
    var _a2, _b;
    return typeof e2.fillColor == `object` ? `linear-gradient(to right, ${(_a2 = e2.fillColor) == null ? void 0 : _a2.stops[0]} , ${(_b = e2.fillColor) == null ? void 0 : _b.stops[1]})` : e2.fillColor;
  }), i2 = L(() => e2.railBorderRadius === void 0 ? e2.height === void 0 ? `` : we(e2.height, { c: 0.5 }) : we(e2.railBorderRadius)), a2 = L(() => e2.fillBorderRadius === void 0 ? e2.railBorderRadius === void 0 ? e2.height === void 0 ? `` : we(e2.height, { c: 0.5 }) : we(e2.railBorderRadius) : we(e2.fillBorderRadius));
  return () => {
    let { indicatorPlacement: o2, railColor: s2, railStyle: c2, percentage: l2, unit: u2, indicatorTextColor: d2, status: f2, showIndicator: p2, processing: m2, clsPrefix: h2 } = e2;
    return M(`div`, { class: `${h2}-progress-content`, role: `none` }, M(`div`, { class: `${h2}-progress-graph`, "aria-hidden": true }, M(`div`, { class: [`${h2}-progress-graph-line`, { [`${h2}-progress-graph-line--indicator-${o2}`]: true }] }, M(`div`, { class: `${h2}-progress-graph-line-rail`, style: [{ backgroundColor: s2, height: n2.value, borderRadius: i2.value }, c2] }, M(`div`, { class: [`${h2}-progress-graph-line-fill`, m2 && `${h2}-progress-graph-line-fill--processing`], style: { maxWidth: `${e2.percentage}%`, background: r2.value, height: n2.value, lineHeight: n2.value, borderRadius: a2.value } }, o2 === `inside` ? M(`div`, { class: `${h2}-progress-graph-line-indicator`, style: { color: d2 } }, t2.default ? t2.default() : `${l2}${u2}`) : null)))), p2 && o2 === `outside` ? M(`div`, null, t2.default ? M(`div`, { class: `${h2}-progress-custom-content`, style: { color: d2 }, role: `none` }, t2.default()) : f2 === `default` ? M(`div`, { role: `none`, class: `${h2}-progress-icon ${h2}-progress-icon--as-text`, style: { color: d2 } }, l2, u2) : M(`div`, { class: `${h2}-progress-icon`, "aria-hidden": true }, M(b, { clsPrefix: h2 }, { default: () => an[f2] }))) : null);
  };
} });
function sn(e2, t2, n2 = 100) {
  return `m ${n2 / 2} ${n2 / 2 - e2} a ${e2} ${e2} 0 1 1 0 ${2 * e2} a ${e2} ${e2} 0 1 1 0 -${2 * e2}`;
}
var cn = F({ name: `ProgressMultipleCircle`, props: { clsPrefix: { type: String, required: true }, viewBoxWidth: { type: Number, required: true }, percentage: { type: Array, default: [0] }, strokeWidth: { type: Number, required: true }, circleGap: { type: Number, required: true }, showIndicator: { type: Boolean, required: true }, fillColor: { type: Array, default: () => [] }, railColor: { type: Array, default: () => [] }, railStyle: { type: Array, default: () => [] } }, setup(e2, { slots: t2 }) {
  let n2 = L(() => e2.percentage.map((t3, n3) => `${Math.PI * t3 / 100 * (e2.viewBoxWidth / 2 - e2.strokeWidth / 2 * (1 + 2 * n3) - e2.circleGap * n3) * 2}, ${e2.viewBoxWidth * 8}`)), r2 = (t3, n3) => {
    let r3 = e2.fillColor[n3], i2 = typeof r3 == `object` ? r3.stops[0] : ``, a2 = typeof r3 == `object` ? r3.stops[1] : ``;
    return typeof e2.fillColor[n3] == `object` && M(`linearGradient`, { id: `gradient-${n3}`, x1: `100%`, y1: `0%`, x2: `0%`, y2: `100%` }, M(`stop`, { offset: `0%`, "stop-color": i2 }), M(`stop`, { offset: `100%`, "stop-color": a2 }));
  };
  return () => {
    let { viewBoxWidth: i2, strokeWidth: a2, circleGap: o2, showIndicator: s2, fillColor: c2, railColor: l2, railStyle: u2, percentage: d2, clsPrefix: f2 } = e2;
    return M(`div`, { class: `${f2}-progress-content`, role: `none` }, M(`div`, { class: `${f2}-progress-graph`, "aria-hidden": true }, M(`div`, { class: `${f2}-progress-graph-circle` }, M(`svg`, { viewBox: `0 0 ${i2} ${i2}` }, M(`defs`, null, d2.map((e3, t3) => r2(e3, t3))), d2.map((e3, t3) => M(`g`, { key: t3 }, M(`path`, { class: `${f2}-progress-graph-circle-rail`, d: sn(i2 / 2 - a2 / 2 * (1 + 2 * t3) - o2 * t3, a2, i2), "stroke-width": a2, "stroke-linecap": `round`, fill: `none`, style: [{ strokeDashoffset: 0, stroke: l2[t3] }, u2[t3]] }), M(`path`, { class: [`${f2}-progress-graph-circle-fill`, e3 === 0 && `${f2}-progress-graph-circle-fill--empty`], d: sn(i2 / 2 - a2 / 2 * (1 + 2 * t3) - o2 * t3, a2, i2), "stroke-width": a2, "stroke-linecap": `round`, fill: `none`, style: { strokeDasharray: n2.value[t3], strokeDashoffset: 0, stroke: typeof c2[t3] == `object` ? `url(#gradient-${t3})` : c2[t3] } })))))), s2 && t2.default ? M(`div`, null, M(`div`, { class: `${f2}-progress-text` }, t2.default())) : null);
  };
} }), ln = a([_(`progress`, { display: `inline-block` }, [_(`progress-icon`, `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 `), h(`line`, `
 width: 100%;
 display: block;
 `, [_(`progress-content`, `
 display: flex;
 align-items: center;
 `, [_(`progress-graph`, { flex: 1 })]), _(`progress-custom-content`, { marginLeft: `14px` }), _(`progress-icon`, `
 width: 30px;
 padding-left: 14px;
 height: var(--n-icon-size-line);
 line-height: var(--n-icon-size-line);
 font-size: var(--n-icon-size-line);
 `, [h(`as-text`, `
 color: var(--n-text-color-line-outer);
 text-align: center;
 width: 40px;
 font-size: var(--n-font-size);
 padding-left: 4px;
 transition: color .3s var(--n-bezier);
 `)])]), h(`circle, dashboard`, { width: `120px` }, [_(`progress-custom-content`, `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `), _(`progress-text`, `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: inherit;
 font-size: var(--n-font-size-circle);
 color: var(--n-text-color-circle);
 font-weight: var(--n-font-weight-circle);
 transition: color .3s var(--n-bezier);
 white-space: nowrap;
 `), _(`progress-icon`, `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: var(--n-icon-color);
 font-size: var(--n-icon-size-circle);
 `)]), h(`multiple-circle`, `
 width: 200px;
 color: inherit;
 `, [_(`progress-text`, `
 font-weight: var(--n-font-weight-circle);
 color: var(--n-text-color-circle);
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `)]), _(`progress-content`, { position: `relative` }), _(`progress-graph`, { position: `relative` }, [_(`progress-graph-circle`, [a(`svg`, { verticalAlign: `bottom` }), _(`progress-graph-circle-fill`, `
 stroke: var(--n-fill-color);
 transition:
 opacity .3s var(--n-bezier),
 stroke .3s var(--n-bezier),
 stroke-dasharray .3s var(--n-bezier);
 `, [h(`empty`, { opacity: 0 })]), _(`progress-graph-circle-rail`, `
 transition: stroke .3s var(--n-bezier);
 overflow: hidden;
 stroke: var(--n-rail-color);
 `)]), _(`progress-graph-line`, [h(`indicator-inside`, [_(`progress-graph-line-rail`, `
 height: 16px;
 line-height: 16px;
 border-radius: 10px;
 `, [_(`progress-graph-line-fill`, `
 height: inherit;
 border-radius: 10px;
 `), _(`progress-graph-line-indicator`, `
 background: #0000;
 white-space: nowrap;
 text-align: right;
 margin-left: 14px;
 margin-right: 14px;
 height: inherit;
 font-size: 12px;
 color: var(--n-text-color-line-inner);
 transition: color .3s var(--n-bezier);
 `)])]), h(`indicator-inside-label`, `
 height: 16px;
 display: flex;
 align-items: center;
 `, [_(`progress-graph-line-rail`, `
 flex: 1;
 transition: background-color .3s var(--n-bezier);
 `), _(`progress-graph-line-indicator`, `
 background: var(--n-fill-color);
 font-size: 12px;
 transform: translateZ(0);
 display: flex;
 vertical-align: middle;
 height: 16px;
 line-height: 16px;
 padding: 0 10px;
 border-radius: 10px;
 position: absolute;
 white-space: nowrap;
 color: var(--n-text-color-line-inner);
 transition:
 right .2s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `)]), _(`progress-graph-line-rail`, `
 position: relative;
 overflow: hidden;
 height: var(--n-rail-height);
 border-radius: 5px;
 background-color: var(--n-rail-color);
 transition: background-color .3s var(--n-bezier);
 `, [_(`progress-graph-line-fill`, `
 background: var(--n-fill-color);
 position: relative;
 border-radius: 5px;
 height: inherit;
 width: 100%;
 max-width: 0%;
 transition:
 background-color .3s var(--n-bezier),
 max-width .2s var(--n-bezier);
 `, [h(`processing`, [a(`&::after`, `
 content: "";
 background-image: var(--n-line-bg-processing);
 animation: progress-processing-animation 2s var(--n-bezier) infinite;
 `)])])])])])]), a(`@keyframes progress-processing-animation`, `
 0% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 100%;
 opacity: 1;
 }
 66% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 100% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 `)]), un = F({ name: `Progress`, props: Object.assign(Object.assign({}, c.props), { processing: Boolean, type: { type: String, default: `line` }, gapDegree: Number, gapOffsetDegree: Number, status: { type: String, default: `default` }, railColor: [String, Array], railStyle: [String, Array], color: [String, Array, Object], viewBoxWidth: { type: Number, default: 100 }, strokeWidth: { type: Number, default: 7 }, percentage: [Number, Array], unit: { type: String, default: `%` }, showIndicator: { type: Boolean, default: true }, indicatorPosition: { type: String, default: `outside` }, indicatorPlacement: { type: String, default: `outside` }, indicatorTextColor: String, circleGap: { type: Number, default: 1 }, height: Number, borderRadius: [String, Number], fillBorderRadius: [String, Number], offsetDegree: Number }), setup(e2) {
  let t2 = L(() => e2.indicatorPlacement || e2.indicatorPosition), n2 = L(() => {
    if (e2.gapDegree || e2.gapDegree === 0) return e2.gapDegree;
    if (e2.type === `dashboard`) return 75;
  }), { mergedClsPrefixRef: r2, inlineThemeDisabled: i2 } = x(e2), a2 = c(`Progress`, `-progress`, ln, dt, e2, r2), o2 = L(() => {
    let { status: t3 } = e2, { common: { cubicBezierEaseInOut: n3 }, self: { fontSize: r3, fontSizeCircle: i3, railColor: o3, railHeight: c2, iconSizeCircle: l3, iconSizeLine: u2, textColorCircle: d2, textColorLineInner: f2, textColorLineOuter: p2, lineBgProcessing: m2, fontWeightCircle: h2, [s(`iconColor`, t3)]: g2, [s(`fillColor`, t3)]: _2 } } = a2.value;
    return { "--n-bezier": n3, "--n-fill-color": _2, "--n-font-size": r3, "--n-font-size-circle": i3, "--n-font-weight-circle": h2, "--n-icon-color": g2, "--n-icon-size-circle": l3, "--n-icon-size-line": u2, "--n-line-bg-processing": m2, "--n-rail-color": o3, "--n-rail-height": c2, "--n-text-color-circle": d2, "--n-text-color-line-inner": f2, "--n-text-color-line-outer": p2 };
  }), l2 = i2 ? u(`progress`, L(() => e2.status[0]), o2, e2) : void 0;
  return { mergedClsPrefix: r2, mergedIndicatorPlacement: t2, gapDeg: n2, cssVars: i2 ? void 0 : o2, themeClass: l2 == null ? void 0 : l2.themeClass, onRender: l2 == null ? void 0 : l2.onRender };
}, render() {
  let { type: e2, cssVars: t2, indicatorTextColor: n2, showIndicator: r2, status: i2, railColor: a2, railStyle: o2, color: s2, percentage: c2, viewBoxWidth: l2, strokeWidth: u2, mergedIndicatorPlacement: d2, unit: f2, borderRadius: p2, fillBorderRadius: m2, height: h2, processing: g2, circleGap: _2, mergedClsPrefix: v2, gapDeg: y2, gapOffsetDegree: b2, themeClass: x2, $slots: S2, onRender: ee2 } = this;
  return ee2 == null ? void 0 : ee2(), M(`div`, { class: [x2, `${v2}-progress`, `${v2}-progress--${e2}`, `${v2}-progress--${i2}`], style: t2, "aria-valuemax": 100, "aria-valuemin": 0, "aria-valuenow": c2, role: e2 === `circle` || e2 === `line` || e2 === `dashboard` ? `progressbar` : `none` }, e2 === `circle` || e2 === `dashboard` ? M(rn, { clsPrefix: v2, status: i2, showIndicator: r2, indicatorTextColor: n2, railColor: a2, fillColor: s2, railStyle: o2, offsetDegree: this.offsetDegree, percentage: c2, viewBoxWidth: l2, strokeWidth: u2, gapDegree: y2 === void 0 ? e2 === `dashboard` ? 75 : 0 : y2, gapOffsetDegree: b2, unit: f2 }, S2) : e2 === `line` ? M(on, { clsPrefix: v2, status: i2, showIndicator: r2, indicatorTextColor: n2, railColor: a2, fillColor: s2, railStyle: o2, percentage: c2, processing: g2, indicatorPlacement: d2, unit: f2, fillBorderRadius: m2, railBorderRadius: p2, height: h2 }, S2) : e2 === `multiple-circle` ? M(cn, { clsPrefix: v2, strokeWidth: u2, railColor: a2, fillColor: s2, railStyle: o2, viewBoxWidth: l2, percentage: c2, showIndicator: r2, circleGap: _2 }, S2) : null);
} }), dn = a([a(`@keyframes spin-rotate`, `
 from {
 transform: rotate(0);
 }
 to {
 transform: rotate(360deg);
 }
 `), _(`spin-container`, `
 position: relative;
 `, [_(`spin-body`, `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [Ce()])]), _(`spin-body`, `
 display: inline-flex;
 align-items: center;
 justify-content: center;
 flex-direction: column;
 `), _(`spin`, `
 display: inline-flex;
 height: var(--n-size);
 width: var(--n-size);
 font-size: var(--n-size);
 color: var(--n-color);
 `, [h(`rotate`, `
 animation: spin-rotate 2s linear infinite;
 `)]), _(`spin-description`, `
 display: inline-block;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 margin-top: 8px;
 `), _(`spin-content`, `
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 pointer-events: all;
 `, [h(`spinning`, `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: none;
 opacity: var(--n-opacity-spinning);
 `)])]), fn = { small: 20, medium: 18, large: 16 }, pn = F({ name: `Spin`, props: Object.assign(Object.assign({}, c.props), { contentClass: String, contentStyle: [Object, String], description: String, stroke: String, size: { type: [String, Number], default: `medium` }, show: { type: Boolean, default: true }, strokeWidth: Number, rotate: { type: Boolean, default: true }, spinning: { type: Boolean, validator: () => true, default: void 0 }, delay: Number }), slots: Object, setup(e2) {
  let { mergedClsPrefixRef: t2, inlineThemeDisabled: n2 } = x(e2), r2 = c(`Spin`, `-spin`, dn, ct, e2, t2), i2 = L(() => {
    let { size: t3 } = e2, { common: { cubicBezierEaseInOut: n3 }, self: i3 } = r2.value, { opacitySpinning: a3, color: o3, textColor: c2 } = i3, l3 = typeof t3 == `number` ? g(t3) : i3[s(`size`, t3)];
    return { "--n-bezier": n3, "--n-opacity-spinning": a3, "--n-size": l3, "--n-color": o3, "--n-text-color": c2 };
  }), a2 = n2 ? u(`spin`, L(() => {
    let { size: t3 } = e2;
    return typeof t3 == `number` ? String(t3) : t3[0];
  }), i2, e2) : void 0, o2 = ge(e2, [`spinning`, `show`]), l2 = E(false);
  return Be((t3) => {
    let n3;
    if (o2.value) {
      let { delay: r3 } = e2;
      if (r3) {
        n3 = window.setTimeout(() => {
          l2.value = true;
        }, r3), t3(() => {
          clearTimeout(n3);
        });
        return;
      }
    }
    l2.value = o2.value;
  }), { mergedClsPrefix: t2, active: l2, mergedStrokeWidth: L(() => {
    let { strokeWidth: t3 } = e2;
    if (t3 !== void 0) return t3;
    let { size: n3 } = e2;
    return fn[typeof n3 == `number` ? `medium` : n3];
  }), cssVars: n2 ? void 0 : i2, themeClass: a2 == null ? void 0 : a2.themeClass, onRender: a2 == null ? void 0 : a2.onRender };
}, render() {
  var _a2;
  var e2;
  let { $slots: t2, mergedClsPrefix: n2, description: r2 } = this, i2 = t2.icon && this.rotate, a2 = (r2 || t2.description) && M(`div`, { class: `${n2}-spin-description` }, r2 || ((_a2 = t2.description) == null ? void 0 : _a2.call(t2))), o2 = t2.icon ? M(`div`, { class: [`${n2}-spin-body`, this.themeClass] }, M(`div`, { class: [`${n2}-spin`, i2 && `${n2}-spin--rotate`], style: t2.default ? `` : this.cssVars }, t2.icon()), a2) : M(`div`, { class: [`${n2}-spin-body`, this.themeClass] }, M(ht, { clsPrefix: n2, style: t2.default ? `` : this.cssVars, stroke: this.stroke, "stroke-width": this.mergedStrokeWidth, class: `${n2}-spin` }), a2);
  return (e2 = this.onRender) == null || e2.call(this), t2.default ? M(`div`, { class: [`${n2}-spin-container`, this.themeClass], style: this.cssVars }, M(`div`, { class: [`${n2}-spin-content`, this.active && `${n2}-spin-content--spinning`, this.contentClass], style: this.contentStyle }, t2), M(Pe, { name: `fade-in-transition` }, { default: () => this.active ? o2 : null })) : o2;
} });
const mn = n(`n-upload`);
var hn = a([_(`upload`, `width: 100%;`, [h(`dragger-inside`, [_(`upload-trigger`, `
 display: block;
 `)]), h(`drag-over`, [_(`upload-dragger`, `
 border: var(--n-dragger-border-hover);
 `)])]), _(`upload-dragger`, `
 cursor: pointer;
 box-sizing: border-box;
 width: 100%;
 text-align: center;
 border-radius: var(--n-border-radius);
 padding: 24px;
 opacity: 1;
 transition:
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 background-color: var(--n-dragger-color);
 border: var(--n-dragger-border);
 `, [a(`&:hover`, `
 border: var(--n-dragger-border-hover);
 `), h(`disabled`, `
 cursor: not-allowed;
 `)]), _(`upload-trigger`, `
 display: inline-block;
 box-sizing: border-box;
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [a(`+`, [_(`upload-file-list`, `margin-top: 8px;`)]), h(`disabled`, `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `), h(`image-card`, `
 width: 96px;
 height: 96px;
 `, [_(`base-icon`, `
 font-size: 24px;
 `), _(`upload-dragger`, `
 padding: 0;
 height: 100%;
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `)])]), _(`upload-file-list`, `
 line-height: var(--n-line-height);
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [a(`a, img`, `outline: none;`), h(`disabled`, `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `, [_(`upload-file`, `cursor: not-allowed;`)]), h(`grid`, `
 display: grid;
 grid-template-columns: repeat(auto-fill, 96px);
 grid-gap: 8px;
 margin-top: 0;
 `), _(`upload-file`, `
 display: block;
 box-sizing: border-box;
 cursor: default;
 padding: 0px 12px 0 6px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `, [Tt(), _(`progress`, [Tt({ foldPadding: true })]), a(`&:hover`, `
 background-color: var(--n-item-color-hover);
 `, [_(`upload-file-info`, [o(`action`, `
 opacity: 1;
 `)])]), h(`image-type`, `
 border-radius: var(--n-border-radius);
 text-decoration: underline;
 text-decoration-color: #0000;
 `, [_(`upload-file-info`, `
 padding-top: 0px;
 padding-bottom: 0px;
 width: 100%;
 height: 100%;
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 6px 0;
 `, [_(`progress`, `
 padding: 2px 0;
 margin-bottom: 0;
 `), o(`name`, `
 padding: 0 8px;
 `), o(`thumbnail`, `
 width: 32px;
 height: 32px;
 font-size: 28px;
 display: flex;
 justify-content: center;
 align-items: center;
 `, [a(`img`, `
 width: 100%;
 `)])])]), h(`text-type`, [_(`progress`, `
 box-sizing: border-box;
 padding-bottom: 6px;
 margin-bottom: 6px;
 `)]), h(`image-card-type`, `
 position: relative;
 width: 96px;
 height: 96px;
 border: var(--n-item-border-image-card);
 border-radius: var(--n-border-radius);
 padding: 0;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: border-color .3s var(--n-bezier), background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 overflow: hidden;
 `, [_(`progress`, `
 position: absolute;
 left: 8px;
 bottom: 8px;
 right: 8px;
 width: unset;
 `), _(`upload-file-info`, `
 padding: 0;
 width: 100%;
 height: 100%;
 `, [o(`thumbnail`, `
 width: 100%;
 height: 100%;
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 font-size: 36px;
 `, [a(`img`, `
 width: 100%;
 `)])]), a(`&::before`, `
 position: absolute;
 z-index: 1;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 opacity: 0;
 transition: opacity .2s var(--n-bezier);
 content: "";
 `), a(`&:hover`, [a(`&::before`, `opacity: 1;`), _(`upload-file-info`, [o(`thumbnail`, `opacity: .12;`)])])]), h(`error-status`, [a(`&:hover`, `
 background-color: var(--n-item-color-hover-error);
 `), _(`upload-file-info`, [o(`name`, `color: var(--n-item-text-color-error);`), o(`thumbnail`, `color: var(--n-item-text-color-error);`)]), h(`image-card-type`, `
 border: var(--n-item-border-image-card-error);
 `)]), h(`with-url`, `
 cursor: pointer;
 `, [_(`upload-file-info`, [o(`name`, `
 color: var(--n-item-text-color-success);
 text-decoration-color: var(--n-item-text-color-success);
 `, [a(`a`, `
 text-decoration: underline;
 `)])])]), _(`upload-file-info`, `
 position: relative;
 padding-top: 6px;
 padding-bottom: 6px;
 display: flex;
 flex-wrap: nowrap;
 `, [o(`thumbnail`, `
 font-size: 18px;
 opacity: 1;
 transition: opacity .2s var(--n-bezier);
 color: var(--n-item-icon-color);
 `, [_(`base-icon`, `
 margin-right: 2px;
 vertical-align: middle;
 transition: color .3s var(--n-bezier);
 `)]), o(`action`, `
 padding-top: inherit;
 padding-bottom: inherit;
 position: absolute;
 right: 0;
 top: 0;
 bottom: 0;
 width: 80px;
 display: flex;
 align-items: center;
 transition: opacity .2s var(--n-bezier);
 justify-content: flex-end;
 opacity: 0;
 `, [_(`button`, [a(`&:not(:last-child)`, { marginRight: `4px` }), _(`base-icon`, [a(`svg`, [pt()])])]), h(`image-type`, `
 position: relative;
 max-width: 80px;
 width: auto;
 `), h(`image-card-type`, `
 z-index: 2;
 position: absolute;
 width: 100%;
 height: 100%;
 left: 0;
 right: 0;
 bottom: 0;
 top: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 `)]), o(`name`, `
 color: var(--n-item-text-color);
 flex: 1;
 display: flex;
 justify-content: center;
 text-overflow: ellipsis;
 overflow: hidden;
 flex-direction: column;
 text-decoration-color: #0000;
 font-size: var(--n-font-size);
 transition:
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier); 
 `, [a(`a`, `
 color: inherit;
 text-decoration: underline;
 `)])])])]), _(`upload-file-input`, `
 display: none;
 width: 0;
 height: 0;
 opacity: 0;
 `)]), gn = F({ name: `UploadDragger`, __UPLOAD_DRAGGER__: true, setup(e2, { slots: t2 }) {
  let n2 = tt(mn, null);
  return n2 || p(`upload-dragger`, "`n-upload-dragger` must be placed inside `n-upload`."), () => {
    let { mergedClsPrefixRef: { value: e3 }, mergedDisabledRef: { value: r2 }, maxReachedRef: { value: i2 } } = n2;
    return M(`div`, { class: [`${e3}-upload-dragger`, (r2 || i2) && `${e3}-upload-dragger--disabled`] }, t2);
  };
} });
function _n() {
  return M(`svg`, { xmlns: `http://www.w3.org/2000/svg`, viewBox: `0 0 28 28` }, M(`g`, { fill: `none` }, M(`path`, { d: `M21.75 3A3.25 3.25 0 0 1 25 6.25v15.5A3.25 3.25 0 0 1 21.75 25H6.25A3.25 3.25 0 0 1 3 21.75V6.25A3.25 3.25 0 0 1 6.25 3h15.5zm.583 20.4l-7.807-7.68a.75.75 0 0 0-.968-.07l-.084.07l-7.808 7.68c.183.065.38.1.584.1h15.5c.204 0 .4-.035.583-.1l-7.807-7.68l7.807 7.68zM21.75 4.5H6.25A1.75 1.75 0 0 0 4.5 6.25v15.5c0 .208.036.408.103.593l7.82-7.692a2.25 2.25 0 0 1 3.026-.117l.129.117l7.82 7.692c.066-.185.102-.385.102-.593V6.25a1.75 1.75 0 0 0-1.75-1.75zm-3.25 3a2.5 2.5 0 1 1 0 5a2.5 2.5 0 0 1 0-5zm0 1.5a1 1 0 1 0 0 2a1 1 0 0 0 0-2z`, fill: `currentColor` })));
}
function vn() {
  return M(`svg`, { xmlns: `http://www.w3.org/2000/svg`, viewBox: `0 0 28 28` }, M(`g`, { fill: `none` }, M(`path`, { d: `M6.4 2A2.4 2.4 0 0 0 4 4.4v19.2A2.4 2.4 0 0 0 6.4 26h15.2a2.4 2.4 0 0 0 2.4-2.4V11.578c0-.729-.29-1.428-.805-1.944l-6.931-6.931A2.4 2.4 0 0 0 14.567 2H6.4zm-.9 2.4a.9.9 0 0 1 .9-.9H14V10a2 2 0 0 0 2 2h6.5v11.6a.9.9 0 0 1-.9.9H6.4a.9.9 0 0 1-.9-.9V4.4zm16.44 6.1H16a.5.5 0 0 1-.5-.5V4.06l6.44 6.44z`, fill: `currentColor` })));
}
var yn = F({ name: `UploadProgress`, props: { show: Boolean, percentage: { type: Number, required: true }, status: { type: String, required: true } }, setup() {
  return { mergedTheme: tt(mn).mergedThemeRef };
}, render() {
  return M(y, null, { default: () => this.show ? M(un, { type: `line`, showIndicator: false, percentage: this.percentage, status: this.status, height: 2, theme: this.mergedTheme.peers.Progress, themeOverrides: this.mergedTheme.peerOverrides.Progress }) : null });
} }), bn = function(e2, t2, n2, r2) {
  function i2(e3) {
    return e3 instanceof n2 ? e3 : new n2(function(t3) {
      t3(e3);
    });
  }
  return new (n2 || (n2 = Promise))(function(n3, a2) {
    function o2(e3) {
      try {
        c2(r2.next(e3));
      } catch (e4) {
        a2(e4);
      }
    }
    function s2(e3) {
      try {
        c2(r2.throw(e3));
      } catch (e4) {
        a2(e4);
      }
    }
    function c2(e3) {
      e3.done ? n3(e3.value) : i2(e3.value).then(o2, s2);
    }
    c2((r2 = r2.apply(e2, t2 || [])).next());
  });
};
function xn(e2) {
  return e2.includes(`image/`);
}
function Sn(e2 = ``) {
  let t2 = e2.split(`/`), n2 = t2[t2.length - 1].split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(n2) || [``])[0];
}
var Cn = /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i;
const wn = (e2) => {
  if (e2.type) return xn(e2.type);
  let t2 = Sn(e2.name || ``);
  if (Cn.test(t2)) return true;
  let n2 = e2.thumbnailUrl || e2.url || ``, r2 = Sn(n2);
  return !!(/^data:image\//.test(n2) || Cn.test(r2));
};
function Tn(e2) {
  return bn(this, void 0, void 0, function* () {
    return yield new Promise((t2) => {
      if (!e2.type || !xn(e2.type)) {
        t2(``);
        return;
      }
      t2(window.URL.createObjectURL(e2));
    });
  });
}
const En = ve && window.FileReader && window.File;
function Dn(e2) {
  return e2.isDirectory;
}
function On(e2) {
  return e2.isFile;
}
function kn(e2, t2) {
  return bn(this, void 0, void 0, function* () {
    let n2 = [];
    function i2(e3) {
      return bn(this, void 0, void 0, function* () {
        for (let a2 of e3) if (a2) {
          if (t2 && Dn(a2)) {
            let e4 = a2.createReader(), t3 = [], n3;
            try {
              do
                n3 = yield new Promise((t4, n4) => {
                  e4.readEntries(t4, n4);
                }), t3 = t3.concat(n3);
              while (n3.length > 0);
            } catch (e5) {
              r(`upload`, `error happens when handling directory upload`, e5);
            }
            yield i2(t3);
          } else if (On(a2)) try {
            let e4 = yield new Promise((e5, t3) => {
              a2.file(e5, t3);
            });
            n2.push({ file: e4, entry: a2, source: `dnd` });
          } catch (e4) {
            r(`upload`, `error happens when handling file upload`, e4);
          }
        }
      });
    }
    return yield i2(e2), n2;
  });
}
function An(e2) {
  let { id: t2, name: n2, percentage: r2, status: i2, url: a2, file: o2, thumbnailUrl: s2, type: c2, fullPath: l2, batchId: u2 } = e2;
  return { id: t2, name: n2, percentage: r2 ?? null, status: i2, url: a2 ?? null, file: o2 ?? null, thumbnailUrl: s2 ?? null, type: c2 ?? null, fullPath: l2 ?? null, batchId: u2 ?? null };
}
function jn(e2, t2, n2) {
  return e2 = e2.toLowerCase(), t2 = t2.toLocaleLowerCase(), n2 = n2.toLocaleLowerCase(), n2.split(`,`).map((e3) => e3.trim()).filter(Boolean).some((n3) => {
    if (n3.startsWith(`.`)) {
      if (e2.endsWith(n3)) return true;
    } else if (n3.includes(`/`)) {
      let [e3, r2] = t2.split(`/`), [i2, a2] = n3.split(`/`);
      if ((i2 === `*` || e3 && i2 && i2 === e3) && (a2 === `*` || r2 && a2 && a2 === r2)) return true;
    } else return true;
    return false;
  });
}
var Mn = function(e2, t2, n2, r2) {
  function i2(e3) {
    return e3 instanceof n2 ? e3 : new n2(function(t3) {
      t3(e3);
    });
  }
  return new (n2 || (n2 = Promise))(function(n3, a2) {
    function o2(e3) {
      try {
        c2(r2.next(e3));
      } catch (e4) {
        a2(e4);
      }
    }
    function s2(e3) {
      try {
        c2(r2.throw(e3));
      } catch (e4) {
        a2(e4);
      }
    }
    function c2(e3) {
      e3.done ? n3(e3.value) : i2(e3.value).then(o2, s2);
    }
    c2((r2 = r2.apply(e2, t2 || [])).next());
  });
}, Nn = { paddingMedium: `0 3px`, heightMedium: `24px`, iconSizeMedium: `18px` }, Pn = F({ name: `UploadFile`, props: { clsPrefix: { type: String, required: true }, file: { type: Object, required: true }, listType: { type: String, required: true }, index: { type: Number, required: true } }, setup(t2) {
  let n2 = tt(mn), r2 = E(null), i2 = E(``), a2 = L(() => {
    let { file: e2 } = t2;
    return e2.status === `finished` ? `success` : e2.status === `error` ? `error` : `info`;
  }), o2 = L(() => {
    let { file: e2 } = t2;
    if (e2.status === `error`) return `error`;
  }), s2 = L(() => {
    let { file: e2 } = t2;
    return e2.status === `uploading`;
  }), c2 = L(() => {
    if (!n2.showCancelButtonRef.value) return false;
    let { file: e2 } = t2;
    return [`uploading`, `pending`, `error`].includes(e2.status);
  }), l2 = L(() => {
    if (!n2.showRemoveButtonRef.value) return false;
    let { file: e2 } = t2;
    return [`finished`].includes(e2.status);
  }), u2 = L(() => {
    if (!n2.showDownloadButtonRef.value) return false;
    let { file: e2 } = t2;
    return [`finished`].includes(e2.status);
  }), d2 = L(() => {
    if (!n2.showRetryButtonRef.value) return false;
    let { file: e2 } = t2;
    return [`error`].includes(e2.status);
  }), f2 = _e(() => i2.value || t2.file.thumbnailUrl || t2.file.url), p2 = L(() => {
    if (!n2.showPreviewButtonRef.value) return false;
    let { file: { status: e2 }, listType: r3 } = t2;
    return [`finished`].includes(e2) && f2.value && r3 === `image-card`;
  });
  function m2() {
    return Mn(this, void 0, void 0, function* () {
      let e2 = n2.onRetryRef.value;
      e2 && (yield e2({ file: t2.file })) === false || n2.submit(t2.file.id);
    });
  }
  function h2(n3) {
    n3.preventDefault();
    let { file: r3 } = t2;
    [`finished`, `pending`, `error`].includes(r3.status) ? _2(r3) : [`uploading`].includes(r3.status) ? y2(r3) : e(`upload`, `The button clicked type is unknown.`);
  }
  function g2(e2) {
    e2.preventDefault(), v2(t2.file);
  }
  function _2(e2) {
    let { xhrMap: r3, doChange: i3, onRemoveRef: { value: a3 }, mergedFileListRef: { value: o3 } } = n2;
    Promise.resolve(a3 ? a3({ file: Object.assign({}, e2), fileList: o3, index: t2.index }) : true).then((t3) => {
      if (t3 === false) return;
      let n3 = Object.assign({}, e2, { status: `removed` });
      r3.delete(e2.id), i3(n3, void 0, { remove: true });
    });
  }
  function v2(e2) {
    let { onDownloadRef: { value: t3 }, customDownloadRef: { value: r3 } } = n2;
    Promise.resolve(t3 ? t3(Object.assign({}, e2)) : true).then((t4) => {
      t4 !== false && (r3 ? r3(Object.assign({}, e2)) : Te(e2.url, e2.name));
    });
  }
  function y2(e2) {
    var _a2;
    let { xhrMap: t3 } = n2;
    (_a2 = t3.get(e2.id)) == null ? void 0 : _a2.abort(), _2(Object.assign({}, e2));
  }
  function b2(e2) {
    let { onPreviewRef: { value: i3 } } = n2;
    if (i3) i3(t2.file, { event: e2 });
    else if (t2.listType === `image-card`) {
      let { value: e3 } = r2;
      if (!e3) return;
      e3.showPreview();
    }
  }
  let x2 = () => Mn(this, void 0, void 0, function* () {
    let { listType: e2 } = t2;
    e2 !== `image` && e2 !== `image-card` || n2.shouldUseThumbnailUrlRef.value(t2.file) && (i2.value = yield n2.getFileThumbnailUrlResolver(t2.file));
  });
  return Be(() => {
    x2();
  }), { mergedTheme: n2.mergedThemeRef, progressStatus: a2, buttonType: o2, showProgress: s2, disabled: n2.mergedDisabledRef, showCancelButton: c2, showRemoveButton: l2, showDownloadButton: u2, showRetryButton: d2, showPreviewButton: p2, mergedThumbnailUrl: f2, shouldUseThumbnailUrl: n2.shouldUseThumbnailUrlRef, renderIcon: n2.renderIconRef, imageRef: r2, handleRemoveOrCancelClick: h2, handleDownloadClick: g2, handleRetryClick: m2, handlePreviewClick: b2 };
}, render() {
  let { clsPrefix: e2, mergedTheme: t2, listType: n2, file: r2, renderIcon: i2 } = this, a2, o2 = n2 === `image`;
  a2 = o2 || n2 === `image-card` ? !this.shouldUseThumbnailUrl(r2) || !this.mergedThumbnailUrl ? M(`span`, { class: `${e2}-upload-file-info__thumbnail` }, i2 ? i2(r2) : wn(r2) ? M(b, { clsPrefix: e2 }, { default: _n }) : M(b, { clsPrefix: e2 }, { default: vn })) : M(`a`, { rel: `noopener noreferer`, target: `_blank`, href: r2.url || void 0, class: `${e2}-upload-file-info__thumbnail`, onClick: this.handlePreviewClick }, n2 === `image-card` ? M(Oe, { src: this.mergedThumbnailUrl || void 0, previewSrc: r2.url || void 0, alt: r2.name, ref: `imageRef` }) : M(`img`, { src: this.mergedThumbnailUrl || void 0, alt: r2.name })) : M(`span`, { class: `${e2}-upload-file-info__thumbnail` }, i2 ? i2(r2) : M(b, { clsPrefix: e2 }, { default: () => M(qt, null) }));
  let s2 = M(yn, { show: this.showProgress, percentage: r2.percentage || 0, status: this.progressStatus }), c2 = n2 === `text` || n2 === `image`;
  return M(`div`, { class: [`${e2}-upload-file`, `${e2}-upload-file--${this.progressStatus}-status`, r2.url && r2.status !== `error` && n2 !== `image-card` && `${e2}-upload-file--with-url`, `${e2}-upload-file--${n2}-type`] }, M(`div`, { class: `${e2}-upload-file-info` }, a2, M(`div`, { class: `${e2}-upload-file-info__name` }, c2 && (r2.url && r2.status !== `error` ? M(`a`, { rel: `noopener noreferer`, target: `_blank`, href: r2.url || void 0, onClick: this.handlePreviewClick }, r2.name) : M(`span`, { onClick: this.handlePreviewClick }, r2.name)), o2 && s2), M(`div`, { class: [`${e2}-upload-file-info__action`, `${e2}-upload-file-info__action--${n2}-type`] }, this.showPreviewButton ? M(gt, { key: `preview`, quaternary: true, type: this.buttonType, onClick: this.handlePreviewClick, theme: t2.peers.Button, themeOverrides: t2.peerOverrides.Button, builtinThemeOverrides: Nn }, { icon: () => M(b, { clsPrefix: e2 }, { default: () => M(oe, null) }) }) : null, (this.showRemoveButton || this.showCancelButton) && !this.disabled && M(gt, { key: `cancelOrTrash`, theme: t2.peers.Button, themeOverrides: t2.peerOverrides.Button, quaternary: true, builtinThemeOverrides: Nn, type: this.buttonType, onClick: this.handleRemoveOrCancelClick }, { icon: () => M(bt, null, { default: () => this.showRemoveButton ? M(b, { clsPrefix: e2, key: `trash` }, { default: () => M(Xt, null) }) : M(b, { clsPrefix: e2, key: `cancel` }, { default: () => M(Jt, null) }) }) }), this.showRetryButton && !this.disabled && M(gt, { key: `retry`, quaternary: true, type: this.buttonType, onClick: this.handleRetryClick, theme: t2.peers.Button, themeOverrides: t2.peerOverrides.Button, builtinThemeOverrides: Nn }, { icon: () => M(b, { clsPrefix: e2 }, { default: () => M(Yt, null) }) }), this.showDownloadButton ? M(gt, { key: `download`, quaternary: true, type: this.buttonType, onClick: this.handleDownloadClick, theme: t2.peers.Button, themeOverrides: t2.peerOverrides.Button, builtinThemeOverrides: Nn }, { icon: () => M(b, { clsPrefix: e2 }, { default: () => M(De, null) }) }) : null)), !o2 && s2);
} }), Fn = F({ name: `UploadTrigger`, props: { abstract: Boolean }, slots: Object, setup(e2, { slots: t2 }) {
  let n2 = tt(mn, null);
  n2 || p(`upload-trigger`, "`n-upload-trigger` must be placed inside `n-upload`.");
  let { mergedClsPrefixRef: r2, mergedDisabledRef: a2, maxReachedRef: o2, listTypeRef: s2, dragOverRef: c2, openOpenFileDialog: l2, draggerInsideRef: u2, handleFileAddition: d2, mergedDirectoryDndRef: f2, triggerClassRef: m2, triggerStyleRef: h2 } = n2, g2 = L(() => s2.value === `image-card`);
  function _2() {
    a2.value || o2.value || l2();
  }
  function v2(e3) {
    e3.preventDefault(), c2.value = true;
  }
  function y2(e3) {
    e3.preventDefault(), c2.value = true;
  }
  function x2(e3) {
    e3.preventDefault(), c2.value = false;
  }
  function S2(e3) {
    var _a2;
    if (e3.preventDefault(), !u2.value || a2.value || o2.value) {
      c2.value = false;
      return;
    }
    let t3 = (_a2 = e3.dataTransfer) == null ? void 0 : _a2.items;
    (t3 == null ? void 0 : t3.length) ? kn(Array.from(t3).map((e4) => e4.webkitGetAsEntry()), f2.value).then((e4) => {
      d2(e4);
    }).finally(() => {
      c2.value = false;
    }) : c2.value = false;
  }
  return () => {
    var _a2;
    let { value: n3 } = r2;
    return e2.abstract ? (_a2 = t2.default) == null ? void 0 : _a2.call(t2, { handleClick: _2, handleDrop: S2, handleDragOver: v2, handleDragEnter: y2, handleDragLeave: x2 }) : M(`div`, { class: [`${n3}-upload-trigger`, (a2.value || o2.value) && `${n3}-upload-trigger--disabled`, g2.value && `${n3}-upload-trigger--image-card`, m2.value], style: h2.value, onClick: _2, onDrop: S2, onDragover: v2, onDragenter: y2, onDragleave: x2 }, g2.value ? M(gn, null, { default: () => i(t2.default, () => [M(b, { clsPrefix: n3 }, { default: () => M(re, null) })]) }) : t2);
  };
} }), In = F({ name: `UploadFileList`, setup(e2, { slots: t2 }) {
  let n2 = tt(mn, null);
  n2 || p(`upload-file-list`, "`n-upload-file-list` must be placed inside `n-upload`.");
  let { abstractRef: r2, mergedClsPrefixRef: i2, listTypeRef: a2, mergedFileListRef: o2, fileListClassRef: s2, fileListStyleRef: c2, cssVarsRef: l2, themeClassRef: u2, maxReachedRef: d2, showTriggerRef: f2, imageGroupPropsRef: m2 } = n2, h2 = L(() => a2.value === `image-card`), g2 = () => o2.value.map((e3, t3) => M(Pn, { clsPrefix: i2.value, key: e3.id, file: e3, index: t3, listType: a2.value })), _2 = () => h2.value ? M(Ee, Object.assign({}, m2.value), { default: g2 }) : M(y, { group: true }, { default: g2 });
  return () => {
    let { value: e3 } = i2, { value: n3 } = r2;
    return M(`div`, { class: [`${e3}-upload-file-list`, h2.value && `${e3}-upload-file-list--grid`, n3 ? u2 == null ? void 0 : u2.value : void 0, s2.value], style: [n3 && l2 ? l2.value : ``, c2.value] }, _2(), f2.value && !d2.value && h2.value && M(Fn, null, t2));
  };
} }), Ln = function(e2, t2, n2, r2) {
  function i2(e3) {
    return e3 instanceof n2 ? e3 : new n2(function(t3) {
      t3(e3);
    });
  }
  return new (n2 || (n2 = Promise))(function(n3, a2) {
    function o2(e3) {
      try {
        c2(r2.next(e3));
      } catch (e4) {
        a2(e4);
      }
    }
    function s2(e3) {
      try {
        c2(r2.throw(e3));
      } catch (e4) {
        a2(e4);
      }
    }
    function c2(e3) {
      e3.done ? n3(e3.value) : i2(e3.value).then(o2, s2);
    }
    c2((r2 = r2.apply(e2, t2 || [])).next());
  });
};
function Rn(e2, t2, n2) {
  let { doChange: r2, xhrMap: i2 } = e2, a2 = 0;
  function o2(n3) {
    var _a2;
    let o3 = Object.assign({}, t2, { status: `error`, percentage: a2 });
    i2.delete(t2.id), o3 = An(((_a2 = e2.onError) == null ? void 0 : _a2.call(e2, { file: o3, event: n3 })) || o3), r2(o3, n3);
  }
  function s2(s3) {
    var _a2;
    if (e2.isErrorState) {
      if (e2.isErrorState(n2)) {
        o2(s3);
        return;
      }
    } else if (n2.status < 200 || n2.status >= 300) {
      o2(s3);
      return;
    }
    let c2 = Object.assign({}, t2, { status: `finished`, percentage: a2 });
    i2.delete(t2.id), c2 = An(((_a2 = e2.onFinish) == null ? void 0 : _a2.call(e2, { file: c2, event: s3 })) || c2), r2(c2, s3);
  }
  return { handleXHRLoad: s2, handleXHRError: o2, handleXHRAbort(e3) {
    let n3 = Object.assign({}, t2, { status: `removed`, file: null, percentage: a2 });
    i2.delete(t2.id), r2(n3, e3);
  }, handleXHRProgress(e3) {
    let n3 = Object.assign({}, t2, { status: `uploading` });
    if (e3.lengthComputable) {
      let t3 = Math.ceil(e3.loaded / e3.total * 100);
      n3.percentage = t3, a2 = t3;
    }
    r2(n3, e3);
  } };
}
function zn(e2) {
  let { inst: t2, file: n2, data: r2, headers: i2, withCredentials: a2, action: o2, customRequest: s2 } = e2, { doChange: c2 } = e2.inst, l2 = 0;
  s2({ file: n2, data: r2, headers: i2, withCredentials: a2, action: o2, onProgress(e3) {
    let t3 = Object.assign({}, n2, { status: `uploading` }), r3 = e3.percent;
    t3.percentage = r3, l2 = r3, c2(t3);
  }, onFinish() {
    var _a2;
    let e3 = Object.assign({}, n2, { status: `finished`, percentage: l2 });
    e3 = An(((_a2 = t2.onFinish) == null ? void 0 : _a2.call(t2, { file: e3 })) || e3), c2(e3);
  }, onError() {
    var _a2;
    let e3 = Object.assign({}, n2, { status: `error`, percentage: l2 });
    e3 = An(((_a2 = t2.onError) == null ? void 0 : _a2.call(t2, { file: e3 })) || e3), c2(e3);
  } });
}
function Bn(e2, t2, n2) {
  let r2 = Rn(e2, t2, n2);
  n2.onabort = r2.handleXHRAbort, n2.onerror = r2.handleXHRError, n2.onload = r2.handleXHRLoad, n2.upload && (n2.upload.onprogress = r2.handleXHRProgress);
}
function Vn(e2, t2) {
  return typeof e2 == `function` ? e2({ file: t2 }) : e2 || {};
}
function Hn(e2, t2, n2) {
  let r2 = Vn(t2, n2);
  r2 && Object.keys(r2).forEach((t3) => {
    e2.setRequestHeader(t3, r2[t3]);
  });
}
function Un(e2, t2, n2) {
  let r2 = Vn(t2, n2);
  r2 && Object.keys(r2).forEach((t3) => {
    e2.append(t3, r2[t3]);
  });
}
function Wn(e2, t2, n2, { method: r2, action: i2, withCredentials: a2, responseType: o2, headers: s2, data: c2 }) {
  let l2 = new XMLHttpRequest();
  l2.responseType = o2, e2.xhrMap.set(n2.id, l2), l2.withCredentials = a2;
  let u2 = new FormData();
  if (Un(u2, c2, n2), n2.file !== null && u2.append(t2, n2.file), Bn(e2, n2, l2), i2 !== void 0) {
    l2.open(r2.toUpperCase(), i2), Hn(l2, s2, n2), l2.send(u2);
    let t3 = Object.assign({}, n2, { status: `uploading` });
    e2.doChange(t3);
  }
}
var Gn = F({ name: `Upload`, props: Object.assign(Object.assign({}, c.props), { name: { type: String, default: `file` }, accept: String, action: String, customRequest: Function, directory: Boolean, directoryDnd: { type: Boolean, default: void 0 }, method: { type: String, default: `POST` }, multiple: Boolean, showFileList: { type: Boolean, default: true }, data: [Object, Function], headers: [Object, Function], withCredentials: Boolean, responseType: { type: String, default: `` }, disabled: { type: Boolean, default: void 0 }, onChange: Function, onRemove: Function, onFinish: Function, onError: Function, onRetry: Function, onBeforeUpload: Function, isErrorState: Function, onDownload: Function, customDownload: Function, defaultUpload: { type: Boolean, default: true }, fileList: Array, "onUpdate:fileList": [Function, Array], onUpdateFileList: [Function, Array], fileListClass: String, fileListStyle: [String, Object], defaultFileList: { type: Array, default: () => [] }, showCancelButton: { type: Boolean, default: true }, showRemoveButton: { type: Boolean, default: true }, showDownloadButton: Boolean, showRetryButton: { type: Boolean, default: true }, showPreviewButton: { type: Boolean, default: true }, listType: { type: String, default: `text` }, onPreview: Function, shouldUseThumbnailUrl: { type: Function, default: (e2) => En ? wn(e2) : false }, createThumbnailUrl: Function, abstract: Boolean, max: Number, showTrigger: { type: Boolean, default: true }, imageGroupProps: Object, inputProps: Object, triggerClass: String, triggerStyle: [String, Object], renderIcon: Function }), setup(e2) {
  e2.abstract && e2.listType === `image-card` && p(`upload`, `when the list-type is image-card, abstract is not supported.`);
  let { mergedClsPrefixRef: n2, inlineThemeDisabled: r2, mergedRtlRef: i2 } = x(e2), a2 = c(`Upload`, `-upload`, hn, lt, e2, n2), o2 = d(`Upload`, i2, n2), s2 = mt(e2), l2 = E(e2.defaultFileList), f2 = O(e2, `fileList`), m2 = E(null), h2 = { value: false }, g2 = E(false), _2 = /* @__PURE__ */ new Map(), v2 = be(f2, l2), y2 = L(() => v2.value.map(An)), b2 = L(() => {
    let { max: t2 } = e2;
    return t2 === void 0 ? false : y2.value.length >= t2;
  });
  function S2() {
    var e3;
    (e3 = m2.value) == null || e3.click();
  }
  function ee2(e3) {
    let t2 = e3.target;
    te2(t2.files ? Array.from(t2.files).map((e4) => ({ file: e4, entry: null, source: `input` })) : null, e3), t2.value = ``;
  }
  function C2(n3) {
    let { "onUpdate:fileList": r3, onUpdateFileList: i3 } = e2;
    r3 && t(r3, n3), i3 && t(i3, n3), l2.value = n3;
  }
  let w2 = L(() => e2.multiple || e2.directory), T2 = (t2, n3, r3 = { append: false, remove: false }) => {
    let { append: i3, remove: a3 } = r3, o3 = Array.from(y2.value), s3 = o3.findIndex((e3) => e3.id === t2.id);
    if (i3 || a3 || ~s3) {
      i3 ? o3.push(t2) : a3 ? o3.splice(s3, 1) : o3.splice(s3, 1, t2);
      let { onChange: r4 } = e2;
      r4 && r4({ file: t2, fileList: o3, event: n3 }), C2(o3);
    }
  };
  function te2(t2, n3) {
    if (!t2 || t2.length === 0) return;
    let { onBeforeUpload: r3 } = e2;
    t2 = w2.value ? t2 : [t2[0]];
    let { max: i3, accept: a3 } = e2;
    t2 = t2.filter(({ file: e3, source: t3 }) => t3 === `dnd` && (a3 == null ? void 0 : a3.trim()) ? jn(e3.name, e3.type, a3) : true), i3 && (t2 = t2.slice(0, i3 - y2.value.length));
    let o3 = ye();
    Promise.all(t2.map((e3) => Ln(this, [e3], void 0, function* ({ file: e4, entry: t3 }) {
      let n4 = { id: ye(), batchId: o3, name: e4.name, status: `pending`, percentage: 0, file: e4, url: null, type: e4.type, thumbnailUrl: null, fullPath: (t3 == null ? void 0 : t3.fullPath) ?? `/${e4.webkitRelativePath || e4.name}` };
      return !r3 || (yield r3({ file: n4, fileList: y2.value })) !== false ? n4 : null;
    }))).then((e3) => Ln(this, void 0, void 0, function* () {
      let t3 = Promise.resolve();
      e3.forEach((e4) => {
        t3 = t3.then(Ve).then(() => {
          e4 && T2(e4, n3, { append: true });
        });
      }), yield t3;
    })).then(() => {
      e2.defaultUpload && ne2();
    });
  }
  function ne2(t2) {
    let { method: n3, action: r3, withCredentials: i3, headers: a3, data: o3, name: s3 } = e2, c2 = t2 === void 0 ? y2.value : y2.value.filter((e3) => e3.id === t2), l3 = t2 !== void 0;
    c2.forEach((t3) => {
      let { status: c3 } = t3;
      (c3 === `pending` || c3 === `error` && l3) && (e2.customRequest ? zn({ inst: { doChange: T2, xhrMap: _2, onFinish: e2.onFinish, onError: e2.onError }, file: t3, action: r3, withCredentials: i3, headers: a3, data: o3, customRequest: e2.customRequest }) : Wn({ doChange: T2, xhrMap: _2, onFinish: e2.onFinish, onError: e2.onError, isErrorState: e2.isErrorState }, s3, t3, { method: n3, action: r3, withCredentials: i3, responseType: e2.responseType, headers: a3, data: o3 }));
    });
  }
  function re2(t2) {
    if (t2.thumbnailUrl) return t2.thumbnailUrl;
    let { createThumbnailUrl: n3 } = e2;
    return n3 ? n3(t2.file, t2) ?? (t2.url || ``) : t2.url ? t2.url : t2.file ? Tn(t2.file) : ``;
  }
  let ie2 = L(() => {
    let { common: { cubicBezierEaseInOut: e3 }, self: { draggerColor: t2, draggerBorder: n3, draggerBorderHover: r3, itemColorHover: i3, itemColorHoverError: o3, itemTextColorError: s3, itemTextColorSuccess: c2, itemTextColor: l3, itemIconColor: u2, itemDisabledOpacity: d2, lineHeight: f3, borderRadius: p2, fontSize: m3, itemBorderImageCardError: h3, itemBorderImageCard: g3 } } = a2.value;
    return { "--n-bezier": e3, "--n-border-radius": p2, "--n-dragger-border": n3, "--n-dragger-border-hover": r3, "--n-dragger-color": t2, "--n-font-size": m3, "--n-item-color-hover": i3, "--n-item-color-hover-error": o3, "--n-item-disabled-opacity": d2, "--n-item-icon-color": u2, "--n-item-text-color": l3, "--n-item-text-color-error": s3, "--n-item-text-color-success": c2, "--n-line-height": f3, "--n-item-border-image-card-error": h3, "--n-item-border-image-card": g3 };
  }), ae2 = r2 ? u(`upload`, void 0, ie2, e2) : void 0;
  Ae(mn, { mergedClsPrefixRef: n2, mergedThemeRef: a2, showCancelButtonRef: O(e2, `showCancelButton`), showDownloadButtonRef: O(e2, `showDownloadButton`), showRemoveButtonRef: O(e2, `showRemoveButton`), showRetryButtonRef: O(e2, `showRetryButton`), onRemoveRef: O(e2, `onRemove`), onDownloadRef: O(e2, `onDownload`), customDownloadRef: O(e2, `customDownload`), mergedFileListRef: y2, triggerClassRef: O(e2, `triggerClass`), triggerStyleRef: O(e2, `triggerStyle`), shouldUseThumbnailUrlRef: O(e2, `shouldUseThumbnailUrl`), renderIconRef: O(e2, `renderIcon`), xhrMap: _2, submit: ne2, doChange: T2, showPreviewButtonRef: O(e2, `showPreviewButton`), onPreviewRef: O(e2, `onPreview`), getFileThumbnailUrlResolver: re2, listTypeRef: O(e2, `listType`), dragOverRef: g2, openOpenFileDialog: S2, draggerInsideRef: h2, handleFileAddition: te2, mergedDisabledRef: s2.mergedDisabledRef, maxReachedRef: b2, fileListClassRef: O(e2, `fileListClass`), fileListStyleRef: O(e2, `fileListStyle`), abstractRef: O(e2, `abstract`), acceptRef: O(e2, `accept`), cssVarsRef: r2 ? void 0 : ie2, themeClassRef: ae2 == null ? void 0 : ae2.themeClass, onRender: ae2 == null ? void 0 : ae2.onRender, showTriggerRef: O(e2, `showTrigger`), imageGroupPropsRef: O(e2, `imageGroupProps`), mergedDirectoryDndRef: L(() => e2.directoryDnd ?? e2.directory), onRetryRef: O(e2, `onRetry`) });
  let oe2 = { clear: () => {
    l2.value = [];
  }, submit: ne2, openOpenFileDialog: S2 };
  return Object.assign({ mergedClsPrefix: n2, draggerInsideRef: h2, rtlEnabled: o2, inputElRef: m2, mergedTheme: a2, dragOver: g2, mergedMultiple: w2, cssVars: r2 ? void 0 : ie2, themeClass: ae2 == null ? void 0 : ae2.themeClass, onRender: ae2 == null ? void 0 : ae2.onRender, handleFileInputChange: ee2 }, oe2);
}, render() {
  var _a2, _b, _c;
  let { draggerInsideRef: e2, mergedClsPrefix: t2, $slots: n2, directory: r2, onRender: i2 } = this;
  n2.default && !this.abstract && ((_b = (_a2 = n2.default()[0]) == null ? void 0 : _a2.type) == null ? void 0 : _b.__UPLOAD_DRAGGER__) && (e2.value = true);
  let a2 = M(`input`, Object.assign({}, this.inputProps, { ref: `inputElRef`, type: `file`, class: `${t2}-upload-file-input`, accept: this.accept, multiple: this.mergedMultiple, onChange: this.handleFileInputChange, webkitdirectory: r2 || void 0, directory: r2 || void 0 }));
  return this.abstract ? M(et, null, (_c = n2.default) == null ? void 0 : _c.call(n2), M($e, { to: `body` }, a2)) : (i2 == null ? void 0 : i2(), M(`div`, { class: [`${t2}-upload`, this.rtlEnabled && `${t2}-upload--rtl`, e2.value && `${t2}-upload--dragger-inside`, this.dragOver && `${t2}-upload--drag-over`, this.themeClass], style: this.cssVars }, a2, this.showTrigger && this.listType !== `image-card` && M(Fn, null, n2), this.showFileList && M(In, null, n2)));
} });
function Kn(e2 = {}) {
  let { autoStart: t2 = false } = e2, n2 = E(0), r2 = E(false), i2 = E(false), a2 = E(null), o2 = null, s2 = (e3) => e3.webkitCompassHeading === void 0 ? e3.alpha === null ? 0 : (360 - e3.alpha) % 360 : e3.webkitCompassHeading, c2 = (e3) => {
    try {
      n2.value = s2(e3), a2.value = null;
    } catch (e4) {
      a2.value = `Failed to process orientation update`, Ye(Ge(e4, `useImuCompass.handleOrientationUpdate`), `useImuCompass.handleOrientationUpdate`);
    }
  }, l2 = async () => {
    try {
      if (r2.value) return;
      let e3 = await Qe.initialize();
      if (e3.isErr()) throw e3.error;
      if (!Qe.isSupported()) throw Error(`Device orientation is not supported on this device`);
      i2.value = true;
      let t3 = await Qe.startOrientationUpdates(c2);
      if (t3.isErr()) throw t3.error;
      o2 = t3.value, r2.value = true, a2.value = null;
      let n3 = await Qe.getCurrentOrientation();
      n3.isOk() && n3.value && c2(n3.value);
    } catch (e3) {
      a2.value = e3 instanceof Error ? e3.message : `Failed to start compass tracking`, r2.value = false, Ye(Ge(e3, `useImuCompass.startTracking`), `useImuCompass.startTracking`);
    }
  }, u2 = () => {
    if (!(!r2.value || o2 === null)) try {
      Qe.stopOrientationUpdates(o2), o2 = null, r2.value = false;
    } catch (e3) {
      a2.value = `Failed to stop compass tracking`, Ye(Ge(e3, `useImuCompass.stopTracking`), `useImuCompass.stopTracking`);
    }
  };
  return t2 && l2().catch(console.error), Le(() => {
    u2();
  }), { bearing: n2, isTracking: r2, isSupported: i2, error: a2, startTracking: l2, stopTracking: u2, toggleTracking: async () => {
    r2.value ? u2() : await l2();
  } };
}
var qn = 0.3, Jn = V(F({ __name: `MapCompass`, props: qe({ pitch: {}, size: {}, tracking: { type: Boolean } }, { bearing: { default: 0 }, bearingModifiers: {} }), emits: qe([`toggleTracking`], [`update:bearing`]), setup(e2, { emit: t2 }) {
  He((e3) => ({ v77b18c8c: A(n2).primaryColor, v2f184cfe: A(n2).modalColor, v21daa1a8: A(n2).borderColor, v3fc1f57c: A(n2).textColorBase }));
  let n2 = At(), r2 = e2, i2 = Re(e2, `bearing`), a2 = t2, { bearing: o2, isTracking: s2, isSupported: c2, error: l2, toggleTracking: u2 } = Kn();
  D(o2, (e3) => {
    r2.tracking && (i2.value = e3);
  }), D(() => r2.tracking, (e3) => {
    e3 !== s2.value && u2();
  });
  let d2 = () => {
    u2(), a2(`toggleTracking`);
  }, f2 = L(() => `transform: rotate(${-i2.value % 360}deg)`), p2 = L(() => `transform: rotateX(${Math.min(45, r2.pitch ? r2.pitch : 0)}deg); transition: all 0.3s ease;`), m2 = L(() => r2.size || 40), h2 = L(() => m2.value / 6), g2 = L(() => h2.value / 2), _2 = L(() => m2.value / 8), v2 = L(() => _2.value / 2), y2 = L(() => m2.value / 3), b2 = L(() => ({ width: `${h2.value}px`, height: `${h2.value}px`, top: `0px`, left: `calc(50% - ${h2.value / 2}px)`, transform: `translateY(-${g2.value}px)` })), x2 = L(() => ({ width: `${_2.value}px`, height: `${_2.value}px`, top: `calc(50% - ${_2.value / 2}px)`, right: `0px`, transform: `translateX(${v2.value}px)` })), S2 = L(() => ({ width: `${_2.value}px`, height: `${_2.value}px`, bottom: `0px`, left: `calc(50% - ${_2.value / 2}px)`, transform: `translateY(${v2.value}px)` })), ee2 = L(() => ({ width: `${_2.value}px`, height: `${_2.value}px`, top: `calc(50% - ${_2.value / 2}px)`, left: `0px`, transform: `translateX(-${v2.value}px)` })), C2 = L(() => ({ height: `${y2.value}px`, width: `100%`, top: `calc(50% - ${y2.value / 2}px)`, fontSize: `${y2.value}px`, lineHeight: `${y2.value}px` })), w2 = L(() => ({ width: `${m2.value}px`, height: `${m2.value}px` })), T2 = [`N`, `E`, `S`, `W`], te2 = L(() => {
    let e3 = i2.value > 0 ? i2.value : 360 + i2.value;
    return T2[Math.round(e3 % 360 / 90) % 4];
  });
  return Me(() => {
    let e3 = document.querySelector(`.map-compass`);
    e3.onclick = () => {
      d2(), r2.tracking || (i2.value = 0);
    }, e3 && e3.addEventListener(`wheel`, (e4) => {
      if (r2.tracking) return;
      e4.preventDefault();
      let t3 = (i2.value + e4.deltaY * qn) % 360;
      i2.value = Math.round(t3 >= 0 ? t3 : 360 + t3);
    });
  }), (e3, t3) => (N(), U(`div`, { style: I(p2.value) }, [B(`div`, { class: H([`map-compass`, { "tracking-active": r2.tracking }]), style: I(w2.value) }, [B(`div`, { class: `compass-panel`, style: I(f2.value) }, [B(`div`, { class: `pin north-pin`, style: I(b2.value) }, null, 4), B(`div`, { class: `pin east-pin`, style: I(x2.value) }, null, 4), B(`div`, { class: `pin south-pin`, style: I(S2.value) }, null, 4), B(`div`, { class: `pin west-pin`, style: I(ee2.value) }, null, 4)], 4), B(`span`, { class: `compass-orientation-text`, style: I(C2.value) }, z(te2.value), 5)], 6)], 4));
} }), [[`__scopeId`, `data-v-7d13d21d`]]);
const Yn = Ke(`routes`, () => {
  let e2 = fe(), t2 = L(() => e2.routeCollection), n2 = L({ get: (() => e2.currentRouteId), set: ((t3) => e2.setCurrentRouteId(t3)) }), r2 = E(0);
  D(n2, (t3) => {
    var _a2, _b;
    t3 !== null && (r2.value = ((_b = (_a2 = e2.getRouteById(t3)) == null ? void 0 : _a2.meta) == null ? void 0 : _b.record_timespan) ?? 0);
  });
  let i2 = E(false), a2 = E(-1), o2 = E(null), s2, c2 = L(() => e2.routes);
  function l2(e3) {
    o2.value = e3;
  }
  async function u2() {
    await e2.init();
  }
  async function d2(t3, n3 = {}) {
    return e2.addRoute(t3, n3);
  }
  async function f2(t3) {
    await e2.deleteRoute(t3);
  }
  async function p2(t3, n3) {
    await e2.addPointToRoute(t3, n3);
  }
  async function m2(t3, n3) {
    await e2.updateRoute(t3, n3);
  }
  async function h2(t3) {
    await e2.clearRoutePoints(t3);
  }
  function g2(t3) {
    return e2.getRouteById(t3);
  }
  function _2(t3) {
    e2.setCurrentRouteId(t3);
  }
  function v2(t3) {
    i2.value || !o2.value || (i2.value = true, t3 && p2(n2.value, t3), a2.value = o2.value.addLocationListener(async (e3) => {
      n2.value && await p2(n2.value, e3);
    }), e2.updateRoute(n2.value, { meta: { modification_timestamp: Date.now() } }), s2 = setInterval(async () => {
      let t4 = e2.getRouteById(n2.value);
      t4.recordTimespan !== void 0 && t4.meta.modification_timestamp && (r2.value = t4.recordTimespan + (Date.now() - t4.meta.modification_timestamp), await e2.updateRoute(n2.value, { meta: { record_timespan: r2.value } }));
    }, 100));
  }
  function y2() {
    !i2.value || !o2.value || (a2.value !== -1 && (o2.value.removeLocationListener(a2.value), a2.value = -1), s2 && (s2 = (clearTimeout(s2), void 0)), i2.value = false);
  }
  async function b2(e3) {
    try {
      if (!o2.value) throw Error(`Geolocation service not available`);
      i2.value ? y2() : n2.value ? v2() : (_2((await d2(e3(`trackerView.nameNewRoute`))).id), v2(o2.value.getLastKnownLocation()));
    } catch (e4) {
      throw console.error(e4), e4;
    }
  }
  function x2() {
    a2.value !== -1 && o2.value && (o2.value.removeLocationListener(a2.value), a2.value = -1), i2.value = false;
  }
  return { routeCollection: t2, routes: c2, currentRouteId: n2, isRecording: i2, watchingHandler: a2, currentRouteRecordTimespan: r2, setLocator: l2, init: u2, addRoute: d2, deleteRoute: f2, addPointToRoute: p2, updateRoute: m2, clearRoutePoints: h2, getRouteById: g2, setCurrentRouteId: _2, startRecording: v2, stopRecording: y2, toggleRecording: b2, cleanup: x2 };
});
var Xn = { class: `upload-container` }, Zn = { class: `action-buttons` }, Qn = V(F({ __name: `TextFileUploaderDialog`, props: qe({ multiple: { type: Boolean }, icon: {}, prompt: {}, types: {} }, { show: { default: false, type: Boolean }, showModifiers: {} }), emits: qe([`update:value`, `confirm`], [`update:show`]), setup(e2, { emit: t2 }) {
  let n2 = T(), r2 = e2, i2 = t2, a2 = Re(e2, `show`), o2 = [], s2 = (e3) => {
    o2 = [];
    for (let t3 of e3) {
      let a3 = t3.file;
      if (a3) if (r2.types.includes(a3.type)) {
        let t4 = new FileReader();
        t4.onload = (t5) => {
          var _a2;
          ((_a2 = t5.target) == null ? void 0 : _a2.result) && o2.push(t5.target.result), o2.length === e3.length && i2(`update:value`, o2);
        }, t4.readAsText(a3);
      } else n2.warning(`Skipped file ${t3.name} due to unsupported type ${a3.type}`);
    }
  }, c2 = () => {
    i2(`confirm`, o2), a2.value = false;
  }, l2 = (e3) => {
    var _a2, _b;
    return r2.types.includes(((_a2 = e3.file.file) == null ? void 0 : _a2.type) ?? ``) ? true : (n2.error(`Unsupported file type ${((_b = e3.file.file) == null ? void 0 : _b.type) ?? `unknown`}. Supported types: ['${r2.types.join(`', '`)}']`), false);
  };
  return (e3, t3) => (N(), k(A(rt), { show: a2.value, "onUpdate:show": t3[2] || (t3[2] = (e4) => a2.value = e4), preset: `dialog`, title: `Dialog` }, { header: W(() => [...t3[3] || (t3[3] = [j(` File Upload `, -1)])]), default: W(() => [B(`div`, Xn, [R(A(Gn), { multiple: r2.multiple ?? false, onChange: t3[0] || (t3[0] = ({ fileList: e4 }) => s2(e4)), onBeforeUpload: l2 }, { default: W(() => [R(A(gn), null, { default: W(() => [R(A(Ot), { size: 36, name: `upload`, class: `upload-icon` }, { default: W(() => [(N(), k(Ie(r2.icon ?? A(ne))))]), _: 1 }), B(`div`, null, z(r2.prompt ?? `Drag and drop a file here or click to upload`), 1)]), _: 1 })]), _: 1 }, 8, [`multiple`])])]), action: W(() => [B(`div`, Zn, [R(A(gt), { onClick: t3[1] || (t3[1] = (e4) => a2.value = false) }, { default: W(() => [...t3[4] || (t3[4] = [j(` Cancel `, -1)])]), _: 1 }), R(A(gt), { type: `primary`, onClick: c2 }, { default: W(() => [...t3[5] || (t3[5] = [j(` Upload `, -1)])]), _: 1 })])]), _: 1 }, 8, [`show`]));
} }), [[`__scopeId`, `data-v-14c5a0c1`]]), $n = { width: `24`, height: `24`, viewBox: `0 0 24 24`, fill: `none`, xmlns: `http://www.w3.org/2000/svg` }, er = { key: 0, d: `M12 4V20M12 4L8 8M12 4L16 8`, stroke: `currentColor`, "stroke-width": `2`, "stroke-linecap": `round`, "stroke-linejoin": `round` }, tr = { key: 1, d: `M12 20V4M12 20L8 16M12 20L16 16`, stroke: `currentColor`, "stroke-width": `2`, "stroke-linecap": `round`, "stroke-linejoin": `round` }, nr = { key: 2, d: `M4 12H20M4 12L8 8M4 12L8 16`, stroke: `currentColor`, "stroke-width": `2`, "stroke-linecap": `round`, "stroke-linejoin": `round` }, rr = { key: 3, d: `M20 12H4M20 12L16 8M20 12L16 16`, stroke: `currentColor`, "stroke-width": `2`, "stroke-linecap": `round`, "stroke-linejoin": `round` }, ir = { style: { height: `100%`, width: `100%`, overflow: `auto` } }, ar = 80, or = V(F({ __name: `MglDrawer`, props: qe({ position: {} }, { show: { type: Boolean, default: false }, showModifiers: {} }), emits: qe([`update:width`, `update:height`, `click`, `contextmenu`], [`update:show`]), setup(e2, { emit: t2 }) {
  He((e3) => ({ fb84bf50: A(i2).modalColor, v5a865300: A(i2).borderRadius, v8087a976: A(i2).textColorBase, v6b220caf: m2.value, d6be737a: p2.value }));
  let n2 = e2, r2 = t2, i2 = At(), a2 = Ne(`route-drawer`), o2 = L(() => n2.position || `left`), s2 = 0, c2 = 0, l2 = (e3) => {
    s2 = e3.touches[0].clientX, c2 = e3.touches[0].clientY;
  }, u2 = (e3) => {
    if (!s2 || !c2) return;
    let t3 = e3.changedTouches[0].clientX, n3 = e3.changedTouches[0].clientY, r3 = t3 - s2, i3 = n3 - c2, a3 = false;
    o2.value === `left` && r3 < -ar && (a3 = true), o2.value === `right` && r3 > ar && (a3 = true), o2.value === `top` && i3 < -ar && (a3 = true), o2.value === `bottom` && i3 > ar && (a3 = true), a3 && (h2.value = false), s2 = 0, c2 = 0;
  }, d2 = L(() => {
    var _a2, _b, _c, _d;
    return Math.min(Pt(Math.round((((_b = (_a2 = a2.value) == null ? void 0 : _a2.parentElement) == null ? void 0 : _b.clientWidth) ?? 2e3) * 0.4), 320, 640), (((_d = (_c = a2.value) == null ? void 0 : _c.parentElement) == null ? void 0 : _d.clientWidth) ?? 1 / 0) - 48);
  }), f2 = L(() => {
    var _a2, _b, _c, _d;
    return Math.min(Pt(Math.round((((_b = (_a2 = a2.value) == null ? void 0 : _a2.parentElement) == null ? void 0 : _b.clientHeight) ?? 2e3) * 0.4), 320, 640), (((_d = (_c = a2.value) == null ? void 0 : _c.parentElement) == null ? void 0 : _d.clientHeight) ?? 1 / 0) - 48);
  }), p2 = L(() => o2.value === `left` ? `${-16 - d2.value}px` : o2.value === `right` ? `${16 + d2.value}px` : o2.value === `top` ? `${-16 - f2.value}px` : o2.value === `bottom` ? `${16 + f2.value}px` : `0px`), m2 = L(() => o2.value === `left` || o2.value === `right` ? `${d2.value}px` : `${f2.value}px`), h2 = Re(e2, `show`);
  return D(d2, () => r2(`update:width`, d2.value)), D(f2, () => r2(`update:height`, f2.value)), (e3, t3) => (N(), k(Pe, { name: `slide-${o2.value}` }, { default: W(() => [je(B(`div`, { ref: `route-drawer`, class: H([`route-drawer`, `route-drawer--${o2.value}`]), onClick: t3[0] || (t3[0] = (e4) => r2(`click`, e4)), onContextmenu: t3[1] || (t3[1] = (e4) => r2(`contextmenu`, e4)), onTouchstart: l2, onTouchend: u2 }, [B(`div`, { class: H([`swipe-indicator`, `swipe-indicator--${o2.value}`]) }, [(N(), U(`svg`, $n, [o2.value === `top` ? (N(), U(`path`, er)) : o2.value === `bottom` ? (N(), U(`path`, tr)) : o2.value === `left` ? (N(), U(`path`, nr)) : o2.value === `right` ? (N(), U(`path`, rr)) : P(``, true)]))], 2), B(`div`, ir, [Fe(e3.$slots, `default`, {}, void 0, true)])], 34), [[We, h2.value]])]), _: 3 }, 8, [`name`]));
} }), [[`__scopeId`, `data-v-d4d0ff7b`]]), sr = { class: `menu-list` }, cr = [`onClick`, `onContextmenu`, `onTouchstart`], lr = { class: `swipe-container` }, ur = { style: { height: `fit-content`, padding: `8px 12px` } }, dr = [`onClick`], fr = { style: { padding: `16px` } }, pr = 120, mr = 40, hr = V(F({ __name: `SelectableSwipeableMenuList`, props: qe({ items: {}, menuOptions: {}, swipeActions: {} }, { selection: { type: String, default: null }, selectionModifiers: {}, multipleSelection: { type: Array, default: () => [] }, multipleSelectionModifiers: {} }), emits: qe([`contextmenu`], [`update:selection`, `update:multipleSelection`]), setup(e2, { emit: t2 }) {
  He((e3) => ({ af602246: A(o2).hoverColor, v2c598f52: A(o2).primaryColor, f032366a: A(o2).bodyColor, v6ce963b2: s2.value }));
  let n2 = e2, r2 = Re(e2, `selection`), i2 = Re(e2, `multipleSelection`), a2 = t2, o2 = At(), s2 = E(`0s`), c2 = E({ startX: 0, delta: 0, currentX: 0, containerWidth: 0, activeId: null, leftMax: 0, rightMax: 0 }), l2 = E(false), u2 = E(0), d2 = E(0), f2 = E(null);
  function p2(e3, t3) {
    c2.value.activeId !== t3 && _2();
    let n3 = e3.touches[0];
    c2.value = { startX: n3.clientX, delta: c2.value.delta ?? 0, currentX: n3.clientX, containerWidth: e3.currentTarget.offsetWidth, activeId: t3, leftMax: pr < 0 ? c2.value.containerWidth : pr, rightMax: mr < 0 ? c2.value.containerWidth : mr };
  }
  function m2(e3) {
    c2.value.activeId && (c2.value.currentX = e3.touches[0].clientX, c2.value.delta += c2.value.currentX - c2.value.startX, c2.value.delta = Pt(c2.value.delta, -c2.value.leftMax, c2.value.rightMax), c2.value.startX = e3.touches[0].clientX);
  }
  function h2() {
    if (!c2.value.activeId) return;
    s2.value = `${Math.abs(c2.value.delta) / c2.value.containerWidth * 0.3}s`, setTimeout(() => {
      s2.value = `0s`;
    }, 300);
    let e3 = c2.value.delta < 0 ? c2.value.leftMax : c2.value.rightMax;
    c2.value.delta = Math.abs(c2.value.delta) > e3 * 0.4 ? Math.sign(c2.value.delta) * e3 : 0, c2.value.delta === 0 && Math.abs(c2.value.delta);
  }
  function g2(e3, t3) {
    e3.stopPropagation(), !(c2.value.delta > 5) && (_2(), r2.value !== t3.id && (r2.value = t3.id));
  }
  function _2() {
    c2.value.delta > 0 || (c2.value = { startX: 0, delta: 0, currentX: 0, containerWidth: 0, activeId: null, leftMax: 0, rightMax: 0 });
  }
  function v2(e3, t3) {
    if (e3.stopPropagation(), e3.preventDefault(), l2.value) {
      l2.value = false;
      return;
    }
    f2.value = t3, u2.value = e3.clientX, d2.value = e3.clientY, l2.value = true, a2(`contextmenu`, e3, t3);
  }
  function y2(e3) {
    let t3 = [...i2.value];
    if (t3.includes(e3)) {
      let n3 = t3.indexOf(e3);
      t3.splice(n3, 1);
    } else t3.push(e3);
    i2.value = t3;
  }
  return (e3, t3) => (N(), U(et, null, [B(`div`, sr, [(N(true), U(et, null, Xe(n2.items, (t4) => (N(), U(`div`, { key: t4.id, class: H([`menu-list-item`, ...t4.id === r2.value ? [`active`] : []]), style: I({ "touch-action": c2.value.activeId === t4.id ? `pan-y` : `auto` }), onClick: (e4) => g2(e4, t4), onContextmenu: ke((e4) => v2(e4, t4), [`prevent`]), onTouchstart: (e4) => p2(e4, t4.id), onTouchmove: m2, onTouchend: h2 }, [B(`div`, lr, [B(`div`, { class: `content-col`, style: I({ transform: `translateX(${c2.value.activeId === t4.id || c2.value.delta > 0 ? c2.value.delta : 0}px)`, willChange: c2.value.activeId === t4.id ? `transform` : `auto`, flexDirection: c2.value.delta >= 0 || c2.value.activeId !== t4.id ? `row` : `row-reverse` }) }, [Fe(e3.$slots, `item`, { item: t4 }, () => [B(`div`, ur, [B(`div`, null, z(t4.name ?? `Untitled`), 1)])], true)], 4), B(`div`, { class: `actions-col`, style: I({ width: `${c2.value.activeId === t4.id && c2.value.delta < 0 ? -c2.value.delta : 0}px`, visibility: c2.value.activeId === t4.id && c2.value.delta < 0 ? `visible` : `hidden`, willChange: c2.value.activeId === t4.id ? `width` : `auto` }) }, [(N(true), U(et, null, Xe(n2.swipeActions, (e4) => (N(), U(`button`, { key: e4.name, class: `menu-action`, style: I({ background: e4.color || A(o2).primaryColorSuppl }), onClick: () => {
    e4.action(t4.id), c2.value.activeId = null;
  } }, z(e4.label), 13, dr))), 128))], 4), B(`div`, { class: `select-col`, style: I({ width: `${c2.value.delta > 0 ? c2.value.delta : 0}px`, backgroundColor: r2.value === t4.id ? A(o2).primaryColor : `transparent`, visibility: c2.value.delta > 0 ? `visible` : `hidden` }) }, [B(`div`, fr, [R(A(tn), { checked: i2.value.includes(t4.id), style: I({ border: r2.value === t4.id ? `1px solid ${A(o2).bodyColor}` : `none`, BorderRadius: r2.value === t4.id ? A(o2).borderRadiusSmall : `none` }), "onUpdate:checked": () => y2(t4.id) }, null, 8, [`checked`, `style`, `onUpdate:checked`])])], 4)])], 46, cr))), 128))]), R(A(st), { show: l2.value, x: u2.value, y: d2.value, options: n2.menuOptions.map((e4) => {
    var _a2;
    return { ...e4, label: ((_a2 = e4.label) == null ? void 0 : _a2.value) ?? e4.label };
  }), placement: `bottom-start`, trigger: `manual`, onClick: t3[0] || (t3[0] = (e4) => l2.value = false), onClickoutside: t3[1] || (t3[1] = (e4) => l2.value = false) }, null, 8, [`show`, `x`, `y`, `options`])], 64));
} }), [[`__scopeId`, `data-v-b353d352`]]), gr = { class: `drawer-floating` }, _r = { class: `drawer-container` }, vr = { class: `drawer-header` }, yr = { class: `drawer-title` }, br = { style: { height: `fit-content`, padding: `8px 12px`, "text-align": `left` } }, xr = { style: { "font-size": `0.8rem`, opacity: `0.7`, display: `flex`, "flex-direction": `row`, gap: `12px` } }, Sr = { key: 0 }, Cr = V(F({ __name: `TrackerViewRouteDrawer`, props: { show: { type: Boolean, default: false }, showModifiers: {} }, emits: qe([`update:width`], [`update:show`]), setup(e2, { emit: t2 }) {
  He((e3) => ({ v47589e0b: A(s2).borderRadius, v9a2db618: A(s2).hoverColor, v1460ff94: A(s2).primaryColorPressed, v9a1176a4: A(s2).primaryColor, v4a59e058: A(s2).bodyColor }));
  let n2 = new Dt().isMobile, { t: r2 } = at(), i2 = te(), a2 = t2, o2 = Yn(), s2 = At(), c2 = Re(e2, `show`), l2 = E(false), u2 = E(0), d2 = E(0), f2 = E(null), p2 = E(false), m2 = E(``), h2 = E(null), g2 = [{ label: L(() => r2(`components.trackerViewRouteDrawer.contextMenu.new`)), key: `new`, props: { onClick: () => {
    l2.value = false, o2.addRoute(r2(`components.trackerViewRouteDrawer.nameNewRoute`));
  } } }], _2 = [{ label: L(() => r2(`components.trackerViewRouteDrawer.contextMenu.rename`)), key: `rename`, props: { onClick: () => {
    var _a2;
    ((_a2 = f2.value) == null ? void 0 : _a2.id) && (m2.value = f2.value.name || ``, p2.value = true);
  } } }, { label: L(() => r2(`components.trackerViewRouteDrawer.contextMenu.delete`)), key: `delete`, props: { onClick: () => {
    f2.value && o2.deleteRoute(f2.value.id);
  } } }, { key: `divider-1`, type: `divider` }, ...g2], v2 = [{ label: L(() => r2(`components.trackerViewRouteDrawer.contextMenu.rename`)), name: `rename`, action: (e3) => {
    let t3 = o2.routes.find((t4) => t4.id === e3);
    h2.value = e3, m2.value = (t3 == null ? void 0 : t3.name) || ``, p2.value = true;
  } }, { label: L(() => r2(`components.trackerViewRouteDrawer.contextMenu.delete`)), name: `delete`, action: (e3) => o2.deleteRoute(e3), color: s2.value.errorColorSuppl }];
  function y2(e3) {
    if (e3.stopPropagation(), e3.preventDefault(), h2.value = o2.currentRouteId, l2.value) {
      l2.value = false;
      return;
    }
    u2.value = e3.clientX, d2.value = e3.clientY, l2.value = true;
  }
  async function b2(e3) {
    m2.value.trim() && (await o2.updateRoute(e3, { meta: { name: m2.value.trim() } }), p2.value = false);
  }
  let x2 = E([]);
  function S2() {
    i2.warning({ title: r2(`components.trackerViewRouteDrawer.deleteConfirmation.title`), content: r2(`components.trackerViewRouteDrawer.deleteConfirmation.prompt`), positiveText: r2(`components.trackerViewRouteDrawer.deleteConfirmation.yes`), negativeText: r2(`components.trackerViewRouteDrawer.deleteConfirmation.no`), onPositiveClick: () => {
      x2.value.forEach((e3) => {
        o2.deleteRoute(e3), x2.value = x2.value.filter((t3) => t3 !== e3);
      });
    } });
  }
  return (e3, t3) => (N(), U(et, null, [R(or, { show: c2.value, "onUpdate:show": t3[5] || (t3[5] = (e4) => c2.value = e4), position: A(n2) ? `bottom` : `left`, onClick: t3[6] || (t3[6] = () => A(o2).currentRouteId = null), "onUpdate:width": t3[7] || (t3[7] = (e4) => a2(`update:width`, e4)), onContextmenu: t3[8] || (t3[8] = (e4) => y2(e4)) }, { default: W(() => [B(`div`, gr, [A(n2) && c2.value ? Fe(e3.$slots, `bottom-floating`, { key: 0 }, void 0, true) : P(``, true)]), B(`div`, _r, [B(`div`, vr, [B(`p`, yr, z(A(r2)(`components.trackerViewRouteDrawer.routes`)), 1), x2.value.length > 0 ? (N(), k(A(gt), { key: 0, strong: ``, secondary: ``, circle: ``, type: `error`, onClick: S2 }, { icon: W(() => [R(A(Ot), { component: A(ee) }, null, 8, [`component`])]), _: 1 })) : P(``, true)]), B(`div`, { class: `drawer-content`, onTouchstart: t3[3] || (t3[3] = (e4) => e4.stopPropagation()), onTouchend: t3[4] || (t3[4] = (e4) => e4.stopPropagation()) }, [R(hr, { selection: A(o2).currentRouteId, "onUpdate:selection": t3[0] || (t3[0] = (e4) => A(o2).currentRouteId = e4), "multiple-selection": x2.value, "onUpdate:multipleSelection": t3[1] || (t3[1] = (e4) => x2.value = e4), items: A(o2).routes, "menu-options": _2, "swipe-actions": v2, onContextmenu: t3[2] || (t3[2] = (e4, t4) => {
    h2.value = (t4 == null ? void 0 : t4.id) ?? null, f2.value = t4 ?? null;
  }) }, { item: W(({ item: e4 }) => {
    var _a2;
    return [B(`div`, br, [B(`div`, null, z(e4.name ?? A(r2)(`components.trackerViewRouteDrawer.nameNewRoute`)), 1), B(`div`, xr, [B(`div`, null, z(A(r2)(`components.trackerViewRouteDrawer.points`, { num: e4.points.length })), 1), e4.points.length > 1 && ((_a2 = e4.meta) == null ? void 0 : _a2.distance) ? (N(), U(`div`, Sr, z(A(r2)(`components.trackerViewRouteDrawer.distance`, { distance: A(Ze)(e4.meta.distance) })), 1)) : P(``, true)])])];
  }), _: 1 }, 8, [`selection`, `multiple-selection`, `items`])], 32)])]), _: 3 }, 8, [`show`, `position`]), R(A(st), { show: l2.value, x: u2.value, y: d2.value, options: g2.map((e4) => ({ ...e4, label: e4.label.value })), placement: `bottom-start`, trigger: `manual`, onClickoutside: t3[9] || (t3[9] = (e4) => l2.value = false) }, null, 8, [`show`, `x`, `y`, `options`]), R(A(rt), { show: p2.value, "onUpdate:show": t3[12] || (t3[12] = (e4) => p2.value = e4), preset: `dialog`, title: `Rename Route`, "positive-text": `Save`, "negative-text": `Cancel`, onPositiveClick: t3[13] || (t3[13] = () => {
    h2.value && b2(h2.value);
  }) }, { default: W(() => [R(A(le), { value: m2.value, "onUpdate:value": t3[10] || (t3[10] = (e4) => m2.value = e4), placeholder: `Enter new route name`, onKeyup: t3[11] || (t3[11] = ze(() => {
    h2.value && b2(h2.value);
  }, [`enter`])) }, null, 8, [`value`])]), _: 1 }, 8, [`show`])], 64));
} }), [[`__scopeId`, `data-v-473cdb34`]]);
const wr = Ke(`map`, () => {
  let e2 = E(7), t2 = E([0, 0]), n2 = E(0), r2 = E(0), i2 = E(false);
  async function a2() {
    let a3 = await yt(`mapState`);
    a3 && (e2.value = a3.zoom, t2.value = a3.center, n2.value = a3.bearing, i2.value = a3.isTrackingOrientation, r2.value = a3.lastUpdateTime);
  }
  async function o2() {
    r2.value = Date.now();
    let a3 = { zoom: e2.value, center: t2.value, bearing: n2.value, isTrackingOrientation: i2.value, lastUpdateTime: r2.value };
    await vt(`mapState`, JSON.parse(JSON.stringify(a3))), await _t();
  }
  function s2(t3) {
    e2.value = t3;
  }
  function c2(e3) {
    t2.value = e3.toLngLatLike();
  }
  function l2(e3) {
    n2.value = e3;
  }
  function u2(e3) {
    i2.value = e3;
  }
  function d2() {
    e2.value = 7, t2.value = [0, 0], n2.value = 0, i2.value = false;
  }
  return D([e2, t2, n2, i2], o2, { deep: true }), { zoom: e2, center: t2, bearing: n2, isTrackingOrientation: i2, lastUpdateTime: r2, init: a2, save: o2, setZoom: s2, setCenter: c2, setBearing: l2, setTrackingOrientation: u2, resetToDefault: d2 };
});
pe();
function G() {
  return G = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var n2 = arguments[t2];
      for (var r2 in n2) ({}).hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
    }
    return e2;
  }, G.apply(null, arguments);
}
var K;
(function(e2) {
  e2.Commit = `commit`, e2.Provisional = `provisional`, e2.Finish = `finish`;
})(K || (K = {}));
var Tr = `https://raw.githubusercontent.com/JamesLMilner/terra-draw/refs/heads/main/assets/markers/marker-blue.png`, q = { SELECTED: `selected`, MID_POINT: `midPoint`, SELECTION_POINT_FEATURE_ID: `selectionPointFeatureId`, SELECTION_POINT: `selectionPoint` }, J = { MODE: `mode`, CURRENTLY_DRAWING: `currentlyDrawing`, EDITED: `edited`, CLOSING_POINT: `closingPoint`, SNAPPING_POINT: `snappingPoint`, COORDINATE_POINT: `coordinatePoint`, COORDINATE_POINT_FEATURE_ID: `coordinatePointFeatureId`, COORDINATE_POINT_IDS: `coordinatePointIds`, PROVISIONAL_COORDINATE_COUNT: `provisionalCoordinateCount`, COMMITTED_COORDINATE_COUNT: `committedCoordinateCount`, MARKER: `marker` }, Er = 10;
function Dr(e2) {
  return !!(e2 && typeof e2 == `object` && e2 && !Array.isArray(e2));
}
function Or(e2) {
  return !!(e2 && typeof e2 == `object` && `properties` in e2 && typeof e2.properties == `object` && e2.properties !== null && `mode` in e2.properties);
}
function kr(e2) {
  return !!(function(e3) {
    return typeof e3 == `number` && !isNaN(new Date(e3).valueOf());
  })(e2);
}
var Ar = `Feature mode property does not match the mode being added to`, jr;
(function(e2) {
  e2.Drawing = `drawing`, e2.Select = `select`, e2.Static = `static`, e2.Render = `render`;
})(jr || (jr = {}));
var Mr = { rightClick: true, contextMenu: false, leftClick: true, onDragStart: true, onDrag: true, onDragEnd: true }, Nr = class {
  get state() {
    return this._state;
  }
  set state(e2) {
    throw Error(`Please use the modes lifecycle methods`);
  }
  get styles() {
    return this._styles;
  }
  set styles(e2) {
    if (typeof e2 != `object`) throw Error(`Styling must be an object`);
    this.onStyleChange && this.onStyleChange([], `styling`), this._styles = e2;
  }
  registerBehaviors(e2) {
  }
  constructor(e2, t2 = false) {
    this._state = `unregistered`, this._styles = {}, this.pointerEvents = Mr, this.behaviors = [], this.validate = void 0, this.pointerDistance = 40, this.coordinatePrecision = void 0, this.onStyleChange = void 0, this.store = void 0, this.projection = `web-mercator`, this.setDoubleClickToZoom = void 0, this.unproject = void 0, this.project = void 0, this.setCursor = void 0, this.isInitialUpdate = false, this.type = jr.Drawing, this.mode = `base`, t2 ? this.isInitialUpdate = true : this.updateOptions(G({}, e2));
  }
  updateOptions(e2) {
    e2 != null && e2.styles && (this.styles = G({}, this._styles, e2.styles)), e2 != null && e2.pointerDistance && (this.pointerDistance = e2.pointerDistance), e2 != null && e2.validation && (this.validate = e2 && e2.validation), e2 != null && e2.projection && (this.projection = e2.projection), (e2 == null ? void 0 : e2.pointerEvents) !== void 0 && (this.pointerEvents = e2.pointerEvents), e2 != null && e2.modeName && true === this.isInitialUpdate && (this.mode = e2.modeName), this.isInitialUpdate = false;
  }
  allowPointerEvent(e2, t2) {
    return typeof e2 == `boolean` ? e2 : typeof e2 != `function` || e2(t2);
  }
  setDrawing() {
    if (this._state !== `started`) throw Error(`Mode must be unregistered or stopped to start`);
    this._state = `drawing`;
  }
  setStarted() {
    if (this._state !== `stopped` && this._state !== `registered` && this._state !== `drawing` && this._state !== `selecting`) throw Error(`Mode must be unregistered or stopped to start`);
    this._state = `started`, this.setDoubleClickToZoom(false);
  }
  setStopped() {
    if (this._state !== `started`) throw Error(`Mode must be started to be stopped`);
    this._state = `stopped`, this.setDoubleClickToZoom(true);
  }
  register(e2) {
    if (this._state !== `unregistered`) throw Error(`Can not register unless mode is unregistered`);
    this._state = `registered`, this.store = e2.store, this.store.registerOnChange(e2.onChange), this.setDoubleClickToZoom = e2.setDoubleClickToZoom, this.project = e2.project, this.unproject = e2.unproject, this.onSelect = e2.onSelect, this.onDeselect = e2.onDeselect, this.setCursor = e2.setCursor, this.onStyleChange = e2.onChange, this.onFinish = e2.onFinish, this.coordinatePrecision = e2.coordinatePrecision, this.registerBehaviors({ mode: e2.mode, store: this.store, project: this.project, unproject: this.unproject, pointerDistance: this.pointerDistance, coordinatePrecision: e2.coordinatePrecision, projection: this.projection });
  }
  validateFeature(e2) {
    return this.performFeatureValidation(e2);
  }
  afterFeatureAdded(e2) {
  }
  afterFeatureUpdated(e2) {
  }
  performFeatureValidation(e2) {
    if (this._state === `unregistered`) throw Error(`Mode must be registered`);
    let t2 = (function(e3, t3) {
      let n2;
      if (Dr(e3)) if (e3.id == null) n2 = `Feature has no id`;
      else if (typeof e3.id != `string` && typeof e3.id != `number`) n2 = `Feature must be string or number as per GeoJSON spec`;
      else if (t3(e3.id)) if (Dr(e3.geometry)) if (Dr(e3.properties)) if (typeof e3.geometry.type == `string` && [`Polygon`, `LineString`, `Point`].includes(e3.geometry.type)) if (Array.isArray(e3.geometry.coordinates)) {
        if (!e3.properties.mode || typeof e3.properties.mode != `string`) return { valid: false, reason: `Feature does not have a valid mode property` };
      } else n2 = `Feature coordinates is not an array`;
      else n2 = `Feature is not Point, LineString or Polygon`;
      else n2 = `Feature has no properties`;
      else n2 = `Feature has no geometry`;
      else n2 = `Feature must match the id strategy (default is UUID4)`;
      else n2 = `Feature is not object`;
      return n2 ? { valid: false, reason: n2 } : { valid: true };
    })(e2, this.store.idStrategy.isValidId);
    if (this.validate) {
      let n2 = this.validate(e2, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: K.Provisional });
      return { valid: t2.valid && n2.valid, reason: n2.reason };
    }
    return { valid: t2.valid, reason: t2.reason };
  }
  validateModeFeature(e2, t2) {
    let n2 = this.performFeatureValidation(e2);
    return n2.valid ? e2.properties.mode === this.mode ? t2(e2) : { valid: false, reason: Ar } : { valid: false, reason: n2.reason };
  }
  onFinish(e2, t2) {
  }
  onDeselect(e2) {
  }
  onSelect(e2) {
  }
  onKeyDown(e2) {
  }
  onKeyUp(e2) {
  }
  onMouseMove(e2) {
  }
  onClick(e2) {
  }
  onDragStart(e2, t2) {
  }
  onDrag(e2, t2) {
  }
  onDragEnd(e2, t2) {
  }
  getHexColorStylingValue(e2, t2, n2) {
    return this.getStylingValue(e2, t2, n2);
  }
  getNumericStylingValue(e2, t2, n2) {
    return this.getStylingValue(e2, t2, n2);
  }
  getUrlStylingValue(e2, t2, n2) {
    return this.getStylingValue(e2, t2, n2);
  }
  getStylingValue(e2, t2, n2) {
    return e2 === void 0 ? t2 : typeof e2 == `function` ? e2(n2) : e2;
  }
}, Pr = class extends Nr {
  constructor(...e2) {
    super(...e2), this.type = jr.Select;
  }
};
function Fr(e2, t2) {
  let n2 = (e3) => e3 * Math.PI / 180, r2 = n2(e2[1]), i2 = n2(e2[0]), a2 = n2(t2[1]), o2 = a2 - r2, s2 = n2(t2[0]) - i2, c2 = Math.sin(o2 / 2) * Math.sin(o2 / 2) + Math.cos(r2) * Math.cos(a2) * Math.sin(s2 / 2) * Math.sin(s2 / 2);
  return 2 * Math.atan2(Math.sqrt(c2), Math.sqrt(1 - c2)) * 6371e3 / 1e3;
}
var Ir = 63710088e-1;
function Y(e2) {
  return e2 % 360 * Math.PI / 180;
}
function Lr(e2) {
  return e2 / 6371.0088;
}
function Rr(e2) {
  return e2 % (2 * Math.PI) * 180 / Math.PI;
}
function X(e2, t2 = 9) {
  let n2 = 10 ** t2;
  return Math.round(e2 * n2) / n2;
}
var zr = 57.29577951308232, Br = 0.017453292519943295, Vr = 6378137, Z = (e2, t2) => ({ x: e2 === 0 ? 0 : e2 * Br * Vr, y: t2 === 0 ? 0 : Math.log(Math.tan(Math.PI / 4 + t2 * Br / 2)) * Vr }), Hr = (e2, t2) => ({ lng: e2 === 0 ? 0 : e2 / Vr * zr, lat: t2 === 0 ? 0 : (2 * Math.atan(Math.exp(t2 / Vr)) - Math.PI / 2) * zr });
function Ur(e2) {
  let t2;
  if (e2.geometry.type === `Polygon`) t2 = e2.geometry.coordinates;
  else {
    if (e2.geometry.type !== `LineString`) throw Error(`Self intersects only accepts Polygons and LineStrings`);
    t2 = [e2.geometry.coordinates];
  }
  let n2 = [];
  for (let e3 = 0; e3 < t2.length; e3++) for (let n3 = 0; n3 < t2[e3].length - 1; n3++) for (let r3 = 0; r3 < t2.length; r3++) for (let a2 = 0; a2 < t2[r3].length - 1; a2++) i2(e3, n3, r3, a2);
  return n2.length > 0;
  function r2(e3) {
    return e3 < 0 || e3 > 1;
  }
  function i2(e3, i3, a2, o2) {
    let s2 = t2[e3][i3], c2 = t2[e3][i3 + 1], l2 = t2[a2][o2], u2 = t2[a2][o2 + 1], d2 = (function(e4, t3, n3, r3) {
      if (Wr(e4, n3) || Wr(e4, r3) || Wr(t3, n3) || Wr(r3, n3)) return null;
      let i4 = e4[0], a3 = e4[1], o3 = t3[0], s3 = t3[1], c3 = n3[0], l3 = n3[1], u3 = r3[0], d3 = r3[1], f3 = (i4 - o3) * (l3 - d3) - (a3 - s3) * (c3 - u3);
      return f3 === 0 ? null : [((i4 * s3 - a3 * o3) * (c3 - u3) - (i4 - o3) * (c3 * d3 - l3 * u3)) / f3, ((i4 * s3 - a3 * o3) * (l3 - d3) - (a3 - s3) * (c3 * d3 - l3 * u3)) / f3];
    })(s2, c2, l2, u2);
    if (d2 === null) return;
    let f2, p2;
    f2 = c2[0] === s2[0] ? (d2[1] - s2[1]) / (c2[1] - s2[1]) : (d2[0] - s2[0]) / (c2[0] - s2[0]), p2 = u2[0] === l2[0] ? (d2[1] - l2[1]) / (u2[1] - l2[1]) : (d2[0] - l2[0]) / (u2[0] - l2[0]), r2(f2) || r2(p2) || (d2.toString(), n2.push(d2));
  }
}
function Wr(e2, t2) {
  return e2[0] === t2[0] && e2[1] === t2[1];
}
function Gr(e2, t2) {
  return qr(e2[0]) <= t2 && qr(e2[1]) <= t2;
}
function Kr(e2) {
  return e2.length === 2 && typeof e2[0] == `number` && typeof e2[1] == `number` && e2[0] !== 1 / 0 && e2[1] !== 1 / 0 && (n2 = e2[0]) >= -180 && n2 <= 180 && (t2 = e2[1]) >= -90 && t2 <= 90;
  var t2, n2;
}
function qr(e2) {
  let t2 = 1, n2 = 0;
  for (; Math.round(e2 * t2) / t2 !== e2; ) t2 *= 10, n2++;
  return n2;
}
var Q = (e2, t2) => {
  let { x: n2, y: r2 } = e2, { x: i2, y: a2 } = t2, o2 = i2 - n2, s2 = a2 - r2;
  return Math.sqrt(s2 * s2 + o2 * o2);
}, $ = class {
  constructor({ store: e2, mode: t2, project: n2, unproject: r2, pointerDistance: i2, coordinatePrecision: a2, projection: o2 }) {
    this.store = void 0, this.mode = void 0, this.project = void 0, this.unproject = void 0, this.pointerDistance = void 0, this.coordinatePrecision = void 0, this.projection = void 0, this.store = e2, this.mode = t2, this.project = n2, this.unproject = r2, this.pointerDistance = i2, this.coordinatePrecision = a2, this.projection = o2;
  }
};
function Jr({ unproject: e2, point: t2, pointerDistance: n2 }) {
  let r2 = n2 / 2, { x: i2, y: a2 } = t2;
  return { type: `Feature`, properties: {}, geometry: { type: `Polygon`, coordinates: [[e2(i2 - r2, a2 - r2), e2(i2 + r2, a2 - r2), e2(i2 + r2, a2 + r2), e2(i2 - r2, a2 + r2), e2(i2 - r2, a2 - r2)].map((e3) => [e3.lng, e3.lat])] } };
}
var Yr = class extends $ {
  constructor(e2) {
    super(e2);
  }
  create(e2) {
    let { containerX: t2, containerY: n2 } = e2;
    return Jr({ unproject: this.unproject, point: { x: t2, y: n2 }, pointerDistance: this.pointerDistance });
  }
}, Xr = class extends $ {
  constructor(e2) {
    super(e2);
  }
  measure(e2, t2) {
    let { x: n2, y: r2 } = this.project(t2[0], t2[1]);
    return Q({ x: n2, y: r2 }, { x: e2.containerX, y: e2.containerY });
  }
}, Zr = class extends $ {
  constructor(e2, t2, n2) {
    super(e2), this.config = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.getSnappableCoordinateFirstClick = (e3) => this.getSnappable(e3, (e4) => !!(e4.properties && e4.properties.mode === this.mode)).coordinate, this.getSnappableCoordinate = (e3, t3) => this.getSnappable(e3, (e4) => !!(e4.properties && e4.properties.mode === this.mode && e4.id !== t3)).coordinate, this.config = e2, this.pixelDistance = t2, this.clickBoundingBox = n2;
  }
  getSnappable(e2, t2) {
    let n2 = this.clickBoundingBox.create(e2), r2 = this.store.search(n2, t2), i2 = { featureId: void 0, featureCoordinateIndex: void 0, coordinate: void 0, minDist: 1 / 0 };
    return r2.forEach((t3) => {
      let n3;
      if (t3.geometry.type === `Polygon`) n3 = t3.geometry.coordinates[0];
      else {
        if (t3.geometry.type !== `LineString`) return;
        n3 = t3.geometry.coordinates;
      }
      n3.forEach((n4, r3) => {
        let a2 = this.pixelDistance.measure(e2, n4);
        a2 < i2.minDist && a2 < this.pointerDistance && (i2.coordinate = n4, i2.minDist = a2, i2.featureId = t3.id, i2.featureCoordinateIndex = r3);
      });
    }), i2;
  }
};
function Qr(e2, t2, n2) {
  let r2 = Y(e2[0]), i2 = Y(e2[1]), a2 = Y(n2), o2 = Lr(t2), s2 = Math.asin(Math.sin(i2) * Math.cos(o2) + Math.cos(i2) * Math.sin(o2) * Math.cos(a2));
  return [Rr(r2 + Math.atan2(Math.sin(a2) * Math.sin(o2) * Math.cos(i2), Math.cos(o2) - Math.sin(i2) * Math.sin(s2))), Rr(s2)];
}
function $r(e2, t2) {
  let n2 = Y(e2[0]), r2 = Y(t2[0]), i2 = Y(e2[1]), a2 = Y(t2[1]), o2 = Math.sin(r2 - n2) * Math.cos(a2), s2 = Math.cos(i2) * Math.sin(a2) - Math.sin(i2) * Math.cos(a2) * Math.cos(r2 - n2);
  return Rr(Math.atan2(o2, s2));
}
function ei({ x: e2, y: t2 }, { x: n2, y: r2 }) {
  let i2 = n2 - e2, a2 = r2 - t2;
  if (i2 === 0 && a2 === 0) return 0;
  let o2 = Math.atan2(a2, i2);
  return o2 *= 180 / Math.PI, o2 > 180 ? o2 -= 360 : o2 < -180 && (o2 += 360), o2;
}
function ti(e2, t2, n2) {
  let r2 = [], i2 = e2.length, a2, o2, s2, c2 = 0;
  for (let i3 = 0; i3 < e2.length && !(t2 >= c2 && i3 === e2.length - 1); i3++) {
    if (c2 > t2 && r2.length === 0) {
      if (a2 = t2 - c2, !a2) return r2.push(e2[i3]), r2;
      o2 = $r(e2[i3], e2[i3 - 1]) - 180, s2 = Qr(e2[i3], a2, o2), r2.push(s2);
    }
    if (c2 >= n2) return a2 = n2 - c2, a2 ? (o2 = $r(e2[i3], e2[i3 - 1]) - 180, s2 = Qr(e2[i3], a2, o2), r2.push(s2), r2) : (r2.push(e2[i3]), r2);
    if (c2 >= t2 && r2.push(e2[i3]), i3 === e2.length - 1) return r2;
    c2 += Fr(e2[i3], e2[i3 + 1]);
  }
  if (c2 < t2 && e2.length === i2) throw Error(`Start position is beyond line`);
  let l2 = e2[e2.length - 1];
  return [l2, l2];
}
function ni(e2) {
  return e2 * (Math.PI / 180);
}
function ri(e2) {
  return e2 * (180 / Math.PI);
}
var ii = class extends $ {
  constructor(e2) {
    super(e2), this.config = void 0, this.config = e2;
  }
  generateInsertionCoordinates(e2, t2, n2) {
    let r2 = [e2, t2], i2 = 0;
    for (let e3 = 0; e3 < r2.length - 1; e3++) i2 += Fr(r2[0], r2[1]);
    if (i2 <= n2) return r2;
    let a2 = i2 / n2 - 1;
    Number.isInteger(a2) || (a2 = Math.floor(a2) + 1);
    let o2 = [];
    for (let e3 = 0; e3 < a2; e3++) {
      let t3 = ti(r2, n2 * e3, n2 * (e3 + 1));
      o2.push(t3);
    }
    let s2 = [];
    for (let e3 = 0; e3 < o2.length; e3++) s2.push(o2[e3][1]);
    return this.limitCoordinates(s2);
  }
  generateInsertionGeodesicCoordinates(e2, t2, n2) {
    let r2 = Fr(e2, t2), i2 = (function(e3, t3, n3) {
      let r3 = [], i3 = ni(e3[1]), a2 = ni(e3[0]), o2 = ni(t3[1]), s2 = ni(t3[0]);
      n3 += 1;
      let c2 = 2 * Math.asin(Math.sqrt(Math.sin((o2 - i3) / 2) ** 2 + Math.cos(i3) * Math.cos(o2) * Math.sin((s2 - a2) / 2) ** 2));
      if (c2 === 0 || isNaN(c2)) return r3;
      for (let e4 = 0; e4 <= n3; e4++) {
        let t4 = e4 / n3, l2 = Math.sin((1 - t4) * c2) / Math.sin(c2), u2 = Math.sin(t4 * c2) / Math.sin(c2), d2 = l2 * Math.cos(i3) * Math.cos(a2) + u2 * Math.cos(o2) * Math.cos(s2), f2 = l2 * Math.cos(i3) * Math.sin(a2) + u2 * Math.cos(o2) * Math.sin(s2), p2 = l2 * Math.sin(i3) + u2 * Math.sin(o2);
        if (isNaN(d2) || isNaN(f2) || isNaN(p2)) continue;
        let m2 = Math.atan2(p2, Math.sqrt(d2 ** 2 + f2 ** 2)), h2 = Math.atan2(f2, d2);
        isNaN(m2) || isNaN(h2) || r3.push([ri(h2), ri(m2)]);
      }
      return r3.slice(1, -1);
    })(e2, t2, Math.floor(r2 / n2));
    return this.limitCoordinates(i2);
  }
  limitCoordinates(e2) {
    return e2.map((e3) => [X(e3[0], this.config.coordinatePrecision), X(e3[1], this.config.coordinatePrecision)]);
  }
};
function ai(e2, t2) {
  return e2[0] === t2[0] && e2[1] === t2[1];
}
function oi(e2, t2) {
  if (e2.geometry.type !== `LineString`) return { valid: false, reason: `Feature is not a LineString` };
  if (e2.geometry.coordinates.length < 2) return { valid: false, reason: `Feature has less than 2 coordinates` };
  for (let n2 = 0; n2 < e2.geometry.coordinates.length; n2++) {
    if (!Kr(e2.geometry.coordinates[n2])) return { valid: false, reason: `Feature has invalid coordinates` };
    if (!Gr(e2.geometry.coordinates[n2], t2)) return { valid: false, reason: `Feature has coordinates with excessive precision` };
  }
  return { valid: true };
}
function si(e2) {
  return Math.sqrt(e2[0] ** 2 + e2[1] ** 2 + e2[2] ** 2);
}
function ci(e2, t2) {
  let n2 = (function(e3, t3) {
    let [n3, r2, i2] = e3, [a2, o2, s2] = t3;
    return n3 * a2 + r2 * o2 + i2 * s2;
  })(e2, t2) / (si(e2) * si(t2));
  return Math.acos(Math.min(Math.max(n2, -1), 1));
}
function li(e2) {
  let t2 = Y(e2[1]), n2 = Y(e2[0]);
  return [Math.cos(t2) * Math.cos(n2), Math.cos(t2) * Math.sin(n2), Math.sin(t2)];
}
function ui(e2) {
  let [t2, n2, r2] = e2, i2 = Rr(Math.asin(r2));
  return [Rr(Math.atan2(n2, t2)), i2];
}
function di(e2, t2, n2) {
  let r2 = li(e2), i2 = li(t2), [a2, o2, s2] = li(n2), [c2, l2, u2] = (function(e3, t3) {
    let [n3, r3, i3] = e3, [a3, o3, s3] = t3;
    return [r3 * s3 - i3 * o3, i3 * a3 - n3 * s3, n3 * o3 - r3 * a3];
  })(r2, i2), d2 = l2 * s2 - u2 * o2, f2 = u2 * a2 - c2 * s2, p2 = c2 * o2 - l2 * a2, m2 = p2 * l2 - f2 * u2, h2 = d2 * u2 - p2 * c2, g2 = f2 * c2 - d2 * l2, _2 = 1 / Math.sqrt(m2 ** 2 + h2 ** 2 + g2 ** 2), v2 = [m2 * _2, h2 * _2, g2 * _2], y2 = [-1 * m2 * _2, -1 * h2 * _2, -1 * g2 * _2], b2 = ci(r2, i2), x2 = ci(r2, v2), S2 = ci(i2, v2), ee2 = ci(r2, y2), C2 = ci(i2, y2), w2;
  return w2 = x2 < ee2 && x2 < C2 || S2 < ee2 && S2 < C2 ? v2 : y2, ci(r2, w2) > b2 || ci(i2, w2) > b2 ? Fr(ui(w2), ui(r2)) <= Fr(ui(w2), ui(i2)) ? [ui(r2), true, false] : [ui(i2), false, true] : [ui(w2), false, false];
}
function fi(e2, t2, n2) {
  let r2 = t2.x - e2.x, i2 = t2.y - e2.y, a2 = Math.max(0, Math.min(1, ((n2.x - e2.x) * r2 + (n2.y - e2.y) * i2) / (r2 * r2 + i2 * i2)));
  return { x: e2.x + a2 * r2, y: e2.y + a2 * i2 };
}
var pi = class extends $ {
  constructor(e2, t2, n2) {
    super(e2), this.config = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.getSnappableCoordinateFirstClick = (e3) => {
      let t3 = this.getSnappable(e3, (e4) => !!(e4.properties && e4.properties.mode === this.mode));
      return t3.coordinate ? [X(t3.coordinate[0], this.config.coordinatePrecision), X(t3.coordinate[1], this.config.coordinatePrecision)] : void 0;
    }, this.getSnappableCoordinate = (e3, t3) => {
      let n3 = this.getSnappable(e3, (e4) => !!(e4.properties && e4.properties.mode === this.mode && e4.id !== t3));
      return n3.coordinate ? [X(n3.coordinate[0], this.config.coordinatePrecision), X(n3.coordinate[1], this.config.coordinatePrecision)] : void 0;
    }, this.config = e2, this.pixelDistance = t2, this.clickBoundingBox = n2;
  }
  getSnappable(e2, t2) {
    let n2 = this.clickBoundingBox.create(e2), r2 = this.store.search(n2, t2), i2 = { featureId: void 0, featureCoordinateIndex: void 0, coordinate: void 0, minDistance: 1 / 0 };
    return r2.forEach((t3) => {
      let n3;
      if (t3.geometry.type === `Polygon`) n3 = t3.geometry.coordinates[0];
      else {
        if (t3.geometry.type !== `LineString`) return;
        n3 = t3.geometry.coordinates;
      }
      let r3 = [];
      for (let e3 = 0; e3 < n3.length - 1; e3++) r3.push([n3[e3], n3[e3 + 1]]);
      let a2, o2 = [e2.lng, e2.lat];
      if (this.config.projection === `web-mercator` ? a2 = (function(e3, t4) {
        let n4 = [1 / 0, 1 / 0], r4 = 1 / 0, i3 = 0;
        for (let a3 of t4) {
          let o3 = a3[0], s3 = a3[1], c2, l2 = 1 / 0, u2 = Z(o3[0], o3[1]), d2 = Z(s3[0], s3[1]), f2 = Z(e3[0], e3[1]);
          if (o3[0] === e3[0] && o3[1] === e3[1]) c2 = o3;
          else if (s3[0] === e3[0] && s3[1] === e3[1]) c2 = s3;
          else {
            let { x: e4, y: t5 } = fi(u2, d2, f2), { lng: n5, lat: r5 } = Hr(e4, t5);
            c2 = [n5, r5];
          }
          c2 && (l2 = Q(f2, Z(c2[0], c2[1])), l2 < r4 && (n4 = c2, r4 = l2, i3 = t4.indexOf(a3)));
        }
        return r4 === 1 / 0 ? void 0 : { coordinate: n4, lineIndex: i3, distance: r4 };
      })(o2, r3) : this.config.projection === `globe` && (a2 = (function(e3, t4) {
        let n4 = [1 / 0, 1 / 0], r4 = 1 / 0, i3 = 0;
        for (let a3 of t4) {
          let o3 = a3[0], s3 = a3[1], c2, l2 = 1 / 0;
          o3[0] === e3[0] && o3[1] === e3[1] ? c2 = o3 : s3[0] === e3[0] && s3[1] === e3[1] ? c2 = s3 : [c2] = di(o3, s3, e3), c2 && (l2 = Fr(e3, c2), l2 < r4 && (n4 = c2, r4 = l2, i3 = t4.indexOf(a3)));
        }
        return r4 === 1 / 0 ? void 0 : { coordinate: n4, distance: r4, lineIndex: i3 };
      })(o2, r3)), !a2) return;
      let s2 = this.pixelDistance.measure(e2, a2.coordinate);
      s2 < i2.minDistance && s2 < this.pointerDistance && (i2.featureId = t3.id, i2.coordinate = [X(a2.coordinate[0], this.config.coordinatePrecision), X(a2.coordinate[1], this.config.coordinatePrecision)], i2.featureCoordinateIndex = a2.lineIndex, i2.minDistance = s2);
    }), i2;
  }
}, mi = { cancel: `Escape`, finish: `Enter` }, hi = { start: `crosshair`, close: `pointer`, dragStart: `grabbing`, dragEnd: `crosshair` }, gi = class extends Nr {
  constructor(e2) {
    super(e2, true), this.mode = `linestring`, this.currentCoordinate = 0, this.currentId = void 0, this.closingPointId = void 0, this.keyEvents = mi, this.snapping = void 0, this.cursors = hi, this.mouseMove = false, this.insertCoordinates = void 0, this.lastCommittedCoordinates = void 0, this.snappedPointId = void 0, this.lastMouseMoveEvent = void 0, this.editable = false, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedSnapType = void 0, this.editedInsertIndex = void 0, this.editedPointId = void 0, this.coordinateSnapping = void 0, this.insertPoint = void 0, this.lineSnapping = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.updateOptions(e2);
  }
  updateOptions(e2) {
    super.updateOptions(e2), e2 != null && e2.cursors && (this.cursors = G({}, this.cursors, e2.cursors)), e2 != null && e2.snapping && (this.snapping = e2.snapping), (e2 == null ? void 0 : e2.keyEvents) === null ? this.keyEvents = { cancel: null, finish: null } : e2 != null && e2.keyEvents && (this.keyEvents = G({}, this.keyEvents, e2.keyEvents)), e2 != null && e2.insertCoordinates && (this.insertCoordinates = e2.insertCoordinates), e2 && e2.editable && (this.editable = e2.editable);
  }
  updateSnappedCoordinate(e2) {
    let t2 = this.snapCoordinate(e2);
    if (t2) {
      if (this.snappedPointId) this.store.updateGeometry([{ id: this.snappedPointId, geometry: { type: `Point`, coordinates: t2 } }]);
      else {
        let [e3] = this.store.create([{ geometry: { type: `Point`, coordinates: t2 }, properties: { mode: this.mode, [J.SNAPPING_POINT]: true } }]);
        this.snappedPointId = e3;
      }
      e2.lng = t2[0], e2.lat = t2[1];
    } else this.snappedPointId && (this.snappedPointId = (this.store.delete([this.snappedPointId]), void 0));
    return t2;
  }
  close() {
    if (this.currentId === void 0) return;
    let e2 = this.store.getGeometryCopy(this.currentId);
    e2.coordinates.pop(), this.updateGeometries([...e2.coordinates], void 0, K.Commit), this.store.updateProperty([{ id: this.currentId, property: J.CURRENTLY_DRAWING, value: void 0 }]);
    let t2 = this.currentId;
    this.closingPointId && this.store.delete([this.closingPointId]), this.snappedPointId && this.store.delete([this.snappedPointId]), this.currentCoordinate = 0, this.currentId = void 0, this.closingPointId = void 0, this.snappedPointId = void 0, this.lastCommittedCoordinates = void 0, this.state === `drawing` && this.setStarted(), this.onFinish(t2, { mode: this.mode, action: `draw` });
  }
  updateGeometries(e2, t2, n2) {
    if (!this.currentId) return;
    let r2 = { type: `LineString`, coordinates: e2 };
    if (this.validate && !this.validate({ type: `Feature`, geometry: r2 }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: n2 }).valid) return;
    let i2 = [{ id: this.currentId, geometry: r2 }];
    this.closingPointId && t2 && i2.push({ id: this.closingPointId, geometry: { type: `Point`, coordinates: t2 } }), n2 === `commit` && (this.lastCommittedCoordinates = r2.coordinates), this.store.updateGeometry(i2);
  }
  generateInsertCoordinates(e2, t2) {
    if (!this.insertCoordinates || !this.lastCommittedCoordinates) throw Error(`Not able to insert coordinates`);
    if (this.insertCoordinates.strategy !== `amount`) throw Error(`Strategy does not exist`);
    let n2 = Fr(e2, t2) / (this.insertCoordinates.value + 1), r2 = [];
    return this.projection === `globe` ? r2 = this.insertPoint.generateInsertionGeodesicCoordinates(e2, t2, n2) : this.projection === `web-mercator` && (r2 = this.insertPoint.generateInsertionCoordinates(e2, t2, n2)), r2;
  }
  createLine(e2) {
    let [t2] = this.store.create([{ geometry: { type: `LineString`, coordinates: [e2, e2] }, properties: { mode: this.mode, [J.CURRENTLY_DRAWING]: true } }]);
    this.lastCommittedCoordinates = [e2, e2], this.currentId = t2, this.currentCoordinate++, this.setDrawing();
  }
  firstUpdateToLine(e2) {
    if (!this.currentId) return;
    let t2 = this.store.getGeometryCopy(this.currentId).coordinates, [n2] = this.store.create([{ geometry: { type: `Point`, coordinates: [...e2] }, properties: { mode: this.mode, [J.CLOSING_POINT]: true } }]);
    this.closingPointId = n2, this.setCursor(this.cursors.close);
    let r2 = [...t2, e2];
    this.updateGeometries(r2, void 0, K.Commit), this.currentCoordinate++;
  }
  updateToLine(e2, t2) {
    if (!this.currentId) return;
    let n2 = this.store.getGeometryCopy(this.currentId).coordinates, [r2, i2] = this.lastCommittedCoordinates ? this.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1] : n2[n2.length - 2], { x: a2, y: o2 } = this.project(r2, i2);
    if (Q({ x: a2, y: o2 }, { x: t2.x, y: t2.y }) < this.pointerDistance) return void this.close();
    this.setCursor(this.cursors.close);
    let s2 = [...n2, e2];
    this.updateGeometries(s2, n2[n2.length - 1], K.Commit), this.currentCoordinate++;
  }
  registerBehaviors(e2) {
    this.coordinateSnapping = new Zr(e2, new Xr(e2), new Yr(e2)), this.insertPoint = new ii(e2), this.clickBoundingBox = new Yr(e2), this.pixelDistance = new Xr(e2), this.lineSnapping = new pi(e2, this.pixelDistance, this.clickBoundingBox), this.coordinateSnapping = new Zr(e2, this.pixelDistance, this.clickBoundingBox);
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.start);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor(`unset`);
  }
  onMouseMove(e2) {
    this.mouseMove = true, this.setCursor(this.cursors.start), this.lastMouseMoveEvent = e2;
    let t2 = this.updateSnappedCoordinate(e2) || [e2.lng, e2.lat];
    if (this.currentId === void 0 || this.currentCoordinate === 0) return;
    let n2 = this.store.getGeometryCopy(this.currentId).coordinates;
    if (n2.pop(), this.closingPointId) {
      let [t3, r3] = n2[n2.length - 1], { x: i2, y: a2 } = this.project(t3, r3);
      Q({ x: i2, y: a2 }, { x: e2.containerX, y: e2.containerY }) < this.pointerDistance && this.setCursor(this.cursors.close);
    }
    let r2 = [...n2, t2];
    if (this.insertCoordinates && this.currentId && this.lastCommittedCoordinates) {
      let e3 = this.lastCommittedCoordinates[this.lastCommittedCoordinates.length - 1], n3 = t2;
      if (!ai(e3, n3)) {
        let i2 = this.generateInsertCoordinates(e3, n3);
        r2 = [...this.lastCommittedCoordinates.slice(0, -1), ...i2, t2];
      }
    }
    this.updateGeometries(r2, void 0, K.Provisional);
  }
  onRightClick(e2) {
    if (!this.editable || this.state !== `started`) return;
    let { featureId: t2, featureCoordinateIndex: n2 } = this.coordinateSnapping.getSnappable(e2, (e3) => this.lineStringFilter(e3));
    if (!t2 || n2 === void 0) return;
    let r2 = this.store.getGeometryCopy(t2), i2;
    if (r2.type === `LineString` && (i2 = r2.coordinates, !(i2.length <= 2))) {
      if (i2.splice(n2, 1), this.validate && !this.validate({ id: t2, type: `Feature`, geometry: r2, properties: {} }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: K.Commit }).valid) return;
      this.snappedPointId && (this.snappedPointId = (this.store.delete([this.snappedPointId]), void 0)), this.store.updateGeometry([{ id: t2, geometry: r2 }]), this.onFinish(t2, { mode: this.mode, action: `edit` });
    }
  }
  onLeftClick(e2) {
    this.snappedPointId && (this.snappedPointId = (this.store.delete([this.snappedPointId]), void 0));
    let t2 = this.snapCoordinate(e2) || [e2.lng, e2.lat];
    this.currentCoordinate === 0 ? this.createLine(t2) : this.currentCoordinate === 1 && this.currentId ? this.firstUpdateToLine(t2) : this.currentId && this.updateToLine(t2, { x: e2.containerX, y: e2.containerY });
  }
  onClick(e2) {
    (e2.button === `right` && this.allowPointerEvent(this.pointerEvents.rightClick, e2) || e2.button === `left` && this.allowPointerEvent(this.pointerEvents.leftClick, e2) || e2.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, e2)) && (this.currentCoordinate > 0 && !this.mouseMove && this.onMouseMove(e2), this.mouseMove = false, e2.button === `right` ? this.onRightClick(e2) : e2.button === `left` && this.onLeftClick(e2));
  }
  onKeyDown() {
  }
  onKeyUp(e2) {
    e2.key === this.keyEvents.cancel && this.cleanUp(), e2.key === this.keyEvents.finish && this.close();
  }
  onDragStart(e2, t2) {
    if (!this.allowPointerEvent(this.pointerEvents.onDragStart, e2) || !this.editable) return;
    let n2;
    if (this.state === `started`) {
      let t3 = this.lineSnapping.getSnappable(e2, (e3) => this.lineStringFilter(e3));
      t3.coordinate && (this.editedSnapType = `line`, this.editedFeatureCoordinateIndex = t3.featureCoordinateIndex, this.editedFeatureId = t3.featureId, n2 = t3.coordinate);
      let r2 = this.coordinateSnapping.getSnappable(e2, (e3) => this.lineStringFilter(e3));
      r2.coordinate && (this.editedSnapType = `coordinate`, this.editedFeatureCoordinateIndex = r2.featureCoordinateIndex, this.editedFeatureId = r2.featureId, n2 = r2.coordinate);
    }
    if (this.editedFeatureId && n2) {
      if (!this.editedPointId) {
        let [e3] = this.store.create([{ geometry: { type: `Point`, coordinates: n2 }, properties: { mode: this.mode, [J.EDITED]: true } }]);
        this.editedPointId = e3;
      }
      this.setCursor(this.cursors.dragStart), t2(false);
    }
  }
  onDrag(e2, t2) {
    if (!this.allowPointerEvent(this.pointerEvents.onDrag, e2) || this.editedFeatureId === void 0 || this.editedFeatureCoordinateIndex === void 0) return;
    let n2 = this.store.getGeometryCopy(this.editedFeatureId);
    this.editedSnapType === `coordinate` || this.editedSnapType === `line` && this.editedInsertIndex !== void 0 ? n2.coordinates[this.editedFeatureCoordinateIndex] = [e2.lng, e2.lat] : this.editedSnapType === `line` && this.editedInsertIndex === void 0 && (this.editedInsertIndex = this.editedFeatureCoordinateIndex + 1, n2.coordinates.splice(this.editedInsertIndex, 0, [e2.lng, e2.lat]), this.editedFeatureCoordinateIndex++);
    let r2 = { type: `LineString`, coordinates: n2.coordinates };
    this.validate && !this.validate({ type: `Feature`, geometry: r2, properties: this.store.getPropertiesCopy(this.editedFeatureId) }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: K.Provisional }).valid || (this.snapping && this.snappedPointId && (this.store.delete([this.snappedPointId]), this.snappedPointId = void 0), this.store.updateGeometry([{ id: this.editedFeatureId, geometry: r2 }]), this.editedPointId && this.store.updateGeometry([{ id: this.editedPointId, geometry: { type: `Point`, coordinates: [e2.lng, e2.lat] } }]), this.store.updateProperty([{ id: this.editedFeatureId, property: J.EDITED, value: true }]));
  }
  onDragEnd(e2, t2) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, e2) && this.editedFeatureId !== void 0 && (this.setCursor(this.cursors.dragEnd), this.editedPointId && (this.editedPointId = (this.store.delete([this.editedPointId]), void 0)), this.store.updateProperty([{ id: this.editedFeatureId, property: J.EDITED, value: false }]), this.onFinish(this.editedFeatureId, { mode: this.mode, action: `edit` }), this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedInsertIndex = void 0, this.editedSnapType = void 0, t2(true));
  }
  cleanUp() {
    let e2 = this.currentId, t2 = this.closingPointId, n2 = this.snappedPointId;
    this.closingPointId = void 0, this.snappedPointId = void 0, this.currentId = void 0, this.currentCoordinate = 0, this.state === `drawing` && this.setStarted();
    try {
      e2 !== void 0 && this.store.delete([e2]), n2 !== void 0 && this.store.delete([n2]), t2 !== void 0 && this.store.delete([t2]);
    } catch {
    }
  }
  styleFeature(e2) {
    let t2 = G({}, { polygonFillColor: `#3f97e0`, polygonOutlineColor: `#3f97e0`, polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: `#3f97e0`, pointOutlineColor: `#ffffff`, pointOutlineWidth: 0, pointWidth: 6, lineStringColor: `#3f97e0`, lineStringWidth: 4, zIndex: 0, markerUrl: void 0, markerHeight: void 0, markerWidth: void 0 });
    if (e2.type === `Feature` && e2.geometry.type === `LineString` && e2.properties.mode === this.mode) return t2.lineStringColor = this.getHexColorStylingValue(this.styles.lineStringColor, t2.lineStringColor, e2), t2.lineStringWidth = this.getNumericStylingValue(this.styles.lineStringWidth, t2.lineStringWidth, e2), t2.zIndex = Er, t2;
    if (e2.type === `Feature` && e2.geometry.type === `Point` && e2.properties.mode === this.mode) {
      let n2 = e2.properties[J.CLOSING_POINT];
      return t2.pointColor = this.getHexColorStylingValue(n2 ? this.styles.closingPointColor : this.styles.snappingPointColor, t2.pointColor, e2), t2.pointWidth = this.getNumericStylingValue(n2 ? this.styles.closingPointWidth : this.styles.snappingPointWidth, t2.pointWidth, e2), t2.pointOutlineColor = this.getHexColorStylingValue(n2 ? this.styles.closingPointOutlineColor : this.styles.snappingPointOutlineColor, `#ffffff`, e2), t2.pointOutlineWidth = this.getNumericStylingValue(n2 ? this.styles.closingPointOutlineWidth : this.styles.snappingPointOutlineWidth, 2, e2), t2.zIndex = 50, t2;
    }
    return t2;
  }
  validateFeature(e2) {
    return this.validateModeFeature(e2, (e3) => oi(e3, this.coordinatePrecision));
  }
  lineStringFilter(e2) {
    return !!(e2.geometry.type === `LineString` && e2.properties && e2.properties.mode === this.mode);
  }
  snapCoordinate(e2) {
    var t2, n2, r2;
    let i2;
    if ((t2 = this.snapping) != null && t2.toLine) {
      let t3;
      t3 = this.currentId ? this.lineSnapping.getSnappableCoordinate(e2, this.currentId) : this.lineSnapping.getSnappableCoordinateFirstClick(e2), t3 && (i2 = t3);
    }
    return (n2 = this.snapping) != null && n2.toCoordinate && (i2 = this.currentId ? this.coordinateSnapping.getSnappableCoordinate(e2, this.currentId) : this.coordinateSnapping.getSnappableCoordinateFirstClick(e2)), (r2 = this.snapping) != null && r2.toCustom && (i2 = this.snapping.toCustom(e2, { currentCoordinate: this.currentCoordinate, currentId: this.currentId, getCurrentGeometrySnapshot: this.currentId ? () => this.store.getGeometryCopy(this.currentId) : () => null, project: this.project, unproject: this.unproject })), i2;
  }
  afterFeatureUpdated(e2) {
    this.editedFeatureId === e2.id && this.editedPointId && (this.store.delete([this.editedPointId]), this.editedPointId = void 0, this.editedFeatureId = void 0, this.editedFeatureCoordinateIndex = void 0, this.editedSnapType = void 0), this.snappedPointId && this.lastMouseMoveEvent && this.updateSnappedCoordinate(this.lastMouseMoveEvent), this.currentId === e2.id && (this.closingPointId && (this.closingPointId = (this.store.delete([this.closingPointId]), void 0)), this.currentCoordinate = 0, this.currentId = void 0, this.state === `drawing` && this.setStarted());
  }
}, _i = `Feature is not a Point`, vi = `Feature has invalid coordinates`, yi = `Feature has coordinates with excessive precision`;
function bi(e2, t2) {
  return e2.geometry.type === `Point` ? Kr(e2.geometry.coordinates) ? Gr(e2.geometry.coordinates, t2) ? { valid: true } : { valid: false, reason: yi } : { valid: false, reason: vi } : { valid: false, reason: _i };
}
var xi = { create: `crosshair`, dragStart: `grabbing`, dragEnd: `crosshair` }, Si = class extends Nr {
  constructor(e2) {
    super(e2, true), this.mode = `point`, this.cursors = xi, this.editable = false, this.editedFeatureId = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.updateOptions(e2);
  }
  updateOptions(e2) {
    super.updateOptions(e2), e2 != null && e2.cursors && (this.cursors = G({}, this.cursors, e2.cursors)), e2 != null && e2.editable && (this.editable = e2.editable);
  }
  start() {
    this.setStarted(), this.setCursor(this.cursors.create);
  }
  stop() {
    this.cleanUp(), this.setStopped(), this.setCursor(`unset`);
  }
  onClick(e2) {
    e2.button === `right` && this.allowPointerEvent(this.pointerEvents.rightClick, e2) || e2.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, e2) ? this.onRightClick(e2) : e2.button === `left` && this.allowPointerEvent(this.pointerEvents.leftClick, e2) && this.onLeftClick(e2);
  }
  onMouseMove() {
  }
  onKeyDown() {
  }
  onKeyUp() {
  }
  cleanUp() {
    this.editedFeatureId = void 0;
  }
  onDragStart(e2, t2) {
    var _a2;
    this.allowPointerEvent(this.pointerEvents.onDragStart, e2) && (this.editable && (this.editedFeatureId = (_a2 = this.getNearestPointFeature(e2)) == null ? void 0 : _a2.id), this.editedFeatureId && (this.setCursor(this.cursors.dragStart), t2(false)));
  }
  onDrag(e2, t2) {
    this.allowPointerEvent(this.pointerEvents.onDrag, e2) && this.editedFeatureId !== void 0 && (this.validate && !this.validate({ type: `Feature`, geometry: { type: `Point`, coordinates: [e2.lng, e2.lat] }, properties: this.store.getPropertiesCopy(this.editedFeatureId) }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: K.Finish }).valid || (this.store.updateGeometry([{ id: this.editedFeatureId, geometry: { type: `Point`, coordinates: [e2.lng, e2.lat] } }]), this.store.updateProperty([{ id: this.editedFeatureId, property: J.EDITED, value: true }])));
  }
  onDragEnd(e2, t2) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, e2) && this.editedFeatureId !== void 0 && (this.onFinish(this.editedFeatureId, { mode: this.mode, action: `edit` }), this.setCursor(this.cursors.dragEnd), this.store.updateProperty([{ id: this.editedFeatureId, property: J.EDITED, value: false }]), this.editedFeatureId = void 0, t2(true));
  }
  registerBehaviors(e2) {
    this.pixelDistance = new Xr(e2), this.clickBoundingBox = new Yr(e2);
  }
  styleFeature(e2) {
    let t2 = G({}, { polygonFillColor: `#3f97e0`, polygonOutlineColor: `#3f97e0`, polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: `#3f97e0`, pointOutlineColor: `#ffffff`, pointOutlineWidth: 0, pointWidth: 6, lineStringColor: `#3f97e0`, lineStringWidth: 4, zIndex: 0, markerUrl: void 0, markerHeight: void 0, markerWidth: void 0 });
    if (e2.type === `Feature` && e2.geometry.type === `Point` && e2.properties.mode === this.mode) {
      let n2 = !!(e2.id && this.editedFeatureId === e2.id);
      t2.pointWidth = this.getNumericStylingValue(n2 ? this.styles.editedPointWidth : this.styles.pointWidth, t2.pointWidth, e2), t2.pointColor = this.getHexColorStylingValue(n2 ? this.styles.editedPointColor : this.styles.pointColor, t2.pointColor, e2), t2.pointOutlineColor = this.getHexColorStylingValue(n2 ? this.styles.editedPointOutlineColor : this.styles.pointOutlineColor, t2.pointOutlineColor, e2), t2.pointOutlineWidth = this.getNumericStylingValue(n2 ? this.styles.editedPointOutlineWidth : this.styles.pointOutlineWidth, 2, e2), t2.zIndex = 30;
    }
    return t2;
  }
  validateFeature(e2) {
    return this.validateModeFeature(e2, (e3) => bi(e3, this.coordinatePrecision));
  }
  onLeftClick(e2) {
    let t2 = { type: `Point`, coordinates: [e2.lng, e2.lat] }, n2 = { mode: this.mode };
    if (this.validate && !this.validate({ type: `Feature`, geometry: t2, properties: n2 }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: K.Finish }).valid) return;
    let [r2] = this.store.create([{ geometry: t2, properties: n2 }]);
    this.onFinish(r2, { mode: this.mode, action: `draw` });
  }
  onRightClick(e2) {
    if (!this.editable) return;
    let t2 = this.getNearestPointFeature(e2);
    t2 && this.store.delete([t2.id]);
  }
  getNearestPointFeature(e2) {
    let t2 = this.clickBoundingBox.create(e2), n2 = this.store.search(t2), r2, i2 = 1 / 0;
    for (let t3 = 0; t3 < n2.length; t3++) {
      let a2 = n2[t3];
      if (a2.geometry.type !== `Point` || a2.properties.mode !== this.mode) continue;
      let o2 = this.pixelDistance.measure(e2, a2.geometry.coordinates);
      o2 > i2 || o2 > this.pointerDistance || (i2 = o2, r2 = a2);
    }
    return r2;
  }
  afterFeatureUpdated(e2) {
    this.editedFeatureId === e2.id && (this.editedFeatureId = void 0, this.setCursor(this.cursors.create));
  }
}, Ci = class extends $ {
  constructor(e2) {
    super(e2);
  }
  createOrUpdate(e2) {
    let t2 = this.store.getGeometryCopy(e2), n2 = this.store.getPropertiesCopy(e2), r2;
    if (t2.type === `Polygon`) r2 = t2.coordinates[0].slice(0, -1);
    else {
      if (t2.type !== `LineString`) return;
      r2 = t2.coordinates;
    }
    let i2 = this.store.getPropertiesCopy(e2), a2 = i2.coordinatePointIds;
    if (a2) if (a2 && a2.every((e3) => this.store.has(e3))) {
      let t3 = i2.coordinatePointIds, a3 = t3.map((e3) => this.store.getGeometryCopy(e3).coordinates);
      if (t3.length !== r2.length) {
        this.deleteCoordinatePoints(t3);
        let i3 = this.createPoints(r2, n2.mode, e2);
        this.setFeatureCoordinatePoints(e2, i3);
      } else r2.forEach((e3, n3) => {
        e3[0] === a3[n3][0] && e3[1] === a3[n3][1] || this.store.updateGeometry([{ id: t3[n3], geometry: { type: `Point`, coordinates: e3 } }]);
      });
    } else {
      let t3 = a2.filter((e3) => this.store.has(e3));
      t3.length && this.deleteCoordinatePoints(t3);
      let i3 = this.createPoints(r2, n2.mode, e2);
      this.setFeatureCoordinatePoints(e2, i3);
    }
    else {
      let t3 = this.createPoints(r2, n2.mode, e2);
      this.setFeatureCoordinatePoints(e2, t3);
    }
  }
  deletePointsByFeatureIds(e2) {
    for (let t2 of e2) this.deleteIfPresent(t2);
  }
  getUpdated(e2, t2) {
    let n2 = this.store.getPropertiesCopy(e2);
    if (n2.coordinatePointIds) return n2.coordinatePointIds.map((e3, n3) => ({ id: e3, geometry: G({}, this.store.getGeometryCopy(e3), { coordinates: t2[n3] }) }));
  }
  createPoints(e2, t2, n2) {
    return this.store.create(e2.map((e3, r2) => ({ geometry: { type: `Point`, coordinates: e3 }, properties: { mode: t2, [J.COORDINATE_POINT]: true, [J.COORDINATE_POINT_FEATURE_ID]: n2, index: r2 } })));
  }
  setFeatureCoordinatePoints(e2, t2) {
    this.store.updateProperty([{ id: e2, property: J.COORDINATE_POINT_IDS, value: t2 }]);
  }
  deleteCoordinatePoints(e2) {
    let t2 = e2.filter((e3) => this.store.has(e3));
    this.store.delete(t2);
  }
  deleteIfPresent(e2) {
    let t2 = this.store.getPropertiesCopy(e2).coordinatePointIds;
    t2 && (this.deleteCoordinatePoints(t2), this.setFeatureCoordinatePoints(e2, null));
  }
};
function wi(e2, t2) {
  let n2 = e2, r2 = t2, i2 = Y(n2[1]), a2 = Y(r2[1]), o2 = Y(r2[0] - n2[0]);
  o2 > Math.PI && (o2 -= 2 * Math.PI), o2 < -Math.PI && (o2 += 2 * Math.PI);
  let s2 = Math.log(Math.tan(a2 / 2 + Math.PI / 4) / Math.tan(i2 / 2 + Math.PI / 4)), c2 = (Rr(Math.atan2(o2, s2)) + 360) % 360;
  return c2 > 180 ? -(360 - c2) : c2;
}
function Ti(e2, t2, n2) {
  let r2 = t2;
  t2 < 0 && (r2 = -Math.abs(r2));
  let i2 = r2 / Ir, a2 = e2[0] * Math.PI / 180, o2 = Y(e2[1]), s2 = Y(n2), c2 = i2 * Math.cos(s2), l2 = o2 + c2;
  Math.abs(l2) > Math.PI / 2 && (l2 = l2 > 0 ? Math.PI - l2 : -Math.PI - l2);
  let u2 = Math.log(Math.tan(l2 / 2 + Math.PI / 4) / Math.tan(o2 / 2 + Math.PI / 4)), d2 = Math.abs(u2) > 1e-11 ? c2 / u2 : Math.cos(o2), f2 = [(180 * (a2 + i2 * Math.sin(s2) / d2) / Math.PI + 540) % 360 - 180, 180 * l2 / Math.PI];
  return f2[0] += f2[0] - e2[0] > 180 ? -360 : e2[0] - f2[0] > 180 ? 360 : 0, f2;
}
function Ei(e2, t2, n2, r2, i2) {
  let a2 = r2(e2[0], e2[1]), o2 = r2(t2[0], t2[1]), { lng: s2, lat: c2 } = i2((a2.x + o2.x) / 2, (a2.y + o2.y) / 2);
  return [X(s2, n2), X(c2, n2)];
}
function Di(e2, t2, n2) {
  let r2 = Ti(e2, 1e3 * Fr(e2, t2) / 2, wi(e2, t2));
  return [X(r2[0], n2), X(r2[1], n2)];
}
function Oi({ featureCoords: e2, precision: t2, unproject: n2, project: r2, projection: i2 }) {
  let a2 = [];
  for (let o2 = 0; o2 < e2.length - 1; o2++) {
    let s2;
    if (i2 === `web-mercator`) s2 = Ei(e2[o2], e2[o2 + 1], t2, r2, n2);
    else {
      if (i2 !== `globe`) throw Error(`Invalid projection`);
      s2 = Di(e2[o2], e2[o2 + 1], t2);
    }
    a2.push(s2);
  }
  return a2;
}
var ki = class extends $ {
  constructor(e2, t2, n2) {
    super(e2), this.config = void 0, this.selectionPointBehavior = void 0, this.coordinatePointBehavior = void 0, this._midPoints = [], this.config = e2, this.selectionPointBehavior = t2, this.coordinatePointBehavior = n2;
  }
  get ids() {
    return this._midPoints.concat();
  }
  set ids(e2) {
  }
  insert(e2, t2, n2) {
    let r2 = this.store.getGeometryCopy(t2), { midPointFeatureId: i2, midPointSegment: a2 } = this.store.getPropertiesCopy(t2), o2 = this.store.getGeometryCopy(i2), s2 = o2.type === `Polygon` ? o2.coordinates[0] : o2.coordinates;
    s2.splice(a2 + 1, 0, r2.coordinates), o2.coordinates = o2.type === `Polygon` ? [s2] : s2, this.store.updateGeometry([{ id: i2, geometry: o2 }]), this.store.getPropertiesCopy(e2)[J.COORDINATE_POINT_IDS] && this.coordinatePointBehavior.createOrUpdate(e2), this.store.delete([...this._midPoints, ...this.selectionPointBehavior.ids]), this.create(s2, i2, n2), this.selectionPointBehavior.create(s2, o2.type, i2);
  }
  create(e2, t2, n2) {
    if (!this.store.has(t2)) throw Error(`Store does not have feature with this id`);
    this._midPoints = this.store.create((function(e3, t3, n3, r2, i2, a2) {
      return Oi({ featureCoords: e3, precision: n3, project: r2, unproject: i2, projection: a2 }).map((e4, n4) => ({ geometry: { type: `Point`, coordinates: e4 }, properties: t3(n4) }));
    })(e2, (e3) => ({ mode: this.mode, [q.MID_POINT]: true, midPointSegment: e3, midPointFeatureId: t2 }), n2, this.config.project, this.config.unproject, this.projection));
  }
  delete() {
    this._midPoints.length && (this.store.delete(this._midPoints), this._midPoints = []);
  }
  getUpdated(e2) {
    if (this._midPoints.length !== 0) return Oi({ featureCoords: e2, precision: this.coordinatePrecision, project: this.config.project, unproject: this.config.unproject, projection: this.config.projection }).map((e3, t2) => ({ id: this._midPoints[t2], geometry: { type: `Point`, coordinates: e3 } }));
  }
}, Ai = class extends $ {
  constructor(e2) {
    super(e2), this._selectionPoints = [];
  }
  get ids() {
    return this._selectionPoints.concat();
  }
  set ids(e2) {
  }
  create(e2, t2, n2) {
    this._selectionPoints = this.store.create((function(e3, t3, n3) {
      let r2 = [], i2 = t3 === `Polygon` ? e3.length - 1 : e3.length;
      for (let t4 = 0; t4 < i2; t4++) r2.push({ geometry: { type: `Point`, coordinates: e3[t4] }, properties: n3(t4) });
      return r2;
    })(e2, t2, (e3) => ({ mode: this.mode, index: e3, [q.SELECTION_POINT]: true, [q.SELECTION_POINT_FEATURE_ID]: n2 })));
  }
  delete() {
    this.ids.length && (this.store.delete(this.ids), this._selectionPoints = []);
  }
  getUpdated(e2) {
    if (this._selectionPoints.length !== 0) return this._selectionPoints.map((t2, n2) => ({ id: t2, geometry: { type: `Point`, coordinates: e2[n2] } }));
  }
  getOneUpdated(e2, t2) {
    if (this._selectionPoints[e2] !== void 0) return { id: this._selectionPoints[e2], geometry: { type: `Point`, coordinates: t2 } };
  }
};
function ji(e2, t2) {
  let n2 = false;
  for (let o2 = 0, s2 = t2.length; o2 < s2; o2++) {
    let s3 = t2[o2];
    for (let t3 = 0, o3 = s3.length, c2 = o3 - 1; t3 < o3; c2 = t3++) (i2 = s3[t3])[1] > (r2 = e2)[1] != (a2 = s3[c2])[1] > r2[1] && r2[0] < (a2[0] - i2[0]) * (r2[1] - i2[1]) / (a2[1] - i2[1]) + i2[0] && (n2 = !n2);
  }
  var r2, i2, a2;
  return n2;
}
var Mi = (e2, t2, n2) => {
  let r2 = (e3) => e3 * e3, i2 = (e3, t3) => r2(e3.x - t3.x) + r2(e3.y - t3.y);
  return Math.sqrt(((e3, t3, n3) => {
    let r3 = i2(t3, n3);
    if (r3 === 0) return i2(e3, t3);
    let a2 = ((e3.x - t3.x) * (n3.x - t3.x) + (e3.y - t3.y) * (n3.y - t3.y)) / r3;
    return a2 = Math.max(0, Math.min(1, a2)), i2(e3, { x: t3.x + a2 * (n3.x - t3.x), y: t3.y + a2 * (n3.y - t3.y) });
  })(e2, t2, n2));
}, Ni = class extends $ {
  constructor(e2, t2, n2) {
    super(e2), this.config = void 0, this.createClickBoundingBox = void 0, this.pixelDistance = void 0, this.config = e2, this.createClickBoundingBox = t2, this.pixelDistance = n2;
  }
  find(e2, t2) {
    let n2, r2, i2, a2, o2 = 1 / 0, s2 = 1 / 0, c2 = 1 / 0, l2 = this.createClickBoundingBox.create(e2), u2 = this.store.search(l2);
    for (let l3 = 0; l3 < u2.length; l3++) {
      let d2 = u2[l3], f2 = d2.geometry;
      if (f2.type === `Point`) {
        if (d2.properties.selectionPoint || d2.properties.coordinatePoint || !t2 && d2.properties[q.MID_POINT]) continue;
        let r3 = this.pixelDistance.measure(e2, f2.coordinates);
        d2.properties[q.MID_POINT] && r3 < this.pointerDistance && r3 < c2 ? (c2 = r3, i2 = d2) : !d2.properties[q.MID_POINT] && r3 < this.pointerDistance && r3 < o2 && (o2 = r3, n2 = d2);
      } else if (f2.type === `LineString`) {
        if (n2) continue;
        for (let t3 = 0; t3 < f2.coordinates.length - 1; t3++) {
          let n3 = f2.coordinates[t3], i3 = f2.coordinates[t3 + 1], a3 = Mi({ x: e2.containerX, y: e2.containerY }, this.project(n3[0], n3[1]), this.project(i3[0], i3[1]));
          a3 < this.pointerDistance && a3 < s2 && (s2 = a3, r2 = d2);
        }
      } else if (f2.type === `Polygon`) {
        if (n2 || r2) continue;
        ji([e2.lng, e2.lat], f2.coordinates) && (a2 = d2);
      }
    }
    return { clickedFeature: n2 || r2 || a2, clickedMidPoint: i2 };
  }
}, Pi = class extends $ {
  constructor(e2, t2, n2, r2, i2) {
    super(e2), this.config = void 0, this.featuresAtCursorEvent = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.draggedFeatureId = null, this.dragPosition = void 0, this.config = e2, this.featuresAtCursorEvent = t2, this.selectionPoints = n2, this.midPoints = r2, this.coordinatePoints = i2;
  }
  startDragging(e2, t2) {
    this.draggedFeatureId = t2, this.dragPosition = [e2.lng, e2.lat];
  }
  stopDragging() {
    this.draggedFeatureId = null, this.dragPosition = void 0;
  }
  isDragging() {
    return this.draggedFeatureId !== null;
  }
  canDrag(e2, t2) {
    let { clickedFeature: n2 } = this.featuresAtCursorEvent.find(e2, true);
    return !(!n2 || n2.id !== t2);
  }
  drag(e2, t2) {
    if (!this.draggedFeatureId) return;
    let n2 = this.store.getGeometryCopy(this.draggedFeatureId), r2 = [e2.lng, e2.lat];
    if (n2.type === `Polygon` || n2.type === `LineString`) {
      let i2, a2;
      if (n2.type === `Polygon` ? (i2 = n2.coordinates[0], a2 = i2.length - 1) : (i2 = n2.coordinates, a2 = i2.length), !this.dragPosition) return false;
      for (let e3 = 0; e3 < a2; e3++) {
        let t3 = i2[e3], n3, a3;
        if (this.config.projection === `web-mercator`) {
          let e4 = Z(this.dragPosition[0], this.dragPosition[1]), i3 = Z(r2[0], r2[1]), o3 = Z(t3[0], t3[1]), s3 = { x: e4.x - i3.x, y: e4.y - i3.y }, { lng: c3, lat: l2 } = Hr(o3.x - s3.x, o3.y - s3.y);
          n3 = c3, a3 = l2;
        } else {
          let e4 = [this.dragPosition[0] - r2[0], this.dragPosition[1] - r2[1]];
          n3 = t3[0] - e4[0], a3 = t3[1] - e4[1];
        }
        if (n3 = X(n3, this.config.coordinatePrecision), a3 = X(a3, this.config.coordinatePrecision), n3 > 180 || n3 < -180 || a3 > 90 || a3 < -90) return false;
        i2[e3] = [n3, a3];
      }
      n2.type === `Polygon` && (i2[i2.length - 1] = [i2[0][0], i2[0][1]]);
      let o2 = this.selectionPoints.getUpdated(i2) || [], s2 = this.midPoints.getUpdated(i2) || [], c2 = this.coordinatePoints.getUpdated(this.draggedFeatureId, i2) || [];
      if (t2 && !t2({ type: `Feature`, id: this.draggedFeatureId, geometry: n2, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: K.Provisional }).valid) return false;
      this.store.updateGeometry([{ id: this.draggedFeatureId, geometry: n2 }, ...o2, ...s2, ...c2]), this.dragPosition = [e2.lng, e2.lat];
    } else n2.type === `Point` && (this.store.updateGeometry([{ id: this.draggedFeatureId, geometry: { type: `Point`, coordinates: r2 } }]), this.dragPosition = [e2.lng, e2.lat]);
  }
}, Fi = class extends $ {
  constructor(e2, t2, n2, r2, i2, a2, o2) {
    super(e2), this.config = void 0, this.pixelDistance = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.coordinateSnapping = void 0, this.lineSnapping = void 0, this.draggedCoordinate = { id: null, index: -1 }, this.config = e2, this.pixelDistance = t2, this.selectionPoints = n2, this.midPoints = r2, this.coordinatePoints = i2, this.coordinateSnapping = a2, this.lineSnapping = o2;
  }
  getClosestCoordinate(e2, t2) {
    let n2 = { dist: 1 / 0, index: -1, isFirstOrLastPolygonCoord: false }, r2;
    if (t2.type === `LineString`) r2 = t2.coordinates;
    else {
      if (t2.type !== `Polygon`) return n2;
      r2 = t2.coordinates[0];
    }
    for (let i2 = 0; i2 < r2.length; i2++) {
      let a2 = this.pixelDistance.measure(e2, r2[i2]);
      if (a2 < this.pointerDistance && a2 < n2.dist) {
        let e3 = t2.type === `Polygon` && (i2 === r2.length - 1 || i2 === 0);
        n2.dist = a2, n2.index = e3 ? 0 : i2, n2.isFirstOrLastPolygonCoord = e3;
      }
    }
    return n2;
  }
  getDraggableIndex(e2, t2) {
    let n2 = this.store.getGeometryCopy(t2), r2 = this.getClosestCoordinate(e2, n2);
    return r2.index === -1 ? -1 : r2.index;
  }
  snapCoordinate(e2, t2, n2) {
    let r2 = [e2.lng, e2.lat], i2 = (e3) => !!(e3.properties && e3.properties.mode === n2.properties.mode && e3.id !== this.draggedCoordinate.id);
    if (t2 != null && t2.toLine) {
      let t3;
      t3 = this.lineSnapping.getSnappable(e2, i2).coordinate, t3 && (r2 = t3);
    }
    if (t2.toCoordinate) {
      let t3;
      t3 = this.coordinateSnapping.getSnappable(e2, i2).coordinate, t3 && (r2 = t3);
    }
    if (t2 != null && t2.toCustom) {
      let i3;
      i3 = t2.toCustom(e2, { currentCoordinate: this.draggedCoordinate.index, currentId: n2.id, getCurrentGeometrySnapshot: n2.id ? () => this.store.getGeometryCopy(n2.id) : () => null, project: this.project, unproject: this.unproject }), i3 && (r2 = i3);
    }
    return r2;
  }
  drag(e2, t2, n2, r2) {
    let i2 = this.draggedCoordinate.id;
    if (i2 === null) return false;
    let a2 = this.draggedCoordinate.index, o2 = this.store.getGeometryCopy(i2), s2 = this.store.getPropertiesCopy(i2), c2 = o2.type === `LineString` ? o2.coordinates : o2.coordinates[0], l2 = o2.type === `Polygon` && (a2 === c2.length - 1 || a2 === 0), u2 = { type: `Feature`, id: i2, geometry: o2, properties: s2 }, d2 = this.snapCoordinate(e2, r2, u2);
    if (e2.lng > 180 || e2.lng < -180 || e2.lat > 90 || e2.lat < -90) return false;
    if (l2) {
      let e3 = c2.length - 1;
      c2[0] = d2, c2[e3] = d2;
    } else c2[a2] = d2;
    let f2 = this.selectionPoints.getOneUpdated(a2, d2), p2 = f2 ? [f2] : [], m2 = this.midPoints.getUpdated(c2) || [], h2 = this.coordinatePoints.getUpdated(i2, c2) || [];
    return !(o2.type !== `Point` && !t2 && Ur({ type: `Feature`, geometry: o2, properties: {} }) || n2 && !n2(u2, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: K.Provisional }).valid || (this.store.updateGeometry([{ id: i2, geometry: o2 }, ...p2, ...m2, ...h2]), 0));
  }
  isDragging() {
    return this.draggedCoordinate.id !== null;
  }
  startDragging(e2, t2) {
    this.draggedCoordinate = { id: e2, index: t2 };
  }
  stopDragging() {
    this.draggedCoordinate = { id: null, index: -1 };
  }
};
function Ii(e2) {
  let t2 = 0, n2 = 0, r2 = 0;
  return (e2.geometry.type === `Polygon` ? e2.geometry.coordinates[0].slice(0, -1) : e2.geometry.coordinates).forEach((e3) => {
    t2 += e3[0], n2 += e3[1], r2++;
  }, true), [t2 / r2, n2 / r2];
}
var Li = (e2, t2) => {
  if (t2 === 0 || t2 === 360 || t2 === -360) return e2;
  let n2 = 0.017453292519943295 * t2, r2 = (e2.geometry.type === `Polygon` ? e2.geometry.coordinates[0] : e2.geometry.coordinates).map(([e3, t3]) => Z(e3, t3)), i2 = r2.reduce((e3, t3) => ({ x: e3.x + t3.x, y: e3.y + t3.y }), { x: 0, y: 0 });
  i2.x /= r2.length, i2.y /= r2.length;
  let a2 = r2.map((e3) => ({ x: i2.x + (e3.x - i2.x) * Math.cos(n2) - (e3.y - i2.y) * Math.sin(n2), y: i2.y + (e3.x - i2.x) * Math.sin(n2) + (e3.y - i2.y) * Math.cos(n2) })).map(({ x: e3, y: t3 }) => [Hr(e3, t3).lng, Hr(e3, t3).lat]);
  return e2.geometry.type === `Polygon` ? e2.geometry.coordinates[0] = a2 : e2.geometry.coordinates = a2, e2;
};
function Ri(e2) {
  let t2 = (e2.geometry.type === `Polygon` ? e2.geometry.coordinates[0] : e2.geometry.coordinates).map((e3) => {
    let { x: t3, y: n2 } = Z(e3[0], e3[1]);
    return [t3, n2];
  });
  return e2.geometry.type === `Polygon` ? (function(e3) {
    let t3 = 0, n2 = 0, r2 = 0, i2 = e3.length;
    for (let a2 = 0; a2 < i2 - 1; a2++) {
      let [i3, o2] = e3[a2], [s2, c2] = e3[a2 + 1], l2 = i3 * c2 - s2 * o2;
      t3 += l2, n2 += (i3 + s2) * l2, r2 += (o2 + c2) * l2;
    }
    return t3 /= 2, n2 /= 6 * t3, r2 /= 6 * t3, { x: n2, y: r2 };
  })(t2) : (function(e3) {
    let t3 = e3.length, n2 = 0, r2 = 0;
    for (let i2 = 0; i2 < t3; i2++) {
      let [t4, a2] = e3[i2];
      n2 += t4, r2 += a2;
    }
    return { x: n2 / t3, y: r2 / t3 };
  })(t2);
}
var zi = class extends $ {
  constructor(e2, t2, n2, r2) {
    super(e2), this.config = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.lastBearing = void 0, this.selectedGeometry = void 0, this.selectedGeometryCentroid = void 0, this.selectedGeometryWebMercatorCentroid = void 0, this.config = e2, this.selectionPoints = t2, this.midPoints = n2, this.coordinatePoints = r2;
  }
  reset() {
    this.lastBearing = void 0, this.selectedGeometry = void 0, this.selectedGeometryWebMercatorCentroid = void 0, this.selectedGeometryCentroid = void 0;
  }
  rotate(e2, t2, n2) {
    this.selectedGeometry || (this.selectedGeometry = this.store.getGeometryCopy(t2));
    let r2 = this.selectedGeometry;
    if (r2.type !== `Polygon` && r2.type !== `LineString`) return;
    let i2 = [e2.lng, e2.lat], a2, o2 = { type: `Feature`, geometry: r2, properties: {} };
    if (this.config.projection === `web-mercator`) {
      this.selectedGeometryWebMercatorCentroid || (this.selectedGeometryWebMercatorCentroid = Ri(o2));
      let t3 = Z(e2.lng, e2.lat);
      if (a2 = ei(this.selectedGeometryWebMercatorCentroid, t3), a2 === 0) return;
      if (!this.lastBearing) return void (this.lastBearing = a2);
      Li(o2, -(this.lastBearing - a2));
    } else {
      if (this.config.projection !== `globe`) throw Error(`Unsupported projection`);
      if (this.selectedGeometryCentroid || (this.selectedGeometryCentroid = Ii({ type: `Feature`, geometry: r2, properties: {} })), a2 = wi(this.selectedGeometryCentroid, i2), !this.lastBearing) return void (this.lastBearing = a2 + 180);
      (function(e3, t3) {
        if (t3 === 0 || t3 === 360 || t3 === -360) return e3;
        let n3 = Ii(e3);
        (e3.geometry.type === `Polygon` ? e3.geometry.coordinates[0] : e3.geometry.coordinates).forEach((e4) => {
          let r3 = wi(n3, e4) + t3, i3 = Ti(n3, (function(e5, t4) {
            e5[0] += e5[0] - t4[0] > 180 ? -360 : t4[0] - e5[0] > 180 ? 360 : 0;
            let n4 = Ir, r4 = t4[1] * Math.PI / 180, i4 = e5[1] * Math.PI / 180, a3 = i4 - r4, o3 = Math.abs(e5[0] - t4[0]) * Math.PI / 180;
            o3 > Math.PI && (o3 -= 2 * Math.PI);
            let s3 = Math.log(Math.tan(i4 / 2 + Math.PI / 4) / Math.tan(r4 / 2 + Math.PI / 4)), c3 = Math.abs(s3) > 1e-11 ? a3 / s3 : Math.cos(r4);
            return Math.sqrt(a3 * a3 + c3 * c3 * o3 * o3) * n4;
          })(n3, e4), r3);
          e4[0] = i3[0], e4[1] = i3[1];
        });
      })(o2, -(this.lastBearing - (a2 + 180)));
    }
    let s2 = r2.type === `Polygon` ? r2.coordinates[0] : r2.coordinates;
    s2.forEach((e3) => {
      e3[0] = X(e3[0], this.coordinatePrecision), e3[1] = X(e3[1], this.coordinatePrecision);
    });
    let c2 = this.midPoints.getUpdated(s2) || [], l2 = this.selectionPoints.getUpdated(s2) || [], u2 = this.coordinatePoints.getUpdated(t2, s2) || [];
    if (n2 && !n2({ id: t2, type: `Feature`, geometry: r2, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: K.Provisional })) return false;
    this.store.updateGeometry([{ id: t2, geometry: r2 }, ...l2, ...c2, ...u2]), this.projection === `web-mercator` ? this.lastBearing = a2 : this.projection === `globe` && (this.lastBearing = a2 + 180);
  }
}, Bi = class extends $ {
  constructor(e2, t2) {
    super(e2), this.config = void 0, this.dragCoordinateResizeBehavior = void 0, this.config = e2, this.dragCoordinateResizeBehavior = t2;
  }
  scale(e2, t2, n2) {
    if (!this.dragCoordinateResizeBehavior.isDragging()) {
      let n3 = this.dragCoordinateResizeBehavior.getDraggableIndex(e2, t2);
      this.dragCoordinateResizeBehavior.startDragging(t2, n3);
    }
    this.dragCoordinateResizeBehavior.drag(e2, `center-fixed`, n2);
  }
  reset() {
    this.dragCoordinateResizeBehavior.stopDragging();
  }
};
function Vi({ coordinates: e2, originX: t2, originY: n2, xScale: r2, yScale: i2 }) {
  r2 === 1 && i2 === 1 || e2.forEach((e3) => {
    let { x: a2, y: o2 } = Z(e3[0], e3[1]), { lng: s2, lat: c2 } = Hr(t2 + (a2 - t2) * r2, n2 + (o2 - n2) * i2);
    e3[0] = s2, e3[1] = c2;
  });
}
var Hi = class extends $ {
  constructor(e2, t2, n2, r2, i2) {
    super(e2), this.config = void 0, this.pixelDistance = void 0, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinatePoints = void 0, this.minimumScale = 1e-4, this.draggedCoordinate = { id: null, index: -1 }, this.boundingBoxMaps = { opposite: { 0: 4, 1: 5, 2: 6, 3: 7, 4: 0, 5: 1, 6: 2, 7: 3 } }, this.config = e2, this.pixelDistance = t2, this.selectionPoints = n2, this.midPoints = r2, this.coordinatePoints = i2;
  }
  getClosestCoordinate(e2, t2) {
    let n2 = { dist: 1 / 0, index: -1, isFirstOrLastPolygonCoord: false }, r2;
    if (t2.type === `LineString`) r2 = t2.coordinates;
    else {
      if (t2.type !== `Polygon`) return n2;
      r2 = t2.coordinates[0];
    }
    for (let i2 = 0; i2 < r2.length; i2++) {
      let a2 = this.pixelDistance.measure(e2, r2[i2]);
      if (a2 < this.pointerDistance && a2 < n2.dist) {
        let e3 = t2.type === `Polygon` && (i2 === r2.length - 1 || i2 === 0);
        n2.dist = a2, n2.index = e3 ? 0 : i2, n2.isFirstOrLastPolygonCoord = e3;
      }
    }
    return n2;
  }
  isValidDragWebMercator(e2, t2, n2) {
    switch (e2) {
      case 0:
        if (t2 <= 0 || n2 >= 0) return false;
        break;
      case 1:
        if (n2 >= 0) return false;
        break;
      case 2:
        if (t2 >= 0 || n2 >= 0) return false;
        break;
      case 3:
        if (t2 >= 0) return false;
        break;
      case 4:
        if (t2 >= 0 || n2 <= 0) return false;
        break;
      case 5:
        if (n2 <= 0) return false;
        break;
      case 6:
        if (t2 <= 0 || n2 <= 0) return false;
        break;
      case 7:
        if (t2 <= 0) return false;
    }
    return true;
  }
  getSelectedFeatureDataWebMercator() {
    if (!this.draggedCoordinate.id || this.draggedCoordinate.index === -1) return null;
    let e2 = this.getFeature(this.draggedCoordinate.id);
    if (!e2) return null;
    let t2 = this.getNormalisedCoordinates(e2.geometry);
    return { boundingBox: this.getBBoxWebMercator(t2), feature: e2, updatedCoords: t2, selectedCoordinate: t2[this.draggedCoordinate.index] };
  }
  centerWebMercatorDrag(e2) {
    let t2 = this.getSelectedFeatureDataWebMercator();
    if (!t2) return null;
    let { feature: n2, boundingBox: r2, updatedCoords: i2, selectedCoordinate: a2 } = t2, o2 = Ri(n2);
    if (!o2) return null;
    let s2 = Z(a2[0], a2[1]), { closestBBoxIndex: c2 } = this.getIndexesWebMercator(r2, s2), l2 = Z(e2.lng, e2.lat);
    return this.scaleWebMercator({ closestBBoxIndex: c2, updatedCoords: i2, webMercatorCursor: l2, webMercatorSelected: s2, webMercatorOrigin: o2 }), i2;
  }
  centerFixedWebMercatorDrag(e2) {
    let t2 = this.getSelectedFeatureDataWebMercator();
    if (!t2) return null;
    let { feature: n2, boundingBox: r2, updatedCoords: i2, selectedCoordinate: a2 } = t2, o2 = Ri(n2);
    if (!o2) return null;
    let s2 = Z(a2[0], a2[1]), { closestBBoxIndex: c2 } = this.getIndexesWebMercator(r2, s2), l2 = Z(e2.lng, e2.lat);
    return this.scaleFixedWebMercator({ closestBBoxIndex: c2, updatedCoords: i2, webMercatorCursor: l2, webMercatorSelected: s2, webMercatorOrigin: o2 }), i2;
  }
  scaleFixedWebMercator({ closestBBoxIndex: e2, webMercatorOrigin: t2, webMercatorSelected: n2, webMercatorCursor: r2, updatedCoords: i2 }) {
    if (!this.isValidDragWebMercator(e2, t2.x - r2.x, t2.y - r2.y)) return null;
    let a2 = Q(t2, r2) / Q(t2, n2);
    return a2 < 0 && (a2 = this.minimumScale), Vi({ coordinates: i2, originX: t2.x, originY: t2.y, xScale: a2, yScale: a2 }), i2;
  }
  oppositeFixedWebMercatorDrag(e2) {
    let t2 = this.getSelectedFeatureDataWebMercator();
    if (!t2) return null;
    let { boundingBox: n2, updatedCoords: r2, selectedCoordinate: i2 } = t2, a2 = Z(i2[0], i2[1]), { oppositeBboxIndex: o2, closestBBoxIndex: s2 } = this.getIndexesWebMercator(n2, a2), c2 = { x: n2[o2][0], y: n2[o2][1] }, l2 = Z(e2.lng, e2.lat);
    return this.scaleFixedWebMercator({ closestBBoxIndex: s2, updatedCoords: r2, webMercatorCursor: l2, webMercatorSelected: a2, webMercatorOrigin: c2 }), r2;
  }
  oppositeWebMercatorDrag(e2) {
    let t2 = this.getSelectedFeatureDataWebMercator();
    if (!t2) return null;
    let { boundingBox: n2, updatedCoords: r2, selectedCoordinate: i2 } = t2, a2 = Z(i2[0], i2[1]), { oppositeBboxIndex: o2, closestBBoxIndex: s2 } = this.getIndexesWebMercator(n2, a2), c2 = { x: n2[o2][0], y: n2[o2][1] }, l2 = Z(e2.lng, e2.lat);
    return this.scaleWebMercator({ closestBBoxIndex: s2, updatedCoords: r2, webMercatorCursor: l2, webMercatorSelected: a2, webMercatorOrigin: c2 }), r2;
  }
  scaleWebMercator({ closestBBoxIndex: e2, webMercatorOrigin: t2, webMercatorSelected: n2, webMercatorCursor: r2, updatedCoords: i2 }) {
    let a2 = t2.x - r2.x, o2 = t2.y - r2.y;
    if (!this.isValidDragWebMercator(e2, a2, o2)) return null;
    let s2 = 1;
    a2 !== 0 && e2 !== 1 && e2 !== 5 && (s2 = 1 - (t2.x - n2.x - a2) / a2);
    let c2 = 1;
    return o2 !== 0 && e2 !== 3 && e2 !== 7 && (c2 = 1 - (t2.y - n2.y - o2) / o2), this.validateScale(s2, c2) ? (s2 < 0 && (s2 = this.minimumScale), c2 < 0 && (c2 = this.minimumScale), this.performWebMercatorScale(i2, t2.x, t2.y, s2, c2), i2) : null;
  }
  getFeature(e2) {
    if (this.draggedCoordinate.id === null) return null;
    let t2 = this.store.getGeometryCopy(e2);
    return t2.type !== `Polygon` && t2.type !== `LineString` ? null : { id: e2, type: `Feature`, geometry: t2, properties: {} };
  }
  getNormalisedCoordinates(e2) {
    return e2.type === `Polygon` ? e2.coordinates[0] : e2.coordinates;
  }
  validateScale(e2, t2) {
    return !isNaN(e2) && t2 < 2 ** 53 - 1 && !isNaN(t2) && t2 < 2 ** 53 - 1;
  }
  performWebMercatorScale(e2, t2, n2, r2, i2) {
    e2.forEach((e3) => {
      let { x: a2, y: o2 } = Z(e3[0], e3[1]), { lng: s2, lat: c2 } = Hr(t2 + (a2 - t2) * r2, n2 + (o2 - n2) * i2);
      e3[0] = s2, e3[1] = c2;
    });
  }
  getBBoxWebMercator(e2) {
    let t2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    (e2 = e2.map((e3) => {
      let { x: t3, y: n3 } = Z(e3[0], e3[1]);
      return [t3, n3];
    })).forEach(([e3, n3]) => {
      e3 < t2[0] && (t2[0] = e3), n3 < t2[1] && (t2[1] = n3), e3 > t2[2] && (t2[2] = e3), n3 > t2[3] && (t2[3] = n3);
    });
    let [n2, r2, i2, a2] = t2;
    return [[n2, a2], [(n2 + i2) / 2, a2], [i2, a2], [i2, a2 + (r2 - a2) / 2], [i2, r2], [(n2 + i2) / 2, r2], [n2, r2], [n2, a2 + (r2 - a2) / 2]];
  }
  getIndexesWebMercator(e2, t2) {
    let n2, r2 = 1 / 0;
    for (let i2 = 0; i2 < e2.length; i2++) {
      let a2 = Q({ x: t2.x, y: t2.y }, { x: e2[i2][0], y: e2[i2][1] });
      a2 < r2 && (n2 = i2, r2 = a2);
    }
    if (n2 === void 0) throw Error(`No closest coordinate found`);
    return { oppositeBboxIndex: this.boundingBoxMaps.opposite[n2], closestBBoxIndex: n2 };
  }
  isDragging() {
    return this.draggedCoordinate.id !== null;
  }
  startDragging(e2, t2) {
    this.draggedCoordinate = { id: e2, index: t2 };
  }
  stopDragging() {
    this.draggedCoordinate = { id: null, index: -1 };
  }
  getDraggableIndex(e2, t2) {
    let n2 = this.store.getGeometryCopy(t2), r2 = this.getClosestCoordinate(e2, n2);
    return r2.index === -1 ? -1 : r2.index;
  }
  drag(e2, t2, n2) {
    if (!this.draggedCoordinate.id) return false;
    let r2 = this.getFeature(this.draggedCoordinate.id);
    if (!r2) return false;
    let i2 = null;
    if (t2 === `center` ? i2 = this.centerWebMercatorDrag(e2) : t2 === `opposite` ? i2 = this.oppositeWebMercatorDrag(e2) : t2 === `center-fixed` ? i2 = this.centerFixedWebMercatorDrag(e2) : t2 === `opposite-fixed` && (i2 = this.oppositeFixedWebMercatorDrag(e2)), !i2) return false;
    for (let e3 = 0; e3 < i2.length; e3++) {
      let t3 = i2[e3];
      if (t3[0] = X(t3[0], this.coordinatePrecision), t3[1] = X(t3[1], this.coordinatePrecision), !Gr(t3, this.coordinatePrecision)) return false;
    }
    let a2 = this.midPoints.getUpdated(i2) || [], o2 = this.selectionPoints.getUpdated(i2) || [], s2 = this.coordinatePoints.getUpdated(r2.id, i2) || [], c2 = { type: r2.geometry.type, coordinates: r2.geometry.type === `Polygon` ? [i2] : i2 };
    return !(n2 && !n2({ id: this.draggedCoordinate.id, type: `Feature`, geometry: c2, properties: {} }, { project: this.config.project, unproject: this.config.unproject, coordinatePrecision: this.config.coordinatePrecision, updateType: K.Provisional }).valid || (this.store.updateGeometry([{ id: this.draggedCoordinate.id, geometry: c2 }, ...o2, ...a2, ...s2]), 0));
  }
}, Ui = { deselect: `Escape`, delete: `Delete`, rotate: [`Control`, `r`], scale: [`Control`, `s`] }, Wi = { pointerOver: `move`, dragStart: `move`, dragEnd: `move`, insertMidpoint: `crosshair` }, Gi = class extends Pr {
  constructor(e2) {
    super(e2, true), this.mode = `select`, this.allowManualDeselection = true, this.dragEventThrottle = 5, this.dragEventCount = 0, this.selected = [], this.flags = {}, this.keyEvents = Ui, this.cursors = Wi, this.validations = {}, this.selectionPoints = void 0, this.midPoints = void 0, this.coordinateSnap = void 0, this.featuresAtMouseEvent = void 0, this.pixelDistance = void 0, this.clickBoundingBox = void 0, this.dragFeature = void 0, this.dragCoordinate = void 0, this.rotateFeature = void 0, this.scaleFeature = void 0, this.dragCoordinateResizeFeature = void 0, this.coordinatePoints = void 0, this.lineSnap = void 0, this.updateOptions(e2);
  }
  updateOptions(e2) {
    if (super.updateOptions(e2), this.cursors = e2 && e2.cursors ? G({}, this.cursors, e2.cursors) : Wi, (e2 == null ? void 0 : e2.keyEvents) === null ? this.keyEvents = { deselect: null, delete: null, rotate: null, scale: null } : e2 != null && e2.keyEvents && (this.keyEvents = G({}, this.keyEvents, e2.keyEvents)), (e2 == null ? void 0 : e2.dragEventThrottle) !== void 0 && (this.dragEventThrottle = e2.dragEventThrottle), (e2 == null ? void 0 : e2.allowManualDeselection) !== void 0 && (this.allowManualDeselection = e2.allowManualDeselection), e2 != null && e2.flags) for (let t2 in this.flags = G({}, this.flags, e2.flags), this.validations = {}, this.flags) {
      let e3 = this.flags[t2].feature;
      e3 && e3.validation && (this.validations[t2] = e3.validation);
    }
  }
  selectFeature(e2) {
    this.select(e2, false);
  }
  setSelecting() {
    if (this._state !== `started`) throw Error(`Mode must be started to move to selecting state`);
    this._state = `selecting`;
  }
  registerBehaviors(e2) {
    this.pixelDistance = new Xr(e2), this.clickBoundingBox = new Yr(e2), this.featuresAtMouseEvent = new Ni(e2, this.clickBoundingBox, this.pixelDistance), this.selectionPoints = new Ai(e2), this.coordinatePoints = new Ci(e2), this.midPoints = new ki(e2, this.selectionPoints, this.coordinatePoints), this.coordinateSnap = new Zr(e2, this.pixelDistance, this.clickBoundingBox), this.lineSnap = new pi(e2, this.pixelDistance, this.clickBoundingBox), this.rotateFeature = new zi(e2, this.selectionPoints, this.midPoints, this.coordinatePoints), this.dragFeature = new Pi(e2, this.featuresAtMouseEvent, this.selectionPoints, this.midPoints, this.coordinatePoints), this.dragCoordinate = new Fi(e2, this.pixelDistance, this.selectionPoints, this.midPoints, this.coordinatePoints, this.coordinateSnap, this.lineSnap), this.dragCoordinateResizeFeature = new Hi(e2, this.pixelDistance, this.selectionPoints, this.midPoints, this.coordinatePoints), this.scaleFeature = new Bi(e2, this.dragCoordinateResizeFeature);
  }
  deselectFeature() {
    this.deselect();
  }
  deselect() {
    let e2 = this.selected.filter((e3) => this.store.has(e3)).map((e3) => ({ id: e3, property: q.SELECTED, value: false }));
    this.store.updateProperty(e2), this.onDeselect(this.selected[0]), this.selected = [], this.selectionPoints.delete(), this.midPoints.delete();
  }
  deleteSelected() {
    this.store.delete(this.selected), this.selected = [];
  }
  onRightClick(e2) {
    if (!this.selectionPoints.ids.length) return;
    let t2, n2 = 1 / 0;
    if (this.selectionPoints.ids.forEach((r3) => {
      let i3 = this.store.getGeometryCopy(r3), a3 = this.pixelDistance.measure(e2, i3.coordinates);
      a3 < this.pointerDistance && a3 < n2 && (n2 = a3, t2 = this.store.getPropertiesCopy(r3));
    }), !t2) return;
    let r2 = t2.selectionPointFeatureId, i2 = t2.index, a2 = this.store.getPropertiesCopy(r2), o2 = this.flags[a2.mode], s2 = this.validations[a2.mode];
    if (!(o2 && o2.feature && o2.feature.coordinates && o2.feature.coordinates.deletable)) return;
    let c2 = this.store.getGeometryCopy(r2), l2;
    if (c2.type === `Polygon`) {
      if (l2 = c2.coordinates[0], l2.length <= 4) return;
    } else if (c2.type === `LineString` && (l2 = c2.coordinates, l2.length <= 2)) return;
    if (!l2 || (c2.type !== `Polygon` || i2 !== 0 && i2 !== l2.length - 1 ? l2.splice(i2, 1) : (l2.shift(), l2.pop(), l2.push([l2[0][0], l2[0][1]])), s2 && !s2({ id: r2, type: `Feature`, geometry: c2, properties: a2 }, { project: this.project, unproject: this.unproject, coordinatePrecision: this.coordinatePrecision, updateType: K.Commit }).valid)) return;
    let u2 = [...this.midPoints.ids, ...this.selectionPoints.ids];
    this.store.delete(u2), this.store.updateGeometry([{ id: r2, geometry: c2 }]), a2.coordinatePointIds && this.coordinatePoints.createOrUpdate(r2), this.selectionPoints.create(l2, c2.type, r2), o2 && o2.feature && o2.feature.coordinates && o2.feature.coordinates.midpoints && this.midPoints.create(l2, r2, this.coordinatePrecision), this.onFinish(r2, { action: `deleteCoordinate`, mode: this.mode });
  }
  select(e2, t2 = true) {
    if (this.selected[0] === e2) return;
    let { mode: n2 } = this.store.getPropertiesCopy(e2), r2 = this.flags[n2];
    if (!r2 || !r2.feature) return;
    let i2 = this.selected[0];
    if (i2) {
      if (i2 === e2) return;
      this.deselect();
    }
    t2 && this.setCursor(this.cursors.pointerOver), this.selected = [e2], this.store.updateProperty([{ id: e2, property: q.SELECTED, value: true }]), this.onSelect(e2);
    let { type: a2, coordinates: o2 } = this.store.getGeometryCopy(e2);
    if (a2 !== `LineString` && a2 !== `Polygon`) return;
    let s2 = a2 === `LineString` ? o2 : o2[0];
    s2 && r2 && r2.feature.coordinates && (this.selectionPoints.create(s2, a2, e2), r2.feature.coordinates.midpoints && this.midPoints.create(s2, e2, this.coordinatePrecision));
  }
  onLeftClick(e2) {
    let { clickedFeature: t2, clickedMidPoint: n2 } = this.featuresAtMouseEvent.find(e2, this.selected.length > 0);
    if (this.selected.length && n2) return this.midPoints.insert(this.selected[0], n2.id, this.coordinatePrecision), void this.onFinish(this.selected[0], { action: `insertMidpoint`, mode: this.mode });
    if (t2 && t2.id) this.select(t2.id, true);
    else if (this.selected.length && this.allowManualDeselection) return void this.deselect();
  }
  start() {
    this.setStarted(), this.setSelecting();
  }
  stop() {
    this.cleanUp(), this.setStarted(), this.setStopped();
  }
  onClick(e2) {
    e2.button === `right` && this.allowPointerEvent(this.pointerEvents.rightClick, e2) || e2.isContextMenu && this.allowPointerEvent(this.pointerEvents.contextMenu, e2) ? this.onRightClick(e2) : e2.button === `left` && this.allowPointerEvent(this.pointerEvents.leftClick, e2) && this.onLeftClick(e2);
  }
  canScale(e2) {
    return this.keyEvents.scale && this.keyEvents.scale.every((t2) => e2.heldKeys.includes(t2));
  }
  canRotate(e2) {
    return this.keyEvents.rotate && this.keyEvents.rotate.every((t2) => e2.heldKeys.includes(t2));
  }
  preventDefaultKeyEvent(e2) {
    let t2 = this.canRotate(e2), n2 = this.canScale(e2);
    (t2 || n2) && e2.preventDefault();
  }
  onKeyDown(e2) {
    this.preventDefaultKeyEvent(e2);
  }
  onKeyUp(e2) {
    if (this.preventDefaultKeyEvent(e2), this.keyEvents.delete && e2.key === this.keyEvents.delete) {
      if (!this.selected.length) return;
      let e3 = this.selected[0];
      this.onDeselect(this.selected[0]), this.coordinatePoints.deletePointsByFeatureIds([e3]), this.deleteSelected(), this.selectionPoints.delete(), this.midPoints.delete();
    } else this.keyEvents.deselect && e2.key === this.keyEvents.deselect && this.cleanUp();
  }
  cleanUp() {
    this.selected.length && this.deselect();
  }
  onDragStart(e2, t2) {
    if (!this.allowPointerEvent(this.pointerEvents.onDragStart, e2) || !this.selected.length) return;
    let n2 = this.store.getPropertiesCopy(this.selected[0]), r2 = this.flags[n2.mode];
    if (!(r2 && r2.feature && (r2.feature.draggable || r2.feature.coordinates && r2.feature.coordinates.draggable || r2.feature.coordinates && r2.feature.coordinates.resizable || r2.feature.coordinates && typeof r2.feature.coordinates.midpoints == `object` && r2.feature.coordinates.midpoints.draggable))) return;
    this.dragEventCount = 0;
    let i2 = this.selected[0], a2 = this.dragCoordinate.getDraggableIndex(e2, i2);
    if (r2 && r2.feature && r2.feature.coordinates && (r2.feature.coordinates.draggable || r2.feature.coordinates.resizable) && a2 !== -1) return this.setCursor(this.cursors.dragStart), r2.feature.coordinates.resizable ? this.dragCoordinateResizeFeature.startDragging(i2, a2) : this.dragCoordinate.startDragging(i2, a2), void t2(false);
    if (r2 && r2.feature && r2.feature.coordinates && typeof r2.feature.coordinates.midpoints == `object` && r2.feature.coordinates.midpoints.draggable) {
      let { clickedMidPoint: n3 } = this.featuresAtMouseEvent.find(e2, this.selected.length > 0);
      if (this.selected.length && n3) {
        this.midPoints.insert(i2, n3.id, this.coordinatePrecision), this.onFinish(this.selected[0], { action: `insertMidpoint`, mode: this.mode });
        let r3 = this.dragCoordinate.getDraggableIndex(e2, i2);
        this.dragCoordinate.startDragging(i2, r3), t2(false);
        return;
      }
    }
    r2 && r2.feature && r2.feature.draggable && this.dragFeature.canDrag(e2, i2) && (this.setCursor(this.cursors.dragStart), this.dragFeature.startDragging(e2, i2), t2(false));
  }
  onDrag(e2, t2) {
    if (!this.allowPointerEvent(this.pointerEvents.onDrag, e2)) return;
    let n2 = this.selected[0];
    if (!n2) return;
    let r2 = this.store.getPropertiesCopy(n2), i2 = this.flags[r2.mode], a2 = true === (i2 && i2.feature && i2.feature.selfIntersectable);
    if (this.dragEventCount++, this.dragEventCount % this.dragEventThrottle == 0) return;
    let o2 = this.validations[r2.mode];
    if (i2 && i2.feature && i2.feature.rotateable && this.canRotate(e2)) return t2(false), void this.rotateFeature.rotate(e2, n2, o2);
    if (i2 && i2.feature && i2.feature.scaleable && this.canScale(e2)) return t2(false), void this.scaleFeature.scale(e2, n2, o2);
    if (this.dragCoordinateResizeFeature.isDragging() && i2.feature && i2.feature.coordinates && i2.feature.coordinates.resizable) {
      if (this.projection === `globe`) throw Error(`Globe is currently unsupported projection for resizable`);
      t2(false), this.dragCoordinateResizeFeature.drag(e2, i2.feature.coordinates.resizable, o2);
      return;
    }
    if (this.dragCoordinate.isDragging()) {
      var s2;
      let t3 = (s2 = i2.feature) == null || (s2 = s2.coordinates) == null ? void 0 : s2.snappable, n3 = { toCoordinate: false };
      true === t3 ? n3 = { toCoordinate: true } : typeof t3 == `object` && (n3 = t3), this.dragCoordinate.drag(e2, a2, o2, n3);
      return;
    }
    this.dragFeature.isDragging() ? this.dragFeature.drag(e2, o2) : t2(true);
  }
  onDragEnd(e2, t2) {
    this.allowPointerEvent(this.pointerEvents.onDragEnd, e2) && (this.setCursor(this.cursors.dragEnd), this.dragCoordinate.isDragging() ? this.onFinish(this.selected[0], { mode: this.mode, action: `dragCoordinate` }) : this.dragFeature.isDragging() ? this.onFinish(this.selected[0], { mode: this.mode, action: `dragFeature` }) : this.dragCoordinateResizeFeature.isDragging() && this.onFinish(this.selected[0], { mode: this.mode, action: `dragCoordinateResize` }), this.dragCoordinate.stopDragging(), this.dragFeature.stopDragging(), this.dragCoordinateResizeFeature.stopDragging(), this.rotateFeature.reset(), this.scaleFeature.reset(), t2(true));
  }
  onMouseMove(e2) {
    if (!this.selected.length) return void this.setCursor(`unset`);
    if (this.dragFeature.isDragging()) return;
    let t2 = false;
    this.midPoints.ids.forEach((n3) => {
      if (t2) return;
      let r3 = this.store.getGeometryCopy(n3);
      this.pixelDistance.measure(e2, r3.coordinates) < this.pointerDistance && (t2 = true);
    });
    let n2 = false;
    if (this.selectionPoints.ids.forEach((r3) => {
      let i2 = this.store.getGeometryCopy(r3);
      this.pixelDistance.measure(e2, i2.coordinates) < this.pointerDistance && (t2 = false, n2 = true);
    }), t2) return void this.setCursor(this.cursors.insertMidpoint);
    let { clickedFeature: r2 } = this.featuresAtMouseEvent.find(e2, true);
    this.setCursor(this.selected.length > 0 && (r2 && r2.id === this.selected[0] || n2) ? this.cursors.pointerOver : `unset`);
  }
  styleFeature(e2) {
    let t2 = G({}, { polygonFillColor: `#3f97e0`, polygonOutlineColor: `#3f97e0`, polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: `#3f97e0`, pointOutlineColor: `#ffffff`, pointOutlineWidth: 0, pointWidth: 6, lineStringColor: `#3f97e0`, lineStringWidth: 4, zIndex: 0, markerUrl: void 0, markerHeight: void 0, markerWidth: void 0 });
    if (e2.properties.mode === this.mode && e2.geometry.type === `Point`) {
      if (e2.properties[q.SELECTION_POINT]) return t2.pointColor = this.getHexColorStylingValue(this.styles.selectionPointColor, t2.pointColor, e2), t2.pointOutlineColor = this.getHexColorStylingValue(this.styles.selectionPointOutlineColor, t2.pointOutlineColor, e2), t2.pointWidth = this.getNumericStylingValue(this.styles.selectionPointWidth, t2.pointWidth, e2), t2.pointOutlineWidth = this.getNumericStylingValue(this.styles.selectionPointOutlineWidth, 2, e2), t2.zIndex = 30, t2;
      if (e2.properties[q.MID_POINT]) return t2.pointColor = this.getHexColorStylingValue(this.styles.midPointColor, t2.pointColor, e2), t2.pointOutlineColor = this.getHexColorStylingValue(this.styles.midPointOutlineColor, t2.pointOutlineColor, e2), t2.pointWidth = this.getNumericStylingValue(this.styles.midPointWidth, 4, e2), t2.pointOutlineWidth = this.getNumericStylingValue(this.styles.midPointOutlineWidth, 2, e2), t2.zIndex = 50, t2;
    } else if (e2.properties[q.SELECTED]) {
      if (e2.geometry.type === `Point` && e2.properties[J.MARKER]) return t2.markerUrl = this.getUrlStylingValue(this.styles.selectedMarkerUrl, Tr, e2), t2.markerHeight = this.getNumericStylingValue(this.styles.selectedMarkerHeight, 40, e2), t2.markerWidth = this.getNumericStylingValue(this.styles.selectedMarkerWidth, 32, e2), t2;
      if (e2.geometry.type === `Polygon`) return t2.polygonFillColor = this.getHexColorStylingValue(this.styles.selectedPolygonColor, t2.polygonFillColor, e2), t2.polygonOutlineWidth = this.getNumericStylingValue(this.styles.selectedPolygonOutlineWidth, t2.polygonOutlineWidth, e2), t2.polygonOutlineColor = this.getHexColorStylingValue(this.styles.selectedPolygonOutlineColor, t2.polygonOutlineColor, e2), t2.polygonFillOpacity = this.getNumericStylingValue(this.styles.selectedPolygonFillOpacity, t2.polygonFillOpacity, e2), t2.zIndex = Er, t2;
      if (e2.geometry.type === `LineString`) return t2.lineStringColor = this.getHexColorStylingValue(this.styles.selectedLineStringColor, t2.lineStringColor, e2), t2.lineStringWidth = this.getNumericStylingValue(this.styles.selectedLineStringWidth, t2.lineStringWidth, e2), t2.zIndex = Er, t2;
      if (e2.geometry.type === `Point`) return t2.pointWidth = this.getNumericStylingValue(this.styles.selectedPointWidth, t2.pointWidth, e2), t2.pointColor = this.getHexColorStylingValue(this.styles.selectedPointColor, t2.pointColor, e2), t2.pointOutlineColor = this.getHexColorStylingValue(this.styles.selectedPointOutlineColor, t2.pointOutlineColor, e2), t2.pointOutlineWidth = this.getNumericStylingValue(this.styles.selectedPointOutlineWidth, t2.pointOutlineWidth, e2), t2.zIndex = Er, t2;
    }
    return t2;
  }
  afterFeatureUpdated(e2) {
    if (this.selected.length && e2.id === this.selected[0]) {
      var t2, n2;
      let r2 = this.flags[e2.properties.mode];
      if (r2 == null || (t2 = r2.feature) == null || !t2.coordinates) return;
      let i2 = e2.geometry.type, a2 = e2.id, o2;
      if (this.selectionPoints.delete(), this.midPoints.delete(), i2 === `Polygon`) o2 = e2.geometry.coordinates[0];
      else {
        if (i2 !== `LineString`) return;
        o2 = e2.geometry.coordinates;
      }
      this.selectionPoints.create(o2, i2, a2), r2 != null && (n2 = r2.feature) != null && (n2 = n2.coordinates) != null && n2.midpoints && this.midPoints.create(i2 === `Polygon` ? e2.geometry.coordinates[0] : e2.geometry.coordinates, a2, this.coordinatePrecision);
    }
  }
}, Ki = class extends Nr {
  constructor(...e2) {
    super(...e2), this.type = jr.Static, this.mode = `static`;
  }
  start() {
  }
  stop() {
  }
  onKeyUp() {
  }
  onKeyDown() {
  }
  onClick() {
  }
  onDragStart() {
  }
  onDrag() {
  }
  onDragEnd() {
  }
  onMouseMove() {
  }
  cleanUp() {
  }
  styleFeature() {
    return G({}, { polygonFillColor: `#3f97e0`, polygonOutlineColor: `#3f97e0`, polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: `#3f97e0`, pointOutlineColor: `#ffffff`, pointOutlineWidth: 0, pointWidth: 6, lineStringColor: `#3f97e0`, lineStringWidth: 4, zIndex: 0, markerUrl: void 0, markerHeight: void 0, markerWidth: void 0 });
  }
};
function qi(e2, t2, n2, r2, i2) {
  for (; r2 > n2; ) {
    if (r2 - n2 > 600) {
      let a3 = r2 - n2 + 1, o3 = t2 - n2 + 1, s3 = Math.log(a3), c2 = 0.5 * Math.exp(2 * s3 / 3), l2 = 0.5 * Math.sqrt(s3 * c2 * (a3 - c2) / a3) * (o3 - a3 / 2 < 0 ? -1 : 1);
      qi(e2, t2, Math.max(n2, Math.floor(t2 - o3 * c2 / a3 + l2)), Math.min(r2, Math.floor(t2 + (a3 - o3) * c2 / a3 + l2)), i2);
    }
    let a2 = e2[t2], o2 = n2, s2 = r2;
    for (Ji(e2, n2, t2), i2(e2[r2], a2) > 0 && Ji(e2, n2, r2); o2 < s2; ) {
      for (Ji(e2, o2, s2), o2++, s2--; i2(e2[o2], a2) < 0; ) o2++;
      for (; i2(e2[s2], a2) > 0; ) s2--;
    }
    i2(e2[n2], a2) === 0 ? Ji(e2, n2, s2) : (s2++, Ji(e2, s2, r2)), s2 <= t2 && (n2 = s2 + 1), t2 <= s2 && (r2 = s2 - 1);
  }
}
function Ji(e2, t2, n2) {
  let r2 = e2[t2];
  e2[t2] = e2[n2], e2[n2] = r2;
}
function Yi(e2, t2) {
  Xi(e2, 0, e2.children.length, t2, e2);
}
function Xi(e2, t2, n2, r2, i2) {
  i2 || (i2 = aa([])), i2.minX = 1 / 0, i2.minY = 1 / 0, i2.maxX = -1 / 0, i2.maxY = -1 / 0;
  for (let a2 = t2; a2 < n2; a2++) {
    let t3 = e2.children[a2];
    Zi(i2, e2.leaf ? r2(t3) : t3);
  }
  return i2;
}
function Zi(e2, t2) {
  return e2.minX = Math.min(e2.minX, t2.minX), e2.minY = Math.min(e2.minY, t2.minY), e2.maxX = Math.max(e2.maxX, t2.maxX), e2.maxY = Math.max(e2.maxY, t2.maxY), e2;
}
function Qi(e2, t2) {
  return e2.minX - t2.minX;
}
function $i(e2, t2) {
  return e2.minY - t2.minY;
}
function ea(e2) {
  return (e2.maxX - e2.minX) * (e2.maxY - e2.minY);
}
function ta(e2) {
  return e2.maxX - e2.minX + (e2.maxY - e2.minY);
}
function na(e2, t2) {
  let n2 = Math.max(e2.minX, t2.minX), r2 = Math.max(e2.minY, t2.minY), i2 = Math.min(e2.maxX, t2.maxX), a2 = Math.min(e2.maxY, t2.maxY);
  return Math.max(0, i2 - n2) * Math.max(0, a2 - r2);
}
function ra(e2, t2) {
  return e2.minX <= t2.minX && e2.minY <= t2.minY && t2.maxX <= e2.maxX && t2.maxY <= e2.maxY;
}
function ia(e2, t2) {
  return t2.minX <= e2.maxX && t2.minY <= e2.maxY && t2.maxX >= e2.minX && t2.maxY >= e2.minY;
}
function aa(e2) {
  return { children: e2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
}
function oa(e2, t2, n2, r2, i2) {
  let a2 = [t2, n2];
  for (; a2.length; ) {
    if ((n2 = a2.pop()) - (t2 = a2.pop()) <= r2) continue;
    let o2 = t2 + Math.ceil((n2 - t2) / r2 / 2) * r2;
    qi(e2, o2, t2, n2, i2), a2.push(t2, o2, o2, n2);
  }
}
var sa = class {
  constructor(e2) {
    this._maxEntries = void 0, this._minEntries = void 0, this.data = void 0, this._maxEntries = Math.max(4, e2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
  }
  search(e2) {
    let t2 = this.data, n2 = [];
    if (!ia(e2, t2)) return n2;
    let r2 = this.toBBox, i2 = [];
    for (; t2; ) {
      for (let a2 = 0; a2 < t2.children.length; a2++) {
        let o2 = t2.children[a2], s2 = t2.leaf ? r2(o2) : o2;
        ia(e2, s2) && (t2.leaf ? n2.push(o2) : ra(e2, s2) ? this._all(o2, n2) : i2.push(o2));
      }
      t2 = i2.pop();
    }
    return n2;
  }
  collides(e2) {
    let t2 = this.data;
    if (ia(e2, t2)) {
      let n2 = [];
      for (; t2; ) {
        for (let r2 = 0; r2 < t2.children.length; r2++) {
          let i2 = t2.children[r2], a2 = t2.leaf ? this.toBBox(i2) : i2;
          if (ia(e2, a2)) {
            if (t2.leaf || ra(e2, a2)) return true;
            n2.push(i2);
          }
        }
        t2 = n2.pop();
      }
    }
    return false;
  }
  load(e2) {
    if (e2.length < this._minEntries) {
      for (let t3 = 0; t3 < e2.length; t3++) this.insert(e2[t3]);
      return;
    }
    let t2 = this._build(e2.slice(), 0, e2.length - 1, 0);
    if (this.data.children.length) if (this.data.height === t2.height) this._splitRoot(this.data, t2);
    else {
      if (this.data.height < t2.height) {
        let e3 = this.data;
        this.data = t2, t2 = e3;
      }
      this._insert(t2, this.data.height - t2.height - 1, true);
    }
    else this.data = t2;
  }
  insert(e2) {
    this._insert(e2, this.data.height - 1);
  }
  clear() {
    this.data = aa([]);
  }
  remove(e2) {
    let t2 = this.data, n2 = this.toBBox(e2), r2 = [], i2 = [], a2, o2, s2 = false;
    for (; t2 || r2.length; ) {
      if (t2 || (t2 = r2.pop(), o2 = r2[r2.length - 1], a2 = i2.pop(), s2 = true), t2.leaf) {
        let n3 = t2.children.indexOf(e2);
        n3 !== -1 && (t2.children.splice(n3, 1), r2.push(t2), this._condense(r2));
      }
      s2 || t2.leaf || !ra(t2, n2) ? o2 ? (a2++, t2 = o2.children[a2], s2 = false) : t2 = null : (r2.push(t2), i2.push(a2), a2 = 0, o2 = t2, t2 = t2.children[0]);
    }
  }
  toBBox(e2) {
    return e2;
  }
  compareMinX(e2, t2) {
    return e2.minX - t2.minX;
  }
  compareMinY(e2, t2) {
    return e2.minY - t2.minY;
  }
  _all(e2, t2) {
    let n2 = [];
    for (; e2; ) e2.leaf ? t2.push(...e2.children) : n2.push(...e2.children), e2 = n2.pop();
    return t2;
  }
  _build(e2, t2, n2, r2) {
    let i2 = n2 - t2 + 1, a2, o2 = this._maxEntries;
    if (i2 <= o2) return a2 = aa(e2.slice(t2, n2 + 1)), Yi(a2, this.toBBox), a2;
    r2 || (r2 = Math.ceil(Math.log(i2) / Math.log(o2)), o2 = Math.ceil(i2 / o2 ** (r2 - 1))), a2 = aa([]), a2.leaf = false, a2.height = r2;
    let s2 = Math.ceil(i2 / o2), c2 = s2 * Math.ceil(Math.sqrt(o2));
    oa(e2, t2, n2, c2, this.compareMinX);
    for (let i3 = t2; i3 <= n2; i3 += c2) {
      let t3 = Math.min(i3 + c2 - 1, n2);
      oa(e2, i3, t3, s2, this.compareMinY);
      for (let n3 = i3; n3 <= t3; n3 += s2) {
        let i4 = Math.min(n3 + s2 - 1, t3);
        a2.children.push(this._build(e2, n3, i4, r2 - 1));
      }
    }
    return Yi(a2, this.toBBox), a2;
  }
  _chooseSubtree(e2, t2, n2, r2) {
    for (; r2.push(t2), !t2.leaf && r2.length - 1 !== n2; ) {
      let n3, r3 = 1 / 0, o2 = 1 / 0;
      for (let s2 = 0; s2 < t2.children.length; s2++) {
        let c2 = t2.children[s2], l2 = ea(c2), u2 = (i2 = e2, a2 = c2, (Math.max(a2.maxX, i2.maxX) - Math.min(a2.minX, i2.minX)) * (Math.max(a2.maxY, i2.maxY) - Math.min(a2.minY, i2.minY)) - l2);
        u2 < o2 ? (o2 = u2, r3 = l2 < r3 ? l2 : r3, n3 = c2) : u2 === o2 && l2 < r3 && (r3 = l2, n3 = c2);
      }
      t2 = n3 || t2.children[0];
    }
    var i2, a2;
    return t2;
  }
  _insert(e2, t2, n2) {
    let r2 = n2 ? e2 : this.toBBox(e2), i2 = [], a2 = this._chooseSubtree(r2, this.data, t2, i2);
    for (a2.children.push(e2), Zi(a2, r2); t2 >= 0 && i2[t2].children.length > this._maxEntries; ) this._split(i2, t2), t2--;
    this._adjustParentBBoxes(r2, i2, t2);
  }
  _split(e2, t2) {
    let n2 = e2[t2], r2 = n2.children.length, i2 = this._minEntries;
    this._chooseSplitAxis(n2, i2, r2);
    let a2 = this._chooseSplitIndex(n2, i2, r2), o2 = aa(n2.children.splice(a2, n2.children.length - a2));
    o2.height = n2.height, o2.leaf = n2.leaf, Yi(n2, this.toBBox), Yi(o2, this.toBBox), t2 ? e2[t2 - 1].children.push(o2) : this._splitRoot(n2, o2);
  }
  _splitRoot(e2, t2) {
    this.data = aa([e2, t2]), this.data.height = e2.height + 1, this.data.leaf = false, Yi(this.data, this.toBBox);
  }
  _chooseSplitIndex(e2, t2, n2) {
    let r2, i2 = 1 / 0, a2 = 1 / 0;
    for (let o2 = t2; o2 <= n2 - t2; o2++) {
      let t3 = Xi(e2, 0, o2, this.toBBox), s2 = Xi(e2, o2, n2, this.toBBox), c2 = na(t3, s2), l2 = ea(t3) + ea(s2);
      c2 < i2 ? (i2 = c2, r2 = o2, a2 = l2 < a2 ? l2 : a2) : c2 === i2 && l2 < a2 && (a2 = l2, r2 = o2);
    }
    return r2 || n2 - t2;
  }
  _chooseSplitAxis(e2, t2, n2) {
    let r2 = e2.leaf ? this.compareMinX : Qi, i2 = e2.leaf ? this.compareMinY : $i;
    this._allDistMargin(e2, t2, n2, r2) < this._allDistMargin(e2, t2, n2, i2) && e2.children.sort(r2);
  }
  _allDistMargin(e2, t2, n2, r2) {
    e2.children.sort(r2);
    let i2 = this.toBBox, a2 = Xi(e2, 0, t2, i2), o2 = Xi(e2, n2 - t2, n2, i2), s2 = ta(a2) + ta(o2);
    for (let r3 = t2; r3 < n2 - t2; r3++) {
      let t3 = e2.children[r3];
      Zi(a2, e2.leaf ? i2(t3) : t3), s2 += ta(a2);
    }
    for (let r3 = n2 - t2 - 1; r3 >= t2; r3--) {
      let t3 = e2.children[r3];
      Zi(o2, e2.leaf ? i2(t3) : t3), s2 += ta(o2);
    }
    return s2;
  }
  _adjustParentBBoxes(e2, t2, n2) {
    for (let r2 = n2; r2 >= 0; r2--) Zi(t2[r2], e2);
  }
  _condense(e2) {
    for (let t2, n2 = e2.length - 1; n2 >= 0; n2--) e2[n2].children.length === 0 ? n2 > 0 ? (t2 = e2[n2 - 1].children, t2.splice(t2.indexOf(e2[n2]), 1)) : this.clear() : Yi(e2[n2], this.toBBox);
  }
}, ca = class {
  constructor(e2) {
    this.tree = void 0, this.idToNode = void 0, this.nodeToId = void 0, this.tree = new sa(e2 && e2.maxEntries ? e2.maxEntries : 9), this.idToNode = /* @__PURE__ */ new Map(), this.nodeToId = /* @__PURE__ */ new Map();
  }
  setMaps(e2, t2) {
    this.idToNode.set(e2.id, t2), this.nodeToId.set(t2, e2.id);
  }
  toBBox(e2) {
    let t2 = [], n2 = [], r2;
    if (e2.geometry.type === `Polygon`) r2 = e2.geometry.coordinates[0];
    else if (e2.geometry.type === `LineString`) r2 = e2.geometry.coordinates;
    else {
      if (e2.geometry.type !== `Point`) throw Error(`Not a valid feature to turn into a bounding box`);
      r2 = [e2.geometry.coordinates];
    }
    for (let e3 = 0; e3 < r2.length; e3++) n2.push(r2[e3][1]), t2.push(r2[e3][0]);
    let i2 = Math.min(...n2), a2 = Math.max(...n2);
    return { minX: Math.min(...t2), minY: i2, maxX: Math.max(...t2), maxY: a2 };
  }
  insert(e2) {
    if (this.idToNode.get(String(e2.id))) throw Error(`Feature already exists`);
    let t2 = this.toBBox(e2);
    this.setMaps(e2, t2), this.tree.insert(t2);
  }
  load(e2) {
    let t2 = [], n2 = /* @__PURE__ */ new Set();
    e2.forEach((e3) => {
      let r2 = this.toBBox(e3);
      if (this.setMaps(e3, r2), n2.has(String(e3.id))) throw Error(`Duplicate feature ID found ${e3.id}`);
      n2.add(String(e3.id)), t2.push(r2);
    }), this.tree.load(t2);
  }
  update(e2) {
    this.remove(e2.id);
    let t2 = this.toBBox(e2);
    this.setMaps(e2, t2), this.tree.insert(t2);
  }
  remove(e2) {
    let t2 = this.idToNode.get(e2);
    if (!t2) throw Error(`${e2} not inserted into the spatial index`);
    this.tree.remove(t2);
  }
  clear() {
    this.tree.clear();
  }
  search(e2) {
    return this.tree.search(this.toBBox(e2)).map((e3) => this.nodeToId.get(e3));
  }
  collides(e2) {
    return this.tree.collides(this.toBBox(e2));
  }
}, la = { getId: () => `xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx`.replace(/[xy]/g, function(e2) {
  let t2 = 16 * Math.random() | 0;
  return (e2 == `x` ? t2 : 3 & t2 | 8).toString(16);
}), isValidId: (e2) => typeof e2 == `string` && e2.length === 36 }, ua = { target: `geometry` }, da = { target: `properties` }, fa = class {
  constructor(e2) {
    this.idStrategy = void 0, this.tracked = void 0, this.spatialIndex = void 0, this.store = void 0, this._onChange = () => {
    }, this.store = {}, this.spatialIndex = new ca(), this.tracked = !e2 || false !== e2.tracked, this.idStrategy = e2 && e2.idStrategy ? e2.idStrategy : la;
  }
  clone(e2) {
    return JSON.parse(JSON.stringify(e2));
  }
  getId() {
    return this.idStrategy.getId();
  }
  has(e2) {
    return !!this.store[e2];
  }
  load(e2, t2, n2, r2) {
    if (e2.length === 0) return [];
    let i2 = this.clone(e2), a2 = [], o2 = [];
    i2 = i2.filter((e3) => {
      e3.id ?? (e3.id = this.idStrategy.getId());
      let n3 = e3.id;
      if (t2) {
        let r3 = t2(e3);
        if (!r3.valid) return a2.push({ id: n3, valid: false, reason: r3.reason }), false;
      }
      if (this.tracked) {
        if (e3.properties.createdAt) {
          if (!kr(e3.properties.createdAt)) return a2.push({ id: e3.id, valid: false, reason: `createdAt is not a valid numeric timestamp` }), false;
        } else e3.properties.createdAt = +/* @__PURE__ */ new Date();
        if (e3.properties.updatedAt) {
          if (!kr(e3.properties.updatedAt)) return a2.push({ id: e3.id, valid: false, reason: `updatedAt is not a valid numeric timestamp` }), false;
        } else e3.properties.updatedAt = +/* @__PURE__ */ new Date();
      }
      return this.has(n3) ? (a2.push({ id: n3, valid: false, reason: `Feature already exists with this id: ${n3}` }), false) : (this.store[n3] = e3, o2.push(e3), a2.push({ id: n3, valid: true }), true);
    }), this.spatialIndex.load(i2);
    let s2 = o2.map(({ id: e3 }) => e3);
    return s2.length > 0 && (this._onChange(s2, `create`, r2), n2 && o2.forEach((e3) => {
      n2(e3);
    })), a2;
  }
  search(e2, t2) {
    let n2 = this.spatialIndex.search(e2).map((e3) => this.store[e3]);
    return this.clone(t2 ? n2.filter(t2) : n2);
  }
  registerOnChange(e2) {
    this._onChange = (t2, n2, r2) => {
      e2(t2, n2, r2);
    };
  }
  getGeometryCopy(e2) {
    let t2 = this.store[e2];
    if (!t2) throw Error(`No feature with this id (${e2}), can not get geometry copy`);
    return this.clone(t2.geometry);
  }
  getPropertiesCopy(e2) {
    let t2 = this.store[e2];
    if (!t2) throw Error(`No feature with this id (${e2}), can not get properties copy`);
    return this.clone(t2.properties);
  }
  updateProperty(e2, t2) {
    let n2 = /* @__PURE__ */ new Set();
    e2.forEach(({ id: e3, property: t3, value: r2 }) => {
      let i2 = this.store[e3];
      if (!i2) throw Error(`No feature with this (${e3}), can not update geometry`);
      i2.properties[t3] !== r2 && (n2.add(e3), r2 === void 0 ? delete i2.properties[t3] : i2.properties[t3] = r2, this.tracked && (i2.properties.updatedAt = +/* @__PURE__ */ new Date()));
    }), this._onChange && n2.size > 0 && this._onChange([...n2], `update`, t2 ? G({}, t2, da) : da);
  }
  updateGeometry(e2, t2) {
    let n2 = /* @__PURE__ */ new Set();
    e2.forEach(({ id: e3, geometry: t3 }) => {
      n2.add(e3);
      let r2 = this.store[e3];
      if (!r2) throw Error(`No feature with this (${e3}), can not update geometry`);
      r2.geometry = this.clone(t3), this.spatialIndex.update(r2), this.tracked && (r2.properties.updatedAt = +/* @__PURE__ */ new Date());
    }), this._onChange && n2.size > 0 && this._onChange([...n2], `update`, t2 ? G({}, t2, ua) : ua);
  }
  create(e2, t2) {
    let n2 = [];
    return e2.forEach(({ geometry: e3, properties: t3 }) => {
      let r2, i2 = G({}, t3);
      this.tracked && (r2 = +/* @__PURE__ */ new Date(), t3 ? (i2.createdAt = typeof t3.createdAt == `number` ? t3.createdAt : r2, i2.updatedAt = typeof t3.updatedAt == `number` ? t3.updatedAt : r2) : i2 = { createdAt: r2, updatedAt: r2 });
      let a2 = this.getId(), o2 = { id: a2, type: `Feature`, geometry: e3, properties: i2 };
      this.store[a2] = o2, this.spatialIndex.insert(o2), n2.push(a2);
    }), this._onChange && this._onChange([...n2], `create`, t2), n2;
  }
  delete(e2, t2) {
    e2.forEach((e3) => {
      if (!this.store[e3]) throw Error(`No feature with id ${e3}, can not delete`);
      delete this.store[e3], this.spatialIndex.remove(e3);
    }), this._onChange && this._onChange([...e2], `delete`, t2);
  }
  copy(e2) {
    return this.clone(this.store[e2]);
  }
  copyAll() {
    return this.clone(Object.keys(this.store).map((e2) => this.store[e2]));
  }
  copyAllWhere(e2) {
    return this.clone(Object.keys(this.store).map((e3) => this.store[e3]).filter((t2) => t2.properties && e2(t2.properties)));
  }
  clear() {
    this.store = {}, this.spatialIndex.clear();
  }
  size() {
    return Object.keys(this.store).length;
  }
};
Math.PI / 180;
var pa = class {
  constructor({ name: e2, callback: t2, unregister: n2, register: r2 }) {
    this.name = void 0, this.callback = void 0, this.registered = false, this.register = void 0, this.unregister = void 0, this.name = e2, this.register = () => {
      this.registered || (this.registered = true, r2(t2));
    }, this.unregister = () => {
      this.register && (this.registered = false, n2(t2));
    }, this.callback = t2;
  }
}, ma = { __proto__: null, GeoJSONStore: fa, TerraDrawBaseDrawMode: Nr, TerraDrawBaseSelectMode: Pr, TerraDrawBaseAdapter: class {
  constructor(e2) {
    this._nextKeyUpIsContextMenu = false, this._lastPointerDownEventTarget = void 0, this._ignoreMismatchedPointerEvents = false, this._minPixelDragDistance = void 0, this._minPixelDragDistanceDrawing = void 0, this._minPixelDragDistanceSelecting = void 0, this._lastDrawEvent = void 0, this._coordinatePrecision = void 0, this._heldKeys = /* @__PURE__ */ new Set(), this._listeners = [], this._dragState = `not-dragging`, this._currentModeCallbacks = void 0, this._ignoreMismatchedPointerEvents = typeof e2.ignoreMismatchedPointerEvents == `boolean` && e2.ignoreMismatchedPointerEvents, this._minPixelDragDistance = typeof e2.minPixelDragDistance == `number` ? e2.minPixelDragDistance : 1, this._minPixelDragDistanceSelecting = typeof e2.minPixelDragDistanceSelecting == `number` ? e2.minPixelDragDistanceSelecting : 1, this._minPixelDragDistanceDrawing = typeof e2.minPixelDragDistanceDrawing == `number` ? e2.minPixelDragDistanceDrawing : 8, this._coordinatePrecision = typeof e2.coordinatePrecision == `number` ? e2.coordinatePrecision : 9;
  }
  getButton(e2) {
    return e2.button === -1 ? `neither` : e2.button === 0 ? `left` : e2.button === 1 ? `middle` : e2.button === 2 ? `right` : `neither`;
  }
  getMapElementXYPosition(e2) {
    let { left: t2, top: n2 } = this.getMapEventElement().getBoundingClientRect();
    return { containerX: e2.clientX - t2, containerY: e2.clientY - n2 };
  }
  getDrawEventFromEvent(e2, t2 = false) {
    let n2 = this.getLngLatFromEvent(e2);
    if (!n2) return null;
    let { lng: r2, lat: i2 } = n2, { containerX: a2, containerY: o2 } = this.getMapElementXYPosition(e2), s2 = this.getButton(e2), c2 = Array.from(this._heldKeys);
    return { lng: X(r2, this._coordinatePrecision), lat: X(i2, this._coordinatePrecision), containerX: a2, containerY: o2, button: s2, heldKeys: c2, isContextMenu: t2 };
  }
  register(e2) {
    this._currentModeCallbacks = e2, this._listeners = this.getAdapterListeners(), this._listeners.forEach((e3) => {
      e3.register();
    });
  }
  getCoordinatePrecision() {
    return this._coordinatePrecision;
  }
  getAdapterListeners() {
    return [new pa({ name: `pointerdown`, callback: (e2) => {
      if (!this._currentModeCallbacks || !e2.isPrimary) return;
      let t2 = this.getDrawEventFromEvent(e2);
      t2 && (this._dragState = `pre-dragging`, this._lastDrawEvent = t2, this._lastPointerDownEventTarget = e2.target ? e2.target : void 0);
    }, register: (e2) => {
      this.getMapEventElement().addEventListener(`pointerdown`, e2);
    }, unregister: (e2) => {
      this.getMapEventElement().removeEventListener(`pointerdown`, e2);
    } }), new pa({ name: `pointermove`, callback: (e2) => {
      if (!this._currentModeCallbacks || !e2.isPrimary) return;
      e2.preventDefault();
      let t2 = this.getDrawEventFromEvent(e2);
      if (t2) if (this._dragState === `not-dragging`) this._currentModeCallbacks.onMouseMove(t2), this._lastDrawEvent = t2;
      else if (this._dragState === `pre-dragging`) {
        if (!this._lastDrawEvent) return;
        let e3 = { x: this._lastDrawEvent.containerX, y: this._lastDrawEvent.containerY }, n2 = { x: t2.containerX, y: t2.containerY }, r2 = this._currentModeCallbacks.getState(), i2 = Q(e3, n2), a2 = false;
        if (a2 = r2 === `drawing` ? i2 < this._minPixelDragDistanceDrawing : r2 === `selecting` ? i2 < this._minPixelDragDistanceSelecting : i2 < this._minPixelDragDistance, a2) return;
        this._nextKeyUpIsContextMenu = false, this._dragState = `dragging`, this._currentModeCallbacks.onDragStart(t2, (e4) => {
          this.setDraggability.bind(this)(e4);
        });
      } else this._dragState === `dragging` && this._currentModeCallbacks.onDrag(t2, (e3) => {
        this.setDraggability.bind(this)(e3);
      });
    }, register: (e2) => {
      this.getMapEventElement().addEventListener(`pointermove`, e2);
    }, unregister: (e2) => {
      this.getMapEventElement().removeEventListener(`pointermove`, e2);
    } }), new pa({ name: `contextmenu`, callback: (e2) => {
      this._currentModeCallbacks && (e2.preventDefault(), this._nextKeyUpIsContextMenu = true);
    }, register: (e2) => {
      this.getMapEventElement().addEventListener(`contextmenu`, e2);
    }, unregister: (e2) => {
      this.getMapEventElement().removeEventListener(`contextmenu`, e2);
    } }), new pa({ name: `pointerup`, callback: (e2) => {
      if (!this._currentModeCallbacks || e2.target !== this.getMapEventElement() || this._ignoreMismatchedPointerEvents && this._lastPointerDownEventTarget !== e2.target || (this._lastPointerDownEventTarget = void 0, !e2.isPrimary)) return;
      let t2 = this.getDrawEventFromEvent(e2);
      t2 && (this._dragState === `dragging` ? this._currentModeCallbacks.onDragEnd(t2, (e3) => {
        this.setDraggability.bind(this)(e3);
      }) : this._dragState !== `not-dragging` && this._dragState !== `pre-dragging` || (this._nextKeyUpIsContextMenu && (this._nextKeyUpIsContextMenu = (t2.isContextMenu = true, false)), this._currentModeCallbacks.onClick(t2)), this._dragState = `not-dragging`, this.setDraggability(true));
    }, register: (e2) => {
      this.getMapEventElement().addEventListener(`pointerup`, e2);
    }, unregister: (e2) => {
      this.getMapEventElement().removeEventListener(`pointerup`, e2);
    } }), new pa({ name: `keyup`, callback: (e2) => {
      this._currentModeCallbacks && (this._heldKeys.delete(e2.key), this._currentModeCallbacks.onKeyUp({ key: e2.key, heldKeys: Array.from(this._heldKeys), preventDefault: () => e2.preventDefault() }));
    }, register: (e2) => {
      this.getMapEventElement().addEventListener(`keyup`, e2);
    }, unregister: (e2) => {
      this.getMapEventElement().removeEventListener(`keyup`, e2);
    } }), new pa({ name: `keydown`, callback: (e2) => {
      this._currentModeCallbacks && (this._heldKeys.add(e2.key), this._currentModeCallbacks.onKeyDown({ key: e2.key, heldKeys: Array.from(this._heldKeys), preventDefault: () => e2.preventDefault() }));
    }, register: (e2) => {
      this.getMapEventElement().addEventListener(`keydown`, e2);
    }, unregister: (e2) => {
      this.getMapEventElement().removeEventListener(`keydown`, e2);
    } })];
  }
  unregister() {
    this._listeners.forEach((e2) => {
      e2.unregister();
    }), this.clear(), this._currentModeCallbacks = void 0, this._lastDrawEvent = void 0, this._lastPointerDownEventTarget = void 0, this._nextKeyUpIsContextMenu = false;
  }
}, getDefaultStyling: () => ({ polygonFillColor: `#3f97e0`, polygonOutlineColor: `#3f97e0`, polygonOutlineWidth: 4, polygonFillOpacity: 0.3, pointColor: `#3f97e0`, pointOutlineColor: `#ffffff`, pointOutlineWidth: 0, pointWidth: 6, lineStringColor: `#3f97e0`, lineStringWidth: 4, zIndex: 0, markerUrl: void 0, markerHeight: void 0, markerWidth: void 0 }), SELECT_PROPERTIES: q };
function ha(e2) {
  if (e2 === null || typeof e2 == `boolean` || typeof e2 == `string`) return true;
  if (e2 === void 0) return false;
  if (typeof e2 == `number`) return Number.isFinite(e2);
  if (typeof e2 == `bigint` || typeof e2 == `symbol` || typeof e2 == `function` || e2 instanceof RegExp || e2 instanceof Map || e2 instanceof Set || e2 instanceof Date) return false;
  if (typeof e2 == `object` && e2 && !Array.isArray(e2)) {
    let t2 = Object.getPrototypeOf(e2);
    if (t2 !== Object.prototype && t2 !== null) return false;
  }
  if (ArrayBuffer.isView(e2) && !(e2 instanceof DataView)) return false;
  if (Array.isArray(e2)) {
    for (let t2 of e2) if (!ha(t2)) return false;
  }
  return typeof e2 == `object` && Object.keys(e2).every((t2) => typeof t2 == `string` && ha(e2[t2]));
}
var ga = class {
  constructor(e2) {
    this._modes = void 0, this._mode = void 0, this._adapter = void 0, this._enabled = false, this._store = void 0, this._eventListeners = void 0, this._instanceSelectMode = void 0, this._adapter = e2.adapter, this._mode = new Ki();
    let t2 = /* @__PURE__ */ new Set(), n2 = e2.modes.reduce((e3, n3) => {
      if (t2.has(n3.mode)) throw Error(`There is already a ${n3.mode} mode provided`);
      return t2.add(n3.mode), e3[n3.mode] = n3, e3;
    }, {}), r2 = Object.keys(n2);
    if (r2.length === 0) throw Error(`No modes provided`);
    r2.forEach((e3) => {
      if (n2[e3].type === jr.Select) {
        if (this._instanceSelectMode) throw Error(`only one type of select mode can be provided`);
        this._instanceSelectMode = e3;
      }
    }), this._modes = G({}, n2, { static: this._mode }), this._eventListeners = { change: [], select: [], deselect: [], finish: [], ready: [] }, this._store = new fa({ tracked: !!e2.tracked, idStrategy: e2.idStrategy ? e2.idStrategy : void 0 });
    let i2 = (e3) => {
      let t3 = [];
      return { changed: t3, unchanged: this._store.copyAll().filter((n3) => !e3.includes(n3.id) || (t3.push(n3), false)) };
    }, a2 = (e3, t3) => {
      this._enabled && this._eventListeners.finish.forEach((n3) => {
        n3(e3, t3);
      });
    }, o2 = (e3, t3, n3) => {
      if (!this._enabled) return;
      this._eventListeners.change.forEach((r4) => {
        r4(e3, t3, n3);
      });
      let { changed: r3, unchanged: a3 } = i2(e3);
      t3 === `create` ? this._adapter.render({ created: r3, deletedIds: [], unchanged: a3, updated: [] }, this.getModeStyles()) : t3 === `update` ? this._adapter.render({ created: [], deletedIds: [], unchanged: a3, updated: r3 }, this.getModeStyles()) : t3 === `delete` ? this._adapter.render({ created: [], deletedIds: e3, unchanged: a3, updated: [] }, this.getModeStyles()) : t3 === `styling` && this._adapter.render({ created: [], deletedIds: [], unchanged: a3, updated: [] }, this.getModeStyles());
    }, s2 = (e3) => {
      if (!this._enabled) return;
      this._eventListeners.select.forEach((t4) => {
        t4(e3);
      });
      let { changed: t3, unchanged: n3 } = i2([e3]);
      this._adapter.render({ created: [], deletedIds: [], unchanged: n3, updated: t3 }, this.getModeStyles());
    }, c2 = (e3) => {
      if (!this._enabled) return;
      this._eventListeners.deselect.forEach((e4) => {
        e4();
      });
      let { changed: t3, unchanged: n3 } = i2([e3]);
      t3 && this._adapter.render({ created: [], deletedIds: [], unchanged: n3, updated: t3 }, this.getModeStyles());
    };
    Object.keys(this._modes).forEach((e3) => {
      this._modes[e3].register({ mode: e3, store: this._store, setCursor: this._adapter.setCursor.bind(this._adapter), project: this._adapter.project.bind(this._adapter), unproject: this._adapter.unproject.bind(this._adapter), setDoubleClickToZoom: this._adapter.setDoubleClickToZoom.bind(this._adapter), onChange: o2, onSelect: s2, onDeselect: c2, onFinish: a2, coordinatePrecision: this._adapter.getCoordinatePrecision() });
    });
  }
  checkEnabled() {
    if (!this._enabled) throw Error(`Terra Draw is not enabled`);
  }
  getModeStyles() {
    let e2 = {};
    return Object.keys(this._modes).forEach((t2) => {
      e2[t2] = (e3) => this._instanceSelectMode && e3.properties[q.SELECTED] ? this._modes[this._instanceSelectMode].styleFeature.bind(this._modes[this._instanceSelectMode])(e3) : this._modes[t2].styleFeature.bind(this._modes[t2])(e3);
    }), e2;
  }
  featuresAtLocation({ lng: e2, lat: t2 }, n2) {
    let r2 = n2 && n2.pointerDistance !== void 0 ? n2.pointerDistance : 30, i2 = !n2 || n2.ignoreSelectFeatures === void 0 || n2.ignoreSelectFeatures, a2 = !(!n2 || n2.ignoreCoordinatePoints === void 0) && n2.ignoreCoordinatePoints, o2 = !(!n2 || n2.ignoreCurrentlyDrawing === void 0) && n2.ignoreCurrentlyDrawing, s2 = !(!n2 || n2.ignoreClosingPoints === void 0) && n2.ignoreClosingPoints, c2 = !(!n2 || n2.ignoreSnappingPoints === void 0) && n2.ignoreSnappingPoints, l2 = this._adapter.unproject.bind(this._adapter), u2 = this._adapter.project.bind(this._adapter), d2 = u2(e2, t2), f2 = Jr({ unproject: l2, point: d2, pointerDistance: r2 });
    return this._store.search(f2).filter((l3) => {
      if (i2 && (l3.properties[q.MID_POINT] || l3.properties[q.SELECTION_POINT]) || a2 && l3.properties[J.COORDINATE_POINT] || s2 && l3.properties[J.CLOSING_POINT] || o2 && l3.properties[J.CURRENTLY_DRAWING] || c2 && l3.properties[J.SNAPPING_POINT]) return false;
      if (l3.geometry.type === `Point`) {
        let e3 = l3.geometry.coordinates;
        return Q(d2, u2(e3[0], e3[1])) < r2;
      }
      if (l3.geometry.type === `LineString`) {
        let e3 = l3.geometry.coordinates;
        for (let t3 = 0; t3 < e3.length - 1; t3++) {
          let n3 = e3[t3], i3 = e3[t3 + 1];
          if (Mi(d2, u2(n3[0], n3[1]), u2(i3[0], i3[1])) < r2) return true;
        }
        return false;
      }
      if (ji([e2, t2], l3.geometry.coordinates)) return true;
      if (n2 != null && n2.includePolygonsWithinPointerDistance) {
        let e3 = l3.geometry.coordinates;
        for (let t3 of e3) for (let e4 = 0; e4 < t3.length - 1; e4++) {
          let n3 = t3[e4], i3 = t3[e4 + 1];
          if (Mi(d2, u2(n3[0], n3[1]), u2(i3[0], i3[1])) < r2) return true;
        }
      }
      return false;
    }).map((r3) => {
      if (n2 == null || !n2.addClosestCoordinateInfoToProperties) return r3;
      let i3;
      if (r3.geometry.type === `Polygon`) i3 = r3.geometry.coordinates[0].slice(0, -1);
      else {
        if (r3.geometry.type !== `LineString`) return r3;
        i3 = r3.geometry.coordinates;
      }
      let a3, o3 = -1, s3 = 1 / 0;
      for (let e3 = 0; e3 < i3.length; e3++) {
        let t3 = i3[e3], n3 = Q(u2(t3[0], t3[1]), d2);
        n3 < s3 && (o3 = e3, s3 = n3, a3 = t3);
      }
      return r3.properties.closestCoordinateIndexToEvent = o3, r3.properties.closestCoordinatePixelDistanceToEvent = s3, r3.properties.closestCoordinateDistanceKmToEvent = Fr(a3, [e2, t2]), r3;
    });
  }
  getSelectModeOrThrow() {
    let e2 = this.getSelectMode({ switchToSelectMode: true });
    if (!e2) throw Error(`No select mode defined in instance`);
    return e2;
  }
  getSelectMode({ switchToSelectMode: e2 }) {
    if (this.checkEnabled(), !this._instanceSelectMode) return null;
    let t2 = this.getMode();
    return e2 && t2 !== this._instanceSelectMode && this.setMode(this._instanceSelectMode), this._modes[this._instanceSelectMode];
  }
  isGuidanceFeature(e2) {
    return !!(e2.properties[q.MID_POINT] || e2.properties[q.SELECTION_POINT] || e2.properties[J.COORDINATE_POINT] || e2.properties[J.SNAPPING_POINT]);
  }
  setModeStyles(e2, t2) {
    if (this.checkEnabled(), !this._modes[e2]) throw Error(`No mode with this name present`);
    this._modes[e2].styles = t2;
  }
  updateModeOptions(e2, t2) {
    if (this.checkEnabled(), !this._modes[e2]) throw Error(`No mode with this name present`);
    this._modes[e2].updateOptions(t2);
  }
  getSnapshot() {
    return this._store.copyAll();
  }
  getSnapshotFeature(e2) {
    if (this._store.has(e2)) return this._store.copy(e2);
  }
  clear() {
    this.checkEnabled(), this._adapter.clear();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e2) {
    throw Error(`Enabled is read only`);
  }
  getMode() {
    return this._mode.mode;
  }
  getModeState() {
    return this._mode.state;
  }
  setMode(e2) {
    if (this.checkEnabled(), !this._modes[e2]) throw Error(`No mode with this name present`);
    this._mode.stop(), this._mode = this._modes[e2], this._mode.start();
  }
  removeFeatures(e2) {
    this.checkEnabled();
    let t2 = [];
    e2.forEach((e3) => {
      if (!this._store.has(e3)) throw Error(`No feature with id ${e3}, can not delete`);
      let n2 = this._store.copy(e3);
      n2.properties[q.SELECTED] && this.deselectFeature(e3), n2.properties[J.COORDINATE_POINT_IDS] && t2.push(...n2.properties[J.COORDINATE_POINT_IDS]);
    }), this._store.delete([...e2, ...t2], { origin: `api` });
  }
  selectFeature(e2) {
    this.getSelectModeOrThrow().selectFeature(e2);
  }
  deselectFeature(e2) {
    this.getSelectModeOrThrow().deselectFeature(e2);
  }
  getFeatureId() {
    return this._store.getId();
  }
  hasFeature(e2) {
    return this._store.has(e2);
  }
  checkIsReservedProperty(e2) {
    return ![...Object.values(q), ...Object.values(J)].includes(e2);
  }
  updateFeatureProperties(e2, t2) {
    if (!this._store.has(e2)) throw Error(`No feature with id ${e2} present in store`);
    let n2 = this._store.copy(e2);
    if (this.isGuidanceFeature(n2)) throw Error(`Guidance features are not allowed to be updated directly.`);
    let r2 = n2.properties.mode;
    if (!this._modes[r2]) throw Error(`No mode with name ${r2} present in instance`);
    let i2 = Object.entries(t2);
    i2.forEach(([e3, t3]) => {
      if (!this.checkIsReservedProperty(e3)) throw Error(`You are trying to update a reserved property name: ${e3}. Please choose another name.`);
      if (t3 !== void 0 && !ha(t3)) throw Error(`Invalid JSON value provided for property ${e3}`);
    }), this._store.updateProperty(i2.map(([e3, t3]) => ({ id: n2.id, property: e3, value: t3 })), { origin: `api` });
  }
  updateFeatureGeometry(e2, t2) {
    if (!this._store.has(e2)) throw Error(`No feature with id ${e2} present in store`);
    let n2 = this._store.copy(e2);
    if (this.isGuidanceFeature(n2)) throw Error(`Guidance features are not allowed to be updated directly.`);
    if (!(n2 && t2 && t2.type && t2.coordinates)) throw Error(`Invalid geometry provided`);
    if (t2.type !== n2.geometry.type) throw Error(`Geometry type mismatch: expected ${n2.geometry.type}, got ${t2.type}`);
    let r2 = n2.properties.mode, i2 = this._modes[r2];
    if (!i2) throw Error(`No mode with name ${r2} present in instance`);
    let a2 = G({}, n2, { geometry: t2 }), o2 = i2.validateFeature(a2);
    if (!o2.valid) throw Error(`Feature validation failed: ${o2.reason || `Unknown reason`}`);
    if (this._store.updateGeometry([{ id: n2.id, geometry: t2 }], { origin: `api` }), i2.afterFeatureUpdated) {
      i2.afterFeatureUpdated(a2);
      let e3 = a2.properties[q.SELECTED], t3 = this.getSelectMode({ switchToSelectMode: false });
      t3 && e3 && t3.afterFeatureUpdated(a2);
    }
  }
  transformFeatureGeometry(e2, t2) {
    if (!this._store.has(e2)) throw Error(`No feature with id ${e2} present in store`);
    let n2 = this._store.copy(e2);
    if (this.isGuidanceFeature(n2)) throw Error(`Guidance features are not allowed to be updated directly.`);
    let r2 = n2.properties.mode, i2 = this._modes[r2];
    if (!i2) throw Error(`No mode with name ${r2} present in instance`);
    let a2;
    if (n2.geometry.type === `Polygon`) a2 = n2.geometry.coordinates[0];
    else {
      if (n2.geometry.type !== `LineString`) throw Error(`Feature geometry type ${n2.geometry.type} is not supported for transformation`);
      a2 = n2.geometry.coordinates;
    }
    if (t2.projection != `web-mercator`) throw Error(`Projection ${t2.projection} is not currently supported for transformation`);
    if (t2.type === `scale`) {
      let { x: e3, y: n3 } = Z(t2.origin[0], t2.origin[1]);
      Vi({ coordinates: a2, originX: e3, originY: n3, xScale: t2.options.xScale || 1, yScale: t2.options.yScale || 1 });
    } else t2.type === `rotate` && (n2 = Li(n2, t2.options.angle || 0), a2 = n2.geometry.type === `Polygon` ? n2.geometry.coordinates[0] : n2.geometry.coordinates);
    if (a2 = a2.map((e3) => [X(e3[0], this._adapter.getCoordinatePrecision()), X(e3[1], this._adapter.getCoordinatePrecision())]), n2.geometry.coordinates = n2.geometry.type === `Polygon` ? [a2] : a2, this._store.updateGeometry([{ id: n2.id, geometry: n2.geometry }], { origin: `api` }), i2.afterFeatureUpdated) {
      i2.afterFeatureUpdated(n2);
      let e3 = n2.properties[q.SELECTED], t3 = this.getSelectMode({ switchToSelectMode: false });
      t3 && e3 && t3.afterFeatureUpdated(n2);
    }
  }
  addFeatures(e2) {
    return this.checkEnabled(), e2.length === 0 ? [] : this._store.load(e2, (e3) => {
      if (Or(e3)) {
        let t2 = e3.properties.mode, n2 = this._modes[t2];
        if (!n2) return { id: e3.id, valid: false, reason: `${t2} mode is not in the list of instantiated modes` };
        let r2 = n2.validateFeature.bind(n2)(e3);
        return { id: e3.id, valid: r2.valid, reason: r2.reason ? r2.reason : r2.valid ? void 0 : `Feature is invalid` };
      }
      return { id: e3.id, valid: false, reason: `Mode property does not exist` };
    }, (e3) => {
      if (Or(e3)) {
        let t2 = this._modes[e3.properties.mode];
        t2 && t2.afterFeatureAdded && t2.afterFeatureAdded(e3);
      }
    }, { origin: `api` });
  }
  start() {
    this._enabled || (this._enabled = true, this._adapter.register({ onReady: () => {
      this._eventListeners.ready.forEach((e2) => {
        e2();
      });
    }, getState: () => this._mode.state, onClick: (e2) => {
      this._mode.onClick(e2);
    }, onMouseMove: (e2) => {
      this._mode.onMouseMove(e2);
    }, onKeyDown: (e2) => {
      this._mode.onKeyDown(e2);
    }, onKeyUp: (e2) => {
      this._mode.onKeyUp(e2);
    }, onDragStart: (e2, t2) => {
      this._mode.onDragStart(e2, t2);
    }, onDrag: (e2, t2) => {
      this._mode.onDrag(e2, t2);
    }, onDragEnd: (e2, t2) => {
      this._mode.onDragEnd(e2, t2);
    }, onClear: () => {
      this._mode.cleanUp(), this._store.clear();
    } }));
  }
  getFeaturesAtLngLat(e2, t2) {
    let { lng: n2, lat: r2 } = e2;
    return this.featuresAtLocation({ lng: n2, lat: r2 }, t2);
  }
  getFeaturesAtPointerEvent(e2, t2) {
    let n2 = this._adapter.getLngLatFromEvent.bind(this._adapter)(e2);
    return n2 === null ? [] : this.featuresAtLocation(n2, t2);
  }
  stop() {
    this._enabled && (this._enabled = false, this._adapter.unregister());
  }
  on(e2, t2) {
    let n2 = this._eventListeners[e2];
    n2.includes(t2) || n2.push(t2);
  }
  off(e2, t2) {
    let n2 = this._eventListeners[e2];
    n2.includes(t2) && n2.splice(n2.indexOf(t2), 1);
  }
}, _a = F({ __name: `MapContainer`, props: { styleUrl: {}, geojsonSource: {}, drawerModes: {}, onMapInit: { type: Function }, onMapTouchStart: { type: Function }, onMapTouchEnd: { type: Function }, onMapClick: { type: Function } }, setup(e2, { expose: t2 }) {
  let n2 = e2, r2 = Ue(null), i2 = Ue(null), a2 = Et(), o2 = wr(), s2 = at();
  D([() => a2.settings.mapLanguage, () => s2.locale.value], (e3) => {
    e3 && r2.value && c2(r2.value, e3[0] === `interface` ? e3[1] : e3[0]);
  });
  let c2 = (e3, t3) => {
    let n3 = t3 === `zh-CN` ? `zh` : `en`;
    for (let t4 of [`City labels`, `Road labels`, `Station labels`, `Airport labels`, `Continent labels`, `Country labels`]) e3.setLayoutProperty(t4, `text-field`, [`get`, `name:${n3}`]);
  };
  function l2(e3) {
    let t3 = e3.getStyle().layers, n3;
    for (let e4 = 0; e4 < t3.length; e4++) {
      let r3 = t3[e4];
      if (r3.type === `symbol` && r3.layout && typeof r3.layout == `object` && `text-field` in r3.layout) {
        n3 = r3.id;
        break;
      }
    }
    e3.addLayer({ id: `3d-buildings`, source: `openfreemap`, "source-layer": `building`, type: `fill-extrusion`, minzoom: 15, filter: [`!=`, [`get`, `hide_3d`], true], paint: { "fill-extrusion-color": [`interpolate`, [`linear`], [`get`, `render_height`], 0, `lightgray`, 200, `royalblue`, 400, `lightblue`], "fill-extrusion-height": [`interpolate`, [`linear`], [`zoom`], 15, 0, 16, [`get`, `render_height`]], "fill-extrusion-base": [`case`, [`>=`, [`get`, `zoom`], 16], [`get`, `render_min_height`], 0] } }, n3);
  }
  function u2(e3) {
    e3.removeLayer(`3d-buildings`);
  }
  function d2(e3) {
    var _a2, _b;
    r2.value = e3.map, (_a2 = r2.value) == null ? void 0 : _a2.addSource(`openfreemap`, { url: `https://tiles.openfreemap.org/planet`, type: `vector` }), r2.value && c2(r2.value, s2.locale.value), o2.isTrackingOrientation && (v2(), v2()), (_b = r2.value) == null ? void 0 : _b.on(`click`, n2.onMapClick), n2.onMapInit(e3);
  }
  let { bearing: f2, isTracking: p2, isSupported: m2, error: h2, startTracking: g2, stopTracking: _2 } = Kn({ autoStart: false }), v2 = () => {
    var _a2;
    o2.setTrackingOrientation(!o2.isTrackingOrientation), o2.isTrackingOrientation ? g2() : (_2(), o2.setBearing(0), (_a2 = r2.value) == null ? void 0 : _a2.setBearing(0));
  }, y2 = (e3) => {
    var _a2, _b, _c, _d;
    if (o2.isTrackingOrientation) {
      if (((_a2 = r2.value) == null ? void 0 : _a2.isEasing()) || ((_b = r2.value) == null ? void 0 : _b.isMoving()) || ((_c = r2.value) == null ? void 0 : _c.isRotating()) || ((_d = r2.value) == null ? void 0 : _d.isZooming())) return;
      o2.setBearing(e3);
    }
  };
  return D([f2, () => o2.isTrackingOrientation], ([e3, t3]) => {
    t3 && y2(e3);
  }), t2({ setupBuildingLayer: l2, removeBuildingLayer: u2, toggleOrientationTracking: v2, map: r2, draw: i2 }), (t3, n3) => (N(), k(A(ae), { bearing: A(o2).bearing, "onUpdate:bearing": n3[0] || (n3[0] = (e3) => A(o2).bearing = e3), zoom: A(o2).zoom, "onUpdate:zoom": n3[1] || (n3[1] = (e3) => A(o2).zoom = e3), center: A(o2).center, "onUpdate:center": n3[2] || (n3[2] = (e3) => A(o2).center = e3), "map-style": e2.styleUrl, height: `100%`, "onMap:load": d2, "onMap:touchstart": e2.onMapTouchStart, "onMap:touchend": e2.onMapTouchEnd }, { default: W(() => [R(A(w), { "source-id": `geojson`, data: e2.geojsonSource, "line-metrics": true }, { default: W(() => [R(A(de), { "layer-id": `geojson`, layout: { "line-join": `round`, "line-cap": `round` }, paint: { "line-width": 5, "line-gradient": [`interpolate`, [`linear`], [`line-progress`], 0, `#00ff00`, 0.7, `#00DD00`, 0.9, `#00BB00`, 1, `#008800`], "line-opacity": 0.8 } })]), _: 1 }, 8, [`data`]), Fe(t3.$slots, `default`)]), _: 3 }, 8, [`bearing`, `zoom`, `center`, `map-style`, `onMap:touchstart`, `onMap:touchend`]));
} }), va = V(F({ __name: `MapControls`, setup(e2) {
  return (e3, t2) => (N(), U(`div`, null, [R(A(ie), { position: `top-left` }), R(A(C), { position: `top-left` }), R(A(se), { position: `bottom-left` })]));
} }), [[`__scopeId`, `data-v-ad570dc0`]]), ya = [`title`, `onClick`], ba = V(F({ __name: `DrawingTools`, props: { activeDrawMethod: {} }, emits: [`update:activeDrawMethod`, `setDrawMode`], setup(e2, { emit: t2 }) {
  let { t: n2 } = at(), r2 = new Dt().isMobile, i2 = [{ mode: new Si(), name: n2(`trackerView.terraDrawTools.point`), icon: nt }, { mode: new gi(), name: n2(`trackerView.terraDrawTools.line`), icon: Ht }, { mode: new Gi({ allowManualDeselection: true, flags: { point: { feature: { draggable: true } }, polygon: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, linestring: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, freehand: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, circle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, rectangle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } } } }), name: n2(`trackerView.terraDrawTools.select`), icon: Bt }], a2 = e2, o2 = t2, s2 = (e3) => {
    a2.activeDrawMethod === e3.mode ? (o2(`setDrawMode`, `select`), o2(`update:activeDrawMethod`, `select`)) : (o2(`update:activeDrawMethod`, e3.mode), o2(`setDrawMode`, e3.mode));
  };
  return (t3, n3) => A(r2) ? P(``, true) : (N(), k(A(ce), { key: 0, position: `top-right` }, { default: W(() => [(N(), U(et, null, Xe(i2, (t4) => B(`button`, { key: t4.name, class: H([`btn-control`, { active: t4.mode.mode === e2.activeDrawMethod }]), title: t4.name, onClick: (e3) => s2(t4.mode) }, [R(A(Ot), { size: 20 }, { default: W(() => [(N(), k(Ie(t4.icon), { class: `btn-default` }))]), _: 2 }, 1024)], 10, ya)), 64))]), _: 1 }));
} }), [[`__scopeId`, `data-v-0c23bdfa`]]), xa = `data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'%20?%3e%3c!DOCTYPE%20svg%20PUBLIC%20'-//W3C//DTD%20SVG%201.1//EN'%20'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg%20width='337pt'%20height='570pt'%20viewBox='0%200%20337%20570'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='%23010101ff'%3e%3c/g%3e%3cg%20id='%23fefefeff'%3e%3cpath%20fill='%23fefefe'%20opacity='1.00'%20d='%20M%20166.30%2034.31%20C%20170.55%2032.66%20175.49%2034.16%20177.91%2038.06%20C%20207.78%2088.56%20237.82%20138.97%20267.41%20189.64%20C%20272.78%20198.93%20278.71%20207.92%20283.33%20217.62%20C%20287.47%20225.84%20291.89%20234.58%20291.29%20244.05%20C%20290.88%20251.07%20284.88%20258.19%20277.33%20256.73%20C%20262.96%20252.68%20250.07%20244.73%20235.92%20240.03%20C%20214.99%20231.74%20192.42%20228.24%20170.00%20227.63%20C%20148.91%20228.22%20127.73%20231.43%20107.84%20238.63%20C%2092.90%20243.30%2079.32%20251.36%2064.47%20256.24%20C%2059.30%20258.15%2052.76%20255.48%2050.66%20250.31%20C%2046.78%20243.23%2049.19%20234.81%2051.89%20227.76%20C%2056.51%20217.17%2062.04%20206.98%2068.16%20197.18%20C%2098.26%20145.68%20128.69%2094.38%20159.14%2043.09%20C%20160.98%2039.80%20162.80%2036.10%20166.30%2034.31%20M%20165.46%2076.51%20C%20161.14%2084.39%20156.35%2091.99%20151.68%2099.66%20C%20146.23%20109.46%20140.40%20119.03%20134.68%20128.66%20C%20119.48%20155.09%20104.18%20181.47%2088.70%20207.74%20C%2086.55%20211.59%2083.58%20214.95%2081.76%20218.99%20C%2081.46%20221.46%2084.20%20221.79%2085.93%20221.02%20C%2093.56%20218.30%20100.92%20214.75%20108.82%20212.83%20C%20115.18%20211.22%20121.55%20209.66%20127.87%20207.89%20C%20150.73%20202.18%20174.79%20200.91%20198.04%20204.96%20C%20208.80%20206.29%20219.05%20209.99%20229.58%20212.41%20C%20237.78%20214.21%20245.35%20217.94%20253.21%20220.76%20C%20254.77%20221.45%20256.47%20221.24%20258.11%20221.06%20C%20258.49%20217.46%20255.67%20214.84%20254.00%20211.98%20C%20250.02%20205.59%20246.07%20199.18%20242.44%20192.58%20C%20220.66%20155.66%20199.60%20118.31%20177.40%2081.64%20C%20175.00%2077.57%20172.96%2073.26%20170.00%2069.54%20C%20168.29%2071.72%20166.77%2074.06%20165.46%2076.51%20Z'%20/%3e%3cpath%20fill='%23fefefe'%20opacity='1.00'%20d='%20M%20151.49%20254.95%20C%20168.99%20253.67%20186.81%20253.49%20204.06%20257.20%20C%20231.32%20262.97%20256.80%20276.81%20276.54%20296.49%20C%20293.71%20313.66%20306.14%20335.33%20313.41%20358.45%20C%20317.29%20371.60%20319.91%20385.24%20319.78%20398.99%20C%20321.35%20441.96%20301.66%20484.35%20269.99%20512.99%20C%20242.00%20538.39%20203.57%20551.09%20166.00%20549.73%20C%20133.58%20548.88%20101.34%20537.42%2076.23%20516.74%20C%2050.26%20494.62%2031.18%20463.95%2024.80%20430.27%20C%2021.58%20416.77%2021.93%20402.83%2022.47%20389.07%20C%2025.30%20359.23%2037.09%20330.28%2055.98%20306.99%20C%2079.44%20278.07%20114.56%20259.24%20151.49%20254.95%20M%20154.41%20286.41%20C%20133.59%20288.80%20113.47%20297.07%2096.91%20309.90%20C%2081.77%20321.39%2070.09%20337.09%2062.38%20354.40%20C%2053.40%20373.52%2050.49%20395.10%2052.40%20416.04%20C%2055.41%20439.33%2065.12%20461.74%2080.46%20479.57%20C%2096.06%20498.43%20118.19%20511.54%20141.99%20516.98%20C%20179.65%20526.00%20222.00%20516.17%20250.33%20489.33%20C%20272.99%20467.84%20287.59%20437.39%20288.11%20405.99%20C%20289.17%20369.33%20272.14%20332.49%20243.21%20309.87%20C%20231.81%20301.36%20219.11%20294.50%20205.43%20290.50%20C%20188.99%20285.41%20171.44%20284.58%20154.41%20286.41%20Z'%20/%3e%3c/g%3e%3cg%20id='%234da0e9ff'%3e%3cpath%20fill='%234da0e9'%20opacity='1.00'%20d='%20M%20165.46%2076.51%20C%20166.77%2074.06%20168.29%2071.72%20170.00%2069.54%20C%20172.96%2073.26%20175.00%2077.57%20177.40%2081.64%20C%20199.60%20118.31%20220.66%20155.66%20242.44%20192.58%20C%20246.07%20199.18%20250.02%20205.59%20254.00%20211.98%20C%20255.67%20214.84%20258.49%20217.46%20258.11%20221.06%20C%20256.47%20221.24%20254.77%20221.45%20253.21%20220.76%20C%20245.35%20217.94%20237.78%20214.21%20229.58%20212.41%20C%20219.05%20209.99%20208.80%20206.29%20198.04%20204.96%20C%20174.79%20200.91%20150.73%20202.18%20127.87%20207.89%20C%20121.55%20209.66%20115.18%20211.22%20108.82%20212.83%20C%20100.92%20214.75%2093.56%20218.30%2085.93%20221.02%20C%2084.20%20221.79%2081.46%20221.46%2081.76%20218.99%20C%2083.58%20214.95%2086.55%20211.59%2088.70%20207.74%20C%20104.18%20181.47%20119.48%20155.09%20134.68%20128.66%20C%20140.40%20119.03%20146.23%20109.46%20151.68%2099.66%20C%20156.35%2091.99%20161.14%2084.39%20165.46%2076.51%20Z'%20/%3e%3cpath%20fill='%234da0e9'%20opacity='1.00'%20d='%20M%20154.41%20286.41%20C%20171.44%20284.58%20188.99%20285.41%20205.43%20290.50%20C%20219.11%20294.50%20231.81%20301.36%20243.21%20309.87%20C%20272.14%20332.49%20289.17%20369.33%20288.11%20405.99%20C%20287.59%20437.39%20272.99%20467.84%20250.33%20489.33%20C%20222.00%20516.17%20179.65%20526.00%20141.99%20516.98%20C%20118.19%20511.54%2096.06%20498.43%2080.46%20479.57%20C%2065.12%20461.74%2055.41%20439.33%2052.40%20416.04%20C%2050.49%20395.10%2053.40%20373.52%2062.38%20354.40%20C%2070.09%20337.09%2081.77%20321.39%2096.91%20309.90%20C%20113.47%20297.07%20133.59%20288.80%20154.41%20286.41%20Z'%20/%3e%3c/g%3e%3c/svg%3e`, Sa = { style: { filter: `drop-shadow(0px 2px 4px #888)` } }, Ca = [`src`], wa = F({ __name: `LocationMarker`, props: { isWatchingCurrentLocation: { type: Boolean }, deviceBearing: {} }, setup(e2) {
  let t2 = tt(`geolocation`), n2 = E((t2 == null ? void 0 : t2.getLastKnownLocation()) || null), r2 = null;
  Me(() => {
    t2 && (r2 = t2.addLocationListener((e3) => {
      n2.value = e3;
    }));
  }), Le(() => {
    r2 !== null && t2 && t2.removeLocationListener(r2);
  });
  let i2 = L(() => n2.value ? n2.value.toLngLatLike() : [0, 0]);
  return (r3, a2) => A(t2) && A(t2).isServiceRunning() && e2.isWatchingCurrentLocation && n2.value ? (N(), k(A(ue), { key: 0, coordinates: i2.value }, { marker: W(() => [B(`div`, Sa, [B(`img`, { src: A(xa), style: I({ height: `4em`, width: `4em`, transform: `rotate(${e2.deviceBearing}deg)`, "transform-origin": `2em 2.83em` }) }, null, 12, Ca)])]), _: 1 }, 8, [`coordinates`])) : P(``, true);
} }), Ta = V(F({ __name: `RecordingButton`, props: { isRecording: { type: Boolean }, recordTimespan: {}, isRouteDrawerOpen: { type: Boolean } }, emits: [`toggleRecording`], setup(e2, { emit: t2 }) {
  He((e3) => {
    var _a2, _b;
    return { v5507afc2: (_a2 = A(ut).Button.common) == null ? void 0 : _a2.primaryColorSuppl, v6d610bb6: (_b = A(ut).Button.common) == null ? void 0 : _b.errorColorSuppl };
  });
  let { t: n2 } = at(), r2 = new Dt().isMobile, i2 = t2;
  return (t3, a2) => A(r2) ? (N(), U(`div`, { key: 0, class: H([`mobile-record-button-container`, { "drawer-open": e2.isRouteDrawerOpen }]) }, [R(A(ot), { theme: A(ut) }, { default: W(() => [R(A(gt), { type: e2.isRecording ? `error` : `primary`, size: `large`, class: H([`mobile-record-button`, e2.isRecording ? `recording` : `not-recording`]), onClick: a2[0] || (a2[0] = (e3) => i2(`toggleRecording`)) }, { icon: W(() => [R(A(Ot), { size: 20 }, { default: W(() => [(N(), k(Ie(e2.isRecording ? A(Kt) : A(Wt)), { size: e2.isRecording ? 16 : 20 }, null, 8, [`size`]))]), _: 1 })]), default: W(() => [j(` ` + z(e2.isRecording ? A(n2)(`trackerView.uiRecordingStatus.on`) : A(n2)(`trackerView.uiRecordingStatus.off`)), 1)]), _: 1 }, 8, [`type`, `class`])]), _: 1 }, 8, [`theme`])], 2)) : P(``, true);
} }), [[`__scopeId`, `data-v-e8aa3504`]]), Ea = { key: 0, class: `status-item` }, Da = { key: 1, class: `status-item` }, Oa = { key: 2, class: `status-item` }, ka = { class: `status-item` }, Aa = V(F({ __name: `StatusBar`, props: { isRecording: { type: Boolean }, recordTimespan: {}, isRouteDrawerOpen: { type: Boolean }, currentLocation: {} }, setup(e2) {
  let { t: t2 } = at(), n2 = new Dt().isMobile, r2 = Yn(), i2 = e2, a2 = L(() => r2.currentRouteId ? r2.routes.find((e3) => e3.id === r2.currentRouteId) : null), o2 = L(() => {
    var _a2;
    return ((_a2 = a2.value) == null ? void 0 : _a2.meta.distance) ? a2.value.meta.distance : 0;
  }), s2 = L(() => {
    if (!i2.isRecording || !i2.currentLocation) return null;
    let e3 = i2.currentLocation.accuracy || 10;
    return Math.max(0.1, Math.min(0.9, 1 / (1 + e3 / 10))).toFixed(2);
  });
  function c2(e3) {
    let t3 = e3 / 1e3, n3 = t3 / 60, r3 = n3 / 60, i3 = t3 % 60, a3 = n3 % 60, o3 = r3, s3 = ``;
    return Math.floor(o3) > 0 && (s3 += `${String(Math.floor(o3))}h `), Math.floor(a3) > 0 && (s3 += `${String(Math.floor(a3))}m `), s3 += `${String(i3.toFixed(1)).padStart(4, `0`)}s`, s3;
  }
  function l2(e3) {
    return e3 < 1e3 ? `${Math.round(e3)}m` : `${(e3 / 1e3).toFixed(2)}km`;
  }
  return (r3, i3) => A(n2) ? (N(), U(`div`, { key: 0, class: H([`mobile-status-bar`, { "drawer-open": e2.isRouteDrawerOpen }]) }, [R(A(ot), { theme: A(ut) }, { default: W(() => [R(A(kt), { size: 16, align: `center`, justify: `center` }, { default: W(() => [e2.isRecording && e2.recordTimespan ? (N(), U(`div`, Ea, [R(A(it), { class: `status-label` }, { default: W(() => [j(z(A(t2)(`trackerView.statusBar.recordingTime`)) + `: `, 1)]), _: 1 }), R(A(it), { class: `status-value recording-time` }, { default: W(() => [j(z(c2(e2.recordTimespan)), 1)]), _: 1 })])) : P(``, true), o2.value > 0 ? (N(), U(`div`, Da, [R(A(it), { class: `status-label` }, { default: W(() => [j(z(A(t2)(`trackerView.statusBar.distance`)) + `: `, 1)]), _: 1 }), R(A(it), { class: `status-value` }, { default: W(() => [j(z(l2(o2.value)), 1)]), _: 1 })])) : P(``, true), e2.isRecording && s2.value && e2.currentLocation ? (N(), U(`div`, Oa, [R(A(it), { class: `status-label` }, { default: W(() => [j(z(A(t2)(`trackerView.statusBar.kalmanGain`)) + `: `, 1)]), _: 1 }), R(A(it), { class: `status-value kalman-gain` }, { default: W(() => [j(z(s2.value), 1)]), _: 1 })])) : P(``, true), B(`div`, ka, [R(A(it), { class: `status-label` }, { default: W(() => [j(z(A(t2)(`trackerView.statusBar.gps`)) + `: `, 1)]), _: 1 }), R(A(it), { class: H([`status-value`, `gps-status`, e2.currentLocation ? `gps-active` : `gps-inactive`]) }, { default: W(() => [j(z(e2.currentLocation ? `GPS` : `No GPS`), 1)]), _: 1 }, 8, [`class`])])]), _: 1 })]), _: 1 }, 8, [`theme`])], 2)) : P(``, true);
} }), [[`__scopeId`, `data-v-d7ab4f5e`]]), ja = V(F({ __name: `BuildingLayerToggle`, props: { isShowingBuildingLayer: { type: Boolean } }, emits: [`toggle`], setup(e2, { emit: t2 }) {
  let n2 = t2, r2 = () => {
    n2(`toggle`);
  };
  return (t3, n3) => (N(), k(A(ce), { position: `top-left` }, { default: W(() => [B(`button`, { class: H([`btn-control`, { active: e2.isShowingBuildingLayer }]), onClick: r2 }, [R(A(Ot), { size: 20 }, { default: W(() => [R(A(It))]), _: 1 })], 2)]), _: 1 }));
} }), [[`__scopeId`, `data-v-c189f5ba`]]), Ma = V(F({ __name: `CurrentLocationToggle`, props: { locator: {}, isWatchingCurrentLocation: { type: Boolean } }, emits: [`toggle`], setup(e2, { emit: t2 }) {
  let n2 = new Dt().isMobile, r2 = t2, i2 = () => {
    r2(`toggle`);
  };
  return (t3, r3) => (N(), k(A(ce), { position: `top-left` }, { default: W(() => [A(n2) && e2.locator.isUsingGPS() ? (N(), U(`button`, { key: 0, class: H([`btn-control`, { active: e2.isWatchingCurrentLocation }]), onClick: i2 }, [R(A(Ot), { size: 20 }, { default: W(() => [R(A(Rt))]), _: 1 })], 2)) : P(``, true)]), _: 1 }));
} }), [[`__scopeId`, `data-v-afaa8b50`]]), Na = class extends ma.TerraDrawBaseAdapter {
  constructor(e2) {
    super(e2), this._renderBeforeLayerId = void 0, this._prefixId = void 0, this._initialDragPan = void 0, this._initialDragRotate = void 0, this._nextRender = void 0, this._map = void 0, this._container = void 0, this.changedIds = { deletion: false, points: false, linestrings: false, polygons: false, styling: false }, this._map = e2.map, this._container = this._map.getContainer(), this._initialDragRotate = this._map.dragRotate.isEnabled(), this._initialDragPan = this._map.dragPan.isEnabled(), this._renderBeforeLayerId = e2.renderBelowLayerId, this._prefixId = e2.prefixId || `td`;
  }
  hashCode(e2) {
    let t2 = 0;
    for (let n2 = 0; n2 < e2.length; n2++) t2 = (t2 << 5) - t2 + e2.charCodeAt(n2), t2 |= 0;
    return Math.abs(t2);
  }
  resizeImage(e2, t2, n2, r2) {
    let i2 = new Image();
    i2.crossOrigin = `anonymous`, i2.onload = () => {
      let e3 = document.createElement(`canvas`);
      e3.width = t2, e3.height = n2;
      let a2 = e3.getContext(`2d`);
      if (!a2) throw Error(`Could not get canvas context`);
      a2.drawImage(i2, 0, 0, t2, n2), r2(e3.toDataURL());
    }, i2.src = e2;
  }
  _addGeoJSONSource(e2, t2) {
    this._map.addSource(e2, { type: `geojson`, data: { type: `FeatureCollection`, features: t2 }, tolerance: 0 });
  }
  _addFillLayer(e2) {
    return this._map.addLayer({ id: e2, source: e2, type: `fill`, layout: { "fill-sort-key": [`get`, `zIndex`] }, paint: { "fill-color": [`get`, `polygonFillColor`], "fill-opacity": [`get`, `polygonFillOpacity`] } });
  }
  _addFillOutlineLayer(e2) {
    return this._map.addLayer({ id: e2 + `-outline`, source: e2, type: `line`, layout: { "line-sort-key": [`get`, `zIndex`] }, paint: { "line-width": [`get`, `polygonOutlineWidth`], "line-color": [`get`, `polygonOutlineColor`] } });
  }
  _addLineLayer(e2) {
    return this._map.addLayer({ id: e2, source: e2, type: `line`, layout: { "line-sort-key": [`get`, `zIndex`] }, paint: { "line-width": [`get`, `lineStringWidth`], "line-color": [`get`, `lineStringColor`] } });
  }
  _addPointLayer(e2) {
    return this._map.addLayer({ id: e2, source: e2, type: `circle`, layout: { "circle-sort-key": [`get`, `zIndex`] }, paint: { "circle-stroke-color": [`get`, `pointOutlineColor`], "circle-stroke-width": [`get`, `pointOutlineWidth`], "circle-radius": [`get`, `pointWidth`], "circle-color": [`get`, `pointColor`] } });
  }
  _addMarkerLayer(e2) {
    return this._map.addLayer({ id: e2 + `-marker`, source: e2, type: `symbol`, filter: [`has`, `markerId`], layout: { "icon-image": [`image`, [`get`, `markerId`]], "icon-anchor": `bottom`, "icon-allow-overlap": true } });
  }
  _addLayer(e2, t2) {
    t2 === `Point` && (this._addPointLayer(e2), this._addMarkerLayer(e2)), t2 === `LineString` && this._addLineLayer(e2), t2 === `Polygon` && (this._addFillLayer(e2), this._addFillOutlineLayer(e2));
  }
  _addGeoJSONLayer(e2, t2) {
    let n2 = `${this._prefixId}-${e2.toLowerCase()}`;
    return this._addGeoJSONSource(n2, t2), this._addLayer(n2, e2), n2;
  }
  _setGeoJSONLayerData(e2, t2) {
    let n2 = `${this._prefixId}-${e2.toLowerCase()}`;
    return this._map.getSource(n2).setData({ type: `FeatureCollection`, features: t2 }), n2;
  }
  updateChangedIds(e2) {
    [...e2.updated, ...e2.created].forEach((e3) => {
      e3.geometry.type === `Point` ? this.changedIds.points = true : e3.geometry.type === `LineString` ? this.changedIds.linestrings = true : e3.geometry.type === `Polygon` && (this.changedIds.polygons = true);
    }), e2.deletedIds.length > 0 && (this.changedIds.deletion = true), e2.created.length === 0 && e2.updated.length === 0 && e2.deletedIds.length === 0 && (this.changedIds.styling = true);
  }
  getLngLatFromEvent(e2) {
    let { left: t2, top: n2 } = this._container.getBoundingClientRect();
    return this.unproject(e2.clientX - t2, e2.clientY - n2);
  }
  getMapEventElement() {
    return this._map.getCanvas();
  }
  setDraggability(e2) {
    e2 ? (this._initialDragRotate && this._map.dragRotate.enable(), this._initialDragPan && this._map.dragPan.enable()) : (this._initialDragRotate && this._map.dragRotate.disable(), this._initialDragPan && this._map.dragPan.disable());
  }
  project(e2, t2) {
    let { x: n2, y: r2 } = this._map.project({ lng: e2, lat: t2 });
    return { x: n2, y: r2 };
  }
  unproject(e2, t2) {
    let { lng: n2, lat: r2 } = this._map.unproject({ x: e2, y: t2 });
    return { lng: n2, lat: r2 };
  }
  setCursor(e2) {
    let t2 = this._map.getCanvas();
    e2 === `unset` ? t2.style.removeProperty(`cursor`) : t2.style.cursor = e2;
  }
  setDoubleClickToZoom(e2) {
    e2 ? this._map.doubleClickZoom.enable() : this._map.doubleClickZoom.disable();
  }
  render(e2, t2) {
    this.updateChangedIds(e2), this._nextRender && cancelAnimationFrame(this._nextRender), this._nextRender = requestAnimationFrame(() => {
      if (!this._currentModeCallbacks) return;
      let n2 = [...e2.created, ...e2.updated, ...e2.unchanged], r2 = [], i2 = [], a2 = [];
      for (let e3 = 0; e3 < n2.length; e3++) {
        let o3 = n2[e3], { properties: s3 } = o3, c3 = t2[s3.mode](o3);
        if (s3.zIndex = c3.zIndex, s3.zIndex = c3.zIndex, o3.geometry.type === `Point`) {
          if (s3.pointColor = c3.pointColor, s3.pointOutlineColor = c3.pointOutlineColor, s3.pointOutlineWidth = c3.pointOutlineWidth, s3.pointWidth = c3.pointWidth, c3.markerUrl && c3.markerWidth && c3.markerHeight) {
            let e4 = `marker-${this.hashCode(c3.markerUrl)}`;
            this._map.hasImage(e4) || this.resizeImage(c3.markerUrl, c3.markerWidth, c3.markerHeight, (t3) => {
              this._map.loadImage(t3).then((t4) => {
                this._map.hasImage(e4) || this._map.addImage(e4, t4.data);
              });
            }), s3.markerId = e4, s3.pointWidth = 0;
          }
          r2.push(o3);
        } else o3.geometry.type === `LineString` ? (s3.lineStringColor = c3.lineStringColor, s3.lineStringWidth = c3.lineStringWidth, i2.push(o3)) : o3.geometry.type === `Polygon` && (s3.polygonFillColor = c3.polygonFillColor, s3.polygonFillOpacity = c3.polygonFillOpacity, s3.polygonOutlineColor = c3.polygonOutlineColor, s3.polygonOutlineWidth = c3.polygonOutlineWidth, a2.push(o3));
      }
      let o2 = this.changedIds.deletion || this.changedIds.styling, s2 = o2 || this.changedIds.linestrings, c2 = o2 || this.changedIds.polygons;
      (o2 || this.changedIds.points) && this._setGeoJSONLayerData(`Point`, r2), s2 && this._setGeoJSONLayerData(`LineString`, i2), c2 && this._setGeoJSONLayerData(`Polygon`, a2), this.changedIds = { points: false, linestrings: false, polygons: false, deletion: false, styling: false };
    });
  }
  clear() {
    this._currentModeCallbacks && (this._currentModeCallbacks.onClear(), this._nextRender && (this._nextRender = (cancelAnimationFrame(this._nextRender), void 0)), this._setGeoJSONLayerData(`Point`, []), this._setGeoJSONLayerData(`LineString`, []), this._setGeoJSONLayerData(`Polygon`, []));
  }
  getCoordinatePrecision() {
    return super.getCoordinatePrecision();
  }
  unregister() {
    super.unregister(), this.changedIds = { points: false, linestrings: false, polygons: false, deletion: false, styling: false }, this._map.removeLayer(`${this._prefixId}-point`), this._map.removeLayer(`${this._prefixId}-point-marker`), this._map.removeSource(`${this._prefixId}-point`), this._map.removeLayer(`${this._prefixId}-linestring`), this._map.removeSource(`${this._prefixId}-linestring`), this._map.removeLayer(`${this._prefixId}-polygon`), this._map.removeLayer(`${this._prefixId}-polygon-outline`), this._map.removeSource(`${this._prefixId}-polygon`);
  }
  register(e2) {
    var t2;
    super.register(e2);
    let n2 = this._addGeoJSONLayer(`Polygon`, []), r2 = this._addGeoJSONLayer(`LineString`, []), i2 = this._addGeoJSONLayer(`Point`, []);
    var a2;
    this._renderBeforeLayerId && (this._map.moveLayer(i2, this._renderBeforeLayerId), this._map.moveLayer(r2, i2), this._map.moveLayer(`${n2}-outline`, r2), this._map.moveLayer(n2, `${n2}-outline`)), (t2 = this._currentModeCallbacks) != null && t2.onReady && ((a2 = this._currentModeCallbacks) == null || a2.onReady());
  }
}, Pa = { class: `map-layout-container` }, Fa = { class: `map-layout` }, Ia = { key: 0, style: { width: `100%`, height: `100%` } }, La = { style: { "z-index": `99`, position: `absolute`, right: `4px`, top: `9em` } }, Ra = { key: 1, style: { width: `100%`, height: `100%`, display: `grid`, "place-content": `center` } }, za = V(F({ __name: `TrackerView`, setup(e2) {
  He((e3) => {
    var _a2;
    return { f8be3436: (_a2 = A(ut).Button.common) == null ? void 0 : _a2.successColorSuppl, ab953752: A(n2).boxShadow3, v3d627dad: A(n2).borderRadius, f561e230: A(n2).borderColor };
  });
  let t2 = new Dt().isMobile, n2 = At(), r2 = wr(), i2 = T(), a2 = tt(`geolocation`), { t: o2 } = at(), s2 = Ue(null), c2 = Ue(null), l2 = E(`select`), u2 = Yn();
  u2.setLocator(a2);
  let d2 = tt(`noSleep`), f2 = L(() => {
    var _a2;
    return u2.currentRouteId && ((_a2 = u2.routes.find((e3) => e3.id === u2.currentRouteId)) == null ? void 0 : _a2.points) || [];
  }), p2 = E(false), m2 = L(() => f2.value.length > 1 || f2.value.length === 0 ? { type: `FeatureCollection`, features: [{ type: `Feature`, properties: { description: u2.currentRouteId }, geometry: { type: `LineString`, coordinates: f2.value.map((e3) => [e3.longitude, e3.latitude]) } }] } : { type: `FeatureCollection`, features: [] }), h2 = [{ mode: new Si(), name: o2(`trackerView.terraDrawTools.point`), icon: nt }, { mode: new gi(), name: o2(`trackerView.terraDrawTools.line`), icon: Ht }, { mode: new Gi({ allowManualDeselection: true, flags: { point: { feature: { draggable: true } }, polygon: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, linestring: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, freehand: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, circle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } }, rectangle: { feature: { draggable: true, coordinates: { midpoints: true, draggable: true, deletable: true } } } } }), name: o2(`trackerView.terraDrawTools.select`), icon: Bt }], g2 = E(false), _2 = E(true), v2 = /* @__PURE__ */ (() => {
    let e3 = true;
    return async function() {
      try {
        u2.isRecording || (e3 = u2.currentRouteId === null), await u2.toggleRecording(o2), !u2.isRecording && e3 && (C2.value = true, setTimeout(() => {
          C2.value = false;
        }, 3e3)), u2.isRecording ? d2.enable() : d2.disable();
      } catch (e4) {
        console.error(e4), d2.disable();
      }
    };
  })(), y2 = E(async () => {
  });
  function b2() {
    S2.value = false, i2.warning(`Not implemented yet`);
  }
  let x2 = E(0), S2 = E(false);
  D(S2, (e3) => {
    var _a2;
    let n3 = (_a2 = s2.value) == null ? void 0 : _a2.map;
    n3 && n3.easeTo({ padding: t2 ? { bottom: e3 ? x2.value : 0 } : { left: e3 ? x2.value : 0 }, duration: 500 });
  });
  let ee2 = () => S2.value = !S2.value, C2 = E(false), w2 = E(false), te2 = E(0), ne2 = E(false), { bearing: re2, isTracking: ie2, isSupported: ae2, error: oe2, startTracking: se2, stopTracking: le2 } = Kn({ autoStart: true });
  D(re2, (e3) => {
    te2.value = e3;
  }), Me(async () => {
    if (await u2.init(), await r2.init(), Date.now() - r2.lastUpdateTime > 6e3 && r2.lastUpdateTime !== 0) {
      let e3 = a2.getLastKnownLocation();
      e3.latitude !== 0 || e3.longitude !== 0 ? r2.setCenter(e3) : console.warn(`[TrackerView] No valid last known location available, skipping map center update`);
    }
    w2.value = true;
  }), setInterval(() => {
    a2.getLastKalmanGain();
  });
  let ue2 = 0, de2 = (e3) => {
    var _a2;
    if (ue2 = e3, r2.isTrackingOrientation) {
      let t3 = (_a2 = s2.value) == null ? void 0 : _a2.map;
      if ((t3 == null ? void 0 : t3.isEasing()) || (t3 == null ? void 0 : t3.isMoving()) || (t3 == null ? void 0 : t3.isRotating()) || (t3 == null ? void 0 : t3.isZooming()) || ne2.value) return;
      r2.setBearing(e3);
    }
  }, fe2 = () => {
    var _a2;
    if (r2.setTrackingOrientation(!r2.isTrackingOrientation), r2.isTrackingOrientation) se2();
    else {
      le2(), r2.setBearing(0);
      let e3 = (_a2 = s2.value) == null ? void 0 : _a2.map;
      e3 && e3.setBearing(0);
    }
  }, pe2 = (e3) => {
    c2.value = new ga({ adapter: new Na({ map: e3.map }), modes: h2.map((e4) => e4.mode) }), c2.value.start();
  }, he2 = () => {
    ne2.value = true;
  }, ge2 = () => {
    ne2.value = false, r2.isTrackingOrientation && de2(ue2);
  }, _e2 = () => {
    S2.value = false;
  }, ve2 = (e3) => {
    c2.value && (e3 === `select` ? (c2.value.setMode(`select`), l2.value = `select`) : (l2.value = e3, c2.value.start(), c2.value.setMode(e3)));
  }, ye2 = () => {
    var _a2;
    if (_2.value = !_2.value, _2.value) {
      let e3 = (_a2 = s2.value) == null ? void 0 : _a2.map;
      if (e3) {
        let t3 = a2.getLastKnownLocation();
        t3.latitude !== 0 || t3.longitude !== 0 ? e3.flyTo({ center: t3.toLngLatLike(), zoom: 18 }) : console.warn(`[TrackerView] No valid current location available for navigation`);
      }
    }
  }, be2 = () => {
    var _a2, _b, _c;
    g2.value = !g2.value;
    let e3 = (_a2 = s2.value) == null ? void 0 : _a2.map;
    e3 && (g2.value ? (_b = s2.value) == null ? void 0 : _b.setupBuildingLayer(e3) : (_c = s2.value) == null ? void 0 : _c.removeBuildingLayer(e3));
  };
  return (e3, n3) => (N(), U(`div`, Pa, [B(`div`, Fa, [R(Pe, { name: `map-load` }, { default: W(() => [w2.value ? (N(), U(`div`, Ia, [R(_a, { ref_key: `mapContainerRef`, ref: s2, "style-url": `https://api.maptiler.com/maps/basic-v2/style.json?key=dCeXFrS9lgSF8hm5C6nm`, "geojson-source": m2.value, "drawer-modes": h2, "on-map-init": pe2, "on-map-touch-start": he2, "on-map-touch-end": ge2, "on-map-click": _e2 }, { default: W(() => [R(va), R(Ma, { locator: A(a2), "is-watching-current-location": _2.value, onToggle: ye2 }, null, 8, [`locator`, `is-watching-current-location`]), R(ja, { "is-showing-building-layer": g2.value, onToggle: be2 }, null, 8, [`is-showing-building-layer`]), R(ba, { "active-draw-method": l2.value, "onUpdate:activeDrawMethod": n3[0] || (n3[0] = (e4) => l2.value = e4), onSetDrawMode: ve2 }, null, 8, [`active-draw-method`]), R(A(ce), { position: `bottom-left` }, { default: W(() => [R(A(Se), { trigger: `manual`, show: C2.value }, { trigger: W(() => [B(`button`, { class: H([`btn-control`, { active: S2.value }]), onClick: ee2 }, [R(A(Ot), { size: 24 }, { default: W(() => [R(A(me))]), _: 1 })], 2)]), default: W(() => [B(`span`, null, z(A(o2)(`trackerView.uiRouteCheckoutTip`)), 1)]), _: 1 }, 8, [`show`])]), _: 1 }), R(wa, { "is-watching-current-location": _2.value, "device-bearing": te2.value }, null, 8, [`is-watching-current-location`, `device-bearing`]), P(``, true)]), _: 1 }, 8, [`geojson-source`]), B(`div`, La, [A(t2) ? (N(), k(Jn, { key: 0, bearing: A(r2).bearing, "onUpdate:bearing": n3[1] || (n3[1] = (e4) => A(r2).bearing = e4), tracking: A(r2).isTrackingOrientation, onToggleTracking: fe2 }, null, 8, [`bearing`, `tracking`])) : P(``, true)])])) : (N(), U(`div`, Ra, [R(A(pn), { size: `large` }, { description: W(() => [R(A(it), null, { default: W(() => [j(z(A(o2)(`trackerView.mapLoading`)), 1)]), _: 1 })]), _: 1 })]))]), _: 1 })]), R(Qn, { show: p2.value, "onUpdate:show": n3[2] || (n3[2] = (e4) => p2.value = e4), types: [`application/json`, `text/plain`], onConfirm: y2.value }, null, 8, [`show`, `onConfirm`]), R(Cr, { show: S2.value, "onUpdate:show": n3[3] || (n3[3] = (e4) => S2.value = e4), "onUpdate:width": n3[4] || (n3[4] = (e4) => x2.value = e4) }, { "bottom-floating": W(() => [R(A(ot), { theme: A(ut) }, { default: W(() => [f2.value.length > 1 ? (N(), k(A(gt), { key: 0, size: `large`, type: `success`, class: `drawer-floating-button`, onClick: b2 }, { default: W(() => [...n3[6] || (n3[6] = [j(` Follow `, -1)])]), _: 1 })) : P(``, true)]), _: 1 }, 8, [`theme`])]), _: 1 }, 8, [`show`]), R(Ta, { "is-recording": A(u2).isRecording, "record-timespan": A(u2).currentRouteRecordTimespan, "is-route-drawer-open": S2.value, onToggleRecording: A(v2) }, null, 8, [`is-recording`, `record-timespan`, `is-route-drawer-open`, `onToggleRecording`]), R(Aa, { "is-recording": A(u2).isRecording, "record-timespan": A(u2).currentRouteRecordTimespan, "is-route-drawer-open": S2.value, "current-location": A(a2).getLastKnownLocation() }, null, 8, [`is-recording`, `record-timespan`, `is-route-drawer-open`, `current-location`])]));
} }), [[`__scopeId`, `data-v-de42ed0f`]]);
export {
  za as default
};
