var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { d as z, c as Xe, o as Qe, a as Z, J as hn, h as v, b as k, q as x, i as B, j, F as gn, t as lt, k as Rt, a2 as et, w as ut, p as H, I as we, Y as ct, G as Ye, f as ce, x as je, T as vn, a5 as bn, g as yn, a6 as V, L as wn, Z as _n, $ as P, a0 as O } from "./index-DSvGlfEm.js";
import { i as xn, m as A, n as _, o as L, B as be, l as D, aP as Sn, K as Ae, J as Ge, aF as Cn, V as Rn, w as dt, u as kn, q as kt, aj as zn, E as In, C as ft, p as Mn, t as He, L as An, v as Tn, P as pt, G as E, X as mt, T as zt } from "./light-DfzEfYBd.js";
import { w as Bn, R as En, j as Fn, l as Pn } from "./text-VZIHOOUl.js";
import { N as ht, a as On } from "./Suffix-BlDmlKJv.js";
import { u as jn } from "./use-locale-Dy4qq2qj.js";
import { u as Dn } from "./light-D7aXBowW.js";
import { m as ae } from "./index-CrzEBEnk.js";
const Nn = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Er = z({ name: "Route", render: function(t, o) {
  return Qe(), Xe("svg", Nn, o[0] || (o[0] = [Z("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [Z("circle", { cx: "6", cy: "19", r: "2" }), Z("circle", { cx: "18", cy: "5", r: "2" }), Z("path", { d: "M12 19h4.5a3.5 3.5 0 0 0 0-7h-8a3.5 3.5 0 0 1 0-7H12" })], -1)]));
} }), Ln = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Fr = z({ name: "Trash", render: function(t, o) {
  return Qe(), Xe("svg", Ln, o[0] || (o[0] = [hn('<g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 7h16"></path><path d="M10 11v6"></path><path d="M14 11v6"></path><path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2l1-12"></path><path d="M9 7V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3"></path></g>', 1)]));
} }), $n = { xmlns: "http://www.w3.org/2000/svg", "xmlns:xlink": "http://www.w3.org/1999/xlink", viewBox: "0 0 24 24" }, Pr = z({ name: "Upload", render: function(t, o) {
  return Qe(), Xe("svg", $n, o[0] || (o[0] = [Z("g", { fill: "none", stroke: "currentColor", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" }, [Z("path", { d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2" }), Z("path", { d: "M7 9l5-5l5 5" }), Z("path", { d: "M12 4v12" })], -1)]));
} }), Or = z({ name: "Add", render() {
  return v("svg", { width: "512", height: "512", viewBox: "0 0 512 512", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, v("path", { d: "M256 112V400M400 256H112", stroke: "currentColor", "stroke-width": "32", "stroke-linecap": "round", "stroke-linejoin": "round" }));
} }), Wn = z({ name: "Eye", render() {
  return v("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, v("path", { d: "M255.66 112c-77.94 0-157.89 45.11-220.83 135.33a16 16 0 0 0-.27 17.77C82.92 340.8 161.8 400 255.66 400c92.84 0 173.34-59.38 221.79-135.25a16.14 16.14 0 0 0 0-17.47C428.89 172.28 347.8 112 255.66 112z", fill: "none", stroke: "currentColor", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "32" }), v("circle", { cx: "256", cy: "256", r: "80", fill: "none", stroke: "currentColor", "stroke-miterlimit": "10", "stroke-width": "32" }));
} }), Vn = z({ name: "EyeOff", render() {
  return v("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, v("path", { d: "M432 448a15.92 15.92 0 0 1-11.31-4.69l-352-352a16 16 0 0 1 22.62-22.62l352 352A16 16 0 0 1 432 448z", fill: "currentColor" }), v("path", { d: "M255.66 384c-41.49 0-81.5-12.28-118.92-36.5c-34.07-22-64.74-53.51-88.7-91v-.08c19.94-28.57 41.78-52.73 65.24-72.21a2 2 0 0 0 .14-2.94L93.5 161.38a2 2 0 0 0-2.71-.12c-24.92 21-48.05 46.76-69.08 76.92a31.92 31.92 0 0 0-.64 35.54c26.41 41.33 60.4 76.14 98.28 100.65C162 402 207.9 416 255.66 416a239.13 239.13 0 0 0 75.8-12.58a2 2 0 0 0 .77-3.31l-21.58-21.58a4 4 0 0 0-3.83-1a204.8 204.8 0 0 1-51.16 6.47z", fill: "currentColor" }), v("path", { d: "M490.84 238.6c-26.46-40.92-60.79-75.68-99.27-100.53C349 110.55 302 96 255.66 96a227.34 227.34 0 0 0-74.89 12.83a2 2 0 0 0-.75 3.31l21.55 21.55a4 4 0 0 0 3.88 1a192.82 192.82 0 0 1 50.21-6.69c40.69 0 80.58 12.43 118.55 37c34.71 22.4 65.74 53.88 89.76 91a.13.13 0 0 1 0 .16a310.72 310.72 0 0 1-64.12 72.73a2 2 0 0 0-.15 2.95l19.9 19.89a2 2 0 0 0 2.7.13a343.49 343.49 0 0 0 68.64-78.48a32.2 32.2 0 0 0-.1-34.78z", fill: "currentColor" }), v("path", { d: "M256 160a95.88 95.88 0 0 0-21.37 2.4a2 2 0 0 0-1 3.38l112.59 112.56a2 2 0 0 0 3.38-1A96 96 0 0 0 256 160z", fill: "currentColor" }), v("path", { d: "M165.78 233.66a2 2 0 0 0-3.38 1a96 96 0 0 0 115 115a2 2 0 0 0 1-3.38z", fill: "currentColor" }));
} }), It = xn("n-input"), Un = A("input", `
 max-width: 100%;
 cursor: text;
 line-height: 1.5;
 z-index: auto;
 outline: none;
 box-sizing: border-box;
 position: relative;
 display: inline-flex;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color .3s var(--n-bezier);
 font-size: var(--n-font-size);
 font-weight: var(--n-font-weight);
 --n-padding-vertical: calc((var(--n-height) - 1.5 * var(--n-font-size)) / 2);
`, [_("input, textarea", `
 overflow: hidden;
 flex-grow: 1;
 position: relative;
 `), _("input-el, textarea-el, input-mirror, textarea-mirror, separator, placeholder", `
 box-sizing: border-box;
 font-size: inherit;
 line-height: 1.5;
 font-family: inherit;
 border: none;
 outline: none;
 background-color: #0000;
 text-align: inherit;
 transition:
 -webkit-text-fill-color .3s var(--n-bezier),
 caret-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 `), _("input-el, textarea-el", `
 -webkit-appearance: none;
 scrollbar-width: none;
 width: 100%;
 min-width: 0;
 text-decoration-color: var(--n-text-decoration-color);
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 background-color: transparent;
 `, [D("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), D("&::placeholder", `
 color: #0000;
 -webkit-text-fill-color: transparent !important;
 `), D("&:-webkit-autofill ~", [_("placeholder", "display: none;")])]), L("round", [be("textarea", "border-radius: calc(var(--n-height) / 2);")]), _("placeholder", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: hidden;
 color: var(--n-placeholder-color);
 `, [D("span", `
 width: 100%;
 display: inline-block;
 `)]), L("textarea", [_("placeholder", "overflow: visible;")]), be("autosize", "width: 100%;"), L("autosize", [_("textarea-el, input-el", `
 position: absolute;
 top: 0;
 left: 0;
 height: 100%;
 `)]), A("input-wrapper", `
 overflow: hidden;
 display: inline-flex;
 flex-grow: 1;
 position: relative;
 padding-left: var(--n-padding-left);
 padding-right: var(--n-padding-right);
 `), _("input-mirror", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre;
 pointer-events: none;
 `), _("input-el", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [D("&[type=password]::-ms-reveal", "display: none;"), D("+", [_("placeholder", `
 display: flex;
 align-items: center; 
 `)])]), be("textarea", [_("placeholder", "white-space: nowrap;")]), _("eye", `
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `), L("textarea", "width: 100%;", [A("input-word-count", `
 position: absolute;
 right: var(--n-padding-right);
 bottom: var(--n-padding-vertical);
 `), L("resizable", [A("input-wrapper", `
 resize: vertical;
 min-height: var(--n-height);
 `)]), _("textarea-el, textarea-mirror, placeholder", `
 height: 100%;
 padding-left: 0;
 padding-right: 0;
 padding-top: var(--n-padding-vertical);
 padding-bottom: var(--n-padding-vertical);
 word-break: break-word;
 display: inline-block;
 vertical-align: bottom;
 box-sizing: border-box;
 line-height: var(--n-line-height-textarea);
 margin: 0;
 resize: none;
 white-space: pre-wrap;
 scroll-padding-block-end: var(--n-padding-vertical);
 `), _("textarea-mirror", `
 width: 100%;
 pointer-events: none;
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre-wrap;
 overflow-wrap: break-word;
 `)]), L("pair", [_("input-el, placeholder", "text-align: center;"), _("separator", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 white-space: nowrap;
 `, [A("icon", `
 color: var(--n-icon-color);
 `), A("base-icon", `
 color: var(--n-icon-color);
 `)])]), L("disabled", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [_("border", "border: var(--n-border-disabled);"), _("input-el, textarea-el", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 text-decoration-color: var(--n-text-color-disabled);
 `), _("placeholder", "color: var(--n-placeholder-color-disabled);"), _("separator", "color: var(--n-text-color-disabled);", [A("icon", `
 color: var(--n-icon-color-disabled);
 `), A("base-icon", `
 color: var(--n-icon-color-disabled);
 `)]), A("input-word-count", `
 color: var(--n-count-text-color-disabled);
 `), _("suffix, prefix", "color: var(--n-text-color-disabled);", [A("icon", `
 color: var(--n-icon-color-disabled);
 `), A("internal-icon", `
 color: var(--n-icon-color-disabled);
 `)])]), be("disabled", [_("eye", `
 color: var(--n-icon-color);
 cursor: pointer;
 `, [D("&:hover", `
 color: var(--n-icon-color-hover);
 `), D("&:active", `
 color: var(--n-icon-color-pressed);
 `)]), D("&:hover", [_("state-border", "border: var(--n-border-hover);")]), L("focus", "background-color: var(--n-color-focus);", [_("state-border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), _("border, state-border", `
 box-sizing: border-box;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border-radius: inherit;
 border: var(--n-border);
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), _("state-border", `
 border-color: #0000;
 z-index: 1;
 `), _("prefix", "margin-right: 4px;"), _("suffix", `
 margin-left: 4px;
 `), _("suffix, prefix", `
 transition: color .3s var(--n-bezier);
 flex-wrap: nowrap;
 flex-shrink: 0;
 line-height: var(--n-height);
 white-space: nowrap;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 color: var(--n-suffix-text-color);
 `, [A("base-loading", `
 font-size: var(--n-icon-size);
 margin: 0 2px;
 color: var(--n-loading-color);
 `), A("base-clear", `
 font-size: var(--n-icon-size);
 `, [_("placeholder", [A("base-icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)])]), D(">", [A("icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)]), A("base-icon", `
 font-size: var(--n-icon-size);
 `)]), A("input-word-count", `
 pointer-events: none;
 line-height: 1.5;
 font-size: .85em;
 color: var(--n-count-text-color);
 transition: color .3s var(--n-bezier);
 margin-left: 4px;
 font-variant: tabular-nums;
 `), ["warning", "error"].map((e) => L(`${e}-status`, [be("disabled", [A("base-loading", `
 color: var(--n-loading-color-${e})
 `), _("input-el, textarea-el", `
 caret-color: var(--n-caret-color-${e});
 `), _("state-border", `
 border: var(--n-border-${e});
 `), D("&:hover", [_("state-border", `
 border: var(--n-border-hover-${e});
 `)]), D("&:focus", `
 background-color: var(--n-color-focus-${e});
 `, [_("state-border", `
 box-shadow: var(--n-box-shadow-focus-${e});
 border: var(--n-border-focus-${e});
 `)]), L("focus", `
 background-color: var(--n-color-focus-${e});
 `, [_("state-border", `
 box-shadow: var(--n-box-shadow-focus-${e});
 border: var(--n-border-focus-${e});
 `)])])]))]), Gn = A("input", [L("disabled", [_("input-el, textarea-el", `
 -webkit-text-fill-color: var(--n-text-color-disabled);
 `)])]);
function Hn(e) {
  let t = 0;
  for (const o of e) t++;
  return t;
}
function Te(e) {
  return e === "" || e == null;
}
function Zn(e) {
  const t = k(null);
  function o() {
    const { value: s } = e;
    if (!(s == null ? void 0 : s.focus)) {
      a();
      return;
    }
    const { selectionStart: p, selectionEnd: f, value: m } = s;
    if (p == null || f == null) {
      a();
      return;
    }
    t.value = { start: p, end: f, beforeText: m.slice(0, p), afterText: m.slice(f) };
  }
  function n() {
    var s;
    const { value: p } = t, { value: f } = e;
    if (!p || !f) return;
    const { value: m } = f, { start: g, beforeText: b, afterText: C } = p;
    let u = m.length;
    if (m.endsWith(C)) u = m.length - C.length;
    else if (m.startsWith(b)) u = b.length;
    else {
      const I = b[g - 1], F = m.indexOf(I, g - 1);
      F !== -1 && (u = F + 1);
    }
    (s = f.setSelectionRange) === null || s === void 0 || s.call(f, u, u);
  }
  function a() {
    t.value = null;
  }
  return x(e, a), { recordCursor: o, restoreCursor: n };
}
const gt = z({ name: "InputWordCount", setup(e, { slots: t }) {
  const { mergedValueRef: o, maxlengthRef: n, mergedClsPrefixRef: a, countGraphemesRef: s } = B(It), p = j(() => {
    const { value: f } = o;
    return f === null || Array.isArray(f) ? 0 : (s.value || Hn)(f);
  });
  return () => {
    const { value: f } = n, { value: m } = o;
    return v("span", { class: `${a.value}-input-word-count` }, Sn(t.default, { value: m === null || Array.isArray(m) ? "" : m }, () => [f === void 0 ? p.value : `${p.value} / ${f}`]));
  };
} }), Kn = Object.assign(Object.assign({}, kt.props), { bordered: { type: Boolean, default: void 0 }, type: { type: String, default: "text" }, placeholder: [Array, String], defaultValue: { type: [String, Array], default: null }, value: [String, Array], disabled: { type: Boolean, default: void 0 }, size: String, rows: { type: [Number, String], default: 3 }, round: Boolean, minlength: [String, Number], maxlength: [String, Number], clearable: Boolean, autosize: { type: [Boolean, Object], default: false }, pair: Boolean, separator: String, readonly: { type: [String, Boolean], default: false }, passivelyActivated: Boolean, showPasswordOn: String, stateful: { type: Boolean, default: true }, autofocus: Boolean, inputProps: Object, resizable: { type: Boolean, default: true }, showCount: Boolean, loading: { type: Boolean, default: void 0 }, allowInput: Function, renderCount: Function, onMousedown: Function, onKeydown: Function, onKeyup: [Function, Array], onInput: [Function, Array], onFocus: [Function, Array], onBlur: [Function, Array], onClick: [Function, Array], onChange: [Function, Array], onClear: [Function, Array], countGraphemes: Function, status: String, "onUpdate:value": [Function, Array], onUpdateValue: [Function, Array], textDecoration: [String, Array], attrSize: { type: Number, default: 20 }, onInputBlur: [Function, Array], onInputFocus: [Function, Array], onDeactivate: [Function, Array], onActivate: [Function, Array], onWrapperFocus: [Function, Array], onWrapperBlur: [Function, Array], internalDeactivateOnEnter: Boolean, internalForceFocus: Boolean, internalLoadingBeforeSuffix: { type: Boolean, default: true }, showPasswordToggle: Boolean }), jr = z({ name: "Input", props: Kn, slots: Object, setup(e) {
  const { mergedClsPrefixRef: t, mergedBorderedRef: o, inlineThemeDisabled: n, mergedRtlRef: a } = kn(e), s = kt("Input", "-input", Un, Bn, e, t);
  En && zn("-input-safari", Gn, t);
  const p = k(null), f = k(null), m = k(null), g = k(null), b = k(null), C = k(null), u = k(null), I = Zn(u), F = k(null), { localeRef: ie } = jn("Input"), se = k(e.defaultValue), De = lt(e, "value"), N = In(De, se), J = Dn(e), { mergedSizeRef: pe, mergedDisabledRef: U, mergedStatusRef: Ne } = J, G = k(false), Y = k(false), d = k(false), l = k(false);
  let c = null;
  const y = j(() => {
    const { placeholder: r, pair: i } = e;
    return i ? Array.isArray(r) ? r : r === void 0 ? ["", ""] : [r, r] : r === void 0 ? [ie.value.placeholder] : [r];
  }), me = j(() => {
    const { value: r } = d, { value: i } = N, { value: h } = y;
    return !r && (Te(i) || Array.isArray(i) && Te(i[0])) && h[0];
  }), Nt = j(() => {
    const { value: r } = d, { value: i } = N, { value: h } = y;
    return !r && h[1] && (Te(i) || Array.isArray(i) && Te(i[1]));
  }), Le = ft(() => e.internalForceFocus || G.value), Lt = ft(() => {
    if (U.value || e.readonly || !e.clearable || !Le.value && !Y.value) return false;
    const { value: r } = N, { value: i } = Le;
    return e.pair ? !!(Array.isArray(r) && (r[0] || r[1])) && (Y.value || i) : !!r && (Y.value || i);
  }), $e = j(() => {
    const { showPasswordOn: r } = e;
    if (r) return r;
    if (e.showPasswordToggle) return "click";
  }), he = k(false), $t = j(() => {
    const { textDecoration: r } = e;
    return r ? Array.isArray(r) ? r.map((i) => ({ textDecoration: i })) : [{ textDecoration: r }] : ["", ""];
  }), nt = k(void 0), Wt = () => {
    var r, i;
    if (e.type === "textarea") {
      const { autosize: h } = e;
      if (h && (nt.value = (i = (r = F.value) === null || r === void 0 ? void 0 : r.$el) === null || i === void 0 ? void 0 : i.offsetWidth), !f.value || typeof h == "boolean") return;
      const { paddingTop: R, paddingBottom: M, lineHeight: S } = window.getComputedStyle(f.value), X = Number(R.slice(0, -2)), Q = Number(M.slice(0, -2)), ee = Number(S.slice(0, -2)), { value: ge } = m;
      if (!ge) return;
      if (h.minRows) {
        const ve = Math.max(h.minRows, 1), Ue = `${X + Q + ee * ve}px`;
        ge.style.minHeight = Ue;
      }
      if (h.maxRows) {
        const ve = `${X + Q + ee * h.maxRows}px`;
        ge.style.maxHeight = ve;
      }
    }
  }, Vt = j(() => {
    const { maxlength: r } = e;
    return r === void 0 ? void 0 : Number(r);
  });
  Rt(() => {
    const { value: r } = N;
    Array.isArray(r) || Ve(r);
  });
  const Ut = et().proxy;
  function Ce(r, i) {
    const { onUpdateValue: h, "onUpdate:value": R, onInput: M } = e, { nTriggerFormInput: S } = J;
    h && E(h, r, i), R && E(R, r, i), M && E(M, r, i), se.value = r, S();
  }
  function Re(r, i) {
    const { onChange: h } = e, { nTriggerFormChange: R } = J;
    h && E(h, r, i), se.value = r, R();
  }
  function Gt(r) {
    const { onBlur: i } = e, { nTriggerFormBlur: h } = J;
    i && E(i, r), h();
  }
  function Ht(r) {
    const { onFocus: i } = e, { nTriggerFormFocus: h } = J;
    i && E(i, r), h();
  }
  function Zt(r) {
    const { onClear: i } = e;
    i && E(i, r);
  }
  function Kt(r) {
    const { onInputBlur: i } = e;
    i && E(i, r);
  }
  function qt(r) {
    const { onInputFocus: i } = e;
    i && E(i, r);
  }
  function Jt() {
    const { onDeactivate: r } = e;
    r && E(r);
  }
  function Yt() {
    const { onActivate: r } = e;
    r && E(r);
  }
  function Xt(r) {
    const { onClick: i } = e;
    i && E(i, r);
  }
  function Qt(r) {
    const { onWrapperFocus: i } = e;
    i && E(i, r);
  }
  function eo(r) {
    const { onWrapperBlur: i } = e;
    i && E(i, r);
  }
  function to() {
    d.value = true;
  }
  function oo(r) {
    d.value = false, r.target === C.value ? ke(r, 1) : ke(r, 0);
  }
  function ke(r, i = 0, h = "input") {
    const R = r.target.value;
    if (Ve(R), r instanceof InputEvent && !r.isComposing && (d.value = false), e.type === "textarea") {
      const { value: S } = F;
      S && S.syncUnifiedContainer();
    }
    if (c = R, d.value) return;
    I.recordCursor();
    const M = no(R);
    if (M) if (!e.pair) h === "input" ? Ce(R, { source: i }) : Re(R, { source: i });
    else {
      let { value: S } = N;
      Array.isArray(S) ? S = [S[0], S[1]] : S = ["", ""], S[i] = R, h === "input" ? Ce(S, { source: i }) : Re(S, { source: i });
    }
    Ut.$forceUpdate(), M || we(I.restoreCursor);
  }
  function no(r) {
    const { countGraphemes: i, maxlength: h, minlength: R } = e;
    if (i) {
      let S;
      if (h !== void 0 && (S === void 0 && (S = i(r)), S > Number(h)) || R !== void 0 && (S === void 0 && (S = i(r)), S < Number(h))) return false;
    }
    const { allowInput: M } = e;
    return typeof M == "function" ? M(r) : true;
  }
  function ro(r) {
    Kt(r), r.relatedTarget === p.value && Jt(), r.relatedTarget !== null && (r.relatedTarget === b.value || r.relatedTarget === C.value || r.relatedTarget === f.value) || (l.value = false), ze(r, "blur"), u.value = null;
  }
  function ao(r, i) {
    qt(r), G.value = true, l.value = true, Yt(), ze(r, "focus"), i === 0 ? u.value = b.value : i === 1 ? u.value = C.value : i === 2 && (u.value = f.value);
  }
  function io(r) {
    e.passivelyActivated && (eo(r), ze(r, "blur"));
  }
  function so(r) {
    e.passivelyActivated && (G.value = true, Qt(r), ze(r, "focus"));
  }
  function ze(r, i) {
    r.relatedTarget !== null && (r.relatedTarget === b.value || r.relatedTarget === C.value || r.relatedTarget === f.value || r.relatedTarget === p.value) || (i === "focus" ? (Ht(r), G.value = true) : i === "blur" && (Gt(r), G.value = false));
  }
  function lo(r, i) {
    ke(r, i, "change");
  }
  function uo(r) {
    Xt(r);
  }
  function co(r) {
    Zt(r), rt();
  }
  function rt() {
    e.pair ? (Ce(["", ""], { source: "clear" }), Re(["", ""], { source: "clear" })) : (Ce("", { source: "clear" }), Re("", { source: "clear" }));
  }
  function fo(r) {
    const { onMousedown: i } = e;
    i && i(r);
    const { tagName: h } = r.target;
    if (h !== "INPUT" && h !== "TEXTAREA") {
      if (e.resizable) {
        const { value: R } = p;
        if (R) {
          const { left: M, top: S, width: X, height: Q } = R.getBoundingClientRect(), ee = 14;
          if (M + X - ee < r.clientX && r.clientX < M + X && S + Q - ee < r.clientY && r.clientY < S + Q) return;
        }
      }
      r.preventDefault(), G.value || at();
    }
  }
  function po() {
    var r;
    Y.value = true, e.type === "textarea" && ((r = F.value) === null || r === void 0 || r.handleMouseEnterWrapper());
  }
  function mo() {
    var r;
    Y.value = false, e.type === "textarea" && ((r = F.value) === null || r === void 0 || r.handleMouseLeaveWrapper());
  }
  function ho() {
    U.value || $e.value === "click" && (he.value = !he.value);
  }
  function go(r) {
    if (U.value) return;
    r.preventDefault();
    const i = (R) => {
      R.preventDefault(), mt("mouseup", document, i);
    };
    if (pt("mouseup", document, i), $e.value !== "mousedown") return;
    he.value = true;
    const h = () => {
      he.value = false, mt("mouseup", document, h);
    };
    pt("mouseup", document, h);
  }
  function vo(r) {
    e.onKeyup && E(e.onKeyup, r);
  }
  function bo(r) {
    switch (e.onKeydown && E(e.onKeydown, r), r.key) {
      case "Escape":
        We();
        break;
      case "Enter":
        yo(r);
        break;
    }
  }
  function yo(r) {
    var i, h;
    if (e.passivelyActivated) {
      const { value: R } = l;
      if (R) {
        e.internalDeactivateOnEnter && We();
        return;
      }
      r.preventDefault(), e.type === "textarea" ? (i = f.value) === null || i === void 0 || i.focus() : (h = b.value) === null || h === void 0 || h.focus();
    }
  }
  function We() {
    e.passivelyActivated && (l.value = false, we(() => {
      var r;
      (r = p.value) === null || r === void 0 || r.focus();
    }));
  }
  function at() {
    var r, i, h;
    U.value || (e.passivelyActivated ? (r = p.value) === null || r === void 0 || r.focus() : ((i = f.value) === null || i === void 0 || i.focus(), (h = b.value) === null || h === void 0 || h.focus()));
  }
  function wo() {
    var r;
    !((r = p.value) === null || r === void 0) && r.contains(document.activeElement) && document.activeElement.blur();
  }
  function _o() {
    var r, i;
    (r = f.value) === null || r === void 0 || r.select(), (i = b.value) === null || i === void 0 || i.select();
  }
  function xo() {
    U.value || (f.value ? f.value.focus() : b.value && b.value.focus());
  }
  function So() {
    const { value: r } = p;
    (r == null ? void 0 : r.contains(document.activeElement)) && r !== document.activeElement && We();
  }
  function Co(r) {
    if (e.type === "textarea") {
      const { value: i } = f;
      i == null ? void 0 : i.scrollTo(r);
    } else {
      const { value: i } = b;
      i == null ? void 0 : i.scrollTo(r);
    }
  }
  function Ve(r) {
    const { type: i, pair: h, autosize: R } = e;
    if (!h && R) if (i === "textarea") {
      const { value: M } = m;
      M && (M.textContent = `${r ?? ""}\r
`);
    } else {
      const { value: M } = g;
      M && (r ? M.textContent = r : M.innerHTML = "&nbsp;");
    }
  }
  function Ro() {
    Wt();
  }
  const it = k({ top: "0" });
  function ko(r) {
    var i;
    const { scrollTop: h } = r.target;
    it.value.top = `${-h}px`, (i = F.value) === null || i === void 0 || i.syncUnifiedContainer();
  }
  let Ie = null;
  ut(() => {
    const { autosize: r, type: i } = e;
    r && i === "textarea" ? Ie = x(N, (h) => {
      !Array.isArray(h) && h !== c && Ve(h);
    }) : Ie == null ? void 0 : Ie();
  });
  let Me = null;
  ut(() => {
    e.type === "textarea" ? Me = x(N, (r) => {
      var i;
      !Array.isArray(r) && r !== c && ((i = F.value) === null || i === void 0 || i.syncUnifiedContainer());
    }) : Me == null ? void 0 : Me();
  }), H(It, { mergedValueRef: N, maxlengthRef: Vt, mergedClsPrefixRef: t, countGraphemesRef: lt(e, "countGraphemes") });
  const zo = { wrapperElRef: p, inputElRef: b, textareaElRef: f, isCompositing: d, clear: rt, focus: at, blur: wo, select: _o, deactivate: So, activate: xo, scrollTo: Co }, Io = Mn("Input", a, t), st = j(() => {
    const { value: r } = pe, { common: { cubicBezierEaseInOut: i }, self: { color: h, borderRadius: R, textColor: M, caretColor: S, caretColorError: X, caretColorWarning: Q, textDecorationColor: ee, border: ge, borderDisabled: ve, borderHover: Ue, borderFocus: Mo, placeholderColor: Ao, placeholderColorDisabled: To, lineHeightTextarea: Bo, colorDisabled: Eo, colorFocus: Fo, textColorDisabled: Po, boxShadowFocus: Oo, iconSize: jo, colorFocusWarning: Do, boxShadowFocusWarning: No, borderWarning: Lo, borderFocusWarning: $o, borderHoverWarning: Wo, colorFocusError: Vo, boxShadowFocusError: Uo, borderError: Go, borderFocusError: Ho, borderHoverError: Zo, clearSize: Ko, clearColor: qo, clearColorHover: Jo, clearColorPressed: Yo, iconColor: Xo, iconColorDisabled: Qo, suffixTextColor: en, countTextColor: tn, countTextColorDisabled: on, iconColorHover: nn, iconColorPressed: rn, loadingColor: an, loadingColorError: sn, loadingColorWarning: ln, fontWeight: un, [He("padding", r)]: cn, [He("fontSize", r)]: dn, [He("height", r)]: fn } } = s.value, { left: pn, right: mn } = An(cn);
    return { "--n-bezier": i, "--n-count-text-color": tn, "--n-count-text-color-disabled": on, "--n-color": h, "--n-font-size": dn, "--n-font-weight": un, "--n-border-radius": R, "--n-height": fn, "--n-padding-left": pn, "--n-padding-right": mn, "--n-text-color": M, "--n-caret-color": S, "--n-text-decoration-color": ee, "--n-border": ge, "--n-border-disabled": ve, "--n-border-hover": Ue, "--n-border-focus": Mo, "--n-placeholder-color": Ao, "--n-placeholder-color-disabled": To, "--n-icon-size": jo, "--n-line-height-textarea": Bo, "--n-color-disabled": Eo, "--n-color-focus": Fo, "--n-text-color-disabled": Po, "--n-box-shadow-focus": Oo, "--n-loading-color": an, "--n-caret-color-warning": Q, "--n-color-focus-warning": Do, "--n-box-shadow-focus-warning": No, "--n-border-warning": Lo, "--n-border-focus-warning": $o, "--n-border-hover-warning": Wo, "--n-loading-color-warning": ln, "--n-caret-color-error": X, "--n-color-focus-error": Vo, "--n-box-shadow-focus-error": Uo, "--n-border-error": Go, "--n-border-focus-error": Ho, "--n-border-hover-error": Zo, "--n-loading-color-error": sn, "--n-clear-color": qo, "--n-clear-size": Ko, "--n-clear-color-hover": Jo, "--n-clear-color-pressed": Yo, "--n-icon-color": Xo, "--n-icon-color-hover": nn, "--n-icon-color-pressed": rn, "--n-icon-color-disabled": Qo, "--n-suffix-text-color": en };
  }), le = n ? Tn("input", j(() => {
    const { value: r } = pe;
    return r[0];
  }), st, e) : void 0;
  return Object.assign(Object.assign({}, zo), { wrapperElRef: p, inputElRef: b, inputMirrorElRef: g, inputEl2Ref: C, textareaElRef: f, textareaMirrorElRef: m, textareaScrollbarInstRef: F, rtlEnabled: Io, uncontrolledValue: se, mergedValue: N, passwordVisible: he, mergedPlaceholder: y, showPlaceholder1: me, showPlaceholder2: Nt, mergedFocus: Le, isComposing: d, activated: l, showClearButton: Lt, mergedSize: pe, mergedDisabled: U, textDecorationStyle: $t, mergedClsPrefix: t, mergedBordered: o, mergedShowPasswordOn: $e, placeholderStyle: it, mergedStatus: Ne, textAreaScrollContainerWidth: nt, handleTextAreaScroll: ko, handleCompositionStart: to, handleCompositionEnd: oo, handleInput: ke, handleInputBlur: ro, handleInputFocus: ao, handleWrapperBlur: io, handleWrapperFocus: so, handleMouseEnter: po, handleMouseLeave: mo, handleMouseDown: fo, handleChange: lo, handleClick: uo, handleClear: co, handlePasswordToggleClick: ho, handlePasswordToggleMousedown: go, handleWrapperKeydown: bo, handleWrapperKeyup: vo, handleTextAreaMirrorResize: Ro, getTextareaScrollContainer: () => f.value, mergedTheme: s, cssVars: n ? void 0 : st, themeClass: le == null ? void 0 : le.themeClass, onRender: le == null ? void 0 : le.onRender });
}, render() {
  var e, t;
  const { mergedClsPrefix: o, mergedStatus: n, themeClass: a, type: s, countGraphemes: p, onRender: f } = this, m = this.$slots;
  return f == null ? void 0 : f(), v("div", { ref: "wrapperElRef", class: [`${o}-input`, a, n && `${o}-input--${n}-status`, { [`${o}-input--rtl`]: this.rtlEnabled, [`${o}-input--disabled`]: this.mergedDisabled, [`${o}-input--textarea`]: s === "textarea", [`${o}-input--resizable`]: this.resizable && !this.autosize, [`${o}-input--autosize`]: this.autosize, [`${o}-input--round`]: this.round && s !== "textarea", [`${o}-input--pair`]: this.pair, [`${o}-input--focus`]: this.mergedFocus, [`${o}-input--stateful`]: this.stateful }], style: this.cssVars, tabindex: !this.mergedDisabled && this.passivelyActivated && !this.activated ? 0 : void 0, onFocus: this.handleWrapperFocus, onBlur: this.handleWrapperBlur, onClick: this.handleClick, onMousedown: this.handleMouseDown, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd, onKeyup: this.handleWrapperKeyup, onKeydown: this.handleWrapperKeydown }, v("div", { class: `${o}-input-wrapper` }, Ae(m.prefix, (g) => g && v("div", { class: `${o}-input__prefix` }, g)), s === "textarea" ? v(Cn, { ref: "textareaScrollbarInstRef", class: `${o}-input__textarea`, container: this.getTextareaScrollContainer, triggerDisplayManually: true, useUnifiedContainer: true, internalHoistYRail: true }, { default: () => {
    var g, b;
    const { textAreaScrollContainerWidth: C } = this, u = { width: this.autosize && C && `${C}px` };
    return v(gn, null, v("textarea", Object.assign({}, this.inputProps, { ref: "textareaElRef", class: [`${o}-input__textarea-el`, (g = this.inputProps) === null || g === void 0 ? void 0 : g.class], autofocus: this.autofocus, rows: Number(this.rows), placeholder: this.placeholder, value: this.mergedValue, disabled: this.mergedDisabled, maxlength: p ? void 0 : this.maxlength, minlength: p ? void 0 : this.minlength, readonly: this.readonly, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, style: [this.textDecorationStyle[0], (b = this.inputProps) === null || b === void 0 ? void 0 : b.style, u], onBlur: this.handleInputBlur, onFocus: (I) => {
      this.handleInputFocus(I, 2);
    }, onInput: this.handleInput, onChange: this.handleChange, onScroll: this.handleTextAreaScroll })), this.showPlaceholder1 ? v("div", { class: `${o}-input__placeholder`, style: [this.placeholderStyle, u], key: "placeholder" }, this.mergedPlaceholder[0]) : null, this.autosize ? v(Rn, { onResize: this.handleTextAreaMirrorResize }, { default: () => v("div", { ref: "textareaMirrorElRef", class: `${o}-input__textarea-mirror`, key: "mirror" }) }) : null);
  } }) : v("div", { class: `${o}-input__input` }, v("input", Object.assign({ type: s === "password" && this.mergedShowPasswordOn && this.passwordVisible ? "text" : s }, this.inputProps, { ref: "inputElRef", class: [`${o}-input__input-el`, (e = this.inputProps) === null || e === void 0 ? void 0 : e.class], style: [this.textDecorationStyle[0], (t = this.inputProps) === null || t === void 0 ? void 0 : t.style], tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, placeholder: this.mergedPlaceholder[0], disabled: this.mergedDisabled, maxlength: p ? void 0 : this.maxlength, minlength: p ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[0] : this.mergedValue, readonly: this.readonly, autofocus: this.autofocus, size: this.attrSize, onBlur: this.handleInputBlur, onFocus: (g) => {
    this.handleInputFocus(g, 0);
  }, onInput: (g) => {
    this.handleInput(g, 0);
  }, onChange: (g) => {
    this.handleChange(g, 0);
  } })), this.showPlaceholder1 ? v("div", { class: `${o}-input__placeholder` }, v("span", null, this.mergedPlaceholder[0])) : null, this.autosize ? v("div", { class: `${o}-input__input-mirror`, key: "mirror", ref: "inputMirrorElRef" }, "\xA0") : null), !this.pair && Ae(m.suffix, (g) => g || this.clearable || this.showCount || this.mergedShowPasswordOn || this.loading !== void 0 ? v("div", { class: `${o}-input__suffix` }, [Ae(m["clear-icon-placeholder"], (b) => (this.clearable || b) && v(ht, { clsPrefix: o, show: this.showClearButton, onClear: this.handleClear }, { placeholder: () => b, icon: () => {
    var C, u;
    return (u = (C = this.$slots)["clear-icon"]) === null || u === void 0 ? void 0 : u.call(C);
  } })), this.internalLoadingBeforeSuffix ? null : g, this.loading !== void 0 ? v(On, { clsPrefix: o, loading: this.loading, showArrow: false, showClear: false, style: this.cssVars }) : null, this.internalLoadingBeforeSuffix ? g : null, this.showCount && this.type !== "textarea" ? v(gt, null, { default: (b) => {
    var C;
    const { renderCount: u } = this;
    return u ? u(b) : (C = m.count) === null || C === void 0 ? void 0 : C.call(m, b);
  } }) : null, this.mergedShowPasswordOn && this.type === "password" ? v("div", { class: `${o}-input__eye`, onMousedown: this.handlePasswordToggleMousedown, onClick: this.handlePasswordToggleClick }, this.passwordVisible ? Ge(m["password-visible-icon"], () => [v(dt, { clsPrefix: o }, { default: () => v(Wn, null) })]) : Ge(m["password-invisible-icon"], () => [v(dt, { clsPrefix: o }, { default: () => v(Vn, null) })])) : null]) : null)), this.pair ? v("span", { class: `${o}-input__separator` }, Ge(m.separator, () => [this.separator])) : null, this.pair ? v("div", { class: `${o}-input-wrapper` }, v("div", { class: `${o}-input__input` }, v("input", { ref: "inputEl2Ref", type: this.type, class: `${o}-input__input-el`, tabindex: this.passivelyActivated && !this.activated ? -1 : void 0, placeholder: this.mergedPlaceholder[1], disabled: this.mergedDisabled, maxlength: p ? void 0 : this.maxlength, minlength: p ? void 0 : this.minlength, value: Array.isArray(this.mergedValue) ? this.mergedValue[1] : void 0, readonly: this.readonly, style: this.textDecorationStyle[1], onBlur: this.handleInputBlur, onFocus: (g) => {
    this.handleInputFocus(g, 1);
  }, onInput: (g) => {
    this.handleInput(g, 1);
  }, onChange: (g) => {
    this.handleChange(g, 1);
  } }), this.showPlaceholder2 ? v("div", { class: `${o}-input__placeholder` }, v("span", null, this.mergedPlaceholder[1])) : null), Ae(m.suffix, (g) => (this.clearable || g) && v("div", { class: `${o}-input__suffix` }, [this.clearable && v(ht, { clsPrefix: o, show: this.showClearButton, onClear: this.handleClear }, { icon: () => {
    var b;
    return (b = m["clear-icon"]) === null || b === void 0 ? void 0 : b.call(m);
  }, placeholder: () => {
    var b;
    return (b = m["clear-icon-placeholder"]) === null || b === void 0 ? void 0 : b.call(m);
  } }), g]))) : null, this.mergedBordered ? v("div", { class: `${o}-input__border` }) : null, this.mergedBordered ? v("div", { class: `${o}-input__state-border` }) : null, this.showCount && s === "textarea" ? v(gt, null, { default: (g) => {
    var b;
    const { renderCount: C } = this;
    return C ? C(g) : (b = m.count) === null || b === void 0 ? void 0 : b.call(m, g);
  } }) : null);
} });
function Dr() {
  const e = B(Fn, null);
  return e === null && zt("use-dialog", "No outer <n-dialog-provider /> founded."), e;
}
function Nr() {
  const e = B(Pn, null);
  return e === null && zt("use-message", "No outer <n-message-provider /> founded. See prerequisite in https://www.naiveui.com/en-US/os-theme/components/message for more details. If you want to use `useMessage` outside setup, please check https://www.naiveui.com/zh-CN/os-theme/components/message#Q-&-A."), e;
}
/*!
* @indoorequal/vue-maplibre-gl v8.4.2
* (c) 2025 Fran√ßois de Metz <francois@2metz.fr>
* @license MIT
*/
const qn = Symbol("map"), de = qn, _e = Symbol("isLoaded"), Jn = Symbol("isInitialized"), Mt = Jn, tt = Symbol("componentId"), ot = Symbol("sourceId"), At = Symbol("sourceLayerRegistry"), Yn = ["error", "load", "idle", "remove", "render", "resize", "webglcontextlost", "webglcontextrestored", "dataloading", "data", "tiledataloading", "sourcedataloading", "styledataloading", "sourcedata", "styledata", "styleimagemissing", "dataabort", "sourcedataabort", "boxzoomcancel", "boxzoomstart", "boxzoomend", "touchcancel", "touchmove", "touchend", "touchstart", "click", "contextmenu", "dblclick", "mousemove", "mouseup", "mousedown", "mouseout", "mouseover", "movestart", "move", "moveend", "zoomstart", "zoom", "zoomend", "rotatestart", "rotate", "rotateend", "dragstart", "drag", "dragend", "pitchstart", "pitch", "pitchend", "wheel", "terrain", "cooperativegestureprevented"];
function Xn(e, t, o, n) {
  return (a) => o.emit(n, { type: a.type, map: t, component: e, event: a });
}
function Qn(e, t) {
  const o = ae.LngLat.convert(e), n = ae.LngLat.convert(t);
  return o.lng === n.lng && o.lat === n.lat;
}
var xe = ((e) => (e.TOP_LEFT = "top-left", e.TOP_RIGHT = "top-right", e.BOTTOM_LEFT = "bottom-left", e.BOTTOM_RIGHT = "bottom-right", e))(xe || {});
const fe = Object.values(xe), vt = /* @__PURE__ */ new Map(), er = Symbol("default");
function tr(e, t, o = er) {
  var _a;
  let n = vt.get(o);
  return n || (n = yn({ isLoaded: false, isMounted: false, language: null }), vt.set(o, n)), n.isLoaded = ((_a = t.value) == null ? void 0 : _a.loaded()) || false, n.isMounted = false, n.component = e, n.map = t.value, n;
}
const Lr = z({ name: "MglMap", props: { width: { type: [Number, String], default: "100%" }, height: { type: [Number, String], default: "100%" }, attributionControl: { type: [Boolean, Object], default: void 0 }, bearing: { type: Number }, bearingSnap: { type: Number }, bounds: { type: [Array, Object] }, boxZoom: { type: Boolean, default: void 0 }, center: { type: [Array, Object] }, clickTolerance: { type: Number }, collectResourceTiming: { type: Boolean, default: void 0 }, crossSourceCollisions: { type: Boolean, default: void 0 }, dragPan: { type: Boolean, default: void 0 }, dragRotate: { type: Boolean, default: void 0 }, doubleClickZoom: { type: Boolean, default: void 0 }, hash: { type: [Boolean, String], default: void 0 }, fadeDuration: { type: Number }, fitBoundsOptions: { type: Object }, interactive: { type: Boolean, default: void 0 }, keyboard: { type: Boolean, default: void 0 }, locale: { type: Object }, localIdeographFontFamily: { type: String }, logoPosition: { type: [String], validator: (e) => e in xe }, maxBounds: { type: [Array, Object] }, maxPitch: { type: Number }, maxZoom: { type: Number }, minPitch: { type: Number }, minZoom: { type: Number }, pitch: { type: Number }, pitchWithRotate: { type: Boolean, default: void 0 }, canvasContextAttributes: { type: Object }, refreshExpiredTiles: { type: Boolean, default: void 0 }, renderWorldCopies: { type: Boolean, default: void 0 }, scrollZoom: { type: Boolean, default: void 0 }, mapStyle: { type: [String, Object] }, trackResize: { type: Boolean, default: void 0 }, transformRequest: { type: Function }, transformCameraUpdate: { type: Function }, touchZoomRotate: { type: Boolean, default: void 0 }, touchPitch: { type: Boolean, default: void 0 }, zoom: { type: Number }, maxTileCacheSize: { type: Number }, mapKey: { type: [String, Symbol] }, pixelRatio: { type: Number }, validateStyle: { type: Boolean, default: void 0 }, cooperativeGestures: { type: Boolean } }, emits: ["map:error", "map:load", "map:idle", "map:remove", "map:render", "map:resize", "map:webglcontextlost", "map:webglcontextrestored", "map:dataloading", "map:data", "map:tiledataloading", "map:sourcedataloading", "map:styledataloading", "map:sourcedata", "map:styledata", "map:styleimagemissing", "map:dataabort", "map:sourcedataabort", "map:boxzoomcancel", "map:boxzoomstart", "map:boxzoomend", "map:touchcancel", "map:touchmove", "map:touchend", "map:touchstart", "map:click", "map:contextmenu", "map:dblclick", "map:mousemove", "map:mouseup", "map:mousedown", "map:mouseout", "map:mouseover", "map:movestart", "map:move", "map:moveend", "map:zoomstart", "map:zoom", "map:zoomend", "map:rotatestart", "map:rotate", "map:rotateend", "map:dragstart", "map:drag", "map:dragend", "map:pitchstart", "map:pitch", "map:pitchend", "map:wheel", "map:terrain", "map:cooperativegestureprevented", "map:projectiontransition", "update:center", "update:zoom", "update:pitch", "update:bearing"], slots: Object, setup(e, t) {
  const o = ct(et()), n = Ye(), a = Ye(), s = k(false), p = k(false), f = /* @__PURE__ */ new Map(), m = tr(o, a, e.mapKey);
  H(de, a), H(_e, p), H(Mt, s), H(tt, o.uid), H(ot, ""), x(() => e.bearing, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setBearing(u));
  }), x(() => e.bounds, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.fitBounds(u, e.fitBoundsOptions));
  }), x(() => e.center, (u) => {
    var _a, _b;
    const I = (_a = a.value) == null ? void 0 : _a.getCenter();
    u && I && !Qn(u, I) && ((_b = a.value) == null ? void 0 : _b.setCenter(u));
  }), x(() => e.maxBounds, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setMaxBounds(u));
  }), x(() => e.maxPitch, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setMaxPitch(u));
  }), x(() => e.maxZoom, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setMaxZoom(u));
  }), x(() => e.minPitch, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setMinPitch(u));
  }), x(() => e.minZoom, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setMinZoom(u));
  }), x(() => e.pitch, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setPitch(u));
  }), x(() => e.renderWorldCopies, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setRenderWorldCopies(u));
  }), x(() => e.mapStyle, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setStyle(u));
  }), x(() => e.transformRequest, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setTransformRequest(u));
  }), x(() => e.zoom, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setZoom(u));
  }), x(() => e.zoom, (u) => {
    var _a;
    u && ((_a = a.value) == null ? void 0 : _a.setZoom(u));
  });
  function g() {
    m.isMounted = true;
    const u = { ...e, style: e.mapStyle, container: n.value };
    for (const I of Object.keys(u)) u[I] === void 0 && delete u[I];
    if (a.value = ct(new ae.Map(u)), m.map = a.value, s.value = true, f.set("__load", () => (p.value = true, m.isLoaded = true)), a.value.on("load", f.get("__load")), f.set("__moveend", () => t.emit("update:center", a.value.getCenter())), a.value.on("moveend", f.get("__moveend")), f.set("__zoomend", () => t.emit("update:zoom", a.value.getZoom())), a.value.on("zoomend", f.get("__zoomend")), f.set("__pitchend", () => t.emit("update:pitch", a.value.getPitch())), a.value.on("pitchend", f.get("__pitchend")), f.set("__rotateend", () => t.emit("update:bearing", a.value.getBearing())), a.value.on("rotateend", f.get("__rotateend")), o.vnode.props) {
      for (const I of Yn) if (o.vnode.props["onMap:" + I]) {
        const F = `map:${I}`, ie = Xn(o, a.value, t, F);
        f.set(I, ie), a.value.on(I, ie);
      }
    }
    a.value.getCanvas().addEventListener("webglcontextlost", C);
  }
  async function b() {
    m.isMounted = false, m.isLoaded = false, p.value = false, a.value && (a.value.getCanvas().removeEventListener("webglcontextlost", C), s.value = false, f.forEach((u, I) => {
      a.value.off(I.startsWith("__") ? I.substring(2) : I, u);
    }), a.value.remove());
  }
  function C() {
    b(), we(g);
  }
  return Rt(g), ce(b), t.expose({ map: a }), () => [v("div", { ref: n, style: { height: e.height, width: e.width } }), s.value && t.slots.default ? t.slots.default({}) : void 0];
}, render() {
  return null;
} });
function or(e, t, o) {
  x(e, (n) => {
    var _a, _b;
    n && fe.indexOf(n) === -1 || (((_a = t.value) == null ? void 0 : _a.hasControl(o)) && t.value.removeControl(o), (_b = t.value) == null ? void 0 : _b.addControl(o, n));
  }, { immediate: true });
}
function Se(e, t) {
  const o = B(de), n = B(Mt), a = Ye();
  return a.value = e(), or(() => t.position, o, a.value), ce(() => {
    var _a;
    return n.value && ((_a = o.value) == null ? void 0 : _a.removeControl(a.value));
  }), { control: a, map: o };
}
class nr {
  constructor(t, o) {
    __publicField(this, "container");
    this.isAdded = t, this.container = document.createElement("div"), this.setClasses(o);
  }
  getDefaultPosition() {
    return xe.TOP_LEFT;
  }
  onAdd() {
    return we(() => this.isAdded.value = true), this.container;
  }
  onRemove() {
    this.isAdded.value = false, this.container.remove();
  }
  setClasses(t) {
    this.container.className = t;
  }
}
const $r = z({ name: "MglCustomControl", props: { position: { type: String, validator: (e) => fe.indexOf(e) !== -1 }, class: { type: String, default: "maplibregl-ctrl maplibregl-ctrl-group" } }, slots: Object, setup(e, { slots: t }) {
  const o = k(false), { control: n } = Se(() => new nr(o, e.class), e);
  return x(() => e.class, () => n.value.setClasses(e.class)), () => {
    var _a;
    return o.value ? v(vn, { to: n.value.container }, (_a = t.default) == null ? void 0 : _a.call(t, {})) : je("custom-component");
  };
}, render() {
  return null;
} }), Wr = z({ name: "MglFullscreenControl", props: { position: { type: String, validator: (e) => fe.indexOf(e) !== -1 }, container: { type: Object, default: null } }, setup(e) {
  const { control: t, map: o } = Se(() => new ae.FullscreenControl({ container: e.container || void 0 }), e);
  function n() {
    we(() => {
      var _a;
      return (_a = o.value) == null ? void 0 : _a.resize();
    });
  }
  t.value.on("fullscreenstart", n), t.value.on("fullscreenend", n), ce(() => {
    t.value.off("fullscreenstart", n), t.value.off("fullscreenend", n);
  });
}, render() {
  return null;
} }), Vr = z({ name: "MglGeolocateControl", props: { position: { type: String, default: xe.TOP_RIGHT, validator: (e) => fe.indexOf(e) !== -1 }, positionOptions: { type: Object, default: () => ({ enableHighAccuracy: false, timeout: 6e3 }) }, fitBoundsOptions: { type: Object, default: () => ({ maxZoom: 15 }) }, trackUserLocation: { type: Boolean, default: false }, showAccuracyCircle: { type: Boolean, default: true }, showUserLocation: { type: Boolean, default: true } }, emits: ["trackuserlocationstart", "trackuserlocationend", "userlocationlostfocus", "userlocationfocus", "geolocate", "error", "outofmaxbounds"], setup(e, t) {
  const { control: o } = Se(() => new ae.GeolocateControl({ positionOptions: e.positionOptions, fitBoundsOptions: e.fitBoundsOptions, trackUserLocation: e.trackUserLocation, showAccuracyCircle: e.showAccuracyCircle, showUserLocation: e.showUserLocation }), e);
  function n(a) {
    const s = (p) => {
      t.emit(a, p);
    };
    o.value.on(a, s), ce(() => {
      o.value.off(a, s);
    });
  }
  n("trackuserlocationstart"), n("trackuserlocationend"), n("userlocationlostfocus"), n("userlocationfocus"), n("geolocate"), n("error"), n("outofmaxbounds");
}, render() {
  return null;
} }), Ur = z({ name: "MglNavigationControl", props: { position: { type: String, validator: (e) => fe.indexOf(e) !== -1 }, showCompass: { type: Boolean, default: true }, showZoom: { type: Boolean, default: true }, visualizePitch: Boolean }, setup(e) {
  Se(() => new ae.NavigationControl({ showCompass: e.showCompass, showZoom: e.showZoom, visualizePitch: e.visualizePitch }), e);
}, render() {
  return null;
} });
var Tt = ((e) => (e.IMPERIAL = "imperial", e.METRIC = "metric", e.NAUTICAL = "nautical", e))(Tt || {});
const rr = Object.values(Tt), Gr = z({ name: "MglScaleControl", props: { position: { type: String, validator: (e) => fe.indexOf(e) !== -1 }, maxWidth: { type: Number, default: 100 }, unit: { type: String, default: "metric", validator: (e) => rr.indexOf(e) !== -1 } }, setup(e) {
  Se(() => new ae.ScaleControl({ maxWidth: e.maxWidth, unit: e.unit }), e);
}, render() {
  return null;
} });
class ar {
  constructor() {
    __publicField(this, "unmountHandlers", /* @__PURE__ */ new Map());
  }
  registerUnmountHandler(t, o) {
    this.unmountHandlers.set(t, o);
  }
  unregisterUnmountHandler(t) {
    this.unmountHandlers.delete(t);
  }
  unmount() {
    this.unmountHandlers.forEach((t) => t());
  }
}
const _ue = class _ue {
  static genSourceOpts(t) {
    const o = { ...t };
    for (const n of Object.keys(o)) (o[n] === void 0 || n === "sourceId") && delete o[n];
    return o;
  }
  static getSourceRef(t, o) {
    const n = typeof o == "string", a = String(t) + (n ? o : "");
    let s = _ue.REFS.get(a);
    return s || (s = k(n ? null : void 0), _ue.REFS.set(a, s)), s;
  }
};
__publicField(_ue, "REFS", /* @__PURE__ */ new Map());
let ue = _ue;
function ir(e, t, o) {
  const n = B(de), a = B(_e);
  function s() {
    a.value && (n.value.addSource(t.sourceId, ue.genSourceOpts(t)), e.value = n.value.getSource(t.sourceId));
  }
  return x(a, s, { immediate: true }), n.value.on("style.load", s), ce(() => {
    a.value && (o.unmount(), n.value.removeSource(t.sourceId)), n.value.off("style.load", s);
  });
}
const Hr = z({ name: "MglGeoJsonSource", props: { sourceId: { type: String, required: true }, data: { type: [Object, String], required: true }, maxzoom: Number, attribution: String, buffer: Number, tolerance: Number, cluster: Boolean, clusterRadius: Number, clusterMaxZoom: Number, clusterMinPoints: Number, clusterProperties: Object, lineMetrics: Boolean, generateId: Boolean, promoteId: [Object, String], filter: [Array, String, Object] }, slots: Object, setup(e, { slots: t }) {
  const o = B(tt), n = ue.getSourceRef(o, e.sourceId), a = new ar(), s = { ...e, type: "geojson" };
  return H(ot, e.sourceId), H(At, a), ir(n, s, a), x([bn(e.data) ? e.data : () => e.data, n], ([p, f]) => {
    f == null ? void 0 : f.setData(p || { type: "FeatureCollection", features: [] });
  }, { immediate: true }), () => [je("GeoJSON Source"), n.value && t.default ? t.default({}) : void 0];
} }), W = ["click", "dblclick", "mousedown", "mouseup", "mousemove", "mouseenter", "mouseleave", "mouseover", "mouseout", "contextmenu", "touchstart", "touchend", "touchcancel"];
function K() {
  return { layerId: { type: String, required: true }, source: { type: String }, metadata: { type: [Object, Array, String, Number] }, sourceLayer: { type: String }, minzoom: { type: Number }, maxzoom: { type: Number }, filter: { type: Object }, before: { type: String }, layout: { type: Object }, paint: { type: Object } };
}
function sr(e, t, o, n) {
  const a = { id: e, type: t, source: o.source || n, metadata: o.metadata, minzoom: o.minzoom, maxzoom: o.maxzoom, "source-layer": o.sourceLayer, filter: o.filter, paint: o.paint, layout: o.layout };
  for (const s of Object.keys(a)) a[s] === void 0 && delete a[s];
  return a;
}
function lr(e, t, o) {
  if (o.props) for (const n of W) {
    const a = "on" + n.charAt(0).toUpperCase() + n.substr(1);
    o.props[a] && e.on(n, t, o.props[a]);
  }
}
function ur(e, t, o) {
  if (o.props) for (const n of W) {
    const a = "on" + n.charAt(0).toUpperCase() + n.substr(1);
    o.props[a] && e.off(n, t, o.props[a]);
  }
}
function Bt(e, t) {
  const o = B(de), n = B(_e), a = B(At);
  function s() {
    n.value && (t && ur(o.value, e, t.vnode), o.value.getLayer(e) && o.value.removeLayer(e));
  }
  a.registerUnmountHandler(e, s), ce(() => {
    a.unregisterUnmountHandler(e), s();
  });
}
z({ name: "MglBackgroundLayer", props: { layerId: { type: String, required: true }, metadata: [Object, Array, String, Number], minzoom: Number, maxzoom: Number, before: String, layout: Object, paint: Object }, emits: [...W], setup(e) {
  const t = B(de), o = B(_e);
  return Bt(e.layerId), x(() => e.layout, (n) => {
    if (n) for (const [a, s] of Object.entries(n)) t.value.setLayoutProperty(e.layerId, a, s);
  }), x(() => e.paint, (n) => {
    if (n) for (const [a, s] of Object.entries(n)) t.value.setPaintProperty(e.layerId, a, s);
  }), x(o, (n) => {
    n && t.value.addLayer({ id: e.layerId, type: "background", metadata: e.metadata, minzoom: e.minzoom, maxzoom: e.maxzoom, layout: e.layout, paint: e.paint }, e.before || void 0);
  }, { immediate: true }), () => je("Background Layer");
} });
function q(e, t) {
  const o = B(ot);
  if (!o && !t.source) return;
  const n = et(), a = B(de), s = B(_e), p = B(tt), f = ue.getSourceRef(p, t.source || o);
  return Bt(t.layerId, n), x(() => t.minzoom, () => a.value.setLayerZoomRange(t.layerId, t.minzoom || 0, t.maxzoom || 24)), x(() => t.maxzoom, () => a.value.setLayerZoomRange(t.layerId, t.minzoom || 0, t.maxzoom || 24)), x(() => t.layout, (m) => {
    if (m) for (const [g, b] of Object.entries(m)) a.value.setLayoutProperty(t.layerId, g, b);
  }, { deep: true }), x(() => t.paint, (m) => {
    if (m) for (const [g, b] of Object.entries(m)) a.value.setPaintProperty(t.layerId, g, b);
  }, { deep: true }), x(() => t.filter, (m) => a.value.setFilter(t.layerId, m), { deep: true }), x([s, f], ([m, g]) => {
    m && (g || g === void 0) && (a.value.addLayer(sr(t.layerId, e, t, o), t.before || void 0), lr(a.value, t.layerId, n.vnode));
  }, { immediate: true }), () => je(`${e} Layer`);
}
z({ name: "MglCircleLayer", props: K(), emits: [...W], setup(e) {
  return q("circle", e);
} });
z({ name: "MglFillLayer", props: K(), emits: [...W], setup(e) {
  return q("fill", e);
} });
z({ name: "MglFillExtrusionLayer", props: K(), emits: [...W], setup(e) {
  return q("fill-extrusion", e);
} });
z({ name: "MglHeatmapLayer", props: K(), emits: [...W], setup(e) {
  return q("heatmap", e);
} });
z({ name: "MglHillshadeLayer", props: K(), emits: [...W], setup(e) {
  return q("hillshade", e);
} });
const Zr = z({ name: "MglLineLayer", props: K(), emits: [...W], setup(e) {
  return q("line", e);
} });
z({ name: "MglRasterLayer", props: K(), emits: [...W], setup(e) {
  return q("raster", e);
} });
z({ name: "MglSymbolLayer", props: K(), emits: [...W], setup(e) {
  return q("symbol", e);
} });
const T = [];
for (let e = 0; e < 256; ++e) T.push((e + 256).toString(16).slice(1));
function cr(e, t = 0) {
  return (T[e[t + 0]] + T[e[t + 1]] + T[e[t + 2]] + T[e[t + 3]] + "-" + T[e[t + 4]] + T[e[t + 5]] + "-" + T[e[t + 6]] + T[e[t + 7]] + "-" + T[e[t + 8]] + T[e[t + 9]] + "-" + T[e[t + 10]] + T[e[t + 11]] + T[e[t + 12]] + T[e[t + 13]] + T[e[t + 14]] + T[e[t + 15]]).toLowerCase();
}
let Ze;
const dr = new Uint8Array(16);
function fr() {
  if (!Ze) {
    if (typeof crypto > "u" || !crypto.getRandomValues) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Ze = crypto.getRandomValues.bind(crypto);
  }
  return Ze(dr);
}
const pr = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), bt = { randomUUID: pr };
function re(e, t, o) {
  var _a;
  if (bt.randomUUID && !e) return bt.randomUUID();
  e = e || {};
  const n = e.random ?? ((_a = e.rng) == null ? void 0 : _a.call(e)) ?? fr();
  if (n.length < 16) throw new Error("Random bytes length must be >= 16");
  return n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, cr(n);
}
function $() {
  return { name: "Untitled", description: "A new geographic item", creation_timestamp: Date.now(), modification_timestamp: Date.now(), created_by: "anonymous", modified_by: "anonymous", tags: [] };
}
function mr() {
  return { ...$(), version: 1, signature: void 0 };
}
class oe {
  constructor(t = re(), o, n, a) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "routes");
    __publicField(this, "drafts");
    this.id = t, this.routes = o || { id: re(), meta: $(), routes: [] }, this.drafts = n || { id: re(), meta: $(), drafts: [] }, this.meta = { ...mr(), ...a };
  }
  toStorage() {
    return { id: this.id, meta: this.meta, routes: this.routes, drafts: this.drafts };
  }
  static fromStorage(t) {
    return new oe(t.id, t.routes, t.drafts, t.meta);
  }
  clone() {
    return oe.fromStorage(this.toStorage());
  }
  updateName(t) {
    this.meta.name = t, this.meta.modification_timestamp = Date.now();
  }
  updateDescription(t) {
    this.meta.description = t, this.meta.modification_timestamp = Date.now();
  }
  addTag(t) {
    this.meta.tags.includes(t) || (this.meta.tags.push(t), this.meta.modification_timestamp = Date.now());
  }
  removeTag(t) {
    const o = this.meta.tags.indexOf(t);
    o > -1 && (this.meta.tags.splice(o, 1), this.meta.modification_timestamp = Date.now());
  }
}
class Et {
  constructor(t = [], o = re(), n = $()) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "routesInternal");
    this.id = o, this.meta = n || $(), this.routesInternal = t;
  }
  get name() {
    return this.meta || (this.meta = $()), this.meta.name;
  }
  set name(t) {
    this.meta || (this.meta = $()), this.meta.name = t;
  }
  get routes() {
    return V(this.routesInternal);
  }
  set routes(t) {
    this.routesInternal = V(t);
  }
  findRoute(t) {
    return this.routesInternal.find((o) => o.id === t);
  }
  existRoute(t) {
    return this.routesInternal.some((o) => o.id === t);
  }
  addRoute(t) {
    if (this.existRoute(t.id)) throw new Error(`[CartoSketch.Route] Route ${t.id} already exist`);
    this.routesInternal.push(V(t)), this.updateModificationTime();
  }
  updateRoute(t) {
    const o = this.routesInternal.findIndex((n) => n.id === t.id);
    if (o === -1) throw new Error(`[CartoSketch.Route] Route ${t.id} not found`);
    this.routesInternal[o] = V(t), this.updateModificationTime();
  }
  removeRoute(t) {
    const o = this.routesInternal.findIndex((n) => n.id === t);
    o !== -1 && (this.routesInternal.splice(o, 1), this.updateModificationTime());
  }
  updateModificationTime() {
    this.meta.modification_timestamp = Date.now();
  }
  exportAsGeoJSON() {
    return { type: "FeatureCollection", features: this.routesInternal.map((t) => t.exportAsGeoJSON()), properties: this.meta };
  }
  exportToStorage() {
    return Object.freeze({ id: this.id, meta: this.meta, routes: this.routesInternal.map((t) => t.exportToStorage()) });
  }
}
class Be {
  constructor(t = re(), o = [], n = {}, a) {
    __publicField(this, "id");
    __publicField(this, "meta");
    __publicField(this, "properties");
    __publicField(this, "points");
    this.id = t, this.meta = { ...$(), record_timespan: 0, ...a }, this.properties = n, this.points = o;
  }
  get name() {
    return this.meta || (this.meta = $()), this.meta.name;
  }
  set name(t) {
    this.meta || (this.meta = $()), this.meta.name = t;
  }
  get distance() {
    return this.meta.distance || 0;
  }
  set distance(t) {
    this.meta.distance = t;
  }
  get recordTimespan() {
    return this.meta.record_timespan || 0;
  }
  set recordTimespan(t) {
    this.meta.record_timespan = t;
  }
  setPoints(t) {
    this.points = V(t), this.updateModificationTime();
  }
  appendPoint(t) {
    this.points.push(V(t)), this.updateModificationTime();
  }
  getPoints() {
    return V(this.points);
  }
  setProperties(t) {
    const o = V(t);
    Object.assign(this.properties, o), this.updateModificationTime();
  }
  updateModificationTime() {
    this.meta.modification_timestamp = Date.now();
  }
  exportAsGeoJSON() {
    return { type: "Feature", properties: { ...this.properties, ...this.meta, description: JSON.stringify({ name: this.meta.name, id: this.id }) }, geometry: { type: "LineString", coordinates: this.points.map((t) => [t.longitude, t.latitude]) } };
  }
  exportToStorage() {
    return V({ id: this.id, meta: this.meta, properties: this.properties, points: this.points });
  }
}
function hr(e) {
  if (!e) throw new Error("[importItemFromStorage] Invalid data provided");
  const t = new Be(e.id || re(), e.points || [], e.properties || {}, e.meta);
  return e.meta && (t.meta = e.meta), t;
}
function gr(e) {
  if (!e) throw new Error("[readCollectionFromStorage] Invalid data provided");
  const t = (e.routes || []).map((n) => hr(n)), o = new Et(t, e.id || re(), e.meta);
  return e.meta && (o.meta = e.meta), o;
}
let w;
const Ft = typeof TextDecoder < "u" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
typeof TextDecoder < "u" && Ft.decode();
let ye = null;
function Ee() {
  return (ye === null || ye.byteLength === 0) && (ye = new Uint8Array(w.memory.buffer)), ye;
}
function ne(e, t) {
  return e = e >>> 0, Ft.decode(Ee().subarray(e, e + t));
}
let Pe = 0;
const Fe = typeof TextEncoder < "u" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} }, vr = typeof Fe.encodeInto == "function" ? function(e, t) {
  return Fe.encodeInto(e, t);
} : function(e, t) {
  const o = Fe.encode(e);
  return t.set(o), { read: e.length, written: o.length };
};
function Pt(e, t, o) {
  if (o === void 0) {
    const f = Fe.encode(e), m = t(f.length, 1) >>> 0;
    return Ee().subarray(m, m + f.length).set(f), Pe = f.length, m;
  }
  let n = e.length, a = t(n, 1) >>> 0;
  const s = Ee();
  let p = 0;
  for (; p < n; p++) {
    const f = e.charCodeAt(p);
    if (f > 127) break;
    s[a + p] = f;
  }
  if (p !== n) {
    p !== 0 && (e = e.slice(p)), a = o(a, n, n = p + e.length * 3, 1) >>> 0;
    const f = Ee().subarray(a + p, a + n), m = vr(e, f);
    p += m.written, a = o(a, n, p, 1) >>> 0;
  }
  return Pe = p, a;
}
function br(e) {
  return e == null;
}
let te = null;
function yt() {
  return (te === null || te.buffer.detached === true || te.buffer.detached === void 0 && te.buffer !== w.memory.buffer) && (te = new DataView(w.memory.buffer)), te;
}
function Ot(e) {
  const t = w.__wbindgen_export_0.get(e);
  return w.__externref_table_dealloc(e), t;
}
function Ke(e, t) {
  if (!(e instanceof t)) throw new Error(`expected instance of ${t.name}`);
}
function yr(e, t, o) {
  Ke(e, Oe), Ke(t, Oe), Ke(o, jt);
  const n = w.transform(e.__wbg_ptr, t.__wbg_ptr, o.__wbg_ptr);
  if (n[1]) throw Ot(n[0]);
}
const wt = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((e) => w.__wbg_point_free(e >>> 0, 1));
class jt {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, wt.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    w.__wbg_point_free(t, 0);
  }
  get x() {
    return w.__wbg_get_point_x(this.__wbg_ptr);
  }
  set x(t) {
    w.__wbg_set_point_x(this.__wbg_ptr, t);
  }
  get y() {
    return w.__wbg_get_point_y(this.__wbg_ptr);
  }
  set y(t) {
    w.__wbg_set_point_y(this.__wbg_ptr, t);
  }
  get z() {
    return w.__wbg_get_point_z(this.__wbg_ptr);
  }
  set z(t) {
    w.__wbg_set_point_z(this.__wbg_ptr, t);
  }
  constructor(t, o, n) {
    const a = w.point_new(t, o, n);
    return this.__wbg_ptr = a >>> 0, wt.register(this, this.__wbg_ptr, this), this;
  }
}
const _t = typeof FinalizationRegistry > "u" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((e) => w.__wbg_projection_free(e >>> 0, 1));
class Oe {
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, _t.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    w.__wbg_projection_free(t, 0);
  }
  constructor(t) {
    const o = Pt(t, w.__wbindgen_malloc, w.__wbindgen_realloc), n = Pe, a = w.projection_new(o, n);
    if (a[2]) throw Ot(a[1]);
    return this.__wbg_ptr = a[0] >>> 0, _t.register(this, this.__wbg_ptr, this), this;
  }
  get projName() {
    let t, o;
    try {
      const n = w.projection_projName(this.__wbg_ptr);
      return t = n[0], o = n[1], ne(n[0], n[1]);
    } finally {
      w.__wbindgen_free(t, o, 1);
    }
  }
  get isLatlon() {
    return w.projection_isLatlon(this.__wbg_ptr) !== 0;
  }
  get isGeocentric() {
    return w.projection_isGeocentric(this.__wbg_ptr) !== 0;
  }
  get axis() {
    let t, o;
    try {
      const n = w.projection_axis(this.__wbg_ptr);
      return t = n[0], o = n[1], ne(n[0], n[1]);
    } finally {
      w.__wbindgen_free(t, o, 1);
    }
  }
  get isNormalizedAxis() {
    return w.projection_isNormalizedAxis(this.__wbg_ptr) !== 0;
  }
  get to_meter() {
    return w.projection_to_meter(this.__wbg_ptr);
  }
  get units() {
    let t, o;
    try {
      const n = w.projection_units(this.__wbg_ptr);
      return t = n[0], o = n[1], ne(n[0], n[1]);
    } finally {
      w.__wbindgen_free(t, o, 1);
    }
  }
}
async function wr(e, t) {
  if (typeof Response == "function" && e instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming == "function") try {
      return await WebAssembly.instantiateStreaming(e, t);
    } catch (n) {
      if (e.headers.get("Content-Type") != "application/wasm") console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", n);
      else throw n;
    }
    const o = await e.arrayBuffer();
    return await WebAssembly.instantiate(o, t);
  } else {
    const o = await WebAssembly.instantiate(e, t);
    return o instanceof WebAssembly.Instance ? { instance: o, module: e } : o;
  }
}
function _r() {
  const e = {};
  return e.wbg = {}, e.wbg.__wbg_buffer_e6c6daaa78528d53 = function(t) {
    return t.buffer;
  }, e.wbg.__wbg_getFloat32_e0872364daa466bb = function(t, o, n) {
    return t.getFloat32(o >>> 0, n !== 0);
  }, e.wbg.__wbg_getFloat64_3c55a5d18420aa12 = function(t, o, n) {
    return t.getFloat64(o >>> 0, n !== 0);
  }, e.wbg.__wbg_getInt32_6ea30555a7e6366d = function(t, o, n) {
    return t.getInt32(o >>> 0, n !== 0);
  }, e.wbg.__wbg_getUint32_78580012d2915dec = function(t, o, n) {
    return t.getUint32(o >>> 0, n !== 0);
  }, e.wbg.__wbg_parseFloat_40655e71a57d91e0 = function(t, o) {
    return parseFloat(ne(t, o));
  }, e.wbg.__wbg_parseInt_7deceafc75400ae4 = function(t, o, n) {
    return parseInt(ne(t, o), n);
  }, e.wbg.__wbg_slice_ab0b7e3d75dccdee = function(t, o, n) {
    return t.slice(o >>> 0, n >>> 0);
  }, e.wbg.__wbindgen_error_new = function(t, o) {
    return new Error(ne(t, o));
  }, e.wbg.__wbindgen_init_externref_table = function() {
    const t = w.__wbindgen_export_0, o = t.grow(4);
    t.set(0, void 0), t.set(o + 0, void 0), t.set(o + 1, null), t.set(o + 2, true), t.set(o + 3, false);
  }, e.wbg.__wbindgen_string_get = function(t, o) {
    const n = o, a = typeof n == "string" ? n : void 0;
    var s = br(a) ? 0 : Pt(a, w.__wbindgen_malloc, w.__wbindgen_realloc), p = Pe;
    yt().setInt32(t + 4, p, true), yt().setInt32(t + 0, s, true);
  }, e.wbg.__wbindgen_throw = function(t, o) {
    throw new Error(ne(t, o));
  }, e;
}
function xr(e, t) {
  return w = e.exports, Dt.__wbindgen_wasm_module = t, te = null, ye = null, w.__wbindgen_start(), w;
}
async function Dt(e) {
  if (w !== void 0) return w;
  typeof e < "u" && (Object.getPrototypeOf(e) === Object.prototype ? { module_or_path: e } = e : console.warn("using deprecated parameters for the initialization function; pass a single object instead")), typeof e > "u" && (e = new URL("" + new URL("proj4rs_bg-Biz-E4lt.wasm", import.meta.url).href, import.meta.url));
  const t = _r();
  (typeof e == "string" || typeof Request == "function" && e instanceof Request || typeof URL == "function" && e instanceof URL) && (e = fetch(e));
  const { instance: o, module: n } = await wr(await e, t);
  return xr(o, n);
}
const qe = { WGS84: "+proj=longlat +datum=WGS84 +no_defs", GRS80: "+proj=latlong +ellps=GRS80 +no_defs", UTM_ZONE_50N: "+proj=utm +zone=50 +datum=WGS84 +units=m +no_defs", UTM_ZONE_51N: "+proj=utm +zone=51 +datum=WGS84 +units=m +no_defs", CGCS2000_3_DEGREE: "+proj=tmerc +lat_0=0 +lon_0=117 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs", BEIJING_1954: "+proj=tmerc +lat_0=0 +lon_0=117 +k=1 +x_0=500000 +y_0=0 +ellps=krass +units=m +no_defs", WEB_MERCATOR: "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs" };
let xt = false;
async function Sr() {
  xt || (await Dt({ module_or_path: "./public/proj4rs_bg.wasm" }), xt = true);
}
async function St(e, t, o) {
  try {
    await Sr();
    const n = new Oe(e), a = new Oe(t), s = new jt(o[0], o[1], 0);
    yr(n, a, s);
    const p = [s.x, s.y];
    return n.free(), a.free(), s.free(), p;
  } catch (n) {
    throw new Error(`Failed to transform coordinate: ${n instanceof Error ? n.message : String(n)}`);
  }
}
function Cr(e, t) {
  const o = t.x - e.x, n = t.y - e.y;
  return Math.sqrt(o * o + n * n);
}
function Ct(e, t) {
  const n = e.latitude * Math.PI / 180, a = t.latitude * Math.PI / 180, s = (t.latitude - e.latitude) * Math.PI / 180, p = (t.longitude - e.longitude) * Math.PI / 180, f = Math.sin(s / 2) * Math.sin(s / 2) + Math.cos(n) * Math.cos(a) * Math.sin(p / 2) * Math.sin(p / 2);
  return 6371e3 * (2 * Math.atan2(Math.sqrt(f), Math.sqrt(1 - f)));
}
async function Rr(e, t, o = {}) {
  const { projection: n = qe.CGCS2000_3_DEGREE, useHaversine: a = false } = o;
  if (a) return Ct(e, t);
  try {
    const s = await St(qe.WGS84, n, [e.longitude, e.latitude]), p = await St(qe.WGS84, n, [t.longitude, t.latitude]);
    return Cr({ x: s[0], y: s[1] }, { x: p[0], y: p[1] });
  } catch (s) {
    return console.warn("Failed to use proj4 distance calculation, falling back to haversine:", s), Ct(e, t);
  }
}
async function Je(e, t = {}) {
  if (e.length < 2) return 0;
  let o = 0;
  for (let n = 1; n < e.length; n++) o += await Rr(e[n - 1], e[n], t);
  return o;
}
function Kr(e) {
  return e < 1e3 ? `${Math.round(e)} m` : e < 1e4 ? `${(e / 1e3).toFixed(1)} km` : `${Math.round(e / 1e3)} km`;
}
const qr = wn("sketches", () => {
  const e = k([]), t = k(null), o = k(null), n = j(() => {
    if (!t.value) return null;
    const d = e.value.find((l) => l.id === t.value);
    return d ? new Et(d.routes.routes.map((l) => new Be(l.id, l.points, l.properties, l.meta)), d.routes.id, d.routes.meta) : null;
  }), a = j(() => n.value ? n.value.routes.map((d) => ({ id: d.id, name: d.name, points: d.getPoints(), meta: d.meta })) : []), s = j(() => t.value && e.value.find((d) => d.id === t.value) || null), p = j(() => s.value ? s.value.drafts.drafts : []);
  async function f() {
    const d = await _n("sketches");
    d ? d && typeof d == "object" && "routes" in d && !("sketches" in d) ? (console.info("[SketchStore] Migrating old route data to new sketch format"), await m(d)) : Array.isArray(d) ? (e.value = d.map((l) => oe.fromStorage(l)), e.value.forEach((l) => {
      l.routes.routes.forEach(async (c) => {
        if (c.points.length > 1 && !c.meta.distance) try {
          c.meta.distance = await Je(c.points);
        } catch (y) {
          console.warn("Failed to calculate route distance:", y), c.meta.distance = 0;
        }
      });
    }), !t.value && e.value.length > 0 && (t.value = e.value[0].id)) : await g() : await g();
  }
  async function m(d) {
    try {
      const l = gr(d), c = new oe();
      c.meta.name = l.meta.name || "Migrated Routes", c.routes = l.exportToStorage(), e.value = [c], t.value = c.id, await P("sketches", e.value.map((y) => y.toStorage())), await O(), console.info("[SketchStore] Route migration to sketch format complete");
    } catch (l) {
      console.error("[SketchStore] Failed to migrate route data:", l), await g();
    }
  }
  async function g() {
    const d = new oe();
    d.meta.name = "Default Sketch", e.value = [d], t.value = d.id, await P("sketches", e.value.map((l) => l.toStorage())), await O();
  }
  async function b(d = "New Sketch") {
    const l = new oe();
    return l.meta.name = d, e.value.push(l), await P("sketches", e.value.map((c) => c.toStorage())), await O(), l;
  }
  async function C(d, l) {
    const c = e.value.find((y) => y.id === d);
    c && (l.name !== void 0 && c.updateName(l.name), l.description !== void 0 && c.updateDescription(l.description), l.tags !== void 0 && (c.meta.tags.forEach((y) => c.removeTag(y)), l.tags.forEach((y) => c.addTag(y))), await P("sketches", e.value.map((y) => y.toStorage())), await O());
  }
  async function u(d) {
    const l = e.value.findIndex((c) => c.id === d);
    l !== -1 && (e.value.splice(l, 1), t.value === d && (t.value = e.value.length > 0 ? e.value[0].id : null), await P("sketches", e.value.map((c) => c.toStorage())), await O());
  }
  function I(d) {
    t.value = d, o.value = null;
  }
  async function F(d, l = {}, c = {}) {
    s.value || await g();
    const y = new Be(void 0, [], l, c);
    return y.meta.name = d, s.value && s.value.routes.routes.push(y.exportToStorage()), await P("sketches", e.value.map((me) => me.toStorage())), await O(), y;
  }
  async function ie(d) {
    if (!s.value) return;
    const l = s.value.routes.routes.findIndex((c) => c.id === d);
    l !== -1 && (s.value.routes.routes.splice(l, 1), o.value === d && (o.value = null), await P("sketches", e.value.map((c) => c.toStorage())), await O());
  }
  async function se(d, l) {
    if (!s.value) return;
    const c = s.value.routes.routes.find((y) => y.id === d);
    if (c) {
      if (c.points.push(l), c.meta.modification_timestamp = Date.now(), c.points.length > 1) try {
        if (c.meta.distance) {
          const y = await Je([c.points[c.points.length - 2], l]);
          c.meta.distance += y;
        } else {
          const y = await Je(c.points);
          c.meta.distance = y;
        }
      } catch (y) {
        console.warn("Failed to calculate route distance:", y), c.meta.distance || (c.meta.distance = 0);
      }
      await P("sketches", e.value.map((y) => y.toStorage())), await O();
    }
  }
  async function De(d, l) {
    if (!s.value) return;
    const c = s.value.routes.routes.find((y) => y.id === d);
    c && (l.meta !== void 0 && (c.meta = { ...c.meta, ...l.meta }), l.properties !== void 0 && (c.properties = { ...c.properties, ...l.properties }), c.meta.modification_timestamp = Date.now(), await P("sketches", e.value.map((y) => y.toStorage())), await O());
  }
  async function N(d) {
    if (!s.value) return;
    const l = s.value.routes.routes.find((c) => c.id === d);
    l && (l.points = [], l.meta.modification_timestamp = Date.now(), await P("sketches", e.value.map((c) => c.toStorage())), await O());
  }
  function J(d) {
    if (!s.value) return null;
    const l = s.value.routes.routes.find((c) => c.id === d);
    return l ? new Be(l.id, l.points, l.properties, l.meta) : null;
  }
  function pe(d) {
    o.value = d;
  }
  async function U(d, l = {}, c = {}) {
    s.value || await g();
    const y = { id: crypto.randomUUID(), meta: { ...$(), ...c }, shape: d, properties: l };
    return s.value && s.value.drafts.drafts.push(y), await P("sketches", e.value.map((me) => me.toStorage())), await O(), y;
  }
  async function Ne(d, l) {
    if (!s.value) return;
    const c = s.value.drafts.drafts.find((y) => y.id === d);
    c && (l.shape !== void 0 && (c.shape = l.shape), l.properties !== void 0 && (c.properties = { ...c.properties, ...l.properties }), l.meta !== void 0 && (c.meta = { ...c.meta, ...l.meta }, c.meta.modification_timestamp = Date.now()), await P("sketches", e.value.map((y) => y.toStorage())), await O());
  }
  async function G(d) {
    if (!s.value) return;
    const l = s.value.drafts.drafts.findIndex((c) => c.id === d);
    l !== -1 && (s.value.drafts.drafts.splice(l, 1), await P("sketches", e.value.map((c) => c.toStorage())), await O());
  }
  function Y(d) {
    return s.value && s.value.drafts.drafts.find((l) => l.id === d) || null;
  }
  return { sketches: e, currentSketchId: t, currentRouteId: o, routeCollection: n, routes: a, currentSketch: s, currentDrafts: p, init: f, createSketch: b, updateSketch: C, deleteSketch: u, setCurrentSketchId: I, addRoute: F, deleteRoute: ie, addPointToRoute: se, updateRoute: De, clearRoutePoints: N, getRouteById: J, setCurrentRouteId: pe, addDraft: U, updateDraft: Ne, deleteDraft: G, getDraftById: Y };
});
export {
  Or as A,
  Gr as C,
  Wn as E,
  Ur as L,
  Wr as M,
  jr as N,
  Er as R,
  $r as S,
  Fr as T,
  Pr as U,
  Zr as V,
  Hr as _,
  Nr as a,
  Dr as b,
  Kr as f,
  Vr as h,
  qr as u,
  Lr as y
};
